{"text": "UCLA Extension Course: Software Design Principles and Guidelines\nDouglas C. Schmidt\nDepartment of Electrical Engineering and Computer Science\nVanderbilt University\nd.schmidt@vanderbilt.edu\nhttp://www.cs.wustl.edu/ schmidt/\nUCLA Extension Course\nOO Programming with C++\nDesign Principles and Guidelines Overview\n\u000f Design Principles\n\u2013 Important design concepts\n\u2013 Useful design principles\n\u000f Development Methodologies\n\u2013 Traditional approaches\n\u2013 Extreme programming\n\u000f Design Guidelines\n\u2013 Motivation\n\u2013 Common Design Mistakes\n\u2013 Design Rules\nCopyright c\n\r1997-2003\nVanderbilt University\n1\nUCLA Extension Course\nOO Programming with C++\nMotivation: Goals of the Design Phase\n\u000f Decompose System into Modules\n\u2013 i.e., identify the software architecture\n\u2013 Modules are abstractions that should:\n\u0003 be independent,\n\u0003 have well-speci\ufb01ed interfaces, and\n\u0003 have high cohesion and low coupling. \u000f Determine Relations Between Modules\n\u2013 Identify module dependencies\n\u2013 Determine the form of intermodule communication, e.g.,\n\u0003 global variables\n\u0003 parameterized function calls\n\u0003 shared memory\n\u0003 RPC or message passing\nCopyright c\n\r1997-2003\nVanderbilt University\n2\nUCLA Extension Course\nOO Programming with C++\nMotivation: Goals of the Design Phase (cont\u2019d)\n\u000f Specify Module Interfaces\n\u2013 Interfaces should be well-de\ufb01ned\n\u0003 facilitate independent module testing\n\u0003 improve group communication\n\u000f Describe Module Functionality\n\u2013 Informally\n\u0003 e.g., comments or documentation\n\u2013 Formally\n\u0003 e.g., via module interface speci\ufb01cation languages\nCopyright c\n\r1997-2003\nVanderbilt University\n3", "domains": ["Code Organization"], "source": "SD princple and guidance slide.pdf", "section": "Page 1", "position": 1, "chunk_type": "semantic", "token_estimate": 214}
{"text": "UCLA Extension Course: OO Programming with C++\nPrimary Design Phases\n\u000f Preliminary Design\n\u2013 External design describes the real-world model\n\u2013 Architectural design decomposes the requirement speci\ufb01cation\ninto software subsystems\n\u000f Detailed Design\n\u2013 Formally specify each subsystem\n\u2013 Further decomposed subsystems, if necessary\n\u000f Note: in design phases the orientation moves\n\u2013 from customer to developer\n\u2013 from what to how\nCopyright c\n\r1997-2003\nVanderbilt University\n4\nUCLA Extension Course\nOO Programming with C++\nKey Design Concepts and Principles\n\u000f Important design concepts and design principles include:\n\u2013 Decomposition\n\u2013 Abstraction\n\u2013 Information Hiding\n\u2013 Modularity\n\u2013 Hierarchy\n\u2013 Separating Policy and Mechanism\n\u000f Main purpose of these concepts and principles is to manage software\nsystem complexity and improve software quality factors. Copyright c\n\r1997-2003\nVanderbilt University\n5\nUCLA Extension Course\nOO Programming with C++\nDecomposition\n\u000f Decomposition is a concept common to all life-cycle and design\ntechniques. \u000f Basic concept is very simple:\n1. Select a piece of the problem (initially, the whole problem)\n2. Determine its components using the mechanism of choice, e.g.,\nfunctional vs data structured vs object-oriented\n3. Show how the components interact\n4. Repeat steps 1 through 3 until some termination criteria is met\n(e.g., customer is satis\ufb01ed, run out of money, etc. ;-))\nCopyright c\n\r1997-2003\nVanderbilt University\n6\nUCLA Extension Course\nOO Programming with C++\nDecomposition (cont\u2019d)\n\u000f Some guiding decomposition principles\n\u2013 Because design decisions transcend execution time, modules\nmight not correspond to execution steps . . . \u2013 Decompose so as to limit the effect of any one design decision on\nthe rest of the system\n\u2013 Remember, anything that permeates the system will be expensive\nto change\n\u2013 Modules should be speci\ufb01ed by all information needed to use the\nmodule and nothing more\nCopyright c\n\r1997-2003\nVanderbilt University\n7", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SD princple and guidance slide.pdf", "section": "Page 2", "position": 2, "chunk_type": "semantic", "token_estimate": 300}
{"text": "UCLA Extension Course: OO Programming with C++\nAbstraction\n\u000f Abstraction provides a way to manage complexity by emphasizing\nessential characteristics and suppressing implementation details. \u000f Allows postponement of certain design decisions that occur at\nvarious levels of analysis, e.g.,\n\u2013 Representational/Algorithmic considerations\n\u2013 Architectural/Structural considerations\n\u2013 External/Functional considerations\nCopyright c\n\r1997-2003\nVanderbilt University\n8\nUCLA Extension Course\nOO Programming with C++\nAbstraction (cont\u2019d)\n\u000f Three basic abstraction mechanisms\n\u2013 Procedural abstraction\n\u0003 e.g., closed subroutines\n\u2013 Data abstraction\n\u0003 e.g., ADTs\n\u2013 Control abstraction\n\u0003 iterators, loops, multitasking, etc. Copyright c\n\r1997-2003\nVanderbilt University\n9\nUCLA Extension Course\nOO Programming with C++\nInformation Hiding\n\u000f Motivation: details of design decisions that are subject to change\nshould be hidden behind abstract interfaces, i.e., modules. \u2013 Information hiding is one means to enhance abstraction. \u000f Modules should communicate only through well-de\ufb01ned interfaces. \u000f Each module is speci\ufb01ed by as little information as possible. \u000f If internal details change, client modules should be minimally affected\n(may require recompilation and relinking, however . . .) Copyright c\n\r1997-2003\nVanderbilt University\n10\nUCLA Extension Course\nOO Programming with C++\nInformation Hiding (cont\u2019d)\n\u000f Information to be hidden includes:\n\u2013 Data representations\n\u0003 i.e., using abstract data types\n\u2013 Algorithms e.g., sorting or searching techniques\n\u2013 Input and Output Formats\n\u0003 Machine dependencies, e.g., byte-ordering, character codes\n\u2013 Policy/mechanism distinctions\n\u0003 i.e., when vs how\n\u0003 e.g., OS scheduling, garbage collection, process migration\n\u2013 Lower-level module interfaces\n\u0003 e.g., Ordering of low-level operations, i.e., process sequence\nCopyright c\n\r1997-2003\nVanderbilt University\n11", "domains": ["Design Patterns", "Code Organization"], "source": "SD princple and guidance slide.pdf", "section": "Page 3", "position": 3, "chunk_type": "semantic", "token_estimate": 256}
{"text": "UCLA Extension Course: OO Programming with C++\nModularity\n\u000f A Modular System is a system structured into highly independent\nabstractions called modules. \u000f Modularity is important for both design and implementation phases. \u000f Module prescriptions:\n\u2013 Modules should possess well-speci\ufb01ed abstract interfaces. \u2013 Modules should have high cohesion and low coupling. Copyright c\n\r1997-2003\nVanderbilt University\n12\nUCLA Extension Course\nOO Programming with C++\nModularity (cont\u2019d)\n\u000f Modularity facilitates certain software quality factors, e.g. :\n\u2013 Extensibility - well-de\ufb01ned, abstract interfaces\n\u2013 Reusability - low-coupling, high-cohesion\n\u2013 Compatibility - design \u201cbridging\u201d interfaces\n\u2013 Portability - hide machine dependencies\n\u000f Modularity is an important characteristic of good designs because it:\n\u2013 allows for separation of concerns\n\u2013 enables developers to reduce overall system complexity via\ndecentralized software architectures\n\u2013 enhances scalability by supporting independent and concurrent\ndevelopment by multiple personnel\nCopyright c\n\r1997-2003\nVanderbilt University\n13\nUCLA Extension Course\nOO Programming with C++\nModularity (cont\u2019d)\n\u000f A module is\n\u2013 A\nsoftware\nentity\nencapsulating\nthe\nrepresentation\nof\nan\nabstraction, e.g., an ADT\n\u2013 A vehicle for hiding at least one design decision\n\u2013 A \u201cwork\u201d assignment for a programmer or group of programmers\n\u2013 a unit of code that\n\u0003 has one or more names\n\u0003 has identi\ufb01able boundaries\n\u0003 can be (re-)used by other modules\n\u0003 encapsulates data\n\u0003 hides unnecessary details\n\u0003 can be separately compiled (if supported)\nCopyright c\n\r1997-2003\nVanderbilt University\n14\nUCLA Extension Course\nOO Programming with C++\nModularity (cont\u2019d)\n\u000f A module interface consists of several sections:\n\u2013 Imports\n\u0003 Services requested from other modules\n\u2013 Exports\n\u0003 Services provided to other modules\n\u2013 Access Control\n\u0003 not all clients are equal! (e.g., C++\u2019s distinction between\nprotected/private/public)\n\u2013 Heuristics for determining interface speci\ufb01cation\n\u0003 de\ufb01ne one speci\ufb01cation that allows multiple implementations\n\u0003 anticipate change\n\u0003 e.g., use structures and classes for parameters\nCopyright c\n\r1997-2003\nVanderbilt University\n15", "domains": ["Design Principles", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SD princple and guidance slide.pdf", "section": "Page 4", "position": 4, "chunk_type": "semantic", "token_estimate": 313}
{"text": "UCLA Extension Course: OO Programming with C++\nModularity Dimensions\n\u000f Modularity has several dimensions and encompasses speci\ufb01cation,\ndesign, and implementation levels:\n\u2013 Criteria for evaluating design methods with respect to modularity\n\u0003 Modular Decomposability\n\u0003 Modular Composability\n\u0003 Modular Understandability\n\u0003 Modular Continuity\n\u0003 Modular Protection\n\u2013 Principles for ensuring modular designs:\n\u0003 Language Support for Modular Units\n\u0003 Few Interfaces\n\u0003 Small Interfaces (Weak Coupling)\n\u0003 Explicit Interfaces\n\u0003 Information Hiding\nCopyright c\n\r1997-2003\nVanderbilt University\n16\nUCLA Extension Course\nOO Programming with C++\nPrinciples for Ensuring Modular Designs\n\u000f Language Support for Modular Units\n\u2013 Modules must correspond to syntactic units in the language used. \u000f Few Interfaces\n\u2013 Every module should communicate with as few others as possible. \u000f Small Interfaces (Weak Coupling)\n\u2013 If any two modules communicate at all, they should exchange as\nlittle information as possible. Copyright c\n\r1997-2003\nVanderbilt University\n17\nUCLA Extension Course\nOO Programming with C++\nPrinciples for Ensuring Modular Designs (cont\u2019d)\n\u000f Explicit Interfaces\n\u2013 Whenever two modules A and B communicate, this must be\nobvious from the text of A or B or both. \u000f Information Hiding\n\u2013 All information about a module should be private to the module\nunless it is speci\ufb01cally declared public. Copyright c\n\r1997-2003\nVanderbilt University\n18\nUCLA Extension Course\nOO Programming with C++\nThe Open/Closed Principle\n\u000f A satisfactory module decomposition technique should yield modules\nthat are both open and closed:\n\u2013 Open Module: is one still available for extension. This is necessary\nbecause the requirements and speci\ufb01cations are rarely completely\nunderstood from the system\u2019s inception. \u2013 Closed Module: is available for use by other modules, usually\ngiven a well-de\ufb01ned, stable description and packaged in a library. This is necessary because otherwise code sharing becomes\nunmanageable because reopening a module may trigger changes\nin many clients. Copyright c\n\r1997-2003\nVanderbilt University\n19", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SD princple and guidance slide.pdf", "section": "Page 5", "position": 5, "chunk_type": "semantic", "token_estimate": 308}
{"text": "UCLA Extension Course: OO Programming with C++\nThe Open/Closed Principle (cont\u2019d)\n\u000f Traditional design techniques and programming languages do not\noffer an elegant solution to the problem of producing modules that\nare both open and closed. \u000f Object-oriented methods utilize inheritance and dynamic binding to\nsolve this problem. Copyright c\n\r1997-2003\nVanderbilt University\n20\nUCLA Extension Course\nOO Programming with C++\nHierarchy\n\u000f Motivation: reduces module interactions by restricting the topology of\nrelationships\n\u000f A relation de\ufb01nes a hierarchy if it partitions units into levels (note\nconnection to virtual machines)\n\u2013 Level 0 is the set of all units that use no other units\n\u2013 Level\ni is the set of all units that use at least one unit at level\n<\ni\nand no unit at level\n\u0015\ni. \u000f Hierarchical structure forms basis of design\n\u2013 Facilitates independent development\n\u2013 Isolates rami\ufb01cations of change\n\u2013 Allows rapid prototyping\nCopyright c\n\r1997-2003\nVanderbilt University\n21\nUCLA Extension Course\nOO Programming with C++\nHierarchy (cont\u2019d)\n\u000f Relations that de\ufb01ne hierarchies:\n\u2013 Uses\n\u2013 Is-Composed-Of\n\u2013 Is-A\n\u2013 Has-A\n\u000f The \ufb01rst two are general to all design methods, the latter two are\nmore particular to object-oriented design and programming. Copyright c\n\r1997-2003\nVanderbilt University\n22\nUCLA Extension Course\nOO Programming with C++\nThe Uses Relation\n\u000f X Uses Y if the correct functioning of X depends on the availability of\na correct implementation of Y\n\u000f Note, uses is not necessarily the same as invokes:\n\u2013 Some invocations are not uses\n\u0003 e.g., error logging\n\u2013 Some uses don\u2019t involve invocations\n\u0003 e.g., message passing, interrupts, shared memory access\n\u000f A uses relation does not necessarily yield a hierarchy (avoid cycles . . .) Copyright c\n\r1997-2003\nVanderbilt University\n23", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SD princple and guidance slide.pdf", "section": "Page 6", "position": 6, "chunk_type": "semantic", "token_estimate": 290}
{"text": "UCLA Extension Course: OO Programming with C++\nThe Is-Composed-Of Relation\n\u000f The is-composed-of relationship shows how the system is broken\ndown in components. \u000f X is-composed-of\nfx\ni\ng if X is a group of units\nx\ni that share some\ncommon purpose\n\u000f The system structure graph description can be speci\ufb01ed by the is-\ncomposed-of relation such that:\n\u2013 non-terminals are \u201cvirtual\u201d code\n\u2013 terminals are the only units represented by \u201cactual\u201d (concrete)\ncode\nCopyright c\n\r1997-2003\nVanderbilt University\n24\nUCLA Extension Course\nOO Programming with C++\nThe Is-Composed-Of Relation, (cont\u2019d)\n\u000f Many programming languages support the is-composed-of relation\nvia some higher-level module or record structuring technique. \u000f Note: the following are not equivalent:\n1. level (virtual machine)\n2. module (an entity that hides a secret)\n3. a subprogram (a code unit)\n\u000f Modules and levels need not be identical, as a module may have\nseveral components on several levels of a uses hierarchy. Copyright c\n\r1997-2003\nVanderbilt University\n25\nUCLA Extension Course\nOO Programming with C++\nThe Is-A and Has-A Relations\n\u000f These two relationships are associated with object-oriented design\nand programming languages that possess inheritance and classes. \u000f Is-A or Descendant relationship\n\u2013 class X possesses Is-A relationship with class Y if instances of\nclass X are specialization of class Y. \u2013 e.g., a square is a specialization of a rectangle, which is a\nspecialization of a shape . . . \u000f Has-A or Containment relationship\n\u2013 class X possesses a Has-B relationship with class Y if instances\nof class X contain one or more instance(s) of class Y. \u2013 e.g., a car has an engine and four tires . . . Copyright c\n\r1997-2003\nVanderbilt University\n26\nUCLA Extension Course\nOO Programming with C++\nSeparating Policy and Mechanism\n\u000f Very important design principle, used to separate concerns at both\nthe design and implementation phases. \u000f Multiple policies can be implemented by shared mechanisms. \u2013 e.g., OS scheduling and virtual memory paging\n\u000f Same policy can be implemented by multiple mechanisms. \u2013 e.g., FIFO containment can be implemented using a stack based\non an array, or a linked list, or . . . \u2013 e.g., reliable, non-duplicated, bytestream service can be provided\nby multiple communication protocols. Copyright c\n\r1997-2003\nVanderbilt University\n27", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SD princple and guidance slide.pdf", "section": "Page 7", "position": 7, "chunk_type": "semantic", "token_estimate": 375}
{"text": "UCLA Extension Course: OO Programming with C++\nProgram Families and Subsets\n\u000f Program families are a collection of related modules or subsystems\nthat form a framework\n\u2013 e.g., BSD UNIX network protocol subsystem. \u2013 Note, a framework is a set of abstract and concrete classes. \u000f Program families are natural way to detect and implement subsets. \u2013 Reasons for providing subsets include cost, time, personnel\nresources, etc. \u2013 Identifying subsets:\n\u0003 Analyze requirements to identify minimally useful subsets. \u0003 Also identify minimal increments to subsets. Copyright c\n\r1997-2003\nVanderbilt University\n28\nUCLA Extension Course\nOO Programming with C++\nA General Design Process\n\u000f Given a requirements speci\ufb01cation, design involves an iterative\ndecision making process with the following general steps:\n\u2013 List the dif\ufb01cult decisions and decisions likely to change\n\u2013 Design a module speci\ufb01cation to hide each such decision\n\u0003 Make decisions that apply to whole program family \ufb01rst\n\u0003 Modularize most likely changes \ufb01rst\n\u0003 Then modularize remaining dif\ufb01cult decisions and decisions\nlikely to change\n\u0003 Design the uses hierarchy as you do this (include reuse\ndecisions)\nCopyright c\n\r1997-2003\nVanderbilt University\n29\nUCLA Extension Course\nOO Programming with C++\nA General Design Process (cont\u2019d)\n\u000f General steps (cont\u2019d)\n\u2013 Treat each higher-level module as a speci\ufb01cation and apply above\nprocess to each\n\u2013 Continue re\ufb01ning until all design decisions are:\n\u0003 hidden in a module\n\u0003 contain easily comprehensible components\n\u0003 provide\nindividual,\nindependent,\nlow-level\nimplementation\nassignments\nCopyright c\n\r1997-2003\nVanderbilt University\n30\nUCLA Extension Course\nOO Programming with C++\nTraditional Development Methodologies\n\u000f Waterfall Model\n\u2013 Specify, analyze, implement, test (in sequence)\n\u2013 Assumes that requirements can be speci\ufb01ed up front\n\u000f Spiral Model\n\u2013 Supports iterative development\n\u2013 Attempts to assess risks of changes\n\u000f Rapid Application Development\n\u2013 Build a prototype\n\u2013 Ship it :-)\nCopyright c\n\r1997-2003\nVanderbilt University\n31", "domains": ["Design Patterns", "Code Organization"], "source": "SD princple and guidance slide.pdf", "section": "Page 8", "position": 8, "chunk_type": "semantic", "token_estimate": 306}
{"text": "UCLA Extension Course: OO Programming with C++\neXtreme Programming\n\u000f Stresses customer satisfaction, and therefore, involvement\n\u2013 Provide what the customer wants, as quickly as possible\n\u2013 Provide only what the customer wants\n\u000f Encourages changes in requirements\n\u000f Relies on testing\n\u000f XP Practices\n\u2013 Planning, designing, coding, testing\nCopyright c\n\r1997-2003\nVanderbilt University\n32\nUCLA Extension Course\nOO Programming with C++\neXtreme Programming: Planning\nTechnology\nSpike\nSystem\nPrototype\nUser\nStory\nPlanning\nGame\nIteration\nCommitment\nSchedule\nChange in Requirements, Risk,\nor Developement Environment\nRisk Estimates\nTime\nRequirements\nbased on http://www.extremeprogramming.org/rules/planninggame.html\n\u000f Start with user stories\n\u2013 Written by customers, to\nspecify system\nrequirements\n\u2013 Minimal detail, typically\njust a few sentences on a\ncard\n\u2013 Expected development\ntime: 1 to 3 weeks each,\nroughly\n\u000f Planning game creates\ncommitment schedule for\nentire project\n\u000f Each iteration should take\n2-3 weeks\nCopyright c\n\r1997-2003\nVanderbilt University\n33\nUCLA Extension Course\nOO Programming with C++\neXtreme Programming: Designing\n\u000f Defer design decisions as long as possible\n\u000f Advantages:\n\u2013 Simpli\ufb01es current task (just build what is needed)\n\u2013 You don\u2019t need to maintain what you haven\u2019t built\n\u2013 Time is on your side: you\u2019re likely to learn something useful by the\ntime you need to decide\n\u2013 Tomorrow may never come: if a feature isn\u2019t needed now, it might\nnever be needed\n\u000f Disadvantages:\n\u2013 Future\ndesign\ndecisions\nmay\nrequire\nrework\nof\nexisting\nimplementation\n\u2013 Ramp-up time will probably be longer later\n\u0003 Therefore, always try to keep designs as simple as possible\nCopyright c\n\r1997-2003\nVanderbilt University\n34\nUCLA Extension Course\nOO Programming with C++\neXtreme Programming: Coding\n\u000f Pair programming\n\u2013 Always code with a partner\n\u2013 Always test as you code\n\u000f Pair programming pays off by supporting good implementation,\nreducing mistakes, and exposing more than one programmer to the\ndesign/implementation\n\u000f If any de\ufb01ciencies in existing implementation are noticed, either \ufb01x\nthem or note that they need to be \ufb01xed. Copyright c\n\r1997-2003\nVanderbilt University\n35", "domains": ["Design Patterns"], "source": "SD princple and guidance slide.pdf", "section": "Page 9", "position": 9, "chunk_type": "semantic", "token_estimate": 329}
{"text": "UCLA Extension Course: OO Programming with C++\nRules of Design (cont\u2019d)\n\u000f Work at multiple levels of abstraction\n\u2013 Good designers must be able to move between various levels of\nabstraction quickly and easily. \u000f Design for extensibility\n\u2013 A good design is \u201copen-ended,\u201d i.e., easily extendible. \u2013 A good design solves a class of problems rather than a single\ninstance. \u2013 Do not introduce what is immaterial. \u2013 Do not restrict what is irrelevant. \u000f Use rapid prototyping when applicable\n\u2013 Before implementing a design, build a high-level prototype and\nverify that the design criteria are met. Copyright c\n\r1997-2003\nVanderbilt University\n40\nUCLA Extension Course\nOO Programming with C++\nRules of Design (cont\u2019d)\n\u000f Details should depend upon abstractions\n\u2013 Abstractions should not depend upon details\n\u2013 Principle of Dependency Inversion\n\u000f The granule of reuse is the same as the granule of release\n\u2013 Only components that are released through a tracking system can\nbe effectively reused\n\u000f Classes within a released component should share common closure\n\u2013 That is, if one needs to be changed, they all are likely to need to\nbe changed\n\u2013 i.e., what affects one, affects all\nCopyright c\n\r1997-2003\nVanderbilt University\n41\nUCLA Extension Course\nOO Programming with C++\nRules of Design (cont\u2019d)\n\u000f Classes within a released component should be reused together\n\u2013 That is, it is impossible to separate the components from each\nother in order to reuse less than the total\n\u000f The dependency structure for released components must be a DAG\n\u2013 There can be no cycles\n\u000f Dependencies between released components must run in the\ndirection of stability\n\u2013 The dependee must be more stable than the depender\n\u000f The more stable a released component is, the more it must consist\nof abstract classes\n\u2013 A completely stable component should consist of nothing but\nabstract classes\nCopyright c\n\r1997-2003\nVanderbilt University\n42\nUCLA Extension Course\nOO Programming with C++\nRules of Design (cont\u2019d)\n\u000f Where possible, use proven patterns to solve design problems\n\u000f When crossing between two different paradigms, build an interface\nlayer that separates the two\n\u2013 Don\u2019t pollute one side with the paradigm of the other\nCopyright c\n\r1997-2003\nVanderbilt University\n43", "domains": ["Design Patterns", "Design Principles", "Software Quality Attributes", "Code Organization"], "source": "SD princple and guidance slide.pdf", "section": "Page 11", "position": 11, "chunk_type": "semantic", "token_estimate": 369}
{"text": "UCLA Extension Course: OO Programming with C++\nRules of Design (cont\u2019d)\n\u000f Software entities (classes,\nmodules,\netc) should be open for\nextension, but closed for modi\ufb01cation\n\u2013 The Open/Closed principle \u2013 Bertrand Meyer\n\u000f Derived classes must usable through the base class interface without\nthe need for the user to know the difference\n\u2013 The Liskov Substitution Principle\nCopyright c\n\r1997-2003\nVanderbilt University\n44\nUCLA Extension Course\nOO Programming with C++\nRules of Design (cont\u2019d)\n\u000f Make it work correctly, then make it work fast\n\u2013 Implement the design, measure its performance, and if necessary,\noptimize it. \u000f Maintain consistency between representations\n\u2013 e.g., check that the \ufb01nal optimized implementation is equivalent to\nthe high-level design that was veri\ufb01ed. \u2013 Also important for documentation . . . \u000f Don\u2019t skip the preceding rules! \u2013 Clearly, this is the most frequently violated rule!!! ;-)\nCopyright c\n\r1997-2003\nVanderbilt University\n45", "domains": ["Design Principles", "Software Quality Attributes", "Code Organization"], "source": "SD princple and guidance slide.pdf", "section": "Page 12", "position": 12, "chunk_type": "semantic", "token_estimate": 149}
