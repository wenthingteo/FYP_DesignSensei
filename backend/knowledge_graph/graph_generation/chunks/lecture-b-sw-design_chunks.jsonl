{"text": "Chapter 1: Introduction to Software Design: 2\nOutline\n\u2022 The software challenge and the software life cycle\n\u2022 Activities of each phase of the software life cycle\n\u2022 Using top-down design and object-oriented design\n\u2022 Managing complexity:\n\u2022 Data abstraction\n\u2022 Procedural abstraction\n\u2022 Information hiding\n\u2022 Class diagrams document interactions between classes", "domains": ["Code Organization"], "source": "lecture-b-sw-design.pdf", "section": "Page 2", "position": 2, "chunk_type": "semantic", "token_estimate": 53}
{"text": "Chapter 1: Introduction to Software Design: 4\nThe Software Challenge\n\u2022 Software is ...\n\u2022 Used for a long time\n\u2022 Updated and maintained\n\u2022 By people who did not write it\n\u2022 Initial specification may be incomplete\n\u2022 Specification clarified through extensive interaction \nbetween user(s) and system analyst(s)\n\u2022 Requirements specification needed at the beginning of \nany software project\n\u2022 Designers and users should both approve it!", "domains": ["Domain-Driven Design"], "source": "lecture-b-sw-design.pdf", "section": "Page 4", "position": 4, "chunk_type": "semantic", "token_estimate": 68}
{"text": "Chapter 1: Introduction to Software Design: 5\nThings Change! \u2022 Users\u2019 needs and expectations change\n\u2022 Use reveals limitations and flaws\n\u2022 Desire for increased convenience, functionality\n\u2022 Desire for increased performance\n\u2022 Environment changes\n\u2022 Hardware, OS, software packages (\u201csoftware rot\u201d)\n\u2022 Need to interact with clients, parent org., etc. \u2022 Law and regulations change\n\u2022 Ways of doing business\n\u2022 Style, \u201ccool\u201d factor", "domains": ["Software Quality Attributes", "Code Organization"], "source": "lecture-b-sw-design.pdf", "section": "Page 5", "position": 5, "chunk_type": "semantic", "token_estimate": 65}
{"text": "Chapter 1: Introduction to Software Design: 12\nSoftware Life Cycle Activities\nActivities essential for successful development:\n\u2022 Requirements specification\n\u2022 Architectural, component, & detailed designs\n\u2022 Implementation\n\u2022 Unit, integration, and acceptance testing\n\u2022 Installation and maintenance", "domains": ["Domain-Driven Design", "Code Organization"], "source": "lecture-b-sw-design.pdf", "section": "Page 12", "position": 12, "chunk_type": "semantic", "token_estimate": 37}
{"text": "Chapter 1: Introduction to Software Design: 14\nSoftware Life Cycle Activities (more)\n\u2022 Requirements Specification\n\u2022 System analyst works with users to clarify the detailed \nsystem requirements\n\u2022 Questions include format of input data, desired form \nof any output screens, and data validation\n\u2022 Analysis\n\u2022 Make sure you completely understand the problem\nbefore starting the design or program a solution\n\u2022 Evaluate different approaches to the design", "domains": ["Domain-Driven Design"], "source": "lecture-b-sw-design.pdf", "section": "Page 14", "position": 14, "chunk_type": "semantic", "token_estimate": 68}
{"text": "Chapter 1: Introduction to Software Design: 18\nUsing Abstraction to Manage Complexity\n\u2022 An abstraction is a model of a physical entity or activity\n\u2022 Models include relevant facts and details\n\u2022 Models exclude matters irrelevant to system/task\n\u2022 Abstraction helps programmers:\n\u2022 Complex issues handled in manageable pieces\n\u2022 Procedural abstraction: distinguishes ...\n\u2022 What to achieve (by a procedure) ...\n\u2022 From how to achieve it (implementation)\n\u2022 Data abstraction: distinguishes ...\n\u2022 Data objects for a problem and their operations ...\n\u2022 From their representation in memory", "domains": ["Domain-Driven Design"], "source": "lecture-b-sw-design.pdf", "section": "Page 18", "position": 18, "chunk_type": "semantic", "token_estimate": 90}
{"text": "Chapter 1: Introduction to Software Design: 19\nUsing Abstraction to Manage Complexity (2)\n\u2022 If another class uses an object only through its methods, \nthe other class will not be affected if the data \nrepresentation changes\n\u2022 Information hiding: Concealing the details of a class \nimplementation from users of the class\n\u2022 Enforces the discipline of data abstraction", "domains": ["Code Organization"], "source": "lecture-b-sw-design.pdf", "section": "Page 19", "position": 19, "chunk_type": "semantic", "token_estimate": 58}
{"text": "Chapter 1: Introduction to Software Design: 20\nAbstract Data Types, Interfaces, and\nPre- and Post-conditions\n\u2022 A major goal of software engineering: write reusable code\n\u2022 Abstract data type (ADT): data + methods\n\u2022 A Java interface is a way to specify an ADT\n\u2022 Names, parameters, return types of methods\n\u2022 No indication of how achieved (procedural abstraction)\n\u2022 No representation (data abstraction)\n\u2022 A class may implement an interface\n\u2022 Must provide bodies for all methods of the interface", "domains": ["Code Organization"], "source": "lecture-b-sw-design.pdf", "section": "Page 20", "position": 20, "chunk_type": "semantic", "token_estimate": 81}
{"text": "Chapter 1: Introduction to Software Design: 22\nAbstract Data Types, Interfaces, and Pre-\nand Postconditions (continued)\n\u2022 You cannot instantiate (new) an interface\n\u2022 But you can:\n\u2022 Declare a variable that has an interface type\n\u2022 Use it to reference an actual object, whose class \nimplements the interface\n\u2022 A Java interface is a contract between\n\u2022 The interface designer and ...\n\u2022 The coder of a class that implements the interface\n\u2022 Precondition: any assumption/constraint on the method \ndata before the method begins execution\n\u2022 Postcondition: describes result of executing the method", "domains": ["Code Organization"], "source": "lecture-b-sw-design.pdf", "section": "Page 22", "position": 22, "chunk_type": "semantic", "token_estimate": 94}
{"text": "Chapter 1: Introduction to Software Design: 25\nDesign of Array-Based Phone Directory\nClasses/interfaces to design include:\n\u2022 PDUserInterface: interface; later we consider:\n\u2022 Console (command line) UI class\n\u2022 Graphical (JOptionPane) UI class\n\u2022 PDApplication: main / driving class\n\u2022 PhoneDirectory: interface\n\u2022 ArrayBasedPD: class implementing PhoneDirectory\n\u2022 DirectoryEntry: class, for one item in the directory", "domains": ["Design Patterns", "Code Organization"], "source": "lecture-b-sw-design.pdf", "section": "Page 25", "position": 25, "chunk_type": "semantic", "token_estimate": 56}
{"text": "Chapter 1: Introduction to Software Design: 30\nThe PhoneDirectory Interface\n/**\n* The interface for the telephone directory. * @author Koffman & Wolfgang\n*/\npublic interface PhoneDirectory {\n...\n}\n\u2022 Shows syntax of an interface\n\u2022 Shows a javadoc comment and the @author tag", "domains": ["Code Organization"], "source": "lecture-b-sw-design.pdf", "section": "Page 30", "position": 30, "chunk_type": "semantic", "token_estimate": 45}
{"text": "Chapter 1: Introduction to Software Design: 31\nPhoneDirectory.loadData\n/** Load the data file containing the\n*  directory, or establish a connection with\n*  the data source. *  @param sourceName The name of the file\n*    (data source) with the phone directory\n*    entries\n*/\nvoid loadData (String sourceName);\n\u2022 Shows syntax of method in an interface (note ;)\n\u2022 Shows a javadoc comment with the @param tag\n\u2022 Since returns void, no @return tag", "domains": ["Code Organization"], "source": "lecture-b-sw-design.pdf", "section": "Page 31", "position": 31, "chunk_type": "semantic", "token_estimate": 74}
{"text": "Chapter 1: Introduction to Software Design: 41\nImplementing and Testing the Array-Based \nPhone Directory: ArrayBasedPD.java\nimport java.io. *;\n/** This is an implementation of the\n*  PhoneDirectory interface that uses an\n*  array to store the data. *  @author Koffman & Wolfgang\n*/\npublic class ArrayBasedPD\nimplements PhoneDirectory {\n...\n}   // note: import, javadoc, implements", "domains": ["Code Organization"], "source": "lecture-b-sw-design.pdf", "section": "Page 41", "position": 41, "chunk_type": "semantic", "token_estimate": 56}
{"text": "Chapter 1: Introduction to Software Design: 55\nImplementing PDUserInterface\n\u2022 Text offers two classes that implement the UI interface:\n\u2022 PDGUI: Uses JOptionPane for graphical UI\n\u2022 PDConsoleUI: Uses console stream I/O \n(System.in and System.out)\n\u2022 Text gives good recipes here that you can use as \nmodels\n\u2022 We will not cover them in detail here", "domains": ["Code Organization"], "source": "lecture-b-sw-design.pdf", "section": "Page 55", "position": 55, "chunk_type": "semantic", "token_estimate": 56}
