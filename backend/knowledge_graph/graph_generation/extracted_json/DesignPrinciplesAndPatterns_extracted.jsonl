{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n1\nDesign Principles and \nDesign Patterns\nRobert C. Martin\nwww.objectmentor.com\nWhat is software architecture? The answer is multitiered. At the highest level, there \nare the architecture patterns that define the overall shape and structure of software \napplications1. Down a level is the architecture that is specifically related to the pur-\npose of the software application. Yet another level down resides the architecture of \nthe modules and their interconnections. This is the domain of design patterns2, pack-\nakges, components, and classes. It is this level that we will concern ourselves with in \nthis chapter.\nOur scope in this chapter is quite limitted. There is much more to be said about the \nprinciples and patterns that are exposed here. Interested readers are referred to \n[Martin99].\nArchitecture and Dependencies\nWhat goes wrong with software? The design of many software applications begins as \na vital image in the minds of its designers. At this stage it is clean, elegant, and com-\npelling. It has a simple beauty that makes the designers and implementers itch to see it \nworking. Some of these applications manage to maintain this purity of design through \nthe initial development and into the first release. \nBut then something begins to happen. The software starts to rot. At first it isn\u2019t so \nbad. An ugly wart here, a clumsy hack there, but the beauty of the design still shows \nthrough. Yet, over time as the rotting continues, the ugly festering sores and boils \naccumulate until they dominate the design of the application. The program becomes a \nfestering mass of code that the developers find increasingly hard to maintain. Eventu-\n1.\n[Shaw96]\n2.\n[GOF96]\n", "page": 1, "type": "text", "section": "Page 1"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n2\nally the sheer effort required to make even the simplest of changes to the application \nbecomes so high that the engineers and front line managers cry for a redesign project.\nSuch redesigns rarely succeed. Though the designers start out with good intentions, \nthey find that they are shooting at a moving target. The old system continues to \nevolve and change, and the new design must keep up. The warts and ulcers accumu-\nlate in the new design before it ever makes it to its first release. On that fateful day, \nusually much later than planned, the morass of problems in the new design may be so \nbad that the designers are already crying for another redesign.\nSymptoms of Rotting Design\nThere are four primary symptoms that tell us that our designs are rotting. They are not \northogonal, but are related to each other in ways that will become obvious. they are: \nrigidity, fragility, immobility, and viscosity.\nRigidity.     Rigidity is the tendency for software to be difficult to change, even in \nsimple ways. Every change causes a cascade of subsequent changes in dependent \nmodules. What begins as a simple two day change to one module grows into a multi-\nweek marathon of change in module after module as the engineers chase the thread of \nthe change through the application.\nWhen software behaves this way, managers fear to allow engineers to fix non-critical \nproblems. This reluctance derives from the fact that they don\u2019t know, with any reli-\nability, when the engineers will be finished. If the managers turn the engineers loose \non such problems, they may disappear for long periods of time. The software design \nbegins to take on some characteristics of a roach motel -- engineers check in, but they \ndon\u2019t check out.\nWhen the manager\u2019s fears become so acute that they refuse to allow changes to soft-\nware, official rigidity sets in. Thus, what starts as a design deficiency, winds up being \nadverse management policy.\nFragility.     Closely related to rigidity is fragility. Fragility is the tendency of the \nsoftware to break in many places every time it is changed. Often the breakage occurs \nin areas that have no conceptual relationship with the area that was changed. Such \nerrors fill the hearts of managers with foreboding. Every time they authorize a fix, \nthey fear that the software will break in some unexpected way.\nAs the fragility becomes worse, the probability of breakage increases with time, \nasymptotically approaching 1. Such software is impossible to maintain. Every fix \nmakes it worse, introducing more problems than are solved.\n", "page": 2, "type": "text", "section": "Page 2"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n3\nSuch software causes managers and customers to suspect that the developers have lost \ncontrol of their software. Distrust reigns, and credibility is lost.\nImmobility.     Immobility is the inability to reuse software from other projects or \nfrom parts of the same project. It often happens that one engineer will discover that he \nneeds a module that is similar to one that another engineer wrote. However, it also \noften happens that the module in question has too much baggage that it depends upon. \nAfter much work, the engineers discover that the work and risk required to separate \nthe desirable parts of the software from the undesirable parts are too great to tolerate. \nAnd so the software is simply rewritten instead of reused.\nViscosity.     Viscosity comes in two forms: viscosity of the design, and viscosity of \nthe environment. When faced with a change, engineers usually find more than one \nway to make the change. Some of the ways preserve the design, others do not (i.e. \nthey are hacks.) When the design preserving methods are harder to employ than the \nhacks, then the viscosity of the design is high. It is easy to do the wrong thing, but \nhard to do the right thing. \nViscosity of environment comes about when the development environment is slow \nand inefficient. For example, if compile times are very long, engineers will be \ntempted to make changes that don\u2019t force large recompiles, even though those \nchanges are not optiimal from a design point of view. If the source code control sys-\ntem requires hours to check in just a few files, then engineers will be tempted to make \nchanges that require as few check-ins as possible, regardless of whether the design is \npreserved.\nThese four symptoms are the tell-tale signs of poor architecture. Any application that \nexhibits them is suffering from a design that is rotting from the inside out. But what \ncauses that rot to take place?\nChanging Requirements\nThe immediate cause of the degradation of the design is well understood. The require-\nments have been changing in ways that the initial design did not anticipate. Often \nthese changes need to be made quickly, and may be made by engineers who are not \nfamiliar with the original design philosophy. So, though the change to the design \nworks, it somehow violates the original design. Bit by bit, as the changes continue to \npour in, these violations accumulate until malignancy sets in. \nHowever, we cannot blame the drifting of the requirements for the degradation of the \ndesign. We, as software engineers, know full well that requirements change. Indeed, \nmost of us realize that the requirements document is the most volatile document in the \n", "page": 3, "type": "text", "section": "Page 3"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n4\nproject. If our designs are failing due to the constant rain of changing requirements, it \nis our designs that are at fault. We must somehow find a way to make our designs \nresilient to such changes and protect them from rotting.\nDependency Management\nWhat kind of changes cause designs to rot? Changes that introduce new and \nunplanned for dependencies. Each of the four symptoms mentioned above is either \ndirectly, or indirectly caused by improper dependencies between the modules of the \nsoftware. It is the dependency architecture that is degrading, and with it the ability of \nthe software to be maintained.\nIn order to forestall the degradation of the dependency architecture, the dependencies \nbetween modules in an application must be managed. This management consists of \nthe creation of dependency firewalls. Accross such firewalls, dependencies do not \npropogate.\nObject Oriented Design is replete with principles and techniques for building such \nfirewalls, and for managing module dependencies. It is these principles and tech-\nniques that will be discussed in the remainder of this chapter. First we will examine \nthe principles, and then the techniques, or design patterns, that help maintain the \ndependency architecture of an application.\nPrinciples of Object Oriented Class Design\nThe Open Closed Principle (OCP)1\nA module should be open for extension but closed for modification.\nOf all the principles of object oriented design, this is the most important. It originated \nfrom the work of Bertrand Meyer2. It means simply this: We should write our mod-\nules so that they can be extended, without requiring them to be modified. In other \nwords, we want to be able to change what the modules do, without changing the \nsource code of the modules.\n1.\n[OCP97]\n2.\n[OOSC98]\n", "page": 4, "type": "text", "section": "Page 4"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n5\nThis may sound contradictory, but there are several techniques for achieving the OCP \non a large scale. All of these techniques are based upon abstraction. Indeed, abstrac-\ntion is the key to the OCP. Several of these techniques are described below.\nDynamic Polymorphism. Consider Listing 2-1. the LogOn function must be \nchanged every time a new kind of modem is added to the software. Worse, since each \ndifferent type of modem depends upon the Modem::Type enumeration, each \nmodem must be recompiled every time a new kind of modem is added.\nListing 2-1\nLogon, must be modified to be extended.\nstruct Modem \n{\nenum Type {hayes, courrier, ernie) type;\n};\nstruct Hayes\n{\nModem::Type type;\n// Hayes related stuff\n};\nstruct Courrier\n{\nModem::Type type;\n// Courrier related stuff\n};\nstruct Ernie\n{\nModem::Type type;\n// Ernie related stuff\n};\nvoid LogOn(Modem& m, \nstring& pno, string& user, string& pw)\n{\nif (m.type == Modem::hayes)\nDialHayes((Hayes&)m, pno);\nelse if (m.type == Modem::courrier)\nDialCourrier((Courrier&)m, pno);\nelse if (m.type == Modem::ernie)\nDialErnie((Ernie&)m, pno)\n// ...you get the idea\n}\n", "page": 5, "type": "text", "section": "Page 5"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n6\nOf course this is not the worst attribute of this kind of design. Programs that are \ndesigned this way tend to be littered with similar if/else or switch statement. Every \ntime anything needs to be done to the modem, a switch statement if/else chain will \nneed to select the proper functions to use. When new modems are added, or modem \npolicy changes, the code must be scanned for all these selection statements, and each \nmust be appropriately modified.\nWorse, programmers may use local optimizations that hide the structure of the selec-\ntion statements. For example, it might be that the function is exactly the same for \nHayes and Courrier modems. Thus we might see code like this:\nif (modem.type == Modem::ernie)\nSendErnie((Ernie&)modem, c);\nelse\nSendHayes((Hayes&)modem, c);\nClearly, such structures make the system much harder to maintain, and are very prone \nto error.\nAs an example of the OCP, consider Figure 2-13. Here the LogOn function depends \nonly upon the Modem interface. Additional modems will not cause the LogOn func-\ntion to change. Thus, we have created a module that can be extended, with new \nmodems, without requiring modification. See Listing 2-2.\nFigure 2-13\nListing 2-2\nLogOn has been closed for modification\nclass Modem\n{\npublic:\n+ Dial(pno)\n+ Send(char)\n+ Recv() : char\n+ Hangup()\nModem\n\u00abinterface\u00bb\nLogOn\nCourrier\nModem\nHayes\nModem\nErnie's\nModem\n\u00abfunction\u00bb\n", "page": 6, "type": "text", "section": "Page 6"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n7\nStatic Polymorphism.     Another technique for conforming to the OCP is through \nthe use of templates or generics. Listing 2-3 shows how this is done. The LogOn func-\ntion can be extended with many different types of modems without requiring modifi-\ncation.\nArchitectural Goals of the OCP.     By using these techniques to conform to the \nOCP, we can create modules that are extensible, without being changed. This means \nthat, with a little forethought, we can add new features to existing code, without \nchanging the existing code and by only adding new code. This is an ideal that can be \ndifficult to achieve, but you will see it achieved, several times, in the case studies later \non in this book. \nEven if the OCP cannot be fully achieved, even partial OCP compliance can make \ndramatic improvements in the structure of an application. It is always better if \nchanges do not propogate into existing code that already works. If you don\u2019t have to \nchange working code, you aren\u2019t likely to break it.\nvirtual void Dial(const string& pno) = 0;\nvirtual void Send(char) = 0;\nvirtual char Recv() = 0;\nvirtual void Hangup() = 0;\n};\nvoid LogOn(Modem& m, \nstring& pno, string& user, string& pw)\n{\nm.Dial(pno);\n// you get the idea.\n}\nListing 2-3\nLogon is closed for modification through static polymorphism\ntemplate <typename MODEM>\nvoid LogOn(MODEM& m,\nstring& pno, string& user, string& pw)\n{\nm.Dial(pno);\n// you get the idea.\n}\nListing 2-2\nLogOn has been closed for modification\n", "page": 7, "type": "text", "section": "Page 7"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n8\nThe Liskov Substitution Principle (LSP)1\nSubclasses should be substitutable for their base classes.\nThis principle was coined by Barbar Liskov2 in her work regarding data abstraction \nand type theory. It also derives from the concept of Design by Contract (DBC) by \nBertrand Meyer3. \nThe concept, as stated above, is depicted in Figure 2-14. Derived classes should be \nsubstitutable for their base classes. That is, a user of a base class should continue to \nfunction properly if a derivative of that base class is passed to it.\nIn other words, if some function User takes an argument ot type Base, then as \nshown in Listing 2-4, it should be legal to pass in an instance of Derived to that \nfunction.\nThis may seem obvious, but there are subtleties that need to be considered. The \ncanonical example is the Circle/Ellipse dilemma.\n1.\n[LSP97]\n2.\n[Liksov88]\n3.\n[OOSC98]\nFigure 2-14\nLSP schema.\nListing 2-4\nUser, Based, Derived, example.\nvoid User(Base& b);\nDerived d;\nUser(d);\nUser\nBase\nDerived\n", "page": 8, "type": "text", "section": "Page 8"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n9\nThe Circle/Ellipse Dilemma.     Most of us learn, in high school math, that a circle \nis just a degenerate form of an ellipse. All circles are ellipses with coincident foci. \nThis is-a relationship tempts us to model circles and ellipses using inheritance as \nshown in Figure 2-15.\nWhile this satisfies our conceptual model, there are certain difficulties. A closer look \nat the declaration of Ellipse in Figure 2-16 begins to expose them. Notice that \nEllipse has three data elements. The first two are the foci, and the last is the length \nof the major axis. If Circle inherits from Ellipse, then it will inherit these data \nvariables. This is unfortunate since Circle really only needs two data elements, a \ncenter point and a radius.\nFigure 2-15\nCircle / Ellipse Dilemma\nFigure 2-16\nDeclaration of Ellipse\nEllipse\nCircle\n+ Circumference() : double\n+ Area() : double\n+ GetFocusA() : Point\n+ GetFocusB() : Point\n+ GetMajorAxis() : double\n+ GetMinorAxis() : double\n+ SetFoci(a:Point, b:Point)\n+ SetMajorAxis(double)\n- itsFocusA : Point\n- itsFocusB : Point\n- itsMajorAxis : double\nEllipse\n", "page": 9, "type": "text", "section": "Page 9"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n10\nStill, if we ignore the slight overhead in space, we can make Circle behave prop-\nerly by overriding its SetFoci method to ensure that both foci are kept at the same \nvalue. See Listing 2-5. Thus, either focus will act as the center of the circle, and the \nmajor axis will be its diameter.\nClients Ruin Everything.     Certainly the model we have created is self consis-\ntent. An instance of Circle will obeys all the rules of a circle. There is nothing you \ncan do to it to make it violate those rules. So too for Ellipse. The two classes form \na nicely consistent model, even if Circle has one too many data elements.\nHowever, Circle and Ellipse do not live alone in a universe by themselves. \nThey cohabit that universe with many other entities, and provide their public inter-\nfaces to those entities. Those interfaces imply a contract. The contract may not be \nexplicitly stated, but it is there nonetheless. For example, users of Ellipse have the \nright to expect the following code fragment to succeed:\nvoid f(Ellipse& e)\n{\nPoint a(-1,0);\nPoint b(1,0);\ne.SetFoci(a,b);\ne.SetMajorAxis(3);\nassert(e.GetFocusA() == a);\nassert(e.GetFocusB() == b);\nassert(e.GetMajorAxis() == 3);\n}\nIn this case the function expects to be working with an Ellipse. As such, it expects \nto be able to set the foci, and major axis, and then verify that they have been properly \nset. If we pass an instance of Ellipse into this function, it will be quite happy. \nHowever, if we pass an instance of Circle into the function, it will fail rather badly.\nIf we were to make the contract of Ellipse explicit, we would see a postcondition \non the SetFoci that guaranteed that the input values got copied to the member vari-\nables, and that the major axis variable was left unchanged. Clearly Circle violates \nthis guarantee because it ignores the second input variable of SetFoci. \nDesign by Contract.     Restating the LSP, we can say that, in order to be substitut-\nable, the contract of the base class must be honored by the derived class. Since \nListing 2-5\nKeeping the Circle Foci coincident.\nvoid Circle::SetFoci(const Point& a, const Point& b)\n{\nitsFocusA = a;\nitsFocusB = a;\n}\n", "page": 10, "type": "text", "section": "Page 10"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n11\nCircle does not honor the implied contract of Ellipse, it is not substitutable and \nviolates the LSP.\nMaking the contract explicit is an avenue of research followed by Bertrand Meyer. He \nhas invented a language named Eiffel in which contracts are explicitly stated for each \nmethod, and explicitly checked at each invocation. Those of us who are not using \nEiffel, have to make do with simple assertions and comments. \nTo state the contract of a method, we declare what must be true before the method is \ncalled. This is called the precondition. If the precondition fails, the results of the \nmethod are undefined, and the method ought not be called. We also declare what the \nmethod guarantees will be true once it has completed. This is called the postcondition. \nA method that fails its postcondition should not return.\nRestating the LSP once again, this time in terms of the contracts, a derived class is \nsubstitutable for its base class if:\n1. Its preconditions are no stronger than the base class method.\n2. Its postconditions are no weaker than the base class method.\nOr, in other words, derived methods should expect no more and provide no less.\nRepercussions of LSP Violation.     Unfortunately, LSP violations are difficult \nto detect until it is too late. In the Circle/Ellipse case, everything worked fine until \nsome client came along and discovered that the implicit contract had been violated.\nIf the design is heavily used, the cost of repairing the LSP violation may be too great \nto bear. It might not be economical to go back and change the design, and then rebuild \nand retest all the existing clients. Therefore the solution will likely be to put into an if/\nelse statement in the client that discovered the violation. This if/else statement checks \nto be sure that the Ellipse is actually an Ellipse and not a Circle. See Listing \n2-6. \nListing 2-6\nUgly fix for LSP violation\nvoid f(Ellipse& e)\n{\nif (typeid(e) == typeid(Ellipse))\n{\nPoint a(-1,0);\nPoint b(1,0);\ne.SetFoci(a,b);\ne.SetMajorAxis(3);\nassert(e.GetFocusA() == a);\nassert(e.GetFocusB() == b);\n", "page": 11, "type": "text", "section": "Page 11"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n12\nCareful examination of Listing 2-6 will show it to be a violation of the OCP. Now, \nwhenever some new derivative of Ellipse is created, this function will have to be \nchecked to see if it should be allowed to operate upon it. Thus, violations of LSP are \nlatent violations of OCP.\nThe Dependency Inversion Principle (DIP)1\nDepend upon Abstractions. Do not depend upon concretions.\nIf the OCP states the goal of OO architecture, the DIP states the primary mechanism. \nDependency Inversion is the strategy of depending upon interfaces or abstract func-\ntions and classes, rather than upon concrete functions and classes. This principle is the \nenabling force behind component design, COM, CORBA, EJB, etc. \nProcedural designs exhibit a particular kind of dependency structure. As Figure 2-17 \nshows, this structure starts at the top and points down towards details. High level \nmodules depend upon lower level modules, which depend upon yet lower level mod-\nules, etc.. \nA little thought should expose this dependency structure as intrinsically weak. The \nhigh level modules deal with the high level policies of the application. These policies \ngenerally care little about the details that implement them. Why then, must these high \nlevel modules directly depend upon those implementation modules?\nAn object oriented architecture shows a very different dependency structure, one in \nwhich the majority of dependencies point towards abstractions. Morevoer, the mod-\nules that contain detailed implementation are no longer depended upon, rather they \ndepend themselves upon abstractions. Thus the dependency upon them has been \ninverted. See Figure 2-18.\nDepending upon Abstractions.     The implication of this principle is quite sim-\nple. Every dependency in the design should target an interface, or an abstract class. \nNo dependency should target a concrete class.\nassert(e.GetMajorAxis() == 3);\n}\nelse\nthrow NotAnEllipse(e);\n}\n1.\n[DIP97]\nListing 2-6\nUgly fix for LSP violation\n", "page": 12, "type": "text", "section": "Page 12"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n13\nClearly such a restriction is draconian, and there are mitigating circumstatnces that \nwe will explore momentarily. But, as much as is feasible, the principle should be fol-\nlowed. The reason is simple, concrete things change alot, abstract things change much \nless frequently. Morevoer, abstractions are \u201chinge points\u201d, they represent the places \nwhere the design can bend or be extended, without themselves being modified (OCP).\nFigure 2-17\nDependency Structure of a Procedural Architecture\nFigure 2-18\nDependency Structure of an Object Oriented Architecture\nmain\nmid 1\nMid 2\nMid 3\nDetail\nDetail\nDetail\nDetail\nHigh level\nPolicy\nAbstract\nInterface\nAbstract\nInterface\nAbstract\nInterface\nDetailed\nImplementation\nDetailed\nImplementation\nDetailed\nImplementation\n", "page": 13, "type": "text", "section": "Page 13"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n14\nSubstrates such as COM enforce this principle, at least between components. The \nonly visible part of a COM component is its abstract interface. Thus, in COM, there is \nlittle escape from the DIP.\nMitigating Forces.     One motivation behind the DIP is to prevent you from \ndepending upon volatile modules. The DIP makes the assumption that anything con-\ncrete is volatile. While this is frequently so, especially in early development, there are \nexceptions. For example, the string.h standard C library is very concrete, but is \nnot at all volatile. Depending upon it in an ANSI string environment is not harmful. \nLikewise, if you have tried and true modules that are concrete, but not volatile, \ndepending upon them is not so bad. Since they are not likely to change, they are not \nlikely to inject volatility into your design. \nTake care however. A dependency upon string.h could turn very ugly when the \nrequirements for the project forced you to change to UNICODE characters. Non-vol-\natility is not a replacement for the substitutability of an abstract interface. \nObject Creation.     One of the most common places that designs depend upon con-\ncrete classes is when those designs create instances. By definition, you cannot create \ninstances of abstract classes. Thus, to create an instance, you must depend upon a \nconcrete class.\nCreation of instances can happen all through the architecture of the design. Thus, it \nmight seem that there is no escape and that the entire architecture will be littered with \ndependencies upon concrete classes. However, there is an elegant solution to this \nproblem named ABSTRACTFACTORY1 -- a design pattern that we\u2019ll be examining in \nmore detail towards the end of this chapter.\nThe Interface Segregation Principle (ISP)2\nMany client specific interfaces are better than one general purpose interface\nThe ISP is another one of the enabling technologies supporting component substrates \nsuch as COM. Without it, components and classes would be much less useful and por-\ntable.\nThe essence of the principle is quite simple. If you have a class that has several cli-\nents, rather than loading the class with all the methods that the clients need, create \nspecific interfaces for each client and multiply inherit them into the class.\n1.\n[GOF96] p??\n2.\n[ISP97]\n", "page": 14, "type": "text", "section": "Page 14"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n15\nFigure 2-19 shows a class with many clients, and one large interface to serve them all. \nNote that whenever a change is made to one of the methods that ClientA calls, \nClientB and ClientC may be affected. It may be necessary to recompile and \nredeploy them. This is unfortunate.\nA better technique is shown in Figure 2-20. The methods needed by each client are \nplaced in special interfaces that are specific to that client. Those interfaces are multi-\nply inherited by the Service class, and implemented there.\nIf the interface for ClientA needs to change, ClientB and ClientC will remain \nunaffected. They will not have to be recompiled or redeployed.\nWhat does Client Specific Mean?     The ISP does not recommend that every \nclass that uses a service have its own special interface class that the service must \ninherit from. If that were the case, the service would depend upon each and every cli-\nent in a bizarre and unhealthy way. Rather, clients should be categorized by their \ntype, and interfaces for each type of client should be created.\nIf two or more different client types need the same method, the method should be \nadded to both of their interfaces. This is neither harmful nor confusing to the client.\nChanging Interfaces.     When object oriented applications are maintained, the \ninterfaces to existing classes and components often change. There are times when \nthese changes have a huge impact and force the recompilation and redeployment of a \nvery large part of the design. This impact can be mitigated by adding new interfaces \nto existing objects, rather than changing the existing interface. Clients of the old inter-\nFigure 2-19\nFat Service with Integrated Interfaces\n\u00abclient A Methods\u00bb\n+ ...\n\u00abclient B methods\u00bb\n+ ...\n\u00abclient C methods\u00bb\n+ ...\nService\nClient A\nClient B\nClient C\n", "page": 15, "type": "text", "section": "Page 15"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n16\nface that wish to access methods of the new interface, can query the object for that \ninterface as shown in the following code.\nvoid Client(Service* s)\n{\nif (NewService* ns = dynamic_cast<NewService*>(s))\n{\n// use the new service interface\n}\n}\nAs with all principles, care must be taken not to overdo it. The specter of a class with \nhundreds of different interfaces, some segregated by client and other segregated by \nversion, would be frightening indeed.\nPrinciples of Package Architecture\nClasses are a necessary, but insufficient, means of organizing a design. The larger \ngranularity of packages are needed to help bring order. But how do we choose which \nclasses belong in which packages. Below are three principles known as the Package \nCohesion Principles, that attempt to help the software architect.\nFigure 2-20\nSegregated Interfaces\n\u00abclient A Methods\u00bb\n+ ...\n\u00abclient B methods\u00bb\n+ ...\n\u00abclient C methods\u00bb\n+ ...\nService\nClient A\nClient B\nClient C\n\u00abclient A Methods\u00bb\n+ ...\nService A\n\u00abinterface\u00bb\n\u00abclient B Methods\u00bb\n+ ...\nService B\n\u00abinterface\u00bb\n\u00abclient C Methods\u00bb\n+ ...\nService C\n\u00abinterface\u00bb\n", "page": 16, "type": "text", "section": "Page 16"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n17\nThe Release Reuse Equivalency Principle (REP)1\nThe granule of reuse is the granule of release.\nA reusable element, be it a component, a class, or a cluster of classes, cannot be \nreused unless it is managed by a release system of some kind. Users will be unwilling \nto use the element if they are forced to upgrade every time the author changes it. \nThus. even though the author has released a new version of his reusable element, he \nmust be willing to support and maintain older versions while his customers go about \nthe slow business of getting ready to upgrade. Thus, clients will refuse to reuse an ele-\nment unless the author promises to keep track of version numbers, and maintain old \nversions for awhile.\nTherefore, one criterion for grouping classes into packages is reuse. Since packages \nare the unit of release, they are also the unit of reuse. Therefore architects would do \nwell to group reusable classes together into packages.\nThe Common Closure Principle (CCP)2\nClasses that change together, belong together.\nA large development project is subdivided into a large network of interelated pack-\nages. The work to manage, test, and release those packages is non-trivial. The more \npackages that change in any given release, the greater the work to rebuild, test, and \ndeploy the release. Therefore we would like to minimze the number of packages that \nare changed in any given release cycle of the product.\nTo achieve this, we group together classes that we think will change together. This \nrequires a certain amount of precience since we must anticipate the kinds of changes \nthat are likely. Still, when we group classes that change together into the same pack-\nages, then the package impact from release to release will be minimzed.\nThe Common Reuse Principle (CRP)3\nClasses that aren\u2019t reused together should not be grouped together.\nA dependency upon a package is a dependency upon everything within the package. \nWhen a package changes, and its release number is bumped, all clients of that pack-\n1.\n[Granularity97]\n2.\n[Granularity97]\n3.\n[Granularity97]\n", "page": 17, "type": "text", "section": "Page 17"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n18\nage must verify that they work with the new package -- even if nothing they used \nwithin the package actually changed.\nWe frequently experience this when our OS vendor releases a new operating system. \nWe have to upgrade sooner or later, because the vendor will not support the old ver-\nsion forever. So even though nothing of interest to us changed in the new release, we \nmust go through the effort of upgrading and revalidating.\nThe same can happen with packages if classes that are not used together are grouped \ntogether. Changes to a class that I don\u2019t care about will still force a new release of the \npackage, and still cause me to go through the effort of upgrading and revalidating.\nTension between the Package Cohesion Principles\nThese three principles are mutually exclusive. They cannot simultaneously be satis-\nfied. That is because each principle benefits a different group of people. The REP and \nCRP makes life easy for reusers, whereas the CCP makes life easier for maintainers. \nThe CCP strives to make packages as large as possible (after all, if all the classes live \nin just one package, then only one package will ever change). The CRP, however, \ntries to make packages very small. \nFortunately, packages are not fixed in stone. Indeed, it is the nature of packages to \nshift and jitter during the course of development. Early in a project, architects may set \nup the package structure such that CCP dominates and develoipment and maintenance \nis aided. Later, as the architecture stabilizes, the architects may refactor the package \nstructure to maximize REP and CRP for the external reusers.\nThe Package Coupling Principles.\nThe next three packages govern the interlationships between packages. Applications \ntend to be large networks of interlated packages. The rules that govern these interrela-\ntionship are some of the most important rules in object oriented architecture.\nThe Acyclic Dependencies Principle (ADP)1\nThe dependencies betwen packages must not form cycles.\nSince packages are the granule of release, they also tend to focus manpower. Engi-\nneers will typically work inside a single package rather than working on dozens. This \ntedency is amplified by the package cohesion principles, since they tend to group \n1.\n[Granularity97]\n", "page": 18, "type": "text", "section": "Page 18"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n19\ntogether those classes that are related. Thus, engineers will find that their changes are \ndirected into just a few package. Once those changes are made, they can release those \npackages to the rest of the project.\nBefore they can do this release, however, they must test that the package works. To \ndo that, they must compile and build it with all the packages that it depends upon. \nHopefully this number is small. \nConsider Figure 2-21. Astute readers will recognize that there are a number of flaws \nin the architecture. The DIP seems to have been abandoned, and along with it the \nOCP. The GUI depends directly upon the communications package, and apparently is \nreponsible for transporting data to the analysis package. Yuk.\nStill, lets use this rather ugly structure for some examples. Consider what would be \nrequired to release the Protocol package. The engineers would have to build it \nwith the latest release of the CommError package, and run their tests. Protocol \nhas no other dependencies, so no other package is needed. This is nice. We can test \nand release with a minimal amount of work.\nFigure 2-21\nAcyclic Package Network\nGUI\nComm\nAnalysis\nDatabase\nModem Control\nProtocol\nComm Error\n", "page": 19, "type": "text", "section": "Page 19"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n20\nA Cycle Creeps In.     But now lets say that I am an engineer working on the \nCommError package. I have decided that I need to display a message on the screen. \nSince the screen is controlled by the GUI, I send a message to one of the GUI objects \nto get my message up on the screen. This means that I have made CommError \ndependent upon GUI. See Figure 2-22.\nNow what happens when the guys who are working on Protocol want to release \ntheir package. They have to build their test suite with CommError, GUI, Comm, \nModemControl, Analysis, and Database! This is clearly disastrous. The \nworkload of the engineers has been increased by an abhorent amount, due to one sin-\ngle little dependency that got out of control.\nThis means that someone needs to be watching the package dependency structure \nwith regularity, and breaking cycles wherever they appear. Otherwise the transitive \ndependencies between modules will cause every module to depend upon every other \nmodule.\nBreaking a Cycle.     Cycles can be broken in two ways. The first involves creating \na new package, and the second makes use of the DIP and ISP.\nFigure 2-22\nA cycle has been added.\nGUI\nComm\nAnalysis\nDatabase\nModem Control\nProtocol\nComm Error\n", "page": 20, "type": "text", "section": "Page 20"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n21\nFigure 2-23 shows how to break the cycle by adding a new package. The classes that \nCommError needed are pulled out of GUI and placed in a new package named \nMessageManager. Both GUI and CommError are made to depend upon this new \npackage.\nThis is an example of how the package structure tends to jitter and shift during devel-\nopment. New package come into existence, and classes move from old package to \nnew packages, to help break cycles.\nFigure 2-24 shows a before and after picture of the other technique for breaking \ncycles. Here we see two packages that are bound by a cycle. Class A depends upon \nclass X, and class Y depends upon class B. We break the cycle by inverting the depen-\ndency between Y and B. This is done by adding a new interface, BY, to B. This inter-\nface has all the methods that Y needs. Y uses this interface and B implements it.\nNotice the placement of BY. It is placed in the package with the class that uses it. This \nis a pattern that you will see repeated throughout the case studies that deal with pack-\nFigure 2-23\nGUI\nComm\nAnalysis\nDatabase\nModem Control\nProtocol\nComm Error\nMessage\nManager\n", "page": 21, "type": "text", "section": "Page 21"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n22\nages. Interfaces are very often included in the package that uses them, rather than in \nthe package that implements them.\nThe Stable Dependencies Principle (SDP)1\nDepend in the direction of stability.\nThough this seems to be an obvious principle, there is quite a bit we can say about it. \nStability is not always well understood.\nStability.     What is meant by stability? Stand a penny on its side. Is it stable in that \nposition? Likely you\u2019d say not. However, unless disturbed, it will remain in that posi-\nFigure 2-24\n1.\n[Stability97]\nA\nB\nX\nY\nA\nB\nX\nY\nBY\n\u00abinterface\u00bb\n", "page": 22, "type": "text", "section": "Page 22"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n23\ntion for a very very long time. Thus stability has nothing direclty to do with frequency \nof change. The penny is not changing, but it is hard to think of it as stable.\nStability is related to the amount of work required to make a change. The penny is not \nstable because it requires very little work to topple it. On the other hand, a table is \nvery stable because it takes a considerable amount of effort to turn it over. \nHow does this relate to software? There are many factors that make a software pack-\nage hard to change. Its size, complexity, clarity, etc. We are going to ignore all those \nfactors and focus upon something different. One sure way to make a software pack-\nage difficult to change, is to make lots of other software packages depend upon it. A \npackage with lots of incomming dependencies is very stable because it requires a \ngreat deal of work to reconcile any changes with all the dependent packages.\nFigure 2-25 shows X: a stable package. This package has three packages depending \nupon it, and therefore it has three good reasons not to change. We say that it is respon-\nsible to those three packages. On the other hand, X depends upon nothing, so it has no \nexternal influence to make it change. We say it is independent.\nFigure 2-26, on the other hand, shows a very instable package. Y has no other pack-\nages depending upon it; we say that it is irresponsible. Y also has three packages that \nit depends upon, so changes may come from three external sources. We say that Y is \ndependent.\nStability Metrics.     We can calculate the stability of a package using a trio of sim-\nple metrics.\nCa\nAfferent Coupling. The number of classes outside the package that depend \nupon classes inside the package. (i.e. incomming dependencies)\nFigure 2-25\nX is a stable package\nX\n", "page": 23, "type": "text", "section": "Page 23"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n24\nCe\nEfferent Coupling. The number of classes outside the package that classes \ninside the package depend upon. (i.e. outgoing dependencies)\nI\nInstability. \n. This is a metric that has the range: [0,1].\nIf there are no outgoing dependencies, then I will be zero and the package is stable. If \nthere are no incomming dependencies then I will be one and the package is instable.\nNow we can rephrase the SDP as follows: \u201cDepend upon packages whose I metric is \nlower than yours.\u201d\nRationale. Should all software be stable? One of the most important attributes of \nwell designed software is ease of change. Software that is flexible in the presence of \nchanging requirements is thought well of. Yet that software is instable by our defini-\ntion. Indeed, we greatly desire that portions of our software be instable. We want cer-\ntain modules to be easy to change so that when requirements drift, the design can \nrespond with ease.\nFigure 2-27 shows how the SDP can be violated. Flexible is a package that we \nintend to be easy to change. We want Flexible to be instable. However, some \nengineer, working in the package named Stable, hung a dependency upon \nFlexible. This violates the SDP since the I metric for Stable is much lower than \nthe I metric for Flexible. As a result, Flexible will no longer be easy to \nchange. A change to Flexible will force us to deal with Stable and all its depen-\ndents.\nThe Stable Abstractions Principle (SAP)1\nStable packages should be abstract packages.\nFigure 2-26\nY is instable.\nY\nI\nCe\nCa\nCe\n+\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n=\n", "page": 24, "type": "text", "section": "Page 24"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n25\nWe can envision the packages structure of our application as a set of interconnected \npackages with instable packages at the top, and stable packages on the bottom. In this \nview, all dependencies point downwards.\nThose packages at the top are instable and flexible. But those at the bottom are very \ndifficult to change. And this leads us to a dilemma: Do we want packages in our \ndesign that are hard to change?\nClearly, the more packages that are hard to change, the less flexible our overall design \nwill be. However, there is a loophole we can crawl through. The highly stable pack-\nages at the bottom of the dependency network may be very difficult to change, but \naccording to the OCP they do not have to be difficult to extend!\nIf the stable packages at the bottom are also highly abstract, then they can be easily \nextended. This means that it is possible to compose our application from instable \npackages that are easy to change, and stable packages that are easy to extend. This is a \ngood thing.\nThus, the SAP is just a restatement of the DIP. It states the packages that are the most \ndepended upon (i.e. stable) should also be the most abstract. But how do we meaure \nabstractness?\nThe Abstractness Metrics. We can derive another trio of metrics to help us cal-\nculate abstractness.\n1.\n[Stability97]\nFigure 2-27\nViolation of SDP.\nFlexible\nStable\n", "page": 25, "type": "text", "section": "Page 25"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n26\nNc\nNumber of classes in the package.\nNa\nNumber of abstract classes in the package. Remember, an abstract class is a \nclass with at least one pure interface, and cannot be instantiated.\nA\nAbstractness. \nThe A metric has a range of [0,1], just like the I metric. A value of zero means that the \npackage contains no abstract classes. A value of one means that the package contains \nnothing but abstract classes.\nThe I vs A graph.     The SAP can now be restated in terms of the I and A metrics: I \nshould increase as A decreases. That is, concrete packages should be instable while \nabstract packages should be stable. We can plot this graphically on the A vs I graph. \nSee Figure 2-28.\nIt seems clear that packages should appear at either of the two black dots on Figure 2-\n28. Those at the upper left are completely abstract and very stable. Those at the lower \nright are completely concrete and very instable. This is just the way we like it. How-\never what about package X in Figure 2-29? Where should it go?\nFigure 2-28\nThe A vs I graph.\nA\nNa\nNc\n-\n-\n-\n-\n-\n-\n-\n=\n0\n1\n1\nThe Main Sequence\nThe\nZone of\nUselessness\nThe Zone of\nPain\nI\nA\n", "page": 26, "type": "text", "section": "Page 26"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n27\nWe can determine where we want Package X, by looking at where we don\u2019t want it to \ngo. The upper right corner of the AI graph represents packages that are highly abstract \nand that nobody depends upon. This is the zone of uselessness. Certainly we don\u2019t \nwant X to live there. On the other hand, the the lower left point of the AI graph repre-\nsents packages that are concrete and have lots of incomming dependencies. This point \nrepresents the worst case for a package. Since the elements there are concrete, they \ncannot be extended the way abstract entities can; and since they have lots of incom-\nming dependencies, the change will be very painful. This is the zone of pain, and we \ncertainly don\u2019t want our package to live there.\nMaximizing the distance between these two zones gives us a line called the main \nsequence. We\u2019d like our packages to sit on this line if at all possible. A position on \nthis line means that the package is abstract in proportion to its incomming dependen-\ncies and is concrete in proportion to its outgoing dependencies. In other words, the \nclasses in such a package are conforming to the DIP.\nDistance Metrics.     This leaves us one more set of metrics to examine. Given the \nA and I values of any package, we\u2019d like to know how far that package is from the \nmain sequence.\nD\nDistance. \n. This ranges from [0,~0.707].\nD\u2019\nNormalized Distance. \n. This metric is much more convenient \nthan D since it ranges from [0,1]. Zero indicates that the package is directly \non the main sequence. One indicates that the package is as far away as possi-\nble from the main sequence.\nThese metrics measure object oriented architecture. They are imperfect, and reliance \nupon them as the sole indicator of a sturdy architecture would be foolhardy. However, \nthey can be, and have been, used to help measure the dependency structure of an \napplication.\nFigure 2-29\nWhat do we put X on the A vs I Graph?\nC\nX\nA\nD\nA\nI\n1\n\u2013\n+\n2\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n=\nD\u2032\nA\nI\n1\n\u2013\n+\n=\n", "page": 27, "type": "text", "section": "Page 27"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n28\nPatterns of Object Oriented Architecture\nWhen following the principles described above to create object oriented architectures, \n, one finds that one repeats the same structures over and over again. These repeating \nstructures of design and architecture are known as design patterns1.\nThe essential definition of a design pattern is a well worn and known good solution to \na common problem. Design patterns are definitively not new. Rather they are old \ntechniques that have shown their usefulness over a period of many years.\nSome common design patterns are described below. These are the patterns that you \nwill come accross while reading through the case studies later in the book.\nIt should be noted that the topic of Design Patterns cannot be adequately covered in a \nsingle chapter of a single book. Interested readers are strongly encouraged to read \n[GOF96].\nAbstract Server\nWhen a client depends directly on a server, the DIP is violated. Changes to the server \nwill propogate to the client, and the client will be unable to easily use similar servers. \nThis can be rectified by inserting an anbstract interface between the client and the \nserver as shown in Figure 2-30. \nThe abstract interface becomes a \u201chinge point\u201d upon which the design can flex. Dif-\nferent implementations of the server can be bound to an unsuspecting client.\n1.\n[GOF96]\nFigure 2-30\nAbstract Server\nConsumer\nResource\nManager\n\u00abinterface\u00bb\nResource\nManager_I\n", "page": 28, "type": "text", "section": "Page 28"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n29\nAdapter\nWhen inserting an abstract interface is infeasible because the server is third party soft-\nware, or is so heavily depended upon that it cannot easily be changed, an ADAPTER \ncan be used to bind the abstract interface to the server. See Figure 2-31.\nThe adapter is an object that implements the abstract interface to delegate to the \nserver. Every method of the adpater simply translates and then delegates.\nObserver\nIt often occurs that one element of a design needs to take some form of action when \nanother element in the design discovers that an event has occurred. However, we fre-\nquently don\u2019t want the detector to know about the actor.\nConsider the case of a meter that shows the status of a sensor. Every time the sensor \nchanges its reading we want the meter to display the new value. However, we don\u2019t \nwant the sensor to know anything about the meter.\nWe can address this situation with an OBSERVER, see Figure 2-32. The Sensor \nderives from a class named Subject, and Meter derives from an interface called \nObserver. Subject contains a list of Observers. This list is loaded by the \nRegsiter method of Subject. In order to be told of events, our Meter must reg-\nister with the Subject base class of the Sensor.\nFigure 2-33 describes the dynamics of the collaboration. Some entity passes control \nto the Sensor who determines that its reading has changed. The Sensor calls \nNotify on its Subject. The Subject then cycles through all the Observers \nFigure 2-31\nAdapter\nConsumer\nResource\nManager\n\u00abinterface\u00bb\nResource\nManager_I\nResource\nManager\nAdapter\n", "page": 29, "type": "text", "section": "Page 29"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n30\nthat have been registered, calling Update on each. The Update message is caught \nby the Meter who uses it to read the new value of the Sensor and display it.\nBridge\nOne of the problems with implementing an abstract class with inheritance is that the \nderived class is so tightly coupled to the base class. This can lead to problems when \nother clients want to use the derived class functions without dragging along the bag-\ngage of the base hiearchy.\nFigure 2-32\nObserver Structure\nFigure 2-33\n+ Check()\n+ GetValue() : double\nSensor\n+ Update()\nMeter\nSubject\n+ Update\nObserver\n*\n\u00abinterface\u00bb\n+ Register(Observer*)\n+ Notify\nSensor\nMeter\nCheck\nSubject\nNotify\nUpdate\nObserver\nGetValue\nValue\n", "page": 30, "type": "text", "section": "Page 30"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n31\nFor example, consider a music synthesizer class. The base class translates MIDI input \ninto a set of primitive EmitVoice calls that are implemented by a derived class. \nNote that the EmitVoice function of the derived class would be useful, in and of \nitself. Unforunately it is inextricably bound to the MusicSynthesizer class and \nthe PlayMidi function. There is no way to get at the PlayVoice method without \ndragging the base class around with it. Also, there is no way to create different imple-\nmentations of the PlayMidi function that use the same EmitVoice function. In \nshort, the hiearchy is just to coupled.\nThe BRIDGE pattern solves this problem by creating a strong seperation between the \ninterface and implementation. Figure 2-35 shows how this works. The \nMusicSynthesizer class contains an abstract PlayMidi function which is \nimplemented by MusicSynthesizer_I. It calls the EmitVoice function that is \nimplemented in MusicSynthesizer to delegate to the VoiceEmitter inter-\nface. This interface is implemented by VoiceEmitter_I and emits the necessary \nsounds.\nNow it is possible to implement both EmitVoice and PlayMidi separately from \neach other. The two functions have been decoupled. EmitVoice can be called with-\nout bringing along all the MusicSynthesizer baggage, and PlayMidi can be \nimplemented any number of different ways, while still using the same EmitVoice \nfunction.\nFigure 2-34\nBadly coupled hierarchy\nMusic\nSynthesizer\n{abstract}\n+ PlayMidi\n- EmitVoice\n+ EmitVoice\nMusic\nSynthesizer_I\n", "page": 31, "type": "text", "section": "Page 31"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n32\nAbstract Factory\nThe DIP strongly recommends that modules not depend upon concrete classes. How-\never, in order ot create an instance of a class, you must depend upon the concrete \nclass. ABSTRACTFACTORY is a pattern that allows that dependency upon the concrete \nclass to exist in one, and only one, place. \nFigure 2-36 shows how this is accomplished for the Modem example. All the users \nwho wish to create modems use an interface called ModemFactory. A pointer to \nthis interface is held in a global variable named GtheFactory. The users call the \nMake function passing in a string that uniquely defines the particular subclass of \nModem that they want. The Make function returns a pointer to a Modem interface.\nThe ModemFactory interface it implemented by ModemFactory_I. This class is \ncreated by main, and a pointer to it is loaded into the GtheFactory global. Thus, \nno module in the system knows about the concrete modem classes except for \nModemFactory_I, and no module knows about ModemFactory_I except for \nmain.\nConclusion\nThis chapter has introduced the concept of object oriented architecture and defined it \nas the structure of classes and packages that keeps the software application flexible, \nrobust, reusable, and developable. The principles and patterns presented here support \nFigure 2-35\nHierarchy decoupled with Bridge\nMusic\nSynthesizer\n{abstract}\n+ PlayMidi\n- EmitVoice\n- PlayMidi\nMusic\nSynthesizer_I\n+ EmitVoice\nVoice Emitter\n\u00abinterface\u00bb\nVoice\nEmitter_I\n", "page": 32, "type": "text", "section": "Page 32"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n33\nsuch architectures, and have been proven over time to be powerful aids in software \narchitecture.\nThis has been an overview. There is much more to be said about the topic of OO \narchitecture than can be said in the few pages of this chapter, indeed by foreshorten-\ning the topic so much, we have run the risk of doing the reader a disservice. It has \nbeen said that a little knowledge is a dangerous thing, and this chapter has provided a \nlittle knowledge. We strongly urge you to search out the books and papers in the cit-\nings of this chapter to learn more.\nBibliography\n[Shaw96]:  Patterns of Software Architecture (???), Garlan and Shaw, ...\n[GOF96]:  Design Patterns...\n[OOSC98]:  OOSC...\nFigure 2-36\nAbstract Factory\n+ Make(string) : Modem*\nModem\nFactory\n\u00abinterface\u00bb\nUsers\nGtheFactory\n\u00abglobal\u00bb\nModem\nFactory_I\nmain\n\u00abmain program\u00bb\n\u00abcreates\u00bb\nHayes\nCourrier\nErnie\nModem\n\u00abinterface\u00bb\n\u00abcreates\u00bb\n", "page": 33, "type": "text", "section": "Page 33"}
{"text": "Robert C. Martin\nCopyright (c) 2000 by Robert C. Martin. All Rights Reserved.\nwww.objectmentor.com\n34\n[OCP97]:  The Open Closed Principle, Robert C. Martin...\n[LSP97]:  The Liskov Substitution Principle, Robert C. Martin\n[DIP97]:  The Dependency Inversion Principle, Robert C. Martin\n[ISP97]:  The Interface Segregation Principle, Robert C. Martin\n[Granularity97]:  Granularity, Robert C. Martin\n[Stability97]:  Stability, Robert C. Martin\n[Liksov88]:  Data Abstraction and Hierarchy...\n[Martin99]:  Designing Object Oriented Applications using UML, 2d. ed., Robert C. \nMartin, Prentice Hall, 1999.\n", "page": 34, "type": "text", "section": "Page 34"}
