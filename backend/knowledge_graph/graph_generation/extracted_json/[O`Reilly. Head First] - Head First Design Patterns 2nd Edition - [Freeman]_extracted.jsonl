{"text": "\n.5\u201d \nA Brain-Friendly Guide\nBrain-Friendly Guide\nSecond\nEdition\nDesign \nPatterns\nBuilding Extensible \n& Maintainable \nObject-Oriented \nSoftware\nEric Freeman & \nElisabeth Robson\nwith Kathy Sierra & Bert Bates\n", "page": 1, "type": "text", "section": "Page 1"}
{"text": "Praise for Head First Design Patterns\n\u201cI received the book yesterday and started to read it on the way home\u2026and I couldn\u2019t stop.  I took it to \nthe gym and I expect people saw me smiling a lot while I was exercising and reading. This is tr\u00e8s \u2018cool\u2019. \nIt is fun, but they cover a lot of ground and they are right to the point.  I\u2019m really impressed.\u201d\n\t\n   \u2014  Erich Gamma, IBM Distinguished Engineer\n\t\n         and coauthor of Design Patterns with the rest of the\n\t\n         Gang of Four\u2014Richard Helm, Ralph Johnson, and John Vlissides\n\u201cHead First Design Patterns manages to mix fun, belly-laughs, insight, technical depth, and great practical \nadvice in one entertaining and thought-provoking read. Whether you are new to Design Patterns or have \nbeen using them for years, you are sure to get something from visiting Objectville.\u201d\n\t\n   \u2014  Richard Helm, coauthor of Design Patterns with the rest of the \n                       Gang of Four\u2014Erich Gamma, Ralph Johnson, and John Vlissides\n \u201cI feel like a thousand pounds of books have just been lifted off of my head.\u201d\n\t\n   \u2014  Ward Cunningham, inventor of the Wiki \n\t\n         and founder of the Hillside Group\n\u201cThis book is close to perfect, because of the way it combines expertise and readability. It speaks with \nauthority and it reads beautifully. It\u2019s one of the very few software books I\u2019ve ever read that strikes me as \nindispensable. (I\u2019d put maybe 10 books in this category, at the outside.)\u201d\n\t\n   \u2014  David Gelernter, Professor of Computer Science,  Yale University, \n\t\n         and author of Mirror Worlds and Machine Beauty\n\u201cA Nose Dive into the realm of patterns, a land where complex things become simple, but where simple \nthings can also become complex. I can think of no better tour guides than Eric and Elisabeth.\u201d\n\t\n   \u2014  Miko Matsumura, Industry Analyst, The Middleware Company\n\t\n         Former Chief Java Evangelist, Sun Microsystems\n\u201cI laughed, I cried, it moved me.\u201d\n\t\n   \u2014  Daniel Steinberg, Editor-in-Chief, java.net\n\u201cMy first reaction was to roll on the floor laughing. After I picked myself up, I realized that not only is the \nbook technically accurate, it is the easiest-to-understand introduction to Design Patterns that I have seen.\u201d\n\t\n   \u2014  Dr. Timothy A. Budd, Associate Professor of Computer Science at \n\t\n        Oregon State University and author of more than a dozen books, \n\t\n        including C++ for Java Programmers\n\u201cJerry Rice runs patterns better than any receiver in the NFL, but Eric and Elisabeth have outrun him. \nSeriously\u2026this is one of the funniest and smartest books on software design I\u2019ve ever read.\u201d\n\t\n   \u2014 Aaron LaBerge, SVP Technology & Product Development, ESPN\n", "page": 3, "type": "text", "section": "Page 3"}
{"text": "\u201cGreat code design is, first and foremost, great information design. A code designer is teaching a \ncomputer how to do something, and it is no surprise that a great teacher of computers should turn out \nto be a great teacher of programmers. This book\u2019s admirable clarity, humor, and substantial doses of \nclever make it the sort of book that helps even non-programmers think well about problem-solving.\u201d\n\t\n   \u2014 Cory Doctorow, coeditor of Boing Boing \n\t\n        and author of Down and Out in the Magic Kingdom\n\t\n        and Someone Comes to Town, Someone Leaves Town\n\u201cThere\u2019s an old saying in the computer and videogame business\u2014well, it can\u2019t be that old because the \ndiscipline is not all that old\u2014and it goes something like this: Design is Life. What\u2019s particularly curious \nabout this phrase is that even today almost no one who works at the craft of creating electronic games \ncan agree on what it means to \u2018design\u2019 a game. Is the designer a software engineer? An art director?  A \nstoryteller? An architect or a builder? A pitch person or a visionary? Can an individual indeed be in \npart all of these? And most importantly, who the %$!#&* cares?\n It has been said that the \u2018designed by\u2019 credit in interactive entertainment is akin to the \u2018directed by\u2019 \ncredit in filmmaking, which in fact allows it to share DNA with perhaps the single most controversial, \noverstated, and too often entirely lacking in humility credit grab ever propagated on commercial art.  \nGood company, eh?  Yet if Design is Life, then perhaps it is time we spent some quality cycles thinking \nabout what it is.   \n Eric Freeman and Elisabeth Robson have intrepidly volunteered to look behind the code curtain for \nus in Head First Design Patterns.  I\u2019m not sure either of them cares all that much about the PlayStation \nor Xbox, nor should they. Yet they do address the notion of design at a significantly honest level such \nthat anyone looking for ego reinforcement of his or her own brilliant auteurship is best advised not to \ngo digging here where truth is stunningly revealed.  Sophists and circus barkers need not apply. Next-\ngeneration literati, please come equipped with a pencil.\u201d\n\t\n   \u2014  Ken Goldstein, Executive Vice President & Managing Director, \n                      Disney Online\n\n\u201cThis is a difficult blurb for me to write since Eric and Elisabeth were my students a long time ago, so \nI don\u2019t want to be seen to be too drooling, but this is the best book on Design Patterns available for \nstudents. As proof: I have used it ever since it was published, in both in my grad and undergrad courses, \nboth for software engineering and advanced programming. As soon as it came out I abandoned the \nGang of Four as well as all competitors!\u201d\n\t\n   \u2014  Gregory Rawlins, Indiana University\n\n\u201cThis book combines good humor, great examples, and in-depth knowledge of Design Patterns in \nsuch a way that makes learning fun. Being in the entertainment technology industry, I am intrigued \nby the Hollywood Principle and the home theater Facade Pattern, to name a few. The understanding \nof Design Patterns not only helps us create reusable and maintainable quality software, but also \nhelps sharpen our problem-solving skills across all problem domains. This book is a must-read for all \ncomputer professionals and students.\u201d\n\t\n   \u2014  Newton Lee, Founder and Editor-in-Chief, Association for Computing \n\t\n        Machinery\u2019s (ACM) Computers in Entertainment (acmcie.org)\nMore Praise for Head First Design Patterns\n", "page": 4, "type": "text", "section": "Page 4"}
{"text": "Praise for other books by Eric Freeman and Elisabeth Robson\n\u201cI literally love this book. In fact, I kissed this book in front of my wife.\u201d\n\t\n   \u2014 Satish Kumar\n\u201cHead First HTML and CSS is a thoroughly modern introduction to forward-looking practices in web \npage markup and presentation. It correctly anticipates readers\u2019 puzzlements and handles them just in \ntime. The highly graphic and incremental approach precisely mimics the best way to learn this stuff: \nmake a small change and see it in the browser to understand what each new item means.\u201d\n\t\n   \u2014 Danny Goodman, author of Dynamic HTML: The Definitive Guide\n\u201cThe Web would be a much better place if every HTML author started off by reading this book.\u201d\n\t\n   \u2014 L. David Baron, Technical Lead, Layout & CSS, Mozilla Corporation\n                     http://dbaron.org\n\n\u201cMy wife stole the book. She\u2019s never done any web design, so she needed a book like Head First HTML \nand CSS to take her from beginning to end. She now has a list of websites she wants to build\u2014for our \nson\u2019s class, our family\u2026If I\u2019m lucky, I\u2019ll get the book back when she\u2019s done.\u201d\n\t\n   \u2014 David Kaminsky, Master Inventor, IBM\n\n\u201cThis book takes you behind the scenes of JavaScript and leaves you with a deep understanding of \nhow this remarkable programming language works. I wish I\u2019d had Head First JavaScript Programming \nwhen I was starting out!\u201d\n\t\n   \u2014 Chris Fuselier, engineering consultant\n\n\u201cThe Head First series utilizes elements of modern learning theory, including constructivism, to bring \nreaders up to speed quickly. The authors have proven with this book that expert-level content can be \ntaught quickly and efficiently. Make no mistake here, this is a serious JavaScript book, and yet, fun \nreading!\u201d\n\t\n   \u2014 Frank Moore, web designer and developer\n\n\u201cLooking for a book that will keep you interested (and laughing) but teach you some serious programming \nskills? Head First JavaScript Programming is it!\u201d\n\t\n   \u2014 Tim Williams, software entrepreneur\n", "page": 5, "type": "text", "section": "Page 5"}
{"text": "Other related books from O\u2019Reilly\nHead First Java\nLearning Java\nJava in a Nutshell\nJava Enterprise in a Nutshell\nJava Examples in a Nutshell\nJava Cookbook\nJ2EE Design Patterns\nOther O\u2019Reilly books by Eric Freeman and Elisabeth Robson\nHead First Learn to Code\nHead First JavaScript Programming\nHead First HTML and CSS\nHead First HTML5 Programming\n", "page": 6, "type": "text", "section": "Page 6"}
{"text": "Beijing  \u2022  Boston  \u2022  Farnham  \u2022  Sebastopol  \u2022  Tokyo\nEric Freeman \nElisabeth Robson\nHead First \nDesign Patterns\nWouldn\u2019t it be dreamy \nif there was a Design Patterns \nbook that was more fun than \ngoing to the dentist, and more \nrevealing than an IRS form? It\u2019s \nprobably just a fantasy\u2026\n", "page": 7, "type": "text", "section": "Page 7"}
{"text": "Head First Design Patterns, 2nd Edition\nby Eric Freeman, Elisabeth Robson, Kathy Sierra, and Bert Bates\nCopyright \u00a9 2021 Eric Freeman and Elisabeth Robson. All rights reserved.\nPrinted in Canada.\nPublished by O\u2019Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\nO\u2019Reilly Media books may be purchased for educational, business, or sales promotional use. Online \neditions are also available for most titles (oreilly.com). For more information, contact our corporate/\ninstitutional sales department: (800) 998-9938 or corporate@oreilly.com.\nEditors 1st Edition:   Mike Hendrickson, Mike Loukides\nEditors 2nd Edition:  Michele Cronin, Melissa Duffield\nCover Designer: \t\n  Ellie Volckhausen\nPattern Wranglers: \t  Eric Freeman, Elisabeth Robson\nPrinting History:\nOctober 2004: First edition\nDecember 2020: Second edition\nRelease History:\n2020-11-10  First release\nThe O\u2019Reilly logo is a registered trademark of O\u2019Reilly Media, Inc. Java and all Java-based trademarks and logos \nare trademarks or registered trademarks of Sun Microsystems, Inc., in the United States and other countries. \nO\u2019Reilly Media, Inc. is independent of Sun Microsystems.\nMany of the designations used by manufacturers and sellers to distinguish their products are claimed as \ntrademarks.\nWhere those designations appear in this book, and O\u2019Reilly Media, Inc. was aware of a trademark claim, the \ndesignations have been printed in caps or initial caps.\nWhile every precaution has been taken in the preparation of this book, the publisher and the authors assume no \nresponsibility for errors or omissions, or for damages resulting from the use of the information contained herein.\nIn other words, if you use anything in Head First Design Patterns to, say, run a nuclear power plant, you\u2019re on your \nown. We do, however, encourage you to use the DJ View app.\nNo ducks were harmed in the making of this book.\nThe original GoF agreed to have their photos in this book. Yes, they really are that good-looking. \nISBN: 978-1-492-07800-5\n[MBP]\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n", "page": 8, "type": "text", "section": "Page 8"}
{"text": "To the Gang of Four, whose insight and expertise in \ncapturing and communicating Design Patterns has \nchanged the face of software design forever, and \nbettered the lives of developers throughout the world.\nBut seriously, when are we going to see a second edition? \nAfter all, it\u2019s been only ten years.\ntwenty-five\n", "page": 9, "type": "text", "section": "Page 9"}
{"text": "viii \nthe authors\nAuthors of Head First Design Patterns\nElisabeth is a software engineer, writer, \nand trainer. She has been passionate \nabout technology since her days as a \nstudent at Yale University, where she \nearned a Masters of Science in Computer \nScience. \nShe\u2019s currently cofounder of \nWickedlySmart, where she creates books, \narticles, videos, and more. Previously, as \nDirector of Special Projects at O\u2019Reilly \nMedia, Elisabeth produced in-person \nworkshops and online courses on a variety \nof technical topics and developed her \npassion for creating learning experiences \nto help people understand technology. \nWhen not in front of her computer, you\u2019ll \nfind Elisabeth hiking, cycling, kayaking, \nand gardening in the great outdoors, \noften with her camera nearby.\nEric Freeman\nEric is described by Head First series co-\ncreator Kathy Sierra as \u201cone of those rare \nindividuals fluent in the language, practice, \nand culture of multiple domains from \nhipster hacker, corporate VP\n, engineer, \nthink tank.\u201d\nBy training, Eric is a computer scientist, \nhaving earned his PhD at Yale University. \nProfessionally, Eric was formerly CTO of \nDisney Online & Disney.com at the Walt \nDisney Company. \nEric now co-directs the Head First series \nand devotes his time to creating print and \nvideo content at WickedlySmart, which is \ndistributed across the leading educational \nchannels.\nEric\u2019s Head First titles include Head First \nDesign Patterns, Head First HTML & CSS, \nHead First JavaScript Programming, Head First \nHTML5 Programming, and Head First Learn \nto Code.\nEric lives in Austin, Texas.\nElisabeth Robson\n", "page": 10, "type": "text", "section": "Page 10"}
{"text": "ix\nCreators of the Head First Series\nKathy Sierra\nKathy has been interested in learning theory \nsince her days as a game designer  for Virgin, \nMGM, and Amblin\u2019, and a teacher of New \nMedia Authoring at UCLA. She was a master \nJava trainer for Sun Microsystems, and she \nfounded JavaRanch.com (now CodeRanch.com), \nwhich won Jolt Cola Productivity awards in \n2003 and 2004.\nIn 2015, she won the Electronic Frontier \nFoundation\u2019s Pioneer Award for her work \ncreating skillful users and building sustainable \ncommunities.\nKathy\u2019s recent focus has been on cutting-edge, \nmovement science and skill acquisition coaching, \nknown as ecological dynamics or \u201cEco-D.\u201d \nHer work using Eco-D for training horses is \nushering in a far, far more humane approach \nto horsemanship, causing delight for some (and \nsadly, consternation for others). Those fortunate \n(autonomous!) horses whose owners are using \nKathy\u2019s approach are happier, healthier, and \nmore athletic than their fellows who are \ntraditionally trained.\nYou can follow Kathy on Instagram: \n@pantherflows.\nBert Bates\nBefore Bert was an author, he was a developer, \nspecializing in old-school AI (mostly expert \nsystems), real-time OSes, and complex \nscheduling systems.\nIn 2003, Bert and Kathy wrote Head First Java \nand launched the Head First series. Since then, \nhe\u2019s written more Java books, and consulted \nwith Sun Microsystems and Oracle on many \nof their Java certifications. He\u2019s also trained \nhundreds of authors and editors to create books \nthat teach well.\nBert\u2019s a Go player, and in 2016 he watched in \nhorror and fascination as AlphaGo trounced \nLee Sedol. Recently he\u2019s been using Eco-D \n(ecological dynamics) to improve his golf game \nand to train his parrotlet Bokeh.\nBert and Kathy have been privileged to know \nBeth and Eric for 16 years now, and the Head \nFirst series is extremely fortunate to count them \nas key contributors.\nYou can send Bert a message at CodeRanch.com.\n", "page": 11, "type": "text", "section": "Page 11"}
{"text": "Intro\nYour brain on Design Patterns.  Here you are trying to learn something, \nwhile here your brain is doing you a favor by making sure the learning doesn\u2019t stick.  Your \nbrain\u2019s thinking, \u201cBetter leave room for more important things, like which wild animals to \navoid and whether naked snowboarding is a bad idea.\u201d  So how do you trick your brain into \nthinking that your life depends on knowing Design Patterns? \nWho is this book for?\t\n\t\n\t\n\t\n\t\nxxvi\nWe know what you\u2019re thinking.\t\n\t\n\t\n\t\nxxvii\nAnd we know what your brain is thinking.\t\n\t\n\t\nxxvii\nWe think of a \u201cHead First\u201d reader as a learner.\t\n\t\n\t\nxxviii\nMetacognition: thinking about thinking\t\t\n\t\n\t\nxxix\nHere\u2019s what WE did\t\n\t\n\t\n\t\n\t\nxxx\nHere\u2019s what YOU can do to bend your brain into submission\t\nxxxi\nRead Me\t\t\n\t\n\t\n\t\n\t\n\t\nxxxii\nTech Reviewers\t\n\t\n\t\n\t\n\t\n\t\nxxxiv\nAcknowledgments\t \t\n\t\n\t\n\t\n\t\nxxxv\nTable of Contents (summary)\n          Intro\t\nxxv\n1 \t\nWelcome to Design Patterns:  intro to Design Patterns\t\n1\n2\t\nKeeping your Objects in the Know:  the Observer Pattern\t\n37\n3\t\nDecorating Objects:  the Decorator Pattern\t\n79\n4\t\nBaking with OO Goodness:  the Factory Pattern\t\n109\n5\t\nOne-of-a-Kind Objects:  the Singleton Pattern\t\n169\n6\t\nEncapsulating Invocation:  the Command Pattern\t\n191\n7\t\nBeing Adaptive:  the Adapter and Facade Patterns\t\n237\n8\t\nEncapsulating Algorithms:  theTemplate Method Pattern\t\n277\n9\t\nWell-Managed Collections:  the Iterator and Composite Patterns\t\n317\n10\t\nThe State of Things:  the State Pattern\t\n381\n11\t\nControlling Object Access:  the Proxy Pattern\t\n425\n12\t\nPatterns of Patterns: compound patterns\t\n493\n13\t\nPatterns in the Real World: better living with patterns\t\n563\n14\t\nAppendix:  Leftover Patterns\t\n597\n\t\nTable of Contents (the real thing)\ntable of contents\n", "page": 12, "type": "text", "section": "Page 12"}
{"text": "1\nWelcome to Design Patterns\nSomeone has already solved your problems. In this \nchapter, you\u2019ll learn why (and how) you can exploit the wisdom and lessons \nlearned by other developers who\u2019ve been down the same design problem road \nand survived the trip. Before we\u2019re done, we\u2019ll look at the use and benefits \nof design patterns, look at some key object-oriented (OO) design principles, \nand walk through an example of how one pattern works. The best way to use \npatterns is to load your brain with them and then recognize places in your \ndesigns and existing applications where you can apply them. Instead of code \nreuse, with patterns you get experience reuse.\nintro to Design Patterns\nYour BRAIN\nYour Code, now new \nand improved with \ndesign patterns!\nA Bunch of Patterns\nswim()\ndisplay()\nperformQuack()\nperformFly()\nsetFlyBehavior()\nsetQuackBehavior()\n// OTHER duck-like methods\u2026\nDuck\nFlyBehavior flyBehavior;\nQuackBehavior quackBehavior;\n<<interface>>\nFlyBehavior\nfly()\nfly() {\n  // implements duck flying\n}\nFlyWithWings\nfly() {\n  // do nothing - can\u2019t fly!\n}\nFlyNoWay\n<<interface>>\nQuackBehavior\nquack()\nquack) {\n  // implements duck quack\u00ad\ning\n}\nQuack\nquack() {\n  // rubber duckie squeak\n}\nSqueak\nquack() {\n  // do nothing - can\u2019t quack!\n}\nMuteQuack\ndisplay() {\n// looks like a decoy duck }\nDecoy Duck\ndisplay() {\n// looks like a mal\u00ad\nlard }\nMallard Duck\ndisplay() {\n// looks like a redhead \n}\nRedhead Duck\ndisplay() {\n// looks like a rubberduck }\nRubber Duck\nEncapsulated fly behavior\nEncapsulated quack behavior\nClient \nView\nController\nModel\nRequest\nMVC\nS\nu\nb\nj\ne\nc\nt\n \nOb\nj\ne\nc\nt\n8\nint\n \n \n \nD\no\ng\n \nO\nb\nj\ne\nc\nt\nM\no\nu\ns\ne\n \nO\nb\njec\nt\n \n \nC\na\nt\n \nO\nb\nj\ne\nct\n \n \nD\nu\nc\nk\n \nO\nb\njec\nt\nObservers\n8\n8\n8\n8\nAutomatic update/notification\nObject that \nholds state\nDependent Objects\nOBSERVER\nRemember, knowing \nconcepts like abstraction, \ninheritance, and polymorphism do \nnot make you a good object oriented \ndesigner.  A design guru thinks \nabout how to create flexible \ndesigns that are maintainable \nand that can cope with \nchange.\nIt started with a simple SimUDuck app\t\t\n\t\n2\nBut now we need the ducks to FLY\t\n\t\n\t\n3\nBut something went horribly wrong\u2026\t \t\n\t\n4\nJoe thinks about inheritance\u2026\t\n\t\n\t\n5\nHow about an interface?\t\n\t\n\t\n\t\n6\nWhat would you do if you were Joe?\t\n\t\n\t\n7\nThe one constant in software development\t\n\t\n8\nZeroing in on the problem\u2026\t\t\n\t\n\t\n9\nSeparating what changes from what stays the same\t\n10\nDesigning the Duck Behaviors\t\n\t\n\t\n11\nImplementing the Duck Behaviors\t\n\t\n\t\n13\nIntegrating the Duck Behavior\t\n\t\n\t\n15\nTesting the Duck code\t\n\t\n\t\n\t\n18\nSetting behavior dynamically\t\t\n\t\n\t\n20\nThe Big Picture on encapsulated behaviors\t\n\t\n22\nHAS-A can be better than IS-A\t\n\t\n\t\n23\nSpeaking of Design Patterns\u2026\t\n\t\n\t\n24\nOverheard at the local diner\u2026\t\n\t\n\t\n26\nOverheard in the next cubicle\u2026\t\n\t\n\t\n27\nThe power of a shared pattern vocabulary\t\n\t\n28\nHow do I use Design Patterns?\t\n\t\n\t\n29\nTools for your Design Toolbox\t\n\t\n\t\n32\n", "page": 13, "type": "text", "section": "Page 13"}
{"text": "The Weather Monitoring application overview\t\n\t\n\t\n39\nMeet the Observer Pattern\t\n\t\n\t\n\t\n\t\n44\nPublishers + Subscribers = Observer Pattern\t\n\t\n\t\n45\nThe Observer Pattern defined\t\n\t\n\t\n\t\n51\nThe Power of Loose Coupling\t\n\t\n\t\n\t\n54\nDesigning the Weather Station\t\n\t\n\t\n\t\n57\nImplementing the Weather Station\t\n\t\n\t\n\t\n58\nPower up the Weather Station\t\n\t\n\t\n\t\n61\nLooking for the Observer Pattern in the Wild\t\n\t\n\t\n65\nCoding the life-changing application\t\n\t\n\t\n\t\n66\nMeanwhile, back at Weather-O-Rama\t \t\n\t\n\t\n69\nTest Drive the new code\t\n\t\n\t\n\t\n\t\n71\nTools for your Design Toolbox\t\n\t\n\t\n\t\n72\nDesign Principle Challenge\t\n\t\n\t\n\t\n\t\n73\n2\nKeeping your Objects in the Know\nYou don\u2019t want to miss out when something \ninteresting happens, do you? We\u2019ve got a pattern that keeps your \nobjects in the know when something they care about happens. It\u2019s the Observer \nPattern. It is one of the most commonly used design patterns, and it\u2019s incredibly \nuseful. We\u2019re going to look at all kinds of interesting aspects of Observer, like its \none-to-many relationships and loose coupling. And, with those concepts in mind, \nhow can you help but be the life of the Patterns Party? \nthe Observer Pattern\nS\nu\nb\nj\ne\nc\nt\n \nOb\nj\ne\nc\nt\n8\nint\n \n \n \nD\no\ng\n \nO\nb\nj\ne\nc\nt\nM\no\nu\ns\ne\n \nO\nb\njec\nt\n \n \nC\na\nt\n \nO\nb\nj\ne\nct\n \n \nD\nu\nc\nk\n \nO\nb\njec\nt\nObservers\n8\n8\n8\n8\nONE TO MANY RELATIONSHIP\nAutomatic update/notification\nObject that \nholds state\nDependent Objects\nAbstraction\nEncapsulation\nPolymorphism\nInheritence\nOO Basics\nEncapsulate what varies.\nFavor Composition over \ninheritance.\nProgram to interfaces, not \nimplementations.\nStrive for loosely coupled \ndesigns between objects that \ninteract.\nOO Principles\ntable of contents\n", "page": 14, "type": "text", "section": "Page 14"}
{"text": "3\nDecorating Objects\nJust call this chapter \u201cDesign Eye for the Inheritance \nGuy.\u201d We\u2019ll re-examine the typical overuse of inheritance and you\u2019ll learn how \nto decorate your classes at runtime using a form of object composition. Why? \nOnce you know the techniques of decorating, you\u2019ll be able to give your (or \nsomeone else\u2019s) objects new responsibilities without making any code changes \nto the underlying classes.\nthe Decorator Pattern\nI used to think real men \nsubclassed everything. That was until \nI learned the power of extension \nat runtime, rather than at compile \ntime.  Now look at me!\nWelcome to Starbuzz Coffee\t \t\n\t\n\t\n80\nThe Open-Closed Principle\t \t\n\t\n\t\n86\nMeet the Decorator Pattern\t \t\n\t\n\t\n88\nConstructing a drink order with Decorators\t\n\t\n89\nThe Decorator Pattern defined\t\n\t\n\t\n91\nDecorating our Beverages\t\n\t\n\t\n\t\n92\nWriting the Starbuzz code\t\n\t\n\t\n\t\n95\nCoding beverages\t \t\n\t\n\t\n\t\n96\nCoding condiments\t\t\n\t\n\t\n\t\n97\nServing some coffees\t\n\t\n\t\n\t\n98\nReal-World Decorators: Java I/O\t\n\t\n\t\n100\nDecorating the java.io classes\t\t\n\t\n\t\n101\nWriting your own Java I/O Decorator\t \t\n\t\n102\nTest out your new Java I/O Decorator\t \t\n\t\n103\nTools for your Design Toolbox\t\n\t\n\t\n105\n", "page": 15, "type": "text", "section": "Page 15"}
{"text": "4\nBaking with OO Goodness\nGet ready to bake some loosely coupled OO designs. \nThere is more to making objects than just using the new operator. You\u2019ll \nlearn that instantiation is an activity that shouldn\u2019t always be done in public \nand can often lead to coupling problems. And we don\u2019t want that, do we? \nFind out how Factory Patterns can help save you from embarrassing \ndependencies.\nthe Factory Pattern\n<<interface>>\nClams\n<<interface>>\nCheese\n<<interface>>\nSauce\n<<interface>>\nDough\ncreatePizza()\nNYPizzaStore\nThinCrustDough\nMarinaraSauce\nReggianoCheese\nFrozenClams\nThickCrustDough\nPlumTomatoSauce\nMozzarella Cheese\nFreshClams\nEach factory produces a different \nimplementation for the family of products.\nThe abstract PizzaIngredientFactory \nis the interface that defines how to \nmake a family of related products- \neverything we need to make a pizza.\nThe clients of the Abstract \nFactory are the two \ninstances of our PizzaStore, \nNYPizzaStore and \nChicagoStylePizzaSore. \nThe job of the concrete \npizza factories is to \nmake pizza ingredients.  \nEach factory knows \nhow to create the right \nobjects for their region.\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\n<<interface>>\nPizzaIngredientFactory\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\nNYPizzaIngredientFactory\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\nChicagoPizzaIngredientFactory\nIdentifying the aspects that vary\t\n\t\n\t\n\t\n112\nEncapsulating object creation\t\t\n\t\n\t\n\t\n114\nBuilding a simple pizza factory\t\n\t\n\t\n\t\n115\nThe Simple Factory defined\t \t\n\t\n\t\n\t\n117\nA framework for the pizza store\t\n\t\n\t\n\t\n120\nAllowing the subclasses to decide\t\n\t\n\t\n\t\n121\nDeclaring a factory method\t \t\n\t\n\t\n\t\n125\nIt\u2019s finally time to meet the Factory Method Pattern\t\n\t\n131\nView Creators and Products in Parallel\t \t\n\t\n\t\n132\nFactory Method Pattern defined\t\n\t\n\t\n\t\n134\nLooking at object dependencies\t\n\t\n\t\n\t\n138\nThe Dependency Inversion Principle\t\n\t\n\t\n\t\n139\nApplying the Principle\t\n\t\n\t\n\t\n\t\n140\nFamilies of ingredients\u2026\t\n\t\n\t\n\t\n\t\n145\nBuilding the ingredient factories\t\n\t\n\t\n\t\n146\nReworking the pizzas\u2026\t\n\t\n\t\n\t\n\t\n149\nRevisiting our pizza stores\t\n\t\n\t\n\t\n\t\n152\nWhat have we done?\t\n\t\n\t\n\t\n\t\n153\nAbstract Factory Pattern defined\t\n\t\n\t\n\t\n156\nFactory Method and Abstract Factory compared\t \t\n\t\n160\nTools for your Design Toolbox\t\n\t\n\t\n\t\n162\ntable of contents\n", "page": 16, "type": "text", "section": "Page 16"}
{"text": "5\nOne-of-a-Kind Objects\nOur next stop is the Singleton Pattern, our ticket to \ncreating one-of-a-kind objects for which there is only \none instance, ever.  You might be happy to know that of all patterns, \nthe Singleton is the simplest in terms of its class diagram; in fact, the diagram \nholds just a single class! But don\u2019t get too comfortable; despite its simplicity \nfrom a class design perspective, it\u2019s going to require some deep object-oriented \nthinking in its implementation. So put on that thinking cap, and let\u2019s get going.\nthe Singleton Pattern\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable.  Strategy lets the algorithm \nvary independently from clients that use it.\nOO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically.  \nDecorators provide a flexible \nalternative to subclassing for extending \nfunctionality.\nAbstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes.\nFactory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate.  Factory Method lets \na class defer instantiation to the \nsubclasses.\nSingleton - Ensure a class only has \none instance and provide a global point \nof access to it.\nDissecting the classic Singleton Pattern implementation\t\n\t\n173\nThe Chocolate Factory\t\n\t\n\t\n\t\n\t\n175\nSingleton Pattern defined\t\n\t\n\t\n\t\n\t\n177\nHouston, we have a problem\t \t\n\t\n\t\n\t\n178\nDealing with multithreading\t \t\n\t\n\t\n\t\n180\nCan we improve multithreading?\t\n\t\n\t\n\t\n181\nMeanwhile, back at the Chocolate Factory\u2026\t\n\t\n\t\n183\nTools for your Design Toolbox\t\n\t\n\t\n\t\n186\nHershey, PA\n", "page": 17, "type": "text", "section": "Page 17"}
{"text": "6\nEncapsulating Invocation\nIn this chapter, we take encapsulation to a whole new \nlevel: we\u2019re going to encapsulate method invocation. \nThat\u2019s right\u2014by encapsulating method invocation, we can crystallize pieces \nof computation so that the object invoking the computation doesn\u2019t need to \nworry about how to do things, it just uses our crystallized method to get it \ndone. We can also do some wickedly smart things with these encapsulated \nmethod invocations, like save them away for logging or reuse them to \nimplement undo functionality in our code. \nthe Command Pattern\nI\u2019ll have a Burger \nwith Cheese and a Malt \nShake\nBurger with Cheese\n  Malt Shake\ncreateOrder()\ntakeOrder()\nBurger with Cheese\n  Malt Shake\norderUp()\nmakeBurger(), makeShake()\noutput\nThe Order consists of an order \nslip and the customer\u2019s menu \nitems that are written on it.\nThe customer knows \nwhat he wants and \ncreates an order.\nThe Waitress takes the Order, and when she \ngets around to it, she calls its orderUp() \nmethod to begin the Order\u2019s preparation.\nThe Order has all \nthe instructions \nneeded to prepare \nthe meal. The \nOrder directs the \nShort Order Cook \nwith methods like \nmakeBurger().\nThe Short Order \nCook follows the \ninstructions of \nthe Order and \nproduces the meal.\nStart Here\nHome Automation or Bust\t\n\t\n\t\n\t\n\t\n192\nTaking a look at the vendor classes\t\n\t\n\t\n\t\n194\nA brief introduction to the Command Pattern\t\n\t\n\t\n197\nFrom the Diner to the Command Pattern\t\n\t\n\t\n201\nOur first command object\t\n\t\n\t\n\t\n\t\n203\nUsing the command object\t\n\t\n\t\n\t\n\t\n204\nAssigning Commands to slots\t\t\n\t\n\t\n\t\n209\nImplementing the Remote Control\t\n\t\n\t\n\t\n210\nImplementing the Commands\t\n\t\n\t\n\t\n211\nPutting the Remote Control through its paces\t\n\t\n\t\n212\nTime to write that documentation\u2026\t\n\t\n\t\n\t\n215\nWhat are we doing?\t\n\t\n\t\n\t\n\t\n217\nTime to QA that Undo button!\t\n\t\n\t\n\t\n220\nUsing state to implement Undo\t\n\t\n\t\n\t\n221\nAdding Undo to the Ceiling Fan commands\t\n\t\n\t\n222\nEvery remote needs a Party Mode!\t\n\t\n\t\n\t\n225\nUsing a macro command\t\n\t\n\t\n\t\n\t\n226\nMore uses of the Command Pattern: queuing requests\t\n\t\n229\nMore uses of the Command Pattern: logging requests\t\n\t\n230\nCommand Pattern in the Real World\t\n\t\n\t\n\t\n231\nTools for your Design Toolbox\t\n\t\n\t\n\t\n233\ntable of contents\n", "page": 18, "type": "text", "section": "Page 18"}
{"text": "7\nBeing Adaptive\nIn this chapter we\u2019re going to attempt such impossible \nfeats as putting a square peg in a round hole. Sound \nimpossible? Not when we have Design Patterns. Remember the Decorator \nPattern? We wrapped objects to give them new responsibilities. Now we\u2019re \ngoing to wrap some objects with a different purpose: to make their interfaces look \nlike something they\u2019re not. Why would we do that? So we can adapt a design \nexpecting one interface to a class that implements a different interface. That\u2019s not \nall; while we\u2019re at it, we\u2019re going to look at another pattern that wraps objects to \nsimplify their interface.\nthe Adapter and Facade Patterns\nAdaptee\nClient\nAdapter\nrequest()\ntranslatedRequest()\nThe Client is implemented \nagainst the target interface\nThe Adapter implements the \ntarget interface and holds an \ninstance of the Adaptee\ntarget interface\nadaptee \ninterface\nTurkey was the \nadaptee interface\nBritish Wall Outlet\nAC Power Adapter\nStandard AC Plug\nAdapters all around us\t\n\t\n\t\n\t\n\t\n238\nObject-oriented adapters\t\n\t\n\t\n\t\n\t\n239\nIf it walks like a duck and quacks like a duck, then it must\n might be a duck turkey wrapped with a duck adapter\u2026\t\n\t\n240\nTest drive the adapter\t\n\t\n\t\n\t\n\t\n242\nThe Adapter Pattern explained\t\n\t\n\t\n\t\n243\nAdapter Pattern defined\t\n\t\n\t\n\t\n\t\n245\nObject and class adapters\t\n\t\n\t\n\t\n\t\n246\nReal-world adapters\t\n\t\n\t\n\t\n\t\n250\nAdapting an Enumeration to an Iterator\t\n\t\n\t\n251\nHome Sweet Home Theater\t \t\n\t\n\t\n\t\n257\nWatching a movie (the hard way)\t\n\t\n\t\n\t\n258\nLights, Camera, Facade!  \t\n\t\n\t\n\t\n\t\n260\nConstructing your home theater facade\t\t\n\t\n\t\n263\nImplementing the simplified interface\t \t\n\t\n\t\n264\nTime to watch a movie (the easy way)\t \t\n\t\n\t\n265\nFacade Pattern defined\t\n\t\n\t\n\t\n\t\n266\nThe Principle of Least Knowledge\t\n\t\n\t\n\t\n267\nHow NOT to Win Friends and Influence Objects\t\t\n\t\n268\nThe Facade Pattern and the Principle of Least Knowledge\t \t\n271\nTools for your Design Toolbox\t\n\t\n\t\n\t\n272\n", "page": 19, "type": "text", "section": "Page 19"}
{"text": "8\nEncapsulating Algorithms\nWe\u2019ve encapsulated object creation, method invocation, \ncomplex interfaces, ducks, pizzas\u2026what could be next?  \nWe\u2019re going to get down to encapsulating pieces of algorithms so that subclasses \ncan hook themselves right into a computation anytime they want. We\u2019re even \ngoing to learn about a design principle inspired by Hollywood. Let\u2019s get started\u2026\nthe Template Method Pattern\n1\nBoil some water\n2\n3\n4\nSteep the tea bag in the water\nPour tea in a cup\nAdd lemon\n1\nBoil some water\n2\n3\n4\nBrew the coffee grinds\nPour coffee in a cup\nAdd sugar and milk\n2\n4\nSteep the teabag in the water\nAdd lemon\nT\nea subclass\nCoffee subclass\n2\n4\nBrew the coffee grinds\nAdd sugar and milk\n1\nBoil some water\n2\n3\n4\nBrew\nPour beverage in a cup\nAdd condiments\nCaffeine Beverage\nTea\nCoffee\nCaffeine Beverage knows \nand controls the steps of \nthe recipe, and performs \nsteps 1 and 3 itself, but \nrelies on T\nea or Coffee \nto do steps 2 and 4.\nWe\u2019ve recognized that \nthe two recipes are \nessentially the same, \nalthough some of the \nsteps require different \nimplementations.  So \nwe\u2019ve  generalized the \nrecipe and placed it in \nthe base class.\ngeneralize\nrelies on \nsubclass for \nsome steps\ngeneralize\nrelies on \nsubclass for \nsome steps\nIt\u2019s time for some more caffeine\t\n\t\n\t\n\t\n278\nWhipping up some coffee and tea classes (in Java)\t\t\n\t\n279\nLet\u2019s abstract that Coffee and Tea\t\n\t\n\t\n\t\n282\nTaking the design further\u2026\t \t\n\t\n\t\n\t\n283\nAbstracting prepareRecipe()\t \t\n\t\n\t\n\t\n284\nWhat have we done?\t\n\t\n\t\n\t\n\t\n287\nMeet the Template Method \t \t\n\t\n\t\n\t\n288\nWhat did the Template Method get us?\t\t\n\t\n\t\n290\nTemplate Method Pattern defined\t\n\t\n\t\n\t\n291\nHooked on Template Method\u2026\t\n\t\n\t\n\t\n294\nUsing the hook\t\n\t\n\t\n\t\n\t\n\t\n295\nThe Hollywood Principle and Template Method\t \t\n\t\n299\nTemplate Methods in the Wild\t\n\t\n\t\n\t\n301\nSorting with Template Method\t\n\t\n\t\n\t\n302\nWe\u2019ve got some ducks to sort\u2026\t\n\t\n\t\n\t\n303\nWhat is compareTo()?\t\n\t\n\t\n\t\n\t\n303\nComparing Ducks and Ducks\t\n\t\n\t\n\t\n\t\n304\nLet\u2019s sort some Ducks\t\n\t\n\t\n\t\n\t\n305\nThe making of the sorting duck machine\t\n\t\n\t\n306\nSwingin\u2019 with Frames\t\n\t\n\t\n\t\n\t\n308\nCustom Lists with AbstractList\t\n\t\n\t\n\t\n309\nTools for your Design Toolbox\t\n\t\n\t\n\t\n313\ntable of contents\n", "page": 20, "type": "text", "section": "Page 20"}
{"text": "9\nWell-Managed Collections\nThere are lots of ways to stuff objects into a collection.\nPut them into an Array, a Stack, a List, a hash map\u2014take your pick. Each has its \nown advantages and tradeoffs. But at some point your clients are going to want \nto iterate over those objects, and when they do, are you going to show them your \nimplementation? We certainly hope not! That just wouldn\u2019t be professional. Well, you \ndon\u2019t have to risk your career; in this chapter you\u2019re going to see how you can allow \nyour clients to iterate through your objects without ever getting a peek at how you \nstore your objects. You\u2019re also going to learn how to create some super collections of \nobjects that can leap over some impressive data structures in a single bound. And if \nthat\u2019s not enough, you\u2019re also going to learn a thing or two about object responsibility. \n \n \nthe Iterator and Composite Patterns\nP\na\nn\nc\na\nk\ne\nH\nou\ns\ne\nM\ne\nn\nu\n \n \nD\ni\nn\ne\nr\nM\ne\nn\nu\n \n \n \nC\na\nf\ne\nM\ne\nn\nu\n1\n2\n3\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nPancake Menu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\nCaf\u00e9 Menu\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nDiner Menu\nAll Menus\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nDessert Menu\nArray\nArrayList\nBreaking News: Objectville Diner and Objectville Pancake House Merge\t\n318\nCheck out the Menu Items\t\n\t\n\t\n\t\n\t\n\t\n319\nImplementing the spec: our first attempt\t\n\t\n\t\n\t\n323\nCan we encapsulate the iteration?\t\n\t\n\t\n\t\n\t\n325\nMeet the Iterator Pattern\t\n\t\n\t\n\t\n\t\n\t\n327\nAdding an Iterator to DinerMenu\t\n\t\n\t\n\t\n\t\n328\nReworking the DinerMenu with Iterator\t\n\t\n\t\n\t\n329\nFixing up the Waitress code\t \t\n\t\n\t\n\t\n\t\n330\nTesting our code\t\n\t\n\t\n\t\n\t\n\t\n\t\n331\nReviewing our current design\u2026\t\n\t\n\t\n\t\n\t\n333\nCleaning things up with java.util.Iterator\t\n\t\n\t\n\t\n335\nIterator Pattern defined\t\n\t\n\t\n\t\n\t\n\t\n338\nThe Iterator Pattern Structure\t\n\t\n\t\n\t\n\t\n339\nThe Single Responsibility Principle\t\n\t\n\t\n\t\n\t\n340\nMeet Java\u2019s Iterable interface\t\t\n\t\n\t\n\t\n\t\n343\nJava\u2019s enhanced for loop\t\n\t\n\t\n\t\n\t\n\t\n344\nTaking a look at the Caf\u00e9 Menu\t\n\t\n\t\n\t\n\t\n347\nIterators and Collections\t\n\t\n\t\n\t\n\t\n\t\n353\nIs the Waitress ready for prime time?\t\n\t\n\t\n\t\n\t\n355\nThe Composite Pattern defined\t\n\t\n\t\n\t\n\t\n360\nDesigning Menus with Composite\t\n\t\n\t\n\t\n\t\n363\nImplementing MenuComponent\t\n\t\n\t\n\t\n\t\n364\nImplementing the MenuItem\t\t\n\t\n\t\n\t\n\t\n365\nImplementing the Composite Menu\t\n\t\n\t\n\t\n\t\n366\nNow for the test drive\u2026\t\n\t\n\t\n\t\n\t\n\t\n369\nTools for your Design Toolbox\t\n\t\n\t\n\t\n\t\n376\n", "page": 21, "type": "text", "section": "Page 21"}
{"text": "10\nThe State of Things\nA little-known fact: the Strategy and State Patterns were \ntwins separated at birth. You\u2019d think they\u2019d live similar lives, but the Strategy \nPattern went on to create a wildly successful business around interchangeable algorithms, \nwhile State took the perhaps more noble path of helping objects to control their behavior \nby changing their internal state. As different as their paths became, however, underneath \nyou\u2019ll find almost precisely the same design. How can that be? As you\u2019ll see, Strategy \nand State have very different intents. First, let\u2019s dig in and see what the State Pattern is all \nabout, and then we\u2019ll return to explore their relationship at the end of the chapter.\nthe State Pattern\nMighty Gumball, Inc.\nWhere the Gumball Machine \nis Never Half Empty\nHere\u2019s the way we think the gumball machine controller needs to \nwork. We\u2019re hoping you can implement this in Java for us!  We may \nbe adding more behavior in the future, so you need to keep the \ndesign as flexible and maintainable as possible!\n       - Mighty Gumball Engineers\nOut of \nGumballs\n   Has \nQuarter\n   No \nQuarter\nGumball \n  Sold\ninserts quarter\nejects quarter\nturns crank\ndispense \ngumball\ngumballs = 0\ngumballs > 0\nJava Breakers\t\n\t\n\t\n\t\n\t\n382\nState machines 101 \t\n\t\n\t\n\t\n384\nWriting the code\t\n\t\n\t\n\t\n\t\n386\nIn-house testing\t\n\t\n\t\n\t\n\t\n388\nYou knew it was coming\u2026a change request!\t\n\t\n390\nThe messy STATE of things\u2026\t\n\t\n\t\n392\nThe new design\t\n\t\n\t\n\t\n\t\n394\nDefining the State interfaces and classes\t\n\t\n\t\n395\nReworking the Gumball Machine\t\n\t\n\t\n398\nNow, let\u2019s look at the complete GumballMachine class\u2026\t\n399\nImplementing more states\t\n\t\n\t\n\t\n400\nThe State Pattern defined\t\n\t\n\t\n\t\n406\nWe still need to finish the Gumball 1 in 10 game\t \t\n409\nFinishing the game\t\t\n\t\n\t\n\t\n410\nDemo for the CEO of Mighty Gumball, Inc.\t\n\t\n411\nSanity check\u2026\t\n\t\n\t\n\t\n\t\n413\nWe almost forgot!\t \t\n\t\n\t\n\t\n416\nTools for your Design Toolbox\t\n\t\n\t\n419\ntable of contents\n", "page": 22, "type": "text", "section": "Page 22"}
{"text": "11\nControlling Object Access\nEver play good cop, bad cop?  You\u2019re the good cop and you provide \nall your services in a nice and friendly manner, but you don\u2019t want everyone asking \nyou for services, so you have the bad cop control access to you. That\u2019s what proxies \ndo: control and manage access. As you\u2019re going to see, there are lots of ways in \nwhich proxies stand in for the objects they proxy. Proxies have been known to haul \nentire method calls over the internet for their proxied objects; they\u2019ve also been \nknown to patiently stand in for some pretty lazy objects. \nthe Proxy Pattern\n<<interface>>\nSubject\nrequest()\nRealSubject\nrequest()\nProxy\nrequest()\n<<interface>>\nInvocationHandler\ninvoke()\nInvocationHandler\nThe proxy now consists of two \nclasses.\ninvoke()\nCoding the Monitor\t\n\t\n\t\n\t\n427\nTesting the Monitor\t\n\t\n\t\n\t\n428\nRemote methods 101\t\n\t\n\t\n\t\n433\nGetting the GumballMachine ready to be a remote service\t 446\nRegistering with the RMI registry\u2026\t\n\t\n\t\n448\nThe Proxy Pattern defined\t\n\t\n\t\n\t\n455\nGet ready for the Virtual Proxy\t\n\t\n\t\n457\nDesigning the Album Cover Virtual Proxy\t\n\t\n459\nWriting the Image Proxy\t\n\t\n\t\n\t\n460\nUsing the Java API\u2019s Proxy to create a protection proxy\t\n469\nGeeky Matchmaking in Objectville\t\n\t\n\t\n470\nThe Person implementation\t \t\n\t\n\t\n471\nFive-minute drama: protecting subjects\t\t\n\t\n473\nBig Picture: creating a Dynamic Proxy for the Person\t\n474\nThe Proxy Zoo\t\n\t\n\t\n\t\n\t\n482\nTools for your Design Toolbox\t\n\t\n\t\n485\nThe code for the Album Cover Viewer\t \t\n\t\n489\n", "page": 23, "type": "text", "section": "Page 23"}
{"text": "12\nPatterns of Patterns\nWho would have ever guessed that Patterns could work \ntogether?  You\u2019ve already witnessed the acrimonious Fireside Chats (and \nyou haven\u2019t even seen the Pattern Death Match pages that the editor forced us to \nremove from the book), so who would have thought patterns can actually get along \nwell together? Well, believe it or not, some of the most powerful OO designs use \nseveral patterns together. Get ready to take your pattern skills to the next level; it\u2019s \ntime for compound patterns.\ncompound patterns\nWorking together\t \t\n\t\n\t\n\t\n494\nDuck reunion\t\n\t\n\t\n\t\n\t\n495\nWhat did we do?\t\n\t\n\t\n\t\n\t\n517\nA bird\u2019s duck\u2019s-eye view: the class diagram\t\n\t\n518\nThe King of Compound Patterns\t\n\t\n\t\n520\nMeet Model-View-Controller\t\t\n\t\n\t\n523\nA closer look\u2026\t\n\t\n\t\n\t\n\t\n524\nUnderstanding MVC as a set of Patterns\t\n\t\n526\nUsing MVC to control the beat\u2026\t\n\t\n\t\n528\nBuilding the pieces\t \t\n\t\n\t\n\t\n531\nNow let\u2019s have a look at the concrete BeatModel class\t\n532\nThe View\t\n\t\n\t\n\t\n\t\n\t\n533\nImplementing the View\t\n\t\n\t\n\t\n534\nNow for the Controller\t\n\t\n\t\n\t\n536\nPutting it all together\u2026\t\n\t\n\t\n\t\n538\nExploring Strategy\t \t\n\t\n\t\n\t\n539\nAdapting the Model\t\n\t\n\t\n\t\n540\nAnd now for a test run\u2026\t\n\t\n\t\n\t\n542\nTools for your Design Toolbox\t\n\t\n\t\n545\nB\ne\na\nt\nM\no\nd\ne\nl\nController\nsetBPM()\ngetBPM()\non()\noff()\nClick on the \nincrease beat \nbutton\u2026\nThe controller asks \nthe model to update \nits BPM by one.\nView is notified that the \nBPM changed.  It calls \ngetBPM() on the model state.\nBecause the BPM is 120, the \nview gets a beat notification \nevery 1/2 second.\nThe beat is set at 119 BPM and you \nwould like to increase it to 120.\n\u2026which results in the \ncontroller being invoked.\nThe view is updated \nto 120 BPM.\nYou see the beatbar \npulse every 1/2 second.\nView\nView\ntable of contents\n", "page": 24, "type": "text", "section": "Page 24"}
{"text": "13\nPatterns in the Real World\nAhhhh, now you\u2019re ready for a bright new world filled \nwith Design Patterns. But, before you go opening all those new doors \nof opportunity, we need to cover a few details that you\u2019ll encounter out in the \nreal world\u2014that\u2019s right, things get a little more complex than they are here \nin Objectville. Come along, we\u2019ve got a nice guide to help you through the \ntransition\u2026\nbetter living with patterns\nDesign Pattern defined\t\n\t\n\t\n\t\n565\nLooking more closely at the Design Pattern definition\t\n567\nMay the force be with you\t\n\t\n\t\n\t\n568\nSo you wanna be a Design Patterns writer\t\n\t\n573\nOrganizing Design Patterns\t \t\n\t\n\t\n575\nThinking in Patterns\t\n\t\n\t\n\t\n580\nYour Mind on Patterns\t\n\t\n\t\n\t\n583\nDon\u2019t forget the power of the shared vocabulary\t \t\n585\nCruisin\u2019 Objectville with the Gang of Four\t\n\t\n587\nYour journey has just begun\u2026\t\n\t\n\t\n588\nThe Patterns Zoo\t \t\n\t\n\t\n\t\n590\nAnnihilating evil with Anti-Patterns\t\n\t\n\t\n592\nTools for your Design Toolbox\t\n\t\n\t\n594\nLeaving Objectville\t\t\n\t\n\t\n\t\n595\nErich Gamma\nJohn Vlissides\nRichard Helm\nRalph \nJohnson\nGang of Four\nThe Objectville Guide to \n    Better Living with Design Patterns\nPlease accept our handy guide of tips & tricks for living with patterns in the real \nworld. In this guide you will:\nb  Learn the all too common misconceptions about the definition of a \u201cDesign \nPattern.\u201d\nb  Discover those nifty Design Pattern Catalogs and why you just have to get \none.\nb  Avoid the embarrassment of using a Design Pattern at the wrong time.\nb  Learn how to keep patterns in classifications where they belong.\nb  See that discovering patterns isn\u2019t just for the gurus; read our quick How To \nand become a patterns writer too.\nb  Be there when the true identify of the mysterious Gang of Four is revealed.\nb  Keep up with the neighbors \u2013 the coffee table books any patterns user must \nown.\nb  Learn to train your Design Patterns mind like a Zen master.\nb  Win friends and influence developers by improving your patterns vocabulary.\n", "page": 25, "type": "text", "section": "Page 25"}
{"text": "14\nAppendix: Leftover Patterns\nNot everyone can be the most popular. A lot has changed in the \nlast 25+ years. Since Design Patterns: Elements of Reusable Object-Oriented \nSoftware first came out, developers have applied these patterns thousands of \ntimes. The patterns we summarize in this appendix are full-fledged, card-carrying, \nofficial GoF patterns, but aren\u2019t used as often as the patterns we\u2019ve explored so \nfar. But these patterns are awesome in their own right, and if your situation calls for \nthem, you should apply them with your head held high. Our goal in this appendix is \nto give you a high-level idea of what these patterns are all about. \ni\nIndex\n\t\n617\t\nBridge\t\n\t\n\t\n\t\n\t\n598\nBuilder\t \t\n\t\n\t\n\t\n600\nChain of Responsibility\t\n\t\n\t\n602\nFlyweight\t\n\t\n\t\n\t\n\t\n604\nInterpreter\t\n\t\n\t\n\t\n606\nMediator\t\t\n\t\n\t\n\t\n608\nMemento\t\n\t\n\t\n\t\n\t\n610\nPrototype\t\n\t\n\t\n\t\n\t\n612\nVisitor\t\n\t\n\t\n\t\n\t\n614\nVisitor\n  Client / \nTraverser\ngetState()\ngetState()\ngetState()\ngetState()\ngetState()\ngetHealthRating()\ngetCalories()\ngetProtein()\ngetCarbs()\nAll these composite \nclasses have to do is add \na getState() method \n(and not worry about \nexposing themselves).\nThe Client asks \nthe Visitor to get \ninformation from the \nComposite structure\u2026 \nNew methods can be \nadded to the Visitor \nwithout affecting the \nComposite.\nThe Visitor needs to be able to call \ngetState() across classes, and this is \nwhere you can add new methods for \nthe client to use.\nThe Traverser knows how to \nguide the Visitor through \nthe Composite structure.\nMenuItem\nMenu\nIngredient\nMenuItem\nIngredient\ntable of contents\n", "page": 26, "type": "text", "section": "Page 26"}
{"text": "xxv\nIntro\nhow to use this book \nI can\u2019t believe they \nput that in a Design \nPatterns book!\nIn this section, we answer the burning question:\n\u201cSo, why DID they put that in a design patterns book?\u201d\n", "page": 27, "type": "text", "section": "Page 27"}
{"text": "how to use this book\nxxvi \nintro\nWho is this book for?\n1\nDo you know Java (you don\u2019t need to be a guru) or \nanother object-oriented language?\n2\nDo you want to learn, understand, remember, and \napply design patterns, including the OO design \nprinciples upon which design patterns are based?\nthis book is for you.\nWho should probably back away from this book?\n1\nAre you completely new to object-oriented \nprogramming?\n4\nthis book is not for you.\nAre you afraid to try something different?  Would \nyou rather have a root canal than mix stripes \nwith plaid? Do you believe that a technical book \ncan\u2019t be serious if object-oriented concepts are \nanthropomorphized?\nIf you can answer \u201cyes\u201d to all of these:\nIf you can answer \u201cyes\u201d to any one of these:\n2\nAre you a kick-butt object-oriented designer/\ndeveloper looking for a reference book?\n[Note from marketing: this book is \nfor anyone with a credit card.]\n3\nDo you prefer stimulating dinner party conversation \nto dry, dull, academic lectures?\n3\nAre you an architect looking for enterprise design \npatterns?\nAll our examples are in \nJava, but you should be \nable to understand the \nmain concepts of the \nbook if you know another \nobject-oriented language.\n", "page": 28, "type": "text", "section": "Page 28"}
{"text": "the intro\nyou are here\u0017 xxvii\n\u201cHow can this be a serious programming book?\u201d\n\u201cWhat\u2019s with all the graphics?\u201d\n\u201cCan I actually learn it this way?\u201d\nWe know what you\u2019re thinking.\nYour brain craves novelty. It\u2019s always searching, scanning, waiting for \nsomething unusual. It was built that way, and it helps you stay alive. \nToday, you\u2019re less likely to be a tiger snack. But your brain\u2019s still looking. \nYou just never know.\nSo what does your brain do with all the routine, ordinary, normal things \nyou encounter? Everything it can to stop them from interfering with the \nbrain\u2019s real job\u2014recording things that matter. It doesn\u2019t bother saving \nthe boring things; they never make it past the \u201cthis is obviously not \nimportant\u201d filter.\nHow does your brain know what\u2019s important? Suppose you\u2019re out for a day \nhike and a tiger jumps in front of you, what happens inside your head and \nbody? \nNeurons fire. Emotions crank up. Chemicals surge. \nAnd that\u2019s how your brain knows...\nThis must be important! Don\u2019t forget it!\nBut imagine you\u2019re at home, or in a library. It\u2019s a safe, warm, tiger-\nfree zone. You\u2019re studying. Getting ready for an exam. Or trying to \nlearn some tough technical topic your boss thinks will take a week, \nten days at the most.\nJust one problem. Your brain\u2019s trying to do you a big favor. It\u2019s \ntrying to make sure that this obviously non-important content doesn\u2019t \nclutter up scarce resources. Resources that are better spent storing \nthe really big things. Like tigers. Like the danger of fire. Like how \nyou should never again snowboard in shorts.\nAnd there\u2019s no simple way to tell your brain, \u201cHey brain, thank \nyou very much, but no matter how dull this book is, and how little \nI\u2019m registering on the emotional Richter scale right now, I really do \nwant you to keep this stuff around.\u201d\nAnd we know what your brain is thinking.\nYour brain thinks \nTHIS is important.\nYour brain thinks \nTHIS isn\u2019t worth \nsaving.\nGreat. Only \n642 more dull, \ndry, boring pages.\n", "page": 29, "type": "text", "section": "Page 29"}
{"text": "how to use this book\nxxviii intro\nSo what does it take to learn something? First, you have to get it, then make \nsure you don\u2019t forget it. It\u2019s not about pushing facts into your head. Based on the \nlatest research in cognitive science, neurobiology, and educational psychology, \nlearning takes a lot more than text on a page. We know what turns your brain on.\nSome of the Head First learning principles:\nMake it visual. Images are far more memorable than words alone, and \nmake learning much more effective (up to 89% improvement in recall and \ntransfer studies). It also makes things more understandable.  Put the \nwords within or near the graphics they relate to, rather than on \nthe bottom or on another page, and learners will be up to twice as likely \nto solve problems related to the content.  \nUse a conversational and personalized style. In studies, students \nperformed up to 40% better on post-learning tests if the content spoke directly to \nthe reader, using a first-person, conversational style rather than taking a formal \ntone. Tell stories instead of lecturing. Use casual language. Don\u2019t take yourself \ntoo seriously. Which would you pay more attention to: a stimulating dinner party \ncompanion, or a lecture?\nGet the learner to think more deeply. In other words, unless \nyou actively flex your neurons, nothing much happens in your head.  A \nreader has to be motivated, engaged, curious, and inspired to solve \nproblems, draw conclusions, and generate new knowledge. And for \nthat, you need challenges, exercises, thought-provoking questions, \nactivities that involve both sides of the brain, and multiple \nsenses.\nGet\u2014and keep\u2014the reader\u2019s attention.  We\u2019ve \nall had the \u201cI really want to learn this but I can\u2019t stay awake past \npage one\u201d experience.  Your brain pays attention to things that \nare out of the ordinary, interesting, strange, eye-catching, unexpected.   \nLearning a new, tough, technical topic doesn\u2019t have to be boring. Your brain will \nlearn much more quickly if it\u2019s not.\nTouch their emotions. We now know that your ability to remember something is largely \ndependent on its emotional content.  You remember what you care about.  You remember when \nyou feel something. No, we\u2019re not talking heart-wrenching stories about a boy and his dog.  We\u2019re \ntalking emotions like surprise, curiosity, fun, \u201cwhat the...?\u201d , and the feeling of  \u201cI Rule!\u201d that comes \nwhen you solve a puzzle, learn something everybody else thinks is hard, or realize you know \nsomething that \u201cI\u2019m more technical than thou\u201d Bob from engineering doesn\u2019t. \nWe think of a \u201cHead First\u201d reader as a learner.\ndoCalc()\nreturn value\nNeeds to call a \nmethod on the \nserver\nServer executes \nremote method\n abstract void roam();\nNo method body! \n \n \n \n \nEnd it with a \nsemicolon.\nDoes it make sense to \nsay Tub IS-A Bathroom? \nBathroom IS-A Tub? Or is it \na HAS-A relationship?\nIt really sucks to be \nan abstract method. \n \nYou don\u2019t have a \nbody.\n", "page": 30, "type": "text", "section": "Page 30"}
{"text": "the intro\nyou are here\u0017\nxxix\nIf you really want to learn, and you want to learn more quickly and more deeply, \npay attention to how you pay attention. Think about how you think. Learn how you \nlearn.\nMost of us did not take courses on metacognition or learning theory when we were \ngrowing up. We were expected to learn, but rarely taught to learn.\nBut we assume that if you\u2019re holding this book, you really want to learn \ndesign patterns. And you probably don\u2019t want to spend a lot of time. And \nyou want to remember what you read, and be able to apply it. And for that, \nyou\u2019ve got to understand it. To get the most from this book, or any book or \nlearning experience, take responsibility for your brain. Your brain on this \ncontent. \nThe trick is to get your brain to see the new material you\u2019re learning as \nReally Important. Crucial to your well-being. As important as a tiger. \nOtherwise, you\u2019re in for a constant battle, with your brain doing its best \nto keep the new content from sticking.\nMetacognition: thinking about thinking\nSo how DO you get your brain to think Design \nPatterns are as important as a tiger?\nThere\u2019s the slow, tedious way, or the faster, more effective way. The \nslow way is about sheer repetition. You obviously know that you are \nable to learn and remember even the dullest of topics, if you keep \npounding on the same thing. With enough repetition, your brain says, \u201cThis doesn\u2019t \nfeel important to him, but he keeps looking at the same thing over and over and over, so I \nsuppose it must be.\u201d\nThe faster way is to do anything that increases brain activity, especially different \ntypes of brain activity. The things on the previous page are a big part of the solution, \nand they\u2019re all things that have been proven to help your brain work in your favor. For \nexample, studies show that putting words within the pictures they describe (as opposed to \nsomewhere else in the page, like a caption or in the body text) causes your brain to try to \nmakes sense of how the words and picture relate, and this causes more neurons to fire. \nMore neurons firing = more chances for your brain to get that this is something worth \npaying attention to, and possibly recording.\nA conversational style helps because people tend to pay more attention when they \nperceive that they\u2019re in a conversation, since they\u2019re expected to follow along and hold up \ntheir end. The amazing thing is, your brain doesn\u2019t necessarily care that the \u201cconversation\u201d \nis between you and a book! On the other hand, if the writing style is formal and dry, your \nbrain perceives it the same way you experience being lectured to while sitting in a roomful \nof passive attendees. No need to stay awake.\nBut pictures and conversational style are just the beginning.\nI wonder how I \ncan trick my brain \ninto remembering \nthis stuff...\n", "page": 31, "type": "text", "section": "Page 31"}
{"text": "xxx \nintro\nhow to use this book\nWe used pictures, because your brain is tuned for visuals, not text. As far as your brain\u2019s \nconcerned, a picture really is worth 1,024 words. And when text and pictures work together, \nwe embedded the text in the pictures because your brain works more effectively when the text \nis within the thing it refers to, as opposed to in a caption or buried somewhere else.\nWe used redundancy, saying the same thing in different ways and with different media types, \nand multiple senses, to increase the chance that the content gets coded into more than one area \nof your brain. \nWe used concepts and pictures in unexpected ways because your brain is tuned for novelty, \nand we used pictures and ideas with at least some emotional content, because your brain \nis tuned to pay attention to the biochemistry of emotions. That which causes you to feel \nsomething is more likely to be remembered, even if that feeling is nothing more than a little \nhumor, surprise, or interest.\nWe used a personalized, conversational style, because your brain is tuned to pay more \nattention when it believes you\u2019re in a conversation than if it thinks you\u2019re passively listening to \na presentation. Your brain does this even when you\u2019re reading.\nWe included more than 90 activities, because your brain is tuned to learn and remember \nmore when you do things than when you read about things. And we made the exercises \nchallenging-yet-do-able, because that\u2019s what most people prefer.\nWe used multiple learning styles, because you might prefer step-by-step procedures, while \nsomeone else wants to understand the big picture first, while someone else just wants to see \na code example. But regardless of your own learning preference, everyone benefits from seeing \nthe same content represented in multiple ways.\nWe included content for both sides of your brain, because the more of your brain you \nengage, the more likely you are to learn and remember, and the longer you can stay focused. \nSince working one side of the brain often means giving the other side a chance to rest, you \ncan be more productive at learning for a longer period of time. \nAnd we included stories and exercises that present more than one point of view, because \nyour brain is tuned to learn more deeply when it\u2019s forced to make evaluations and judgments. \nWe included challenges, both with exercises and by asking questions that don\u2019t always \nhave a straight answer, because your brain is tuned to learn and remember when it has to work \nat something. Think about it\u2014you can\u2019t get your body in shape just by watching people at the \ngym. But we did our best to make sure that when you\u2019re working hard, it\u2019s on the right things. \nThat you\u2019re not spending one extra dendrite processing a hard-to-understand example, \nor parsing difficult, jargon-laden, or overly terse text.\nWe used people. In stories, examples, pictures, etc., because, well, because you\u2019re a person. \nAnd your brain pays more attention to people than it does to things. \nWe used an 80/20 approach. We assume that if you\u2019re going for a PhD in software design, \nthis won\u2019t be your only book. So we don\u2019t talk about everything. Just the stuff you\u2019ll actually need.\nHere\u2019s what WE did:\nThe Patterns Guru\n BULLET POINTS\nS\nu\nb\nj\ne\nc\nt\n \nOb\nj\ne\nc\nt\n8\nint\n \n \n \nD\no\ng\n \nO\nb\nj\ne\nc\nt\nM\no\nu\ns\ne\n \nO\nb\njec\nt\n \n \nC\na\nt\n \nO\nb\nj\ne\nct\n \n \nD\nu\nc\nk\n \nO\nb\njec\nt\nObservers\n8\n8\n8\n8\nONE TO MANY RELATIONSHIP\nAutomatic update/notification\nObject that \nholds state\nDependent Objects\nPuzzles\n", "page": 32, "type": "text", "section": "Page 32"}
{"text": "the intro\nyou are here\u0017\nxxxi\nSo, we did our part. The rest is up to you. These tips are a \nstarting point; listen to your brain and figure out what works \nfor you and what doesn\u2019t. Try new things.\nHere\u2019s what YOU can do to bend \nyour brain into submission\n1\nSlow down. The more you understand, \nthe less you have to memorize.\nDon\u2019t just read. Stop and think. When the \nbook asks you a question, don\u2019t just skip to the \nanswer. Imagine that someone really is asking \nthe question. The more deeply you force your \nbrain to think, the better chance you have of \nlearning and remembering.\n2\nDo the exercises. Write your own notes.\nWe put them in, but if we did them for you, \nthat would be like having someone else do \nyour workouts for you. And don\u2019t just look at \nthe exercises. Use a pencil. There\u2019s plenty of \nevidence that physical activity while learning \ncan increase the learning. \n3\nRead the \u201cThere Are No Dumb Questions\u201d\nThat means all of them. They\u2019re not optional \nsidebars\u2014they\u2019re part of the core content! \nDon\u2019t skip them.\n4\nMake this the last thing you read before \nbed. Or at least the last challenging thing.\nPart of the learning (especially the transfer to \nlong-term memory) happens after you put the \nbook down. Your brain needs time on its own, to \ndo more processing. If you put in something new \nduring that processing time, some of what you \njust learned will be lost. \n5\nDrink water. Lots of it.\nYour brain works best in a nice bath of fluid. \nDehydration (which can happen before you ever \nfeel thirsty) decreases cognitive function. \n6\nTalk about it. Out loud.\nSpeaking activates a different part of the brain. \nIf you\u2019re trying to understand something, or \nincrease your chance of remembering it later, say \nit out loud. Better still, try to explain it out loud \nto someone else. You\u2019ll learn more quickly, and \nyou might uncover ideas you hadn\u2019t known were \nthere when you were reading about it.\n7\nListen to your brain.\nPay attention to whether your brain is getting \noverloaded. If you find yourself starting to skim the \nsurface or forget what you just read, it\u2019s time for a \nbreak. Once you go past a certain point, you won\u2019t \nlearn faster by trying to shove more in, and you \nmight even hurt the process.\n9\nDesign something!\nApply this to something new you\u2019re designing, or \nrefactor an older project. Just do something to get \nsome experience beyond the exercises and activities \nin this book. All you need is a pencil and a problem \nto solve\u2026a problem that might benefit from one or \nmore design patterns. \nCut this out and stick it \non your refrigerator.\n8\nFeel something!\nYour brain needs to know that this matters. Get \ninvolved with the stories. Make up your own \ncaptions for the photos. Groaning over a bad joke is \nstill better than feeling nothing at all.\n", "page": 33, "type": "text", "section": "Page 33"}
{"text": "xxxii \nintro\nRead Me\nDirector\ngetMovies\ngetOscars()\ngetKevinBaconDegrees()\nWe use a simpler, \nmodified version \nof UML.\nThis is a learning experience, not a reference book. We deliberately stripped out \neverything that might get in the way of learning whatever it is we\u2019re working on at that \npoint in the book. And the first time through, you need to begin at the beginning, because \nthe book makes assumptions about what you\u2019ve already seen and learned.\nWe use simple UML-like diagrams. \nAlthough there\u2019s a good chance you\u2019ve run across UML, it\u2019s not covered in the book, and \nit\u2019s not a prerequisite for the book. If you\u2019ve never seen UML before, don\u2019t worry, we\u2019ll \ngive you a few pointers along the way.  So in other words, you won\u2019t have to worry about \nDesign Patterns and UML at the same time. Our diagrams are \u201cUML-like\u201d\u2014while we \ntry to be true to UML there are times we bend the rules a bit, usually for our own selfish \nartistic reasons. \nWe don\u2019t cover every single Design Pattern ever created.\nThere are a lot of Design Patterns: the original foundational patterns (known as the GoF \npatterns), enterprise Java patterns, architectural patterns, game design patterns, and a lot \nmore. But our goal was to make sure the book weighed less than the person reading it, so \nwe don\u2019t cover them all here. Our focus is on the core patterns that matter from the original \nGoF object-oriented patterns, and making sure that you really, truly, deeply understand \nhow and when to use them. You will find a brief look at some of the other patterns (the \nones you\u2019re far less likely to use) in the appendix. In any case, once you\u2019re done with Head \nFirst Design Patterns, you\u2019ll be able to pick up any patterns catalog and get up to speed \nquickly.\nThe activities are NOT optional. \nThe exercises and activities are not add-ons; they\u2019re part of the core content of the book. \nSome of them are to help with memory, some for understanding, and some to help you \napply what you\u2019ve learned. Don\u2019t skip the exercises. The crossword puzzles are the \nonly things you don\u2019t have to do, but they\u2019re good for giving your brain a chance to think \nabout the words from a different context.\nWe use the word \u201ccomposition\u201d in the general OO sense, which is \nmore flexible than the strict UML use of \u201ccomposition.\u201d\nWhen we say \u201cone object is composed with another object\u201d we mean that they are related \nby a HAS-A relationship. Our use reflects the traditional use of the term and is the one \nused in the GoF text (you\u2019ll learn what that is later). More recently, UML has refined this \nterm into several types of composition. If you are an UML expert, you\u2019ll still be able \nto read the book and you should be able to easily map the use of composition to more \nrefined terms as you read.\nhow to use this book\n", "page": 34, "type": "text", "section": "Page 34"}
{"text": "the intro\nyou are here\u0017 xxxiii\nThe redundancy is intentional and important. \nOne distinct difference in a Head First book is that we want you to really get it. And we want \nyou to finish the book remembering what you\u2019ve learned. Most reference books don\u2019t have \nretention and recall as a goal, but this book is about learning, so you\u2019ll see some of the same \nconcepts come up more than once. \nThe code examples are as lean as possible.\nOur readers tell us that it\u2019s frustrating to wade through 200 lines of code looking for the two \nlines they need to understand. Most examples in this book are shown within the smallest \npossible context, so that the part you\u2019re trying to learn is clear and simple. Don\u2019t expect \nall of the code to be robust, or even complete\u2014the examples are written specifically for \nlearning, and aren\u2019t always fully functional. \nIn some cases, we haven\u2019t included all of the import statements needed, but we assume that \nif you\u2019re a Java programmer, you know that ArrayList is in java.util, for example. If the \nimports were not part of the normal core JSE API, we mention it. We\u2019ve also placed all the \nsource code on the web so you can download it. You\u2019ll find it at \nhttp://wickedlysmart.com/head-first-design-patterns.\nAlso, for the sake of focusing on the learning side of the code, we did not put our classes \ninto packages (in other words, they\u2019re all in the Java default package). We don\u2019t recommend \nthis in the real world, and when you download the code examples from this book, you\u2019ll find \nthat all classes are in packages.\nThe Brain Power exercises don\u2019t have answers.\nFor some of them, there is no right answer, and for others, part of the learning experience \nof the Brain Power activities is for you to decide if and when your answers are right. In \nsome of the Brain Power exercises, you will find hints to point you in the right direction.\n", "page": 35, "type": "text", "section": "Page 35"}
{"text": "xxxiv \nintro\nTech Reviewers\nJef Cumps \nJason Menard\nDirk Schreckmann\nBarney Marispini\nValentin Crettaz\nIke Van Atta\nMark Spritzler\nJohannes deJong\nFearless leader of \nthe HFDP Extreme \nReview T\neam\nthe first edition review team\nPhilippe Maquet\nIn memory of Philippe Maquet, 1960 - \n2004. Your amazing technical expertise, \nrelentless enthusiasm, and deep concern for \nthe learner will inspire us always. \n", "page": 36, "type": "text", "section": "Page 36"}
{"text": "the intro\nyou are here\u0017 xxxv\nthe second edition review team\nJulian Setiawan\nGeorge Heineman\nDavid Powers\nTrisha Gee\nTech Reviewers, 2nd Edition\n2nd Edition Reviewer MVP!\nAt O\u2019Reilly: \nOur biggest thanks to Mike Loukides at O\u2019Reilly, for starting it all and helping to shape the Head First concept into \na series. And a big thanks to the driving force behind Head First, Tim O\u2019Reilly. Thanks to the clever Head First \n\u201cseries mom\u201d Kyle Hart, \u201cIn Design King\u201d Ron Bilodeau, rock-and-roll star Ellie Volkhausen for her inspired \ncover design, Melanie Yarbrough for shepherding production, Colleen Gorman and Rachel Monaghan for \ntheir hardcore copyedits, and Bob Pfahler for a much improved index. Finally, thanks to Mike Hendrickson and \nMeghan Blanchette for championing this book and building the team.\nOur intrepid reviewers:\nWe are extremely grateful for our technical review director Johannes deJong. You are our hero, Johannes. And we \ndeeply appreciate the contributions of the co-manager of the Javaranch review team, the late Philippe Maquet. \nYou have single-handedly brightened the lives of thousands of developers, and the impact you\u2019ve had on their (and \nour) lives is forever. Jef Cumps is scarily good at finding problems in our draft chapters, and once again made a huge \ndifference for the book. Thanks Jef! Valentin Cretazz (AOP guy), who has been with us from the very first Head First \nbook, proved (as always) just how much we really need his technical expertise and insight. You rock Valentin (but lose \nthe tie).\nTwo newcomers to the HF review team, Barney Marispini and Ike Van Atta, did a kick-butt job on the book\u2014you \nguys gave us some really crucial feedback. Thanks for joining the team. \nWe also got some excellent technical help from Javaranch moderators/gurus Mark Spritzler, Jason Menard, Dirk \nSchreckmann, Thomas Paul, and Margarita Isaeva. And as always, thanks especially to the javaranch.com \nTrail Boss, Paul Wheaton.  \nThanks to the finalists of the Javaranch \u201cPick the Head First Design Patterns Cover\u201d contest. The winner, Si Brewster, \nsubmitted the winning essay that persuaded us to pick the woman you see on our cover. Other finalists include Andrew \nEsse, Gian Franco Casula, Helen Crosbie, Pho Tek, Helen Thomas, Sateesh Kommineni, and Jeff Fisher.\nFor the 2014 update to the book, we are so grateful to the following technical reviewers: George Hoffer, Ted Hill, Todd \nBartoszkiewicz, Sylvain Tenier, Scott Davidson, Kevin Ryan, Rich Ward, Mark Francis Jaeger, Mark Masse, Glenn Ray, \nBayard Fetler, Paul Higgins, Matt Carpenter, Julia Williams, Matt McCullough, and Mary Ann Belarmino.\nFrom the first edition\nAcknowledgments\n", "page": 37, "type": "text", "section": "Page 37"}
{"text": "how to use this book\nxxxvi \nintro\nVery Special Thanks\nA very special thanks to Erich Gamma, who went far beyond the call of duty in reviewing this book (he even \ntook a draft with him on vacation). Erich, your interest in this book inspired us, and your thorough technical review \nimproved it immeasurably. Thanks as well to the entire Gang of Four for their support and interest, and for \nmaking a special appearance in Objectville.  We are also indebted to Ward Cunningham and the patterns \ncommunity who created the Portland Pattern Repository\u2014an indispensable resource for us in writing this book.\nA big thank you to Mike Loukides, Mike Hendrickson, and Meghan Blanchette. Mike L. was with \nus every step of the way. Mike, your insightful feedback helped shape the book, and your encouragement kept us \nmoving ahead. Mike H., thanks for your persistence over five years in trying to get us to write a patterns book; we \nfinally did it and we\u2019re glad we waited for Head First. \nIt takes a village to write a technical book: Bill Pugh and Ken Arnold gave us expert advice on Singleton. \nJoshua Marinacci provided rockin\u2019 Swing tips and advice. John Brewer\u2019s \u201cWhy a Duck?\u201d paper inspired \nSimUDuck (and we\u2019re glad he likes ducks too). Dan Friedman inspired the Little Singleton example. Daniel \nSteinberg acted as our \u201ctechnical liason\u201d and our emotional support network. Thanks to Apple\u2019s James \nDempsey for allowing us to use his MVC song. And thank you to Richard Warburton, who made sure our \nJava 8 code updates were up to snuff for this updated edition of the book.\nLast, a personal thank you to the Javaranch review team for their top-notch reviews and warm support. \nThere\u2019s more of you in this book than you know. \nWriting a Head First book is a wild ride with two amazing tour guides: Kathy Sierra and Bert Bates. With \nKathy and Bert you throw out all book writing convention and enter a world full of storytelling, learning theory, \ncognitive science, and pop culture, where the reader always rules. \nAt O\u2019Reilly: \nFirst and foremost, Mary Treseler is the superpower who makes everything happen and we are eternally grateful \nto her for all she does for O\u2019Reilly, Head First, and the authors. Melissa Duffield and Michele Cronin \ncleared many paths that made this second edition happen. Rachel Monaghan did an amazing copy edit, giving a \nnew sparkle to our text. Kristen Brown made the book look beautiful online and in print. Ellie Volckhausen \nworked her magic and designed a brilliant new cover for the second edition. Thank you all!\nOur 2nd edition reviewers:\nWe\u2019re grateful to our 2nd edition technical reviewers for picking up the task 15 years later. David Powers is our go-\nto reviewer (he\u2019s ours, don\u2019t even think about asking him to review your book) because he doesn\u2019t miss a thing. George \nHeineman went above and beyond with his detailed comments, suggestions, and feedback, and he received this \nedition\u2019s technical MVP award. Trisha Gee and Julian Setiawan provided the invaluable Java savvy we needed \nto help us avoid those embarrassing and cringe-worthy Java mistakes. Thank you all!\nFrom the second edition\nAcknowledgments\nour thanks\n", "page": 38, "type": "text", "section": "Page 38"}
{"text": "this is a new chapter\u2003 \u2003 1\nSomeone has already solved your problems. In this chapter, \nyou\u2019ll learn why (and how) you can exploit the wisdom and lessons learned by other \ndevelopers who\u2019ve been down the same design problem road and survived the trip. \nBefore we\u2019re done, we\u2019ll look at the use and benefits of design patterns, look at some \nkey object-oriented (OO) design principles, and walk through an example of how one \npattern works. The best way to use patterns is to load your brain with them and then \nrecognize places in your designs and existing applications where you can apply them. \nInstead of code reuse, with patterns you get experience reuse.\nWelcome to \n      Design Patterns\n1  intro to Design Patterns\nNow that we\u2019re living \nin Objectville, we\u2019ve just got to \nget into Design Patterns...everyone \nis doing them. Soon we\u2019ll be the hit \nof Jim and Betty\u2019s Wednesday night \npatterns group!\n", "page": 39, "type": "text", "section": "Page 39"}
{"text": "2\u2003 \u2003 Chapter 1\nSimUDuck\nIt started with a simple SimUDuck app\nJoe works for a company that makes a highly successful duck pond \nsimulation game, SimUDuck. The game can show a large variety of \nduck species swimming and making quacking sounds. The initial \ndesigners of the system used standard OO techniques and created \none Duck superclass from which all other duck types inherit.\nDuck\nquack()\nswim()\ndisplay()\n// OTHER duck-like methods...\ndisplay() {\n// looks like a mallard }\nMallardDuck\ndisplay() {\n// looks like a redhead }\nRedheadDuck\nLots of other types of ducks \ninherit from the Duck class. \nEach duck subtype \nis responsible \nfor implementing \nits own display() \nbehavior for how it \nlooks on the screen.\nAll ducks quack and swim. The \nsuperclass takes care of the \nimplementation code.\nIn the last year, the company has been under increasing pressure \nfrom competitors. After a week-long off-site brainstorming \nsession over golf, the company executives think it\u2019s time for a big \ninnovation. They need something really impressive to show at the \nupcoming shareholders meeting in Maui next week.\nThe display() method is \nabstract, since all duck \nsubtypes look different.\n", "page": 40, "type": "text", "section": "Page 40"}
{"text": "you are here 4\u2003 \u2003 3\nintro to design patterns\nJoe\nAll subclasses \ninherit fly().\nWhat Joe added.\nThe executives decided that flying ducks is just what the \nsimulator needs to blow away the competitors. And of course \nJoe\u2019s manager told them it\u2019ll be no problem for Joe to just \nwhip something up in a week. \u201cAfter all,\u201d said Joe\u2019s boss, \n\u201che\u2019s an OO programmer\u2026how hard can it be?\u201d\nBut now we need the ducks to FLY\nOther Duck types... \nDuck\nquack()\nswim()\ndisplay()\nfly()\n// OTHER duck-like methods...\ndisplay() {\n// looks like a mallard }\nMallardDuck\ndisplay() {\n// looks like a redhead }\nRedheadDuck\nWhat we want.\nI just need to add a \nfly() method in the Duck class \nand then all the ducks will inherit \nit. Now\u2019s my time to really show my \ntrue OO genius.\n", "page": 41, "type": "text", "section": "Page 41"}
{"text": "4\u2003 \u2003 Chapter 1\nsomething went wrong\nWhat Joe thought \nwas a great use \nof inheritance \nfor the purpose \nof reuse hasn\u2019t \nturned out so well \nwhen it comes to \nmaintenance.\nOkay, so there\u2019s a slight \nflaw in my design. I don\u2019t \nsee why they can\u2019t just call \nit a \u201cfeature.\u201d It\u2019s kind \nof cute...\nJoe failed to notice that not all \nsubclasses of Duck should fly. When \nJoe added new behavior to the \nDuck superclass, he was also adding \nbehavior that was not appropriate \nfor some Duck subclasses. He now \nhas flying inanimate objects in the \nSimUDuck program.\nA localized update to the code caused a non-\nlocal side effect (flying rubber ducks)!\nWhat happened?  \nquack()\nswim()\ndisplay()\nfly()\n// OTHER duck-like methods...\ndisplay() {\n// looks like a mallard \n}\nMallardDuck\ndisplay() {\n// looks like a redhead \n}\nRedheadDuck\nquack() {\n  // overridden to Squeak\n}\ndisplay() {\n// looks like a rubberduck \n}\nRubberDuck\nDuck\nNotice too, that rubber \nducks don\u2019t quack, so quack() \nis overridden to \u201cSqueak\u201d.\nBy putting fly() in the \nsuperclass, he gave the \nflying ability to ALL \nducks, including those \nthat shouldn\u2019t fly.\nBut something went horribly wrong...\nJoe, I\u2019m at the shareholders meeting.  \nThey just gave a demo and there were \nrubber duckies flying around the screen. \nWas this your idea of a joke? \n", "page": 42, "type": "text", "section": "Page 42"}
{"text": "you are here 4\u2003 \u2003 5\nintro to design patterns\nJoe thinks about inheritance...\nquack()  { // squeak}\ndisplay() { // rubber duck }\nfly() {\n   // override to do nothing\n}\nRubberDuck\n\u274f   A.\t Code is duplicated across subclasses.\n\u274f   B.\t Runtime behavior changes are difficult.\n\u274f   C.\t We can\u2019t make ducks dance.\n\u274f   D.\t It\u2019s hard to gain knowledge of all duck behaviors.\n\u274f   E.\t Ducks can\u2019t fly and quack at the same time.\n\u274f   F.\t Changes can unintentionally affect other ducks.\nquack() {\n  // override to do nothing\n}\ndisplay() { // decoy duck}\nfly() {\n  // override to do nothing\n}\nDecoyDuck\nHere\u2019s another class in the \nhierarchy; notice that like \nRubberDuck, it doesn\u2019t fly, \nbut it also doesn\u2019t quack.\nBut then what happens \nwhen we add wooden \ndecoy ducks to the \nprogram? They aren\u2019t \nsupposed to fly or quack...\nWhich of the following are disadvantages of using inheritance to \nprovide Duck behavior? (Choose all that apply.)\nI could always just \noverride the fly() method \nin rubber duck, like I have \nwith the quack() method...\n", "page": 43, "type": "text", "section": "Page 43"}
{"text": "6\u2003 \u2003 Chapter 1\ninheritance is not the answer\ndisplay() \nfly()\nquack()\nMallardDuck\ndisplay()\nfly()\nquack()\nRedheadDuck\ndisplay()\nquack()\nRubberDuck\nswim()\ndisplay()\n// OTHER duck-like methods...\nDuck\ndisplay()\nDecoyDuck\nfly()\nFlyable\nquack()\nQuackable\nHow about an interface?\nJoe realized that inheritance probably wasn\u2019t the \nanswer, because he just got a memo that says that \nthe executives now want to update the product every \nsix months (in ways they haven\u2019t yet decided on). Joe \nknows the spec will keep changing and he\u2019ll be forced \nto look at and possibly override fly() and quack() for \nevery new Duck subclass that\u2019s ever added to the \nprogram... forever. \nSo, he needs a cleaner way to have only some (but not \nall) of the duck types fly or quack.\nWhat do YOU think about this design?\nI could take the fly() out of the Duck \nsuperclass, and make a Flyable() interface \nwith a fly() method. That way, only the ducks \nthat are supposed to fly will implement that \ninterface and have a fly() method...and I might \nas well make a Quackable, too, since not all \nducks can quack. \n", "page": 44, "type": "text", "section": "Page 44"}
{"text": "you are here 4\u2003 \u2003 7\nintro to design patterns\nWhat would you do if you were Joe?\nWe know that not all of the subclasses should have flying or quacking \nbehavior, so inheritance isn\u2019t the right answer. But while having the \nsubclasses implement Flyable and/or Quackable solves part of the \nproblem (no inappropriately flying rubber ducks), it completely \ndestroys code reuse for those behaviors, so it just creates a different \nmaintenance nightmare. And of course there might be more than one \nkind of flying behavior even among the ducks that do fly...\nAt this point you might be waiting for a Design Pattern to come riding \nin on a white horse and save the day. But what fun would that be? No, \nwe\u2019re going to figure out a solution the old-fashioned way\u2014by applying \ngood OO software design principles.\nThat is, like, the dumbest idea \nyou\u2019ve come up with. Can you say, \n\u201cduplicate code\u201d? If you thought having \nto override a few methods was bad, how \nare you gonna feel when you need to make a \nlittle change to the flying behavior...in all 48 \nof the flying Duck subclasses?!\nWouldn\u2019t it be dreamy \nif there were a way to build software \nso that when we need to change it, we \ncould do so with the least possible \nimpact on the existing code? We could \nspend less time reworking code and \nmore making the program do cooler \nthings...\n", "page": 45, "type": "text", "section": "Page 45"}
{"text": "8\u2003 \u2003 Chapter 1\nchange is constant\nOkay, what\u2019s the one thing you can always count on in software development?\nNo matter where you work, what you\u2019re building, or what language you are programming in, what\u2019s \nthe one true constant that will be with you always?\nThe one constant in software development\nCHANGE\n(use a mirror to see the answer)\nNo matter how well you design an application, over time an \napplication must grow and change or it will die.\nMy customers or users decide they want something else, or they want new functionality.\nMy company decided it is going with another database vendor and it is also purchasing \nits data from another supplier that uses a different data format. Argh!\nLots of things can drive change. List some reasons you\u2019ve had to change code \nin your applications (we put in a couple of our own to get you started). Check \nyour answers with the solution at the end of the chapter before you go on.\n", "page": 46, "type": "text", "section": "Page 46"}
{"text": "you are here 4\u2003 \u2003 9\nintro to design patterns\nSo we know using inheritance hasn\u2019t worked out very well, since \nthe duck behavior keeps changing across the subclasses, and it\u2019s not \nappropriate for all subclasses to have those behaviors. The Flyable \nand Quackable interface sounded promising at first\u2014only ducks that \nreally do fly will be Flyable, etc.\u2014except Java interfaces typically have \nno implementation code, so no code reuse. In either case, whenever \nyou need to modify a behavior, you\u2019re often forced to track down and \nchange it in all the different subclasses where that behavior is defined, \nprobably introducing new bugs along the way!\nLuckily, there\u2019s a design principle for just this situation.\nZeroing in on the problem...\nIn other words, if you\u2019ve got some aspect of your code that is \nchanging, say with every new requirement, then you know you\u2019ve \ngot a behavior that needs to be pulled out and separated from all \nthe stuff that doesn\u2019t change. \nHere\u2019s another way to think about this principle: take the parts \nthat vary and encapsulate them, so that later you can \nalter or extend the parts that vary without affecting \nthose that don\u2019t.  \nAs simple as this concept is, it forms the basis for almost every \ndesign pattern. All patterns provide a way to let some part of  a \nsystem vary independently of  all other parts.\nOkay, time to pull the duck behavior out of the Duck classes!\nTake what varies and \n\u201cencapsulate\u201d it so it \nwon\u2019t affect the rest of \nyour code.\nThe result? Fewer \nunintended consequences \nfrom code changes and \nmore f \nlexibility in your \nsystems!\nDesign Principle\nIdentify the aspects of your \napplication that vary and separate \nthem from what stays the same. \nThe first of many design \nprinciples. We\u2019ll spend more time \non these throughout the book.\n", "page": 47, "type": "text", "section": "Page 47"}
{"text": "10\u2003 \u2003 Chapter 1\npull out what varies\nSeparating what changes from what stays the same\nD\nu\nc\nk\n \nc\nl\na\ns\ns\nThe Duck class is still the \nsuperclass of all ducks, but we \nare pulling out the fly and quack \nbehaviors and putting them into \nanother class structure.\nVarious behavior \nimplementations are \ngoing to live here.\nNow flying and quacking each \nget their own set of classes.\nDuck Behaviors\nQ\nu\na\nc\nk\ni\nn\ng\n \nB\ne\nh\navio\nr\ns\nF\nl\ny\ni\nn\ng\n \nB\ne\nh\na\nv\niors\nPull out what varies \nWhere do we start? As far as we can tell, other than the problems with fly() and quack(), the Duck \nclass is working well and there are no other parts of it that appear to vary or change frequently. So, \nother than a few slight changes, we\u2019re going to pretty much leave the Duck class alone.\nNow, to separate the \u201cparts that change from those that stay the same,\u201d we are going to create \ntwo sets of classes (totally apart from Duck), one for fly and one for quack. Each set of classes will \nhold all the implementations of the respective behavior. For instance, we might have one class that \nimplements quacking, another that implements squeaking, and another that implements silence. \nWe know that fly() and quack() are the parts of the \nDuck class that vary across ducks.\nTo separate these behaviors from the Duck class, we\u2019ll pull both methods \nout of the Duck class and create a new set of classes \nto represent each behavior.\n", "page": 48, "type": "text", "section": "Page 48"}
{"text": "you are here 4\u2003 \u2003 11\nintro to design patterns\nSo how are we going to design the set of classes that \nimplement the fly and quack behaviors?  \nWe\u2019d like to keep things flexible; after all, it was the inflexibility in \nthe duck behaviors that got us into trouble in the first place. And we \nknow that we want to assign behaviors to the instances of Duck. For \nexample, we might want to instantiate a new MallardDuck instance \nand initialize it with a specific type of flying behavior. And while \nwe\u2019re there, why not make sure that we can change the behavior of a \nduck dynamically? In other words, we should include behavior setter \nmethods in the Duck classes so that we can change the MallardDuck\u2019s \nflying behavior at runtime.\nGiven these goals, let\u2019s look at our second design principle:\nDesigning the Duck Behaviors\nDesign Principle\nProgram to an interface, not an \nimplementation.\nWe\u2019ll use an interface to represent each behavior\u2014for instance, \nFlyBehavior and QuackBehavior\u2014and each implementation of a \nbehavior will implement one of those interfaces. \nSo this time it won\u2019t be the Duck classes that will implement the \nflying and quacking interfaces. Instead, we\u2019ll make a set of classes \nwhose entire reason for living is to represent a behavior (for example, \n\u201csqueaking\u201d), and it\u2019s the behavior class, rather than the Duck class, \nthat will implement the behavior interface.\nThis is in contrast to the way we were doing things before, where \na behavior came either from a concrete implementation in the \nsuperclass Duck, or by providing a specialized implementation in the \nsubclass itself. In both cases we were relying on an implementation. We \nwere locked into using that specific implementation and there was no \nroom for changing the behavior (other than writing more code).\nWith our new design, the Duck subclasses will use a behavior \nrepresented by an interface (FlyBehavior and QuackBehavior), so that \nthe actual implementation of the behavior (in other words, the specific \nconcrete behavior coded in the class that implements the FlyBehavior \nor QuackBehavior) won\u2019t be locked into the Duck subclass.\nFrom now on, the Duck \nbehaviors will live in \na separate class\u2014a \nclass that implements \na particular behavior \ninterface.\nThat way, the Duck \nclasses won\u2019t need \nto know any of the \nimplementation details \nfor their own behaviors.\n<<interface>>\nFlyBehavior\nfly()\nfly() {\n  // implements duck flying\n}\nFlyWithWings\nfly() {\n  // do nothing - can\u2019t fly!\n}\nFlyNoWay\n", "page": 49, "type": "text", "section": "Page 49"}
{"text": "12\u2003 \u2003 Chapter 1\nprogram to an interface\nThe word interface is overloaded here. There\u2019s the concept of an \ninterface, but there\u2019s also the Java construct of an interface. You \ncan program to an interface without having to actually use a Java \ninterface. The point is to exploit polymorphism by programming \nto a supertype so that the actual runtime object isn\u2019t locked into \nthe code. And we could rephrase \u201cprogram to a supertype\u201d as \n\u201cthe declared type of the variables should be a supertype, usually \nan abstract class or interface, so that the objects assigned to \nthose variables can be of any concrete implementation of the \nsupertype, which means the class declaring them doesn\u2019t have to \nknow about the actual object types!\u201d\nThis is probably old news to you, but just to make sure we\u2019re \nall saying the same thing, here\u2019s a simple example of using a \npolymorphic type\u2014imagine an abstract class Animal, with two \nconcrete implementations, Dog and Cat. \nProgramming to an implementation would be:\nBut programming to an interface/supertype would be:\n\nEven better, rather than hardcoding the instantiation of the \nsubtype (like new Dog()) into the code, assign the concrete \nimplementation object at runtime:\n\u201cProgram to an interface\u201d really means \n\u201cProgram to a supertype.\u201d\nmakeSound()\nAnimal\nmakeSound() {\n    bark();\n}\nbark() { // bark sound }\nDog\nmakeSound() {\n   meow();\n}\nmeow() { // meow sound }\nCat\nAbstract supertype (could \nbe an abstract class OR \ninterface).\nConcrete\nimplementations.\nDeclaring the variable \u201cd\u201d as type \nDog (a concrete implementation \nof Animal) forces us to code to a \nconcrete implementation.\nWe know it\u2019s a Dog, but \nwe can now use the animal \nreference polymorphically.\nWe don\u2019t know WHAT the actual \nanimal subtype is...all we care about \nis that it knows how to respond to \nmakeSound().\nDog d = new Dog();\nd.bark();\nAnimal animal = new Dog();\nanimal.makeSound();\na = getAnimal();\na.makeSound(); \nI don\u2019t see why you \nhave to use an interface for \nFlyBehavior. You can do the \nsame thing with an abstract \nsuperclass. Isn\u2019t the whole point \nto use polymorphism?\n", "page": 50, "type": "text", "section": "Page 50"}
{"text": "you are here 4\u2003 \u2003 13\nintro to design patterns\nFlyBehavior is an interface \nthat all flying classes implement. \n \nAll new flying classes just need \nto implement the fly() method.\nHere\u2019s the implementation \nof flying for all ducks \nthat have wings.\nAnd here\u2019s the implementation \nfor all ducks that can\u2019t fly.\nQuacks that \nreally quack.\nQuacks that squeak.\nQuacks that make \nno sound at all.\nSame thing here for the quack \nbehavior; we have an interface \nthat just includes a quack() \nmethod that needs to be \nimplemented. \n<<interface>>\nFlyBehavior\nfly()\nfly() {\n  // implements duck flying\n}\nFlyWithWings\nfly() {\n  // do nothing - can\u2019t fly!\n}\nFlyNoWay\n<<interface>>\nQuackBehavior\nquack()\nquack() {\n  // implements duck quacking\n}\nQuack\nquack() {\n  // rubber duckie squeak\n}\nSqueak\nquack() {\n  // do nothing - can\u2019t quack!\n}\nMuteQuack\nImplementing the Duck Behaviors\nHere we have the two interfaces, FlyBehavior and QuackBehavior, along with \nthe corresponding classes that implement each concrete behavior:\nSo we get the benefit of \nREUSE without all the \nbaggage that comes along \nwith inheritance.\nWith this design, other types of objects can \nreuse our fly and quack behaviors because \nthese behaviors are no longer hidden away \nin our Duck classes!\nAnd we can add new behaviors without \nmodifying any of our existing behavior \nclasses or touching any of the Duck classes \nthat use flying behaviors.\n", "page": 51, "type": "text", "section": "Page 51"}
{"text": "14\u2003 \u2003 Chapter 1\nbehavior in a class\nAnswers: \n1) Create a FlyRocketPowered \nclass that implements the \nFlyBehavior interface.\n2) One example, a duck call (a \ndevice that makes duck sounds).\nUsing our new design, what would you do if you needed \nto add rocket-powered flying to the SimUDuck app?\n1\nCan you think of a class that might want to use the Quack \nbehavior that isn\u2019t a duck?\n2\nQ: Do I always have to implement my \napplication first, see where things are \nchanging, and then go back to separate \nand encapsulate those things?\nA: Not always; often when you are \ndesigning an application, you anticipate \nthose areas that are going to vary and then \ngo ahead and build the flexibility to deal \nwith it into your code. You\u2019ll find that the \nprinciples and patterns can be applied at any \nstage of the development lifecycle.\n\n\nQ: Should we make Duck an interface \ntoo?\nA: Not in this case. As you\u2019ll see once \nwe\u2019ve got everything hooked together, we do \nbenefit by having Duck not be an interface, \nand having specific ducks, like MallardDuck, \ninherit common properties and methods. \nNow that we\u2019ve removed what varies from \nthe Duck inheritance, we get the benefits of \nthis structure without the problems.\n\n\nQ: It feels a little weird to have a class \nthat\u2019s just a behavior. Aren\u2019t classes \nsupposed to represent things? Aren\u2019t \nclasses supposed to have both state AND \nbehavior?\nA: In an OO system, yes, classes \nrepresent things that generally have both \nstate (instance variables) and methods. \nAnd in this case, the thing happens to be \na behavior. But even a behavior can still \nhave state and methods; a flying behavior \nmight have instance variables representing \nthe attributes for the flying (wing beats per \nminute, max altitude, speed, etc.) behavior.\n", "page": 52, "type": "text", "section": "Page 52"}
{"text": "you are here 4\u2003 \u2003 15\nintro to design patterns\nHere\u2019s the key: A Duck will now delegate its flying and \nquacking behaviors, instead of using quacking and \nflying methods defined in the Duck class (or subclass).\nHere\u2019s how:\npublic abstract class Duck {\n   QuackBehavior quackBehavior;\n   // more\n   public void performQuack() {\n     quackBehavior.quack();\n   }\n}\nIntegrating the Duck Behaviors\nFirst we\u2019ll add two instance variables of type FlyBehavior and \nQuackBehavior\u2014let\u2019s call them flyBehavior and quackBehavior. Each concrete duck \nobject will assign to those variables a specific behavior at runtime, like FlyWithWings for \nflying and Squeak for quacking.\nWe\u2019ll also remove the fly() and quack() methods from the Duck class (and any subclasses) \nbecause we\u2019ve moved this behavior out into the FlyBehavior and QuackBehavior classes. \nWe\u2019ll replace fly() and quack() in the Duck class with two similar methods, called \nperformFly() and performQuack(); you\u2019ll see how they work next.\n1\n2\nThese methods replace \nfly() and quack().\nInstance variables hold a reference \nto a specific behavior at runtime.\nNow we implement performQuack():\nperformQuack()\nswim()\ndisplay()\nperformFly()\n// OTHER duck-like methods...\nDuck\nFlyBehavior  flyBehavior\nQuackBehavior  quackBehavior\nDuck Behaviors\nQ\nu\na\nc\nk\ni\nn\ng\n \nB\ne\nh\navio\nr\ns\nF\nl\ny\ni\nn\ng\n \nB\ne\nh\na\nv\niors\nRather than handling the quack \nbehavior itself, the Duck object \ndelegates that behavior to the object \nreferenced by quackBehavior.\nPretty simple, huh? To perform the quack, a Duck just asks the object that \nis referenced by quackBehavior to quack for it. In this part of the code we \ndon\u2019t care what kind of object the concrete Duck is, all we care about is \nthat it knows how to quack()!\nEach Duck has a reference to something that \nimplements the QuackBehavior interface.\nThe behavior variables are \ndeclared as the behavior \nINTERFACE type.\n", "page": 53, "type": "text", "section": "Page 53"}
{"text": "16\u2003 \u2003 Chapter 1\nintegrating duck behavior\nMore integration...\n3\nOkay, time to worry about how the flyBehavior and quackBehavior \ninstance variables are set. Let\u2019s take a look at the MallardDuck \nclass:\npublic class MallardDuck extends Duck {\n   public MallardDuck() {\n      quackBehavior = new Quack();\n      flyBehavior = new FlyWithWings();\n   }\n   public void display() {\n\t\nSystem.out.println(\"I'm a real Mallard duck\");\n   }\n}\nMallardDuck\u2019s quack is a real live duck quack, not a squeak and not \na mute quack. When a MallardDuck is instantiated, its constructor \ninitializes the MallardDuck\u2019s inherited quackBehavior instance \nvariable to a new instance of type Quack (a QuackBehavior concrete \nimplementation class).\nAnd the same is true for the duck\u2019s flying behavior\u2014the MallardDuck\u2019s \nconstructor initializes the inherited flyBehavior instance variable \nwith an instance of type FlyWithWings (a FlyBehavior concrete \nimplementation class).\nA MallardDuck uses the Quack \nclass to handle its quack, so when \nperformQuack() is called, the \nresponsibility for the quack is delegated \nto the Quack object and we get a real \nquack. \nAnd it uses FlyWithWings as its \nFlyBehavior type.\nRemember, MallardDuck inherits the \nquackBehavior and flyBehavior instance \nvariables from class Duck.\n", "page": 54, "type": "text", "section": "Page 54"}
{"text": "you are here 4\u2003 \u2003 17\nintro to design patterns\nGood catch, that\u2019s exactly what we\u2019re doing... \nfor now.\nLater in the book we\u2019ll have more patterns in \nour toolbox that can help us fix it.\nStill, notice that while we are setting the \nbehaviors to concrete classes (by instantiating \na behavior class like Quack or FlyWithWings \nand assigning it to our behavior reference \nvariable), we could easily change that at \nruntime.  \nSo, we still have a lot of flexibility here. That \nsaid, we\u2019re doing a poor job of initializing \nthe instance variables in a flexible way. But \nthink about it: since the quackBehavior \ninstance variable is an interface type, we \ncould (through the magic of polymorphism) \ndynamically assign a different QuackBehavior \nimplementation class at runtime.\nTake a moment and think about how you \nwould implement a duck so that its behavior \ncould change at runtime. (You\u2019ll see the code \nthat does this a few pages from now.)\nWait a second, didn\u2019t you \nsay we should NOT program to an \nimplementation? But what are we doing in that \nconstructor? We\u2019re making a new instance of a \nconcrete Quack implementation class!\n", "page": 55, "type": "text", "section": "Page 55"}
{"text": "18\u2003 \u2003 Chapter 1\ntesting duck behaviors\nTesting the Duck code\nType and compile the Duck class below (Duck.java), and the \nMallardDuck class from two pages back (MallardDuck.java).\n1\npublic abstract class Duck {\n   FlyBehavior flyBehavior;\n   QuackBehavior quackBehavior;\n   public Duck() { }\t\n\t\n \n   public abstract void display();\n   public void performFly() {\n      flyBehavior.fly();\n   }\n   public void performQuack() {\n      quackBehavior.quack();\n   } \n   public void swim() {\n      System.out.println(\"All ducks float, even decoys!\");\n   }\n}\nDeclare two reference \nvariables for the behavior \ninterface types. All duck \nsubclasses (in the same \npackage) inherit these. \nDelegate to the behavior class.\nType and compile the FlyBehavior interface (FlyBehavior.java) \nand the two behavior implementation classes (FlyWithWings.java \nand FlyNoWay.java).\n2\npublic interface FlyBehavior {\n   public void fly();\n}\npublic class FlyWithWings implements FlyBehavior { \n \n \n   public void fly() {\n\t\nSystem.out.println(\"I'm flying!!\");\n   }\n}\npublic class FlyNoWay implements FlyBehavior {\n   public void fly() {\n       System.out.println(\"I can't fly\");\n   }\n}\nThe interface that all flying \nbehavior classes implement.\nFlying behavior implementation \nfor ducks that DO fly...\nFlying behavior implementation \nfor ducks that do NOT fly (like \nrubber ducks and decoy ducks).\n", "page": 56, "type": "text", "section": "Page 56"}
{"text": "you are here 4\u2003 \u2003 19\nintro to design patterns\nFile  Edit   Window  Help  Yadayadayada\n%java MiniDuckSimulator\nQuack\nI\u2019m flying!!\npublic class MiniDuckSimulator {\n   public static void main(String[] args) {\n      Duck mallard = new MallardDuck();\n      mallard.performQuack();\n      mallard.performFly();\n   }\n}\n5\nRun the code!\nThis calls the MallardDuck\u2019s inherited \nperformQuack() method, which then delegates to \nthe object\u2019s QuackBehavior (i.e., calls quack() on \nthe duck\u2019s inherited quackBehavior reference).\nThen we do the same thing with MallardDuck\u2019s \ninherited performFly() method.\nType and compile the test class \n(MiniDuckSimulator.java).\n4\nTesting the Duck code, continued...\nType and compile the QuackBehavior interface \n(QuackBehavior.java) and the three behavior implementation \nclasses (Quack.java, MuteQuack.java, and Squeak.java).\n3\npublic interface QuackBehavior {\n   public void quack();\n}\npublic class Quack implements QuackBehavior {\n   public void quack() {\n      System.out.println(\"Quack\");\n   }\n}\npublic class MuteQuack implements QuackBehavior {\n   public void quack() {\n\t\nSystem.out.println(\"<< Silence >>\");\n   }\n}\npublic class Squeak implements QuackBehavior {\n   public void quack() {\n\t\nSystem.out.println(\"Squeak\");\n   }\n}\n", "page": 57, "type": "text", "section": "Page 57"}
{"text": "20\u2003 \u2003 Chapter 1\nducks with dynamic behavior\nSetting behavior dynamically\nWhat a shame to have all this dynamic talent built into our ducks and not be using \nit! Imagine you want to set the duck\u2019s behavior type through a setter method on the \nDuck class, rather than by instantiating it in the duck\u2019s constructor.\n1\nAdd two new methods to the Duck class:\nWe can call these methods anytime we want to change the \nbehavior of a duck on the fly.\npublic void setFlyBehavior(FlyBehavior fb) {\n    flyBehavior = fb;\n}\npublic void setQuackBehavior(QuackBehavior qb) {\n    quackBehavior = qb;\n}\nEditor note:  gratuitous pun - fix\npublic class ModelDuck extends Duck {   \n    public ModelDuck() {\n       flyBehavior = new FlyNoWay();\n\t\nquackBehavior = new Quack();\n    }\n    public void display() {\n       System.out.println(\"I'm a model duck\");\n    }\n}\npublic class FlyRocketPowered implements FlyBehavior {\n    public void fly() {\n       System.out.println(\"I'm flying with a rocket!\");\n    }\n}\n2\nOur model duck begins life grounded...\nwithout a way to fly.\nThat\u2019s okay, we\u2019re creating a \nrocket-powered flying behavior.\nMake a new Duck type (ModelDuck.java).\n3\nMake a new FlyBehavior type \n(FlyRocketPowered.java).\nswim()\ndisplay()\nperformQuack()\nperformFly()\nsetFlyBehavior()\nsetQuackBehavior()\n// OTHER duck-like methods...\nDuck\nFlyBehavior flyBehavior\nQuackBehavior quackBehavior\n", "page": 58, "type": "text", "section": "Page 58"}
{"text": "you are here 4\u2003 \u2003 21\nintro to design patterns\npublic class MiniDuckSimulator {\n    public static void main(String[] args) {\n          Duck mallard = new MallardDuck();\n          mallard.performQuack();\n          mallard.performFly();\n   \n          Duck model = new ModelDuck();\n          model.performFly();\n          model.setFlyBehavior(new FlyRocketPowered());\n          model.performFly();  \n    }\n}\nThe first call to performFly() \ndelegates to the flyBehavior object \nset in the ModelDuck\u2019s constructor, \nwhich is a FlyNoWay instance.\nFile  Edit   Window  Help  Yabbadabbadoo\n%java MiniDuckSimulator\nQuack\nI'm flying!!\nI can't fly\nI\u2019m flying with a rocket!\n4\nRun it!\n5\nChange the test class (MiniDuckSimulator.java), add the \nModelDuck, and make the ModelDuck rocket-enabled.\nThis invokes the model\u2019s inherited \nbehavior setter method, and...voil\u00e0! \nThe model suddenly has rocket-\npowered flying capability!\nIf it worked, the model duck dynamically \nchanged its flying behavior! You can\u2019t do \nTHAT if the implementation lives inside \nthe Duck class.\nTo change a duck\u2019s \nbehavior at runtime, just \ncall the duck\u2019s setter \nmethod for that behavior.\nBefore\nAfter\n", "page": 59, "type": "text", "section": "Page 59"}
{"text": "22\u2003 \u2003 Chapter 1\nthe big picture\nBelow is the entire reworked class structure. We have everything you\u2019d expect: \nducks extending Duck, fly behaviors implementing FlyBehavior, and quack \nbehaviors implementing QuackBehavior.\nNotice also that we\u2019ve started to describe things a little differently. Instead \nof thinking of the duck behaviors as a set of  behaviors, we\u2019ll start thinking of \nthem as a family of  algorithms. Think about it: in the SimUDuck design, the \nalgorithms represent things a duck would do (different ways of quacking or \nflying), but we could just as easily use the same techniques for a set of classes \nthat implement the ways to compute state sales tax by different states. \nPay careful attention to the relationships between the classes. In fact, grab \nyour pen and write the appropriate relationship (IS-A, HAS-A, and \nIMPLEMENTS) on each arrow in the class diagram.\nThe Big Picture on encapsulated behaviors\nOkay, now that we\u2019ve done the deep dive on the \nduck simulator design, it\u2019s time to come back up \nfor air and take a look at the big picture.\nswim()\ndisplay()\nperformQuack()\nperformFly()\nsetFlyBehavior()\nsetQuackBehavior()\n// OTHER duck-like methods...\nDuck\nFlyBehavior flyBehavior\nQuackBehavior quackBehavior\n<<interface>>\nFlyBehavior\nfly()\nfly() {\n  // implements duck flying\n}\nFlyWithWings\nfly() {\n  // do nothing - can\u2019t fly!\n}\nFlyNoWay\n<<interface>>\nQuackBehavior\nquack()\nquack() {\n  // implements duck quacking\n}\nQuack\nquack() {\n  // rubber duckie squeak\n}\nSqueak\nquack() {\n  // do nothing - can\u2019t quack!\n}\nMuteQuack\ndisplay() {\n// looks like a decoy duck }\nDecoyDuck\ndisplay() {\n// looks like a mallard }\nMallardDuck\ndisplay() {\n// looks like a redhead }\nRedheadDuck\ndisplay() {\n// looks like a rubberduck }\nRubberDuck\nEncapsulated fly behavior\nEncapsulated quack behavior\nThink of each \nset of behaviors \nas a family of \nalgorithms.\nClient \nThese behaviors \n\u201calgorithms\u201d are \ninterchangeable.\nClient makes use of an \nencapsulated family of algorithms \nfor both flying and quacking.\nMake sure you do this.\n", "page": 60, "type": "text", "section": "Page 60"}
{"text": "you are here 4\u2003 \u2003 23\nintro to design patterns\nThe HAS-A relationship is an interesting one: each duck \nhas a FlyBehavior and a QuackBehavior to which it \ndelegates flying and quacking.  \nWhen you put two classes together like this you\u2019re using \ncomposition. Instead of inheriting their behavior, the \nducks get their behavior by being composed with the right \nbehavior object. \nThis is an important technique; in fact, it is the basis of our \nthird design principle:\nDesign Principle\nFavor composition over inheritance.\nAs you\u2019ve seen, creating systems using composition gives you \na lot more flexibility. Not only does it let you encapsulate \na family of algorithms into their own set of classes, but it \nalso lets you change behavior at runtime as long as \nthe object you\u2019re composing with implements the correct \nbehavior interface. \nComposition is used in many design patterns and you\u2019ll see a \nlot more about its advantages and disadvantages throughout \nthe book. \nGuru and Student...\nGuru: Tell me what you \nhave learned of the \nObject-Oriented ways.\nStudent: Guru, I have \nlearned that the promise of the object-\noriented way is reuse.\nGuru: Continue...\nStudent: Guru, through inheritance all \ngood things may be reused and so we \ncome to drastically cut development \ntime like we swiftly cut bamboo in the \nwoods.\nGuru: Is more time spent on code \nbefore or after development is \ncomplete?\nStudent: The answer is after, \nGuru. We always spend more time \nmaintaining and changing software \nthan on initial development.\nGuru: So, should effort go into reuse \nabove maintainability and extensibility?\nStudent: Guru, I believe that there is \ntruth in this.\nGuru: I can see that you still have \nmuch to learn. I would like for you to \ngo and meditate on inheritance further. \nAs you\u2019ve seen, inheritance has its \nproblems, and there are other ways of \nachieving reuse.\nHAS-A can be better than IS-A\nA duck call is a device that hunters use to \nmimic the calls (quacks) of ducks. How \nwould you implement your own duck call \nthat does not inherit from the Duck class?\n", "page": 61, "type": "text", "section": "Page 61"}
{"text": "24\u2003 \u2003 Chapter 1\nthe strategy pattern\nCongratulations on \nyour first pattern!\nYou just applied your first design pattern\u2014the STRATEGY \nPattern. That\u2019s right, you used the Strategy Pattern to \nrework the SimUDuck app.\nThanks to this pattern, the simulator is ready for any \nchanges those execs might cook up on their next \nbusiness trip to Maui.\nNow that we\u2019ve made you take the long road to learn it, \nhere\u2019s the formal definition of this pattern:\nThe Strategy Pattern defines a family of algorithms, \nencapsulates each one, and makes them interchangeable.  \nStrategy lets the algorithm vary independently from \nclients that use it.\nSpeaking of Design Patterns...\nUse THIS definition when you \nneed to impress friends and \ninfluence key executives.\n", "page": 62, "type": "text", "section": "Page 62"}
{"text": "you are here 4\u2003 \u2003 25\nintro to design patterns\nBelow you\u2019ll find a mess of classes and interfaces for an action adventure game. You\u2019ll \nfind classes for game characters along with classes for weapon behaviors the characters \ncan use in the game. Each character can make use of one weapon at a time, but can \nchange weapons at any time during the game. Your job is to sort it all out...\n(Answers are at the end of the chapter.)\nCharacter\nWeaponBehavior weapon\nsetWeapon(WeaponBehavior w) {\n    this.weapon = w;\n}\nfight()\nKnifeBehavior\nuseWeapon() { // implements \ncutting with a knife }\nQueen\nfight() { ... }\nKing\nfight() { ... }\nTroll\nfight() { ... }\nBowAndArrowBehavior\nuseWeapon() { // implements \nshooting an arrow with a bow }\nKnight\nfight() { ... }\n<<interface>>\nWeaponBehavior\nuseWeapon();\nAxeBehavior\nuseWeapon() { // implements \nchopping with an axe }\nSwordBehavior\nuseWeapon() { // implements \nswinging a sword }\n1.   Arrange the classes.\n2.   Identify one abstract class, one interface, and eight classes.\n3.   Draw arrows between classes.\n\t\na. Draw this kind of arrow for inheritance (\u201cextends\u201d).\n\t\nb. Draw this kind of arrow for interface (\u201cimplements\u201d).\n\t\nc. Draw this kind of arrow for HAS-A. \n4.   Put the method setWeapon() into the right class.\n1\n2\n3\n4\nYour task:\n Design Puzzle\n", "page": 63, "type": "text", "section": "Page 63"}
{"text": "26\u2003 \u2003 Chapter 1\ndiner talk\nOverheard at the local diner...\nWhat\u2019s the difference between these two orders? Not a thing! They\u2019re both the \nsame order, except Alice is using twice the number of words and trying the \npatience of a grumpy short-order cook.  \nWhat\u2019s Flo got that Alice doesn\u2019t? A shared vocabulary with the short-order \ncook. Not only does that make it easier to communicate with the cook, but it gives \nthe cook less to remember because he\u2019s got all the diner patterns in his head.\nDesign Patterns give you a shared vocabulary with other developers. Once you\u2019ve \ngot the vocabulary, you can more easily communicate with other developers and \ninspire those who don\u2019t know patterns to start learning them. It also elevates your \nthinking about architectures by letting you think at the pattern level, not the \nnitty-gritty object level.\nFlo\nAlice\nI need a cream cheese with jelly on white \nbread, a chocolate soda with vanilla ice cream, a \ngrilled cheese sandwich with bacon, a tuna fish \nsalad on toast, a banana split with ice cream & sliced \nbananas, and a coffee with a cream and two sugars ... \noh, and put a hamburger on the grill!\nGive me a C.J. White, \na black & white, a Jack \nBenny, a radio, a house boat, a \ncoffee regular, and burn one!\n", "page": 64, "type": "text", "section": "Page 64"}
{"text": "you are here 4\u2003 \u2003 27\nintro to design patterns\nOverheard in the next cubicle...\nRick\nCan you think of other shared \nvocabularies that are used \nbeyond OO design and diner \ntalk? (Hint: how about auto \nmechanics, carpenters, gourmet \nchefs, and air traffic controllers?) \nWhat qualities are communicated \nalong with the lingo?\nCan you think of aspects of OO \ndesign that get communicated \nalong with pattern names? What \nqualities get communicated along \nwith the name \u201cStrategy Pattern\u201d?\nSo I created this broadcast class. It keeps \ntrack of all the objects listening to it, and \nanytime a new piece of data comes along it sends \na  message to each listener. What\u2019s cool is that the \nlisteners can join the broadcast at any time or \nthey can even remove themselves. It is really \ndynamic and loosely coupled!\nExactly. If you communicate \nin patterns, then other developers \nknow immediately and precisely the \ndesign you\u2019re describing. Just don\u2019t \nget Pattern Fever...you\u2019ll know you \nhave it when you start using patterns \nfor Hello World...\nRick, why didn\u2019t you \njust say you are using \nthe Observer Pattern?\n", "page": 65, "type": "text", "section": "Page 65"}
{"text": "28\u2003 \u2003 Chapter 1\nshared vocabulary\nShared pattern vocabularies are POWERFUL.  \nWhen you communicate with another developer or your \nteam using patterns, you are communicating not just a \npattern name but a whole set of qualities, characteristics, \nand constraints that the pattern represents.\nPatterns allow you to say more with less. When you \nuse a pattern in a description, other developers quickly \nknow precisely the design you have in mind.\nTalking at the pattern level allows you to stay \u201cin \nthe design\u201d longer. Talking about software systems using \npatterns allows you to keep the discussion at the design \nlevel, without having to dive down to the nitty-gritty details \nof implementing objects and classes.\nShared vocabularies can turbo-charge your \ndevelopment team. A team well versed in design \npatterns can move more quickly with less room for \nmisunderstanding.\nShared vocabularies encourage more  junior \ndevelopers to get up to speed.  Junior developers look \nup to experienced developers. When senior developers \nmake use of design patterns, junior developers also become \nmotivated to learn them. Build a community of pattern \nusers at your organization.\nThe power of a shared pattern vocabulary\nWhen you communicate using patterns, you \nare doing more than just sharing LINGO.\n\u201cWe\u2019re using the Strategy Pattern to \nimplement the various behaviors of our \nducks.\u201d This tells you the duck behavior \nhas been encapsulated into its own set \nof classes that can be easily expanded \nand changed, even at runtime if needed.\nHow many design meetings have you \nbeen in that quickly degrade into \nimplementation details?  \nThink about starting a patterns \nstudy group at your organization. \nMaybe you can even get paid while \nyou\u2019re learning...\nAs your team begins to share \ndesign ideas and experience in \nterms of patterns, you will build \na community of pattern users.\n", "page": 66, "type": "text", "section": "Page 66"}
{"text": "you are here 4\u2003 \u2003 29\nintro to design patterns\nWe\u2019ve all used off-the-shelf libraries and frameworks. We take them, write some code against their APIs, \ncompile them into our programs, and benefit from a lot of code someone else has written. Think about \nthe Java APIs and all the functionality they give you: network, GUI, IO, etc. Libraries and frameworks go \na long way toward a development model where we can just pick and choose components and plug them \nright in. But...they don\u2019t help us structure our own applications in ways that are easier to understand, more \nmaintainable, and more flexible. That\u2019s where design patterns come in.\nDesign patterns don\u2019t go directly into your code, they first go into your BRAIN. Once you\u2019ve loaded your \nbrain with a good working knowledge of patterns, you can then start to apply them to your new designs, \nand rework your old code when you find it\u2019s degrading into an inflexible mess.\nHow do I use Design Patterns?\nYour BRAIN\nYour Code, now new \nand improved with \ndesign patterns!\nA Bunch of Patterns\nswim()\ndisplay()\nperformQuack()\nperformFly()\nsetFlyBehavior()\nsetQuackBehavior()\n// OTHER duck-like methods...\nDuck\nFlyBehavior flyBehavior;\nQuackBehavior quackBehavior;\n<<interface>>\nFlyBehavior\nfly()\nfly() {\n  // implements duck flying\n}\nFlyWithWings\nfly() {\n  // do nothing - can\u2019t fly!\n}\nFlyNoWay\n<<interface>>\nQuackBehavior\nquack()\nquack) {\n  // implements duck quacking\n}\nQuack\nquack() {\n  // rubber duckie squeak\n}\nSqueak\nquack() {\n  // do nothing - can\u2019t quack!\n}\nMuteQuack\ndisplay() {\n// looks like a decoy duck }\nDecoy Duck\ndisplay() {\n// looks like a mallard }\nMallard Duck\ndisplay() {\n// looks like a redhead }\nRedhead Duck\ndisplay() {\n// looks like a rubberduck }\nRubber Duck\nEncapsulated fly behavior\nEncapsulated quack behavior\nClient \nView\nController\nModel\nRequest\nMVC\nS\nu\nb\nj\ne\nc\nt\n \nOb\nj\ne\nc\nt\n8\nint\n \n \n \nD\no\ng\n \nO\nb\nj\ne\nc\nt\nM\no\nu\ns\ne\n \nO\nb\njec\nt\n \n \nC\na\nt\n \nO\nb\nj\ne\nct\n \n \nD\nu\nc\nk\n \nO\nb\njec\nt\nObservers\n8\n8\n8\n8\nAutomatic update/notification\nObject that \nholds state\nDependent Objects\nQ: If design patterns are so great, why \ncan\u2019t someone build a library of them so I \ndon\u2019t have to?\nA: Design patterns are higher level than \nlibraries. Design patterns tell us how to \nstructure classes and objects to solve certain \nproblems, and it is our job to adapt those \ndesigns to fit our particular application.\n\nQ: Aren\u2019t libraries and frameworks \nalso design patterns?\nA: Frameworks and libraries are not \ndesign patterns; they provide specific \nimplementations that we link into our \ncode. Sometimes, however, libraries and \nframeworks make use of design patterns in \ntheir implementations. That\u2019s great, because \nonce you understand design patterns, you\u2019ll \nmore quickly understand APIs that are \nstructured around design patterns.\nQ: So, there are no libraries of design \npatterns?\nA: No, but you will learn later about \npatterns catalogs with lists of patterns that \nyou can apply to your applications.\n", "page": 67, "type": "text", "section": "Page 67"}
{"text": "30\u2003 \u2003 Chapter 1\nwhy design patterns?\nSkeptical Developer\nFriendly Patterns Guru\nDeveloper:  Okay, hmm, but isn\u2019t this all just good object-oriented design; I \nmean as long as I follow encapsulation and I know about abstraction, inheritance, \nand polymorphism, do I really need to think about Design Patterns? Isn\u2019t it pretty \nstraightforward? Isn\u2019t this why I took all those OO courses? I think Design Patterns \nare useful for people who don\u2019t know good OO design.\nGuru:  Ah, this is one of the true misunderstandings of object-oriented \ndevelopment: that by knowing the OO basics we are automatically going to be good at \nbuilding flexible, reusable, and maintainable systems.\nDeveloper: No?\nGuru: No. As it turns out, constructing OO systems that have these properties is \nnot always obvious and has been discovered only through hard work.\nDeveloper: I think I\u2019m starting to get it. These, sometimes non-obvious, ways of \nconstructing object-oriented systems have been collected...\nGuru: ...yes, into a set of patterns called Design Patterns.\nDeveloper: So, by knowing patterns, I can skip the hard work and jump straight to \ndesigns that always work?\nGuru: Yes, to an extent, but remember, design is an art. There will always be \ntradeoffs. But, if you follow well-thought-out and time-tested design patterns, you\u2019ll \nbe way ahead.  \nDeveloper: What do I do if I can\u2019t find a pattern?\nPatterns are nothing \nmore than using OO \ndesign principles...\nA common misconception, \nbut it\u2019s more subtle than that. \nYou have much to learn...\n", "page": 68, "type": "text", "section": "Page 68"}
{"text": "you are here 4\u2003 \u2003 31\nintro to design patterns\nGuru: There are some object-oriented principles that \nunderlie the patterns, and knowing these will help you \nto cope when you can\u2019t find a pattern that matches your \nproblem.\nDeveloper: Principles? You mean beyond abstraction, \nencapsulation, and...\nGuru: Yes, one of the secrets to creating maintainable \nOO systems is thinking about how they might change in the \nfuture, and these principles address those issues.\nRemember, knowing concepts \nlike abstraction, inheritance, and \npolymorphism does not make you a good \nobject-oriented designer. A design guru \nthinks about how to create flexible \ndesigns that are maintainable and can \ncope with change.\n", "page": 69, "type": "text", "section": "Page 69"}
{"text": "32\u2003 \u2003 Chapter 1\nyour design toolbox\nTools for your Design Toolbox\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies.\nFavor composition over \ninheritance.\nProgram to interfaces, not \nimplementations.\nOO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it.\nOO Patterns\nWe assume you know the \nOO basics like abstraction, \nencapsulation, polymorphism, \nand inheritance. If you are a \nlittle rusty on these, pull out \nyour favorite object-oriented \nbook and review, then skim \nthis chapter again.\nWe\u2019ll be taking a closer look at \nthese down the road and also \nadding a few more to the list.\nOne down, many to go!  \nThroughout the \nbook, think about \nhow patterns rely \non OO basics and \nprinciples.\nYou\u2019ve nearly made it through the first chapter!  You\u2019ve \nalready put a few tools in your OO toolbox; let\u2019s make a \nlist of them before we move on to Chapter 2.\n\t\n\u0083\nKnowing the OO basics \ndoes not make you a good \nOO designer.\n\t\n\u0083\nGood OO designs are \nreusable, extensible, and \nmaintainable.\n\t\n\u0083\nPatterns show you how to \nbuild systems with good \nOO design qualities.\n\t\n\u0083\nPatterns are proven \nobject-oriented \nexperience.\n\t\n\u0083\nPatterns don\u2019t give you \ncode, they give you \ngeneral solutions to \ndesign problems. You \napply them to your specific \napplication.\n\t\n\u0083\nPatterns aren\u2019t invented, \nthey are discovered.\n\t\n\u0083\nMost patterns and \nprinciples address issues \nof change in software.\n\t\n\u0083\nMost patterns allow some \npart of a system to vary \nindependently of all other \nparts.\n\t\n\u0083\nWe often try to take what \nvaries in a system and \nencapsulate it.\n\t\n\u0083\nPatterns provide a \nshared language that can \nmaximize the value of \nyour communication with \nother developers.\n", "page": 70, "type": "text", "section": "Page 70"}
{"text": "you are here 4\u2003 \u2003 33\nintro to design patterns\nDesign Patterns Crossword\nLet\u2019s give your right brain something to do. \nIt\u2019s your standard crossword; all of the solution words \nare from this chapter. \nACROSS\n1. Paatterns can help us build ________ applications.\n4. Strategies can be __________. \n7. Favor this over inheritance. \n8. Development constant.\n9. Java IO, Networking, Sound. \n10. Most patterns follow from OO _________. \n12. Design patterns are a shared __________.\n14. High-level libraries.\n15. Learn from the other guy's ___________. \n17. Pattern that fixed the simulator. \n18. Program to this, not an implementation.\n\n\n\nDOWN\n2. Patterns go into your _______. \n3. Duck that can't quack.\n5. Rubber ducks make a _______.\n6. ________ what varies.\n11. Grilled cheese with bacon.\n13. Rick was thrilled with this pattern. \n16. Duck demo was located here.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nAcross\n1. Patterns can help us build ____ applications\n4. Strategies can be _______\n7. Favor over inheritance\n8. Development constant\n9. Java IO, Networking, Sound \n10. Most patterns follow from OO _______\n12. Design patterns are a shared _____\n14. High level libraries\n15. Learn from the other guy's _______\n17. Pattern that fixed the simulator\n18. Program to this, not an implementation\nDown\n2. Patterns go into your _______\n3. Duck that can't quack\n5. Rubberducks make a ________\n6. _______ what varies\n11. Grilled cheese with bacon\n13. Rick was thrilled with this pattern\n16. Duck demo was located where\n", "page": 71, "type": "text", "section": "Page 71"}
{"text": "34\u2003 \u2003 Chapter 1\ndesign puzzle solution\n<<interface>> \nWeaponBehavior\nCharacter is the abstract class for all the other characters (King, Queen, \nKnight, and Troll), while WeaponBehavior is an interface that all weapon \nbehaviors implement. So all actual characters and weapons are concrete \nclasses.\nTo switch weapons, each character calls the setWeapon() method, which \nis defined in the Character superclass. During a fight the useWeapon() \nmethod is called on the current weapon set for a given character to inflict \ngreat bodily damage on another character.\nCharacter\nWeaponBehavior weapon\nfight()\nsetWeapon(WeaponBehavior w) {\n    this.weapon = w;\n}\nKing\nfight() { ... }\nQueen\nfight() { ... }\nKnight\nfight() { ... }\nTroll\nfight() { ... }\nuseWeapon()\nBowAndArrowBehavior\nuseWeapon() { // implements \nshooting an arrow with a bow }\nAxeBehavior\nuseWeapon() { // implements \nchopping with an axe }\nSwordBehavior\nuseWeapon() { // implements \nswinging a sword }\nKnifeBehavior\nuseWeapon() { // implements \ncutting with a knife }\n Design Puzzle Solution\nNote that ANY object could \nimplement the WeaponBehavior \ninterface\u2014say, a paper clip, a tube of \ntoothpaste, or a mutated sea bass.\nAbstract\nA Character HAS-A \nWeaponBehavior.\n", "page": 72, "type": "text", "section": "Page 72"}
{"text": "you are here 4\u2003 \u2003 35\nintro to design patterns\n\u274f   A.\t Code is duplicated across subclasses.\n\u274f   B.\t Runtime behavior changes are difficult.\n\u274f   C.\t We can\u2019t make ducks dance.\n\u274f   D.\t It\u2019s hard to gain knowledge of all duck behaviors.\n\u274f   E.\t Ducks can\u2019t fly and quack at the same time.\n\u274f   F.\t Changes can unintentionally affect other ducks.\nMy customers or users decide they want something else, or they want new functionality.\nMy company decided it is going with another database vendor and it is also purchasing its data \nfrom another supplier that uses a different data format. Argh!\nWell, technology changes and we\u2019ve got to update our code to make use of protocols.\nWe\u2019ve learned enough building our system that we\u2019d like to go back and do things a little better.\nWhich of the following are disadvantages of using subclassing to provide \nspecific Duck behavior? (Choose all that apply.) Here\u2019s our solution.\nWhat are some factors that drive change in your applications? \nYou might have a very different list, but here\u2019s a few of ours. Look \nfamiliar? Here\u2019s our solution.\n", "page": 73, "type": "text", "section": "Page 73"}
{"text": "36\u2003 \u2003 Chapter 1\nDesign Patterns Crossword Solution\nF\n1\nL\nE\nX\nI\nB\n2\nL\nE\nD\n3\nR\nR\n4\nE\nU\nS\n5\nE\nD\nE\nA\nE\n6\nQ\nC\n7\nO\nM\nP\nO\nS\nI\nT\nI\nO\nN\nU\nO\nN\nC\n8\nH\nA\nN\nG\nE\nY\nA\nA\n9\nP\nI\nS\nD\nP\n10\nR\nI\nN\nC\nI\nP\nL\nE\nS\nK\nU\nS\nJ\n11\nC\nV\n12\nO\nC\nA\nB\nU\nL\nA\nR\nY\nA\nK\nO\n13\nL\nC\nB\nF\n14\nR\nA\nM\nE\nW\nO\nR\nK\nS\nS\nT\nB\nE\n15\nX\nP\nE\nR\nI\nE\nN\nC\nE\nE\nM\n16\nR\nN\nA\nV\nN\nU\nE\nS\n17\nT\nR\nA\nT\nE\nG\nY\nI\n18\nN\nT\nE\nR\nF\nA\nC\nE\nAcross\n1. Patterns can help us build ____ applications \n[FLEXIBLE] \n4. Strategies can be _______ [REUSED] \n7. Favor over inheritance [COMPOSITION] \n8. Development constant [CHANGE] \n9. Java IO, Networking, Sound  [APIS] \n10. Most patterns follow from OO _______ \n[PRINCIPLES] \n12. Design patterns are a shared _____ \n[VOCABULARY] \n14. High level libraries [FRAMEWORKS] \nDown\n2. Patterns go into your _______ [BRAIN] \n3. Duck that can't quack [DECOYDUCK] \n5. Rubberducks make a ________ [SQUEAK] \n6. _______ what varies [ENCAPSULATE] \n11. Grilled cheese with bacon [JACKBENNY] \n13. Rick was thrilled with this pattern [OBSERVER] \n16. Duck demo was located where [MAUI] \ncrossword solution\n", "page": 74, "type": "text", "section": "Page 74"}
{"text": "this is a new chapter\u2003 \u2003 37\nYou don\u2019t want to miss out when something interesting \nhappens, do you? We\u2019ve got a pattern that keeps your objects in the \nknow when something they care about happens. It\u2019s the Observer Pattern. It is \none of the most commonly used design patterns, and it\u2019s incredibly useful. We\u2019re \ngoing to look at all kinds of interesting aspects of Observer, like its one-to-many \nrelationships and loose coupling. And, with those concepts in mind, how can you \nhelp but be the life of the Patterns Party? \nKeeping your \n Objects in the Know\n2  the Observer Pattern\nHey Jerry, I\u2019m notifying \neveryone that the Patterns Group \nmeeting moved to Saturday night.  \nWe\u2019re going to be talking about the \nObserver Pattern. That pattern is \nthe best! It\u2019s the BEST, Jerry!\n", "page": 75, "type": "text", "section": "Page 75"}
{"text": "38\u2003 \u2003 Chapter 2\nweather monitoring station\nWeather-O-Rama, Inc.\n100 Main Street\nTornado Alley, OK 45021\nStatement of Work\nYour team has just won the contract to build \nWeather-O-Rama, Inc.\u2019s next-generation, \ninternet-based Weather Monitoring Station.\nCongratulations! \nCongratulations on being selected to build our next-generation, \ninternet-based Weather Monitoring Station!\nThe weather station will be based on our patent pending \nWeatherData object, which tracks current weather conditions \n(temperature, humidity, and barometric pressure). We\u2019d like \nyou to create an application that initially provides three display \nelements: current conditions, weather statistics, and a simple \nforecast, all updated in real time as the WeatherData object \nacquires the most recent measurements.\nFurther, this is an expandable weather station. Weather-O-\nRama wants to allow other developers to write their own \nweather displays and plug them right in. So it\u2019s important that \nnew displays will be easy to add in the future.\nWeather-O-Rama thinks we have a great business model: once \nthe customers are hooked, we intend to charge them for each \ndisplay they use. Now for the best part: we are going to pay you \nin stock options.\nWe look forward to seeing your design and alpha application.\nSincerely,\nJohnny Hurricane, CEO\nP\n.S. See the attached WeatherData source files!\n", "page": 76, "type": "text", "section": "Page 76"}
{"text": "you are here 4\u2003 \u2003 39\nthe observer pattern\nThe Weather Monitoring application overview\nLet\u2019s take a look at the Weather Monitoring application we need to deliver\u2014both \nwhat Weather-O-Rama is giving us, and what we\u2019re going to need to build or \nextend. The system has three components: the weather station (the physical device \nthat acquires the actual weather data), the WeatherData object (that tracks the data \ncoming from the Weather Station and updates the displays), and the display that \nshows users the current weather conditions:\nWeatherData \nobject\nWeather Station\nDisplay device\nTemperature \nsensor device\nHumidity \nsensor device\nPressure \nsensor device\npulls data\ndisplays\nCurrent \nConditions\nTemp: 72\u00b0\nHumidity: 60\nPressure:\nThe WeatherData object was written by Weather-O-Rama and knows how to talk \nto the physical Weather Station to get updated weather data. We\u2019ll need to adapt \nthe WeatherData object so that it knows how to update the display. Hopefully \nWeather-O-Rama has given us hints for how to do this in the source code. \nRemember, we\u2019re responsible for implementing three different display elements: \nCurrent Conditions (shows temperature, humidity, and pressure), Weather \nStatistics, and a simple Forecast.\nSo, our job, if we choose to accept it, is to create an app \nthat uses the WeatherData object to update three displays \nfor current conditions, weather stats, and a forecast.\nThe user can view one of three different \ndisplays: the current conditions, weather \nstats, or a forecast.\nWhat Weather-O-Rama \nis providing\nWhat we need to implement.\nWe\u2019ll also need to integrate \nthe WeatherData object with \nthe display.\n", "page": 77, "type": "text", "section": "Page 77"}
{"text": "40\u2003 \u2003 Chapter 2\nweather data class\nUnpacking the WeatherData class\nWeatherData\ngetTemperature()\ngetHumidity()\ngetPressure()\nmeasurementsChanged()\n// other methods\nLet\u2019s check out the source code attachments that Johnny Hurricane, \nthe CEO, sent over. We\u2019ll start with the WeatherData class:\nThese three methods return the most recent weather measurements \nfor temperature, humidity, and barometric pressure, respectively.\nWe don\u2019t care right now HOW it gets this data, we just know that the \nWeatherData object gets updated info from the Weather Station. \nNote that whenever WeatherData has updated values, the \nmeasurementsChanged() method is called.\nLet\u2019s looks at the measurementsChanged() \nmethod, which, again, gets called anytime \nthe WeatherData obtains new values for \ntemp, humidity, and pressure.\n/* \n * This method gets called \n * whenever the weather measurements\n * have been updated\n * \n */\npublic void measurementsChanged() {\n    // Your code goes here\n}\nWeatherData.java\nDisplay device\nCurrent \nConditions\nTemp: 72\u00b0\nHumidity: 60\nPressure:\nSo, our job is to alter the measurementsChanged() \nmethod so that it updates the three displays for \ncurrent conditions, weather stats, and forecast.\nOur soon-to-be-\nimplemented display.\nHere is our WeatherData class.\nIt looks like Weather-O-Rama left a note in the comments to \nadd our code here. So perhaps this is where we need to update \nthe display (once we\u2019ve implemented it)\n", "page": 78, "type": "text", "section": "Page 78"}
{"text": "you are here 4\u2003 \u2003 41\nthe observer pattern\n\t\n\u25cf\nWe know the WeatherData class has getter methods for \nthree measurement values: temperature, humidity, and \nbarometric pressure.\n\t\n\u25cf\nWe know the measurementsChanged() method is called \nanytime new weather measurement data is available. (Again, \nwe don\u2019t know or care how this method is called; we just \nknow that it is called.)\n\t\n\u25cf\nWe\u2019ll need to implement three display elements that use the \nweather data: a current conditions display, a statistics display, \nand a forecast display. These displays must be updated as \noften as the WeatherData has new measurements.\n\t\n\u25cf\nTo update the displays, we\u2019ll add code to the \nmeasurementsChanged() method.\nOur Goal\nWe know we need to implement a display and then have the WeatherData \nupdate that display each time it has new values, or, in other words, each time \nthe measurementsChanged() method is called. But how? Let\u2019s think through \nwhat we\u2019re trying to acheive:\nDisplay One\nCurrent \nConditions\nTemp: 72\u00b0\nHumidity: 60\nPressure:\nDisplay Two\nWeather\nStats\nAvg. temp: 62\u00b0\nMin. temp:  50\u00b0\nMax. temp: 78\u00b0\nDisplay Three\nForecast\nTT\nT\nFuture displays\n?\nStretch Goal\n\t\n\u25cf\nExpandability\u2014other developers may want to create new \ncustom displays. Why not allow users to add (or remove) \nas many display elements as they want to the application? \nCurrently, we know about the initial three display types \n(current conditions, statistics, and forecast), but we expect a \nvibrant marketplace for new displays in the future.\nBut let\u2019s also think about the future\u2014remember the constant in software \ndevelopment? Change. We expect, if the Weather Station is successful, there \nwill be more than three displays in the future, so why not create a marketplace \nfor additional displays? So, how about we build in:\n", "page": 79, "type": "text", "section": "Page 79"}
{"text": "42\u2003 \u2003 Chapter 2\nfirst try with the weather station\npublic class WeatherData {\n    // instance variable declarations\n    public void measurementsChanged() {\n        float temp = getTemperature();\n        float humidity = getHumidity();\n        float pressure = getPressure();\n        currentConditionsDisplay.update(temp, humidity, pressure);\n        statisticsDisplay.update(temp, humidity, pressure);\n        forecastDisplay.update(temp, humidity, pressure);\n    }\n    // other WeatherData methods here\n}\n...by calling its update method \nand passing it the most recent \nmeasurements.\nFirst, we grab the most recent measurements by \ncalling the WeatherData\u2019s getter methods. We assign \neach value to an appropriately named variable.\nTaking a first, misguided implementation \nof the Weather Station\nHere\u2019s a first implementation possibility\u2014as we\u2019ve discussed, we\u2019re going to add our code to \nthe measurementsChanged() method in the WeatherData class:\n\u274f   A.\t We are coding to concrete \nimplementations, not interfaces.\n\u274f   B.\t For every new display we\u2019ll need to \nalter this code.\n\u274f   C.\t We have no way to add (or remove) \ndisplay elements at runtime.\n\u274f   D.\t The display elements don\u2019t implement a \ncommon interface.\n\u274f   E.\t We haven\u2019t encapsulated the part that \nchanges.                  \n\u274f   F.\t We are violating encapsulation of the \nWeatherData class.\nNext we\u2019re going to \nupdate each display...\nBased on our first implementation, which of the following apply?  \n(Choose all that apply.)\nHere\u2019s the measurementsChanged() method.\nAnd here are our code additions...\n", "page": 80, "type": "text", "section": "Page 80"}
{"text": "you are here 4\u2003 \u2003 43\nthe observer pattern\nThink back to all those Chapter 1 concepts and principles\u2014which are we violating, and \nwhich are we not? Think in particular about the effects of change on this code. Let\u2019s work \nthrough our thinking as we look at the code:\nWhat\u2019s wrong with our implementation anyway?\npublic void measurementsChanged() {\n    float temp = getTemperature();\n    float humidity = getHumidity();\n    float pressure = getPressure();\n    currentConditionsDisplay.update(temp, humidity, pressure);\n    statisticsDisplay.update(temp, humidity, pressure);\n    forecastDisplay.update(temp, humidity, pressure);\n}\nBy coding to concrete \nimplementations, we have no way \nto add or remove other display \nelements without making changes to \nthe code.\nLooks like an area of \nchange. We need to \nencapsulate this.\nAt least we seem to be using a \ncommon interface to talk to the \ndisplay elements...they all have an \nupdate() method that takes the \ntemp, humidity, and pressure values.\nGood idea. Let\u2019s take a look at \nObserver, then come back and figure \nout how to apply it to the Weather \nMonitoring app. \nUmm, I know I\u2019m \nnew here, but given that we \nare in the Observer Pattern \nchapter, maybe we should \nstart using it?\nLet\u2019s take another look...\nWhat if we want to add or remove \ndisplays at runtime? This looks \nhardcoded.\n", "page": 81, "type": "text", "section": "Page 81"}
{"text": "44\u2003 \u2003 Chapter 2\nmeet the observer pattern\nMeet the Observer Pattern\nYou know how newspaper or magazine \nsubscriptions work:\nA newspaper publisher goes into business and begins \npublishing newspapers.\nYou subscribe to a particular publisher, and every time \nthere\u2019s a new edition it gets delivered to you. As long as \nyou remain a subscriber, you get new newspapers.\nYou unsubscribe when you don\u2019t want papers anymore, \nand they stop being delivered.\nWhile the publisher remains in business, people, hotels, \nairlines, and other businesses constantly subscribe and \nunsubscribe to the newspaper.\n1\n2\n3\n4\nNo way we want to \nmiss what\u2019s going on in \nObjectville. Of course we \nsubscribe.\n", "page": 82, "type": "text", "section": "Page 82"}
{"text": "you are here 4\u2003 \u2003 45\nthe observer pattern\nObserver Objects\nThe observers have subscribed to \n(registered with) the Subject \nto receive updates when the \nSubject\u2019s data changes.\nThe Subject object \nmanages some \nimportant data.\nS\nu\nb\nj\ne\nc\nt\n \nOb\nj\ne\nc\nt\n2\nint\n \n \n \nD\no\ng\n \nO\nb\nj\ne\nc\nt\nM\no\nu\ns\ne\n \nO\nb\njec\nt\n \n \nC\na\nt\n \nO\nb\nj\ne\nct\nIf you understand newspaper subscriptions, you pretty much \nunderstand the Observer Pattern, only we call the publisher the \nSUBJECT and the subscribers the OBSERVERS.  \nLet\u2019s take a closer look:\n2\n2\n2\nWhen data in the Subject changes, \nthe observers are notified.\nNew data values are \ncommunicated to the \nobservers in some form \nwhen they change.\n \n \nD\nu\nc\nk\n \nO\nb\njec\nt\nThis object isn\u2019t an \nobserver, so it doesn\u2019t \nget notified when the \nSubject\u2019s data changes.\nPublishers + Subscribers = Observer Pattern\n", "page": 83, "type": "text", "section": "Page 83"}
{"text": "46\u2003 \u2003 Chapter 2\na day in the life of the observer pattern\nA day in the life of the Observer Pattern\nA Duck object comes along \nand tells the Subject that \nhe wants to become an \nobserver.\nDuck really wants in on the \naction; those ints Subject is \nsending out whenever its state \nchanges look pretty interesting...\nObservers\nS\nu\nb\nj\ne\nc\nt\n \nOb\nj\ne\nc\nt\n2\nint\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n \n \nD\nu\nc\nk\n \nO\nb\njec\nt\nS\nu\nb\nj\ne\nc\nt\n \nO\nb\nj\ne\nc\nt\n2\nint\nObservers\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n  \nD\nu\nc\nk\n \nO\nb\nj\ne\nc\nt\nThe Duck object is now an \nofficial observer.\nDuck is psyched...he\u2019s on the \nlist and is waiting with great \nanticipation for the next \nnotification so he can get an int.\nS\nu\nb\nj\ne\nc\nt\n \nO\nb\nj\ne\nc\nt\n8\nint\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n  \nD\nu\nc\nk\n \nO\nb\nj\ne\nc\nt\nThe Subject gets a new \ndata value! \nNow Duck and all the rest of the \nobservers get a notification that \nthe Subject has changed.\nObservers\n8\n8\n8\n8\n\u201cregister/subscribe me\u201d\n", "page": 84, "type": "text", "section": "Page 84"}
{"text": "you are here 4\u2003 \u2003 47\nthe observer pattern\nThe Mouse object asks to be \nremoved as an observer.\nThe Mouse object has been \ngetting ints for ages and is tired \nof it, so he decides it\u2019s time to \nstop being an observer.\nMouse is outta here!\nThe Subject acknowledges the \nMouse\u2019s request and removes him \nfrom the set of observers.\nS\nu\nb\nj\ne\nc\nt\n \nO\nb\nj\ne\nc\nt\n14\nint\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n  \nD\nu\nc\nk\n \nO\nb\nj\ne\nc\nt\nThe Subject has another \nnew int.\nAll the observers get another \nnotification, except for the \nMouse who is no longer included.  \nDon\u2019t tell anyone, but the Mouse \nsecretly misses those ints... \nmaybe he\u2019ll ask to be an observer \nagain some day.\nObservers\nS\nu\nb\nj\ne\nc\nt\n \nO\nb\nj\ne\nc\nt\n8\nint\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n  \nD\nu\nc\nk\n \nO\nb\nj\ne\nc\nt\nObservers\nS\nu\nb\nj\ne\nc\nt\n \nO\nb\nj\ne\nc\nt\n8\nint\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n  \nD\nu\nc\nk\n \nO\nb\nj\ne\nc\nt\nObservers\n14\n14\n14\n\u201cremove/unsubscribe me\u201d\n", "page": 85, "type": "text", "section": "Page 85"}
{"text": "48\u2003 \u2003 Chapter 2\nfive-minute drama\n3\nSoftware \nDeveloper #2\nHeadhunter/Subject\n2\n1\nSoftware \nDeveloper #1\n4\nSubject\nFive-minute drama: a subject for observation\nIn today\u2019s skit, two enterprising software developers encounter a real \nlive head hunter...\nThis is Lori. I\u2019m looking \nfor a Java development \nposition. I\u2019ve got five years \nof experience and...\nUh, yeah, you and \neverybody else, baby.  \nI\u2019m putting you on my list of \nJava developers. Don\u2019t call \nme, I\u2019ll call you!\nHi, I\u2019m Jill. I\u2019ve written \na lot of enterprise systems. \nI\u2019m interested in any job you\u2019ve \ngot with Java development.\nI\u2019ll add you to the list\u2014 \nyou\u2019ll know along with \neveryone else.\n", "page": 86, "type": "text", "section": "Page 86"}
{"text": "you are here 4\u2003 \u2003 49\nthe observer pattern\n8\n6\nSubject\nSubject\n9\n7\nObserver\nObserver\nObserver\n5\nMeanwhile, for Lori and Jill life goes \non; if a Java job comes along, they\u2019ll get \nnotified. After all, they are observers.\nJill lands her own job!\nHey observers, there\u2019s \na Java opening down at \nJavaBeans-R-Us. Jump on \nit! Don\u2019t blow it!\nBwahaha, money in \nthe bank, baby!\nArghhh!!! Mark my \nwords, Jill, you\u2019ll never \nwork in this town again if I \nhave anything to do with it. \nYou\u2019re off my call list!!!\nYou can take me \noff your call list. I \nfound my own job!\nThanks, I\u2019ll send my \nresume right over.\nThis guy is a real jerk. \nWho needs him. I\u2019m \nlooking for my own job.\n", "page": 87, "type": "text", "section": "Page 87"}
{"text": "50\u2003 \u2003 Chapter 2\nmore five-minute drama\nJill\u2019s loving life, and no longer an observer.  \nShe\u2019s also enjoying the nice fat signing \nbonus that she got because the company \ndidn\u2019t have to pay a headhunter.\nTwo weeks later...\nBut what has become of our dear Lori? We \nhear she\u2019s beating the headhunter at his own \ngame. She\u2019s not only still an observer, she\u2019s \ngot her own call list now, and she is notifying \nher own observers. Lori\u2019s a subject and an \nobserver all in one.\n", "page": 88, "type": "text", "section": "Page 88"}
{"text": "you are here 4\u2003 \u2003 51\nthe observer pattern\nThe Observer Pattern defines a one-to-many \ndependency between objects so that when one \nobject changes state, all of its dependents are \nnotified and updated automatically.\nThe Observer Pattern defined\nA newspaper subscription, with its publisher and subscribers, is a \ngood way to visualize the pattern.\nIn the real world, however, you\u2019ll typically see the Observer \nPattern defined like this:\nThe subject and observers define the one-to-many relationship. We \nhave one subject, who notifies many observers when something in the subject \nchanges. The observers are dependent on the subject\u2014when the subject\u2019s \nstate changes, the observers are notified. \nAs you\u2019ll discover, there are a few different ways to implement the \nObserver Pattern, but most revolve around a class design that includes \nSubject and Observer interfaces.  \nThe Observer Pattern \ndefines a one-to-many \nrelationship between a \nset of objects.\nWhen the state of one \nobject changes, all of its \ndependents are notified.\nLet\u2019s relate this definition to how we\u2019ve been thinking about the \npattern:\nS\nu\nb\nj\ne\nc\nt\n \nO\nb\nj\ne\nc\nt\n8\nint\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n  \nD\nu\nc\nk\n \nO\nb\nj\ne\nc\nt\nObservers\n8\n8\n8\n8\nONE-TO-MANY RELATIONSHIP\nAutomatic update/notification\nObject that \nholds state\nDependent Objects\n", "page": 89, "type": "text", "section": "Page 89"}
{"text": "52\u2003 \u2003 Chapter 2\nthe observer pattern\n<<interface>>\nSubject\nregisterObserver()\nremoveObserver()\nnotifyObservers()\n<<interface>>\nObserver\nupdate()\nregisterObserver() {...}\nremoveObserver() {...}\nnotifyObservers() {...}\ngetState()\nsetState()\nConcreteSubject\nHere\u2019s the Subject interface. Objects \nuse this interface to register as \nobservers and also to remove themselves \nfrom being observers.\nAll potential observers need \nto implement the Observer \ninterface. This interface has \njust one method, update(), \nthat is called when the \nSubject\u2019s state changes.\nConcrete observers can be \nany class that implements the \nObserver interface. Each observer \nregisters with a concrete subject \nto receive updates.\nA concrete subject always \nimplements the Subject \ninterface. In addition to \nthe register and remove \nmethods, the concrete subject  \nimplements a notifyObservers() \nmethod that is used to update \nall the current observers \nwhenever state changes.\nupdate()\n// other Observer specific \nmethods \nConcreteObserver\nThe Observer Pattern: the Class Diagram\nThe concrete subject may also \nhave methods for setting and \ngetting its state (more about \nthis later).\nobservers\nsubject\nEach subject \ncan have many \nobservers.\nQ: What does this have to do with \none-to-many relationships?\nA: With the Observer Pattern, the Subject \nis the object that contains the state and \ncontrols it. So, there is ONE subject with \nstate. The observers, on the other hand, use \nthe state, even if they don\u2019t own it. There \nare many observers, and they rely on the \nSubject to tell them when its state changes.  \nSo there is a relationship between the ONE \nSubject to the MANY Observers.\nQ: How does dependence come into \nthis?\nA: Because the subject is the sole owner \nof that data, the observers are dependent on \nthe subject to update them when the data \nchanges. This leads to a cleaner OO design \nthan allowing many objects to control the \nsame data.\nQ: I\u2019ve also heard of a Publish-\nSubscribe Pattern. Is that just another \nname for the Observer Pattern?\nA: No, although they are related. The \nPublish-Subscribe pattern is a more complex \npattern that allows subscribers to express \ninterest in different types of messages \nand further separates publishers from \nsubscribers. It is often used in middleware \nsystems. \nLet\u2019s take a look at the structure of the Observer Pattern, complete with \nits Subject and Observer classes. Here\u2019s the class diagram:\n", "page": 90, "type": "text", "section": "Page 90"}
{"text": "you are here 4\u2003 \u2003 53\nthe observer pattern\nGuru and Student...\nGuru: Have we talked about loose coupling?\nStudent: Guru, I do not recall such a discussion.\nGuru: Is a tightly woven basket stiff or flexible?\nStudent: Stiff, Guru.\nGuru: And do stiff or flexible baskets tear or break less easily?\nStudent: A flexible basket tends to break less easily.\nGuru: And in our software, might our designs break less easily if \nour objects are less tightly bound together?\nStudent: Guru, I see the truth of it. But what does it mean for \nobjects to be less tightly bound?\nGuru: We like to call it, loosely coupled.\nStudent: Ah!\nGuru: We say a object is tightly coupled to another object when it is \ntoo dependent on that object.\nStudent: So a loosely coupled object can\u2019t depend on another \nobject?\nGuru: Think of nature; all living things depend on each other. \nLikewise, all objects depend on other objects. But a loosely coupled \nobject doesn\u2019t know or care too much about the details of another \nobject.\nStudent: But Guru, that doesn\u2019t sound like a good quality. Surely \nnot knowing is worse than knowing.\nGuru: You are doing well in your studies, but you have much to \nlearn. By not knowing too much about other objects, we can create \ndesigns that can handle change better. Designs that have more \nflexibility, like the less tightly woven basket.\nStudent: Of course, I am sure you are right. Could you give me an \nexample?\nGuru: That is enough for today.\n", "page": 91, "type": "text", "section": "Page 91"}
{"text": "54\u2003 \u2003 Chapter 2\nThe Power of Loose Coupling\nDesign Principle\nStrive for loosely coupled designs \nbetween objects that interact.\nWhen two objects are loosely coupled, they can interact, but they typically have very little knowledge \nof each other. As we\u2019re going to see, loosely coupled designs often give us a lot of flexibility (more \non that in a bit). And, as it turns out, the Observer Pattern is a great example of loose coupling. \nLet\u2019s walk through all the ways the pattern achieves loose coupling:\nLoosely coupled designs allow us to build flexible OO \nsystems that can handle change because they minimize \nthe interdependency between objects.\nHow many \ndifferent kinds \nof change can you \nidentify here? \nFirst, the only thing the subject knows about an observer is that it \nimplements a certain interface (the Observer interface). It doesn\u2019t need to \nknow the concrete class of the observer, what it does, or anything else about it.  \nWe can add new observers at any time. Because the only thing the subject depends \non is a list of objects that implement the Observer interface, we can add new observers \nwhenever we want. In fact, we can replace any observer at runtime with another observer \nand the subject will keep purring along. Likewise, we can remove observers at any time. \nWe never need to modify the subject to add new types of observers. Let\u2019s say \nwe have a new concrete class come along that needs to be an observer. We don\u2019t need \nto make any changes to the subject to accommodate the new class type; all we have \nto do is implement the Observer interface in the new class and register as an observer.  \nThe subject doesn\u2019t care; it will deliver notifications to any object that implements the \nObserver interface.\nWe can reuse subjects or observers independently of each other. If we have \nanother use for a subject or an observer, we can easily reuse them because the two aren\u2019t \ntightly coupled.\nChanges to either the subject or an observer will not affect the other.  \nBecause the two are loosely coupled, we are free to make changes to either, as long as the \nobjects still meet their obligations to implement the Subject or Observer interfaces.\nLook! We have a new \nDesign Principle!\nloose coupling\n", "page": 92, "type": "text", "section": "Page 92"}
{"text": "you are here 4\u2003 \u2003 55\nthe observer pattern\nBefore moving on, try sketching out the classes you\u2019ll need to \nimplement the Weather Station, including the WeatherData class \nand its display elements. Make sure your diagram shows how all \nthe pieces fit together and also how another developer might \nimplement her own display element.\nIf you need a little help, read the next page; your teammates are \nalready talking about how to design the Weather Station.\n", "page": 93, "type": "text", "section": "Page 93"}
{"text": "56\u2003 \u2003 Chapter 2\nCubicle conversation\nThe Observer Pattern defines a one-to-many dependency between objects so that when \none object changes state, all its dependents are notified and updated automatically.\nBack to the Weather Station project. Your teammates have already begun thinking \nthrough the problem...\nSue\nSo, how are we going \nto build this thing?\nMary: Well, it helps to know we\u2019re using the Observer Pattern.\nSue: Right...but how do we apply it?\nMary: Hmm. Let\u2019s look at the definition again: \nMary: That actually makes some sense when you think about it. Our WeatherData class is the \n\u201cone,\u201d and our \u201cmany\u201d is the various display elements that use the weather measurements.\nSue: That\u2019s right. The WeatherData class certainly has state...that\u2019s the temperature, \nhumidity, and barometric pressure, and those definitely change.\nMary: Yup, and when those measurements change, we have to notify all the display elements \nso they can do whatever it is they are going to do with the measurements.\nSue: Cool, now I think I see how the Observer Pattern can be applied to our Weather \nStation problem.\nMary: There are still a few things to consider that I\u2019m not sure I understand yet.\nSue: Like what?\nMary: For one thing, how do we get the weather measurements to the display elements?\nSue: Well, looking back at the picture of the Observer Pattern, if we make the WeatherData \nobject the subject, and the display elements the observers, then the displays will register \nthemselves with the WeatherData object in order to get the information they want, right?\nMary: Yes...and once the Weather Station knows about a display element, then it can just \ncall a method to tell it about the measurements.\nSue: We gotta remember that every display element can be different...so I think that\u2019s where \nhaving a common interface comes in. Even though every component has a different type, \nthey should all implement the same interface so that the WeatherData object will know how \nto send them the measurements.\nMary: I see what you mean. So every display will have, say, an update() method that \nWeatherData will call.\nSue: And update() is defined in a common interface that all the elements implement\u2026\nconversation about the weather station\n", "page": 94, "type": "text", "section": "Page 94"}
{"text": "you are here 4\u2003 \u2003 57\nthe observer pattern\nDesigning the Weather Station\n<<interface>>\nSubject\nregisterObserver()\nremoveObserver()\nnotifyObservers()\n<<interface>>\nObserver\nupdate()\nregisterObserver() \nremoveObserver() \nnotifyObservers()\ngetTemperature()\ngetHumidity()\ngetPressure()\nmeasurementsChanged()\nWeatherData\nupdate()\ndisplay() { // display current \nmeasurements }\nCurrentConditionsDisplay\nupdate() \ndisplay() { // display the aver\u00ad\nage, min and max measure\u00ad\nments }\nStatisticsDisplay\nupdate()\ndisplay() { // display the \nforecast }\nForecastDisplay\nHere\u2019s our Subject interface. \nThis should look familiar.\nAll our weather components \nimplement the Observer \ninterface. This gives the \nSubject a common interface to \ntalk to when it comes time to \nupdate the observers.\nThis display element \nshows the current \nmeasurements from the \nWeatherData object.\nThis one keeps track \nof the min/avg/max \nmeasurements and \ndisplays them.\nThis display shows the weather \nforecast based on the barometer.\nWeatherData now \nimplements the Subject \ninterface.\nobservers\nupdate()\ndisplay() { // display  \nsomething else based on \nmeasurements }\nThirdPartyDisplay\nDevelopers can \nimplement the \nObserver and \nDisplayElement \ninterfaces to \ncreate their own \ndisplay element.\n<<interface>>\nDisplayElement\ndisplay()\nLet\u2019s also create an interface \nfor all display elements \nto implement. The display \nelements just need to \nimplement a display() method.\nThese three display elements should have a pointer to \nWeatherData labeled \u201csubject\u201d too, but boy would \nthis diagram start to look like spaghetti if they did.\nHow does this diagram compare with yours?\nsubject\n", "page": 95, "type": "text", "section": "Page 95"}
{"text": "58\u2003 \u2003 Chapter 2\nImplementing the Weather Station\nAll right, we\u2019ve had some great thinking from Mary and Sue (from a few pages back) \nand we\u2019ve got a diagram that details the overall structure of our classes. So, let\u2019s get \nour implemention of the weather station underway. Let\u2019s start with the interfaces:\nBoth of these methods take an \nObserver as an argument\u2014that is, the \nObserver to be registered or removed.\nThis method is called to notify all observers \nwhen the Subject\u2019s state has changed.\nThe Observer interface \nis implemented by all \nobservers, so they all \nhave to implement the \nupdate() method. Here \nwe\u2019re following Mary and \nSue\u2019s lead and passing \nthe measurements to the \nobservers.\nThese are the state values the Observers get from \nthe Subject when a weather measurement changes.\nThe DisplayElement interface \njust includes one method, display(), \nthat we will call when the display \nelement needs to be displayed.\nMary and Sue thought that passing the measurements directly to the observers was the \nmost straightforward method of updating state. Do you think this is wise? Hint: is this an area \nof the application that might change in the future? If it did change, would the change be well \nencapsulated, or would it require changes in many parts of the code?\nCan you think of other ways to approach the problem of passing the updated state to the \nobservers?\nDon\u2019t worry; we\u2019ll come back to this design decision after we finish the initial implementation.\npublic interface Subject {\n    public void registerObserver(Observer o);\n    public void removeObserver(Observer o);\n    public void notifyObservers();\n}\npublic interface Observer {\n    public void update(float temp, float humidity, float pressure);\n}\npublic interface DisplayElement {\n    public void display();\n}\nimplementing the weather station\n", "page": 96, "type": "text", "section": "Page 96"}
{"text": "you are here 4\u2003 \u2003 59\nthe observer pattern\npublic class WeatherData implements Subject {\n    private List<Observer> observers;\n    private float temperature;\n    private float humidity;\n    private float pressure;\n    \n    public WeatherData() {\n        observers = new ArrayList<Observer>();\n    }\n    \n    public void registerObserver(Observer o) {\n        observers.add(o);\n    }\n    \n    public void removeObserver(Observer o) {\n        observers.remove(o);\n    }\n    \n    public void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(temperature, humidity, pressure);\n        }\n    }\n    \n    public void measurementsChanged() {\n        notifyObservers();\n    }\n    \n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n    \n    // other WeatherData methods here\n}\nImplementing the Subject interface \nin WeatherData\nWe notify the Observers when we \nget updated measurements from \nthe Weather Station.\nRemember our first attempt at implementing the WeatherData class at the \nbeginning of the chapter? You might want to refresh your memory. Now it\u2019s \ntime to go back and do things with the Observer Pattern in mind:\nWeatherData now implements \nthe Subject interface.\nWhen an observer registers, we \njust add it to the end of the list.\nLikewise, when an observer wants to \nun-register, we just take it off the list.\nHere\u2019s the fun part; this is where we \ntell all the observers about the state. \nBecause they are all Observers, we \nknow they all implement update(), so we \nknow how to notify them.  \nOkay, while we wanted to ship a nice little \nweather station with each book, the publisher \nwouldn\u2019t go for it. So, rather than reading \nactual weather data off a device, we\u2019re going \nto use this method to test our display elements. \nOr, for fun, you could write code to grab \nmeasurements off the web.\nWe\u2019ve added an ArrayList to \nhold the Observers, and we \ncreate it in the constructor.\nHere we implement the Subject interface.\nREMEMBER: we don\u2019t provide \nimport and package statements \nin the code listings. Get the \ncomplete source code from \nhttps://wickedlysmart.com/\nhead-first-design-patterns\n", "page": 97, "type": "text", "section": "Page 97"}
{"text": "60\u2003 \u2003 Chapter 2\npublic class CurrentConditionsDisplay implements Observer, DisplayElement {\n    private float temperature;\n    private float humidity;\n    private WeatherData weatherData;\n    \n    public CurrentConditionsDisplay(WeatherData weatherData) {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n    \n    public void update(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        display();\n    }\n    \n    public void display() {\n        System.out.println(\"Current conditions: \" + temperature \n            + \"F degrees and \" + humidity + \"% humidity\");\n    }\n}\nNow, let\u2019s build those display elements\nThis display implements the Observer \ninterface so it can get changes from \nthe WeatherData object.\nWhen update() is called, we \nsave the temp and humidity \nand call display().\nThe display() method \njust prints out the most \nrecent temp and humidity.\nNow that we\u2019ve got our WeatherData class straightened out, it\u2019s time to build the \ndisplay elements. Weather-O-Rama ordered three: the current conditions display, the \nstatistics display, and the forecast display. Let\u2019s take a look at the current conditions \ndisplay; once you have a good feel for this display element, check out the statistics and \nforecast displays in the code directory. You\u2019ll see they are very similar.\nIt also implements DisplayElement, \nbecause our API is going to \nrequire all display elements to \nimplement this interface.\nThe constructor is passed the \nweatherData object (the Subject) \nand we use it to register the \ndisplay as an observer.\nQ: Is update() the best place to call display()?\nA: In this simple example it made sense to call display() when the \nvalues changed. However, you\u2019re right; there are much better ways to \ndesign the way the data gets displayed. We\u2019ll see this when we get to \nthe Model-View-Controller pattern.\nQ: Why did you store a reference to the WeatherData \nSubject? It doesn\u2019t look like you use it again after the \nconstructor.\nA: True, but in the future we may want to un-register ourselves as \nan observer and it would be handy to already have a reference to the \nsubject.\nbuild the display elements\n", "page": 98, "type": "text", "section": "Page 98"}
{"text": "you are here 4\u2003 \u2003 61\nthe observer pattern\npublic class WeatherStation {\n    public static void main(String[] args) {\n        WeatherData weatherData = new WeatherData();\n    \n        CurrentConditionsDisplay currentDisplay = \n            new CurrentConditionsDisplay(weatherData);\n        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);\n        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);\n        weatherData.setMeasurements(80, 65, 30.4f);\n        weatherData.setMeasurements(82, 70, 29.2f);\n        weatherData.setMeasurements(78, 90, 29.2f);\n    }\n}\nPower up the Weather Station\nFile  Edit   Window  Help  StormyWeather\n%java WeatherStation\nCurrent conditions: 80.0F degrees and 65.0% humidity\nAvg/Max/Min temperature = 80.0/80.0/80.0\nForecast: Improving weather on the way!\nCurrent conditions: 82.0F degrees and 70.0% humidity\nAvg/Max/Min temperature = 81.0/82.0/80.0\nForecast: Watch out for cooler, rainy weather\nCurrent conditions: 78.0F degrees and 90.0% humidity\nAvg/Max/Min temperature = 80.0/82.0/78.0\nForecast: More of the same\n%\nThe Weather Station is ready to go. All we need is some code to \nglue everything together. We\u2019ll be adding some more displays and \ngeneralizing things in a bit. For now, here\u2019s our first attempt:\nFirst, let\u2019s create a test harness.\n1\nRun the code and let the Observer Pattern do its magic.\n2\nFirst, create the  \nWeatherData object.\nCreate the three \ndisplays and \npass them the \nWeatherData object.\nSimulate new weather \nmeasurements.\nIf you don\u2019t \nwant to \ndownload the \ncode, you can \ncomment out \nthese two lines \nand run it.\n", "page": 99, "type": "text", "section": "Page 99"}
{"text": "62\u2003 \u2003 Chapter 2\nJohnny Hurricane, Weather-O-Rama\u2019s CEO, just called and they can\u2019t possibly ship without a Heat \nIndex display element. Here are the details.\nThe heat index is an index that combines temperature and humidity to determine the apparent \ntemperature (how hot it actually feels).  To compute the heat index, you take the temperature, T, \nand the relative humidity, RH, and use this formula:\n \nSo get typing!  \nJust kidding. Don\u2019t worry, you won\u2019t have to type that formula in; just create your own \nHeatIndexDisplay.java file and copy the formula from heatindex.txt into it. \nHow does it work? You\u2019d have to refer to Head First Meteorology, or try asking someone at the \nNational Weather Service (or try a web search).\nWhen you finish, your output should look like this:\nYou can get heatindex.txt from wickedlysmart.com.\n16.923  + 1.85212 * 10-1 * T  + 5.37941 * RH  - 1.00254 * 10-1 * \nT * RH  + 9.41695 * 10-3 * T2 + 7.28898 * 10-3 * RH2  + 3.45372 * \n10-4 * T2 * RH  - 8.14971 * 10-4 * T * RH2  + 1.02102 * 10-5 * T2 * \nRH2  - 3.8646 * 10-5 * T3  + 2.91583 * 10-5 * RH3  + 1.42721 * 10-6 \n* T3 * RH  + 1.97483 * 10-7 * T * RH3  - 2.18429 * 10-8 * T3 * RH2  \n+ 8.43296 * 10-10 * T2 * RH3  - 4.81975 * 10-11 * T3 * RH3\nheatindex = \nFile  Edit   Window  Help  OverDaRainbow\n%java WeatherStation\nCurrent conditions: 80.0F degrees and 65.0% humidity\nAvg/Max/Min temperature = 80.0/80.0/80.0\nForecast: Improving weather on the way!\nHeat index is 82.95535\nCurrent conditions: 82.0F degrees and 70.0% humidity\nAvg/Max/Min temperature = 81.0/82.0/80.0\nForecast: Watch out for cooler, rainy weather\nHeat index is 86.90124\nCurrent conditions: 78.0F degrees and 90.0% humidity\nAvg/Max/Min temperature = 80.0/82.0/78.0\nForecast: More of the same\nHeat index is 83.64967\n%\nHere\u2019s what \nchanged in \nthis output.\nexercise: code the heat index display\n", "page": 100, "type": "text", "section": "Page 100"}
{"text": "you are here 4\u2003 \u2003 63\nthe observer pattern\nTonight\u2019s talk: Subject and Observer spar over the right way \nto get state information to the Observer.\nSubject:\nI\u2019m glad we\u2019re finally getting a chance to chat in \nperson.\n\n\nWell, I do my job, don\u2019t I? I always tell you what\u2019s \ngoing on... Just because I don\u2019t really know who \nyou are doesn\u2019t mean I don\u2019t care. And besides, I \ndo know the most important thing about you\u2014you \nimplement the Observer interface.\nOh yeah, like what?\n\n\nWell, excuuuse me. I have to send my state with my \nnotifications so all you lazy Observers will know \nwhat happened!\nWell...I guess that might work. I\u2019d have to open \nmyself up even more, though, to let all you \nObservers come in and get the state that you \nneed. That might be kind of dangerous. I can\u2019t \nlet you come in and just snoop around looking at \neverything I\u2019ve got.\nObserver:\n\n\nReally? I thought you didn\u2019t care much about us \nObservers.\n\n\nYeah, but that\u2019s just a small part of who I am.  \nAnyway, I know a lot more about you...\nWell, you\u2019re always passing your state around to us \nObservers so we can see what\u2019s going on inside you.  \nWhich gets a little annoying at times...\nOkay, wait just a minute here; first, we\u2019re not lazy, \nwe just have other stuff to do in between your oh-\nso-important notifications, Mr. Subject, and second, \nwhy don\u2019t you let us come to you for the state we \nwant rather than pushing it out to just everyone?\n", "page": 101, "type": "text", "section": "Page 101"}
{"text": "64\u2003 \u2003 Chapter 2\nSubject:\nYes, I could let you pull my state. But won\u2019t \nthat be less convenient for you? If you have to \ncome to me every time you want something, you \nmight have to make multiple method calls to get \nall the state you want. That\u2019s why I like push \nbetter...then you have everything you need in one \nnotification.\nWell, as I like to say, don\u2019t call us, we\u2019ll call you! \nBut I\u2019ll give it some thought.\nYou never know, hell could freeze over.\nIndeed.\nObserver:\nWhy don\u2019t you just write some public getter \nmethods that will let us pull out the state we need?\n\n\nDon\u2019t be so pushy! There are so many different \nkinds of us Observers, there\u2019s no way you can \nanticipate everything we need. Just let us come to \nyou to get the state we need. That way, if some of \nus only need a little bit of state, we aren\u2019t forced to \nget it all. It also makes things easier to modify later. \nSay, for example, you expand yourself and add \nsome more state. If you use pull, you don\u2019t have to \ngo around and change the update calls on every \nobserver; you just need to change yourself to allow \nmore getter methods to access our additional state.\nI won\u2019t hold my breath.\nI see, always the wise guy...\nfireside chat: subject and observer\n", "page": 102, "type": "text", "section": "Page 102"}
{"text": "you are here 4\u2003 \u2003 65\nthe observer pattern\nLooking for the Observer Pattern in the Wild\nThe Observer Pattern is one of the most common patterns in use, and you\u2019ll find plenty \nof examples of the pattern being used in many libraries and frameworks. If we look at the \nJava Development Kit (JDK), for instance, both the JavaBeans and Swing libraries make use \nof the Observer Pattern. The pattern\u2019s not limited to Java either; it\u2019s used in JavaScript\u2019s \nevents and in Cocoa and Swift\u2019s Key-Value Observing protocol, to name a couple of other \nexamples. One of the advantages of knowing design patterns is recognizing and quickly \nunderstanding the design motivation in your favorite libraries. Let\u2019s take a quick diversion \ninto the Swing library to see how Observer is used.\nOkay, our application is pretty simple. You\u2019ve got a button that says, \u201cShould I do \nit?\u201d and when you click on that button the listeners (observers) get to answer the \nquestion in any way they want. We\u2019re implementing two such listeners, called the \nAngelListener and the DevilListener. Here\u2019s how the application behaves:\nIf you\u2019re curious about \nthe Observer Pattern in \nJavaBeans, check out the \nPropertyChangeListener \ninterface.\nYou probably already know that Swing is Java\u2019s GUI toolkit for user interfaces. One \nof the most basic components of that toolkit is the JButton class. If you look up \nJButton\u2019s superclass, AbstractButton, you\u2019ll find that it has a lot of add/remove \nlistener methods. These methods allow you to add and remove observers\u2014or, as \nthey are called in Swing, listeners\u2014to listen for various types of events that occur \non the Swing component. For instance, an ActionListener lets you \u201clisten in\u201d on \nany types of actions that might occur on a button, like a button press. You\u2019ll find \nvarious types of listeners all over the Swing API.  \nThe Swing library\n%java SwingObserverExample\nCome on, do it!\nDon\u2019t do it, you might regret it!\n%\nA little life-changing application\nAnd here\u2019s the output when \nwe click on the button.\nHere\u2019s our fancy interface.\nAngel answer\nDevil answer\nFile  Edit  Window  Help  HeMadeMeDoIt\n", "page": 103, "type": "text", "section": "Page 103"}
{"text": "66\u2003 \u2003 Chapter 2\npublic class SwingObserverExample {\n    JFrame frame;\n    public static void main(String[] args) {\n        SwingObserverExample example = new SwingObserverExample();\n        example.go();\n    }\n    public void go() {\n        frame = new JFrame();\n        JButton button = new JButton(\"Should I do it?\");\n        button.addActionListener(new AngelListener());\n        button.addActionListener(new DevilListener());\n        // Set frame properties here\n    }\n    class AngelListener implements ActionListener {\n        public void actionPerformed(ActionEvent event) {\n            System.out.println(\"Don't do it, you might regret it!\");\n        }\n    }\n    class DevilListener implements ActionListener {\n        public void actionPerformed(ActionEvent event) {\n            System.out.println(\"Come on, do it!\");\n        }\n    }\n}\nSimple Swing application that \njust creates a frame and \nthrows a button in it.\nMakes the devil and \nangel objects listeners \n(observers) of the button.\nHere are the class definitions for \nthe observers, defined as inner \nclasses (but they don\u2019t have to be).\nRather than update(), the actionPerformed() \nmethod gets called when the state in the \nsubject (in this case the button) changes.\nThis life-changing application requires very little code. All we need to do is \ncreate a JButton object, add it to a JFrame, and set up our listeners. We\u2019re \ngoing to use inner classes for the listeners, which is a common technique in \nSwing programming. If you aren\u2019t up on inner classes or Swing, you might \nwant to review the Swing chapter in your favorite Java reference guide.\nCoding the life-changing application\nCode to set up the frame goes here.\nuse action listener observers\n", "page": 104, "type": "text", "section": "Page 104"}
{"text": "you are here 4\u2003 \u2003 67\nthe observer pattern\npublic class SwingObserverExample {\n    JFrame frame;\n    public static void main(String[] args) {\n        SwingObserverExample example = new SwingObserverExample();\n        example.go();\n    }\n    public void go() {\n        frame = new JFrame();\n        JButton button = new JButton(\"Should I do it?\");\n        button.addActionListener(event -> \n             System.out.println(\"Don't do it, you might regret it!\"));\n        button.addActionListener(event -> \n             System.out.println(\"Come on, do it!\"));\n        // Set frame properties here\n    }\n}\nThe updated code, using lambda expressions:\nWe\u2019ve replaced the AngelListener \nand DevilListener objects with \nlambda expressions that implement \nthe same functionality that we \nhad before.\nWe\u2019ve removed the two ActionListener classes \n(DevilListener and AngelListener) completely.\nWhen you click the button, the \nfunction objects created by the \nlambda expressions are notified \nand the method they implement \nis run.\nUsing lambda expressions makes \nthis code a lot more concise.\nLambda expressions were added in Java \n8. If you aren\u2019t familiar with them, don\u2019t \nworry about it; you can continue using inner \nclasses for your Swing observers.\nFor more on lambda expressions, check out the Java docs.\nHow about taking your use of the Observer Pattern even further? By using a lambda expression \nrather than an inner class, you can skip the step of creating an ActionListener object. With a lambda \nexpression, we create a function object instead, and the function object is the observer. And, when you pass \nthat function object to addActionListener(), Java ensures its signature matches actionPerformed(), the \none method in the ActionListener interface. \nLater, when the button is clicked, the button object notifies its observers\u2014including the function \nobjects created by the lambda expressions\u2014that it\u2019s been clicked, and calls each listener\u2019s \nactionPerformed() method.\nLet\u2019s take a look at how you\u2019d use lambda expressions as observers to simplify our previous code:\n", "page": 105, "type": "text", "section": "Page 105"}
{"text": "68\u2003 \u2003 Chapter 2\nI was thinking about the push/pull discussion \nwe had earlier. Would it generalize the code a \nbit more if we allowed the displays to pull their \ndata from the WeatherData object as needed? \nThat might make it easier to add new displays in \nthe future.\nQ: I thought Java had Observer and Observable classes?\nA: Good catch. Java used to provide an Observable class (the \nSubject) and an Observer interface, which you could use to help \nintegrate the Observer Pattern in your code. The Observable class \nprovided methods to add, delete, and notify observers, so that you \ndidn\u2019t have to write that code. And the Observer interface provided \nan interface just like ours, with one update() method. These classes \nwere deprecated in Java 9. Folks find it easier to support the basic \nObserver Pattern in their own code, or want something more robust, \nso the Observer/Observable classes are being phased out.\nQ: Does Java offer other built-in support for Observer to \nreplace those classes?\nA: JavaBeans offers built-in support through \nPropertyChangeEvents that are generated when a Bean \nchanges a particular kind of property, and sends notifications \nto PropertyChangeListeners. There are also related publisher/\nsubscriber components in the Flow API for handling asynchronous \nstreams.\nQ: Should I expect notifications from a Subject to its \nObservers to arrive in a specific order?\nA: With Java\u2019s implementations of Observer, the JDK developers \nspecifically advise you to not depend on any specific notification \norder. \nThat\u2019s a good idea. \nIn our current Weather Station design, we are pushing all three pieces of data \nto the update() method in the displays, even if the displays don\u2019t need all these \nvalues. That\u2019s okay, but what if Weather-O-Rama adds another data value later, \nlike wind speed? Then we\u2019ll have to change all the update() methods in all the \ndisplays, even if most of them don\u2019t need or want the wind speed data. \nNow, whether we pull or push the data to the Observer is an implementation \ndetail, but in a lot of cases it makes sense to let Observers retrieve the data they \nneed rather than passing more and more data to them through the update() \nmethod. After all, over time, this is an area that may change and grow unwieldy. \nAnd, we know CEO Johnny Hurricane is going to want to expand the Weather \nStation and sell more displays, so let\u2019s take another pass at the design and see if \nwe can make it even easier to expand in the future.\nUpdating the Weather Station code to allow Observers to pull the data they \nneed is a pretty straightforward exercise. All we need to do is make sure the \nSubject has getter methods for its data, and then change our Observers to use \nthem to pull the data that\u2019s appropriate for their needs. Let\u2019s do that.\nrevisiting push and pull\n", "page": 106, "type": "text", "section": "Page 106"}
{"text": "you are here 4\u2003 \u2003 69\nthe observer pattern\nFor an Observer to receive notifications...\nFor the Subject to send notifications...\nWe\u2019ll modify the notifyObservers() method in WeatherData to call the method \nupdate() in the Observers with no arguments: \npublic void notifyObservers() {\n\t\nfor (Observer observer : observers) {\n\t\n\t\nobserver.update();\n\t\n}\n}\nThen we\u2019ll modify the Observer interface, changing the signature of the \nupdate() method so that it has no parameters: \npublic interface Observer {\n\t\npublic void update();\n}\n1\nAnd finally, we modify each concrete Observer to change the signature of its respective \nupdate() methds and get the weather data from the Subject using the WeatherData\u2019s \ngetter methods. Here\u2019s the new code for the CurrentConditionsDisplay class:\n2\npublic void update() {\n\t\nthis.temperature = weatherData.getTemperature();\n\t\nthis.humidity = weatherData.getHumidity();\n\t\ndisplay();\n}\n1\nMeanwhile, back at Weather-O-Rama\nThere\u2019s another way of handling the data in the Subject: we can rely on the \nObservers to pull it from the Subject as needed. Right now, when the Subject\u2019s data \nchanges, we push the new values for temperature, humidity, and pressure to the \nObservers, by passing that data in the call to update(). \nLet\u2019s set things up so that when an Observer is notified of a change, it calls getter \nmethods on the Subject to pull the values it needs. \nTo switch to using pull, we need to make a few small changes to our existing code. \nHere we\u2019re using the \nSubject\u2019s getter methods \nthat were supplied with \nthe code in WeatherData \nfrom Weather-O-Rama.\n", "page": 107, "type": "text", "section": "Page 107"}
{"text": "70\u2003 \u2003 Chapter 2\nCode Magnets\nThe ForecastDisplay class is all scrambled up on the fridge.  Can you \nreconstruct the code snippets to make it work?  Some of the curly \nbraces fell on the floor and they were too small to pick up, so feel \nfree to add as many of those as you need!\npublic void display() {\n    // display code here\n}\nweatherData.registerObserver(this);\npublic ForecastDisplay(WeatherData \nweatherData) {\ndisplay();\npublic class ForecastDisplay implements \n \n \n \n \nObserver, DisplayElement {\nlastPressure = currentPressure;\ncurrentPressure = weatherData.getPressure();\nprivate float currentPressure = 29.92f; \n \nprivate float lastPressure;\nthis.weatherData = weatherData;\npublic void update() {\nprivate WeatherData weatherData;\n}\ncode magnet exercise\n", "page": 108, "type": "text", "section": "Page 108"}
{"text": "you are here 4\u2003 \u2003 71\nthe observer pattern\nTest Drive the new code\nFile  Edit   Window  Help  TryThisAtHome\n%java WeatherStation\nCurrent conditions: 80.0F degrees and 65.0% humidity\nAvg/Max/Min temperature = 80.0/80.0/80.0\nForecast: Improving weather on the way!\nCurrent conditions: 82.0F degrees and 70.0% humidity\nAvg/Max/Min temperature = 81.0/82.0/80.0\nForecast: Watch out for cooler, rainy weather\nCurrent conditions: 78.0F degrees and 90.0% humidity\nAvg/Max/Min temperature = 80.0/82.0/78.0\nForecast: More of the same\n%\nOkay, you\u2019ve got one more display to update, the Avg/Min/Max display. Go ahead and \ndo that now!\nJust to be sure, let\u2019s run the new code...\nWeather-O-Rama, Inc.\n100 Main Street\nTornado Alley, OK 45021\nWow! \nYour design is fantastic. Not only did you quickly create all three \ndisplays that we asked for, you\u2019ve created a general design that \nallows anyone to create new display, and even allows users to add \nand remove displays at runtime! \nIngenious!\nUntil our next engagement, \nHere\u2019s what we got.\nLook! This just arrived!\n", "page": 109, "type": "text", "section": "Page 109"}
{"text": "72\u2003 \u2003 Chapter 2\nTools for your Design Toolbox\nAbstraction\nEncapsulation\nPolymorphism\nInheritence\nOO Basics\nEncapsulate what varies.\nFavor composition over \ninheritance.\nProgram to interfaces, not \nimplementations.\nStrive for loosely coupled \ndesigns between objects that \ninteract.\nOO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable.  Strategy lets the algorithm \nvary independently from clients that use it.\nOO Patterns\nWelcome to the end of Chapter 2. You\u2019ve added a \nfew new things to your OO toolbox...\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nHere\u2019s your newest \nprinciple. Remember, \nloosely coupled designs are \nmuch more flexible and \nresilient to change.\nA new pattern for communicating state to a \nset of objects in a loosely coupled manner. We \nhaven\u2019t seen the last of the Observer Pattern\u2014\njust wait until we talk about MVC!\n\t\n\u0083\nThe Observer Pattern defines \na one-to-many relationship \nbetween objects.\n\t\n\u0083\nSubjects update Observers \nusing a common interface.\n\t\n\u0083\nObservers of any concrete type \ncan participate in the pattern \nas long as they implement the \nObserver interface.\n\t\n\u0083\nObservers are loosely coupled \nin that the Subject knows \nnothing about them, other \nthan that they implement the \nObserver interface.\n\t\n\u0083\nYou can push or pull data from \nthe Subject when using the \npattern (pull is considered more \n\u201ccorrect\u201d).\n\t\n\u0083\nSwing makes heavy use of the \nObserver Pattern, as do many \nGUI frameworks.\n\t\n\u0083\nYou\u2019ll also find the pattern in \nmany other places, including \nRxJava, JavaBeans, and RMI, \nas well as in other language \nframeworks, like Cocoa, Swift, \nand JavaScript events.\n\t\n\u0083\nThe Observer Pattern is related \nto the Publish/Subscribe Pattern, \nwhich is for more complex \nsituations with multiple Subjects \nand/or multiple message types.\n\t\n\u0083\nThe Observer Pattern is a \ncommonly used pattern, and \nwe\u2019ll see it again when we learn \nabout Model-View-Controller.\ndesign toolbox\n", "page": 110, "type": "text", "section": "Page 110"}
{"text": "you are here 4\u2003 \u2003 73\nthe observer pattern\nDesign Principle\nIdentify the aspects of your application that vary \nand separate them from what stays the same. \nDesign Principle\nProgram to an interface, not an implementation.\nDesign Principle\nFavor composition over inheritance.\nDesign Principle Challenge\nFor each design principle, describe how the Observer \nPattern makes use of the principle.\nThis is a hard one. Hint: think about how observers \nand subjects work together.\n", "page": 111, "type": "text", "section": "Page 111"}
{"text": "74\u2003 \u2003 Chapter 2\nDesign Patterns Crossword\nTime to give your right brain something to do again! \nAll of the solution words are from Chapters 1 & 2. \nACROSS\n1. One Subject likes to talk to _______ observers. \n3. Subject initially wanted to _________ all the data to \nObserver.\n6. CEO almost forgot the ________ index display.\n8. CurrentConditionsDisplay implements this interface. \n9. Java framework with lots of Observers.\n11. A Subject is similar to a __________.\n12. Observers like to be ___________ when something \nnew happens.\n15. How to get yourself off the Observer list. \n16. Lori was both an Observer and a _________.\n18. Subject is an ______.\n20. You want to keep your coupling ________.\n21. Program to an __________ not an implementation.\n22. Devil and Angel are _________ to the button.\nDOWN\n1. He didn\u2019t want any more ints, so he removed himself.\n2. Temperature, humidity, and __________.\n4. Weather-O-Rama\u2019s CEO is named after this kind of \nstorm.\n5. He says you should go for it.\n7. The Subject doesn\u2019t have to know much about the \n_____.\n10. The WeatherData class __________ the Subject \ninterface.\n13. Don\u2019t count on this for notification.\n14. Observers are______ on the Subject.\n17. Implement this method to get notified.\n19. Jill got one of her own.\ncross word\nUntitled Puzzle\nHeader Info 1\nHeader Info 2\netc...\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nAcross\n1. One Subject likes to talk to _____ \nObservers\n3. Subject initially wanted to ____ all the data \nto Observer\n6. CEO almost forgot the ____ index display\n8. CurrentConditionsDisplay implements this \ninterface\n9. Java framework with lots of Observers\n11. A Subject is similar to a _____\n12. Observers like to be _____ when something \nnew happens\n15. How to get yourself off the Observer list\n16. Ron was both an Observer and a ______\nDown\n1. He didn't want any more ints so he removed \nhimself\n2. Temperature, humidity, and _____\n4. Weather-O-Rama's CEO is named after this \nkind of storm\n5. He says you should go for it\n7. The Subject doesn't have to know much \nabout the _____\n10. The WeatherData class ______ the Subject \ninterface\n13. Don't count on this for notification\n14. Observers are _____ on the Subject\n17. Implement this method to get notified\n", "page": 112, "type": "text", "section": "Page 112"}
{"text": "you are here 4\u2003 \u2003 75\nthe observer pattern\nDesign Principle\nIdentify the aspects of your application that \nvary and separate them from what stays the \nsame. \nDesign Principle\nProgram to an interface, not an implementation.\nDesign Principle\nFavor composition over inheritance.\nThe thing that varies in the Observer Pattern \nis the state of the Subject and the number and \ntypes of Observers. With this pattern, you can  \nvary the objects that are dependent on the state \nof the Subject, without having to change that \nSubject. That\u2019s called planning ahead!\nBoth the Subject and Observers use interfaces.  \nThe Subject keeps track of objects implementing \nthe Observer interface, while the Observers \nregister with, and get notified by, the Subject \ninterface. As we\u2019ve seen, this keeps things nice and \nloosely coupled.\nThe Observer Pattern uses composition to compose \nany number of Observers with their Subject.  \nThese relationships aren\u2019t set up by some kind \nof inheritance hierarchy. No, they are set up at \nruntime by composition!\nDesign \nPrinciple \nChallenge \nSolution\n\u274f   A.\tWe are coding to concrete \nimplementations, not interfaces.\n\u274f   B.\tFor every new display element, \nwe need to alter code.\n\u274f   C.\tWe have no way to add display \nelements at runtime.\n\u274f   D.\tThe display elements don\u2019t implement \na common interface.\n\u274f   E.\tWe haven\u2019t encapsulated what changes. \n \n\u274f   F.\t We are violating encapsulation of the \nWeatherData class.\nBased on our first implementation, which of the \nfollowing apply? (Choose all that apply.)\n", "page": 113, "type": "text", "section": "Page 113"}
{"text": "76\u2003 \u2003 Chapter 2\nexercise solution\nCode Magnets Solution\nThe ForecastDisplay class is all scrambled up on the fridge. Can you \nreconstruct the code snippets to make it work? Some of the curly \nbraces fell on the floor and they were too small to pick up, so feel \nfree to add as many of those as you need! Here\u2019s our solution.\npublic void display() {\n    // display code here\n}\nweatherData.registerObserver(this);\ndisplay();\npublic class ForecastDisplay implements \n \n \n \n \nObserver, DisplayElement {\nlastPressure = currentPressure;\ncurrentPressure = weatherData.getPressure();\nprivate float currentPressure = 29.92f; \n \nprivate float lastPressure;\npublic void update() {\nprivate WeatherData weatherData;\n}\n}\n}\npublic ForecastDisplay(WeatherData \nweatherData) {\nthis.weatherData = weatherData;\n", "page": 114, "type": "text", "section": "Page 114"}
{"text": "you are here 4\u2003 \u2003 77\nthe observer pattern\nUntitled Puzzle\nHeader Info 1\nHeader Info 2\netc...\nM\n1\nA\nN\nY\nP\n2\nP\n3\nU\nS\nH\n4\nO\nR\nU\nU\nD\n5\nH\n6\nE\nA\nT\nO\n7\nR\nS\nE\nS\nO\n8\nB\nS\nE\nR\nV\nE\nR\nV\nS\n9\nW\nI\n10\nN\nG\nS\nI\nI\nU\nM\nE\nC\nL\nR\nP\n11\nU\nB\nL\nI\nS\nH\nE\nR\nA\nL\nE\nL\nV\nN\n12\nO\n13\nT\nI\nF\nI\nE\nD\n14\nR\n15\nE\nM\nO\nV\nE\nO\nB\nS\nE\nR\nV\nE\nR\nS\nE\nM\nR\nD\nT\nP\nE\nS\n16\nU\n17\nB\nJ\nE\nC\nT\nE\nE\nI\n18\nN\nT\nE\nR\nF\nA\nC\nE\nP\nR\nN\nN\nJ\n19\nT\nD\nE\nD\nL\n20\nO\nO\nS\nE\nI\n21\nN\nT\nE\nR\nF\nA\nC\nE\nR\nE\nB\nT\nN\nL\n22\nI\nS\nT\nE\nN\nI\nN\nG\nT\nAcross\n1. One Subject likes to talk to _____ \nObservers [MANY] \n3. Subject initially wanted to ____ all the data \nto Observer [PUSH] \n6. CEO almost forgot the ____ index display \n[HEAT] \n8. CurrentConditionsDisplay implements this \ninterface [OBSERVER] \n9. Java framework with lots of Observers \n[SWING] \n11. A Subject is similar to a _____ \n[PUBLISHER]\nDown\n1. He didn't want any more ints so he removed \nhimself [MOUSE] \n2. Temperature, humidity, and _____ \n[PRESSURE] \n4. Weather-O-Rama's CEO is named after this \nkind of storm [HURRICANE] \n5. He says you should go for it \n[DEVILLISTENER] \n7. The Subject doesn't have to know much \nabout the _____ [OBSERVERS] \n10. The WeatherData class ______ the Subject \ninterface [IMPLEMENTS]\nDesign Patterns \nCrossword Solution\n", "page": 115, "type": "text", "section": "Page 115"}
{"text": "this is a new chapter\u2003 \u2003 79\nJust call this chapter \u201cDesign Eye for the Inheritance Guy.\u201d \nWe\u2019ll re-examine the typical overuse of inheritance and you\u2019ll learn how to decorate \nyour classes at runtime using a form of object composition. Why? Once you know the \ntechniques of decorating, you\u2019ll be able to give your (or someone else\u2019s) objects new \nresponsibilities without making any code changes to the underlying classes.\nDecorating Objects          \n3  the Decorator Pattern\nI used to think real men \nsubclassed everything. That was \nuntil I learned the power of \nextension at runtime, rather than \nat compile time. Now look at me!\n", "page": 117, "type": "text", "section": "Page 117"}
{"text": "80\u2003 \u2003 Chapter 3\nthe starbuzz story\nWelcome to Starbuzz Coffee\nBeverage is an abstract class, \nsubclassed by all beverages \noffered in the coffee shop.\nEach subclass implements cost() to return the cost of the beverage.\ncost()\nEspresso\ncost()\nDecaf\ncost()\nDarkRoast\ncost()\nHouseBlend\nBeverage\ndescription\ngetDescription()\ncost()\n// Other useful methods...\nThe description instance variable \nis set in each subclass and holds a \ndescription of the beverage, like \n\u201cMost Excellent Dark Roast\u201d. \nThe getDescription() method \nreturns the description.\nThe cost() method is \nabstract; subclassses \nneed to define their \nown implementation.\nStarbuzz Coffee has made a name for itself as the fastest-\ngrowing coffee shop around. If you\u2019ve seen one on your local \ncorner, look across the street; you\u2019ll see another one.\nBecause they\u2019ve grown so quickly, they\u2019re scrambling to update \ntheir ordering systems to match their beverage offerings.  \nWhen they first went into business they designed their classes \nlike this...\n", "page": 118, "type": "text", "section": "Page 118"}
{"text": "you are here 4\u2003 \u2003 81\nthe decorator pattern\nBeverage\ndescription\ngetDescription()\ncost()\n// Other useful methods...\ncost()\nHouseBlendWithSteamedMilk\nandCaramel\ncost()\nHouseBlendWithMocha\ncost()\nHouseBlendWithWhipandMocha\ncost()\nHouseBlendWithSteamedMilk\nandSoy\ncost()\nHouseBlendWithSteamedMilk\ncost()\nHouseBlendWithSteamedMilk\nandMocha\ncost()\nHouseBlendWithSoy\ncost()\nHouseBlendWithWhip\ncost()\nHouseBlendWithSteamedMilk\nandWhip\ncost()\nHouseBlendWithSoyandMocha\ncost()\nHouseBlendWithWhipandSoy\ncost()\nDarkRoastWithSteamedMilk\nandCaramel\ncost()\nDarkRoastWithMocha\ncost()\nDarkRoastWithWhipandMocha\ncost()\nDarkRoastWithSteamedMilk\nandSoy\ncost()\nDarkRoastWithSteamedMilk\ncost()\nDarkRoastWithSteamedMilk\nandMocha\ncost()\nDarkRoastWithSoy\ncost()\nDarkRoastWithWhip\ncost()\nDarkRoastWithSteamedMilk\nandWhip\ncost()\nDarkRoastWithSoyandMocha\ncost()\nDarkRoastWithWhipandSoy\ncost()\nDecafWithSteamedMilk\nandCaramel\ncost()\nDecafWithMocha\ncost()\nDecafWithWhipandMocha\ncost()\nDecafWithSteamedMilk\nandSoy\ncost()\nDecafWithSteamedMilk\ncost()\nDecafWithSteamedMilk\nandMocha\ncost()\nDecafWithSoy\ncost()\nDecafWithWhip\ncost()\nDecafWithSteamedMilk\nandWhip\ncost()\nDecafWithSoyandMocha\ncost()\nDecafWithWhipandSoy\ncost()\nDarkRoastWithSoy\ncost()\nEspressoWithSteamedMilk\nandCaramel\ncost()\nEspressoWithMocha\ncost()\nEspressoWithWhipandMocha\ncost()\nEspressoWithSteamedMilk\nandSoy\ncost()\nEspressoWithSteamedMilk\ncost()\nEspressoWithSteamedMilk\nandMocha\ncost()\nDecafWithSoy\ncost()\nEspressoWhip\ncost()\nEspressoWithSteamedMilk\nandWhip\ncost()\nDecafWithSoyandMocha\ncost()\nEspressoWithWhipandSoy\nEach cost method computes the \ncost of the coffee along with the \nother condiments in the order.\nWhoa!  \nCan you say \n\u201cclass explosion\u201d?\nIn addition to your coffee, you can also ask for several \ncondiments like steamed milk, soy, and mocha (otherwise \nknown as chocolate), and have it all topped off with whipped \nmilk. Starbuzz charges a bit for each condiment, so they really \nneed to get them built into their order system. \n Here\u2019s their first attempt...\n", "page": 119, "type": "text", "section": "Page 119"}
{"text": "82\u2003 \u2003 Chapter 3\nviolating design principles\nWell, let\u2019s give it a try. Let\u2019s start with the Beverage base class \nand add instance variables to represent whether or not each \nbeverage has milk, soy, mocha, and whip...\nBeverage\ndescription\nmilk\nsoy\nmocha\nwhip\ngetDescription()\ncost()\nhasMilk()\nsetMilk()\nhasSoy()\nsetSoy()\nhasMocha()\nsetMocha()\nhasWhip()\nsetWhip()\n// Other useful methods..\nThese get and set the boolean \nvalues for the condiments.\nNew boolean values for \neach condiment.\nNow we\u2019ll implement cost() in Beverage (instead of \nkeeping it abstract), so that it can calculate the \ncosts associated with the condiments for a particular \nbeverage instance. Subclasses will still override \ncost(), but they will also invoke the super version so \nthat they can calculate the total cost of the basic \nbeverage plus the costs of the added condiments.\nThis is stupid; why \ndo we need all these classes? \nCan\u2019t we just use instance variables \nand inheritance in the superclass to \nkeep track of the condiments?\nIt\u2019s pretty obvious that Starbuzz has created a maintenance \nnightmare for themselves. What happens when the price of milk \ngoes up? What do they do when they add a new caramel topping? \n \nThinking beyond the maintenance problem, which of the design \nprinciples that we\u2019ve covered so far are they violating?\nHint: they\u2019re violating two of them in a big way!\n", "page": 120, "type": "text", "section": "Page 120"}
{"text": "you are here 4\u2003 \u2003 83\nthe decorator pattern\ncost()\nEspresso\ncost()\nDecaf\ncost()\nDarkRoast\ncost()\nHouseBlend\nNow let\u2019s add in the subclasses, one for \neach beverage on the menu:\nEach cost() method needs to compute \nthe cost of the beverage and then \nadd in the condiments by calling the \nsuperclass implementation of cost().\nBeverage\ndescription\nmilk\nsoy\nmocha\nwhip\ngetDescription()\ncost()\nhasMilk()\nsetMilk()\nhasSoy()\nsetSoy()\nhasMocha()\nsetMocha()\nhasWhip()\nsetWhip()\n// Other useful methods..\nThe superclass cost() will calculate the \ncosts for all of the condiments, while \nthe overridden cost() in the subclasses \nwill extend that functionality to include \ncosts for that specific beverage type.\nWrite the cost() methods for the following classes (pseudo-Java is okay):\npublic class Beverage {\n    public double cost() {\n    }\n}\npublic class DarkRoast extends Beverage {\n    public DarkRoast() {\n        description = \"Most Excellent Dark Roast\";\n    }\n    public double cost() {\n    }\n}\n", "page": 121, "type": "text", "section": "Page 121"}
{"text": "84\u2003 \u2003 Chapter 3\nimpact of change\nWhat requirements or other factors might change that will impact this design?\nPrice changes for condiments will force us to alter existing code.\nNew condiments will force us to add new methods and alter the cost method in the superclass.\nWe may have new beverages. For some of these beverages (iced tea?), the condiments may \nnot be appropriate, yet the T\nea subclass will still inherit methods like hasWhip().\nWhat if a customer wants a double mocha?\nYour turn:\nAs we saw in \nChapter 1, this is \na very bad idea!\nSee, five classes \ntotal. This is definitely \nthe way to go.\nI\u2019m not so sure; I can see some \npotential problems with this approach \nby thinking about how the design might \nneed to change in the future.\n", "page": 122, "type": "text", "section": "Page 122"}
{"text": "you are here 4\u2003 \u2003 85\nthe decorator pattern\nGuru and Student...\nGuru: It has been some time since our last meeting. Have you \nbeen deep in meditation on inheritance?\nStudent: Yes, Guru. While inheritance is powerful, I have \nlearned that it doesn\u2019t always lead to the most flexible or \nmaintainable designs. \nGuru: Ah yes, you have made some progress. So, tell me, my student, how \nthen will you achieve reuse if not through inheritance?\nStudent: Guru, I have learned there are ways of \u201cinheriting\u201d behavior at \nruntime through composition and delegation. \nGuru: Please, go on...\nStudent: When I inherit behavior by subclassing, that behavior is set statically \nat compile time. In addition, all subclasses must inherit the same behavior. If, \nhowever, I can extend an object\u2019s behavior through composition, then I can \ndo this dynamically at runtime.\nGuru: Very good; you are beginning to see the power of composition.\nStudent: Yes, it is possible for me to add multiple new responsibilities to \nobjects through this technique, including responsibilities that were not even \nthought of by the designer of the superclass. And I don\u2019t have to touch their \ncode!\nGuru: What have you learned about the effect of composition on maintaining \nyour code?\nStudent: Well, that is what I was getting at. By dynamically composing \nobjects, I can add new functionality by writing new code rather than altering \nexisting code. Because I\u2019m not changing existing code, the chances of \nintroducing bugs or causing unintended side effects in pre-existing code are \nmuch reduced.\nGuru: Very good. Enough for today. I would like for you to go and meditate \nfurther on this topic... Remember, code should be closed (to change) like the \nlotus flower in the evening, yet open (to extension) like the lotus flower in the \nmorning.\n", "page": 123, "type": "text", "section": "Page 123"}
{"text": "86\u2003 \u2003 Chapter 3\nthe open-closed principle\nThe Open-Closed Principle\nDesign Principle\nClasses should be open \nfor extension, but closed for \nmodification.\nCome on in; we\u2019re \nopen. Feel free to extend our \nclasses with any new behavior you like.  If your \nneeds or requirements change (and we know they \nwill), just go ahead and make your own extensions. \nSorry, we\u2019re closed.  \nThat\u2019s right, we \nspent a lot of time getting this \ncode correct and bug free, so we can\u2019t let you \nalter the existing code. It must remain closed to \nmodification. If you don\u2019t like it, you can speak to \nthe manager.\nWe're on to one of the most important design principles:\nOur goal is to allow classes to be easily extended to \nincorporate new behavior without modifying existing code. \nWhat do we get if we accomplish this? Designs that are \nresilient to change and flexible enough to take on new \nfunctionality to meet changing requirements.\n", "page": 124, "type": "text", "section": "Page 124"}
{"text": "you are here 4\u2003 \u2003 87\nthe decorator pattern\nWhile it may seem like a contradiction, \nthere are techniques for allowing code to be \nextended without direct modification.\nBe careful when choosing the areas of code \nthat need to be extended; applying the \nOpen-Closed Principle EVERYWHERE is \nwasteful and unnecessary, and can lead to \ncomplex, hard-to-understand code.\nQ: Open for extension and closed \nfor modification? That sounds very \ncontradictory. How can a design be both?\nA: That\u2019s a very good question. It certainly \nsounds contradictory at first. After all, the less \nmodifiable something is, the harder it is to \nextend, right?\n\nAs it turns out, though, there are some \nclever OO techniques for allowing systems \nto be extended, even if we can\u2019t change the \nunderlying code. Think about the Observer \nPattern (in Chapter 2)...by adding new \nObservers, we can extend the Subject at \nany time, without adding code to the Subject. \nYou\u2019ll see quite a few more ways of extending \nbehavior with other OO design techniques.\nQ: Okay, I understand Observer, but \nhow do I generally design something to be \nextensible yet closed for modification?\nA: Many of the patterns give us time-tested \ndesigns that protect your code from being \nmodified by supplying a means of extension. \nIn this chapter you\u2019ll see a good example of \nusing the Decorator Pattern to follow the Open-\nClosed Principle.\nQ: How can I make every part of my \ndesign follow the Open-Closed Principle?\nA: Usually, you can\u2019t. Making OO design \nflexible and open to extension without \nmodifying existing code takes time and effort. In \ngeneral, we don\u2019t have the luxury of tying down \nevery part of our designs (and it would probably \nbe wasteful). Following the Open-Closed \nPrinciple usually introduces new levels of \nabstraction, which adds complexity to our code. \nYou want to concentrate on those areas that are \nmost likely to change in your designs and apply \nthe principles there.\nQ: How do I know which areas of change \nare more important?\nA: That is partly a matter of experience \nin designing OO systems and also a matter \nof knowing the domain you are working in. \nLooking at other examples will help you learn to \nidentify areas of change in your own designs.\n", "page": 125, "type": "text", "section": "Page 125"}
{"text": "88\u2003 \u2003 Chapter 3\nmeet the decorator pattern\nMeet the Decorator Pattern\nOkay, we\u2019ve seen that representing our beverage and condiments with \ninheritance has not worked out very well\u2014we get class explosions and rigid \ndesigns, or we add functionality to the base class that isn\u2019t appropriate for \nsome of the subclasses.\nSo, here\u2019s what we\u2019ll do instead: we\u2019ll start with a beverage and \u201cdecorate\u201d \nit with the condiments at runtime. For example, if the customer wants a \nDark Roast with Mocha and Whip, then we\u2019ll:\n1\n2\nStart with a DarkRoast object.\nDecorate it with a Mocha object.\n3\nDecorate it with a Whip object.\n4\nCall the cost() method and rely on delegation to \nadd up the condiment costs.\nOkay, but how do you \u201cdecorate\u201d an object, and how does delegation \ncome into this? A hint: think of decorator objects as \u201cwrappers.\u201d Let\u2019s see \nhow this works...\nOkay, enough of the \n\u201cObject-Oriented Design Club.\u201d We \nhave real  problems here! Remember us? \nStarbuzz Coffee? Do you think you could use \nsome of those design principles to actually \nhelp us?\n", "page": 126, "type": "text", "section": "Page 126"}
{"text": "you are here 4\u2003 \u2003 89\nthe decorator pattern\nRemember that DarkRoast \ninherits from Beverage and has \na cost() method that computes \nthe cost of the drink.\n \n \n \nD\na\nr\nk\nR\no\na\ns\nt\ncost()\n  \n   \n \nM\noc\nh\na\ncost()\n  \nW\nh\ni\np\ncost()\n  \n   \n \nM\noc\nh\na\ncost()\n1\n2\nWe start with our DarkRoast object.\nThe customer wants Mocha, so we create a Mocha \nobject and wrap it around the DarkRoast.\n3\nThe customer also wants Whip, so we create a Whip \ndecorator and wrap Mocha with it.\nThe Mocha object is a decorator. Its \ntype mirrors the object it is decorating\u2014\nin this case, a Beverage. (By \u201cmirror,\u201d \nwe mean it is the same type.)\nSo, Mocha has a cost() method too, \nand through polymorphism we can treat \nany Beverage wrapped in Mocha as \na Beverage, too (because Mocha is a \nsubtype of Beverage).\nWhip is a decorator, so it also \nmirrors DarkRoast\u2019s type and \nincludes a cost() method.\nConstructing a drink order with Decorators\nSo, a DarkRoast wrapped in Mocha and Whip is still \na Beverage and we can do anything with it we can do \nwith a DarkRoast, including call its cost() method.\n \n \n \nD\na\nr\nk\nR\no\na\ns\nt\ncost()\n \n \n \nD\na\nr\nk\nR\no\na\ns\nt\ncost()\n", "page": 127, "type": "text", "section": "Page 127"}
{"text": "90\u2003 \u2003 Chapter 3\ndecorator characteristics\nFirst, we call cost() on the \noutermost decorator, Whip.\n  \nW\nh\ni\np\n  \n   \n \nM\noc\nh\na\n  \n \nD\na\nr\nk\nR\no\na\nst\nNow it\u2019s time to compute the cost for the customer. We do this by \ncalling cost() on the outermost decorator, Whip, and Whip is going to \ndelegate computing the cost to the objects it decorates. And so on. \nLet\u2019s see how this works:\nWhip calls cost() on Mocha.\nMocha adds its cost, 20 cents, \nto the result from DarkRoast, \nand returns the new total, $1.19.\n4\n.99\n.20\n.10\n$1.29\nWhip adds its total, 10 cents, \nto the result from Mocha, and \nreturns the final result\u2014$1.29.\n1\n2\n5\n6\nOkay, here\u2019s what we know about Decorators, so far...\n\t\n\u0083\nDecorators have the same supertype as the objects they decorate.\n\t\n\u0083\nYou can use one or more decorators to wrap an object.\n\t\n\u0083\nGiven that the decorator has the same supertype as the object it decorates, we can \npass around a decorated object in place of the original (wrapped) object.\n\t\n\u0083\nThe decorator adds its own behavior before and/or after delegating to the object it \ndecorates to do the rest of the job.\n\t\n\u0083\nObjects can be decorated at any time, so we can decorate objects dynamically at \nruntime with as many decorators as we like.\nNow let\u2019s see how this all really works by looking at the \nDecorator Pattern definition and writing some code.\n3\nMocha calls cost() on \nDarkRoast.\nDarkRoast returns \nits cost, 99 cents.\n4\n(You\u2019ll see how in \na few pages.)\nKey point!\ncost()\ncost()\ncost()\n", "page": 128, "type": "text", "section": "Page 128"}
{"text": "you are here 4\u2003 \u2003 91\nthe decorator pattern\nThe Decorator Pattern attaches additional \nresponsibilities to an object dynamically.  \nDecorators provide a flexible alternative to \nsubclassing for extending functionality.\nThe Decorator Pattern defined\nDecorators implement the \nsame interface or abstract \nclass as the component they \nare going to decorate.\nmethodA()\nmethodB()\n// other methods\nConcreteComponent\ncomponent\nmethodA()\nmethodB()\n// other methods\nComponent\nThe ConcreteDecorator \ninherits (from the \nDecorator class) an instance \nvariable for the thing it \ndecorates (the Component \nthe Decorator wraps).\nDecorators can add new methods; however, new \nbehavior is typically added by doing computation \nbefore or after an existing method in the component.\nEach decorator HAS-A  \n(wraps) a component, which \nmeans the decorator has an \ninstance variable that holds a \nreference to a component.\nThe ConcreteComponent  \nis the object we\u2019re going \nto dynamically add new \nbehavior to. It extends \nComponent.\nLet\u2019s first take a look at the Decorator Pattern description:\nWhile that describes the role of the Decorator Pattern, it doesn\u2019t give us a lot \nof insight into how we\u2019d apply the pattern to our own implementation. Let\u2019s \ntake a look at the class diagram, which is a little more revealing (on the next \npage we\u2019ll look at the same structure applied to the beverage problem).\nEach component can be used on its \nown or wrapped by a decorator.\nDecorators can extend the \nstate of the component.\nConcreteDecoratorB\nmethodA()\nmethodB()\n// other methods\nObject newState\nConcreteDecoratorA\nmethodA()\nmethodB()\nnewBehavior()\n// other methods\nmethodA()\nmethodB()\n// other methods\nDecorator\nComponent wrappedObj\n", "page": 129, "type": "text", "section": "Page 129"}
{"text": "92\u2003 \u2003 Chapter 3\ndecorating beverages\nDecorating our Beverages\nLet\u2019s rework our Starbuzz beverages using the Decorator Pattern...\nBeverage beverage\nCondimentDecorator\ngetDescription()\ncost()\n// other useful methods\nBeverage\ndescription\ncost()\ngetDescription()\nMilk\ncost()\nHouseBlend\ncomponent\ncost()\nDarkRoast\ncost()\nDecaf\ncost()\nEspresso\nMocha\nThe four concrete \ncomponents, one per \ncoffee type.\nAnd here are our condiment decorators; notice \nthey need to implement not only cost() but also \ngetDescription(). We\u2019ll see why in a moment...\nBeverage acts as our \nabstract component class.\nBefore going further, think about how you\u2019d implement the cost() \nmethod of the coffees and the condiments. Also think about how \nyou\u2019d implement the getDescription() method of the condiments.\ngetDescription()\nSoy\nWhip\ncost()\ngetDescription()\ncost()\ngetDescription()\ncost()\ngetDescription()\nHere's the reference to \nthe Beverage that the \nDecorators will be wrapping.\n", "page": 130, "type": "text", "section": "Page 130"}
{"text": "you are here 4\u2003 \u2003 93\nthe decorator pattern\nCubicle Conversation\nSome confusion over Inheritance versus Composition\nMary\nSue: What do you mean?\nMary: Look at the class diagram. The CondimentDecorator is extending the Beverage class.  \nThat\u2019s inheritance, right?\nSue: True. I think the point is that it\u2019s vital that the decorators have the same type as the objects \nthey are going to decorate. So here we\u2019re using inheritance to achieve the type matching, but we \naren\u2019t using inheritance to get behavior.\nMary: Okay, I can see how decorators need the same \u201cinterface\u201d as the components they wrap \nbecause they need to stand in place of the component. But where does the behavior come in?\nSue: When we compose a decorator with a component, we are adding new behavior. We are \nacquiring new behavior not by inheriting it from a superclass, but by composing objects together.\nMary: Okay, so we\u2019re subclassing the abstract class Beverage in order to have the correct type, \nnot to inherit its behavior. The behavior comes in through the composition of decorators with the \nbase components as well as other decorators.\nSue: That\u2019s right.\nMary: Oh, I get it! And because we are using object composition, we get a whole lot more \nflexibility about how to mix and match condiments and beverages. Very slick.\nSue: Yes, if we rely on inheritance, then our behavior can only be determined statically at \ncompile time. In other words, we get only whatever behavior the superclass gives us or that we \noverride. With composition, we can mix and match decorators any way we like...at runtime.\nMary: I get it\u2014we can implement new decorators at any time to add new behavior. If we relied \non inheritance, we\u2019d have to go in and change existing code anytime we wanted new behavior.\nSue: Exactly.\nMary: I just have one more question: if all we need to inherit is the type of the component, how \ncome we didn\u2019t use an interface instead of an abstract class for the Beverage class?\nSue: Well, remember, when we got this code, Starbuzz already had an abstract Beverage class.  \nTraditionally the Decorator Pattern does specify an abstract component, but in Java, obviously, \nwe could use an interface. But we always try to avoid altering existing code, so don\u2019t \u201cfix\u201d it if the \nabstract class will work just fine.\nOkay, I\u2019m a little confused...I \nthought we weren\u2019t going to use \ninheritance in this pattern? I thought \nwe were going to rely on composition \ninstead?\n", "page": 131, "type": "text", "section": "Page 131"}
{"text": "94\u2003 \u2003 Chapter 3\ndecorator training\nNew barista training\nFirst, we call cost() on the \noutermost decorator, Whip.\n  \nW\nh\ni\np\ncost()\n  \n   \n \nM\noc\nh\na\n  \n \nD\na\nr\nk\nR\no\na\nst\ncost()\ncost()\nWhip calls cost() on Mocha.\nMocha adds its cost, 20 \ncents, to the result from \nDarkRoast, and returns \nthe new total, $1.19.\n.99\n.20\n.10\n$1.29\nWhip adds its total, 10 cents, \nto the result from Mocha, and \nreturns the final result\u2014$1.29.\n1\n2\n5\n6\n3\nDarkRoast returns \nits cost, 99 cents.\n4\nMocha calls cost() on \nDarkRoast.\nMake a picture for what happens when the order is for a \n\u201cdouble mocha soy latte with whip\u201d beverage. Use the menu to \nget the correct prices, and draw your picture using the same \nformat we used earlier (from a few pages back):\nStarbuzz Coffee\nCoffees\nHouse Blend \n \n \nDark Roast \nDecaf         \nEspresso\nCondiments\nSteamed Milk\nMocha\nSoy\nWhip\n .89\n .99\n1.05\n1.99\n .10\n .20\n .15\n .10\nDraw your picture here.\nThis picture was for \na \u201cdark roast mocha \nwhip\u201d beverage. \nS\nt\na\nr\nb\nu\nz\nz\n \nC\no\nf\nf\ne\ne\n \nS\nt\na\nr\nb\nu\nz\nz\n \nC\no\nf\nf\ne\ne\nHINT: you can make a \n\u201cdouble mocha soy latte \nwith whip\u201d by combining \nHouseBlend, Soy, two shots \nof Mocha, and Whip! \nOkay, I need for you to \nmake me a double mocha \nsoy latte with whip.\n", "page": 132, "type": "text", "section": "Page 132"}
{"text": "you are here 4\u2003 \u2003 95\nthe decorator pattern\npublic abstract class CondimentDecorator extends Beverage {\n    Beverage beverage;\n    public abstract String getDescription();\n}\npublic abstract class Beverage {\n    String description = \"Unknown Beverage\";\n  \n    public String getDescription() {\n        return description;\n    }\n \n    public abstract double cost();\n}\nWriting the Starbuzz code\nIt\u2019s time to whip this design into some real code. \nLet\u2019s start with the Beverage class, which doesn\u2019t \nneed to change from Starbuzz\u2019s original design.  \nLet\u2019s take a look: \nBeverage is simple enough. Let\u2019s implement the abstract \nclass for the Condiments (the Decorator) as well:\nBeverage is an abstract \nclass with the two methods \ngetDescription() and cost().\ngetDescription is already \nimplemented for us, but we \nneed to implement cost() \nin the subclasses.\nFirst, we need to be \ninterchangeable with a Beverage, \nso we extend the Beverage class.\nWe\u2019re also going to require \nthat the condiment \ndecorators all reimplement the \ngetDescription() method. Again, \nwe\u2019ll see why in a sec...\nHere's the Beverage that each \nDecorator will be wrapping. \nNotice we are using the \nBeverage supertype to refer to \nthe Beverage so the Decorator \ncan wrap any beverage.\n", "page": 133, "type": "text", "section": "Page 133"}
{"text": "96\u2003 \u2003 Chapter 3\nimplementing the beverages\npublic class HouseBlend extends Beverage {\n    public HouseBlend() {\n        description = \"House Blend Coffee\";\n    }\n \n    public double cost() {\n        return .89;\n    }\n}\npublic class Espresso extends Beverage {\n    public Espresso() {\n        description = \"Espresso\";\n    }\n  \n    public double cost() {\n        return 1.99;\n    }\n}\nCoding beverages\nStarbuzz Coffee\nCoffees\nHouse Blend \n \n \nDark Roast \nDecaf         \nEspresso\nCondiments\nSteamed Milk\nMocha\nSoy\nWhip\n .89\n .99\n1.05\n1.99\n .10\n .20\n .15\n .10\nNow that we\u2019ve got our base classes out of the way, let\u2019s implement \nsome beverages. We\u2019ll start with Espresso. Remember, we need to \nset a description for the specific beverage and also implement the \ncost() method.\nFirst we extend the Beverage \nclass, since this is a beverage.\nT\no take care of the description, we set \nthis in the constructor for the class. \nRemember, the description instance \nvariable is inherited from Beverage.\nFinally, we need to compute the cost of an Espresso. We don\u2019t \nneed to worry about adding in condiments in this class, we just \nneed to return the price of an Espresso: $1.99.\nOkay, here\u2019s another Beverage. All we \ndo is set the appropriate description, \n\u201cHouse Blend Coffee,\u201d and then return \nthe correct cost: 89\u00a2.\nYou can create the other two Beverage classses \n(DarkRoast and Decaf) in exactly the same way.\n", "page": 134, "type": "text", "section": "Page 134"}
{"text": "you are here 4\u2003 \u2003 97\nthe decorator pattern\npublic class Mocha extends CondimentDecorator {\n \n    public Mocha(Beverage beverage) {\n        this.beverage = beverage;\n    }\n \n    public String getDescription() {\n        return beverage.getDescription() + \", Mocha\";\n    }\n \n    public double cost() {\n        return beverage.cost() + .20;\n    }\n}\nCoding condiments\nIf you look back at the Decorator Pattern class diagram, you\u2019ll see \nwe\u2019ve now written our abstract component (Beverage), we have \nour concrete components (HouseBlend), and we have our abstract \ndecorator (CondimentDecorator). Now it\u2019s time to implement the \nconcrete decorators. Here\u2019s Mocha:\nMocha is a decorator, so we \nextend CondimentDecorator.\nWe\u2019re going to instantiate Mocha with a \nreference to a Beverage.\nRemember, this class inherits the \nBeverage instance variable to hold the \nbeverage we are wrapping.\nWe set this instance variable to the \nobject we are wrapping. Here, we\u2019re \npassing the beverage we\u2019re wrapping to \nthe decorator\u2019s constructor.\nNow we need to compute the cost of our beverage \nwith Mocha. First, we delegate the call to the \nobject we\u2019re decorating so that it can compute the \ncost; then, we add the cost of Mocha to the result.\nWe want our description to include not \nonly the beverage-say \u201cDark Roast\u201d-\nbut also each item decorating the \nbeverage (for instance, \u201cDark Roast,  \nMocha\u201d). So we first delegate to the \nobject we are decorating to get its \ndescription, then append \u201c, Mocha\u201d to \nthat description.\nOn the next page we\u2019ll actually instantiate the beverage and \nwrap it with all its condiments (decorators), but first...\nRemember, CondimentDecorator \nextends Beverage.\nWrite and compile the code for the other Soy and Whip \ncondiments. You\u2019ll need them to finish and test the application.\n", "page": 135, "type": "text", "section": "Page 135"}
{"text": "98\u2003 \u2003 Chapter 3\ntesting the beverages\npublic class StarbuzzCoffee {\n \n    public static void main(String args[]) {\n        Beverage beverage = new Espresso();\n        System.out.println(beverage.getDescription() \n                + \" $\" + beverage.cost());\n \n        Beverage beverage2 = new DarkRoast();\n        beverage2 = new Mocha(beverage2);\n        beverage2 = new Mocha(beverage2);\n        beverage2 = new Whip(beverage2);\n        System.out.println(beverage2.getDescription() \n                + \" $\" + beverage2.cost());\n \n        Beverage beverage3 = new HouseBlend();\n        beverage3 = new Soy(beverage3);\n        beverage3 = new Mocha(beverage3);\n        beverage3 = new Whip(beverage3);\n        System.out.println(beverage3.getDescription() \n                + \" $\" + beverage3.cost());\n    }\n}\nServing some coffees\nFile  Edit   Window  Help  CloudsInMyCoffee\n% java StarbuzzCoffee\nEspresso $1.99\nDark Roast Coffee, Mocha, Mocha, Whip $1.49\nHouse Blend Coffee, Soy, Mocha, Whip $1.34\n%\nCongratulations. It\u2019s time to sit back, order a few coffees, and marvel \nat the flexible design you created with the Decorator Pattern.\nHere\u2019s some test code to make orders:\nOrder up an espresso, no condiments, \nand print its description and cost.\nMake a DarkRoast object.\nFinally, give us a HouseBlend \nwith Soy, Mocha, and Whip.\nNow, let\u2019s get those orders in:\nWe\u2019re going to see a much better way of creating \ndecorated objects when we cover the Factory and \nBuilder Design Patterns. Please note that the \nBuilder Pattern is covered in the Appendix.\nFile  Edit   Window  Help  CloudsInMyCoffee\nWrap it with a Mocha.\nWrap it in a second Mocha.\nWrap it in a Whip.\n", "page": 136, "type": "text", "section": "Page 136"}
{"text": "you are here 4\u2003 \u2003 99\nthe decorator pattern\nOur friends at Starbuzz have introduced sizes to their menu. You can now order a \ncoffee in tall, grande, and venti sizes (translation: small, medium, and large). Starbuzz \nsaw this as an intrinsic part of the coffee class, so they\u2019ve added two methods to \nthe Beverage class: setSize() and getSize(). They\u2019d also like for the condiments to be \ncharged according to size, so for instance, Soy costs 10\u00a2, 15\u00a2, and 20\u00a2, respectively, for \ntall, grande, and venti coffees. The updated Beverage class is shown below.\nHow would you alter the decorator classes to handle this change in requirements?\nQ: I\u2019m a little worried about code \nthat might test for a specific concrete \ncomponent\u2014say, HouseBlend\u2014and do \nsomething, like issue a discount. Once \nI\u2019ve wrapped the HouseBlend with \ndecorators, this isn\u2019t going to work \nanymore.\nA: That is exactly right. If you have code \nthat relies on the concrete component\u2019s \ntype, decorators will break that code. As \nlong as you only write code against the \nabstract component type, the use of \ndecorators will remain transparent to your \ncode. However, once you start writing code \nagainst concrete components, you\u2019ll want to \nrethink your application design and your use \nof decorators.\n\nQ: Wouldn\u2019t it be easy for some client \nof a beverage to end up with a decorator \nthat isn\u2019t the outermost decorator? Like \nif I had a DarkRoast with Mocha, Soy, \nand Whip, it would be easy to write code \nthat somehow ended up with a reference \nto Soy instead of Whip, which means it \nwould not include Whip in the order.\nA: You could certainly argue that you \nhave to manage more objects with the \nDecorator Pattern and so there is an \nincreased chance that coding errors will \nintroduce the kinds of problems you suggest. \nHowever, we typically create decorators \nby using other patterns like Factory and \nBuilder. Once we\u2019ve covered these patterns, \nyou\u2019ll see that the creation of the concrete \ncomponent with its decorator is \u201cwell \nencapsulated\u201d and doesn\u2019t lead to these \nkinds of problems.\nQ: Can decorators know about the \nother decorations in the chain? Say I \nwanted my getDescription() method to \nprint \u201cWhip, Double Mocha\u201d instead of \n\u201cMocha, Whip, Mocha.\u201d That would require \nthat my outermost decorator know all the \ndecorators it is wrapping.\nA: Decorators are meant to add behavior \nto the object they wrap. When you need to \npeek at multiple layers into the decorator \nchain, you are starting to push the decorator \nbeyond its true intent. Nevertheless, \nsuch things are possible. Imagine a \nCondimentPrettyPrint decorator that parses \nthe final decription and can print \u201cMocha,  \nWhip, Mocha\u201d as \u201cWhip, Double Mocha.\u201d  \nNote that getDescription() could return an \nArrayList of descriptions to make this easier.\npublic abstract class Beverage {\n\t\npublic enum Size { TALL, GRANDE, VENTI };\n\t\nSize size = Size.TALL;\n\t\nString description = \"Unknown Beverage\";\n  \t\npublic String getDescription() {\n\t\n\t\nreturn description;\n\t\n}\n\t\npublic void setSize(Size size) {\n\t\n\t\nthis.size = size;\n\t\n}\n\t\npublic Size getSize() {\n\t\n\t\nreturn this.size;\n\t\n}\n\t\npublic abstract double cost();\n}\n", "page": 137, "type": "text", "section": "Page 137"}
{"text": "100\u2003 \u2003 Chapter 3\ndecorators in java i/o\nFileInputStream is the component \nthat\u2019s being decorated. The \nJava I/O library supplies several \ncomponents, including FileInputStream, \nStringBufferInputStream, \nByteArrayInputStream, and a few \nothers. All of these give us a base \ncomponent from which to read bytes.\nReal-World Decorators: Java I/O\nThe large number of classes in the java.io package is...overwhelming. Don\u2019t feel alone \nif you said \u201cwhoa\u201d the first (and second and third) time you looked at this API. \nBut now that you know the Decorator Pattern, the I/O classes should make more \nsense since the java.io package is largely based on Decorator. Here\u2019s a typical set of \nobjects that use decorators to add functionality to reading data from a file:\nZi\np\nI\nn\np\nu\nt\nS\nt\nr\ne\nam\nB\nu\nf\nf\ne\nr\ne\nd\nI\nn\npu\nt\nS\nt\nre\na\nm\nFi\nle\nIn\npu\nt\nS\nt\nr\ne\na\nm\nBufferedInputStream is \na concrete decorator.  \nBufferedInputStream adds \nbuffering behavior to a \nFileInputStream: it buffers \ninput to improve performance.\nZipInputStream is also a \nconcrete decorator. It \nadds the ability to read \nzip file entries as it reads \ndata from a zip file.\nA text file for reading.\n", "page": 138, "type": "text", "section": "Page 138"}
{"text": "you are here 4\u2003 \u2003 101\nthe decorator pattern\nBufferedInputStream and ZipInputStream both extend FilterInputStream, which \nextends InputStream. InputStream acts as the abstract decorator class: \nFileInputStream\nByteArrayInputStream\nFilterInputStream\nStringBufferInputStream\nInputStream\nInflatorInputStream\nDataInputStream\nBufferedInputStream\nPushbackInputStream\nHere\u2019s our abstract component.\nFilterInputStream \nis an abstract \ndecorator.\nAnd finally, here are all our concrete decorators.\nYou can see that this isn\u2019t so different from the Starbuzz design. You should \nnow be in a good position to look over the java.io API docs and compose \ndecorators on the various input streams. \nYou\u2019ll see that the output streams have the same design. And you\u2019ve probably \nalready found that the Reader/Writer streams (for character-based data) \nclosely mirror the design of the streams classes (with a few differences and \ninconsistencies, but close enough to figure out what\u2019s going on).\nJava I/O also points out one of the downsides of the Decorator Pattern: \ndesigns using this pattern often result in a large number of small classes \nthat can be overwhelming to a developer trying to use the Decorator-based \nAPI. But now that you know how Decorator works, you can keep things in \nperspective and when you\u2019re using someone else\u2019s Decorator-heavy API, you \ncan work through how their classes are organized so that you can easily use \nwrapping to get the behavior you\u2019re after.  \nDecorating the java.io classes\nThese InputStreams act as the concrete \ncomponents that we will wrap with \ndecorators. There are a few more we \ndidn\u2019t show, like ObjectInputStream.\nZipInputStream\n", "page": 139, "type": "text", "section": "Page 139"}
{"text": "102\u2003 \u2003 Chapter 3\nwrite your own i/o decorator\npublic class LowerCaseInputStream extends FilterInputStream {\n    public LowerCaseInputStream(InputStream in) {\n        super(in);\n    }\n \n    public int read() throws IOException {\n        int c = in.read();\n        return (c == -1 ? c : Character.toLowerCase((char)c));\n    }\n        \n    public int read(byte[] b, int offset, int len) throws IOException {\n        int result = in.read(b, offset, len);\n        for (int i = offset; i < offset+result; i++) {\n            b[i] = (byte)Character.toLowerCase((char)b[i]);\n        }\n        return result;\n    }\n}\nWriting your own Java I/O Decorator\nOkay, you know the Decorator Pattern, and you\u2019ve seen the \nI/O class diagram. You should be ready to write your own input \ndecorator.\nHow about this: write a decorator that converts all uppercase \ncharacters to lowercase in the input stream.  In other words, if \nwe read in \u201cI know the Decorator Pattern therefore I RULE!\u201d \nthen your decorator converts this to \u201ci know the decorator \npattern therefore i rule!\u201d\nFirst, extend the FilterInputStream, the \nabstract decorator for all InputStreams.\nNow we need to implement two \nread methods. They take a \nbyte (or an array of bytes) \nand convert each byte (that \nrepresents a character) to \nlowercase if it\u2019s an uppercase \ncharacter.\nDon\u2019t forget to import \njava.io... (not shown).\nREMEMBER: we don\u2019t provide import and package statements \nin the code listings. Get the complete source code from \nhttps://wickedlysmart.com/head-first-design-patterns.\nNo problem. I \njust have to extend the \nFilterInputStream class and \noverride the read() methods.\n", "page": 140, "type": "text", "section": "Page 140"}
{"text": "you are here 4\u2003 \u2003 103\nthe decorator pattern\npublic class InputTest {\n    public static void main(String[] args) throws IOException {\n        int c;\n        try {\n            InputStream in = \n                new LowerCaseInputStream(\n                    new BufferedInputStream(\n                        new FileInputStream(\"test.txt\")));\n            while((c = in.read()) >= 0) {\n                System.out.print((char)c);\n            }\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\nWrite some quick code to test the I/O decorator:\n% java InputTest\ni know the decorator pattern therefore i rule!\n%\nFile  Edit   Window  Help  DecoratorsRule\nGive it a spin:\nSet up the FileInputStream and decorate \nit, first with a BufferedInputStream \nand then our brand new \nLowerCaseInputStream filter.\nJust use the stream to read \ncharacters until the end of \nfile and print as we go.\nI know the Decorator Pattern therefore I RULE!\ntest.txt file\nTest out your new Java I/O Decorator\nYou need to \nmake this file.\n", "page": 141, "type": "text", "section": "Page 141"}
{"text": "104\u2003 \u2003 Chapter 3\ndecorator interview\nHead First: Welcome, Decorator Pattern. We\u2019ve heard that you\u2019ve been a bit down on \nyourself lately?\nDecorator: Yes, I know the world sees me as the glamorous design pattern, but you know, I\u2019ve \ngot my share of problems just like everyone. \nHeadFirst: Can you perhaps share some of your troubles with us?\nDecorator: Sure. Well, you know I\u2019ve got the power to add flexibility to designs, that much is \nfor sure, but I also have a dark side. You see, I can sometimes add a lot of small classes to a design, \nand this occasionally results in a design that\u2019s less than straightforward for others to understand.\nHeadFirst: Can you give us an example?\nDecorator: Take the Java I/O libraries. These are notoriously difficult for people to \nunderstand at first. But if they just saw the classes as a set of wrappers around an InputStream, \nlife would be much easier.\nHeadFirst: That doesn\u2019t sound so bad. You\u2019re still a great pattern, and improving this is just a \nmatter of public education, right?\nDecorator: There\u2019s more, I\u2019m afraid. I\u2019ve got typing problems: you see, people sometimes \ntake a piece of client code that relies on specific types and introduce decorators without \nthinking through everything. Now, one great thing about me is that you can usually insert decorators \ntransparently and the client never has to know it\u2019s dealing with a decorator. But like I said, some code is \ndependent on specific types and when you start introducing decorators, boom! Bad things \nhappen.\nHeadFirst: Well, I think everyone understands that you have to be careful when inserting \ndecorators. I don\u2019t think this is a reason to be too down on yourself.\nDecorator: I know, I try not to be. I also have the problem that introducing decorators can \nincrease the complexity of the code needed to instantiate the component. Once you\u2019ve got \ndecorators, you\u2019ve got to not only instantiate the component, but also wrap it with who knows \nhow many decorators.\nHeadFirst: I\u2019ll be interviewing the Factory and Builder patterns next week\u2014I hear they can \nbe very helpful with this?\nDecorator: That\u2019s true; I should talk to those guys more often.\nHeadFirst: Well, we all think you\u2019re a great pattern for creating flexible designs and staying \ntrue to the Open-Closed Principle, so keep your chin up and think positively!\nDecorator: I\u2019ll do my best, thank you.\nPatterns Exposed\nThis week\u2019s interview:\nConfessions of a Decorator\n", "page": 142, "type": "text", "section": "Page 142"}
{"text": "you are here 4\u2003 \u2003 105\nthe decorator pattern\nTools for your Design Toolbox\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies.\nFavor composition over inheritance.\nProgram to interfaces, not \nimplementations.\nStrive for loosely coupled designs \nbetween objects that interact.\nClasses should be open for \nextension but closed for \nmodification.\nOO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable.  Strategy lets the algorithm \nvary independently from clients that use it.\nOO Patterns\nYou\u2019ve got another chapter under your belt and a new \nprinciple and pattern in the toolbox.\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nWe now have the Open-\nClosed Principle to guide \nus. We\u2019re going to strive \nto design our system so \nthat the closed parts \nare isolated from our \nnew extensions.\nAnd here\u2019s our first pattern for creating designs \nthat satisfy the Open-Closed Principle. Or was it \nreally the first? Is there another pattern we\u2019ve \nused that follows this principle as well?\nDecorator - Attach additional \nresponsibilities to an object dynamically.  \nDecorators provide a flexible \nalternative to subclassing for extending \nfunctionality.\n\t\n\u0083\nInheritance is one form of \nextension, but not necessarily the \nbest way to achieve flexibility in \nour designs.\n\t\n\u0083\nIn our designs we should allow \nbehavior to be extended without \nthe need to modify existing code.\n\t\n\u0083\nComposition and delegation \ncan often be used to add new \nbehaviors at runtime.\n\t\n\u0083\nThe Decorator Pattern provides \nan alternative to subclassing for \nextending behavior.\n\t\n\u0083\nThe Decorator Pattern involves \na set of decorator classes that \nare used to wrap concrete \ncomponents.\n\t\n\u0083\nDecorator classes mirror the type \nof the components they decorate. \n(In fact, they are the same type \nas the components they decorate, \neither through inheritance or \ninterface implementation.)\n\t\n\u0083\nDecorators change the behavior of \ntheir components by adding new \nfunctionality before and/or after (or \neven in place of) method calls to \nthe component.\n\t\n\u0083\nYou can wrap a component with \nany number of decorators.\n\t\n\u0083\nDecorators are typically \ntransparent to the client of the \ncomponent\u2014that is, unless \nthe client is relying on the \ncomponent\u2019s concrete type.\n\t\n\u0083\nDecorators can result in many \nsmall objects in our design, and \noveruse can be complex.\n", "page": 143, "type": "text", "section": "Page 143"}
{"text": "106\u2003 \u2003 Chapter 3\nexercise solutions\nWrite the cost() methods for the following classes \n(pseudo-Java is okay). Here\u2019s our solution:\npublic class Beverage {\n// declare instance variables for milkCost,\n// soyCost, mochaCost, and whipCost, and \n// getters and setters for milk, soy, mocha\n// and whip.  \npublic double cost() {\n        double condimentCost = 0.0;\n        if (hasMilk()) {\n            condimentCost += milkCost;\n        }\n        if (hasSoy()) {\n            condimentCost += soyCost;\n        }\n        if (hasMocha()) {\n            condimentCost += mochaCost;\n        }\n        if (hasWhip()) {\n            condimentCost += whipCost;\n        }\n        return condimentCost;\n    }\n}\npublic class DarkRoast extends Beverage {\n    public DarkRoast() {\n        description = \"Most Excellent Dark Roast\";\n    }\n    public double cost() {\n        return 1.99 + super.cost();\n    }\n}\n", "page": 144, "type": "text", "section": "Page 144"}
{"text": "you are here 4\u2003 \u2003 107\nthe decorator pattern\nS\nt\na\nr\nb\nu\nz\nz\n \nC\no\nf\nf\ne\ne\n  \n   \n \nM\noc\nh\na\n  \n \nH\no\nu\ns\ne\nB\nl\nend\n  \n   \n \nM\noc\nh\na\n  \n  \nSo\ny\n  \nW\nh\ni\np\ncost()\ncost()\ncost()\ncost()\ncost()\n.89\n.15\n.20\n.20\n.10\n$1.54\nFirst, we call cost() on the \noutermost decorator, Whip.\nWhip calls cost() on Mocha.\nLast topping! Soy calls \ncost() on HouseBlend.\nFinally, the result returns to Whip\u2019s \ncost(), which adds .10, giving us a \nfinal cost of $1.54.\n1\n2\n5\n10\n3 Mocha calls cost() on another Mocha.\n4 Next, Mocha calls cost() on Soy.\nNew barista training\n\u201cdouble mocha soy latte with whip\u201d \nHouseBlend\u2019s cost() method \nreturns .89 and pops off \nthe stack.\n6\nSoy\u2019s cost() method adds .15 \nand returns the result, then \npops off the stack.\n7\nThe second Mocha\u2019s cost() method \nadds .20 and returns the result, \nthen pops off the stack.\n8\nThe first Mocha\u2019s cost() method adds \n.20 and returns the result, then pops \noff the stack.\n9\n", "page": 145, "type": "text", "section": "Page 145"}
{"text": "108\u2003 \u2003 Chapter 3\nexercise solutions\npublic class Soy extends CondimentDecorator {\n    public Soy(Beverage beverage) {\n        this.beverage = beverage;\n    }\n    public String getDescription() {\n        return beverage.getDescription() + \", Soy\";\n    }\n    public double cost() {\n        double cost = beverage.cost();\n        if (beverage.getSize() == Size.TALL) {\n            cost += .10;\n        } else if (beverage.getSize() == Size.GRANDE) {\n            cost += .15;\n        } else if (beverage.getSize() == Size.VENTI) {\n            cost += .20;\n        }\n        return cost;\n    }\n}\nOur friends at Starbuzz have introduced sizes to their menu. You can now order \na coffee in tall, grande, and venti sizes (translation: small, medium, and large). \nStarbuzz saw this as an intrinsic part of the coffee class, so they\u2019ve added two \nmethods to the Beverage class: setSize() and getSize().  They\u2019d also like for the \ncondiments to be charged according to size, so for instance, Soy costs 10\u00a2, 15\u00a2, \nand 20\u00a2, respectively, for tall, grande, and venti coffees.\nHow would you alter the decorator classes to handle this change in \nrequirements? Here\u2019s our solution.\nHere we get the size (which \npropagates all the way to the \nconcrete beverage) and then \nadd the appropriate cost.\npublic abstract class CondimentDecorator extends Beverage {\n    public Beverage beverage;\n    public abstract String getDescription();\n\t\n    public Size getSize() {\n        return beverage.getSize();\n    }\n}\nWe added a method, getSize(), for \nthe decorators that simply returns \nthe size of the beverage.\n", "page": 146, "type": "text", "section": "Page 146"}
{"text": "this is a new chapter\u2003 \u2003 109\n4  the Factory Pattern\nGet ready to bake some loosely coupled OO designs. There is more \nto making objects than just using the new operator. You\u2019ll learn that instantiation is an \nactivity that shouldn\u2019t always be done in public and can often lead to coupling problems.  \nAnd we don\u2019t want that, do we? Find out how Factory Patterns can help save you from \nembarrassing dependencies.\nBaking with OO Goodness\n", "page": 147, "type": "text", "section": "Page 147"}
{"text": "110\u2003 \u2003 Chapter 4\nthinking about new\nYes, when you use the new operator you are certainly instantiating \na concrete class, so that\u2019s definitely an implementation and not an \ninterface. And you make a good observation: that tying your code to \na concrete class can make it more fragile and less flexible.\nDuck duck; \nif (picnic) {\n    duck = new MallardDuck();\n} else if (hunting) {\n    duck = new DecoyDuck();\n} else if (inBathTub) {\n    duck = new RubberDuck();\n}\nHere we\u2019ve got several concrete classes being instantiated, and the \ndecision of which to instantiate is made at runtime depending on \nsome set of conditions.\nWhen you see code like this, you know that when it comes time for \nchanges or extensions, you\u2019ll have to reopen this code and examine \nwhat needs to be added (or deleted). Often this kind of code ends \nup in several parts of the application, making maintenance and \nupdates more difficult and error-prone.\nDuck duck = new MallardDuck();\nWe want to use abstact types \nto keep code flexible.\nBut we have to create an \ninstance of a concrete class!\nWhen we have a whole set of related concrete classes, often we end up \nwriting code like this:\nWe have a bunch of different \nduck classes, and we don\u2019t \nknow until runtime which one \nwe need to instantiate.\nWhen you see \u201cnew,\u201d think \u201cconcrete.\u201d\nOkay, it\u2019s been three chapters and you \nstill haven\u2019t answered my question about \nnew. We aren\u2019t supposed to program to an \nimplementation, but every time I use new, \nthat\u2019s exactly what I\u2019m doing, right?\n", "page": 148, "type": "text", "section": "Page 148"}
{"text": "you are here 4\u2003 \u2003 111\nthe factory pattern\nTechnically there\u2019s nothing wrong with the new operator. \nAfter all, it\u2019s a fundamental part of most modern object-\noriented languages. The real culprit is our old friend \nCHANGE and how change impacts our use of new.  \nBy coding to an interface, you know you can insulate yourself \nfrom many of the changes that might happen to a system \ndown the road. Why? If your code is written to an interface, \nthen it will work with any new classes implementing that \ninterface through polymorphism. However, when you have \ncode that makes use of lots of concrete classes, you\u2019re looking \nfor trouble because that code may have to be changed as new \nconcrete classes are added. So, in other words, your code will \nnot be \u201cclosed for modification.\u201d To extend your code with \nnew concrete types, you\u2019ll have to reopen it.\nSo what can you do? It\u2019s times like these that you can fall back \non OO design principles to look for clues. Remember, our first \nprinciple deals with change and guides us to identify the aspects \nthat vary and separate them from what stays the same.\nRemember that designs \nshould be \u201copen for \nextension but closed \nfor modification.\u201d See \nChapter 3 for a review.\nWhat\u2019s wrong with \u201cnew\u201d?\nBut you have to create an \nobject at some point, and Java \nonly gives us one way to create an \nobject, right? So what gives?\nHow might you take all the parts of your application that instantiate \nconcrete classes and separate or encapsulate them from the rest of \nyour application?\n", "page": 149, "type": "text", "section": "Page 149"}
{"text": "112\u2003 \u2003 Chapter 4\nidentify what varies\nIdentifying the aspects that vary\nLet\u2019s say you have a pizza shop, and as a cutting-edge pizza store owner in \nObjectville you might end up writing some code like this:\nPizza orderPizza() {\n\t\nPizza pizza = new Pizza();\n\t\npizza.prepare();\n\t\npizza.bake();\t\n\t\npizza.cut();\n\t\npizza.box();\n\t\nreturn pizza;\n}\nFor flexibility, we really want this \nto be an abstract class or interface, \nbut unfortunately we can\u2019t directly \ninstantiate either of those.\nSo then you\u2019d add some code that determines the appropriate type of pizza and \nthen goes about making the pizza:\nWe\u2019re now passing in \nthe type of pizza to \norderPizza.\nBased on the type of pizza, we \ninstantiate the correct concrete class \nand assign it to the pizza instance \nvariable. Note that each pizza here has \nto implement the Pizza interface.\nOnce we have a Pizza, we prepare it \n(you know, roll the dough, put on the \nsauce, and add the toppings), then we \nbake it, cut it, and box it!\nEach Pizza subtype (CheesePizza, \nGreekPizza, etc.) knows how to prepare \nitself.\nPizza orderPizza(String type) {\n\t\nPizza pizza;\n       if (type.equals(\"cheese\")) {\n           pizza = new CheesePizza();\n       } else if (type.equals(\"greek\") {\n           pizza = new GreekPizza();\n\t\n} else if (type.equals(\"pepperoni\") {\n           pizza = new PepperoniPizza();\n       } \n\t\npizza.prepare();\n\t\npizza.bake();\t\n\t\npizza.cut();\n\t\npizza.box();\n\t\nreturn pizza;\n}\nBut you need more than one type of pizza...\n", "page": 150, "type": "text", "section": "Page 150"}
{"text": "you are here 4\u2003 \u2003 113\nthe factory pattern\nPizza orderPizza(String type) {\n\t\nPizza pizza;\n       if (type.equals(\"cheese\")) {\n           pizza = new CheesePizza();\n       } else if (type.equals(\"greek\") {\n           pizza = new GreekPizza();\n\t\n} else if (type.equals(\"pepperoni\") {\n           pizza = new PepperoniPizza();\n\t\n} else if (type.equals(\"clam\") {\n           pizza = new ClamPizza();\n\t\n} else if (type.equals(\"veggie\") {\n           pizza = new VeggiePizza();\n       } \n\t\npizza.prepare();\n\t\npizza.bake();\t\n\t\npizza.cut();\n\t\npizza.box();\n\t\nreturn pizza;\n}\nYou realize that all of your competitors have added a couple of trendy pizzas to their \nmenus: the Clam Pizza and the Veggie Pizza. Obviously you need to keep up with the \ncompetition, so you\u2019ll add these items to your menu. And you haven\u2019t been selling many \nGreek pizzas lately, so you decide to take that off the menu:\nThis is what varies.  \nAs the pizza \nselection changes \nover time, you\u2019ll have \nto modify this code \nover and over.\nThis is what we expect to \nstay the same. For the most \npart, preparing, cooking, and \npackaging a pizza has remained \nthe same for years and years.  \nSo, we don\u2019t expect this code \nto change, just the pizzas it \noperates on.\nThis code is \nNOT closed for \nmodification. If the \nPizza Store changes \nits pizza offerings, we \nhave to open this code \nand modify it.  \nClearly, dealing with which concrete class is instantiated is really messing up our \norderPizza() method and preventing it from being closed for modification. But now that we \nknow what is varying and what isn\u2019t, it\u2019s probably time to encapsulate it.\nBut the pressure is on to add more pizza types\n", "page": 151, "type": "text", "section": "Page 151"}
{"text": "114\u2003 \u2003 Chapter 4\nencapsulate object creation\n       if (type.equals(\"cheese\")) {\n           pizza = new CheesePizza();\n\t\n} else if (type.equals(\"pepperoni\") {\n           pizza = new PepperoniPizza();\n\t\n} else if (type.equals(\"clam\") {\n           pizza = new ClamPizza();\n\t\n} else if (type.equals(\"veggie\") {\n           pizza = new VeggiePizza();\n       } \nSo now we know we\u2019d be better off moving the object \ncreation out of the orderPizza() method. But how? Well, what \nwe\u2019re going to do is take the creation code and move it out \ninto another object that is only going to be concerned with \ncreating pizzas.\nPizza orderPizza(String type) {\n\t\nPizza pizza;\n\t\npizza.prepare();\n\t\npizza.bake();\t\n\t\npizza.cut();\n\t\npizza.box();\n\t\nreturn pizza;\n}\nFirst we pull the object \ncreation code out of the \norderPizza() method.\nThen we place that code in an object that \nis only going to worry about how to create \npizzas. If any other object needs a pizza \ncreated, this is the object to come to.\nWe\u2019ve got a name for this new object: we \ncall it a Factory.\nFactories handle the details of object creation. Once we have \na SimplePizzaFactory, our orderPizza() method becomes a \nclient of that object. Anytime it needs a pizza, it asks the pizza \nfactory to make one. Gone are the days when the orderPizza() \nmethod needs to know about Greek versus Clam pizzas. Now \nthe orderPizza() method just cares that it gets a pizza that \nimplements the Pizza interface so that it can call prepare(), \nbake(), cut(), and box().\nWe\u2019ve still got a few details to fill in here; for instance, what does \nthe orderPizza() method replace its creation code with? Let\u2019s \nimplement a simple factory for the pizza store and find out...\nWhat\u2019s going to go here?\nS\ni\nm\np\nl\ne\nP\ni\nz\nza\nF\na\nc\nt\no\nr\ny\nEncapsulating object creation\n", "page": 152, "type": "text", "section": "Page 152"}
{"text": "you are here 4\u2003 \u2003 115\nthe factory pattern\npublic class SimplePizzaFactory {\n    public Pizza createPizza(String type) {\n        Pizza pizza = null;\n        if (type.equals(\"cheese\")) {\n            pizza = new CheesePizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new PepperoniPizza();\n        } else if (type.equals(\"clam\")) {\n            pizza = new ClamPizza();\n        } else if (type.equals(\"veggie\")) {\n            pizza = new VeggiePizza();\n        }\n        return pizza;\n    }\n}\nBuilding a simple pizza factory\nWe\u2019ll start with the factory itself. What we\u2019re going to do is define a class that \nencapsulates the object creation for all pizzas. Here it is...\nHere\u2019s the code we \nplucked out of the \norderPizza() method.\nFirst we define a \ncreatePizza() method in \nthe factory. This is the \nmethod all clients will use \nto instantiate new objects.\nHere\u2019s our new class, the SimplePizzaFactory. It \nhas one job in life: creating pizzas for its clients.\nThis code is still parameterized by the type of the \npizza, just like our original orderPizza() method was.\nQ: What\u2019s the advantage of this? It looks like we\u2019re just \npushing the problem off to another object.\nA: One thing to remember is that the SimplePizzaFactory may \nhave many clients. We\u2019ve only seen the orderPizza() method; \nhowever, there may be a PizzaShopMenu class that uses the factory \nto get pizzas for their current description and price. We might also \nhave a HomeDelivery class that handles pizzas in a different way \nthan our PizzaShop class but is also a client of the factory.\n\nSo, by encapsulating the pizza creating in one class, we now have \nonly one place to make modifications when the implementation \nchanges.\n\nAnd, don\u2019t forget, we\u2019re also just about to remove the concrete \ninstantiations from our client code.\nQ: I\u2019ve seen a similar design where a factory like this is \ndefined as a static method. What\u2019s the difference?\nA: Defining a simple factory as a static method is a common \ntechnique and is often called a static factory. Why use a static \nmethod? Because you don\u2019t need to instantiate an object to make \nuse of the create method. But it also has the disadvantage that you \ncan\u2019t subclass and change the behavior of the create method.\n", "page": 153, "type": "text", "section": "Page 153"}
{"text": "116\u2003 \u2003 Chapter 4\nsimple factory\npublic class PizzaStore {\n    SimplePizzaFactory factory;\n \n    public PizzaStore(SimplePizzaFactory factory) { \n        this.factory = factory;\n    }\n \n    public Pizza orderPizza(String type) {\n        Pizza pizza;\n \n        pizza = factory.createPizza(type);\n \n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n        return pizza;\n    }\n    // other methods here\n}\nReworking the PizzaStore class \nPizzaStore gets the factory passed \nto it in the constructor.\nAnd the orderPizza() method uses the \nfactory to create its pizzas by simply \npassing on the type of the order.\nNotice that we\u2019ve replaced the new \noperator with a createPizza method \nin the factory object. No more \nconcrete instantiations here!\nNow it\u2019s time to fix up our client code. What we want to do is rely on the \nfactory to create the pizzas for us. Here are the changes:\nFirst we give PizzaStore a \nreference to a SimplePizzaFactory.\nWe don\u2019t know about you, but we\u2019re thinking New York, Chicago, and California style pizza factories (let\u2019s \nnot forget New Haven, too).\nWe know that object composition allows us to change behavior dynamically at runtime (among \nother things) because we can swap in and out implementations. How might we be able to use \nthat in the PizzaStore? What factory implementations might we be able to swap in and out?\n", "page": 154, "type": "text", "section": "Page 154"}
{"text": "you are here 4\u2003 \u2003 117\nthe factory pattern\nThe Simple Factory defined\nThe Simple Factory isn\u2019t actually a Design Pattern; it\u2019s more of a programming idiom.  \nBut it is commonly used, so we\u2019ll give it a Head First Pattern Honorable Mention. \nSome developers do mistake this idiom for the Factory Pattern, but the next time that \nhappens you can subtly show you know your stuff; just don\u2019t strut as you educate them \non the distinction.\nJust because Simple Factory isn\u2019t a REAL pattern doesn\u2019t mean we shouldn\u2019t check out \nhow it\u2019s put together. Let\u2019s take a look at the class diagram of our new Pizza Store:\nThink of Simple Factory as a warm-up. Next, we\u2019ll explore two heavy-duty patterns \nthat are both factories. But don\u2019t worry, there\u2019s more pizza to come!\nThis is the factory where we create \npizzas; it should be the only part \nof our application that refers to \nconcrete Pizza classes.\nThis is the client of the \nfactory. PizzaStore \nnow goes through the \nSimplePizzaFactory to get \ninstances of pizza.\nSimplePizzaFactory\ncreatePizza()\nPizza\nPizzaStore\norderPizza()\nClamPizza\nVeggiePizza\nCheesePizza\nPepperoniPizza\nprepare()\nbake()\ncut()\nbox()\nThese are our concrete products. Each \nproduct needs to implement the Pizza \ninterface* (which in this case means \n\u201cextend the abstract Pizza class\u201d) and \nbe concrete. As long as that\u2019s the case, \nit can be created by the factory and \nhanded back to the client. \nThis is the product of \nthe factory: pizza!\nWe\u2019ve defined Pizza \nas an abstract class \nwith some helpful \nimplementations that \ncan be overridden.\nThe create method is \noften declared statically.\n*Just another reminder: in design patterns, the phrase \u201cimplement an interface\u201d does NOT always mean \n\u201cwrite a class that implements a Java interface, by using the \u2018implements' keyword in the class declaration.\u201d \nIn the general use of the phrase, a concrete class implementing a method from a supertype (which could be a \nabstract class OR interface) is still considered to be \u201cimplementing the interface\u201d of that supertype.\nHead First\nHonorable \nMention\nPattern \n \n \n \n \n \n \n \n \n \n \n \n \nHonorable \nMention\n", "page": 155, "type": "text", "section": "Page 155"}
{"text": "118\u2003 \u2003 Chapter 4\npizza franchise\nFranchising the pizza store\nYour Objectville Pizza Store has done so well that you\u2019ve trounced \nthe competition and now everyone wants a Pizza Store in their \nown neighborhood. As the franchiser, you want to ensure the \nquality of the franchise operations and so you want them to use \nyour time-tested code.   \nBut what about regional differences? Each franchise might want to \noffer different styles of pizzas (New York, Chicago, and California, \nto name a few), depending on where the franchise store is located \nand the tastes of the local pizza connoisseurs.  \n \n  \n \n \n \nP\ni\nz\nz\na\nSto\nr\ne\nYou want all the franchise pizza stores \nto leverage your PizzaStore code, so the \npizzas are prepared in the same way.\nOne franchise wants a \nfactory that makes NY-style \npizzas: thin crust, tasty sauce, \nand just a little cheese.\nAnother franchise \nwants a factory that \nmakes Chicago-style \npizzas; their customers \nlike pizzas with thick \ncrust, rich sauce, and \ntons of cheese.\nWe\u2019ve seen one approach...\nIf we take out SimplePizzaFactory and create three different \nfactories\u2014NYPizzaFactory, ChicagoPizzaFactory, and \nCaliforniaPizzaFactory\u2014then we can just compose the PizzaStore \nwith the appropriate factory and a franchise is good to go. That\u2019s \none approach.\nLet\u2019s see what that would look like...\n \n \nN\nY\nP\ni\nz\nz\na\nFa\nc\nt\no\nr\ny\nC\nh\ni\nc\na\ng\no\nP\ni\nzza\nF\na\nc\nt\nory\nYes, different areas of the US serve \nvery different styles of pizza\u2014from \nthe deep-dish pizzas of Chicago, to the \nthin crust of New York, to the cracker-\nlike pizza of California (some would say \ntopped with fruits and nuts). \n", "page": 156, "type": "text", "section": "Page 156"}
{"text": "you are here 4\u2003 \u2003 119\nthe factory pattern\nNYPizzaFactory nyFactory = new NYPizzaFactory();\nPizzaStore nyStore = new PizzaStore(nyFactory);\nnyStore.orderPizza(\"Veggie\");\nChicagoPizzaFactory chicagoFactory = new ChicagoPizzaFactory();\nPizzaStore chicagoStore = new PizzaStore(chicagoFactory);\nchicagoStore.orderPizza(\"Veggie\");\nHere we create a factory for \nmaking NY-style pizzas.\nThen we create a PizzaStore and pass \nit a reference to the NY factory.\n...and when we make pizzas, we \nget NY-style pizzas.\nLikewise for the Chicago pizza stores: we \ncreate a factory for Chicago pizzas and \ncreate a store that is composed with a \nChicago factory. When we make pizzas, we \nget the Chicago-style ones.\nBut you\u2019d like a little more quality control...\nSo you test-marketed the SimpleFactory idea, and what you \nfound was that the franchises were using your factory to \ncreate pizzas, but starting to employ their own home-grown \nprocedures for the rest of the process: they\u2019d bake things \na little differently, they\u2019d forget to cut the pizza, and they\u2019d \nuse third-party boxes.  \nRethinking the problem a bit, you see that what you\u2019d really \nlike to do is create a framework that ties the store and the \npizza creation together, yet still allows things to remain \nflexible.  \nIn our early code, before the SimplePizzaFactory, we had \nthe pizza-making code tied to the PizzaStore, but it wasn\u2019t \nflexible. So, how can we have our pizza and eat it too?\nNot what you want in a good \nfranchise. You do NOT want to \nknow what he puts on his pizzas.\nI\u2019ve been making pizza \nfor years so I thought I\u2019d add \nmy own \u201cimprovements\u201d to the \nPizzaStore procedures...\n", "page": 157, "type": "text", "section": "Page 157"}
{"text": "120\u2003 \u2003 Chapter 4\nlet the subclasses decide\nThere is a way to localize all the pizza-making activities to the PizzaStore \nclass, and to give the franchises freedom to have their own regional style.\nWhat we\u2019re going to do is put the createPizza() method back into PizzaStore, \nbut this time as an abstract method, and then create a PizzaStore subclass \nfor each regional style.\nFirst, let\u2019s look at the changes to the PizzaStore:  \nA framework for the pizza store\npublic abstract class PizzaStore {\n\t\npublic Pizza orderPizza(String type) {\n\t\n\t\nPizza pizza;\n\t\n\t\npizza = createPizza(type);\n\t\n\t\npizza.prepare();\n\t\n\t\npizza.bake();\t\n\t\n\t\npizza.cut();\n\t\n\t\npizza.box();\n\t\n\t\nreturn pizza;\n\t\n}\n\n\t\nabstract Pizza createPizza(String type);\n}\nNow createPizza is back to being a \ncall to a method in the PizzaStore \nrather than on a factory object.\nAll this looks just the same...\nNow we\u2019ve moved our factory \nobject to this method.\nOur \u201cfactory method\u201d is now \nabstract in PizzaStore.\nPizzaStore is now abstract (see why below).\nNow we\u2019ve got a store waiting for subclasses; we\u2019re going to have a \nsubclass for each regional type (NYPizzaStore, ChicagoPizzaStore, \nCaliforniaPizzaStore) and each subclass is going to make the decision about \nwhat makes up a pizza. Let\u2019s take a look at how this is going to work.\n", "page": 158, "type": "text", "section": "Page 158"}
{"text": "you are here 4\u2003 \u2003 121\nthe factory pattern\npublic Pizza createPizza(type) {\n    if (type.equals(\"cheese\")) {\n        pizza = new NYStyleCheesePizza();\n    } else if (type.equals(\"pepperoni\") {\n        pizza = new NYStylePepperoniPizza();\n    } else if (type.equals(\"clam\") {\n        pizza = new NYStyleClamPizza();\n    } else if (type.equals(\"veggie\") {\n        pizza = new NYStyleVeggiePizza();\n    }\n}\ncreatePizza()\nChicagoStylePizzaStore\ncreatePizza()\nNYStylePizzaStore\npublic Pizza createPizza(type) {\n    if (type.equals(\"cheese\")) {\n        pizza = new ChicagoStyleCheesePizza();\n    } else if (type.equals(\"pepperoni\") {\n        pizza = new ChicagoStylePepperoniPizza();\n    } else if (type.equals(\"clam\") {\n        pizza = new ChicagoStyleClamPizza();\n    } else if (type.equals(\"veggie\") {\n        pizza = new ChicagoStyleVeggiePizza();\n    }\n}\nSimilarly, by using the \nChicago subclass, we get an \nimplementation of createPizza() \nwith Chicago ingredients.\nIf a franchise wants NY-style \npizzas for its customers, it \nuses the NY subclass, which has \nits own createPizza() method, \ncreating NY-style pizzas.\nEach subclass provides an implementation \nof the createPizza() method, overriding \n \nthe abstract createPizza() method in \nPizza Store, while all subclasses make use \nof the orderPizza() method defined \nin Pizza Store. We could make the \norderPizza() method final if we really \nwanted to enforce this.\ncreatePizza()\norderPizza()\nPizzaStore\nAllowing the subclasses to decide\nRemember, the Pizza Store already has a well-honed order system in the orderPizza() \nmethod and you want to ensure that it\u2019s consistent across all franchises.\nWhat varies among the regional Pizza Stores is the style of pizzas they make\u2014New York \npizza has thin crust, Chicago pizza has thick, and so on\u2014and we are going to push all \nthese variations into the createPizza() method and make it responsible for creating the \nright kind of pizza. The way we do this is by letting each subclass of Pizza Store define \nwhat the createPizza() method looks like. So, we\u2019ll have a number of concrete subclasses \nof Pizza Store, each with its own pizza variations, all fitting within the Pizza Store \nframework and still making use of the well-tuned orderPizza() method.\nRemember: createPizza() is \nabstract in Pizza Store, so \nall pizza store subtypes MUST \nimplement the method.\n", "page": 159, "type": "text", "section": "Page 159"}
{"text": "122\u2003 \u2003 Chapter 4\nhow do subclasses decide?\nWell, think about it from the point of view of the PizzaStore\u2019s orderPizza() method: it is \ndefined in the abstract PizzaStore, but concrete types are only created in the subclasses.\ncreatePizza()\norderPizza()\nPizzaStore\ncreatePizza()\nChicagoStylePizzaStore\ncreatePizza()\norderPizza()\npizza = createPizza();\npizza.prepare();\npizza.bake();\npizza.cut();\npizza.box();\nPizzaStore\ncreatePizza()\nNYStylePizzaStore\norderPizza() is defined in the abstract \nPizzaStore, not the subclasses. So, the \nmethod has no idea which subclass is actually \nrunning the code and making the pizzas.\nNow, to take this a little further, the orderPizza() method does a lot of things with a \nPizza object (like prepare, bake, cut, box), but because Pizza is abstract, orderPizza() has \nno idea what real concrete classes are involved. In other words, it\u2019s decoupled!\nWhen orderPizza() calls createPizza(), one of your subclasses will be called into action to \ncreate a pizza. Which kind of pizza will be made? Well, that\u2019s decided by the choice of \npizza store you order from, NYStylePizzaStore or ChicagoStylePizzaStore.\nSo, is there a real-time decision that subclasses make? No, but from the perspective of \norderPizza(), if you chose a NYStylePizzaStore, that subclass gets to determine which \npizza is made. So the subclasses aren\u2019t really \u201cdeciding\u201d\u2014it was you who decided by \nchoosing which store you wanted\u2014but they do determine which kind of pizza gets made.\norderPizza() calls createPizza() to actually get a \npizza object. But which kind of pizza will it get? \nThe orderPizza() method can\u2019t decide; it doesn\u2019t \nknow how. So who does decide?\nI don\u2019t get it. The PizzaStore \nsubclasses are just subclasses. How \nare they deciding anything? I don\u2019t \nsee any logical decision-making code in \nNYStylePizzaStore....\n", "page": 160, "type": "text", "section": "Page 160"}
{"text": "you are here 4\u2003 \u2003 123\nthe factory pattern\npublic class NYPizzaStore extends PizzaStore {\n    Pizza createPizza(String item) {\n        if (item.equals(\"cheese\")) {\n            return new NYStyleCheesePizza();\n        } else if (item.equals(\"veggie\")) {\n            return new NYStyleVeggiePizza();\n        } else if (item.equals(\"clam\")) {\n            return new NYStyleClamPizza();\n        } else if (item.equals(\"pepperoni\")) {\n            return new NYStylePepperoniPizza();\n        } else return null;\n    }\n}\nLet\u2019s make a Pizza Store\nThe NYPizzaStore extends \nPizzaStore, so it inherits the \norderPizza() method (among others).\nWe\u2019ve got to implement \ncreatePizza(), since it is \nabstract in PizzaStore.\nBeing a franchise has its benefits. You get all the PizzaStore \nfunctionality for free. All the regional stores need to do is subclass \nPizzaStore and supply a createPizza() method that implements \ntheir style of pizza. We\u2019ll take care of the big three pizza styles for \nthe franchisees.\nHere\u2019s the New York regional style:\nOnce we\u2019ve got our PizzaStore subclasses built, it will be time \nto see about ordering up a pizza or two. But before we do that, \nwhy don\u2019t you take a crack at building the Chicago-style and \nCalifornia-style pizza stores on the next page?\nHere\u2019s where we create our \nconcrete classes. For each type of \nPizza we create the NY style.  \n* Note that the orderPizza() method in the \nsuperclass has no clue which Pizza we are creating; \nit just knows it can prepare, bake, cut, and box it!\ncreatePizza() returns a Pizza, and \nthe subclass is fully responsible for \nwhich concrete Pizza it instantiates.\n", "page": 161, "type": "text", "section": "Page 161"}
{"text": "124\u2003 \u2003 Chapter 4\nfactory method\nWe\u2019ve knocked out the NYPizzaStore; just two more to go and we\u2019ll be ready to franchise! Write \nthe Chicago-style and California-style PizzaStore implementations here:\n", "page": 162, "type": "text", "section": "Page 162"}
{"text": "you are here 4\u2003 \u2003 125\nthe factory pattern\nWith just a couple of transformations to the PizzaStore class, we\u2019ve gone from \nhaving an object handle the instantiation of our concrete classes to a set of \nsubclasses that are now taking on that responsibility. Let\u2019s take a closer look: \nThe subclasses of \nPizzaStore handle object \ninstantiation for us in the \ncreatePizza() method.\ncreatePizza()\nNYStylePizzaStore\ncreatePizza()\nChicagoStylePizzaStore\nDeclaring a factory method\npublic abstract class PizzaStore {\n    public Pizza orderPizza(String type) {\n        Pizza pizza;\n        pizza = createPizza(type);\n        pizza.prepare();\n        pizza.bake();\t\n        pizza.cut();\n        pizza.box();\n        return pizza;\n    }\n    protected abstract Pizza createPizza(String type);\n\n    // other methods here\n}\nAll the responsibility for \ninstantiating Pizzas has \nbeen moved into a method \nthat acts as a factory.\nCode Up Close\nA factory method handles object creation and encapsulates it in a \nsubclass. This decouples the client code in the superclass from the \nobject creation code in the subclass.\nabstract Product factoryMethod(String type)\nA factory method \nis abstract so the \nsubclasses are counted \non to handle object \ncreation.\nA factory method may \nbe parameterized (or \nnot) to select among \nseveral variations of a \nproduct.\nA factory method isolates the client (the \ncode in the superclass, like orderPizza()) \nfrom knowing what kind of concrete \nProduct is actually created.\nA factory method returns \na Product that is typically \nused within methods \ndefined in the superclass.\n", "page": 163, "type": "text", "section": "Page 163"}
{"text": "126\u2003 \u2003 Chapter 4\nordering a pizza\nI like NY-style pizza...you \nknow, thin, crispy crust with \na little cheese and really \ngood sauce.\nI like Chicago-style deep dish \npizza with thick crust and \ntons of cheese.\nEthan needs to order \nhis pizza from a NY \npizza store.\nJoel needs to order his \npizza from a Chicago  \npizza store. Same pizza \nordering method, but \ndifferent kind of pizza!\nJoel\nEthan\nLet\u2019s see how it works: ordering pizzas with \nthe pizza factory method\n1\n2\nFirst, Joel and Ethan need an instance of a PizzaStore. Joel needs to instantiate a \nChicagoPizzaStore and Ethan needs a NYPizzaStore.\nWith a PizzaStore in hand, both Ethan and Joel call the orderPizza() method and pass \nin the type of pizza they want (cheese, veggie, and so on).  \n4\nThe orderPizza() method has no idea what kind of pizza was created, but it knows it is \na pizza and it prepares, bakes, cuts, and boxes it for Ethan and Joel.\n3\nTo create the pizzas, the createPizza() method is called, which is defined in the \ntwo subclasses NYPizzaStore and ChicagoPizzaStore. As we defined them, the \nNYPizzaStore instantiates a NY-style pizza, and the ChicagoPizzaStore instantiates a \nChicago-style pizza. In either case, the Pizza is returned to the orderPizza() method.\nSo how do they order?\n", "page": 164, "type": "text", "section": "Page 164"}
{"text": "you are here 4\u2003 \u2003 127\nthe factory pattern\nLet\u2019s check out how these pizzas are \nreally made to order...\nBehind \nthe Scenes\n1\n2\nPizzaStore nyPizzaStore = new NYPizzaStore();\nLet\u2019s follow Ethan\u2019s order: first we need a NYPizzaStore:\nnyPizzaStore.orderPizza(\"cheese\");\nNow that we have a store, we can take an order:\n3\nThe orderPizza() method then calls the createPizza() \nmethod:\n4\nFinally, we have the unprepared pizza in hand and the \norderPizza() method finishes preparing it:\nPizza pizza  = createPizza(\"cheese\");\n \n  \n \n \nn\ny\nP\ni\nz\nz\naS\nt\no\nr\ne\nCreates a instance of \nNYPizzaStore.\nThe orderPizza() method is called on \nthe nyPizzaStore instance (the method \ndefined inside PizzaStore runs).\n \n  \n \n \n  \n \n  \n \nP\ni\nzza\ncreatePizza(\"cheese\")\nRemember, createPizza(), the factory \nmethod, is implemented in the subclass. In this \ncase it returns a NY-style cheese Pizza.\npizza.prepare();\npizza.bake();\npizza.cut();\npizza.box();\nAll of these methods are \ndefined in the specific pizza \nreturned from the factory \nmethod createPizza(), defined \nin the NYPizzaStore.\nThe orderPizza() method gets \nback a Pizza, without knowing \nexactly what concrete class it is.\n", "page": 165, "type": "text", "section": "Page 165"}
{"text": "128\u2003 \u2003 Chapter 4\nthe pizza classes\npublic abstract class Pizza {\n    String name;\n    String dough;\n    String sauce;\n    List<String> toppings = new ArrayList<String>();\n \n    void prepare() {\n        System.out.println(\"Preparing \" + name);\n        System.out.println(\"Tossing dough...\");\n        System.out.println(\"Adding sauce...\");\n        System.out.println(\"Adding toppings: \");\n        for (String topping : toppings) {\n            System.out.println(\"   \" + topping);\n        }\n    }\n  \n    void bake() {\n        System.out.println(\"Bake for 25 minutes at 350\");\n    }\n \n    void cut() {\n        System.out.println(\"Cutting the pizza into diagonal slices\");\n    }\n  \n    void box() {\n        System.out.println(\"Place pizza in official PizzaStore box\");\n    }\n \n    public String getName() {\n        return name;\n    }\n}\nWe\u2019re just missing one thing: Pizzas!\nOur Pizza Store isn\u2019t going to be very popular \nwithout some pizzas, so let\u2019s implement them\nWe\u2019ll start with an abstract \nPizza class, and all the concrete \npizzas will derive from this.\nEach Pizza has a name, a type of dough, \na type of sauce, and a set of toppings.\nThe abstract class provides \nsome basic defaults for \nbaking, cutting, and boxing.\nPreparation follows a \nnumber of steps in a \nparticular sequence.\nREMEMBER: we don\u2019t provide import and package statements in the \ncode listings. Get the complete source code from the wickedlysmart \nwebsite at https://wickedlysmart.com/head-first-design-patterns\n\nIf you lose this URL, you can always quickly find it in the Intro section.\n", "page": 166, "type": "text", "section": "Page 166"}
{"text": "you are here 4\u2003 \u2003 129\nthe factory pattern\npublic class ChicagoStyleCheesePizza extends Pizza {\n    public ChicagoStyleCheesePizza() { \n        name = \"Chicago Style Deep Dish Cheese Pizza\";\n        dough = \"Extra Thick Crust Dough\";\n        sauce = \"Plum Tomato Sauce\";\n \n        toppings.add(\"Shredded Mozzarella Cheese\");\n    }\n \n    void cut() {\n        System.out.println(\"Cutting the pizza into square slices\");\n    }\n}\npublic class NYStyleCheesePizza extends Pizza {\n    public NYStyleCheesePizza() { \n        name = \"NY Style Sauce and Cheese Pizza\";\n        dough = \"Thin Crust Dough\";\n        sauce = \"Marinara Sauce\";\n \n        toppings.add(\"Grated Reggiano Cheese\");\n    }\n}\nNow we just need some concrete subclasses...how about defining \nNew York and Chicago-style cheese pizzas?\nThe NY Pizza has its own \nmarinara-style sauce and thin crust.\nAnd one topping, Reggiano cheese!\nThe Chicago-style deep \ndish pizza has lots of \nmozzarella cheese!\nThe Chicago-style pizza also overrides the cut() \nmethod so that the pieces are cut into squares.\nThe Chicago Pizza uses plum \ntomatoes as a sauce along \nwith extra-thick crust.\n", "page": 167, "type": "text", "section": "Page 167"}
{"text": "130\u2003 \u2003 Chapter 4\nmake some pizzas\npublic class PizzaTestDrive {\n \n    public static void main(String[] args) {\n        PizzaStore nyStore = new NYPizzaStore();\n        PizzaStore chicagoStore = new ChicagoPizzaStore();\n \n        Pizza pizza = nyStore.orderPizza(\"cheese\");\n        System.out.println(\"Ethan ordered a \" + pizza.getName() + \"\\n\");\n \n        pizza = chicagoStore.orderPizza(\"cheese\");\n        System.out.println(\"Joel ordered a \" + pizza.getName() + \"\\n\");\n    }\n}\nYou\u2019ve waited long enough. Time for some pizzas!\nFile  Edit   Window  Help  YouWantMootzOnThatPizza?\n%java PizzaTestDrive\nPreparing NY Style Sauce and Cheese Pizza\nTossing dough...\nAdding sauce...\nAdding toppings: \n   Grated Reggiano cheese\nBake for 25 minutes at 350\nCutting the pizza into diagonal slices\nPlace pizza in official PizzaStore box\nEthan ordered a NY Style Sauce and Cheese Pizza\nPreparing Chicago Style Deep Dish Cheese Pizza\nTossing dough...\nAdding sauce...\nAdding toppings: \n   Shredded Mozzarella Cheese\nBake for 25 minutes at 350\nCutting the pizza into square slices\nPlace pizza in official PizzaStore box\nJoel ordered a Chicago Style Deep Dish Cheese Pizza\nFirst we create two \ndifferent stores.\nWe use one store to \nmake Ethan\u2019s order...\n...and the other for Joel\u2019s.\nBoth pizzas get prepared, \nthe toppings get added, and \nthe pizzas are baked, cut, \nand boxed. Our superclass \nnever had to know the \ndetails; the subclass handled \nall that just by instantiating \nthe right pizza.\n", "page": 168, "type": "text", "section": "Page 168"}
{"text": "you are here 4\u2003 \u2003 131\nthe factory pattern\ncreatePizza()\nChicagoPizzaStore\ncreatePizza()\nNYPizzaStore\nPizza\nNYStyleCheesePizza\nNYStyleVeggiePizza\nNYStyleClamPizza\nNYStylePepperoniPizza\nChicagoStyleVeggiePizza\nChicagoStyleClamPizza\nChicagoStylePepperoniPizza\nChicagoStyleCheesePizza\ncreatePizza()\norderPizza()\nPizzaStore\nIt\u2019s finally time to meet the Factory Method Pattern\nAll factory patterns encapsulate object creation. The Factory Method Pattern encapsulates object \ncreation by letting subclasses decide what objects to create. Let\u2019s check out these class diagrams to see \nwho the players are in this pattern:\nOften the creator contains code \nthat depends on an abstract product, \nwhich is produced by a subclass. The \ncreator never really knows which \nconcrete product was produced.\nSince each franchise gets its \nown subclass of PizzaStore, \nit\u2019s free to create its own \nstyle of pizza by implementing \ncreatePizza().\nThe createPizza() method \nis our factory method. It \nproduces products.\nThis is our abstract \ncreator class. It defines \nan abstract factory \nmethod that the \nsubclasses implement to \nproduce products.\nThese are the concrete \nproducts\u2009\u2014\u2009all the pizzas that \nare produced by our stores.\nFactories produce products, \nand in the PizzaStore, our \nproduct is a Pizza.\nThe Creator classes\nThe Product classes\nClasses that produce \nproducts are called \nconcrete creators.\n", "page": 169, "type": "text", "section": "Page 169"}
{"text": "132\u2003 \u2003 Chapter 4\ncreators and products\nView Creators and Products in Parallel\nFor every concrete Creator, there\u2019s typically a whole set of products that \nit creates. Chicago pizza creators create different types of Chicago-style \npizza, New York pizza creators create different types of New York\u2013style \npizza, and so on. In fact, we can view our sets of Creator classes and their \ncorresponding Product classes as parallel hierarchies.\nLet\u2019s look at the two parallel class hierarchies and see how they relate:\nPizza\nThe NYPizzaStore \nencapsulates all the \nknowledge about how to \nmake NY-style pizzas.\nThe ChicagoPizzaStore \nencapsulates all the \nknowledge about how to \nmake Chicago-style pizzas.\nNotice how these \nclass hierarchies are \nparallel: both have \nabstract classes that \nare extended by \nconcrete classes, which \nknow about specific \nimplementations for \nNY and Chicago pizza.\nThe factory method is the key to encapsulating this knowledge.\ncreatePizza()\nChicagoPizzaStore\ncreatePizza()\nNYPizzaStore\ncreatePizza()\norderPizza()\nPizzaStore\nNYStyleClamPizza\nChicagoStyleVeggiePizza\nChicagoStyleClamPizza\nChicagoStylePepperoniPizza\nChicagoStyleCheesePizza\nNYStylePepperoniPizza\nNYStyleCheesePizza\nNYStyleVeggiePizza\nThe Creator classes\nThe Product classes\n", "page": 170, "type": "text", "section": "Page 170"}
{"text": "you are here 4\u2003 \u2003 133\nthe factory pattern\nWe need another kind of pizza for those crazy Californians (crazy in a good way, \nof course). Draw another parallel set of classes that you\u2019d need to add a new \nCalifornia region to our PizzaStore.\ncreatePizza()\norderPizza()\nPizzaStore\nOkay, now write the five most bizarre things you can think of to put on a pizza.  \nThen, you\u2019ll be ready to go into business making pizza in California!\nNYStyleCheesePizza\nNYStyleVeggiePizza\nNYStyleClamPizza\nNYStylePepperoniPizza\nChicagoStyleVeggiePizza\nChicagoStyleClamPizza\nChicagoStylePepperoniPizza\nChicagoStyleCheesePizza\ncreatePizza()\nChicagoPizzaStore\ncreatePizza()\nNYPizzaStore\nYour drawing here...\n Design Puzzle\n", "page": 171, "type": "text", "section": "Page 171"}
{"text": "134\u2003 \u2003 Chapter 4\nfactory method defined\nFactory Method Pattern defined\nThe Factory Method Pattern defines an interface \nfor creating an object, but lets subclasses decide which \nclass to instantiate. Factory Method lets a class defer \ninstantiation to subclasses.\nIt\u2019s time to roll out the official definition of the Factory Method Pattern:\nAs with every factory, the Factory Method Pattern gives us a way to encapsulate the \ninstantiations of concrete types. Looking at the class diagram below, you can see that the \nabstract Creator class gives you an interface with a method for creating objects, also known \nas the \u201cfactory method.\u201d Any other methods implemented in the abstract Creator are \nwritten to operate on products produced by the factory method. Only subclasses actually \nimplement the factory method and create products.\nAs in the official definition, you\u2019ll often hear developers say, \u201cthe Factory Method pattern \nlets subclasses decide which class to instantiate.\u201d Because the Creator class is written without \nknowledge of the actual products that will be created, we say \u201cdecide\u201d not because the \npattern allows subclasses themselves to decide, but rather, because the decision actually comes \ndown to which subclass is used to create the product.\nProduct\nConcreteProduct\nfactoryMethod()\nanOperation()\nCreator\nfactoryMethod()\nConcreteCreator\nCreator is a class that contains \nthe implementations for all of the \nmethods to manipulate products, \nexcept for the factory method.\nConcreteCreator \nimplements the \nfactoryMethod(), which is \nthe method that actually \nproduces products.\nAll products must implement \nthe same interface so that the \nclasses that use the products \ncan refer to the interface, \nnot the concrete class.\nConcreteCreator is responsible for creating \none or more concrete products. It is the \nonly class that has the knowledge of how \nto create these products.\nThe abstract factoryMethod() \nis what all Creator subclasses \nmust implement.\nYou could ask them what \n\u201cdecides\u201d means, but we \nbet you now understand \nthis better than they do!\n", "page": 172, "type": "text", "section": "Page 172"}
{"text": "you are here 4\u2003 \u2003 135\nthe factory pattern\nQ: What\u2019s the advantage of the Factory Method \nPattern when you only have one ConcreteCreator?\nA: The Factory Method Pattern is useful if you\u2019ve only \ngot one concrete creator because you are decoupling the \nimplementation of the product from its use. If you add \nadditional products or change a product\u2019s implementation, \nit will not affect your Creator (because the Creator is not \ntightly coupled to any ConcreteProduct).\nQ: Would it be correct to say that our NY and \nChicago stores are implemented using Simple \nFactory? They look just like it.\nA: They\u2019re similar, but used in different ways. Even \nthough the implementation of each concrete store looks \na lot like the SimplePizzaFactory, remember that the \nconcrete stores are extending a class that has defined \ncreatePizza() as an abstract method. It is up to each \nstore to define the behavior of the createPizza() method. \nIn Simple Factory, the factory is another object that is \ncomposed with the PizzaStore.\nQ: Are the factory method and the Creator class \nalways abstract?\nA: No, you can define a default factory method to \nproduce some concrete product. Then you always \nhave a means of creating products even if there are no \nsubclasses of the Creator class.\nQ: Each store can make four different kinds of \npizzas based on the type passed in. Do all concrete \ncreators make multiple products, or do they \nsometimes just make one?\n\n\nA: We implemented what is known as the \nparameterized factory method. It can make more than one \nobject based on a parameter passed in, as you noticed.  \nOften, however, a factory just produces one object and is \nnot parameterized. Both are valid forms of the pattern.\nQ: Your parameterized types don\u2019t seem \u201ctype-\nsafe.\u201d I\u2019m just passing in a String! What if I asked for a \n\u201cCalmPizza\u201d?\nA: You are certainly correct, and that would cause what \nwe call in the business a \u201cruntime error.\u201d There are several \nother more sophisticated techniques that can be used to \nmake parameters more \u201ctype safe\u201d\u2014in other words, to \nensure errors in parameters can be caught at compile time. \nFor instance, you can create objects that represent the \nparameter types, use static constants, or use enums.\nQ: I\u2019m still a bit confused about the difference \nbetween Simple Factory and Factory Method. They \nlook very similar, except that in Factory Method, the \nclass that returns the pizza is a subclass. Can you \nexplain?\nA: You\u2019re right that the subclasses do look a lot like \nSimple Factory; however, think of Simple Factory as a \none-shot deal, while with Factory Method you are creating \na framework that lets the subclasses decide which \nimplementation will be used. For example, the orderPizza() \nmethod in the Factory Method Pattern provides a general \nframework for creating pizzas that relies on a factory \nmethod to actually create the concrete classes that go \ninto making a pizza. By subclassing the PizzaStore class, \nyou decide what concrete products go into making the \npizza that orderPizza() returns. Compare that with Simple \nFactory, which gives you a way to encapsulate object \ncreation, but doesn\u2019t give you the flexibility of Factory \nMethod because there is no way to vary the products \nyou\u2019re creating. \n", "page": 173, "type": "text", "section": "Page 173"}
{"text": "136\u2003 \u2003 Chapter 4\nmaster and student\nGuru and Student...\nGuru: Tell me about your training.\nStudent: Guru, I have taken my study of \u201cencapsulate what \nvaries\u201d further.\nGuru: Go on...\nStudent: I have learned that one can encapsulate the code \nthat creates objects. When you have code that instantiates \nconcrete classes, this is an area of frequent change. I\u2019ve learned \na technique called \u201cfactories\u201d that allows you to encapsulate this \nbehavior of instantiation.\nGuru: And these \u201cfactories,\u201d of what benefit are they?\nStudent: There are many. By placing all my creation code in one \nobject or method, I avoid duplication in my code and provide one \nplace to perform maintenance. That also means clients depend \nonly upon interfaces rather than the concrete classes required to \ninstantiate objects. As I have learned in my studies, this allows me \nto program to an interface, not an implementation, and that makes \nmy code more flexible and extensible in the future.\nGuru: Yes, your OO instincts are growing. Do you have any \nquestions for your guru today?\nStudent: Guru, I know that by encapsulating object creation I am \ncoding to abstractions and decoupling my client code from actual \nimplementations. But my factory code must still use concrete \nclasses to instantiate real objects. Am I not pulling the wool over \nmy own eyes?\nGuru: Object creation is a reality of life; we must create objects or \nwe will never create a single Java application. But, with knowledge \nof this reality, we can design our code so that we have corralled \nthis creation code like the sheep whose wool you would pull \nover your eyes. Once corralled, we can protect and care for the \ncreation code. If we let our creation code run wild, then we will \nnever collect its \u201cwool.\u201d\nStudent: Guru, I see the truth in this.\nGuru:  As I knew you would. Now, please go and meditate on \nobject dependencies.\n", "page": 174, "type": "text", "section": "Page 174"}
{"text": "you are here 4\u2003 \u2003 137\nthe factory pattern\npublic class DependentPizzaStore {\n \n    public Pizza createPizza(String style, String type) {\n        Pizza pizza = null;\n        if (style.equals(\"NY\")) {\n            if (type.equals(\"cheese\")) {\n                pizza = new NYStyleCheesePizza();\n            } else if (type.equals(\"veggie\")) {\n                pizza = new NYStyleVeggiePizza();\n            } else if (type.equals(\"clam\")) {\n                pizza = new NYStyleClamPizza();\n            } else if (type.equals(\"pepperoni\")) {\n                pizza = new NYStylePepperoniPizza();\n            }\n        } else if (style.equals(\"Chicago\")) {\n            if (type.equals(\"cheese\")) {\n                pizza = new ChicagoStyleCheesePizza();\n            } else if (type.equals(\"veggie\")) {\n                pizza = new ChicagoStyleVeggiePizza();\n            } else if (type.equals(\"clam\")) {\n                pizza = new ChicagoStyleClamPizza();\n            } else if (type.equals(\"pepperoni\")) {\n                pizza = new ChicagoStylePepperoniPizza();\n            }\n        } else {\n            System.out.println(\"Error: invalid type of pizza\");\n            return null;\n        }\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n        return pizza;\n    }\n}\nLet\u2019s pretend you\u2019ve never heard of an OO factory. Here\u2019s a \u201cvery dependent\u201d \nversion of PizzaStore that doesn\u2019t use a factory. We need you to make a count \nof the number of concrete pizza classes this class is dependent on. If you \nadded California-style pizzas to this PizzaStore, how many classes would it be \ndependent on then?\nYou can write your \nanswers here:\nnumber\nnumber with \nCalifornia, too\nHandles all the \nNY-style pizzas\nHandles all the \nChicago-style pizzas\n", "page": 175, "type": "text", "section": "Page 175"}
{"text": "138\u2003 \u2003 Chapter 4\nobject dependencies\nLooking at object dependencies\nWhen you directly instantiate an object, you are depending on its \nconcrete class. Take a look at our very dependent PizzaStore one \npage back. It creates all the pizza objects right in the PizzaStore class \ninstead of delegating to a factory. \nIf we draw a diagram representing that version of the PizzaStore \nand all the objects it depends on, here\u2019s what it looks like:\n \n \n \n \n \n \n \n \n \nP\ni\nz\nz\na\nS\nt\no\nr\ne\nIf the implementation of these \nclasses changes, then we may \nhave to modify in PizzaStore. \nN\nY\nS\nt\ny\nl\ne\nV\ne\ng\ng\nie\nP\ni\nzz\na\nN\nY\nS\nt\ny\nl\ne\nC\nla\nm\nPi\nz\nz\na\nN\nY\nS\nt\ny\nl\ne\nP\ne\np\np\ne\nr\non\niP\ni\nz\nza\nCh\nic\na\ng\no\nS\nt\ny\nl\ne\nP\nep\np\ner\no\nn\ni\nP\nizza\nC\nhi\nc\na\ng\no\nS\nt\ny\nl\ne\nC\nh\ne\ne\ns\nePizza\nC\nhi\nc\na\ng\no\nS\nt\ny\nl\ne\nV\ne\ng\ng\ni\ne\nPizza\nC\nhi\nc\na\ng\no\nS\nt\ny\nl\ne\nC\nl\na\nm\nP\ni\nzza\nN\nY\nS\nt\ny\nl\ne\nC\nh\ne\ne\ns\neP\ni\nzza\nBecause any change to the concrete \nimplementations of pizzas affects the \nPizzaStore, we say that the PizzaStore \n\u201cdepends on\u201d the pizza implementations. \nEvery new kind of pizza \nwe add creates another \ndependency for PizzaStore.\nThis version of the \nPizzaStore depends on all \nthose pizza objects, because \nit\u2019s creating them directly.\n", "page": 176, "type": "text", "section": "Page 176"}
{"text": "you are here 4\u2003 \u2003 139\nthe factory pattern\nDesign Principle\nDepend upon abstractions. Do \nnot depend upon concrete classes. \nAt first, this principle sounds a lot like \u201cProgram to an \ninterface, not an implementation,\u201d right? It is similar; \nhowever, the Dependency Inversion Principle makes an even \nstronger statement about abstraction. It suggests that our \nhigh-level components should not depend on our low-level \ncomponents; rather, they should both depend on abstractions.\nBut what the heck does that mean?\nWell, let\u2019s start by looking again at the pizza store diagram \non the previous page. PizzaStore is our \u201chigh-level \ncomponent\u201d and the pizza implementations are our \u201clow-\nlevel components,\u201d and clearly PizzaStore is dependent on \nthe concrete pizza classes.\nNow, this principle tells us we should instead write our code \nso that we are depending on abstractions, not concrete \nclasses. That goes for both our high-level modules and our \nlow-level modules.\nBut how do we do this? Let\u2019s think about how we\u2019d apply this \nprinciple to our very dependent PizzaStore implementation...\nIt should be pretty clear that reducing dependencies to \nconcrete classes in our code is a \u201cgood thing.\u201d In fact, we\u2019ve \ngot an OO design principle that formalizes this notion; it even \nhas a big, formal name: Dependency Inversion Principle.\nHere\u2019s the general principle:\nThe Dependency Inversion Principle\nYet another phrase you can \nuse to impress the execs in \nthe room! Your raise will \nmore than offset the cost \nof this book, and you\u2019ll \ngain the admiration of \nyour fellow developers.\nA \u201chigh-level\u201d component is a class \nwith behavior defined in terms of \nother, \u201clow-level\u201d components.  \nFor example, PizzaStore is a \nhigh-level component because \nits behavior is defined in terms \nof pizzas\u2009\u2014\u2009it creates all the \ndifferent pizza objects, and \nprepares, bakes, cuts, and boxes \nthem, while the pizzas it uses are \nlow-level components.\n", "page": 177, "type": "text", "section": "Page 177"}
{"text": "140\u2003 \u2003 Chapter 4\ndependency inversion principle\nApplying the Principle\nNow, the main problem with the very dependent PizzaStore is that it depends \non every type of pizza because it actually instantiates concrete types in its \norderPizza() method.  \nWhile we\u2019ve created an abstraction, Pizza, we\u2019re nevertheless creating concrete \nPizzas in this code, so we don\u2019t get a lot of leverage out of this abstraction.  \nHow can we get those instantiations out of the orderPizza() method? Well, as we \nknow, the Factory Method Pattern allows us to do just that.  \nSo, after we\u2019ve applied the Factory Method Pattern, our diagram looks like this:\n \n \n \n  \nP\ni\nz\nz\na\nSt\no\nr\ne\n \n \n \n  \n \n \n \nP\ni\nz\nza\nN\nY\nS\nt\ny\nl\ne\nV\ne\ng\ng\nie\nP\ni\nzz\na\nN\nY\nS\nt\ny\nl\ne\nC\nla\nm\nPi\nz\nz\na\nN\nY\nS\nt\ny\nl\ne\nP\ne\np\np\ne\nr\no\nn\ni\nP\ni\nzza\nN\nY\nS\nt\ny\nl\ne\nC\nh\ne\ne\ns\neP\ni\nzza\nCh\nic\na\ng\no\nS\nt\ny\nl\ne\nP\nep\np\ner\no\nn\ni\nP\nizza\nC\nhi\nc\na\ng\no\nS\nt\ny\nl\ne\nC\nh\ne\ne\ns\nePizza\nC\nhi\nc\na\ng\no\nS\nt\ny\nl\ne\nV\ne\ng\ng\ni\ne\nPizza\nC\nhi\nc\na\ng\no\nS\nt\ny\nl\ne\nC\nl\na\nm\nP\ni\nzza\nThe concrete pizza classes depend on \nthe Pizza abstraction too, because \nthey implement the Pizza interface \n(remember, we\u2019re using \u201cinterface\u201d \nin the general sense) in the Pizza \nabstract class.\nPizza is an abstract \nclass...an abstraction.\nPizzaStore now depends only \non Pizza, the abstract class.\nAfter applying Factory Method, you\u2019ll notice that our high-level component, the \nPizzaStore, and our low-level components, the pizzas, both depend on Pizza, the \nabstraction. Factory Method is not the only technique for adhering to the Dependency \nInversion Principle, but it is one of the more powerful ones.\n", "page": 178, "type": "text", "section": "Page 178"}
{"text": "you are here 4\u2003 \u2003 141\nthe factory pattern\nThe \u201cinversion\u201d in the name Dependency Inversion \nPrinciple is there because it inverts the way you typically \nmight think about your OO design. Look at the diagram \non the previous page. Notice that the low-level components \nnow depend on a higher-level abstraction. Likewise, the \nhigh-level component is also tied to the same abstraction.  \nSo, the top-to-bottom dependency chart we drew a couple \nof pages back has inverted itself, with both high-level and \nlow-level modules now depending on the abstraction.\nLet\u2019s also walk through the thinking behind the typical \ndesign process and see how introducing the principle can \ninvert the way we think about the design...\nWhere\u2019s the \u201cinversion\u201d in Dependency \nInversion Principle?\nOkay, I get \nthe dependency part, \nbut why is it called \ndependency inversion?\n", "page": 179, "type": "text", "section": "Page 179"}
{"text": "142\u2003 \u2003 Chapter 4\ninvert your thinking\nRight, you start at the top and follow things \ndown to the concrete classes. But, as you\u2019ve seen, \nyou don\u2019t want your pizza store to know about \nthe concrete pizza types, because then it\u2019ll be \ndependent on all those concrete classes!\nNow, let\u2019s \u201cinvert\u201d your thinking...instead of \nstarting at the top, start at the Pizzas and think \nabout what you can abstract.\nRight! You are thinking about the abstraction Pizza. \nSo now, go back and think about the design of the \nPizza Store again.\nClose. But to do that you\u2019ll have to rely on a \nfactory to get those concrete classes out of \nyour Pizza Store. Once you\u2019ve done that, your \ndifferent concrete pizza types depend only on an \nabstraction, and so does your store. We\u2019ve taken \na design where the store depended on concrete \nclasses and inverted those dependencies (along \nwith your thinking).\nOkay, so you need to implement a Pizza Store. \nWhat\u2019s the first thought that pops into your head?\nInverting your thinking...\nWell, a CheesePizza and a \nVeggiePizza and a ClamPizza are \nall just Pizzas, so they should \nshare a Pizza interface.\nHmmm, Pizza Stores \nprepare, bake, and box pizzas.  \nSo, my store needs to be able to \nmake a bunch of different pizzas: \nCheesePizza, VeggiePizza, ClamPizza, \nand so on...\nSince I now have a Pizza \nabstraction, I can design my \nPizza Store and not worry about \nthe concrete pizza classes.\n", "page": 180, "type": "text", "section": "Page 180"}
{"text": "you are here 4\u2003 \u2003 143\nthe factory pattern\nA few guidelines to help you follow \nthe Principle...\nYou\u2019re exactly right! Like many of our principles, this is a guideline \nyou should strive for, rather than a rule you should follow all the time.  \nClearly, every single Java program ever written violates these guidelines!\nBut, if you internalize these guidelines and have them in the back of \nyour mind when you design, you\u2019ll know when you are violating the \nprinciple and you\u2019ll have a good reason for doing so. For instance, if you \nhave a class that isn\u2019t likely to change, and you know it, then it\u2019s not the \nend of the world if you instantiate a concrete class in your code. Think \nabout it; we instantiate String objects all the time without thinking twice.  \nDoes that violate the principle? Yes. Is that okay? Yes. Why? Because \nString is very unlikely to change.\nIf, on the other hand, a class you write is likely to change, you have some \ngood techniques like Factory Method to encapsulate that change.\nThe following guidelines can help you avoid OO designs that violate \nthe Dependency Inversion Principle:\n\t\n\u0083\nNo variable should hold a reference to a concrete class.\n\n\n\t\n\u0083\nNo class should derive from a concrete class.\n\n\n\t\n\u0083\nNo method should override an implemented method of any \nof its base classes.\nIf you use new, you\u2019ll be holding a \nreference to a concrete class. Use \na factory to get around that!\nIf you derive from a concrete class, you\u2019re \ndepending on a concrete class. Derive from an \nabstraction, like an interface or an abstract class.\nIf you override an implemented method, \nthen your base class wasn\u2019t really an \nabstraction to start with. Those methods \nimplemented in the base class are meant to \nbe shared by all your subclasses.\nBut wait, aren\u2019t these \nguidelines impossible to \nfollow? If I follow these, \nI\u2019ll never be able to write \na single program!\n", "page": 181, "type": "text", "section": "Page 181"}
{"text": "144\u2003 \u2003 Chapter 4\nfamilies of ingredients\nThe design for the Pizza Store is really shaping up: it\u2019s got a \nflexible framework and it does a good job of adhering to design \nprinciples.  \nNow, the key to Objectville Pizza\u2019s success has always been fresh, \nquality ingredients, and what you\u2019ve discovered is that with the \nnew framework your franchises have been following your procedures, \nbut a few franchises have been substituting inferior ingredients in \ntheir pizzas to lower costs and increase their margins. You know \nyou\u2019ve got to do something, because in the long term this is going \nto hurt the Objectville brand!\nSo how are you going to ensure each franchise is using quality ingredients?  \nYou\u2019re going to build a factory that produces them and ships them to your \nfranchises!\nNow there\u2019s only one problem with this plan: the franchises are located in \ndifferent regions and what is red sauce in New York is not red sauce in Chicago.  \nSo, you have one set of ingredients that needs to be shipped to New York and a \ndifferent set that needs to be shipped to Chicago. Let\u2019s take a closer look:\nEnsuring consistency in your ingredients\nCheese Pizza\n   Marinara Sauce, Reggiano, Garlic\nVeggie Pizza\n   Marinara Sauce, Reggiano, Mushrooms, \n   Onions, Red Peppers\nClam Pizza\n   Marinara Sauce, Reggiano, Fresh Clams\nPepperoni Pizza\n   Marinara Sauce, Reggiano, Mushrooms, \n   Onions, Red Peppers, Pepperoni\nNew York\nPizzaMenu\nCheese Pizza\n   Plum Tomato Sauce, Mozzarella, Parmesan,\n    Oregano\nVeggie Pizza\n   Plum Tomato Sauce, Mozzarella, Parmesan,\n   Eggplant, Spinach, Black Olives\nClam Pizza\n   Plum Tomato Sauce, Mozzarella, Parmesan, Clams\nPepperoni Pizza\n   Plum Tomato Sauce, Mozzarella, Parmesan,\n   Eggplant, Spinach, Black Olives, Pepperoni\nChicago\nPizzaMenu\nWe\u2019ve got the \nsame product \nfamilies (dough, \nsauce, cheese, \nveggies, meats) \nbut different \nimplementations \nbased on region.\nMeanwhile, back at the Pizza Store...\nDough\nSauce\nCheese\nVeggies\nPepperoni\nThat is, the baking, \nthe cutting, the \nboxing, and so on...\n", "page": 182, "type": "text", "section": "Page 182"}
{"text": "you are here 4\u2003 \u2003 145\nthe factory pattern\nFamilies of ingredients...\nNew York uses one set of ingredients and \nChicago another. Given the popularity of \nObjectville Pizza, it won\u2019t be long before \nyou also need to ship another set of regional \ningredients to California, and what\u2019s next? \nAustin?\nFor this to work, you\u2019re going to have to figure \nout how to handle families of ingredients.\nReggianoCheese\nThinCrustDough\nFreshClams\nFreshClams\nMarinaraSauce\nBruschettaSauce\nGoatCheese\nVeryThinCrustDough\nCalifornia\nFrozenClams\nPlumTomatoSauce\nMozzarellaCheese\nThickCrustDough\nNew York\nChicago\nAll Objectville\u2019s Pizzas are made from the same \ncomponents, but each region has a different \nimplementation of those components.\nIn total, these three regions make up ingredient families, with \neach region implementing a complete family of ingredients.\nEach family consists of a type of dough, \na type of sauce, a type of cheese, and a \nseafood topping (along with a few more we \nhaven\u2019t shown, like veggies and spices).\n", "page": 183, "type": "text", "section": "Page 183"}
{"text": "146\u2003 \u2003 Chapter 4\ningredient factories\npublic interface PizzaIngredientFactory {\n \n    public Dough createDough();\n    public Sauce createSauce();\n    public Cheese createCheese();\n    public Veggies[] createVeggies();\n    public Pepperoni createPepperoni();\n    public Clams createClam();\n \n}\nBuilding the ingredient factories\nNow we\u2019re going to build a factory to create our ingredients; the \nfactory will be responsible for creating each ingredient in the \ningredient family. In other words, the factory will need to create \ndough, sauce, cheese, and so on... You\u2019ll see how we are going to \nhandle the regional differences shortly.\nLet\u2019s start by defining an interface for the factory that is going to \ncreate all our ingredients:\nFor each ingredient we define a \ncreate method in our interface. \nWith that interface, here\u2019s what we\u2019re going to do:\nLots of new classes here, \none per ingredient.\n1\n2\n3\nBuild a factory for each region. To do this, you\u2019ll create a subclass of \nPizzaIngredientFactory that implements each create method.\nImplement a set of ingredient classes to be used with the factory, like \nReggianoCheese, RedPeppers, and ThickCrustDough. These classes can be \nshared among regions where appropriate.\nThen we still need to hook all this up by working our new ingredient \nfactories into our old PizzaStore code.\n", "page": 184, "type": "text", "section": "Page 184"}
{"text": "you are here 4\u2003 \u2003 147\nthe factory pattern\npublic class NYPizzaIngredientFactory implements PizzaIngredientFactory {\n \n    public Dough createDough() {\n        return new ThinCrustDough();\n    }\n \n    public Sauce createSauce() {\n        return new MarinaraSauce();\n    }\n \n    public Cheese createCheese() {\n        return new ReggianoCheese();\n    }\n \n    public Veggies[] createVeggies() {\n        Veggies veggies[] = { new Garlic(), new Onion(), new Mushroom(), new RedPepper() };\n        return veggies;\n    }\n \n    public Pepperoni createPepperoni() {\n        return new SlicedPepperoni();\n    }\n    public Clams createClam() {\n        return new FreshClams();\n    }\n}\nBuilding the New York ingredient factory\nOkay, here\u2019s the implementation for the New York ingredient factory. This \nfactory specializes in Marinara Sauce, Reggiano Cheese, Fresh Clams, etc.\nThe NY ingredient factory \nimplements the interface for all \ningredient factories.\nFor each ingredient in the \ningredient family, we create \nthe New York version.\nFor veggies, we return an array of \nVeggies. Here we\u2019ve hardcoded the \nveggies. We could make this more \nsophisticated, but that doesn\u2019t really \nadd anything to learning the factory \npattern, so we\u2019ll keep it simple.\nThe best sliced pepperoni.  \nThis is shared between New \nYork and Chicago. Make sure \nyou use it on the next page \nwhen you get to implement \nthe Chicago factory yourself.\nNew York is on the coast; it \ngets fresh clams. Chicago has \nto settle for frozen.\n", "page": 185, "type": "text", "section": "Page 185"}
{"text": "148\u2003 \u2003 Chapter 4\nbuild a factory\nWrite the ChicagoPizzaIngredientFactory.  You can reference \nthe classes below in your implementation:\nSlicedPepperoni\nEggPlant\nSpinach\nBlackOlives\nFrozenClams\nPlumTomatoSauce\nMozzarellaCheese\nThickCrustDough\n", "page": 186, "type": "text", "section": "Page 186"}
{"text": "you are here 4\u2003 \u2003 149\nthe factory pattern\npublic abstract class Pizza {\n    String name;\n    Dough dough;\n    Sauce sauce;\n    Veggies veggies[];\n    Cheese cheese;\n    Pepperoni pepperoni;\n    Clams clam;\n    abstract void prepare();\n    void bake() {\n        System.out.println(\"Bake for 25 minutes at 350\");\n    }\n    void cut() {\n        System.out.println(\"Cutting the pizza into diagonal slices\");\n    }\n    void box() {\n        System.out.println(\"Place pizza in official PizzaStore box\");\n    }\n    void setName(String name) {\n        this.name = name;\n    }\n    String getName() {\n        return name;\n    }\n    public String toString() {\n        // code to print pizza here\n    }\n}\nReworking the pizzas...\nWe\u2019ve got our factories all fired up and ready to produce quality ingredients; now we \njust need to rework our Pizzas so they only use factory-produced ingredients.  We\u2019ll \nstart with our abstract Pizza class:\nEach pizza holds a set of ingredients \nthat are used in its preparation.\nOur other methods remain the same, with \nthe exception of the prepare method.\nWe\u2019ve now made the prepare method abstract.  \nThis is where we are going to collect the \ningredients needed for the pizza, which of \ncourse will come from the ingredient factory.\n", "page": 187, "type": "text", "section": "Page 187"}
{"text": "150\u2003 \u2003 Chapter 4\ndecoupling ingredients\npublic class CheesePizza extends Pizza {\n    PizzaIngredientFactory ingredientFactory;\n \n    public CheesePizza(PizzaIngredientFactory ingredientFactory) {\n        this.ingredientFactory = ingredientFactory;\n    }\n \n    void prepare() {\n        System.out.println(\"Preparing \" + name);\n        dough = ingredientFactory.createDough();\n        sauce = ingredientFactory.createSauce();\n        cheese = ingredientFactory.createCheese();\n    }\n}\nReworking the pizzas, continued...\nNow that you\u2019ve got an abstract Pizza class to work from, it\u2019s time to \ncreate the New York\u2013 and Chicago-style Pizzas\u2014only this time around, \nthey\u2019ll get their ingredients straight from the factory. The franchisees\u2019 days \nof skimping on ingredients are over!\nWhen we wrote the Factory Method code, we had a NYCheesePizza and \na ChicagoCheesePizza class. If you look at the two classes, the only thing \nthat differs is the use of regional ingredients. The pizzas are made just \nthe same (dough + sauce + cheese). The same goes for the other pizzas: \nVeggie, Clam, and so on. They all follow the same preparation steps; they \njust have different ingredients.\nSo, what you\u2019ll see is that we really don\u2019t need two classes for each pizza; \nthe ingredient factory is going to handle the regional differences for us.\nHere\u2019s the CheesePizza:\nT\no make a pizza now, we \nneed a factory to provide \nthe ingredients. So each \nPizza class gets a factory \npassed into its constructor, \nand it\u2019s stored in an \ninstance variable.\nHere\u2019s where the magic happens!\nThe prepare() method steps through creating \na cheese pizza, and each time it needs an \ningredient, it asks the factory to produce it.\n", "page": 188, "type": "text", "section": "Page 188"}
{"text": "you are here 4\u2003 \u2003 151\nthe factory pattern\npublic class ClamPizza extends Pizza {\n    PizzaIngredientFactory ingredientFactory;\n \n    public ClamPizza(PizzaIngredientFactory ingredientFactory) {\n        this.ingredientFactory = ingredientFactory;\n    }\n \n    void prepare() {\n        System.out.println(\"Preparing \" + name);\n        dough = ingredientFactory.createDough();\n        sauce = ingredientFactory.createSauce();\n        cheese = ingredientFactory.createCheese();\n        clam = ingredientFactory.createClam();\n    }\n}\nCode Up Close\nThe Pizza code uses the factory it has been composed with to produce the ingredients used in the \npizza. The ingredients produced depend on which factory we\u2019re using. The Pizza class doesn\u2019t care; \nit knows how to make pizzas. Now, it\u2019s decoupled from the differences in regional ingredients and can \nbe easily reused when there are factories for the Austin, the Nashville, and beyond.\nsauce = ingredientFactory.createSauce();\nWe\u2019re setting the \nPizza instance \nvariable to refer to \nthe specific sauce \nused in this pizza.\nThe createSauce() method returns the sauce \nthat is used in its region. If this is a NY \ningredient factory, then we get marinara sauce.\nThis is our ingredient factory. \nThe Pizza class doesn\u2019t care \nwhich factory is used, as long \nas it\u2019s an ingredient factory.\nLet\u2019s check out the ClamPizza as well:\nClamPizza also stashes \nan ingredient factory.\nT\no make a clam pizza, the prepare() \nmethod collects the right \ningredients from its local factory.\nIf it\u2019s a New York factory, \nthe clams will be fresh; if it\u2019s \nChicago, they\u2019ll be frozen.\n", "page": 189, "type": "text", "section": "Page 189"}
{"text": "152\u2003 \u2003 Chapter 4\nuse the right ingredient factory\npublic class NYPizzaStore extends PizzaStore {\n \n    protected Pizza createPizza(String item) {\n        Pizza pizza = null;\n        PizzaIngredientFactory ingredientFactory = \n            new NYPizzaIngredientFactory();\n \n        if (item.equals(\"cheese\")) {\n  \n            pizza = new CheesePizza(ingredientFactory);\n            pizza.setName(\"New York Style Cheese Pizza\");\n  \n        } else if (item.equals(\"veggie\")) {\n \n            pizza = new VeggiePizza(ingredientFactory);\n            pizza.setName(\"New York Style Veggie Pizza\");\n \n        } else if (item.equals(\"clam\")) {\n \n            pizza = new ClamPizza(ingredientFactory);\n            pizza.setName(\"New York Style Clam Pizza\");\n \n        } else if (item.equals(\"pepperoni\")) {\n            pizza = new PepperoniPizza(ingredientFactory);\n            pizza.setName(\"New York Style Pepperoni Pizza\");\n \n        } \n        return pizza;\n    }\n}\nRevisiting our pizza stores\nWe\u2019re almost there; we just need to make a quick trip to our franchise stores to make \nsure they are using the correct Pizzas. We also need to give them a reference to their \nlocal ingredient factories:\nThe NY Store is composed with \na NY pizza ingredient factory. \nThis will be used to produce the \ningredients for all NY-style \npizzas.\nWe now pass each pizza the \nfactory that should be used to \nproduce its ingredients.\nLook back one page and make \nsure you understand how the \npizza and the factory work \ntogether!\nFor each type of Pizza, we \ninstantiate a new Pizza and \ngive it the factory it needs to \nget its ingredients.\nCompare this version of the createPizza() \nmethod to the one in the Factory Method \nimplementation earlier in the chapter.\n", "page": 190, "type": "text", "section": "Page 190"}
{"text": "you are here 4\u2003 \u2003 153\nthe factory pattern\nWhat have we done?\nThat was quite a series of code changes; \nwhat exactly did we do?  \nWe provided a means of creating a family \nof ingredients for pizzas by introducing \na new type of factory called an Abstract \nFactory.\nAn Abstract Factory gives us an interface \nfor creating a family of products. By \nwriting code that uses this interface, we \ndecouple our code from the actual factory \nthat creates the products. That allows us \nto implement a variety of factories that \nproduce products meant for different \ncontexts\u2014such as different regions, \ndifferent operating systems, or different \nlook and feels.\nBecause our code is decoupled from the \nactual products, we can substitute different \nfactories to get different behaviors \n(like getting marinara instead of plum \ntomatoes).\nAn Abstract Factory provides an interface for \na family of products. What\u2019s a family? In our \ncase, it\u2019s all the things we need to make a pizza: \ndough, sauce, cheese, meats, and veggies.\nFrom the abstract factory, we \nderive one or more concrete \nfactories that produce the same \nproducts, but with different \nimplementations.\nObjectvilleAbstract IngredientFactory\nNew York \nChicago\nDefines the \ninterface.\nWe then write our code so that it uses the \nfactory to create products. By passing in \na variety of factories, we get a variety of \nimplementations of those products. But our \nclient code stays the same.\n \n \n \n \n \nP\ni\nz\nz\na\nSto\nr\ne\nProvides implementations \nfor products.\nPizza made with \ningredients produced \nby concrete factory.\n", "page": 191, "type": "text", "section": "Page 191"}
{"text": "154\u2003 \u2003 Chapter 4\norder some more pizza\nMore pizza for Ethan and Joel...\nEthan and Joel can\u2019t get enough Objectville Pizza! What \nthey don\u2019t know is that now their orders are making use of \nthe new ingredient factories. So now when they order...\nThe first part of the order process hasn\u2019t changed at all.  \nLet\u2019s follow Ethan\u2019s order again:\n1\n2\n3\n \n  \n \n \nn\ny\nP\ni\nz\nz\naS\nt\no\nr\ne\ncreatePizza(\"cheese\")\nPizzaStore nyPizzaStore = new NYPizzaStore();\nFirst we need a NYPizzaStore:\nnyPizzaStore.orderPizza(\"cheese\");\nNow that we have a store, we can take an order:\nThe orderPizza() method first calls the \ncreatePizza() method:\nPizza pizza  = createPizza(\"cheese\");\nCreates an instance \nof NYPizzaStore.\nThe orderPizza() method is called \non the nyPizzaStore instance.\nBehind \nthe Scenes\nI\u2019m stickin\u2019 with \nChicago.\nI\u2019m still lovin\u2019 NY style.\n(See on the next page.)\n", "page": 192, "type": "text", "section": "Page 192"}
{"text": "you are here 4\u2003 \u2003 155\nthe factory pattern\nFrom here things change, because we \nare using an ingredient factory\nPizza pizza = new CheesePizza(nyIngredientFactory);\nWhen the createPizza() method is called, that\u2019s \nwhen our ingredient factory gets involved:\nNext we need to prepare the pizza. Once the \nprepare() method is called, the factory is asked to \nprepare ingredients:\nFinally, we have the prepared pizza in hand and the \norderPizza() method bakes, cuts, and boxes the pizza.\nCreates a instance \nof Pizza that is \ncomposed with the \nNew York ingredient \nfactory.\n \n  \n \n \n  \n \n  \n \nP\ni\nzza\nprepare()\nn\ny\nI\nn\ng\nr\ne\nd\nien\nt\nF\nac\nt\no\nr\ny\nholds\nFor Ethan\u2019s pizza the New York \ningredient factory is used, and so \nwe get the NY ingredients.\n    void prepare() {\n        dough = factory.createDough();\n        sauce = factory.createSauce();\n        cheese = factory.createCheese();\n    }\nThin crust\nMarinara\nReggiano\nThe ingredient factory is chosen and \ninstantiated in the PizzaStore and then \npassed into the constructor of each pizza.\n4\n5\n6\nBehind \nthe Scenes\n", "page": 193, "type": "text", "section": "Page 193"}
{"text": "156\u2003 \u2003 Chapter 4\nabstract factory defined\nAbstract Factory Pattern defined\nThe Abstract Factory Pattern provides an interface \nfor creating families of related or dependent objects \nwithout specifying their concrete classes.\nWe\u2019re adding yet another factory pattern to our pattern family, one that lets us create families \nof products. Let\u2019s check out the official definition for this pattern:\nWe\u2019ve certainly seen that Abstract Factory allows a client to use an abstract interface to \ncreate a set of related products without knowing (or caring) about the concrete products that \nare actually produced. In this way, the client is decoupled from any of the specifics of the \nconcrete products. Let\u2019s look at the class diagram to see how this all holds together:\nCreateProductA()\nCreateProductB()\n<<interface>>\nAbstractFactory\nClient\nProductB1\n<<interface>>\nAbstractProductB\nProductA1\nProductB2\n<<interface>>\nAbstractProductA\nProductA2\nCreateProductA()\nCreateProductB()\nConcreteFactory2\nCreateProductA()\nCreateProductB()\nConcreteFactory1\nThe Client is written against the \nabstract factory and then composed \nat runtime with an actual factory.\nThe concrete factories implement \nthe different product families. T\no \ncreate a product, the client uses \none of these factories, so it never \nhas to instantiate a product object.\nThe Abstract Factory defines the \ninterface that all Concrete factories \nmust implement, which consists of a set \nof methods for producing products.\nThis is the product \nfamily. Each concrete \nfactory can produce an \nentire set of products.\n", "page": 194, "type": "text", "section": "Page 194"}
{"text": "you are here 4\u2003 \u2003 157\nthe factory pattern\n<<interface>>\nClams\n<<interface>>\nCheese\n<<interface>>\nSauce\n<<interface>>\nDough\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\nChicagoPizzaIngredientFactory\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\nNYPizzaIngredientFactory\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\n<<interface>>\nPizzaIngredientFactory\ncreatePizza()\nNYPizzaStore\nEach factory produces a different \nimplementation for the family of products.\nThe abstract \nPizzaIngredientFactory is the \ninterface that defines how to \nmake a family of related products\u2014\neverything we need to make a pizza.\nThe clients of the Abstract \nFactory are the two \ninstances of our PizzaStore, \nNYPizzaStore and \nChicagoStylePizzaStore. \nThe job of the \nconcrete pizza \nfactories is to make \npizza ingredients. Each \nfactory knows how \nto create the right \nobjects for its region.\nThat\u2019s a fairly complicated class \ndiagram; let\u2019s look at it all in terms \nof our PizzaStore:\nThickCrustDough\nThinCrustDough\nPlumTomatoSauce\nMarinaraSauce\nMozzarella Cheese\nReggianoCheese\nFreshClams\nFrozenClams\n", "page": 195, "type": "text", "section": "Page 195"}
{"text": "158\u2003 \u2003 Chapter 4\ninterview with factory patterns\nHeadFirst: Wow, an interview with two patterns at once! This is a first for us.\nFactory Method: Yeah, I\u2019m not so sure I like being lumped in with Abstract Factory, \nyou know. Just because we\u2019re both factory patterns doesn\u2019t mean we shouldn\u2019t get our own \ninterviews.\nHeadFirst: Don\u2019t be miffed, we wanted to interview you together so we could help clear up \nany confusion about who\u2019s who for the readers. You do have similarities, and I\u2019ve heard that \npeople sometimes get you confused.\nAbstract Factory: It\u2019s true, there have been times I\u2019ve been mistaken for Factory Method, \nand I know you\u2019ve had similar issues, Factory Method. We\u2019re both really good at decoupling \napplications from specific implementations; we just do it in different ways. So I can see why \npeople might sometimes get us confused.\nFactory Method: Well, it still ticks me off. After all, I use classes to create and you use objects; \nthat\u2019s totally different!\nThis week\u2019s interview:\nFactory Method and Abstract Factory, on each other\nPatterns Exposed\nGood catch! Yes, often the methods of an Abstract Factory are \nimplemented as factory methods. It makes sense, right? The job of an \nAbstract Factory is to define an interface for creating a set of products.  \nEach method in that interface is responsible for creating a concrete \nproduct, and we implement a subclass of the Abstract Factory to \nsupply those implementations. So, factory methods are a natural way to \nimplement your product methods in your abstract factories.\nIs that a factory method lurking inside the \nAbstract Factory?\nI noticed that each method in the \nAbstract Factory actually looks like \na factory method (createDough(), \ncreateSauce(), etc.). Each method is \ndeclared abstract and the subclasses \noverride it to create some object. Isn\u2019t \nthat a factory method?\n", "page": 196, "type": "text", "section": "Page 196"}
{"text": "you are here 4\u2003 \u2003 159\nthe factory pattern\nHeadFirst: Can you explain more about that, Factory \nMethod?\nFactory Method: Sure. Both Abstract Factory and \nI create objects\u2014that\u2019s our job. But I do it through \ninheritance...\nAbstract Factory: ...and I do it through object \ncomposition.\nFactory Method: Right. So that means, to create \nobjects using Factory Method, you need to extend a class \nand provide an implementation for a factory method.\nHeadFirst: And that factory method does what? \nFactory Method: It creates objects, of course! I mean, \nthe whole point of the Factory Method Pattern is that \nyou\u2019re using a subclass to do your creation for you. In that \nway, clients only need to know the abstract type they are \nusing; the subclass worries about the concrete type. So, in \nother words, I keep clients decoupled from the concrete \ntypes.\nAbstract Factory: And I do too, only I do it in a \ndifferent way. \nHeadFirst: Go on, Abstract Factory...you said \nsomething about object composition?\nAbstract Factory: I provide an abstract type for \ncreating a family of products. Subclasses of this type \ndefine how those products are produced. To use the \nfactory, you instantiate one and pass it into some code \nthat is written against the abstract type. So, like Factory \nMethod, my clients are decoupled from the actual \nconcrete products they use.\nHeadFirst: Oh, I see, so another advantage is that you \ngroup together a set of related products.\nAbstract Factory: That\u2019s right.\nHeadFirst: What happens if you need to extend that set \nof related products to, say, add another one? Doesn\u2019t that \nrequire changing your interface?\nAbstract Factory: That\u2019s true; my interface has to \nchange if new products are added, which I know people \ndon\u2019t like to do....\nFactory Method: <snicker>\nAbstract Factory: What are you snickering at, Factory \nMethod?\nFactory Method:  Oh, come on, that\u2019s a big deal! \nChanging your interface means you have to go in and \nchange the interface of every subclass! That sounds like a \nlot of work.\nAbstract Factory: Yeah, but I need a big interface \nbecause I am used to creating entire families of products. \nYou\u2019re only creating one product, so you don\u2019t really need \na big interface, you just need one method. \nHeadFirst: Abstract Factory, I heard that you often use \nfactory methods to implement your concrete factories?\nAbstract Factory: Yes, I\u2019ll admit it, my concrete \nfactories often implement a factory method to create \ntheir products. In my case, they are used purely to create \nproducts...\nFactory Method:  ...while in my case I usually \nimplement code in the abstract creator that makes use of \nthe concrete types the subclasses create.\nHeadFirst: It sounds like you both are good at what you \ndo. I\u2019m sure people like having a choice; after all, factories \nare so useful, they\u2019ll want to use them in all kinds of \ndifferent situations. You both encapsulate object creation \nto keep applications loosely coupled and less dependent \non implementations, which is really great, whether you\u2019re \nusing Factory Method or Abstract Factory. May I allow \nyou each a parting word?\nAbstract Factory: Thanks. Remember me, Abstract \nFactory, and use me whenever you have families of \nproducts you need to create and you want to make sure \nyour clients create products that belong together.\nFactory Method:  And I\u2019m Factory Method; use me to \ndecouple your client code from the concrete classes you \nneed to instantiate, or if you don\u2019t know ahead of time all \nthe concrete classes you are going to need. To use me, just \nsubclass me and implement my factory method!\n", "page": 197, "type": "text", "section": "Page 197"}
{"text": "160\u2003 \u2003 Chapter 4\npatterns compared\ncreatePizza()\nChicagoPizzaStore\ncreatePizza()\nNYPizzaStore\ncreatePizza()\nPizzaStore\nNYStyleVeggiePizza\nNYStyleClamPizza\nNYStylePepperoniPizza\nNYStyleCheesePizza\nPizza\nChicagoStyleVeggiePizza\nChicagoStyleClamPizza\nChicagoStylePepperoniPizza\nChicagoStyleCheesePizza\nFactory Method and Abstract Factory compared\nNew York Store\nPizzaStore is implemented as a Factory \nMethod because we want to be able to \ncreate a product that varies by region. \nWith the Factory Method, each region \ngets its own concrete factory that \nknows how to make pizzas that are \nappropriate for the area.\nEach subclass decides which \nconcrete class to instantiate. \nThe Factory Method \nThis is the product of the \nPizzaStore. Clients only \nrely on this abstract type.\nSubclasses are \ninstantiated by the \nFactory Methods.\nNew York\nChicago\nThe Factory Method \nThe NYPizzaStore subclass \ninstantiates only NY-style pizzas.\nThe ChicagoPizzaStore \nsubclass instantiates only \nChicago-style pizzas.\nChicago Store\nThe createPizza() method is parameterized by pizza \ntype, so we can return many types of pizza products.\nProvides an abstract \ninterface for \ncreating one product.\n", "page": 198, "type": "text", "section": "Page 198"}
{"text": "you are here 4\u2003 \u2003 161\nthe factory pattern\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\n<<interface>>\nPizzaIngredientFactory\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\nNYPizzaIngredientFactory\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\nChicagoPizzaIngredientFactory\nPizzaIngredientFactory is implemented as an \nAbstract Factory because we need to create \nfamilies of products (the ingredients). Each \nsubclass implements the ingredients using its \nown regional suppliers.\nFrozenClams\nFreshClams\n<<interface>>\nClams\n<<interface>>\nSauce\n<<interface>>\nDough\nReggianoCheese\nMozzarellaCheese\n<<interface>>\nCheese\nEach concrete subclass creates \na family of products.\nThinCrustDough\nThickCrustDough\nMarinaraSauce\nPlumTomatoSauce\nChicago\nProvides an abstract \ninterface for creating a \nfamily of products.\nMethods to create \nproducts in an Abstract \nFactory are often \nimplemented with a \nFactory Method...\n...\u2009or the type of clams.\nNew York\nEach ingredient \nrepresents a \nproduct that is \nproduced by a \nFactory Method \nin the Abstract \nFactory.\n...for instance, the subclass \ndecides the type of dough...\nThe product subclasses create parallel sets of product families. \nHere we have a New York ingredient family and a Chicago family.\n", "page": 199, "type": "text", "section": "Page 199"}
{"text": "162\u2003 \u2003 Chapter 4\nyour design toolbox\nTools for your Design Toolbox\nIn this chapter, we added two more tools to your toolbox: \nFactory Method and Abstract Factory. Both patterns \nencapsulate object creation and allow you to decouple your \ncode from concrete types.\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies.\nFavor composition over inheritance.\nProgram to interfaces, not \nimplementations.\nStrive for loosely coupled designs \nbetween objects that interact.\nClasses should be open for extension \nbut closed for modification.\nDepend on abstractions. Do not \ndepend on concrete classes.\nOO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable.  Strategy lets the algorithm \nvary independently from clients that use it.\nOO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically.  \nDecorators provide a flexible \nalternative to subclassing for extending \nfunctionality.\nAbstract Factory - Provides \nan interface for creating families of \nrelated or dependent objects without \nspecifying their concrete classes.\nFactory Method - Defines an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate.  Factory Method lets \na class defer instantiation to the \nsubclasses.\nWe have a new principle that \nguides us to keep things \nabstract whenever possible.\nBoth of these new \npatterns encapsulate \nobject creation \nand lead to more \ndecoupled, flexible \ndesigns.\n\t\n\u0083\nAll factories encapsulate object \ncreation.\n\t\n\u0083\nSimple Factory, while not a \nbona fide design pattern, is a \nsimple way to decouple your \nclients from concrete classes.\n\t\n\u0083\nFactory Method relies on \ninheritance: object creation is \ndelegated to subclasses, which \nimplement the factory method \nto create objects.\n\t\n\u0083\nAbstract Factory relies on \nobject composition: object \ncreation is implemented in \nmethods exposed in the factory \ninterface.\n\t\n\u0083\nAll factory patterns promote \nloose coupling by reducing the \ndependency of your application \non concrete classes.\n\t\n\u0083\nThe intent of Factory Method \nis to allow a class to defer \ninstantiation to its subclasses.\n\t\n\u0083\nThe intent of Abstract Factory \nis to create families of related \nobjects without having to \ndepend on their concrete \nclasses.\n\t\n\u0083\nThe Dependency Inversion \nPrinciple guides us to avoid \ndependencies on concrete \ntypes and to strive for \nabstractions.\n\t\n\u0083\nFactories are a powerful \ntechnique for coding to \nabstractions, not concrete \nclasses.\n", "page": 200, "type": "text", "section": "Page 200"}
{"text": "you are here 4\u2003 \u2003 163\nthe factory pattern\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nAcross\n1. In Factory Method, each franchise is a \n______________\n4. In Factory Method, who decides which class to \ninstantiate?\n6. Role of PizzaStore in Factory Method Pattern\n7. All New York Style Pizzas use this kind of \ncheese\n8. In Abstract Factory, each ingredient factory is a \n_____________\n9. When you use new, you are programming to an \n___________\n11. createPizza() is a ______________ (two words)\n12. Joel likes this kind of pizza\n13. In Factory Method, the PizzaStore and the \nconcrete Pizzas all depend on this abstraction\n14. When a class instantiates an object from a \nconcrete class, it's __________ on that object\n15. All factory patterns allow us to __________ \nobject creation\nDown\n2. We used ______________  in Simple Factory \nand Abstract Factory and inheritance in Factory \nMethod\n3. Abstract Factory creates a ___________ of \nproducts\n5. Not a REAL factory pattern, but handy \nnonetheless\n10. Ethan likes this kind of pizza\nDesign Patterns Crossword\nIt\u2019s been a long chapter. Grab a slice of Pizza and relax while doing \nthis crossword; all of the solution words are from this chapter.\nACROSS\n1. In Factory Method, each franchise is a ________.\n4. In Factory Method, who decides which class to \ninstantiate?\n6. Role of PizzaStore in the Factory Method Pattern.\n7. All New York\u2013style pizzas use this kind of cheese.\n8. In Abstract Factory, each ingredient factory is a \n_______.\n9. When you use new, you are programming to an \n___________.\n11. createPizza() is a ____________.\n12. Joel likes this kind of pizza.\n13. In Factory Method, the PizzaStore and the concrete \nPizzas all depend on this abstraction.\n14. When a class instantiates an object from a concrete \nclass, it's ___________ on that object.\n15. All factory patterns allow us to __________ object \ncreation.\n\nDOWN\n2.We used ___________ in Simple Factory and Abstract \nFactory, and inheritance in Factory Method.\n3. Abstract Factory creates a ___________ of products.\n5. Not a REAL factory pattern, but handy nonetheless.\n10. Ethan likes this kind of pizza.\n", "page": 201, "type": "text", "section": "Page 201"}
{"text": "164\u2003 \u2003 Chapter 4\nexercise solutions\nWe\u2019ve knocked out the NYPizzaStore; just two more to go and we\u2019ll be ready to franchise! Write \nthe Chicago-style and California-style PizzaStore implementations here:\npublic class ChicagoPizzaStore extends PizzaStore {\n    protected Pizza createPizza(String item) {\n        if (item.equals(\"cheese\")) {\n            return new ChicagoStyleCheesePizza();\n        } else if (item.equals(\"veggie\")) {\n            return new ChicagoStyleVeggiePizza();\n        } else if (item.equals(\"clam\")) {\n            return new ChicagoStyleClamPizza();\n        } else if (item.equals(\"pepperoni\")) {\n            return new ChicagoStylePepperoniPizza();\n        } else return null;\n    }\n}\npublic class CaliforniaPizzaStore extends PizzaStore {\n    protected Pizza createPizza(String item) {\n        if (item.equals(\"cheese\")) {\n            return new CaliforniaStyleCheesePizza();\n        } else if (item.equals(\"veggie\")) {\n            return new CaliforniaStyleVeggiePizza();\n        } else if (item.equals(\"clam\")) {\n            return new CaliforniaStyleClamPizza();\n        } else if (item.equals(\"pepperoni\")) {\n            return new CaliforniaStylePepperoniPizza();\n        } else return null;\n    }\n}\nFor the Chicago pizza \nstore, we just have to \nmake sure we create \nChicago-style pizzas...\n...\u200a\nand for the California \npizza store, we create \nCalifornia-style pizzas.\nBoth of these stores are almost exactly like the New \nYork store...they just create different kinds of pizzas.\n", "page": 202, "type": "text", "section": "Page 202"}
{"text": "you are here 4\u2003 \u2003 165\nthe factory pattern\nWe need another kind of pizza for those crazy Californians (crazy in a good way, \nof course). Draw another parallel set of classes that you\u2019d need to add a new \nCalifornia region to our PizzaStore.\ncreatePizza()\norderPizza()\nPizzaStore\nOkay, now write the five silliest things you can think of to put on a pizza.  \nThen, you\u2019ll be ready to go into business making pizza in California!\ncreatePizza()\nNYPizzaStore\ncreatePizza()\nChicagoPizzaStore\nNYStyleVeggiePizza\nNYStyleClamPizza\nNYStylePepperoniPizza\nNYStyleCheesePizza\nChicagoStyleVeggiePizza\nChicagoStyleClamPizza\nChicagoStylePepperoniPizza\nChicagoStyleCheesePizza\ncreatePizza()\nCaliforniaPizzaStore\nCaliforniaStyleVeggiePizza\nCaliforniaStyleClamPizza\nCaliforniaStylePepperoniPizza\nCaliforniaStyleCheesePizza\nHere\u2019s everything you need to \nadd a California pizza store, \nthe concrete pizza store class, \nand the California-style pizzas.\nMashed potatoes with roasted garlic\nBBQ sauce\nArtichoke hearts\nM&M\u2019s\nPeanuts\nHere \nare our \nsuggestions...\n Design Puzzle Solution\n", "page": 203, "type": "text", "section": "Page 203"}
{"text": "166\u2003 \u2003 Chapter 4\nexercise solutions\npublic class DependentPizzaStore {\n \n    public Pizza createPizza(String style, String type) {\n        Pizza pizza = null;\n        if (style.equals(\"NY\")) {\n            if (type.equals(\"cheese\")) {\n                pizza = new NYStyleCheesePizza();\n            } else if (type.equals(\"veggie\")) {\n                pizza = new NYStyleVeggiePizza();\n            } else if (type.equals(\"clam\")) {\n                pizza = new NYStyleClamPizza();\n            } else if (type.equals(\"pepperoni\")) {\n                pizza = new NYStylePepperoniPizza();\n            }\n        } else if (style.equals(\"Chicago\")) {\n            if (type.equals(\"cheese\")) {\n                pizza = new ChicagoStyleCheesePizza();\n            } else if (type.equals(\"veggie\")) {\n                pizza = new ChicagoStyleVeggiePizza();\n            } else if (type.equals(\"clam\")) {\n                pizza = new ChicagoStyleClamPizza();\n            } else if (type.equals(\"pepperoni\")) {\n                pizza = new ChicagoStylePepperoniPizza();\n            }\n        } else {\n            System.out.println(\"Error: invalid type of pizza\");\n            return null;\n        }\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n        return pizza;\n    }\n}\n8\n12\nYou can write your \nanswers here:\nnumber\nnumber with \nCalifornia too\nHandles all the \nNY-style pizzas\nHandles all the \nChicago-style pizzas\nLet\u2019s pretend you\u2019ve never heard of an OO factory. Here\u2019s a \u201cvery dependent\u201d \nversion of PizzaStore that doesn\u2019t use a factory. We need for you to make a \ncount of the number of concrete pizza classes this class is dependent on. If \nyou added California-style pizzas to PizzaStore, how many classes would it be \ndependent on then? Here\u2019s our solution.\n", "page": 204, "type": "text", "section": "Page 204"}
{"text": "you are here 4\u2003 \u2003 167\nthe factory pattern\npublic class ChicagoPizzaIngredientFactory \n    implements PizzaIngredientFactory \n{\n    public Dough createDough() {\n        return new ThickCrustDough();\n    }\n    public Sauce createSauce() {\n        return new PlumTomatoSauce();\n    }\n    public Cheese createCheese() {\n        return new MozzarellaCheese();\n    }\n    public Veggies[] createVeggies() {\n        Veggies veggies[] = { new BlackOlives(), \n                              new Spinach(), \n                              new Eggplant() };\n        return veggies;\n    }\n    public Pepperoni createPepperoni() {\n        return new SlicedPepperoni();\n    }\n    public Clams createClam() {\n        return new FrozenClams();\n    }\n}\nGo ahead and write the ChicagoPizzaIngredientFactory; you can reference the \nclasses below in your implementation:\nSlicedPepperoni\nEggPlant\nSpinach\nBlackOlives\nFrozenClams\nPlumTomatoSauce\nMozzarellaCheese\nThickCrustDough\n", "page": 205, "type": "text", "section": "Page 205"}
{"text": "168\u2003 \u2003 Chapter 4\ncrossword puzzle solution\nC\n1\nO\n2\nN\nC\nR\nE\nT\nE\nC\nR\nE\nA\nT\nO\nR\nB\nF\n3\nJ\nS\n4\nU\nB\nC\nL\nA\nS\nS\nE\nM\nS\n5\nC\n6\nR\nE\nA\nT\nO\nR\nR\n7\nE\nG\nG\nI\nA\nN\nO\nI\nT\nL\nM\nC\n8\nO\nN\nC\nR\nE\nT\nE\nF\nA\nC\nT\nO\nR\nY\nP\nO\nL\nI\n9\nM\nP\nL\nE\nM\nE\nN\nT\nA\nT\nI\nO\nN\n10\nE\nP\nY\nF\n11\nA\nC\nT\nO\nR\nY\nM\nE\nT\nH\nO\nD\nS\nA\nS\nT\nC\nC\n12\nH\nI\nC\nA\nG\nO\nS\nT\nY\nL\nE\nY\nT\nT\nL\nO\nP\n13\nI\nZ\nZ\nA\nD\n14\nE\nP\nE\nN\nD\nE\nN\nT\nR\nO\nY\nE\n15\nN\nC\nA\nP\nS\nU\nL\nA\nT\nE\nAcross\n1. In Factory Method, each franchise is a \n______________ [CONCRETECREATOR] \n4. In Factory Method, who decides which class to \ninstantiate? [SUBCLASS] \n6. Role of PizzaStore in Factory Method Pattern \n[CREATOR] \n7. All New York Style Pizzas use this kind of \ncheese [REGGIANO] \n8. In Abstract Factory, each ingredient factory is a \n_____________ [CONCRETEFACTORY] \n9. When you use new, you are programming to an \n___________ [IMPLEMENTATION] \n11. createPizza() is a ______________ (two words) \nDown\n2. We used ______________  in Simple Factory \nand Abstract Factory and inheritance in Factory \nMethod [OBJECTCOMPOSITION] \n3. Abstract Factory creates a ___________ of \nproducts [FAMILY] \n5. Not a REAL factory pattern, but handy \nnonetheless [SIMPLEFACTORY] \n10. Ethan likes this kind of pizza [NYSTYLE] \nDesign Patterns Crossword Solution\nIt\u2019s been a long chapter.  Grab a slice of Pizza and relax while doing this \ncrossword; all of the solution words are from this chapter. Here\u2019s the solution.\n", "page": 206, "type": "text", "section": "Page 206"}
{"text": "this is a new chapter\u2003 \u2003 169\nOur next stop is the Singleton Pattern, our ticket to creating one-\nof-a-kind objects for which there is only one instance, ever. You might \nbe happy to know that of all patterns, the Singleton is the simplest in terms of its class diagram; \nin fact, the diagram holds just a single class! But don\u2019t get too comfortable; despite its simplicity \nfrom a class design perspective, it\u2019s going to require some deep object-oriented thinking in its \nimplementation. So put on that thinking cap, and let\u2019s get going.\n5  the Singleton Pattern\nOne-of-a-Kind Objects\nI tell ya she\u2019s ONE \nOF A KIND. Look at the \nlines, the curves, the body, \nthe headlights!\nYou talkin\u2019 to me or the car?  \nOh, and when can I get my oven \nmitt back?\n", "page": 207, "type": "text", "section": "Page 207"}
{"text": "170\u2003 \u2003 Chapter 5\none and only one\nDeveloper: What use is that?\nGuru: There are many objects we only need one of: thread pools, caches, dialog boxes, objects \nthat handle preferences and registry settings, objects used for logging, and objects that act as \ndevice drivers to devices like printers and graphics cards. In fact, for many of these types of \nobjects, if we were to instantiate more than one we\u2019d run into all sorts of problems like incorrect \nprogram behavior, overuse of resources, or inconsistent results.\nDeveloper: Okay, so maybe there are classes that should only be instantiated once, but do I \nneed a whole chapter for this? Can\u2019t I just do this by convention or by global variables? You know, \nlike in Java, I could do it with a static variable.\nGuru: In many ways, the Singleton Pattern is a convention for ensuring one and only one object \nis instantiated for a given class. If you\u2019ve got a better one, the world would like to hear about it; \nbut remember, like all patterns, the Singleton Pattern is a time-tested method for ensuring only \none object gets created. The Singleton Pattern also gives us a global point of access, just like a \nglobal variable, but without the downsides.\nDeveloper: What downsides?\nGuru: Well, here\u2019s one example: if you assign an object to a global variable, then that object \nmight be created when your application begins. Right? What if this object is resource intensive \nand your application never ends up using it? As you will see, with the Singleton Pattern, we can \ncreate our objects only when they are needed.\nDeveloper: This still doesn\u2019t seem like it should be so difficult.\nGuru: If you\u2019ve got a good handle on static class variables and methods as well as access \nmodifiers, it\u2019s not. But, in either case, it is interesting to see how a Singleton works, and, as \nsimple as it sounds, Singleton code is hard to get right. Just ask yourself: how do I prevent more \nthan one object from being instantiated? It\u2019s not so obvious, is it?\nThat\u2019s one and ONLY \nONE object.\nWhat is this? An \nentire chapter about \nhow to instantiate just \nONE object?\n", "page": 208, "type": "text", "section": "Page 208"}
{"text": "you are here 4\u2003 \u2003 171\nthe singleton pattern\nHow would you create a single object?\nnew MyObject();\nAnd, what if another object wanted to create a \nMyObject? Could it call new on MyObject again?\nYes, of course.\nSo as long as we have a class, can we always \ninstantiate it one or more times?\nYes. Well, only if it\u2019s a public class.\nAnd if not?\nWell, if it\u2019s not a public class, only classes in the \nsame package can instantiate it. But they can still \ninstantiate it more than once.\nHmm, interesting.  \nDid you know you could do this?\nNo, I\u2019d never thought of it, but I guess it makes \nsense because it is a legal definition. \npublic MyClass {\n   private MyClass() {}\n}\nWhat does it mean?\nI suppose it is a class that can\u2019t be instantiated \nbecause it has a private constructor.\nWell, is there ANY object that could use \nthe private constructor?\nHmm, I think the code in MyClass is the only \ncode that could call it. But that doesn\u2019t make \nmuch sense.\nThe Little Singleton\nA small Socratic exercise in the style of The Little Lisper\n", "page": 209, "type": "text", "section": "Page 209"}
{"text": "172\u2003 \u2003 Chapter 5\ncreating a singleton\nWhy not ?\nBecause I\u2019d have to have an instance of the \nclass to call it, but I can\u2019t have an instance \nbecause no other class can instantiate it. It\u2019s \na chicken-and-egg problem: I can use the \nconstructor from an object of type MyClass, \nbut I can never instantiate that object because \nno other object can use \u201cnew MyClass()\u201d.\nOkay.  It was just a thought.\nWhat does this mean?\nMyClass is a class with a static method. We can call \nthe static method like this:\nMyClass.getInstance();\npublic MyClass {\n   public static MyClass getInstance() {\n   }\n}\nWhy did you use MyClass instead of \nsome object name?\nWell, getInstance() is a static method; in other \nwords, it is a CLASS method. You need to use the \nclass name to reference a static method.\nVery interesting. What if we put things together?\npublic MyClass {\n    private MyClass() {}\n    public static MyClass getInstance() {\n        return new MyClass();\n    }\n}\nWow, you sure can.\nNow can I instantiate a MyClass?\nSo, now can you think of a second way to instantiate \nan object?\nMyClass.getInstance();\nCan you finish the code so that only ONE instance \nof MyClass is ever created?\nYes, I think so...\n(You\u2019ll find the code on the next page.)\n", "page": 210, "type": "text", "section": "Page 210"}
{"text": "you are here 4\u2003 \u2003 173\nthe singleton pattern\npublic class Singleton {\n    private static Singleton uniqueInstance;\n \n    // other useful instance variables here\n \n    private Singleton() {}\n \n    public static Singleton getInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n \n    // other useful methods here\n}\nDissecting the classic Singleton \nPattern implementation\nWe have a static \nvariable to hold our \none instance of the \nclass Singleton.\nOur constructor is \ndeclared private; only \nSingleton can instantiate \nthis class!\nThe getInstance() method \ngives us a way to instantiate \nthe class and also to return \nan instance of it.\nOf course, Singleton is a normal \nclass; it has other useful instance \nvariables and methods.\nif (uniqueInstance == null) {\n    uniqueInstance = new Singleton();\n}\nreturn uniqueInstance;\nIf uniqueInstance is null, then we \nhaven\u2019t created the instance yet...\n...and, if it doesn\u2019t exist, we \ninstantiate Singleton through \nits private constructor and \nassign it to uniqueInstance. Note \nthat if we never need the \ninstance, it never gets created; \nthis is lazy instantiation.\nBy the time we hit this code, we \nhave an instance and we return it.\nIf uniqueInstance wasn\u2019t null, \nthen it was previously created. \nWe just fall through to the \nreturn statement.\nCode Up Close\nuniqueInstance holds our ONE \ninstance; remember, it is a \nstatic variable.\nLet\u2019s rename \nMyClass to Singleton.\n\t\n       \n\n\n\n\nIf you\u2019re just \nflipping through \nthe book, don\u2019t \nblindly type in this \ncode; you\u2019ll see it \nhas a few issues \nlater in the chapter.\n", "page": 211, "type": "text", "section": "Page 211"}
{"text": "174\u2003 \u2003 Chapter 5\ninterview with singleton\nHeadFirst:  Today we are pleased to bring you an \ninterview with a Singleton object. Why don\u2019t you \nbegin by telling us a bit about yourself?\nSingleton: Well, I\u2019m totally unique; there is just one \nof me!\nHeadFirst: One?\nSingleton: Yes, one. I\u2019m based on the Singleton \nPattern, which ensures that at any time there is only \none instance of me.\nHeadFirst: Isn\u2019t that sort of a waste? Someone took \nthe time to develop a full-blown class and now all we \ncan get is one object out of it?\nSingleton: Not at all! There is power in ONE. Let\u2019s \nsay you have an object that contains registry settings.  \nYou don\u2019t want multiple copies of that object and its \nvalues running around\u2014that would lead to chaos.  \nBy using an object like me you can ensure that every \nobject in your application is making use of the same \nglobal resource.\nHeadFirst: Tell us more\u2026\nSingleton: Oh, I\u2019m good for all kinds of things.  \nBeing single sometimes has its advantages, you know.\u202f \nI\u2019m often used to manage pools of resources, like \nconnection or thread pools. \nHeadFirst: Still, only one of your kind? That sounds \nlonely.\nSingleton: Because there\u2019s only one of me, I do keep \nbusy, but it would be nice if more developers knew \nme\u2014many developers run into bugs because they have \nmultiple copies of objects floating around they\u2019re not \neven aware of. \nHeadFirst: So, if we may ask, how do you know \nthere is only one of you? Can\u2019t anyone with a new \noperator create a \u201cnew you\u201d?\nSingleton:  Nope! I\u2019m truly unique.\nHeadFirst: Well, do developers swear an oath not to \ninstantiate you more than once?\nSingleton: Of course not. The truth be told\u2026well, \nthis is getting kind of personal but\u2026I have no public \nconstructor.\nHeadFirst: NO PUBLIC CONSTRUCTOR! Oh, \nsorry, no public constructor?\nSingleton: That\u2019s right. My constructor is declared \nprivate.\nHeadFirst: How does that work? How do you EVER \nget instantiated?\nSingleton: You see, to get a hold of a Singleton \nobject, you don\u2019t instantiate one, you just ask for \nan instance. So my class has a static method called \ngetInstance(). Call that, and I\u2019ll show up at once, ready \nto work. In fact, I may already be helping other objects \nwhen you request me.\nHeadFirst: Well, Mr. Singleton, there seems to be a \nlot under your covers to make all this work. Thanks \nfor revealing yourself and we hope to speak with you \nagain soon!\nPatterns Exposed\nThis week\u2019s interview:\nConfessions of a Singleton\n", "page": 212, "type": "text", "section": "Page 212"}
{"text": "you are here 4\u2003 \u2003 175\nthe singleton pattern\npublic class ChocolateBoiler {\n    private boolean empty;\n    private boolean boiled;\n  \n    private ChocolateBoiler() {\n        empty = true;\n        boiled = false;\n    }\n  \n    public void fill() {\n        if (isEmpty()) {\n            empty = false;\n            boiled = false;\n            // fill the boiler with a milk/chocolate mixture\n        }\n    }\n \n    public void drain() {\n        if (!isEmpty() && isBoiled()) {\n            // drain the boiled milk and chocolate\n            empty = true;\n        }\n    }\n \n    public void boil() {\n        if (!isEmpty() && !isBoiled()) {\n            // bring the contents to a boil\n            boiled = true;\n        }\n    }\n  \n    public boolean isEmpty() {\n        return empty;\n    }\n \n    public boolean isBoiled() {\n        return boiled;\n    }\n}\nThe Chocolate Factory\nEveryone knows that all modern chocolate factories have computer-controlled \nchocolate boilers. The job of the boiler is to take in chocolate and milk, bring them \nto a boil, and then pass them on to the next phase of making chocolate bars.\nHere\u2019s the controller class for Choc-O-Holic, Inc.\u2019s industrial strength Chocolate \nBoiler. Check out the code; you\u2019ll notice they\u2019ve tried to be very careful to ensure \nthat bad things don\u2019t happen, like draining 500 gallons of unboiled mixture, or \nfilling the boiler when it\u2019s already full, or boiling an empty boiler!\nThis code is only started \nwhen the boiler is empty!\nT\no fill the boiler it must be \nempty, and, once it\u2019s full, we \nset the empty and boiled flags.\nT\no drain the boiler, it must be full \n(non-empty) and also boiled. Once it is \ndrained, we set empty back to true.\nT\no boil the mixture, the boiler \nhas to be full and not already \nboiled. Once it\u2019s boiled, we set \nthe boiled flag to true.\npublic\n", "page": 213, "type": "text", "section": "Page 213"}
{"text": "176\u2003 \u2003 Chapter 5\nchocolate boiler singleton\npublic class ChocolateBoiler {\n    private boolean empty;\n    private boolean boiled;\n             ChocolateBoiler() {\n        empty = true;\n        boiled = false;\n    }\n    \n    public void fill() {\n        if (isEmpty()) {\n           empty = false;\n           boiled = false;\n           // fill the boiler with a milk/chocolate mixture\n        }\n    }\n    // rest of ChocolateBoiler code...\n}\nChoc-O-Holic has done a decent job of ensuring bad things don\u2019t happen, \ndon\u2019t you think? Then again, you probably suspect that if two ChocolateBoiler \ninstances get loose, some very bad things can happen.\nHow might things go wrong if more than one instance of ChocolateBoiler is \ncreated in an application?\nCan you help Choc-O-Holic improve their ChocolateBoiler class \nby turning it into a Singleton?\n", "page": 214, "type": "text", "section": "Page 214"}
{"text": "you are here 4\u2003 \u2003 177\nthe singleton pattern\nSingleton\nstatic uniqueInstance\n// Other useful Singleton data...\nstatic getInstance()\n// Other useful Singleton methods...\nThe Singleton Pattern ensures a class has only one \ninstance, and provides a global point of access to it.\nSingleton Pattern defined\nNow that you\u2019ve got the classic implementation of Singleton \nin your head, it\u2019s time to sit back, enjoy a bar of chocolate, \nand check out the finer points of the Singleton Pattern.\nLet\u2019s start with the concise definition of the pattern:\nNo big surprises there. But let\u2019s break it down a bit more:\n\u0083\t What\u2019s really going on here? We\u2019re taking a class and letting it manage a single \ninstance of itself. We\u2019re also preventing any other class from creating a new \ninstance on its own. To get an instance, you\u2019ve got to go through the class itself.\n\u0083\t We\u2019re also providing a global access point to the instance: whenever you need \nan instance, just query the class and it will hand you back the single instance. \nAs you\u2019ve seen, we can implement this so that the Singleton is created in a lazy \nmanner, which is especially important for resource-intensive objects.\nOkay, let\u2019s check out the class diagram:\nThe getInstance() method is static, \nwhich means it\u2019s a class method, so you \ncan conveniently access this method \nfrom anywhere in your code using \nSingleton.getInstance(). That\u2019s just as \neasy as accessing a global variable, but \nwe get benefits like lazy instantiation \nfrom the Singleton.\nThe uniqueInstance \nclass variable holds our \none and only instance \nof Singleton.\nA class implementing the Singleton \nPattern is more than a Singleton; it \nis a general-purpose class with its \nown set of data and methods.\n", "page": 215, "type": "text", "section": "Page 215"}
{"text": "178\u2003 \u2003 Chapter 5\nthreads are a problem\nHouston, we have a problem...\nHershey, PA\nIt looks like the Chocolate Boiler has let us down; despite \nthe fact we improved the code using the classic Singleton \nPattern, somehow the Chocolate Boiler\u2019s fill() method was \nable to start filling the boiler even though a batch of milk \nand chocolate was already boiling! That\u2019s 500 gallons of \nspilled milk (and chocolate)! What happened!?\nCould the addition of threads have caused \nthis? Isn\u2019t it the case that once we\u2019ve set the \nuniqueInstance variable to the sole instance \nof ChocolateBoiler, all calls to getInstance() \nshould return the same instance? Right?\nWe don\u2019t know what happened! The new Singleton \ncode was running fine. The only thing we can think \nof is that we just added some optimizations to \nthe Chocolate Boiler Controller that makes use of \nmultiple threads.\n", "page": 216, "type": "text", "section": "Page 216"}
{"text": "you are here 4\u2003 \u2003 179\nthe singleton pattern\nWe have two threads, each executing this code. Your job is to play the JVM \nand determine whether there is a case in which two threads might get a hold \nof different boiler objects. Hint: \nyou really just need to look at the \nsequence of operations in the \ngetInstance() method and \nthe value of uniqueInstance \nto see how they might \noverlap. Use the code \nmagnets to help you study how the \ncode might interleave to create two boiler objects.\nBE the JVM\nif (uniqueInstance == null) {\n}\nThread\nOne\nThread\nTwo\nuniqueInstance = \n    new ChocolateBoiler();\nreturn uniqueInstance;\npublic static ChocolateBoiler\n\t\ngetInstance() {\n}\nChocolateBoiler boiler = \n        ChocolateBoiler.getInstance();\nboiler.fill();\nboiler.boil();\nboiler.drain();\nValue of \nuniqueInstance\nMake sure you check your answer on \npage 188 before continuing!\n", "page": 217, "type": "text", "section": "Page 217"}
{"text": "180\u2003 \u2003 Chapter 5\nmultithreading and singleton\npublic class Singleton {\n    private static Singleton uniqueInstance;\n \n    // other useful instance variables here\n \n    private Singleton() {}\n \n    public static synchronized Singleton getInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n \n    // other useful methods here\n}\nDealing with multithreading\nOur multithreading woes are almost trivially fixed by making \ngetInstance() a synchronized method:\nBy adding the synchronized keyword to \ngetInstance(), we force every thread to \nwait its turn before it can enter the \nmethod. That is, no two threads may \nenter the method at the same time.\nGood point, and it\u2019s actually a little worse than you make \nout: the only time synchronization is relevant is the first time \nthrough this method. In other words, once we\u2019ve set the \nuniqueInstance variable to an instance of Singleton, we have \nno further need to synchronize this method. After the first time \nthrough, synchronization is totally unneeded overhead!\nI agree this fixes the \nproblem. But synchronization \nis expensive; is this an issue?\n", "page": 218, "type": "text", "section": "Page 218"}
{"text": "you are here 4\u2003 \u2003 181\nthe singleton pattern\npublic class Singleton {\n    private static Singleton uniqueInstance = new Singleton();\n \n    private Singleton() {}\n \n    public static Singleton getInstance() {\n        return uniqueInstance;\n    }\n}\nUsing this approach, we rely on the JVM to create the unique instance of the Singleton \nwhen the class is loaded. The JVM guarantees that the instance will be created before \nany thread accesses the static uniqueInstance variable. \nCan we improve multithreading?\nFor most Java applications, we obviously need to ensure that the Singleton works in the \npresence of multiple threads. But it\u2019s expensive to synchronize the getInstance() method,  \nso what do we do?\nWell, we have a few options...\n1.  Do nothing if the performance of getInstance() isn\u2019t critical \nto your application. \nThat\u2019s right; if calling the getInstance() method isn\u2019t causing substantial overhead for your \napplication, forget about it. Synchronizing getInstance() is straightforward and effective. \nJust keep in mind that synchronizing a method can decrease performance by a factor \nof 100, so if a high-traffic part of your code begins using getInstance(), you may have to \nreconsider.\n2.  Move to an eagerly created instance rather than a lazily \ncreated one.\nIf your application always creates and uses an instance of the Singleton, or the overhead \nof creation and runtime aspects of the Singleton isn\u2019t onerous, you may want to create \nyour Singleton eagerly, like this:\nGo ahead and create an \ninstance of Singleton \nin a static initializer.  \nThis code is guaranteed \nto be thread safe!\nWe\u2019ve already got an \ninstance, so just return it.\n", "page": 219, "type": "text", "section": "Page 219"}
{"text": "182\u2003 \u2003 Chapter 5\ndouble-checked locking\npublic class Singleton {\n    private volatile static Singleton uniqueInstance;\n \n    private Singleton() {}\n \n    public static Singleton getInstance() {\n        if (uniqueInstance == null) {\n            synchronized (Singleton.class) {\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\nCheck for an instance and \nif there isn\u2019t one, enter a \nsynchronized block.\nOnce in the block, check again and \nif it\u2019s still null, create an instance.\nNote we only synchronize \nthe first time through!\nThe volatile keyword ensures that multiple threads \nhandle the uniqueInstance variable correctly when it \nis being initialized to the Singleton instance.\nIf performance is an issue in your use of the getInstance() method, then this method of \nimplementing the Singleton can drastically reduce the overhead.\n3.   Use  \u201c\ndouble-checked locking\u201d to reduce the use of \nsynchronization in getInstance().\nWith double-checked locking, we first check to see if an instance is created, and if not, THEN \nwe synchronize. This way, we only synchronize the first time through, just what we want.\nLet\u2019s check out the code:\n\t\n       Double-checked locking doesn\u2019t work in \nJava 1.4 or earlier!\nIf for some reason you\u2019re using an old version \nof Java, unfortunately, in Java version 1.4 and \nearlier, many JVMs contain implementations of \nthe volatile keyword that allow improper synchronization for \ndouble-checked locking. If you must use a JVM earlier than Java \n5, consider other methods of implementing your Singleton.\n", "page": 220, "type": "text", "section": "Page 220"}
{"text": "you are here 4\u2003 \u2003 183\nthe singleton pattern\nMeanwhile, back at the Chocolate Factory...\nWhile we\u2019ve been off diagnosing the multithreading problems, the chocolate boiler \nhas been cleaned up and is ready to go. But first, we have to fix the multithreading \nproblems. We have a few solutions at hand, each with different tradeoffs, so which \nsolution are we going to employ?\nAt this point, the Chocolate Factory is a happy customer and Choc-O-Holic was glad to \nhave some expertise applied to their boiler code. No matter which multithreading solution \nyou applied, the boiler should be in good shape with no more mishaps. Congratulations\u2014\nnot only have you managed to escape 500 lbs of hot chocolate in this chapter, but you\u2019ve \nalso been through all the potential problems of the Singleton Pattern. \nCongratulations!\nFor each solution, describe its applicability to the \nproblem of fixing the Chocolate Boiler code:\nSynchronize the getInstance() method:\nUse eager instantiation:\nDouble-checked locking:\n", "page": 221, "type": "text", "section": "Page 221"}
{"text": "184\u2003 \u2003 Chapter 5\nq&a about singleton\nQ: For such a simple pattern \nconsisting of only one class, Singleton \nsure seems to have some problems.\nA: Well, we warned you up front! But \ndon\u2019t let the problems discourage you; while \nimplementing Singletons correctly can be \ntricky, after reading this chapter you\u2019re now \nwell informed on the techniques for creating \nSingletons and should use them wherever \nyou need to control the number of instances \nyou\u2019re creating.\nQ: Can\u2019t I just create a class in which \nall methods and variables are defined as \nstatic? Wouldn\u2019t that be the same as a \nSingleton?\nA: Yes, if your class is self-contained and \ndoesn\u2019t depend on complex initialization. \nHowever, because of the way static \ninitializations are handled in Java, this can \nget very messy, especially if multiple classes \nare involved. Often this scenario can result \nin subtle, hard-to-find bugs involving order \nof initialization. Unless there is a compelling \nneed to implement your \u201csingleton\u201d this way, \nit\u2019s far better to stay in the object world.\nQ: What about class loaders? I \nheard there\u2019s a chance that two class \nloaders could each end up with their own \ninstance of Singleton.\nA: Yes, that is true as each class loader \ndefines a namespace. If you have two or \nmore class loaders, you can load the same \nclass multiple times (once in each class \nloader). Now, if that class happens to be a \nSingleton, then since we have more than \none version of the class, we also have more \nthan one instance of Singleton. So, if you are \nusing multiple class loaders and Singletons, \nbe careful. One way around this problem is \nto specify the class loader yourself.\n Q: And reflection, and serialization/\ndeserialization? \nA: Yes, reflection and serialization/\ndeserialization can also present problems \nwith Singletons. If you\u2019re an advanced Java \nuser using reflection, serialization, and \ndeserialization, you\u2019ll need to keep that in mind.\nQ: Earlier we talked about the loose \ncoupling principle. Isn\u2019t a Singleton \nviolating this? After all, every object in \nour code that depends on the Singleton \nis going to be tightly coupled to that very \nspecific object. \nA: Yes, and in fact this is a common \ncriticism of the Singleton Pattern. The \nloose coupling principle says to \u201cstrive for \nloosely coupled designs between objects \nthat interact.\u201d It\u2019s easy for Singletons to \nviolate this principle: if you make a change \nto the Singleton, you\u2019ll likely have to make a \nchange to every object connected to it. \n\nQ: I\u2019ve always been taught that a class \nshould do one thing and one thing only.  \nFor a class to do two things is considered \nbad OO design. Isn\u2019t a Singleton violating \nthis too? \n\nA: You would be referring to the Single \nResponsibility Principle, and yes, you are \ncorrect: the Singleton is responsible not only \nfor managing its one instance (and providing \nglobal access), but also for whatever \nits main role is in your application. So, \ncertainly you could argue it is taking on two \nresponsibilities. Nevertheless, it isn\u2019t hard to \nsee that there is utility in a class managing \nits own instance; it certainly makes the \noverall design simpler. In addition, many \ndevelopers are familiar with the Singleton \nPattern as it is in wide use. That said, some \ndevelopers do feel the need to abstract out \nthe Singleton functionality.\nQ: I wanted to subclass my Singleton \ncode, but I ran into problems. Is it okay to \nsubclass a Singleton?\nA: One problem with subclassing a \nSingleton is that the constructor is private.  \nYou can\u2019t extend a class with a private \nconstructor. So, the first thing you\u2019ll have \nto do is change your constructor so that it\u2019s \npublic or protected. But then, it\u2019s not really a \nSingleton anymore, because other classes \ncan instantiate it.\n\nIf you do change your constructor, there\u2019s \nanother issue. The implementation of \nSingleton is based on a static variable, so \nif you do a straightforward subclass, all of \nyour derived classes will share the same \ninstance variable. This is probably not what \nyou had in mind. So, for subclassing to work, \nimplementing a registry of sorts is required \nin the base class.  \n\nBut what are you really gaining from \nsubclassing a Singleton? Like most patterns, \nSingleton is not necessarily meant to be a \nsolution that can fit into a library. In addition, \nthe Singleton code is trivial to add to any \nexisting class. Last, if you are using a large \nnumber of Singletons in your application, \nyou should take a hard look at your design. \nSingletons are meant to be used sparingly.\nQ: I still don\u2019t totally understand \nwhy global variables are worse than a \nSingleton.\nA: In Java, global variables are basically \nstatic references to objects. There are a \ncouple of disadvantages to using global \nvariables in this manner. We\u2019ve already \nmentioned one: the issue of lazy versus \neager instantiation. But we need to keep \nin mind the intent of the pattern: to ensure \nonly one instance of a class exists and to \nprovide global access. A global variable can \nprovide the latter, but not the former. Global \nvariables also tend to encourage developers \nto pollute the namespace with lots of global \nreferences to small objects. Singletons don\u2019t \nencourage this in the same way, but can be \nabused nonetheless.\n", "page": 222, "type": "text", "section": "Page 222"}
{"text": "you are here 4\u2003 \u2003 185\nthe singleton pattern\nI just realized...I think we can \nsolve a lot of the problems with \nSingleton by using an enum. Is \nthat right?\nAh, good idea!\nMany of the problems we\u2019ve discussed\u2014worrying about \nsynchronization, class loading issues, reflection, and serialization/\ndeserialization issues\u2014can all be solved by using an enum to create \nyour Singleton. Here\u2019s how you\u2019d do that:\npublic enum Singleton {\n    UNIQUE_INSTANCE;\n    // more useful fields here\n}\npublic class SingletonClient {\n\t\npublic static void main(String[] args) {\n\t\n\t\nSingleton singleton = Singleton.UNIQUE_INSTANCE;\n\t\n\t\n// use the singleton here\n\t\n}\n}\nYep, that\u2019s all there is to it. Simplest Singleton ever, right? Now, you \nmight be asking, why did we go through all that earlier with creating \na Singleton class with a getInstance() method and then synchronizing, \nand so on? We did that so you really, truly understand how Singleton \nworks. Now that you know, you can go off and use enum whenever \nyou need a Singleton, and still be able to ace that Java interview if \nthe question pops up: \u201cHow do you implement a Singleton without \nusing enum?\u201d \nCan you rework Choc-O-Holic to use an enum? Give it a try. \nAnd back in the old days, \nwhen we had to walk to \nschool, uphill, in the snow, in \nboth directions, Java didn\u2019t \nhave enums.\n", "page": 223, "type": "text", "section": "Page 223"}
{"text": "186\u2003 \u2003 Chapter 5\nyour design toolbox\nTools for your Design Toolbox\nYou\u2019ve now added another pattern to your toolbox.  \nSingleton gives you another method of creating \nobjects\u2014in this case, unique objects.\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies.\nFavor composition over inheritance.\nProgram to interfaces, not \nimplementations.\nStrive for loosely coupled designs \nbetween objects that interact.\nClasses should be open for extension \nbut closed for modification.\nDepend on abstractions. Do not \ndepend on concrete classes.\nOO Principles\nAs you\u2019ve seen, despite its apparent simplicity, there are a lot of details \ninvolved in Singleton\u2019s implementation. After reading this chapter, \nthough, you\u2019re ready to go out and use Singleton in the wild.\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable.  Strategy lets the algorithm \nvary independently from clients that use it.\nOO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically.  \nDecorators provide a flexible \nalternative to subclassing for extending \nfunctionality.\nAbstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes.\nFactory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate.  Factory Method lets \na class defer instantiation to the \nsubclasses.\nSingleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it.\nWhen you need to ensure you \nonly have one instance of a class \nrunning around your application, \nturn to the Singleton. \n\t\n\u0083\nThe Singleton Pattern \nensures you have at most \none instance of a class in \nyour application.\n\t\n\u0083\nThe Singleton Pattern also \nprovides a global access \npoint to that instance.\n\t\n\u0083\nJava\u2019s implementation \nof the Singleton Pattern \nmakes use of a private \nconstructor, a static \nmethod combined with a \nstatic variable.\n\t\n\u0083\nExamine your performance \nand resource constraints \nand carefully choose an \nappropriate Singleton \nimplementation for  \nmultithreaded applications \n(and we should \nconsider all applications \nmultithreaded!).\n\t\n\u0083\nBeware of the double-\nchecked locking \nimplementation; it isn\u2019t \nthread safe in versions \nbefore Java 5.\n\t\n\u0083\nBe careful if you are using \nmultiple class loaders; this \ncould defeat the Singleton \nimplementation and result \nin multiple instances.\n\t\n\u0083\nYou can use Java\u2019s enums \nto simplify your Singleton \nimplementation.\n", "page": 224, "type": "text", "section": "Page 224"}
{"text": "you are here 4\u2003 \u2003 187\nthe singleton pattern\nDesign Patterns Crossword\nSit back, open that case of chocolate that you were sent for solving the \nmultithreading problem, and have some downtime working on this \nlittle crossword puzzle; all of the solution words are from this chapter.\nACROSS\n3. Company that produces boilers. \n6. An incorrect implementation caused this to overflow.\n7. The Singleton Pattern has one.\n10. To totally defeat the new constructor, we have to \ndeclare the constructor __________.\n12. The classic implementation doesn\u2019t handle this.\n13. Singleton provides a single instance and __________ \n(three words).\n14. An easy way to create Singletons in Java.\n15. The Singleton was embarrassed it had no public \n__________. \n16. A Singleton is a class that manages an instance of \n________.\nDOWN\n1. Added to chocolate in the boiler.\n2. Flawed multithreading approach if not using Java 5 or \nlater (two words).\n3. It was \u201cone of a kind.\u201d\n4. Multiple __________ can cause problems (two words).\n5. If you don\u2019t need to worry about lazy instantiation, you \ncan create your instance __________.\n8. One advantage over global variables: ________ \ncreation.\n9. Chocolate capital of the USA.\n11. Singleton ensures only one of these exists.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nAcross\n3. Company that produces boilers\n6. An incorrect implementation caused this to \noverflow\n7. The Singleton Pattern has one\n10. To totally defeat the new constructor, we \nhave to declare the constructor ________\n12. The classic implementation doesn't handle \nthis\n13. Singleton provides a single instance and \n(three words)\n14. An easy way to create Singletons in Java\n15. The Singleton was embarassed it had no \npublic ____________\n16. A Singleton is a class that manages an \nDown\n1. Added to chocolate in the boiler\n2. Flawed multithreading approach if not using \nJava 5 or later (two words)\n3. It was \"one of a kind\"\n4. Multiple __________ can cause problems \n(two words)\n5. If you don't need to worry about lazy \ninstantiation, you can create your instance \n________\n8. One advantage over global variables: \n_______ creation\n9. Chocolate capital of the US\n11. Singleton ensures only one of these exist\n", "page": 225, "type": "text", "section": "Page 225"}
{"text": "188\u2003 \u2003 Chapter 5\nexercise solutions\nThead\nOne\nThead\nTwo\nValue of \nuniqueInstance\nif (uniqueInstance == null) {\nuniqueInstance = \n    new ChocolateBoiler();\npublic static ChocolateBoiler\n\t\ngetInstance() {\npublic static ChocolateBoiler\n\t\ngetInstance() {\nif (uniqueInstance == null) {\nuniqueInstance = \n    new ChocolateBoiler();\nreturn uniqueInstance;\nreturn uniqueInstance;\nnull\nnull\nnull\n<object1>\n<object2>\n<object2>\n<object1>\nTwo different \nobjects are \nreturned! \nWe have two \nChocolateBoiler \ninstances!!!\nUh oh, this \ndoesn\u2019t look \ngood!\nBE the JVM Solution\n", "page": 226, "type": "text", "section": "Page 226"}
{"text": "you are here 4\u2003 \u2003 189\nthe singleton pattern\npublic class ChocolateBoiler {\n    private boolean empty;\n    private boolean boiled;\n    private static ChocolateBoiler uniqueInstance;\n    private ChocolateBoiler() {\n        empty = true;\n        boiled = false;\n    }\n    public static ChocolateBoiler getInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new ChocolateBoiler();\n        }\n        return uniqueInstance;\n    }\n    public void fill() {\n        if (isEmpty()) {\n            empty = false;\n            boiled = false;\n            // fill the boiler with a milk/chocolate mixture\n        }\n    }\n   // rest of ChocolateBoiler code...\n}\nCan you help Choc-O-Holic improve their ChocolateBoiler class \nby turning it into a Singleton?\n", "page": 227, "type": "text", "section": "Page 227"}
{"text": "190\u2003 \u2003 Chapter 5\nexercise solutions\nDesign \nPatterns \nCrossword \nSolution\nFor each solution, describe its applicability to the \nproblem of fixing the Chocolate Boiler code:\nSynchronize the getInstance() method:\nUse eager instantiation:\nDouble-checked locking:\nA straightforward technique that is guaranteed to work. We don\u2019t seem to have \nany performance concerns with the chocolate boiler, so this would be a good choice.\nWe are always going to instantiate the chocolate boiler in our code, so statically initializing \nthe instance would cause no concerns. This solution would work as well as the synchronized \nmethod, although perhaps be less obvious to a developer familar with the standard pattern.\nGiven we have no performance concerns, double-checked locking seems like overkill.  In \naddition, we\u2019d have to ensure that we are running at least Java 5.\nM\n1\nD\n2\nI\nO\nC\n3\nH\nO\nC\n-\nO\n-\nH\nO\nL\nI\nC\n4\nU\nA\nK\nL\nS\n5\nB\n6\nO\nI\nL\nE\nR\nR\nA\nT\nL\nC\n7\nL\nA\nS\nS\nA\nE\nL\n8\nS\nT\nC\nH\n9\nP\n10\nR\nI\n11\nV\nA\nT\nE\nM\n12\nU\nL\nT\nI\nT\nH\nR\nE\nA\nD\nI\nN\nG\nN\nZ\nO\nC\nE\nR\nS\nY\nG\n13\nL\nO\nB\nA\nL\nA\nC\nC\nE\nS\nS\nP\nO\nI\nN\nT\nT\nD\nL\nK\nH\nA\nE\nL\nE\nE\n14\nN\nU\nM\nC\n15\nO\nN\nS\nT\nR\nU\nC\nT\nO\nR\nY\nD\nY\nC\nS\nI\n16\nT\nS\nE\nL\nF\nAcross\n3. Company that produces boilers [CHOC-O-\nDown\n1. Added to chocolate in the boiler [MILK] \n", "page": 228, "type": "text", "section": "Page 228"}
{"text": "this is a new chapter\u2003 \u2003 191\nIn this chapter, we take encapsulation to a whole new level: \nwe\u2019re going to encapsulate method invocation. That\u2019s right\u2014by \nencapsulating method invocation, we can crystallize pieces of computation so that \nthe object invoking the computation doesn\u2019t need to worry about how to do things, it \njust uses our crystallized method to get it done. We can also do some wickedly smart \nthings with these encapsulated method invocations, like save them away for logging \nor reuse them to implement undo functionality in our code. \nEncapsulating Invocation \n \n \n \n \n \n \n \n \n \n6  the Command Pattern\nThese top secret drop \nboxes have revolutionized the spy \nindustry. I just drop in my request and \npeople disappear, governments change \novernight, and my dry cleaning gets done. I \ndon\u2019t have to worry about when, where, or \nhow; it just happens!\n", "page": 229, "type": "text", "section": "Page 229"}
{"text": "192\u2003 \u2003 Chapter 6\nhome automation or bust\nHome Automation or Bust, Inc.\n1221 Industrial Avenue, Suite 2000\nFuture City, IL 62914\nGreetings!\nI recently received a demo and briefing from Johnny \nHurricane, CEO of Weather-O-Rama, on their new \nexpandable weather station. I have to say, I was so \nimpressed with the software architecture that I\u2019d like to \nask you to design the API for our new Home Automation \nRemote Control. In return for your services we\u2019d be happy \nto handsomely reward you with stock options in Home \nAutomation or Bust, Inc.\nYou should have already received a prototype of our \nground-breaking remote control for your perusal. The \nremote control features seven programmable slots (each \ncan be assigned to a  different household device) along with \ncorresponding on/off buttons for each. The remote also has \na global undo button.   \nI\u2019m also attaching to this email a set of  Java classes \nthat were created by various vendors to control home \nautomation devices such as lights, fans, hot tubs, audio \nequipment, and other similar controllable appliances. \nWe\u2019d like you to create an API for programming the remote \nso that each slot can be assigned to control a device or set of \ndevices. Note that it is important that we be able to control \nall the current devices, and also any future devices that the \nvendors may supply.\nGiven the work you did on the Weather-O-Rama weather \nstation, we know you\u2019ll do a great job on our remote control!\nWe look forward to seeing your design.\nSincerely,\nBill Thompson, CEO\n", "page": 230, "type": "text", "section": "Page 230"}
{"text": "you are here 4\u2003 \u2003 193\nthe command pattern\nThere are on and off \nbuttons for each of \nthe seven slots.\n We\u2019ve got seven slots to program.  We \ncan put a different device in each \nslot and control it via the buttons.\nHere\u2019s the global undo button that \nundoes the operation of the last \nbutton pressed.\nThese two buttons are \nused to control the \nhousehold device stored \nin slot one...\n...and these two control \nthe household device \nstored in slot two...\n...and so on.\nFree hardware! Let\u2019s check out the Remote Control...\nGet your Sharpie out and \nwrite your device names here.\n", "page": 231, "type": "text", "section": "Page 231"}
{"text": "194\u2003 \u2003 Chapter 6\nvendor classes from home automation\nTaking a look at the vendor classes\nLet\u2019s check out the vendor classes the CEO attached to his email. \nThese should give you some idea of the interfaces of the objects \nwe need to control from the remote.\nCeilingLight\non()\noff()\ndim()\nHottub\ncirculate()\njetsOn()\njetsOff()\nsetTemperature()\non()\noff()\nsetInputChannel()\nsetVolume()\nTV\nOutdoorLight\non()\noff()\nGarageDoor\nup()\ndown()\nstop()\nlightOn()\nlightOff()\nStereo\non()\noff()\nsetCd()\nsetDvd()\nsetRadio()\nsetVolume()\nFaucetControl\nopenValve()\ncloseValve()\nThermostat\nsetTemperature()\n()\nGardenLight\nsetDuskTime()\nsetDawnTime()\nmanualOn()\nmanualOff()\nCeilingFan\nhigh()\nmedium()\nlow()\noff()\ngetSpeed()\nApplianceControl\non()\noff()\nSecurityControl\narm()\ndisarm()\nSprinkler\nwaterOn()\nwaterOff()\nLight\non()\noff()\nIt looks like we have quite a set of classes here, and not a lot of \nindustry effort to come up with a set of common interfaces. Not \nonly that, it sounds like we can expect more of these classes in the \nfuture. Designing a remote control API is going to be interesting.  \nLet\u2019s get on to the design.\nWow, lots of different kinds \nof devices that we\u2019re going \nto need to be able to control.\nAnd some very different \nkinds of interfaces across \nthese devices.\n", "page": 232, "type": "text", "section": "Page 232"}
{"text": "you are here 4\u2003 \u2003 195\nthe command pattern\nMary: Yes, I thought we\u2019d see a bunch of classes with on() and off() \nmethods, but here we\u2019ve got methods like dim(), setTemperature(), \nsetVolume(), and setInputChannel(), and waterOn().\nSue: Not only that, it sounds like we can expect more vendor classes in \nthe future with methods just as diverse.\nMary: I think it\u2019s important we view this as a separation of concerns.\nSue: Meaning?\nMary: What I mean is that the remote should know how to interpret \nbutton presses and make requests, but it shouldn\u2019t know a lot about \nhome automation or how to turn on a hot tub.\nSue: But if the remote is dumb and just knows how to make generic \nrequests, how do we design the remote so that it can invoke an action \nthat, say, turns on a light or opens a garage door?\nMary: I\u2019m not sure, but we don\u2019t want the remote to have to know the \nspecifics of the vendor classes.\nSue: What do you mean?\nMary: We don\u2019t want the remote to consist of a set of if statements, \nlike \u201cif slot1 == Light, then light.on(), else if slot1 == Hottub then \nhottub.jetsOn()\u201d. We know that is a bad design.\nSue: I agree. Whenever a new vendor class comes out, we\u2019d have to go \nin and modify the code, potentially creating bugs and more work for \nourselves!\nCubicle Conversation\nSue\nYour teammates are already discussing how to design the remote control API...\nWell, we\u2019ve got another design to \ndo. My first observation is that we\u2019ve \ngot a simple remote with on and off \nbuttons but a set of vendor classes \nthat are quite diverse.\n", "page": 233, "type": "text", "section": "Page 233"}
{"text": "196\u2003 \u2003 Chapter 6\ncommand pattern might work\nMary: Yeah? Tell us more.\nJoe: The Command Pattern allows you to decouple the requester of an action from \nthe object that actually performs the action. So, here the requester would be the remote \ncontrol and the object that performs the action would be an instance of one of your \nvendor classes.\nSue: How is that possible? How can we decouple them? After all, when I press a button, \nthe remote has to turn on a light.\nJoe: You can do that by introducing command objects into your design. A command object \nencapsulates a request to do something (like turn on a light) on a specific object (say, the \nliving room light object). So, if we store a command object for each button, when the \nbutton is pressed we ask the command object to do some work. The remote doesn\u2019t have \nany idea what the work is, it just has a command object that knows how to talk to the right \nobject to get the work done. So, you see, the remote is decoupled from the light object!\nSue: This certainly sounds like it\u2019s going in the right direction.\nMary: Still, I\u2019m having a hard time wrapping my head around the pattern.\nJoe: Given that the objects are so decoupled, it\u2019s a little difficult to picture how the pattern \nactually works.\nMary: Let me see if I at least have the right idea: using this pattern, we could create \nan API in which these command objects can be loaded into button slots, allowing the \nremote code to stay very simple. And the command objects encapsulate how to do a home \nautomation task along with the object that needs to do it.\nJoe: Yes, I think so. I also think this pattern can help you with that undo button, but I \nhaven\u2019t studied that part yet.\nMary: This sounds really encouraging, but I think I have a bit of work to do to really \n\u201cget\u201d the pattern.\nSue: Me too.\nHey, I couldn\u2019t help \noverhearing. Since Chapter 1 \nI\u2019ve been boning up on Design \nPatterns. There\u2019s a pattern \ncalled \u201cCommand Pattern\u201d I think \nmight help.\nJoe\n", "page": 234, "type": "text", "section": "Page 234"}
{"text": "you are here 4\u2003 \u2003 197\nthe command pattern\nMeanwhile, back at the Diner..., \nor, \nA brief introduction to the Command Pattern\nOkay, we all know how the Diner operates:\nYou, the Customer, \ngive the Waitress \nyour Order.\n1\nThe Waitress \ntakes the Order, \nplaces it on the \norder counter, \nand says \u201cOrder \nup!\u201d\nThe Short-Order Cook prepares your meal \nfrom the Order.\nAs Joe said, it is a little hard to understand the Command Pattern by just hearing its \ndescription. But don\u2019t fear, we have some friends ready to help: remember \nour friendly diner from Chapter 1? It\u2019s been a while since we visited Alice, \nFlo, and the short-order cook, but we\u2019ve got good reason for returning \n(beyond the food and great conversation): the diner is going to help us \nunderstand the Command Pattern. \nSo, let\u2019s take a short detour back to the diner and study the interactions \nbetween the customers, the waitress, the orders, and the short-order \ncook. Through these interactions, you\u2019re going to understand the \nobjects involved in the Command Pattern and also get a feel for how the \ndecoupling works. After that, we\u2019re going to knock out that remote control \nAPI.\nChecking in at the Objectville Diner...\n2\n3\nObjectville Diner\nWish you were here...\nBurger with Cheese\n  Malt Shake\n", "page": 235, "type": "text", "section": "Page 235"}
{"text": "198\u2003 \u2003 Chapter 6\nthe diner\nBurger with Cheese\n  Malt Shake\ncreateOrder()\ntakeOrder()\nBurger with Cheese\n  Malt Shake\norderUp()\nmakeBurger(), makeShake()\noutput\nThe Order consists of an rder \nSlip and the Customer\u2019s menu \nitems that are written on it.\nThe Customer knows \nwhat he wants and \ncreates an Order.\nThe Waitress takes the Order, and when she \ngets around to it, she calls its orderUp() \nmethod to begin the Order\u2019s preparation.\nThe Order has all \nthe instructions \nneeded to \nprepare the \nmeal. The Order \ndirects the \nShort-Order \nCook with \nmethods like \nmakeBurger().\nThe Short-Order \nCook follows the \ninstructions of the \nOrder and produces \nthe meal.\nLet\u2019s study the interaction in a little more detail...\n...and given this Diner is in Objectville, let\u2019s think about \nthe object and method calls involved, too!\nStart Here\nI\u2019ll have a Burger \nwith Cheese and a \nMalt Shake.\n", "page": 236, "type": "text", "section": "Page 236"}
{"text": "you are here 4\u2003 \u2003 199\nthe command pattern\nThe Objectville Diner roles and responsibilities\nAn Order Slip encapsulates a request to prepare a meal.\nThink of the Order Slip as an object that acts as a \nrequest to prepare a meal.  Like any object, it can be passed \naround\u2014from the Waitress to the order counter, or to the next \nWaitress taking over her shift. It has an interface that consists \nof only one method, orderUp(), that encapsulates the actions \nneeded to prepare the meal. It also has a reference to the object \nthat needs to prepare it (in our case, the Short-Order Cook). It\u2019s \nencapsulated in that the Waitress doesn\u2019t have to know what\u2019s in \nthe Order or even who prepares the meal; she only needs to pass \nthe slip through the order window and call \u201cOrder up!\u201d\nOkay, in real life a waitress would probably \ncare what is on the order slip and who cooks \nit, but this is Objectville...work with us here!\npublic void orderUp() {\n    cook.makeBurger();\n    cook.makeShake();\n}\nThe Waitress\u2019s job is to take Order Slips and \ninvoke the orderUp() method on them.\nThe Waitress has it easy: take an Order from the Customer, \ncontinue helping customers until she makes it back to the \norder counter, and then invoke the orderUp() method to have \nthe meal prepared.  As we\u2019ve already discussed, in Objectville, the \nWaitress really isn\u2019t worried about what\u2019s on the Order or who is going \nto prepare it; she just knows Order Slips have an orderUp() method she \ncan call to get the job done.\nNow, throughout the day, the Waitress\u2019s takeOrder() method gets \nparameterized with different Order Slips from different customers, but \nthat doesn\u2019t faze her; she knows all Order Slips support the orderUp() \nmethod and she can call orderUp() any time she needs a meal prepared.\nThe Short-Order Cook has the knowledge \nrequired to prepare the meal.\nThe Short-Order Cook is the object that really knows \nhow to prepare meals. Once the Waitress has invoked \nthe orderUp() method; the Short-Order Cook takes over and \nimplements all the methods that are needed to create meals. \nNotice the Waitress and the Cook are totally decoupled: the \nWaitress has Order Slips that encapsulate the details of the \nmeal; she just calls a method on each Order to get it prepared. \nLikewise, the Cook gets his instructions from the Order Slip; he \nnever needs to directly communicate with the Waitress.\nDon\u2019t ask me to cook, \nI just take orders and \nyell \u201cOrder up!\u201d\nYou can definitely \nsay the Waitress and I \nare decoupled. She\u2019s not \neven my type!\n", "page": 237, "type": "text", "section": "Page 237"}
{"text": "200\u2003 \u2003 Chapter 6\nthe diner is a model for command pattern\nPatience, we\u2019re getting there...  \nThink of the Diner as a model for an OO design pattern that allows \nus to separate an object making a request from the objects that receive \nand execute those requests. For instance, in our remote control API, \nwe need to separate the code that gets invoked when we press a button \nfrom the objects of the vendor-specific classes that carry out those \nrequests. What if each slot of the remote held an object like the Diner\u2019s \nOrder Slip object? Then, when a button is pressed, we could just call \nthe equivalent of the orderUp() method on this object and have the \nlights turn on without the remote knowing the details of how to make \nthose things happen or what objects are making them happen.\nNow, let\u2019s switch gears a bit and map all this Diner talk to the \nCommand Pattern...\nOkay, we have a Diner with \na Waitress who is decoupled \nfrom the Short-Order Cook \nby an Order Slip, so what? \nGet to the point!\nBefore we move on, spend some time studying \nthe diagram two pages back along with Diner \nroles and responsibilities until you think you\u2019ve \ngot a handle on the Objectville Diner objects and \nrelationships. Once you\u2019ve done that, get ready \nto nail the Command Pattern!\n", "page": 238, "type": "text", "section": "Page 238"}
{"text": "you are here 4\u2003 \u2003 201\nthe command pattern\ncreateCommandObject()\nsetCommand()\nexecute()\naction1(), action2()\nThe Client is responsible for \ncreating the Command object.  \nThe command object consists of \na set of actions on a Receiver.\nThe Client calls setCommand() on \nan Invoker object and passes it the \nCommand object, where it gets \nstored until it is needed.\nAt some point in the future \nthe Invoker calls the Command \nobject\u2019s execute() method...\n...which results \nin the actions \nbeing invoked \non the Receiver.\n \n \n \n \n \n \n \n \n \n \nR\ne\nc\ne\ni\nv\ne\nr\n \n \n \n \n \nC\no\nm\nma\nn\nd\nexecute()\n \n \nI\nn\nv\no\nke\nr\nsetCommand()\naction1()\naction2()\n     ...\n \n \n \n \n \n \n \n \n \n \n \nC\nl\ni\nent\ncreate\nCommand\nObject()\n \n \n \n \n \nC\no\nm\nma\nn\nd\nexecute()\n \n \n \n \n \n \n \n \n \n \nR\ne\nc\ne\ni\nv\ne\nr\naction1()\naction2()\n     ...\npublic void execute {\n    receiver.action1();\n    receiver.action2();\n}\nThe Command object provides \none method, execute(), that \nencapsulates the actions and \ncan be called to invoke the \nactions on the Receiver.\nThe actions and the Receiver \nare bound together in the \ncommand object.\nFrom the Diner to the Command Pattern\nOkay, we\u2019ve spent enough time in the Objectville Diner that we know all the \npersonalities and their responsibilities quite well. Now we\u2019re going to rework \nthe Diner diagram to reflect the Command Pattern. You\u2019ll see that all the \nplayers are the same; only the names have changed.  \nStart Here\n1\n2\n3\nThe client creates a \ncommand object.\nThe client does a \nsetCommand() to store \nthe command object in \nthe invoker.\nLater...the client asks \nthe invoker to execute \nthe command. Note: \nas you\u2019ll see later in \nthe chapter, once the \ncommand is loaded into \nthe invoker, it may be \nused and discarded, or it \nmay remain and be used \nmany times.\n1\n2\n3\nLoading the Invoker\n", "page": 239, "type": "text", "section": "Page 239"}
{"text": "202\u2003 \u2003 Chapter 6\nwho does what\nMatch the diner objects and methods with the corresponding names from the \nCommand Pattern.\nDiner\nCommand Pattern\nWaitress\nShort-Order Cook\norderUp()\nOrder\nCustomer\ntakeOrder()\nCommand \nexecute()\nClient\nInvoker\nReceiver\nsetCommand()\n", "page": 240, "type": "text", "section": "Page 240"}
{"text": "you are here 4\u2003 \u2003 203\nthe command pattern\npublic class LightOnCommand implements Command {\n    Light light;\n  \n    public LightOnCommand(Light light) {\n        this.light = light;\n    }\n \n    public void execute() {\n        light.on();\n    }\n}\npublic interface Command {\n    public void execute();\n}\nOur first command object\nIsn\u2019t it about time we built our first command object? Let\u2019s go ahead and write some \ncode for the remote control. While we haven\u2019t figured out how to design the remote \ncontrol API yet, building a few things from the bottom up may help us...\nImplementing the Command interface\nFirst things first: all command objects implement the same interface, which \nconsists of one method. In the Diner we called this method orderUp(); however, \nwe typically just use the name execute().\nHere\u2019s the Command interface:\nNow, let\u2019s say you want to implement a command for turning a light on.  \nReferring to our set of vendor classes, the Light class has two methods: on() \nand off(). Here\u2019s how you can implement this as a command:\nSimple. All we need is one method called execute().\nThe execute() method calls \nthe on() method on the \nreceiving object, which is \nthe light we are controlling.\nThe constructor is passed the specific \nlight that this command is going to \ncontrol\u2014say the living room light\u2014\nand stashes it in the light instance \nvariable. When execute gets called, \nthis is the light object that is going \nto be the receiver of the request.\nNow that you\u2019ve got a LightOnCommand class, let\u2019s see if we can put it to use...\nImplementing a command to turn a light on\nThis is a command, so we need to \nimplement the Command interface.\nLight\non()\noff()\n", "page": 241, "type": "text", "section": "Page 241"}
{"text": "204\u2003 \u2003 Chapter 6\nusing the command object\npublic class SimpleRemoteControl {\n    Command slot;\n    public SimpleRemoteControl() {}\n \n    public void setCommand(Command command) {\n        slot = command;\n    }\n    public void buttonWasPressed() {\n        slot.execute();\n    }\n}\npublic class RemoteControlTest {\n    public static void main(String[] args) {\n        SimpleRemoteControl remote = new SimpleRemoteControl();\n        Light light = new Light();\n        LightOnCommand lightOn = new LightOnCommand(light);\n \n        remote.setCommand(lightOn);\n        remote.buttonWasPressed();\n    }\n}\nUsing the command object\nOkay, let\u2019s make things simple: say we\u2019ve got a remote control with only one \nbutton and corresponding slot to hold a device to control:\nHere\u2019s just a bit of code to test out the simple remote control. Let\u2019s take a look and \nwe\u2019ll point out how the pieces match the Command Pattern diagram:\nFile  Edit   Window  Help  DinerFoodYum\n%java RemoteControlTest\nLight is On\n%\nWe have one slot to hold our command, \nwhich will control one device.\nCreating a simple test to use the Remote Control\nWe have a method for setting the \ncommand the slot is going to control.  \nThis could be called multiple times if the \nclient of this code wanted to change \nthe behavior of the remote button.\nThis method is called when the button \nis pressed. All we do is take the \ncurrent command bound to the slot \nand call its execute() method.\nThis is our Client in Command Pattern-speak.\nThe remote is our Invoker; \nit will be passed a command \nobject that can be used to \nmake requests.\nNow we create a Light \nobject. This will be the \nReceiver of the request.\nHere, create a command and \npass the Receiver to it.\nHere, pass the command \nto the Invoker.\nAnd then we simulate the \nbutton being pressed.\nHere\u2019s the output of \nrunning this test code.\n", "page": 242, "type": "text", "section": "Page 242"}
{"text": "you are here 4\u2003 \u2003 205\nthe command pattern\npublic class RemoteControlTest {\n    public static void main(String[] args) {\n        SimpleRemoteControl remote = new SimpleRemoteControl();\n        Light light = new Light();\n        GarageDoor garageDoor = new GarageDoor();\n        LightOnCommand lightOn = new LightOnCommand(light);\n        GarageDoorOpenCommand garageOpen = \n            new GarageDoorOpenCommand(garageDoor);\n \n        remote.setCommand(lightOn);\n        remote.buttonWasPressed();\n        remote.setCommand(garageOpen);\n        remote.buttonWasPressed();\n    }\n}\nGarageDoor\nup()\ndown()\nstop()\nlightOn()\nlightOff()\npublic class GarageDoorOpenCommand \n        implements Command {\n}\nYour output here.\nYour code here\nOkay, it\u2019s time for you to implement the \nGarageDoorOpenCommand class. First, supply the code for the \nclass below. You\u2019ll need the GarageDoor class diagram.\nNow that you\u2019ve got your class, what is the output of the \nfollowing code? (Hint: the GarageDoor up() method prints out \n\u201cGarage Door is Open\u201d when it is complete.)\nFile  Edit   Window  Help  GreenEggs&Ham\n%java RemoteControlTest\n", "page": 243, "type": "text", "section": "Page 243"}
{"text": "206\u2003 \u2003 Chapter 6\ncommand pattern defined\nThe Command Pattern defined\nYou\u2019ve done your time in the Objectville Diner, you\u2019ve partly \nimplemented the remote control API, and in the process you\u2019ve \ngot a fairly good picture of how the classes and objects interact in \nthe Command Pattern. Now we\u2019re going to define the Command \nPattern and nail down all the details. \nLet\u2019s start with its official definition:\nLet\u2019s step through this. We know that a command object \nencapsulates a request by binding together a set of actions on a \nspecific receiver. To achieve this, it packages the actions and the \nreceiver into an object that exposes just one method, execute(). \nWhen called, execute() causes the actions to be invoked on the \nreceiver. From the outside, no other objects really know what \nactions get performed on what receiver; they just know that if they \ncall the execute() method, their request will be serviced.\nWe\u2019ve also seen a couple examples of parameterizing an object with a \ncommand. Back at the diner, the Waitress was parameterized with \nmultiple orders throughout the day. In the simple remote control, \nwe first loaded the button slot with a \u201clight on\u201d command and \nthen later replaced it with a \u201cgarage door open\u201d command. Like \nthe Waitress, your remote slot didn\u2019t care what command object it \nhad, as long as it implemented the Command interface.\nWhat we haven\u2019t encountered yet is using commands to \nimplement queues and logs and support undo operations. Don\u2019t worry, \nthose are pretty straightforward extensions of the basic Command \nPattern, and we\u2019ll get to them soon. We can also easily support \nwhat\u2019s known as the Meta Command Pattern once we have the \nbasics in place. The Meta Command Pattern allows you to create \nmacros of commands so that you can execute multiple commands \nat once.\n \n \n \n \n \n \n \n \n \n \nC\no\nmm\na\nn\nd\nexecute() {\n  receiver.action();\n}\n \n  \n \n  \n  \n \n \nR\ne\nc\nei\nv\ne\nr\naction()\nAn encapsulated request.\n \n \n \n \n \nL\ni\ng\nh\nt\nO\nn\nC\no\nm\nm\na\nnd\nexecute()\n \n \n \n \n \n \n \n \n \nR\ne\nm\no\nt\ne\n \nS\nlo\nt\n \n  \n  \n \nG\na\nr\na\ngeD\no\no\nr\nO\np\nen\nexecute()\n  \n  \n  \n  \n  \n  \n  \nC\ne\ni\nl\ni\nn\ng\nF\na\nn\nH\ni\ng\nh\nexecute()\n  \n  \n  \n  \n  \n  \n  \n \n \nS\nt\ne\nre\no\nO\nf\nf\nexecute()\nAn invoker\u2009\u2014\u2009for instance, \none slot of the remote\u2009\u2014\ncan be parameterized with \ndifferent requests.\nThe Command Pattern encapsulates a request as an \nobject, thereby letting you parameterize other objects \nwith different requests, queue or log requests, and \nsupport undoable operations.\n", "page": 244, "type": "text", "section": "Page 244"}
{"text": "you are here 4\u2003 \u2003 207\nthe command pattern\nThe ConcreteCommand defines a binding between an \naction and a Receiver. The Invoker makes a request by \ncalling execute() and the ConcreteCommand carries it \nout by calling one or more actions on the Receiver.\nThe Receiver knows how to \nperform the work needed to \ncarry out the request. Any class \ncan act as a Receiver.\nCommand declares an interface for all commands. As \nyou already know, a command is invoked through its \nexecute() method, which asks a receiver to perform an \naction. You\u2019ll also notice this interface has an undo() \nmethod, which we\u2019ll cover a bit later in the chapter.\nThe Client is responsible for \ncreating a ConcreteCommand and \nsetting its Receiver.\nThe Command Pattern defined: \nthe class diagram\nThe Invoker holds \na command and at \nsome point asks the \ncommand to carry \nout a request by \ncalling its execute() \nmethod.\nInvoker\n<<interface>>\nCommand\nexecute()\nundo()\naction()\nReceiver\nClient\nConcreteCommand\nexecute()\nundo()\npublic void execute() {\n    receiver.action()\n}\nThe execute() \nmethod invokes \nthe action(s) \non the receiver \nneeded to fulfill \nthe request.\nsetCommand()\nHow does the design of the Command Pattern support the decoupling \nof the invoker of a request and the receiver of the request?\n", "page": 245, "type": "text", "section": "Page 245"}
{"text": "208\u2003 \u2003 Chapter 6\nwhere do we begin?\nMary: Me too. So where do we begin?\nSue:  Like we did in the SimpleRemote, we need to provide a \nway to assign commands to slots. In our case we have seven slots, \neach with an on and off button. So we might assign commands to \nthe remote something like this:\u200a\n \nonCommands[0] = onCommand; \noffCommands[0] = offCommand; \nand so on for each of the seven command slots.\nMary: That makes sense, except for the Light objects. How does \nthe remote know the living room from the kitchen light?\nSue: Ah, that\u2019s just it\u2014it doesn\u2019t! The remote doesn\u2019t know \nanything but how to call execute() on the corresponding \ncommand object when a button is pressed.\nMary: Yeah, I sorta got that, but in the implementation, how do \nwe make sure the right objects are turning on and off the right \ndevices?\nSue: When we create the commands to be loaded into the \nremote, we create one LightCommand that is bound to the living \nroom light object and another that is bound to the kitchen light \nobject. Remember, the receiver of the request gets bound to \nthe command it\u2019s encapsulated in. So, by the time the button is \npressed, no one cares which light is which; the right thing just \nhappens when the execute() method is called.\nMary: I think I\u2019ve got it. Let\u2019s implement the remote and I think \nthis will get clearer!\nSue: Sounds good. Let\u2019s give it a shot...\nOkay, I think I\u2019ve got a good \nfeel for the Command Pattern now. \n \nGreat tip, Joe, I think we\u2019re going to \nlook like superstars after finishing off \nthe Remote Control API.\n", "page": 246, "type": "text", "section": "Page 246"}
{"text": "you are here 4\u2003 \u2003 209\nthe command pattern\n  \n  \n  \n  \n  \n  \n  \nC\ne\ni\nl\ni\nn\ng\nF\na\nn\nOf\nf\nexecute()\n \n \n \n \n \nL\ni\ng\nh\nt\nO\nn\nC\no\nm\nm\na\nnd\nexecute()\n \n  \n  \n \nG\na\nr\na\ngeD\no\no\nr\nO\np\nen\nexecute()\n  \n  \n  \n  \n  \n  \n  \nC\ne\ni\nl\ni\nn\ng\nF\na\nn\nH\ni\ng\nh\nexecute()\n  \n  \n  \n  \n  \n  \n  \n \n \nS\nt\ne\nre\no\nO\nf\nf\nexecute()\n \n  \n  \n \nG\na\nr\na\ngeD\no\no\nr\nC\nl\no\nse\nexecute()\n \n \n \n \n \nL\ni\ng\nh\nt\nO\nf\nf\nC\no\nm\nm\nand\nexecute()\n \n \n \n \n \nL\ni\ng\nh\nt\nO\nn\nC\no\nm\nm\na\nnd\nexecute()\n \n \n \n \n \nL\ni\ng\nh\nt\nO\nf\nf\nC\no\nm\nm\nand\nexecute()\n  \n  \n  \n  \n  \n  \n  \n \n \nS\nt\ne\nre\no\nO\nn\nF\no\nr\nCD\nexecute()\nAssigning Commands to slots\nSo we have a plan: we\u2019re going to assign a command to each slot in the \nremote control. This makes the remote control our invoker. When a button \nis pressed, the execute() method will be called on the corresponding \ncommand, which results in actions being invoked on the receiver (like \nlights, ceiling fans, and stereos).\n \n \n \n \n \n \n \nS\nt\ne\nre\no\n  off()\n   on()\n(1) Each slot gets a command.\n(2) When the button is pressed, the \nexecute() method is called on the \ncorresponding command.\n(3) In the execute() method, \nactions are invoked on the receiver.\nThe Invoker\nWe\u2019ll worry about the \nremaining slots in a bit.\nIn our code you\u2019ll find that each \ncommand name has \u201cCommand\u201d \nappended to it, but in print, \nwe\u2019ve unfortunately run out of \nspace for a few of them.\n", "page": 247, "type": "text", "section": "Page 247"}
{"text": "210\u2003 \u2003 Chapter 6\nimplementing the remote control\npublic class RemoteControl {\n    Command[] onCommands;\n    Command[] offCommands;\n \n    public RemoteControl() {\n        onCommands = new Command[7];\n        offCommands = new Command[7];\n \n        Command noCommand = new NoCommand();\n        for (int i = 0; i < 7; i++) {\n            onCommands[i] = noCommand;\n            offCommands[i] = noCommand;\n        }\n    }\n  \n    public void setCommand(int slot, Command onCommand, Command offCommand) {\n        onCommands[slot] = onCommand;\n        offCommands[slot] = offCommand;\n    }\n \n    public void onButtonWasPushed(int slot) {\n        onCommands[slot].execute();\n    }\n \n    public void offButtonWasPushed(int slot) {\n        offCommands[slot].execute();\n    }\n  \n    public String toString() {\n        StringBuffer stringBuff = new StringBuffer();\n        stringBuff.append(\"\\n------ Remote Control -------\\n\");\n        for (int i = 0; i < onCommands.length; i++) {\n            stringBuff.append(\"[slot \" + i + \"] \" + onCommands[i].getClass().getName()\n                + \"    \" + offCommands[i].getClass().getName() + \"\\n\");\n        }\n        return stringBuff.toString();\n    }\n}\nIn the constructor, all we need to \ndo is instantiate and initialize the \nOn and Off arrays.\nThis time around, the remote is going \nto handle seven On and Off commands, \nwhich we\u2019ll hold in corresponding arrays.\nThe setCommand() method takes a slot \nposition and an On and Off command to \nbe stored in that slot.  \nWhen an On or Off button is \npressed, the hardware takes \ncare of calling the corresponding \nmethods onButtonWasPushed() or \noffButtonWasPushed().\nWe override toString() to print out each slot and \nits corresponding command. You\u2019ll see us use this \nwhen we test the remote control.  \nImplementing the Remote Control\nIt puts these commands in the \nOn and Off arrays for later use.\n", "page": 248, "type": "text", "section": "Page 248"}
{"text": "you are here 4\u2003 \u2003 211\nthe command pattern\npublic class StereoOnWithCDCommand implements Command {\n    Stereo stereo;\n \n    public StereoOnWithCDCommand(Stereo stereo) {\n        this.stereo = stereo;\n    }\n \n    public void execute() {\n        stereo.on();\n        stereo.setCD();\n        stereo.setVolume(11);\n    }\n}\npublic class LightOffCommand implements Command {\n    Light light;\n \n    public LightOffCommand(Light light) {\n        this.light = light;\n    }\n \n    public void execute() {\n        light.off();\n    }\n}\nImplementing the Commands\nWell, we\u2019ve already gotten our feet wet implementing the LightOnCommand for the \nSimpleRemoteControl. We can plug that same code in here and everything works \nbeautifully. Off commands are no different; in fact, the LightOffCommand looks like this:\nThe LightOffCommand works exactly \nthe same way as the LightOnCommand, \nexcept that we\u2019re binding the receiver to \na different action: the off() method.\nLet\u2019s try something a little more challenging; how about writing on and off \ncommands for the Stereo? Okay, off is easy, we just bind the Stereo to the off() \nmethod in the StereoOffCommand. On is a little more complicated; let\u2019s say we \nwant to write a StereoOnWithCDCommand...\nStereo\non()\noff()\nsetCd()\nsetDvd()\nsetRadio()\nsetVolume()\nJust like the LightOnCommand, we \nget passed the instance of the stereo \nwe\u2019re going to be controlling and we \nstore it in an instance variable.\nT\no carry out this request, we need to call three \nmethods on the stereo: first, turn it on, then set \nit to play the CD, and finally set the volume to 11.  \nWhy 11? Well, it\u2019s better than 10, right?\nNot too bad. Take a look at the rest of the vendor classes; by now, you can definitely \nknock out the rest of the Command classes we need for those.\n", "page": 249, "type": "text", "section": "Page 249"}
{"text": "212\u2003 \u2003 Chapter 6\ntesting the remote control\npublic class RemoteLoader {\n \n    public static void main(String[] args) {\n        RemoteControl remoteControl = new RemoteControl();\n \n        Light livingRoomLight = new Light(\"Living Room\");\n        Light kitchenLight = new Light(\"Kitchen\");\n        CeilingFan ceilingFan = new CeilingFan(\"Living Room\");\n        GarageDoor garageDoor = new GarageDoor(\"Garage\");\n        Stereo stereo = new Stereo(\"Living Room\");\n  \n        LightOnCommand livingRoomLightOn = \n                new LightOnCommand(livingRoomLight);\n        LightOffCommand livingRoomLightOff = \n                new LightOffCommand(livingRoomLight);\n        LightOnCommand kitchenLightOn = \n                new LightOnCommand(kitchenLight);\n        LightOffCommand kitchenLightOff = \n                new LightOffCommand(kitchenLight);\n  \n        CeilingFanOnCommand ceilingFanOn = \n                new CeilingFanOnCommand(ceilingFan);\n        CeilingFanOffCommand ceilingFanOff = \n                new CeilingFanOffCommand(ceilingFan);\n \n        GarageDoorUpCommand garageDoorUp =\n                new GarageDoorUpCommand(garageDoor);\n        GarageDoorDownCommand garageDoorDown =\n                new GarageDoorDownCommand(garageDoor);\n \n        StereoOnWithCDCommand stereoOnWithCD =\n                new StereoOnWithCDCommand(stereo);\n        StereoOffCommand stereoOff =\n                new StereoOffCommand(stereo);\n \nPutting the Remote Control through its paces\nOur job with the remote is pretty much done; all we need to do is run some tests and get \nsome documentation together to describe the API. Home Automation or Bust, Inc., sure \nis going to be impressed, don\u2019t ya think? We\u2019ve managed to come up with a design \nthat will allow them to produce a remote that is easy to maintain, and they\u2019re going \nto have no trouble convincing the vendors to write some simple command classes in \nthe future since those are so easy to write.\nLet\u2019s get to testing this code!  \nCreate all the devices in \ntheir proper locations.\nCreate all the Light \nCommand objects.\nCreate the On and Off \nfor the ceiling fan.\nCreate the Up and Down \ncommands for the Garage.\nCreate the stereo On \nand Off commands.\n", "page": 250, "type": "text", "section": "Page 250"}
{"text": "you are here 4\u2003 \u2003 213\nthe command pattern\n        remoteControl.setCommand(0, livingRoomLightOn, livingRoomLightOff);\n        remoteControl.setCommand(1, kitchenLightOn, kitchenLightOff);\n        remoteControl.setCommand(2, ceilingFanOn, ceilingFanOff);\n        remoteControl.setCommand(3, stereoOnWithCD, stereoOff);\n  \n        System.out.println(remoteControl);\n \n        remoteControl.onButtonWasPushed(0);\n        remoteControl.offButtonWasPushed(0);\n        remoteControl.onButtonWasPushed(1);\n        remoteControl.offButtonWasPushed(1);\n        remoteControl.onButtonWasPushed(2);\n        remoteControl.offButtonWasPushed(2);\n        remoteControl.onButtonWasPushed(3);\n        remoteControl.offButtonWasPushed(3);\n    }\n}\nFile  Edit   Window  Help  CommandsGetThingsDone\n% java RemoteLoader\n------ Remote Control -------\n[slot 0] LightOnCommand            LightOffCommand\n[slot 1] LightOnCommand            LightOffCommand\n[slot 2] CeilingFanOnCommand       CeilingFanOffCommand\n[slot 3] StereoOnWithCDCommand     StereoOffCommand\n[slot 4] NoCommand                 NoCommand\n[slot 5] NoCommand                 NoCommand\n[slot 6] NoCommand                 NoCommand\nLiving Room light is on\nLiving Room light is off\nKitchen light is on\nKitchen light is off\nLiving Room ceiling fan is on high\nLiving Room ceiling fan is off\nLiving Room stereo is on\nLiving Room stereo is set for CD input\nLiving Room stereo volume set to 11\nLiving Room stereo is off\n%\nNow that we\u2019ve got \nall our commands, we \ncan load them into \nthe remote slots.\nHere\u2019s where we use our toString() method \nto print each remote slot and the command \nassigned to it. (Note that toString() gets \ncalled automatically here, so we don\u2019t have \nto call toString() explicitly.)\nAll right, we are ready to roll!  \nNow, we step through each slot \nand push its On and Off buttons.\nNow, let\u2019s check out the execution of our remote control test...\nOn slots    Off slots\nOur commands in action! Remember, the output \nfrom each device comes from the vendor classes. \nFor instance, when a light object is turned on, it \nprints \u201cLiving Room light is on.\u201d\n", "page": 251, "type": "text", "section": "Page 251"}
{"text": "214\u2003 \u2003 Chapter 6\nnull object\nCommand noCommand = new NoCommand();\nfor (int i = 0; i < 7; i++) {\n    onCommands[i] = noCommand;\n    offCommands[i] = noCommand;\n}\npublic class NoCommand implements Command {\n    public void execute() { }\n}\nGood catch. We did sneak a little something in there. In the remote \ncontrol, we didn\u2019t want to check to see if a command was loaded every \ntime we referenced a slot. For instance, in the onButtonWasPushed() \nmethod, we would need code like this:\npublic void onButtonWasPushed(int slot) {\n    if (onCommands[slot] != null) {\n        onCommands[slot].execute();\n    }\n}\nSo, how do we get around that? Implement a command that does nothing!\nThen, in our RemoteControl constructor, we assign every slot a \nNoCommand object by default and we know we\u2019ll always have some \ncommand to call in each slot.\nSo, in the output of our test run, you\u2019re seeing only slots that have been \nassigned to a command other than the default NoCommand object, \nwhich we assigned when we created the RemoteControl constructor.\nPattern \n \n \n \n \n \n \n \n \n \n \n \n \nHonorable \nMention\nHead First\nHonorable \nMention\nThe NoCommand object is an example of a null object. A null object is useful when \nyou don\u2019t have a meaningful object to return, and yet you want to remove the \nresponsibility for handling null from the client. For instance, in our remote control we \ndidn\u2019t have a meaningful object to assign to each slot out of the box, so we provided \na NoCommand object that acts as a surrogate and does nothing when its execute() \nmethod is called.\nYou\u2019ll find uses for Null Objects in conjunction with many Design Patterns, and \nsometimes you\u2019ll even see \u201cNull Object\u201d listed as a Design Pattern.\n Wait a second, what\u2019s \nwith that NoCommand \nthat\u2019s loaded in slots 4 \nthrough 6? Trying to pull a \nfast one?\n", "page": 252, "type": "text", "section": "Page 252"}
{"text": "you are here 4\u2003 \u2003 215\nthe command pattern\nTime to write that documentation...\nRemote Control API Design for Home Automation or Bust, Inc.\nWe are pleased to present you with the following design and application programming interface for your Home \nAutomation Remote Control.  Our primary design goal was to keep the remote control code as simple as possible so that \nit doesn\u2019t require changes as new vendor classes are produced.  To this end we have employed the Command Pattern to \nlogically decouple the RemoteControl class from the Vendor Classes.  We believe this will reduce the cost of producing \nthe remote as well as drastically reduce your ongoing maintenance costs.\nThe following class diagram provides an overview of our design:\nUsing the Command Interface, we implement each action \nthat can be invoked by pressing a button on the remote \nwith a simple Command object.  The Command object holds \na reference to an object that is an instance of a Vendor Class \nand implements an execute() method that calls one or more \nmethods on that object.  Here we show two such classes \nthat turn a light on and off, respectively.\nThe Vendor Classes are used to perform \nthe actual home automation work of \ncontrolling devices. Here, we\u2019re using the \nLight class as an example.\nAll RemoteControl commands \nimplement the Command \ninterface, which consists of one \nmethod: execute(). Commands \nencapsulate a set of actions on a \nspecific vendor class. The remote \ninvokes these actions by calling \nthe execute() method.\nThe RemoteLoader creates a \nnumber of Command objects \nthat are loaded into the slots \nof the Remote Control.  Each \ncommand object encapsulates \na request of a home \nautomation device.  \nRemoteControl\nsetCommand()\nonButtonWasPushed()\noffButtonWasPushed()\n<<interface>>\nCommand\nexecute()\non()\noff()\nLight\nRemoteLoader\nLightOnCommand\nexecute()LightOffCommand\nexecute()\npublic void execute() {\n    light.on()\n}\npublic void execute() {\n    light.off()\n}\nonCommands\noffCommands\nThe RemoteControl class manages a set of \nCommand objects, one per button. When a button \nis pressed, the corresponding ButtonWasPushed() \nmethod is called, which invokes the execute() \nmethod on the command. That is the full extent of \nthe remote\u2019s knowledge of the classes it\u2019s invoking \nas the Command object decouples the remote from \nthe classes doing the actual home automation work.\n", "page": 253, "type": "text", "section": "Page 253"}
{"text": "216\u2003 \u2003 Chapter 6\npublic class RemoteLoader {\n \n   public static void main(String[] args) {\n      RemoteControl remoteControl = new RemoteControl();\n      Light livingRoomLight = new Light(\"Living Room\");\n      ... \n      LightOnCommand livingRoomLightOn = \n\t\n\t\n\t\n\t\nnew LightOnCommand(livingRoomLight);\n      LightOffCommand livingRoomLightOff = \n\t\n\t\n\t\n\t\nnew LightOffCommand(livingRoomLight);\n      ...\n      remoteControl.setCommand(0,() -> livingRoomLight.on(), \n                                 () -> livingRoomLight.off());\n      ...\n   }\n}\nThe updated code, using lambda expressions:\nWe create the Light \nobject like normal...\nWant to take your Command Pattern coding to the next level? You can use Java\u2019s lambda expressions \nto skip the step of creating all those concrete command objects. With lambda expressions, instead of \ninstantiating the concrete command objects, you can use function objects in their place. In other words, \nwe can use a function object as a command. And, while we\u2019re at it, we can delete all those concrete \nCommand classes, too. \nLet\u2019s take a look at how you\u2019d use lambda expressions as commands to simplify our previous code:\nOnce we\u2019ve replaced the concrete commands with lambda expressions, we can delete all those \nconcrete command classes (LightOnCommand, LightOffCommand, HottubOnCommand, \nHottubOffCommand, etc.). If you do this for every concrete command, you\u2019ll reduce the total number \nof classes in the remote control application from 22 to 9. \nNote that you can only do this if your Command interface has one abstract method. As soon as we add a \nsecond abstract method, the lambda shorthand no longer works. \nIf you like this technique, check out your favorite Java reference for more information on the lambda \nexpression.\nBut we can remove \nthe concrete \nLightOnCommand and \nLightOffCommand \nobjects.\nInstead we'll write the concrete commands as lambda \nexpressions that do the same work as the concrete \ncommand\u2019s execute() method was doing: that is, turning \nthe light on or turning the light off. \nrepresent commands with lambdas\nLater, when you click one of the remote\u2019s \nbuttons, the remote calls the execute() \nmethod of the command object in the \nslot for that button, which is represented \nby this lambda expression.\n", "page": 254, "type": "text", "section": "Page 254"}
{"text": "you are here 4\u2003 \u2003 217\nthe command pattern\npublic interface Command {\n    public void execute();\n    public void undo();\n}\nWhoops! We almost forgot...luckily, once \nwe have our basic Command classes, \nundo is easy to add. Let\u2019s step through \nadding undo to our commands and to the \nremote control...\nHere\u2019s the new undo() method.\nWhat are we doing?\nOkay, we need to add functionality to support the undo button on the remote. It works like \nthis: say the Living Room Light is off and you press the on button on the remote. Obviously \nthe light turns on. Now if you press the undo button, then the last action will be reversed\u2014in \nthis case, the light will turn off. Before we get into more complex examples, let\u2019s get the light \nworking with the undo button:\n1\nWhen commands support undo, they have an undo() method that mirrors the execute() \nmethod. Whatever execute() last did, undo() reverses. So, before we can add undo to our \ncommands, we need to add an undo() method to the Command interface:\nThat was simple enough.\nNow, let\u2019s dive into the Light commands and implement the undo() method.\nGreat job; it looks like \nyou\u2019ve come up with a terrific \ndesign, but aren\u2019t you forgetting one \nlittle thing the customer asked for?  \nLIKE THE UNDO BUTTON?!\n", "page": 255, "type": "text", "section": "Page 255"}
{"text": "218\u2003 \u2003 Chapter 6\npublic class LightOffCommand implements Command {\n    Light light;\n \n    public LightOffCommand(Light light) {\n        this.light = light;\n    }\n \n    public void execute() {\n        light.off();\n    }\n \n    public void undo() {\n        light.on();\n    }\n}\npublic class LightOnCommand implements Command {\n    Light light;\n \n    public LightOnCommand(Light light) {\n        this.light = light;\n    }\n \n    public void execute() {\n        light.on();\n    }\n \n    public void undo() {\n        light.off();\n    }\n}\nCould this be any easier? Okay, we aren\u2019t done yet; we need to work a little \nsupport into the Remote Control to handle tracking the last button pressed \nand the undo button press.\nPiece of cake! Now for the LightOffCommand. Here the undo() method just \nneeds to call the Light\u2019s on() method.\n2\nLet\u2019s start with the LightOnCommand: if the LightOnCommand\u2019s execute() method \nwas called, then the on() method was last called. We know that undo() needs to do the \nopposite of this by calling the off() method.\nAnd here, undo() turns \nthe light back on.\nexecute() turns the light \non, so undo() simply turns \nthe light back off.\nimplementing undo\n", "page": 256, "type": "text", "section": "Page 256"}
{"text": "you are here 4\u2003 \u2003 219\nthe command pattern\npublic class RemoteControlWithUndo {\n    Command[] onCommands;\n    Command[] offCommands;\n    Command undoCommand;\n \n    public RemoteControlWithUndo() {\n        onCommands = new Command[7];\n        offCommands = new Command[7];\n \n        Command noCommand = new NoCommand();\n        for(int i=0;i<7;i++) {\n            onCommands[i] = noCommand;\n            offCommands[i] = noCommand;\n        }\n        undoCommand = noCommand;\n    }\n  \n    public void setCommand(int slot, Command onCommand, Command offCommand) {\n        onCommands[slot] = onCommand;\n        offCommands[slot] = offCommand;\n    }\n \n    public void onButtonWasPushed(int slot) {\n        onCommands[slot].execute();\n        undoCommand = onCommands[slot];\n    }\n \n    public void offButtonWasPushed(int slot) {\n        offCommands[slot].execute();\n        undoCommand = offCommands[slot];\n    }\n \n    public void undoButtonWasPushed() {\n        undoCommand.undo();\n    }\n  \n    public String toString() {\n        // toString code here...\n    }\n}\n3\nTo add support for the undo button, we only have to make a few small changes to the Remote \nControl class. Here\u2019s how we\u2019re going to do it: we\u2019ll add a new instance variable to track the last \ncommand invoked; then, whenever the undo button is pressed, we retrieve that command and \ninvoke its undo() method.\nThis is where we\u2019ll stash the last \ncommand executed for the undo button.\nJust like the other slots, undo \nstarts off with a noCommand, so \npressing undo before any other \nbutton won\u2019t do anything at all.\nWhen a button is pressed, we take \nthe command and first execute \nit; then we save a reference to \nit in the undoCommand instance \nvariable. We do this for both on \ncommands and off commands.\nWhen the undo button is pressed, we \ninvoke the undo() method of the \ncommand stored in undoCommand.  \nThis undoes the operation of the last \ncommand executed.\nUpdate to add undoCommands.\n", "page": 257, "type": "text", "section": "Page 257"}
{"text": "220\u2003 \u2003 Chapter 6\npublic class RemoteLoader {\n \n    public static void main(String[] args) {\n        RemoteControlWithUndo remoteControl = new RemoteControlWithUndo();\n \n        Light livingRoomLight = new Light(\"Living Room\");\n \n        LightOnCommand livingRoomLightOn = \n                new LightOnCommand(livingRoomLight);\n        LightOffCommand livingRoomLightOff = \n                new LightOffCommand(livingRoomLight);\n \n        remoteControl.setCommand(0, livingRoomLightOn, livingRoomLightOff);\n \n        remoteControl.onButtonWasPushed(0);\n        remoteControl.offButtonWasPushed(0);\n        System.out.println(remoteControl);\n        remoteControl.undoButtonWasPushed();\n        remoteControl.offButtonWasPushed(0);\n        remoteControl.onButtonWasPushed(0);\n        System.out.println(remoteControl);\n        remoteControl.undoButtonWasPushed();\n    }\n}\nTime to QA that Undo button!\nCreate a Light, and our new undo() \nenabled Light On and Off Commands.\nAdd the light Commands \nto the remote in slot 0.\nAnd here are the test results...\nOkay, let\u2019s rework the test harness a bit to test the undo button:\nTurn the light on, then \noff, and then undo.\nThen, turn the light off, back on, and undo.\nFile  Edit   Window  Help  UndoCommandsDefyEntropy\n% java RemoteLoader\nLight is on\nLight is off\n------ Remote Control -------\n[slot 0] LightOnCommand        LightOffCommand\n[slot 1] NoCommand             NoCommand\n[slot 2] NoCommand             NoCommand\n[slot 3] NoCommand             NoCommand\n[slot 4] NoCommand             NoCommand\n[slot 5] NoCommand             NoCommand\n[slot 6] NoCommand             NoCommand\n[undo] LightOffCommand\nLight is on\nLight is off\nLight is on\n------ Remote Control -------\n[slot 0] LightOnCommand        LightOffCommand\n[slot 1] NoCommand             NoCommand\n[slot 2] NoCommand             NoCommand\n[slot 3] NoCommand             NoCommand\n[slot 4] NoCommand             NoCommand\n[slot 5] NoCommand             NoCommand\n[slot 6] NoCommand             NoCommand\n[undo] LightOnCommand\nLight is off\nUndo was pressed...\u2009the LightOffCommand \nundo() turns the light back on.\nHere are the Light commands.\nTurn the light on, then off.\nNow undo holds the \nLightOffCommand, the \nlast command invoked.\nThen we turn the light off and back on.\nUndo was pressed, so the light is back off.\nNow undo holds the LightOnCommand, the last \ncommand invoked.\ntest drive undo\n", "page": 258, "type": "text", "section": "Page 258"}
{"text": "you are here 4\u2003 \u2003 221\nthe command pattern\npublic class CeilingFan {\n    public static final int HIGH = 3;\n    public static final int MEDIUM = 2;\n    public static final int LOW = 1;\n    public static final int OFF = 0;\n    String location;\n    int speed;\n \n    public CeilingFan(String location) {\n        this.location = location;\n        speed = OFF;\n    }\n  \n    public void high() {\n        speed = HIGH;\n        // code to set fan to high\n    } \n \n    public void medium() {\n        speed = MEDIUM;\n        // code to set fan to medium \n    }\n \n    public void low() {\n        speed = LOW;\n        // code to set fan to low\n    }\n  \n    public void off() {\n        speed = OFF;\n        // code to turn fan off\n    }\n  \n    public int getSpeed() {\n        return speed;\n    }\n}\nUsing state to implement Undo\nOkay, implementing undo on the Light was instructive but a little too easy. Typically, \nwe need to manage a bit of state to implement undo. Let\u2019s try something a little more \ninteresting, like the CeilingFan from the vendor classes. The CeilingFan class allows a \nnumber of speeds to be set along with an off method.\nHere\u2019s the source code for the CeilingFan class:\nCeilingFan\nhigh()\nmedium()\nlow()\noff()\ngetSpeed()\nNotice that the CeilingFan class \nholds local state representing the \nspeed of the ceiling fan.\nThese methods set the \nspeed of the ceiling fan.\nWe can get the current \nspeed of the ceiling fan \nusing getSpeed().\nHmm, so to properly \nimplement undo, I\u2019d have \nto take the previous speed of \nthe ceiling fan into account...\n", "page": 259, "type": "text", "section": "Page 259"}
{"text": "222\u2003 \u2003 Chapter 6\npublic class CeilingFanHighCommand implements Command {\n    CeilingFan ceilingFan;\n    int prevSpeed;\n  \n    public CeilingFanHighCommand(CeilingFan ceilingFan) {\n        this.ceilingFan = ceilingFan;\n    }\n \n    public void execute() {\n        prevSpeed = ceilingFan.getSpeed();\n        ceilingFan.high();\n    }\n \n    public void undo() {\n        if (prevSpeed == CeilingFan.HIGH) {\n            ceilingFan.high();\n        } else if (prevSpeed == CeilingFan.MEDIUM) {\n            ceilingFan.medium();\n        } else if (prevSpeed == CeilingFan.LOW) {\n            ceilingFan.low();\n        } else if (prevSpeed == CeilingFan.OFF) {\n            ceilingFan.off();\n        }\n    }\n}\nNow let\u2019s tackle adding undo to the various Ceiling Fan commands. To \ndo so, we need to track the last speed setting of the fan and, if the undo() \nmethod is called, restore the fan to its previous setting. Here\u2019s the code for \nthe CeilingFanHighCommand:\nWe\u2019ve added local state to \nkeep track of the previous \nspeed of the fan.\nIn execute(), before we \nchange the speed of the \nfan, we need to first \nrecord its previous state, \njust in case we need to \nundo our actions.\nT\no undo, we set the \nspeed of the fan back \nto its previous speed.\nAdding Undo to the Ceiling Fan commands\nWe\u2019ve got three more ceiling fan commands to write: low, \nmedium, and off. Can you see how these are implemented?\nadd undo to the ceiling fan\n", "page": 260, "type": "text", "section": "Page 260"}
{"text": "you are here 4\u2003 \u2003 223\nthe command pattern\npublic class RemoteLoader {\n \n    public static void main(String[] args) {\n        RemoteControlWithUndo remoteControl = new RemoteControlWithUndo();\n \n        CeilingFan ceilingFan = new CeilingFan(\"Living Room\");\n   \n        CeilingFanMediumCommand ceilingFanMedium = \n                new CeilingFanMediumCommand(ceilingFan);\n        CeilingFanHighCommand ceilingFanHigh = \n                new CeilingFanHighCommand(ceilingFan);\n        CeilingFanOffCommand ceilingFanOff = \n                new CeilingFanOffCommand(ceilingFan);\n  \n        remoteControl.setCommand(0, ceilingFanMedium, ceilingFanOff);\n        remoteControl.setCommand(1, ceilingFanHigh, ceilingFanOff);\n   \n        remoteControl.onButtonWasPushed(0);\n        remoteControl.offButtonWasPushed(0);\n        System.out.println(remoteControl);\n        remoteControl.undoButtonWasPushed();\n  \n        remoteControl.onButtonWasPushed(1);\n        System.out.println(remoteControl);\n        remoteControl.undoButtonWasPushed();\n    }\n}\nGet ready to test the ceiling fan\nTime to load up our remote control with the ceiling fan \ncommands. We\u2019re going to load slot 0\u2019s on button with the \nmedium setting for the fan and slot 1 with the high setting. \nBoth corresponding off buttons will hold the ceiling fan off \ncommand.\nHere\u2019s our test script:\nHere we instantiate three \ncommands: medium, high, and off.\nHere we put medium in \nslot 0, and high in slot \n1. We also load up the \noff command.\nFirst, turn the fan on medium.\nThen turn it off. \nUndo! It should go back to medium...\nTurn it on to high this time.\nAnd, one more undo; it should go back \nto medium.\n", "page": 261, "type": "text", "section": "Page 261"}
{"text": "224\u2003 \u2003 Chapter 6\nv\n% java RemoteLoader\nLiving Room ceiling fan is on medium\nLiving Room ceiling fan is off\n------ Remote Control -------\n[slot 0] CeilingFanMediumCommand    CeilingFanOffCommand\n[slot 1] CeilingFanHighCommand      CeilingFanOffCommand\n[slot 2] NoCommand                  NoCommand\n[slot 3] NoCommand                  NoCommand\n[slot 4] NoCommand                  NoCommand\n[slot 5] NoCommand                  NoCommand\n[slot 6] NoCommand                  NoCommand\n[undo] CeilingFanOffCommand\nLiving Room ceiling fan is on medium\nLiving Room ceiling fan is on high\n------ Remote Control -------\n[slot 0] CeilingFanMediumCommand    CeilingFanOffCommand\n[slot 1] CeilingFanHighCommand      CeilingFanOffCommand\n[slot 2] NoCommand                  NoCommand\n[slot 3] NoCommand                  NoCommand\n[slot 4] NoCommand                  NoCommand\n[slot 5] NoCommand                  NoCommand\n[slot 6] NoCommand                  NoCommand\n[undo] CeilingFanHighCommand\nLiving Room ceiling fan is on medium\n%\nFile  Edit   Window  Help  UndoThis!\nOne more undo, and the ceiling \nfan goes back to medium speed.\nTurn the ceiling fan on \nmedium, then turn it off.\n...and undo has the last command \nexecuted, the CeilingFanOffCommand, \nwith the previous speed of medium.\nHere are the commands \nin the remote control...\nUndo the last command, and it goes back to medium.\nNow, turn it on high.\nNow, high is the last \ncommand executed.\nTesting the ceiling fan...\nOkay, let\u2019s fire up the remote, load it with commands, and push some buttons!\ntest drive the ceiling fan\n", "page": 262, "type": "text", "section": "Page 262"}
{"text": "you are here 4\u2003 \u2003 225\nthe command pattern\npublic class MacroCommand implements Command {\n    Command[] commands;\n \n    public MacroCommand(Command[] commands) {\n        this.commands = commands;\n    }\n \n    public void execute() {\n        for (int i = 0; i < commands.length; i++) {\n            commands[i].execute();\n        }\n    }\n}\nEvery remote needs a Party Mode!\nHottub\non()\noff()\ncirculate()\njetsOn()\njetsOff()\nsetTemperature()\nStereo\non()\noff()\nsetCd()\nsetDvd()\nsetRadio()\nsetVolume()\nLight\non()\noff()\ndim()\non()\noff()\nsetInputChannel()\nsetVolume()\nTV\nMary\u2019s idea is to make a new \nkind of Command that can \nexecute other Commands... \nand more than one of them!  \nPretty good idea, huh?\nT\nake an array of Commands and store \nthem in the MacroCommand.\nWhen the macro gets executed by the remote, \nexecute those commands one at a time.\nWhat\u2019s the point of having a remote if you \ncan\u2019t push one button and have the lights \ndimmed, the stereo and TV turned on, and \nthe hot tub fired up?\nHmm, our remote \ncontrol would need a \nbutton for each device, so \nI don\u2019t think we can do this.\nHold on, Sue, don\u2019t be \nso sure. I think we can do \nthis without changing the \nremote at all!\n", "page": 263, "type": "text", "section": "Page 263"}
{"text": "226\u2003 \u2003 Chapter 6\nremoteControl.setCommand(0, partyOnMacro, partyOffMacro);\nCommand[] partyOn = { lightOn, stereoOn, tvOn, hottubOn};\nCommand[] partyOff = { lightOff, stereoOff, tvOff, hottubOff};\n  \nMacroCommand partyOnMacro = new MacroCommand(partyOn);\nMacroCommand partyOffMacro = new MacroCommand(partyOff);\nLight light = new Light(\"Living Room\");\nTV tv = new TV(\"Living Room\");\nStereo stereo = new Stereo(\"Living Room\");\nHottub hottub = new Hottub();\n \nLightOnCommand lightOn = new LightOnCommand(light);\nStereoOnCommand stereoOn = new StereoOnCommand(stereo);\nTVOnCommand tvOn = new TVOnCommand(tv);\nHottubOnCommand hottubOn = new HottubOnCommand(hottub);\nUsing a macro command\nLet\u2019s step through how we use a macro command:\n1\nFirst we create the set of commands we want to go into the macro:\nNext we create two arrays, one for the On commands and one for the Off \ncommands, and load them with the corresponding commands:\n3\nThen we assign MacroCommand to a button like we always do:\nCreate all the devices: a light, \ntv, stereo, and hot tub.\nNow create all the On \ncommands to control them.\nCreate an array for \nOn commands and \nan array for Off \ncommands...\n...and  create two \ncorresponding macros \nto hold them.\nAssign the macro \ncommand to a button as \nyou would any command.\nWe\u2019ll also need commands for the off buttons. \nWrite the code to create those here:\n2\ncreate a macro command\n", "page": 264, "type": "text", "section": "Page 264"}
{"text": "you are here 4\u2003 \u2003 227\nthe command pattern\nSystem.out.println(remoteControl);\nSystem.out.println(\"--- Pushing Macro On---\");\nremoteControl.onButtonWasPushed(0);\nSystem.out.println(\"--- Pushing Macro Off---\");\nremoteControl.offButtonWasPushed(0);\nFile  Edit   Window  Help  You Can\u2019tBeatABabka\n% java RemoteLoader\n------ Remote Control -------\n[slot 0] MacroCommand    MacroCommand\n[slot 1] NoCommand       NoCommand\n[slot 2] NoCommand       NoCommand\n[slot 3] NoCommand       NoCommand\n[slot 4] NoCommand       NoCommand\n[slot 5] NoCommand       NoCommand\n[slot 6] NoCommand       NoCommand\n[undo] NoCommand\n--- Pushing Macro On---\nLight is on\nLiving Room stereo is on\nLiving Room TV is on\nLiving Room TV channel is set for DVD\nHottub is heating to a steaming 104 degrees\nHottub is bubbling!\n--- Pushing Macro Off---\nLight is off\nLiving Room stereo is off\nLiving Room TV is off\nHottub is cooling to 98 degrees\nHere are the two macro commands.\nAll the Commands in the \nmacro are executed when we \ninvoke the on macro...\n...and when we invoke the off \nmacro. Looks like it works.\n4\nFinally, we just need to push some buttons and see if this works. \nHere\u2019s the output.\n", "page": 265, "type": "text", "section": "Page 265"}
{"text": "228\u2003 \u2003 Chapter 6\nexercise with macro commands\nThe only thing our MacroCommand is missing is its undo functionality. When the undo \nbutton is pressed after a macro command, all the commands that were invoked in the \nmacro must undo their previous actions. Here\u2019s the code for MacroCommand; go ahead \nand implement the undo() method:\npublic class MacroCommand implements Command {\n    Command[] commands;\n    public MacroCommand(Command[] commands) {\n        this.commands = commands;\n    }\n    public void execute() {\n        for (int i = 0; i < commands.length; i++) {\n            commands[i].execute();\n        }\n    }\n    public void undo() {\n    }\n}\nQ: Do I always need a receiver? Why \ncan\u2019t the command object implement the \ndetails of the execute() method?\nA: In general, we strive for \u201cdumb\u201d \ncommand objects that just invoke an action \non a receiver; however, there are many \nexamples of \u201csmart\u201d command objects \nthat implement most, if not all, of the logic \nneeded to carry out a request. Certainly you \ncan do this; just keep in mind you\u2019ll no longer \nhave the same level of decoupling between \nthe invoker and receiver, nor will you be \nable to parameterize your commands with \nreceivers.\nQ: How can I implement a history \nof undo operations? In other words, I \nwant to be able to press the undo button \nmultiple times.\nA: Great question. It\u2019s pretty easy \nactually; instead of keeping just a reference \nto the last Command executed, you keep \na stack of previous commands. Then, \nwhenever undo is pressed, your invoker \npops the first item off the stack and calls its \nundo() method.\n\nQ: Could I have just implemented \nparty mode as a Command by creating \na PartyCommand and putting the calls \nto execute the other Commands in \nPartyCommand\u2019s execute() method?\nA: You could; however, you\u2019d essentially \nbe  \u201chardcoding\u201d the party mode into \nPartyCommand. Why go to the trouble?  \nWith MacroCommand, you can decide \ndynamically which Commands you want to \ngo into PartyCommand, so you have more \nflexibility using MacroCommands. In general, \nMacroCommand is a more elegant solution \nand requires less new code.\n", "page": 266, "type": "text", "section": "Page 266"}
{"text": "you are here 4\u2003 \u2003 229\nthe command pattern\nMore uses of the Command Pattern: queuing requests\nNote that the job queue classes are totally decoupled from \nthe objects that are doing the computation. One minute a \nthread may be computing a financial computation, and the \nnext it may be retrieving something from the network. The \njob queue objects don\u2019t care; they just retrieve commands \nand call execute(). Likewise, as long as you put objects into \nthe queue that implement the Command Pattern, your \nexecute() method will be invoked when a thread is available.\n \n \n \n \n \n \n \n \n \n \n \nT\nh\nre\na\nd\n \n \n \n \n \n \n \n \n \n \nR\na\ny\nTr\na\nce\nexecute()\n  \n  \n  \n  \n  \n  \n  \n \n \nC\no\nmp\ni\nl\ne\nr\nT\na\ns\nk\n \n \n \n \n \n \n \n \n \n \n \nT\nh\nre\na\nd\nThreads computing \njobs\nObjects implementing the \ncommand interface are \nadded to the queue.\nThreads remove commands \nfrom the queue one by one \nand call their execute() \nmethod. Once complete, \nthey go back for a new \ncommand object.\nThis gives us an effective way \nto limit computation to a \nfixed number of threads.\nF\ni\nn\na\nn\nc\ni\na\nl\nC\no\nm\np\nu\nt\na\nt\ni\non \n  \n  \n  \n  \n  \n  \n \nC\no\nm\np\nil\ne\nr\nTa\nsk\nexecute()\n  \n  \n  \n  \n  \n  \n  \nD\no\nw\nnlo\na\ndR\ne\nqu\nest\nexecute()\n  \n  \n  \n  \n  \n  \n \nC\no\nm\np\nil\ne\nr\nTa\nsk\nexecute()\n  \n  \n  \n  \n  \n  \n  \nN\ne\nt\nwo\nr\nk\nF\ne\nt\nc\nh\nexecute()\nF\ni\nn\na\nn\nc\ni\na\nl\n Co\nm\npu\nt\na\nt\nion\nexecute()\n \n \n \n \n \n \n \n \n \n \nR\na\ny\nTr\na\nce\nexecute()\n   \n   \n   \nD\nis\nt\nr\ni\nb\nu\nt\ne\ndC\no\nmp\nut\na\nt\ni\non\nexecute()\nexecute()\n  \n  \n  \n  \n  \n  \n  \nD\no\nw\nnlo\na\ndR\ne\nqu\nest\n  \n  \n  \n  \n  \n  \n  \n \n \nC\no\nmp\ni\nl\ne\nr\nT\na\ns\nk\nexecute()\n  \n  \n  \n  \n  \n  \n  \nN\ne\nt\nwo\nr\nk\nF\ne\nt\nc\nh\nexecute()\nF\ni\nn\na\nn\nc\ni\na\nl\nC\no\nm\np\nu\nt\na\nt\ni\non\nexecute()\n \n \n \n \n \n \n \n \n \n \nR\na\ny\nTr\na\nce\nexecute()\nexecute()\nJob queue\nCommands\nexecute()\n  \n  \n  \n  \n  \n  \n  \nD\no\nw\nnlo\na\ndR\ne\nqu\nest\n \n \n \n \n \n \n \n \n \n \n \nT\nh\nre\na\nd\nexecute()\n  \n  \n  \n  \n  \n  \n  \nN\ne\nt\nwo\nr\nk\nF\ne\nt\nc\nh\n \n \n \n \n \n \n \n \n \n \n \nT\nh\nre\na\nd\nexecute()\nCommands give us a way to package a piece of \ncomputation (a receiver and a set of actions) and pass \nit around as a first-class object. Now, the computation \nitself may be invoked long after some client application \ncreates the command object. In fact, it may even be \ninvoked by a different thread. We can take this scenario \nand apply it to many useful applications, such as \nschedulers, thread pools, and job queues, to name a few.\nImagine a job queue: you add commands to the \nqueue on one end, and on the other end sits a group \nof threads. Threads run the following script: they \nremove a command from the queue, call its execute() \nmethod, wait for the call to finish, and then discard the \ncommand object and retrieve a new one.\nHow might a web server make \nuse of such a queue? What other \napplications can you think of?\n", "page": 267, "type": "text", "section": "Page 267"}
{"text": "230\u2003 \u2003 Chapter 6\nusing the command pattern for logging requests\nThe semantics of some applications require that we log all actions and be able to \nrecover after a crash by reinvoking those actions. The Command Pattern can support \nthese semantics with the addition of two methods: store() and load(). In Java we could \nuse object serialization to implement these methods, but the normal caveats for using \nserialization for persistence apply.\nHow does this work? As we execute commands, we store a history of them on disk. \nWhen a crash occurs, we reload the command objects and invoke their execute() \nmethods in batch and in order.\nNow, this kind of logging wouldn\u2019t make sense for a remote control; however, there \nare many applications that invoke actions on large data structures that can\u2019t be \nquickly saved each time a change is made. By using logging, we can save all the \noperations since the last checkpoint, and if there is a system failure, apply those \noperations to our checkpoint. Take, for example, a  spreadsheet application: we might \nwant to implement our failure recovery by logging the actions on the spreadsheet rather \nthan writing a copy of the spreadsheet to disk every time a change occurs. In more \nadvanced applications, these techniques can be extended to apply to sets of operations \nin a transactional manner so that all of the operations complete, or none of them do.\n<<interface>>\nCommand\nexecute()\nundo()\nstore()\nload()\nAs each command \nis executed, it is \nstored on disk.\nMore uses of the Command Pattern: logging requests\nC\no\nm\nm\na\nn\nd\nO\nn\ne\nexecute()\nstore()\nload()\n \n \n \nC\no\nm\nm\nan\nd\nT\nw\no\nexecute()\nstore()\nload()\n \nC\no\nm\nm\na\nnd\nT\nh\nr\ne\ne\nexecute()\nstore()\nload()\nstore\nstore\nstore\n1. execute()\n \n \nI\nn\nv\no\nke\nr\n2. execute()\n3. execute()\n \n \nC\no\nm\nm\na\nnd\nO\nn\ne\nexecute()\nstore()\nload()\n \n \n \nC\no\nm\nm\nan\nd\nT\nw\no\nexecute()\nstore()\nload()\n \nC\no\nm\nm\na\nnd\nT\nh\nr\ne\ne\nexecute()\nstore()\nload()\nload\nload\nload\n \n \nI\nn\nv\no\nke\nr\n3. execute()\n2. execute()\n1. execute()\nCrash!\nRestore\nAfter a system \nfailure, the objects are \nreloaded and executed \nin the correct order.\nWe add two methods \nfor logging.\n", "page": 268, "type": "text", "section": "Page 268"}
{"text": "you are here 4\u2003 \u2003 231\nthe command pattern\nCommand Pattern in the Real World\nRemember the little life-changing application from Chapter 2?\n%java SwingObserverExample\nCome on, do it!\nDon\u2019t do it, you might regret it!\n%\nAnd here\u2019s the output when \nwe click on the button.\nHere\u2019s our fancy interface.\nAngel answer\nDevil answer\npublic class SwingObserverExample {\n\t\n// Set up ...\n        JButton button = new JButton(\"Should I do it?\");\n        button.addActionListener(new AngelListener());\n        button.addActionListener(new DevilListener());\n        // Set frame properties here\n    }\n    class AngelListener implements ActionListener {\n        public void actionPerformed(ActionEvent event) {\n            System.out.println(\"Don't do it, you might regret it!\");\n        }\n    }\n    class DevilListener implements ActionListener {\n        public void actionPerformed(ActionEvent event) {\n            System.out.println(\"Come on, do it!\");\n        }\n    }\n}\nIn that chapter we saw how Java\u2019s Swing \nlibrary is chock full of Observers in the \nform of ActionListeners that listen in (or \nobserve) events on user interface components. \nWell, it turns out that ActionListener  is \nnot just an Observer interface, it\u2019s also a \nCommand interface, and our AngelListener \nand DevilListener classes are not just \nObservers, but also concrete Commands. \nThat\u2019s right, we have two patterns in one \nexample! \nHere\u2019s the code (the important bits anyway) for the little life-changing \napplication from Chapter 2. See if you can identify who is the Client, who are \nthe Commands, who is the Invoker, and who is the Receiver.\nFile  Edit  Window  Help  HeMadeMeDoIt\n", "page": 269, "type": "text", "section": "Page 269"}
{"text": "232\u2003 \u2003 Chapter 6\nexercise solution\npublic class SwingObserverExample {\n\t\n// Set up ...\n        JButton button = new JButton(\"Should I do it?\");\n        button.addActionListener(new AngelListener());\n        button.addActionListener(new DevilListener());\n        // Set frame properties here\n    }\n    class AngelListener implements ActionListener {\n        public void actionPerformed(ActionEvent event) {\n            System.out.println(\"Don't do it, you might regret it!\");\n        }\n    }\n    class DevilListener implements ActionListener {\n        public void actionPerformed(ActionEvent event) {\n            System.out.println(\"Come on, do it!\");\n        }\n    }\n}\nHere\u2019s the code (the important bits anyway) for the little life-changing \napplication from Chapter 2. See if you can identify who is the Client, who are \nthe Commands, who is the Invoker, and who is the Receiver?\nHere\u2019s our solution.\nThe Client is the class that sets up the \nSwing components and sets the commands \n(AngelListener and DevilListener) in the \nInvoker (the Button).\nThe button is our Invoker. The button \ncalls the actionPerformed() (like \nexecute()) methods in the commands (the \nActionListeners) when you click the button.\nActionListener is the Command \nInterface: it has one method, \nactionPerformed() that, like \nexecute(), is executed when the \ncommand is invoked.\nAngelListener and DevilListener \nare our concrete Commands. They \nimplement the command interface (in \nthis case, ActionListener).\nThe Receiver in this example is the System object. \nRemember, invoking a command results in actions on \nthe Receiver. In a typical Swing application this would \nresult in calling actions on other components in the UI. \n", "page": 270, "type": "text", "section": "Page 270"}
{"text": "you are here 4\u2003 \u2003 233\nthe command pattern\nTools for your Design Toolbox\nYour toolbox is starting to get heavy! In this chapter \nwe\u2019ve added a pattern that allows us to encapsulate \nmethods into Command objects: store them, pass them \naround, and invoke them when you need them.\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies.\nFavor composition over inheritance.\nProgram to interfaces, not \nimplementations.\nStrive for loosely coupled designs \nbetween objects that interact.\nClasses should be open for extension \nbut closed for modification.\nDepend on abstractions. Do not \ndepend on concrete classes.\nOO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable.  Strategy lets the algorithm \nvary independently from clients that use it.\nOO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically.  \nDecorators provide a flexible \nalternative to subclassing for extending \nfunctionality.\nAbstract Factory - Provide \nan interface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes.\nFactory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate.  Factory Method lets \na class defer instantiation to the \nsubclasses.\nSingleton - Ensure a class only has \none instance and provide a global point \nof access to it.\nCommand - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nWhen you need to decouple an \nobject making requests from \nthe objects that know how to \nperform the requests, use the \nCommand Pattern.\n\t\n\u0083\nThe Command Pattern \ndecouples an object making \na request from the one that \nknows how to perform it.\n\t\n\u0083\nA Command object is at the \ncenter of this decoupling and \nencapsulates a receiver with \nan action (or set of actions).\n\t\n\u0083\nAn invoker makes a request \nof a Command object by \ncalling its execute() method, \nwhich invokes those actions \non the receiver.\n\t\n\u0083\nInvokers can be \nparameterized with \nCommands, even \ndynamically at runtime.\n\t\n\u0083\nCommands may support \nundo by implementing an \nundo() method that restores \nthe object to its previous \nstate before the execute() \nmethod was last called.\n\t\n\u0083\nMacroCommands are a \nsimple extension of the \nCommand Pattern that \nallow multiple commands \nto be invoked. Likewise, \nMacroCommands can easily \nsupport undo().\n\t\n\u0083\nIn practice, it\u2019s not \nuncommon for \u201csmart\u201d \nCommand objects to \nimplement the request \nthemselves rather than \ndelegating to a receiver.\n\t\n\u0083\nCommands may also be \nused to implement logging \nand transactional systems.\n", "page": 271, "type": "text", "section": "Page 271"}
{"text": "234\u2003 \u2003 Chapter 6\ndesign patterns crossword\nDesign Patterns Crossword\nTime to take a breather and let it all sink in.\nIt\u2019s another crossword; all of the solution words are from \nthis chapter.\nACROSS\n5. Our favorite city.\n6. Company that got us word-of-mouth business.\n7. Role of customer in the Command Pattern.\n9. Object that knows the actions and the receiver.\n12. Invoker and receiver are _________.\n15. The Waitress was one.\n16. Dr. Seuss diner food (four words).\n17. Another thing Command can do.\n\nDOWN\n1. The Cook and this person were definitely decoupled.\n2. The Waitress didn\u2019t do this.\n3. A command encapsulates this.\n4. Act as the receivers in the remote control (two words).\n8. Object that knows how to get things done.\n10. Carries out a request.\n11. All commands provide this.\n13. Our first command object controlled this.\n14. A command __________ a set of actions and a \nreceiver.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nAcross\n5. Our favorite city\n6. Company that got us word of mouth business\n7. Role of customer in the command pattern\n9. Object that knows the actions and the receiver\n12. Invoker and receiver are ______________\n15. The Waitress was one\n16. Dr. Seuss diner food\n17. Another thing Command can do\nDown\n1. The cook and this person were definitely \ndecoupled\n2. Waitress didn't do this\n3. A command encapsulates this\n4. Act as the receivers in the remote control (two \nwords)\n8. Object that knows how to get things done\n10. Carries out a request\n11. All commands provide this\n13. Our first command object controlled this\n14. A command ____ a set of actions and a receiver\n", "page": 272, "type": "text", "section": "Page 272"}
{"text": "you are here 4\u2003 \u2003 235\nthe command pattern\nSOlUTion\nMatch the diner objects and methods with the corresponding \nnames from the Command Pattern.\nDiner\nCommand Pattern\nWaitress\nShort-Order Cook\norderUp()\nOrder\nCustomer\ntakeOrder()\nCommand \nexecute()\nClient\nInvoker\nReceiver\nsetCommand()\nFile  Edit   Window  Help  GreenEggs&Ham\n%java RemoteControlTest\nLight is on\nGarage Door is Open\n%\nHere\u2019s the code for the GarageDoorOpenCommand class.  \nHere\u2019s the output:\npublic class GarageDoorOpenCommand implements Command {\n    GarageDoor garageDoor;\n    public GarageDoorOpenCommand(GarageDoor garageDoor) {\n        this.garageDoor = garageDoor;\n    }\n    public void execute() {\n        garageDoor.up();\n    }\n}\n", "page": 273, "type": "text", "section": "Page 273"}
{"text": "236\u2003 \u2003 Chapter 6\nexercise solutions\nHere\u2019s the code to create commands for the off button.\nLightOffCommand lightOff = new LightOffCommand(light);\nStereoOffCommand stereoOff = new StereoOffCommand(stereo);\nTVOffCommand tvOff = new TVOffCommand(tv);\nHottubOffCommand hottubOff = new HottubOffCommand(hottub);\nHere is the undo() \nmethod for the \nMacroCommand.\npublic class MacroCommand implements Command {\n    Command[] commands;\n    public MacroCommand(Command[] commands) {\n        this.commands = commands;\n    }\n    public void execute() {\n        for (int i = 0; i < commands.length; i++) {\n            commands[i].execute();\n        }\n    }\n    public void undo() {\n        for (int i = commands.length - 1; i >= 0; i--) {\n            commands[i].undo();\n        }\n    }\n}\nW\n1\nC\n2\nR\n3\nA\nV\n4\nO\n5\nB\nJ\nE\nC\nT\nV\nI\nL\nL\nE\nO\nQ\nT\nN\nK\nU\nR\nD\nW\n6\nE\nA\nT\nH\nE\nR\n-\nO\n-\nR\nA\nM\nA\nS\nS\nR\nC\n7\nL\nI\nE\nN\nT\nR\n8\nS\nC\n9\nO\nM\nM\nA\nN\nD\nE\nL\nR\n10\nC\nA\nE\n11\nD\n12\nE\nC\nO\nU\nP\nL\nE\nD\nS\nL\n13\nX\nC\nI\nS\nB\n14\nI\n15\nN\nV\nO\nK\nE\nR\nE\nV\nE\nI\nG\nC\nI\nG\n16\nR\nE\nE\nN\nE\nG\nG\nS\nA\nN\nD\nH\nA\nM\nU\n17\nN\nD\nO\nV\nR\nD\nT\nT\nE\nS\nE\nR\nAcross\n5. Our favorite city [OBJECTVILLE] \n6. Company that got us word of mouth business \n[WEATHER-O-RAMA] \n7 R l\nf\nt\ni\nth\nd\ntt\nDown\n1. The cook and this person were definitely \ndecoupled [WAITRESS] \n2. Waitress didn't do this [COOK] \n3 A\nd\nl t\nthi [REQUEST]\n", "page": 274, "type": "text", "section": "Page 274"}
{"text": "this is a new chapter\u2003 \u2003 237\nIn this chapter we\u2019re going to attempt such impossible feats \nas putting a square peg in a round hole. Sound impossible? Not when \nwe have Design Patterns. Remember the Decorator Pattern? We wrapped objects to \ngive them new responsibilities. Now we\u2019re going to wrap some objects with a different \npurpose: to make their interfaces look like something they\u2019re not. Why would we do that? \nSo we can adapt a design expecting one interface to a class that implements a different \ninterface. That\u2019s not all; while we\u2019re at it, we\u2019re going to look at another pattern that wraps \nobjects to simplify their interface.\nBeing Adaptive \n \n \n \n \n \n \n \n \n \n7  the Adapter and Facade Patterns\nYou mean it\u2019s not \nsupposed to be a \nfootball match?\nDo you think the \nreaders are really getting the \nimpression we\u2019re watching a \nhorse race rather than sitting \nin a photo studio?\nThat\u2019s the beauty of \nour profession: we can \nmake things look like \nsomething they\u2019re not!\nWrapped in this coat, \nI\u2019m a different man!\n", "page": 275, "type": "text", "section": "Page 275"}
{"text": "238\u2003 \u2003 Chapter 7\nadapters everywhere\nYou know what the adapter does: it sits in between the plug of your laptop and the \nBritish AC outlet; its job is to adapt the British outlet so that you can plug your laptop \ninto it and receive power. Or look at it this way: the adapter changes the interface of the \noutlet into one that your laptop expects.\nSome AC adapters are simple\u2014they only change the shape of the outlet so that it \nmatches your plug, and they pass the AC current straight through\u2014but other adapters \nare more complex internally and may need to step the power up or down to match your \ndevices\u2019 needs.\nOkay, that\u2019s the real world; what about object-oriented adapters? Well, our OO adapters \nplay the same role as their real-world counterparts: they take an interface and adapt it \nto one that a client is expecting.  \nAdapters all around us\nYou\u2019ll have no trouble understanding what an OO adapter is \nbecause the real world is full of them. How\u2019s this for an example: \nHave you ever needed to use a US-made laptop in Great Britain? \nThen you\u2019ve probably needed an AC power adapter...\nBritish Wall Outlet\nUS Standard AC Plug\nAC Power Adapter\nThe British wall outlet exposes \none interface for getting power.\nThe US laptop expects \nanother interface.\nThe adapter converts one \ninterface into another.\nHow many other real-world \nadapters can you think of?\n", "page": 276, "type": "text", "section": "Page 276"}
{"text": "you are here 4\u2003 \u2003 239\nthe adapter and facade patterns\nSay you\u2019ve got an existing software system that you need to work a new vendor class library \ninto, but the new vendor designed their interfaces differently than the last vendor:\nObject-oriented adapters\nOkay, you don\u2019t want to solve the problem by changing your existing code (and you can\u2019t \nchange the vendor\u2019s code). So what do you do? Well, you can write a class that adapts the \nnew vendor interface into the one you\u2019re expecting.\nThe adapter acts as the middleman by receiving requests from the client and converting \nthem into requests that make sense on the vendor classes.\nAdapter\nVendor \nClass\nYour \nExisting \nSystem\nVendor \nClass\nYour \nExisting \nSystem\nTheir interface doesn\u2019t match the one you\u2019ve written \nyour code against. This isn\u2019t going to work!\nThe adapter implements the \ninterface your classes expect...\n...and talks to the vendor interface \nto service your requests.\nNo code changes.\nNo code changes.\nNew code.\nCan you think of a solution \nthat doesn\u2019t require YOU to \nwrite ANY additional code \nto integrate the new vendor \nclasses? How about making the \nvendor supply the adapter class?\nVendor \nClass\nAdapter\nYour \nExisting \nSystem\n", "page": 277, "type": "text", "section": "Page 277"}
{"text": "240\u2003 \u2003 Chapter 7\nturkey adapter\npublic interface Turkey {\n    public void gobble();\n    public void fly();\n}\npublic class MallardDuck implements Duck {\n    public void quack() {\n        System.out.println(\"Quack\");\n    }\n \n    public void fly() {\n        System.out.println(\"I'm flying\");\n    }\n}\npublic interface Duck {\n    public void quack();\n    public void fly();\n}\nIf it walks like a duck and quacks like a duck, \nthen it must might be a duck turkey wrapped \nwith a duck adapter...\nIt\u2019s time to see an adapter in action. Remember our ducks from Chapter 1? \nLet\u2019s review a slightly simplified version of the Duck interfaces and classes:\nThis time around, our \nducks implement a Duck \ninterface that allows \nDucks to quack and fly.\nHere\u2019s a subclass of Duck, the MallardDuck:\nSimple implementations: MallardDuck \njust prints out what it is doing.\nNow it\u2019s time to meet the newest fowl on the block:\nTurkeys don\u2019t quack, they gobble.\nTurkeys can fly, although they \ncan only fly short distances.\n", "page": 278, "type": "text", "section": "Page 278"}
{"text": "you are here 4\u2003 \u2003 241\nthe adapter and facade patterns\npublic class WildTurkey implements Turkey {\n    public void gobble() {\n        System.out.println(\"Gobble gobble\");\n    }\n \n    public void fly() {\n        System.out.println(\"I'm flying a short distance\");\n    }\n}\npublic class TurkeyAdapter implements Duck {\n    Turkey turkey;\n \n    public TurkeyAdapter(Turkey turkey) {\n        this.turkey = turkey;\n    }\n    \n    public void quack() {\n        turkey.gobble();\n    }\n  \n    public void fly() {\n        for(int i=0; i < 5; i++) {\n            turkey.fly();\n        }\n    }\n}\nHere\u2019s a concrete implementation \nof Turkey; like MallardDuck, it \njust prints out its actions.\nNow, let\u2019s say you\u2019re short on Duck objects and you\u2019d like to use some Turkey objects in their \nplace. Obviously we can\u2019t use the turkeys outright because they have a different interface.\nSo, let\u2019s write an Adapter:\nCode Up Close\nFirst, you need to implement the interface \nof the type you\u2019re adapting to. This is the \ninterface your client expects to see.\nNext, we need to get a reference to the \nobject that we are adapting; here we do \nthat through the constructor.\nNow we need to implement all the methods in \nthe interface; the quack() translation between \nclasses is easy: just call the gobble() method.\nEven though both interfaces have a fly() \nmethod, Turkeys fly in short spurts\u2014\nthey can\u2019t do long-distance flying like \nducks. T\no map between a Duck\u2019s fly() \nmethod and a Turkey\u2019s, we need to call \nthe Turkey\u2019s fly() method five times to \nmake up for it.\n", "page": 279, "type": "text", "section": "Page 279"}
{"text": "242\u2003 \u2003 Chapter 7\ntest the adapter\npublic class DuckTestDrive {\n    public static void main(String[] args) {\n        Duck duck = new MallardDuck();\n \n        Turkey turkey = new WildTurkey();\n        Duck turkeyAdapter = new TurkeyAdapter(turkey);\n   \n        System.out.println(\"The Turkey says...\");\n        turkey.gobble();\n        turkey.fly();\n \n        System.out.println(\"\\nThe Duck says...\");\n        testDuck(duck);\n  \n        System.out.println(\"\\nThe TurkeyAdapter says...\");\n        testDuck(turkeyAdapter);\n    }\n \n    static void testDuck(Duck duck) {\n        duck.quack();\n        duck.fly();\n    }\n}\nTest drive the adapter\nFile  Edit   Window  Help  Don\u2019tForgetToDuck\n%java DuckTestDrive\nThe Turkey says...\nGobble gobble\nI'm flying a short distance\nThe Duck says...\nQuack\nI'm flying\nThe TurkeyAdapter says...\nGobble gobble\nI'm flying a short distance\nI'm flying a short distance\nI'm flying a short distance\nI'm flying a short distance\nI'm flying a short distance\nLet\u2019s create a Duck...\nNow we just need some code to test drive our adapter:\n...and a Turkey.\nAnd then wrap the turkey \nin a TurkeyAdapter, which \nmakes it look like a Duck.\nNow let\u2019s test the duck \nby calling the testDuck() \nmethod, which expects a \nDuck object.\nThen, let\u2019s test the Turkey: \nmake it gobble, make it fly.\nNow the big test: we try to pass \noff the turkey as a duck...\nThe Duck quacks and flies \njust like you\u2019d expect.\nThe Turkey gobbles and \nflies a short distance.\nAnd the adapter gobbles when \nquack() is called and flies a few times \nwhen fly() is called. The testDuck() \nmethod never knows it has a turkey \ndisguised as a duck!\nHere\u2019s our testDuck() method; it \ngets a duck and calls its quack() \nand fly() methods.\nT\nest run\n", "page": 280, "type": "text", "section": "Page 280"}
{"text": "you are here 4\u2003 \u2003 243\nthe adapter and facade patterns\nAdaptee\nClient\nAdapter\nrequest()\ntranslatedRequest()\nThe Adapter Pattern explained\nThe Client is implemented \nagainst the target interface.\nThe Adapter implements the \ntarget interface and holds an \ninstance of the Adaptee.\ntarget interface\nadaptee \ninterface\nNow that we have an idea of what an Adapter is, let\u2019s step back and look \nat all the pieces again.  \nThe client makes a request to the adapter by \ncalling a method on it using the target interface.\nThe adapter translates the request into one or \nmore calls on the adaptee using the adaptee \ninterface.\nThe client receives the results of the call and never \nknows there is an adapter doing the translation.\nHere\u2019s how the Client uses the Adapter\n1\n2\n3\nNote that the Client and Adaptee \nare decoupled\u2014neither knows about \nthe other.\nTurkeyAdapter implemented \nthe target interface, Duck.\nTurkey was the \nadaptee interface.\n", "page": 281, "type": "text", "section": "Page 281"}
{"text": "244\u2003 \u2003 Chapter 7\nadapter pattern defined\nLet\u2019s say we also need an Adapter that converts a Duck to a \nTurkey. Let\u2019s call it DuckAdapter. Write that class:\nHow did you handle the fly() method (after all, we know ducks fly longer than turkeys)? \nCheck the answers at the end of the chapter for our solution. Did you think of a better way?\nQ: How much \u201cadapting\u201d does an \nadapter need to do? It seems like if I need \nto implement a large target interface, I \ncould have a LOT of work on my hands.\nA: You certainly could. The job of \nimplementing an adapter really is \nproportional to the size of the interface you \nneed to support as your target interface. \nThink about your options, however. You \ncould rework all your client-side calls to \nthe interface, which would result in a lot \nof investigative work and code changes. \nOr, you can cleanly provide one class that \nencapsulates all the changes in that class.\nQ: Does an adapter always wrap one \nand only one class?\nA: The Adapter Pattern\u2019s role is to convert \none interface into another. While most \nexamples of the Adapter Pattern show an \nadapter wrapping one adaptee, we both \nknow the world is often a bit more messy. \nSo, you may well have situations where an \nadapter holds two or more adaptees that are \nneeded to implement the target interface. \n\nThis relates to another pattern called the \nFacade Pattern; people often confuse the \ntwo. Remind us to revisit this point when we \ntalk about facades later in this chapter.\nQ: What if I have old and new parts \nof my system, and the old parts expect \nthe old vendor interface, but we\u2019ve \nalready written the new parts to use the \nnew vendor interface? It's going to get \nconfusing using an adapter here and the \nunwrapped interface there. Wouldn\u2019t I be \nbetter off just writing my older code and \nforgetting the adapter?\nA: Not necessarily. One thing you can do \nis create a Two Way Adapter that supports \nboth interfaces. To create a Two Way \nAdapter, just implement both interfaces \ninvolved, so the adapter can act as an old \ninterface or a new interface.\n", "page": 282, "type": "text", "section": "Page 282"}
{"text": "you are here 4\u2003 \u2003 245\nthe adapter and facade patterns\nAdapter Pattern defined\nThe Adapter Pattern converts the interface of a class \ninto another interface the clients expect. Adapter lets \nclasses work together that couldn\u2019t otherwise because of \nincompatible interfaces.\nEnough ducks, turkeys, and AC power adapters; let\u2019s get real and look at the official \ndefinition of the Adapter Pattern:\nNow, we know this pattern allows us to use a client with an incompatible interface by \ncreating an Adapter that does the conversion. This acts to decouple the client from \nthe implemented interface, and if we expect the interface to change over time, the \nadapter encapsulates that change so that the client doesn\u2019t have to be modified each \ntime it needs to operate against a different interface. \nWe\u2019ve taken a look at the runtime behavior of the pattern; let\u2019s take a look at its class \ndiagram as well:\nspecificRequest()\nClient\nAdaptee\nrequest()\n<<interface>>\nTarget\nrequest()\nAdapter\nThe Adapter Pattern is full of good object-oriented design principles: check out the use of \nobject composition to wrap the adaptee with an altered interface. This approach has the \nadded advantage that we can use an adapter with any subclass of the adaptee. \nAlso check out how the pattern binds the client to an interface, not an implementation; we \ncould use several adapters, each converting a different backend set of classes. Or, we could \nadd new implementations after the fact, as long as they adhere to the Target interface.\nThe Adapter implements \nthe T\narget interface.\nAdapter is composed \nwith the Adaptee.\nAll requests get \ndelegated to the \nAdaptee.\nThe client sees only the \nT\narget interface.\n", "page": 283, "type": "text", "section": "Page 283"}
{"text": "246\u2003 \u2003 Chapter 7\nobject and class adapters\nObject and class adapters\nNow despite having defined the pattern, we haven\u2019t told you the whole story yet. \nThere are actually two kinds of adapters: object adapters and class adapters. This \nchapter has covered object adapters, and the class diagram on the previous page is \na diagram of an object adapter.\nSo what\u2019s a class adapter and why haven\u2019t we told you about it? Because you need \nmultiple inheritance to implement it, which isn\u2019t possible in Java. But that doesn\u2019t \nmean you might not encounter a need for class adapters down the road when using \nyour favorite multiple inheritance language! Let\u2019s look at the class diagram for \nmultiple inheritance.\nspecificRequest()\nrequest()\nAdapter\nClient\nAdaptee\nrequest()\nTarget\nInstead of using composition \nto adapt the Adaptee, the \nAdapter now subclasses the \nAdaptee and the T\narget classes.\nLook familiar? That\u2019s right\u2014the only difference is that with a class adapter \nwe subclass the Target and the Adaptee, while with an object adapter we use \ncomposition to pass requests to an Adaptee.  \nObject adapters and class adapters use two different \nmeans of adapting the adaptee (composition \nversus inheritance). How do these implementation \ndifferences affect the flexibility of the adapter?\n", "page": 284, "type": "text", "section": "Page 284"}
{"text": "you are here 4\u2003 \u2003 247\nthe adapter and facade patterns\nYour job is to take the duck and turkey magnets and drag \nthem over the part of the diagram that describes the role \nplayed by that bird, in our earlier example. (Try not to flip \nback through the pages.) Then add your own annotations \nto describe how it works.\nDuck Magnets\nspecificRequest()\nClient\nAdaptee\nrequest()\n<<interface>>\nTarget\nrequest()\nAdapter\nspecificRequest()\nrequest()\nAdapter\nClient\nAdaptee\nrequest()\nTarget\nClass Adapter\nObject Adapter\nDrag these onto the class diagram \nto show which part of the diagram \nrepresents the Duck class and which \nrepresents the Turkey class.\n", "page": 285, "type": "text", "section": "Page 285"}
{"text": "248\u2003 \u2003 Chapter 7\nexercise answer\nDuck Magnets \nAnswer\nspecificRequest()\nrequest()\nAdapter\nClient\nAdaptee\nrequest()\nTarget\nspecificRequest()\nClient\nAdaptee\nrequest()\n<<interface>>\nTarget\nrequest()\nAdapter\nClass Adapter\nObject Adapter\nClient thinks he\u2019s \ntalking to a Duck.\nThe T\narget is the \nDuck class. This \nis what the client \ninvokes methods on.\nThe Adapter lets the Turkey respond to \nrequests on a Duck, by extending BOTH \nclasses (Duck and Turkey).\nThe Turkey class does not \nhave the same methods as \nDuck, but the Adapter can \ntake Duck method calls \nand turn around and invoke \nmethods on the Turkey class.\nNote: the class adapter uses \nmultiple inheritance, so you \ncan\u2019t do it in Java...\nClient thinks he\u2019s \ntalking to a Duck.\nJust as with the Class \nAdapter, the T\narget is the \nDuck class. This is what the \nclient invokes methods on.\nThe Turkey class doesn\u2019t have the same \ninterface as the Duck. In other words, \nTurkeys don\u2019t have quack() methods, etc.\nThe Adapter implements the Duck \ninterface, but when it gets a \nmethod call it turns around and \ndelegates the calls to Turkey.\nThanks to the Adapter, the Turkey \n(Adaptee) will get calls that the \nclient makes on the Duck interface.\nDuck interface\nTurkey \nobject\nDuck class\nTurkey class\n", "page": 286, "type": "text", "section": "Page 286"}
{"text": "you are here 4\u2003 \u2003 249\nthe adapter and facade patterns\nTonight\u2019s talk: Object Adapter and Class \nAdapter meet face to face.\nObject Adapter:\nBecause I use composition I\u2019ve got a leg up. I can \nadapt not only an adaptee class, but any of its \nsubclasses.\n\n\n\nIn my part of the world, we like to use composition \nover inheritance; you may be saving a few lines \nof code, but all I\u2019m doing is writing a little code \nto delegate to the adaptee. We like to keep things \nflexible. \nYou\u2019re worried about one little object? You might be \nable to quickly override a method, but any behavior \nI add to my adapter code works with my adaptee \nclass and all its subclasses.\n\n\nHey, come on, cut me some slack, I just need to \ncompose with the subclass to make that work.\nYou wanna see messy? Look in the mirror!\nClass Adapter:\n\n\n\nThat\u2019s true, I do have trouble with that because I \nam committed to one specific adaptee class, but \nI have a huge advantage because I don\u2019t have to \nreimplement my entire adaptee. I can also override \nthe behavior of my adaptee if I need to because I\u2019m \njust subclassing.\n\n\nFlexible maybe, but efficient? No. There is just one \nof me, not an adapter and an adaptee.\nYeah, but what if a subclass of Adaptee adds some \nnew behavior\u2014then what?\nSounds messy...\n", "page": 287, "type": "text", "section": "Page 287"}
{"text": "250\u2003 \u2003 Chapter 7\nreal world adapters\nReal-world adapters\nIf you\u2019ve been around Java for a while, you \nprobably remember that the early collection \ntypes (Vector, Stack, Hashtable, and a few \nothers) implement a method, elements(), which \nreturns an Enumeration. The Enumeration \ninterface allows you to step through the \nelements of a collection without knowing \nthe specifics of how they are managed in the \ncollection. \n<<interface>>\nEnumeration\nhasMoreElements()\nnextElement()\nT\nells you if there are any more \nelements in the collection.\nGives you the next element \nin the collection.\nThe more recent Collection classes use an \nIterator interface that, like the Enumeration \ninterface, allows you to iterate through a set of \nitems in a collection, and adds the ability to \nremove items.\n<<interface>\nIterator\nAnalogous to hasMoreElements() \nin the Enumeration interface.  \nThis method just tells you if \nyou\u2019ve looked at all the items in \nthe collection.\nGives you the next \nelement in the collection.\nRemoves an item from \nthe collection.\nWe are sometimes faced with legacy code that exposes the \nEnumeration interface, yet we\u2019d like for our new code to use only \nIterators. It looks like we need to build an adapter.\nEnumerators\nIterators\nUsing Enumerators with code that expects Iterators\nLet\u2019s take a look at the use of a simple Adapter in the real world \n(something more serious than Ducks at least)...\nEnumeration has a simple interface.\nhasNext()\nnext()\nremove()\n", "page": 288, "type": "text", "section": "Page 288"}
{"text": "you are here 4\u2003 \u2003 251\nthe adapter and facade patterns\nAdapting an Enumeration to an Iterator\n<<interface>>\nEnumeration\nhasMoreElements()\nnextElement()\n<<interface>>\nIterator\nhasNext()\nnext()\nremove()\nThese two methods look easy. \nThey map straight to hasNext() \nand next() in Iterator.\nBut what about this method \nremove() in Iterator? There\u2019s \nnothing like that in Enumeration.\nHere\u2019s what the classes should look like: we need an adapter that implements the Target \ninterface and is composed with an adaptee. The hasNext() and next() methods are going \nto be straightforward to map from target to adaptee: we just pass them right through. \nBut what do you do about remove()? Think about it for a moment (and we\u2019ll deal with it \non the next page). For now, here\u2019s the class diagram:\n<<interface>>\nEnumeration\nhasMoreElements()\nnextElement()\n<<interface>>\nIterator\nhasNext()\nnext()\nremove()\nYour new code still gets \nto use Iterators, even \nif there\u2019s really an \nEnumeration underneath.\nEnumerationIterator\nhasNext()\nnext()\nremove()\nEnumerationIterator \nis the adapter.\nA class \nimplementing \nthe Enumeration \ninterface is the \nadaptee.\nWe\u2019re making the Enumerations \nin your old code look like \nIterators for your new code.\nT\narget interface\nAdaptee interface\nDesigning the Adapter\nFirst we\u2019ll look at the two interfaces to figure out how the methods map from one to \nthe other. In other words, we\u2019ll figure out what to call on the adaptee when the client \ninvokes a method on the target.\n", "page": 289, "type": "text", "section": "Page 289"}
{"text": "252\u2003 \u2003 Chapter 7\nenumeration iterator adapter\npublic class EnumerationIterator implements Iterator<Object> {\n    Enumeration<?> enumeration;\n \n    public EnumerationIterator(Enumeration<?> enumeration) {\n        this.enumeration = enumeration;\n    }\n \n    public boolean hasNext() {\n        return enumeration.hasMoreElements();\n    }\n \n    public Object next() {\n        return enumeration.nextElement();\n    }\n \n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n}\nSince we\u2019re adapting \nEnumeration to Iterator, \nour Adapter implements the \nIterator interface...it has to \nlook like an Iterator.\nThe Enumeration we\u2019re \nadapting. We\u2019re using \ncomposition, so we stash it \nin an instance variable.\nThe Iterator\u2019s hasNext() method \nis delegated to the Enumeration\u2019s \nhasMoreElements() method...\n...and the Iterator\u2019s next() method \nis delegated to the Enumeration\u2019s \nnextElement() method.\nUnfortunately, we can\u2019t support \nIterator\u2019s remove() method, so \nwe have to punt (in other words, \nwe give up!). Here we just throw \nan exception.\nWell, we know Enumeration doesn\u2019t support remove(). It\u2019s a \u201cread only\u201d interface. There\u2019s no \nway to implement a fully functioning remove() method on the adapter. The best we can do is \nthrow a runtime exception. Luckily, the designers of the Iterator interface foresaw this need and \ndefined the remove() method so that it supports an UnsupportedOperationException.\nThis is a case where the adapter isn\u2019t perfect; clients will have to watch out for potential \nexceptions, but as long as the client is careful and the adapter is well documented, this is a \nperfectly reasonable solution. \nDealing with the remove() method\nWriting the EnumerationIterator adapter\nHere\u2019s simple but effective code for all those legacy classes still producing Enumerations:\n", "page": 290, "type": "text", "section": "Page 290"}
{"text": "you are here 4\u2003 \u2003 253\nthe adapter and facade patterns\nWhile Java has gone in the direction of the Iterator interface, there is nevertheless still legacy \nclient code that depends on the Enumeration interface, so an Adapter that converts an Iterator to \nan Enumeration could potentially be useful. \nWrite an Adapter that adapts an Iterator to an Enumeration. You can test your code by \nadapting an ArrayList. The ArrayList class supports the Iterator interface but doesn\u2019t support \nEnumerations.\nSome AC adapters do more than just change the interface\u2014they add other features \nlike surge protection, indicator lights, and other bells and whistles.\nIf you were going to implement these kinds of features, what pattern would you use?\n", "page": 291, "type": "text", "section": "Page 291"}
{"text": "254\u2003 \u2003 Chapter 7\nfireside chats: decorator and adapter\nTonight\u2019s talk: The Decorator Pattern and the Adapter \nPattern discuss their differences.\nDecorator:\nI\u2019m important. My job is all about responsibility\u2014you \nknow that when a Decorator is involved, there\u2019s \ngoing to be some new responsibilities or behaviors \nadded to your design.\n\n\n\nThat may be true, but don\u2019t think we don\u2019t work \nhard. When we have to decorate a big interface, \nwhoa, that can take a lot of code.\nCute. Don\u2019t think we get all the glory; sometimes \nI\u2019m just one decorator that is being wrapped by who \nknows how many other decorators. When a method \ncall gets delegated to you, you have no idea how \nmany other decorators have already dealt with it \nand you don\u2019t know that you\u2019ll ever get noticed for \nyour efforts servicing the request.\nAdapter:\n\n\n\n\nYou decorators want all the glory while us adapters \nare down in the trenches doing the dirty work: \nconverting interfaces. Our jobs may not be \nglamorous, but our clients sure do appreciate us \nmaking their lives simpler.\n\n\nTry being an adapter when you\u2019ve got to bring \nseveral classes together to provide the interface your \nclient is expecting. Now that\u2019s tough. But we have a \nsaying: \u201cA decoupled client is a happy client.\u201d\nHey, if adapters are doing their job, our clients \nnever even know we\u2019re there. It can be a thankless \njob.  \n", "page": 292, "type": "text", "section": "Page 292"}
{"text": "you are here 4\u2003 \u2003 255\nthe adapter and facade patterns\nDecorator:\nWell, us decorators do that as well, only we allow \nnew behavior to be added to classes without altering \nexisting code. I still say that adapters are just fancy \ndecorators\u2014I mean, just like us, you wrap an object.\n\n\n\nUh, no. Our job in life is to extend the behaviors or \nresponsibilities of the objects we wrap; we aren\u2019t a \nsimple pass through.\nMaybe we should agree to disagree. We seem to \nlook somewhat similar on paper, but clearly we are \nmiles apart in our intent.\nAdapter:\nBut the great thing about us adapters is that we \nallow clients to make use of new libraries and \nsubsets without changing any code; they just rely on \nus to do the conversion for them. Hey, it\u2019s a niche, \nbut we\u2019re good at it.\n\n\nNo, no, no, not at all. We always convert the \ninterface of what we wrap; you never do. I\u2019d say a \ndecorator is like an adapter; it's just that you don\u2019t \nchange the interface!\nHey, who are you calling a simple pass through? \nCome on down and we\u2019ll see how long you last \nconverting a few interfaces!\nOh yeah, I\u2019m with you there.\n", "page": 293, "type": "text", "section": "Page 293"}
{"text": "256\u2003 \u2003 Chapter 7\nwho does what?\nAnd now for something different...\nThere\u2019s another pattern in this chapter.\nYou\u2019ve seen how the Adapter Pattern converts the interface of a class into one \nthat a client is expecting. You also know we achieve this in Java by wrapping \nthe object that has an incompatible interface with an object that implements \nthe correct one.\nWe\u2019re going to look at a pattern now that alters an interface, but for a different \nreason: to simplify the interface. It\u2019s aptly named the Facade Pattern because \nthis pattern hides all the complexity of one or more classes behind a clean, \nwell-lit facade.\nMatch each pattern with its intent:\nPattern\nIntent\nDecorator\nAdapter\nFacade\nConverts one interface to \nanother\nDoesn\u2019t alter the interface, \nbut adds responsibility\nMakes an interface simpler\n", "page": 294, "type": "text", "section": "Page 294"}
{"text": "you are here 4\u2003 \u2003 257\nthe adapter and facade patterns\nAmplifier\ntuner\nplayer\non()\noff()\nsetStreamingPlayer()\nsetStereoSound()\nsetSurroundSoud()\nsetTuner()\nsetVolume()\ntoString()\nStreamingPlayer\namplifier\non()\noff()\npause()\nplay()\nsetSurroundAudio()\nsetTwoChannelAudio()\nstop()\ntoString()\nTuner\non()\noff()\nsetAm()\nsetFm()\nsetFrequency()\ntoString()\namplifier\nScreen\nup()\ndown()\ntoString()\nProjector\non()\noff()\ntvMode()\nwideScreenMode()\ntoString()\nplayer\nPopcornPopper\non()\noff()\npop()\ntoString()\nTheaterLights\non()\noff()\ndim()\ntoString()\nBefore we dive into the details of the Facade Pattern, let\u2019s take a look at a \ngrowing national obsession: building a nice theater to binge-watch all those \nmovies and TV series.\nYou\u2019ve done your research and you\u2019ve assembled a killer system complete \nwith a streaming player, a projection video system, an automated screen, \nsurround sound, and even a popcorn popper.\nCheck out all the components you\u2019ve put together:\nHome Sweet Home Theater\nYou\u2019ve spent weeks running wire, mounting the projector, making all the \nconnections, and fine tuning. Now it\u2019s time to put it all in motion and enjoy a \nmovie...\nThat\u2019s a lot of \nclasses, a lot \nof interactions, \nand a big set \nof interfaces to \nlearn and use.\n", "page": 295, "type": "text", "section": "Page 295"}
{"text": "258\u2003 \u2003 Chapter 7\ntasks to watch a movie\nPick out a movie, relax, and get ready for movie magic. \nOh, there\u2019s just one thing\u2014to watch the movie, you need \nto perform a few tasks:\nWatching a movie (the hard way)\nTurn on the popcorn popper\nStart the popper popping\nDim the lights\nPut the screen down\nTurn the projector on\nPut the projector on widescreen mode\nTurn the sound amplifier on\nSet the amplifier to streaming player input\nSet the amplifier to surround sound\nSet the amplifier volume to medium (5)\nTurn the streaming player on\n12\n11\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n13\nSet the projector input to streaming player\nI\u2019m already exhausted \nand all I\u2019ve done is turn \neverything on!\nStart playing the movie\n", "page": 296, "type": "text", "section": "Page 296"}
{"text": "you are here 4\u2003 \u2003 259\nthe adapter and facade patterns\npopper.on();\npopper.pop();\nlights.dim(10);\nscreen.down();\nprojector.on();\nprojector.setInput(player);\nprojector.wideScreenMode();\namp.on();\namp.setStreamingPlayer(player);\namp.setSurroundSound();\namp.setVolume(5);\nplayer.on();\nplayer.play(movie);\nTurn on the popcorn popper and start \npopping...\n\nDim the lights to 10%...\nPut the screen down...\nTurn on the projector and put it in \nwidescreen mode for the movie...\n\nTurn on the amp, set it to Streaming \nplayer, put it in surround-sound mode, \nand set the volume to 5...\n\nTurn on the Streaming player... \nand FINALLY, play the movie!\nLet\u2019s check out those same tasks in terms of the classes and the \nmethod calls needed to perform them:\nSix different classes \ninvolved!\nBut there\u2019s more...\n\t\n\u0083\nWhen the movie is over, how do you turn everything off? Wouldn\u2019t you have to do all \nof this over again, in reverse?\n\t\n\u0083\nWouldn\u2019t it be as complex to listen to the radio?\n\t\n\u0083\nIf you decide to upgrade your system, you\u2019re probably going to have to learn a slightly \ndifferent procedure.\nSo what to do? The complexity of using your home theater is becoming apparent!\nLet\u2019s see how the Facade Pattern can get us out of this mess so we can enjoy the movie...\n", "page": 297, "type": "text", "section": "Page 297"}
{"text": "260\u2003 \u2003 Chapter 7\nlights, camera, facade\nA Facade is just what you need: with the Facade Pattern you can take a complex \nsubsystem and make it easier to use by implementing a Facade class that provides \none, more reasonable interface. Don\u2019t worry; if you need the power of the complex \nsubsystem, it\u2019s still there for you to use, but if all you need is a straightforward \ninterface, the Facade is there for you. \n Let\u2019s take a look at how the Facade operates:\nLights, Camera, Facade!  \nwatchMovie()\nendMovie()\nlistenToRadio()\nendRadio()\nHomeTheaterFacade\nTheaterLights\non()\noff()\ndim()\ntoString()\nPopcornPopper\non()\noff()\npop()\ntoString()\nScreen\nup()\ndown()\ntoString()\nTuner\non()\noff()\nsetAm()\nsetFm()\nsetFrequency()\ntoString()\namplifier\nAmplifier\ntuner\nplayer\non()\noff()\nsetStreamingPlayer()\nsetStereoSound()\nsetSurroundSoud()\nsetTuner()\nsetVolume()\ntoString()\nProjector\non()\noff()\ntvMode()\nwideScreenMode()\ntoString()\nplayer\nStreamingPlayer\namplifier\non()\noff()\npause()\nplay()\nsetSurroundAudio()\nsetTwoChannelAudio()\nstop()\ntoString()\nOkay, time to create a \nFacade for the home \ntheater system. To do this \nwe create a new class \nHomeTheaterFacade, \nwhich exposes a few \nsimple methods such as \nwatchMovie().\n1\nThe Facade\nThe subsystem the \nFacade is simplifying.\non()\nplay()\nThe Facade class treats \nthe home theater \ncomponents as a \nsubsystem, and calls \non the subsystem \nto implement its \nwatchMovie() method.\n2\n", "page": 298, "type": "text", "section": "Page 298"}
{"text": "you are here 4\u2003 \u2003 261\nthe adapter and facade patterns\nwatchMovie()\nYour client code now calls \nmethods on the home theater \nFacade, not on the subsystem.  \nSo now to watch a movie we just \ncall one method, watchMovie(), \nand it communicates with \nthe lights, streaming player, \nprojector, amplifier, screen, and \npopcorn maker for us.\n3\nA client of the \nsubsystem facade.\nFormer president of the \nRushmore High School \nA/V Science Club.\nThe Facade still leaves the subsystem \naccessible so it can be used directly. If \nyou need the advanced functionality \nof the subsystem classes, they are \navailable for your use.\n4\nI\u2019ve got to have \nmy low-level access!\n", "page": 299, "type": "text", "section": "Page 299"}
{"text": "262\u2003 \u2003 Chapter 7\nfacade versus adapter\nA facade not \nonly simplifies \nan interface, it \ndecouples a client \nfrom a subsystem \nof components.\nFacades and \nadapters may \nwrap multiple \nclasses, but a \nfacade\u2019s intent is \nto simplify, while \nan adapter\u2019s \nis to convert \nthe interface \nto something \ndifferent.\nQ: If the facade encapsulates the \nsubsystem classes, how does a client \nthat needs lower-level functionality gain \naccess to them?\nA: Facades don\u2019t \u201cencapsulate\u201d the \nsubsystem classes; they merely provide a \nsimplified interface to their functionality. The \nsubsystem classes still remain available \nfor direct use by clients that need to use \nmore specific interfaces. This is a nice \nproperty of the Facade Pattern: it provides \na simplified interface while still exposing the \nfull functionality of the system to those who \nmay need it.\nQ: Does the facade add any \nfunctionality or does it just pass through \neach request to the subsystem?\nA: A facade is free to add its own \u201csmarts\u201d \nin addition to making use of the subsystem. \nFor instance, while our home theater facade \ndoesn\u2019t implement any new behavior, it is \nsmart enough to know that the popcorn \npopper has to be turned on before it can pop \n(as well as the details of how to turn on and \nstage a movie showing).\nQ: Does each subsystem have only \none facade?\nA: Not necessarily. The pattern certainly \nallows for any number of facades to be \ncreated for a given subsystem.\n\nQ: What is the benefit of the facade \nother than the fact that I now have a \nsimpler interface?\nA: The Facade Pattern also allows you \nto decouple your client implementation \nfrom any one subsystem. Let\u2019s say that you \nget a big raise and decide to upgrade your \nhome theater to all new components that \nhave different interfaces. Well, if you coded \nyour client to the facade rather than the \nsubsystem, your client code doesn\u2019t need to \nchange, just the facade (and hopefully the \nmanufacturer is supplying that!).\nQ: So the way to tell the difference \nbetween the Adapter Pattern and the \nFacade Pattern is that the adapter wraps \none class and the facade may represent \nmany classes?\nA: No! Remember, the Adapter Pattern \nchanges the interface of one or more classes \ninto one interface that a client is expecting. \nWhile most textbook examples show the \nadapter adapting one class, you may need to \nadapt many classes to provide the interface \na client is coded to. Likewise, a Facade may \nprovide a simplified interface to a single \nclass with a very complex interface.  \nThe difference between the two is not in \nterms of how many classes they \u201cwrap,\u201d it \nis in their intent. The intent of the Adapter \nPattern is to alter an interface so that it \nmatches one a client is expecting. The \nintent of the Facade Pattern is to provide a \nsimplified interface to a subsystem.\n", "page": 300, "type": "text", "section": "Page 300"}
{"text": "you are here 4\u2003 \u2003 263\nthe adapter and facade patterns\npublic class HomeTheaterFacade {\n    Amplifier amp;\n    Tuner tuner;\n    StreamingPlayer player;\n    Projector projector;\n    TheaterLights lights;\n    Screen screen;\n    PopcornPopper popper;\n \n    public HomeTheaterFacade(Amplifier amp, \n                 Tuner tuner, \n                 StreamingPlayer player; \n                 Projector projector, \n                 Screen screen,\n                 TheaterLights lights,\n                 PopcornPopper popper) {\n \n        this.amp = amp;\n        this.tuner = tuner;\n        this.player = player;\n        this.projector = projector;\n        this.screen = screen;\n        this.lights = lights;\n        this.popper = popper;\n    }\n \n        // other methods here\n \n}\nConstructing your home theater facade\nLet\u2019s step through the construction of the HomeTheaterFacade class. \nThe first step is to use composition so that the facade has access to all the \ncomponents of the subsystem:\nThe facade is passed a \nreference to each component \nof the subsystem in its \nconstructor. The facade \nthen assigns each to the \ncorresponding instance variable.\nHere\u2019s the composition; these \nare all the components of the \nsubsystem we are going to use.\nWe\u2019re just about to fill these in...\n", "page": 301, "type": "text", "section": "Page 301"}
{"text": "264\u2003 \u2003 Chapter 7\nimplementing facade\npublic void watchMovie(String movie) {\n    System.out.println(\"Get ready to watch a movie...\");\n    popper.on();\n    popper.pop();\n    lights.dim(10);\n    screen.down();\n    projector.on();\n    projector.wideScreenMode();\n    amp.on();\n    amp.setStreamingPlayer(player);\n    amp.setSurroundSound();\n    amp.setVolume(5);\n    player.on();\n    player.play(movie);\n}\n \npublic void endMovie() {\n    System.out.println(\"Shutting movie theater down...\");\n    popper.off();\n    lights.on();\n    screen.up();\n    projector.off();\n    amp.off();\n    player.stop();\n    player.off();\n}\nImplementing the simplified interface\nNow it\u2019s time to bring the components of the subsystem together into a unified interface. \nLet\u2019s implement the watchMovie() and endMovie() methods:\nwatchMovie() follows the same sequence \nwe had to do by hand before, but wraps \nit up in a handy method that does all \nthe work. Notice that for each task we \nare delegating the responsibility to the \ncorresponding component in the subsystem.\nAnd endMovie() takes care of \nshutting everything down for \nus. Again, each task is delegated \nto the appropriate component in \nthe subsystem. \nThink about the facades you\u2019ve encountered in the Java \nAPI. Where would you like to have a few new ones?\n", "page": 302, "type": "text", "section": "Page 302"}
{"text": "you are here 4\u2003 \u2003 265\nthe adapter and facade patterns\nHere\u2019s the output.\nCalling the Facade\u2019s \nwatchMovie() does all \nthis work for us...\n...and here, we\u2019re done \nwatching the movie, so \ncalling endMovie() turns \neverything off.\npublic class HomeTheaterTestDrive {\n    public static void main(String[] args) {\n        // instantiate components here\n \n        HomeTheaterFacade homeTheater = \n                new HomeTheaterFacade(amp, tuner, player, \n                        projector, screen, lights, popper);\n \n        homeTheater.watchMovie(\"Raiders of the Lost Ark\");\n        homeTheater.endMovie();\n    }\n}\nIt\u2019s showtime!  \nTime to watch a movie (the easy way)\n%java HomeTheaterTestDrive\nGet ready to watch a movie...\nPopcorn Popper on\nPopcorn Popper popping popcorn!\nTheater Ceiling Lights dimming to 10%\nTheater Screen going down\nProjector on\nProjector in widescreen mode (16x9 aspect ratio)\nAmplifier on\nAmplifier setting Streaming player to Streaming Player\nAmplifier surround sound on (5 speakers, 1 subwoofer)\nAmplifier setting volume to 5\nStreaming Player on\nStreaming Player playing \"Raiders of the Lost Ark\"\nShutting movie theater down...\nPopcorn Popper off\nTheater Ceiling Lights on\nTheater Screen going up\nProjector off\nAmplifier off\nStreaming Player stopped \"Raiders of the Lost Ark\"\nStreaming Player off\n%\nFile  Edit   Window  Help  SnakesWhy\u2019dItHaveToBeSnakes? \nFirst you instantiate \nthe Facade with all the \ncomponents in the subsystem. \nUse the simplified interface to \nfirst start the movie up, and \nthen shut it down.\nHere we\u2019re creating the components \nright in the test drive. Normally the \nclient is given a facade; it doesn\u2019t have \nto construct one itself.\n", "page": 303, "type": "text", "section": "Page 303"}
{"text": "266\u2003 \u2003 Chapter 7\nfacade pattern defined\nFacade Pattern defined\nThe Facade Pattern provides a unified interface to a \nset of interfaces in a subsystem. Facade defines a higher-\nlevel interface that makes the subsystem easier to use.\nTo use the Facade Pattern, we create a class that simplifies and unifies a set of more complex \nclasses that belong to some subsystem. Unlike a lot of patterns, Facade is fairly straightforward; \nthere are no mind-bending abstractions to get your head around. But that doesn\u2019t make it \nany less powerful: the Facade Pattern allows us to avoid tight coupling between clients and \nsubsystems, and, as you will see shortly, also helps us adhere to a new object-oriented principle. \n \n \nBefore we introduce that new principle, let\u2019s take a look at the official definition of the pattern:\nThere isn\u2019t a lot here that you don\u2019t already know, but one of the most important things to \nremember about a pattern is its intent. This definition tells us loud and clear that the purpose \nof the facade is to make a subsystem easier to use through a simplified interface. You can see \nthis in the pattern\u2019s class diagram:\nClient\nFacade\nsubsystem classes\nUnified interface \nthat is easier to use.\nThat\u2019s it; you\u2019ve got another pattern under your belt! Now, it\u2019s time for that new OO principle.  \nWatch out, this one can challenge some assumptions!\nMore complex subsystem.\nHappy client whose \njob just became \neasier because of \nthe facade.\n", "page": 304, "type": "text", "section": "Page 304"}
{"text": "you are here 4\u2003 \u2003 267\nthe adapter and facade patterns\nThe Principle of Least Knowledge\nDesign Principle\nPrinciple of Least Knowledge: talk \nonly to your immediate friends.\nThe Principle of Least Knowledge guides us to reduce the \ninteractions between objects to just a few close \u201cfriends.\u201d \nThe principle is usually stated as:\nBut what does this mean in real terms? It means when you \nare designing a system, for any object, be careful of the \nnumber of classes it interacts with and also how it comes to \ninteract with those classes. \nThis principle prevents us from creating designs that have \na large number of classes coupled together so that changes \nin one part of the system cascade to other parts. When you \nbuild a lot of dependencies between many classes, you are \nbuilding a fragile system that will be costly to maintain and \ncomplex for others to understand.\nHow many classes is this code coupled to?\npublic float getTemp() {\n    return station.getThermometer().getTemperature();\n}\n", "page": 305, "type": "text", "section": "Page 305"}
{"text": "268\u2003 \u2003 Chapter 7\nprinciple of least knowledge\nNotice that these guidelines tell us not \nto call methods on objects that were \nreturned from calling other methods!!\nThink of a \u201ccomponent\u201d as any object that is \nreferenced by an instance variable. In other \nwords, think of this as a HAS-A relationship.\nOkay, but how do you keep from doing this? The principle \nprovides some guidelines: take any object, and from any \nmethod in that object, invoke only methods that belong to:\n\t\n\u0083\nThe object itself\n\t\n\u0083\nObjects passed in as a parameter to the method\n\t\n\u0083\nAny object the method creates or instantiates\n\t\n\u0083\nAny components of the object\nThis sounds kind of stringent, doesn\u2019t it? What\u2019s the harm \nin calling the method of an object we get back from another \ncall? Well, if we were to do that, then we\u2019d be making a \nrequest of another object\u2019s subpart (and increasing the \nnumber of objects we directly know). In such cases, the \nprinciple forces us to ask the object to make the request for us; \nthat way, we don\u2019t have to know about its component objects \n(and we keep our circle of friends small). For example:\nHow NOT to Win Friends and Influence Objects\npublic float getTemp() {\n    Thermometer thermometer = station.getThermometer();\n    return thermometer.getTemperature();\n}\nWithout the \nPrinciple\npublic float getTemp() {\n    return station.getTemperature();\n}\nWith the \nPrinciple\nHere we get the thermometer object \nfrom the station and then call the \ngetT\nemperature() method ourselves.\nWhen we apply the principle, we add a method \nto the Station class that makes the request \nto the thermometer for us. This reduces the \nnumber of classes we\u2019re dependent on.\n", "page": 306, "type": "text", "section": "Page 306"}
{"text": "you are here 4\u2003 \u2003 269\nthe adapter and facade patterns\npublic class Car {\n\t\nEngine engine;\n\t\n// other instance variables\n\t\npublic Car() {\n\t\n\t\n// initialize engine, etc.\n\t\n}\n\t\npublic void start(Key key) {\n\t\n\t\nDoors doors = new Doors();\n\t\n\t\nboolean authorized = key.turns();\n\t\n\t\nif (authorized) {\n\t\n\t\n\t\nengine.start();\n\t\n\t\n\t\nupdateDashboardDisplay();\n\t\n\t\n\t\ndoors.lock();\n\t\n\t\n}\n\t\n}\n\t\npublic void updateDashboardDisplay() {\n\t\n\t\n// update display\n\t\n}\n}\nKeeping your method calls in bounds...\nHere\u2019s a Car class that demonstrates all the ways you can call methods and still \nadhere to the Principle of Least Knowledge:\nYou can call a local method \nwithin the object.\nYou can call a method on an \nobject passed as a parameter.\nYou can call a method on a \ncomponent of the object.\nYou can call a method on an \nobject you create or instantiate.\nHere\u2019s a component of this \nclass. We can call its methods.\nHere we\u2019re creating a new \nobject; its methods are legal.\nQ: There is another principle called the \nLaw of Demeter; how are they related?\nA: The two are one and the same, and \nyou\u2019ll encounter these terms being used \ninterchangeably. We prefer to use the \nPrinciple of Least Knowledge for a couple \nof reasons: (1) the name is more intuitive, \nand (2) the use of the word \u201cLaw\u201d implies we \nalways have to apply this principle. In fact, \nno principle is a law; all principles should \n\nbe used when and where they are helpful. \nAll design involves tradeoffs (abstractions \nversus speed, space versus time, and so on) \nand while principles provide guidance, you \nshould take all factors into account before \napplying them.\nQ: Are there any disadvantages \nto applying the Principle of Least \nKnowledge?\nA: Yes; while the principle reduces \nthe dependencies between objects and \nstudies have shown this reduces software \nmaintenance, it is also the case that applying \nthis principle results in more \u201cwrapper\u201d \nclasses being written to handle method \ncalls to other components. This can result in \nincreased complexity and development time \nas well as decreased runtime performance.\n", "page": 307, "type": "text", "section": "Page 307"}
{"text": "270\u2003 \u2003 Chapter 7\nviolating the principle of least knowledge\nHard hat area. \nwatch out for \nfalling assumptions\nDo either of these classes violate the Principle of Least \nKnowledge? Why or why not?\npublic House {\n    WeatherStation station;\n    // other methods and constructor\n    public float getTemp() {\n         return station.getThermometer().getTemperature();\n    }\n}\npublic House {\n     WeatherStation station;\n    // other methods and constructor\n    public float getTemp() {\n         Thermometer thermometer = station.getThermometer();\n         return getTempHelper(thermometer);\n    }\n \n    public float getTempHelper(Thermometer thermometer) {\n        return thermometer.getTemperature();\n    }\n}\nCan you think of a common use of Java that \nviolates the Principle of Least Knowledge?\nShould you care?\nAnswer: How about System.out.println()?\n", "page": 308, "type": "text", "section": "Page 308"}
{"text": "you are here 4\u2003 \u2003 271\nthe adapter and facade patterns\nThe Facade Pattern and the Principle of Least Knowledge\nClient\nThis client only has one friend: \nthe HomeTheaterFacade. In OO \nprogramming, having only one \nfriend is a GOOD thing!\nHomeTheaterFacade \nmanages all those subsystem \ncomponents for the client.  \nIt keeps the client simple \nand flexible. \nWe try to keep subsystems \nadhering to the Principle of Least \nKnowledge as well. If this gets too \ncomplex and too many friends are \nintermingling, we can introduce \nadditional facades to form layers \nof subsystems.\nWe can upgrade the home \ntheater components without \naffecting the client.\nwatchMovie()\nendMovie()\nlistenToRadio()\nendRadio()\nHomeTheaterFacade\nTheaterLights\non()\noff()\ndim()\ntoString()\nPopcornPopper\non()\noff()\npop()\ntoString()\nScreen\nup()\ndown()\ntoString()\nTuner\non()\noff()\nsetAm()\nsetFm()\nsetFrequency()\ntoString()\namplifier\nAmplifier\ntuner\nplayer\non()\noff()\nsetStreamingPlayer()\nsetStereoSound()\nsetSurroundSoud()\nsetTuner()\nsetVolume()\ntoString()\nProjector\non()\noff()\ntvMode()\nwideScreenMode()\ntoString()\nplayer\nStreamingPlayer\namplifier\non()\noff()\npause()\nplay()\nsetSurroundAudio()\nsetTwoChannelAudio()\nstop()\ntoString()\n", "page": 309, "type": "text", "section": "Page 309"}
{"text": "272\u2003 \u2003 Chapter 7\nyour design toolbox\nTools for your Design Toolbox\nYour toolbox is starting to get heavy!  In this chapter we\u2019ve \nadded a couple of patterns that allow us to alter interfaces and \nreduce coupling between clients and the systems they use.\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies.\nFavor composition over inheritance.\nProgram to interfaces, not \nimplementations.\nStrive for loosely coupled designs \nbetween objects that interact.\nClasses should be open for extension \nbut closed for modification.\nDepend on abstractions. Do not \ndepend on concrete classes.\nT\nalk only to your friends.\nOO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable.  Strategy lets the algorithm \nvary independently from clients that use it.\nOO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically.  \nDecorators provide a flexible \nalternative to subclassing for extending \nfunctionality.\nAbstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes.\nFactory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate.  Factory Method lets \na class defer instantiation to the \nsubclasses.\nSingleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it.\nCommand - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nAdapter - Converts the interface of \na class into another interface clients \nexpect. Lets classes work together \nthat couldn\u2019t otherwise because of \nincompatible interfaces.\nWe have a new technique \nfor maintaining a low level \nof coupling in our designs \n(remember, talk only to your \nfriends)...\nFacade - Provides a unified interface \nto a set of interfaces in a subsystem.  \nFacade defines a higher-level interface \nthat makes the subsystem easier to use.\n...and TWO new patterns. \nEach changes an interface, \nthe adapter to convert, \nand the facade to unify \nand simplify.\n\t\n\u0083\nWhen you need to use \nan existing class and its \ninterface is not the one you \nneed, use an adapter.\n\t\n\u0083\nWhen you need to simplify \nand unify a large interface or \ncomplex set of interfaces, use \na facade.\n\t\n\u0083\nAn adapter changes an \ninterface into one a client \nexpects.\n\t\n\u0083\nA facade decouples a client \nfrom a complex subsystem.\n\t\n\u0083\nImplementing an adapter may \nrequire little work or a great \ndeal of work depending on \nthe size and complexity of the \ntarget interface.\n\t\n\u0083\nImplementing a facade \nrequires that we compose \nthe facade with its subsystem \nand use delegation to \nperform the work of the \nfacade.\n\t\n\u0083\nThere are two forms of the \nAdapter Pattern: object \nand class adapters. Class \nadapters require multiple \ninheritance.\n\t\n\u0083\nYou can implement more than \none facade for a subsystem.\n\t\n\u0083\nAn adapter wraps an object \nto change its interface, a \ndecorator wraps an object \nto add new behaviors and \nresponsibilities, and a facade \n\u201cwraps\u201d a set of objects to \nsimplify.\n", "page": 310, "type": "text", "section": "Page 310"}
{"text": "you are here 4\u2003 \u2003 273\nthe adapter and facade patterns\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nAcross\n1. True or false, Adapters can only wrap one object\n5. An Adapter _____ an interface\n6. Movie we watched (5 words)\n10. If in Europe you might need one of these (two \nwords)\n11. Adapter with two roles (two words)\n14. Facade still _____ low level access\n15. Ducks do it better than Turkeys\n16. Disadvantage of the Principle of Least \nKnowledge: too many __________\n17. A _________ simplifies an interface\n19. New American dream (two words)\nDown\n2. Decorator called Adapter this (3 words)\n3. One advantage of Facade\n4. Principle that wasn't as easy as it sounded (two \nwords)\n7. A ______ adds new behavior \n8. Masquerading as a Duck\n9. Example that violates the Principle of Least \nKnowledge: System.out.______\n12. No movie is complete without this\n13. Adapter client uses the _________ interface\n18. An Adapter and a Decorator can be said to \n_____ an object\nDesign Patterns Crossword\nYes, it\u2019s another crossword. All of the solution words are \nfrom this chapter.\nACROSS\n1. True or false? Adapters can wrap only one object.\n5. An Adapter __________ an interface.\n6. Movie we watched (five words).\n10. If in Britain, you might need one of these (two words).\n11. Adapter with two roles (two words).\n14. Facade still ________ low-level access.\n15. Ducks do it better than Turkeys.\n16. Disadvantage of the Principle of Least Knowledge: \ntoo many __________.\n17. A __________ simplifies an interface.\n19. New American dream (two words).\n\nDOWN\n2. Decorator called Adapter this (three words).\n3. One advantage of Facade.\n4. Principle that wasn't as easy as it sounded (two words).\n7. A __________ adds new behavior.\n8. Masquerading as a Duck.\n9. Example that violates the Principle of Least \nKnowledge: System.out.__________.\n12. No movie is complete without this.\n13. Adapter client uses the __________ interface.\n18. An Adapter and a Decorator can be said to ________ \nan object.\n", "page": 311, "type": "text", "section": "Page 311"}
{"text": "274\u2003 \u2003 Chapter 7\nexercise solutions\nLet\u2019s say we also need an Adapter that converts a Duck to a \nTurkey. Let\u2019s call it DuckAdapter. Here\u2019s our solution:\npublic class DuckAdapter implements Turkey {\n    Duck duck;\n    Random rand;\n    public DuckAdapter(Duck duck) {\n        this.duck = duck;\n        rand = new Random();\n    }\n    public void gobble() {\n        duck.quack();\n    }\n    public void fly() {\n        if (rand.nextInt(5) == 0) {\n             duck.fly();\n        }\n    }\n}\nNow we are adapting Turkeys to Ducks, so \nwe implement the Turkey interface.\nWe stash a reference to the Duck we are adapting.\nWe also create a random object; take a look at the \nfly() method to see how it is used.\nA gobble just becomes a quack.\nSince Ducks fly a lot longer than Turkeys, \nwe decided to only fly the Duck on average \none of five times.\nDo either of these classes violate the Principle of Least \nKnowledge? Why or why not?\npublic House {\n    WeatherStation station;\n    // other methods and constructor\n    public float getTemp() {\n         return station.getThermometer().getTemperature();\n    }\n}\npublic House {\n     WeatherStation station;\n    // other methods and constructor\n    public float getTemp() {\n         Thermometer thermometer = station.getThermometer();\n         return getTempHelper(thermometer);\n    }\n \n    public float getTempHelper(Thermometer thermometer) {\n        return thermometer.getTemperature();\n    }\n}\nViolates the Principle of Least Knowledge! \nYou are calling the method of an object \nreturned from another call.\nDoesn\u2019t violate Principle of \nLeast Knowledge! This seems \nlike hacking our way around \nthe principle. Has anything \nreally changed since we \njust moved out the call to \nanother method?\n", "page": 312, "type": "text", "section": "Page 312"}
{"text": "you are here 4\u2003 \u2003 275\nthe adapter and facade patterns\nMatch each pattern with its intent:\nSOlUTion\nPattern\nIntent\nDecorator\nAdapter\nFacade\nConverts one interface to \nanother\nDoesn\u2019t alter the interface, \nbut adds responsibility\nMakes an interface simpler\nYou\u2019ve seen how to implement an adapter that adapts an Enumeration to an Iterator; now write \nan adapter that adapts an Iterator to an Enumeration.\npublic class IteratorEnumeration implements Enumeration<Object> {\n    Iterator<?> iterator;\n \n    public IteratorEnumeration(Iterator<?> iterator) {\n        this.iterator = iterator;\n    }\n \n    public boolean hasMoreElements() {\n        return iterator.hasNext();\n    }\n \n    public Object nextElement() {\n        return iterator.next();\n    }\n}\nNotice we keep the \ntype parameter \ngeneric so this will \nwork for any type \nof object.\n", "page": 313, "type": "text", "section": "Page 313"}
{"text": "276\u2003 \u2003 Chapter 7\ncrossword puzzle solution\nF\n1\nA\nL\nS\n2\nE\nD\n3\nI\nL\n4\nC\n5\nO\nN\nV\nE\nR\nT\nS\nM\nE\nC\nP\nR\n6\nA\nI\nD\n7\nE\nR\nS\nO\nF\nT\n8\nH\nE\nL\nO\nS\nT\nA\nR\nK\nS\nE\nU\nU\nE\nT\nC\nP\nR\nP\nP\n9\nK\nO\nL\nK\nA\n10\nC\nA\nD\nA\nP\nT\nE\nR\nN\nR\nI\nE\nS\nI\nT\n11\nW\nO\nW\nA\nY\nN\nY\nS\nN\nW\nT\nG\nT\nP\n12\nT\n13\nT\nA\n14\nL\nL\nO\nW\nS\nH\nO\nA\nF\n15\nL\nY\nE\nR\nW\n16\nR\nA\nP\nP\nE\nR\nS\nN\nF\n17\nA\nC\nA\nD\nE\nW\n18\nO\nC\nG\nG\nR\nU\nO\nE\nH\n19\nO\nM\nE\nT\nH\nE\nA\nT\nE\nR\nG\nR\nT\nP\nH\nN\nAcross\n1. True or false, Adapters can only wrap one object \n[FALSE] \n5. An Adapter _____ an interface [CONVERTS] \n6. Movie we watched (5 words) \n[RAIDERSOFTHELOSTARK] \n10. If in Europe you might need one of these (two \nwords) [ACADAPTER] \n11. Adapter with two roles (two words) [TWOWAY] \n14. Facade still _____ low level access [ALLOWS] \n15. Ducks do it better than Turkeys [FLY] \n16. Disadvantage of the Principle of Least \nKnowledge: too many __________ \n[WRAPPERS] \n17. A _________ simplifies an interface [FACADE] \n19. New American dream (two words) \n[HOMETHEATER] \nDown\n2. Decorator called Adapter this (3 words) \n[SIMPLEPASSTHROUGH] \n3. One advantage of Facade [DECOUPLING] \n4. Principle that wasn't as easy as it sounded (two \nwords) [LEASTKNOWLEDGE] \n7. A ______ adds new behavior  [DECORATOR] \n8. Masquerading as a Duck [TURKEY] \n9. Example that violates the Principle of Least \nKnowledge: System.out.______ [PRINTLN] \n12. No movie is complete without this [POPCORN] \n13. Adapter client uses the _________ interface \n[TARGET] \n18. An Adapter and a Decorator can be said to \n_____ an object [WRAP] \nDesign Patterns Crossword Solution\n", "page": 314, "type": "text", "section": "Page 314"}
{"text": "this is a new chapter\u2003 \u2003 277\nWe\u2019re on an encapsulation roll; we\u2019ve encapsulated object \ncreation, method invocation, complex interfaces, ducks, \npizzas...what could be next? We\u2019re going to get down to encapsulating \npieces of algorithms so that subclasses can hook themselves right into a \ncomputation anytime they want. We\u2019re even going to learn about a design principle \ninspired by Hollywood. Let\u2019s get started...\n8  the Template Method Pattern\nEncapsulating \n               Algorithms \n \n \n \n \n \nYeah, he\u2019s a great \nboss until it comes to getting \ndown in this hole, then it ALL \nbecomes MY job. See what I \nmean? He\u2019s nowhere in sight!\n", "page": 315, "type": "text", "section": "Page 315"}
{"text": "278\u2003 \u2003 Chapter 8\ncoffee and tea recipes are similar\nIt\u2019s time for some more caffeine\nSome people can\u2019t live without their coffee; some \npeople can\u2019t live without their tea. The common \ningredient? Caffeine, of course! \nBut there\u2019s more; tea and coffee are made in very \nsimilar ways. Let\u2019s check it out:\nThe recipe for \ncoffee looks a lot \nlike the recipe for \ntea, doesn\u2019t it? \nStarbuzz Coffee Barista Training Manual\n(1) Boil some water\n(2) Brew coffee in boiling water\n(3) Pour coffee in cup\n(4) Add sugar and milk\nStarbuzz Tea Recipe\nStarbuzz Coffee Recipe\nBaristas! Please follow these recipes precisely \nwhen preparing Starbuzz beverages. \n(1) Boil some water\n(2) Steep tea in boiling water\n(3) Pour tea in cup\n(4) Add lemon\nAll recipes are Starbuzz Coffee trade secrets and should be kept \nstrictly confidential. \n", "page": 316, "type": "text", "section": "Page 316"}
{"text": "you are here 4\u2003 \u2003 279\nthe template method pattern\npublic class Coffee {\n \n    void prepareRecipe() {\n        boilWater();\n        brewCoffeeGrinds();\n        pourInCup();\n        addSugarAndMilk();\n    }\n \n    public void boilWater() {\n        System.out.println(\"Boiling water\");\n    }\n \n    public void brewCoffeeGrinds() {\n        System.out.println(\"Dripping Coffee through filter\");\n    }\n \n    public void pourInCup() {\n        System.out.println(\"Pouring into cup\");\n    }\n \n    public void addSugarAndMilk() {\n        System.out.println(\"Adding Sugar and Milk\");\n    }\n}\nLet\u2019s play \u201ccoding barista\u201d and write some code for \ncreating coffee and tea.\nHere\u2019s the coffee:\nWhipping up some coffee and tea classes \n(in Java)\nHere\u2019s our Coffee class for making coffee. \nHere\u2019s our recipe for coffee, \nstraight out of the training manual. \nEach of the steps is implemented as \na separate method.\nEach of these methods \nimplements one step of \nthe algorithm. There\u2019s \na method to boil water, \nbrew the coffee, pour \nthe coffee in a cup, \nand add sugar and milk.\n", "page": 317, "type": "text", "section": "Page 317"}
{"text": "280\u2003 \u2003 Chapter 8\ntea implementation\npublic class Tea {\n \n    void prepareRecipe() {\n        boilWater();\n        steepTeaBag();\n        pourInCup();\n        addLemon();\n    }\n \n    public void boilWater() {\n        System.out.println(\"Boiling water\");\n    }\n \n    public void steepTeaBag() {\n        System.out.println(\"Steeping the tea\");\n    }\n \n    public void addLemon() {\n        System.out.println(\"Adding Lemon\");\n    }\n \n    public void pourInCup() {\n        System.out.println(\"Pouring into cup\");\n    }\n}\nThis looks very similar to the one \nwe just implemented in Coffee; \nthe second and fourth steps are \ndifferent, but it\u2019s basically the \nsame recipe.\nNotice that these \ntwo methods \nare exactly the \nsame as they \nare in Coffee! \nSo we definitely \nhave some code \nduplication going \non here.\nAnd now the Tea...\nThese two \nmethods are \nspecialized to T\nea.\nWhen we\u2019ve got code \nduplication, that\u2019s a good sign we need to \nclean up the design. It seems like here we \nshould abstract the commonality into a base \nclass since coffee and tea are so similar.\n", "page": 318, "type": "text", "section": "Page 318"}
{"text": "you are here 4\u2003 \u2003 281\nthe template method pattern\n Design Puzzle\nYou\u2019ve seen that the Coffee and Tea classes have a fair bit of code duplication. Take another \nlook at the Coffee and Tea classes and draw a class diagram showing how you\u2019d redesign the \nclasses to remove redundancy:\n", "page": 319, "type": "text", "section": "Page 319"}
{"text": "282\u2003 \u2003 Chapter 8\nfirst cut at abstraction\nLet\u2019s abstract that Coffee and Tea\nEach subclass \nimplements its \nown recipe.\nIt looks like we\u2019ve got a pretty straightforward design \nexercise on our hands with the Coffee and Tea classes.  \nYour first cut might have looked something like this:\nprepareRecipe()\nboilWater()\npourInCup()\nCaffeineBeverage\nprepareRecipe()\nsteepTeaBag()\naddLemon()\nTea\nprepareRecipe()\nbrewCoffeeGrinds()\naddSugarAndMilk()\nCoffee\nThe boilWater() and pourInCup() \nmethods are shared by both subclasses, \nso they are defined in the superclass.\nThe prepareRecipe() method \ndiffers in each subclass, so it \nis defined as abstract.\nThe methods specific to \nCoffee and T\nea stay in \nthe subclasses.\nEach subclass \noverrides the \nprepareRecipe() \nmethod and \nimplements its own \nrecipe.\nDid we do a good job on the redesign? Hmmmm, take another \nlook. Are we overlooking some other commonality? What are \nother ways that Coffee and Tea are similar?\n", "page": 320, "type": "text", "section": "Page 320"}
{"text": "you are here 4\u2003 \u2003 283\nthe template method pattern\n(1) Boil some water\n(2) Brew coffee in boiling water\n(3) Pour coffee in cup\n(4) Add sugar and milk\nStarbuzz Coffee Recipe\nStarbuzz Tea Recipe\n(1) Boil some water\n(2) Steep tea in boiling water\n(3) Pour tea in cup\n(4) Add lemon\nTaking the design further...\nSo what else do Coffee and Tea have in common? Let\u2019s start with the recipes.\nNotice that both recipes follow the same algorithm:\n1\nBoil some water.\n2\n3\n4\nUse the hot water to extract the coffee \nor tea.\nPour the resulting beverage into a cup.\nAdd the appropriate condiments to the \nbeverage.\nThese two are \nalready abstracted \ninto the base class.\nThese aren\u2019t \nabstracted but \nare the same; \nthey just apply \nto different \nbeverages.\nSo, can we find a way to abstract prepareRecipe() too? Yes, let\u2019s find out...\n", "page": 321, "type": "text", "section": "Page 321"}
{"text": "284\u2003 \u2003 Chapter 8\nabstract the algorithm\nAbstracting prepareRecipe()\nThe first problem we have is that Coffee uses brewCoffeeGrinds() \nand addSugarAndMilk() methods, while Tea uses steepTeaBag() and \naddLemon() methods.\nLet\u2019s step through abstracting prepareRecipe() from each subclass (that is, \nthe Coffee and Tea classes)...\n1\nLet\u2019s think through this: steeping and brewing aren\u2019t so different; they\u2019re pretty analogous. \nSo let\u2019s make a new method name, say, brew(), and we\u2019ll use the same name whether \nwe\u2019re brewing coffee or steeping tea.\nLikewise, adding sugar and milk is pretty much the same as adding a lemon: both \nare adding condiments to the beverage. Let\u2019s also make up a new method name, \naddCondiments(), to handle this. So, our new prepareRecipe() method will look like this:\n    void prepareRecipe() {\n        boilWater();\n        brew();\n        pourInCup();\n        addCondiments();\n    }\n    void prepareRecipe() {\n        boilWater();\n        steepTeaBag();\n        pourInCup();\n        addLemon();\n    }\nTea\n    void prepareRecipe() {\n        boilWater();\n        brewCoffeeGrinds();\n        pourInCup();\n        addSugarAndMilk();\n    }\nCoffee\nNow we have a new prepareRecipe() method, but we need to fit it into the code. \nTo do this we\u2019ll start with the CaffeineBeverage superclass:\n2\n(Code on the \nnext page.)\n", "page": 322, "type": "text", "section": "Page 322"}
{"text": "you are here 4\u2003 \u2003 285\nthe template method pattern\npublic class Coffee extends CaffeineBeverage {\n    public void brew() {\n        System.out.println(\"Dripping Coffee through filter\");\n    }\n    public void addCondiments() {\n        System.out.println(\"Adding Sugar and Milk\");\n    }\n}\npublic class Tea extends CaffeineBeverage {\n    public void brew() {\n        System.out.println(\"Steeping the tea\");\n    }\n    public void addCondiments() {\n        System.out.println(\"Adding Lemon\");\n    }\n}\npublic abstract class CaffeineBeverage {\n  \n    final void prepareRecipe() {\n        boilWater();\n        brew();\n        pourInCup();\n        addCondiments();\n    }\n \n    abstract void brew();\n  \n    abstract void addCondiments();\n \n    void boilWater() {\n        System.out.println(\"Boiling water\");\n    }\n  \n    void pourInCup() {\n        System.out.println(\"Pouring into cup\");\n    }\n}\nNow, the same prepareRecipe() method \nwill be used to make both T\nea and Coffee.  \nprepareRecipe() is declared final because \nwe don\u2019t want our subclasses to be able to \noverride this method and change the recipe! \nWe\u2019ve generalized steps 2 and 4 to brew() the \nbeverage and addCondiments().\nCaffeineBeverage is abstract, \njust like in the class design.\nBecause Coffee and T\nea handle these \nmethods in different ways, they\u2019re going to \nhave to be declared as abstract. Let the \nsubclasses worry about that stuff!\nRemember, we moved these into \nthe CaffeineBeverage class \n(back in our class diagram).\nFinally, we need to deal with the Coffee and Tea classes. They now rely on CaffeineBeverage \nto handle the recipe, so they just need to handle brewing and condiments:\n3\nAs in our design, T\nea and Coffee \nnow extend CaffeineBeverage.\nT\nea needs to define brew() and \naddCondiments()\u2014the two abstract \nmethods from CaffeineBeverage.  \nSame for Coffee, except Coffee \ndeals with coffee, and sugar and milk \ninstead of tea bags and lemon.\n", "page": 323, "type": "text", "section": "Page 323"}
{"text": "286\u2003 \u2003 Chapter 8\nclass diagram for caffeine beverages \nDraw the new class diagram now that we\u2019ve moved the \nimplementation of prepareRecipe() into the CaffeineBeverage class:\n", "page": 324, "type": "text", "section": "Page 324"}
{"text": "you are here 4\u2003 \u2003 287\nthe template method pattern\nWhat have we done?\n1\nBoil some water\n2\n3\n4\nSteep the tea bag in the water\nPour tea in a cup\nAdd lemon\n1\nBoil some water\n2\n3\n4\nBrew the coffee grinds\nPour coffee in a cup\nAdd sugar and milk\n2\n4\nSteep the tea bag in the water\nAdd lemon\nT\nea subclass\nCoffee subclass\n2\n4\nBrew the coffee grinds\nAdd sugar and milk\n1\nBoil some water\n2\n3\n4\nBrew\nPour beverage in a cup\nAdd condiments\nCaffeine Beverage\nTea\nCoffee\nCaffeine Beverage \nknows and controls the \nsteps of the recipe, and \nperforms steps 1 and 3 \nitself, but relies on T\nea \nor Coffee to do steps \n2 and 4.\nWe\u2019ve recognized \nthat the two recipes \nare essentially the \nsame, although \nsome of the steps \nrequire different \nimplementations. So \nwe\u2019ve generalized the \nrecipe and placed it \nin the base class.\ngeneralize\nrelies on \nsubclass \nfor some \nsteps\ngeneralize\nrelies on \nsubclass \nfor some \nsteps\n", "page": 325, "type": "text", "section": "Page 325"}
{"text": "288\u2003 \u2003 Chapter 8\nmeet the template method pattern\nMeet the Template Method \nWe\u2019ve basically just implemented the Template Method Pattern. What\u2019s that? Let\u2019s look at \nthe structure of the CaffeineBeverage class; it contains the actual \u201ctemplate method\u201d:\nfinal void prepareRecipe() {\n}\nbrew();\npourInCup();\naddCondiments();\nboilWater();\n   abstract void brew();\n   abstract void addCondiments();\n   void boilWater() {\n        // implementation\n   }\n   void pourInCup() {\n        // implementation\n   }\n}\npublic abstract class CaffeineBeverage {\nIn the template, each \nstep of the algorithm is \nrepresented by a method.\nprepareRecipe() is our \ntemplate method. Why?\nBecause:\n   (1) It is a method, after all.\n   (2) It serves as a template for an \nalgorithm\u2014in this case, an algorithm \nfor making caffeinated beverages.\nSome methods are \nhandled by this class...\n...and some are handled \nby the subclass.\nThe methods that need to \nbe supplied by a subclass are \ndeclared abstract.\nThe Template Method defines the steps of an algorithm and allows \nsubclasses to provide the implementation for one or more steps.\n", "page": 326, "type": "text", "section": "Page 326"}
{"text": "you are here 4\u2003 \u2003 289\nthe template method pattern\nLet\u2019s make some tea...\nLet\u2019s step through making a tea and trace through how the \ntemplate method works. You\u2019ll see that the template method \ncontrols the algorithm; at certain points in the algorithm, it lets \nthe subclass supply the implementation of the steps...\n1\nTea myTea = new Tea();\nOkay, first we need a Tea object...\n2\nmyTea.prepareRecipe();\nThen we call the template method:\nwhich follows the algorithm for making caffeine \nbeverages...\nboilWater();\nbrew();\npourInCup();\naddCondiments();\n3\nboilWater();\nFirst we boil water:\nwhich happens in CaffeineBeverage.\nprepareRecipe()\nboilWater()\npourInCup()\nCaffeineBeverage\nbrew()\naddCondiments();\nTea\n4\nbrew();\nNext we need to brew the tea, which only the subclass knows \nhow to do:\n5\npourInCup();\nNow we pour the tea in the cup; this is the same for all beverages, \nso it happens in CaffeineBeverage:\n6\naddCondiments();\nFinally, we add the condiments, which are specific to each beverage, \nso the subclass implements this:\nThe prepareRecipe() method \ncontrols the algorithm. No \none can change this, and \nit counts on subclasses to \nprovide some or all of the \nimplementation.\nBehind \nthe Scenes\n", "page": 327, "type": "text", "section": "Page 327"}
{"text": "290\u2003 \u2003 Chapter 8\nwhat did template method get us?\nUnderpowered  Tea & Coffee \nimplementation\nWhat did the Template Method get us?\nCoffee and Tea are running the show; \nthey control the algorithm.\nCode changes to the algorithm \nrequire opening the subclasses and \nmaking multiple changes.\nThe algorithm lives in one place and \ncode changes only need to be made \nthere.\nCode is duplicated across Coffee and \nTea.\nThe CaffeineBeverage class \nmaximizes reuse among the \nsubclasses.\nThe CaffeineBeverage class runs \nthe show; it has the algorithm, and \nprotects it.\nClasses are organized in a structure \nthat requires a lot of work to add a \nnew caffeine beverage.\nThe Template Method Pattern provides \na framework that other caffeine \nbeverages can be plugged into. New \ncaffeine beverages only need to \nimplement a couple of methods.\nThe CaffeineBeverage class \nconcentrates knowledge about the \nalgorithm and relies on subclasses to \nprovide complete implementations.\nKnowledge of the algorithm and how \nto implement it is distributed over \nmany classes.\nNew, hip CaffeineBeverage \npowered by Template Method\n", "page": 328, "type": "text", "section": "Page 328"}
{"text": "you are here 4\u2003 \u2003 291\nthe template method pattern\nTemplate Method Pattern defined\nThe Template Method Pattern defines the skeleton \nof an algorithm in a method, deferring some steps to \nsubclasses. Template Method lets subclasses redefine \ncertain steps of an algorithm without changing the \nalgorithm\u2019s structure.\nYou\u2019ve seen how the Template Method Pattern works in our Tea and Coffee example; \nnow, check out the official definition and nail down all the details:\nThis pattern is all about creating a template for an algorithm. What\u2019s a template?  \nAs you\u2019ve seen it\u2019s just a method; more specifically, it\u2019s a method that defines an \nalgorithm as a set of steps. One or more of these steps is defined to be abstract and \nimplemented by a subclass. This ensures the algorithm\u2019s structure stays unchanged, \nwhile subclasses provide some part of the implementation.\nLet\u2019s check out the class diagram:\ntemplateMethod()\nprimitiveOperation1()\nprimitiveOperation2()\nAbstractClass\nprimitiveOperation1()\nprimitiveOperation2()\nConcreteClass\nprimitiveOperation1();\nprimitiveOperation2();\nThe AbstractClass \ncontains the template \nmethod...\n...and abstract versions \nof the operations \nused in the template \nmethod.\nThe ConcreteClass implements \nthe abstract operations, \nwhich are called when the \ntemplateMethod() needs them.\nThere may be many \nConcreteClasses, each \nimplementing the full set of \noperations required by the \ntemplate method.\nThe template method makes use of the \nprimitive operations to implement an \nalgorithm. It is decoupled from the actual \nimplementation of these operations.\n", "page": 329, "type": "text", "section": "Page 329"}
{"text": "292\u2003 \u2003 Chapter 8\ntemplate method pattern up close\nCode Up Close\nHere we have our abstract class; it \nis declared abstract and meant to \nbe subclassed by classes that provide \nimplementations of the operations.\nLet\u2019s take a closer look at how the AbstractClass is defined, including the template method \nand primitive operations.\nabstract class AbstractClass {\n    \n    final void templateMethod() {\n        primitiveOperation1();\n        primitiveOperation2();\n        concreteOperation();\n    }\n    abstract void primitiveOperation1();\n    \n    abstract void primitiveOperation2();\n    \n    void concreteOperation() {\n        // implementation here\n    }\n}\nHere\u2019s the template method. It\u2019s \ndeclared final to prevent subclasses \nfrom reworking the sequence of \nsteps in the algorithm.\nThe template method \ndefines the sequence of \nsteps, each represented \nby a method.\nIn this example, two of \nthe primitive operations \nmust be implemented by \nconcrete subclasses.\nWe also have a concrete operation \ndefined in the abstract class. This \ncould be overridden by subclasses, or we \ncould prevent overriding by declaring \nconcreteOperation() as final. More about \nthis in a bit...\n", "page": 330, "type": "text", "section": "Page 330"}
{"text": "you are here 4\u2003 \u2003 293\nthe template method pattern\nNow we\u2019re going to look even closer at the types of method that can go in the abstract class:\nabstract class AbstractClass {\n    \n    final void templateMethod() {\n        primitiveOperation1();\n        primitiveOperation2();\n        concreteOperation();\n        hook();\n    }\n    abstract void primitiveOperation1();\n    \n    abstract void primitiveOperation2();\n    \n    final void concreteOperation() {\n        // implementation here\n    }\n    void hook() {}\n}\nWe still have our primitive \noperation methods; \nthese are abstract and \nimplemented by concrete \nsubclasses.\nA concrete operation is defined in the \nabstract class. This one is declared final \nso that subclasses can\u2019t override it. It \nmay be used in the template method \ndirectly, or used by subclasses.\nWe can also have concrete methods that do nothing \nby default; we call these \u201chooks.\u201d Subclasses are free \nto override these but don\u2019t have to. We\u2019re going to \nsee how these are useful on the next page.\nA concrete method, but \nit does nothing!\nWe\u2019ve changed the \ntemplateMethod() to \ninclude a new method call.\nCode Way Up Close\n", "page": 331, "type": "text", "section": "Page 331"}
{"text": "294\u2003 \u2003 Chapter 8\nimplement a hook\npublic abstract class CaffeineBeverageWithHook {\n \n    final void prepareRecipe() {\n        boilWater();\n        brew();\n        pourInCup();\n        if (customerWantsCondiments()) {\n            addCondiments();\n        }\n    }\n \n    abstract void brew();\n \n    abstract void addCondiments();\n \n    void boilWater() {\n        System.out.println(\"Boiling water\");\n    }\n \n    void pourInCup() {\n        System.out.println(\"Pouring into cup\");\n    }\n \n    boolean customerWantsCondiments() {\n        return true;\n    }\n}\nHooked on \nTemplate Method...\nA hook is a method that is declared in the \nabstract class, but only given an empty or default \nimplementation. This gives subclasses the ability to \n\u201chook into\u201d the algorithm at various points, if they \nwish; a subclass is also free to ignore the hook. \nThere are several uses of hooks; let\u2019s take a look at \none now. We\u2019ll talk about a few other uses later:\nWe\u2019ve added a little conditional \nstatement that bases its \nsuccess on a concrete method, \ncustomerWantsCondiments(). If the \ncustomer WANTS condiments, only then \ndo we call addCondiments().\nHere we\u2019ve defined a method \nwith a (mostly) empty default \nimplementation. This method just \nreturns true and does nothing else.  \nThis is a hook because the \nsubclass can override this \nmethod, but doesn\u2019t have to.\nWith a hook, I can \noverride the method or not. \nIt\u2019s my choice. If I don\u2019t, the \nabstract class provides a default \nimplementation.\n", "page": 332, "type": "text", "section": "Page 332"}
{"text": "you are here 4\u2003 \u2003 295\nthe template method pattern\npublic class CoffeeWithHook extends CaffeineBeverageWithHook {\n \n    public void brew() {\n        System.out.println(\"Dripping Coffee through filter\");\n    }\n \n    public void addCondiments() {\n        System.out.println(\"Adding Sugar and Milk\");\n    }\n \n    public boolean customerWantsCondiments() {\n        String answer = getUserInput();\n        if (answer.toLowerCase().startsWith(\"y\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n \n    private String getUserInput() {\n        String answer = null;\n        System.out.print(\"Would you like milk and sugar with your coffee (y/n)? \");\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            answer = in.readLine();\n        } catch (IOException ioe) {\n            System.err.println(\"IO error trying to read your answer\");\n        }\n        if (answer == null) {\n            return \"no\";\n        }\n        return answer;\n    }\n}\nUsing the hook\nTo use the hook, we override it in our subclass. Here, the hook controls whether \nthe CaffeineBeverage class evaluates a certain part of the algorithm\u2014that is, \nwhether it adds a condiment to the beverage.\nHow do we know whether the customer wants the condiment? Just ask!\nHere\u2019s where you override \nthe hook and provide your \nown functionality.\nGet the user\u2019s input on \nthe condiment decision \nand return true or false, \ndepending on the input.\nThis code asks if the user would like milk and \nsugar and gets the input from the command line.\n", "page": 333, "type": "text", "section": "Page 333"}
{"text": "296\u2003 \u2003 Chapter 8\ntest drive\npublic class BeverageTestDrive {\n    public static void main(String[] args) {\n \n        TeaWithHook teaHook = new TeaWithHook();\n        CoffeeWithHook coffeeHook = new CoffeeWithHook();\n \n        System.out.println(\"\\nMaking tea...\");\n        teaHook.prepareRecipe();\n \n        System.out.println(\"\\nMaking coffee...\");\n        coffeeHook.prepareRecipe();\n    }\n}\nLet\u2019s run the Test Drive\nOkay, the water\u2019s boiling... Here\u2019s the test code where we create a \nhot tea and a hot coffee.\n%java BeverageTestDrive\nMaking tea...\nBoiling water\nSteeping the tea\nPouring into cup\nWould you like lemon with your tea (y/n)? y\nAdding Lemon\nMaking coffee...\nBoiling water\nDripping Coffee through filter\nPouring into cup\nWould you like milk and sugar with your coffee (y/n)? n\n%\nFile  Edit   Window  Help  send-more-honesttea\nAnd let\u2019s give it a run...\nA steaming cup of tea, and yes, \nof course we want that lemon!\nAnd a nice hot cup of coffee, \nbut we\u2019ll pass on the waistline-\nexpanding condiments.\nCreate a tea. \nCreate a coffee.\nAnd call prepareRecipe() \non both!\n", "page": 334, "type": "text", "section": "Page 334"}
{"text": "you are here 4\u2003 \u2003 297\nthe template method pattern\nYou know what? We agree with you. But you \nhave to admit before you thought of that, it was \na pretty cool example of how a hook can be used \nto conditionally control the flow of the algorithm \nin the abstract class. Right?\nWe\u2019re sure you can think of many other more \nrealistic scenarios where you could use the \ntemplate method and hooks in your own code.\nNow, I would have thought \nthat functionality like \nasking the customer could \nhave been used by all \nsubclasses?\nQ: When I\u2019m creating a template method, how do I know when \nto use abstract methods and when to use hooks?\nA: Use abstract methods when your subclass MUST provide an \nimplementation of the method or step in the algorithm. Use hooks \nwhen that part of the algorithm is optional. With hooks, a subclass \nmay choose to implement that hook, but it doesn\u2019t have to.\nQ: What are hooks really supposed to be used for?\nA: There are a few uses of hooks. As we just said, a hook may \nprovide a way for a subclass to implement an optional part of an \nalgorithm, or if it isn\u2019t important to the subclass\u2019s implementation, it \ncan skip it. Another use is to give the subclass a chance to react to \nsome step in the template method that is about to happen or just \nhappened. For instance, a hook method like justReorderedList() \nallows the subclass to perform some activity (such as redisplaying an \nonscreen representation) after an internal list is reordered. As you\u2019ve \nseen, a hook can also provide a subclass with the ability to make a \ndecision for the abstract class.  \nQ: Does a subclass have to implement all the abstract \nmethods in the AbstractClass? \nA: Yes, each concrete subclass defines the entire set of abstract \nmethods and provides a complete implementation of the undefined \nsteps of the template method\u2019s algorithm.\nQ: It seems like I should keep my abstract methods small in \nnumber; otherwise, it will be a big job to implement them in the \nsubclass.\nA: That\u2019s a good thing to keep in mind when you write template \nmethods. Sometimes you can do this by not making the steps of \nyour algorithm too granular. But it\u2019s obviously a tradeoff: the less \ngranularity, the less flexibility.\n\nRemember, too, that some steps will be optional, so you can \nimplement these as hooks rather than abstract methods, easing the \nburden on the subclasses of your abstract class.\n", "page": 335, "type": "text", "section": "Page 335"}
{"text": "298\u2003 \u2003 Chapter 8\nthe hollywood principle\nThe Hollywood Principle\nThe Hollywood Principle\nDon\u2019t call us, we\u2019ll call you. \nWe\u2019ve got another design principle for you; it\u2019s called the \nHollywood Principle:\nEasy to remember, right? But what has it got to do with OO \ndesign?\nThe Hollywood Principle gives us a way to prevent \n\u201cdependency rot.\u201d Dependency rot happens when you have \nhigh-level components depending on low-level components \ndepending on high-level components depending on sideways \ncomponents depending on low-level components, and so \non.  When rot sets in, no one can easily understand the way a \nsystem is designed.\nWith the Hollywood Principle, we allow low-level components \nto hook themselves into a system, but the high-level \ncomponents determine when they are needed, and how. In \nother words, the high-level components give the low-level \ncomponents the \u201cdon\u2019t call us, we\u2019ll call you\u201d treatment.\nHigh-Level Component\nLow-Level \nComponent\nAnother \nLow-Level \nComponent\nLow-level components \ncan participate in the \ncomputation...\n...but the high-level \ncomponents control \nwhen and how.\nA low-level component never \ncalls a high-level component \ndirectly.\nYou\u2019ve heard me say it \nbefore, and I\u2019ll say it again: \ndon\u2019t call me, I\u2019ll call you!\n", "page": 336, "type": "text", "section": "Page 336"}
{"text": "you are here 4\u2003 \u2003 299\nthe template method pattern\nThe Factory Method and Observer; any others?\nThe Hollywood Principle and Template Method\nThe connection between the Hollywood Principle and the Template Method \nPattern is probably somewhat apparent: when we design with the Template \nMethod Pattern, we\u2019re telling subclasses, \u201cdon\u2019t call us, we\u2019ll call you.\u201d How? \nLet\u2019s take another look at our CaffeineBeverage design: \nprepareRecipe()\nboilWater()\npourInCup()\nbrew()\naddCondiments()\nCaffeineBeverage\nbrew()\naddCondiments()\nTea\nbrew()\naddCondiments()\nCoffee\nCaffeineBeverage is our high-level \ncomponent. It has control over the \nalgorithm for the recipe, and calls on \nthe subclasses only when they\u2019re needed \nfor an implementation of a method.\nT\nea and Coffee never \ncall the abstract class \ndirectly without being \n\u201ccalled\u201d first.\nThe subclasses are used simply to \nprovide implementation details.  \nClients of beverages will depend \non the CaffeineBeverage \nabstraction rather than a \nconcrete T\nea or Coffee, which \nreduces dependencies in the \noverall system.\nWhat other patterns make use of the Hollywood Principle?\n", "page": 337, "type": "text", "section": "Page 337"}
{"text": "300\u2003 \u2003 Chapter 8\nwho does what\nMatch each pattern with its description:\nPattern\nDescription\nTemplate Method\nStrategy\nFactory Method\nEncapsulate interchangeable \nbehaviors and use delegation to \ndecide which behavior to use.\nSubclasses decide how \nto implement steps in an \nalgorithm.\nSubclasses decide which \nconcrete classes to instantiate.\nQ: How does the Hollywood Principle relate to the \nDependency Inversion Principle that we learned a few chapters \nback?\nA: The Dependency Inversion Principle teaches us to avoid the \nuse of concrete classes and instead work as much as possible with \nabstractions. The Hollywood Principle is a technique for building \nframeworks or components so that lower-level components can be \nhooked into the computation, but without creating dependencies \nbetween the lower-level components and the higher-level layers. So, \nthey both have the goal of decoupling, but the Dependency Inversion \nPrinciple makes a much stronger and more general statement about \nhow to avoid dependencies in design.  \n\nThe Hollywood Principle gives us a technique for creating designs \nthat allow low-level structures to interoperate while preventing other \nclasses from becoming too dependent on them.\nQ: Is a low-level component disallowed from calling a \nmethod in a higher-level component? \nA: Not really. In fact, a low-level component will often end up \ncalling a method defined above it in the inheritance hierarchy purely \nthrough inheritance. But we want to avoid creating explicit circular \ndependencies between the low-level component and the high-level \nones.\n", "page": 338, "type": "text", "section": "Page 338"}
{"text": "you are here 4\u2003 \u2003 301\nthe template method pattern\nTemplate Methods in the Wild\nThe Template Method Pattern is a very common pattern and \nyou\u2019re going to find lots of it in the wild. You\u2019ve got to have \na keen eye, though, because there are many implementations \nof the template methods that don\u2019t quite look like the \ntextbook design of the pattern.\nThis pattern shows up so often because it\u2019s a great design tool \nfor creating frameworks, where the framework controls how \nsomething gets done, but leaves you (the person using the \nframework) to specify your own details about what is actually \nhappening at each step of the framework\u2019s algorithm.\nLet\u2019s take a little safari through a few uses in the wild (well, \nokay, in the Java API)...\nIn training, we study the classic \npatterns. However, when we are out in \nthe real world, we must learn to recognize \nthe patterns out of context. We must also \nlearn to recognize variations of patterns, \nbecause in the real world a square hole is \nnot always truly square.\n", "page": 339, "type": "text", "section": "Page 339"}
{"text": "302\u2003 \u2003 Chapter 8\nsorting with template method\npublic static void sort(Object[] a) {\n    Object aux[] = (Object[])a.clone();\n    mergeSort(aux, a, 0, a.length, 0);\n}\nprivate static void mergeSort(Object src[], Object dest[],\n\t\n\t\nint low, int high, int off) \n{\n    // a lot of other code here\n    for (int i=low; i<high; i++){\n        for (int j=i; j>low &&\n             ((Comparable)dest[j-1]).compareTo((Comparable)dest[j])>0; j--)\n        {\n            swap(dest, j, j-1);\n        }\n    }\n    // and a lot of other code here\n}\nWhat\u2019s something we often need to do with arrays?  \nSort them!\nRecognizing that, the designers of the Java Arrays class \nhave provided us with a handy template method for \nsorting. Let\u2019s take a look at how this method operates:\nSorting with Template Method\nWe actually have two methods here and they act \ntogether to provide the sort functionality.  \ncompareT\no() is the method we \nneed to implement to \u201cfill out\u201d \nthe template method.\nThis is a concrete method, already \ndefined in the Arrays class.\nWe\u2019ve pared down this \ncode a little to make \nit easier to explain. If \nyou\u2019d like to see it all, \ngrab the Java source \ncode and check it out...\nThink of this as the \ntemplate method.\nThe first method, sort(), is just a helper method that creates a \ncopy of the array and passes it along as the destination array to \nthe mergeSort() method. It also passes along the length of the \narray and tells the sort to start at the first element.\nThe mergeSort() method contains the sort algorithm, and \nrelies on an implementation of the compareT\no() method to \ncomplete the algorithm. If you\u2019re interested in the nitty-\ngritty of how the sorting happens, you\u2019ll want to check out \nthe Java source code.\n", "page": 340, "type": "text", "section": "Page 340"}
{"text": "you are here 4\u2003 \u2003 303\nthe template method pattern\nWe\u2019ve got an array of \nducks we need to sort.\nWe\u2019ve got some ducks to sort...\nThe compareTo() method compares two objects and returns whether one is less than, greater than, \nor equal to the other. sort() uses this as the basis of its comparison of objects in the array.\nLet\u2019s say you have an array of ducks that you\u2019d like to sort. How do \nyou do it? Well, the sort() template method in Arrays gives us the \nalgorithm, but you need to tell it how to compare ducks, which you do by \nimplementing the compareTo() method... Make sense?\nGood point. Here\u2019s the deal: the designers of sort() wanted \nit to be useful across all arrays, so they had to make sort() a \nstatic method that could be used from anywhere. But that\u2019s \nokay, since it works almost the same as if it were in a superclass. \nNow, here is one more detail: because sort() really isn\u2019t defined \nin our superclass, the sort() method needs to know that you\u2019ve \nimplemented the compareTo() method, or else you don\u2019t have \nthe piece needed to complete the sort algorithm.\nTo handle this, the designers made use of the Comparable \ninterface. All you have to do is implement this interface, which \nhas one method (surprise): compareTo().\nWhat is compareTo()?\nNo, it doesn\u2019t. \nAren\u2019t we supposed to be \nsubclassing something? I thought \nthat was the point of Template \nMethod. An array doesn\u2019t subclass \nanything, so I don\u2019t get how we\u2019d \nuse sort().\nAm I greater \nthan you?\nI don\u2019t \nknow. That\u2019s what \ncompareTo() tells us.\n", "page": 341, "type": "text", "section": "Page 341"}
{"text": "304\u2003 \u2003 Chapter 8\npublic class Duck implements Comparable<Duck> {\n    String name;\n    int weight;\n  \n    public Duck(String name, int weight) {\n        this.name = name;\n        this.weight = weight;\n    }\n \n    public String toString() {\n        return name + \" weighs \" + weight;\n    }\n \n \n  \n    public int compareTo(Duck otherDuck) {\n  \n        if (this.weight < otherDuck.weight) {\n            return -1;\n        } else if (this.weight == otherDuck.weight) {\n            return 0;\n        } else { // this.weight > otherDuck.weight\n            return 1;\n        }\n    }\n}\nimplementing comparable\nComparing Ducks and Ducks\nOkay, so you know that if you want to sort Ducks, \nyou\u2019re going to have to implement this compareTo() \nmethod; by doing that, you\u2019ll give the Arrays class \nwhat it needs to complete the algorithm and sort \nyour ducks.  \nHere\u2019s the duck implementation:\nRemember, we need to implement the Comparable \ninterface since we aren\u2019t really subclassing.\nOur Ducks have a name and a weight.\nWe\u2019re keepin\u2019 it simple; all Ducks do is \nprint their name and weight!\nOkay, here\u2019s what sort() needs...\ncompareT\no() takes another Duck to compare THIS Duck to.  \nHere\u2019s where we specify how Ducks \ncompare. If THIS Duck weighs less \nthan otherDuck, we return -1; if \nthey are equal, we return 0; and \nif THIS Duck weighs more, we \nreturn 1.  \n", "page": 342, "type": "text", "section": "Page 342"}
{"text": "you are here 4\u2003 \u2003 305\nthe template method pattern\npublic class DuckSortTestDrive {\n    public static void main(String[] args) {\n        Duck[] ducks = { \n                         new Duck(\"Daffy\", 8), \n                         new Duck(\"Dewey\", 2),\n                         new Duck(\"Howard\", 7),\n                         new Duck(\"Louie\", 2),\n                         new Duck(\"Donald\", 10), \n                         new Duck(\"Huey\", 2)\n         };\n        System.out.println(\"Before sorting:\");\n        display(ducks);\n        Arrays.sort(ducks);\n \n        System.out.println(\"\\nAfter sorting:\");\n        display(ducks);\n    }\n    public static void display(Duck[] ducks) {\n        for (Duck d : ducks) {\n            System.out.println(d);\n        }\n    }\n}\nLet\u2019s sort some Ducks\n%java DuckSortTestDrive\nBefore sorting:\nDaffy weighs 8\nDewey weighs 2\nHoward weighs 7\nLouie weighs 2\nDonald weighs 10\nHuey weighs 2\nAfter sorting:\nDewey weighs 2\nLouie weighs 2\nHuey weighs 2\nHoward weighs 7\nDaffy weighs 8\nDonald weighs 10\n%\nFile  Edit   Window  Help  DonaldNeedsToGoOnADiet\nThe unsorted Ducks\nThe sorted Ducks\nLet the sorting commence!\nHere\u2019s the test drive for sorting Ducks...\nWe need an array of \nDucks; these look good.\nLet\u2019s print them to see \ntheir names and weights.\nIt\u2019s sort time!\nLet\u2019s print them (again) to see \ntheir names and weights.\nNotice that we \ncall Arrays\u2019 static \nmethod sort(), and \npass it our Ducks.\n", "page": 343, "type": "text", "section": "Page 343"}
{"text": "306\u2003 \u2003 Chapter 8\nbehind the scenes: sorting ducks\nThe making of the sorting duck machine\nLet\u2019s trace through how the Arrays sort() template method works.  \nWe\u2019ll check out how the template method controls the algorithm, \nand at certain points in the algorithm, how it asks our Ducks to \nsupply the implementation of a step...\n1\nDuck[] ducks = {new Duck(\"Daffy\", 8), ... };\nFirst, we need an array of Ducks:\n2\nArrays.sort(ducks);\nThen we call the sort() template method in the Arrays \nclass and pass it our ducks:\nThe sort() method (and its helper, mergeSort()) control \nthe sort procedure.\nfor (int i=low; i<high; i++){\n        ... compareTo() ...\n        ... swap() ...\n}\n3\nducks[0].compareTo(ducks[1]);\nTo sort an array, you need to compare two items one \nby one until the entire list is in sorted order.\nWhen it comes to comparing two ducks, the sort() \nmethod relies on the Duck\u2019s compareTo() method \nto know how to do this. The compareTo() method \nis called on the first duck and passed the duck to be \ncompared to:\nsort()\nswap()\nArrays\ncompareTo()\ntoString()\nDuck\n4\nswap()\nIf the Ducks are not in sorted order, they\u2019re swapped with \nthe concrete swap() method in Arrays:\nThe sort() method controls \nthe algorithm; no class can \nchange this. sort() counts \non a Comparable class to \nprovide the implementation \nof compareT\no().\n5\nThe sort() method continues comparing and swapping Ducks \nuntil the array is in the correct order!\nFirst Duck\nDuck to compare it to\nNo inheritance, \nunlike a typical \ntemplate method.\nBehind \nthe Scenes\n", "page": 344, "type": "text", "section": "Page 344"}
{"text": "you are here 4\u2003 \u2003 307\nthe template method pattern\nQ: Is this really the Template Method Pattern, or are you \ntrying too hard?\nA: The pattern calls for implementing an algorithm and letting \nsubclasses supply the implementation of the steps\u2014and the Arrays \nsort() is clearly not doing that! But, as we know, patterns in the \nwild aren\u2019t always just like the textbook patterns. They have to be  \nmodified to fit the context and implementation constraints.\nThe designers of the Arrays sort() method had a few constraints. In \ngeneral, you can\u2019t subclass a Java array and they wanted the sort to \nbe used on all arrays (and each array is a different class). So they \ndefined a static method and deferred the comparison part of the \nalgorithm to the items being sorted. \nSo, while it\u2019s not a textbook template method, this implementation is \nstill in the spirit of the Template Method Pattern. Also, by eliminating \nthe requirement that you have to subclass Arrays to use this \nalgorithm, they\u2019ve made sorting in some ways more flexible and \nuseful. \nQ: This implementation of sorting actually seems more like \nthe Strategy Pattern than the Template Method Pattern. Why do \nwe consider it Template Method?\nA: You\u2019re probably thinking that because the Strategy Pattern uses \nobject composition. You\u2019re right in a way\u2014we\u2019re using the Arrays \nobject to sort our array, so that\u2019s similar to Strategy. But remember, \nin Strategy, the class that you compose with implements the \nentire algorithm. The algorithm that Arrays implements for sort() is \nincomplete; it needs a class to fill in the missing compareTo() method. \nSo, in that way, it\u2019s more like Template Method.\nQ: Are there other examples of template methods in the Java \nAPI?\nA: Yes, you\u2019ll find them in a few places. For example, java.io has a \nread() method in InputStream that subclasses must implement and is \nused by the template method read(byte b[], int off, int len).\nWe know that we should favor composition over inheritance, right? Well, the \nimplementers of the sort() template method decided not to use inheritance and \ninstead to implement sort() as a static method that is composed with a Comparable \nat runtime. How is this better? How is it worse? How would you approach this \nproblem? Do Java arrays make this particularly tricky?\nThink of another pattern that is a specialization of the template method. In \nthis specialization, primitive operations are used to create and return objects.  \nWhat pattern is this?\n2\n", "page": 345, "type": "text", "section": "Page 345"}
{"text": "308\u2003 \u2003 Chapter 8\nthe paint hook\npublic class MyFrame extends JFrame {\n    public MyFrame(String title) {\n        super(title);\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setSize(300,300);\n        this.setVisible(true);\n    }\n    public void paint(Graphics graphics) {\n        super.paint(graphics);\n        String msg = \"I rule!!\";\n        graphics.drawString(msg, 100, 100);\n    }\n    public static void main(String[] args) {\n        MyFrame myFrame = new MyFrame(\"Head First Design Patterns\");\n    }\n}\nSwingin\u2019 with Frames\nUp next on our Template Method safari...keep your eye out for swinging JFrames!\nIf you haven\u2019t encountered JFrame, it\u2019s the most basic Swing container and inherits a \npaint() method. By default, paint() does nothing because it\u2019s a hook! By overriding paint(), \nyou can insert yourself into JFrame\u2019s algorithm for displaying its area of the screen and \nhave your own graphic output incorporated into the JFrame. Here\u2019s an embarrassingly \nsimple example of using a JFrame to override the paint() hook method:\nWe\u2019re extending JFrame, which contains a \nmethod update() that controls the algorithm \nfor updating the screen. We can hook into that \nalgorithm by overriding the paint() hook method.\nJFrame\u2019s update algorithm calls paint(). By \ndefault, paint() draws nothing...it\u2019s a hook.  \nWe\u2019re overriding paint() and telling the \nJFrame to draw a message in the window.\nHere\u2019s the message that gets \npainted in the frame because we\u2019ve \nhooked into the paint() method.\nDon\u2019t look behind the \ncurtain! Just some \ninitialization here...\n", "page": 346, "type": "text", "section": "Page 346"}
{"text": "you are here 4\u2003 \u2003 309\nthe template method pattern\nCustom Lists with AbstractList\nOur final stop on the safari: AbstractList.\nThe list collections in Java, like ArrayList and LinkedList, \nextend the AbstractList class, which provides some of the \nbasic implementations for list behavior. If you want to \ncreate your own custom list\u2014say, a list that contains only \nStrings\u2014you can do that by extending AbstractList so \nyou get that basic list behavior for free. \nAbstractList has a template method, subList(), that relies \non two abstract methods, get() and size(). So when you \nextend AbstractList to create your own custom list, you\u2019ll \nprovide implementations for these methods. \nHere\u2019s an implementation of a custom list that contains \nonly String objects, and uses arrays for the underlying \nimplementation: \nCreate a sublist of one item starting at \nindex 2...the Rubber Duck, of course.\nWe create a custom list by \nextending AbstractList.\nsubList()\nget(int)\nsize()\niterator()\nhashCode()\n// other methods\nAbstractList\nget(int)\nsize()\nMyList\nget(3);\nsize();\npublic class MyStringList extends AbstractList<String> {\n\t\nprivate String[] myList;\n\t\nMyStringList(String[] strings) {\n\t\n\t\nmyList = strings;\n\t\n}\n\t\npublic String get(int index) {\n\t\n\t\nreturn myList[index];\n\t\n}\n\t\npublic int size() {\n\t\n\t\nreturn myList.length;\n\t\n}\n\t\npublic String set(int index, String item) {\n\t\n\t\nString oldString = myList[index];\n\t\n\t\nmyList[index] = item;\n\t\n\t\nreturn oldString;\n\t\n}\n}\nString[] ducks = { \"Mallard Duck\", \"Redhead Duck\", \"Rubber Duck\", \"Decoy Duck\"};\nMyStringList ducksList = new MyStringList(ducks);\nList ducksSubList = ducksList.subList(2, 3);\nTest the subList() template method in your MyStringList implementation like this:\nWe must implement the methods get() \nand size(), which are both used by \nthe template method subList().\nWe also implement a method set() \nso we can modify the list. \n", "page": 347, "type": "text", "section": "Page 347"}
{"text": "310\u2003 \u2003 Chapter 8\nfireside chats: template method and strategy\nTonight\u2019s talk: Template Method and Strategy \ncompare methods.\nTemplate Method:\nHey Strategy, what are you doing in my chapter?  \nI figured I\u2019d get stuck with someone boring like \nFactory Method.\n\n\n\nI was just kidding! But seriously, what are you doing \nhere? We haven\u2019t heard from you in seven chapters!\nYou might want to remind the reader what you\u2019re \nall about, since it\u2019s been so long.\n\n\nHey, that does sound a lot like what I do. But my \nintent\u2019s a little different from yours; my job is to \ndefine the outline of an algorithm, but let my \nsubclasses do some of the work. That way, I can \nhave different implementations of an algorithm\u2019s \nindividual steps, but keep control over the \nalgorithm\u2019s structure. Seems like you have to give up \ncontrol of your algorithms.\nStrategy:\n\n\n\n\n\nNope, it\u2019s me, although be careful\u2014you and Factory \nMethod are related, aren\u2019t you?\n\n\nI\u2019d heard you were on the final draft of your chapter \nand I thought I\u2019d swing by to see how it was going. \nWe have a lot in common, so I thought I might be \nable to help...\nI don\u2019t know, since Chapter 1, people have been \nstopping me in the street saying, \u201cAren\u2019t you that \npattern...?\u201d So I think they know who I am. But \nfor your sake: I define a family of algorithms and \nmake them interchangeable. Since each algorithm is \nencapsulated, the client can use different algorithms \neasily.\nI\u2019m not sure I\u2019d put it quite like that...and anyway, \nI\u2019m not stuck using inheritance for algorithm \nimplementations. I offer clients a choice of \nalgorithm implementation through object \ncomposition.\nHey, I heard that!\nFactory Method\n", "page": 348, "type": "text", "section": "Page 348"}
{"text": "you are here 4\u2003 \u2003 311\nthe template method pattern\nTemplate Method:\nI remember that. But I have more control over \nmy algorithm and I don\u2019t duplicate code. In fact, \nif every part of my algorithm is the same except \nfor, say, one line, then my classes are much more \nefficient than yours. All my duplicated code gets put \ninto the superclass, so all the subclasses can share it.\n\n\n\n\nYeah, well, I\u2019m real happy for ya, but don\u2019t forget \nI\u2019m the most used pattern around. Why? Because I \nprovide a fundamental method for code reuse that \nallows subclasses to specify behavior. I\u2019m sure you \ncan see that this is perfect for creating frameworks.\nHow\u2019s that? My superclass is abstract.  \nLike I said, Strategy, I\u2019m real happy for you. Thanks \nfor stopping by, but I\u2019ve got to get the rest of this \nchapter done.\nGot it. Don\u2019t call us, we\u2019ll call you...\nStrategy:\n\n\n\n\n\nYou might be a little more efficient (just a little) and \nrequire fewer objects. And you might also be a little \nless complicated in comparison to my delegation \nmodel, but I\u2019m more flexible because I use object \ncomposition. With me, clients can change their \nalgorithms at runtime simply by using a different \nstrategy object. Come on, they didn\u2019t choose me for \nChapter 1 for nothing!\nYeah, I guess...but what about dependency?  You\u2019re \nway more dependent than me.\nBut you have to depend on methods implemented \nin your subclasses, which are part of your algorithm. \n \nI don\u2019t depend on anyone; I can do the entire \nalgorithm myself!\nOkay, okay, don\u2019t get touchy. I\u2019ll let you work, but let \nme know if you need my special techniques anyway; \nI\u2019m always glad to help.\n", "page": 349, "type": "text", "section": "Page 349"}
{"text": "312\u2003 \u2003 Chapter 8\ncrossword puzzle\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nAcross\n1. Huey, Louie and Dewey all weigh ________ \npounds\n2. The template method is usually defined in an \n___________ class\n4. In this chapter we gave you more \n_____________\n7. The steps in the algorithm that must be \nsupplied by the subclasses are usually \ndeclared ___________\n11. The JFrame hook method that we overrode \nto print \"I Rule\"\n12. _____List has a subList template method\n13. Type of sort used in Arrays\n14. The Template Method Pattern uses \n____________ to defer implementation to \nDown\n1. Coffee and _____\n3. Factory Method is a _______________ of \nTemplate Method\n5. A template method defines the steps of an \n____________\n6. Big headed pattern\n8. _________ algorithm steps are implemented \nby hook methods\n9. Our favorite coffee shop in Objectville\n10. The Arrays class implements its template \nmethod as a _________ method\n15. A method in the abstract superclass that \ndoes nothing or provides default behavior is \ncalled a _________ method\nDesign Patterns Crossword\nIt\u2019s that time again...\nACROSS\n1. Huey, Louie, and Dewey all weigh __________ pounds.\n2. The template method is usually defined in an _______ \nclass.\n4. In this chapter we gave you more _________.\n7. The steps in the algorithm that must be supplied by the \nsubclasses are usually declared ___________.\n11. The JFrame hook method that we overrode to print \u201cI \nrule!!\u201d\n12. ___________ has a subList() template method.\n13. Type of sort used in Arrays.\n14. The Template Method Pattern uses _____________ \nto defer implementation to other classes.\n15. \u201cDon\u2019t call us, we\u2019ll call you\u201d is known as the \n_________ Principle.\nDOWN\n1. Coffee and ______.\n3. Factory Method is a __________ of Template Method.\n5. A template method defines the steps of an ________.\n6. Big-headed pattern.\n8. _______ algorithm steps are implemented by hook \nmethods. \n9. Our favorite coffee shop in Objectville.\n10. The Arrays class implements its template method as \na ______ method.\n15. A method in the abstract superclass that does nothing \nor provides default behavior is called a ____________  \nmethod.\n", "page": 350, "type": "text", "section": "Page 350"}
{"text": "you are here 4\u2003 \u2003 313\nthe template method pattern\nTools for your Design Toolbox\nWe\u2019ve added Template Method to your toolbox. \nWith Template Method, you can reuse code like a \npro while keeping control of your algorithms.\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies.\nFavor composition over inheritance.\nProgram to interfaces, not \nimplementations.\nStrive for loosely coupled designs \nbetween objects that interact.\nClasses should be open for extension \nbut closed for modification.\nDepend on abstractions. Do not \ndepend on concrete classes.\nT\nalk only to your friends.\nDon\u2019t call us, we\u2019ll call you.\nOO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable.  Strategy lets the algorithm \nvary independently from clients that use it.\nOO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically.  \nDecorators provide a flexible \nalternative to subclassing for extending \nfunctionality.\nAbstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes.\nFactory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate.  Factory Method lets \na class defer instantiation to the \nsubclasses.\nSingleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it.\nCommand - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nAdapter - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nOur newest principle \nreminds you that your \nsuperclasses are running \nthe show, so let them call \nyour subclass methods when \nthey\u2019re needed, just like \nthey do in Hollywood.\nFacade - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nAnd our newest \npattern lets classes \nimplementing an \nalgorithm defer some \nsteps to subclasses.\nT\nemplate Method - Define the \nskeleton of an algorithm in an operation, \ndeferring some steps to subclasses.  \nT\nemplate Method lets subclasses redefine \ncertain steps of an algorithm without \nchanging the algorithm\u2019s structure.\n\t\n\u0083\nA template method defines the \nsteps of an algorithm, deferring to \nsubclasses for the implementation \nof those steps.\n\t\n\u0083\nThe Template Method Pattern \ngives us an important technique \nfor code reuse.\n\t\n\u0083\nThe template method\u2019s abstract \nclass may define concrete \nmethods, abstract methods, and \nhooks.\n\t\n\u0083\nAbstract methods are \nimplemented by subclasses.\n\t\n\u0083\nHooks are methods that do \nnothing or default behavior in \nthe abstract class, but may be \noverridden in the subclass.\n\t\n\u0083\nTo prevent subclasses from \nchanging the algorithm in the \ntemplate method, declare the \ntemplate method as final.\n\t\n\u0083\nThe Hollywood Principle guides us \nto put decision making in high-\nlevel modules that can decide \nhow and when to call low-level \nmodules.\n\t\n\u0083\nYou\u2019ll see lots of uses of the \nTemplate Method Pattern in \nreal-world code, but (as with any \npattern) don\u2019t expect it all to be \ndesigned \u201cby the book.\u201d\n\t\n\u0083\nThe Strategy and Template \nMethod Patterns both encapsulate \nalgorithms, the first by composition \nand the other by inheritance.\n\t\n\u0083\nFactory Method is a specialization \nof Template Method.\n", "page": 351, "type": "text", "section": "Page 351"}
{"text": "314\u2003 \u2003 Chapter 8\nexercise solutions\nDraw the new class diagram now that we\u2019ve moved \nprepareRecipe() into the CaffeineBeverage class:\nMatch each pattern with its description:\nSOlUTion\nPattern\nDescription\nTemplate Method\nStrategy\nFactory Method\nEncapsulate interchangable \nbehaviors and use delegation to \ndecide which behavior to use.\nSubclasses decide how to \nimplement steps in an algorithm.\nSubclasses decide which \nconcrete classes to create.\nprepareRecipe()\nboilWater()\npourInCup()\nbrew()\naddCondiments()\nCaffeineBeverage\nbrew()\naddCondiments()\nCoffee\nbrew()\naddCondiments()\nTea\n", "page": 352, "type": "text", "section": "Page 352"}
{"text": "you are here 4\u2003 \u2003 315\nthe template method pattern\nDesign Patterns Crossword Solution\nIt\u2019s that time again...\nT\n1\nW\nO\nA\n2\nB\nS\n3\nT\nR\nA\nC\nT\nC\n4\nA\n5\nF\nF\nE\nI\nN\nE\nP\nL\nA\nE\nS\n6\nG\nA\n7\nB\nS\nT\nR\nA\nC\nT\nT\nO\nI\nR\nR\nA\nO\n8\nA\nI\nS\n9\nS\n10\nL\nP\n11\nA\nI\nN\nT\nT\nT\nA\n12\nB\nS\nT\nR\nA\nC\nT\nL\nI\nS\nT\nE\nH\nA\nA\nZ\nI\nG\nM\n13\nE\nR\nG\nE\nS\nO\nR\nT\nA\nO\nY\nB\nI\n14\nN\nH\nE\nR\nI\nT\nA\nN\nC\nE\nU\nC\nI\nA\nZ\nH\n15\nO\nL\nL\nY\nW\nO\nO\nD\nZ\nC\n16\nO\nM\nP\nO\nS\nI\nT\nI\nO\nN\nO\nK\nAcross\n1. Huey, Louie and Dewey all weigh ________ \npounds [TWO] \n2. The template method is usually defined in an \n___________ class [ABSTRACT] \n4. In this chapter we gave you more \n_____________ [CAFFEINE] \n7. The steps in the algorithm that must be \nsupplied by the subclasses are usually \ndeclared ___________ [ABSTRACT] \n11. The JFrame hook method that we overrode \nto print \"I Rule\" [PAINT] \n12. _____List has a subList template method \n[ABSTRACTLIST] \n13 Type of sort used in Arrays [MERGESORT]\nDown\n1. Coffee and _____ [TEA] \n3. Factory Method is a _______________ of \nTemplate Method [SPECIALIZATION] \n5. A template method defines the steps of an \n____________ [ALGORITHM] \n6. Big headed pattern [STRATEGY] \n8. _________ algorithm steps are implemented \nby hook methods [OPTIONAL] \n9. Our favorite coffee shop in Objectville \n[STARBUZZ] \n10. The Arrays class implements its template \nmethod as a _________ method [STATIC] \n15. A method in the abstract superclass that \ndoes nothing or provides default behavior is\n", "page": 353, "type": "text", "section": "Page 353"}
{"text": "this is a new chapter\u2003 \u2003 317\nThere are lots of ways to stuff objects into a collection. \nPut them into an Array, a Stack, a List, a hash map\u2014take your pick. Each has its \nown advantages and tradeoffs. But at some point your clients are going to want \nto iterate over those objects, and when they do, are you going to show them your \nimplementation? We certainly hope not! That just wouldn\u2019t be professional. Well, you \ndon\u2019t have to risk your career; in this chapter you\u2019re going to see how you can allow \nyour clients to iterate through your objects without ever getting a peek at how you store \nyour objects. You\u2019re also going to learn how to create some super collections of objects \nthat can leap over some impressive data structures in a single bound. And if that\u2019s not \nenough, you\u2019re also going to learn a thing or two about object responsibility.  \n9  the Iterator and Composite Patterns\nWell-Managed\n          Collections\nYou bet I keep \nmy collections well \nencapsulated!\n", "page": 355, "type": "text", "section": "Page 355"}
{"text": "318\u2003 \u2003 Chapter 9\na business merger\nMel\nLou\nThat\u2019s great news! Now we can get those delicious pancake breakfasts at the \nPancake House and those yummy lunches at the Diner all in one place. But there \nseems to be a slight problem...\nBreaking News: Objectville Diner and \nObjectville Pancake House Merge\nThey want to use my Pancake House \nmenu as the breakfast menu and \nthe Diner\u2019s menu as the lunch menu.  \nWe\u2019ve agreed on an implementation \nfor the menu items...\n...but we can\u2019t agree on how to implement \nour menus. That joker over there used an \nArrayList to hold his menu items, and I \nused an Array. Neither one of us is willing to \nchange our implementations...we just have \ntoo much code written that depends on \nthem.\n", "page": 356, "type": "text", "section": "Page 356"}
{"text": "you are here 4\u2003 \u2003 319\nthe iterator and composite patterns\npublic class MenuItem {\n    String name;\n    String description;\n    boolean vegetarian;\n    double price;\n \n    public MenuItem(String name, \n                    String description, \n                    boolean vegetarian, \n                    double price) \n    {\n        this.name = name;\n        this.description = description;\n        this.vegetarian = vegetarian;\n        this.price = price;\n    }\n  \n    public String getName() {\n        return name;\n    }\n  \n    public String getDescription() {\n        return description;\n    }\n  \n    public double getPrice() {\n        return price;\n    }\n  \n    public boolean isVegetarian() {\n        return vegetarian;\n    }\n}\nCheck out the Menu Items\nObjectville Diner\nVegetarian BLT                                                                          2.99\n        (Fakin\u2019) Bacon with lettuce & tomato on \n        whole wheat\nBLT                                                                                                      2.99\n        Bacon with lettuce & tomato on whole wheat\nSoup of the day                                                                        3.29\n        A bowl of the soup of the day, with \n        a side of potato salad\nHot Dog                                                                                       3.05\n        A hot dog, with sauerkraut, relish, onions, \n        topped with cheese\nSteamed Veggies and Brown Rice                           3.99\n        A medley of steamed vegetables over brown rice\nK&B\u2019s Pancake Breakfast                                           2.99\n        Pancakes with scrambled eggs and toast \nRegular Pancake Breakfast                                     2.99\n        Pancakes with fried eggs, sausage\nBlueberry Pancakes                                                      3.49\n        Pancakes made with fresh blueberries, \n        and blueberry syrup\nWaffles                                                                                   3.59\n        Waffles with your choice of blueberries \n        or strawberries\nObjectville Pancake House\nA MenuItem consists of a name, a description, \na flag to indicate if the item is vegetarian, \nand a price. You pass all these values into the \nconstructor to initialize the MenuItem.\nThese getter methods let you access \nthe fields of the menu item.\nAt least Lou and Mel agree on the \nimplementation of the MenuItems. Let\u2019s \ncheck out the items on each menu, and \nalso take a look at the implementation.\nThe Diner menu has lots of lunch \nitems, while the Pancake House \nconsists of breakfast items.  \nEvery menu item has a name, a \ndescription, and a price.\n", "page": 357, "type": "text", "section": "Page 357"}
{"text": "320\u2003 \u2003 Chapter 9\ntwo menu implementations\npublic class PancakeHouseMenu {\n    List<MenuItem> menuItems;\n \n    public PancakeHouseMenu() {\n        menuItems = new ArrayList<MenuItem>();\n    \n        addItem(\"K&B's Pancake Breakfast\", \n            \"Pancakes with scrambled eggs and toast\", \n            true,\n            2.99);\n \n        addItem(\"Regular Pancake Breakfast\", \n            \"Pancakes with fried eggs, sausage\", \n            false,\n            2.99);\n \n        addItem(\"Blueberry Pancakes\",\n            \"Pancakes made with fresh blueberries\",\n            true,\n            3.49);\n \n        addItem(\"Waffles\",\n            \"Waffles with your choice of blueberries or strawberries\",\n            true,\n            3.59);\n    }\n    public void addItem(String name, String description,\n                        boolean vegetarian, double price)\n    {\n        MenuItem menuItem = new MenuItem(name, description, vegetarian, price);\n        menuItems.add(menuItem);\n    }\n \n    public ArrayList<MenuItem> getMenuItems() {\n        return menuItems;\n    }\n    // other menu methods here\n}\nI used an ArrayList \nso I can easily expand \nmy menu.\nLou and Mel\u2019s Menu implementations\nNow let\u2019s take a look at what Lou and Mel are \narguing about. They both have lots of time and \ncode invested in the way they store their menu \nitems in a menu, and lots of other code that \ndepends on it.\nLou\u2019s using an ArrayList \nclass to store his menu items.\nEach menu item is added to the \nArrayList here, in the constructor.\nT\no add a menu item, Lou creates a new \nMenuItem object, passing in each argument, \nand then adds it to the ArrayList.\nLou has a bunch of other menu code that \ndepends on the ArrayList implementation. He \ndoesn\u2019t want to have to rewrite all that code!\nThe getMenuItems() method returns the \nlist of menu items.\nHere\u2019s Lou\u2019s implementation of \nthe Pancake House menu.  \nEach MenuItem has a name, a \ndescription, whether or not it\u2019s a \nvegetarian item, and the price.\n", "page": 358, "type": "text", "section": "Page 358"}
{"text": "you are here 4\u2003 \u2003 321\nthe iterator and composite patterns\npublic class DinerMenu {\n    static final int MAX_ITEMS = 6;\n    int numberOfItems = 0;\n    MenuItem[] menuItems;\n  \n    public DinerMenu() {\n        menuItems = new MenuItem[MAX_ITEMS];\n \n        addItem(\"Vegetarian BLT\",\n            \"(Fakin') Bacon with lettuce & tomato on whole wheat\", true, 2.99);\n        addItem(\"BLT\",\n            \"Bacon with lettuce & tomato on whole wheat\", false, 2.99);\n        addItem(\"Soup of the day\",\n            \"Soup of the day, with a side of potato salad\", false, 3.29);\n        addItem(\"Hotdog\",\n            \"A hot dog, with sauerkraut, relish, onions, topped with cheese\",\n            false, 3.05);\n        // a couple of other Diner Menu items added here\n    }\n  \n    public void addItem(String name, String description, \n                         boolean vegetarian, double price) \n    {\n        MenuItem menuItem = new MenuItem(name, description, vegetarian, price);\n        if (numberOfItems >= MAX_ITEMS) {\n            System.err.println(\"Sorry, menu is full!  Can't add item to menu\");\n        } else {\n            menuItems[numberOfItems] = menuItem;\n            numberOfItems = numberOfItems + 1;\n        }\n    }\n \n    public MenuItem[] getMenuItems() {\n        return menuItems;\n    }\n \n    // other menu methods here\n}\nAnd here\u2019s Mel\u2019s implementation of the Diner menu.  \nMel takes a different approach; he\u2019s using an Array \nclass so he can control the max size of the menu. \nLike Lou, Mel creates his menu items in the \nconstructor, using the addItem() helper method. \naddItem() takes all the parameters \nnecessary to create a MenuItem and \ninstantiates one. It also checks to make \nsure we haven\u2019t hit the menu size limit.\nLike Lou, Mel has a bunch of code that depends on the implementation \nof his menu being an Array. He\u2019s too busy cooking to rewrite all of this.\nMel specifically wants to keep his menu \nunder a certain size (presumably so he \ndoesn\u2019t have to remember too many recipes).\ngetMenuItems() returns the array of menu items.\nHaah! An ArrayList...I used a \nREAL Array so I can control the \nmaximum size of my menu.\n", "page": 359, "type": "text", "section": "Page 359"}
{"text": "322\u2003 \u2003 Chapter 9\njava-enabled waitress\nTo see why having two different menu representations complicates \nthings, let\u2019s try implementing a client that uses the two menus.  \nImagine you have been hired by the new company formed by the \nmerger of the Diner and the Pancake House to create a Java-enabled \nwaitress (this is Objectville, after all). The spec for the Java-enabled \nwaitress specifies that she can print a custom menu for customers on \ndemand, and even tell you if a menu item is vegetarian without having \nto ask the cook\u2014now that\u2019s an innovation!\nLet\u2019s check out the spec for the waitress, and then step through what it \nmight take to implement her...\nWhat\u2019s the problem with having two different \nmenu representations?\nThe Waitress is getting \nJava-enabled.\nThe Java-Enabled Waitress Specification\nJava-Enabled Waitress: code-name \"Alice\"\nprintMenu()\n   - prints every item on the breakfast and\n     lunch menus\nprintBreakfastMenu()\n   - prints just breakfast items\nprintLunchMenu()\n   - prints just lunch items\nprintVegetarianMenu()\n   - prints all vegetarian menu items\nisItemVegetarian(name)\n   - given the name of an item, returns true\n     if the items is vegetarian, otherwise,\n     returns false\nThe spec for \nthe Waitress\n", "page": 360, "type": "text", "section": "Page 360"}
{"text": "you are here 4\u2003 \u2003 323\nthe iterator and composite patterns\n1\n3\n2\nTo print all the items on each menu, you\u2019ll need to call the getMenuItems() \nmethod on the PancakeHouseMenu and the DinerMenu to retrieve their \nrespective menu items. Note that each returns a different type:\nPancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();\nArrayList<MenuItem> breakfastItems = pancakeHouseMenu.getMenuItems();\nDinerMenu dinerMenu = new DinerMenu();\nMenuItem[] lunchItems = dinerMenu.getMenuItems();\nNow, to print out the items from the PancakeHouseMenu, we\u2019ll loop through the \nitems on the breakfastItems ArrayList. And to print out the Diner items, we\u2019ll loop \nthrough the Array.\nImplementing every other method in the Waitress is going to be a variation of \nthis theme. We\u2019re always going to need to get both menus and use two loops to \niterate through their items. If another restaurant with a different implementation \nis acquired, then we\u2019ll have three loops.\nfor (int i = 0; i < breakfastItems.size(); i++) {\n    MenuItem menuItem = breakfastItems.get(i);\n    System.out.print(menuItem.getName() + \" \");\n    System.out.println(menuItem.getPrice() + \" \");\n    System.out.println(menuItem.getDescription());\n}\nfor (int i = 0; i < lunchItems.length; i++) {\n    MenuItem menuItem = lunchItems[i];\n    System.out.print(menuItem.getName() + \" \");\n    System.out.println(menuItem.getPrice() + \" \");\n    System.out.println(menuItem.getDescription());\n}\nThe method looks \nthe same, but the \ncalls are returning \ndifferent types.\nNow, we have to \nimplement two \ndifferent loops to \nstep through the two \nimplementations of the \nmenu items...\n...one loop for the \nArrayList...\n...and another for \nthe Array.\nThe implementation is showing \nthrough: breakfast items are \nin an ArrayList, and lunch \nitems are in an Array.\nLet\u2019s start by stepping through how we\u2019d implement the printMenu() method:\nImplementing the spec: our first attempt\n", "page": 361, "type": "text", "section": "Page 361"}
{"text": "324\u2003 \u2003 Chapter 9\nwhat\u2019s the goal\n\u274f   A.\t We are coding to the \nPancakeHouseMenu and DinerMenu \nconcrete implementations, not to an \ninterface.\n\u274f   B.\t The Waitress doesn\u2019t implement the \nJava Waitress API and so she isn\u2019t \nadhering to a standard.\n\u274f   C.\t If we decided to switch from using \nDinerMenu to another type of menu \nthat implemented its list of menu items \nwith a hash table, we\u2019d have to modify \na lot of code in the Waitress.\n\u274f   D.\t The Waitress needs to know how each \nmenu represents its internal collection of \nmenu items; this violates encapsulation.\n\u274f   E.\t We have duplicate code: the printMenu() \nmethod needs two separate loops to \niterate over the two different kinds of \nmenus. And if we added a third menu, \nwe\u2019d have yet another loop. \n\u274f   F.\t The implementation isn\u2019t based on \nMXML (Menu XML) and so isn\u2019t as \ninteroperable as it should be.\nMel and Lou are putting us in a difficult position. They don\u2019t want to change their \nimplementations because it would mean rewriting a lot of code that is in each respective \nmenu class. But if one of them doesn\u2019t give in, then we\u2019re going to have the job of \nimplementing a Waitress that will be hard to maintain and extend.\nIt would really be nice if we could find a way to allow them to implement the same \ninterface for their menus (they\u2019re already close, except for the return type of the \ngetMenuItems() method). That way we can minimize the concrete references in the \nWaitress code and also hopefully get rid of the multiple loops required to iterate over \nboth menus.\nSound good? Well, how are we going to do that?\nWhat now?\nBased on our implementation of printMenu(), which of the following apply? \n", "page": 362, "type": "text", "section": "Page 362"}
{"text": "you are here 4\u2003 \u2003 325\nthe iterator and composite patterns\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArrayList\nAn ArrayList \nof MenuItems\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArray\nAn Array of \nMenuItems.\nfor (int i = 0; i < breakfastItems.size(); i++) {\n    MenuItem menuItem = breakfastItems.get(i);\n}\nfor (int i = 0; i < lunchItems.length; i++) {\n    MenuItem menuItem = lunchItems[i];\n}\nCan we encapsulate the iteration?\nIf we\u2019ve learned one thing in this book, it\u2019s to encapsulate what varies. It\u2019s \nobvious what is changing here: the iteration caused by different collections of \nobjects being returned from the menus. But can we encapsulate this? Let\u2019s work \nthrough the idea...\n1\nTo iterate through the breakfast items, we use the size() and get() \nmethods on the ArrayList:\n2\nAnd to iterate through the lunch items we use the Array length field and \nthe array subscript notation on the MenuItem Array.\nlunchItems[0]\nlunchItems[1]\nlunchItems[2]\nlunchItems[3]\nget(0)\nget(1)\nget(2)\nget(3)\nget() helps us step \nthrough each item.\nWe use the array \nsubscripts to step \nthrough items.\n", "page": 363, "type": "text", "section": "Page 363"}
{"text": "326\u2003 \u2003 Chapter 9\n3\nNow what if we create an object, let\u2019s call it an Iterator, \nthat encapsulates the way we iterate through a \ncollection of objects? Let\u2019s try this on the ArrayList:\nIterator iterator = breakfastMenu.createIterator();\nwhile (iterator.hasNext()) {\n    MenuItem menuItem = iterator.next();\n}\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArrayList\n \n \n \n \n \n \n \n \n \nI\nt\ne\nr\na\nt\no\nr\nWe ask the breakfastMenu \nfor an iterator of its \nMenuItems.\nAnd while there are more items left...\n...we get the next item.\n4\nLet\u2019s try that on the Array too:\nIterator iterator = lunchMenu.createIterator();\nwhile (iterator.hasNext()) {\n    MenuItem menuItem = iterator.next();\n}\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArray\nlunchItems[0]\nlunchItems[1]\nlunchItems[2]\nlunchItems[3]\n \n \n \n \n \n \n \n \n \nI\nt\ne\nr\na\nt\no\nr\nThe client just calls hasNext() \nand next(); behind the scenes the \niterator calls get() on the ArrayList.\nSame situation here: the client just calls \nhasNext() and next(); behind the scenes, \nthe iterator indexes into the Array.\nWow, this code \nis exactly the \nsame as the \nbreakfastMenu \ncode.\nget(0)\nget(1)\nget(2)\nget(3)\nnext()\nnext()\nencapsulating iteration\n", "page": 364, "type": "text", "section": "Page 364"}
{"text": "you are here 4\u2003 \u2003 327\nthe iterator and composite patterns\nMeet the Iterator Pattern\nWell, it looks like our plan of encapsulating iteration just might \nactually work; and as you\u2019ve probably already guessed, it is a \nDesign Pattern called the Iterator Pattern.  \nThe first thing you need to know about the Iterator Pattern is that \nit relies on an interface called Iterator. Here\u2019s one possible Iterator \ninterface:\nhasNext()\nnext()\n<<interface>>\nIterator\nThe hasNext() method \ntells us if there are \nmore elements in the \naggregate to iterate \nthrough.\nThe next() method \nreturns the next \nobject in the \naggregate.\nNow, once we have this interface, we can implement Iterators for \nany kind of collection of objects: arrays, lists, hash maps\u2009...\u2009pick your \nfavorite collection of objects. Let\u2019s say we wanted to implement the \nIterator for the Array used in the DinerMenu. It would look like this:\nDinerMenuIterator is an \nimplementation of Iterator \nthat knows how to iterate \nover an array of MenuItems. \nhasNext()\nnext()\n<<interface>>\nIterator\nhasNext()\nnext()\nDinerMenuIterator\nLet\u2019s go ahead and implement this Iterator and incorporate it into \nDinerMenu to see how this works...\nWhen we say \nCOLLECTION we just mean a group \nof objects. They might be stored in \nvery different data structures like lists, \narrays, or hash maps, but they\u2019re still \ncollections. We also sometimes call \nthese AGGREGATES.\n", "page": 365, "type": "text", "section": "Page 365"}
{"text": "328\u2003 \u2003 Chapter 9\npublic interface Iterator {\n    boolean hasNext();\n    MenuItem next();\n}\npublic class DinerMenuIterator implements Iterator {\n    MenuItem[] items;\n    int position = 0;\n \n    public DinerMenuIterator(MenuItem[] items) {\n        this.items = items;\n    }\n \n    public MenuItem next() {\n        MenuItem menuItem = items[position];\n        position = position + 1;\n        return menuItem;\n    }\n \n    public boolean hasNext() {\n        if (position >= items.length || items[position] == null) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\nAdding an Iterator to DinerMenu\nHere are our two methods:\nThe hasNext() method returns a boolean \nindicating whether or not there are \nmore elements to iterate over...\nTo add an iterator to the DinerMenu, we first need to define the Iterator interface:\n...and the next() method \nreturns the next element.\nAnd now we need to implement a concrete Iterator that works for the Diner menu:\nWe implement the \nIterator interface.\nThe constructor takes the \narray of menu items we are \ngoing to iterate over.\nposition maintains the \ncurrent position of the \niteration over the array.\nThe next() method returns the \nnext item in the array and \nincrements the position.\nThe hasNext() method checks to see \nif we\u2019ve seen all the elements of the \narray and returns true if there are \nmore to iterate through. \nBecause the diner chef went ahead and \nallocated a max sized array, we need to \ncheck not only if we are at the end of \nthe array, but also if the next item is null, \nwhich indicates there are no more items. \nusing iterator\n", "page": 366, "type": "text", "section": "Page 366"}
{"text": "you are here 4\u2003 \u2003 329\nthe iterator and composite patterns\npublic class DinerMenu {\n    static final int MAX_ITEMS = 6;\n    int numberOfItems = 0;\n    MenuItem[] menuItems;\n  \n    // constructor here\n  \n    // addItem here\n \n    public MenuItem[] getMenuItems() {\n        return menuItems;\n    }\n  \n    public Iterator createIterator() {\n        return new DinerMenuIterator(menuItems);\n    }\n \n    // other menu methods here\n}\nReworking the DinerMenu with Iterator\nOkay, we\u2019ve got the iterator. Time to work it into the DinerMenu; all we need to do is \nadd one method to create a DinerMenuIterator and return it to the client:\nWe\u2019re not going to need the getMenuItems() \nmethod anymore; in fact, we don\u2019t want it \nbecause it exposes our internal implementation!\nHere\u2019s the createIterator() method. \n \nIt creates a DinerMenuIterator \nfrom the menuItems array and \nreturns it to the client.\nWe\u2019re returning the Iterator interface. The client \ndoesn\u2019t need to know how the MenuItems are maintained \nin the DinerMenu, nor does it need to know how the \nDinerMenuIterator is implemented. It just needs to use \nthe iterators to step through the items in the menu.\nGo ahead and implement the PancakeHouseIterator yourself and make the changes \nneeded to incorporate it into the PancakeHouseMenu.\n", "page": 367, "type": "text", "section": "Page 367"}
{"text": "330\u2003 \u2003 Chapter 9\npublic class Waitress {\n    PancakeHouseMenu pancakeHouseMenu;\n    DinerMenu dinerMenu;\n \n    public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) {\n        this.pancakeHouseMenu = pancakeHouseMenu;\n        this.dinerMenu = dinerMenu;\n    }\n \n    public void printMenu() {\n        Iterator pancakeIterator = pancakeHouseMenu.createIterator();\n        Iterator dinerIterator = dinerMenu.createIterator();\n        System.out.println(\"MENU\\n----\\nBREAKFAST\");\n        printMenu(pancakeIterator);\n        System.out.println(\"\\nLUNCH\");\n        printMenu(dinerIterator);\n    }\n \n    private void printMenu(Iterator iterator) {\n        while (iterator.hasNext()) {\n            MenuItem menuItem = iterator.next();\n            System.out.print(menuItem.getName() + \", \");\n            System.out.print(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n \n    // other methods here\n}\nFixing up the Waitress code\nIn the constructor the Waitress \nclass takes the two menus.\nThe printMenu() \nmethod now creates \ntwo iterators, one for \neach menu...\n...and then calls the \noverloaded printMenu() \nwith each iterator.\nThe overloaded \nprintMenu() \nmethod uses \nthe Iterator to \nstep through \nthe menu items \nand print them.\nNote that we\u2019re down \nto one loop.\nT\nest if there are \nany more items.\nGet the \nnext item.\nUse the item to \nget name, price, \nand description \nand print them.\nNow we need to integrate the iterator code into the \nWaitress class. We should be able to get rid of some \nof the redundancy in the process. Integration is pretty \nstraightforward: first we create a printMenu() method \nthat takes an Iterator; then we use the createIterator() \nmethod on each menu to retrieve the Iterator and \npass it to the new method.\nNew and \nimproved with \nIterator.\nfixing the waitress\n", "page": 368, "type": "text", "section": "Page 368"}
{"text": "you are here 4\u2003 \u2003 331\nthe iterator and composite patterns\npublic class MenuTestDrive {\n    public static void main(String args[]) {\n        PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();\n        DinerMenu dinerMenu = new DinerMenu();\n \n        Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu);\n \n        waitress.printMenu();\n    }\n}\nTesting our code\nFile  Edit   Window  Help   \n% java DinerMenuTestDrive\nMENU\n----\nBREAKFAST\nK&B\u2019s Pancake Breakfast, 2.99 -- Pancakes with scrambled eggs and toast\nRegular Pancake Breakfast, 2.99 -- Pancakes with fried eggs, sausage\nBlueberry Pancakes, 3.49 -- Pancakes made with fresh blueberries\nWaffles, 3.59 -- Waffles with your choice of blueberries or strawberries\nLUNCH\nVegetarian BLT, 2.99 -- (Fakin\u2019) Bacon with lettuce & tomato on whole wheat\nBLT, 2.99 -- Bacon with lettuce & tomato on whole wheat\nSoup of the day, 3.29 -- Soup of the day, with a side of potato salad\nHot Dog, 3.05 -- A hot dog, with sauerkraut, relish, onions, topped with cheese\nSteamed Veggies and Brown Rice, 3.99 -- Steamed vegetables over brown rice\nPasta, 3.89 -- Spaghetti with marinara sauce, and a slice of sourdough bread\n%\nFirst we create the new menus.\nThen we create a \nWaitress and pass \nher the menus.\nThen we print them.\nHere\u2019s the test run...\nIt\u2019s time to put everything to a test. Let\u2019s write some \ntest drive code and see how the Waitress works...\nFirst we iterate \nthrough the \npancake menu...\n...and then \nthe lunch \nmenu, all \nwith the \nsame \niteration \ncode.\n", "page": 369, "type": "text", "section": "Page 369"}
{"text": "332\u2003 \u2003 Chapter 9\nWhat have we done so far?\nWoohoo! No code \nchanges other \nthan adding the \ncreateIterator() method.\nVeggie burger\nFor starters, we\u2019ve made our Objectville cooks \nvery happy. They settled their differences and \nkept their own implementations. Once we gave \nthem a PancakeHouseMenuIterator and a \nDinerMenuIterator, all they had to do was add a \ncreateIterator() method and they were finished.\nWe\u2019ve also helped ourselves in the process. The \nWaitress will be much easier to maintain and \nextend down the road. Let\u2019s go through exactly \nwhat we did and think about the consequences:\nHard-to-Maintain \nWaitress Implementation\nNew, Hip \nWaitress Powered by Iterator\nThe Menus are not well \nencapsulated; we can see the \nDiner is using an ArrayList and the \nPancake House an Array.\nThe Waitress is bound to concrete \nclasses (MenuItem[] and ArrayList).\nThe Waitress now uses an interface \n(Iterator).\nWe need two loops to iterate through \nthe MenuItems.\nAll we need is a loop that \npolymorphically handles any \ncollection of items as long as it \nimplements Iterator.\nThe Menu implementations are now \nencapsulated. The Waitress has \nno idea how the Menus hold their \ncollection of menu items.\nThe Waitress is bound to two different \nconcrete Menu classes, despite their \ninterfaces being almost identical.\nThe Menu interfaces are now exactly \nthe same and, uh oh, we still don\u2019t \nhave a common interface, which \nmeans the Waitress is still bound to \ntwo concrete Menu classes. We\u2019d \nbetter fix that.\ncomparing our implementations\n", "page": 370, "type": "text", "section": "Page 370"}
{"text": "you are here 4\u2003 \u2003 333\nthe iterator and composite patterns\nhasNext()\nnext()\n<<interface>>\nIterator\nBefore we clean things up, let\u2019s get a bird\u2019s-eye view of our current design.\nNote that the iterator gives us a way to \nstep through the elements of an aggregate \nwithout forcing the aggregate to clutter its \nown interface with a bunch of methods to \nsupport traversal of its elements. It also allows \nthe implementation of the iterator to live \noutside of the aggregate; in other words, we\u2019ve \nencapsulated the iteration.\nPancakeHouseMenu and DinerMenu \nimplement the new createIterator() \nmethod; they are responsible for creating \nthe iterator for their respective menu \nitems\u2019 implementations.\nprintMenu()\nWaitress\ncreateIterator()\nPancakeHouseMenu\nmenuItems\ncreateIterator()\nDinerMenu\nmenuItems\nhasNext()\nnext()\nDinerMenuIterator\nhasNext()\nnext()\nPancakeHouseMenuIterator\nReviewing our current design...\nThese two menus implement the \nsame exact set of methods, but \nthey aren\u2019t implementing the same \ninterface. We\u2019re going to fix this \nand free the Waitress from any \ndependencies on concrete Menus.\nWe\u2019re now using a \ncommon Iterator \ninterface \nand we\u2019ve \nimplemented two \nconcrete classes.\nThe Iterator allows the Waitress to be decoupled \nfrom the actual implementation of the concrete \nclasses. She doesn\u2019t need to know if a Menu is \nimplemented with an Array, an ArrayList, or with \nPost-it  notes. All she cares about is that she can \nget an Iterator to do her iterating.\n\u00ae\n", "page": 371, "type": "text", "section": "Page 371"}
{"text": "334\u2003 \u2003 Chapter 9\nMaking some improvements...\nOkay, we know the interfaces of PancakeHouseMenu and DinerMenu are exactly the same \nand yet we haven\u2019t defined a common interface for them. So, we\u2019re going to do that and clean \nup the Waitress a little more.  \nYou may be wondering why we\u2019re not using the Java Iterator interface\u2014we did that so you \ncould see how to build an iterator from scratch. Now that we\u2019ve done that, we\u2019re going to \nswitch to using the Java Iterator interface, because we\u2019ll get a lot of leverage by implementing \nthat instead of our home-grown Iterator interface. What kind of leverage? You\u2019ll soon see.\nFirst, let\u2019s check out the java.util.Iterator interface: \nhasNext()\nnext()\nremove()\n<<interface>>\nIterator\nThis looks just like our previous definition...\n...except we have an additional method that \nallows us to remove the last item returned \nby the next() method from the aggregate.\nThis is going to be a piece of cake: we just need to change the interface that both \nPancakeHouseMenuIterator and DinerMenuIterator extend, right? Almost...actually, it\u2019s even \neasier than that. Not only does java.util have its own Iterator interface, but ArrayList has an \niterator() method that returns an iterator. In other words, we never needed to implement our \nown iterator for ArrayList. However, we\u2019ll still need our implementation for the DinerMenu \nbecause it relies on an Array, which doesn\u2019t support the iterator() method.\nQ: What if I don\u2019t want to provide the ability to remove \nsomething from the underlying collection of objects?\nA: The remove() method is considered optional. You don\u2019t have \nto provide remove functionality. But you should provide the method \nbecause it\u2019s part of the Iterator interface. If you\u2019re not going to \nallow remove() in your iterator, you\u2019ll want to throw the runtime \nexception java.lang.UnsupportedOperationException. The Iterator \nAPI documentation specifies that this exception may be thrown \nfrom remove() and any client that is a good citizen will check for this \nexception when calling the remove() method.\nQ: How does remove() behave under multiple threads that \nmay be using different iterators over the same collection of \nobjects? \nA: The behavior of the remove() method is unspecified if the \ncollection changes while you are iterating over it. So you should be \ncareful in designing your own multithreaded code when accessing a \ncollection concurrently.\nusing java\u2019s iterator\n", "page": 372, "type": "text", "section": "Page 372"}
{"text": "you are here 4\u2003 \u2003 335\nthe iterator and composite patterns\nimport java.util.Iterator;\n  \npublic class DinerMenuIterator implements Iterator<MenuItem> {\n    MenuItem[] items;\n    int position = 0;\n \n    public DinerMenuIterator(MenuItem[] items) {\n        this.items = items;\n    }\n \n    public MenuItem next() {\n        //implementation here\n    }\n \n    public boolean hasNext() {\n        //implementation here\n    }\n  \n    public void remove() {\n        throw new UnsupportedOperationException\n                    (\"You shouldn't be trying to remove menu items.\");\n    }\n}\nCleaning things up with java.util.Iterator\npublic Iterator<MenuItem> createIterator() {\n    return menuItems.iterator();\n}\nLet\u2019s start with the PancakeHouseMenu. Changing it over to \njava.util.Iterator is going to be easy. We just delete the \nPancakeHouseMenuIterator class, add an import java.util.Iterator \nto the top of PancakeHouseMenu, and change one line of the \nPancakeHouseMenu:\nInstead of creating our own iterator \nnow, we just call the iterator() \nmethod on the menuItems ArrayList \n(more on this in a bit).\nAnd that\u2019s it, PancakeHouseMenu is done.\nNow we need to make the changes to allow DinerMenu to work with java.util.Iterator.\nFirst we import java.util.Iterator, the \ninterface we\u2019re going to implement.\nNone of our current \nimplementation changes...\nRemember, the remove() method is optional \nin the Iterator interface. Having our waitress \nremove menu items really doesn\u2019t make sense, \nso we\u2019ll just throw an exception if she tries.\n", "page": 373, "type": "text", "section": "Page 373"}
{"text": "336\u2003 \u2003 Chapter 9\nimport java.util.Iterator;\n \npublic class Waitress {\n    Menu pancakeHouseMenu;\n    Menu dinerMenu;\n \n    public Waitress(Menu pancakeHouseMenu, Menu dinerMenu) {\n        this.pancakeHouseMenu = pancakeHouseMenu;\n        this.dinerMenu = dinerMenu;\n    }\n \n    public void printMenu() {\n        Iterator<MenuItem> pancakeIterator = pancakeHouseMenu.createIterator();\n        Iterator<MenuItem> dinerIterator = dinerMenu.createIterator();\n        System.out.println(\"MENU\\n----\\nBREAKFAST\");\n        printMenu(pancakeIterator);\n        System.out.println(\"\\nLUNCH\");\n        printMenu(dinerIterator);\n    }\n \n    private void printMenu(Iterator iterator) {\n        while (iterator.hasNext()) {\n            MenuItem menuItem = iterator.next();\n            System.out.print(menuItem.getName() + \", \");\n            System.out.print(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n \n    // other methods here\n}\nWe are almost there...\nNow we just need to give the Menus a common interface and rework the \nWaitress a little. The Menu interface is quite simple: we might want to add a \nfew more methods to it eventually, like addItem(), but for now we\u2019ll let the chefs \ncontrol their menus by keeping that method out of the public interface:\npublic interface Menu {\n    public Iterator<MenuItem> createIterator();\n}\nThis is a simple interface that \njust lets clients get an iterator \nfor the items in the menu.\nNow we need to add an implements Menu to both the PancakeHouseMenu \nand the DinerMenu class definitions and update the Waitress class:\nNow the Waitress uses the java.util.Iterator as well.\nWe need to replace the \nconcrete Menu classes with \nthe Menu interface.\nNothing changes \nhere.\nreworking the waitress\n", "page": 374, "type": "text", "section": "Page 374"}
{"text": "you are here 4\u2003 \u2003 337\nthe iterator and composite patterns\nThe PancakeHouseMenu and DinerMenu classes implement an interface, \nMenu. This allows the Waitress to refer to each menu object using the interface \nrather than the concrete class. So, we\u2019re reducing the dependency between \nthe Waitress and the concrete classes by \u201cprogramming to an interface, not an \nimplementation.\u201d\nAlso, the new Menu interface has one method, createIterator(), that is \nimplemented by PancakeHouseMenu and DinerMenu. Each menu class \nassumes the responsibility of creating a concrete Iterator that is appropriate for \nits internal implementation of the menu items.\nprintMenu()\nWaitress\ncreateIterator()\nPancakeHouseMenu\nmenuItems\ncreateIterator()\nDinerMenu\nmenuItems\nhasNext()\nnext()\nremove()\n<<interface>>\nIterator\nHere\u2019s our new Menu interface. \nIt specifies the new method, \ncreateIterator().\nNow, Waitress \nonly needs to \nbe concerned \nwith Menus and \nIterators. \nWe\u2019ve decoupled Waitress from the \nimplementation of the menus, so now \nwe can use an Iterator to iterate \nover any list of menu items without \nhaving to know about how the list of \nitems is implemented.\nPancakeHouseMenu and DinerMenu now \nimplement the Menu interface, which \nmeans they need to implement the new \ncreateIterator() method.\nDinerMenu returns \na DinerMenuIterator \nfrom its \ncreateIterator() \nmethod because \nthat\u2019s the kind of \niterator required \nto iterate over its \nArray of menu items. \n \nEach concrete Menu is responsible \nfor creating the appropriate \nconcrete Iterator class. \nWhat does this get us?\nThis solves the problem \nof the Waitress \ndepending on the \nconcrete Menus.\ncreateIterator()\n<<interface>>\nMenu\ncreateIterator()\nhasNext()\nnext()\nremove()\nPancakeHouseMenuIterator\nhasNext()\nnext()\nremove()\nDinerMenuIterator\nWe\u2019re now using the \nArrayList iterator \nsupplied by java.util. We \ndon\u2019t need this anymore.\n", "page": 375, "type": "text", "section": "Page 375"}
{"text": "338\u2003 \u2003 Chapter 9\nIterator Pattern defined\nThe Iterator Pattern provides a way to \naccess the elements of an aggregate object \nsequentially without exposing its underlying \nrepresentation.\nYou\u2019ve already seen how to implement the Iterator \nPattern with your very own iterator. You\u2019ve also seen \nhow Java supports iterators in some of its collection-\noriented classes (ArrayList). Now it\u2019s time to check out \nthe official definition of the pattern:\nThis makes a lot of sense: the pattern gives you a way \nto step through the elements of an aggregate without \nhaving to know how things are represented under the \ncovers. You\u2019ve seen that with the two implementations \nof Menus. But the effect of using iterators in your design \nis just as important: once you have a uniform way of \naccessing the elements of all your aggregate objects, you \ncan write polymorphic code that works with any of these \naggregates\u2014just like the printMenu() method, which \ndoesn\u2019t care if the menu items are held in an Array or \nArrayList (or anything else that can create an Iterator), as \nlong as it can get hold of an Iterator.\nThe other important impact on your design is that the \nIterator Pattern takes the responsibility of traversing \nelements and gives that responsibility to the iterator \nobject, not the aggregate object. This not only keeps \nthe aggregate interface and implementation simpler, \nit removes the responsibility for iteration from the \naggregate and keeps the aggregate focused on the \nthings it should be focused on (managing a collection of \nobjects), not on iteration.\nThe Iterator Pattern \nallows traversal of the \nelements of an aggregate \nwithout exposing the \nunderlying implementation.\nIt also places the task \nof traversal on the \niterator object, not \non the aggregate, \nwhich simplifies the \naggregate interface and \nimplementation, and \nplaces the responsibility \nwhere it should be.\niterator pattern defined\n", "page": 376, "type": "text", "section": "Page 376"}
{"text": "you are here 4\u2003 \u2003 339\nthe iterator and composite patterns\nhasNext()\nnext()\nremove()\n<<interface>>\nIterator\nhasNext()\nnext()\nremove()\nConcreteIterator\ncreateIterator()\n<<interface>>\nAggregate\ncreateIterator()\nConcreteAggregate\nClient\nThe ConcreteAggregate \nhas a collection of \nobjects and implements \nthe method that \nreturns an Iterator for \nits collection.\nEach \nConcreteAggregate \nis responsible for \ninstantiating a \nConcreteIterator that \ncan iterate over its \ncollection of objects.\nThe Iterator interface \nprovides the interface \nthat all iterators \nmust implement, and \na set of methods \nfor traversing over \nelements of a collection. \nHere we\u2019re using the \n \n \n \n \n \n \n \n \n \n \n \n \n \n \njava.util.Iterator. If \nyou don\u2019t want to \nuse Java\u2019s Iterator \ninterface, you can \nalways create your own.\nHaving a common interface for your \naggregates is handy for your client; \nit decouples your client from the \nimplementation of your collection of objects.\nThe ConcreteIterator is \nresponsible for managing \nthe current position of \nthe iteration.\nThe class diagram for the Iterator Pattern looks very similar to another \npattern you\u2019ve studied; can you think of what it is? Hint: a subclass \ndecides which object to create.\nLet\u2019s check out the class diagram to put all the pieces in context...\nThe Iterator Pattern Structure\n", "page": 377, "type": "text", "section": "Page 377"}
{"text": "340\u2003 \u2003 Chapter 9\nthe single responsibility principle\nOO Glue\nHead First\nThe Single Responsibility Principle\nDesign Principle\nA class should have only one \nreason to change.\nWhat if we allowed our aggregates to implement their internal \ncollections and related operations AND the iteration methods? \nWell, we already know that would expand the number of \nmethods in the aggregate, but so what? Why is that so bad?\nWell, to see why, you first need to recognize that when we allow \na class to not only take care of its own business (managing \nsome kind of aggregate) but also take on more responsibilities \n(like iteration) then we\u2019ve given the class two reasons to change. \nTwo? Yup, two: it can change if the collection changes in some \nway, and it can change if the way we iterate changes. So once \nagain our friend CHANGE is at the center of another design \nprinciple:\nWe know we want to avoid change in our classes because \nmodifying code provides all sorts of opportunities for \nproblems to creep in. Having two ways to change increases \nthe probability the class will change in the future, and when \nit does, it\u2019s going to affect two aspects of your design.\nThe solution? The principle guides us to assign each \nresponsibility to one class, and only one class.\nThat\u2019s right, it\u2019s as easy as that, and then again it\u2019s not: \nseparating responsibility in design is one of the most \ndifficult things to do. Our brains are just too good at seeing \na set of behaviors and grouping them together even when \nthere are actually two or more responsibilities. The only \nway to succeed is to be diligent in examining your designs  \nand to watch out for signals that a class is changing in more \nthan one way as your system grows.\nEvery responsibility of \na class is an area of \npotential change. More \nthan one responsibility \nmeans more than one area \nof change.  \nThis principle guides us to \nkeep each class to a single \nresponsibility.\nCohesion is a term you\u2019ll \nhear used as a measure of \nhow closely a class or a \nmodule supports a single \npurpose or responsibility. \nWe say that a module or \nclass has high cohesion when it \nis designed around a set of related \nfunctions, and we say it has low \ncohesion when it is designed around a \nset of unrelated functions.\nCohesion is a more general concept \nthan the Single Responsibility Principle, \nbut the two are closely related.  \nClasses that adhere to the principle \ntend to have high cohesion and are \nmore maintainable than classes that \ntake on multiple responsibilities and \nhave low cohesion.\n", "page": 378, "type": "text", "section": "Page 378"}
{"text": "you are here 4\u2003 \u2003 341\nthe iterator and composite patterns\nhasNext()\nnext()\nremove()\nIterator\nhasNext()\nnext()\nremove()\naddCard()\nremoveCard()\nshuffle()\nDeckOfCards\nsetName()\nsetAddress()\nsetPhoneNumber()\nsave()\nload()\nPerson\ndial()\nhangUp()\ntalk()\nsendData()\nflash()\nPhone\ngetCount()\ngetState()\ngetLocation()\nGumballMachine\nadd()\nremove()\ncheckOut()\nsaveForLater()\nShoppingCart\nlogin()\nsignup()\nmove()\nfire()\nrest()\nGame\nHard hat area. watch out \nfor falling assumptions\ngetHighScore()\ngetName()\nPlayer\nlogin()\nsignup()\nmove()\nfire()\nrest()\ngetHighScore()\ngetName()\nGame\nmove()\nfire()\nrest()\nPlayerActions\nlogin()\nsignup()\nGameSession\nExamine these classes and determine which ones \nhave multiple responsibilities.\nDetermine if these classes have low or high cohesion.\n2\n", "page": 379, "type": "text", "section": "Page 379"}
{"text": "342\u2003 \u2003 Chapter 9\nno dumb questions\nQ: I\u2019ve seen other books show the \nIterator class diagram with the methods \nfirst(), next(), isDone(), and currentItem().  \nWhy are these methods different?\nA: Those are the \u201cclassic\u201d method names \nthat have been used. These names have \nchanged over time and we now have next(), \nhasNext(), and even remove() in \njava.util.Iterator.\n\nLet\u2019s look at the classic methods. The \nnext() and currentItem() have been merged \ninto one method in java.util. The isDone() \nmethod has become hasNext(), but we \nhave no method corresponding to first(). \nThat\u2019s because in Java we tend to just get \na new iterator whenever we need to start \nthe traversal over. Nevertheless, you can \nsee there is very little difference in these \ninterfaces. In fact, there is a whole range \nof behaviors you can give your iterators.  \nThe remove() method is an example of an \nextension in java.util.Iterator.\nQ: I\u2019ve heard about \u201cinternal\u201d iterators \nand \u201cexternal\u201d iterators. What are they?  \nWhich kind did we implement in the \nexample?\nA: We implemented an external iterator, \nwhich means that the client controls the \niteration by calling next() to get the next \nelement. An internal iterator is controlled \nby the iterator itself. In that case, because \nit\u2019s the iterator that\u2019s stepping through the \nelements, you have to tell the iterator what \nto do with those elements as it goes through \nthem. That means you need a way to pass \nan operation to an iterator. Internal iterators \nare less flexible than external iterators \nbecause the client doesn\u2019t have control of \nthe iteration. However, some might argue \nthat they are easier to use because you just\n\n\n hand them an operation and tell them to \niterate, and they do all the work for you.  \nQ: Could I implement an Iterator that \ncan go backward as well as forward?\nA: Definitely. In that case, you\u2019d probably \nwant to add two methods, one to get to the \nprevious element, and one to tell you when \nyou\u2019re at the beginning of the collection \nof elements. Java\u2019s Collection Framework \nprovides another type of iterator interface \ncalled ListIterator. This iterator adds \nprevious() and a few other methods to the \nstandard Iterator interface. It is supported \nby any Collection that implements the List \ninterface.\nQ: Who defines the ordering of the \niteration in a collection like Hashtable, \nwhich is inherently unordered?\nA: Iterators imply no ordering. The \nunderlying collections may be unordered as \nin a hash table or in a bag; they may even \ncontain duplicates. So ordering is related \nto both the properties of the underlying \ncollection and to the implementation. In \ngeneral, you should make no assumptions \nabout ordering unless the Collection \ndocumentation indicates otherwise.\nQ: You said we can write \n\u201cpolymorphic code\u201d using an iterator; can \nyou explain that more?\nA: When we write methods that take \nIterators as parameters, we are using \npolymorphic iteration. That means we are \ncreating code that can iterate over any \ncollection as long as it supports Iterator.  \nWe don\u2019t care about how the collection \nis implemented, we can still write code to \niterate over it.\nQ: If I\u2019m using Java, won\u2019t I always \nwant to use the java.util.Iterator \ninterface so I can use my own iterator \nimplementations with classes that are \nalready using the Java iterators?\nA: Probably. If you have a common \nIterator interface, it will certainly make it \neasier for you to mix and match your own \naggregates with Java aggregates like \nArrayList and Vector. But remember, if you \nneed to add functionality to your Iterator \ninterface for your aggregates, you can \nalways extend the Iterator interface.\nQ: I\u2019ve seen an Enumeration interface \nin Java; does that implement the Iterator \nPattern?\nA: We talked about this in the \nAdapter Pattern chapter (Chapter 7). \nRemember? The java.util.Enumeration \nis an older implementation of Iterator \nthat has since been replaced by java.util.\nIterator. Enumeration has two methods, \nhasMoreElements(), corresponding to \nhasNext(), and nextElement(), corresponding \nto next(). However, you\u2019ll probably want to \nuse Iterator over Enumeration as more Java \nclasses support it. If you need to convert \nfrom one to another, review Chapter 7 again \nwhere you implemented the adapter for \nEnumeration and Iterator.\nQ: Is using Java\u2019s enhanced for loop \nrelated to iterators?\nA: Good question! It is, and to tackle that \nquestion we need to understand another \ninterface\u2014that is, Java\u2019s Iterable interface. \nThis is a good time to do just that...\n", "page": 380, "type": "text", "section": "Page 380"}
{"text": "you are here 4\u2003 \u2003 343\nthe iterator and composite patterns\nMeet Java\u2019s Iterable interface\nYou\u2019re already up to speed on Java\u2019s Iterator interface, but there\u2019s \nanother interface you need to meet: Iterable. The Iterable interface \nis implemented by every Collection type in Java. Guess what? In your \ncode using the ArrayList, you\u2019ve already been using this interface. \nLet\u2019s take a look at the Iterable interface:\niterator()\n+ forEach()\n+ spliterator()\n<<interface>>\nIterable\nadd()\naddAll()\nclear()\ncontains()\ncontainsAll()\nequals()\nhashCode()\nisEmpty()\niterator()\nremove()\nremoveAll()\nretainAll()\nsize()\ntoArray()\n<<interface>>\nCollection\nnext()\nhasNext()\n+ remove()\n<<interface>>\nIterator\nThe Iterable interface \nincludes an iterator() \nmethod that returns \nan iterator that \nimplements the \nIterator interface.\nAll Collection classes, like \nArrayList, implement the \nCollection interface, which \ninherits from the Iterable \ninterface, so all Collection \nclasses are Iterables. \nYou already know about the \nIterator interface; that's the \nsame interface we\u2019ve been using \nwith our Diner and Pancake \nhouse iterators.\nHere\u2019s the Iterable \ninterface.\nIf a class implements Iterable, we know that the class implements an \niterator() method. That method returns an iterator that implements \nthe Iterator interface. This interface also includes a default forEach() \nmethod that can be used as another way to iterate through the \ncollection. In addition to all that, Java even provides some nice \nsyntactic sugar for iteration, with its enhanced for loop. Let\u2019s see how \nthat works.\nThe Iterable interface also \nincludes the spliterator() \nmethod, which provides even \nmore advanced ways to iterate \nthrough a collection. \n", "page": 381, "type": "text", "section": "Page 381"}
{"text": "344\u2003 \u2003 Chapter 9\nthe enhanced for loop\nJava\u2019s enhanced for loop\nLet\u2019s take an object whose class implements the Iterable interface...why not \nthe ArrayList collection we used for the Pancake House menu items:\nList<MenuItem> menuItems = new ArrayList<MenuItem>();\nWe can iterate over ArrayList the way we have been:\nIterator iterator = menu.iterator();\nwhile (iterator.hasNext()) {\n\t\nMenuItem menuItem = iterator.next();\n\t\nSystem.out.print(menuItem.getName() + \", \");\n\t\nSystem.out.print(menuItem.getPrice() + \" -- \");\n\t\nSystem.out.println(menuItem.getDescription());\n}\nOr, given we know ArrayList is an Iterable, we could use Java\u2019s enhanced \nfor shorthand:\nfor (MenuItem item: menu) {\n\t\nSystem.out.print(menuItem.getName() + \", \");\n\t\nSystem.out.print(menuItem.getPrice() + \" -- \");\n\t\nSystem.out.println(menuItem.getDescription());\n}\nHere we can dispense with \nthe explicit iterator as the \nhasNext() and next() methods.\nThis is the way we've been \ndoing iteration over our \ncollections, using an iterator \nalong with the hasNext() and \nnext() methods.\nLooks like a great way to use Iterators \nthat really results in simple code\u2014no more \nhasNext() or next() method calls. So, can we \nrework our Waitress code to use Iterable and \nthe enhanced for loop for both menus?\n", "page": 382, "type": "text", "section": "Page 382"}
{"text": "you are here 4\u2003 \u2003 345\nthe iterator and composite patterns\nWe have some bad news: the Diner may not have made the best decision using an \nArray as the basis for its menus. As it turns out, Arrays are not Java Collections \nand so they don\u2019t implement the Iterable interface. Given that, we can\u2019t as easily \nconsolidate our Waitress code into one method that takes an Iterable and use it \nwith both the Pancake House\u2019s breakfastItems and the Diner\u2019s lunchItems. If you \ntry to change the Waitress\u2019s printMenu() method to take an Iterable instead of an \nIterator, and use the for-each loop instead of the Iterator API, like this: \nNot so fast; Arrays are not Iterables\npublic void printMenu(Iterable<MenuItem> iterable) {\n\t\nfor (MenuItem menuItem : iterable) {\n\t\n\t\n// print menuItem\n\t\n}\n}\nyou\u2019ll get a compiler error when you try to pass the lunchItems array to printMenu():\nprintMenu(lunchItems);\nbecause, again, Arrays don\u2019t implement the Iterable interface.\nIf you keep both loops in the Waitress code, we\u2019re back to square one: the Waitress is \nonce again dependent on the aggregate types we\u2019re using to store the menus, and she \nhas duplicate code: one loop for the ArrayList, and one loop for the Array. \nSo what do we do? Well, there are many ways to solve this issue, but they are a bit of a \nsideshow, as would be refactoring our code. After all, this chapter is about the Iterator \nPattern, not Java\u2019s Iterable interface. But the good news is you know about Iterable, you \nknow its relationship to Java\u2019s Iterator interface and to the Iterator Pattern. So, let\u2019s keep \nmoving, as we\u2019ve got a great implementation even if we aren\u2019t taking advantage of a \nlittle syntactic sugar from Java\u2019s for loop.\nThis will only work for the \nArrayList we\u2019re using for the \nPancake House menu.\nCompile error! Arrays are not Iterables.\nbreakfastItems.forEach(item -> System.out.println(item));\nYou probably noticed the forEach() method in the Iterable menu. It\u2019s used as the basis for \nJava\u2019s enhanced for loop, but you can also use it directly with Iterables. Here\u2019s how it works:\nHere\u2019s an Iterable, in this case \nour Pancake House ArrayList \nof menu items.\nWe\u2019re calling forEach()...\n...and passing a lambda that takes a \nmenuItem, and just prints it. \nSo this code will print every \nitem in the collection.\n", "page": 383, "type": "text", "section": "Page 383"}
{"text": "346\u2003 \u2003 Chapter 9\na new acquisition\nWow, and we thought things \nwere already complicated.  \nNow what are we going to do? \nGood thing you\u2019re \nlearning about the Iterator \nPattern because I just heard that \nObjectville Mergers and Acquisitions \nhas done another deal...we\u2019re merging \nwith Objectville Caf\u00e9 and adopting their \ndinner menu.\nCome on, think positively. \nI\u2019m sure we can find a way to \nwork them into the Iterator \nPattern.\n", "page": 384, "type": "text", "section": "Page 384"}
{"text": "you are here 4\u2003 \u2003 347\nthe iterator and composite patterns\npublic class CafeMenu {\n    Map<String, MenuItem> menuItems = new HashMap<String, MenuItem>();\n  \n    public CafeMenu() {\n        addItem(\"Veggie Burger and Air Fries\",\n            \"Veggie burger on a whole wheat bun, lettuce, tomato, and fries\",\n            true, 3.99);\n        addItem(\"Soup of the day\",\n            \"A cup of the soup of the day, with a side salad\",\n            false, 3.69);\n        addItem(\"Burrito\",\n            \"A large burrito, with whole pinto beans, salsa, guacamole\",\n            true, 4.29);\n    }\n \n    public void addItem(String name, String description, \n                         boolean vegetarian, double price) \n    {\n        MenuItem menuItem = new MenuItem(name, description, vegetarian, price);\n        menuItems.put(name, menuItem);\n    }\n \n    public Map<String, MenuItem> getMenuItems() {\n        return menuItems;\n    }\n}\nHere\u2019s the caf\u00e9 menu. It doesn\u2019t look like too much trouble to integrate the \nCafeMenu class into our framework...let\u2019s check it out.\nCafeMenu doesn\u2019t implement our new Menu \ninterface, but this is easily fixed.\nThe caf\u00e9 is storing their menu items in a HashMap.  \nDoes that support Iterator? We\u2019ll see shortly...\nLike the other Menus, the menu items \nare initialized in the constructor.\nHere\u2019s where we create a new MenuItem \nand add it to the menuItems HashMap.\nWe\u2019re not going to need this anymore.\n1. \n2. \n3. \nThe key is the item name.\nThe value is the menuItem object.\nBefore looking at the next page, quickly jot down the three \nthings we have to do to this code to fit it into our framework:\nTaking a look at the Caf\u00e9 Menu\n", "page": 385, "type": "text", "section": "Page 385"}
{"text": "348\u2003 \u2003 Chapter 9\nAre we violating \nthe Principle of \nLeast Knowledge \nhere? What can \nwe do about it?\nreworking the menu code\npublic class CafeMenu implements Menu {\n    Map<String, MenuItem> menuItems = new HashMap<String, MenuItem>();\n  \n    public CafeMenu() {\n        // constructor code here\n    }\n \n    public void addItem(String name, String description, \n                         boolean vegetarian, double price) \n    {\n        MenuItem menuItem = new MenuItem(name, description, vegetarian, price);\n        menuItems.put(name, menuItem);\n    }\n \n    public Map<String, MenuItem> getMenuItems() {\n        return menuItems;\n    }\n  \n    public Iterator<MenuItem> createIterator() {\n        return menuItems.values().iterator();\n    }\n}\nCode Up Close\nLet\u2019s rework the CafeMenu code. We\u2019re going to take care of implementing the \nMenu interface, and we also need to deal with creating an Iterator for the values \nstored in the HashMap. Things are a little different than when we did the same \nfor the ArrayList; check it out...\nCafeMenu implements the Menu interface, so the \nWaitress can use it just like the other two Menus.\nJust like before, we can get rid of getItems() \nso we don\u2019t expose the implementation of \nmenuItems to the Waitress.\nAnd here\u2019s where we implement the \ncreateIterator() method. Notice that \nwe\u2019re not getting an Iterator for the \nwhole HashMap, just for the values.\n    public Iterator<MenuItem> createIterator() {\n        return menuItems.values().iterator();\n    }\nFirst we get the values of the \nHashMap, which is just a collection of \nall the objects in the HashMap.\nLuckily that collection supports the \niterator() method, which returns a \nobject of type java.util.Iterator.\nHashMap is a little more complex than ArrayList because it supports both \nkeys and values, but we can still get an Iterator for the values (which are \nthe MenuItems).\nWe\u2019re using HashMap because it\u2019s a common \ndata structure for storing values.\nReworking the Caf\u00e9 Menu code\n", "page": 386, "type": "text", "section": "Page 386"}
{"text": "you are here 4\u2003 \u2003 349\nthe iterator and composite patterns\npublic class Waitress {\n    Menu pancakeHouseMenu;\n    Menu dinerMenu;\n    Menu cafeMenu;\n \n    public Waitress(Menu pancakeHouseMenu, Menu dinerMenu, Menu cafeMenu) {\n        this.pancakeHouseMenu = pancakeHouseMenu;\n        this.dinerMenu = dinerMenu;\n        this.cafeMenu = cafeMenu;\n    }\n \n    public void printMenu() {\n        Iterator<MenuItem> pancakeIterator = pancakeHouseMenu.createIterator();\n        Iterator<MenuItem> dinerIterator = dinerMenu.createIterator();\n        Iterator<MenuItem> cafeIterator = cafeMenu.createIterator();\n        System.out.println(\"MENU\\n----\\nBREAKFAST\");\n        printMenu(pancakeIterator);\n        System.out.println(\"\\nLUNCH\");\n        printMenu(dinerIterator);\n        System.out.println(\"\\nDINNER\");\n        printMenu(cafeIterator);\n    }\n \n    private void printMenu(Iterator iterator) {\n        while (iterator.hasNext()) {\n            MenuItem menuItem = iterator.next();\n            System.out.print(menuItem.getName() + \", \");\n            System.out.print(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n}\nNow it\u2019s time to modify the Waitress to support our new Menu. Now that the \nWaitress expects Iterators, it should be straightforward:\nThe caf\u00e9 menu is passed into the Waitress \nin the constructor with the other menus, \nand we stash it in an instance variable.\nWe\u2019re using the caf\u00e9\u2019s \nmenu for our dinner \nmenu. All we have to do \nto print it is create the \niterator, and pass it to \nprintMenu(). That\u2019s it!\nNothing changes here.\nAdding the Cafe Menu to the Waitress\n\u2018\n", "page": 387, "type": "text", "section": "Page 387"}
{"text": "350\u2003 \u2003 Chapter 9\ntesting the new menu\npublic class MenuTestDrive {\n    public static void main(String args[]) {\n        PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();\n        DinerMenu dinerMenu = new DinerMenu();\n        CafeMenu cafeMenu = new CafeMenu();\n \n        Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu, cafeMenu);\n \n        waitress.printMenu();\n}\nFile  Edit   Window  Help   \n% java DinerMenuTestDrive\nMENU\n----\nBREAKFAST\nK&B's Pancake Breakfast, 2.99 -- Pancakes with scrambled eggs and toast\nRegular Pancake Breakfast, 2.99 -- Pancakes with fried eggs, sausage\nBlueberry Pancakes, 3.49 -- Pancakes made with fresh blueberries\nWaffles, 3.59 -- Waffles with your choice of blueberries or strawberries\nLUNCH\nVegetarian BLT, 2.99 -- (Fakin') Bacon with lettuce & tomato on whole wheat\nBLT, 2.99 -- Bacon with lettuce & tomato on whole wheat\nSoup of the day, 3.29 -- Soup of the day, with a side of potato salad\nHot Dog, 3.05 -- A hot dog, with sauerkraut, relish, onions, topped with cheese\nSteamed Veggies and Brown Rice, 3.99 -- Steamed vegetables over brown rice\nPasta, 3.89 -- Spaghetti with marinara sauce, and a slice of sourdough bread\nDINNER\nSoup of the day, 3.69 -- A cup of the soup of the day, with a side salad\nBurrito, 4.29 -- A large burrito, with whole pinto beans, salsa, guacamole\nVeggie Burger and Air Fries, 3.99 -- Veggie burger on a whole wheat bun,\n lettuce, tomato, and fries\n%\nFirst we iterate \nthrough the \npancake menu...\n...and then \nthe diner \nmenu...\n...and finally \nthe new caf\u00e9 \nmenu, all with \nthe same \niteration code.\nBreakfast, lunch, AND dinner\nLet\u2019s update our test drive to make sure this all works.\nCreate a CafeMenu...\n...and pass it to the waitress.\nNow, when we print we should see all three menus.\nHere\u2019s the test run; check out the new dinner menu from the Caf\u00e9!\n", "page": 388, "type": "text", "section": "Page 388"}
{"text": "you are here 4\u2003 \u2003 351\nthe iterator and composite patterns\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArrayList\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArray\n...and we didn\u2019t want her to \nknow about how the menu \nitems are implemented.\nArrayList has a \nbuilt-in iterator...\n...Array \ndoesn\u2019t have \na built-in \nIterator so \nwe built our \nown.\n \n \n \n \n \n \n \n \nI\nt\ne\nr\nat\no\nr\nWe wanted to give the \nWaitress an easy way to \niterate over menu items...\nOur menu items had two \ndifferent implementations \nand two different \ninterfaces for iterating.\n \n \n \n \n \n \n \n \nI\nt\ne\nr\nat\no\nr\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArrayList\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArray\nSo we gave the Waitress an \nIterator for each kind of \ngroup of objects she needed \nto iterate over...\n...one for \nArrayList...\n...and one for Array.\nnext()\nnext()\nNow she doesn\u2019t have to worry about which \nimplementation we used; she always uses the same \ninterface\u2009\u2014\u2009Iterator\u2009\u2014\u2009to iterate over menu items.  \nShe\u2019s been decoupled from the implementation.\nWhat did we do?\nWe decoupled the Waitress....\n", "page": 389, "type": "text", "section": "Page 389"}
{"text": "352\u2003 \u2003 Chapter 9\na more extensible waitress\n \n \n \n \n \n \n \n \n \nI\nt\ne\nr\na\nt\no\nr\nnext()\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nVector\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\nHashMap\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\nMost have different \ninterfaces.\nBy giving her an Iterator, \nwe have decoupled her \nfrom the implementation \nof the menu items, so we \ncan easily add new Menus \nif we want.\nWe easily added another \nimplementation of menu \nitems, and since we \nprovided an Iterator, \nthe Waitress knew what \nto do.\nWhich is better for her, \nbecause now she can use the \nsame code to iterate over \nany group of objects. And \nit\u2019s better for us because \nthe implementation details \naren\u2019t exposed.\n...and more!\nMaking an Iterator \nfor the HashMap \nvalues was easy; \nwhen you call \nvalues.iterator() \nyou get an Iterator.\nLinkedList\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\nBut almost all of \nthem support a \nway to obtain an \nIterator.\nAnd if they don\u2019t support \nIterator, that\u2019s okay, because now \nyou know how to build your own.\n...and we made the Waitress more extensible\nBut there\u2019s more!\nJava gives you a lot of \u201cCollection\u201d \nclasses that allow you to store \nand retrieve groups of objects; \nfor example, Vector and \nLinkedList.\n", "page": 390, "type": "text", "section": "Page 390"}
{"text": "you are here 4\u2003 \u2003 353\nthe iterator and composite patterns\nIterators and Collections\nWe\u2019ve been using a couple of classes that are part of the Java Collections Framework. \nThis \u201cframework\u201d is just a set of classes and interfaces, including ArrayList, which \nwe\u2019ve been using, and many others like Vector, LinkedList, Stack, and PriorityQueue. \n \nEach of these classes implements the java.util.Collection interface, which contains a \nbunch of useful methods for manipulating groups of objects.\nLet\u2019s take a quick look at the interface:\nadd()\naddAll()\nclear()\ncontains()\ncontainsAll()\nequals()\nhashCode()\nisEmpty()\niterator()\nremove()\nremoveAll()\nretainAll()\nsize()\ntoArray()\n<<interface>>\nCollection\nAs you can see, there\u2019s all kinds \nof good stuff here. You can add \nand remove elements from your \ncollection without even knowing \nhow it\u2019s implemented.\nHere\u2019s our old friend, the \niterator() method. With this \nmethod, you can get an Iterator \nfor any class that implements \nthe Collection interface.\nOther handy methods include \nsize(), to get the number of \nelements, and toArray() to turn \nyour collection into an array.\n\t\n       HashMap is one of \na few classes that \nindirectly \nsupports Iterator.\nAs you saw when we \nimplemented the CafeMenu, you \ncould get an Iterator from it, but \nonly by first retrieving its Collection \ncalled values. If you think about it, \nthis makes sense: the HashMap \nholds two sets of objects: keys and \nvalues. If we want to iterate over \nits values, we first need to retrieve \nthem from the HashMap, and then \nobtain the iterator.\nThe nice thing about Collections and \nIterators is that each Collection object \nknows how to create its own Iterator. Calling \niterator() on an ArrayList returns a concrete \nIterator made for ArrayLists, but you never need \nto see or worry about the concrete class it uses; \nyou just use the Iterator interface.\niterator()\n+ forEach()\n+ spliterator()\n<<interface>>\nIterable\nDon\u2019t forget the \nCollection interface \nimplements the \nIterable interface.\n", "page": 391, "type": "text", "section": "Page 391"}
{"text": "354\u2003 \u2003 Chapter 9\ncode magnets\nThe Chefs have decided that they want to be able to alternate their lunch menu items; in other words, \nthey will offer some items on Monday, Wednesday, Friday, and Sunday, and other items on Tuesday, \nThursday, and Saturday. Someone already wrote the code for a new \u201cAlternating\u201d DinerMenu Iterator so \nthat it alternates the menu items, but she scrambled it up and put it on the fridge in the Diner as a joke. \nCan you put it back together?  Some of the curly braces fell on the floor and they were too small to pick \nup, so feel free to add as many of those as you need.\nCode Magnets\n}\n}\n}\nMenuItem menuItem = items[position];\nposition = position + 2;\nreturn menuItem;\nimport java.util.Iterator;\nimport java.util.Calendar;\npublic Object next() {\npublic AlternatingDinerMenuIterator(MenuItem[] items)\nthis.items = items;\nposition = Calendar.DAY_OF_WEEK % 2;\npublic void remove() {\nimplements Iterator<MenuItem>\nMenuItem[] items;\nint position;\npublic class AlternatingDinerMenuIterator\npublic boolean hasNext() {\nthrow new UnsupportedOperationException(\n    \"Alternating Diner Menu Iterator does not support remove()\");\nif (position >= items.length || items[position] == null) {\n    return false;\n} else {\n    return true;\n}\n", "page": 392, "type": "text", "section": "Page 392"}
{"text": "you are here 4\u2003 \u2003 355\nthe iterator and composite patterns\n    public void printMenu() {\n        Iterator<MenuItem> pancakeIterator = pancakeHouseMenu.createIterator();\n        Iterator<MenuItem> dinerIterator = dinerMenu.createIterator();\n        Iterator<MenuItem> cafeIterator = cafeMenu.createIterator();\n        System.out.println(\"MENU\\n----\\nBREAKFAST\");\n        printMenu(pancakeIterator);\n        System.out.println(\"\\nLUNCH\");\n        printMenu(dinerIterator);\n        System.out.println(\"\\nDINNER\");\n        printMenu(cafeIterator);\n    }\nIs the Waitress ready for prime time?\nThe Waitress has come a long way, but you\u2019ve gotta admit \nthose three calls to printMenu() are looking kind of ugly.\nLet\u2019s be real\u2014every time we add a new menu we\u2019re going to \nhave to open up the Waitress implementation and add more \ncode. Can you say \u201cviolating the Open Closed Principle\u201d?\nIt\u2019s not the Waitress\u2019s fault. We\u2019ve done a great job of decoupling the menu implementation \nand extracting the iteration into an iterator. But we still are handling the menus with \nseparate, independent objects\u2014we need a way to manage them together.\nThree calls to \nprintMenu.\nThree createIterator() calls.\nEvery time we add or remove a menu\u200a\n, we\u2019re going \nto have to open this code up for changes.\nThe Waitress still needs to make three calls to printMenu(), one for each menu. Can you \nthink of a way to combine the menus so that only one call needs to be made? Or perhaps \nso that one Iterator is passed to the Waitress to iterate over all the menus?\n", "page": 393, "type": "text", "section": "Page 393"}
{"text": "356\u2003 \u2003 Chapter 9\npublic class Waitress {\n    List<Menu> menus;\n  \n    public Waitress(List<Menu> menus) {\n\t\nthis.menus = menus;\n    }\n   \n    public void printMenu() {\n\t\nIterator<Menu> menuIterator = menus.iterator();\n\t\nwhile(menuIterator.hasNext()) {\n\t\n\t\nMenu menu = menuIterator.next();\n\t\n\t\nprintMenu(menu.createIterator());\n\t\n}\n    }\n   \n    void printMenu(Iterator<MenuItem> iterator) {\n\t\nwhile (iterator.hasNext()) {\n\t\n\t\nMenuItem menuItem = iterator.next();\n\t\n\t\nSystem.out.print(menuItem.getName() + \", \");\n\t\n\t\nSystem.out.print(menuItem.getPrice() + \" -- \");\n\t\n\t\nSystem.out.println(menuItem.getDescription());\n\t\n}\n    }\n} \na new design\nSounds like the chef is on to something. Let\u2019s give it a try:\nNow we just take a list \nof menus, instead of \neach menu separately.\nAnd we iterate through the \nmenus, passing each menu\u2019s \niterator to the overloaded \nprintMenu() method.\nNo code \nchanges here.\nThis looks pretty good, although we\u2019ve lost the names of the menus, \nbut we could add the names to each menu.\nThis isn\u2019t so bad. All \nwe need to do is package the \nmenus up into an ArrayList and then \niterate through each Menu. The code in \nthe Waitress is going to be simple and it \nwill handle any number of menus.\n", "page": 394, "type": "text", "section": "Page 394"}
{"text": "you are here 4\u2003 \u2003 357\nthe iterator and composite patterns\nP\na\nn\nc\na\nk\ne\nH\nou\ns\ne\nM\ne\nn\nu\n \n \nD\ni\nn\ne\nr\nM\ne\nn\nu\n \n \n \nC\na\nf\ne\nM\ne\nn\nu\n1\n2\n3\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nPancake Menu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nDiner Menu\nAll Menus\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nDessert Menu\nHere\u2019s our ArrayList \nthat holds the menus \nof each restaurant.\nWe need for Diner Menu to hold a submenu, \nbut we can\u2019t actually assign a menu to a \nMenuItem array because the types are \ndifferent, so this isn\u2019t going to work.\nArray\nArrayList\nHashMap\nJust when we thought it was safe...\nNow they want to add a dessert submenu.\nOkay, now what? Now we have to support not only multiple \nmenus, but menus within menus.  \nIt would be nice if we could just make the dessert menu an \nelement of the DinerMenu collection, but that won\u2019t work as it is \nnow implemented.\nWhat we want (something like this):\nBut this won\u2019t \nwork!\nWe can\u2019t assign a dessert menu to a \nMenuItem array.\nTime for a change!\nI just heard the Diner is \ngoing to be creating a dessert \nmenu that is going to be an insert \ninto their regular menu. \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\nCaf\u00e9 Menu\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n", "page": 395, "type": "text", "section": "Page 395"}
{"text": "358\u2003 \u2003 Chapter 9\ntime to refactor\nWhat do we need?\nThe time has come to make an executive decision to \nrework the chef\u2019s implementation into something that \nis general enough to work over all the menus (and now \nsubmenus). That\u2019s right, we\u2019re going to tell the chefs that \nthe time has come for us to reimplement their menus. \nThe reality is that we\u2019ve reached a level of complexity \nsuch that if we don\u2019t rework the design now, we\u2019re never \ngoing to have a design that can accommodate further \nacquisitions or submenus.\nSo, what is it we really need out of our new design?\n\u2022\u2003\nWe need some kind of a tree-shaped structure that \nwill accommodate menus, submenus, and menu \nitems.\n\u2022\u2003\nWe need to make sure we maintain a way to traverse \nthe items in each menu that is at least as convenient \nas what we\u2019re doing now with iterators.\n\u2022\u2003\nWe may need to traverse the items in a more flexible \nmanner. For instance, we might need to iterate over \nonly the Diner\u2019s dessert menu, or we might need to \niterate over the Diner\u2019s entire menu, including the \ndessert submenu.\nThere comes a time when we \nmust refactor our code in order \nfor it to grow. To not do so would \nleave us with rigid, inflexible code \nthat has no hope of ever sprouting \nnew life.\n", "page": 396, "type": "text", "section": "Page 396"}
{"text": "you are here 4\u2003 \u2003 359\nthe iterator and composite patterns\n \n \n \n \nA\nl\nl\n \nM\ne\nnu\ns\n \n \n \nD\ne\ns\ns\ne\nr\nt \nM\ne\nn\nu\nP\na\nn\nc\na\nk\ne\n \nHo\nu\ns\ne\n \nM\nenu\n \n \n \n \nD\ni\nn\ne\nr\n \nMe\nn\nu\n \n \n \n \n \nC\na\nf\n\u00e9\n \nMe\nn\nu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\nWe need to \naccommodate \nMenus...\n...and menu items.\n...and submenus...\nBecause we need to represent \nmenus, nested submenus, and menu \nitems, we can naturally fit them \nin a tree-like structure.\n \n \n \n \nA\nl\nl\n \nM\ne\nnu\ns\n \n \n \nD\ne\ns\ns\ne\nr\nt \nM\ne\nn\nu\nP\na\nn\nc\na\nk\ne\n \nHo\nu\ns\ne\n \nM\nenu\n \n \n \n \nD\ni\nn\ne\nr\n \nMe\nn\nu\n \n \n \n \n \nC\na\nf\ne\n \nMe\nn\nu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nD\ne\ns\ns\ne\nr\nt \nM\ne\nn\nu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\nWe still need to be able \nto traverse all the items \nin the tree.\nWe also need to be able to \ntraverse more flexibly, for \ninstance over one menu.\nHow would you handle this new wrinkle to our design \nrequirements? Think about it before turning the page.\n", "page": 397, "type": "text", "section": "Page 397"}
{"text": "360\u2003 \u2003 Chapter 9\ncomposite pattern defined\nThe Composite Pattern defined\nThat\u2019s right; we\u2019re going to introduce another pattern \nto solve this problem. We didn\u2019t give up on Iterator\u2014it \nwill still be part of our solution\u2014however, the problem \nof managing menus has taken on a new dimension that \nIterator doesn\u2019t solve. So, we\u2019re going to step back and \nsolve it with the Composite Pattern.\nWe\u2019re not going to beat around the bush on this \npattern; we\u2019re going to go ahead and roll out the official \ndefinition now:\nThe Composite Pattern allows you to \ncompose objects into tree structures to \nrepresent part-whole hierarchies. Composite \nlets clients treat individual objects and \ncompositions of objects uniformly.\nLet\u2019s think about this in terms of our menus: this pattern \ngives us a way to create a tree structure that can handle \na nested group of menus and menu items in the same \nstructure. By putting menus and items in the same \nstructure we create a part-whole hierarchy\u2014that is, a \ntree of objects that is made of parts (menus and menu \nitems) but that can be treated as a whole, like one big \n\u00fcber menu.\nOnce we have our \u00fcber menu, we can use this \npattern to treat \u201cindividual objects and compositions \nuniformly.\u201d What does that mean? It means if we have \na tree structure of menus, submenus, and perhaps \nsubsubmenus along with menu items, then any menu \nis a \u201ccomposition\u201d because it can contain both other \nmenus and menu items. The individual objects are just \nthe menu items\u2014they don\u2019t hold other objects. As you\u2019ll \nsee, using a design that follows the Composite Pattern \nis going to allow us to write some simple code that can \napply the same operation (like printing!) over the entire \nmenu structure.\nHere\u2019s a tree structure.\n \n \n \n \n \n \n \nN\no\nd\ne\n \n \n \n \n \n \n \n \n \n \n \nL\ne\naf\n \n \n \n \n \n \n \n \n \nL\ne\na\nf\n \n \n \n \n \n \n \n \n \n \nL\ne\naf\nElements without children \nare called leaves.\nElements with \nchild elements \nare called nodes.\n \n \n \n \n \n \n \n \nM\ne\nnu\n \n \n \n \n \n \n \n \n \nM\ne\nnu\nI\nt\ne\nm\n \n \n \n \n \nM\ne\nn\nu\nI\nte\nm\n \n \n \n \n \n \nM\ne\nn\nu\nI\nt\ne\nm\nMenus are nodes and \nMenuItems are leaves.\nWe can represent \nour Menu and \nMenuItems in a \ntree structure.\n", "page": 398, "type": "text", "section": "Page 398"}
{"text": "you are here 4\u2003 \u2003 361\nthe iterator and composite patterns\nThe Composite Pattern \nallows us to build \nstructures of objects in \nthe form of trees that \ncontain both compositions \nof objects and individual \nobjects as nodes.\nUsing a composite \nstructure, we can apply \nthe same operations over \nboth composites and \nindividual objects.  In \nother words, in most \ncases we can ignore the \ndifferences between \ncompositions of objects \nand individual objects.\n \n \n \n \nA\nl\nl\n \nM\ne\nnu\ns\n \n \n \nD\ne\ns\ns\ne\nr\nt \nM\ne\nn\nu\nP\na\nn\nc\na\nk\ne\n \nHo\nu\ns\ne\n \nM\nenu\n \n \n \n \nD\ni\nn\ne\nr\n \nMe\nn\nu\n \n \n \n \n \nC\na\nf\ne\n \nMe\nn\nu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\nMenus\nSubmenu\nMenuItems\nWe can create arbitrarily \ncomplex trees.\n \n \n \n \nA\nl\nl\n \nM\ne\nnu\ns\n \n \n \nD\ne\ns\ns\ne\nr\nt \nM\ne\nn\nu\nP\na\nn\nc\na\nk\ne\n \nHo\nu\ns\ne\n \nM\nenu\n \n \n \n \nD\ni\nn\ne\nr\n \nMe\nn\nu\n \n \n \n \n \nC\na\nf\ne\n \nMe\nn\nu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\nMenus\nSubmenu\nMenuItems\nAnd treat them as a whole...\n....or as parts.\n \n \n \n \nA\nl\nl\n \nM\ne\nnu\ns\n \n \n \nD\ne\ns\ns\ne\nr\nt \nM\ne\nn\nu\nP\na\nn\nc\na\nk\ne\n \nHo\nu\ns\ne\n \nM\nenu\n \n \n \n \nD\ni\nn\ne\nr\n \nMe\nn\nu\n \n \n \n \n \nC\na\nf\ne\n \nMe\nn\nu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\nMenus\nSubmenu\nMenuItems\nOperations can be \napplied to the whole...\n...or the parts.\nprint()\nprint()\n", "page": 399, "type": "text", "section": "Page 399"}
{"text": "362\u2003 \u2003 Chapter 9\ncomposite pattern class diagram\noperation()\nadd(Component)\nremove(Component)\ngetChild(int)\nComponent\nadd(Component)\nremove(Component)\ngetChild(int)\noperation()\nComposite\nClient\noperation()\nLeaf\nThe Component defines an \ninterface for all objects in the \ncomposition: both the composite \nand leaves.\nThe Component may implement \na default behavior for add(), \nremove(), getChild() and its \noperations.\nA leaf has no \nchildren.\nA leaf defines the behavior for \nthe elements in the composition.  \nIt does this by implementing the \noperations the Composite supports.\nThe Composite\u2019s role is to \ndefine behavior of the \ncomponents having children and \nto store child components.\nThe Composite also \nimplements the Leaf-\nrelated operations.  \nNote that some of \nthese may not make \nsense on a Composite, \nso in that case an \nexception might be \ngenerated.\nThe Client uses the \nComponent interface to \nmanipulate the objects in \nthe composition.\nNote that the leaf also \ninherits methods like add(), \nremove(), and getChild(), \nwhich don\u2019t necessarily make a \nlot of sense for a leaf node. \nWe\u2019re going to come back to \nthis issue.\nQ: Component, Composite, Trees? I\u2019m confused.\nA: A composite contains components. Components come in \ntwo flavors: composites and leaf elements. Sound recursive? It is. \nA composite holds a set of children; those children may be other \ncomposites or leaf elements.  \n\nWhen you organize data in this way you end up with a tree structure \n(actually an upside-down tree structure) with a composite at the root \nand branches of composites growing up to leaves.\nQ: How does this relate to iterators?\nA: Remember, we\u2019re taking a new approach. We\u2019re going to \nre-implement the menus with a new solution: the Composite Pattern.  \nSo don\u2019t look for some magical transformation from an iterator to a \ncomposite. That said, the two work very nicely together. You\u2019ll soon \nsee that we can use iterators in a couple of ways in the composite \nimplementation. \n", "page": 400, "type": "text", "section": "Page 400"}
{"text": "you are here 4\u2003 \u2003 363\nthe iterator and composite patterns\ngetName()\ngetDescription()\ngetPrice()\nisVegetarian()\nprint()\nadd(MenuComponent)\nremove(MenuComponent)\ngetChild(int)\nMenuComponent\ngetName()\ngetDescription()\ngetPrice()\nisVegetarian()\nprint()\nMenuItem\nWaitress\ngetName()\ngetDescription()\nprint()\nadd(MenuComponent)\nremove(MenuComponent)\ngetChild(int)\nMenu\nmenuComponents\nDesigning Menus with Composite\nSo, how do we apply the Composite Pattern to our menus? To start with, we need to create a \ncomponent interface; this acts as the common interface for both menus and menu items and allows \nus to treat them uniformly. In other words, we can call the same method on menus or menu items.\nNow, it may not make sense to call some of the methods on a menu item or a menu, but we can deal \nwith that, and we will in just a moment. But for now, let\u2019s take a look at a sketch of how the menus \nare going to fit into a Composite Pattern structure:\nMenuComponent represents the interface \nfor both MenuItem and Menu. We\u2019ve used an \nabstract class here because we want to provide \ndefault implementations for these methods. \nWe have some of the same \nmethods you\u2019ll remember \nfrom our previous versions \nof MenuItem and Menu, \nand we\u2019ve added print(), \nadd(), remove() and \ngetChild(). We\u2019ll describe \nthese soon, when we \nimplement our new Menu \nand MenuItem classes.\nMenuItem overrides the methods that make \nsense, and uses the default implementations \nin MenuComponent for those that don\u2019t \nmake sense (like add()\u2009\u2014\u2009it doesn\u2019t make \nsense to add a component  to a MenuItem... \nwe can only add components to a Menu).\nMenu also overrides the methods that \nmake sense, like a way to add and remove \nmenu items (or other menus!) from its \nmenuComponents. In addition, we\u2019ll use the \ngetName() and getDescription() methods to \nreturn the name and description of the menu.\nBoth MenuItem and \nMenu override print(). \nThe Waitress is going to use the \nMenuComponent interface to access \nboth Menus and MenuItems.  \nHere are the methods for \nmanipulating the components. \n \nThe components are \nMenuItem and Menu.\n", "page": 401, "type": "text", "section": "Page 401"}
{"text": "364\u2003 \u2003 Chapter 9\nimplementing composite menus\npublic abstract class MenuComponent {\n   \n    public void add(MenuComponent menuComponent) {\n        throw new UnsupportedOperationException();\n    }\n    public void remove(MenuComponent menuComponent) {\n        throw new UnsupportedOperationException();\n    }\n    public MenuComponent getChild(int i) {\n        throw new UnsupportedOperationException();\n    }\n  \n    public String getName() {\n        throw new UnsupportedOperationException();\n    }\n    public String getDescription() {\n        throw new UnsupportedOperationException();\n    }\n    public double getPrice() {\n        throw new UnsupportedOperationException();\n    }\n    public boolean isVegetarian() {\n        throw new UnsupportedOperationException();\n    }\n  \n    public void print() {\n        throw new UnsupportedOperationException();\n    }\n}\nImplementing MenuComponent\nOkay, we\u2019re going to start with the MenuComponent abstract \nclass; remember, the role of the menu component is to provide an \ninterface for the leaves and the composite nodes. Now you might \nbe asking, \u201cIsn\u2019t MenuComponent playing two roles?\u201d It might \nwell be and we\u2019ll come back to that point. However, for now we\u2019re \ngoing to provide a default implementation of the methods so that \nif the MenuItem (the leaf) or the Menu (the composite) doesn\u2019t \nwant to implement some of the methods (like getChild() for a leaf \nnode), it can fall back on some basic behavior:\nMenuComponent \nprovides default \nimplementations for \nevery method.\nWe\u2019ve grouped together the \n\u201ccomposite\u201d methods\u2009\u2014\u2009that is, \nmethods to add, remove, and \nget MenuComponents.\nHere are the \u201coperation\u201d methods; \nthese are used by the MenuItems.  \nIt turns out we can also use a \ncouple of them in Menu too, as \nyou\u2019ll see in a couple of pages when \nwe show the Menu code.\nprint() is an \u201coperation\u201d method \nthat both our Menus and \nMenuItems will implement, but we \nprovide a default operation here.\nBecause some of these methods \nonly make sense for MenuItems, and \nsome only make sense for Menus, \nthe default implementation is \nUnsupportedOperationException. That \nway, if MenuItem or Menu doesn\u2019t \nsupport an operation, it doesn\u2019t have \nto do anything; it can just inherit the \ndefault implementation.\nAll components must implement \nthe MenuComponent interface; \nhowever, because leaves and \nnodes have different roles we \ncan\u2019t always define a default \nimplementation for each \nmethod that makes sense. \nSometimes the best you can do \nis throw a runtime exception.\n", "page": 402, "type": "text", "section": "Page 402"}
{"text": "you are here 4\u2003 \u2003 365\nthe iterator and composite patterns\npublic class MenuItem extends MenuComponent {\n    String name;\n    String description;\n    boolean vegetarian;\n    double price;\n    \n    public MenuItem(String name, \n                    String description, \n                    boolean vegetarian, \n                    double price) \n    { \n        this.name = name;\n        this.description = description;\n        this.vegetarian = vegetarian;\n        this.price = price;\n    }\n  \n    public String getName() {\n        return name;\n    }\n  \n    public String getDescription() {\n        return description;\n    }\n  \n    public double getPrice() {\n        return price;\n    }\n  \n    public boolean isVegetarian() {\n        return vegetarian;\n    }\n  \n    public void print() {\n        System.out.print(\"  \" + getName());\n        if (isVegetarian()) {\n            System.out.print(\"(v)\");\n        }\n        System.out.println(\", \" + getPrice());\n        System.out.println(\"     -- \" + getDescription());\n    }\n}\nImplementing the MenuItem\nOkay, let\u2019s give the MenuItem class a shot. Remember, \nthis is the leaf class in the Composite diagram, and it \nimplements the behavior of the elements of the composite.\nFirst we need to extend \nthe MenuComponent \ninterface.\nThe constructor just takes the \nname, description, etc., and \nkeeps a reference to them all. \nThis is pretty much like our \nold MenuItem implementation.\nHere\u2019s our getter \nmethods\u2009\u2014\u2009just like our \nprevious implementation.\nThis is different from the previous implementation. \nHere we\u2019re overriding the print() method in the \nMenuComponent class. For MenuItem this method \nprints the complete menu entry: name, description, \nprice, and whether or not it\u2019s veggie.\nI\u2019m glad we\u2019re going in this \ndirection. I\u2019m thinking this \nis going to give me the flexibility \nI need to implement that cr\u00eape \nmenu I\u2019ve always wanted.\n", "page": 403, "type": "text", "section": "Page 403"}
{"text": "366\u2003 \u2003 Chapter 9\nimplementing the new menu class\npublic class Menu extends MenuComponent {\n    List<MenuComponent> menuComponents = new ArrayList<MenuComponent>();\n    String name;\n    String description;\n  \n    public Menu(String name, String description) {\n        this.name = name;\n        this.description = description;\n    }\n \n    public void add(MenuComponent menuComponent) {\n        menuComponents.add(menuComponent);\n    }\n \n    public void remove(MenuComponent menuComponent) {\n        menuComponents.remove(menuComponent);\n    }\n \n    public MenuComponent getChild(int i) {\n        return menuComponents.get(i);\n    }\n \n    public String getName() {\n        return name;\n    }\n \n    public String getDescription() {\n        return description;\n    }\n \n    public void print() {\n        System.out.print(\"\\n\" + getName());\n        System.out.println(\", \" + getDescription());\n        System.out.println(\"---------------------\");\n    }\n}\nImplementing the Composite Menu\nNow that we have the MenuItem, we just need the composite class, which we\u2019re \ncalling Menu. Remember, the composite class can hold MenuItems or other Menus.   \nThere\u2019s a couple of methods from MenuComponent this class doesn\u2019t implement, \ngetPrice() and isVegetarian(), because those don\u2019t make a lot of sense for a Menu.\nMenu can have any number of children \nof type MenuComponent. We\u2019ll use an \ninternal ArrayList to hold these.\nThis is different than our old \nimplementation: we\u2019re going to give each \nMenu a name and a description. Before, \nwe just relied on having different classes \nfor each menu.\nHere\u2019s how you add MenuItems or \nother Menus to a Menu. Because \nboth MenuItems and Menus are \nMenuComponents, we just need one \nmethod to do both.\nYou can also remove a MenuComponent \nor get a MenuComponent.\nHere are the getter methods for getting the name \nand description.\nNotice, we aren\u2019t overriding getPrice() or \nisVegetarian() because those methods don\u2019t make \nsense for a Menu (although you could argue that \nisVegetarian() might make sense). If someone tries \nto call those methods on a Menu, they\u2019ll get an \nUnsupportedOperationException.\nT\no print the Menu, we print its \nname and description.\nMenu is also a MenuComponent, \njust like MenuItem.\n", "page": 404, "type": "text", "section": "Page 404"}
{"text": "you are here 4\u2003 \u2003 367\nthe iterator and composite patterns\npublic class Menu extends MenuComponent {\n    List<MenuComponent> menuComponents = new ArrayList<MenuComponent>();\n    String name;\n    String description;\n  \n    // constructor code here\n \n    // other methods here\n \n    public void print() {\n\t\nSystem.out.print(\"\\n\" + getName());\n\t\nSystem.out.println(\", \" + getDescription());\n\t\nSystem.out.println(\"---------------------\");\n  \n\t\nfor (MenuComponent menuComponent : menuComponents) {\n           menuComponent.print();\n\t\n}\n    }\n}\nLook! We get to use an Iterator behind \nthe scenes of the enhanced for loop. We \nuse it to iterate through all the Menu\u2019s \ncomponents...those could be other Menus, \nor they could be MenuItems.  \nGood catch. Because Menu is a composite and contains \nboth MenuItems and other Menus, its print() method should \nprint everything it contains. If it doesn\u2019t, we\u2019ll have to iterate \nthrough the entire composite and print each item ourselves. \nThat kind of defeats the purpose of having a composite \nstructure.\nAs you\u2019re going to see, implementing print() correctly is easy \nbecause we can rely on each component to be able to print \nitself. It\u2019s all wonderfully recursive and groovy. Check it out:\nAll we need to do is change the print() method \nto make it print not only the information about \nthis Menu, but all of this Menu\u2019s components: \nother Menus and MenuItems.  \nNOTE: If, during this iteration, we encounter another Menu object, \nits print() method will start another iteration, and so on.\nFixing the print() method\nWait a sec, I don\u2019t \nunderstand the implementation of print(). \nI thought I was supposed to be able to apply the \nsame operations to a composite that I could to a leaf. If \nI apply print() to a composite with this implementation, \nall I get is a simple menu name and description. I don\u2019t \nget a printout of the COMPOSITE.\nSince both Menus and MenuItems \nimplement print(), we just call \nprint() and the rest is up to them.\n", "page": 405, "type": "text", "section": "Page 405"}
{"text": "368\u2003 \u2003 Chapter 9\ntest drive the menu composite\npublic class Waitress {\n    MenuComponent allMenus;\n \n    public Waitress(MenuComponent allMenus) {\n        this.allMenus = allMenus;\n    }\n \n    public void printMenu() {\n        allMenus.print();\n    }\n}\nGetting ready for a test drive...\nIt\u2019s about time we took this code for a test drive, but we need to update the Waitress code before \nwe do\u2014after all, she\u2019s the main client of this code:\n \n \n \n \nA\nl\nl\n \nM\ne\nnu\ns\n \n \n \nD\ne\ns\ns\ne\nr\nt \nM\ne\nn\nu\nP\na\nn\nc\na\nk\ne\n \nHo\nu\ns\ne\n \nM\nenu\n \n \n \n \nD\ni\nn\ne\nr\n \nMe\nn\nu\n \n \n \n \n \nC\na\nf\ne\n \nMe\nn\nu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\nComposite\nYup! The Waitress code really is this simple. \n \nNow we just hand her the top-level menu \ncomponent, the one that contains all the \nother menus. We\u2019ve called that allMenus.\nAll she has to do to print the entire menu \nhierarchy\u2009\u2014\u2009all the menus and all the menu \nitems\u2009\u2014\u2009is call print() on the top-level menu. \nWe\u2019re gonna have one happy Waitress.\nOkay, one last thing before we write our test drive. Let\u2019s get an idea of what the menu \ncomposite is going to look like at runtime:\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\nThe top-level menu holds \nall menus and items.\nEach Menu \nholds items...\n...or items and \nother menus.\nComposite\nComposite\nLeaf\nEvery Menu and \nMenuItem implements the \nMenuComponent interface.\nLeaf\nLeaf\nLeaf\n", "page": 406, "type": "text", "section": "Page 406"}
{"text": "you are here 4\u2003 \u2003 369\nthe iterator and composite patterns\npublic class MenuTestDrive {\n    public static void main(String args[]) {\n        MenuComponent pancakeHouseMenu = \n            new Menu(\"PANCAKE HOUSE MENU\", \"Breakfast\");\n        MenuComponent dinerMenu = \n            new Menu(\"DINER MENU\", \"Lunch\");\n        MenuComponent cafeMenu = \n            new Menu(\"CAFE MENU\", \"Dinner\");\n        MenuComponent dessertMenu = \n            new Menu(\"DESSERT MENU\", \"Dessert of course!\");\n  \n        MenuComponent allMenus = new Menu(\"ALL MENUS\", \"All menus combined\");\n  \n        allMenus.add(pancakeHouseMenu);\n        allMenus.add(dinerMenu);\n        allMenus.add(cafeMenu);\n  \n        // add menu items here\n \n        dinerMenu.add(new MenuItem(\n            \"Pasta\",\n            \"Spaghetti with Marinara Sauce, and a slice of sourdough bread\",\n            true, \n            3.89));\n   \n        dinerMenu.add(dessertMenu);\n  \n        dessertMenu.add(new MenuItem(\n            \"Apple Pie\",\n            \"Apple pie with a flakey crust, topped with vanilla ice cream\",\n            true,\n            1.59));\n  \n        // add more menu items here\n  \n        Waitress waitress = new Waitress(allMenus);\n   \n        waitress.printMenu();\n    }\n}\nNow for the test drive...\nOkay, now we just need a test drive. Unlike our previous version, we\u2019re going to \nhandle all the menu creation in the test drive. We could ask each chef to give us \nhis new menu, but let\u2019s get it all tested first. Here\u2019s the code:\nLet\u2019s first create \nall the menu objects.\nWe also need a top-\nlevel menu that we\u2019ll \nname allMenus.\nWe\u2019re using the Composite add() method to add \neach menu to the top-level menu, allMenus.\nAnd we\u2019re also adding a menu to a \nmenu. All dinerMenu cares about is that \neverything it holds, whether it\u2019s a menu \nitem or a menu, is a MenuComponent.\nAdd some apple pie to the \ndessert menu...\nOnce we\u2019ve constructed our \nentire menu hierarchy, we hand \nthe whole thing to the Waitress, \nand as you\u2019ve seen, it\u2019s as easy as \napple pie for her to print it out.\nNow we need to add all the menu \nitems. Here\u2019s one example; for \nthe rest, look at the complete \nsource code.\n", "page": 407, "type": "text", "section": "Page 407"}
{"text": "370\u2003 \u2003 Chapter 9\nanother test drive\nFile  Edit   Window  Help   \n% java MenuTestDrive\nALL MENUS, All menus combined\n---------------------\nPANCAKE HOUSE MENU, Breakfast\n---------------------\n  K&B\u2019s Pancake Breakfast(v), 2.99\n     -- Pancakes with scrambled eggs and toast\n  Regular Pancake Breakfast, 2.99\n     -- Pancakes with fried eggs, sausage\n  Blueberry Pancakes(v), 3.49\n     -- Pancakes made with fresh blueberries, and blueberry syrup\n  Waffles(v), 3.59\n     -- Waffles with your choice of blueberries or strawberries\nDINER MENU, Lunch\n---------------------\n  Vegetarian BLT(v), 2.99\n     -- (Fakin\u2019) Bacon with lettuce & tomato on whole wheat\n  BLT, 2.99\n     -- Bacon with lettuce & tomato on whole wheat\n  Soup of the day, 3.29\n     -- A bowl of the soup of the day, with a side of potato salad\n  Hot Dog, 3.05\n     -- A hot dog, with sauerkraut, relish, onions, topped with cheese\n  Steamed Veggies and Brown Rice(v), 3.99\n     -- Steamed vegetables over brown rice\n  Pasta(v), 3.89\n     -- Spaghetti with marinara sauce, and a slice of sourdough bread\nDESSERT MENU, Dessert of course!\n---------------------\n  Apple Pie(v), 1.59\n     -- Apple pie with a flakey crust, topped with vanilla ice cream\n  Cheesecake(v), 1.99\n     -- Creamy New York cheesecake, with a chocolate graham crust\n  Sorbet(v), 1.89\n     -- A scoop of raspberry and a scoop of lime\nCAFE MENU, Dinner\n---------------------\n  Veggie Burger and Air Fries(v), 3.99\n     -- Veggie burger on a whole wheat bun, lettuce, tomato, and fries\n  Soup of the day, 3.69\n     -- A cup of the soup of the day, with a side salad\n  Burrito(v), 4.29\n     -- A large burrito, with whole pinto beans, salsa, guacamole\n%\nHere\u2019s all our menus...we printed all \nthis just by calling print() on the \ntop-level menu.\nThe new \ndessert menu \nis printed \nwhen we are \nprinting all the \nDiner menu \ncomponents.\nGetting ready for a test drive...\nNOTE: this output is based on the complete source.\n", "page": 408, "type": "text", "section": "Page 408"}
{"text": "you are here 4\u2003 \u2003 371\nthe iterator and composite patterns\nThere is some truth to that observation. We could \nsay that the Composite Pattern takes the Single Responsibility \nPrinciple and trades it for transparency. What\u2019s transparency? Well, by \nallowing the Component interface to contain the child management \noperations and the leaf operations, a client can treat both composites \nand leaves uniformly; so whether an element is a composite or leaf \nnode becomes transparent to the client.\nNow, given we have both types of operations in the Component \nclass, we lose a bit of safety because a client might try to do something \ninappropriate or meaningless on an element (like try to add a menu \nto a menu item). This is a design decision; we could take the design \nin the other direction and separate out the responsibilities into \ninterfaces. This would make our design safe, in the sense that any \ninappropriate calls on elements would be caught at compile time or \nruntime, but we\u2019d lose transparency and our code would have to use \nconditionals and the instanceof operator.\nSo, to return to your question, this is a classic case of tradeoff. We \nare guided by design principles, but we always need to observe the \neffect they have on our designs. Sometimes we purposely do things \nin a way that seems to violate the principle. In some cases, however, \nthis is a matter of perspective; for instance, it might seem incorrect to \nhave child management operations in the leaves (like add(), remove(), \nand getChild()), but then again you can always shift your perspective \nand see a leaf as a node with zero children.\nWhat\u2019s the story?  \nFirst you tell us One Class, One \nResponsibility, and now you\u2019re giving us a \npattern with two responsibilities in one class. \nThe Composite Pattern manages a hierarchy \nAND it performs operations related to Menus.\n", "page": 409, "type": "text", "section": "Page 409"}
{"text": "372\u2003 \u2003 Chapter 9\ninterview with composite\nHeadFirst: We\u2019re here tonight speaking with the \nComposite Pattern. Why don\u2019t you tell us a little about \nyourself, Composite?\nComposite: Sure...I\u2019m the pattern to use when you have \ncollections of objects with whole-part relationships and \nyou want to be able to treat those objects uniformly.\nHeadFirst: Okay, let\u2019s dive right in here...what do you \nmean by whole-part relationships?\nComposite: Imagine a graphical user interface (GUI); \nthere you\u2019ll often find a top-level component like a Frame \nor a Panel, containing other components, like menus, \ntext panes, scrollbars, and buttons. So your GUI consists \nof several parts, but when you display it, you generally \nthink of it as a whole. You tell the top-level component \nto display, and count on that component to display all \nits parts. We call the components that contain other \ncomponents, composite objects, and components that don\u2019t \ncontain other components leaf  objects.\nHeadFirst: Is that what you mean by treating the objects \nuniformly? Having common methods you can call on \ncomposites and leaves?\nComposite: Right. I can tell a composite object to \ndisplay or a leaf object to display and it will do the right \nthing. The composite object will display by telling all its \ncomponents to display.\nHeadFirst: That implies that every object has the same \ninterface. What if you have objects in your composite that \ndo different things?\nComposite: In order for the composite to work \ntransparently to the client, you must implement the same \ninterface for all objects in the composite; otherwise, the \nclient has to worry about which interface each object \nis implementing, which kind of defeats the purpose. \nObviously that means that at times you\u2019ll have objects for \nwhich some of the method calls don\u2019t make sense. \nHeadFirst: So how do you handle that?\nComposite: Well, there are a couple of ways to handle \nit; sometimes you can just do nothing, or return null or \nfalse\u2014whatever makes sense in your application. Other \ntimes you\u2019ll want to be more proactive and throw an \nexception. Of course, then the client has to be willing to \ndo a little work and make sure that the method call didn\u2019t \ndo something unexpected.\nHeadFirst: But if the client doesn\u2019t know which kind of \nobject they\u2019re dealing with, how would they ever know \nwhich calls to make without checking the type?  \nComposite: If you\u2019re a little creative you can structure \nyour methods so that the default implementations do \nsomething that does make sense. For instance, if the client \nis calling getChild() on the composite, this makes sense. \nAnd it makes sense on a leaf too, if you think of the leaf \nas an object with no children.  \nHeadFirst: Ah...smart. But I\u2019ve heard some clients are \nso worried about this issue that they require separate \ninterfaces for different objects so they aren\u2019t allowed to \nmake nonsensical method calls. Is that still the Composite \nPattern? \nComposite: Yes. It\u2019s a much safer version of the \nComposite Pattern, but it requires the client to check the \ntype of every object before making a call so the object can \nbe cast correctly.\nHeadFirst: Tell us a little more about how these \ncomposite and leaf objects are structured.\nComposite: Usually it\u2019s a tree structure, some kind of \nhierarchy. The root is the top-level composite, and all its \nchildren are either composites or leaves.\nHeadFirst: Do children ever point back up to their \nparents?\nComposite: Yes, a component can have a pointer to a \nparent to make traversal of the structure easier. And, if \nThis week\u2019s interview: \nThe Composite Pattern, on implementation issues\nPatterns Exposed\n", "page": 410, "type": "text", "section": "Page 410"}
{"text": "you are here 4\u2003 \u2003 373\nthe iterator and composite patterns\nyou have a reference to a child and you need to delete it, \nyou\u2019ll need to get the parent to remove the child. Having \nthe parent reference makes that easier too.\nHeadFirst: There\u2019s really quite a lot to consider in your \nimplementation. Are there other issues we should think \nabout when implementing the Composite Pattern?\nComposite: Actually, there are. One is the ordering \nof children. What if you have a composite that needs to \nkeep its children in a particular order? Then you\u2019ll need a \nmore sophisticated management scheme for adding and \nremoving children, and you\u2019ll have to be careful about \nhow you traverse the hierarchy.\nHeadFirst: A good point I hadn\u2019t thought of.\nComposite: And did you think about caching?\nHeadFirst: Caching?\nComposite: Yeah, caching. Sometimes, if the \ncomposite structure is complex or expensive to traverse, \nit\u2019s helpful to implement caching of the composite nodes. \nFor instance, if you are constantly traversing a composite \nand all its children to compute some result, you could \nimplement a cache that stores the result temporarily to \nsave traversals. \nHeadFirst: Well, there\u2019s a lot more to the Composite \nPatterns than I ever would have guessed. Before we wrap \nthis up, one more question: what do you consider your \ngreatest strength?\nComposite: I think I\u2019d definitely have to say simplifying \nlife for my clients. My clients don\u2019t have to worry about \nwhether they\u2019re dealing with a composite object or a \nleaf object, so they don\u2019t have to write if statements \neverywhere to make sure they\u2019re calling the right methods \non the right objects. Often, they can make one method \ncall and execute an operation over an entire structure.\nHeadFirst: That does sound like an important benefit.  \nThere\u2019s no doubt you\u2019re a useful pattern to have around \nfor collecting and managing objects. And, with that, we\u2019re \nout of time. Thanks so much for joining us and come \nback soon for another Patterns Exposed.\n", "page": 411, "type": "text", "section": "Page 411"}
{"text": "374\u2003 \u2003 Chapter 9\ncrossword puzzle\nDesign Patterns Crossword\nWrap your brain around this composite crossword.\nACROSS\n1. Collection and Iterator are in this package.\n3. This class indirectly supports Iterator.\n8. Iterators are usually created using this pattern (two \nwords).\n12. A class should have only one reason to do this.\n13. We encapsulated this.\n15. User interface packages often use this pattern for \ntheir components.\n16. Name of the principle that states only one \nresponsibility per class (two words).\n17. This menu caused us to change our entire \nimplementation.\nDOWN\n2. Has no children.\n4. Merged with the Diner (two words).\n5. The Iterator Pattern decouples the client from the \naggregate\u2019s ________.\n6. A separate object that can traverse a collection.\n7. HashMap values and ArrayList both implement this \ninterface.\n9. We Java-enabled her.\n10. A component can be a composite or this.\n11. A composite holds these.\n12. Third company acquired.\n14. We deleted the PancakeHouseMenuIterator because \nthis class already provides an iterator. \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nAcross\n1. Collection and Iterator are in this package\n3. This class indirectly supports Iterator.\n8. Iterators are usually created using this \npattern.\n12. A class should have only one reason to do \nthis.\n13. We encapsulated this.\n15. User interface packages often use this \npattern for their components.\n16. Name of principle that states only one \nresponsibility per class.\n17. This menu caused us to change our entire \nimplementation.\nDown\n2. Has no children.\n4. Merged with the Diner.\n5. The Iterator Pattern decouples the client \nfrom the aggregates _________.\n6. A separate object that can traverse a \ncollection.\n7. HashMap values and ArrayList both \nimplement this interface.\n9. We java-enabled her.\n10. A component can be a composite or this.\n11. A composite holds these.\n12. Third company acquired.\n14. We deleted PancakeHouseMenuIterator \nbecause this class already provides an \niterator.\n", "page": 412, "type": "text", "section": "Page 412"}
{"text": "you are here 4\u2003 \u2003 375\nthe iterator and composite patterns\nMatch each pattern with its description:\nPattern\nDescription\nStrategy\nAdapter\nIterator\nFacade\nComposite\nObserver\nClients treat collections \nof objects and individual \nobjects uniformly\nProvides a way to traverse \na collection of objects \nwithout exposing the \ncollection\u2019s implementation\nSimplifies the interface of \na group of classes\nChanges the interface of \none or more classes\nAllows a group of objects to \nbe notified when some state \nchanges\nEncapsulates interchangeable \nbehaviors and uses delegation to \ndecide which one to use\n", "page": 413, "type": "text", "section": "Page 413"}
{"text": "376\u2003 \u2003 Chapter 9\nyour design toolbox\nTools for your Design Toolbox\nTwo new patterns for your toolbox\u2014two great ways to \ndeal with collections of objects.\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable.  Strategy lets the algorithm \nvary independently from clients that use it.\nOO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically.  \nDecorators provide a flexible \nalternative to subclassing for extending \nfunctionality.\nAbstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes.\nFactory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate.  Factory Method lets \na class defer instantiation to the \nsubclasses.\nSingleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it.\nCommand - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nAdapter - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nYet another important \nprinciple based on change \nin a design.\nFacade - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nAnother two-for-one \nchapter.\nT\nemplate Method - Define the \nskeleton of an algorithm in an operation, \n \ndeferring some steps to subclasses.  \nT\nemplate Method lets subclasses \nredefine certain steps of an algorithm \nwithout changing the algorithm\u2019s \nstructure\nIterator - Provide a way to access \nthe elements of an aggregate object \nsequentially without exposing its \nunderlying representation\nComposite - Compose objects into \ntree structures to represent part-whole \nhierarchies. Composite lets clients treat \nindividual objects and compositions of \nobjects uniformly\nEncapsulate what varies\nFavor composition over inheritance.\nProgram to interfaces, not \nimplementations.\nStrive for loosely coupled designs \nbetween objects that interact.\nClasses should be open for extension \nbut closed for modification.\nDepend on abstractions. Do not \ndepend on concrete classes.\nOnly talk to your friends.\nDon\u2019t call us, we\u2019ll call you.\nA class should have only one reason \nto change.\nOO Principles\n\t\n\u0083\nAn Iterator allows access to an \naggregate\u2019s elements without \nexposing its internal structure.\n\t\n\u0083\nAn Iterator takes the job of \niterating over an aggregate \nand encapsulates it in another \nobject.\n\t\n\u0083\nWhen using an Iterator, we \nrelieve the aggregate of the \nresponsibility of supporting \noperations for traversing its \ndata.\n\t\n\u0083\nAn Iterator provides a \ncommon interface for \ntraversing the items of an \naggregate, allowing you to use \npolymorphism when writing \ncode that makes use of the \nitems of the aggregate.\n\t\n\u0083\nThe Iterable interface provides \na means of getting an \niterator and enables Java\u2019s \nenchanced for loop.\n\t\n\u0083\nWe should strive to assign \nonly one responsibility to each \nclass.\n\t\n\u0083\nThe Composite Pattern allows \nclients to treat composites and \nindividual objects uniformly.\n\t\n\u0083\nA Component is any object \nin a Composite structure. \nComponents may be other \ncomposites or leaves.\n\t\n\u0083\nThere are many design \ntradeoffs in implementing \nComposite. You need to \nbalance transparency and \nsafety with your needs.\n", "page": 414, "type": "text", "section": "Page 414"}
{"text": "you are here 4\u2003 \u2003 377\nthe iterator and composite patterns\n\u274f   A.\t We are coding to the \nPancakeHouseMenu and DinerMenu \nconcrete implementations, not to an \ninterface.\n\u274f   B.\t The Waitress doesn\u2019t implement the \nJava Waitress API and so she isn\u2019t \nadhering to a standard.\n\u274f   C.\t If we decided to switch from using \nDinerMenu to another type of menu \nthat implemented its list of menu items \nwith a hash table, we\u2019d have to modify \na lot of code in the Waitress.\n\u274f   D.\t The Waitress needs to know how each \nmenu represents its internal collection of \nmenu items; this violates encapsulation.\n\u274f   E.\t We have duplicate code: the printMenu() \nmethod needs two separate loops to \niterate over the two different kinds of \nmenus. And if we added a third menu, \nwe\u2019d have yet another loop.\n\u274f   F.\t The implementation isn\u2019t based on \nMXML (Menu XML) and so isn\u2019t as \ninteroperable as it should be.\nBased on our implementation of printMenu(), which of the following apply? \n1. \n2. \n3. \nBefore looking at the next page, quickly jot down the three \nthings we have to do to this code to fit it into our framework:\nimplement the Menu interface\nget rid of getItems()\nadd createIterator() and return an Iterator that can step through the HashMap values\n", "page": 415, "type": "text", "section": "Page 415"}
{"text": "378\u2003 \u2003 Chapter 9\nexercise solutions\nNotice that this Iterator \nimplementation does not \nsupport remove().\nThe unscrambled \u201cAlternating\u201d DinerMenu Iterator.\nCode Magnets Solution\n}\n}\n}\nimport java.util.Iterator;\nimport java.util.Calendar;\npublic MenuItem next() {\npublic AlternatingDinerMenuIterator(MenuItem[] items)\nthis.items = items;\nposition = Calendar.DAY_OF_WEEK % 2;\npublic void remove() {\nimplements Iterator<MenuItem>\npublic class AlternatingDinerMenuIterator\npublic boolean hasNext() {\nthrow new UnsupportedOperationException(\n    \"Alternating Diner Menu Iterator does not support remove()\");\nif (position >= items.length || items[position] == null) {\n    return false;\n} else {\n    return true;\n}\n}\nMenuItem menuItem = items[position];\nposition = position + 2;\nreturn menuItem;\n}\nMenuItem[] items;\nint position;\n}\n}\n", "page": 416, "type": "text", "section": "Page 416"}
{"text": "you are here 4\u2003 \u2003 379\nthe iterator and composite patterns\nMatch each pattern with its description:\nPattern\nDescription\nStrategy\nAdapter\nIterator\nFacade\nComposite\nObserver\nClients treat collections \nof objects and individual \nobjects uniformly\nProvides a way to traverse \na collection of objects \nwithout exposing the \ncollection\u2019s implementation\nSimplifies the interface of \na group of classes\nChanges the interface of \none or more classes\nAllows a group of objects to \nbe notified when some state \nchanges\nEncapsulates interchangeable \nbehaviors and uses delegation to \ndecide which one to use\nSOlUTion\n", "page": 417, "type": "text", "section": "Page 417"}
{"text": "380\u2003 \u2003 Chapter 9\ncrossword puzzle solution\nDesign Patterns Crossword Solution\nWrap your brain around this composite crossword. Here\u2019s our solution.\nJ\n1\nA\nV\nA\n.\nU\nT\nI\nL\n2\nE\nH\n3\nA\nS\nH\nM\nA\nP\n4\nI\n5\nI\n6\nC\n7\nF\n8\nA\nC\nT\nO\nR\nY\nM\nE\nT\nH\nO\nD\nO\nN\nP\nE\nW\n9\nL\nC\nL\n10\nL\nR\nA\nL\nC\n11\nC\n12\nH\nA\nN\nG\nE\nE\nA\nI\n13\nT\nE\nR\nA\n14\nT\nI\nO\nN\nA\nK\nA\nM\nT\nT\nC\nR\nM\nF\nE\nF\nE\nO\nR\nT\nR\nP\nE\nH\nN\nR\nE\nI\nA\nO\nC\n15\nO\nM\nP\nO\nS\nI\nT\nE\nS\nO\nY\nN\nU\nA\nS\n16\nI\nN\nG\nL\nE\nR\nE\nS\nP\nO\nN\nS\nI\nB\nI\nL\nI\nT\nY\nI\nN\nE\nI\nD\n17\nE\nS\nS\nE\nR\nT\nO\nT\nS\nN\nAcross\n1. Collection and Iterator are in this package \n[JAVA.UTIL] \n3. This class indirectly supports Iterator. \n[HASHMAP] \n8. Iterators are usually created using this \npattern. [FACTORYMETHOD] \n12. A class should have only one reason to do \nthis. [CHANGE] \n13. We encapsulated this. [ITERATION] \n15. User interface packages often use this \npattern for their components. [COMPOSITE] \n16. Name of principle that states only one \nresponsibility per class. \n[SINGLERESPONSIBILITY] \n17. This menu caused us to change our entire \nimplementation. [DESSERT] \nDown\n2. Has no children. [LEAF] \n4. Merged with the Diner. [PANCAKEHOUSE] \n5. The Iterator Pattern decouples the client \nfrom the aggregates _________. \n[IMPLEMENTATION] \n6. A separate object that can traverse a \ncollection. [ITERATOR] \n7. HashMap values and ArrayList both \nimplement this interface. [COLLECTION] \n9. We java-enabled her. [WAITRESS] \n10. A component can be a composite or this. \n[LEAF] \n11. A composite holds these. [COMPONENTS] \n12. Third company acquired. [CAFE] \n14. We deleted PancakeHouseMenuIterator \nbecause this class already provides an \niterator [ARRAYLIST]\n", "page": 418, "type": "text", "section": "Page 418"}
{"text": "this is a new chapter\u2003 \u2003 381\nA little-known fact: the Strategy and State Patterns \nare twins separated at birth. You\u2019d think they\u2019d live similar lives, \nbut the Strategy Pattern went on to create a wildly successful business around \ninterchangeable algorithms, while State took the perhaps more noble path of helping \nobjects to control their behavior by changing their internal state. As different as their \npaths became, however, underneath you\u2019ll find almost precisely the same design. How \ncan that be? As you\u2019ll see, Strategy and State have very different intents. First, let\u2019s \ndig in and see what the State Pattern is all about, and then we\u2019ll return to explore their \nrelationship at the end of the chapter.\n10  the State Pattern\nThe State of Things\nI thought things in Objectville were \ngoing to be so easy, but now every time I \nturn around there\u2019s another change request \ncoming in. I\u2019m at the breaking point! Oh, \nmaybe I should have been going to Betty\u2019s \nWednesday night patterns group all along. \nI\u2019m in such a state!\n", "page": 419, "type": "text", "section": "Page 419"}
{"text": "382\u2003 \u2003 Chapter 10\nmeet mighty gumball\nGumball machines have gone high tech. That\u2019s right, the \nmajor manufacturers have found that by putting CPUs \ninto their candy machines, they can increase sales, monitor \ninventory over the network, and measure customer satisfaction \nmore accurately.  \nBut these manufacturers are gumball machine experts, not \nsoftware developers, and they\u2019ve asked for your help:\nJaw  Breakers\nMighty Gumball, Inc.\nWhere the Gumball Machine \nis Never Half Empty\nHere\u2019s the way we think the gumball machine controller needs to \nwork. We\u2019re hoping you can implement this in Java for us! We may \nbe adding more behavior in the future, so you need to keep the \ndesign as flexible and maintainable as possible!\n       - Mighty Gumball Engineers\nOut of \nGumballs\n   Has \nQuarter\n   No \nQuarter\nGumball \n  Sold\ninsert quarter\neject quarter\nturn crank\nva\nAt least that\u2019s their story\u2014\nwe think they just got \nbored with the circa 1800s \ntechnology and needed to \nfind a way to make their \njobs more exciting.\ndispense \ngumball\ngumballs = 0\ngumballs > 0\n", "page": 420, "type": "text", "section": "Page 420"}
{"text": "you are here 4\u2003 \u2003 383\nthe state pattern\nCubicle Conversation\nJudy: This diagram looks like a state diagram.\nJoe: Right, each of those circles is a state...\nJudy:  ...and each of the arrows is a state transition.\nFrank: Slow down, you two, it\u2019s been too long since I studied state diagrams.  \nCan you remind me what they\u2019re all about?\nJudy: Sure, Frank. Look at the circles; those are states. \u201cNo Quarter\u201d is \nprobably the starting state for the gumball machine because it\u2019s just sitting there \nwaiting for you to put your quarter in. All states are just different configurations \nof the machine that behave in a certain way and need some action to take them to \nanother state.\nJoe: Right. See, to go to another state, you need to do something like put a quarter in the machine. See the arrow \nfrom \u201cNo Quarter\u201d to \u201cHas Quarter\u201d?\nFrank: Yes...\nJoe: That just means that if the gumball machine is in the \u201cNo Quarter\u201d state and you put a quarter in, it will \nchange to the \u201cHas Quarter\u201d state. That\u2019s the state transition.\nFrank: Oh, I see! And if I\u2019m in the \u201cHas Quarter\u201d state, I can turn the crank and change to the \u201cGumball Sold\u201d \nstate, or eject the quarter and change back to the \u201cNo Quarter\u201d state.\nJudy: You got it!\nFrank: This doesn\u2019t look too bad then. We\u2019ve obviously got four states, and I think we also have four actions: \u201cinsert \nquarter,\u201d \u201ceject quarter,\u201d \u201cturn crank,\u201d and \u201cdispense.\u201d But...when we dispense, we test for zero or more gumballs \nin the \u201cGumball Sold\u201d state, and then either go to the \u201cOut of Gumballs\u201d state or the \u201cNo Quarter\u201d state. So we \nactually have five transitions from one state to another.\nJudy: That test for zero or more gumballs also implies we\u2019ve got to keep track of the number of gumballs too. Any \ntime the machine gives you a gumball, it might be the last one, and if it is, we need to transition to the \u201cOut of \nGumballs\u201d state.\nJoe: Also, don\u2019t forget that you could do nonsensical things, like try to eject the quarter when the gumball machine is \nin the \u201cNo Quarter\u201d state, or insert two quarters.\nFrank: Oh, I didn\u2019t think of that; we\u2019ll have to take care of those too.\nJoe: For every possible action we\u2019ll just have to check to see which state we\u2019re in and act appropriately. We can do \nthis!  Let\u2019s start mapping the state diagram to code...\nJoe\nJudy\nFrank\nLet\u2019s take a look at this \ndiagram and see what the \nMighty Gumball guys want...\n", "page": 421, "type": "text", "section": "Page 421"}
{"text": "384\u2003 \u2003 Chapter 10\nreview of state machines\nState machines 101 \ninsert quarter\neject quarter\nturn crank\nThese actions are \nthe gumball machine\u2019s \ninterface\u2009\u2014\u2009the things \nyou can do with it.\nHow are we going to get from that state diagram to actual code? Here\u2019s a quick \nintroduction to implementing state machines:\nFirst, gather up your states:\n1\nGumball \n  Sold\n   No \nQuarter\n   Has \nQuarter\nOut of \nGumballs\nHere are the states\u2009\u2014\u2009four in total.\nNext, create an instance variable to hold the current state, and define values for each of the states:\n2\nfinal static int SOLD_OUT = 0;\nfinal static int NO_QUARTER = 1;\nfinal static int HAS_QUARTER = 2;\nfinal static int SOLD = 3;\n \nint state = SOLD_OUT;\nHere\u2019s each state represented \nas a unique integer...\n...and here\u2019s an instance variable that holds the \ncurrent state. We\u2019ll go ahead and set it to \u201cSold \nOut\u201d since the machine will be unfilled when it\u2019s \nfirst taken out of its box and turned on.\nNow we gather up all the actions that can happen in the system:\n3\nLooking at the diagram, invoking any of \nthese actions causes a state transition.\ndispense\nDispense is more of an internal \naction the machine invokes on itself.\nLet\u2019s just call \u201cOut of Gumballs\u201d \n\u201cSold Out\u201d for short.\n", "page": 422, "type": "text", "section": "Page 422"}
{"text": "you are here 4\u2003 \u2003 385\nthe state pattern\npublic void insertQuarter() {\n    if (state == HAS_QUARTER) {\n        System.out.println(\"You can't insert another quarter\");\n    } else if (state == NO_QUARTER) {\n        state = HAS_QUARTER;\n        System.out.println(\"You inserted a quarter\");\n    } else if (state == SOLD_OUT) {\n        System.out.println(\"You can't insert a quarter, the machine is sold out\");\n    } else if (state == SOLD) {\n        System.out.println(\"Please wait, we're already giving you a gumball\");\n    }\n}\nNow we create a class that acts as the state machine. For each action, \nwe create a method that uses conditional statements to determine \nwhat behavior is appropriate in each state. For instance, for the \n\u201cinsert quarter\u201d action, we might write a method like this:\n4\nHere we\u2019re talking \nabout a common technique: \nmodeling state within an object \nby creating an instance variable to hold \nthe state values and writing conditional \ncode within our methods to handle \nthe various states.\nEach possible \nstate is checked \nwith a conditional \nstatement...\n...but can also transition to other states, \njust as depicted in the diagram.\nWith that quick review, let\u2019s go implement the Gumball Machine!\n...and exhibits the appropriate \nbehavior for each possible state...\n", "page": 423, "type": "text", "section": "Page 423"}
{"text": "386\u2003 \u2003 Chapter 10\nimplement the gumball machine\npublic class GumballMachine {\n \n    final static int SOLD_OUT = 0;\n    final static int NO_QUARTER = 1;\n    final static int HAS_QUARTER = 2;\n    final static int SOLD = 3;\n \n    int state = SOLD_OUT;\n    int count = 0;\n  \n    public GumballMachine(int count) {\n        this.count = count;\n        if (count > 0) {\n            state = NO_QUARTER;\n        }\n    }\n \n    public void insertQuarter() {\n        if (state == HAS_QUARTER) {\n            System.out.println(\"You can't insert another quarter\");\n        } else if (state == NO_QUARTER) {\n            state = HAS_QUARTER;\n            System.out.println(\"You inserted a quarter\");\n        } else if (state == SOLD_OUT) {\n            System.out.println(\"You can't insert a quarter, the machine is sold out\");\n        } else if (state == SOLD) {\n            System.out.println(\"Please wait, we're already giving you a gumball\");\n        }\n    }\n   \nWriting the code\nHere are the four states; they match the \nstates in Mighty Gumball\u2019s state diagram.\nHere\u2019s the instance variable that is going \nto keep track of the current state we\u2019re \nin. We start in the SOLD_OUT state.\nWe have a second instance variable that \nkeeps track of the number of gumballs \nin the machine.\nThe constructor takes an initial inventory \nof gumballs. If the inventory isn\u2019t zero, \nthe machine enters state NO_QUARTER, \nmeaning it is waiting for someone to \ninsert a quarter; otherwise, it stays in \nthe SOLD_OUT state.\nNow we start implementing \nthe actions as methods....\nWhen a quarter is inserted...\n...if a quarter is already \ninserted, we tell the \ncustomer...\n...otherwise, we accept the \nquarter and transition to \nthe HAS_QUARTER state.\nAnd if the machine is sold \nout, we reject the quarter.\nIt\u2019s time to implement the Gumball Machine. We know we\u2019re going to have an instance \nvariable that holds the current state. From there, we just need to handle all the actions, \nbehaviors, and state transitions that can happen. For actions, we need to implement \ninserting a quarter, removing a quarter, turning the crank, and dispensing a gumball; we \nalso have the empty Gumball Machine condition to implement.  \nIf the customer just bought a \ngumball, he needs to wait until the \ntransaction is complete before \ninserting another quarter.\n", "page": 424, "type": "text", "section": "Page 424"}
{"text": "you are here 4\u2003 \u2003 387\nthe state pattern\n \n \n    public void ejectQuarter() {\n        if (state == HAS_QUARTER) {\n            System.out.println(\"Quarter returned\");\n            state = NO_QUARTER;\n        } else if (state == NO_QUARTER) {\n            System.out.println(\"You haven't inserted a quarter\");\n        } else if (state == SOLD) {\n            System.out.println(\"Sorry, you already turned the crank\");\n        } else if (state == SOLD_OUT) {\n            System.out.println(\"You can't eject, you haven't inserted a quarter yet\");\n        }\n    }\n \n \n    public void turnCrank() {\n        if (state == SOLD) {\n            System.out.println(\"Turning twice doesn't get you another gumball!\");\n        } else if (state == NO_QUARTER) {\n            System.out.println(\"You turned but there's no quarter\");\n        } else if (state == SOLD_OUT) {\n            System.out.println(\"You turned, but there are no gumballs\");\n        } else if (state == HAS_QUARTER) {\n            System.out.println(\"You turned...\");\n            state = SOLD;\n            dispense();\n        }\n    }\n \n    public void dispense() {\n        if (state == SOLD) {\n            System.out.println(\"A gumball comes rolling out the slot\");\n            count = count - 1;\n            if (count == 0) {\n                System.out.println(\"Oops, out of gumballs!\");\n                state = SOLD_OUT;\n            } else {\n                state = NO_QUARTER;\n            }\n        } else if (state == NO_QUARTER) {\n            System.out.println(\"You need to pay first\");\n        } else if (state == SOLD_OUT) {\n            System.out.println(\"No gumball dispensed\");\n        } else if (state == HAS_QUARTER) {\n            System.out.println(\"You need to turn the crank\");\n        }\n    }\n \n    // other methods here like toString() and refill()\n}\nNow, if the customer tries to remove the quarter...\n...if there is a quarter, we \nreturn it and go back to the \nNO_QUARTER state...\nIf the customer just \nturned the crank, we \ncan\u2019t give a refund; he \nalready has the gumball!\n...otherwise, if there isn\u2019t \none we can\u2019t give it back.\nThe customer tries to turn the crank...\nWe can\u2019t deliver \ngumballs; there \nare none.\nWe need a \nquarter first.\nSuccess! They get a gumball. Change \nthe state to SOLD and call the \nmachine\u2019s dispense() method.\nSomeone\u2019s trying to cheat the machine.\nYou can\u2019t eject if the machine is sold \nout, it doesn\u2019t accept quarters!\nCalled to dispense a gumball.\nHere\u2019s where we handle the \n\u201cout of gumballs\u201d condition: \nIf this was the last one, we \nset the machine\u2019s state to \nSOLD_OUT; otherwise, we\u2019re \nback to not having a quarter.\nWe\u2019re in the \nSOLD state; give \n\u2019em a gumball!\nNone of these should ever \nhappen, but if they do, \nwe give \u2019em an error, not \na gumball.\n", "page": 425, "type": "text", "section": "Page 425"}
{"text": "388\u2003 \u2003 Chapter 10\ntest the gumball machine\npublic class GumballMachineTestDrive {\n    public static void main(String[] args) {\n        GumballMachine gumballMachine = new GumballMachine(5);\n        System.out.println(gumballMachine);\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        System.out.println(gumballMachine);\n        gumballMachine.insertQuarter();\n        gumballMachine.ejectQuarter();\n        gumballMachine.turnCrank();\n        System.out.println(gumballMachine);\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.ejectQuarter();\n        System.out.println(gumballMachine);\n        gumballMachine.insertQuarter();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        System.out.println(gumballMachine);\n    }\n}\nIn-house testing\nThat feels like a nice solid design using a well-thought-out methodology, doesn\u2019t \nit? Let\u2019s do a little in-house testing before we hand it off to Mighty Gumball to \nbe loaded into their actual gumball machines. Here\u2019s our test harness:\nLoad it up with five \ngumballs total.\nPrint out the state of the machine.\nThrow a quarter in...\nTurn the crank; we should get our gumball.\nPrint out the state of the machine again.\nThrow a quarter in...\nAsk for it back.\nTurn the crank; we shouldn\u2019t get our gumball.\nPrint out the state of the machine again.\nThrow a quarter in...\nTurn the crank; we should get our gumball.\nThrow a quarter in...\nTurn the crank; we should get our gumball.\nAsk for a quarter back we didn\u2019t put in.\nPrint out the state of the machine again.\nThrow TWO quarters in...\nTurn the crank; we should get our gumball.\nNow for the stress testing...\nPrint that machine state one more time.\n", "page": 426, "type": "text", "section": "Page 426"}
{"text": "you are here 4\u2003 \u2003 389\nthe state pattern\nFile  Edit   Window  Help  mightygumball.com\n%java GumballMachineTestDrive\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 5 gumballs\nMachine is waiting for quarter\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 4 gumballs\nMachine is waiting for quarter\nYou inserted a quarter\nQuarter returned\nYou turned but there's no quarter\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 4 gumballs\nMachine is waiting for quarter\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot\nYou haven't inserted a quarter\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 2 gumballs\nMachine is waiting for quarter\nYou inserted a quarter\nYou can't insert another quarter\nYou turned...\nA gumball comes rolling out the slot\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot\nOops, out of gumballs!\nYou can't insert a quarter, the machine is sold out\nYou turned, but there are no gumballs\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 0 gumballs\nMachine is sold out\n", "page": 427, "type": "text", "section": "Page 427"}
{"text": "390\u2003 \u2003 Chapter 10\ngumball buying game\nYou knew it was coming...a change request!\nMighty Gumball, Inc., has loaded your code into their \nnewest machine and their quality assurance experts are \nputting it through its paces. So far, everything\u2019s looking \ngreat from their perspective.\nIn fact, things have gone so smoothly they\u2019d like to take \nthings to the next level...\nWe think that by turning \n\u201cgumball buying\u201d into a game we \ncan significantly increase our \nsales. We\u2019re going to put one of \nthese stickers on every machine. \n \nWe\u2019re so glad we\u2019ve got Java \nin the machines because this is \ngoing to be easy, right?\nCEO, Mighty \nGumball, Inc.\nJawBreaker or \nGumdrop?\n10% of the time, \nwhen the crank \nis turned, the \ncustomer gets \ntwo gumballs \ninstead of one.\nGumballs\n", "page": 428, "type": "text", "section": "Page 428"}
{"text": "you are here 4\u2003 \u2003 391\nthe state pattern\nDraw a state diagram for a Gumball Machine that handles the 1 in 10 \ncontest. In this contest, 10% of the time the Sold state leads to two \nballs being released, not one. Check your answer with ours (at the \nend of the chapter) to make sure we agree before you go further...\nMighty Gumball, Inc.\nWhere the Gumball Machine \nis Never Half Empty\nUse Mighty Gumball\u2019s stationery to draw your state diagram.\n Design Puzzle\n", "page": 429, "type": "text", "section": "Page 429"}
{"text": "392\u2003 \u2003 Chapter 10\nthings get messy\nThe messy STATE of things...\nJust because you\u2019ve written your gumball machine using a well-thought-out \nmethodology doesn\u2019t mean it\u2019s going to be easy to extend. In fact, when you go back \nand look at your code and think about what you\u2019ll have to do to modify it, well...\nfinal static int SOLD_OUT = 0;\nfinal static int NO_QUARTER = 1;\nfinal static int HAS_QUARTER = 2;\nfinal static int SOLD = 3;\npublic void insertQuarter() {\n    // insert quarter code here\n}\npublic void ejectQuarter() {\n    // eject quarter code here\n}\npublic void turnCrank() {\n    // turn crank code here\n}\npublic void dispense() {\n    // dispense code here\n}\nFirst, you\u2019d have to add a new WINNER state \nhere. That isn\u2019t too bad...\n...but then, you\u2019d have to add a new conditional \nin every single method to handle the WINNER \nstate; that\u2019s a lot of code to modify.\nturnCrank() will get especially messy, because you\u2019d \nhave to add code to check to see whether you\u2019ve \ngot a WINNER and then switch to either the \nWINNER state or the SOLD state.\n\u274f   A.\t This code certainly isn\u2019t adhering to the \nOpen Closed Principle.\n\u274f   B.\t This code would make a FORTRAN \nprogrammer proud.\n\u274f   C.\t This design isn\u2019t even very object-\noriented.\n\u274f   D.\t State transitions aren\u2019t explicit; they \nare buried in the middle of a bunch of \nconditional statements.\n\u274f   E.\t We haven\u2019t encapsulated anything that \nvaries here.                \n\u274f   F.\t Further additions are likely to cause bugs \nin working code.\nWhich of the following describe the state of our implementation?  \n(Choose all that apply.)\n", "page": 430, "type": "text", "section": "Page 430"}
{"text": "you are here 4\u2003 \u2003 393\nthe state pattern\nFrank: You\u2019re right about that! We need to refactor this code so that it\u2019s easy \nto maintain and modify.\nJudy: We really should try to localize the behavior for each state so that if we \nmake changes to one state, we don\u2019t run the risk of messing up the other code.\nFrank: Right; in other words, follow that ol\u2019 \u201cencapsulate what varies\u201d \nprinciple.  \nJudy: Exactly.\nFrank:: If we put each state\u2019s behavior in its own class, then every state just \nimplements its own actions.\nJudy: Right. And maybe the Gumball Machine can just delegate to the state \nobject that represents the current state.\nFrank: Ah, you\u2019re good: favor composition...more principles at work.\nJudy: Cute. Well, I\u2019m not 100% sure how this is going to work, but I think \nwe\u2019re on to something.\nFrank: I wonder if this will make it easier to add new states?\nJudy: I think so...  We\u2019ll still have to change code, but the changes will be \nmuch more limited in scope because adding a new state will mean we just \nhave to add a new class and maybe change a few transitions here and there.\nFrank: I like the sound of that. Let\u2019s start hashing out this new design!\nOkay, this isn\u2019t good. I think \nour first version was great, but it isn\u2019t \ngoing to hold up over time as Mighty Gumball \nkeeps asking for new behavior. The rate of bugs \nis just going to make us look bad, not to mention \nthe CEO will drive us crazy.\n", "page": 431, "type": "text", "section": "Page 431"}
{"text": "394\u2003 \u2003 Chapter 10\na new state design\nThe new design\n1\n2\n3\nFirst, we\u2019re going to define a State interface that \ncontains a method for every action in the Gumball \nMachine.\nThen we\u2019re going to implement a State class for \nevery state of the machine. These classes will be \nresponsible for the behavior of the machine when it \nis in the corresponding state.\nFinally, we\u2019re going to get rid of all of our conditional \ncode and instead delegate the work to the State class.\nIt looks like we\u2019ve got a new plan: instead of maintaining our existing code, we\u2019re going to \nrework it to encapsulate state objects in their own classes and then delegate to the current \nstate when an action occurs.  \nWe\u2019re following our design principles here, so we should end up with a design that is easier to \nmaintain down the road. Here\u2019s how we\u2019re going to do it:\nNot only are we following design principles, as you\u2019ll see, we\u2019re actually implementing the \nState Pattern. But we\u2019ll get to all the official State Pattern stuff after we rework our code...\nNow we\u2019re going \nto put all the behavior of a \nstate into one class. That way, \nwe\u2019re localizing the behavior and \nmaking things a lot easier to \nchange and understand.\n", "page": 432, "type": "text", "section": "Page 432"}
{"text": "you are here 4\u2003 \u2003 395\nthe state pattern\nDefining the State interfaces and classes\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\n<<interface>>\nState\nHasQuarterState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nNoQuarterState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nSoldOutState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\npublic class GumballMachine {\n \n    final static int SOLD_OUT = 0;\n    final static int NO_QUARTER = 1;\n    final static int HAS_QUARTER = 2;\n    final static int SOLD = 3;\n \n    int state = SOLD_OUT;\n    int count = 0;\n...and we map each state \ndirectly to a class. \nHere\u2019s the interface for all states. The methods map directly \nto actions that could happen to the Gumball Machine (these \nare the same methods as in the previous code).\nFirst let\u2019s create an interface for State, which all our states implement:\nT\no figure out what \nstates we need, we look \nat our previous code...\nThen take each state in our design and \nencapsulate it in a class that implements \nthe State interface.\nSoldState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nWinnerState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nDon\u2019t forget, we need a new \u201cwinner\u201d state \ntoo that implements the State interface. We\u2019ll \ncome back to this after we reimplement the \nfirst version of the Gumball Machine.\n", "page": 433, "type": "text", "section": "Page 433"}
{"text": "396\u2003 \u2003 Chapter 10\nwhat are all the states\nTo implement our states, we first need to specify the behavior of the \nclasses when each action is called. Annotate the diagram below with the \nbehavior of each action in each class; we\u2019ve already filled in a few for you.\nGo to HasQuarterState.\nT\nell the customer, \u201cYou haven\u2019t inserted a quarter.\u201d\nT\nell the customer, \u201cPlease wait, we\u2019re already giving you a gumball.\u201d\nT\nell the customer, \u201cThere are no gumballs.\u201d\nGo to SoldState.\nDispense one gumball. Check number of gumballs; if > 0, \ngo to NoQuarterState; otherwise, go to SoldOutState.\nGo ahead and fill this out even though we\u2019re implementing it later.\nNoQuarterState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nSoldOutState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nSoldState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nHasQuarterState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nWinnerState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\n", "page": 434, "type": "text", "section": "Page 434"}
{"text": "you are here 4\u2003 \u2003 397\nthe state pattern\npublic class NoQuarterState implements State {\n    GumballMachine gumballMachine;\n \n    public NoQuarterState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n \n    public void insertQuarter() {\n        System.out.println(\"You inserted a quarter\");\n        gumballMachine.setState(gumballMachine.getHasQuarterState());\n    }\n \n    public void ejectQuarter() {\n        System.out.println(\"You haven't inserted a quarter\");\n    }\n \n    public void turnCrank() {\n        System.out.println(\"You turned, but there's no quarter\");\n     }\n \n    public void dispense() {\n        System.out.println(\"You need to pay first\");\n    } \n}\nImplementing our State classes\nTime to implement a state: we know what behaviors we want; we just need to get it down in code. We\u2019re going to \nclosely follow the state machine code we wrote, but this time everything is broken out into different classes.  \nLet\u2019s start with the NoQuarterState:\nFirst we need to implement the State interface.\nWe get passed a reference to \nthe Gumball Machine through the \nconstructor. We\u2019re just going to \nstash this in an instance variable.\nIf someone inserts a quarter, \nwe print a message saying the \nquarter was accepted and then \nchange the machine\u2019s state to \nthe HasQuarterState.\nYou can\u2019t get money \nback if you never gave \nit to us!\nAnd you can\u2019t get a gumball \nif you don\u2019t pay us.\nWhat we\u2019re doing is \nimplementing the behaviors that \nare appropriate for the state \nwe\u2019re in. In some cases, this behavior \nincludes moving the Gumball \nMachine to a new state.\nWe can\u2019t be dispensing \ngumballs without payment.\nYou\u2019ll see how these \nwork in just a sec...\n", "page": 435, "type": "text", "section": "Page 435"}
{"text": "398\u2003 \u2003 Chapter 10\nstate objects in the gumball machine\nIn the GumballMachine, we update the \ncode to use the new classes rather than \nthe static integers. The code is quite \nsimilar, except that in one class we have \nintegers and in the other objects...\nBefore we finish the State classes, we\u2019re going to rework the Gumball \nMachine\u2014that way, you can see how it all fits together. We\u2019ll start \nwith the state-related instance variables and switch the code from \nusing integers to using state objects:\nReworking the Gumball Machine\nOld code\nNew code\nAll the State objects are created \nand assigned in the constructor.\nThis now holds a \nState object, not \nan integer.\npublic class GumballMachine {\n \n    final static int SOLD_OUT = 0;\n    final static int NO_QUARTER = 1;\n    final static int HAS_QUARTER = 2;\n    final static int SOLD = 3;\n \n    int state = SOLD_OUT;\n    int count = 0;\npublic class GumballMachine {\n \n    State soldOutState;\n    State noQuarterState;\n    State hasQuarterState;\n    State soldState;\n \n    State state = soldOutState;\n    int count = 0;\n", "page": 436, "type": "text", "section": "Page 436"}
{"text": "you are here 4\u2003 \u2003 399\nthe state pattern\npublic class GumballMachine {\n \n    State soldOutState;\n    State noQuarterState;\n    State hasQuarterState;\n    State soldState;\n \n    State state;\n    int count = 0;\n \n    public GumballMachine(int numberGumballs) {\n        soldOutState = new SoldOutState(this);\n        noQuarterState = new NoQuarterState(this);\n        hasQuarterState = new HasQuarterState(this);\n        soldState = new SoldState(this);\n        this.count = numberGumballs;\n        if (numberGumballs > 0) {\n            state = noQuarterState;\n        } else {\n            state = soldOutState;\n        }\n    }\n \n    public void insertQuarter() {\n        state.insertQuarter();\n    }\n    public void ejectQuarter() {\n        state.ejectQuarter();\n    }\n    public void turnCrank() {\n        state.turnCrank();\n        state.dispense();\n    }\n    void setState(State state) {\n        this.state = state;\n    }\n \n    void releaseBall() {\n        System.out.println(\"A gumball comes rolling out the slot...\");\n        if (count > 0) {\n            count = count - 1;\n        }\n    }\n    // More methods here including getters for each State...\n}\nNow, let\u2019s look at the complete GumballMachine class...\nHere are all the States again...\n...and the State instance variable.\nThe count instance variable holds the count \nof gumballs\u2009\u2014\u2009initially the machine is empty.\nOur constructor takes the initial \nnumber of gumballs and stores it \nin an instance variable.\nIt also creates the State \ninstances, one of each.\nIf there are more than 0 gumballs we \nset the state to the NoQuarterState; \notherwise, we start in the SoldOutState.\nNow for the actions. These are \nVERY EASY to implement now. We \njust delegate to the current state.\nNote that we don\u2019t need an \naction method for dispense() in \nGumballMachine because it\u2019s just an \ninternal action; a user can\u2019t ask the \nmachine to dispense directly. But we \ndo call dispense() on the State object \nfrom the turnCrank() method.\nThe machine supports a releaseBall() \nhelper method that releases the ball and \ndecrements the count instance variable.\nThis method allows other objects (like \nour State objects) to transition the \nmachine to a different state.\nThis includes methods like getNoQuarterState() for getting each \nstate object, and getCount() for getting the gumball count.\n", "page": 437, "type": "text", "section": "Page 437"}
{"text": "400\u2003 \u2003 Chapter 10\nmore states for the gumball machine\npublic class HasQuarterState implements State {\n    GumballMachine gumballMachine;\n \n    public HasQuarterState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n  \n    public void insertQuarter() {\n        System.out.println(\"You can't insert another quarter\");\n    }\n \n    public void ejectQuarter() {\n        System.out.println(\"Quarter returned\");\n        gumballMachine.setState(gumballMachine.getNoQuarterState());\n    }\n \n    public void turnCrank() {\n        System.out.println(\"You turned...\");\n        gumballMachine.setState(gumballMachine.getSoldState());\n    }\n    public void dispense() {\n        System.out.println(\"No gumball dispensed\");\n    }\n}\nImplementing more states\nNow that you\u2019re starting to get a feel for how the Gumball Machine and the states \nfit together, let\u2019s implement the HasQuarterState and the SoldState classes...\nAn inappropriate \naction for this \nstate.\nAnother \ninappropriate \naction for this \nstate.\nReturn the customer\u2019s \nquarter and \ntransition back to the \nNoQuarterState.\nWhen the crank is \nturned we transition \nthe machine to the \nSoldState state by \ncalling its setState() \nmethod and passing it \nthe SoldState object. \n \nThe SoldState object \nis retrieved by the \ngetSoldState() \ngetter method  \n(there is one of these \ngetter methods for \neach state).\nWhen the state is instantiated \nwe pass it a reference to the \nGumballMachine. This is used \nto transition the machine to a \ndifferent state.\n", "page": 438, "type": "text", "section": "Page 438"}
{"text": "you are here 4\u2003 \u2003 401\nthe state pattern\npublic class SoldState implements State {\n    //constructor and instance variables here\n \n    public void insertQuarter() {\n        System.out.println(\"Please wait, we're already giving you a gumball\");\n    }\n \n    public void ejectQuarter() {\n        System.out.println(\"Sorry, you already turned the crank\");\n    }\n \n    public void turnCrank() {\n        System.out.println(\"Turning twice doesn't get you another gumball!\");\n    }\n \n    public void dispense() {\n        gumballMachine.releaseBall();\n        if (gumballMachine.getCount() > 0) {\n            gumballMachine.setState(gumballMachine.getNoQuarterState());\n        } else {\n            System.out.println(\"Oops, out of gumballs!\");\n            gumballMachine.setState(gumballMachine.getSoldOutState());\n        }\n    }\n}\nNow, let\u2019s check out the SoldState class...\nHere are all the \ninappropriate \nactions for this \nstate.\nAnd here\u2019s where the \nreal work begins...\nWe\u2019re in the SoldState, which means the \ncustomer paid. So, we first need to ask \nthe machine to release a gumball.\nThen we ask the machine what the gumball \ncount is, and either transition to the \nNoQuarterState or the SoldOutState.\nLook back at the GumballMachine implementation. If the crank is turned and \nnot successful (say the customer didn\u2019t insert a quarter first), we call dispense() \nanyway, even though it\u2019s unnecessary. How might you fix this?\n", "page": 439, "type": "text", "section": "Page 439"}
{"text": "402\u2003 \u2003 Chapter 10\nyour turn to implement a state\npublic class SoldOutState implements _______________  {\n    GumballMachine gumballMachine;\n \n    public SoldOutState(GumballMachine gumballMachine) {\n    }\n \n    public void insertQuarter() {\n    }\n \n    public void ejectQuarter() {\n    }\n    public void turnCrank() {\n    }\n    public void dispense() {\n    }\n}\nWe have one remaining class we haven\u2019t implemented: SoldOutState.  \nWhy don\u2019t you implement it? To do this, carefully think through how the \nGumball Machine should behave in each situation. Check your answer \nbefore moving on...\n", "page": 440, "type": "text", "section": "Page 440"}
{"text": "you are here 4\u2003 \u2003 403\nthe state pattern\nFor starters, you now have a Gumball Machine implementation that is structurally quite \ndifferent from your first version, and yet functionally it is exactly the same. By structurally \nchanging the implemention, you\u2019ve:\n\u2003\n\u0083\nLocalized the behavior of each state into its own class.\n\u2003\n\u0083\nRemoved all the troublesome if statements that would have been difficult to maintain.\n\u2003\n\u0083\nClosed each state for modification, and yet left the Gumball Machine open to extension \nby adding new state classes (and we\u2019ll do this in a second).\n\u2003\n\u0083\nCreated a code base and class structure that maps much more closely to the Mighty \nGumball diagram and is easier to read and understand.\nNow let\u2019s look a little more at the functional aspect of what we did:\nLet\u2019s take a look at what we\u2019ve done so far...\nGumball Machine States\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\ncurrent state\nThe Gumball Machine now holds an \ninstance of each State class.\nThe current state of the \nmachine is always one of \nthese class instances.\n", "page": 441, "type": "text", "section": "Page 441"}
{"text": "404\u2003 \u2003 Chapter 10\nstate transitions\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nGumball Machine States\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nGumball Machine States\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\ncurrent state\nturnCrank()\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\ncurrent state\nWhen an action is called, it is \ndelegated to the current state.\nIn this case, the turnCrank() \nmethod is being called when the \nmachine is in the HasQuarter \nstate, so as a result the machine \ntransitions to the Sold state.\n....and then the \nmachine will \neither go to \nthe SoldOut \nor NoQuarter \nstate depending \non the number of \ngumballs remaining \nin the machine.\nThe machine enters \nthe Sold state and a \ngumball is dispensed...\nturnCrank()\nMore gumballs\nSold out\nTRANSITION TO SOLD STATE\ndispense()\n", "page": 442, "type": "text", "section": "Page 442"}
{"text": "you are here 4\u2003 \u2003 405\nthe state pattern\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nGumball Machine States\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nGumball Machine States\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nGumball Machine States\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nGumball Machine States\n1\n2\n4\n3\nBehind the Scenes: \nSelf-Guided Tour\nTrace the steps of the Gumball Machine starting with the NoQuarter state. Also annotate the diagram with actions \nand output of the machine. For this exercise you can assume there are plenty of gumballs in the machine.\n", "page": 443, "type": "text", "section": "Page 443"}
{"text": "406\u2003 \u2003 Chapter 10\nstate pattern defined\nThe State Pattern defined\nThe State Pattern allows an object to alter its behavior \nwhen its internal state changes. The object will appear to \nchange its class.\nrequest()\nContext\nYes, it\u2019s true, we just implemented the State Pattern! So now, let\u2019s take a look at what it\u2019s all about:\nThe first part of this description makes a lot of sense, right? Because the pattern encapsulates \nstate into separate classes and delegates to the object representing the current state, we know \nthat behavior changes along with the internal state. The Gumball Machine provides a good \nexample: when the gumball machine is in the NoQuarterState and you insert a quarter, you get \ndifferent behavior (the machine accepts the quarter) than if you insert a quarter when it\u2019s in the \nHasQuarterState (the machine rejects the quarter).\nWhat about the second part of the definition? What does it mean for an object to \u201cappear to \nchange its class\u201d? Think about it from the perspective of a client: if an object you\u2019re using can \ncompletely change its behavior, then it appears to you that the object is actually instantiated from \nanother class. In reality, however, you know that we are using composition to give the appearance \nof a class change by simply referencing different state objects.\nOkay, now it\u2019s time to check out the State Pattern class diagram:\nstate.handle()\nhandle()\nState\nhandle()\nConcreteStateA\nhandle()\nConcreteStateB\nMany concrete \nstates are possible.\nThe Context is the class that  \ncan have a number of internal \nstates. In our example, the \nGumballMachine is the Context.\nWhenever the request() is \nmade on the Context\u200a\n, it \nis delegated to the state \nto handle.\nThe State interface defines a common \ninterface for all concrete states; the \nstates all implement the same interface, \nso they are interchangeable.\nConcreteStates handle requests from the \nContext. Each ConcreteState provides its \nown implementation for a request. In this \nway, when the Context changes state, its \nbehavior will change as well.\n", "page": 444, "type": "text", "section": "Page 444"}
{"text": "you are here 4\u2003 \u2003 407\nthe state pattern\nYou\u2019ve got a good eye (or you read the beginning of the chapter)! \nYes, the class diagrams are essentially the same, but the two patterns \ndiffer in their intent. \nWith the State Pattern, we have a set of behaviors encapsulated in \nstate objects; at any time the context is delegating to one of those \nstates. Over time, the current state changes across the set of state \nobjects to reflect the internal state of the context, so the context\u2019s \nbehavior changes over time as well. The client usually knows very \nlittle, if anything, about the state objects.  \nWith Strategy, the client usually specifies the strategy object that \nthe context is composed with. Now, while the pattern provides the \nflexibility to change the strategy object at runtime, often there is \na strategy object that is most appropriate for a context object. For \ninstance, in Chapter 1, some of our ducks were configured to fly \nwith typical flying behavior (like mallard ducks), while others were \nconfigured with a fly behavior that kept them grounded (like rubber \nducks and decoy ducks).\nIn general, think of the Strategy Pattern as a flexible alternative to \nsubclassing; if you use inheritance to define the behavior of a class, \nthen you\u2019re stuck with that behavior even if you need to change it. \nWith Strategy you can change the behavior by composing with a \ndifferent object.\nThink of the State Pattern as an alternative to putting lots of \nconditionals in your context; by encapsulating the behaviors within \nstate objects, you can simply change the state object in context to \nchange its behavior.\nWait a sec; from what \nI remember of the Strategy \nPattern, this class diagram is \nEXACTLY the same.\n", "page": 445, "type": "text", "section": "Page 445"}
{"text": "408\u2003 \u2003 Chapter 10\nq&a about the state pattern\nQ: In GumballMachine, the states decide what the \nnext state should be. Do the ConcreteStates always \ndecide what state to go to next?\nA: No, not always. The alternative is to let the Context \ndecide on the flow of state transitions.  \nAs a general guideline, when the state transitions are fixed \nthey are appropriate for putting in the Context; however, \nwhen the transitions are more dynamic, they are typically \nplaced in the state classes themselves (for instance, in \nGumballMachine the choice of the transition to NoQuarter or \nSoldOut depended on the runtime count of gumballs).\nThe disadvantage of having state transitions in the state \nclasses is that we create dependencies between the state \nclasses. In our implementation of GumballMachine we tried \nto minimize this by using getter methods on the Context, \nrather than hardcoding explicit concrete state classes.\nNotice that by making this decision, you are making a \ndecision as to which classes are closed for modification\u2014\nthe Context or the state classes\u2014as the system evolves.\nQ: Do clients ever interact directly with the states?\nA: No. The states are used by the Context to represent \nits internal state and behavior, so all requests to the states \ncome from the Context. Clients don\u2019t directly change the \nstate of the Context. It is the Context\u2019s job to oversee its \nstate, and you don\u2019t usually want a client changing the state \nof a Context without that Context\u2019s knowledge. \nQ: If I have lots of instances of the Context in my \napplication, is it possible to share the state objects \nacross them?\nA: Yes, absolutely, and in fact this is a very common \nscenario. The only requirement is that your state objects do \nnot keep their own internal context; otherwise, you\u2019d need a \nunique instance per context.\n\nTo share your states, you\u2019ll typically assign each state to a \nstatic instance variable. If your state needs to make use of \nmethods or instance variables in your Context, you\u2019ll also \nhave to give it a reference to the Context in each handler() \nmethod.\nQ: It seems like using the State Pattern always \nincreases the number of classes in our designs. Look \nhow many more classes our GumballMachine had than \nthe original design! \nA: You\u2019re right; by encapsulating state behavior \ninto separate state classes, you\u2019ll always end up with \nmore classes in your design. That\u2019s often the price you \npay for flexibility. Unless your code is some \u201cone-off\u201d \nimplementation you\u2019re going to throw away (yeah, right), \nconsider building it with the additional classes and you\u2019ll \nprobably thank yourself down the road. Note that often what \nis important is the number of classes that you expose to \nyour clients, and there are ways to hide these extra classes \nfrom your clients (say, by declaring them package private).\nAlso, consider the alternative: if you have an application \nthat has a lot of state and you decide not to use separate \nobjects, you\u2019ll instead end up with very large, monolithic \nconditional statements. This makes your code hard to \nmaintain and understand. By using objects, you make states \nexplicit and reduce the effort needed to understand and \nmaintain your code. \nQ: The State Pattern class diagram shows that State \nis an abstract class. But didn\u2019t you use an interface in \nthe implementation of the gumball machine\u2019s state?\nA: Yes. Given we had no common functionality to put \ninto an abstract class, we went with an interface. In your \nown implementation, you might want to consider an abstract \nclass. Doing so has the benefit of allowing you to add \nmethods to the abstract class later, without breaking the \nconcrete state implementations.\n", "page": 446, "type": "text", "section": "Page 446"}
{"text": "you are here 4\u2003 \u2003 409\nthe state pattern\npublic class WinnerState implements State {\n \n    // instance variables and constructor\n    // insertQuarter error message\n    // ejectQuarter error message\n    // turnCrank error message\n \n    public void dispense() {\n        gumballMachine.releaseBall();\n        if (gumballMachine.getCount() == 0) {\n            gumballMachine.setState(gumballMachine.getSoldOutState());\n        } else {\n            gumballMachine.releaseBall();\n            System.out.println(\"YOU'RE A WINNER! You got two gumballs for your quarter\");\n            if (gumballMachine.getCount() > 0) {\n                gumballMachine.setState(gumballMachine.getNoQuarterState());\n            } else {\n                System.out.println(\"Oops, out of gumballs!\");\n                gumballMachine.setState(gumballMachine.getSoldOutState());\n            }\n        }\n    }\n}\npublic class GumballMachine {\n \n    State soldOutState;\n    State noQuarterState;\n    State hasQuarterState;\n    State soldState;\n    State winnerState;\n \n    State state = soldOutState;\n    int count = 0;\n    // methods here\n}\nWe still need to finish the Gumball 1 in 10 game\nRemember, we\u2019re not done yet. We\u2019ve got a game to implement, but now that we\u2019ve got the State \nPattern implemented, it should be a breeze. First, we need to add a state to the GumballMachine class:\nAll you need to add here is \nthe new WinnerState and \ninitialize it in the constructor.\nNow let\u2019s implement the WinnerState class; it\u2019s remarkably similar to the SoldState class:\nHere we release two gumballs and then \neither go to the NoQuarterState or \nthe SoldOutState.\nJust like SoldState.\nIf we have a second gumball, we release it.\nDon\u2019t forget you also have \nto add a getter method for \nWinnerState too.\nIf we were able \nto release two \ngumballs, we let \nthe user know \nhe was a winner.\n", "page": 447, "type": "text", "section": "Page 447"}
{"text": "410\u2003 \u2003 Chapter 10\nimplementing the 1 in 10 game\npublic class HasQuarterState implements State {\n    Random randomWinner = new Random(System.currentTimeMillis());\n    GumballMachine gumballMachine;\n \n    public HasQuarterState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n  \n    public void insertQuarter() {\n        System.out.println(\"You can't insert another quarter\");\n    }\n \n    public void ejectQuarter() {\n        System.out.println(\"Quarter returned\");\n        gumballMachine.setState(gumballMachine.getNoQuarterState());\n    }\n \n    public void turnCrank() {\n        System.out.println(\"You turned...\");\n        int winner = randomWinner.nextInt(10);\n        if ((winner == 0) && (gumballMachine.getCount() > 1)) {\n            gumballMachine.setState(gumballMachine.getWinnerState());\n        } else {\n            gumballMachine.setState(gumballMachine.getSoldState());\n        }\n    }\n    public void dispense() {\n        System.out.println(\"No gumball dispensed\");\n    }\n}\nFirst we add a \nrandom number \ngenerator to \ngenerate the 10% \nchance of winning...\nFinishing the game\nWe\u2019ve got just one more change to make: we need to implement the random \nchance game and add a transition to the WinnerState. We\u2019re going to add both to \nthe HasQuarterState since that\u2019s where the customer turns the crank:\n...then we determine \nif this customer won.\nWow, that was pretty simple to implement! We just added a new state to the GumballMachine \nand then implemented it. All we had to do from there was to implement our chance game and \ntransition to the correct state. It looks like our new code strategy is paying off...\nIf they won, and there\u2019s enough gumballs \nleft for them to get two, we go to \nWinnerState; otherwise, we go to \nSoldState (just like we always did).\n", "page": 448, "type": "text", "section": "Page 448"}
{"text": "you are here 4\u2003 \u2003 411\nthe state pattern\npublic class GumballMachineTestDrive {\n    public static void main(String[] args) {\n        GumballMachine gumballMachine = new GumballMachine(5);\n        System.out.println(gumballMachine);\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        System.out.println(gumballMachine);\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        System.out.println(gumballMachine);\n    }\n}\nDemo for the CEO of Mighty Gumball, Inc.\nThe CEO of Mighty Gumball has dropped by for a demo of your new gumball game code. Let\u2019s \nhope those states are all in order! We\u2019ll keep the demo short and sweet (the short attention span of \nCEOs is well documented), but hopefully long enough so that we\u2019ll win at least once.  \nThis code really hasn\u2019t changed at all; \nwe just shortened it a bit.\nOnce, again, start with a gumball \nmachine with 5 gumballs.\nWe want to get a winning state, \nso we just keep pumping in those \nquarters and turning the crank. We \nprint out the state of the gumball \nmachine every so often...\nThe whole engineering team is waiting \noutside the conference room to see \nif the new State Pattern-based \ndesign is going to work!!\n", "page": 449, "type": "text", "section": "Page 449"}
{"text": "412\u2003 \u2003 Chapter 10\ntesting the gumball machine\nFile  Edit   Window  Help  Whenisagumballajawbreaker?\n%java GumballMachineTestDrive\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 5 gumballs\nMachine is waiting for quarter\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot...\nA gumball comes rolling out the slot...\nYOU'RE A WINNER! You got two gumballs for your quarter\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 3 gumballs\nMachine is waiting for quarter\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot...\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot...\nA gumball comes rolling out the slot...\nYOU'RE A WINNER! You got two gumballs for your quarter\nOops, out of gumballs!\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 0 gumballs\nMachine is sold out\n%\nGee, did we get lucky \nor what? In our demo \nto the CEO, we won \nnot once, but twice!\nYes! That rocks!\nQ: Why do we need the WinnerState? Couldn\u2019t we just have the SoldState dispense two gumballs?\nA: That\u2019s a great question. SoldState and WinnerState are almost identical, except that WinnerState dispenses two \ngumballs instead of one. You certainly could put the code to dispense two gumballs into SoldState. The downside is, of \ncourse, that now you\u2019ve got TWO states represented in one State class: the state in which you\u2019re a winner, and the state \nin which you\u2019re not. So you are sacrificing clarity in your State class to reduce code duplication. Another thing to consider \nis the principle you learned in the previous chapter: the Single Responsibility Principle. By putting the WinnerState \nresponsibility into the SoldState, you\u2019ve just given the SoldState TWO responsibilities. What happens when the \npromotion ends? Or the stakes of the contest change? So, it\u2019s a tradeoff and comes down to a design decision.\n", "page": 450, "type": "text", "section": "Page 450"}
{"text": "you are here 4\u2003 \u2003 413\nthe state pattern\nBravo! Great job, \ngang. Our sales are already \ngoing through the roof with the new \ngame. You know, we also make soda \nmachines, and I was thinking we could put \none of those slot-machine arms on the \nside and make that a game too. We\u2019ve got \nfour-year-olds gambling with the \ngumball machines; why stop there?\nSanity check...\nYes, the CEO of Mighty Gumball probably needs a sanity check, but that\u2019s not what \nwe\u2019re talking about here. Let\u2019s think through some aspects of the GumballMachine \nthat we might want to shore up before we ship the gold version:\n\u2003\n\u0083\nWe\u2019ve got a lot of duplicate code in the Sold and Winning \nstates and we might want to clean those up. How would we \ndo it? We could make State into an abstract class and build \nin some default behavior for the methods; after all, error \nmessages like, \u201cYou already inserted a quarter,\u201d aren\u2019t going \nto be seen by the customer. So all \u201cerror response\u201d behavior \ncould be generic and inherited from the abstract State class.\n\u2003\n\u0083\nThe dispense() method always gets called, even if the crank is \nturned when there is no quarter. While the machine operates \ncorrectly and doesn\u2019t dispense unless it\u2019s in the right state, we \ncould easily fix this by having turnCrank() return a boolean \nor by introducing exceptions. Which do you think is a better \nsolution?\n\u2003\n\u0083\nAll of the intelligence for the state transitions is in the State \nclasses. What problems might this cause? Would we want to \nmove that logic into the GumballMachine? What would be \nthe advantages and disadvantages of that?\n\u2003\n\u0083\nWill you be instantiating a lot of GumballMachine objects?  \nIf so, you may want to move the state instances into static \ninstance variables and share them. What changes would this \nrequire to the GumballMachine and the States?\nDammit Jim, \nI\u2019m a gumball \nmachine, not a \ncomputer!\n", "page": 451, "type": "text", "section": "Page 451"}
{"text": "414\u2003 \u2003 Chapter 10\nfireside chats: state and strategy\nTonight\u2019s talk: A Strategy and State Pattern Reunion.\nStrategy:\nHey, bro. Did you hear I was in Chapter 1?\n\n\nI was just over giving the Template Method guys a \nhand\u2014they needed me to help them finish off their \nchapter. So, anyway, what is my noble brother up to?\n\n\nI don\u2019t know, you always sound like you\u2019ve just \ncopied what I do and you\u2019re using different words \nto describe it. Think about it: I allow objects to \nincorporate different behaviors or algorithms \nthrough composition and delegation. You\u2019re just \ncopying me.\n\n\nOh yeah? How so? I don\u2019t get it. \n\nYeah, that was some fine work...and I\u2019m sure you can \nsee how that\u2019s more powerful than inheriting your \nbehavior, right?\n\nSorry, you\u2019re going to have to explain that.\nState:\nYeah, word is definitely getting around.\n\n\n\nSame as always\u2014helping classes to exhibit different \nbehaviors in different states.\n\n\n\n\n\n\nI admit that what we do is definitely related, but my \nintent is totally different than yours. And the way I \nteach my clients to use composition and delegation \nis totally different.\nWell, if you spent a little more time thinking about \nsomething other than yourself, you might. Anyway,  \nthink about how you work: you have a class you\u2019re \ninstantiating and you usually give it a strategy object \nthat implements some behavior. Like, in Chapter 1 \nyou were handing out quack behaviors, right? Real \nducks got a real quack; rubber ducks got a quack \nthat squeaked.\n\n\nYes, of course. Now, think about how I work; it\u2019s \ntotally different.\n", "page": 452, "type": "text", "section": "Page 452"}
{"text": "you are here 4\u2003 \u2003 415\nthe state pattern\nStrategy:\n\n\nHey, come on, I can change behavior at runtime \ntoo; that\u2019s what composition is all about!\n\n\n\n\n\n\nWell, I admit, I don\u2019t encourage my objects to have \na well-defined set of transitions between states. In \nfact, I typically like to control what strategy my \nobjects are using.\n\n\n\n\nYeah, yeah, keep living your pipe dreams, brother.  \nYou act like you\u2019re a big pattern like me, but check \nit out: I\u2019m in Chapter 1; they stuck you way out in \nChapter 10. I mean, how many people are actually \ngoing to read this far?\n\n\n\n\nThat\u2019s my brother, always the dreamer.\nState:\nOkay, when my Context objects get created, I may \ntell them the state to start in, but then they change \ntheir own state over time.\n\n\n\nSure you can, but the way I work is built around \ndiscrete states; my Context objects change state \nover time according to some well-defined state \ntransitions.  In other words, changing behavior is \nbuilt in to my scheme\u2014it\u2019s how I work!\n\n\n\n\n\nLook, we\u2019ve already said we\u2019re alike in structure, but \nwhat we do is quite different in intent. Face it, the \nworld has uses for both of us.\n\n\n\n\n\n\nAre you kidding? This is a Head First book and \nHead First readers rock. Of course they\u2019re going to \nget to Chapter 10!\n", "page": 453, "type": "text", "section": "Page 453"}
{"text": "416\u2003 \u2003 Chapter 10\nrefill exercise\nWe almost forgot!\nMighty Gumball, Inc.\nWhere the Gumball Machine \nis Never Half Empty\nGumball \n  Sold\n   No \nQuarter\n   Has \nQuarter\nOut of \nGumballs\nThere\u2019s one transition we forgot to put in the original spec...we \nneed a way to refill the gumball machine when it\u2019s out of gumballs!  \nHere\u2019s the new diagram\u2009\u2014\u2009can you implement it for us? You did such \na good job on the rest of the gumball machine we have no doubt \nyou can add this in a jiffy!\n               - The Mighty Gumball Engineers\ninsert quarter\neject quarter\nturn crank\ndispense \ngumball\ngumballs = 0\ngumballs > 0\nrefill\n", "page": 454, "type": "text", "section": "Page 454"}
{"text": "you are here 4\u2003 \u2003 417\nthe state pattern\nYou\u2019ve done some amazing work! \nI\u2019ve got some more ideas that \nare going to change the gumball \nindustry and I need you to implement \nthem. Shhhhh! I\u2019ll let you in on these \nideas in the next chapter.\nWe need you to write the refill() method for the Gumball machine.  It has one \nargument\u2014the number of gumballs you\u2019re adding to the machine\u2014and \nshould update the gumball machine count and reset the machine\u2019s state.\n", "page": 455, "type": "text", "section": "Page 455"}
{"text": "418\u2003 \u2003 Chapter 10\nwho does what?\nPattern\nDescription\nState\nStrategy\nTemplate Method\nEncapsulate interchangeable \nbehaviors and use delegation to \ndecide which behavior to use.\nSubclasses decide how \nto implement steps in an \nalgorithm.\nEncapsulate state-based \nbehavior and delegate \nbehavior to the current state.\nMatch each pattern with its description:\n", "page": 456, "type": "text", "section": "Page 456"}
{"text": "you are here 4\u2003 \u2003 419\nthe state pattern\nTools for your Design Toolbox\nIt\u2019s the end of another chapter; you\u2019ve got enough \npatterns here to breeze through any job interview!\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable.  Strategy lets the algorithm \nvary independently from clients that use it.\nOO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically.  \nDecorators provide a flexible \nalternative to subclassing for extending \nfunctionality.\nAbstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes.\nFactory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate.  Factory Method lets \na class defer instantiation to the \nsubclasses.\nSingleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it.\nCommand - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nAdapter - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nNo new principles this \nchapter. That gives you \ntime to sleep on them.\nFacade - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nHere\u2019s our new \npattern. If you\u2019re \nmanaging state in \na class, the State \nPattern gives you \na technique for \nencapsulating that \nstate.\nState - Allow an object to alter its \nbehavior when its internal state changes. \n \nThe object will appear to change its \nclass.\nEncapsulate what varies.\nFavor composition over inheritance.\nProgram to interfaces, not \nimplementations.\nStrive for loosely coupled designs \nbetween objects that interact.\nClasses should be open for extension \nbut closed for modification.\nDepend on abstractions. Do not \ndepend on concrete classes.\nOnly talk to your friends.\nDon\u2019t call us, we\u2019ll call you.\nA class should have only one reason \nto change.\nOO Principles\n\t\n\u0083\nThe State Pattern allows an \nobject to have many different \nbehaviors that are based on \nits internal state.\n\t\n\u0083\nUnlike a procedural state \nmachine, the State Pattern \nrepresents each state as a \nfull-blown class.\n\t\n\u0083\nThe Context gets its behavior \nby delegating to the current \nstate object it is composed \nwith.\n\t\n\u0083\nBy encapsulating each state \ninto a class, we localize any \nchanges that will need to be \nmade.\n\t\n\u0083\nThe State and Strategy \nPatterns have the same class \ndiagram, but they differ in \nintent.\n\t\n\u0083\nThe Strategy Pattern typically \nconfigures Context classes \nwith a behavior or algorithm.\n\t\n\u0083\nThe State Pattern allows \na Context to change its \nbehavior as the state of the \nContext changes.\n\t\n\u0083\nState transitions can be \ncontrolled by the State \nclasses or by the Context \nclasses.\n\t\n\u0083\nUsing the State Pattern will \ntypically result in a greater \nnumber of classes in your \ndesign.\n\t\n\u0083\nState classes may be shared \namong Context instances.\n", "page": 457, "type": "text", "section": "Page 457"}
{"text": "420\u2003 \u2003 Chapter 10\nexercise solutions\nOut of \nGumballs\n   Has \nQuarter\n   No \nQuarter\ninsert quarter\neject quarter\nturn crank, no winner\nWinner\nturn crank, we \nhave a winner!\nMighty Gumball, Inc.\nWhere the Gumball Machine \nis Never Half Empty\nGumball \n  Sold\ndispense \ngumball\ngumballs = 0\ngumballs > 0\ngumballs = 0\ngumballs > 0\ndispense 2 \ngumballs\nDraw a state diagram for a Gumball Machine that handles the 1-in-10 \ncontest. In this contest, 10% of the time the Sold state leads to two \nballs being released, not one. Here\u2019s our solution.\nDesign Puzzle Solution\n", "page": 458, "type": "text", "section": "Page 458"}
{"text": "you are here 4\u2003 \u2003 421\nthe state pattern\nWhich of the following describe the state of our implementation?  \n(Choose all that apply.) Here\u2019s our solution.\nWe have one remaining class we haven\u2019t implemented: SoldOutState. Why \ndon\u2019t you implement it? To do this, carefully think through how the Gumball \nMachine should behave in each situation. Here\u2019s our solution.\npublic class SoldOutState implements State {\n    GumballMachine gumballMachine;\n \n    public SoldOutState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n \n    public void insertQuarter() {\n        System.out.println(\"You can't insert a quarter, the machine is sold out\");\n    }\n \n    public void ejectQuarter() {\n        System.out.println(\"You can't eject, you haven't inserted a quarter yet\");\n    }\n \n    public void turnCrank() {\n        System.out.println(\"You turned, but there are no gumballs\");\n    }\n \n    public void dispense() {\n        System.out.println(\"No gumball dispensed\");\n    }\n}\nIn the Sold Out state, we really \ncan\u2019t do anything until someone \nrefills the Gumball Machine.\n\u274f   A.\t This code certainly isn\u2019t adhering to the \nOpen Closed Principle.\n\u274f   B.\t This code would make a FORTRAN \nprogrammer proud.\n\u274f   C.\t This design isn\u2019t even very object-\noriented.\n\u274f   D.\t State transitions aren\u2019t explicit; they \nare buried in the middle of a bunch of \nconditional statements.\n\u274f   E.\t We haven\u2019t encapsulated anything that \nvaries here.                \n\u274f   F.\t Further additions are likely to cause bugs \nin working code.\n", "page": 459, "type": "text", "section": "Page 459"}
{"text": "422\u2003 \u2003 Chapter 10\nexercise solutions\nGo to HasQuarterState.\nT\nell the customer, \u201cYou haven\u2019t inserted a quarter.\u201d\nT\nell the customer, \u201cPlease wait, we\u2019re already giving you a gumball.\u201d\nT\nell the customer, \u201cSorry, you already turned the crank.\u201d\nT\nell the customer, \u201cTurning twice doesn\u2019t get you another gumball.\u201d\nT\nell the customer, \u201cThe machine is sold out.\u201d\nT\nell the customer, \u201cYou haven\u2019t inserted a quarter yet.\u201d\nT\nell the customer, \u201cYou can\u2019t insert another quarter.\u201d\nT\nell the customer, \u201cThere are no gumballs.\u201d\nGo to SoldState.\nGive back quarter, go to NoQuarter state.\nT\nell the customer, \u201cYou turned, but there\u2019s no quarter.\u201d\nNoQuarterState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nSoldOutState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nSoldState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nHasQuarterState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nT\nell the customer, \u201cYou need to pay first.\u201d\nT\nell the customer, \u201cNo gumball dispensed.\u201d\nDispense one gumball. Check number of gumballs; if > 0, go \nto NoQuarter state; otherwise, go to SoldOut state.\nT\nell the customer, \u201cNo gumball dispensed.\u201d\nT\nell the customer, \u201cPlease wait, we\u2019re already giving you a gumball.\u201d\nT\nell the customer, \u201cSorry, you already turned the crank.\u201d\nT\nell the customer, \u201cTurning twice doesn\u2019t get you another gumball.\u201d\nWinnerState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nDispense two gumballs. Check number of gumballs; if > 0, \ngo to NoQuarter state; otherwise, go to SoldOutState.\nTo implement the states, we first need to define what the behavior will \nbe when the corresponding action is called. Annotate the diagram below \nwith the behavior of each action in each class; here\u2019s our solution.\n", "page": 460, "type": "text", "section": "Page 460"}
{"text": "you are here 4\u2003 \u2003 423\nthe state pattern\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\n \n \n \n \n \n \n \n \nS\no\nl\nd\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\n \n \n \n \n \n \n \n \nS\no\nl\nd\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \n \n \n \n \nS\no\nl\nd\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\n \n \n \n \n \n \n \n \nS\no\nl\nd\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\nGumball Machine States\nGumball Machine States\nGumball Machine States\nGumball Machine States\n1\n2\n4\n3\ncurrent state\ncurrent state\ncurrent state\ncurrent state\nBehind the Scenes: \nSelf-Guided Tour \nSolution\ninsertQuarter()\ninsertQuarter()\ndelegates to \ncurrent state\nturnCrank()\nturnCrank()\ndelegates\ntransitions to \nHasQuarter state\nmachine action\nmachine action\ntransitions to \nSold state\ndispense()\nHere the machine \ngives out a gumball \nby calling the internal \ndispense() action...\n...and then transitions \nto NoQuarter.\n", "page": 461, "type": "text", "section": "Page 461"}
{"text": "424\u2003 \u2003 Chapter 10\nexercise solutions\npublic void refill() { \n    gumballMachine.setState(gumballMachine.getNoQuarterState());\n}\nPattern\nDescription\nState\nStrategy\nTemplate Method\nEncapsulate interchangeable \nbehaviors and use delegation to \ndecide which behavior to use.\nSubclasses decide how \nto implement steps in an \nalgorithm.\nEncapsulate state-based \nbehavior and delegate \nbehavior to the current state.\nMatch each pattern with its description:\nSOlUTion\nTo refill the Gumball Machine, we add a refill() method to the State interface, \nwhich each State must implement. In every state except SoldOutState, the \nmethod does nothing. In SoldOutState, refill() transitions to NoQuarterState. \nWe also add a refill() method to GumballMachine that adds to the count of \ngumballs, and then calls the current state\u2019s refill() method.\nvoid refill(int count) {\n    this.count += count;\n    System.out.println(\"The gumball machine was just refilled; its new count is: \" + this.count);\n    state.refill();\n}\nWe add this method to \nthe SoldOutState...\n...and add this method to \nthe GumballMachine class.\n", "page": 462, "type": "text", "section": "Page 462"}
{"text": "this is a new chapter\u2003 \u2003 425\nEver play good cop, bad cop? You\u2019re the good cop and you provide all \nyour services in a nice and friendly manner, but you don\u2019t want everyone asking you \nfor services, so you have the bad cop control access to you. That\u2019s what proxies do: \ncontrol and manage access. As you\u2019re going to see, there are lots of ways in which \nproxies stand in for the objects they proxy. Proxies have been known to haul entire \nmethod calls over the internet for their proxied objects; they\u2019ve also been known to \npatiently stand in for some pretty lazy objects. \nControlling \n     Object Access\n11  the Proxy Pattern\nWith you as my proxy, \nI\u2019ll be able to triple the \namount of lunch money I can \nextract from friends!\n", "page": 463, "type": "text", "section": "Page 463"}
{"text": "426\u2003 \u2003 Chapter 11\nwhat\u2019s the goal\nSounds easy enough. If you remember, we\u2019ve already \ngot methods in the gumball machine code for getting the \ncount of gumballs, getCount(), and getting the current \nstate of the machine, getState().\nAll we need to do is create a report that can be printed out \nand sent back to the CEO. Hmmm, we should probably \nadd a location field to each gumball machine as well; that \nway the CEO can keep the machines straight.\nLet\u2019s just jump in and code this. We\u2019ll impress the CEO \nwith a very fast turnaround.\nRemember the CEO of \nMighty Gumball, Inc.?\nHey team, I\u2019d really like to \nget some better monitoring for \nmy gumball machines. Can you find a \nway to get me a report of inventory \nand machine state?\n", "page": 464, "type": "text", "section": "Page 464"}
{"text": "you are here 4\u2003 \u2003 427\nthe proxy pattern\npublic class GumballMonitor {\n    GumballMachine machine;\n \n    public GumballMonitor(GumballMachine machine) {\n        this.machine = machine;\n    }\n \n    public void report() {\n        System.out.println(\"Gumball Machine: \" + machine.getLocation());\n        System.out.println(\"Current inventory: \" + machine.getCount() + \" gumballs\");\n        System.out.println(\"Current state: \" + machine.getState());\n    }\n}\npublic class GumballMachine {\n    // other instance variables\n    String location;\n \n    public GumballMachine(String location, int count) {\n        // other constructor code here\n        this.location = location;\n    }\n \n    public String getLocation() {\n        return location;\n    }\n \n    // other methods here\n}\nCoding the Monitor\nNow let\u2019s create another class, GumballMonitor, that retrieves the machine\u2019s \nlocation, inventory of gumballs, and current machine state and prints them in a \nnice little report:\nThe monitor takes the machine in \nits constructor and assigns it to \nthe machine instance variable.\nOur report() method just prints a report with \nlocation, inventory, and the machine\u2019s state.\nLet\u2019s start by adding support to the GumballMachine class so that it \ncan handle locations:\nA location is just a String.\nThe location is passed into the \nconstructor and stored in the \ninstance variable.\nLet\u2019s also add a getter method to \ngrab the location when we need it.\n", "page": 465, "type": "text", "section": "Page 465"}
{"text": "428\u2003 \u2003 Chapter 11\nlocal gumball monitor\npublic class GumballMachineTestDrive {\n    public static void main(String[] args) {\n        int count = 0;\n        if (args.length < 2) {\n            System.out.println(\"GumballMachine <name> <inventory>\");\n            System.exit(1);\n        }\n        count = Integer.parseInt(args[1]);\n        GumballMachine gumballMachine = new GumballMachine(args[0], count);\n        GumballMonitor monitor = new GumballMonitor(gumballMachine);\n \n        // rest of test code here\n        monitor.report();\n    }\n}\nTesting the Monitor\nWe implemented that in no time. The CEO is going to be thrilled and amazed by our \ndevelopment skills.\nNow we just need to instantiate a GumballMonitor and give it a machine to monitor:\nDon\u2019t forget to give \nthe constructor a \nlocation and count...\n...and instantiate a monitor and pass it a \nmachine to provide a report on.\nAnd here\u2019s the output!\nWhen we need a report on \nthe machine, we call the \nreport() method.\nPass in a location and initial # of \ngumballs on the command line.\nFile  Edit   Window  Help  FlyingFish\n%java GumballMachineTestDrive Austin 112\nGumball Machine: Austin\nCurrent Inventory: 112 gumballs\nCurrent State: waiting for quarter\nThe monitor output looks \ngreat, but I guess I wasn\u2019t clear. I need \nto monitor gumball machines REMOTELY!  \nIn fact, we already have the networks in \nplace for monitoring. Come on guys, you\u2019re \nsupposed to be the internet generation!\n", "page": 466, "type": "text", "section": "Page 466"}
{"text": "you are here 4\u2003 \u2003 429\nthe proxy pattern\nFrank: A remote what?\nJoe: Remote proxy. Think about it: we\u2019ve already got the monitor code written, right? We give the \nGumballMonitor class a reference to a machine and it gives us a report. The problem is that the monitor runs \nin the same JVM as the gumball machine and the CEO wants to sit at his desk and remotely monitor the \nmachines! So what if we left our GumballMonitor class as is, but handed it a proxy to a remote object?\nFrank: I\u2019m not sure I get it.\nJim: Me neither.\nJoe: Let\u2019s start at the beginning...a proxy is a stand in for a real object. In this case, the proxy acts just like it \nis a Gumball Machine object, but behind the scenes it is communicating over the network to talk to the real, \nremote GumballMachine.\nJim: So you\u2019re saying we keep our code as it is, and we give the monitor a reference to a proxy version of the \nGumballMachine...\nFrank: And this proxy pretends it\u2019s the real object, but it\u2019s really just communicating over the net to the real \nobject.\nJoe: Yeah, that\u2019s pretty much the story.\nFrank: It sounds like something that\u2019s easier said than done.\nJoe: Perhaps, but I don\u2019t think it\u2019ll be that bad. We have to make sure that the gumball machine can act as \na service and accept requests over the network; we also need to give our monitor a way to get a reference to \na proxy object, but we\u2019ve got some great tools already built into Java to help us. Let\u2019s talk a little more about \nremote proxies first...\nJoe\nJim\nFrank\nDon\u2019t worry, guys, I\u2019ve \nbeen brushing up on my design \npatterns. All we need is a remote \nproxy and we\u2019ll be ready to go.\nWell, that will teach us to \ngather some requirements \nbefore we jump in and code. I hope \nwe don\u2019t have to start over...\n", "page": 467, "type": "text", "section": "Page 467"}
{"text": "430\u2003 \u2003 Chapter 11\nremote proxy\nA remote proxy acts as a local representative to a remote object. What\u2019s a \u201cremote \nobject\u201d? It\u2019s an object that lives in the heap of a different Java Virtual Machine \n(or more generally, a remote object that is running in a different address space).  \nWhat\u2019s a \u201clocal representative\u201d? It\u2019s an object that you can call local methods on \nand have them forwarded on to the remote object.\nThe role of the \u2018remote proxy\u2019\nYour client object acts like it\u2019s making remote method calls. \nBut what it\u2019s really doing is calling methods on a heap-\nlocal \u201cproxy\u201d object that handles all the low-level details of \nnetwork communication.\n \n  \n  \n \n \nG\nu\nm\nb\na\nl\nl\n \nM\na\nc\nhi\nn\ne \nRemote Heap\nG\nu\nm\nb\na\nl\nl\n \nM\non\ni\nt\no\nr\nLocal Heap\n \n \n \n \n \n \n \nP\nr\no\nx\ny\nHere the Gumball \nMonitor is the client \nobject; it thinks it\u2019s \ntalking to the Real \ngumball machine, but  \nit\u2019s really just talking \nto the proxy, which \nthen talks to the \nReal gumball machine \nover the network.\nThe proxy pretends to \nbe the remote object, \nbut it\u2019s just a stand in \nfor the Real Thing.\nThe Remote object IS \nthe Real Thing. It\u2019s the \nobject with the method \nthat actually does the \nreal work.\nCEO\u2019s desktop\nRemote Gumball Machine \nwith a JVM.\nSame as your old \ncode, only it\u2019s \ntalking to a proxy.\nThe client object is the object \nmaking use of the proxy-in our \ncase, the GumballMonitor class.\n", "page": 468, "type": "text", "section": "Page 468"}
{"text": "you are here 4\u2003 \u2003 431\nthe proxy pattern\nThis is a pretty slick idea.  \nWe\u2019re going to write some code that \ntakes a method invocation, somehow transfers it \nover the network, and invokes the same method \non a remote object. Then I presume when the call is \ncomplete, the result gets sent back over the network \nto our client. But it seems to me this code is going \nto be very tricky to write.\nHold on now, we aren\u2019t going \nto write that code ourselves; it\u2019s \npretty much built into Java\u2019s remote \ninvocation functionality. All we have to \ndo is retrofit our code so that it takes \nadvantage of RMI.\nBefore going further, think about how you\u2019d design a system to enable Remote Method \nInvocation (RMI). How would you make it easy on the developer so that she has to write as \nlittle code as possible? How would you make the remote invocation look seamless?\nShould making remote calls be totally transparent? Is that a good idea? What might be a \nproblem with that approach?\n2\n", "page": 469, "type": "text", "section": "Page 469"}
{"text": "432\u2003 \u2003 Chapter 11\nrmi detour\nAdding a remote proxy to the Gumball \nMachine monitoring code\nOn paper our plan looks good, but how do we create a proxy that knows how to invoke a \nmethod on an object that lives in another JVM?\nHmmm. Well, you can\u2019t get a reference to something on another heap, right? In other words, \nyou can\u2019t say:\n       Duck d = <object in another heap>\nWhatever the variable d is referencing must be in the same heap space as the code running \nthe statement. So how do we approach this? Well, that\u2019s where Java\u2019s Remote Method \nInvocation (RMI) comes in...RMI gives us a way to find objects in a remote JVM and allows \nus to invoke their methods.\nNow might be a good time to brush up on RMI with your favorite Java reference, or you can \ntake the RMI Detour ahead, and we\u2019ll walk you though the high points of RMI before adding \nthe proxy support to the Gumball Machine code.\nIn either case, here\u2019s our plan:\nAn RMI Detour\nIf you\u2019re new to RMI, \ntake the detour that runs \nover the next few pages; \notherwise, you might want to \njust quickly thumb through \nthe detour as a review. If \nyou\u2019d like to continue on, \njust getting the gist of the \nremote proxy, that is fine \ntoo\u2014you can skip the detour.\n1\n2\n3\nFirst, we\u2019re going to take the RMI \nDetour and explore RMI. Even if you are \nfamiliar with RMI, you might want to \nfollow along and check out the scenery.\nThen we\u2019re going to take our Gumball \nMachine and make it a remote service \nthat provides a set of methods calls \nthat can be invoked remotely.\nFinally, we going to create a proxy that \ncan talk to a remote Gumball Machine, \nagain using RMI, and put the monitoring \nsystem back together so that the CEO can \nmonitor any number of remote machines.\n", "page": 470, "type": "text", "section": "Page 470"}
{"text": "you are here 4\u2003 \u2003 433\nthe proxy pattern\nLet\u2019s say we want to design a system that allows us to call a local object that forwards each request \nto a remote object. How would we design it? We\u2019d need a couple of helper objects that do the \ncommunicating for us. The helpers make it possible for the client to act as though it\u2019s calling a method \non a local object (which it is). The client calls a method on the client helper, as if the client helper were \nthe actual service. The client helper then takes care of forwarding that request for us.\nIn other words, the client object thinks it\u2019s calling a method on the remote service, because the client \nhelper is pretending to be the service object\u2014that is, pretending to be the thing with the method the \nclient wants to call.\nBut the client helper isn\u2019t really the remote service. Although the client helper acts like it (because it has \nthe same method that the service is advertising), the client helper doesn\u2019t have any of the method logic \nthe client is expecting. Instead, the client helper contacts the server, transfers information about the \nmethod call (e.g., name of the method, arguments, etc.), and waits for a return from the server.\nOn the server side, the service helper receives the request from the client helper (through a Socket \nconnection), unpacks the information about the call, and then invokes the real method on the real service \nobject. So, to the service object, the call is local. It\u2019s coming from the service helper, not a remote client.\nThe service helper gets the return value from the service, packs it up, and ships it back (over a Socket\u2019s \noutput stream) to the client helper. The client helper unpacks the information and returns the value to \nthe client object.\nLet\u2019s walk through this to make it clearer...\nRemote methods 101\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nServer heap\nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nClient heap\nC\nl\ni\ne\nn\nt\n \nh\ne\nl\nper\nS\ne\nr\nv\ni\nc\ne\n \nh\nelp\ne\nr\nClient object thinks \nit\u2019s talking to the \nReal Service. It \nthinks the client \nhelper is the thing \nthat can actually do \nthe real work.\nClient helper pretends \nto be the service, but \nit\u2019s just a proxy for the \nReal Thing.\nService helper gets the \nrequest from the client \nhelper, unpacks it, and \ncalls the method on the \nReal Service.\nThe Service object IS \nthe Real Service. It\u2019s the \nobject with the method \nthat actually does the \nreal work.\nConsider this design...\nThis is going \nto be our \nproxy.\nAn RMI Detour\nWalking through the design\n", "page": 471, "type": "text", "section": "Page 471"}
{"text": "434\u2003 \u2003 Chapter 11\nremote method invocation\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nServer heap\nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nClient heap\nC\nl\ni\ne\nn\nt\n \nh\ne\nl\nper\nS\ne\nr\nv\ni\nc\ne\n \nh\nelp\ne\nr\nHow the method call happens\n1\nThe Client object calls doBigThing() on the client helper object.\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nServer heap\nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nClient heap\nC\nl\ni\ne\nn\nt\n \nh\ne\nl\nper\nS\ne\nr\nv\ni\nc\ne\n \nh\nelp\ne\nr\n2\nThe Client helper packages up information about the call \n(arguments, method name, etc.) and ships it over the \nnetwork to the service helper.\ndoBigThing()\ndoBigThing()\n\u201cclient wants to call a method\u201d\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nServer heap\nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nClient heap\nC\nl\ni\ne\nn\nt\n \nh\ne\nl\nper\nS\ne\nr\nv\ni\nc\ne\n \nh\nelp\ne\nr\n3\nThe Service helper unpacks the information from the client \nhelper, finds out which method to call (and on which object), \nand invokes the real method on the real service object.\ndoBigThing()\n\u201cclient wants to call a method\u201d\ndoBigThing()\nRemember, this is the \nobject with the REAL \nmethod logic. The one \nthat does the real work!\n", "page": 472, "type": "text", "section": "Page 472"}
{"text": "you are here 4\u2003 \u2003 435\nthe proxy pattern\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nServer heap\nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nClient heap\nC\nl\ni\ne\nn\nt\n \nh\ne\nl\nper\nS\ne\nr\nv\ni\nc\ne\n \nh\nelp\ne\nr\n4\nThe method is invoked on the service object, which returns \nsome result to the service helper.\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nServer heap\nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nClient heap\nC\nl\ni\ne\nn\nt\n \nh\ne\nl\nper\nS\ne\nr\nv\ni\nc\ne\n \nh\nelp\ne\nr\n5\nThe Service helper packages up information returned from the \ncall and ships it back over the network to the client helper.\npackaged up result\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nServer heap\nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nClient heap\nC\nl\ni\ne\nn\nt\n \nh\ne\nl\nper\nS\ne\nr\nv\ni\nc\ne\n \nh\nelp\ne\nr\n6\nThe Client helper unpackages the returned values and returns \nthem to the client object. To the client object, this was all \ntransparent.\nresult\nresult\nAn RMI Detour\n", "page": 473, "type": "text", "section": "Page 473"}
{"text": "436\u2003 \u2003 Chapter 11\nrmi: the big picture\nOkay, you\u2019ve got the gist of how remote methods work; \nnow you just need to understand how to use RMI. \nWhat RMI does for you is build the client and service \nhelper objects, right down to creating a client helper \nobject with the same methods as the remote service. The \nnice thing about RMI is that you don\u2019t have to write \nany of the networking or I/O code yourself. With your \nclient, you call remote methods (i.e., the ones the Real \nService has) just like normal method calls on objects \nrunning in the client\u2019s own local JVM. \nRMI also provides all the runtime infrastructure to make \nit all work, including a lookup service that the client can \nuse to find and access the remote objects.\nThere is one difference between RMI calls and local \n(normal) method calls. Remember that even though to \nthe client it looks like the method call is local, the client \nhelper sends the method call across the network. So \nthere is networking and I/O. And what do we know \nabout networking and I/O methods?\nThey\u2019re risky! They can fail! And so they throw \nexceptions all over the place. As a result, the client does \nhave to acknowledge the risk. We\u2019ll see how in a few \npages.\nJava RMI, the Big Picture\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nC\nl\ni\ne\nn\nt\n \nh\ne\nl\nper\nS\ne\nr\nv\ni\nc\ne\n \nh\nelp\ne\nr\nServer heap\nClient heap\nRMI STUB\nRMI SKELETON\nRMI nomenclature: in RMI, the client helper is a \u201cstub\u201d and the \nservice helper is a \u201cskeleton.\u201d\nThis is going \nto act as our \nproxy!\nNow let\u2019s go through all the steps needed to make an object \ninto a service that can accept remote calls and also the steps \nneeded to allow a client to make remote calls.\nYou might want to make sure your seat belt is fastened; there \nare a lot of steps\u2014but nothing to be too worried about.\nAn RMI Detour\n", "page": 474, "type": "text", "section": "Page 474"}
{"text": "you are here 4\u2003 \u2003 437\nthe proxy pattern\nAn RMI Detour\nMaking the Remote service\nMake a Remote Interface\nMake a Remote Implementation\nStart the RMI registry (rmiregistry)\nStart the remote service \nMyService.java\npublic interface \nMyRemote extends \nRemote { }\nMyServiceImpl.java\npublic interface \nMyRemote extends \nRemote { }\nThis is an overview of the five steps for making the remote service\u2014in other \nwords, the steps needed to take an ordinary object and supercharge it so it can \nbe called by a remote client. We\u2019ll be doing this later to our Gumball Machine. \nFor now, let\u2019s get the steps down and then we\u2019ll explain each one in detail.\nThe remote interface defines the methods that \na client can call remotely. It\u2019s what the client \nwill use as the class type for your service. Both \nthe Stub and actual service will implement \nthis.\nThis interface defines the \nremote methods that you \nwant clients to call.\nThis is the class that does the Real Work. It \nhas the real implementation of the remote \nmethods defined in the remote interface. \nIt\u2019s the object that the client wants to call \nmethods on (e.g., GumballMachine).\nThe Real Service: the class \nwith the methods that do \nthe real work. It implements \nthe remote interface.\nThe Stub and Skeleton are \ngenerated dynamically for you \nbehind the scenes.\nFile  Edit   Window  Help  Drink\n%rmiregistry\nFile  Edit   Window  Help  BeMerry\n%java MyServiceImpl\nThe rmiregistry is like the white pages of a phone \nbook. It\u2019s where the client goes to get the proxy \n(the client stub/helper object).\nYou have to get the service object up and running. Your \nservice implementation class instantiates an instance \nof the service and registers it with the RMI registry. \nRegistering it makes the service available for clients.\nRun this in a separate \nterminal window.\nStep one:\nStep two:\nStep three:\nStep four:\nStub\n101101 \n10 110 1 \n0 11 0 \n001 10 \n001 01\nSkeleton\n101101 \n10 110 1 \n0 11 0 \n001 10 \n001 01\n", "page": 475, "type": "text", "section": "Page 475"}
{"text": "438\u2003 \u2003 Chapter 11\nmake a remote interface\nStep one: make a Remote interface\n1\nExtend java.rmi.Remote\nRemote is a \u201cmarker\u201d interface, which means it has no methods. It has \nspecial meaning for RMI, though, so you must follow this rule. Notice that \nwe say \u201cextends\u201d here. One interface is allowed to extend another interface.\npublic interface MyRemote extends Remote {\n2\nDeclare that all methods throw RemoteException\nThe remote interface is the one the client uses as the type for the service. In \nother words, the client invokes methods on something that implements the \nremote interface. That something is the stub, of course, and since the stub is \ndoing networking and I/O, all kinds of bad things can happen. The client has \nto acknowledge the risks by handling or declaring the remote exceptions. If \nthe methods in an interface declare exceptions, any code calling methods on a \nreference of that type (the interface type) must handle or declare the exceptions.\nimport java.rmi.*;\npublic interface MyRemote extends Remote {\n    public String sayHello() throws RemoteException;\n}\n3\nBe sure arguments and return values are primitives or Serializable\nArguments and return values of a remote method must be either primitive \nor Serializable. Think about it. Any argument to a remote method has to \nbe packaged up and shipped across the network, and that\u2019s done through \nSerialization. The same thing applies with return values. If you use primitives, \nStrings, and the majority of types in the API (including arrays and collections), \nyou\u2019ll be fine. If you are passing around your own types, just be sure that you \nmake your classes implement Serializable.\npublic String sayHello() throws RemoteException;\nThis tells us that the \ninterface is going to be used \nto support remote calls.\nEvery remote method \ncall is considered \n\u201crisky.\u201d Declaring \nRemoteException on \nevery method forces the \nclient to pay attention \nand acknowledge that \nthings might not work.\nThis return value is gonna be shipped over the wire from the \nserver back to the client, so it must be Serializable. That\u2019s \nhow args and return values get packaged up and sent.\nRemote interface is in java.rmi.\nCheck out your \nfavorite Java \nreference if you \nneed to refresh your \nmemory on Serializable.\nAn RMI Detour\n", "page": 476, "type": "text", "section": "Page 476"}
{"text": "you are here 4\u2003 \u2003 439\nthe proxy pattern\nStep two: make a Remote implementation\n1\nImplement the Remote interface\nYour service has to implement the remote interface\u2014the one with \nthe methods your client is going to call. \npublic class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {\n    public String sayHello() {\n       return \"Server says, 'Hey'\";\n   }\n   // more code in class\n}\n2\nExtend UnicastRemoteObject\nIn order to work as a remote service object, your object needs some functionality \nrelated to \u201cbeing remote.\u201d The simplest way is to extend UnicastRemoteObject \n(from the java.rmi.server package) and let that class (your superclass) do the \nwork for you.\npublic class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {\n    private static final long serialVersionUID = 1L;\n3\nWrite a no-arg constructor that declares RemoteException\nYour new superclass, UnicastRemoteObject, has one little problem\u2014its \nconstructor throws RemoteException. The only way to deal with this is to declare \na constructor for your remote implementation, just so that you have a place to \ndeclare RemoteException. Remember,  when a class is instantiated, its superclass \nconstructor is always called. If your superclass constructor throws an exception, \nyou have no choice but to declare that your constructor also throws an exception.\npublic MyRemoteImpl() throws RemoteException { }\n4\nRegister the service with the RMI registry\nNow that you\u2019ve got a remote service, you have to make it available to remote \nclients. You do this by instantiating it and putting it into the RMI registry (which \nmust be running or this line of code fails). When you register the implementation \nobject, the RMI system actually puts the stub in the registry, since that\u2019s what the \nclient really needs. Register your service using the static rebind() method of the \njava.rmi.Naming class.\ntry {\n    MyRemote service = new MyRemoteImpl();\n    Naming.rebind(\"RemoteHello\", service);\n} catch(Exception ex) {...}      \nThe compiler will make sure that you\u2019ve implemented \nall the methods from the interface you implement. \nIn this case, there\u2019s only one.\nYou don\u2019t have to put anything in \nthe constructor. You just need a \nway to declare that your superclass \nconstructor throws an exception.\nGive your service a name (that clients can use \nto look it up in the registry) and register it \nwith the RMI registry. When you bind the \nservice object, RMI swaps the service for the \nstub and puts the stub in the registry.\nAn RMI Detour\nUnicastRemoteObject implements \nSerializable, so we need the \nserialVersionUID field.\n", "page": 477, "type": "text", "section": "Page 477"}
{"text": "440\u2003 \u2003 Chapter 11\nstart the service\nStep three: run rmiregistry\n1\nBring up a terminal and start the rmiregistry. \nBe sure you start it from a directory that has access to \nyour classes. The simplest way is to start it from your \nclasses directory.\nFile  Edit   Window  Help  Huh?\n%rmiregistry\nStep four: start the service\n1\nBring up another terminal and start your service\nThis might be from a main() method in your remote \nimplementation class or from a separate launcher class. \nIn this simple example, we put the starter code in the \nimplementation class, in a main method that instantiates \nthe object and registers it with RMI registry.\nQ: Why are you showing stubs and skeletons in the diagrams for the RMI code? I thought we got \nrid of those way back.\nA: You\u2019re right; for the skeleton, the RMI runtime can dispatch the client calls directly to the remote \nservice using reflection, and stubs are generated dynamically using Dynamic Proxy (which you\u2019ll learn \nmore about a bit later in the chapter). The remote object\u2019s stub is a java.lang.reflect.Proxy instance (with an \ninvocation handler) that is automatically generated to handle all the details of getting the local method calls \nby the client to the remote object. But we like to show both the stub and skeleton, because conceptually \nit helps you to understand that there is something under the covers that\u2019s making that communication \nbetween the client stub and the remote service happen.\nAn RMI Detour\nFile  Edit   Window  Help  Huh?\n%java MyRemoteImpl\n", "page": 478, "type": "text", "section": "Page 478"}
{"text": "you are here 4\u2003 \u2003 441\nthe proxy pattern\nComplete code for the server side\nimport java.rmi.*;\nimport java.rmi.server.*;\npublic class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {\n    private static final long serialVersionUID = 1L;\n    public String sayHello() {\n        return \"Server says, 'Hey'\";\n    }\n    public MyRemoteImpl() throws RemoteException { }\n    public static void main (String[] args) {\n        try {\n            MyRemote service = new MyRemoteImpl();\n            Naming.rebind(\"RemoteHello\", service);\n        } catch(Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}\nimport java.rmi.*;\npublic interface MyRemote extends Remote {\n    public String sayHello() throws RemoteException;\n}\nRemoteException and the Remote \ninterface are in the java.rmi package.\nYour interface MUST extend java.rmi.Remote.\nAll of your remote methods must \ndeclare RemoteException.\nUnicastRemoteObject is in \nthe java.rmi.server package.\nThe Remote interface:\nThe Remote service (the implementation):\nExtending UnicastRemoteObject is the \neasiest way to make a remote object.\nYou MUST implement \nyour remote interface!! \nYou have to implement all the \ninterface methods, of course. But \nnotice that you do NOT have to \ndeclare the RemoteException.\nYour superclass constructor (for \nUnicastRemoteObject) declares an exception, \nso YOU must write a constructor, because it \nmeans that your constructor is calling risky \ncode (its super constructor).\nMake the remote object, then \u201cbind\u201d it to the \nrmiregistry using the static Naming.rebind(). The \nname you register it under is the name clients will \nuse to look it up in the RMI registry.\nAn RMI Detour\nLet\u2019s take a look at all the code for the server side:\n", "page": 479, "type": "text", "section": "Page 479"}
{"text": "442\u2003 \u2003 Chapter 11\nhow to get the stub object\nAnd that\u2019s where the RMI registry comes in. \nAnd, you\u2019re right; the client has to get the stub object \n(our proxy), because that\u2019s the thing the client will call \nmethods on. To do that, the client does a \u201clookup,\u201d \nlike going to the white pages of a phone book, and \nessentially says, \u201cHere\u2019s a name, and I\u2019d like the stub \nthat goes with that name.\u201d \nLet\u2019s take a look at the code we need to look up and \nretrieve a stub object.\nCode Up Close\nMyRemote service = \n    (MyRemote) Naming.lookup(\"rmi://127.0.0.1/RemoteHello\");\nThe client always uses the remote \ninterface as the type of the service. \nIn fact, the client never needs to \nknow the actual class name of your \nremote service.\nYou have to cast it to the \ninterface, since the lookup \nmethod returns type Object. \nlookup() is a static method \nof the Naming class.\nThe host name or IP \naddress where the \nservice is running. \n(127.0.0.1 is localhost.)\nThis must be the name \nthat the service was \nregistered under.\nHere\u2019s how it works \non the next page.\nAn RMI Detour\nHow does the client actually get \nthe stub object?\n", "page": 480, "type": "text", "section": "Page 480"}
{"text": "you are here 4\u2003 \u2003 443\nthe proxy pattern\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nS\nt\nu\nb\nS\nk\ne\nl\ne\nt\no\nn\nServer\nClient\nRemote Hello\nStub\nRMI registry (on server)\n1\nClient does a lookup on the RMI registry\n2\nRMI registry returns the stub object\n(as the return value of the lookup method) and RMI \ndeserializes the stub automatically. \n3\nClient invokes a method on the stub, as if the \nstub IS the real service\n1\n2\n3\nNaming.lookup(\"rmi://127.0.0.1/RemoteHello\");\nlookup( )\nstub returned\nsayHello( )\nHow it works...\nAn RMI Detour\n", "page": 481, "type": "text", "section": "Page 481"}
{"text": "444\u2003 \u2003 Chapter 11\nthe remote client\nimport java.rmi.*;\npublic class MyRemoteClient {\n   public static void main (String[] args) {\n        new MyRemoteClient().go();\n   }\n   public void go() {\n     try {\n        MyRemote service = (MyRemote) Naming.lookup(\"rmi://127.0.0.1/RemoteHello\");\n        String s = service.sayHello(); \n        System.out.println(s);\n      } catch(Exception ex) {\n         ex.printStackTrace();\n      }\n   }\n}\nThe Naming class (for doing the rmiregistry \nlookup) is in the java.rmi package.\nIt comes out of the registry as type \nObject, so don\u2019t forget the cast.\nYou need the IP \naddress or hostname...\n...and the name used to \nbind/rebind the service.\nIt looks just like a regular old \nmethod call! (Except it must \nacknowledge the RemoteException.)\n1.  \t\n       \nThe things programmers do wrong \nwith RMI are:\n1.  Forget to start rmiregistry before starting the remote \nservice (when the service is registered using Naming.\nrebind(), the rmiregistry must be running!)\n2.  Forget to make arguments and return types serializable \n(you won\u2019t know until runtime; this is not something the \ncompiler will detect).\nAn RMI Detour\nComplete code for the client side\nLet\u2019s take a look at all the code for the client side:\n", "page": 482, "type": "text", "section": "Page 482"}
{"text": "you are here 4\u2003 \u2003 445\nthe proxy pattern\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nServer heap\nG\nu\nm\nb\na\nl\nl\nM\noni\nt\no\nr\nClient heap\nG\nu\nm\nb\na\nl\nl\nS\ntub\nG\nu\nm\nb\na\nl\nl\nS\nkel\ne\nto\nn\nThis is our \nMonitor code. It \nuses a proxy to \ntalk to remote \ngumball machines.\nThe stub is a proxy \nto the remote \nGumballMachine.\nThe skeleton accepts the \nremote calls and makes \neverything work on the \nservice side.\nThe \nGumballMachine is \nour remote service; \nit\u2019s going to expose \na remote interface \nfor the client to \nuse.\nBack to our GumballMachine remote proxy\nOkay, now that you have the RMI basics down, you\u2019ve got the tools you need \nto implement the gumball machine remote proxy. Let\u2019s take a look at how the \nGumballMachine fits into this framework:\nCEO\u2019s desktop\nRemote GumballMachine \nwith a JVM.\nStop and think through how we\u2019re going to adapt the gumball machine code to work with \na remote proxy. Feel free to make some notes here about what needs to change and \nwhat\u2019s going to be different than the previous version.\n", "page": 483, "type": "text", "section": "Page 483"}
{"text": "446\u2003 \u2003 Chapter 11\nremote interface for the gumball machine\nimport java.io.*;\n  \npublic interface State extends Serializable {\n    public void insertQuarter();\n    public void ejectQuarter();\n    public void turnCrank();\n    public void dispense();\n}\nimport java.rmi.*;\n \npublic interface GumballMachineRemote extends Remote {\n    public int getCount() throws RemoteException;\n    public String getLocation() throws RemoteException;\n    public State getState() throws RemoteException;\n}\nGetting the GumballMachine ready to \nbe a remote service\nThe first step in converting our code to use the remote proxy is to enable the \nGumballMachine to service remote requests from clients. In other words, \nwe\u2019re going to make it into a service. To do that, we need to:\n1. Create a remote interface for the GumballMachine. This will provide a set \nof methods that can be called remotely. \n2. Make sure all the return types in the interface are serializable.\n3. Implement the interface in a concrete class.\nWe\u2019ll start with the remote interface:\nThis is the remote interface.\nDon\u2019t forget to import java.rmi.* \nHere are the methods we\u2019re going to support. \nEach one throws RemoteException.\nAll return types need \nto be primitive or \nSerializable...\nWe have one return type that isn\u2019t Serializable: the State class. Let\u2019s fix it up...\nSerializable is in the java.io package.\nThen we just extend the Serializable \ninterface (which has no methods in it). \nAnd now State in all the subclasses can \nbe transferred over the network.\n", "page": 484, "type": "text", "section": "Page 484"}
{"text": "you are here 4\u2003 \u2003 447\nthe proxy pattern\npublic class NoQuarterState implements State {\n    private static final long serialVersionUID = 2L;\n    transient GumballMachine gumballMachine;\n    // all other methods here\n}\nimport java.rmi.*;\nimport java.rmi.server.*;\n \npublic class GumballMachine\n        extends UnicastRemoteObject implements GumballMachineRemote \n{\n    private static final long serialVersionUID = 2L;\n    // other instance variables here\n \n    public GumballMachine(String location, int numberGumballs) throws RemoteException {\n        // code here\n    }\n \n    public int getCount() {\n        return count;\n    }\n \n    public State getState() {\n        return state;\n    }\n \n    public String getLocation() {\n        return location;\n    }\n    // other methods here\n}\nActually, we\u2019re not done with Serializable yet; we have one problem with State. As you may \nremember, each State object maintains a reference to a gumball machine so that it can call the \ngumball machine\u2019s methods and change its state. We don\u2019t want the entire gumball machine \nserialized and transferred with the State object. There is an easy way to fix this:\nIn each implementation of State, we add \nthe serialVersionUID and the transient \nkeyword to the GumballMachine instance \nvariable. The transient keyword tells the \nJVM not to serialize this field. Note \nthat this can be slightly dangerous if you \ntry to access this field once the object\u2019s \nbeen serialized and transferred.\nWe\u2019ve already implemented our GumballMachine, but we need to make sure it can act as a service and \nhandle requests coming from over the network. To do that, we have to make sure the GumballMachine is \ndoing everything it needs to implement the GumballMachineRemote interface. \nAs you\u2019ve already seen in the RMI detour, this is quite simple; all we need to do is add a couple of things...\nFirst, we need to import the \nRMI packages.\nGumballMachine is \ngoing to subclass the \nUnicastRemoteObject; \nthis gives it the ability to \nact as a remote service.\nGumballMachine also needs to \nimplement the remote interface...\n...and the constructor needs \nto throw a remote exception, \nbecause the superclass does.\nThat\u2019s it! Nothing \nchanges here at all!\n", "page": 485, "type": "text", "section": "Page 485"}
{"text": "448\u2003 \u2003 Chapter 11\nregister the gumball service\npublic class GumballMachineTestDrive {\n \n    public static void main(String[] args) {\n        GumballMachineRemote gumballMachine = null;\n        int count;\n        if (args.length < 2) {\n            System.out.println(\"GumballMachine <name> <inventory>\");\n            System.exit(1);\n        }\n        try {\n            count = Integer.parseInt(args[1]);\n            gumballMachine = new GumballMachine(args[0], count);\n            Naming.rebind(\"//\" + args[0] + \"/gumballmachine\", gumballMachine);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\nFile  Edit   Window  Help  Huh?\n% rmiregistry\nRegistering with the RMI registry...\nThat completes the gumball machine service. Now we just need to fire it up so \nit can receive requests. First, we need to make sure we register it with the RMI \nregistry so that clients can locate it. \nWe\u2019re going to add a little code to the test drive that will take care of this for us:\nFirst we need to add a try/catch block \naround the gumball instantiation because our \nconstructor can now throw exceptions.\nWe also add the call to Naming.rebind, \nwhich publishes the GumballMachine stub \nunder the name gumballmachine.\nLet\u2019s go ahead and get this running...\nFile  Edit   Window  Help  Huh?\n% java GumballMachineTestDrive austin.mightygumball.com 100\nRun this first.\nRun this second.\nThis gets the RMI \nregistry service up \nand running.\nThis gets the GumballMachine up and running \nand registers it with the RMI registry.\nWe\u2019re using the \u201cofficial\u201d Mighty \nGumball machines; you should \nsubstitute your own machine name \nhere, or \u201clocalhost\u201d.\n", "page": 486, "type": "text", "section": "Page 486"}
{"text": "you are here 4\u2003 \u2003 449\nthe proxy pattern\nimport java.rmi.*;\n \npublic class GumballMonitor {\n    GumballMachineRemote machine;\n \n    public GumballMonitor(GumballMachineRemote machine) {\n        this.machine = machine;\n    }\n \n    public void report() {\n        try {\n            System.out.println(\"Gumball Machine: \" + machine.getLocation());\n            System.out.println(\"Current inventory: \" + machine.getCount() + \" gumballs\");\n            System.out.println(\"Current state: \" + machine.getState());\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n}\nNow for the GumballMonitor client...\nRemember the GumballMonitor? We wanted to reuse it without \nhaving to rewrite it to work over a network. Well, we\u2019re pretty much \ngoing to do that, but we do need to make a few changes. \nWe also need to catch any remote exceptions \nthat might happen as we try to invoke methods \nthat are ultimately happening over the network.\nNow we\u2019re going to rely on the remote \ninterface rather than the concrete \nGumballMachine class.\nWe need to import the RMI package because we \nare using the RemoteException class below...\nJoe was right; \nthis is working out \nquite nicely!\n", "page": 487, "type": "text", "section": "Page 487"}
{"text": "450\u2003 \u2003 Chapter 11\ntest drive the monitor\nimport java.rmi.*;\n \npublic class GumballMonitorTestDrive {\n \n    public static void main(String[] args) {\n        String[] location = {\"rmi://santafe.mightygumball.com/gumballmachine\",\n                             \"rmi://boulder.mightygumball.com/gumballmachine\",\n                             \"rmi://austin.mightygumball.com/gumballmachine\"}; \n \n        GumballMonitor[] monitor = new GumballMonitor[location.length];\n \n        for (int i=0; i < location.length; i++) {\n            try {\n                GumballMachineRemote machine = \n                        (GumballMachineRemote) Naming.lookup(location[i]);\n                monitor[i] = new GumballMonitor(machine);\n                System.out.println(monitor[i]);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n \n        for (int i=0; i < monitor.length; i++) {\n            monitor[i].report();\n        }\n    }\n}\nWriting the Monitor test drive\nNow we\u2019ve got all the pieces we need. We just need to write some \ncode so the CEO can monitor a bunch of gumball machines:\nHere\u2019s all the locations \nwe\u2019re going to monitor.\nHere\u2019s the monitor test drive. The \nCEO is going to run this!\nWe create an array \nof locations, one for \neach machine.  \nThen we iterate through each \nmachine and print out its report.\nNow we need to get a proxy \nto each remote machine.\nWe also create an \narray of monitors.\n", "page": 488, "type": "text", "section": "Page 488"}
{"text": "you are here 4\u2003 \u2003 451\nthe proxy pattern\nCode Up Close\nOn each machine, run rmiregistry in \nthe background or from a separate \nterminal window...\ntry {\n    GumballMachineRemote machine = \n\t\n        (GumballMachineRemote) Naming.lookup(location[i]);\n    monitor[i] = new GumballMonitor(machine);\n} catch (Exception e) {\n    e.printStackTrace();\n}\nRemember, Naming.lookup() is a \nstatic method in the RMI package \nthat takes a location and service \nname and looks it up in the \nrmiregistry at that location.\nThis returns a proxy to the remote \nGumball Machine (or throws an exception \nif one can\u2019t be located).\nOnce we get a proxy to the remote \nmachine, we create a new GumballMonitor \nand pass it the machine to monitor.\nAnother demo for the CEO of Mighty Gumball...\n...and then run the GumballMachine, giving it \na location and an initial gumball count.\n% rmiregistry &\n% java GumballMachineTestDrive santafe.mightygumball.com 100\nFile  Edit   Window  Help  Huh?\nFile  Edit   Window  Help  Huh?\n% rmiregistry &\n% java GumballMachineTestDrive boulder.mightygumball.com 100\nFile  Edit   Window  Help  Huh?\n% rmiregistry &\n% java GumballMachineTestDrive austin.mightygumball.com 250\nPopular machine!\nOkay, it\u2019s time to put all this work together and give another demo. First let\u2019s make \nsure a few gumball machines are running the new code:\n", "page": 489, "type": "text", "section": "Page 489"}
{"text": "452\u2003 \u2003 Chapter 11\ndemoing the monitor\nAnd now let\u2019s put the monitor in the hands of the CEO.\nHopefully, this time he\u2019ll love it:\nFile  Edit   Window  Help  GumballsAndBeyond\n% java GumballMonitorTestDrive\nGumball Machine: santafe.mightygumball.com\nCurrent inventory: 99 gumballs\nCurrent state: waiting for quarter\nGumball Machine: boulder.mightygumball.com\nCurrent inventory: 44 gumballs\nCurrent state: waiting for turn of crank\nGumball Machine: austin.mightygumball.com\nCurrent inventory: 187 gumballs\nCurrent state: waiting for quarter\n%\nThe monitor iterates \nover each remote \nmachine and calls \nits getLocation(), \ngetCount(), and \ngetState() methods.\nBy invoking methods on the proxy, we make \na remote call across the wire, and get back \na String, an integer, and a State object. \nBecause we are using a proxy, the Gumball \nMonitor doesn\u2019t know, or care, that calls \nare remote (other than having to worry \nabout remote exceptions).\nThis is amazing; it\u2019s going to \nrevolutionize my business and \nblow away the competition!\n", "page": 490, "type": "text", "section": "Page 490"}
{"text": "you are here 4\u2003 \u2003 453\nthe proxy pattern\nThis worked great! But \nI want to make sure I \nunderstand exactly what\u2019s \ngoing on...\nCEO\u2019s desktop\nRemote GumballMachine \nwith a JVM\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nG\nu\nm\nb\na\nl\nl\nM\no\nn\ni\nt\no\nr\nP\nr\no\nx\ny\n/\nS\nt\nub\nS\nk\ne\nl\ne\nt\no\nn\naustin\nProxy/Stub\nRMI registry (on gumball machine)\n1\n3\nlookup( \u201caustin\u201d)\nproxy returned\ngetState( )\n2\nType is GumballMachineRemote\n1\nThe CEO runs the monitor, which first grabs the proxies to the remote \ngumball machines and then calls getState() on each one (along with \ngetCount() and getLocation()).\nBehind \nthe Scenes\n", "page": 491, "type": "text", "section": "Page 491"}
{"text": "454\u2003 \u2003 Chapter 11\nproxy behind the scenes\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nG\nu\nm\nb\na\nl\nl\nM\no\nn\ni\nt\no\nr\nP\nr\no\nx\ny\n/\nS\nt\nub\nS\nk\ne\nl\ne\nt\no\nn\ngetState( )\n2\ngetState() is called on the proxy, which forwards the call to the remote \nservice. The skeleton receives the request and then forwards it to the \nGumballMachine.\ngetState()\n3\nGumballMachine returns the state to the skeleton, which serializes it and \ntransfers it back over the wire to the proxy. The proxy deserializes it and \nreturns it as an object to the monitor.\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nG\nu\nm\nb\na\nl\nl\nM\no\nn\ni\nt\no\nr\nP\nr\no\nx\ny\n/\nS\nt\nub\nS\nk\ne\nl\ne\nt\no\nn\nState \nobject\nState \nobject\nSerialized \nState\nThe monitor hasn\u2019t changed at all, \nexcept it knows it may encounter \nremote exceptions. It also uses the \nGumballMachineRemote interface rather \nthan a concrete implementation.\nLikewise, the GumballMachine \nimplements another interface and \nmay throw a remote exception in its \nconstructor, but other than that, the \ncode hasn\u2019t changed.\nWe also have a small bit of code to register and locate stubs using the \nRMI registry. But no matter what, if we were writing something to \nwork over the internet, we\u2019d need some kind of locator service.\n", "page": 492, "type": "text", "section": "Page 492"}
{"text": "you are here 4\u2003 \u2003 455\nthe proxy pattern\nWell, we\u2019ve seen how the Proxy Pattern provides a surrogate or \nplaceholder for another object. We\u2019ve also described the proxy as \na \u201crepresentative\u201d for another object.\nBut what about a proxy controlling access? That sounds a little \nstrange. No worries. In the case of the gumball machine, just think \nof the proxy controlling access to the remote object. The proxy \nneeded to control access because our client, the monitor, didn\u2019t \nknow how to talk to a remote object. So in some sense the remote \nproxy controlled access so that it could handle the network details \nfor us. As we just discussed, there are many variations of the Proxy \nPattern, and the variations typically revolve around the way the \nproxy \u201ccontrols access.\u201d We\u2019re going to talk more about this later, \nbut for now here are a few ways proxies control access:\n\u2003\n\u0083\nAs we know, a remote proxy controls access to a remote \nobject.\n\u2003\n\u0083\nA virtual proxy controls access to a resource that is expensive \nto create.\n\u2003\n\u0083\nA protection proxy controls access to a resource based on \naccess rights.\nNow that you\u2019ve got the gist of the general pattern, check out the \nclass diagram...\nThe Proxy Pattern defined\nThe Proxy Pattern provides a surrogate or \nplaceholder for another object to control access to it.\nWe\u2019ve already put a lot of pages behind us in this chapter; as you \ncan see, explaining the Remote Proxy is quite involved. Despite that, \nyou\u2019ll see that the definition and class diagram for the Proxy Pattern \nis actually fairly straightforward. Note that the Remote Proxy is one \nimplementation of the general Proxy Pattern; there are actually \nquite a few variations of the pattern, and we\u2019ll talk about them later. \nFor now, let\u2019s get the details of the general pattern down.\nHere\u2019s the Proxy Pattern definition:\nUse the Proxy \nPattern to create a \nrepresentative object \nthat controls access \nto another object, \nwhich may be remote, \nexpensive to create, or \nin need of securing.\n", "page": 493, "type": "text", "section": "Page 493"}
{"text": "456\u2003 \u2003 Chapter 11\nthe proxy pattern defined\nBoth the Proxy and the \nRealSubject implement the \nSubject interface. This \nallows any client to treat \nthe proxy just like the \nRealSubject.\nThe RealSubject is \nusually the object \nthat does most \nof the real work; \nthe Proxy controls \naccess to it.\nThe Proxy keeps a \nreference to the \nSubject, so it can \nforward requests \nto the Subject \nwhen necessary.\n<<interface>>\nSubject\nrequest()\nRealSubject\nrequest()\nProxy\nsubject\nrequest()\nThe Proxy often instantiates \nor handles the creation of \nthe RealSubject.\nLet\u2019s step through the diagram...\nFirst we have a Subject, which provides an interface for the RealSubject and the \nProxy. Because it implements the same interface as the RealSubject, the Proxy can \nbe substituted for the RealSubject anywhere it occurs.\nThe RealSubject is the object that does the real work. It\u2019s the object that the Proxy \nrepresents and controls access to.\nThe Proxy holds a reference to the RealSubject. In some cases, the Proxy may be \nresponsible for creating and destroying the RealSubject. Clients interact with the \nRealSubject through the Proxy.  Because the Proxy and RealSubject implement the \nsame interface (Subject), the Proxy can be substituted anywhere the Subject can be \nused. The Proxy also controls access to the RealSubject; this control may be needed \nif the Subject is running on a remote machine, if the Subject is expensive to create \nin some way, or if access to the subject needs to be protected in some way.\nNow that you understand the general pattern, let\u2019s look at some other ways of using \nproxy beyond the Remote Proxy...\n", "page": 494, "type": "text", "section": "Page 494"}
{"text": "you are here 4\u2003 \u2003 457\nthe proxy pattern\nGet ready for the Virtual Proxy\nOkay, so far you\u2019ve seen the definition of the Proxy Pattern and you\u2019ve taken a look \nat one specific example: the Remote Proxy. Now we\u2019re going to take a look at a different \ntype of proxy, the Virtual Proxy. As you\u2019ll discover, the Proxy Pattern can manifest \nitself in many forms, yet all the forms follow roughly the general proxy design. Why \nso many forms? Because the Proxy Pattern can be applied to a lot of different use \ncases. Let\u2019s check out the Virtual Proxy and compare it to the Remote Proxy:\n \n \n \n \nR\ne\na\nl\nS\nu\nbje\nc\nt\n \n \n \n \n \n \nC\nl\ni\ne\nn\nt\nP\nr\no\nx\ny\nRemote Proxy\nrequest( )\nrequest( )\nWith the Remote Proxy, the proxy \nacts as a local representative \nfor an object that lives in a \ndifferent JVM. A method call on \nthe proxy results in the call being \ntransferred over the wire and \ninvoked remotely, and the result \nbeing returned back to the proxy \nand then to the Client.\n \n \n \n \nR\ne\na\nl\nS\nu\nbje\nc\nt\n \n \n \n \n \n \nC\nl\ni\ne\nn\nt\nP\nr\no\nx\ny\nVirtual Proxy\nThe Virtual Proxy acts as a \nrepresentative for an object that \nmay be expensive to create. The \nVirtual Proxy often defers the \ncreation of the object until it \nis needed; the Virtual Proxy \nalso acts as a surrogate for \nthe object before and while it is \nbeing created. After that, the proxy \ndelegates requests directly to the \nRealSubject.\nWe know this diagram \npretty well by now...\nBig \u201cexpensive to create\u201d object.\nThe proxy creates \nthe RealSubject \nwhen it\u2019s needed.\nrequest( )\nrequest( )\nThe proxy may handle the request, or if \nthe RealSubject has been created, delegate \nthe calls to the RealSubject.\n", "page": 495, "type": "text", "section": "Page 495"}
{"text": "458\u2003 \u2003 Chapter 11\nimage proxy controls access\nWhile the album cover is loading, \nthe proxy displays a message.\nWhen the album cover is \nfully loaded, the proxy \ndisplays the image.\nChoose the album cover of \nyour liking here.\nDisplaying Album covers\nLet\u2019s say you want to write an application that displays your favorite album covers. \nYou might create a menu of the album titles and then retrieve the images from an \nonline service like Amazon.com. If you\u2019re using Swing, you might create an Icon \nand ask it to load the image from the network. The only problem is, depending \non the network load and the bandwidth of your connection, retrieving an album \ncover might take a little time, so your application should display something while \nyou\u2019re waiting for the image to load. We also don\u2019t want to hang up the entire \napplication while it\u2019s waiting on the image. Once the image is loaded, the message \nshould go away and you should see the image.\nAn easy way to achieve this is through a virtual proxy. The virtual proxy can stand \nin place of the icon, manage the background loading, and before the image is \nfully retrieved from the network, display \u201cLoading album cover, please wait...\u201d.  \nOnce the image is loaded, the proxy delegates the display to the Icon.\n", "page": 496, "type": "text", "section": "Page 496"}
{"text": "you are here 4\u2003 \u2003 459\nthe proxy pattern\nDesigning the Album Cover Virtual Proxy\n<<interface>>\nIcon\ngetIconWidth()\ngetIconHeight()\npaintIcon()\nImageProxy\nsubject\ngetIconWidth()\ngetIconHeight()\npaintIcon()\ngetIconWidth()\ngetIconHeight()\npaintIcon()\nImageIcon\nThis is javax.swing.ImageIcon, \na class that displays an Image.\nThis is our proxy, which first \ndisplays a message and then, when \nthe image is loaded, delegates to \nImageIcon to display the image.\nThis is the Swing \nIcon interface used \nto display images in a \nuser interface.\nBefore writing the code for the Album Cover Viewer, let\u2019s look at the class diagram.  \nYou\u2019ll see this looks just like our Remote Proxy class diagram, but here the proxy is \nused to hide an object that is expensive to create (because we need to retrieve the data \nfor the Icon over the network) as opposed to an object that actually lives somewhere \nelse on the network.\nImageProxy first creates an ImageIcon and starts \nloading it from a network URL.\nWhile the bytes of the image are being retrieved, \nImageProxy displays  \u201cLoading album cover, please \nwait...\u201d.\nWhen the image is fully loaded, ImageProxy delegates \nall method calls to the image icon, including \npaintIcon(), getIconWidth(), and getIconHeight().\nIf the user requests a new image, we\u2019ll create a new \nproxy and start the process over.\nHow ImageProxy is going to work:\n1\n2\n3\n4\n", "page": 497, "type": "text", "section": "Page 497"}
{"text": "460\u2003 \u2003 Chapter 11\nthe image proxy\nclass ImageProxy implements Icon {\n    volatile ImageIcon imageIcon;\n    final URL imageURL;\n    Thread retrievalThread;\n    boolean retrieving = false;\n     \n    public ImageProxy(URL url) { imageURL = url; }\n    public int getIconWidth() {\n        if (imageIcon != null) {\n            return imageIcon.getIconWidth();\n        } else {\n            return 800;\n        }\n    }\n    public int getIconHeight() {\n        if (imageIcon != null) {\n            return imageIcon.getIconHeight();\n        } else {\n            return 600;\n        }\n    }\n    synchronized void setImageIcon(ImageIcon imageIcon) {\n        this.imageIcon = imageIcon;\n    }\n     \n    public void paintIcon(final Component c, Graphics  g, int x,  int y) {\n        if (imageIcon != null) {\n            imageIcon.paintIcon(c, g, x, y);\n        } else {\n            g.drawString(\"Loading album cover, please wait...\", x+300, y+190);\n            if (!retrieving) {\n                retrieving = true;\n                retrievalThread = new Thread(new Runnable() {\n                    public void run() {\n                        try {\n                            setImageIcon(new ImageIcon(imageURL, \"Album Cover\"));\n                            c.repaint();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                });\n                retrievalThread.start();\n            }\n        }\n    }\n}\nWriting the Image Proxy\nWe pass the URL of the image into \nthe constructor. This is the image we \nneed to display once it\u2019s loaded!\nThe imageIcon is the REAL icon that we \neventually want to display when it\u2019s loaded.\nWe return a default width and height \nuntil the imageIcon is loaded; then we \nturn it over to the imageIcon.\nHere\u2019s where things get interesting.  \nThis code paints the icon on the \nscreen (by delegating to imageIcon). \nHowever, if we don\u2019t have a fully \ncreated imageIcon, then we create \none. Let\u2019s look at this up close on the \nnext page...\n<<interface>>\nIcon\ngetIconWidth()\ngetIconHeight()\npaintIcon()\nThe ImageProxy \nimplements the Icon \ninterface.\nimageIcon is used by two different \nthreads, so along with making the variable \nvolatile (to protect reads), we use a \nsynchronized setter (to protect writes).\n", "page": 498, "type": "text", "section": "Page 498"}
{"text": "you are here 4\u2003 \u2003 461\nthe proxy pattern\n.\nCode Up Close\n   public void paintIcon(final Component c, Graphics  g, int x,  int y) {\n        if (imageIcon != null) {\n            imageIcon.paintIcon(c, g, x, y);\n        } else {\n            g.drawString(\"Loading album cover, please wait...\", x+300, y+190);\n            if (!retrieving) {\n                retrieving = true;\n                retrievalThread = new Thread(new Runnable() {\n                    public void run() {\n                        try {\n                            setImageIcon(new ImageIcon(imageURL, \"Album Cover\"));\n                            c.repaint();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                });\n                retrievalThread.start();\n            }\n        }\n    }\nThis method is called when it\u2019s time to paint the icon on the screen.\nIf we\u2019ve got an icon already, we go \nahead and tell it to paint itself.\nOtherwise we  \ndisplay the \n\u201cloading\u201d message.\nHere\u2019s where we load the REAL icon image. Note that \nthe image loading with IconImage is synchronous: the \nImageIcon constructor doesn\u2019t return until the image \nis loaded. That doesn\u2019t give us much of a chance to do \nscreen updates and have our message displayed, so we\u2019re \ngoing to do this asynchronously. See the \u201cCode Way Up \nClose\u201d on the next page for more...\n", "page": 499, "type": "text", "section": "Page 499"}
{"text": "462\u2003 \u2003 Chapter 11\nimage proxy up close\n            \n            if (!retrieving) {\n                retrieving = true;\n                retrievalThread = new Thread(new Runnable() {\n                    public void run() {\n                        try {\n                            setImageIcon(new ImageIcon(imageURL, \"Album Cover\"));\n                            c.repaint();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                });\n                retrievalThread.start();\n            }\nIn our thread we \ninstantiate the \nIcon object. Its \nconstructor will not \nreturn until the \nimage is loaded.\nIf we aren\u2019t already trying to retrieve the image...\nWe don\u2019t want to hang up the \nentire user interface, so we\u2019re \ngoing to use another thread to \nretrieve the image.\nWhen we have the image, \nwe tell Swing that we \nneed to be repainted.\nSo, the next time the display is painted after the ImageIcon is instantiated, \nthe paintIcon() method will paint the image, not the loading message.\n...then it\u2019s time to start retrieving it (in case you \nwere wondering, only one thread calls paint, so we \nshould be okay here in terms of thread safety).\nCode Way Up Close\n", "page": 500, "type": "text", "section": "Page 500"}
{"text": "you are here 4\u2003 \u2003 463\nthe proxy pattern\nclass ImageProxy implements Icon {\n    // instance variables & constructor here\n     \n    public int getIconWidth() {\n        if (imageIcon != null) {\n            return imageIcon.getIconWidth();\n        } else {\n            return 800;\n        }\n    }\n \n    public int getIconHeight() {\n        if (imageIcon != null) {\n            return imageIcon.getIconHeight();\n        } else {\n            return 600;\n        }\n    }\n     \n    public void paintIcon(final Component c, Graphics  g, int x,  int y) {\n        if (imageIcon != null) {\n            imageIcon.paintIcon(c, g, x, y);\n        } else {\n            g.drawString(\"Loading album cover, please wait...\", x+300, y+190);\n\t\n     // more code here\n        }             \n    }\n}\nThe ImageProxy class appears to have two states that are controlled \nby conditional statements. Can you think of another pattern that might \nclean up this code? How would you redesign ImageProxy?\nTwo states\nTwo states\nTwo states\n Design Puzzle\n", "page": 501, "type": "text", "section": "Page 501"}
{"text": "464\u2003 \u2003 Chapter 11\ntest drive the image proxy\npublic class ImageProxyTestDrive {\n    ImageComponent imageComponent;\n    public static void main (String[] args) throws Exception {\n        ImageProxyTestDrive testDrive = new ImageProxyTestDrive();\n    }\n \n    public ImageProxyTestDrive() throws Exception {\n        \n        // set up frame and menus\n \n        Icon icon = new ImageProxy(initialURL);\n        imageComponent = new ImageComponent(icon);\n        frame.getContentPane().add(imageComponent);\n    }\n}\nTesting the Album Cover Viewer\nHere we create an image proxy and \nset it to an initial URL. Whenever \nyou choose a selection from the Album \nmenu, you\u2019ll get a new image proxy.\nOkay, it\u2019s time to test out this fancy new virtual proxy. Behind the scenes \nwe\u2019ve been baking up a new ImageProxyTestDrive that sets up the window, \ncreates a frame, installs the menus, and creates our proxy. We don\u2019t go \nthrough all that code in gory detail here, but you can always grab the \nsource code and have a look, or check it out at the end of the chapter \nwhere we list all the source code for the Virtual Proxy.\nHere\u2019s a partial view of the test drive code:\nNext we wrap our proxy in a \ncomponent so it can be added to \nthe frame. The component will \ntake care of the proxy's width, \nheight, and similar details.\nFinally we add the proxy to the \nframe so it can be displayed.\nNow let\u2019s run the test drive:\nRunning ImageProxyT\nestDrive \nshould give you a window like this.\nUse the menu to load different album covers; watch the \nproxy display \u201cloading\u201d until the image has arrived.\nResize the window as the \u201cloading\u201d message is displayed.  \nNotice that the proxy is handling the loading without \nhanging up the Swing window.\nAdd your own favorite albums to ImageProxyTestDrive.\nThings to try...\n1\n2\n3\nFile  Edit   Window  Help  JustSomeOfTheAlbumsThatGotUsThroughThisBook\n% java ImageProxyTestDrive\nReady Bake\nCode\naphex twin\n", "page": 502, "type": "text", "section": "Page 502"}
{"text": "you are here 4\u2003 \u2003 465\nthe proxy pattern\nI\nm\na\ng\ne\nI\nc\no\nn\nget image\nget image\nWhat did we do?\nI\nm\na\ng\ne\nI\nc\no\nn\n \n \n \n \n \n \nI\nm\na\ng\ne\nPr\no\nx\ny\nimage retrieved\nimage retrieved\nWe created an ImageProxy class for the display. The \npaintIcon() method is called and ImageProxy fires off a \nthread to retrieve the image and create the ImageIcon.\npaintIcon()\npaintIcon()\nImageProxy creates a \nthread to instantiate the \nImageIcon, which starts \nretrieving the image.\ndisplays loading \ndisplays loading \nmessage\nmessage\nAt some point the image is returned and \nthe ImageIcon fully instantiated.\nAfter the ImageIcon is created, the next time paintIcon() \nis called, the proxy delegates to the ImageIcon.\nI\nm\na\ng\ne\nI\nc\no\nn\n \n \n \n \n \n \nI\nm\na\ng\ne\nPr\no\nx\ny\npaintIcon()\npaintIcon()\ndisplays the real image\ndisplays the real image\npaintIcon()\npaintIcon()\n1\n2\n3\nSome image \nSome image \nserver on \nserver on \nthe internet\nthe internet\nBehind \nthe Scenes\n", "page": 503, "type": "text", "section": "Page 503"}
{"text": "466\u2003 \u2003 Chapter 11\nq&a about the image proxy\nQ: The Remote Proxy and Virtual \nProxy seem so different to me; are \nthey really ONE pattern?\nA: You\u2019ll find a lot of variants of the \nProxy Pattern in the real world; what \nthey all have in common is that they \nintercept a method invocation that the \nclient is making on the subject. This \nlevel of indirection allows us to do \nmany things, including dispatching \nrequests to a remote subject, providing \na representative for an expensive \nobject as it is created, or, as you\u2019ll see, \nproviding some level of protection that \ncan determine which clients should be \ncalling which methods. That\u2019s just the \nbeginning; the general Proxy Pattern \ncan be applied in many different ways, \nand we\u2019ll cover some of the other ways \nat the end of the chapter.\nQ: ImageProxy seems just like \na Decorator to me. I mean, we are \nbasically wrapping one object with \nanother and then delegating the calls \nto the ImageIcon. What am I missing?\nA: Sometimes Proxy and Decorator \nlook very similar, but their purposes are \ndifferent: a decorator adds behavior to \na class, while a proxy controls access \nto it. You might ask, \u201cIsn\u2019t the loading \nmessage adding behavior?\u201d In some \nways it is; however, more importantly,  \nthe ImageProxy is controlling access \nto an ImageIcon. How does it control \naccess? Well, think about it this way: \nthe proxy is decoupling the client from \nthe ImageIcon. If they were coupled \n\nthe client would have to wait until each \nimage is retrieved before it could paint \nits entire interface. The proxy controls \naccess to the ImageIcon so that before \nit is fully created, the proxy provides \nanother onscreen representation. Once \nthe ImageIcon is created, the proxy \nallows access.  \nQ: How do I make clients use the \nProxy rather than the Real Subject? \nA: Good question. One common \ntechnique is to provide a factory that \ninstantiates and returns the subject. \nBecause this happens in a factory \nmethod, we can then wrap the subject \nwith a proxy before returning it. The \nclient never knows or cares that it\u2019s \nusing a proxy instead of the real thing.\nQ: I noticed in the ImageProxy \nexample, you always create a new \nImageIcon to get the image, even if \nthe image has already been retrieved. \n \nCould you implement something \nsimilar to the ImageProxy that \ncaches past retrievals?\nA: You are talking about a \nspecialized form of a Virtual Proxy \ncalled a Caching Proxy. A caching proxy \nmaintains a cache of previously created \nobjects and when a request is made it \nreturns a cached object, if possible.\n\nWe\u2019re going to look at this and at \nseveral other variants of the Proxy \nPattern at the end of the chapter.\nQ: I see how Decorator and Proxy \nrelate, but what about Adapter? An \nadapter seems very similar as well.\nA: Both Proxy and Adapter sit in front \nof other objects and forward requests to \nthem. Remember that Adapter changes \nthe interface of the objects it adapts, \nwhile Proxy implements the same \ninterface.\n\nThere is one additional similarity that \nrelates to the Protection Proxy. A \nProtection Proxy may allow or disallow \na client access to particular methods \nin an object based on the role of the \nclient. In this way a Protection Proxy \nmay only provide a partial interface to \na client, which is quite similar to some \nAdapters. We are going to take a look at \nProtection Proxy in a few pages.\n", "page": 504, "type": "text", "section": "Page 504"}
{"text": "you are here 4\u2003 \u2003 467\nthe proxy pattern\nTonight\u2019s talk: Proxy and Decorator get intentional.\nProxy:\nHello, Decorator.  I presume you\u2019re here because \npeople sometimes get us confused?\n\n\n\nMe copying your ideas? Please. I control access to \nobjects. You just decorate them. My job is so much \nmore important than yours it\u2019s just not even funny.\n\n\n\nFine, so maybe you\u2019re not entirely frivolous...but I \nstill don\u2019t get why you think I\u2019m copying all your \nideas. I\u2019m all about representing my subjects, not \ndecorating them.\n\n\n\n\n\nI don\u2019t think you get it, Decorator. I stand in for \nmy Subjects; I don\u2019t just add behavior. Clients use \nme as a surrogate of a Real Subject, because I can \nprotect them from unwanted access, or keep their \nGUIs from hanging up while they\u2019re waiting for big \nobjects to load, or hide the fact that their Subjects \nare running on remote machines. I\u2019d say that\u2019s a \nvery different intent from yours!\nDecorator:\n\n\nWell, I think the reason people get us confused is \nthat you go around pretending to be an entirely \ndifferent pattern, when in fact, you\u2019re just Decorator \nin disguise. I really don\u2019t think you should be \ncopying all my ideas.\n\n\n\u201cJust\u201d decorate? You think decorating is some \nfrivolous, unimportant pattern? Let me tell you \nbuddy, I add behavior. That\u2019s the most important \nthing about objects\u2014what they do!\n\n\nYou can call it \u201crepresentation\u201d but if it looks like \na duck and walks like a duck... I mean, just look at  \nyour Virtual Proxy; it\u2019s just another way of adding \nbehavior to do something while some big expensive \nobject is loading, and your Remote Proxy is a way \nof talking to remote objects so your clients don\u2019t \nhave to bother with that themselves. It\u2019s all about \nbehavior, just like I said. \n\n\n\n\n\n\n\nCall it what you want. I implement the same \ninterface as the objects I wrap; so do you.\n", "page": 505, "type": "text", "section": "Page 505"}
{"text": "468\u2003 \u2003 Chapter 11\nfireside chats: proxy and decorator\nProxy:\nOkay, let\u2019s review that statement. You wrap an \nobject. While sometimes we informally say a proxy \nwraps its Subject, that\u2019s not really an accurate term.\n\n\nThink about a remote proxy...what object am \nI wrapping? The object I\u2019m representing and \ncontrolling access to lives on another machine!  \nLet\u2019s see you do that.\n\nSure, okay, take a virtual proxy...think about the \nalbum viewer example. When the client first uses \nme as a proxy the subject doesn\u2019t even exist! So \nwhat am I wrapping there? \n\n\n\nI never knew decorators were so dumb! Of course \nI sometimes create objects. How do you think a \nvirtual proxy gets its subject?! Okay, you just pointed \nout a big difference between us: we both know \ndecorators only add window dressing; they never get \nto instantiate anything.\n\n\nHey, after this conversation I\u2019m convinced you\u2019re \njust a dumb proxy!\n\n\n\nVery seldom will you ever see a proxy get into \nwrapping a subject multiple times; in fact, if you\u2019re \nwrapping something 10 times, you better go back \nreexamine your design.\nDecorator:\n\n\n\n\nOh yeah? Why not?\n\n\n\nOkay, but we all know remote proxies are kinda \nweird. Got a second example? I doubt it.\n\n\n\nUh huh, and the next thing you\u2019ll be saying is that \nyou actually get to create objects.\n\n\n\n\n\n\n\nOh yeah? Instantiate this!\n\n\nDumb proxy? I\u2019d like to see you recursively wrap \nan object with 10 decorators and keep your head \nstraight at the same time.\n\n\n\n\nJust like a proxy, acting all real when in fact you just \nstand in for the objects doing the real work. You \nknow, I actually feel sorry for you.\n", "page": 506, "type": "text", "section": "Page 506"}
{"text": "you are here 4\u2003 \u2003 469\nthe proxy pattern\nUsing the Java API\u2019s Proxy to create a \nprotection proxy\nJava\u2019s got its own proxy support right in the java.lang.reflect package. With this package, \nJava lets you create a proxy class on the fly that implements one or more interfaces and \nforwards method invocations to a class that you specify. Because the actual proxy class is \ncreated at runtime, we refer to this Java technology as a dynamic proxy.\nWe\u2019re going to use Java\u2019s dynamic proxy to create our next proxy implementation (a \nprotection proxy), but before we do that, let\u2019s quickly look at a class diagram that shows \nhow dynamic proxies are put together. Like most things in the real world, it differs \nslightly from the classic definition of the pattern:\n<<interface>>\nSubject\nrequest()\nRealSubject\nrequest()\nProxy\nrequest()\n<<interface>>\nInvocationHandler\ninvoke()\nInvocationHandler\nThe Proxy now consists \nof two classes.\nThe Proxy is generated \nby Java and implements \nthe entire Subject \ninterface.\nYou supply the InvocationHandler, which gets passed \nall method calls that are invoked on the Proxy.  \nThe InvocationHandler controls access to the \nmethods of the RealSubject.\nBecause Java creates the Proxy class for you, you need a way to tell the Proxy class what \nto do. You can\u2019t put that code into the Proxy class like we did before, because you\u2019re not \nimplementing one directly. So, if you can\u2019t put this code in the Proxy class, where do \nyou put it? In an InvocationHandler. The job of the InvocationHandler is to respond to \nany method calls on the proxy. Think of the InvocationHandler as the object the Proxy \nasks to do all the real work after it has received the method calls.\nOkay, let\u2019s step through how to use the dynamic proxy...\ninvoke()\n", "page": 507, "type": "text", "section": "Page 507"}
{"text": "470\u2003 \u2003 Chapter 11\nprotection proxy\npublic interface Person {\n \n    String getName();\n    String getGender();\n    String getInterests();\n    int getGeekRating();\n \n    void setName(String name);\n    void setGender(String gender);\n    void setInterests(String interests);\n    void setGeekRating(int rating); \n \n}\nGeeky Matchmaking in Objectville\nEvery town needs a matchmaking service, right? You\u2019ve risen to the task and \nimplemented a dating service for Objectville. You\u2019ve also tried to be innovative \nby including a \u201cGeek rating\u201d feature where participants can rate each other\u2019s \ngeekiness (a good thing)\u2014you figure this keeps your customers engaged and \nlooking through possible matches; it also makes things a lot more fun.\nYour service revolves around a Person interface that allows you to set and get \ninformation about a person:\nHere we can get information \nabout the person\u2019s name, \ngender, interests, and Geek \nrating (1-10).\nWe can also set the same \ninformation through the \nrespective method calls.\nsetGeekRating() takes an integer \nand adds it to the running \naverage for this person.\nThis is the interface; we\u2019ll \nget to the implementation \nin just a sec...\nNow let\u2019s check out the implementation...\n", "page": 508, "type": "text", "section": "Page 508"}
{"text": "you are here 4\u2003 \u2003 471\nthe proxy pattern\npublic class PersonImpl implements Person {\n    String name;\n    String gender;\n    String interests;\n    int rating;\n    int ratingCount = 0;\n  \n    public String getName() {\n        return name;    \n    } \n  \n    public String getGender() {\n        return gender;\n    }\n  \n    public String getInterests() {\n        return interests;\n    }\n   \n    public int getGeekRating() {\n        if (ratingCount == 0) return 0;\n        return (rating/ratingCount);\n    }\n  \n \n    public void setName(String name) {\n        this.name = name;\n    }\n \n    public void setGender(String gender) {\n        this.gender = gender;\n    } \n  \n    public void setInterests(String interests) {\n        this.interests = interests;\n    } \n  \n    public void setGeekRating(int rating) {\n        this.rating += rating;  \n        ratingCount++;\n    }\n}\nThe instance variables.\nThe PersonImpl implements the Person interface.\nAll the getter methods; they each return \nthe appropriate instance variable...\n...except for getGeekRating(), \nwhich computes the average \nof the ratings by dividing the \nratings by the ratingCount.\nAnd here\u2019s all the setter \nmethods, which set the \ncorresponding instance variable.\nFinally, the setGeekRating() method \nincrements the total ratingCount and \nadds the rating to the running total.\nThe Person implementation\n", "page": 509, "type": "text", "section": "Page 509"}
{"text": "472\u2003 \u2003 Chapter 11\nperson needs protecting\nWhile we suspect other factors may be keeping Elroy from getting \ndates, he\u2019s right: you shouldn\u2019t be able to vote for yourself or to \nchange another customer\u2019s data. The way Person is defined, any client \ncan call any of the methods.\nThis is a perfect example of where we might be able to use a \nProtection Proxy. What\u2019s a Protection Proxy? It\u2019s a proxy that controls \naccess to an object based on access rights. For instance, if we had an \nemployee object, a Protection Proxy might allow the employee to call \ncertain methods on the object, a manager to call additional methods \n(like setSalary()), and a human resources employee to call any method \non the object.\nIn our dating service we want to make sure that a customer can set \nhis own information while preventing others from altering it. We also \nwant to allow just the opposite with the Geek ratings: we want the \nother customers to be able to set the rating, but not that particular \ncustomer. We also have a number of getter methods in Person, and \nbecause none of these return private information, any customer \nshould be able to call them.\nElroy\nI wasn\u2019t very successful finding dates. \nThen I noticed someone had changed my \ninterests. I also noticed that a lot of \npeople are bumping up their Geek scores \nby giving themselves high ratings. You \nshouldn\u2019t be able to change someone else\u2019s \ninterests or give yourself a rating!\n", "page": 510, "type": "text", "section": "Page 510"}
{"text": "you are here 4\u2003 \u2003 473\nthe proxy pattern\nFive-minute drama: protecting subjects\nThe internet bubble seems a distant memory; those were the days \nwhen all you needed to do to find a better, higher-paying job was \nto walk across the street. Even agents for software developers \nwere in vogue...\nLike a protection \nproxy, the agent \nprotects access to his \nsubject, letting only \ncertain calls through...\nAgent\nJane DotCom\nI\u2019d like to make an \noffer, can we get her on \nthe phone?\nCome on.  \nYou\u2019re wasting our time \nhere! Not a chance! Come \nback later with a better \noffer.\nShe\u2019s tied up...uh...\nin a meeting right now, \nwhat did you have in \nmind?\nWe think we can \nmeet her current \nsalary plus 15%.\nSubject\n", "page": 511, "type": "text", "section": "Page 511"}
{"text": "474\u2003 \u2003 Chapter 11\nbig picture of proxy\nBig Picture: creating a Dynamic Proxy \nfor the Person\nWe have a couple of problems to fix: customers shouldn\u2019t be changing their \nown Geek rating and customers shouldn\u2019t be able to change other customers\u2019 \npersonal information. To fix these problems we\u2019re going to create two proxies: \none for accessing your own Person object and one for accessing another \ncustomer\u2019s Person object. That way, the proxies can control what requests can \nbe made in each circumstance.\n<<interface>>\nSubject\nrequest()\nRealSubject\nrequest()\nProxy\nrequest()\n<<interface>>\nInvocationHandler\ninvoke()\nInvocationHandler\nCreate two InvocationHandlers.\nWrite the code that creates the \ndynamic proxies.\nWrap any Person object with the \nappropriate proxy.\nInvocationHandlers implement the behavior \nof the proxy. As you\u2019ll see, Java will take care \nof creating the actual proxy class and object; \nwe just need to supply a handler that knows \nwhat to do when a method is called on it.\nWe need to write a little bit of code to \ngenerate the proxy class and instantiate it. \nWe\u2019ll step through this code in just a bit.\nWhen we need to use a Person object, either it\u2019s \nthe object of the customer himself (in that case, \nwe\u2019ll call him the \u201cowner\u201d), or it\u2019s another user \nof the service that the customer is checking out \n(in that case we\u2019ll call him \u201cnon-owner\u201d).  \nIn either case, we create the appropriate proxy \nfor the Person.\nStep one:\nStep two:\nStep three:\nWe need two \nof these.\nWe create the \nproxy itself at \nruntime.\nrequest()\nProxy\ninvoke()\nOwnerInvocationHandler\nrequest()\nProxy\ninvoke()\nNonOwnerInvocationHandler\nWhen a customer is viewing his own bean\nWhen a customer is viewing someone else\u2019s bean\ninvoke()\nTo create these proxies we\u2019re going to use the Java \nAPI\u2019s dynamic proxy that you saw a few pages \nback. Java will create two proxies for us; all we \nneed to do is supply the handlers that know what \nto do when a method is invoked on the proxy.\nRemember this diagram \nfrom a few pages back...\n", "page": 512, "type": "text", "section": "Page 512"}
{"text": "you are here 4\u2003 \u2003 475\nthe proxy pattern\nStep one: creating Invocation Handlers\nWe know we need to write two invocation handlers, one for the owner and one for \nthe non-owner. But what are invocation handlers? Here\u2019s the way to think about \nthem: when a method call is made on the proxy, the proxy forwards that call to \nyour invocation handler, but not by calling the invocation handler\u2019s corresponding \nmethod. So, what does it call? Have a look at the InvocationHandler interface:\nThere\u2019s only one method, invoke(), and no matter what methods get called \non the proxy, the invoke() method is what gets called on the handler. Let\u2019s see \nhow this works:\nproxy.setGeekRating(9);\ninvoke(Object proxy, Method method, Object[] args)\nLet\u2019s say the setGeekRating() \nmethod is called on the proxy.\nThe proxy then \nturns around and \ncalls invoke() on the \nInvocationHandler.\n1\n2\nThe handler decides \nwhat it should do \nwith the request \nand possibly \nforwards it on to \nthe RealSubject. \nHow does the \nhandler decide? \nWe\u2019ll find out next.\n3\nreturn method.invoke(person, args);\nHere we invoke the \noriginal method that was \ncalled on the proxy. This \nobject was passed to us in \nthe invoke call.\nOnly now we \ninvoke it on the \nRealSubject...\n...with the original \narguments.\nHere\u2019s how \nwe invoke the \nmethod on the \nRealSubject.\nThe Method class, part of the \nreflection API, tells us what \nmethod was called on the proxy \nvia its getName() method.\n<<interface>>\nInvocationHandler\ninvoke()\n", "page": 513, "type": "text", "section": "Page 513"}
{"text": "476\u2003 \u2003 Chapter 11\ncreating an invocation handler\nimport java.lang.reflect.*;\n \npublic class OwnerInvocationHandler implements InvocationHandler { \n    Person person;\n \n    public OwnerInvocationHandler(Person person) {\n        this.person = person;\n    }\n \n    public Object invoke(Object proxy, Method method, Object[] args) \n            throws IllegalAccessException {\n  \n        try {\n            if (method.getName().startsWith(\"get\")) {\n                return method.invoke(person, args);\n            } else if (method.getName().equals(\"setGeekRating\")) {\n                throw new IllegalAccessException();\n            } else if (method.getName().startsWith(\"set\")) {\n                return method.invoke(person, args);\n            } \n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        } \n        return null;\n    }\n}\nCreating Invocation Handlers, continued...\nWhen invoke() is called by the proxy, how do you know what to do with the call?  \nTypically, you\u2019ll examine the method that was called on the proxy and make \ndecisions based on the method\u2019s name and possibly its arguments. Let\u2019s implement \nOwnerInvocationHandler to see how this works:\nInvocationHandler is part of the java.lang.reflect \npackage, so we need to import it.\nAll invocation handlers \nimplement the \nInvocationHandler interface.\nWe're passed the \nRealSubject in the \nconstructor and we \nkeep a reference to it.\nHere\u2019s the invoke() \nmethod that gets \ncalled every time a \nmethod is invoked \non the proxy.\nIf the method is a getter, \nwe go ahead and invoke it \non the real subject.\nOtherwise, if it is \nthe setGeekRating() \nmethod we disallow \nit by throwing \nIllegalAccessException.\nBecause we are the \nowner, any other set \nmethod is fine and we \ngo ahead and invoke it \non the real subject.\nIf any other method is called, \nwe\u2019re just going to return null \nrather than take a chance.\nThis will happen if \nthe real subject \nthrows an exception.\n", "page": 514, "type": "text", "section": "Page 514"}
{"text": "you are here 4\u2003 \u2003 477\nthe proxy pattern\nThe NonOwnerInvocationHandler works just like the OwnerInvocationHandler except \nthat it allows calls to setGeekRating() and it disallows calls to any other set method.  \nGo ahead and write this handler yourself:\n", "page": 515, "type": "text", "section": "Page 515"}
{"text": "478\u2003 \u2003 Chapter 11\ncreate the proxy\nPerson getOwnerProxy(Person person) {\n    \n    return (Person) Proxy.newProxyInstance( \n            person.getClass().getClassLoader(),\n            person.getClass().getInterfaces(),\n            new OwnerInvocationHandler(person));\n}\nNow, all we have left is to dynamically create the Proxy class and instantiate the proxy \nobject. Let\u2019s start by writing a method that takes a Person object and knows how to create \nan owner proxy for it. That is, we\u2019re going to create the kind of proxy that forwards its \nmethod calls to OwnerInvocationHandler. Here\u2019s the code:\nStep two: creating the Proxy class and \ninstantiating the Proxy object\nThis method takes a Person object (the real \nsubject) and returns a proxy for it. Because the \nproxy has the same interface as the subject, we \nreturn a Person.\nThis code creates the \nproxy. Now this is some \nmighty ugly code, so let\u2019s \nstep through it carefully.\nT\no create a proxy we use the \nstatic newProxyInstance() \nmethod on the Proxy class.\nWe pass it the class loader for our subject...\n...and the set of interfaces the \nproxy needs to implement...\n...and an invocation handler, in this \ncase our OwnerInvocationHandler.\nWe pass the real subject into the constructor of \nthe invocation handler. If you look back two pages, \nyou\u2019ll see this is how the handler gets access to \nthe real subject.\nWhile it is a little complicated, there isn\u2019t much to creating \na dynamic proxy. Why don\u2019t you write getNonOwnerProxy(), \nwhich returns a proxy for NonOwnerInvocationHandler:\nTake it further: can you write a method called getProxy() that takes \na handler and a person and returns a proxy that uses that handler?\n", "page": 516, "type": "text", "section": "Page 516"}
{"text": "you are here 4\u2003 \u2003 479\nthe proxy pattern\npublic class MatchMakingTestDrive {\n    // instance variables here\n  \n    public static void main(String[] args) {\n        MatchMakingTestDrive test = new MatchMakingTestDrive();\n        test.drive();\n    }\n \n    public MatchMakingTestDrive() {\n        initializeDatabase();\n    }\n    public void drive() {\n        Person joe = getPersonFromDatabase(\"Joe Javabean\"); \n        Person ownerProxy = getOwnerProxy(joe);\n        System.out.println(\"Name is \" + ownerProxy.getName());\n        ownerProxy.setInterests(\"bowling, Go\");\n        System.out.println(\"Interests set from owner proxy\");\n        try {\n            ownerProxy.setGeekRating(10);\n        } catch (Exception e) {\n            System.out.println(\"Can't set rating from owner proxy\");\n        }\n        System.out.println(\"Rating is \" + ownerProxy.getGeekRating());\n        Person nonOwnerProxy = getNonOwnerProxy(joe);\n        System.out.println(\"Name is \" + nonOwnerProxy.getName());\n        try {\n            nonOwnerProxy.setInterests(\"bowling, Go\");\n        } catch (Exception e) {\n            System.out.println(\"Can't set interests from non owner proxy\");\n        }\n        nonOwnerProxy.setGeekRating(3);\n        System.out.println(\"Rating set from non owner proxy\");\n        System.out.println(\"Rating is \" + nonOwnerProxy.getGeekRating());\n    }\n    // other methods like getOwnerProxy and getNonOwnerProxy here\n}\nTesting the matchmaking service\nLet\u2019s give the matchmaking service a test run and see how it controls access to \nthe setter methods based on the proxy that is used.\nThe main() method just creates \nthe test drive and calls its drive() \nmethod to get things going.\nThe constructor initializes our database \nof people in the matchmaking service.\nLet\u2019s retrieve a person \nfrom the database...\n...and create an owner proxy.\nCall a getter...\n...and then a setter.\nAnd then try to \nchange the rating.\nThis shouldn\u2019t work!\nNow create a non-\nowner proxy...\n...and call a getter...\n...followed by a \nsetter.\nThis shouldn\u2019t work!\nThen try to set \nthe rating.\nThis should work!\n", "page": 517, "type": "text", "section": "Page 517"}
{"text": "480\u2003 \u2003 Chapter 11\ntest drive the protection proxy\nFile  Edit   Window  Help  Born2BDynamic\n% java MatchMakingTestDrive \nName is Joe Javabean\nInterests set from owner proxy\nCan't set rating from owner proxy\nRating is 7\nName is Joe Javabean\nCan't set interests from non owner proxy\nRating set from non owner proxy\nRating is 5\n%\nRunning the code...\nOur Owner proxy allows \ngetting and setting, \nexcept for the Geek \nrating.\nOur NonOwner proxy allows \ngetting only, but also \nallows calls to set the Geek \nrating.\nThe new rating is the average of the previous rating, 7, \nand the value set by the NonOwner proxy, 3.\nQ: So what exactly is the \u201cdynamic\u201d \naspect of dynamic proxies? Is it that I\u2019m \ninstantiating the proxy and setting it to a \nhandler at runtime?\nA: No, the proxy is dynamic because \nits class is created at runtime. Think about \nit: before your code runs there is no proxy \nclass; it is created on demand from the set of \ninterfaces you pass it.\nQ: My InvocationHandler seems like a \nvery strange proxy; it doesn\u2019t implement \nany of the methods of the class it\u2019s \nproxying.\nA: That\u2019s because the InvocationHandler \nisn\u2019t a proxy\u2014it\u2019s a class that the proxy \ndispatches to for handling method calls. The \nproxy itself is created dynamically at runtime  \nby the static Proxy.newProxyInstance() \nmethod. \nQ: Is there any way to tell if a class is \na Proxy class? \nA: Yes. The Proxy class has a static \nmethod called isProxyClass(). Calling this \nmethod with a class will return true if the \nclass is a dynamic proxy class. Other than \nthat, the proxy class will act like any other \nclass that implements a particular set of \ninterfaces.\nQ: Are there any restrictions on \nthe types of interfaces I can pass into \nnewProxyInstance()?\nA: Yes, there are a few. First, it \nis worth pointing out that we always \npass newProxyInstance() an array of \ninterfaces\u2014only interfaces are allowed, no \nclasses. The major restrictions are that \nall non-public interfaces need to be from \nthe same package. You also can\u2019t have \ninterfaces with clashing method names \n(that is, two interfaces with a method with \nthe same signature). There are a few other \nminor nuances as well, so at some point \nyou should take a look at the fine print on \ndynamic proxies in the javadoc.\n", "page": 518, "type": "text", "section": "Page 518"}
{"text": "you are here 4\u2003 \u2003 481\nthe proxy pattern\nMatch each pattern with its description:\nPattern\nDescription\nDecorator\nFacade\nProxy\nAdapter\nWraps another object \nand provides a different \ninterface to it.\nWraps another object \nand provides additional \nbehavior for it.\nWraps another object \nto control access to it.\nWraps a bunch of \nobjects to simplify \ntheir interface.\n", "page": 519, "type": "text", "section": "Page 519"}
{"text": "482\u2003 \u2003 Chapter 11\nthe proxy zoo\nThe Proxy Zoo\nWelcome to the Objectville Zoo!  \nYou now know about the remote, virtual, and protection proxies, but \nout in the wild you\u2019re going to see lots of mutations of this pattern. \nOver here in the Proxy corner of the zoo we\u2019ve got a nice collection \nof wild proxy patterns that we\u2019ve captured for your study.\nOur job isn\u2019t done; we\u2019re sure you\u2019re going to see more variations of \nthis pattern in the real world, so give us a hand in cataloging more \nproxies. Let\u2019s take a look at the existing collection:\nCaching Proxy provides \ntemporary storage for \nresults of operations \nthat are expensive. It \ncan also allow multiple clients to share \nthe results to reduce computation or \nnetwork latency.\nFirewall Proxy \ncontrols access to a \nset of network \nresources, protecting \nthe subject from \u201cbad\u201d clients.\nSmart Reference Proxy \nprovides additional actions \nwhenever a subject is \nreferenced, such as counting \nthe number of references to \nan object.\nHabitat: often seen in the location \nof corporate firewall systems.\nHabitat: often seen in web server proxies as well \nas content management and publishing systems.\nHelp find a habitat\n", "page": 520, "type": "text", "section": "Page 520"}
{"text": "you are here 4\u2003 \u2003 483\nthe proxy pattern\nSynchronization Proxy \nprovides safe access to a \nsubject from multiple threads.\nComplexity Hiding Proxy \nhides the complexity of \nand controls access to a \ncomplex set of classes. \nThis is sometimes called \nthe Facade Proxy for obvious reasons. \nThe Complexity Hiding Proxy differs from \nthe Facade Pattern in that the proxy \ncontrols access, while the Facade Pattern \njust provides an alternative interface.\nCopy-On-Write Proxy \ncontrols the copying of \nan object by deferring \nthe copying of an \nobject until it is required by \na client. This is a variant of \nthe Virtual Proxy.\nSeen hanging around Collections, where it controls \nsynchronized access to an underlying set of objects \nin a multithreaded environment.\nField Notes: please add your observations of other proxies in the wild here:\nHabitat: seen in the vicinity of the \nJava\u2019s CopyOnWriteArrayList.\nHelp find a habitat\n", "page": 521, "type": "text", "section": "Page 521"}
{"text": "484\u2003 \u2003 Chapter 11\ncrossword puzzle\nDesign Patterns Crossword\nIt\u2019s been a LONG chapter. Why not unwind by doing a \ncrossword puzzle before it ends?\nACROSS\n5. Group of first album cover displayed (two words).\n7. Commonly used proxy for web services (two words).\n8. In RMI, the object that takes the network requests on \nthe service side.\n11. Proxy that protects method calls from unauthorized \ncallers.\n13. Group that did the album MCMXC a.D.\n14. A ________ proxy class is created at runtime.\n15. Place to learn about the many proxy variants.\n16. The Album viewer used this kind of proxy.\n17. In RMI, the proxy is called this.\n18. We took one of these to learn RMI.\n19. Why Elroy couldn\u2019t get dates.\nDOWN\n1. Objectville Matchmaking is for ________.\n2. Java\u2019s dynamic proxy forwards all requests to this (two \nwords).\n3. This utility acts as a lookup service for RMI.\n4. Proxy that stands in for expensive objects.\n6. Remote ______ was used to implement the gumball \nmachine monitor (two words).\n9. Software developer agent was being this kind of proxy.\n10. Our first mistake: the gumball machine reporting was \nnot _____.\n12. Similar to proxy, but with a different purpose.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nAcross\n5. Group of first Album cover displayed (two \nwords)\n7. Commonly used proxy for web services (two \nwords)\n8. In RMI, the object that takes the network \nrequests on the service side\n11. Proxy that protects method calls from \nunauthorized callers\n13. Group that did the album MCMXC A.D.\n14. A _______ proxy class is created at runtime\n15. Place to learn about the many proxy variants\n16. The Album viewer used this kind of proxy\n17. In RMI, the proxy is called this\n18. We took one of these to learn RMI\n19. Why Elroy couldn't get dates\nDown\n1. Objectville Matchmaking is for _____\n2. Java's dynamic proxy forwards all requests \nto this (two words)\n3. This utility acts as a lookup service for RMI\n4. Proxy that stands in for expensive objects\n6. Remote ________  was used to implement \nthe gumball machine monitor (two words)\n9. Software developer agent was being this kind \nof proxy\n10. Our first mistake: the gumball machine \nreporting was not _______\n12. Similar to proxy, but with a different \npurpose\n", "page": 522, "type": "text", "section": "Page 522"}
{"text": "you are here 4\u2003 \u2003 485\nthe proxy pattern\nTools for your Design Toolbox\nYour design toolbox is almost full; you\u2019re prepared for \nalmost any design problem that comes your way.\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable.  Strategy lets the algorithm \nvary independently from clients that use it.\nOO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically.  \nDecorators provide a flexible \nalternative to subclassing for extending \nfunctionality.\nAbstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes.\nFactory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate.  Factory Method lets \na class defer instantiation to the \nsubclasses.\nSingleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it.\nCommand - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nAdapter - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nNo new principles this \nchapter; can you close the \nbook and remember them all?\nFacade - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nOur new pattern.  \nA Proxy acts as a \nrepresentative for \nanother object.\nState - Allow an object to alter its \nbehavior when its internal state changes. \n \nThe object will appear to change its \nclass.\nEncapsulate what varies.\nFavor composition over inheritance.\nProgram to interfaces, not \nimplementations.\nStrive for loosely coupled designs \nbetween objects that interact.\nClasses should be open for extension \nbut closed for modification.\nDepend on abstractions. Do not \ndepend on concrete classes.\nOnly talk to your friends.\nDon\u2019t call us, we\u2019ll call you.\nA class should have only one reason \nto change.\nOO Principles\nProxy - Provide a surrogate or \nplaceholder for another object to \ncontrol access to it.\n\t\n\u0083\nThe Proxy Pattern provides \na representative for another \nobject in order to control the \nclient\u2019s access to it. There \nare a number of ways it can \nmanage that access.\n\t\n\u0083\nA Remote Proxy manages \ninteraction between a client \nand a remote object.\n\t\n\u0083\nA Virtual Proxy controls \naccess to an object that is \nexpensive to instantiate.\n\t\n\u0083\nA Protection Proxy controls \naccess to the methods of an \nobject based on the caller.\n\t\n\u0083\nMany other variants of \nthe Proxy Pattern exist \nincluding caching proxies, \nsynchronization proxies, \nfirewall proxies, copy-on-write \nproxies, and so on.\n\t\n\u0083\nProxy is structurally similar \nto Decorator, but the two \npatterns differ in their purpose.\n\t\n\u0083\nThe Decorator Pattern adds \nbehavior to an object, while \nProxy controls access.\n\t\n\u0083\nJava\u2019s built-in support for \nProxy can build a dynamic \nproxy class on demand and \ndispatch all calls on it to a \nhandler of your choosing.\n\t\n\u0083\nLike any wrapper, proxies \nwill increase the number of \nclasses and objects in your \ndesigns.\n", "page": 523, "type": "text", "section": "Page 523"}
{"text": "486\u2003 \u2003 Chapter 11\nexercise solutions\nimport java.lang.reflect.*;\n \npublic class NonOwnerInvocationHandler implements InvocationHandler { \n    Person person;\n \n    public NonOwnerInvocationHandler(Person person) {\n        this.person = person;\n    }\n \n    public Object invoke(Object proxy, Method method, Object[] args) \n            throws IllegalAccessException {\n  \n        try {\n            if (method.getName().startsWith(\"get\")) {\n                return method.invoke(person, args);\n            } else if (method.getName().equals(\"setGeekRating\")) {\n                return method.invoke(person, args);\n            } else if (method.getName().startsWith(\"set\")) {\n                throw new IllegalAccessException();\n            } \n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        } \n        return null;\n    }\n}\nThe NonOwnerInvocationHandler works just like the OwnerInvocationHandler except \nthat it allows calls to setGeekRating() and it disallows calls to any other set method.  \nHere\u2019s our solution:\nThe ImageProxy class appears to have two states that are controlled \nby conditional statements. Can you think of another pattern that might \nclean up this code? How would you redesign ImageProxy?\n Design Puzzle Solution\nUse the State Pattern: implement two states, ImageLoaded and ImageNotLoaded. Then put \nthe code from the if statements into their respective states. Start in the ImageNotLoaded state \nand then transition to the ImageLoaded state once the ImageIcon had been retrieved.\n", "page": 524, "type": "text", "section": "Page 524"}
{"text": "you are here 4\u2003 \u2003 487\nthe proxy pattern\nG\n1\nI\n2\nR\n3\nV\n4\nA\n5\nP\nH\nE\nX\nT\nW\nI\nN\nM\nM\n6\nI\nE\nV\nI\nW\n7\nE\nB\nP\nR\nO\nX\nY\nS\n8\nK\nE\nL\nE\nT\nO\nN\nR\nT\nT\nS\nC\nP\n9\nE\nH\nU\nA\nR\nG\nO\nA\nT\nO\nI\nD\nL\nI\nT\nS\nI\nR\n10\nP\n11\nR\nO\nT\nE\nC\nT\nI\nO\nN\nD\n12\nE\nN\nC\nR\nV\nE\n13\nN\nI\nG\nM\nA\nH\nT\nY\nO\nC\nO\nD\n14\nY\nN\nA\nM\nI\nC\nC\nZ\n15\nO\nO\nT\nN\nO\nA\nR\nE\nD\nN\nT\nA\nV\n16\nI\nR\nT\nU\nA\nL\nI\nS\n17\nT\nU\nB\nE\nO\nO\nD\n18\nE\nT\nO\nU\nR\nS\n19\nU\nS\nP\nE\nN\nD\nE\nR\nS\nAcross\n5. Group of first Album cover displayed (two \nwords) [APHEXTWIN] \n7. Commonly used proxy for web services (two \nDown\n1. Objectville Matchmaking is for _____ \n[GEEKS] \n2. Java's dynamic proxy forwards all requests \nPerson getNonOwnerProxy(Person person) {\n    \n    return (Person) Proxy.newProxyInstance(\n            person.getClass().getClassLoader(),\n            person.getClass().getInterfaces(),\n            new NonOwnerInvocationHandler(person));\n}\nWhile it is a little complicated, there isn\u2019t much to creating a dynamic \nproxy. Why don\u2019t you write getNonOwnerProxy(), which returns a \nproxy for the NonOwnerInvocationHandler? Here\u2019s our solution:\nDesign Patterns Crossword Solution\n", "page": 525, "type": "text", "section": "Page 525"}
{"text": "488\u2003 \u2003 Chapter 11\nexercise solutions\nMatch each pattern with its description:\nPattern\nDescription\nDecorator\nFacade\nProxy\nAdapter\nWraps another object \nand provides a different \ninterface to it.\nWraps another object \nand provides additional \nbehavior for it.\nWraps another object \nto control access to it.\nWraps a bunch of \nobjects to simplify \ntheir interface.\nSOlUTion\n", "page": 526, "type": "text", "section": "Page 526"}
{"text": "you are here 4\u2003 \u2003 489\nthe proxy pattern\nThe code for the Album Cover Viewer\nReady Bake\nCode\npackage headfirst.designpatterns.proxy.virtualproxy;\nimport java.net.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\nimport java.util.*;\npublic class ImageProxyTestDrive {\n    ImageComponent imageComponent;\n    JFrame frame = new JFrame(\"Album Cover Viewer\");\n    JMenuBar menuBar;\n    JMenu menu;\n    Hashtable<String, String> albums = new Hashtable<String, String>();\n \n    public static void main (String[] args) throws Exception {\n        ImageProxyTestDrive testDrive = new ImageProxyTestDrive();\n    }\n \n    public ImageProxyTestDrive() throws Exception{\n        albums.put(\"Buddha Bar\",\"http://images.amazon.com/images/P/B00009XBYK.01.LZZZZZZZ.\njpg\");\n        albums.put(\"Ima\",\"http://images.amazon.com/images/P/B000005IRM.01.LZZZZZZZ.jpg\");\n        albums.put(\"Karma\",\"http://images.amazon.com/images/P/B000005DCB.01.LZZZZZZZ.\ngif\");\n        albums.put(\"MCMXC a.D.\",\"http://images.amazon.com/images/P/B000002URV.01.LZZZZZZZ.\njpg\");\n        albums.put(\"Northern Exposure\",\"http://images.amazon.com/images/P/B000003SFN.01.\nLZZZZZZZ.jpg\");\n        albums.put(\"Selected Ambient Works, Vol. 2\",\"http://images.amazon.com/images/P/\nB000002MNZ.01.LZZZZZZZ.jpg\");\n        URL initialURL = new URL((String)albums.get(\"Selected Ambient Works, Vol. 2\"));\n        menuBar = new JMenuBar();\n        menu = new JMenu(\"Favorite Albums\");\n        menuBar.add(menu);\n", "page": 527, "type": "text", "section": "Page 527"}
{"text": "490\u2003 \u2003 Chapter 11\nready-bake code: album cover viewer\nThe code for the Album Cover \nViewer, continued...\nReady Bake\nCode\n        frame.setJMenuBar(menuBar);\n        for(Enumeration e = albums.keys(); e.hasMoreElements();) {\n            String name = (String)e.nextElement();\n            JMenuItem menuItem = new JMenuItem(name);\n            menu.add(menuItem); \n            menuItem.addActionListener(event -> {\n                imageComponent.setIcon(\n                     new ImageProxy(getAlbumUrl(event.getActionCommand())));\n                frame.repaint();\n            });\n        }\n        \n        // set up frame and menus\n \n        Icon icon = new ImageProxy(initialURL);\n        imageComponent = new ImageComponent(icon);\n        frame.getContentPane().add(imageComponent);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(800,600);\n        frame.setVisible(true);\n    }\n    URL getAlbumUrl(String name) {\n        try {\n            return new URL((String)albums.get(name));\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n", "page": 528, "type": "text", "section": "Page 528"}
{"text": "you are here 4\u2003 \u2003 491\nthe proxy pattern\nThe code for the Album Cover \nViewer, continued...\nReady Bake\nCode\npackage headfirst.designpatterns.proxy.virtualproxy;\nimport java.net.*;\nimport java.awt.*;\nimport javax.swing.*;\nclass ImageProxy implements Icon {\n    volatile ImageIcon imageIcon;\n    final URL imageURL;\n    Thread retrievalThread;\n    boolean retrieving = false;\n     \n    public ImageProxy(URL url) { imageURL = url; }\n     \n    public int getIconWidth() {\n        if (imageIcon != null) {\n            return imageIcon.getIconWidth();\n        } else {\n            return 800;\n        }\n    }\n \n    public int getIconHeight() {\n        if (imageIcon != null) {\n            return imageIcon.getIconHeight();\n        } else {\n            return 600;\n        }\n    }\n\t\n    synchronized void setImageIcon(ImageIcon imageIcon) {\n        this.imageIcon = imageIcon;\n    }\n     \n    public void paintIcon(final Component c, Graphics  g, int x,  int y) {\n        if (imageIcon != null) {\n            imageIcon.paintIcon(c, g, x, y);\n        } else {\n            g.drawString(\"Loading album cover, please wait...\", x+300, y+190);\n            if (!retrieving) {\n                retrieving = true;\n", "page": 529, "type": "text", "section": "Page 529"}
{"text": "492\u2003 \u2003 Chapter 11\nready-bake code: album cover viewer\nThe code for the Album Cover Viewer, \ncontinued...\nReady Bake\nCode\n                retrievalThread = new Thread(new Runnable() {\n                    public void run() {\n                        try {\n                            setImageIcon(new ImageIcon(imageURL, \"Album Cover\"));\n                            c.repaint();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                });\n                retrievalThread.start();\n            }\n        }\n    }\n}\npackage headfirst.designpatterns.proxy.virtualproxy;\nimport java.awt.*;\nimport javax.swing.*;\nclass ImageComponent extends JComponent {\n    private Icon icon;\n    public ImageComponent(Icon icon) {\n        this.icon = icon;\n    }\n    public void setIcon(Icon icon) {\n        this.icon = icon;\n    }\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        int w = icon.getIconWidth();\n        int h = icon.getIconHeight();\n        int x = (800 - w)/2;\n        int y = (600 - h)/2;\n        icon.paintIcon(this, g, x, y);\n    }\n}\n", "page": 530, "type": "text", "section": "Page 530"}
{"text": "this is a new chapter\u2003 \u2003 493\nWho would have ever guessed that Patterns could work together?  \nYou\u2019ve already witnessed the acrimonious Fireside Chats (and you haven\u2019t even seen the Pattern \nDeath Match pages that the editor forced us to remove from the book), so who would have \nthought patterns can actually get along well together? Well, believe it or not, some of the most \npowerful OO designs use several patterns together. Get ready to take your pattern skills to the \nnext level; it\u2019s time for compound patterns.\nPatterns \n12  compound patterns\nof Patterns\n", "page": 531, "type": "text", "section": "Page 531"}
{"text": "494\u2003 \u2003 Chapter 12\npatterns can work together\nWorking together\nOne of the best ways to use patterns is to get them out of the house so \nthey can interact with other patterns. The more you use patterns the \nmore you\u2019re going to see them showing up together in your designs. We \nhave a special name for a set of patterns that work together in a design \nthat can be applied over many problems: a compound pattern. That\u2019s right, \nwe are now talking about patterns made of patterns!  \nYou\u2019ll find a lot of compound patterns in use in the real world. Now \nthat you\u2019ve got patterns in your brain, you\u2019ll see that they are really just \npatterns working together, and that makes them easier to understand.\nWe\u2019re going to start this chapter by revisiting our friendly ducks in the \nSimUDuck duck simulator. It\u2019s only fitting that the ducks should be here \nwhen we combine patterns; after all, they\u2019ve been with us throughout \nthe entire book and they\u2019ve been good sports about taking part in lots \nof patterns. The ducks are going to help you understand how patterns \ncan work together in the same solution. But just because we\u2019ve combined \nsome patterns doesn\u2019t mean we have a solution that qualifies as a \ncompound pattern. For that, it has to be a general-purpose solution that \ncan be applied to many problems. So, in the second half of the chapter \nwe\u2019ll visit a real compound pattern: the Model-View-Controller, otherwise \nknown as MVC. If you haven\u2019t heard of MVC, you will, and you\u2019ll find \nMVC is one of the most powerful compound patterns in your design \ntoolbox.\nPatterns are often used together and \ncombined within the same design solution.\nA compound pattern combines two or \nmore patterns into a solution that solves a \nrecurring or general problem.\n", "page": 532, "type": "text", "section": "Page 532"}
{"text": "you are here 4\u2003 \u2003 495\ncompound patterns\npublic interface Quackable {\n    public void quack();\n}\npublic class MallardDuck implements Quackable {\n    public void quack() {\n        System.out.println(\"Quack\");\n    }\n}\npublic class RedheadDuck implements Quackable {\n    public void quack() {\n        System.out.println(\"Quack\");\n    }\n}\nQuackables only need to do \none thing well: Quack!\nYour standard \nMallard duck.\nWe\u2019ve got to have some variation \nof species if we want this to be \nan interesting simulator.\nDuck reunion\nAs you\u2019ve already heard, we\u2019re going to get to work with the ducks again. This \ntime the ducks are going to show you how patterns can coexist and even \ncooperate within the same solution.  \nWe\u2019re going to rebuild our duck simulator from scratch and give it some \ninteresting capabilities by using a bunch of patterns. Okay, let\u2019s get started...\nLike we said, we\u2019re starting from scratch. This time around, the Ducks are \ngoing to implement a Quackable interface. That way we\u2019ll know what things \nin the simulator can quack()\u2014like Mallard Ducks, Redhead Ducks, Duck \nCalls, and we might even see the Rubber Duck sneak back in.\n1\nFirst, we\u2019ll create a Quackable interface.\nWhat good is an interface without some classes to implement it? Time to \ncreate some concrete ducks (but not the \u201clawn art\u201d kind, if you know what \nwe mean).\n2\nNow, some Ducks that implement Quackable\n", "page": 533, "type": "text", "section": "Page 533"}
{"text": "496\u2003 \u2003 Chapter 12\nadding more ducks\npublic class DuckSimulator {\n    public static void main(String[] args) {\n        DuckSimulator simulator = new DuckSimulator();\n        simulator.simulate();\n    }\n  \n    void simulate() {\n        Quackable mallardDuck = new MallardDuck();\n        Quackable redheadDuck = new RedheadDuck();\n        Quackable duckCall = new DuckCall();\n        Quackable rubberDuck = new RubberDuck();\n \n        System.out.println(\"\\nDuck Simulator\");\n \n        simulate(mallardDuck);\n        simulate(redheadDuck);\n        simulate(duckCall);\n        simulate(rubberDuck);\n    }\n   \n    void simulate(Quackable duck) {\n        duck.quack();\n    }\n}\npublic class DuckCall implements Quackable {\n    public void quack() {\n        System.out.println(\"Kwak\");\n    }\n}\npublic class RubberDuck implements Quackable {\n    public void quack() {\n        System.out.println(\"Squeak\");\n    }\n}\nWe need some ducks, so \nhere we create one of  \neach Quackable...\n...then we simulate \neach one.\nHere we let polymorphism do its magic: no \nmatter what kind of Quackable gets passed in, \nthe simulate() method asks it to quack.\nA DuckCall that quacks but \ndoesn\u2019t sound quite like the real \nthing.\nA RubberDuck that makes a \nsqueak when it quacks.\nRemember last time? We had duck calls (those things hunters use\u2014they \nare definitely quackable) and rubber ducks.\nThis wouldn\u2019t be much fun if we didn\u2019t add other kinds of Ducks too.\nLet\u2019s cook up a simulator that creates a few ducks and makes sure their \nquackers are working...\n3\nOkay, we\u2019ve got our ducks; now all we need is a simulator.\nHere\u2019s our main() method \nto get everything going.\nWe create a simulator \nand then call its \nsimulate() method.\nHere we overload the simulate() \nmethod to simulate just one duck.\n", "page": 534, "type": "text", "section": "Page 534"}
{"text": "you are here 4\u2003 \u2003 497\ncompound patterns\npublic class Goose {\n    public void honk() {\n        System.out.println(\"Honk\");\n    }\n}\n% java DuckSimulator\nDuck Simulator\nQuack\nQuack\nKwak\nSqueak\nFile  Edit   Window  Help  ItBetterGetBetterThanThis\nNot too exciting yet, but we \nhaven\u2019t added patterns!\nA Goose is a honker, \nnot a quacker.\nWhere there is one waterfowl, there are probably two. Here\u2019s a Goose \nclass that has been hanging around the simulator.\n4\nWhen ducks are around, geese can\u2019t be far.\nIt looks like everything is working; so far, so good.\nThey all implement the same Quackable \ninterface, but their implementations allow \nthem to quack in their own way.\nLet\u2019s say we wanted to be able to use a Goose anywhere we\u2019d want to use a \nDuck. After all, geese make noise; geese fly; geese swim. Why can\u2019t we have \nGeese in the simulator?  \nWhat pattern would allow Geese to easily intermingle with Ducks?\n", "page": 535, "type": "text", "section": "Page 535"}
{"text": "498\u2003 \u2003 Chapter 12\ngoose adapter\npublic class GooseAdapter implements Quackable {\n    Goose goose;\n \n    public GooseAdapter(Goose goose) {\n        this.goose = goose;\n    }\n \n    public void quack() {\n        goose.honk();\n    }\n}\npublic class DuckSimulator {\n    public static void main(String[] args) {\n        DuckSimulator simulator = new DuckSimulator();\n        simulator.simulate();\n    }\n    void simulate() {\n        Quackable mallardDuck = new MallardDuck();\n        Quackable redheadDuck = new RedheadDuck();\n        Quackable duckCall = new DuckCall();\n        Quackable rubberDuck = new RubberDuck();\n        Quackable gooseDuck = new GooseAdapter(new Goose());\n \n        System.out.println(\"\\nDuck Simulator: With Goose Adapter\");\n \n        simulate(mallardDuck);\n        simulate(redheadDuck);\n        simulate(duckCall);\n        simulate(rubberDuck);\n        simulate(gooseDuck);\n    }\n \n    void simulate(Quackable duck) {\n        duck.quack();\n    }\n}\nThe constructor takes the \ngoose we are going to adapt.\nRemember, an Adapter \nimplements the target interface, \nwhich in this case is Quackable.\nWhen quack is called, the call is delegated \nto the goose\u2019s honk() method.\nWe make a Goose that acts \nlike a Duck by wrapping the \nGoose in the GooseAdapter.\nOnce the Goose is wrapped, we can treat \nit just like other duck Quackable objects.\nOur simulator expects to see Quackable interfaces. Since geese \naren\u2019t quackers (they\u2019re honkers), we can use an adapter to adapt \na goose to a duck.  \n5\nWe need a goose adapter.\nAll we need to do is create a Goose and wrap it in an adapter \nthat implements Quackable, and we should be good to go.  \n6\nNow geese should be able to play in the simulator, too.\n", "page": 536, "type": "text", "section": "Page 536"}
{"text": "you are here 4\u2003 \u2003 499\ncompound patterns\n% java DuckSimulator\nDuck Simulator: With Goose Adapter\nQuack\nQuack\nKwak\nSqueak\nHonk\nFile  Edit   Window  Help  GoldenEggs\nThere\u2019s the goose! Now the \nGoose can quack with the \nrest of the Ducks.\n7\nNow let\u2019s give this a quick run...\nQuackology\nThis time when we run the simulator, the list of objects passed \nto the simulate() method includes a Goose wrapped in a duck \nadapter. The result? We should see some honking!\nJ. Brewer, \nPark Ranger and \nQuackologist\nQuackologists are fascinated by all aspects of Quackable behavior. One \nthing Quackologists have always wanted to study is the total number of \nquacks made by a flock of ducks.\nHow can we add the ability to count duck quacks without having to \nchange the duck classes?\nCan you think of a pattern that would help?\n", "page": 537, "type": "text", "section": "Page 537"}
{"text": "500\u2003 \u2003 Chapter 12\nduck decorator\npublic class QuackCounter implements Quackable {\n    Quackable duck;\n    static int numberOfQuacks;\n  \n    public QuackCounter (Quackable duck) {\n        this.duck = duck;\n    }\n  \n    public void quack() {\n        duck.quack();\n        numberOfQuacks++;\n    }\n \n    public static int getQuacks() {\n        return numberOfQuacks;\n    }\n}\n8\nWe\u2019re going to make those Quackologists happy and give \nthem some quack counts.\nHow? Let\u2019s create a decorator that gives the ducks some new \nbehavior (the behavior of counting) by wrapping them with a \ndecorator object. We won\u2019t have to change the Duck code at all.\nAs with Adapter, we need to \nimplement the target interface.\nWe\u2019ve got an instance variable \nto hold on to the quacker \nwe\u2019re decorating.\nAnd we\u2019re counting ALL \nquacks, so we\u2019ll use a static \nvariable to keep track.\nWe get the reference to the \nQuackable we\u2019re decorating \nin the constructor.\nWhen quack() is called, we delegate the call \nto the Quackable we\u2019re decorating...\n...then we increase the number of quacks.\nWe\u2019re adding one other method to the \ndecorator. This static method just \nreturns the number of quacks that \nhave occurred in all Quackables.\nQuackCounter is a decorator.\n", "page": 538, "type": "text", "section": "Page 538"}
{"text": "you are here 4\u2003 \u2003 501\ncompound patterns\npublic class DuckSimulator {\n    public static void main(String[] args) {\n        DuckSimulator simulator = new DuckSimulator();\n        simulator.simulate();\n    }\n    void simulate() {\n        Quackable mallardDuck = new QuackCounter(new MallardDuck());\n        Quackable redheadDuck = new QuackCounter(new RedheadDuck());\n        Quackable duckCall = new QuackCounter(new DuckCall());\n        Quackable rubberDuck = new QuackCounter(new RubberDuck());\n        Quackable gooseDuck = new GooseAdapter(new Goose());\n        System.out.println(\"\\nDuck Simulator: With Decorator\");\n        simulate(mallardDuck);\n        simulate(redheadDuck);\n        simulate(duckCall);\n        simulate(rubberDuck);\n        simulate(gooseDuck);\n        System.out.println(\"The ducks quacked \" + \n                           QuackCounter.getQuacks() + \" times\");\n    }\n    void simulate(Quackable duck) {\n        duck.quack();\n    }\n}\n9\nWe need to update the simulator to create decorated ducks.\nNow, we must wrap each Quackable object we instantiate in a \nQuackCounter decorator. If we don\u2019t, we\u2019ll have ducks running \naround making uncounted quacks.\nHere\u2019s where we \ngather the quacking \nbehavior for the \nQuackologists.\nEach time we create a \nQuackable, we wrap it with \na new decorator.\nHere\u2019s the \noutput!\n% java DuckSimulator\nDuck Simulator: With Decorator\nQuack\nQuack\nKwak\nSqueak\nHonk\nThe ducks quacked 4 times\n%\nFile  Edit   Window  Help  DecoratedEggs\nNothing changes here; the decorated \nobjects are still Quackables.\nThe park ranger told us he \ndidn\u2019t want to count geese \nhonks, so we don\u2019t decorate it.\nRemember, \nwe\u2019re not \ncounting geese.\n", "page": 539, "type": "text", "section": "Page 539"}
{"text": "502\u2003 \u2003 Chapter 12\nduck factory\npublic abstract class AbstractDuckFactory {\n \n    public abstract Quackable createMallardDuck();\n    public abstract Quackable createRedheadDuck();\n    public abstract Quackable createDuckCall();\n    public abstract Quackable createRubberDuck();\n}\n10\nWe need a factory to produce ducks!\nOkay, we need some quality control to make sure our ducks get wrapped. \nWe\u2019re going to build an entire factory just to produce them. The factory \nshould produce a family of products that consists of different types of \nducks, so we\u2019re going to use the Abstract Factory Pattern.\nLet\u2019s start with the definition of the AbstractDuckFactory class:\nHe\u2019s right, that\u2019s the problem with wrapping objects: \nyou have to make sure they get wrapped or they don\u2019t \nget the decorated behavior.\nWhy don\u2019t we take the creation of ducks and localize \nit in one place; in other words, let\u2019s take the duck \ncreation and decorating and encapsulate it.\nWhat pattern does that sound like?\nWe\u2019re defining an abstract factory \nthat subclasses will implement to \ncreate different families.\nEach method creates one kind of duck.\nYou have to decorate objects to \nget decorated behavior.\nThis quack counting is great. We\u2019re learning \nthings we never knew about the little quackers. \nBut we\u2019re finding that too many quacks aren\u2019t \nbeing counted. Can you help?\n", "page": 540, "type": "text", "section": "Page 540"}
{"text": "you are here 4\u2003 \u2003 503\ncompound patterns\npublic class CountingDuckFactory extends AbstractDuckFactory {\n  \n    public Quackable createMallardDuck() {\n        return new QuackCounter(new MallardDuck());\n    }\n  \n    public Quackable createRedheadDuck() {\n        return new QuackCounter(new RedheadDuck());\n    }\n  \n    public Quackable createDuckCall() {\n        return new QuackCounter(new DuckCall());\n    }\n   \n    public Quackable createRubberDuck() {\n        return new QuackCounter(new RubberDuck());\n    }\n}\npublic class DuckFactory extends AbstractDuckFactory {\n  \n    public Quackable createMallardDuck() {\n        return new MallardDuck();\n    }\n  \n    public Quackable createRedheadDuck() {\n        return new RedheadDuck();\n    }\n  \n    public Quackable createDuckCall() {\n        return new DuckCall();\n    }\n   \n    public Quackable createRubberDuck() {\n        return new RubberDuck();\n    }\n}\nNext we\u2019ll create a factory that creates ducks without decorators, just to \nget the hang of the factory:\nNow let\u2019s create the factory we really want, the CountingDuckFactory:\nDuckFactory extends \nthe abstract factory.\nEach method creates a product: \na particular kind of Quackable.  \nThe actual product is unknown to \nthe simulator\u2009\u2014\u2009it just knows it\u2019s \ngetting a Quackable.\nCountingDuckFactory \nalso extends the \nabstract factory.  \nEach method wraps the \nQuackable with the quack \ncounting decorator. The \nsimulator will never know \nthe difference; it just \ngets back a Quackable.  \nBut now our rangers can \nbe sure that all quacks \nare being counted.\n", "page": 541, "type": "text", "section": "Page 541"}
{"text": "504\u2003 \u2003 Chapter 12\nfamilies of ducks\npublic class DuckSimulator {\n    public static void main(String[] args) {\n        DuckSimulator simulator = new DuckSimulator();\n        AbstractDuckFactory duckFactory = new CountingDuckFactory();\n \n        simulator.simulate(duckFactory);\n    }\n \n    void simulate(AbstractDuckFactory duckFactory) {\n        Quackable mallardDuck = duckFactory.createMallardDuck();\n        Quackable redheadDuck = duckFactory.createRedheadDuck();\n        Quackable duckCall = duckFactory.createDuckCall();\n        Quackable rubberDuck = duckFactory.createRubberDuck();\n        Quackable gooseDuck = new GooseAdapter(new Goose());\n \n        System.out.println(\"\\nDuck Simulator: With Abstract Factory\");\n \n        simulate(mallardDuck);\n        simulate(redheadDuck);\n        simulate(duckCall);\n        simulate(rubberDuck);\n        simulate(gooseDuck);\n \n        System.out.println(\"The ducks quacked \" + \n                           QuackCounter.getQuacks() + \n                           \" times\");\n    }\n \n    void simulate(Quackable duck) {\n        duck.quack();\n    }\n}\n11\nLet\u2019s set up the simulator to use the factory.\nRemember how Abstract Factory works? We create a polymorphic method \nthat takes a factory and uses it to create objects. By passing in different \nfactories, we get to use different product families in the method.\nWe\u2019re going to alter the simulate() method so that it takes a factory and \nuses it to create ducks.\nFirst we create \nthe factory \nthat we\u2019re going \nto pass into \nthe simulate() \nmethod. \nThe simulate() \nmethod takes an \nAbstractDuckFactory \nand uses it to create \nducks rather than \ninstantiating them \ndirectly.\nNothing changes \nhere! Same ol\u2019 code.\n", "page": 542, "type": "text", "section": "Page 542"}
{"text": "you are here 4\u2003 \u2003 505\ncompound patterns\nSame as last time, \nbut this time \nwe\u2019re ensuring that \nthe ducks are all \ndecorated because \nwe are using the \nCountingDuckFactory.\n% java DuckSimulator\nDuck Simulator: With Abstract Factory\nQuack\nQuack\nKwak\nSqueak\nHonk\n4 quacks were counted\n%\nFile  Edit   Window  Help  EggFactory\nHere\u2019s the output using the factory...\nWe\u2019re still directly instantiating Geese by relying on concrete \nclasses. Can you write an Abstract Factory for Geese? How should \nit handle creating \u201cgoose ducks\u201d?\n", "page": 543, "type": "text", "section": "Page 543"}
{"text": "506\u2003 \u2003 Chapter 12\nflock of ducks\n        Quackable mallardDuck = duckFactory.createMallardDuck();\n        Quackable redheadDuck = duckFactory.createRedheadDuck();\n        Quackable duckCall = duckFactory.createDuckCall();\n        Quackable rubberDuck = duckFactory.createRubberDuck();\n        Quackable gooseDuck = new GooseAdapter(new Goose());\n \n        simulate(mallardDuck);\n        simulate(redheadDuck);\n        simulate(duckCall);\n        simulate(rubberDuck);\n        simulate(gooseDuck);\nHere\u2019s another good question from Ranger Brewer:   \nWhy are we managing ducks individually?\nThis isn\u2019t very \nmanageable!\nWhat we need is a way to talk about collections of \nducks and even subcollections of ducks (to deal with \nthe family request from Ranger Brewer). It would \nalso be nice if we could apply operations across the \nwhole set of ducks.\nWhat pattern can help us?\nAh, he wants to manage a flock \nof ducks.\nIt\u2019s getting a little difficult to manage \nall these different ducks separately.  \nIs there any way you can help us \nmanage ducks as a whole, and perhaps even \nallow us to manage a few duck \u201cfamilies\u201d \nthat we\u2019d like to keep track of?\n", "page": 544, "type": "text", "section": "Page 544"}
{"text": "you are here 4\u2003 \u2003 507\ncompound patterns\npublic class Flock implements Quackable {\n    List<Quackable> quackers = new ArrayList<Quackable>();\n \n    public void add(Quackable quacker) {\n        quackers.add(quacker);\n    }\n \n    public void quack() {\n        Iterator<Quackable> iterator = quackers.iterator();\n        while (iterator.hasNext()) {\n            Quackable quacker = iterator.next();\n            quacker.quack();\n        }\n    }\n}\n12\nLet\u2019s create a flock of ducks (well, actually a flock of Quackables).\nRemember the Composite Pattern that allows us to treat a collection of \nobjects in the same way as individual objects? What better composite than \na flock of Quackables!\nLet\u2019s step through how this is going to work:\nRemember, the composite needs to implement \nthe same interface as the leaf elements. Our \nleaf elements are Quackables.\nWe\u2019re using an ArrayList inside each Flock to \nhold the Quackables that belong to the Flock.\nThe add() method adds a \nQuackable to the Flock.\nNow for the quack() method\u2009\u2014\u2009after all, the Flock is a Quackable too.  \nThe quack() method in Flock needs to work over the entire Flock. Here \nwe iterate through the ArrayList and call quack() on each element.\nDid you notice that we tried to sneak a Design Pattern \nby you without mentioning it?\n    public void quack() {\n        Iterator<Quackable> iterator = quackers.iterator();\n        while (iterator.hasNext()) {\n            Quackable quacker = iterator.next();\n            quacker.quack();\n        }\n    }\nThere it is! The Iterator \nPattern at work!\nCode Up Close\n", "page": 545, "type": "text", "section": "Page 545"}
{"text": "508\u2003 \u2003 Chapter 12\nduck composite\npublic class DuckSimulator {\n    // main method here\n \n    void simulate(AbstractDuckFactory duckFactory) {\n        Quackable redheadDuck = duckFactory.createRedheadDuck();\n        Quackable duckCall = duckFactory.createDuckCall();\n        Quackable rubberDuck = duckFactory.createRubberDuck();\n        Quackable gooseDuck = new GooseAdapter(new Goose());\n        System.out.println(\"\\nDuck Simulator: With Composite - Flocks\");\n        Flock flockOfDucks = new Flock();\n        flockOfDucks.add(redheadDuck);\n        flockOfDucks.add(duckCall);\n        flockOfDucks.add(rubberDuck);\n        flockOfDucks.add(gooseDuck);\n        Flock flockOfMallards = new Flock();\n        Quackable mallardOne = duckFactory.createMallardDuck();\n        Quackable mallardTwo = duckFactory.createMallardDuck();\n        Quackable mallardThree = duckFactory.createMallardDuck();\n        Quackable mallardFour = duckFactory.createMallardDuck();\n        flockOfMallards.add(mallardOne);\n        flockOfMallards.add(mallardTwo);\n        flockOfMallards.add(mallardThree);\n        flockOfMallards.add(mallardFour);\n        flockOfDucks.add(flockOfMallards);\n        System.out.println(\"\\nDuck Simulator: Whole Flock Simulation\");\n        simulate(flockOfDucks);\n        System.out.println(\"\\nDuck Simulator: Mallard Flock Simulation\");\n        simulate(flockOfMallards);\n        System.out.println(\"\\nThe ducks quacked \" + \n                           QuackCounter.getQuacks() + \n                           \" times\");\n    }\n    void simulate(Quackable duck) {\n        duck.quack();\n    }\n}\n13\nNow we need to alter the simulator.\nOur composite is ready; we just need some code to round up the \nducks into the composite structure.\nCreate all the \nQuackables, \njust like before.\nFirst we create a Flock and \nload it up with Quackables.\nHere we\u2019re \ncreating a \nlittle family of \nmallards...\nThen we create a new \nFlock of mallards.\n...and adding them to the \nFlock of mallards.\nThen we add the Flock of \nmallards to the main flock.\nLet\u2019s test out the entire Flock!\nThen let\u2019s just test out the mallard Flock.\nFinally, let\u2019s give the \nQuackologist the data.\nNothing needs to change here; a Flock is a Quackable!\n", "page": 546, "type": "text", "section": "Page 546"}
{"text": "you are here 4\u2003 \u2003 509\ncompound patterns\nLet\u2019s give it a spin...\n% java DuckSimulator\nDuck Simulator: With Composite - Flocks\nDuck Simulator: Whole Flock Simulation\nQuack\nKwak\nSqueak\nHonk\nQuack\nQuack\nQuack\nQuack\nDuck Simulator: Mallard Flock Simulation\nQuack\nQuack\nQuack\nQuack\nThe ducks quacked 11 times\nFile  Edit   Window  Help  FlockADuck\nHere\u2019s the first flock.\nAnd now the mallards.\nThe data looks \ngood (remember the \ngoose doesn\u2019t get \ncounted).\nSafety versus transparency\nYou might remember that in the Composite Pattern chapter the composites (the Menus) and the \nleaves (the MenuItems) had the same exact set of methods, including the add() method. Because \nthey had the same set of methods, we could call methods on MenuItems that didn\u2019t really make \nsense (like trying to add something to a MenuItem by calling add()).  The benefit of this was that the \ndistinction between leaves and composites was transparent: the client didn\u2019t have to know whether \nit was dealing with a leaf or a composite; it just called the same methods on both.\nHere, we\u2019ve decided to keep the composite\u2019s child maintenance methods separate from the leaf \nnodes: that is, only Flocks have the add() method.  We know it doesn\u2019t make sense to try to add \nsomething to a Duck, and in this implementation, you can\u2019t.  You can only add() to a Flock. So \nthis design is safer\u2014you can\u2019t call methods that don\u2019t make sense on components\u2014but it\u2019s less \ntransparent.  Now the client has to know that a Quackable is a Flock in order to add Quackables to it. \nAs always, there are tradeoffs when you do OO design and you need to consider them as you create \nyour own composites.\n", "page": 547, "type": "text", "section": "Page 547"}
{"text": "510\u2003 \u2003 Chapter 12\nduck observer\npublic interface QuackObservable {\n    public void registerObserver(Observer observer);\n    public void notifyObservers();\n}\npublic interface Quackable extends QuackObservable {\n    public void quack();\n}\n14\nFirst we need an interface for our Subject.\nRemember that the Subject is the object being observed. Let\u2019s call it \nsomething more memorable\u2014how about Observable? An Observable needs \nmethods for registering and notifying observers. We could also have a \nmethod for removing observers, but we\u2019ll keep the implementation simple \nhere and leave that out.\nIt sounds like the Quackologist would like to observe individual \nduck behavior. That leads us right to a pattern made for observing \nthe behavior of objects: the Observer Pattern.\nQuackObservable is the interface \nthat Quackables should implement \nif they want to be observed.\nIt also has a method for \nnotifying the observers.\nIt has a method for registering \nObservers. Any object implementing \nthe Observer interface can listen \nto quacks. We\u2019ll define the Observer \ninterface in a sec.\nNow we need to make sure all Quackables implement this interface...\nSo, we extend the Quackable \ninterface with QuackObserver.\nCan you say \u201cobserver\u201d?\nThe Composite is working great! Thanks!  \nNow we have the opposite request: we also \nneed to track individual ducks. Can you give \nus a way to keep track of individual duck \nquacking in real time?\n", "page": 548, "type": "text", "section": "Page 548"}
{"text": "you are here 4\u2003 \u2003 511\ncompound patterns\npublic class Observable implements QuackObservable {\n    List<Observer> observers = new ArrayList<Observer>();\n    QuackObservable duck;\n \n    public Observable(QuackObservable duck) {\n        this.duck = duck;\n    }\n  \n    public void registerObserver(Observer observer) {\n        observers.add(observer);\n    }\n  \n    public void notifyObservers() {\n        Iterator iterator = observers.iterator();\n        while (iterator.hasNext()) {\n            Observer observer = iterator.next();\n            observer.update(duck);\n        }\n    }\n}\nNow, we need to make sure all the concrete \nclasses that implement Quackable can handle \nbeing a QuackObservable.\nWe could approach this by implementing registration and \nnotification in each and every class (like we did in Chapter \n2). But we\u2019re going to do it a little differently this time: \nwe\u2019re going to encapsulate the registration and notification \ncode in another class, call it Observable, and compose it \nwith QuackObservable. That way, we only write the real \ncode once and QuackObservable just needs enough code to \ndelegate to the helper class Observable.\nLet\u2019s begin with the Observable helper class.\nObservable implements all the functionality \na Quackable needs to be an observable. We \njust need to plug it into a class and have \nthat class delegate to Observable.\nQuackObserverable\nIn the constructor we get \npassed the QuackObservable \nthat is using this object \nto manage its observable \nbehavior. Check out the \nnotifyObservers() method \nbelow; you\u2019ll see that when \na notify occurs, Observable \npasses this object along so \nthat the observer knows \nwhich object is quacking.\nHere\u2019s the code for \nregistering an observer.\nAnd the code for doing \nthe notifications.\nNow let\u2019s see how a Quackable class uses this helper...\nObservable must implement QuackObservable \nbecause these are the same method calls \nthat are going to be delegated to it.\nStop looking at me. \nYou\u2019re making me \nnervous!\n15\n", "page": 549, "type": "text", "section": "Page 549"}
{"text": "512\u2003 \u2003 Chapter 12\nquack decorators are observables too\npublic class MallardDuck implements Quackable {\n    Observable observable;\n \n    public MallardDuck() {\n        observable = new Observable(this);\n    }\n \n    public void quack() {\n        System.out.println(\"Quack\");\n        notifyObservers();\n    }\n \n    public void registerObserver(Observer observer) {\n        observable.registerObserver(observer);\n    }\n \n    public void notifyObservers() {\n        observable.notifyObservers();\n    }\n}\n16\nIntegrate the helper Observable with the Quackable classes.\nThis shouldn\u2019t be too bad. All we need to do is make sure the Quackable classes \nare composed with an Observable and that they know how to delegate to it. After \nthat, they\u2019re ready to be Observables. Here\u2019s the implementation of MallardDuck; \nthe other ducks are the same.\nEach Quackable has an \nObservable instance variable.\nIn the constructor, we create an \nObservable and pass it a reference \nto the MallardDuck object.\nWhen we quack, we need \nto let the observers know \nabout it.\nHere are our two QuackObservable \nmethods. Notice that we just \ndelegate to the helper.\nWe haven\u2019t changed the implementation of one Quackable, the \nQuackCounter decorator.  We need to make it an Observable too.  \nWhy don\u2019t you write that one:\n", "page": 550, "type": "text", "section": "Page 550"}
{"text": "you are here 4\u2003 \u2003 513\ncompound patterns\npublic interface Observer {\n    public void update(QuackObservable duck);\n}\npublic class Quackologist implements Observer {\n \n    public void update(QuackObservable duck) {\n        System.out.println(\"Quackologist: \" + duck + \" just quacked.\");\n    }\n}\n17\nWe\u2019re almost there! We just need to work on the Observer side \nof the pattern.\nWe\u2019ve implemented everything we need for the Observables; now we \nneed some Observers. We\u2019ll start with the Observer interface:\nThe Observer interface just has one \nmethod, update(), which is passed the \nQuackObservable that is quacking.\nNow we need an Observer: where are \nthose Quackologists?!\nThe Quackologist is simple; it just has one \nmethod, update(), which prints out the \nQuackable that just quacked.\nWe need to implement the Observer interface or else \nwe won\u2019t be able to register with a QuackObservable.\n", "page": 551, "type": "text", "section": "Page 551"}
{"text": "514\u2003 \u2003 Chapter 12\nflock composites are observables too\nWhat if a Quackologist wants to observe an entire flock? What does that \nmean anyway? Think about it like this: if we observe a composite, then \nwe\u2019re observing everything in the composite. So, when you register with \na flock, the flock composite makes sure you get registered with all its \nchildren (sorry, all its little quackers), which may include other flocks.\nGo ahead and write the Flock observer code before we go any further.\n", "page": 552, "type": "text", "section": "Page 552"}
{"text": "you are here 4\u2003 \u2003 515\ncompound patterns\npublic class DuckSimulator {\n    public static void main(String[] args) {\n        DuckSimulator simulator = new DuckSimulator();\n        AbstractDuckFactory duckFactory = new CountingDuckFactory();\n \n        simulator.simulate(duckFactory);\n    }\n  \n    void simulate(AbstractDuckFactory duckFactory) {\n  \n        // create duck factories and ducks here\n \n        // create flocks here\n \n        System.out.println(\"\\nDuck Simulator: With Observer\");\n        Quackologist quackologist = new Quackologist();\n        flockOfDucks.registerObserver(quackologist);\n        simulate(flockOfDucks);\n        System.out.println(\"\\nThe ducks quacked \" + \n                           QuackCounter.getQuacks() + \n                           \" times\");\n    }\n \n    void simulate(Quackable duck) {\n        duck.quack();\n    }\n}\n18\nWe\u2019re ready to observe. Let\u2019s update the \nsimulator and give it a try:\nAll we do here is create \na Quackologist and set \nhim as an observer of \nthe flock.\nLet\u2019s give it a try \nand see how it works!\nThis time we\u2019ll \nwe just simulate \nthe entire flock.\n", "page": 553, "type": "text", "section": "Page 553"}
{"text": "516\u2003 \u2003 Chapter 12\nthe duck finale\nThis is the big finale. Five\u2014no, six\u2014patterns have come together to \ncreate this amazing Duck Simulator. Without further ado, we present \nDuckSimulator!\nFile  Edit   Window  Help  DucksAreEverywhere\n% java DuckSimulator\nDuck Simulator: With Observer\nQuack\nQuackologist: Redhead Duck just quacked.\nKwak\nQuackologist: Duck Call just quacked.\nSqueak\nQuackologist: Rubber Duck just quacked.\nHonk\nQuackologist: Goose pretending to be a Duck just quacked.\nQuack\nQuackologist: Mallard Duck just quacked.\nQuack\nQuackologist: Mallard Duck just quacked.\nQuack\nQuackologist: Mallard Duck just quacked.\nQuack\nQuackologist: Mallard Duck just quacked.\nThe Ducks quacked 7 times.\nAfter each \nquack, no \nmatter what \nkind of quack \nit was, the \nobserver gets a \nnotification.\nAnd the \nquackologist still \ngets his counts.\nQ: So this was a compound pattern?\nA: No, this was just a set of patterns \nworking together. A compound pattern is a \nset of a few patterns that are combined to \nsolve a general problem. We\u2019re just about \nto take a look at the Model-View-Controller \ncompound pattern; it\u2019s a collection of a few \npatterns that has been used over and over in \nmany design solutions.\n\nQ: So the real beauty of Design \nPatterns is that I can take a problem and \nstart applying patterns to it until I have a \nsolution. Right?\nA: Wrong. We went through this exercise \nwith Ducks to show you how patterns can \nwork together. You\u2019d never actually want to \napproach a design like we just did. In fact, \nthere may be solutions to parts of the Duck \nSimulator for which some of these patterns \nwere big-time overkill. Sometimes just using \ngood OO design principles can solve a \nproblem well enough on its own.\n\nWe\u2019re going to talk more about this in the \nnext chapter, but you only want to apply \npatterns when and where they make sense. \nYou never want to start out with the intention \nof using patterns just for the sake of it. You \nshould consider the design of the Duck \nSimulator to be forced and artificial. But hey, \nit was fun and gave us a good idea of how \nseveral patterns can fit into a solution.\n", "page": 554, "type": "text", "section": "Page 554"}
{"text": "you are here 4\u2003 \u2003 517\ncompound patterns\nWhat did we do?\nWe started with a bunch of Quackables...\nA goose came along and wanted to act like a Quackable too. So we \nused the Adapter Pattern to adapt the goose to a Quackable. Now, you can call quack() on a \ngoose wrapped in the adapter and it will honk!\nThen, the Quackologists decided they wanted to count quacks. So we \nused the Decorator Pattern to add a QuackCounter decorator that keeps track of the number \nof times quack() is called, and then delegates the quack to the Quackable it\u2019s wrapping.\nBut the Quackologists were worried they\u2019d forget to add the \nQuackCounter decorator. So we used the Abstract Factory Pattern to create ducks \nfor them. Now, whenever they want a duck, they ask the factory for one, and it hands back \na decorated duck. (And don\u2019t forget, they can also use another duck factory if they want an \nundecorated duck!)\nWe had management problems keeping track of all those ducks and \ngeese and quackables. So we used the Composite Pattern to group Quackables \ninto Flocks. The pattern also allows the Quackologist to create subFlocks to manage duck \nfamilies. We used the Iterator Pattern in our implementation by using java.util\u2019s iterator in \nArrayList.\nThe Quackologists also wanted to be notified when any Quackable \nquacked. So we used the Observer Pattern to let the Quackologists register as Quackable \nObservers. Now they\u2019re notified every time any Quackable quacks. We used iterator again \nin this implementation. The Quackologists can even use the Observer Pattern with their \ncomposites.\nThat was quite a Design Pattern \nworkout. You should study the class \ndiagram on the next page and then \ntake a relaxing break before continuing \non with Model-View-Controller.\n", "page": 555, "type": "text", "section": "Page 555"}
{"text": "518\u2003 \u2003 Chapter 12\nduck's-eye view\nDuckSimulator\ncreateMallardDuck()\ncreateRedheadDuck()\ncreateDuckCall()\ncreateRubberDuck()\nAbstractDuckFactory\ncreateMallardDuck()\ncreateRedheadDuck()\ncreateDuckCall()\ncreateRubberDuck()\nDuckFactory\ncreateMallardDuck()\ncreateRedheadDuck()\ncreateDuckCall()\ncreateRubberDuck()\nCountingDuckFactory\nupdate(QuackObservable)\n<<interface>> \nObserver\nupdate(QuackObservable)\nQuackologist\nA bird\u2019s duck\u2019s-eye view: the class diagram\nDuckSimulator uses a factory to create Ducks.  \nHere are two different \nfactories that produce \nthe same family of \nproducts. The DuckFactory \ncreates ducks, and the \nCountingDuckFactory \ncreates Ducks wrapped in \nQuackCounter decorators. \nWe only implemented one kind of Observer \nfor the Quackables\u2009\u2014\u2009the Quackologist.  \nBut any class that implements the Observer \ninterface can observe ducks...how about \nimplementing a BirdWatcher observer?\nIf a class \nimplements \nObserver, that \nmeans it can \nobserve Quackables, \nand will be notified \nwhenever a \nQuackable quacks.\nWe\u2019ve packed a lot of patterns into one small duck simulator! Here\u2019s the big picture of what we did:\n", "page": 556, "type": "text", "section": "Page 556"}
{"text": "you are here 4\u2003 \u2003 519\ncompound patterns\nregisterObserver(Observer)\nnotifyObservers()\n<<interface>> \nQuackObservable\nquack()\n<<interface>> \nQuackable\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nMallardDuck\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nRedheadDuck\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nDuckCall\nregisterObserver(Observer)\nnotifyObservers()\nObservable\nList observers\nQuackObservable duck\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nGooseAdapter\nGoose goose\nadd(Quackable)\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nFlock\nList ducks\ngetQuacks()\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nQuackCounter\nQuackable duck\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nRubberDuck\nThe QuackObservable interface \ngives us a set of methods that \nany Observable must implement.\nWe have two kinds of \nQuackables: ducks and \nother things that want \nQuackable behavior: like \nthe GooseAdapter, which \nwraps a Goose and makes \nit look like a Quackable; \nFlock, which is a \nQuackable Composite, and \nQuackCounter, which adds \nbehavior to Quackables.\nQuackable is the interface \nthat all classes that have \nquacking behavior implement.\nEach Quackable has an \ninstance of Observable \nto keep track of their \nobservers and notify them \nwhen the Quackable quacks.\nThis Adapter...\n...and this \nComposite...\n...and this \nDecorator \nall act like \nQuackables!\n", "page": 557, "type": "text", "section": "Page 557"}
{"text": "520\u2003 \u2003 Chapter 12\nthe model view controller song\nModel, View, Controller\nLyrics and music by James Dempsey.\nMVC\u2019s a paradigm for factoring your code\ninto functional segments, so your brain does not explode.\nT\no achieve reusability, you gotta keep those boundaries \nclean\nModel on the one side, View on the other, the Controller\u2019s \nin between.\nModel View, it\u2019s got three layers like Oreos do \nModel View Controller\nModel View, Model View, Model View Controller\nModel objects represent your application\u2019s raison d\u2019\u00eatre\nCustom objects that contain data, logic, and et cetera\nYou create custom classes, in your app\u2019s problem domain\nyou can choose to reuse them with all the views\nbut the model objects stay the same.\nYou can model a throttle and a manifold\nModel the toddle of a two year old\nModel a bottle of fine Chardonnay\nModel all the glottal stops people say\nModel the coddling of boiling eggs\nYou can model the waddle in Hexley\u2019s legs\nModel View, you can model all the models that pose for GQ\nModel View Controller\nView objects tend to be controls used to display and edit\nCocoa\u2019s got a lot of those, well written to its credit.\nT\nake an NST\nextView, hand it any old Unicode string\nThe user can interact with it, it can hold most anything\nBut the view don\u2019t know about the Model\nThat string could be a phone number or the works of \nAristotle\nKeep the coupling loose \nand so achieve a massive level of reuse\nModel View, all rendered very nicely in aqua blue\nModel View Controller\nYou\u2019re probably wondering now\nYou\u2019re probably wondering how\nData flows between Model and View\nThe Controller has to mediate\nBetween each layer\u2019s changing state\nT\no synchronize the data of the two\nIt pulls and pushes every changed value\nModel View, mad props to the smalltalk crew!\nModel View Controller\nThe King of Compound Patterns\nIf Elvis were a compound pattern, his name would be Model-View-Controller, \nand he\u2019d be singing a little song like this...\nModel\nView\nCreamy \nController\nSo does Java!\n", "page": 558, "type": "text", "section": "Page 558"}
{"text": "you are here 4\u2003 \u2003 521\ncompound patterns\nModel View, it\u2019s pronounced Oh Oh not Ooo Ooo\nModel View Controller\nThere\u2019s a little left to this story\nA few more miles upon this road\nNobody seems to get much glory \nFrom writing the controller code\nWell, the model\u2019s mission critical \nAnd gorgeous is the view\nI might be lazy, but sometimes it\u2019s just crazy \nHow much code I write is just glue\nAnd it wouldn\u2019t be so tragic\nBut the code ain\u2019t doing magic\nIt\u2019s just moving values through\nAnd I don\u2019t mean to be vicious\nBut it gets repetitious\nDoing all the things controllers do\nAnd I wish I had a dime\nFor every single time \nI sent a T\nextField StringValue.\n\nModel View\nHow we gonna deep six all that glue\nModel View Controller\nControllers know the Model and View very intimately \nThey often use hardcoding which can be foreboding for \nreusability\nBut now you can connect each model key that you select \nto any view property\nAnd once you start binding\nI think you\u2019ll be finding less code in your source tree\nYeah, I know I was elated by the stuff they\u2019ve automated\nand the things you get for free\nAnd I think it bears repeating \nall the code you won\u2019t be needing\nwhen you hook it up in IB.\nModel View even handles multiple selections too\nModel View Controller\nModel View, bet I ship my application before you\nModel View Controller\nEar\npower\nDon\u2019t just read!  After all, this is a Head First book...check out this URL:\nhttps://www.youtube.com/watch?v=YYvOGPMLVDo\nSit back and give it a listen.\nUsing Swing.\n", "page": 559, "type": "text", "section": "Page 559"}
{"text": "522\u2003 \u2003 Chapter 12\nmvc is patterns put together\nWe were just trying to whet your appetite \nwith the song. Tell you what, after you finish \nreading this chapter, go back and listen to the \nsong again\u2014you\u2019ll have more fun.\nIt sounds like you\u2019ve had a bad run-in with \nMVC before? Most of us have. You\u2019ve \nprobably had other developers tell you it\u2019s \nchanged their lives and could possibly create \nworld peace. It\u2019s a powerful compound \npattern, for sure, and while we can\u2019t claim it \nwill create world peace, it will save you hours \nof writing code once you know it.\nBut first you have to learn it, right? Well, \nthere\u2019s going to be a big difference this time \naround because now you know patterns!\nThat\u2019s right, patterns are the key to MVC. \nLearning MVC from the top down is difficult; \nnot many developers succeed. Here\u2019s the \nsecret to learning MVC: it\u2019s just a few patterns \nput together. When you approach learning \nMVC by looking at the patterns, all of a \nsudden it starts to make sense.\nLet\u2019s get started. This time around, you\u2019re \ngoing to nail MVC!\nDesign Patterns are your key \nto understanding MVC.\nCute song, but is that really supposed \nto teach me what Model-View-\nController is? I\u2019ve tried learning MVC \nbefore and it made my brain hurt.\n", "page": 560, "type": "text", "section": "Page 560"}
{"text": "you are here 4\u2003 \u2003 523\ncompound patterns\nMeet Model-View-Controller\nView\nController\nyou use the \nyou use the \ninterface and \ninterface and \nyour actions \nyour actions \ngo to the \ngo to the \ncontroller\ncontroller\nclass Player {\n  play(){}\n  rip(){}\n  burn(){}\n}\nModel\nImagine you\u2019re using your favorite music player, like iTunes. You can use its interface to add \nnew songs, manage playlists, and rename tracks. The player takes care of maintaining a little \ndatabase of all your songs along with their associated names and data. It also takes care of \nplaying the songs and, as it does, the user interface is constantly updated with the current song \ntitle, the running time, and so on. \nWell, underneath it all sits Model-View-Controller...\nthe controller \nmanipulates \nthe model\nthe model  notifies \nthe view of a change \nin state\nthe view \ndisplay is \nupdated for \nyou \n \n\u201cPlay new song\u201d\nController asks \nPlayer model to \nbegin playing \nsong\nModel tells the \nview the state has \nchanged\nYou see the song \ndisplay update and \nhear the new song \nplaying\nThe model contains all the state, \ndata, and application logic needed \nto maintain and play mp3s.\n", "page": 561, "type": "text", "section": "Page 561"}
{"text": "524\u2003 \u2003 Chapter 12\nmvc up close\nModel\nController\nCONTROLLER\nTakes user input and figures out \nwhat it means to the model.\nMODEL\nThe model holds all \nthe data, state, and \napplication logic. The \nmodel is oblivious to \nthe view and controller, \nalthough it provides an \ninterface to manipulate \nand retrieve its \nstate and it can send \nnotifications of state  \nchanges to observers.\nVIEW\nGives you a presentation \nof the model. The view \nusually gets the state \nand data it needs to \ndisplay directly from \nthe model.\nView\nA closer look...\n2\nI\u2019ve changed!\nI need your state \ninformation\nThe user did \nsomething\nChange your \ndisplay\nChange your \nstate\n3\n1\n4\n5\nThis is the user \ninterface.\nHere\u2019s the \nmodel; it \nhandles all \napplication data \nand logic.\nHere\u2019s the creamy \ncontroller; it lives in \nthe middle.\nThe music player description gives us a high-level view of MVC, but it really \ndoesn\u2019t help you understand the nitty-gritty of how the compound pattern \nworks, how you\u2019d build one yourself, or why it\u2019s such a good thing. Let\u2019s start by \nstepping through the relationships among the model, view, and controller, and \nthen we\u2019ll take second look from the perspective of Design Patterns.\nclass Player {\n  play(){}\n  rip(){}\n  burn(){}\n}\n", "page": 562, "type": "text", "section": "Page 562"}
{"text": "you are here 4\u2003 \u2003 525\ncompound patterns\nThe view is your window to the model. When you do something to the view (like click \nthe Play button), then the view tells the controller what you did. It\u2019s the controller\u2019s \njob to handle that.\n1\nYou\u2019re the user\u2014you interact with the view.\nThe controller takes your actions and interprets them. If you click a button, \nit\u2019s the controller\u2019s job to figure out what that means and how the model \nshould be manipulated based on that action.\n2\nThe controller asks the model to change its state.\nWhen the controller receives an action from the view, it may need to tell the view \nto change as a result. For example, the controller could enable or disable certain \nbuttons or menu items in the interface.\n3\nThe controller may also ask the view to change.\nWhen something changes in the model, based either on some action you took (like \nclicking a button) or some other internal change (like the next song in the playlist \nhas started), the model notifies the view that its state has changed. \n4\nThe model notifies the view when its state has changed.\nThe view gets the state it displays directly from the model. For instance, when the \nmodel notifies the view that a new song has started playing, the view requests the \nsong name from the model and displays it. The view might also ask the model for \nstate as the result of the controller requesting some change in the view.\n5\nThe view asks the model for state.\nQ: Does the controller ever become an \nobserver of the model?\nA: Sure. In some designs the controller \nregisters with the model and is notified \nof changes. This can be the case when \nsomething in the model directly affects the \nuser interface controls. For instance, certain \nstates in the model may dictate that some \ninterface items be enabled or disabled. If so, \nit\u2019s really the controller\u2019s job to ask the view \nto update its display accordingly.\n\nQ: All the controller does is take user \ninput from the view and send it to the \nmodel, correct? Why have it at all if that \nis all it does? Why not just have the code \nin the view itself? In most cases isn\u2019t the \ncontroller just calling a method on the \nmodel?\nA: The controller does more than just \n\u201csend it to the model\u201d; it is responsible for \ninterpreting the input and manipulating the \nmodel based on that input. But your real \nquestion is probably, \u201cWhy can\u2019t I just do that \nin the view code?\u201d\n\nYou could; however, you don\u2019t want to for two \nreasons. First, you\u2019ll complicate your view \ncode because it now has two responsibilities: \nmanaging the user interface and dealing \nwith the logic of how to control the model.  \nSecond, you\u2019re tightly coupling your view \nto the model. If you want to reuse the view \nwith another model, forget it. The controller \nseparates the logic of control from the view \nand decouples the view from the model. \nBy keeping the view and controller loosely \ncoupled, you are building a more flexible and \nextensible design, one that can more easily \naccommodate change down the road.\n", "page": 563, "type": "text", "section": "Page 563"}
{"text": "526\u2003 \u2003 Chapter 12\nthe patterns in mvc\nUnderstanding MVC as a set of Patterns\nWe\u2019ve already suggested that the best path to learning MVC is to see it for what it is: a \nset of patterns working together in the same design.\nLet\u2019s start with the model: the model uses Observer to keep the views and controllers \nupdated on the latest state changes. The view and the controller, on the other hand, \nimplement the Strategy Pattern. The controller is the strategy of the view, and it \ncan be easily exchanged with another controller if you want different behavior. The \nview itself also uses a pattern internally to manage the windows, buttons, and other \ncomponents of the display: the Composite Pattern.\nLet\u2019s take a closer look:\nThe display consists of a nested set of \nwindows, panels, buttons, text labels, and so \non. Each display component is a composite \n(like a window) or a leaf (like a button). When \nthe controller tells the view to update, it \nonly has to tell the top view component, and \nComposite takes care of the rest.\nThe model implements the Observer Pattern \nto keep interested objects updated when \nstate changes occur. Using the Observer \nPattern keeps the model completely \nindependent of the views and controllers. It \nallows us to use different views with the same \nmodel, or even use multiple views at once.\nModel\nController\nView\nI\u2019ve changed!\nI need your state \ninformation\nThe user did \nsomething\nChange your \ndisplay\nChange your \nstate\nStrategy\nObserver\nComposite\nThe view and controller implement the classic Strategy Pattern: the \nview is an object that is configured with a strategy. The controller \nprovides the strategy. The view is concerned only with the visual \naspects of the application, and delegates to the controller any \ndecisions about the interface behavior. Using the Strategy Pattern also \nkeeps the view decoupled from the model because it is the controller \nthat is responsible for interacting with the model to carry out user \nrequests. The view knows nothing about how this gets done.\nclass Player {\n  play(){}\n  rip(){}\n  burn(){}\n}\n   \n", "page": 564, "type": "text", "section": "Page 564"}
{"text": "you are here 4\u2003 \u2003 527\ncompound patterns\nView\nModel\nclass Foo {\n void bar() \n{\n   doBar();\n }\n}\n   \nView\nController\nView\nView\nObservers\nObservable\nI\u2019d like to register \nas an observer\nMy state has \nchanged!\nObserver\nController\nView\nStrategy\nController\nThe user did \nsomething\nComposite\nAll these observers will be \nnotified whenever state \nchanges in the model.\nAny object that\u2019s \ninterested in state \nchanges in the model \nregisters with the \nmodel as an observer.\nThe controller is the \nstrategy for the \nview\u2009\u2014\u2009it\u2019s the object \nthat knows how to \nhandle the user actions.\nWe can swap in \nanother behavior for \nthe view by changing \nthe controller.\nThe view \ndelegates to \nthe controller \nto handle the \nuser actions.\nThe view is a composite \nof  GUI components (labels, \nbuttons, text entry, etc.).  \nThe top-level component \ncontains other components, \nwhich contain other \ncomponents, and so on until \nyou get to the leaf nodes.\npaint()\nThe model has no dependencies on \nviewers or controllers!\nThe view only worries about presentation. The controller \nworries about translating user input to actions on the model.\n", "page": 565, "type": "text", "section": "Page 565"}
{"text": "528\u2003 \u2003 Chapter 12\nmvc and the dj view\nUsing MVC to control the beat...\nIt\u2019s your time to be the DJ. When you\u2019re a DJ it\u2019s all about the beat. You might start \nyour mix with a slowed, down-tempo groove at 95 beats per minute (BPM) and \nthen bring the crowd up to a frenzied 140 BPM of trance techno. You\u2019ll finish off \nyour set with a mellow 80 BPM ambient mix.  \nHow are you going to do that? You have to control the beat, and you\u2019re going to \nbuild the tool to get you there.\nThe view has two \nparts, the part \nfor viewing the \nstate of the model \nand the part for \ncontrolling things.\nIncreases \nthe BPM by \none beat per \nminute.\nDecreases \nthe BPM by \none beat per \nminute.\nYou can enter a specific BPM and click \nthe Set button to set a specific beats \nper minute, or you can use the increase \nand decrease buttons for fine tuning.\nA pulsing bar shows the beat in real time.\nA display shows the current BPMs and is \nautomatically set whenever the BPM changes.\nLet\u2019s start with the view of the tool. The view allows you to create \na driving drumbeat and tune its beats per minute...\nMeet the Java DJ View\n120\n", "page": 566, "type": "text", "section": "Page 566"}
{"text": "you are here 4\u2003 \u2003 529\ncompound patterns\nLet\u2019s not forget about the model underneath it all...\nYou can\u2019t see the model, but you can hear it. The \nmodel sits underneath everything else, managing the \nbeat and driving the speakers.\nB\ne\na\nt\nM\no\nd\ne\nl\nsetBPM()\ngetBPM()\non()\noff()\nYou can start the \nbeat kicking by \nchoosing the Start \nmenu item in the \u201cDJ \nControl\u201d menu.\nNotice Stop is \ndisabled until you \nstart the beat.\nYou use the Stop \nbutton to shut \ndown the beat \ngeneration.\nNotice Start is \ndisabled after \nthe beat has \nstarted.\nThe controller is in the middle...\nController\nAll user actions are \nsent to the controller.\nThe controller sits between the view and \nmodel. It takes your input, like selecting \nStart from the DJ Control menu, and turns \nit into an action on the model to start the \nbeat generation.  \nThe controller takes input \nfrom the user and figures \nout how to translate that \ninto requests on the model.\nThe BeatModel is the heart of \nthe application. It implements \nthe logic to start and stop \nthe beat, set the BPM, and \ngenerate the sound.\nHere are a few more ways to control the DJ View...\nThe model also allows us to \nobtain its current state through \nthe getBPM() method.\n", "page": 567, "type": "text", "section": "Page 567"}
{"text": "530\u2003 \u2003 Chapter 12\nthe dj model, view, and controller\nB\ne\na\nt\nM\no\nd\ne\nl\nController\nsetBPM()\ngetBPM()\non()\noff()\nClick the \nincrease beat \nbutton...\nThe controller asks \nthe model to update \nits BPM by one.\nView is notified that the \nBPM changed. It calls \ngetBPM() on the model state.\nBecause the BPM is 120, the \nview gets a beat notification \nevery 1/2 second.\nThe beat is set at 119 BPM and you \nwould like to increase it to 120.\n...which results in the \ncontroller being invoked.\nThe view is updated \nto 120 BPM.\nYou see the beat bar \npulse every 1/2 second.\nView\nView\nPutting the pieces together\n", "page": 568, "type": "text", "section": "Page 568"}
{"text": "you are here 4\u2003 \u2003 531\ncompound patterns\npublic interface BeatModelInterface {\n    void initialize();\n  \n    void on();\n  \n    void off();\n  \n    void setBPM(int bpm);\n  \n    int getBPM();\n  \n    void registerObserver(BeatObserver o);\n  \n    void removeObserver(BeatObserver o);\n  \n    void registerObserver(BPMObserver o);\n  \n    void removeObserver(BPMObserver o);\n}\nBuilding the pieces\nThese are the methods \nthe controller will \nuse to direct the \nmodel based on user \ninteraction.\nThese methods allow \nthe view and the \ncontroller to get \nstate and to become \nobservers.\nThis should look familiar. \nThese methods allow objects \nto register as observers for \nstate changes.\nWe\u2019ve split this into two kinds of observers: \nobservers that want to be notified on every \nbeat, and observers that just want to be \nnotified when the beats per minute change.\nOkay,  you know the model is responsible for maintaining all the data, state, and any \napplication logic. So what\u2019s the BeatModel got in it? Its main job is managing the beat, \nso it has state that maintains the current beats per minute and code to play an audio \nclip to create the beat that we hear. It also exposes an interface that lets the controller \nmanipulate the beat and lets the view and controller obtain the model\u2019s state. Also, \ndon\u2019t forget that the model uses the Observer Pattern, so we also need some methods to \nlet objects register as observers and send out notifications.\nThis gets called after \nBeatModel is instantiated.\nThese methods turn the \nbeat generator on and off.\nThis method sets the beats per \nminute. After it is called, the beat \nfrequency changes immediately.\nThe getBPM() method \nreturns the current BPMs, \nor 0 if the generator is off.\nLet\u2019s check out the BeatModelInterface before \nlooking at the implementation:\n", "page": 569, "type": "text", "section": "Page 569"}
{"text": "532\u2003 \u2003 Chapter 12\npublic class BeatModel implements BeatModelInterface, Runnable {\n   List<BeatObserver> beatObservers = new ArrayList<BeatObserver>();\n   List<BPMObserver> bpmObservers = new ArrayList<BPMObserver>();\n   int bpm = 90;\n   Thread thread;\n   boolean stop = false;\n   Clip clip;\n  public void initialize() {\n      try {\n         File resource = new File(\"clap.wav\");\n         clip = (Clip) AudioSystem.getLine(new Line.Info(Clip.class));\n         clip.open(AudioSystem.getAudioInputStream(resource));\n      }\n      catch(Exception ex) { /* ... */}\n   }\n   public void on() {\n      bpm = 90;\n      notifyBPMObservers();\n      thread = new Thread(this);\n      stop = false;\n      thread.start();\n   }\n   public void off() {\n      stopBeat();\n      stop = true;\n   }\n   public void run() {\n      while (!stop) {\n         playBeat();\n         notifyBeatObservers();\n         try {\n            Thread.sleep(60000/getBPM());\n         } catch (Exception e) {}\n      }\n   }\n   public void setBPM(int bpm) {\n      this.bpm = bpm;\n      notifyBPMObservers();\n   }\n   public int getBPM() {\n      return bpm;\n   }\n   // Code to register and notify observers\n   // Audio code to handle the beat\n}\nthe beat model\nNow let\u2019s have a look at the concrete BeatModel class\nWe implement the \nBeatModeIInterface and Runnable.\nThis is the audio clip we play for the beat.\nThese Lists hold the two kinds of \nobservers (Beat and BPM observers).\nThe bpm variable holds the frequency \nof beats\u2009\u2014\u2009by default, 90 BPM.\nThis method does setup \nfor the beat track.\nThe on() method sets the BPMs to the default, \nand starts the thread to play the beat.\nAnd off() shuts it down by setting BPMs to \n0 and stopping the thread playing the beat.\nThe setBPM() method is the way \nthe controller manipulates the \nbeat. It sets the bpm variable, and \nnotifies all BPM Observers that \nthe BPM has changed.\nThis model uses an \naudio clip to generate \nbeats. You can check \nout the complete \nimplementation of all \nthe DJ classes in the Java \nsource files, available on \nthe wickedlysmart.com \nsite, or look at the code \nat the end of the chapter.\nReady Bake Code\nWe use these to start and \nstop the beat thread.\nThe getBPM() method just returns \nthe current beats per minute.\nThe run() method runs the beat thread, playing \na beat determined by the BPM, and notifies the \nbeat observers that a beat\u2019s been played. The loop \nterminates when we select Stop from the menu.\n", "page": 570, "type": "text", "section": "Page 570"}
{"text": "you are here 4\u2003 \u2003 533\ncompound patterns\nThe View\nNow the fun starts; we get to hook up a view and visualize the BeatModel!\nThe first thing to notice about the view is that we\u2019ve implemented it so that it is displayed in two \nseparate windows. One window contains the current BPM and the pulse; the other contains \nthe interface controls. Why? We wanted to emphasize the difference between the interface that \ncontains the view of the model and the rest of the interface that contains the set of user controls. \n \nLet\u2019s take a closer look at the two parts of the view:\nWe\u2019ve separated \nthe view of the \nmodel from the \nview with the \ncontrols.\nThe DJ view \ndisplays two \naspects of the \nBeatModel...\n...the current \nbeats per \nminute, from the \nBPMObserver \nnotifications...\n...and a \u201cbeat bar\u201d \nthat pulses in sync \nwith the beat, driven \nby the BeatObserver \nnotifications.\nA textual view that displays a music genre based on the BPM (ambient, downbeat, techno, etc.).\nA light show that is based on the real-time beat.\nThis is the part of the view that \nyou use to change the beat. This \nview passes everything you do on \nto the controller.\nOur BeatModel makes no assumptions about the view. The model is implemented using the \nObserver Pattern, so it just notifies any view registered as an observer when its state changes.  \nThe view uses the model\u2019s API to get access to the state. We\u2019ve implemented one type of view; \ncan you think of other views that could make use of the notifications and state in the BeatModel?\n", "page": 571, "type": "text", "section": "Page 571"}
{"text": "534\u2003 \u2003 Chapter 12\nthe dj view\npublic class DJView implements ActionListener,  BeatObserver, BPMObserver {\n    BeatModelInterface model;\n    ControllerInterface controller;\n    JFrame viewFrame;\n    JPanel viewPanel;\n    BeatBar beatBar;\n    JLabel bpmOutputLabel;\n  \n    public DJView(ControllerInterface controller, BeatModelInterface model) { \n \n \n        this.controller = controller;\n        this.model = model;\n        model.registerObserver((BeatObserver)this);\n        model.registerObserver((BPMObserver)this);\n    }\n    \n    public void createView() {\n        // Create all Swing components here\n    }\n  \n    public void updateBPM() {\n        int bpm = model.getBPM();\n        if (bpm == 0) {\n            bpmOutputLabel.setText(\"offline\");\n        } else {\n            bpmOutputLabel.setText(\"Current BPM: \" + model.getBPM());\n        }\n    }\n  \n    public void updateBeat() {\n        beatBar.setValue(100);\n    }\n}\nImplementing the View\nThe two parts of the view\u2014the view of the model, and \nthe view with the user interface controls\u2014are displayed \nin two windows, but live together in one Java class. We\u2019ll \nfirst show you just the code that creates the view of the \nmodel, which displays the current BPM and the beat bar.  \nThen we\u2019ll come back on the next page and show you just \nthe code that creates the user interface controls, which \ndisplays the BPM text entry field, and the buttons.\nDJView is an observer for both real-time beats and BPM changes.\nHere, we create a few \ncomponents for the display.\nThe view holds a reference to both the model and \nthe controller. The controller is only used by the \ncontrol interface, which we\u2019ll go over in a sec...\nThe constructor gets a reference \nto the controller and the model, \nand we store references to those \nin the instance variables.\nWe also register as a BeatObserver and \na BPMObserver of the model.\nThe updateBPM() method is called when a state \nchange occurs in the model. When that happens, we \nupdate the display with the current BPM. We can get \nthis value by requesting it directly from the model.\nLikewise, the updateBeat() method is called \nwhen the model starts a new beat. When that \nhappens, we need to pulse our beat bar. We do \nthis by setting it to its maximum value (100) \nand letting it handle the animation of the pulse.\n\t\n       The code on these two \npages is just an outline!\nWhat we\u2019ve done here is \nsplit ONE class into TWO, \nshowing you one part of \nthe view on this page, and the other \npart on the next page. All this code is \nreally in ONE class\u2014DJView.java. It\u2019s \nall listed at the end of the chapter.\n", "page": 572, "type": "text", "section": "Page 572"}
{"text": "you are here 4\u2003 \u2003 535\ncompound patterns\npublic class DJView implements ActionListener,  BeatObserver, BPMObserver {\n    BeatModelInterface model;\n    ControllerInterface controller;\n    JLabel bpmLabel;\n    JTextField bpmTextField;\n    JButton setBPMButton;\n    JButton increaseBPMButton;\n    JButton decreaseBPMButton;\n    JMenuBar menuBar;\n    JMenu menu;\n    JMenuItem startMenuItem;\n    JMenuItem stopMenuItem;\n  \n    public void createControls() {\n        // Create all Swing components here\n    }\n    public void enableStopMenuItem() {\n        stopMenuItem.setEnabled(true);\n    }\n    public void disableStopMenuItem() {\n        stopMenuItem.setEnabled(false);\n    }\n    public void enableStartMenuItem() {\n        startMenuItem.setEnabled(true);\n    }\n    public void disableStartMenuItem() {\n        startMenuItem.setEnabled(false);\n    }\n    public void actionPerformed(ActionEvent event) {\n        if (event.getSource() == setBPMButton) {\n            int bpm = Integer.parseInt(bpmTextField.getText());\n            controller.setBPM(bpm);\n        } else if (event.getSource() == increaseBPMButton) {\n            controller.increaseBPM();\n        } else if (event.getSource() == decreaseBPMButton) {\n            controller.decreaseBPM();\n        }\n    }\n}\nImplementing the View, continued...\nNow, we\u2019ll look at the code for the user interface controls part of the view. This view lets you control \nthe model by telling the controller what to do, which in turn, tells the model what to do. Remember, \nthis code is in the same class file as the other view code. \nAll these methods allow the start and \nstop items in the menu to be enabled and \ndisabled. We\u2019ll see that the controller uses \nthese to change the interface.\nThis method creates all the controls and places them \nin the interface. It also takes care of the menu. When \nthe stop or start items are chosen, the corresponding \nmethods are called on the controller.\nThis method is called when a button is clicked.\nIf the Set button is \nclicked, then it is passed \non to the controller \nalong with the new bpm.\nLikewise, if the increase or \ndecrease button is clicked, \nthis information is passed \non to the controller.\n", "page": 573, "type": "text", "section": "Page 573"}
{"text": "536\u2003 \u2003 Chapter 12\nthe dj controller\npublic interface ControllerInterface {\n    void start();\n    void stop();\n    void increaseBPM();\n    void decreaseBPM();\n    void setBPM(int bpm);\n}\nNow for the Controller\nIt\u2019s time to write the missing piece: the controller. Remember the controller \nis the strategy that we plug into the view to give it some smarts.  \nBecause we are implementing the Strategy Pattern, we need to start with \nan interface for any Strategy that might be plugged into the DJ View. We\u2019re \ngoing to call it ControllerInterface.\nHere are all the \nmethods the view can \ncall on the controller.\nThese should look familiar to you after seeing \nthe model\u2019s interface. You can stop and start \nthe beat generation and change the BPM.  \nThis interface is \u201cricher\u201d than the BeatModel \ninterface because you can adjust the BPMs \nwith increase and decrease.\nYou\u2019ve seen that the view and controller together make use of the Strategy \nPattern. Can you draw a class diagram of the two that represents this pattern?\nDesign Puzzle\n", "page": 574, "type": "text", "section": "Page 574"}
{"text": "you are here 4\u2003 \u2003 537\ncompound patterns\npublic class BeatController implements ControllerInterface {\n    BeatModelInterface model;\n    DJView view;\n   \n    public BeatController(BeatModelInterface model) {\n        this.model = model;\n        view = new DJView(this, model);\n        view.createView();\n        view.createControls();\n        view.disableStopMenuItem();\n        view.enableStartMenuItem();\n        model.initialize();\n    }\n  \n    public void start() {\n        model.on();\n        view.disableStartMenuItem();\n        view.enableStopMenuItem();\n    }\n  \n    public void stop() {\n        model.off();\n        view.disableStopMenuItem();\n        view.enableStartMenuItem();\n    }\n    \n    public void increaseBPM() {\n        int bpm = model.getBPM();\n        model.setBPM(bpm + 1);\n    }\n    \n    public void decreaseBPM() {\n        int bpm = model.getBPM();\n        model.setBPM(bpm - 1);\n    }\n  \n    public void setBPM(int bpm) {\n        model.setBPM(bpm);\n    }\n}\nAnd here\u2019s the implementation of the controller:\nThe controller implements \nthe ControllerInterface.\nThe controller is the creamy stuff \nin the middle of the MVC Oreo \ncookie, so it is the object that \ngets to hold on to the view and the \nmodel and glues it all together.\nThe controller is passed the \nmodel in the constructor and \nthen creates the view.\nLikewise, when you choose Stop from \nthe menu, the controller turns the \nmodel off and alters the user interface \nso that the Stop menu item is disabled \nand the Start menu item is enabled.\nWhen you choose Start from the user \ninterface menu, the controller turns \nthe model on and then alters the user \ninterface so that the Start menu \nitem is disabled and the Stop menu \nitem is enabled.\nNOTE: the controller is \nmaking the intelligent \ndecisions for the view. \nThe view just knows how \nto turn menu items on \nand off; it doesn\u2019t know \nthe situations in which \nit should disable them.\nIf the increase button is clicked, \nthe controller gets the current \nBPM from the model, adds one, \nand then sets a new BPM.\nSame thing here, only we subtract \none from the current BPM.\nFinally, if the user interface is used to \nset an arbitrary BPM, the controller \ninstructs the model to set its BPM.\n", "page": 575, "type": "text", "section": "Page 575"}
{"text": "538\u2003 \u2003 Chapter 12\nputting it all together\npublic class DJTestDrive {\n    public static void main (String[] args) {\n        BeatModelInterface model = new BeatModel();\n        ControllerInterface controller = new BeatController(model);\n    }\n}\nPutting it all together...\nWe\u2019ve got everything we need: a model, a view, and a controller. \nNow it\u2019s time to put them all together! We\u2019re going to see and \nhear how well they work together.\nAll we need is a little code to get things started; it won\u2019t take much:\nFirst create a model...\n...then create a controller and \npass it the model. Remember, \nthe controller creates the view, \nso we don\u2019t have to do that.\nAnd now for a test run...\n% java DJTestDrive\n%\nFile  Edit   Window  Help  LetTheBassKick\nRun this...\n...and you\u2019ll see this.\nStart the beat generation with the Start menu item; \nnotice the controller disables the item afterward.\nUse the text entry along with the increase and \ndecrease buttons to change the BPM. Notice how the \nview display reflects the changes despite the fact that \nit has no logical link to the controls.\nNotice how the beat bar always keeps up with the beat \nsince it\u2019s an observer of the model.\nPut on your favorite song and see if you can match the \nbeat by using the increase and decrease controls.\nStop the generator. Notice how the controller disables \nthe Stop menu item and enables the Start menu item.\nThings to try\n5\n4\n3\n2\n1\nMake sure you have \nthe file clip.wav at \nthe top level of the \ncode folder!\n", "page": 576, "type": "text", "section": "Page 576"}
{"text": "you are here 4\u2003 \u2003 539\ncompound patterns\nExploring Strategy\nLet\u2019s take the Strategy Pattern just a little further to get a \nbetter feel for how it is used in MVC. We\u2019re going to see \nanother friendly pattern pop up too\u2014a pattern you\u2019ll often \nsee hanging around the MVC trio: the Adapter Pattern.\nThink for a second about what the DJ View does: it displays \na beat rate and a pulse. Does that sound like something else?  \nHow about a heartbeat? It just so happens that we have a \nheart monitor class; here\u2019s the class diagram:\ngetHeartRate()\nregisterBeatObserver()\nregisterBPMObserver()\n// other heart methods\nHeartModel\nWe\u2019ve got a method for getting \nthe current heart rate.\nAnd luckily, its developers knew about the \nBeat and BPM Observer interfaces!\nIt certainly would be nice to reuse our current view with the HeartModel, but we need a \ncontroller that works with this model. Also, the interface of the HeartModel doesn\u2019t match what \nthe view expects because it has a getHeartRate() method rather than a getBPM(). How would \nyou design a set of classes to allow the view to be reused with the new model? Jot down your \nclass design ideas below.\n", "page": 577, "type": "text", "section": "Page 577"}
{"text": "540\u2003 \u2003 Chapter 12\nmvc and adapter\npublic class HeartAdapter implements BeatModelInterface {\n    HeartModelInterface heart;\n \n    public HeartAdapter(HeartModelInterface heart) {\n        this.heart = heart;\n    }\n    public void initialize() {}\n  \n    public void on() {}\n  \n    public void off() {}\n   \n    public int getBPM() {\n        return heart.getHeartRate();\n    }\n  \n    public void setBPM(int bpm) {}\n   \n    public void registerObserver(BeatObserver o) {\n        heart.registerObserver(o);\n    }\n    \n    public void removeObserver(BeatObserver o) {\n        heart.removeObserver(o);\n    }\n     \n    public void registerObserver(BPMObserver o) {\n        heart.registerObserver(o);\n    }\n  \n    public void removeObserver(BPMObserver o) {\n        heart.removeObserver(o);\n    }\n}\nAdapting the Model\nFor starters, we\u2019re going to need to adapt the HeartModel to a BeatModel. If we don\u2019t, the \nview won\u2019t be able to work with the model, because the view only knows how to getBPM(), \nand the equivalent heart model method is getHeartRate(). How are we going to do this? \nWe\u2019re going to use the Adapter Pattern, of course! It turns out that this is a common \ntechnique when working with MVC: use an adapter to adapt a model to work with existing \ncontrollers and views.  \nHere\u2019s the code to adapt a HeartModel to a BeatModel:\nWe need to implement the \ntarget interface\u2009\u2014\u2009in this \ncase, BeatModelInterface.\nHere, we store a reference \nto the heart model.\nWe don\u2019t know what these would \ndo to a heart, but it sounds scary. \n \nSo we\u2019ll just leave them as \u201cno ops.\u201d\nWhen getBPM() is called, we\u2019ll just \ntranslate it to a getHeartRate() \ncall on the heart model.\nWe don\u2019t want to do this on a heart! \nAgain, let\u2019s leave it as a \u201cno op.\u201d\nHere are our observer methods.  \nWe just delegate them to the \nwrapped heart model.\n", "page": 578, "type": "text", "section": "Page 578"}
{"text": "you are here 4\u2003 \u2003 541\ncompound patterns\npublic class HeartTestDrive {\n    public static void main (String[] args) {\n        HeartModel heartModel = new HeartModel();\n        ControllerInterface model = new HeartController(heartModel);\n    }\n}\npublic class HeartController implements ControllerInterface {\n    HeartModelInterface model;\n    DJView view;\n  \n    public HeartController(HeartModelInterface model) {\n        this.model = model;\n        view = new DJView(this, new HeartAdapter(model));\n        view.createView();\n        view.createControls();\n        view.disableStopMenuItem();\n        view.disableStartMenuItem();\n    }\n  \n    public void start() {}\n \n    public void stop() {}\n    \n    public void increaseBPM() {}\n    \n    public void decreaseBPM() {}\n  \n    public void setBPM(int bpm) {}\n}\nNow we\u2019re ready for a HeartController\nWith our HeartAdapter in hand, we should be ready to create a controller and get \nthe view running with the HeartModel. Talk about reuse!\nThe HeartController implements \nthe ControllerInterface, just \nlike the BeatController did.\nLike before, the \ncontroller creates the \nview and gets everything \nglued together.\nThere is one change: we are passed \na HeartModel, not a BeatModel...\n...and we need to wrap that \nmodel with an adapter before \nwe hand it to the view.\nThere\u2019s not a lot to do here; after all, \nwe can\u2019t really control hearts like we \ncan beat machines.\nAnd that\u2019s it! Now it\u2019s time for some test code...\nAll we need to do is create the \ncontroller and pass it a heart monitor.\nFinally, the HeartController disables the \nmenu items because they aren\u2019t needed.\n", "page": 579, "type": "text", "section": "Page 579"}
{"text": "542\u2003 \u2003 Chapter 12\ntest the heart model\n% java HeartTestDrive\n%\nFile  Edit   Window  Help  CheckMyPulse\nRun this...\n...and you\u2019ll see this.\nNotice that the display works great with a heart! \nThe beat bar looks just like a pulse. Because the \nHeartModel also supports BPM and Beat Observers, \nwe can get beat updates just like with the DJ beats.\nAs the heartbeat has natural variation, notice the \ndisplay is updated with the new beats per minute.\nEach time we get a BPM update, the adapter is doing \nits job of translating getBPM() calls to getHeartRate() \ncalls.\nThe Start and Stop menu items are not enabled \nbecause the controller disabled them.\nThe other buttons still work but have no effect \nbecause the controller implements no ops for them.  \nThe view could be changed to support the disabling \nof these items.\nThings to try\nAnd now for a test run...\n5\n4\n3\n2\n1\nNice healthy \nheart rate.\n", "page": 580, "type": "text", "section": "Page 580"}
{"text": "you are here 4\u2003 \u2003 543\ncompound patterns\nQ: It seems like you are really hand-\nwaving the fact that the Composite \nPattern is really in MVC. Is it really there?\nA: Yes, Virginia, there really is a \nComposite Pattern in MVC. But, actually, \nthis is a very good question. Today GUI \npackages, like Swing, have become so \nsophisticated that we hardly notice the \ninternal structure and the use of Composite \nin the building and update of the display. \nIt\u2019s even harder to see when we have web \nbrowsers that can take markup language \nand convert it into a user interface.\n\nBack when MVC was first discovered, \ncreating GUIs required a lot more manual \nintervention and the pattern was more \nobviously part of the MVC.\nQ: Does the controller ever implement \nany application logic?\nA: No, the controller implements behavior \nfor the view. It is the smarts that translates \nthe actions from the view to actions on the \nmodel. The model takes those actions and \nimplements the application logic to decide \nwhat to do in response to those actions. The \ncontroller might have to do a little work to \ndetermine what method calls to make on \nthe model, but that\u2019s not considered the \n\u201capplication logic.\u201d The application logic is the \ncode that manages and manipulates your \ndata and it lives in your model.\nQ: I\u2019ve always found the word \u201cmodel\u201d \nhard to wrap my head around. I now \nget that it\u2019s the guts of the application, \nbut why was such a vague, hard-to-\nunderstand word used to describe this \naspect of MVC?\nA: When MVC was named they needed a \nword that began with a \u201cM\u201d or otherwise they \ncouldn\u2019t have called it MVC.\n\nBut seriously, we agree with you. Everyone \nscratches their head and wonders what a \nmodel is. But then everyone comes to the \nrealization that they can\u2019t think of a better \nword either. \nQ: You\u2019ve talked a lot about the state \nof the model. Does this mean it has the \nState Pattern in it?\nA: No, we mean the general idea of state.  \nBut certainly some models do use the State \nPattern to manage their internal states.\nQ: I\u2019ve seen descriptions of MVC \nwhere the controller is described as \na \u201cmediator\u201d between the view and the \nmodel. Is the controller implementing the \nMediator Pattern?\nA: We haven\u2019t covered the Mediator \nPattern (although you\u2019ll find a summary of \nthe pattern in the appendix), so we won\u2019t go \ninto too much detail here, but the intent of \nthe mediator is to encapsulate how objects \ninteract and promote loose coupling by \nkeeping two objects from referring to each \nother explicitly. So, to some degree, the \ncontroller can be seen as a mediator, since \nthe view never sets state directly on the \nmodel, but rather always goes through the \ncontroller. Remember, however, that the \nview does have a reference to the model to \naccess its state. If the controller were truly a \nmediator, the view would have to go through \nthe controller to get the state of the model \nas well.  \nQ: Does the view always have to ask \nthe model for its state? Couldn\u2019t we use \nthe push model and send the model\u2019s \nstate with the update notification?\nA: Yes, the model could certainly send \nits state with the notification, and we could \ndo something similar with the BeatModel \nby sending just the state that the view \nis interested in. If you remember the \nObserver Pattern chapter, however, you\u2019ll \nalso remember that there are a couple of \ndisadvantages to this. If you don\u2019t, go back \nto Chapter 2 and have a second look. The \nMVC model has been adapted to a number \nof similar models\u2014in particular, for the web\u2019s \nbrowser/server environment\u2014so you\u2019ll find a \nlot of exceptions to the rule out there.\nQ: If I have more than one view, do I \nalways need more than one controller?\nA: Typically, you need one controller \nper view at runtime; however, the same \ncontroller class can easily manage many \nviews.\nQ: The view is not supposed to \nmanipulate the model; however, I noticed \nin your implementation that the view has \nfull access to the methods that change \nthe model\u2019s state. Is this dangerous?\nA: You are correct; we gave the view full \naccess to the model\u2019s set of methods. We \ndid this to keep things simple, but there may \nbe circumstances where you want to give the \nview access to only part of your model\u2019s API.  \nThere\u2019s a great design pattern that allows \nyou to adapt an interface to provide only a \nsubset. Can you think of it?\n", "page": 581, "type": "text", "section": "Page 581"}
{"text": "544\u2003 \u2003 Chapter 12\nyour design toolbox\nYes!\nMVC is so useful that it has been adapted to many web \nframeworks. Of course, the web works differently than your \nstandard application, so there are several different approaches \nto applying the MVC Pattern to the web.\nWeb applications have a client side (the browser) and a server \nside. Given that, we can make different design tradeoffs based \non where the model, the view, and the controller reside. In \nthin client approaches, the model, most of the view, and the \ncontroller all reside in the server, with the browser providing \na way to display the view, and to get input from the browser \nto the controller. Another approach is the single page application, \nwhere almost all of the model, view, and controller reside on \nthe client side. Those are the two ends of the spectrum, and \nyou\u2019ll find frameworks that vary the extent to which each \ncomponent\u2014that is the model, the view, and the controller\u2014\nreside on the client or the server, along with hybrid models \nwhere some components are shared across the client and server.\nThere are many popular web MVC frameworks, like Spring \nWeb MVC, Django, ASP\n.NET MVC, AngularJS, EmberJS, \nJavaScriptMVC, Backbone, and no doubt more on the way.  \nFor the most part each framework has its own unique way it \nmaps the model, the view, and the controller across the client \nand the server. Now that you know the MVC Pattern, you \nwill have no problem adapting your knowledge to whatever \nframework you choose to use.\nMost of my user \ninterfaces are \nactually browser-based. \nIs any of this going to \nhelp me?\n", "page": 582, "type": "text", "section": "Page 582"}
{"text": "you are here 4\u2003 \u2003 545\ncompound patterns\nTools for your Design Toolbox\nYou could impress anyone with your design toolbox. Wow, look \nat all those principles, patterns, and now, compound patterns!\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nStrategy - defines a family \nof algorithms, encapsulates \neach one, and makes them \ninterchangeable.  Strategy \nlets the algorithm vary \nOO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically.  \nDecorators provide a flexible \nalternative to subclassing for extending \nfunctionality.\nAbstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes.\nFactory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate.  Factory Method lets \na class defer instantiation to the \nsubclasses.\nSingleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it.\nCommand - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nAdapter - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nFacade - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nWe have a new \ncategory! MVC \nis  a  compound \npattern.\nState - Allow an object to alter its \nbehavior when its internal state changes. \n \nThe object will appear to change its \nclass.\nEncapsulate what varies.\nFavor composition over inheritance.\nProgram to interfaces, not \nimplementations.\nStrive for loosely coupled designs \nbetween objects that interact.\nClasses should be open for extension \nbut closed for modification.\nDepend on abstractions. Do not \ndepend on concrete classes.\nOnly talk to your friends.\nDon\u2019t call us, we\u2019ll call you.\nA class should have only one reason \nto change.\nOO Principles\nProxy - Provide a surrogate or \nplaceholder for another object to \ncontrol access to it.\nA Compound Pattern combines two or \nmore patterns into a solution that \nsolves a recurring or general problem.\nCompound Patterns\n\t\n\u0083\nThe Model View Controller \n(MVC) Pattern is a compound \npattern consisting of the \nObserver, Strategy, and \nComposite Patterns.\n\t\n\u0083\nThe model makes use of the \nObserver Pattern so that it \ncan keep observers updated \nyet stay decoupled from them.\n\t\n\u0083\nThe controller is the Strategy \nfor the view. The view can use \ndifferent implementations of \nthe controller to get different \nbehavior.\n\t\n\u0083\nThe view uses the Composite \nPattern to implement \nthe user interface, which \nusually consists of nested \ncomponents like panels, \nframes, and buttons.\n\t\n\u0083\nThese patterns work together \nto decouple the three players \nin the MVC model, which \nkeeps designs clear and \nflexible.\n\t\n\u0083\nThe Adapter Pattern can be \nused to adapt a new model \nto an existing view and \ncontroller.\n\t\n\u0083\nMVC has been adapted to \nthe web.\n\t\n\u0083\nThere are many web MVC \nframeworks with various \nadaptations of the MVC \npattern to fit the client/server \napplication structure.\n", "page": 583, "type": "text", "section": "Page 583"}
{"text": "546\u2003 \u2003 Chapter 12\npublic class QuackCounter implements Quackable {\n    Quackable duck;\n    static int numberOfQuacks;\n  \n    public QuackCounter(Quackable duck) {\n        this.duck = duck;\n    }\n  \n    public void quack() {\n        duck.quack();\n        numberOfQuacks++;\n    }\n \n    public static int getQuacks() {\n        return numberOfQuacks;\n    }\n \n    public void registerObserver(Observer observer) {\n        duck.registerObserver(observer);\n    }\n \n    public void notifyObservers() {\n        duck.notifyObservers();\n    }\n}\nQuackCounter is a Quackable, so \nnow it\u2019s a QuackObservable too.\nAll of this code is the \nsame as the previous \nversion of QuackCounter.\nHere\u2019s the duck that QuackCounter \nis decorating. It\u2019s this duck that \nreally needs to handle the observable \nmethods.\nHere are the two \nQuackObservable \nmethods. Notice that \nwe just delegate both \ncalls to the duck \nthat we\u2019re decorating.\nExercise Solutions\nThe QuackCounter is a Quackable too. When we change \nQuackable to extend QuackObservable, we have to change every \nclass that implements Quackable, including QuackCounter:\nexercise solutions\n", "page": 584, "type": "text", "section": "Page 584"}
{"text": "you are here 4\u2003 \u2003 547\ncompound patterns\npublic class Flock implements Quackable {\n    List<Quackable> quackers = new ArrayList<Quackable>();\n  \n    public void add(Quackable duck) {\n        ducks.add(duck);\n    }\n  \n    public void quack() {\n        Iterator<Quackable> iterator = quackers.iterator();\n        while (iterator.hasNext()) {\n            Quackable duck = iterator.next();\n            duck.quack();\n        }\n    }\n   \n    public void registerObserver(Observer observer) {\n        Iterator<Quackable> iterator = ducks.iterator();\n        while (iterator.hasNext()) {\n            Quackable duck = iterator.next();\n            duck.registerObserver(observer);\n        }\n    }\n  \n    public void notifyObservers() { }\n  \n}\nWhat if our Quackologist wants to observe an entire flock? What does that \nmean anyway? Think about it like this: if we observe a composite, then we\u2019re \nobserving everything in the composite. So, when you register with a flock, the \nflock composite makes sure you get registered with all its children, which may \ninclude other flocks.\nFlock is a Quackable, so now \nit\u2019s a QuackObservable too.\nHere are the Quackables \nthat are in the Flock.\nWhen you register as an Observer \nwith the Flock, you actually \nget registered with everything \nthat\u2019s IN the flock, which is \nevery Quackable, whether it\u2019s a \nduck or another Flock.\nWe iterate through all the \nQuackables in the Flock \nand delegate the call to \neach Quackable. If the \nQuackable is another Flock, \nit will do the same.\nEach Quackable does its own notification, so \nFlock doesn\u2019t have to worry about it. This \nhappens when Flock delegates quack() to each \nQuackable in the Flock.\n", "page": 585, "type": "text", "section": "Page 585"}
{"text": "548\u2003 \u2003 Chapter 12\nYou\u2019ve seen that the view and controller together make use of the Strategy \nPattern. Can you draw a class diagram of the two that represents this pattern?\nDesign Puzzle Solution\nsetBPM()\nincreaseBPM()\ndecreaseBPM()\n<<interface>> \nControllerInterface\ncreateView()\nupdateBPM()\nupdateBeat()\ncreateControls()\nenableStopMenuItem()\ndisableStopMenuItem()\nenableStartMenuItem()\ndisableStartMenuItem()\nactionPerformed()\nDJView\ncontroller\nsetBPM()\nincreaseBPM()\ndecreaseBPM()\nController\nThe \nControllerInterface \nis the interface \nthat all concrete \ncontrollers \nimplement. This \nis the strategy \ninterface.\nWe can plug \nin different \ncontrollers \nto provide \ndifferent \nbehaviors for \nthe view.\nThe view delegates \nbehavior to the \ncontroller. The \nbehavior it \ndelegates is how to \ncontrol the model \nbased on user \ninput.  \nWe\u2019re still directly instantiating Geese by relying on concrete classes.  \nCan you write an Abstract Factory for Geese?  How should it handle \ncreating \u201cgoose ducks\u201d?\nYou could add a createGooseDuck() method to the existing Duck Factories. Or, \nyou could create a completely separate Factory for creating families of Geese.  \nexercise solutions\n", "page": 586, "type": "text", "section": "Page 586"}
{"text": "you are here 4\u2003 \u2003 549\ncompound patterns\npackage headfirst.designpatterns.combined.djview;\n  \npublic class DJTestDrive {\n    public static void main (String[] args) {\n        BeatModelInterface model = new BeatModel();\n        ControllerInterface controller = new BeatController(model);\n    }\n}\npackage headfirst.designpatterns.combined.djview;\n  \npublic interface BeatModelInterface {\n    void initialize();\n  \n    void on();\n  \n    void off();\n  \n    void setBPM(int bpm);\n  \n    int getBPM();\n  \n    void registerObserver(BeatObserver o);\n  \n    void removeObserver(BeatObserver o);\n  \n    void registerObserver(BPMObserver o);\n  \n    void removeObserver(BPMObserver o);\n}\nHere\u2019s the complete implementation of the DJView. It shows all the \nMIDI code to generate the sound, and all the Swing components to \ncreate the view.  You can also download this code at \nhttps://www.wickedlysmart.com. Have fun!\nThe Beat Model\nReady Bake\nCode\n", "page": 587, "type": "text", "section": "Page 587"}
{"text": "550\u2003 \u2003 Chapter 12\npackage headfirst.designpatterns.combined.djview;\nimport java.util.*;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport java.io.*;\nimport javax.sound.sampled.Line;\npublic class BeatModel implements BeatModelInterface, Runnable {\n\t\nList<BeatObserver> beatObservers = new ArrayList<BeatObserver>();\n\t\nList<BPMObserver> bpmObservers = new ArrayList<BPMObserver>();\n\t\nint bpm = 90;\n\t\nThread thread;\n\t\nboolean stop = false;\n\t\nClip clip;\n\t\npublic void initialize() {\n\t\n\t\ntry {\n\t\n\t\n\t\nFile resource = new File(\"clap.wav\");\n\t\n\t\n\t\nclip = (Clip) AudioSystem.getLine(new Line.Info(Clip.class));\n\t\n\t\n\t\nclip.open(AudioSystem.getAudioInputStream(resource));\n\t\n\t\n}\n\t\n\t\ncatch(Exception ex) {\n\t\n\t\n\t\nSystem.out.println(\"Error: Can\u2019t load clip\");\n\t\n\t\n\t\nSystem.out.println(ex);\n\t\n\t\n}\n\t\n}\n\t\npublic void on() {\n\t\n\t\nbpm = 90;\n\t\n\t\nnotifyBPMObservers();\n\t\n\t\nthread = new Thread(this);\n\t\n\t\nstop = false;\n\t\n\t\nthread.start();\n\t\n}\n\t\npublic void off() {\n\t\n\t\nstopBeat();\n\t\n\t\nstop = true;\n\t\n}\nready-bake code: model\n", "page": 588, "type": "text", "section": "Page 588"}
{"text": "you are here 4\u2003 \u2003 551\ncompound patterns\nReady Bake\nCode\n\t\npublic void run() {\n\t\n\t\nwhile (!stop) {\n\t\n\t\n\t\nplayBeat();\n\t\n\t\n\t\nnotifyBeatObservers();\n\t\n\t\n\t\ntry {\n\t\n\t\n\t\n\t\nThread.sleep(60000/getBPM());\n\t\n\t\n\t\n} catch (Exception e) {}\n\t\n\t\n}\n\t\n}\n\t\npublic void setBPM(int bpm) {\n\t\n\t\nthis.bpm = bpm;\n\t\n\t\nnotifyBPMObservers();\n\t\n}\n\t\npublic int getBPM() {\n\t\n\t\nreturn bpm;\n\t\n}\n\t\npublic void registerObserver(BeatObserver o) {\n\t\n\t\nbeatObservers.add(o);\n\t\n}\n\t\npublic void notifyBeatObservers() {\n\t\n\t\nfor (int i = 0; i < beatObservers.size(); i++) {\n\t\n\t\n\t\nBeatObserver observer = (BeatObserver)beatObservers.get(i);\n\t\n\t\n\t\nobserver.updateBeat();\n\t\n\t\n}\n\t\n}\n\t\npublic void registerObserver(BPMObserver o) {\n\t\n\t\nbpmObservers.add(o);\n\t\n}\n\t\npublic void notifyBPMObservers() {\n\t\n\t\nfor (int i = 0; i < bpmObservers.size(); i++) {\n\t\n\t\n\t\nBPMObserver observer = (BPMObserver)bpmObservers.get(i);\n\t\n\t\n\t\nobserver.updateBPM();\n\t\n\t\n}\n\t\n}\n", "page": 589, "type": "text", "section": "Page 589"}
{"text": "552\u2003 \u2003 Chapter 12\n\t\npublic void removeObserver(BeatObserver o) {\n\t\n\t\nint i = beatObservers.indexOf(o);\n\t\n\t\nif (i >= 0) {\n\t\n\t\n\t\nbeatObservers.remove(i);\n\t\n\t\n}\n\t\n}\n\t\npublic void removeObserver(BPMObserver o) {\n\t\n\t\nint i = bpmObservers.indexOf(o);\n\t\n\t\nif (i >= 0) {\n\t\n\t\n\t\nbpmObservers.remove(i);\n\t\n\t\n}\n\t\n}\n\t\npublic void playBeat() {\n\t\n\t\nclip.setFramePosition(0);\n\t\n\t\nclip.start();\n\t\n}\n\t\npublic void stopBeat() {\n\t\n\t\nclip.setFramePosition(0);\n\t\n\t\nclip.stop();\n\t\n}\n}\nready-bake code: model\n", "page": 590, "type": "text", "section": "Page 590"}
{"text": "you are here 4\u2003 \u2003 553\ncompound patterns\npackage headfirst.designpatterns.combined.djview;\n  \npublic interface BPMObserver {\n    void updateBPM();\n}\npackage headfirst.designpatterns.combined.djview;\n  \npublic interface BeatObserver {\n    void updateBeat();\n}\nThe View\nReady Bake\nCode\npackage headfirst.designpatterns.combined.djview;\n    \nimport java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\npublic class DJView implements ActionListener,  BeatObserver, BPMObserver {\n    BeatModelInterface model;\n    ControllerInterface controller;\n    JFrame viewFrame;\n    JPanel viewPanel;\n    BeatBar beatBar;\n    JLabel bpmOutputLabel;\n    JFrame controlFrame;\n    JPanel controlPanel;\n    JLabel bpmLabel;\n    JTextField bpmTextField;\n    JButton setBPMButton;\n    JButton increaseBPMButton;\n    JButton decreaseBPMButton;\n    JMenuBar menuBar;\n    JMenu menu;\n    JMenuItem startMenuItem;\n    JMenuItem stopMenuItem;\n  \n    public DJView(ControllerInterface controller, BeatModelInterface model) {   \n        this.controller = controller;\n        this.model = model;\n        model.registerObserver((BeatObserver)this);\n        model.registerObserver((BPMObserver)this);\n    }\n    \n", "page": 591, "type": "text", "section": "Page 591"}
{"text": "554\u2003 \u2003 Chapter 12\n    public void createView() {\n        // Create all Swing components here\n        viewPanel = new JPanel(new GridLayout(1, 2));\n        viewFrame = new JFrame(\"View\");\n        viewFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        viewFrame.setSize(new Dimension(100, 80));\n        bpmOutputLabel = new JLabel(\"offline\", SwingConstants.CENTER);\n        beatBar = new BeatBar();\n        beatBar.setValue(0);\n        JPanel bpmPanel = new JPanel(new GridLayout(2, 1));\n        bpmPanel.add(beatBar);\n        bpmPanel.add(bpmOutputLabel);\n        viewPanel.add(bpmPanel);\n        viewFrame.getContentPane().add(viewPanel, BorderLayout.CENTER);\n        viewFrame.pack();\n        viewFrame.setVisible(true);\n    }\n  \n    public void createControls() {\n        // Create all Swing components here\n        JFrame.setDefaultLookAndFeelDecorated(true);\n        controlFrame = new JFrame(\"Control\");\n        controlFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        controlFrame.setSize(new Dimension(100, 80));\n        controlPanel = new JPanel(new GridLayout(1, 2));\n        menuBar = new JMenuBar();\n        menu = new JMenu(\"DJ Control\");\n        startMenuItem = new JMenuItem(\"Start\");\n        menu.add(startMenuItem);\n        startMenuItem.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent event) {\n                controller.start();\n            }\n        });\n        stopMenuItem = new JMenuItem(\"Stop\");\n        menu.add(stopMenuItem); \n        stopMenuItem.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent event) {\n                controller.stop();\n            }\n        });\n        JMenuItem exit = new JMenuItem(\"Quit\");\n        exit.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent event) {\n                System.exit(0);\n            }\n        });\nready-bake code: view\n", "page": 592, "type": "text", "section": "Page 592"}
{"text": "you are here 4\u2003 \u2003 555\ncompound patterns\nReady Bake\nCode\n        menu.add(exit);\n        menuBar.add(menu);\n        controlFrame.setJMenuBar(menuBar);\n        bpmTextField = new JTextField(2);\n        bpmLabel = new JLabel(\"Enter BPM:\", SwingConstants.RIGHT);\n        setBPMButton = new JButton(\"Set\");\n        setBPMButton.setSize(new Dimension(10,40));\n        increaseBPMButton = new JButton(\">>\");\n        decreaseBPMButton = new JButton(\"<<\");\n        setBPMButton.addActionListener(this);\n        increaseBPMButton.addActionListener(this);\n        decreaseBPMButton.addActionListener(this);\n        JPanel buttonPanel = new JPanel(new GridLayout(1, 2));\n        buttonPanel.add(decreaseBPMButton);\n        buttonPanel.add(increaseBPMButton);\n        JPanel enterPanel = new JPanel(new GridLayout(1, 2));\n        enterPanel.add(bpmLabel);\n        enterPanel.add(bpmTextField);\n        JPanel insideControlPanel = new JPanel(new GridLayout(3, 1));\n        insideControlPanel.add(enterPanel);\n        insideControlPanel.add(setBPMButton);\n        insideControlPanel.add(buttonPanel);\n        controlPanel.add(insideControlPanel);\n        \n        bpmLabel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n        bpmOutputLabel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n        controlFrame.getRootPane().setDefaultButton(setBPMButton);\n        controlFrame.getContentPane().add(controlPanel, BorderLayout.CENTER);\n        controlFrame.pack();\n        controlFrame.setVisible(true);\n    }\n    public void enableStopMenuItem() {\n        stopMenuItem.setEnabled(true);\n    }\n    public void disableStopMenuItem() {\n        stopMenuItem.setEnabled(false);\n    }\n", "page": 593, "type": "text", "section": "Page 593"}
{"text": "556\u2003 \u2003 Chapter 12\n    public void enableStartMenuItem() {\n        startMenuItem.setEnabled(true);\n    }\n    public void disableStartMenuItem() {\n        startMenuItem.setEnabled(false);\n    }\n    public void actionPerformed(ActionEvent event) {\n        if (event.getSource() == setBPMButton) {\n            int bpm = 90;\n            String bpmText = bpmTextField.getText();\n            if (bpmText == null || bpmText.contentEquals(\"\")) {\n                bpm = 90;\n            } else {\n                bpm = Integer.parseInt(bpmTextField.getText());\n            }\n            controller.setBPM(bpm);\n        } else if (event.getSource() == increaseBPMButton) {\n            controller.increaseBPM();\n        } else if (event.getSource() == decreaseBPMButton) {\n            controller.decreaseBPM();\n        }\n    }\n    public void updateBPM() {\n        int bpm = model.getBPM();\n        if (bpm == 0) {\n            bpmOutputLabel.setText(\"offline\");\n        } else {\n            bpmOutputLabel.setText(\"Current BPM: \" + model.getBPM());\n        }\n    }\n  \n    public void updateBeat() {\n        beatBar.setValue(100);\n    }\n}\npackage headfirst.designpatterns.combined.djview;\n  \npublic interface ControllerInterface {\n    void start();\n    void stop();\n    void increaseBPM();\n    void decreaseBPM();\n    void setBPM(int bpm);\n}\nThe Controller\nready-bake code: controller\n", "page": 594, "type": "text", "section": "Page 594"}
{"text": "you are here 4\u2003 \u2003 557\ncompound patterns\npackage headfirst.designpatterns.combined.djview;\n  \npublic class BeatController implements ControllerInterface {\n    BeatModelInterface model;\n    DJView view;\n   \n    public BeatController(BeatModelInterface model) {\n        this.model = model;\n        view = new DJView(this, model);\n        view.createView();\n        view.createControls();\n        view.disableStopMenuItem();\n        view.enableStartMenuItem();\n        model.initialize();\n    }\n  \n    public void start() {\n        model.on();\n        view.disableStartMenuItem();\n        view.enableStopMenuItem();\n    }\n  \n    public void stop() {\n        model.off();\n        view.disableStopMenuItem();\n        view.enableStartMenuItem();\n    }\n    \n    public void increaseBPM() {\n        int bpm = model.getBPM();\n        model.setBPM(bpm + 1);\n    }\n    \n    public void decreaseBPM() {\n        int bpm = model.getBPM();\n        model.setBPM(bpm - 1);\n    }\n  \n    public void setBPM(int bpm) {\n        model.setBPM(bpm);\n    }\n}\nReady Bake\nCode\n", "page": 595, "type": "text", "section": "Page 595"}
{"text": "558\u2003 \u2003 Chapter 12\npackage headfirst.designpatterns.combined.djview;\npublic interface HeartModelInterface {\n    int getHeartRate();\n    void registerObserver(BeatObserver o);\n    void removeObserver(BeatObserver o);\n    void registerObserver(BPMObserver o);\n    void removeObserver(BPMObserver o);\n}\npackage headfirst.designpatterns.combined.djview;\n  \npublic class HeartTestDrive {\n    public static void main (String[] args) {\n        HeartModel heartModel = new HeartModel();\n        ControllerInterface model = new HeartController(heartModel);\n    }\n}\nThe Heart Model\npackage headfirst.designpatterns.combined.djview;\nimport java.util.*;\npublic class HeartModel implements HeartModelInterface, Runnable {\n    List<BeatObserver> beatObservers = new ArrayList<BeatObserver>();\n    List<BPMObserver> bpmObservers = new ArrayList<BPMObserver>();\n    int time = 1000;\n    int bpm = 90;\n    Random random = new Random(System.currentTimeMillis());\n    Thread thread;\n    public HeartModel() {\n        thread = new Thread(this);\n        thread.start();\n    }\n    public void run() {\n        int lastrate = -1;\n        for(;;) {\n            int change = random.nextInt(10);\n            if (random.nextInt(2) == 0) {\n                change = 0 - change;\n            }\n            int rate = 60000/(time + change);\nready-bake code: heart model\n", "page": 596, "type": "text", "section": "Page 596"}
{"text": "you are here 4\u2003 \u2003 559\ncompound patterns\nReady Bake\nCode\n            if (rate < 120 && rate > 50) {\n                time += change;\n                notifyBeatObservers();\n                if (rate != lastrate) {\n                    lastrate = rate;\n                    notifyBPMObservers();\n                }\n            }\n            try {\n                Thread.sleep(time);\n            } catch (Exception e) {}\n        }\n    }\n    public int getHeartRate() {\n        return 60000/time;\n    }\n    public void registerObserver(BeatObserver o) {\n        beatObservers.add(o);\n    }\n    public void removeObserver(BeatObserver o) {\n        int i = beatObservers.indexOf(o);\n        if (i >= 0) {\n            beatObservers.remove(i);\n        }\n    }\n    public void notifyBeatObservers() {\n        for(int i = 0; i < beatObservers.size(); i++) {\n            BeatObserver observer = (BeatObserver)beatObservers.get(i);\n            observer.updateBeat();\n        }\n    }\n    public void registerObserver(BPMObserver o) {\n        bpmObservers.add(o);\n    }\n    public void removeObserver(BPMObserver o) {\n        int i = bpmObservers.indexOf(o);\n        if (i >= 0) {\n            bpmObservers.remove(i);\n        }\n    }\n    public void notifyBPMObservers() {\n        for(int i = 0; i < bpmObservers.size(); i++) {\n            BPMObserver observer = (BPMObserver)bpmObservers.get(i);\n            observer.updateBPM();\n        }\n    }\n}\n", "page": 597, "type": "text", "section": "Page 597"}
{"text": "560\u2003 \u2003 Chapter 12\npackage headfirst.designpatterns.combined.djview;\npublic class HeartAdapter implements BeatModelInterface {\n    HeartModelInterface heart;\n \n    public HeartAdapter(HeartModelInterface heart) {\n        this.heart = heart;\n    }\n    public void initialize() {}\n  \n    public void on() {}\n  \n    public void off() {}\n   \n    public int getBPM() {\n        return heart.getHeartRate();\n    }\n  \n    public void setBPM(int bpm) {}\n   \n    public void registerObserver(BeatObserver o) {\n        heart.registerObserver(o);\n    }\n    \n    public void removeObserver(BeatObserver o) {\n        heart.removeObserver(o);\n    }\n     \n    public void registerObserver(BPMObserver o) {\n        heart.registerObserver(o);\n    }\n  \n    public void removeObserver(BPMObserver o) {\n        heart.removeObserver(o);\n    }\n}\nThe Heart Adapter\nready-bake code: heart adapter\n", "page": 598, "type": "text", "section": "Page 598"}
{"text": "you are here 4\u2003 \u2003 561\ncompound patterns\npackage headfirst.designpatterns.combined.djview;\n  \npublic class HeartController implements ControllerInterface {\n    HeartModelInterface model;\n    DJView view;\n  \n    public HeartController(HeartModelInterface model) {\n        this.model = model;\n        view = new DJView(this, new HeartAdapter(model));\n        view.createView();\n        view.createControls();\n        view.disableStopMenuItem();\n        view.disableStartMenuItem();\n    }\n  \n    public void start() {}\n \n    public void stop() {}\n    \n    public void increaseBPM() {}\n    \n    public void decreaseBPM() {}\n  \n    public void setBPM(int bpm) {}\n}\nThe Controller\nReady Bake\nCode\n", "page": 599, "type": "text", "section": "Page 599"}
{"text": "this is a new chapter\u2003 \u2003 563\nAhhhh, now you\u2019re ready for a bright new world filled with \nDesign Patterns. But, before you go opening all those new doors of opportunity, we \nneed to cover a few details that you\u2019ll encounter out in the real world\u2014that\u2019s right, things \nget a little more complex than they are here in Objectville. Come along, we\u2019ve got a nice \nguide to help you through the transition on the next page...\nPatterns in the \n13  better living with patterns\nReal World\n", "page": 601, "type": "text", "section": "Page 601"}
{"text": "564\u2003 \u2003 Chapter 13\nwhat you\u2019ll learn from the guide\nThe Objectville Guide to \n    Better Living with Design Patterns\nPlease accept our handy guide with tips & tricks for living with patterns in the real \nworld. In this guide you will:\n \n)   Learn the all too common misconceptions about the definition of a \n\u201cDesign Pattern.\u201d\n \n)   Discover those nifty Design Patterns catalogs and why you just have to \nget one.\n \n)   Avoid the embarrassment of using a Design Pattern at the wrong time.\n \n)   Learn how to keep patterns in classifications where they belong.\n \n)   See that discovering patterns isn\u2019t just for the gurus; read our quick \nHow To and become a patterns writer too.\n \n)   Be there when the true identity of the mysterious Gang of Four is revealed.\n \n)   Keep up with the neighbors\u2014the coffee table books any patterns user \nmust own.\n \n)   Learn to train your mind like a Zen master.\n \n)   Win friends and influence developers by improving your patterns \nvocabulary.\n", "page": 602, "type": "text", "section": "Page 602"}
{"text": "you are here 4\u2003 \u2003 565\nbetter living with patterns\nA Pattern is a solution to a problem in a context.\nDesign Pattern defined\nWe bet you\u2019ve got a pretty good idea of what a pattern is after reading this book. But \nwe\u2019ve never really given a definition for a Design Pattern. Well, you might be a bit \nsurprised by the definition that is in common use:\nThat\u2019s not the most revealing definition, is it? But don\u2019t worry, we\u2019re going to \nstep through each of these parts: context, problem, and solution:\nThe context is the situation in which the pattern applies. This should be \na recurring situation.\nThe problem refers to the goal you are trying to achieve in this context, \nbut it also refers to any constraints that occur in the context.\nThe solution is what you\u2019re after: a general design that anyone can \napply that resolves the goal and set of constraints.\nThis is one of those definitions that takes a while to sink in, but take it one step \nat a time. Try thinking of it like this:\n\u201cIf you find yourself in a context with a problem that has a goal that \nis affected by a set of constraints, then you can apply a design that \nresolves the goal and constraints and leads to a solution.\u201d\nNow, this seems like a lot of work just to figure out what a Design Pattern \nis. After all, you already know that a Design Pattern gives you a solution to a \ncommon recurring design problem. What is all this formality getting you? Well, \nyou\u2019re going to see that by having a formal way of describing patterns we can \ncreate a catalog of patterns, which has all kinds of benefits.\nExample: You have a \ncollection of objects.\nYou need to step \nthrough the objects \nwithout exposing \nthe collection\u2019s \nimplementation.\nEncapsulate the \niteration into a \nseparate class.\n", "page": 603, "type": "text", "section": "Page 603"}
{"text": "566\u2003 \u2003 Chapter 13\ndesign pattern defined\nYou might be right; let\u2019s think about this a bit... We need a problem, a \nsolution, and a context:\nProblem: How do I get to work on time?\nContext: I\u2019ve locked my keys in the car.\nSolution: Break the window, get in the car, start the \nengine, and drive to work.\n\nWe have all the components of the definition: we have a problem, \nwhich includes the goal of getting to work, and the constraints of time, \ndistance, and probably some other factors. We also have a context in \nwhich the keys to the car are inaccessible. And we have a solution that \ngets us to the keys and resolves both the time and distance constraints.  \nWe must have a pattern now! Right? \nI\u2019ve been thinking about \nthe three-part definition, \nand I don\u2019t think it defines a \npattern at all.\nWe followed the Design Pattern definition and defined a problem, a context, and \na solution (which works!). Is this a pattern? If not, how did it fail? Could we fail the \nsame way when defining an OO Design Pattern?\n", "page": 604, "type": "text", "section": "Page 604"}
{"text": "you are here 4\u2003 \u2003 567\nbetter living with patterns\nPatterns\nA-I\nPatterns\nJ-R\nPatterns\nS-Z\nLooking more closely at the \nDesign Pattern definition\nOur example does seem to match the Design Pattern \ndefinition, but it isn\u2019t a true pattern. Why? For starters, \nwe know that a pattern needs to apply to a recurring \nproblem. While an absent-minded person might lock \nhis keys in the car often, breaking the car window \ndoesn\u2019t qualify as a solution that can be applied over \nand over (or at least isn\u2019t likely to if we balance the \ngoal with another constraint: cost).\nIt also fails in a couple of other ways: first, it isn\u2019t easy \nto take this description, hand it to someone, and have \nhim apply it to his own unique problem. Second, we\u2019ve \nviolated an important but simple aspect of a pattern: \nwe haven\u2019t even given it a name! Without a name, the \npattern doesn\u2019t become part of a vocabulary that can \nbe shared with other developers.\nLuckily, patterns are not described and documented as \na simple problem, context, and solution; we have much \nbetter ways of describing patterns and collecting them \ntogether into patterns catalogs.\nQ: Am I going to see pattern \ndescriptions that are stated as a problem, \na context, and a solution?\nA: Pattern descriptions, which you\u2019ll \ntypically find in patterns catalogs, are usually \na bit more revealing than that. We\u2019re going \nto look at patterns catalogs in detail in just \na minute; they describe a lot more about a \npattern\u2019s intent and motivation and where it \nmight apply, along with the solution design \nand the consequences (good and bad) of \nusing it.\n\nQ: Is it okay to slightly alter a pattern\u2019s \nstructure to fit my design? Or am I going \nto have to go by the strict definition?\nA: Of course you can alter it. Like design \nprinciples, patterns are not meant to be laws \nor rules; they are guidelines that you can \nalter to fit your needs. As you\u2019ve seen, a lot \nof real-world examples don\u2019t fit the classic \npattern designs. \n\nHowever, when you adapt patterns, it \nnever hurts to document how your pattern \ndiffers from the classic design\u2014that way, \nother developers can quickly recognize the \npatterns you\u2019re using and any differences \nbetween your pattern and the classic pattern.\nQ: Where can I get a patterns catalog? \nA: The first and most definitive patterns \ncatalog is Design Patterns: Elements of \nReusable Object-Oriented Software, by \nGamma, Helm, Johnson, and Vlissides \n(Addison Wesley). This catalog lays out 23 \nfundamental patterns. We\u2019ll talk a little more \nabout this book in a few pages.\n\nMany other patterns catalogs are starting to \nbe published in various domain areas such \nas enterprise software, concurrent systems, \nand business systems.\nNext time someone \ntells you a pattern is a \nsolution to a problem in a context, just \nnod and smile. You know what they mean, \neven if it isn\u2019t a definition sufficient to \ndescribe what a Design Pattern really is.\n", "page": 605, "type": "text", "section": "Page 605"}
{"text": "568\u2003 \u2003 Chapter 13\nforces goals constraints\nGeek Bits\nMay the force be with you\nThe Design Pattern \ndefinition tells us that \nthe problem consists of a \ngoal and a set of constraints. \nPattern gurus have a term for \nthese: they call them forces. \nWhy? Well, we\u2019re sure they \nhave their own reasons, but if \nyou remember the movie, the force \n\u201cshapes and controls the Universe.\u201d \nLikewise, the forces in the pattern \ndefinition shape and control the solution. \n \nOnly when a solution balances both sides of \nthe force (the light side: your goal, and the dark \nside: the constraints) do we have a useful pattern.\nThis \u201cforce\u201d terminology can be quite confusing \nwhen you first see it in pattern discussions, but \njust remember that there are two sides of the force \n(goals and constraints) and that they need to be \nbalanced or resolved to create a pattern solution. Don\u2019t \nlet the lingo get in your way and may the force be with you! \n", "page": 606, "type": "text", "section": "Page 606"}
{"text": "you are here 4\u2003 \u2003 569\nbetter living with patterns\nFrank: Fill us in, Jim. I\u2019ve just been learning patterns by reading a few \narticles here and there.\nJim: Sure, each patterns catalog takes a set of patterns and describes \neach in detail along with its relationship to the other patterns.\nJoe: Are you saying there is more than one patterns catalog?\nJim: Of course; there are catalogs for fundamental Design Patterns \nand there are also catalogs on domain-specific patterns, like enterprise \nor distributed computing patterns.\nFrank: Which catalog are you looking at?\nJim: This is the classic GoF catalog; it contains 23 fundamental \nDesign Patterns.\nFrank: GoF?\nJim: Right, that stands for the Gang of Four. The Gang of Four are \nthe guys that put together the first patterns catalog.\nJoe: What\u2019s in the catalog?\nJim: There is a set of related patterns. For each pattern there is a \ndescription that follows a template and spells out a lot of details of the \npattern. For instance, each pattern has a name.\nJoe\nJim\nFrank\nI wish I\u2019d known \nabout patterns catalogs \na long time ago...\n", "page": 607, "type": "text", "section": "Page 607"}
{"text": "570\u2003 \u2003 Chapter 13\nusing a patterns catalog\nFrank: Wow, that\u2019s earth-shattering, a name! Imagine that.\nJim: Hold on, Frank; actually, the name is really important. When we have a name \nfor a pattern, it gives us a way to talk about the pattern; you know, that whole shared \nvocabulary thing.\nFrank: Okay, okay. I was just kidding. Go on, what else is there?\nJim: Well, like I was saying, every pattern follows a template. For each pattern we have \na name and a few sections that tell us more about the pattern. For instance, there is an \nIntent section that describes what the pattern is, kind of like a definition. Then there are \nMotivation and Applicability sections that describe when and where the pattern might be \nused. \nJoe: What about the design itself?\nJim: There are several sections that describe the class design along with all the classes \nthat make it up and what their roles are. There is also a section that describes how to \nimplement the pattern and often sample code to show you how.\nFrank: It sounds like they\u2019ve thought of everything.\nJim: There\u2019s more. There are also examples of where the pattern has been used in real \nsystems, as well as what I think is one of the most useful sections: how the pattern relates \nto other patterns.\nFrank: Oh, you mean they tell you things like how the State and Strategy Patterns differ?\nJim: Exactly!\nJoe:  So Jim, how are you actually using the catalog? When you have a problem, do you \ngo fishing in the catalog for a solution?\nJim: I try to get familiar with all the patterns and their relationships first. Then, when I \nneed a pattern, I have some idea of what it is. I go back and look at the Motivation and \nApplicability sections to make sure I\u2019ve got it right. There is also another really important \nsection: Consequences. I review that to make sure there won\u2019t be some unintended effect \non my design. \nFrank: That makes sense. So once you know the pattern is right, how do you approach \nworking it into your design and implementing it?\nJim:  That\u2019s where the class diagram comes in. I first read over the Structure section to \nreview the diagram and then over the Participants section to make sure I understand each \nclass\u2019s role. From there, I work it into my design, making any alterations I need to make \nit fit. Then I review the Implementation and Sample Code sections to make sure I know \nabout any good implementation techniques or gotchas I might encounter.\nJoe:  I can see how a catalog is really going to accelerate my use of patterns!\nFrank: Totally. Jim, can you walk us through a pattern description?\n", "page": 608, "type": "text", "section": "Page 608"}
{"text": "you are here 4\u2003 \u2003 571\nbetter living with patterns\nSINGLETON\nObject Creational\nIntent\nEt aliquat, velesto ent lore feuis acillao rperci tat, quat nonsequam il ea at nim nos do enim \nqui eratio ex ea faci tet, sequis dion utat, volore magnisi.\nMotivation\nEt aliquat, velesto ent lore feuis acillao rperci tat, quat nonsequam il ea at nim nos do enim qui \neratio ex ea faci tet, sequis dion utat, volore magnisi.Rud modolore dit laoreet augiam iril el \ndipis dionsequis dignibh eummy nibh esequat. Duis nulputem ipisim esecte conullut wissi.\nOs nisissenim et lumsandre do con el utpatuero corercipis augue doloreet luptat amet vel \niuscidunt digna feugue dunt num etummy nim dui blaor sequat num vel etue magna augiat.\nAliquis nonse vel exer se minissequis do dolortis ad magnit, sim zzrillut ipsummo dolorem \ndignibh euguer sequam ea am quate magnim illam zzrit ad magna feu facinit delit ut\nApplicability\nDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre \ndolore magna feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min \nea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit \nirit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \ndiam nonullu tpatiss ismodignibh er.\nStructure\nSingleton\nstatic uniqueInstance\n// Other useful Singleton data...\nstatic getInstance()\n// Other useful Singleton methods...\nParticipants\nDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre \ndolore magna feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min \nea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit \nirit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \ndiam nonullu tpatiss ismodignibh er\n\u0083\t A dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem diam \nnonullu tpatiss ismodignibh er\n\t\n\t\n\t\n\u2013  A feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min ea \t\n\t\n\t\n    feuipit ing enit laore magnibh eniat wisissec\n\t\n\t\n\t\n\u2013  Ad magnim quate modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit\nCollaborations\n\u0083\t Feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit \nirit, conse dolore.\nConsequences\nDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre:\t\n\t\n1.  Dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \t\n\t\n     diam nonullu tpatiss ismodignibh er.\n\t\n2.  Modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit laore magnibh \t\n\t\n     eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit irit, conse dolore dolore \t\n\t\n     et, verci enis enit ip elesequisl ut ad esectem.\n\t\n3.  Dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \t\n\t\n     diam nonullu tpatiss ismodignibh er.\n\t\n4.  Modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit laore magnibh \t\n\t\n     eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit irit, conse dolore dolore \t\n\t\n     et, verci enis enit ip elesequisl ut ad esectem.\nImplementation/Sample Code\nDuDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre \ndolore magna feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min \nea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit \nirit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \ndiam nonullu tpatiss ismodignibh er.\nNos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit \nlaore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit irit, conse dolore \ndolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem diam nonullu \ntpatiss ismodignibh er.\npublic class Singleton {\n    private static Singleton uniqueInstance;\n \n    // other useful instance variables here\n \n    private Singleton() {}\n \n    public static synchronized Singleton getInstance() \n{\n        if (uniqueInstance == null) {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n \n    // other useful methods here\n}\nKnown Uses\nDuDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre \ndolore magna feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min \nea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit \nirit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \ndiam nonullu tpatiss ismodignibh er.\nDuDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre \ndolore magna feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min \nea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit \nirit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \ndiam nonullu tpatiss ismodignibh er. alit ad magnim quate modolore vent lut luptat prat. \nDui blaore min ea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam \ndolorpe rcilit irit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con \neros autem diam nonullu tpatiss ismodignibh er.\nRelated Patterns\nElesequisl ut ad esectem ing ea con eros autem diam nonullu tpatiss ismodignibh er. alit \nad magnim quate modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit laore \nmagnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit irit, conse dolore dolore \net, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem diam nonullu tpatiss \nismodignibh er.\nThe structure provides a \ndiagram illustrating the \nrelationships among the \nclasses that participate \nin the pattern.\nThe participants are the classes and \nobjects in the design. This section \ndescribes their responsibilities and roles \nin the pattern.\nCollaborations tells us \nhow the participants work \ntogether in the pattern.\nThe consequences describe the \neffects that using this pattern \nmay have: good and bad.\nAll patterns in a catalog start with \na name. The name is a vital part of \na pattern\u2009\u2014\u2009without a good name, \na pattern can\u2019t become part of \nthe vocabulary that you share with \nother developers.\nThis is the pattern\u2019s \nclassification or \ncategory. We\u2019ll talk \nabout these in a few \npages.\nThe intent describes what \nthe pattern does in a short \nstatement. You can also think \nof this as the pattern\u2019s \ndefinition (just like we\u2019ve been \nusing in this book).\nThe motivation gives you a concrete \nscenario that describes the problem and \n \nhow the solution solves the problem.\nThe applicability describes situations \nin which the pattern can be applied.\nImplementation provides \ntechniques you need to use when \nimplementing this pattern, and \nissues you should watch out for.\nSample Code \nprovides code \nfragments that \nmight help with your \nimplementation.\nKnown Uses describes \nexamples of this pattern \nfound in real systems.\nRelated Patterns \ndescribes the \nrelationship between \nthis pattern and others.\n", "page": 609, "type": "text", "section": "Page 609"}
{"text": "572\u2003 \u2003 Chapter 13\ndiscovering your own patterns\nSo you wanna be a design \npatterns star?\nWell, listen now to what I tell.\nGet yourself a patterns catalog,\nThen take some time and learn \nit well.\nAnd when you\u2019ve got your \ndescription right,\nAnd three developers agree \nwithout a fight,\nThen you\u2019ll know it\u2019s a pattern \nalright.\nT\no the tune of \u201cSo you wanna \nbe a Rock\u2019n\u2019Roll Star.\u201d\nQ: Is it possible to create your own Design \nPatterns? Or is that something you have to be a \n\u201cpatterns guru\u201d to do?\nA: First, remember that patterns are discovered, not \ncreated. So, anyone can discover a Design Pattern and \nthen author its description; however, it\u2019s not easy and \ndoesn\u2019t happen quickly, nor often. Being a \u201cpatterns \nwriter\u201d takes commitment.\n\nYou should first think about why you\u2019d want to\u2014the \nmajority of people don\u2019t author patterns; they just use \nthem. However, you might work in a specialized domain \nfor which you think new patterns would be helpful, or you \nmight have come across a solution to what you think is a \nrecurring problem, or you may just want to get involved \nin the patterns community and contribute to the growing \nbody of work.\nQ: I\u2019m game; how do I get started?\nA: As with any discipline, the more you know, the \nbetter. Studying existing patterns, what they do, and how \nthey relate to other patterns is crucial. Not only does it \nmake you familiar with how patterns are crafted, it also \nprevents you from reinventing the wheel. From there \nyou\u2019ll want to start writing your patterns on paper, so you \ncan communicate them to other developers; we\u2019re going \nto talk more about how to communicate your patterns in \na bit. If you\u2019re really interested, you\u2019ll want to read the \nsection that follows these Q&As.\nQ: How do I know when I really have a pattern? \nA: That\u2019s a very good question: you don\u2019t have a \npattern until others have used it and found it to work. In \ngeneral, you don\u2019t have a pattern until it passes the \u201cRule \nof Three.\u201d This rule states that a pattern can be called a \npattern only if it has been applied in a real-world solution \nat least three times.\n", "page": 610, "type": "text", "section": "Page 610"}
{"text": "you are here 4\u2003 \u2003 573\nbetter living with patterns\nName\nIntent\nMotivation\nApplicability\nStructure\nParticipants\nCollaborations\n ...\nUse one of the existing \npattern templates to \ndefine your pattern. A lot \nof thought has gone into \nthese templates and other \npattern users will recognize \nthe format.\nSo you wanna be a Design Patterns writer\nDo your homework. You need to be well versed in the \nexisting patterns before you can create a new one. Most patterns \nthat appear to be new, are, in fact, just variants of existing \npatterns. By studying patterns, you become better at recognizing \nthem, and you learn to relate them to other patterns.\nTake time to reflect, evaluate. Your experience\u2014the \nproblems you\u2019ve encountered, and the solutions you\u2019ve used\u2014\nare where ideas for patterns are born. So take some time to \nreflect on your experiences and comb them for novel designs \nthat recur. Remember that most designs are variations on \nexisting patterns and not new patterns. And when you do find \nwhat looks like a new pattern, its applicability may be too \nnarrow to qualify as a real pattern.\nGet your ideas down on paper in a way others can \nunderstand. Locating new patterns isn\u2019t of much use if \nothers can\u2019t make use of your find; you need to document your \npattern candidates so that others can read, understand, and \napply them to their own solution and then supply you with \nfeedback. Luckily, you don\u2019t need to invent your own method of \ndocumenting your patterns. As you\u2019ve already seen with the GoF \ntemplate, a lot of thought has already gone into how to describe \npatterns and their characteristics.\nHave others try your patterns; then refine and refine \nsome more.  Don\u2019t expect to get your pattern right the first \ntime. Think of your pattern as a work in progress that will \nimprove over time. Have other developers review your candidate \npattern, try it out, and give you feedback. Incorporate that \nfeedback into your description and try again. Your description \nwill never be perfect, but at some point it should be solid enough \nthat other developers can read and understand it.\nDon\u2019t forget the Rule of Three. Remember, unless your \npattern has been successfully applied in three real-world \nsolutions, it can\u2019t qualify as a pattern. That\u2019s another good \nreason to get your pattern into the hands of others so they can \ntry it, give feedback, and allow you to converge on a working \npattern.\n", "page": 611, "type": "text", "section": "Page 611"}
{"text": "574\u2003 \u2003 Chapter 13\nwho does what?\nMatch each pattern with its description:\nPattern\nDescription\nWraps an object and provides a different \ninterface to it.\nSubclasses decide how to implement steps in an \nalgorithm.\nSubclasses decide which concrete classes to \ncreate.\nEnsures one and only one object is created.\nEncapsulates interchangeable behaviors and uses \ndelegation to decide which one to use.\nClients treat collections of objects and individual \nobjects uniformly.\nEncapsulates state-based behaviors and uses \ndelegation to switch between behaviors.\nProvides a way to traverse a collection of objects \nwithout exposing its implementation.\nSimplifies the interface of a set of classes.\nWraps an object to provide new behavior.\nAllows a client to create families of objects \nwithout specifying their concrete classes.\nAllows objects to be notified when state changes.\nWraps an object to control access to it.\nEncapsulates a request as an object.\nDecorator\nState\nIterator\nFacade\nStrategy\nProxy\nFactory Method\nAdapter\nObserver\nTemplate Method\nComposite\nSingleton\nAbstract Factory\nCommand\n", "page": 612, "type": "text", "section": "Page 612"}
{"text": "you are here 4\u2003 \u2003 575\nbetter living with patterns\nOrganizing Design Patterns\nAs the number of discovered Design Patterns grows, it makes sense to partition them into \nclassifications so that we can organize them, narrow our searches to a subset of all Design Patterns, \nand make comparisons within a group of patterns.\nIn most catalogs, you\u2019ll find patterns grouped into one of a few classification schemes. The most \nwell-known scheme was used by the first patterns catalog and partitions patterns into three distinct \ncategories based on their purposes: Creational, Behavioral, and Structural.  \nAny pattern that is a Behavioral \nPattern is concerned with how \nclasses and objects interact and \ndistribute responsibility. \nStructural Patterns let you \ncompose classes or objects \ninto larger structures.   \nAbstract Factory\nFactory Method\nSingleton\nAdapter\nComposite\nDecorator\nFacade\nProxy\nCommand\nIterator\nObserver\nState\nStrategy\nTemplate Method\nBehavioral\nCreational\nStructural\nCreational Patterns involve object \ninstantiation and all provide a \nway to decouple a client from the \nobjects it needs to instantiate.\nEach of these patterns belongs \nin one of those categories.\nRead each category description and \nsee if you can corral these patterns \ninto their correct categories. This is a \ntoughy! But give it your best shot and \nthen check out the answers on the \nnext page.\n", "page": 613, "type": "text", "section": "Page 613"}
{"text": "576\u2003 \u2003 Chapter 13\npattern categories\nAny pattern that is a Behavioral \nPattern is concerned with how \nclasses and objects interact and \ndistribute responsibility. \nStructural Patterns let you \ncompose classes or objects \ninto larger structures.   \nAbstract Factory\nFactory Method\nSingleton\nAdapter\nComposite\nDecorator\nFacade\nProxy\nCommand\nIterator\nObserver\nState\nStrategy\nTemplate Method\nBehavioral\nCreational\nStructural\nPrototype\nBuilder\nInterpreter\nChain of Responsibility\nMediator\nMemento\nVisitor\nBridge\nFlyweight\nWe\u2019ve got a few patterns \n(in grey) that you haven\u2019t \nseen yet. You\u2019ll find an \noverview of these patterns \nin the Appendix.\nCreational Patterns involve object \ninstantiation and all provide a \nway to decouple a client from the \nobjects it needs to instantiate.\nPattern Categories\nHere\u2019s the grouping of patterns into categories. You probably found the exercise difficult, because \nmany of the patterns seem like they could fit into more than one category. Don\u2019t worry, everyone \nhas trouble figuring out the right categories for the patterns.\n", "page": 614, "type": "text", "section": "Page 614"}
{"text": "you are here 4\u2003 \u2003 577\nbetter living with patterns\nClass Patterns describe how relationships between \nclasses are defined via inheritance. Relationships in \nclass patterns are established at compile time.\nAbstract Factory\nFactory Method\nSingleton\nAdapter\nComposite\nDecorator\nFacade\nProxy\nCommand\nIterator\nObserver\nState\nStrategy\nTemplate Method\nObject\nClass\nPrototype\nBuilder\nInterpreter\nChain of Responsibility\nMediator\nMemento\nVisitor\nBridge\nFlyweight\nPatterns are often classified by a second attribute: whether or not \nthe pattern deals with classes or objects:\nObject Patterns describe \nrelationships between objects \nand are primarily defined by \ncomposition. Relationships in \nobject patterns are typically \ncreated at runtime and are \nmore dynamic and flexible.\nNotice there are \na lot more object \npatterns than \nclass patterns!\nQ: Are these the only classification \nschemes?\nA: No, other schemes have been \nproposed. Some other schemes start \nwith the three categories and then add \nsubcategories, like \u201cDecoupling Patterns.\u201d \nYou\u2019ll want to be familiar with the most \ncommon schemes for organizing patterns, \nbut also feel free to create your own, if it \nhelps you to understand the patterns better.\nQ: Does organizing patterns into \ncategories really help you remember \nthem?\nA: It certainly gives you a framework for \nthe sake of comparison. But many people \nare confused by the creational, structural, \nand behavioral categories; often a pattern \nseems to fit into more than one category. \nThe most important thing is to know the \npatterns and the relationships among them.  \nWhen categories help, use them!\nQ: Why is the Decorator Pattern in the \nstructural category? I would have thought \nof that as a behavioral pattern; after all, it \nadds behavior! \n\n\nA: Yes, lots of developers say that! \nHere\u2019s the thinking behind the Gang of Four \nclassification: structural patterns describe \nhow classes and objects are composed to \ncreate new structures or new functionality. \nThe Decorator Pattern allows you to \ncompose objects by wrapping one object \nwith another to provide new functionality. So \nthe focus is on how you compose the objects \ndynamically to gain functionality, rather than \non the communication and interconnection \nbetween objects, which is the purpose of \nbehavioral patterns. But remember, the \nintent of these patterns is different, and \nthat\u2019s often the key to understanding which \ncategory a pattern belongs to.\n", "page": 615, "type": "text", "section": "Page 615"}
{"text": "578\u2003 \u2003 Chapter 13\npattern categories\nGuru and Student...\nGuru: Student, you look troubled.\nStudent: Yes, I\u2019ve just learned about \npattern classification and I\u2019m confused.\nGuru: Continue...\nStudent: After learning much about patterns, I\u2019ve \njust been told that each pattern fits into one of three \nclassifications: structural, behavioral, or creational. Why \ndo we need these classifications?\nGuru: Whenever we have a large collection of anything, \nwe naturally find categories to fit those things into. It \nhelps us to think of the items at a more abstract level.\nStudent: Guru; can you give me an example?\nGuru: Of course. Take automobiles; there are many \ndifferent models of automobiles and we naturally put \nthem into categories like economy cars, sports cars, \nSUVs, trucks, and luxury cars.  \nGuru: You look shocked; does this not make sense?\nStudent: Guru, it makes a lot of sense, but I am \nshocked you know so much about cars!\nGuru: I can\u2019t relate everything to lotus flowers or rice \nbowls. Now, may I continue?\nStudent: Yes, yes, I\u2019m sorry, please continue.\nGuru: Once you have classifications or categories, you \ncan easily talk about the different groupings: \u201cIf you\u2019re \ndoing the mountain drive from Silicon Valley to Santa \nCruz, a sports car with good handling is the best \noption.\u201d Or, \u201cWith the worsening oil situation, you really \nwant to buy a economy car; they\u2019re more fuel-efficient.\u201d\nStudent: So by having categories, we can talk about a \nset of patterns as a group. We might know we need a \ncreational pattern, without knowing exactly which one, \nbut we can still talk about creational patterns.\nGuru: Yes, and it also gives us a way to compare a \nmember to the rest of the category. For example, \u201cThe \nMini really is the most stylish compact car around,\u201d or \nto narrow our search, \u201cI need a fuel-efficient car.\u201d\n", "page": 616, "type": "text", "section": "Page 616"}
{"text": "you are here 4\u2003 \u2003 579\nbetter living with patterns\nStudent: I see. So I might say that the Adapter Pattern \nis the best structural pattern for changing an object\u2019s \ninterface.\nGuru: Yes. We also can use categories for one more \npurpose: to launch into new territory. For instance, \n\u201cWe really want to deliver a sports car with Ferrari \nperformance at Honda prices.\u201d\nStudent: That sounds like a death trap.\nGuru: I\u2019m sorry, I did not hear you, student.\nStudent: Uh, I said \u201cI see that.\u201d\nStudent: So categories give us a way to think about the \nway groups of patterns relate and how patterns within \na group relate to one another. They also give us a way \nto extrapolate to new patterns. But why are there three \ncategories and not four or five?\nGuru: Ah, like stars in the night sky, there are as many \ncategories as you want to see. Three is a convenient \nnumber and a number that many people have decided \nmakes for a nice grouping of patterns. But others have \nsuggested four, five, or more.\n", "page": 617, "type": "text", "section": "Page 617"}
{"text": "580\u2003 \u2003 Chapter 13\nthinking in patterns\nThinking in Patterns\nYour Brain on Patterns\nContexts, constraints, forces, catalogs, classifications...boy, this \nis starting to sound mighty academic. Okay, all that stuff is \nimportant and knowledge is power. But, let\u2019s face it, if you \nunderstand the academic stuff and don\u2019t have the experience and \npractice using patterns, then it\u2019s not going to make much difference \nin your life.\nHere\u2019s a quick guide to help you start to think in patterns. What do \nwe mean by that? We mean being able to look at a design and see \nwhere patterns naturally fit and where they don\u2019t.\nKeep it simple (KISS)\nFirst of all, when you design, solve things in the simplest way possible. Your goal should be simplicity, \nnot \u201chow can I apply a pattern to this problem?\u201d Don\u2019t feel like you aren\u2019t a sophisticated developer if \nyou don\u2019t use a pattern to solve a problem. Other developers will appreciate and admire the simplicity \nof your design. That said, sometimes the best way to keep your design simple and flexible is to use a \npattern.\nDesign Patterns aren\u2019t a magic bullet; in fact, they\u2019re not even a bullet!\nPatterns, as you know, are general solutions to recurring problems. Patterns also have the benefit of \nbeing well tested by lots of developers. So, when you see a need for one, you can sleep well knowing \nmany developers have been there before and solved the problem using similar techniques.\nHowever, patterns aren\u2019t a magic bullet. You can\u2019t plug one in, compile, and then take an early lunch.  \nTo use patterns, you also need to think through the consequences for the rest of your design. \nYou know you need a pattern when...\nAh...the most important question: when do you use a pattern? As you approach your design, introduce \na pattern when you\u2019re sure it addresses a problem in your design. If a simpler solution might work, give \nthat consideration before you commit to using a pattern.\nKnowing when a pattern applies is where your experience and knowledge come in. Once you\u2019re sure \na simple solution will not meet your needs, you should consider the problem along with the set of \nconstraints under which the solution will need to operate\u2014these will help you match your problem to \na pattern. If you\u2019ve got a good knowledge of patterns, you may know of a pattern that is a good match.  \nOtherwise, survey patterns that look like they might solve the problem. The intent and applicability \nsections of the patterns catalogs are particularly useful for this. Once you\u2019ve found a pattern that \nappears to be a good match, make sure it has a set of consequences you can live with and study its effect \non the rest of your design. If everything looks good, go for it!  \n", "page": 618, "type": "text", "section": "Page 618"}
{"text": "you are here 4\u2003 \u2003 581\nbetter living with patterns\nThere is one situation in which you\u2019ll want to use a pattern even if a \nsimpler solution would work: when you expect aspects of your system to \nvary. As we\u2019ve seen, identifying areas of change in your design is usually a \ngood sign that a pattern is needed. Just make sure you are adding patterns \nto deal with practical change that is likely to happen, not hypothetical change \nthat may happen.\nDesign time isn\u2019t the only time you want to consider introducing patterns; \nyou\u2019ll also want to do so at refactoring time.\nRefactoring time is Patterns time!\nRefactoring is the process of making changes to your code to improve \nthe way it is organized. The goal is to improve its structure, not change \nits behavior. This is a great time to reexamine your design to see if it \nmight be better structured with patterns. For instance, code that is full of \nconditional statements might signal the need for the State Pattern. Or, it \nmay be time to clean up concrete dependencies with Factory. Entire books \nhave been written on the topic of refactoring with patterns, and as your \nskills grow, you\u2019ll want to study this area more.\nTake out what you don\u2019t really need. Don\u2019t be afraid \nto remove a Design Pattern from your design.\nNo one ever talks about when to remove a pattern. You\u2019d think it was \nblasphemy! Nah, we\u2019re all adults here; we can take it.\nSo when do you remove a pattern? When your system has become \ncomplex and the flexibility you planned for isn\u2019t needed. In other words, \nwhen a simpler solution without the pattern would be better.\nIf you don\u2019t need it now, don\u2019t do it now.\nDesign Patterns are powerful, and it\u2019s easy to see all kinds of ways they \ncan be used in your current designs. Developers naturally love to create \nbeautiful architectures that are ready to take on change from any direction.\nResist the temptation. If you have a practical need to support change in \na design today, go ahead and employ a pattern to handle that change.  \nHowever, if the reason is only hypothetical, don\u2019t add the pattern; it will \nonly add complexity to your system, and you might never need it!\nCenter your thinking on \ndesign, not on patterns. Use \npatterns when there is a natural \nneed for them. If something \nsimpler will work, then use it.\n", "page": 619, "type": "text", "section": "Page 619"}
{"text": "582\u2003 \u2003 Chapter 13\npatterns emerge naturally\nGuru and Student...\nGuru: Student, your initial training is almost complete. \nWhat are your plans?\nStudent: I\u2019m going to Disneyland! And then I\u2019m \ngoing to start creating lots of code with patterns!\nGuru: Whoa, hold on. Never use your big guns \nunless you have to.\nStudent: What do you mean, Guru? Now that I\u2019ve learned design \npatterns, shouldn\u2019t I be using them in all my designs to achieve maximum \npower, flexibility, and manageability?\nGuru: No; patterns are a tool, and a tool that should only be used \nwhen needed. You\u2019ve also spent a lot of time learning design principles.  \nAlways start from your principles and create the simplest code you can \nthat does the job. However, if you see the need for a pattern emerge, \nthen use it.\nStudent: So I shouldn\u2019t build my designs from patterns?\nGuru: That should not be your goal when beginning a design. Let \npatterns emerge naturally as your design progresses. \nStudent: If patterns are so great, why should I be so careful about using \nthem?\nGuru: Patterns can introduce complexity, and we never want complexity \nwhere it is not needed. But patterns are powerful when used where they \nare needed. As you already know, patterns are proven design experience \nthat can be used to avoid common mistakes. They\u2019re also a shared \nvocabulary for communicating our design to others.\nStudent: Well, when do we know it\u2019s okay to introduce design patterns?\nGuru: Introduce a pattern when you are sure it\u2019s necessary to solve a \nproblem in your design, or when you are quite sure that it is needed to \ndeal with a future change in the requirements of your application.\nStudent: I guess my learning is going to continue even though I already \nunderstand a lot of patterns.\nGuru: Yes; learning to manage the complexity and change in software is \na lifelong pursuit. But now that you know a good set of patterns, the time \nhas come to apply them where needed in your design and to continue \nlearning more patterns.\nStudent: Wait a minute, you mean I don\u2019t know them ALL?\nGuru: Student, you\u2019ve learned the fundamental patterns; you\u2019re going to \nfind there are many more, including patterns that just apply to particular \ndomains such as concurrent systems and enterprise systems. But now \nthat you know the basics, you\u2019re in good shape to learn them.\n", "page": 620, "type": "text", "section": "Page 620"}
{"text": "you are here 4\u2003 \u2003 583\nbetter living with patterns\nZen Mind\nBeginner Mind\nIntermediate \nMind\nYour Mind on Patterns\nThe Beginner uses patterns everywhere.  This is good: \nthe beginner gets lots of experience with and practice \nusing patterns.  The beginner also thinks, \u201cThe more \npatterns I use, the better the design.\u201d The beginner will \nlearn this is not so, that all designs should be as simple as \npossible. Complexity and patterns should only be used \nwhere they are needed for practical extensibility.\nAs learning progresses, the Intermediate \nmind starts to see where patterns are needed \nand where they aren\u2019t. The intermediate \nmind still tries to fit too many square patterns \ninto round holes, but also begins to see that  \npatterns can be adapted to fit situations where \nthe canonical pattern doesn\u2019t fit.\nThe Zen mind is able to see patterns where they fit naturally. \nThe Zen mind is not obsessed with using patterns; rather, it \nlooks for simple solutions that best solve the problem. The Zen \nmind thinks in terms of the object principles and their tradeoffs. \nWhen a need for a pattern naturally arises, the Zen mind applies \nit knowing well that it may require adaptation. The Zen mind \nalso sees relationships to similar patterns and understands the \nsubtleties of  differences in the intent of related patterns. The \nZen mind is also a Beginner mind\u2014it doesn\u2019t let all that pattern \nknowledge overly influence design decisions.\n\u201cI need a pattern for Hello World.\u201d\n\u201cMaybe I need a Singleton here.\u201d\n\u201cThis is a natural place for Decorator.\u201d\n", "page": 621, "type": "text", "section": "Page 621"}
{"text": "584\u2003 \u2003 Chapter 13\nwhen not to use patterns\nWARNING: Overuse of design patterns can lead to code that \nis downright overengineered. Always go with the simplest \nsolution that does the job and introduce patterns where the \nneed emerges.\nOf course we want you to use \nDesign Patterns! \nBut we want you to be a good OO designer even \nmore.\nWhen a design solution calls for a pattern, you \nget the benefits of using a solution that has been \ntime-tested by lots of developers. You\u2019re also \nusing a solution that is well documented and that \nother developers are going to recognize (you know, \nthat whole shared vocabulary thing).\nHowever, when you use Design Patterns, there \ncan also be a downside. Design Patterns often \nintroduce additional classes and objects, and so \nthey can increase the complexity of your designs. \nDesign Patterns can also add more layers to your \ndesign, which adds not only complexity, but also \ninefficiency.\nAlso, using a Design Pattern can sometimes be \noutright overkill. Many times you can fall back on \nyour design principles and find a much simpler \nsolution to solve the same problem. If that \nhappens, don\u2019t fight it. Use the simpler solution.\nDon\u2019t let us discourage you, though. When a \nDesign Pattern is the right tool for the job, the \nadvantages are many.\nWait a minute; I\u2019ve \nread this entire book and \nnow you\u2019re telling me NOT to \nuse patterns?\n", "page": 622, "type": "text", "section": "Page 622"}
{"text": "you are here 4\u2003 \u2003 585\nbetter living with patterns\nDon\u2019t forget the power of the \nshared vocabulary\nSo I created this broadcast class. It \nkeeps track of all the objects listening to it \nand any time a new piece of data comes along \nit sends a message to each listener. What\u2019s cool \nis that the listeners can join the broadcast at any \ntime or they can even remove themselves. And the \nbroadcast class itself doesn\u2019t know anything about \nthe listeners; any object that implements the \nright interface can register.\nTime-consuming\nIncomplete\nConfusing\nWe\u2019ve spent so much time in this book discussing OO nuts and bolts that it\u2019s \neasy to forget the human side of Design Patterns\u2014they don\u2019t just help load \nyour brain with solutions, they also give you a shared vocabulary with other \ndevelopers. Don\u2019t underestimate the power of a shared vocabulary, it\u2019s one of \nthe biggest benefits of Design Patterns.\nJust think, something has changed since the last time we talked about shared \nvocabularies; you\u2019ve now started to build up quite a vocabulary of your own!  \nNot to mention, you have also learned a full set of OO design principles from \nwhich you can easily understand the motivation and workings of any new \npatterns you encounter.\nNow that you\u2019ve got the Design Pattern basics down, it\u2019s time for you to \ngo out and spread the word to others. Why? Because when your fellow \ndevelopers know patterns and use a shared vocabulary as well, it leads to \nbetter designs and better communication, and, best of all, it\u2019ll save you a lot \nof time that you can spend on cooler things.\n", "page": 623, "type": "text", "section": "Page 623"}
{"text": "586\u2003 \u2003 Chapter 13\nfive ways to share your vocabulary\nPrecise\nSuccinct\nComplete\nTop five ways to share your vocabulary\n1. In design meetings:  When you meet with your team to discuss \na software design, use design patterns to help stay \u201cin the design\u201d \nlonger. Discussing designs from the perspective of Design Patterns \nand OO principles keeps your team from getting bogged down in \nimplementation details and prevents many misunderstandings.\n2. With other developers:  Use patterns in your discussions \nwith other developers. This helps other developers learn about new \npatterns and builds a community. The best part about sharing what \nyou\u2019ve learned is that great feeling when someone else \u201cgets it\u201d!\n3. In architecture documentation:  When you write \narchitectural documentation, using patterns will reduce the amount \nof documentation you need to write and gives the reader a clearer \npicture of the design. \n4. In code comments and naming conventions:  When \nyou\u2019re writing code, clearly identify the patterns you\u2019re using in \ncomments. Also, choose class and method names that reveal any \npatterns underneath. Other developers who have to read your \ncode will thank you for allowing them to quickly understand your \nimplementation.\n5. To groups of interested developers: Share your knowledge. \nMany developers have heard about patterns but don\u2019t have a good \nunderstanding of what they are. Volunteer to give a brown-bag lunch \non patterns or a talk at your local user group.\nObserver\n", "page": 624, "type": "text", "section": "Page 624"}
{"text": "you are here 4\u2003 \u2003 587\nbetter living with patterns\nErich Gamma\nCruisin\u2019 Objectville with the \nGang of Four\nYou won\u2019t find the Jets or Sharks hanging around Objectville, but \nyou will find the Gang of Four. As you\u2019ve probably noticed, you \ncan\u2019t get far in the World of Patterns without running into them. \nSo, who is this mysterious gang?\nPut simply, \u201cthe GoF,\u201d which includes Erich Gamma, Richard \nHelm, Ralph Johnson, and John Vlissides, is the group of guys who \nput together the first patterns catalog and in the process, started an \nentire movement in the software field!\nHow did they get that name? No one knows for sure; it\u2019s just a \nname that stuck. But think about it: if you\u2019re going to have a \u201cgang \nelement\u201d running around Objectville, could you think of a nicer \nbunch of guys? In fact, they\u2019ve even agreed to pay us a visit...\nObjectville Patterns Tour\nThe GoF launched the software \npatterns movement, but many others \nhave made significant contributions, \nincluding Ward Cunningham, Kent \nBeck, Jim Coplien, Grady Booch, Bruce \nAnderson, Richard Gabriel, Doug Lea, \nPeter Coad, and Doug Schmidt, to \nname just a few.\nGo for simplicity \nand don\u2019t become overexcited. \n \nIf you can come up with a \nsimpler solution without using a \npattern, then go for it.\nJohn Vlissides*\nRichard \nHelm\nRalph \nJohnson\nToday \nthere are more \npatterns than in the \nGoF book; learn about \nthem as well.\nShoot for practical \nextensibility. Don\u2019t \nprovide hypothetical\ngenerality; be extensible \nin ways that matter.\nPatterns are tools, not \nrules\u2014they need to be \ntweaked and adapted to\nyour problem.\n*John Vlissides passed away in 2005. A great loss to the Design Patterns community.\n", "page": 625, "type": "text", "section": "Page 625"}
{"text": "588\u2003 \u2003 Chapter 13\npatterns resources\nYour journey has just begun...\nThe authors of Design Patterns are \naffectionately known as the \u201cGang of Four,\u201d \nor GoF for short. \nNow that you\u2019re on top of Design Patterns and ready to dig deeper, we\u2019ve got three definitive \ntexts that you need to add to your bookshelf...\nThis is the book that kicked off the entire field of Design \nPatterns when it was released in 1995. You\u2019ll find all the \nfundamental patterns here. In fact, this book is the basis for \nthe set of patterns we used in Head First Design Patterns.\nYou won\u2019t find this book to be the last word on Design \nPatterns\u2014the field has grown substantially since its \npublication\u2014but it is the first and most definitive. \nPicking up a copy of Design Patterns is a great way to start \nexploring patterns after Head First.\nPatterns didn\u2019t start with the GoF; they started \nwith Christopher Alexander, a professor of \narchitecture at Berkeley\u2014that\u2019s right, Alexander \nis an architect, not a computer scientist. Alexander \ninvented patterns for building living architectures \n(like houses, towns, and cities).\nThe next time you\u2019re in the mood for some deep, \nengaging reading, pick up The Timeless Way of \nBuilding and A Pattern Language. You\u2019ll see the true \nbeginnings of Design Patterns and recognize \nthe direct analogies between creating \u201cliving \narchitecture\u201d and flexible, extensible software. \nSo grab a cup of Starbuzz coffee, sit back, and \nenjoy...\nThe definitive Design Patterns text\nThe definitive Patterns texts\nChristopher Alexander invented \npatterns, which inspired applying similar \nsolutions to software.\n", "page": 626, "type": "text", "section": "Page 626"}
{"text": "you are here 4\u2003 \u2003 589\nbetter living with patterns\nOther Design Patterns resources\nWebsites\nThe Portland Patterns Repository, run by Ward \nCunningham, is a wiki devoted to all things related to \npatterns. You\u2019ll find threads of discussion on every topic \nyou can think of related to patterns and OO systems.\nc2.com/cgi/wiki?WelcomeVisitors\nThe Hillside Group fosters common programming \nand design practices and provides a central resource for \npatterns work. The site includes information on many \npatterns-related resources such as articles, books, mailing \nlists, and tools. \nhillside.net\nO\u2019Reilly Online Learning provides online design \npatterns books, courses, and live teaching. You\u2019ll also find \na design patterns bootcamp course based on this book.\noreilly.com\nYou\u2019re going to find there is a vibrant, friendly community of patterns \nusers and writers out there and they\u2019re glad to have you join them. \nHere are a few resources to get you started...\nConferences and Workshops\nIf you\u2019d like to interact with the patterns \ncommunity, be sure to check out the many \npatterns-related conferences and workshops. The \nHillside site maintains a complete list. Check out \nPattern Languages of Programs (PLoP) and the \nACM Conference on Object-Oriented Systems, \nLanguages and Applications (OOPSLA), which is \nnow part of the SPLASH conference.\nOther Resources\nWe\u2019d be remiss if we didn\u2019t mention Google, Stack Overflow, Quora, and many other sites \nand services as good places to ask questions, find answers, and discuss design patterns. As \nwith anything on the web, always double-check the information you receive.\n", "page": 627, "type": "text", "section": "Page 627"}
{"text": "590\u2003 \u2003 Chapter 13\npatterns zoo\nThe Patterns Zoo\nArchitectural Patterns are \nused to create the living, \nvibrant architecture of \nbuildings, towns, and cities.  \nThis is where patterns got \ntheir start.\nApplication Patterns are \npatterns for creating \nsystem-level architecture. \nMany multitier \narchitectures fall into this \ncategory.\nHabitat: found in buildings you \nlike to live in, look at and visit.\nAs you\u2019ve just seen, patterns didn\u2019t start with software; they started \nwith the architecture of buildings and towns. In fact, the patterns \nconcept can be applied in many different domains. Take a walk \naround the Patterns Zoo to see a few...\nHabitat: seen hanging around \nthree-tier architectures, client-\nserver systems and the web.\nField note: MVC has been \nknown to pass for an \napplication pattern.\nDomain-Specific Patterns \nare patterns that concern \nproblems in specific domains, \nlike concurrent systems or \nreal-time systems.\nHelp find a habitat\nEnterprise Computing\n", "page": 628, "type": "text", "section": "Page 628"}
{"text": "you are here 4\u2003 \u2003 591\nbetter living with patterns\nBusiness Process Patterns \ndescribe the interaction \nbetween businesses, customers, \nand data, and can be applied \nto problems such as how \nto effectively make and \ncommunicate decisions.\nOrganizational Patterns \ndescribe the structures \nand practices of human \norganizations. Most \nefforts to date have \nfocused on organizations \nthat produce and/or \nsupport software. \nUser Interface \nDesign Patterns \naddress the \nproblems of how to \ndesign interactive \nsoftware programs.\nSeen hanging around corporate \nboardrooms and project \nmanagement meetings.\nField notes: please add your observations of pattern domains here:\nHabitat: seen in the vicinity \nof video game designers, GUI \nbuilders, and producers.\nHelp find a habitat\nDevelopment team\nCustomer support team\n", "page": 629, "type": "text", "section": "Page 629"}
{"text": "592\u2003 \u2003 Chapter 13\nanti-patterns\nAnnihilating evil with Anti-Patterns\nThe Universe just wouldn\u2019t be complete if we had patterns and no \nanti-patterns, now would it? \nIf a Design Pattern gives you a general solution to a recurring \nproblem in a particular context, then what does an anti-pattern \ngive you?\nAn anti-pattern always \nlooks like a good solution, \nbut then turns out to be \na bad solution when it \nis applied.\nBy documenting anti-\npatterns we help \nothers to recognize bad \nsolutions before they \nimplement them.\nLike patterns, there \nare many types \nof anti-patterns \nincluding development, \nOO, organizational, \nand domain-specific         \nanti-patterns.\nAn Anti-Pattern tells you how to go from a problem \nto a BAD solution.\nYou\u2019re probably asking yourself, \u201cWhy on earth would anyone \nwaste their time documenting bad solutions?\u201d\nThink about it like this: if there is a recurring bad solution to a \ncommon problem, then by documenting it we can prevent other \ndevelopers from making the same mistake. After all, avoiding bad \nsolutions can be just as valuable as finding good ones!\nLet\u2019s look at the elements of an anti-pattern:\nAn anti-pattern tells you why a bad solution is \nattractive. Let\u2019s face it, no one would choose a bad solution if \nthere wasn\u2019t something about it that seemed attractive up front. \nOne of the biggest jobs of the anti-pattern is to alert you to the \nseductive aspect of the solution.\nAn anti-pattern tells you why that solution in the long \nterm is bad. In order to understand why it\u2019s an anti-pattern, \nyou\u2019ve got to understand how it\u2019s going to have a negative effect \ndown the road. The anti-pattern describes where you\u2019ll get into \ntrouble using the solution.\nAn anti-pattern suggests other applicable patterns that \nmay provide good solutions. To be truly helpful, an anti-\npattern needs to point you in the right direction; it should suggest \nother possibilities that may lead to good solutions.\nLet\u2019s have a look at an anti-pattern.\n", "page": 630, "type": "text", "section": "Page 630"}
{"text": "you are here 4\u2003 \u2003 593\nbetter living with patterns\nAnti-Pattern\nName: Golden Hammer \nProblem: You need to choose technologies \nfor your development and you believe that \nexactly one technology must dominate the \narchitecture. \nContext: You need to develop some new \nsystem or piece of software that doesn\u2019t \nfit well with the technology that the \ndevelopment team is familiar with.\nForces:\n\u2022 The development team is committed \nto the technology they know.\n\u2022 The development team is not familiar \nwith other technologies.\n\u2022 Unfamiliar technologies are seen as \nrisky.\n\u2022 It is easy to plan and estimate for \ndevelopment using the familiar \ntechnology.\nSupposed solution: Use the familiar \ntechnology anyway. The technology is applied \nobsessively to many problems, including \nplaces where it is clearly inappropriate. \nRefactored solution: Expand the knowledge \nof developers through education, training, and \nbook study groups that expose developers to \nnew solutions.\nExamples: \nWeb companies keep using and maintaining \ntheir internal homegrown caching systems \nwhen open source alternatives are in use.\nAdapted from the Portland Pattern Repository\u2019s wiki \nat https://wiki.c2.com/?WelcomeVisitors where you\u2019ll \nfind many anti-patterns and discussions.\nThe bad, yet attractive, solution.\nT\nells you why \nthe solution is \nattractive.\nHow to get to a \ngood solution.\nThe problem and context, \njust like a Design Pattern \ndescription.\nJust like a Design Pattern, \nan anti-pattern has a name \nso we can create a shared \nvocabulary.\nHere\u2019s an example of a software development anti-pattern.\nExample of where this anti-pattern \nhas been observed.\n", "page": 631, "type": "text", "section": "Page 631"}
{"text": "594\u2003 \u2003 Chapter 13\nyour design toolbox\nTools for your Design Toolbox\nYou\u2019ve reached that point where you\u2019ve outgrown us. Now\u2019s the \ntime to go out in the world and explore patterns on your own...\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable.  Strategy lets the algorithm \nvary independently from clients that use it.\nOO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically.  \nDecorators provide a flexible \nalternative to subclassing for extending \nfunctionality.\nAbstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes.\nskip\nSingleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it.\nCommand - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nAdapter - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nFacade - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations.\nThe time has come \nfor you to go out and \ndiscover more patterns \non your own. There are \nmany domain-specific \npatterns we haven\u2019t even \nmentioned and there are \nalso some foundational \nones we didn\u2019t cover. \nYou\u2019ve also got patterns \nof your own to create.\nState - Allow an object to alter its \nbehavior when its internal state changes. \n \nThe object will appear to change its \nclass.\nProxy - Provide a surrogate or \nplaceholder for another object to \ncontrol access to it.\nA Compound Pattern combines two or \nmore patterns into a solution that \nsolves a recurring or general problem.\nCompound Patterns\n____________________\n____________________\n_____________________\nYour Patterns Here!\nCheck out the \nAppendix; we\u2019ll \ngive you a heads \nup on some more \nfoundational \npatterns you\u2019ll \nprobably want to \nhave a look at.\nEncapsulate what varies.\nFavor composition over inheritance.\nProgram to interfaces, not \nimplementations.\nStrive for loosely coupled designs \nbetween objects that interact.\nClasses should be open for extension but \nclosed for modification.\nDepend on abstractions. Do not depend \non concrete classes.\nOnly talk to your friends.\nDon\u2019t call us, we\u2019ll call you.\nA class should have only one reason to change.\nOO Principles\n\t\n\u0083\nLet Design Patterns emerge \nin your designs; don\u2019t force \nthem in just for the sake of \nusing a pattern.\n\t\n\u0083\nDesign Patterns aren\u2019t set in \nstone; adapt and tweak them \nto meet your needs.\n\t\n\u0083\nAlways use the simplest \nsolution that meets your \nneeds, even if it doesn\u2019t \ninclude a pattern.\n\t\n\u0083\nStudy Design Patterns \ncatalogs to familiarize \nyourself with patterns and the \nrelationships among them.\n\t\n\u0083\nPattern classifications (or \ncategories) provide groupings \nfor patterns. When they help, \nuse them.\n\t\n\u0083\nYou need to be committed to \nbe a patterns writer: it takes \ntime and patience, and you \nhave to be willing to do lots of \nrefinement.\n\t\n\u0083\nRemember, most patterns you \nencounter will be adaptations \nof existing patterns, not new \npatterns.\n\t\n\u0083\nBuild your team\u2019s shared \nvocabulary. This is one of \nthe most powerful benefits of \nusing patterns.\n\t\n\u0083\nLike any community, the \npatterns community has its \nown lingo. Don\u2019t let that hold \nyou back. Having read this \nbook, you now know most \nof it.\n", "page": 632, "type": "text", "section": "Page 632"}
{"text": "you are here 4\u2003 \u2003 595\nbetter living with patterns\nWe\u2019re going to miss you, for sure. But don\u2019t worry\u2014before you know it, the \nnext Head First book will be out and you can visit again. What\u2019s the next \nbook, you ask? Hmmm, good question! Why don\u2019t you help us decide?  \nSend email to booksuggestions@wickedlysmart.com.\nBoy, it\u2019s been great having you in Objectville.\nLeaving Objectville...\n", "page": 633, "type": "text", "section": "Page 633"}
{"text": "596\u2003 \u2003 Chapter 13\nexercise solutions\nMatch each pattern with its description:\nPattern\nDescription\nWraps an object and provides a different \ninterface to it.\nSubclasses decide how to implement steps in an \nalgorithm.\nSubclasses decide which concrete classes to \ncreate.\nEnsures one and only one object is created.\nEncapsulates interchangeable behaviors and uses \ndelegation to decide which one to use.\nClients treat collections of objects and individual \nobjects uniformly.\nEncapsulates state-based behaviors and uses \ndelegation to switch between behaviors.\nProvides a way to traverse a collection of objects \nwithout exposing its implementation.\nSimplifies the interface of a set of classes.\nWraps an object to provide new behavior.\nAllows a client to create families of objects \nwithout specifying their concrete classes.\nAllows objects to be notified when state changes.\nWraps an object to control access to it.\nEncapsulates a request as an object.\nDecorator\nState\nIterator\nFacade\nStrategy\nProxy\nFactory Method\nAdapter\nObserver\nTemplate Method\nComposite\nSingleton\nAbstract Factory\nCommand\nSOlUTion\n", "page": 634, "type": "text", "section": "Page 634"}
{"text": "this is a new chapter\u2003 \u2003 597\nNot everyone can be the most popular. A lot has changed \nin the last 25+ years. Since Design Patterns: Elements of Reusable Object-\nOriented Software first came out, developers have applied these patterns \nthousands of times. The patterns we summarize in this appendix are full-\nfledged, card-carrying, official GoF patterns, but aren\u2019t used as often as the \npatterns we\u2019ve explored so far. But these patterns are awesome in their own \nright, and if your situation calls for them, you should apply them with your \nhead held high. Our goal in this appendix is to give you a high-level idea of \nwhat these patterns are all about. \n14  Appendix\nLeftover Patterns\n", "page": 635, "type": "text", "section": "Page 635"}
{"text": "598\u2003 \u2003 Appendix\nbridge pattern\nBridge\nUse the Bridge Pattern to vary not only your \nimplementations, but also your abstractions.\nImagine you\u2019re writing the code for a new \nergonomic and user-friendly remote control for \nTVs. You already know that you\u2019ve got to use \ngood object-oriented techniques because while \nthe remote is based on the same abstraction, there \nwill be lots of implementations\u2014one for each model \nof TV\n.\nA scenario\nYour dilemma\nYou know that the remote\u2019s user interface won\u2019t be right the \nfirst time. In fact, you expect that the product will be refined \nmany times as usability data is collected on the remote \ncontrol.\nSo your dilemma is that the remotes are going to change and \nthe TVs are going to change. You\u2019ve already abstracted the user \ninterface so that you can vary the implementation over the many \nTVs your customers will own. But you are also going to need \nto vary the abstraction because it is going to change over time as \nthe remote is improved based on the user feedback.\nSo how are you going to create an object-oriented design that \nallows you to vary the implementation and the abstraction?\nEvery remote has the \nsame abstraction.\nRemoteControl\non()\noff()\nsetChannel()\n// more methods\nLots of \nimplementations, \none for each TV.\nSonyControl\non()\noff()\nsetChannel()\n// more methods\nRCAControl\non()\noff()\nsetChannel()\n// more methods\nThis is an abstraction. It could be \nan interface or an abstract class.\n{\n  tuneChannel(channel);\n}\nUsing this design we can vary \nonly the TV implementation, not \nthe user interface.\n", "page": 636, "type": "text", "section": "Page 636"}
{"text": "you are here 4\u2003 \u2003 599\nleftover patterns\nBridge Benefits\n\u0083\t\nDecouples an implementation so that it is not bound \npermanently to an interface.\n\u0083\t\nAbstraction and implementation can be extended \nindependently.\n\u0083\t\nChanges to the concrete abstraction classes don\u2019t \naffect the client. \n\u0083\t\nUseful in graphics and windowing systems that need \nto run over multiple platforms.\n\u0083\t\nUseful any time you need to vary an interface and an \nimplementation in different ways.\n\u0083\t\nIncreases complexity. \nBridge Uses and Drawbacks \nWhy use the Bridge Pattern?\nThe Bridge Pattern allows you to vary the implementation and \nthe abstraction by placing the two in separate class hierarchies.\nTV\non()\noff()\ntuneChannel()\n// more methods\nSony\non()\noff()\ntuneChannel()\n// more methods\nRCA\non()\noff()\ntuneChannel()\n// more methods\nConcreteRemote\non()\noff()\nsetChannel()\nnextChannel()\npreviousChannel()\n// more methods\nRemoteControl\nimplementor\non()\noff()\nsetChannel()\n// more methods\nHas-A\nimplementor.tuneChannel(channel);\nAbstraction \nclass hierarchy.\nImplementation class hierarchy.\nThe relationship between \nthe two is referred to as \nthe \u201cbridge.\u201d\nAll methods in the abstraction \nare implemented in terms of \nthe implementation.\nsetChannel(currentStation + 1);\ncurrentStation\nConcrete subclasses are implemented in terms of the \nabstraction, not the implementation.\nNow you have two hierarchies, one for the remotes and a separate one for platform-\nspecific TV implementations. The bridge allows you to vary either side of the two \nhierarchies independently.\n", "page": 637, "type": "text", "section": "Page 637"}
{"text": "600\u2003 \u2003 Appendix\nbuilder pattern\nBuilder\nUse the Builder Pattern to encapsulate the construction of \na product and allow it to be constructed in steps.\nYou\u2019ve just been asked to build a vacation planner for Patternsland, a new theme \npark just outside of Objectville. Park guests can choose a hotel and various types of \nadmission tickets, make restaurant reservations, and even book special events. To create \na vacation planner, you need to be able to create structures like this:\nA scenario\nYou need a flexible design\nEach guest\u2019s planner can vary in the number of days and types of activities it includes.  \nFor instance, a local resident might not need a hotel, but wants to make dinner and \nspecial event reservations. Another guest might be flying into Objectville and needs a \nhotel, dinner reservations, and admission tickets.\nSo, you need a flexible data structure that can represent guest planners and all their \nvariations; you also need to follow a sequence of potentially complex steps to create the \nplanner. How can you provide a way to create the complex structure without mixing it \nwith the steps for creating it?\nEach day can have any combination \nof hotel reservations, tickets, \nmeals, and special events.\nEach vacation is planned \nover some number of days.\n \n \n \n \n \nV\na\nc\na\nt\ni\no\nn\n \n \n \n \n \n \n \n \n \nD\na\nyO\nn\ne\n \n \n \n \n \n \n \nD\na\ny\nTw\no\n \n \n \n \n \n \nD\na\ny\nT\nh\nr\ne\ne\n \n \n \n \n \n \n \n \nD\ni\nn\ni\nn\ng\n \n \n \n \nS\np\ne\nc\ni\na\nl E\nv\ne\nn\nt\n \n \n \nP\na\nr\nk\n \nT\ni\nck\ne\nts\n \n \n \nP\na\nr\nk\n \nT\ni\nck\ne\nts\n \n \n \nP\na\nr\nk\n \nT\ni\nck\ne\nts\n \n \n \n \n \n \n \n \nH\no\nt\nel\n \n \n \n \n \n \n \n \nH\no\nt\nel\n \n \n \n \n \n \n \n \n \nD\ni\nn\nn\ne\nr\nP\na\nt\nt\ne\nr\nn\ns\n \no\nn\n \nI\nc\ne\n \n \n \n \n \n \n \n \nH\no\nt\nel\n \n \n \n \n \n \n \n \nD\ni\nn\ni\nn\ng\n \n \n \n \n \n \n \n \n \nD\ni\nn\nn\ne\nr\n \n \n \n \nS\np\ne\nc\ni\na\nl E\nv\ne\nn\nt\nC\ni\nr\nq\nu\ne\n \nD\nu\n \nP\na\ntt\ne\nr\nns\n", "page": 638, "type": "text", "section": "Page 638"}
{"text": "you are here 4\u2003 \u2003 601\nleftover patterns\nBuilder Benefits\n\u0083\t\nEncapsulates the way a complex object is \nconstructed.\n\u0083\t\nAllows objects to be constructed in a multistep and \nvarying process (as opposed to one-step factories).\n\u0083\t\nHides the internal representation of the product from \nthe client. \n\u0083\t\nProduct implementations can be swapped in and out \nbecause the client only sees an abstract interface.\nBuilder Uses and Drawbacks \nWhy use the Builder Pattern?\nRemember Iterator? We encapsulated the iteration into a separate \nobject and hid the internal representation of the collection from the \nclient. It\u2019s the same idea here: we encapsulate the creation of the \ntrip planner in an object (let\u2019s call it a builder), and have our client \nask the builder to construct the trip planner structure for it.  \nThe Client directs \nthe builder to \nconstruct the \nplanner.\nAbstractBuilder\nbuildDay()\naddHotel()\naddReservation()\naddSpecialEvent()\naddTickets()\ngetVacationPlanner()\nClient\nbuilder.buildDay(date);\nbuilder.addHotel(date, \"Grand Facadian\");\nbuilder.addTickets(\"Patterns on Ice\");\n  // plan rest of vacation \nPlanner yourPlanner = \n        builder.getVacationPlanner();\nThe client uses an \nabstract interface to \nbuild the planner.\nThe concrete builder \ncreates real products \nand stores them in \nthe vacation composite \nstructure.\nThe Client directs the builder to create \nthe planner in a number of steps and \nthen calls the getVacationPlanner() \nmethod to retrieve the complete object.\nVacationBuilder\nvacation\nbuildDay()\naddHotel()\naddReservation()\naddSpecialEvent()\naddTickets()\ngetVacationPlanner()\nbuilder\nconstructPlanner()\n\u0083\t\nOften used for building composite structures.\n\u0083\t\nConstructing objects requires more domain \nknowledge of the client than when using a Factory.\n", "page": 639, "type": "text", "section": "Page 639"}
{"text": "602\u2003 \u2003 Appendix\nchain of responsibility pattern\nChain of Responsibility\nUse the Chain of Responsibility Pattern when you want to \ngive more than one object a chance to handle a request.\nMighty Gumball has been getting more email \nthan they can handle since the release of the \nJava-powered Gumball Machine. From their \nown analysis they get four kinds of email: fan \nmail from customers that love the new 1-in-10 \ngame, complaints from parents whose kids are \naddicted to the game, requests to put machines \nin new locations, and a fair amount of spam. \nAll fan mail should go straight to the CEO, all \ncomplaints should go to the legal department, \nand all requests for new machines should go to \nbusiness development. Spam should be deleted.\nA scenario\nYour task\nMighty Gumball has already written some AI \ndetectors that can tell if an email is spam, fan \nmail, a complaint, or a request, but they need \nyou to create a design that can use the detectors \nto handle incoming email.\nYou\u2019ve got to help us \ndeal with the flood of email we\u2019re \ngetting since the release of the \nJava Gumball Machine.\n", "page": 640, "type": "text", "section": "Page 640"}
{"text": "you are here 4\u2003 \u2003 603\nleftover patterns\n Chain of Responsibility Benefits\n\u0083\t\nDecouples the sender of the request and its \nreceivers.\n\u0083\t\nSimplifies your object because it doesn\u2019t have \nto know the chain\u2019s structure and keep direct \nreferences to its members.\n\u0083\t\nAllows you to add or remove responsibilities \ndynamically by changing the members or order of \nthe chain. \n\u0083\t\nCommonly used in Windows systems to handle \nevents like mouse clicks and keyboard events.\n\u0083\t\nExecution of the request isn\u2019t guaranteed; it may \nfall off the end of the chain if no object handles it \n(this can be an advantage or a disadvantage).\n\u0083\t\nCan be hard to observe and debug at runtime.\nChain of Responsibility Uses and Drawbacks \nHow to use the Chain of Responsibility Pattern\nWith the Chain of Responsibility Pattern, you create a chain of objects \nto examine requests. Each object in turn examines a request and either \nhandles it or passes it on to the next object in the chain.  \nHandler\nSpamHandler\nFanHandler\nComplaintHandler\nNewLocHandler\nSpam \nHandler\nFan     \nHandler\nComplaint \nHandler\nNewLoc  \nHandler\nEach object in the chain \nacts as a handler and has \na successor object. If it \ncan handle the request, \nit does; otherwise, it \nforwards the request to \nits successor.\nAs email is received, it is passed to the first handler: \nSpamHandler. If the SpamHandler can\u2019t handle the request, it \nis passed on to the FanHandler. And so on...\nEach email is passed to \nthe first handler.\nEmail is not handled if it \nfalls off the end of the \nchain\u2009\u2014\u2009although you can always \nimplement a catch-all handler.\nsuccessor\nhandleRequest()\nhandleRequest()\nhandleRequest()\nhandleRequest()\nhandleRequest()\n", "page": 641, "type": "text", "section": "Page 641"}
{"text": "604\u2003 \u2003 Appendix\nflyweight pattern\nFlyweight\nUse the Flyweight Pattern when one instance of a class \ncan be used to provide many virtual instances.\nYou want to add trees as objects in your new landscape design application. In your \napplication, trees don\u2019t really do very much; they have an X-Y location, and they can \ndraw themselves dynamically, depending on how old they are. The thing is, a user \nmight want to have lots and lots of trees in one of their home landscape designs. It \nmight look something like this:\nA scenario\nYour big client\u2019s dilemma\nYou have a key client you\u2019ve been pitching for months. \nThey\u2019re going to buy 1,000 seats of your application, and \nthey\u2019re using your software to do the landscape design for \nhuge planned communities. After using your software for a \nweek, your client is complaining that when they create large \ngroves of trees, the app starts getting sluggish...\nTree\nTree\nTree\nTree\nTree\nTree\nTree\nHouse\nEach Tree instance \nmaintains its own state.\nTree\nxCoord\nyCoord\nage\ndisplay()  {\n  // use X-Y coords\n  // & complex age\n  // related calcs\n}\n", "page": 642, "type": "text", "section": "Page 642"}
{"text": "you are here 4\u2003 \u2003 605\nleftover patterns\n Flyweight Benefits\n\u0083\t\nReduces the number of object instances at runtime, \nsaving memory.\n\u0083\t\nCentralizes state for many \u201cvirtual\u201d objects into a \nsingle location.\n\u0083\t\nThe Flyweight is used when a class has many \ninstances, and they can all be controlled identically. \n\u0083\t\nA drawback of the Flyweight Pattern is that once \nyou\u2019ve implemented it, single, logical instances of the \nclass will not be able to behave independently from \nthe other instances.\n Flyweight Uses and Drawbacks \nWhy use the Flyweight Pattern?\nWhat if, instead of having thousands of Tree objects, you \ncould redesign your system so that you\u2019ve got only one \ninstance of Tree, and a client object that maintains the state \nof ALL your trees? That\u2019s the Flyweight!\nOne, single, state-free \nTree object.\nAll the state, for ALL \nof your virtual Tree \nobjects, is stored in this \n2D array.\nTreeManager\ntreeArray\ndisplayTrees() {\n  // for all trees {\n    // get array row\n    display(x, y, age);\n   }\n}\nTree\ndisplay(x, y, age) {\n  // use X-Y coords\n  // & complex age\n  // related calcs\n}\n", "page": 643, "type": "text", "section": "Page 643"}
{"text": "606\u2003 \u2003 Appendix\ninterpreter pattern\nexpression ::=  <command> | <sequence> | <repetition>\nsequence ::= <expression> ';' <expression>\ncommand ::= right | quack | fly\nrepetition ::= while '(' <variable> ')'<expression>\nvariable ::= [A-Z,a-z]+\nInterpreter\nUse the Interpreter Pattern to build an \ninterpreter for a language.\nRemember the Duck Simulator? You have a hunch it would also \nmake a great educational tool for children to learn programming. \nUsing the simulator, each child gets to control one duck with a \nsimple language. Here\u2019s an example of the language:\nA scenario\nNow what?\nYou\u2019ve got a grammar; now all you need is a way to represent and \ninterpret sentences in the grammar so that the students can see the \neffects of their programming on the simulated ducks.\nNow, remembering how to create grammars from one of your old \nintroductory programming classes, you write out the grammar:\nTurn the duck right.\nFly all day...\n...and then quack.\nA program is an expression consisting \nof sequences of commands and \nrepetitions (\u201cwhile\u201d statements).\nA while statement is just \na conditional variable and \nan expression.\nright;\nwhile (daylight) fly;\nquack;\nA sequence is a set of \nexpressions separated \nby semicolons.\nWe have three \ncommands: right, \nquack, and fly.\n\t\n\t\nThe Interpreter \nPattern requires \nsome knowledge of \nformal grammars.\nIf you\u2019ve never studied formal grammars, \ngo ahead and read through the pattern; \nyou\u2019ll still get the gist of it.\n", "page": 644, "type": "text", "section": "Page 644"}
{"text": "you are here 4\u2003 \u2003 607\nleftover patterns\n Interpreter Benefits\n\u0083\t\nRepresenting each grammar rule in a class makes \nthe language easy to implement.\n\u0083\t\nBecause the grammar is represented by classes, you \ncan easily change or extend the language.\n\u0083\t\nBy adding methods to the class structure, you can \nadd new behaviors beyond interpretation, like pretty \nprinting and more sophisticated program validation.\n\u0083\t\nUse Interpreter when you need to implement a \nsimple language.\n\u0083\t\nAppropriate when you have a simple grammar and \nsimplicity is more important than efficiency.\n\u0083\t\nUsed for scripting and programming languages.\n\u0083\t\nThis pattern can become cumbersome when \nthe number of grammar rules is large. In these \ncases a parser/compiler generator may be more \nappropriate.\n Interpreter Uses and Drawbacks \nHow to implement an interpreter\nWhen you need to implement a simple language, the  \nInterpreter Pattern defines a class-based representation for its \ngrammar along with an interpreter to interpret its sentences. \nTo represent the language, you use a class to represent each \nrule in the language. Here\u2019s the duck language translated into \nclasses. Notice the direct mapping to the grammar. \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nTo interpret the language, call the interpret() method on each \nexpression type. This method is passed a context\u2014which \ncontains the input stream of the program we\u2019re parsing\u2014and \nmatches the input and evaluates it.\nExpression\ninterpret(context)\nSequence\nRepetition\nFlyCommand\ninterpret(context)\nVariable\nRightCommand\nQuackCommand\ninterpret(context)\ninterpret(context)\ninterpret(context)\ninterpret(context)\nexpression1\nexpression2\nvariable\nexpression\ninterpret(context)\n", "page": 645, "type": "text", "section": "Page 645"}
{"text": "608\u2003 \u2003 Appendix\nmediator pattern\nMediator\nUse the Mediator Pattern to centralize complex \ncommunications and control between related objects.\nCalendar\nBob has an automated home, thanks to the good folks at HouseOfTheFuture. All of \nhis appliances are designed to make his life easier. When Bob stops hitting the snooze \nbutton, his alarm clock tells the coffee maker to start brewing. Even though life is good \nfor Bob, he and other customers are always asking for lots of new features: No coffee \non the weekends...  Turn off the sprinkler 15 minutes before a shower is scheduled...  \nSet the alarm early on trash days... \nA scenario\nSprinkler\nCoffeePot\nAlarm\nHouseOfTheFuture\u2019s dilemma\nIt\u2019s getting really hard to keep track of which rules reside in which objects, and how \nthe various objects should relate to each other.\nAlarm\nonEvent() {\n  checkCalendar()\n  checkSprinkler()\n  startCoffee()\n  // do more stuff\n}\nCalendar\nonEvent() {\n  checkDayOfWeek()\n  doSprinkler()\n  doCoffee()\n  doAlarm()\n  // do more stuff\n}\nCoffeePot\nonEvent() {\n  checkCalendar()\n  checkAlarm()\n  // do more stuff\n}\nSprinkler\nonEvent() {\n  checkCalendar()\n  checkShower()\n  checkTemp()\n  checkWeather()\n  // do more stuff\n}\n", "page": 646, "type": "text", "section": "Page 646"}
{"text": "you are here 4\u2003 \u2003 609\nleftover patterns\n Mediator Benefits\n\u0083\t\nIncreases the reusability of the objects supported by \nthe Mediator by decoupling them from the system.\n\u0083\t\nSimplifies maintenance of the system by centralizing \ncontrol logic.\n\u0083\t\nSimplifies and reduces the variety of messages sent \nbetween objects in the system.\n\u0083\t\nThe Mediator is commonly used to coordinate \nrelated GUI components.\n\u0083\t\nA drawback of the Mediator Pattern is that without \nproper design, the Mediator object itself can become \noverly complex.\n Mediator Uses and Drawbacks \nMediator\nCalendar\nSprinkler\nCoffeePot\nAlarm\nMediator in action...\nWith a Mediator added to the system, all \nof the appliance objects can be greatly \nsimplified:\n  \n\u0083 They tell the Mediator when their state \nchanges.\n  \n\u0083 They respond to requests from the \nMediator.\nBefore we added the Mediator, all of the \nappliance objects needed to know about each \nother; that is, they were all tightly coupled. \nWith the Mediator in place, the appliance \nobjects are all completely decoupled from \neach other.\nThe Mediator contains all of the control \nlogic for the entire system. When an existing \nappliance needs a new rule, or a new \nappliance is added to the system, you\u2019ll know \nthat all of the necessary logic will be added to \nthe Mediator.\nMediator \nif(alarmEvent){\n checkCalendar()\n checkShower()\n checkTemp()\n}\nif(weekend) {\n checkWeather()\n // do more stuff\n}\nif(trashDay) {\n resetAlarm()\n // do more stuff\n}\nIt\u2019s such a relief, \nnot having to figure \nout that Alarm clock\u2019s \npicky rules!\n", "page": 647, "type": "text", "section": "Page 647"}
{"text": "610\u2003 \u2003 Appendix\nmemento pattern\n \nMemento\nUse the Memento Pattern when you need \nto be able to return an object to one of its \nprevious states; for instance, if your user \nrequests an \u201cundo.\u201d\nYour interactive role-playing game is hugely successful, \nand has created a legion of addicts, all trying to get \nto the fabled \u201clevel 13.\u201d As users progress to more \nchallenging game levels, the odds of encountering \na game-ending situation increase. Fans who have \nspent days progressing to an advanced level are \nunderstandably miffed when their character gets snuffed, \nand they have to start all over. The cry goes out for a \n\u201csave progress\u201d command, so that players can store their \ngame progress and at least recover most of their efforts \nwhen their character is unfairly extinguished. The \n\u201csave progress\u201d function needs to be designed to return \na resurrected player to the last level she completed \nsuccessfully.\nA scenario\nJust be careful how you go about \nsaving the game state. It\u2019s pretty \ncomplicated, and I don\u2019t want anyone \nelse with access to it mucking it up and \nbreaking my code. \n", "page": 648, "type": "text", "section": "Page 648"}
{"text": "you are here 4\u2003 \u2003 611\nleftover patterns\nThe Memento at work\nThe Memento has two goals:\n \n\u0083 Saving the important state of a system\u2019s key object\n \n\u0083 Maintaining the key object\u2019s encapsulation\nKeeping the Single Responsibility Principle in mind, it\u2019s also \na good idea to keep the state that you\u2019re saving separate from \nthe key object. This separate object that holds the state is \nknown as the Memento object.\n Memento Benefits\n\u0083\t\nKeeping the saved state external from the key \nobject helps to maintain cohesion.\n\u0083\t\nKeeps the key object\u2019s data encapsulated.\n\u0083\t\nProvides easy-to-implement recovery capability.\n\u0083\t\nThe Memento is used to save state.\n\u0083\t\nA drawback to using Memento is that saving and \nrestoring state can be time-consuming.\n\u0083\t\nIn Java systems, consider using Serialization to \nsave a system\u2019s state.\n Memento Uses and Drawbacks \nWhile this isn\u2019t \na terribly fancy \nimplementation, notice \nthat the Client has \nno access to the \nMemento\u2019s data.\nClient\n// when new level is reached\nObject saved = \n  (Object) mgo.getCurrentState();\n// when a restore is required\nmgo.restoreState(saved);\nGameMemento\nsavedGameState\nMasterGameObject\nObject getCurrentState() {\n  // gather state\n  return(gameState);\n}\nrestoreState(Object savedState) {\n  // restore state\n}\n// do other game stuff\ngameState\n", "page": 649, "type": "text", "section": "Page 649"}
{"text": "612\u2003 \u2003 Appendix\nprototype pattern\nYour interactive role-playing game has an insatiable appetite for monsters. As your \nheroes make their journey through a dynamically created landscape, they encounter \nan endless chain of foes that must be subdued. You\u2019d like the monster\u2019s characteristics \nto evolve with the changing landscape. It doesn\u2019t make a lot of sense for bird-like \nmonsters to follow your characters into underseas realms. Finally, you\u2019d like to allow \nadvanced players to create their own custom monsters.\nPrototype\nUse the Prototype Pattern when creating an instance \nof a given class is either expensive or complicated.\nA scenario\nIt would be a lot cleaner if \nwe could decouple the code that \nhandles the details of creating the \nmonsters from the code that actually \nneeds to create the instances on \nthe fly.\nYikes! Just the act \nof creating all of these different \nkinds of monster instances is getting \ntricky... Putting all sorts of state detail in the \nconstructors doesn\u2019t seem to be very cohesive. It \nwould be great if there was a single place where \nall of the instantiation details could be \nencapsulated... \n", "page": 650, "type": "text", "section": "Page 650"}
{"text": "you are here 4\u2003 \u2003 613\nleftover patterns\n<<interface>>\nMonster\nPrototype to the rescue\nThe Prototype Pattern allows you to make new instances by \ncopying existing instances. (In Java this typically means using \nthe clone() method, or deserialization when you need deep \ncopies.) A key aspect of this pattern is that the client code can \nmake new instances without knowing which specific class is \nbeing instantiated.\n Prototype Benefits\n\u0083\t\nHides the complexities of making new instances \nfrom the client.\n\u0083\t\nProvides the option for the client to generate \nobjects whose type is not known.\n\u0083\t\nIn some circumstances, copying an object can be \nmore efficient than creating a new object.\n\u0083\t\nPrototype should be considered when a system \nmust create new objects of many types in a \ncomplex class hierarchy.\n\u0083\t\nA drawback to using Prototype is that making a \ncopy of an object can sometimes be complicated.\n Prototype Uses and Drawbacks \nThe registry finds the appropriate \nmonster, makes a clone of it, and \nreturns the clone.\nThe client needs a new monster \nappropriate to the current \nsituation. (The client won\u2019t know \nwhat kind of monster he gets.)\nWellKnownMonster\nDynamicPlayerGeneratedMonster\nMonsterMaker\nmakeRandomMonster() {\n   Monster m = \n     MonsterRegistry.getMonster();\n}\nMonsterRegistry\nMonster getMonster() {\n  // find the correct monster\n  return correctMonster.clone();\n}\n", "page": 651, "type": "text", "section": "Page 651"}
{"text": "614\u2003 \u2003 Appendix\nvisitor pattern\nVisitor\nUse the Visitor Pattern when you want to \nadd capabilities to a composite of objects \nand encapsulation is not important.\nCustomers who frequent the Objectville Diner and Objectville \nPancake House have recently become more health conscious. They \nare asking for nutritional information before ordering their meals. \nBecause both establishments are so willing to create special orders, \nsome customers are even asking for nutritional information on a \nper-ingredient basis.\nA scenario\nLou\u2019s proposed solution:\nMenuItem\nMenu\nIngredient\nMenuItem\nIngredient\n// new methods\ngetHealthRating()\ngetCalories()\ngetProtein()\ngetCarbs()\n// new methods\ngetHealthRating()\ngetCalories()\ngetProtein()\ngetCarbs()\nMel\u2019s concerns...\n\u201cBoy, it seems like we\u2019re opening Pandora\u2019s box. Who knows what \nnew method we\u2019re going to have to add next, and every time we \nadd a new method we have to do it in two places. Plus, what if \nwe want to enhance the base application with, say, a recipes class?  \nThen we\u2019ll have to make these changes in three different places...\u201d\n", "page": 652, "type": "text", "section": "Page 652"}
{"text": "you are here 4\u2003 \u2003 615\nleftover patterns\nThe Visitor drops by\nThe Visitor works hand in hand with a Traverser. The Traverser \nknows how to navigate to all of the objects in a Composite. The \nTraverser guides the Visitor through the Composite so that the Visitor \ncan collect state as it goes. Once state has been gathered, the Client \ncan have the Visitor perform various operations on the state. When \nnew functionality is required, only the Visitor must be enhanced.\n Visitor Benefits\n\u0083\t\nAllows you to add operations to a Composite \nstructure without changing the structure itself.\n\u0083 \t Adding new operations is relatively easy.\n\u0083\t\nThe code for operations performed by the Visitor is \ncentralized.\n\u0083\t\nThe Composite classes\u2019 encapsulation is broken \nwhen the Visitor is used.\n\u0083\t\nBecause the traversal function is involved, \nchanges to the Composite structure are more \ndifficult.\n Visitor Drawbacks \nVisitor\n  Client / \nTraverser\ngetState()\ngetState()\ngetState()\ngetState()\ngetState()\ngetHealthRating()\ngetCalories()\ngetProtein()\ngetCarbs()\nAll these composite \nclasses have to do is add \na getState() method \n(and not worry about \nexposing themselves).\nThe Client asks \nthe Visitor to get \ninformation from the \nComposite structure... \nNew methods can be \nadded to the Visitor \nwithout affecting the \nComposite.\nThe Visitor needs to be able to call \ngetState() across classes, and this is \nwhere you can add new methods for \nthe client to use.\nThe Traverser knows how to \nguide the Visitor through \nthe Composite structure.\nMenuItem\nMenu\nIngredient\nMenuItem\nIngredient\n", "page": 653, "type": "text", "section": "Page 653"}
{"text": "this is the index\u2003 \u2003 617\nIndex\nA\nAbstractButton class  65\nabstract class  128, 292, 293\nAbstract Factory Pattern\nabout  153\nbuilding ingredient factories  146\u2013148, 167\ncombining patterns  502\u2013505, 548\ndefined  156\u2013157\nexercise matching description of  574, 596\nFactory Method Pattern and  158\u2013161\nimplementing  158\ninterview with  158\u2013159\nAbstractList  309\nabstract superclasses  12\nAdapter Pattern\nabout  243\u2013244\nadapting to Iterator Enumeration interface  251\ncombining patterns  498\u2013499\ndealing with remove() method  252\nDecorator Pattern vs.  254\u2013255\ndefined  245\ndesigning Adapter  251\nexercises for  256, 275, 375, 379, 481, 574, 596\nFacade Pattern vs.  262\nin Model-View-Controller  540\nobject and class adapters  246\u2013249\nProxy Pattern vs.  466\nsimple real world adapters  250\nwriting Enumeration Iterator Adapter  252\u2013253\nadapters, OO (Object-Oriented)\nabout  238\u2013239\ncreating Two Way Adapters  244\nin action  240\u2013241\nobject, class object and class  246\u2013249\ntest driving  242\naggregates  327, 338\nalbum covers, displaying using Proxy Pattern\nabout  458\ncode for  489\u2013492\ndesigning Virtual Proxy  459\nreviewing process  465\ntesting viewer  464\nwriting Image Proxy  460\u2013463\nAlexander, Christopher\nA Pattern Language  588\nThe Timeless Way of Building  588\nalgorithms, encapsulating\nabout  277\nabstracting prepareRecipe()  284\u2013287\nStrategy Pattern and  24\nTemplate Method Pattern and\nabout  288\u2013290\napplets in  309\ncode up close  292\u2013293\ndefined  291\nThe Hollywood Principle and  298\u2013300\nhooks in  293\u2013295\nin real world  301\nsorting with  302\u2013307\nSwing and  308\ntesting code  296\nalgorithms, family of  22\nAnti-Patterns  592\u2013593\nApplicability section, in pattern catalog  571\nApplication Patterns  590\nArchitectural Patterns  590\nArrayList, arrays and  320\u2013325, 351\narrays\niteration and  325\u2013326, 345\niterator and hasNext() method with  328\niterator and next() method with  328\n", "page": 655, "type": "text", "section": "Page 655"}
{"text": "618\u2003 \u2003 Index\nthe index\nB\nbehavioral patterns categories, Design Patterns  576, \n578\u2013579\nbehaviors\nclasses as  14\nclasses extended to incorporate new  86\ndeclaring variables  15\ndelegating to decorated objects while adding  90\ndesigning  11\u201312\nencapsulating  11, 22\nimplementing  11, 13\nseparating  10\nsetting dynamically  20\u201321\nBe the JVM solution exercises, dealing with multithreading \n \n179\u2013180, 188\nBridge Pattern  598\u2013599\nBuilder Pattern  600\u2013601\nBusiness Process Patterns  591\nC\nCaching Proxy, as form of Virtual Proxy  466, 482\nCaf\u00e9 Menu, integrating into framework (Iterator Pattern)  \n347\nChain of Responsibility Pattern  602\u2013603\nchange\nas the one constant in software development  8\nidentifying  54\niteration and  340\nchocolate factory example, using Singleton Pattern  \n175\u2013176, 183\nclass adapters, object vs.  246\u2013249\nclass design, of Observer Pattern  51\u201352\nclasses. See also\u00a0subclasses\nabstract  128, 292, 293\nadapter  244, 274\nAdapter Pattern  245\naltering decorator  108\nas behaviors  14\ncollection  352\ncreating  10\nextended to incorporate new behaviors  86\nFactory Method Pattern creator and product  131\u2013132\nhaving single responsibility  340\u2013341\nhigh-level component  139\nidentifying as Proxy class  480\nrelationships between  22\nstate\ndefining  395\nimplementing  397, 400\u2013405, 409\nincreasing number in design of  408\nreworking  398\u2013399\nstate transitions in  408\nusing composition with  23\nusing instance variables instead of  82\u201383\nusing instead of Singletons static  184\nusing new operator for instantiating concrete  110\u2013113\nClassification section, in pattern catalog  571\nclassloaders, using with Singletons  184\nclass patterns, Design Patterns  577\nclient heap  433\u2013436\nclient helper (stubs), in RMI  436\u2013437, 440, 442\u2013444, \n453\u2013454\nCode Magnets exercise\nfor DinerMenu Iterator  354, 378\nfor Observer Pattern  70, 76\ncohesion  340\nCollaborations section, in pattern catalog  571\ncollection classes  352\ncollection of objects\nabstracting with Iterator Pattern\nabout  317\nadding Iterators  328\u2013334\ncleaning up code using java.util.Iterator  335\u2013337\nremove() method in  334\nimplementing Iterators for  327\nintegrating into framework  347\nmeaning of  327\nusing Composite Pattern\nabout  363\nimplementing components  364\u2013366\ntesting code  368\u2013370\ntree structure  360\u2013362, 368\nusing whole-part relationships  372\nCollections, Iterators and  353\n", "page": 656, "type": "text", "section": "Page 656"}
{"text": "you are here 4\u2003 \u2003 619\nthe index\nCombining Patterns\nAbstract Factory Pattern  502\u2013505\nAdapter Pattern  498\u2013499\nclass diagram for  518\u2013519\nComposite Pattern  507\u2013509\nDecorator Pattern  500\u2013501\nIterator Pattern  507\nObserver Pattern  510\u2013516\ncommand objects\nencapsulating requests to do something  196\nmapping  201\nusing  204\nCommand Pattern\ncommand objects\nbuilding  203\nencapsulating requests to do something  196\nmapping  201\nusing  204\ndefined  206\u2013207\ndumb and smart command objects  228\nexercise matching description of  574, 596\nhome automation remote control\nabout  193\nbuilding  203\u2013205, 235\nclass diagram  207\ncreating commands to be loaded  208\u2013209\ndefining  206\ndesigning  195\u2013196\nimplementing  210\u2013212\nmacro commands  225, 226\u2013228, 236\nmapping  201\u2013202, 235\nNull Object in  214\ntesting  204, 212\u2013213, 227\nundo commands  217\u2013221, 223\u2013224, 228, 236\nvendor classes for  194\nwriting documentation  215\nlogging requests using  230\nmapping  201\u2013202, 235\nNull Object  214\nqueuing requests using  229\nunderstanding  197\u2013200\ncompareTo() method  303\nComplexity Hiding Proxy  483\ncomponents of object  267\u2013271\nComposite Pattern\ncombining patterns  507\u2013509\ndefined  360\ndessert submenu using\nabout  357\ndesigning  363, 371\nimplementing  364\u2013367\ntesting  368\u2013370\nexercise matching description of  375, 379, 574, 596\nin Model-View-Controller  526\u2013527, 543\ninterview with  372\u2013373\non implementation issues  372\u2013373\nsafety vs. transparency  509\ntransparency in  371\ntree structure of  360\u2013362, 368\ncomposition\nadding behavior at runtime  85\nfavoring over inheritance  23, 85\ninheritance vs.  93\nobject adapters and  249\ncompound patterns, using\nabout  493\u2013494\nModel-View-Controller\nabout  520\u2013521, 523\u2013525\nAdapter Pattern  539\nBeat model  529, 549\u2013552\nComposite Pattern  526\u2013527, 543\ncontrollers per view  543\nHeart controller  541, 561\nHeart model  539, 558\u2013560\nimplementing controller  536\u2013537, 556\u2013557\nimplementing DJ View  528\u2013535, 553\u2013556\nMediator Pattern  543\nmodel in  543\nObserver Pattern  526\u2013527, 531\u2013533\nsong  520\u2013521\nstate of model  543\nStrategy Pattern  526\u2013527, 536\u2013537, 539, 558\u2013560\ntesting  538\nviews accessing model state methods  543\nmultiple patterns vs.  516\nconcrete classes\nderiving from  143\nFactory Pattern and  134\ngetting rid of  116\n", "page": 657, "type": "text", "section": "Page 657"}
{"text": "620\u2003 \u2003 Index\nthe index\ninstantiating objects and  138\nusing new operator for instantiating  110\u2013113\nvariables holding reference to  143\nconcrete creators  135\nconcrete implementation object, assigning,  12\nconcrete methods, as hooks  293\u2013295\nconcrete subclasses  121\u2013122, 297\nConsequences section, in pattern catalog  571\ncontrolling object access, using Proxy Pattern\nabout  426\u2013428\nCaching Proxy  466, 482\nComplexity Hiding Proxy  483\nCopy-On-Write Proxy  483\nFirewall Proxy  482\nProtection Proxy\nabout  469\ncreating dynamic proxy  474\u2013478\nimplementing matchmaking service  471\u2013472\nprotecting subjects  473\ntesting matchmaking service  479\u2013480\nusing dynamic proxy  469\u2013470\nRemote Proxy\nabout  429\nadding to monitoring code  432\npreparing for remote service  446\u2013447\nregistering with RMI registry  448\nreusing client for  449\nreviewing process  453\u2013455\nrole of  430\u2013431\ntesting  450\u2013452\nwrapping objects and  468\nSmart Reference Proxy  482\nSynchronization Proxy  483\nVirtual Proxy\nabout  457\ndesigning Virtual Proxy  459\nreviewing process  465\ntesting  464\nwriting Image Proxy  460\u2013463\nCopy-On-Write Proxy  483\ncreate method\nreplacing new operator with  116\nstatic method vs.  115\nusing subclasses with  121\u2013122\ncreating static classes instead of Singleton  179\u2013180\ncreational patterns category, Design Patterns  576, \n578\u2013579\ncreator classes, in Factory Method Pattern  131\u2013132, \n134\u2013135\ncrossword puzzle  33, 74, 163, 187, 234, 273, 311, 374, \n484\nCunningham, Ward  589\nD\nDecorator Pattern\nabout  88\u201390, 104\nAdapter Pattern vs.  254\u2013255\ncombining patterns  500\u2013501\ndefined  91\ndisadvantages of  101\nexercises for  256, 275, 481, 574, 596\nin Java I/O  100\u2013101\nin Structural patterns category  577\ninterview with  104\nProxy Pattern vs.  466\u2013468\nStarbuzz Coffee project\nabout  80\u201381\nadding sizes to code  99\nconstructing drink orders  89\u201390\ndrawing beverage order process  94, 107\ntesting order code  98\u201399\nwriting code  95\u201397\ndecoupling, Iterator allowing  333, 337, 339, 351\u2013352\ndelegation, adding behavior at runtime  85\ndependence, in Observer Pattern  52\nDependency Inversion Principle (DIP)  139\u2013143, 300\ndependency rot  298\ndepend upon abstractions design principle  139\nDesign Patterns\nbecoming writer of  573\nbehavioral patterns category  576, 578\u2013579\ncategories of  576\u2013579\nclass patterns  577\ncreational patterns category  576, 578\u2013579\ndefined  565\u2013567\ndiscovering own  572\nexercise matching description of  596\n", "page": 658, "type": "text", "section": "Page 658"}
{"text": "you are here 4\u2003 \u2003 621\nthe index\nframeworks vs.  29\nguide to better living with  564\nimplement on interface in  117\nlibraries vs.  29\nobject patterns  577\norganizing  575\noverusing  584\nresources for  588\u2013589\nrule of three applied to  573\nstructural patterns category  576, 578\u2013579\nthinking in patterns  580\u2013581\nusing  29, 582, 584\nyour mind on patterns  583\nDesign Patterns- Reusable Object-Oriented Software \n(Gamma et al.)  588\ndesign principles\nDependency Inversion Principle  139\u2013143\ndepend upon abstractions  139\nEncapsulate what varies  9, 73, 75, 136, 393\nFavor composition over inheritance  23, 73, 75, 393\nThe Hollywood Principle  298\u2013300\nOne Class, One Responsibility Principle  184, 340, \n371\none instance. See\u00a0Singleton Pattern\nOpen-Closed Principle  355, 392\nPrinciple of Least Knowledge  267\u2013271\nProgram to an interface, not an implementation  \n11\u201312, 73, 75\u201376, 337\nSingle Responsibility Principle (SRP)  340\u2013341\nusing Observer Pattern  73, 75\nDesign Puzzles\ndrawing class diagram making use of view and con\u00ad\ntroller  536, 548\ndrawing parallel set of classes  133, 165\ndrawing state diagram  391, 420\nof classes and interfaces  25, 34\nredesigning classes to remove redundancy  281, \n278\u2013283\nredesigning Image Proxy  463, 486\ndessert submenu, using Composite Pattern\nabout  357\ndesigning  363, 371\nimplementing  364\u2013367\ntesting  368\u2013370\ndiner menus, merging (Iterator Pattern)\nabout  318\u2013319\nadding Iterators  328\u2013334\ncleaning up code using java.util.Iterator  335\u2013337\nencapsulating Iterator  325\u2013326\nimplementing Iterators for  327\nimplementing of  320\u2013325\nDIP (Dependency Inversion Principle)  139\u2013143, 300\nDJ View  528\u2013535, 549\u2013561\nDomain-Specific Patterns  590\ndouble-checked locking, reducing use of synchronization \nusing  182\nDuck Magnets exercises, object and class object and class \nadapters  247\u2013248\nduck simulator, rebuilding\nabout  495\u2013497\nadding Abstract Factory Pattern  502\u2013505, 548\nadding Adapter Pattern  498\u2013499\nadding Composite Pattern  507\u2013509\nadding Decorator Pattern  500\u2013501\nadding Iterator Pattern  507\nadding Observer Pattern  510\u2013516\nclass diagram  518\u2013519\ndumb command objects  228\ndynamic aspect of dynamic proxies  480\ndynamic proxy  469\u2013470, 474\u2013478\nE\nEncapsulate what varies design principle  9, 73, 75, 136, \n393\nencapsulating\nbehavior  11\ncode  22\u201323, 114\u2013115, 136\niteration  325\u2013326\nmethod invocation  191, 206\nobject construction  600\nrequests  206\nencapsulating algorithms\nabout  277\nabstracting prepareRecipe()  284\u2013287\nTemplate Method Pattern and\nabout  288\u2013290\nAbstractList and  309\ncode up close  292\u2013293\ndefined  291\nThe Hollywood Principle and  298\u2013300\n", "page": 659, "type": "text", "section": "Page 659"}
{"text": "622\u2003 \u2003 Index\nthe index\nhooks in  293\u2013295\nin real world  301\nsorting with  302\u2013307\nSwing and  308\ntesting code  296\nencapsulating subsystem, Facades  262\nEnumeration\nabout  250\nadapting to Iterator  251\njava.util.Enumeration as older implementation of \nIterator  250, 342\nremove() method and  252\nwriting Adapter that adapts Iterator to  253, 275\nexercises\nBe the JVM solution, dealing with multithreading  \n179\u2013180, 188\nCode Magnets\nfor DinerMenu Iterator  354, 378\nfor Observer Pattern  70, 76\ndealing with multithreading  247\u2013248\nDesign Puzzles\ndrawing class diagram making use of view and \ncontroller  536, 548\ndrawing parallel set of classes  133, 165\ndrawing state diagram  391, 420\nof classes and interfaces  25, 34\nredesigning classes to remove redundancy  281\u2013\n282\nredesigning Image Proxy  463, 486\nDuck Magnets exercises, object and class object and \nclass adapters  247\nimplementing Iterator  329\nimplementing undo button for macro command  228, \n236\nSharpen Your Pencil\naltering decorator classes  99, 108\nannotating Gumball Machine states  405, 423\nannotating state diagram  396, 422\nbuilding ingredient factory  148, 167\nchanging classes for Decorator Pattern  512, 546\nchanging code to fit framework in Iterator Pattern  \n347, 377\nchoosing descriptions of state of implementation  \n392, 421\nclass diagram for implementation of prepareR\u00ad\necipe()  286, 314\ncode not using factories  137, 166\ncreating commands for off buttons  226, 236\ncreating heat index  62\ndetermining classes violating Principle of Least \nKnowledge  270, 274\ndrawing beverage order process  107\nfixing Chocolate Boiler code  183, 190\nidentifying factors influencing design  84\nimplementing garage door command  205, 235\nimplementing state classes  402, 421\nmaking pizza store  124, 164\nmatching patterns with categories  575\u2013577\nmethod for refilling gumball machine  417, 424\non adding behaviors  14\non implementation of printmenu()  324, 377\non inheritance  5, 35\nsketching out classes  55\nthings driving change  8, 35\nturning class into Singleton  176, 189\nweather station SWAG  42, 75\nwriting Abstract Factory Pattern  505, 548\nwriting classes for adapters  244, 274\nwriting dynamic proxy  478, 487\nwriting Flock observer code  514, 547\nwriting methods for classes  83, 106\nWho Does What\nmatching objects and methods to Command Pat\u00ad\ntern  202, 235\nmatching patterns with its intent  256, 275\nmatching pattern with description  300, 314, 375, \n379, 418, 424, 481, 488, 574, 596\nwriting Adapter that adapts Iterator to Enumeration  \n253, 275\nwriting handler for matchmaking service  477, 486\nexternal iterators  342\nF\nFacade Pattern\nabout  256\nAdapter Pattern vs.  262\nadvantages  262\n", "page": 660, "type": "text", "section": "Page 660"}
{"text": "you are here 4\u2003 \u2003 623\nthe index\nbenefits of  262\nbuilding home theater system\nabout  257\u2013259\nconstructing Facade in  263\nimplementing Facade class  260\u2013262\nimplementing interface  264\nclass diagram  266\nComplexity Hiding Proxy vs.  483\ndefined  266\nexercises for  256, 275, 375, 379, 481, 574, 596\nPrinciple of Least Knowledge and  271\nfactory method\nabout  125, 134\nas abstract  135\ndeclaring  125\u2013127\nFactory Method Pattern\nabout  131\u2013132\nabout factory objects  114\nAbstract Factory Pattern and  158\u2013161\ncode up close  151\nconcrete classes and  134\ncreator classes  131\u2013132\ndeclaring factory method  125\u2013127\ndefined  134\nDependency Inversion Principle  139\u2013143\ndrawing parallel set of classes  133, 165\nexercise matching description of  574, 596\ninterview with  158\u2013159\nlooking at object dependencies  138\nproduct classes  131\u2013132\nSimple Factory and  135\nFactory Pattern\nAbstract Factory\nabout  153\nbuilding ingredient factories  146\u2013148, 167\ncombining patterns  502\u2013505, 548\ndefined  156\u2013157\nexercise matching description of  574, 596\nFactory Method Pattern and  158\u2013160\nimplementing  158\nexercise matching description of  300, 314\nFactory Method\nabout  131\u2013132\nadvantages of  135\ncode up close  151\ncreator classes  131\u2013132\ndeclaring factory method  125\u2013127\ndefined  134\nDependency Inversion Principle  139\u2013143\ndrawing parallel set of classes  133, 165\nexercise matching description of  574, 596\nlooking at object dependencies  138\nproduct classes  131\u2013132\nSimple Factory and  135\nSimple Factory\nabout factory objects  114\nbuilding factory  115\ndefined  117\nFactory Method Pattern and  135\npattern honorable mention  117\nusing new operator for instantiating concrete \nclasses  110\u2013113\nFavor composition over inheritance design principle  23, \n73, 75, 393\nFireside Chat\nDecorator Pattern vs. Adapter Pattern  254\u2013255\nStrategy Pattern vs. State Pattern  414\u2013415\nFirewall Proxy  482\nFlyweight Pattern  604\u2013605\nforces  568\nfor loop  344\nframeworks vs. libraries  29\nG\nGamma, Erich  587\u2013588\nGang of Four (GoF)  569, 587\u2013588\nglobal access point  177\nglobal variables, Singleton vs.  184\nguide to better living with Design Patterns  564\ngumball machine controller implementation, using State \nPattern\ncleaning up code  413\ndemonstration of  411\u2013412\ndiagram to code  384\u2013385\nfinishing  410\none in ten contest\nabout  390\u2013391\nannotating state diagram  396, 422\nchanging code  392\u2013393\n", "page": 661, "type": "text", "section": "Page 661"}
{"text": "624\u2003 \u2003 Index\nthe index\ndrawing state diagram  391, 420\nimplementing state classes  397, 400\u2013405, 409\nnew design  394\u2013396\nreworking state classes  398\u2013399\nrefilling gumball machine  416\u2013417\nSoldState and WinnerState in  412\ntesting code  388\u2013389\nwriting code  386\u2013387\ngumball machine monitoring, using Proxy Patterns\nabout  426\u2013428\nRemote Proxy\nabout  429\nadding to monitoring code  432\npreparing for remote service  446\u2013447\nregistering with RMI registry  448\nreusing client for  449\nreviewing process  453\u2013454\nrole of  430\u2013431\ntesting  450\u2013452\nwrapping objects and  468\nH\nHAS-A relationships  23, 91\nHashMap  348, 352, 353\nhasNext() method  328, 342, 344\nHead First learning principles  xxviii\nHelm, Richard  587\u2013588\nhigh-level component classes  139\nThe Hollywood Principle  298\u2013300\nhome automation remote control, using Command Pattern\nabout  193\nbuilding  203\u2013205, 235\nclass diagram  207\ncreating commands to be loaded  208\u2013209\ndefining  206\ndesigning  195\u2013196\nimplementing  210\u2013212\nmacro commands\nabout  225\nhard coding vs.  228\nundo button  228, 236\nusing  226\u2013227\nmapping  201\u2013202, 235\nNull Object  214\ntesting  204, 212\u2013213, 227\nundo commands\ncreating  217\u2013219, 228\nimplementing for macro command  236\ntesting  220, 223\u2013224\nusing state to implement  221\nvendor classes for  194\nwriting documentation  215\nhome theater system, building\nabout  257\u2013259\nconstructing Facade in  263\nimplementing interface  264\nSharpen Your Pencil  270\nusing Facade Pattern  260\u2013262\nhooks, in Template Method Pattern  293\u2013295\nI\nImage Proxy, writing  460\u2013463\nimplementations  13, 17, 43\nImplementation section, in pattern catalog  571\nimplement on interface, in design patterns  117\nimport and package statements  128\ninheritance\ncomposition vs.  93\ndisadvantages of  5, 85\nfavoring composition over  23\nfor maintenance  4\nfor reuse  4, 13\nimplementing multiple  246\ninstance variables  82\u201383, 97\u201398\ninstantiating  110\u2013113, 138, 170\u2013172\nintegrating Caf\u00e9 Menu, using Iterator Pattern  347\nIntent section, in pattern catalog  571\ninterface  11\u201312, 110\u2013113\ninterface type  15, 18\ninternal iterators  342\nInterpreter Pattern  606\u2013607\nInterview With\nComposite Pattern  372\u2013373\nDecorator Pattern  104\n", "page": 662, "type": "text", "section": "Page 662"}
{"text": "you are here 4\u2003 \u2003 625\nthe index\nFactory Method Pattern and Abstract Factory Pattern  \n158\u2013159\nSingleton Pattern  174\ninversion, in Dependency Inversion Principle  141\ninvoker  201, 206\u2013207, 209, 233\nIS-A relationships  23\nIterable interface  343\nIterator Pattern\nabout  327\nclass diagram  339\ncode up close using HashMap  348\ncode violating Open-Closed Principle  355\u2013356\nCollections and  353\ncombining patterns  507\ndefined  338\u2013339\nexercise matching description of  375, 379, 574, 596\nintegrating Caf\u00e9 Menu  347\njava.util.Iterator  334\nmerging diner menus\nabout  318\u2013319\nadding Iterators  328\u2013334\ncleaning up code using java.util.Iterator  335\u2013337\nencapsulating Iterator  325\u2013326\nimplementing Iterators for  327\nimplementing of  320\u2013325\nremoving objects  334\nSingle Responsibility Principle (SRP)  340\u2013341\nIterators\nadding  328\u2013334\nallowing decoupling  333, 337, 339, 351\u2013352\ncleaning up code using java.util.Iterator  335\u2013337\nCollections and  353\nencapsulating  325\u2013326\nEnumeration adapting to  251, 342\nexternal  342\nHashMap and  353\nimplementing  327\ninternal  342\nordering of  342\npolymorphic code using  338, 342\nusing ListItterator  342\nwriting Adapter for Enumeration  252\u2013253\nwriting Adapter that adapts to Enumeration  253, 275\nJ\nJavaBeans library  65\nJava Collections Framework  353\nJava decorators (java.io packages)  100\u2013103\nJava Development Kit (JDK)  65\nJava Iterable interface  343\njava.lang.reflect package, proxy support in  440, 469, 476\njava.util.Collection  353\njava.util.Enumeration, as older implementation of Iterator \n \n250, 342\njava.util.Iterator\ncleaning up code using  335\u2013337\ninterface of  334\nusing  342\nJava Virtual Machines (JVMs)  182, 432\nJButton class  65\nJFrames, Swing  308\nJohnson, Ralph  587\u2013588\nK\nKeep It Simple (KISS), in designing patterns  580\nKnown Uses section, in pattern catalog  571\nL\nlambda expressions  67\nLaw of Demeter. See\u00a0Principle of Least Knowledge\nlazy instantiation  177\nleaves, in Composite Pattern tree structure  360\u2013362, 368\nlibraries  29\nLinkedList  352\nListItterator  342\nlogging requests, using Command Pattern  230\nlooping through array items  323\nLoose Coupling Principle  54\n", "page": 663, "type": "text", "section": "Page 663"}
{"text": "626\u2003 \u2003 Index\nthe index\nM\nmacro commands\nabout  225\nmacro commands  228, 236\nusing  226\u2013227\nmaintenance, inheritance for,  4\nmatchmaking service, using Proxy Pattern\nabout  470\ncreating dynamic proxy  474\u2013478\nimplementing  471\u2013472\nprotecting subjects  473\ntesting  479\u2013480\nMediator Pattern  543, 608\u2013609\nMemento Pattern  610\u2013611\nmerging diner menus (Iterator Pattern)\nabout  318\u2013319\nadding Iterators  328\u2013334\ncleaning up code using java.util.Iterator  335\u2013337\nencapsulating Iterator  325\u2013326\nimplementing Iterators for  327\nimplementing of  320\u2013325\nmethod of objects, components of object vs.  267\u2013271\nmethods  143, 293\u2013295\nmodeling state  384\u2013385\nModel-View-Controller (MVC)\nabout  520\u2013521, 523\u2013525\nAdapter Pattern  540\nBeat model  529, 549\u2013552\nComposite Pattern  526\u2013527, 543\ncontrollers per view  543\nHeart controller  541, 561\nHeart model  539\nimplementing controller  536\u2013537, 556\u2013557\nimplementing DJ View  528\u2013535, 553\u2013556\nMediator Pattern  543\nmodel in  543\nObserver Pattern  526\u2013527, 531\u2013533\nsong  520\u2013521\nstate of model  543\nStrategy Pattern  526\u2013527, 536\u2013537, 539, 558\u2013560\ntesting  538\nviews accessing model state methods  543\nMotivation section, in pattern catalog  571\nmultiple patterns, using\nabout  493\u2013494\nin duck simulator\nabout rebuilding  495\u2013497\nadding Abstract Factory Pattern  502\u2013505, 548\nadding Adapter Pattern  498\u2013499\nadding Composite Pattern  507\u2013509\nadding Decorator Pattern  500\u2013501\nadding Iterator Pattern  507\nadding Observer Pattern  510\u2013516\nclass diagram  518\u2013519\nmultithreading  181\u2013182, 188\nN\nName section, in pattern catalog  571\nnew operator\nrelated to Singleton Pattern  171\u2013172\nreplacing with concrete method  116\nnext() method  328, 342, 344\nNoCommand, in remote control code  214\nnodes, in Composite Pattern tree structure  360\u2013362, 368\nNull Objects  214\nO\nobject access, using Proxy Pattern for controlling\nabout  426\u2013428\nCaching Proxy  466, 482\nComplexity Hiding Proxy  483\nCopy-On-Write Proxy  483\nFirewall Proxy  482\nProtection Proxy\nabout  469\ncreating dynamic proxy  474\u2013478\nimplementing matchmaking service  471\u2013472\nprotecting subjects  473\ntesting matchmaking service  479\u2013480\nusing dynamic proxy  469\u2013470\nRemote Proxy\nabout  429\nadding to monitoring code  432\npreparing for remote service  446\u2013447\nregistering with RMI registry  448\n", "page": 664, "type": "text", "section": "Page 664"}
{"text": "you are here 4\u2003 \u2003 627\nthe index\nreusing client for  449\nreviewing process  453\u2013454\nrole of  430\u2013431\ntesting  450\u2013452\nwrapping objects and  468\nSmart Reference Proxy  482\nSynchronization Proxy  483\nVirtual Proxy\nabout  457\ndesigning Virtual Proxy  459\nreviewing process  465\ntesting  464\nwriting Image Proxy  460\u2013463\nobject adapters vs. class adapters  246\u2013249\nobject construction, encapsulating  600\nobject creation, encapsulating  114\u2013115, 136\nObject-Oriented (OO) design. See also\u00a0design principles\nadapters\nabout  238\u2013239\ncreating Two Way Adapters  244\nin action  240\u2013241, 242\nobject and class object and class  246\u2013249\ndesign patterns vs.  30\u201331\nextensibility and modification os code in  87\nguidelines for avoiding violation of Dependency Inver\u00ad\nsion Principle  143\nloosely coupled designs and  54\nobject patterns, Design Patterns  577\nobjects\ncomponents of  267\u2013271\ncreating  134\nloosely coupled designs between  54\nsharing state  408\nSingleton  171, 174\nwrapping  88, 244, 254, 262, 502\nObserver Pattern\nabout  37, 44\nclass patterns category  574\ncombining patterns  510\u2013516\ncomparison to Publish-Subscribe  45\ndependence in  52\nexamples of  65\nexercise matching description of  375, 379, 596\nin Five-minute drama  48\u201350\nin Model-View-Controller  526\u2013527, 531\u2013533\nloose coupling in  54\nObserver object in  45\none-to-many relationships  51\u201352\nprocess  46\u201347\nSubject object in  45\nweather station using\nbuilding display elements  60\ndesigning  57\nimplementing  58\npowering up  61\nSWAG  42\nobservers\nin class diagram  52\nin Five-minute drama  48\u201350\nin Observer Pattern  45\nOCP (Open-Closed Principle)  355, 392\nOne Class, One Responsibility Principle. See\u00a0Single Re\u00ad\nsponsibility Principle (SRP)\none in ten contest in gumball machine, using State Pattern\nabout  390\u2013391\nannotating state diagram  396, 422\nchanging code  392\u2013393\ndrawing state diagram  391, 420\nimplementing state classes  397, 400\u2013405, 409\nnew design  394\u2013396\nreworking state classes  398\u2013399\nOO (Object-Oriented) design. See\u00a0Object-Oriented (OO) \ndesign\nOpen-Closed Principle (OCP)  355, 392\nOrganizational Patterns  591\noverusing Design Patterns  584\nP\npackage and import statements  128\nParticipants section, in pattern catalog  571\npart-whole hierarchy  360\npattern catalogs  567, 569\u2013572\nPattern Death Match pages  493\nA Pattern Language (Alexander)  588\npatterns, using compound  493\u2013494\n", "page": 665, "type": "text", "section": "Page 665"}
{"text": "628\u2003 \u2003 Index\nthe index\npatterns, using multiple\nabout  493\nin duck simulator\nabout rebuilding  495\u2013497\nadding Abstract Factory Pattern  502\u2013505, 548\nadding Adapter Pattern  498\u2013499\nadding Composite Pattern  507\u2013509\nadding Decorator Pattern  500\u2013501\nadding Iterator Pattern  507\nadding Observer Pattern  510\u2013516\nclass diagram  518\u2013519\npattern templates, uses of  573\nPizza Store project, using Factory Pattern\nAbstract Factory in  153, 156\u2013157\nbehind the scenes  154\u2013155\nbuilding factory  115\nconcrete subclasses in  121\u2013122\ndrawing parallel set of classes  133, 165\nencapsulating object creation  114\u2013115\nensuring consistency in ingredients  144\u2013148, 167\nframework for  120\nfranchising store  118\u2013119\nidentifying aspects in  112\u2013113\nimplementing  142\nmaking pizza store in  123\u2013124\nordering pizza  128\u2013132\nreferencing local ingredient factories  152\nreworking pizzas  149\u2013151\npolymorphic code, using on iterator  338, 342\npolymorphism  12\nprepareRecipe(), abstracting  284\u2013287\nPrinciple of Least Knowledge  267\u2013271. See also\u00a0Single \nResponsibility Principle (SRP)\nprint() method, in dessert submenu using Composite Pat\u00ad\ntern  364\u2013367\nprogramming  12\nProgram to an interface, not an implementation design \nprinciple  11\u201312, 73, 75\u201376, 337\nprogram to interface vs. program to supertype  12\nProtection Proxy\nabout  469\ncreating dynamic proxy  474\u2013478\nimplementing matchmaking service  471\u2013472\nprotecting subjects  473\nProxy Pattern and  466\ntesting matchmaking service  479\u2013480\nusing dynamic proxy  469\u2013470\nPrototype Pattern  612\u2013613\nproxies  425\nProxy class, identifying class as  480\nProxy Pattern\nAdapter Pattern vs.  466\nComplexity Hiding Proxy  483\nCopy-On-Write Proxy  483\nDecorator Pattern vs.  466\u2013468\ndefined  455\u2013456\ndynamic aspect of dynamic proxies  480\nexercise matching description of  481, 574, 596\nFirewall Proxy  482\nimplementation of Remote Proxy\nabout  429\nadding to monitoring code  432\npreparing for remote service  446\u2013447\nregistering with RMI registry  448\nreusing client for  449\nreviewing process  453\u2013454\nrole of  430\u2013431\ntesting  450\u2013452\nwrapping objects and  468\njava.lang.reflect package  440, 469, 476\nProtection Proxy and\nabout  469\nAdapters and  466\ncreating dynamic proxy  474\u2013478\nimplementing matchmaking service  471\u2013472\nprotecting subjects  473\ntesting matchmaking service  479\u2013480\nusing dynamic proxy  469\u2013470\nReal Subject\nas surrogate of  466\ninvoking method on  475\nmaking client use Proxy instead of  466\npassing in constructor  476\nreturning proxy for  478\nrestrictions on passing types of interfaces  480\nSmart Reference Proxy  482\nSynchronization Proxy  483\nvariations  466, 482\u2013483\n", "page": 666, "type": "text", "section": "Page 666"}
{"text": "you are here 4\u2003 \u2003 629\nthe index\nVirtual Proxy\nabout  457\nCaching Proxy as form of  466, 482\ndesigning  459\nreviewing process  465\ntesting  464\nwriting Image Proxy  460\u2013463\nPublish-Subscribe, as Observer Pattern  45\nQ\nqueuing requests, using Command Pattern  229\nR\nReal Subject\nas surrogate of Proxy Pattern  466\ninvoking method on  475\nmaking client use proxy instead of  466\npassing in constructor  476\nreturning proxy for  478\nrefactoring  358, 581\nRelated patterns section, in pattern catalog  571\nrelationships, between classes  22\nRemote Method Invocation (RMI)\nabout  432\u2013433, 436\ncode up close  442\ncompleting code for server side  441\u2013444\nimporting java.rmi  446\nimporting packages  447, 449\nmaking remote service  437\u2013441\nmethod call in  434\u2013435\nregistering with RMI registry  448\nthings to watch out for in  444\nRemote Proxy\nabout  429\nadding to monitoring code  432\npreparing for remote service  446\u2013447\nregistering with RMI registry  448\nreusing client for  449\nreviewing process  453\u2013454\nrole of  430\u2013431\ntesting  450\u2013452\nwrapping objects and  468\nremove() method\nEnumeration and  252\nin collection of objects  334\nin java.util.Iterator  342\nrequests, encapsulating  206\nresources, Design Patterns  588\u2013589\nreuse  4, 85\nrule of three, applied to inventing Design Patterns  573\nruntime errors, causes of  135\nS\nSample code section, in pattern catalog  571\nserver heap  433\u2013436\nservice helper (skeletons), in RMI  436\u2013437, 440, 442\u2013\n444, 453\u2013454\nshared vocabulary  26\u201327, 28, 585\u2013586\nSharpen Your Pencil\naltering decorator classes  99, 108\nannotating Gumball Machine States  405, 423\nannotating state diagram  396, 422\nbuilding ingredient factory  148, 167\nchanging classes for Decorator Pattern  512, 546\nchanging code to fit framework in Iterator Pattern  \n347, 377\nchoosing descriptions of state of implementation  392, \n421\nclass diagram for implementation of prepareRecipe()  \n286, 314\ncode not using factories  137, 166\ncreating commands for off buttons  226, 236\ncreating heat index  62\ndetermining classes violating Principle of Least \nKnowledge  270, 274\ndrawing beverage order process  107\nfixing Chocolate Boiler code  183, 190\nidentifying factors influencing design  84\nimplementing garage door command  205, 235\nimplementing state classes  402, 421\nmaking pizza store  124, 164\nmatching patterns with categories  575\u2013577\nmethod for refilling gumball machine  417, 424\non adding behaviors  14\non implementation of printmenu()  324, 377\n", "page": 667, "type": "text", "section": "Page 667"}
{"text": "630\u2003 \u2003 Index\nthe index\non inheritance  5, 35\nsketching out classes  55\nthings driving change  8, 35\nturning class into Singleton  176, 189\nweather station SWAG  42, 75\nwriting Abstract Factory Pattern  505, 548\nwriting classes for adapters  244, 274\nwriting dynamic proxy  478, 487\nwriting Flock observer code  514, 547\nwriting methods for classes  83, 106\nSimple Factory Pattern\nabout factory objects  114\nbuilding factory  115\ndefinition of  117\nFactory Method Pattern and  135\npattern honorable mention  117\nusing new operator for instantiating concrete classes  \n110\u2013113\nSingle Responsibility Principle (SRP)  184, 340\u2013341, 371\nSingleton objects  171, 174\nSingleton Pattern\nabout  169\u2013172\nadvantages of  170\nChocolate Factory  175\u2013176, 183\nclass diagram  177\ncode up close  173\ndealing with multithreading  179\u2013182, 188\ndefined  177\ndisadvantages of  184\ndouble-checked locking  182\nexercise matching description of  574\nglobal variables vs.  184\nimplementing  173\ninterview with  174\nOne Class, One Responsibility Principle and  184\nsubclasses in  184\nusing  184\nskeletons (service helper), in RMI  436\u2013437, 440, 442\u2013\n444, 453\u2013454\nsmart command objects  228\nSmart Reference Proxy  482\nsoftware development, change as a constant in  8\nsorting methods, in Template Method Pattern  302\u2013307\nsort() method  306\u2013311\nspliterator method  343\nSRP (Single Responsibility Principle)  184, 340\u2013341, 371\nStarbuzz Coffee Barista training manual project\nabout  278\u2013283\nabstracting prepareRecipe()  284\u2013287\nusing Template Method Pattern\nabout  288\u2013290\ncode up close  292\u2013293\ndefined  291\nThe Hollywood Principle and  298\u2013300\nhooks in  293\u2013295\ntesting code  296\nStarbuzz Coffee project, using Decorator Pattern\nabout  80\u201381\nadding sizes to code  99\nconstructing drink orders  89\u201390\ndrawing beverage order process  94, 107\ntesting order code  98\u201399\nwriting code  95\u201397\nstate machines  384\u2013385\nState Pattern\ndefined  406\nexercise matching description of  418, 424, 574, 596\ngumball machine controller implementation\ncleaning up code  413\ndemonstration of  411\u2013412\ndiagram to code  384\u2013385\nfinishing  410\nrefilling gumball machine  416\u2013417\nSoldState and WinnerState in  412\ntesting code  388\u2013389\nwriting code  386\u2013387\nincreasing number of classes in design  408\nmodeling state  384\u2013385\none in ten contest in gumball machine\nabout  390\u2013391\nannotating state diagram  396, 422\nchanging code  392\u2013393\ndrawing state diagram  391, 420\nimplementing state classes  397, 400\u2013405, 409\nnew design  394\u2013396\nreworking state classes  398\u2013399\nsharing state objects  408\nstate transitions in state classes  408\nStrategy Pattern vs.  381, 407, 414\u2013415\nstate transitions, in state classes  408\n", "page": 668, "type": "text", "section": "Page 668"}
{"text": "you are here 4\u2003 \u2003 631\nthe index\nstate, using to implement undo commands  221\nstatic classes, using instead of Singletons  184\nstatic method vs. create method  115\nStrategy Pattern\nalgorithms and  24\ndefined  24\nexercise matching description of  300, 314, 375, 379, \n418, 424, 574, 596\nin Model-View-Controller  526\u2013527, 536\u2013537, 539\nState Pattern vs.  381, 407, 414\u2013415\nTemplate Method Pattern and  307\nstrive for loosely coupled designs between objects that in\u00ad\nteract design principle  54. See also\u00a0Loose Coupling \nPrinciple\nstructural patterns category, Design Patterns  576, \n578\u2013579\nStructure section, in pattern catalog  571\nstubs (client helper), in RMI  436\u2013437, 440, 442\u2013444, \n453\u2013454\nsubclasses\nconcrete commands and  207\nconcrete states and  406\nexplosion of classes  81\nFactory Method and, letting subclasses decide which \nclass to instantiate  134\nin Singletons  184\nPizza Store concrete  121\u2013122\nTemplate Method  288\ntroubleshooting  4\nSubject\nin class diagram  52\nin Five-minute drama  48\u201350\nin Observer Pattern  45\u201347\nsubsystems, Facades and  262\nsuperclasses  4, 12\nsupertype (programming to interface), vs. programming to \ninterface  12\nSwing library  65, 308, 543\nsynchronization, as overhead  180\nSynchronization Proxy  483\nT\nTemplate Method Pattern\nabout  288\u2013290\nabstract class in  292, 293, 297\napplets in  309\nclass diagram  291\ncode up close  292\u2013293\ndefined  291\nexercise matching description of  300, 314, 418, 424, \n574, 596\nThe Hollywood Principle and  298\u2013300\nhooks in  293\u2013295, 297\nin real world  301\nsorting with  302\u2013307\nStrategy Pattern and  307\nSwing and  308\ntesting code  296\nthinking in patterns  580\u2013581\ntightly coupled  54\nThe Timeless Way of Building (Alexander)  588\ntransparency, in Composite Pattern  371\ntree structure, Composite Pattern  360\u2013362, 368\nTwo Way Adapters, creating  244\ntype safe parameters  135\nU\nundo commands\ncreating  217\u2013219, 228\nimplementing for macro command  228\nsupport of  217\ntesting  220, 223\u2013224\nusing state to implement  221\nUser Interface Design Patterns  591\nV\nvariables\ndeclaring behavior  15\nholding reference to concrete class  143\ninstance  82\u201383, 97\u201398\n", "page": 669, "type": "text", "section": "Page 669"}
{"text": "632\u2003 \u2003 Index\nthe index\nVector  352\nVirtual Proxy\nabout  457\nCaching Proxy as form of  466, 482\ndesigning  459\nreviewing process  465\ntesting  464\nwriting Image Proxy  460\u2013463\nVisitor Pattern  614\u2013615\nVlissides, John  587\u2013588\nvolatile keyword  182\nW\nweather station\nbuilding display elements  60\ndesigning  57\nimplementing  58\npowering up  61\nWho Does What exercises\nmatching objects and methods to Command Pattern  \n202, 235\nmatching patterns with its intent  256, 275\nmatching pattern with description  300, 314, 375, 379, \n418, 424, 481, 488, 574, 596\nwhole-part relationships, collection of objects using  372\nWickedlysmart website  xxxiii\nwrapping objects  88, 244, 254, 262, 468, 502\nY\nyour mind on patterns design pattern  583\n", "page": 670, "type": "text", "section": "Page 670"}
{"text": "Don\u2019t know about the website? \nWe\u2019ve got updates, video, \nprojects, author blogs, and more!\nBring your brain over to \nwickedlysmart.com\n", "page": 671, "type": "text", "section": "Page 671"}
{"text": "There\u2019s much more  \nwhere this came from.\nExperience books, videos, live online  \ntraining courses, and more from O\u2019Reilly  \nand our 200+ partners\u2014all in one place.\nLearn more at oreilly.com/online-learning\n\u00a92019 O\u2019Reilly Media, Inc. O\u2019Reilly is a registered trademark of O\u2019Reilly Media, Inc. | 175\n", "page": 672, "type": "text", "section": "Page 672"}
