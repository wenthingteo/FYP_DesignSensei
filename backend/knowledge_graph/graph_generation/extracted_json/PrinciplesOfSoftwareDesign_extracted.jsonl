{"text": "Principles of Software Design \n \nThis paper presents fundamental principles of effective software design.  If consistently \napplied, they help us to achieve simple, understandable, and robust software designs.  \nThey provide criteria for choosing between various design alternatives.  All design \ndecisions should be evaluated against them to ensure their consistent application.  These \nprinciples also provide a framework for evaluating the quality of software designs created \nby others. \nGoals of Software Design \nSoftware design is primarily about managing complexity.  Software systems are often \nvery complex and have many moving parts.  Most systems must support dozens of \nfeatures simultaneously.  Each feature by itself might not seem very complicated.  \nHowever, when faced with the task of creating one coherent structure that supports all of \nthe required functionality at once, things become complicated very quickly.  Human \ncapacity to deal with complexity is quite limited; people become overwhelmed and \nconfused relatively quickly.  Perhaps the primary objective of software design is to make \nand keep software systems well organized, thus enhancing our ability to understand, \nexplain, modify, and fix them. \n \nBased on this view of software design, disorganization (or sloppiness) is the antithesis of \ngood software design.  As the laws of physics teach us, the universe tends to become \nmore disorganized over time unless we take active steps to make and keep it organized.  \nSoftware systems are very much the same way.  If created or modified without careful \nforethought, software systems quickly become incomprehensible, tangled messes that \ndon\u2019t work right and are impossible to fix.  This is especially true for systems that remain \nin use over extended periods of time, and are periodically upgraded to support new \nfeatures.  Even if a system starts out with a good design, we must consistently strive to \npreserve the integrity of its design throughout its lifetime by carefully considering all \nchanges we make to it. \n \nBased on these principles, we can list several important goals of software design: \n\u0083 Software that works \n\u0083 Software that is easy to read and understand \n\u0083 Software that is easy to debug and maintain \n\u0083 Software that is easy to extend and holds up well under changes \n\u0083 Software that is reusable in other projects \nDesign Is an Iterative Process \nSoftware design is a complex undertaking.  Therefore, you will rarely get a design right \nthe first time.  Implementing a design provides new insights into its deficiencies: things \nyou didn't think about, better ways of doing things, etc.  Such insights should feed back \ninto your design to make it better.  For this reason, design and implementation activities \nare usually interleaved in short iterations: Design, code, test, debug, Design, code, test, \ndebug, \u2026 \n", "page": 1, "type": "text", "section": "Page 1"}
{"text": " \nThe notion that a complex system can be completely designed in every detail before \nimplementation begins is fallacious.  Such an approach deprives designers of valuable \nknowledge and experience that come only from actually implementing the design.  The \nopposite extreme is also dangerous, starting implementation having done little or no \ndesign at all.  Those who start coding immediately and wing it as they go are even more \nprone to failure than those who try to design everything up front.  The truth lies between \nthese two extremes.  You should do enough design to have a fairly detailed idea of how \nthings will work, and then implement the design to discover its deficiencies.  Then, go \nback and incorporate what you\u2019ve learned into the design, and then implement some \nmore.  This process will eventually converge on a good design. \nAbstraction \nAbstraction is one of the software designer\u2019s primary tools for coping with complexity. \n \nMost programming languages and their associated libraries are meant to be general \npurpose.  They can be used to implement solutions to problems in any application domain \n(finance, retail, biology, communications, etc.).  Due to their general purpose nature, \nthese languages provide only low-level abstractions such as bit, byte, character, string, \ninteger, float, array, file, etc. that model the machines on which the software will run \nrather than the application domain of the problem being solved.  Programs written solely \nin terms of these low-level abstractions are extremely difficult to understand.  Effective \nsoftware design requires the creation of new, higher-level abstractions that map directly \nto the application domain rather than the underlying computer. \n \nIn object-oriented design, application-specific abstractions are represented as classes.  \nClasses encapsulate the state (or data) and operations (or algorithms) associated with a \nparticular higher-level application concept.  For example, the design for a word processor \nwould contain classes such as Document, Font, Table, Figure, and Printer.  \nSimilarly, the design for a web browser would contain classes such as Favorites, \nURL, Viewer, and NetworkProtocol.  Software written in terms of such higher-\nlevel abstractions is far more understandable to the human reader because it is expressed \nin terms of the application domain rather than the underlying machine. \n \nThere may also be mid-level abstractions such as ArrayList, ThreadPool, and \nConnectionManager that don\u2019t map directly the concepts of the application domain, \nbut that still play an important role in the implementation of the system.  Such mid-level \nabstractions are helpful in bridging the gap between high-level application concepts and \nlow-level facilities provided by the programming language. \n \nAs stated above, part of effective abstraction is identifying a good set of classes that \neffectively model the application domain.  Another part of effective abstraction is \ncarefully defining the interfaces (i.e., operations) supported by those classes.  While \nclasses represent the nouns of the application domain, the operations supported by classes \nrepresent the verbs.  The ability to execute a complex, domain-specific operation by \n", "page": 2, "type": "text", "section": "Page 2"}
{"text": "calling a single method on an object leads to concise, highly-readable code.  For example, \nthe following line of code might be used to print a document: \n \ndefaultPrinter.print(document); \n \nWhile only one line of code is required to print a document, it obviously requires a lot of \nlow-level work underneath to actually send the document\u2019s contents to the printer.  This \nwork must be carried out by the implementation of the print method.  How does \nprint actually print the document?  I don\u2019t know, and I don\u2019t want to know.  Unless I \nam actually implementing the print method, I prefer to ignore those details, thus \nfreeing me to think about something else.  The ability to hide all of this complexity \nbehind a simple method call demonstrates the power of abstraction: a complex idea can \nbe conveyed very concisely, thus shielding the reader from many low-level details that \nmight otherwise cloud their thinking. \nNaming \nAbstraction involves taking something that is complicated, giving it a simple name, and \nthen referring to it by its simple name.  This way, complex ideas can be conveyed very \nconcisely.  With this in mind, one of the most important tools for achieving effective \nabstraction is the identifier.  An identifier is a name that we assign to something.  We \nchoose names for classes, methods, variables, constants, source files, etc.  While selecting \na name might seem to be a relatively inconsequential thing, it is not.  The names we \nchoose for things go a long way toward determining how readable our code becomes.  \nEven if I create the right class, if I name it poorly, much of the benefit to be gained from \nabstraction has been lost.  For example, if I name the class that represents printers as \nThingy instead of Printer, I have done significant harm to the readability of my \ndesign. \n \nThe name assigned to a class, variable, or method should clearly and accurately reflect \nthe function performed by that class, variable, or method.  The name Printer implies \nthat a class represents a printer; the name calculatePayrollTax implies that a \nmethod calculates payroll taxes; the name homeAddress implies that a variable stores a \nhome address.  In contrast, the names Thingy, doStuff, and info would convey no \ninformation whatsoever to the reader.  Name selection makes a huge difference. \n \nIn general, class names should be nouns, and method names should be verbs.  There are \noccasional exceptions to this rule, but it applies in the vast majority of cases.  One \nexception to this rule relates to methods that get/set object attribute values, such as \ngetName and setName.  Depending on the style you prefer, one or both of these \nmethods could alternatively be named with a noun. \nCohesion \nAbstractions (i.e., classes and operations) should be highly cohesive. \n \n", "page": 3, "type": "text", "section": "Page 3"}
{"text": "Each class should represent one well-defined concept, and should be given a name that \nclearly reflects the concept it represents (e.g., URL).  Cohesive classes are almost always \neasy to name.  In fact, the name they should be given is often obvious, because they \nrepresent only one concept.  The operations on a class should all be highly-related to the \nconcept represented by the class.  For example, URL operations should all be highly \nrelated to storing and manipulating URLs.  Operations like getPath, getFileName, \nand resolveRelative would be appropriate.  Operations that are loosely related or \nunrelated to the concept represented by the class should be placed on some other class.  \nFor example, a URL class should not have a display method that renders the document \nreferenced by the URL on the screen.  The rendering function is only loosely related to \nthe concept of a URL, and so should be placed on a different class (e.g., FileViewer). \n \nClass operations should also be highly cohesive.  Each operation should perform one \nwell-defined task, and should be given a name that clearly reflects the task it performs \n(e.g., rebootComputer).  Cohesive operations are almost always easy to name, \nbecause they do only one thing.  If a method does a bunch of loosely related or unrelated \nthings, it will either be hard to find a good name that describes what the operation does, \nleading to inferior names like handleStuff, or the method\u2019s name will become too \nlong (e.g., sweepFloorAndDoDishesAndPayBills).   \nAbstracting All the Way \nA typical design contains many classes, some larger and more complex, others relatively \nsimple.  Some abstractions are simple enough that they can be directly represented using \none of the built-in data types provided by the programming language (e.g., integer, string, \nfloat, etc.).  For example, concepts such as \u201ctitle\u201d, \u201cpay grade\u201d, or \u201ccredit card number\u201d \ncould be directly represented using strings or integers.  The question is: Is it worth \ncreating classes to represent relatively simple abstractions such as these?  Should a \ndesigner create classes named Title, PayGrade, and CreditCardNumber, or just \ngo ahead and use strings or integers directly to represent this kind of information?  Of \ncourse, even if we create such classes, internally they will store integers or strings \nanyway.  Does it help to create such classes, or is it OK to just use the built-in types \ndirectly? \n \nCreating classes to represent relatively simple abstractions is often the better choice.  \nFollowing are some criteria to help make the decision: \n \n1) Domain Checking \u2013 Programs need to validate input values that come from end \nusers, files, or other input sources.  This is done by parsing or otherwise \ninspecting the input values to ensure they are valid and lie within acceptable \nranges.  For example, phone numbers might enter a program as string values, but \nmost strings are not valid phone numbers.  Rather than using strings to store \nphone numbers, it would be better to create a PhoneNumber class to store phone \nnumbers.  The PhoneNumber class would contain the code necessary to validate \nphone number inputs, probably in a constructor.  Input strings containing phone \nnumbers would be passed to the constructor, which would parse the string.  If the \n", "page": 4, "type": "text", "section": "Page 4"}
{"text": "string contained a valid phone number, the constructor would store it in the object \nfor later use.  If the string was not a valid phone number, an exception would be \nthrown.  Domain checking is an excellent reason to create classes to represent \ndata values that could otherwise be stored directly as built-in data types. \n \n2) Additional Operations \u2013 Creating classes to represent simple data values provides \na place to put operations that operate on those data types.  For example, URLs \ncould be stored directly as strings, but if we do so there will be no place to locate \nURL-related algorithms that may be needed as the program evolves (parsing \nURLs into their component parts, resolving relative URLs, etc.).  Creating a URL \nclass, however, would provide an excellent place to put such URL-related \noperations. \n \n3) Code Readability \u2013 Creating classes for simple abstractions can enhance a \nprogram\u2019s readability.  For example, if you see a variable of type String, you \ndon\u2019t know much about what the variable represents.  If you see a variable of type \nURL, you know a lot about what it represents (i.e., a URL).  Creating classes for \nsimple data types enhances readability because variable, parameter, and return \ntypes are much more descriptive about what kind of data they represent.  Of \ncourse, giving good names to variables and parameters will go a long way toward \ntelling the reader what kind of data they represent.  Return values, however, don\u2019t \nhave names (at least not directly). \nDecomposition \nIn addition to abstraction, another fundamental technique for dealing with complexity is \ntaking the original problem and dividing it into several smaller sub-problems.  The sub-\nproblems are smaller and hence less complex than the original, thus making them more \napproachable.  After solving each sub-problem individually, the solutions to the sub-\nproblems can be combined to create a solution to the original, larger problem.  This \napproach is frequently called \u201cdivide and conquer\u201d. \n \nAfter breaking the original problem into sub-problems, we may find that the sub-\nproblems themselves are still too complex to solve directly.  In this case, we decompose \nthe sub-problems yet again to create second-level sub-problems that are even simpler. \nSub-problems are divided into smaller and smaller parts until the smallest sub-problems \nare simple enough to solve directly, and thus require no further subdivision.  In effect, we \ncreate a tree of problems, where the original problem is at the root, and each successive \nlevel of subdivision adds another level of nodes to the tree.  The solution to each sub-\nproblem makes use of the solutions to the sub-problems below it.  This approach allows \nus to cope with the inherent complexity of the original problem in bite-size chunks. \n \nDecomposition is strongly related to abstraction.  The solution to each sub-problem is \nabstracted as a class or method.  The solution to the larger problem invokes the \nabstractions which encapsulate the sub-problem solutions.  This results in a concise \nsolution to the original problem, and allows the details of the sub-problem solutions to be \ntemporarily ignored, thus reducing the cognitive burden of solving the original problem.  \n", "page": 5, "type": "text", "section": "Page 5"}
{"text": "It is through the decomposition process that many of the necessary abstractions are \ndiscovered (or invented). \nLevels of Design \n \n \nSystem \n \n \n \nSubsystems \n \n \n \nPackages \n \n \n \n \nClasses \n \n \nRoutines \n \n \n \nDecomposition is inherently a top-down process.  At the topmost level we have the entire \nsystem.  The first level of decomposition divides the system into subsystems, each of \nwhich represents a major but somewhat independent chunk of the system\u2019s functionality.   \nFor example, the subsystems for a web browser might be Network Protocols, \nFile Viewers, History, Favorites, Printing, etc. \n \nAt the next level of decomposition, each subsystem is further subdivided into packages.  \nEach package is responsible for implementing a part of the subsystem\u2019s functionality.  \nFor example, a web browser\u2019s File Viewers subsystem might contain a separate \npackage for each different file format that the browser can display (HTML, PDF, XML, \netc.).  The package corresponding to a particular format would contain the code that \nimplements the file viewer for that format. \n \nA package is further decomposed into a collection of one or more classes that together \nimplement that package\u2019s functionality.  For example, the web browser\u2019s HTML viewer \nmight consist of a dozen different classes. \n \nThe functionality of each class is further decomposed into routines which implement the \noperations (or algorithms) of the class.  Significant algorithms are typically decomposed \n", "page": 6, "type": "text", "section": "Page 6"}
{"text": "further into multiple levels of subroutines.  Decomposition continues until the leaf-level \nsubroutines are simple enough to implement directly. \nHypo- and Hyper- Decomposition \nMany software designers, especially beginners, tend to not decompose things far enough.  \nThis might be referred to as hypo-decomposition (hypo means deficient).  An extreme \nexample of this would be implementing an entire program in a single class.  The one and \nonly class would implement all of the functionality for the entire program.  Such a class \nwould be an egregious violation of the cohesion principle discussed earlier, which states \nthat a class should \u201cdo one thing, and do it well\u201d.  One could argue that a one-class \napplication is very cohesive because the class does only one thing \u2013 it implements the \nentire application!  While there is nothing wrong (and often much right) with having a \nclass that represents the entire application (e.g., a WebBrowser class), it is wholly \ninappropriate to actually implement all of the application\u2019s functionality on that one \nclass.  Instead, the main class should delegate to other, smaller classes which implement \nvarious subsets of the program\u2019s functionality.  The main class, then, is primarily a \ndelegator (or \u201cdriver\u201d), and performs little or no actual work itself other than driving the \nother classes.  In general, if a class represents a large or complex concept, its \nfunctionality should be decomposed into one or more smaller classes that perform the \nactual work.  Often these second-level classes will also need to be decomposed further \ninto even smaller classes.  This decomposition should be repeated until the resulting \nclasses are too simple to decompose further. \n \nAt the other extreme are those who decompose things too far, which might be called \nhyper-decomposition (hyper means excessive).  This mistake is harder to make and far \nmore rare than hypo-decomposition.  When decomposing a system, one must have a \nsense of when they have decomposed far enough.  In general, we have said that a system \nhas been decomposed sufficiently when its sub-parts are simple enough to \u201cimplement \ndirectly\u201d.  Everyone has a slightly different sense of when that point has been reached.   \n \nAlthough rare, it is possible to decompose too far.  For example, a \nCreditCardNumber class might be created to represent the concept of a credit card \nnumber.  This seems like a good design choice.  But, how should a \nCreditCardNumber object store the actual credit card number internally?  A String \nseems like a natural representation for a credit card number (after it has been validated by \nthe CreditCardNumber constructor, of course).  Alternatively, it would also be \npossible to store a credit card number as an array of Digit objects.  Most people would \nsay that creating a Digit class to store individual digits in a credit card number is \noverkill, and an example of hyper-decomposition. \nSize and Length Metrics \nHow shall we know when we have decomposed far enough?  Length metrics, often \nmeasured in lines of code (LOC), can be helpful in making this determination.  A method \nthat contains a single LOC has been decomposed far enough, of course.  A method that \ncontains 500 LOC almost certainly has not been decomposed far enough.  Methods that \nhave been sufficiently decomposed are usually less than 50 LOC, and in many cases 50 \n", "page": 7, "type": "text", "section": "Page 7"}
{"text": "LOC is still too long.  Maybe 20 LOC would be a better goal.  While there is no \u201cright\u201d \nmethod length, the basic principle is that when an algorithm has been decomposed \nsufficiently, the resulting subroutines which implement the algorithm tend to be short \u2013 \nfrequently, very short. \n \nSize metrics such as the number of parameters can also be used to judge how well a \nmethod has been decomposed.  A method that requires 10 parameters is too complex.  \nThe problem might be one of insufficient decomposition. \n \nClass size can also provide a clue as to whether or not a class has been decomposed far \nenough.  A class with 50 methods has probably not been decomposed far enough.  Such a \nclass is probably doing the work of several classes.  As a result, the class is also not \ncohesive, and should be further subdivided. \n \nClasses with a lot of internal variables are also usually insufficiently decomposed.  If a \nclass contains a lot of variables (e.g., 20), there are probably smaller subgroups of those \nvariables that are closely related to each other.  These clusters of related variables will \noften suggest new classes to be created, thus further decomposing the original class.  The \noriginal class would then become a client of the newly discovered classes.   \n \nSimilarly, a class that contains 5,000 LOC has almost certainly not been decomposed far \nenough.  A class containing 2,000 LOC often requires further decomposition, but not \nalways.  Well-designed classes often contain less than 500 LOC, frequently much less \n(but, not always).  There is no \u201cright\u201d class length, but, in general, classes that have been \ndecomposed sufficiently tend to be shorter rather than longer. \nComplexity Metrics \nSometimes length metrics based on LOC measurements don\u2019t tell the whole story.  It is \npossible for two methods with the same length measured in LOC to have radically \ndifferent complexity levels.  For example, imagine two 100-line methods, the first \ncontaining only straight-line output statements (e.g., println), and the second \ncontaining complex logic with deeply nested loops and lots of branching.  While these \nmethods have the same length, their complexity levels are not even close.  Straight-line \noutput statements are readily understandable, while complex logic is far more difficult to \nunderstand.  Both methods might benefit from further decomposition, but the second one \ndemands it. \n \nIn general, methods containing complex arithmetic expressions, deeply nested structures, \nand lots of branching should be simplified by breaking up the complex routine into \nsimpler subroutines that each perform part of the original routine\u2019s work.  The original \nroutine then becomes a driver routine that delegates much of the actual work to its \nsubordinates. \n \nMany routines naturally contain multiple sections (or paragraphs) of related statements \nthat can be easily factored out into a separate subroutines.  Moving a paragraph of related \nstatements to a separate subroutine, giving the new subroutine a good name, and \n", "page": 8, "type": "text", "section": "Page 8"}
{"text": "replacing the original statements with a call to the new subroutine will do much to \nsimplify the original routine.  Consistently applying this technique of algorithm \ndecomposition will have a significant positive impact on the quality of your code. \nAlgorithm & Data Structure Selection \nA major part of software design is selecting appropriate algorithms and data structures for \nthe problem at hand.  Using an algorithm that is O(n3) on data sets that become very large \nwill almost certainly be far too slow, regardless of how well we have decomposed and \nabstracted the problem.  Similarly, storing data values as unsorted, linear lists will be far \ntoo slow if the data set is large and needs to be searched frequently.  Selecting (or \ninventing) algorithms and data structures with good performance characteristics \n(including running time and memory consumption) for the intended application is a \nfundamental design skill.  No amount of decomposition or abstraction will hide a \nfundamentally flawed selection of algorithm or data structure. \nMinimize Dependencies (or, Low Coupling) \nLarge systems contain many classes.  As a system is decomposed into its constituent \nclasses, it is important to keep each class as independent as possible from the other \nclasses in the system.  Classes A and B depend on each other if: \n \n1) Class A invokes a method on class B \n2) Class A accesses the internal state of class B \n3) Class A inherits from class B \n4) Class A has a method parameter of class B \n5) Class A and Class B both access the same global data structure or file \n6) Etc. \n \nMinimizing the number of communication channels and interactions between different \nclasses has several benefits: \n \n1) A class with few dependencies on other classes is generally easier to understand \nthan a class with many dependencies on other classes (i.e., dependencies increase \na class\u2019s complexity) \n2) A class with few dependencies on other classes is less prone to ripple effects \ncaused by changes or defects in other classes (i.e., dependencies make a system \nharder to modify and debug). \n3) A class with few dependencies on other classes is easier to reuse in a different \nprogram than a class with many dependencies (i.e., dependencies discourage \nreuse). \n \nImagine a system in which every class depends on every other class.  Every time any \nclass is changed, we must consider the potential impact on all other classes (very \nconfusing, indeed).  Similarly, when a class has a defect, the defect will potentially \nimpact the behavior of all other classes, thus making it difficult to track down where the \ndefect actually resides (again, very confusing). \n \n", "page": 9, "type": "text", "section": "Page 9"}
{"text": "At the other extreme, imagine a system where there are no dependencies between classes \n(i.e., each class is an island unto itself).  In this case, the software doesn\u2019t do anything.  \nMaking a program perform useful functions requires a certain level of communication \n(and therefore dependency) between the classes in the system.  The goal is not to remove \nall dependencies, but rather to minimize the number and strength of dependencies. \n \nWhen two classes must interact, it is desirable to keep the interaction as simple and \nstraightforward as possible.  The ideal form of interaction between two classes is through \nsimple method calls.  A method call is simple if it has a good name and the data passed \nthrough the parameter list and return value is easy to understand.  Simple method calls \nhave the advantage of being direct and obvious in the code.  Other more indirect forms of \ncommunication between classes, such as accessing the same global data structure, make \nthe dependency less explicit and harder to detect and comprehend.  To the extent \npossible, interactions between classes should be through explicit, well-defined method \ninterfaces. \nSeparation of Interface and Implementation \nOne important technique for minimizing dependencies between classes is maintaining a \nstrict separation between a class\u2019s public interface and its internal implementation.  A \nclass\u2019s public interface consists of the operations (or methods) through which clients can \naccess its services.  In order to use a class, a client needs only to understand the class\u2019s \npublic interface.  The details of how the public interface is implemented internally are \nincidental to the client, and should not be accessed or relied upon by the client in any \nway.  The code that implements the public interface, including all variables and \nsubroutines that support that code, should not be accessed by clients.  By relying only on \nthe details of the public interface, a class\u2019s internal implementation can be changed \nwithout affecting (i.e., breaking) its clients.  Only changes to the public interface itself \naffect the clients.  The strict separation of interface and implementation goes a long way \ntoward minimizing dependencies between classes. \nInformation Hiding \nBecause the separation of interface and implementation is so central to good software \ndesign, programming languages often provide features to help enforce this separation.  \nSome languages physically separate a class\u2019s public interface and internal \nimplementation into separate source files.  Other languages require the designer to \ndeclare all class features (variables and methods) as \u201cpublic\u201d, \u201cprivate\u201d, or \u201cprotected\u201d, \nthus preventing clients from accessing private details.  Such language features encourage \ndesigners to hide as much information as possible from clients, thus reducing \nopportunities for dependency between classes. \n \nA class\u2019s public interface should be as small (or \u201cthin\u201d) as possible, ideally including \nonly a small number of methods.  Each public method\u2019s parameters should be as simple \nas possible.  All internal variables should be hidden, and only methods that are directly \ninvoked by clients should be made public. \n \n", "page": 10, "type": "text", "section": "Page 10"}
{"text": "This advice applies even to inheritance relationships.  By making variables \u201cprotected\u201d, it \nis easy for a superclass to directly expose its internal variables to its subclasses.  This \nmakes the subclasses highly dependent on the internal details of the superclass.  As \nalways, this makes it difficult to change the superclass implementation without breaking \nthe subclasses.  A designer may choose to make superclasses and subclasses highly \ncoupled in this manner, but the downsides of doing so should be considered when making \nthis decision.  Another approach would be to define the superclass/subclass interface in \nterms of \u201cprotected\u201d methods only (i.e., no \u201cprotected\u201d variables), thus reducing the level \nof dependency between superclass and subclass. \n \nDesigners should also be careful to ensure that internal implementation details do not \n\u201cleak out\u201d of a class.  For example, a method that performs a search algorithm might be \nnamed binarySearch.  Unfortunately, the name binarySearch reveals the \nmethod\u2019s internal implementation.  This choice of name forever binds the method to use \nthe binary search algorithm as its implementation.  Alternatively, naming the method \nsearch would preserve the designer\u2019s freedom to vary the internal algorithm without \nviolating the client contract. \n \nSimilarly, a grade-keeping program might represent the notion of a class roll with a class \nnamed StudentLinkedList.  However, doing so betrays the fact that the class uses a \nlinked list as the internal data structure for storing a sequence of students.  A better \nchoice would be to name the class ClassRoll, thus hiding all details of how students \nare actually stored internally, and preserving freedom to change that representation at \nwill. \n \nThere are times, however, when a class or method is inherently tied to a particular \nimplementation.  In such cases, it is appropriate to name classes or methods in terms of \ntheir internal details.  For example, a class whose sole purpose is to implement a hash \ntable could appropriately be named HashTable because its implementation is an \ninherent part of its existence.  A hash table will always be a hash table, and that will \nnever change.  However, clients of the HashTable class should not reveal their internal \nuse of HashTable unless that choice is inherent and will never change. \nAvoid Code Duplication \nAnother core principle of good software design is that code duplication should be \nstrenuously avoided.  Frequently, programs will contain duplicated sections of code, or \nsections of code that are very similar.  For example, searching an array for a particular \nvalue is a common operation, and this code could easily be duplicated many times \nthroughout a program.  Similarly, formatting of date/time values for end-user display is a \ncommon operation that is often be duplicated throughout a program.  \n \nThe disadvantages associated with duplication are fairly obvious: \n \n1) If the duplicated code needs to be modified, we must remember to change all N \ncopies, and do so correctly. \n2) If the duplicated code contains a bug, the bug will the replicated N times. \n", "page": 11, "type": "text", "section": "Page 11"}
{"text": "3) Duplication makes the program longer, thus decreasing its maintainability. \n \nIf the same or similar code appears in N places, the obvious solution is to isolate the \nduplicated code in one place, and then have all N clients invoke the shared copy.  If all N \ncopies are in the same class, the duplicated code can be factored out into a private method \non that class.  If the N copies are in different classes, the shared copy could be placed on \none of the client classes, or placed on some other (possibly new) class that provides a \nlogical home for the shared code.  Another solution would be to place the shared code in \na superclass, and then make each client class a subclass of the superclass. \n \nIf the duplicated code is similar but not identical, it might be possible to create a generic \nversion that will serve the needs of all clients.  If the implementation language provides \ngeneric types (e.g., C++ templates), a generic type or subroutine will often be a good \nimplementation choice for the shared code. \nDesign Principles Summary \n1. Abstraction \na. Naming \nb. Cohesion \nc. Abstracting All the Way \n2. Decomposition \na. Levels of Design (System, Subsystem, Package, Class, Routine) \nb. Hypo- and Hyper- Decomposition \nc. Size and Length Metrics \nd. Complexity Metrics \n3. Algorithm & Data Structure Selection \n4. Minimize Dependencies (or, Low Coupling) \na. Separation of Interface and Implementation \nb. Information Hiding \n5. Avoid Code Duplication \n \n", "page": 12, "type": "text", "section": "Page 12"}
