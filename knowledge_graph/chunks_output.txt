
================================================================================
SOURCE: 12-design-principles.pdf
TOTAL CHUNKS: 5
================================================================================

--- Chunk 0 ---
Tokens: 367
Type: sentence-based
Text:
Design Principles 1 Previous Code Convention Discussions  Style  What does the code look like? Is it consistent, scalable, and maintainable? Appearance, format, readability  Naming  How are we describing the identifiers in our code? Are they understandable? Do the names reflect purposeresponsibility? Program comprehension 2 SOLID Principles for Object-Oriented Design  Five basic principles (guidelines) for Object-Oriented Design (OOD)  Results in systems that are:  Easy to maintain  Easy to extend  SOLID is a guide for:  Creating designs from scratch  Improving existing designs 3 SOILD Principles  Single Responsibility Principle (SRP)  Openclosed Principle (OCP) Liskov Substitution Principle (LSP) Interface Segregation Principle (ISP) Dependency Inversion Principle (DIP) 4 Single Responsibility Principle  Every class should have A SINGLE RESPONSIBILITY  The responsibility of a class drives its need to change  Responsibility should be entirely encapsulated by the class  All functionality of the class should focus on that single responsibility  Why? More cohesive  Easier to understand  Easier to maintain 5 SRP Analysis  A basic method for determining if a method belongs with a given class. A rough approximation  Need to apply context about the domain and the abstraction The _class name _method name_ itself. 6 7 8 9 SRP Example 10 SRP Example - Violation 11 SRP Example - Compliant 12 OpenClosed Principle  Software entities (classes, function, etc.)

--- Chunk 1 ---
Tokens: 343
Type: sentence-based
Text:
6 7 8 9 SRP Example 10 SRP Example - Violation 11 SRP Example - Compliant 12 OpenClosed Principle  Software entities (classes, function, etc.) should be open for extension but closed for modification  Closed - as can be compiled, stored in a library, and used by client classes  Open - as any new class can inherit and add new features  Why? Client code dependent on base (closed) class unaffected  Less testing  Less code to review 13 Meyers OpenClosed Principle  Implementation is extended through inheritance  Open means available for extension (generalizationinheritance)  Closed to avoid changes to the original class  New functionality by adding a new class, not changing current ones  Results in tight coupling between base and derived classes 14 Polymorphic OpenClosed Principle  Abstract base class and multiple implementations that we can substitute for each other  Base design on abstract base classes  Focus on sharing the interface, not the implementation  Code to an interface, not an implementation  Reuse implementation via delegation abstract Parser parse() ParserImplementation parse() ParserRubyImplementation parse() 15 Liskov Substitution Principle  An Object in a program should be replaceable with an instance of subtypes without affecting program correctness  Objects of subtypes should behave like those of supertypes if used via supertype methods.

--- Chunk 2 ---
Tokens: 354
Type: sentence-based
Text:
Client code dependent on base (closed) class unaffected  Less testing  Less code to review 13 Meyers OpenClosed Principle  Implementation is extended through inheritance  Open means available for extension (generalizationinheritance)  Closed to avoid changes to the original class  New functionality by adding a new class, not changing current ones  Results in tight coupling between base and derived classes 14 Polymorphic OpenClosed Principle  Abstract base class and multiple implementations that we can substitute for each other  Base design on abstract base classes  Focus on sharing the interface, not the implementation  Code to an interface, not an implementation  Reuse implementation via delegation abstract Parser parse() ParserImplementation parse() ParserRubyImplementation parse() 15 Liskov Substitution Principle  An Object in a program should be replaceable with an instance of subtypes without affecting program correctness  Objects of subtypes should behave like those of supertypes if used via supertype methods. Preconditions cannot be strengthened in a subtype  Postconditions cannot be weakened in a subtype  Invariants of supertype must be preserved in subtype  History constraint - new methods in subtype cannot introduce state changes in a way that is not permissible in the supertype  Why? Knowledgeassumptions about base class apply to the subclass  Easier to understand  Easier to maintain.

--- Chunk 3 ---
Tokens: 260
Type: sentence-based
Text:
Knowledgeassumptions about base class apply to the subclass  Easier to understand  Easier to maintain. 16 LSP Example 17 LSP Example - Violation 18 LSP Example 19 LSP Example 20 21 Interface Segregation Principle  A client should NOT be forced to depend on methods it does not use  Having many client-specific interfaces is better than one general- purpose interface  Why? More cohesive  Lower coupling  Easier to understand  Easier to maintain 22 ISP Example  How can we make this better? 23 ISP Example  How can we make this better? Bird name: string FlyingBird fly() Ostrich Duck CREATED WITH YUML 24 Dependency Inversion Principle  Depend upon abstractions, not concretions (specific implementations of an abstraction)  Abstractions should not depend on details, but details on abstractions  High-level modules are independent and should not depend on low- level modules  Why? Lower coupling  Reuse  Easier to test  Easer to understand  Easier to maintain 25 DIP Example 26 DIP Example  Can We Do Better? 27 DIP Example  Can We Do Better?

--- Chunk 4 ---
Tokens: 310
Type: sentence-based
Text:
27 DIP Example  Can We Do Better? https:medium.comkedren.villenasimplifying-dependency-inversion-principle-dip-59228122649a Lamp isOn: boolean powerSource: OutletInterface turnOn() turnOff() changeOutlet(OutletInterface) OutletInterface DormOutlet GarageOutlet ClassroomOutlet CREATED WITH YUML 28 29 Other Helpful Principles  DRY- Dont Repeat Yourself  Use functional decomposition or abstractions to reduce redundancies  YAGNI  You Arent Gonna Need It  Dont try to build out features now that you think your software MIGHT need later  Software development is too volatile for that, focus on what is needed now and the maintainability of your design  Occams RazorKISS  Keep it simple  Dont introduce unnecessary complexity or overblown designs  GRASP  General Responsibility Assignment Software Patterns  Design patterns that can help with your software designimplementation  More on design patterns later 30 Conclusion  Meant to be applied together  Make it more likely that the system is easy to maintain and extend over time  SOLID principles are guidelines  Do not guarantee success  Can be misused  Use in conjunction with other principles  Dont chase perfection  Design based on your needs  Good enough design gets software delivered 31

================================================================================
SOURCE: a philosphy of SD.pdf
TOTAL CHUNKS: 258
================================================================================

--- Chunk 0 ---
Tokens: 391
Type: sentence-based
Text:
APhilosophyofSoftwareDesign JohnOusterhout StanfordUniversity APhilosophyofSoftwareDesign byJohnOusterhout Copyright2018JohnK.Ousterhout. Allrightsreserved.Nopartofthisbookmaybereproduced,inanyformorbyanymeans,without permissioninwritingfromtheauthor. PublishedbyYaknyamPress,PaloAlto,CA. CoverdesignbyPeteNguyenandShirinOreizy(www.hellonextstep.com). PrintingHistory: April2018:FirstEdition(v1.0) November2018:FirstEdition(v1.01) ISBN978-1-7321022-0-0 Digitalbook(s)(epubandmobi)producedbyBooknook.biz. Contents Preface 1Introduction 1.1Howtousethisbook 2TheNatureofComplexity 2.1Complexitydefined 2.2Symptomsofcomplexity 2.3Causesofcomplexity 2.4Complexityisincremental 2.5Conclusion 3WorkingCodeIsntEnough 3.1Tacticalprogramming 3.2Strategicprogramming 3.3Howmuchtoinvest? 3.4Startupsandinvestment 3.5Conclusion 4ModulesShouldBeDeep 4.1Modulardesign 4.2Whatsinaninterface? 4.3Abstractions 4.4Deepmodules 4.5Shallowmodules 4.6Classitis 4.7Examples:JavaandUnixIO 4.8Conclusion 5InformationHiding(andLeakage) 5.1Informationhiding 5.2Informationleakage 5.3Temporaldecomposition 5.4Example:HTTPserver 5.5Example:toomanyclasses 5.6Example:HTTPparameterhandling 5.7Example:defaultsinHTTPresponses 5.8Informationhidingwithinaclass 5.9Takingittoofar 5.10Conclusion 6General-PurposeModulesareDeeper 6.1Makeclassessomewhatgeneral-purpose 6.2Example:storingtextforaneditor 6.3Amoregeneral-purposeAPI 6.4Generalityleadstobetterinformationhiding 6.5Questionstoaskyourself 6.6Conclusion 7DifferentLayer,DifferentAbstraction 7.1Pass-throughmethods 7.2WhenisinterfaceduplicationOK?

--- Chunk 1 ---
Tokens: 371
Type: sentence-based
Text:
4.3Abstractions 4.4Deepmodules 4.5Shallowmodules 4.6Classitis 4.7Examples:JavaandUnixIO 4.8Conclusion 5InformationHiding(andLeakage) 5.1Informationhiding 5.2Informationleakage 5.3Temporaldecomposition 5.4Example:HTTPserver 5.5Example:toomanyclasses 5.6Example:HTTPparameterhandling 5.7Example:defaultsinHTTPresponses 5.8Informationhidingwithinaclass 5.9Takingittoofar 5.10Conclusion 6General-PurposeModulesareDeeper 6.1Makeclassessomewhatgeneral-purpose 6.2Example:storingtextforaneditor 6.3Amoregeneral-purposeAPI 6.4Generalityleadstobetterinformationhiding 6.5Questionstoaskyourself 6.6Conclusion 7DifferentLayer,DifferentAbstraction 7.1Pass-throughmethods 7.2WhenisinterfaceduplicationOK? 7.3Decorators 7.4Interfaceversusimplementation 7.5Pass-throughvariables 7.6Conclusion 8PullComplexityDownwards 8.1Example:editortextclass 8.2Example:configurationparameters 8.3Takingittoofar 8.4Conclusion 9BetterTogetherOrBetterApart? 9.1Bringtogetherifinformationisshared 9.2Bringtogetherifitwillsimplifytheinterface 9.3Bringtogethertoeliminateduplication 9.4Separategeneral-purposeandspecial-purposecode 9.5Example:insertioncursorandselection 9.6Example:separateclassforlogging 9.7Example:editorundomechanism 9.8Splittingandjoiningmethods 9.9Conclusion 10DefineErrorsOutOfExistence 10.1Whyexceptionsaddcomplexity 10.2Toomanyexceptions 10.3Defineerrorsoutofexistence 10.4Example:filedeletioninWindows 10.5Example:Javasubstringmethod 10.6Maskexceptions 10.7Exceptionaggregation 10.8Justcrash?

--- Chunk 2 ---
Tokens: 383
Type: sentence-based
Text:
9.1Bringtogetherifinformationisshared 9.2Bringtogetherifitwillsimplifytheinterface 9.3Bringtogethertoeliminateduplication 9.4Separategeneral-purposeandspecial-purposecode 9.5Example:insertioncursorandselection 9.6Example:separateclassforlogging 9.7Example:editorundomechanism 9.8Splittingandjoiningmethods 9.9Conclusion 10DefineErrorsOutOfExistence 10.1Whyexceptionsaddcomplexity 10.2Toomanyexceptions 10.3Defineerrorsoutofexistence 10.4Example:filedeletioninWindows 10.5Example:Javasubstringmethod 10.6Maskexceptions 10.7Exceptionaggregation 10.8Justcrash? 10.9Designspecialcasesoutofexistence 10.10Takingittoofar 10.11Conclusion 11DesignitTwice 12WhyWriteComments?TheFourExcuses 12.1Goodcodeisself-documenting 12.2Idonthavetimetowritecomments 12.3Commentsgetoutofdateandbecomemisleading 12.4AllthecommentsIhaveseenareworthless 12.5Benefitsofwell-writtencomments 13CommentsShouldDescribeThingsthatArentObviousfromtheCode 13.1Pickconventions 13.2Dontrepeatthecode 13.3Lower-levelcommentsaddprecision 13.4Higher-levelcommentsenhanceintuition 13.5Interfacedocumentation 13.6Implementationcomments:whatandwhy,nothow 13.7Cross-moduledesigndecisions 13.8Conclusion 13.9AnswerstoquestionsfromSection13.5 14ChoosingNames 14.1Example:badnamescausebugs 14.2Createanimage 14.3Namesshouldbeprecise 14.4Usenamesconsistently 14.5Adifferentopinion:Gostyleguide 14.6Conclusion 15WriteTheCommentsFirst 15.1Delayedcommentsarebadcomments 15.2Writethecommentsfirst 15.3Commentsareadesigntool 15.4Earlycommentsarefuncomments 15.5Areearlycommentsexpensive?

--- Chunk 3 ---
Tokens: 516
Type: sentence-based
Text:
10.9Designspecialcasesoutofexistence 10.10Takingittoofar 10.11Conclusion 11DesignitTwice 12WhyWriteComments?TheFourExcuses 12.1Goodcodeisself-documenting 12.2Idonthavetimetowritecomments 12.3Commentsgetoutofdateandbecomemisleading 12.4AllthecommentsIhaveseenareworthless 12.5Benefitsofwell-writtencomments 13CommentsShouldDescribeThingsthatArentObviousfromtheCode 13.1Pickconventions 13.2Dontrepeatthecode 13.3Lower-levelcommentsaddprecision 13.4Higher-levelcommentsenhanceintuition 13.5Interfacedocumentation 13.6Implementationcomments:whatandwhy,nothow 13.7Cross-moduledesigndecisions 13.8Conclusion 13.9AnswerstoquestionsfromSection13.5 14ChoosingNames 14.1Example:badnamescausebugs 14.2Createanimage 14.3Namesshouldbeprecise 14.4Usenamesconsistently 14.5Adifferentopinion:Gostyleguide 14.6Conclusion 15WriteTheCommentsFirst 15.1Delayedcommentsarebadcomments 15.2Writethecommentsfirst 15.3Commentsareadesigntool 15.4Earlycommentsarefuncomments 15.5Areearlycommentsexpensive? 15.6Conclusion 16ModifyingExistingCode 16.1Staystrategic 16.2Maintainingcomments:keepthecommentsnearthecode 16.3Commentsbelonginthecode,notthecommitlog 16.4Maintainingcomments:avoidduplication 16.5Maintainingcomments:checkthediffs 16.6Higher-levelcommentsareeasiertomaintain 17Consistency 17.1Examplesofconsistency 17.2Ensuringconsistency 17.3Takingittoofar 17.4Conclusion 18CodeShouldbeObvious 18.1Thingsthatmakecodemoreobvious 18.2Thingsthatmakecodelessobvious 18.3Conclusion 19SoftwareTrends 19.1Object-orientedprogrammingandinheritance 19.2Agiledevelopment 19.3Unittests 19.4Test-drivendevelopment 19.5Designpatterns 19.6Gettersandsetters 19.7Conclusion 20DesigningforPerformance 20.1Howtothinkaboutperformance 20.2Measurebeforemodifying 20.3Designaroundthecriticalpath 20.4Anexample:RAMCloudBuffers 20.5Conclusion 21Conclusion Index SummaryofDesignPrinciples SummaryofRedFlags Preface Peoplehavebeenwritingprogramsforelectroniccomputersformorethan80 years, but there has been surprisingly little conversation about how to design those programs or what good programs should look like.

--- Chunk 4 ---
Tokens: 391
Type: sentence-based
Text:
15.6Conclusion 16ModifyingExistingCode 16.1Staystrategic 16.2Maintainingcomments:keepthecommentsnearthecode 16.3Commentsbelonginthecode,notthecommitlog 16.4Maintainingcomments:avoidduplication 16.5Maintainingcomments:checkthediffs 16.6Higher-levelcommentsareeasiertomaintain 17Consistency 17.1Examplesofconsistency 17.2Ensuringconsistency 17.3Takingittoofar 17.4Conclusion 18CodeShouldbeObvious 18.1Thingsthatmakecodemoreobvious 18.2Thingsthatmakecodelessobvious 18.3Conclusion 19SoftwareTrends 19.1Object-orientedprogrammingandinheritance 19.2Agiledevelopment 19.3Unittests 19.4Test-drivendevelopment 19.5Designpatterns 19.6Gettersandsetters 19.7Conclusion 20DesigningforPerformance 20.1Howtothinkaboutperformance 20.2Measurebeforemodifying 20.3Designaroundthecriticalpath 20.4Anexample:RAMCloudBuffers 20.5Conclusion 21Conclusion Index SummaryofDesignPrinciples SummaryofRedFlags Preface Peoplehavebeenwritingprogramsforelectroniccomputersformorethan80 years, but there has been surprisingly little conversation about how to design those programs or what good programs should look like. There has been considerable discussion about software development processes such as agile development and about development tools such as debuggers, version control systems, and test coverage tools. There has also been extensive analysis of programming techniques such as object-oriented programming and functional programming,and ofdesignpatterns andalgorithms. All of these discussions have been valuable, but the core problem of software design is still largely untouched.

--- Chunk 5 ---
Tokens: 388
Type: sentence-based
Text:
All of these discussions have been valuable, but the core problem of software design is still largely untouched. David Parnas classic paper On the Criteria to be used in DecomposingSystemsintoModulesappearedin1971,butthestateoftheartin softwaredesignhasnotprogressedmuchbeyondthatpaperintheensuing45 years. The most fundamental problem in computer science is problem decomposition:howtotakeacomplexproblemanddivideitupintopiecesthat canbesolvedindependently.Problemdecompositionisthecentraldesigntask thatprogrammersfaceeveryday,andyet,otherthantheworkdescribedhere,I have not been able to identify a single class in any university where problem decomposition is a central topic. We teach for loops and object-oriented programming,butnotsoftwaredesign. In addition, there is a huge variation in quality and productivity among programmers,butwehavemadelittleattempttounderstandwhatmakesthebest programmerssomuchbetterortoteachthoseskillsinourclasses.Ihavetalked withseveralpeopleIconsidertobegreatprogrammers,butmostofthemhad difficultyarticulatingspecifictechniquesthatgivethemtheiradvantage.Many peopleassumethatsoftwaredesignskillisaninnatetalentthatcannotbetaught. However,thereisquiteabitofscientificevidencethatoutstandingperformance inmanyfieldsisrelatedmoretohigh-qualitypracticethaninnateability(see,for example,TalentisOverratedbyGeoffColvin). For many years these issues have perplexed and frustrated me. I have wonderedwhethersoftwaredesigncanbetaught,andIhavehypothesizedthat design skill is what separates great programmers from average ones.

--- Chunk 6 ---
Tokens: 387
Type: sentence-based
Text:
I have wonderedwhethersoftwaredesigncanbetaught,andIhavehypothesizedthat design skill is what separates great programmers from average ones. I finally decidedthattheonlywaytoanswerthesequestionswastoattempttoteacha courseonsoftwaredesign.TheresultisCS190atStanfordUniversity.Inthis class I put forth a set of principles of software design. Students then work throughaseriesofprojectstoassimilateandpracticetheprinciples.Theclassis taughtinafashionsimilartoatraditionalEnglishwritingclass.InanEnglish class,studentsuseaniterativeprocesswheretheywriteadraft,getfeedback,and thenrewritetomakeimprovements.InCS190,studentsdevelopasubstantial pieceofsoftwarefromscratch.Wethengothroughextensivecodereviewsto identifydesignproblems,andstudentsrevisetheirprojectstofixtheproblems. Thisallowsstudentstoseehowtheircodecanbeimprovedbyapplyingdesign principles. I have now taught the software design class three times, and this book is basedonthedesignprinciplesthatemergedfromtheclass.Theprinciplesare fairly high level and border on the philosophical (Define errors out of existence), so it is hard for students to understand the ideas in the abstract. Studentslearnbestbywritingcode,makingmistakes,andthenseeinghowtheir mistakesandthesubsequentfixesrelatetotheprinciples. Atthispointyoumaywellbewondering:whatmakesmethinkIknowall theanswersaboutsoftwaredesign?Tobehonest,Idont.Therewerenoclasses onsoftwaredesignwhenIlearnedtoprogram,andIneverhadamentortoteach me design principles. At the time I learned to program, code reviews were virtually nonexistent.

--- Chunk 7 ---
Tokens: 370
Type: sentence-based
Text:
At the time I learned to program, code reviews were virtually nonexistent. My ideas about software design come from personal experience writing and reading code. Over my career I have written about 250,000 lines of code in a variety of languages. Ive worked on teams that createdthreeoperatingsystemsfromscratch,multiplefileandstoragesystems, infrastructure tools such as debuggers, build systems, and GUI toolkits, a scriptinglanguage,andinteractiveeditorsfortext,drawings,presentations,and integrated circuits. Along the way Ive experienced firsthand the problems of largesystemsandexperimentedwithvariousdesigntechniques.Inaddition,Ive readaconsiderableamountofcodewrittenbyotherpeople,whichhasexposed metoavarietyofapproaches,bothgoodandbad. Outofallofthisexperience,Ivetriedtoextractcommonthreads,bothabout mistakes to avoid and techniques to use. This book is a reflection of my experiences: every problem described here is one that I have experienced personally,andeverysuggestedtechniqueisonethatIhaveusedsuccessfullyin myowncoding. Idontexpectthisbooktobethefinalwordonsoftwaredesign;Imsure therearevaluabletechniquesthatIvemissed,andsomeofmysuggestionsmay turnouttobebadideasinthelongrun.However,Ihopethatthebookwillstarta conversationaboutsoftwaredesign.Comparetheideasinthisbookwithyour ownexperiencesanddecideforyourselfwhethertheapproachesdescribedhere reallydoreducesoftwarecomplexity.Thisbookisanopinionpiece,sosome readers will disagree with some of my suggestions.

--- Chunk 8 ---
Tokens: 389
Type: sentence-based
Text:
Idontexpectthisbooktobethefinalwordonsoftwaredesign;Imsure therearevaluabletechniquesthatIvemissed,andsomeofmysuggestionsmay turnouttobebadideasinthelongrun.However,Ihopethatthebookwillstarta conversationaboutsoftwaredesign.Comparetheideasinthisbookwithyour ownexperiencesanddecideforyourselfwhethertheapproachesdescribedhere reallydoreducesoftwarecomplexity.Thisbookisanopinionpiece,sosome readers will disagree with some of my suggestions. If you do disagree, try to understandwhy.Iminterestedinhearingaboutthingsthatworkforyou,things thatdontwork,andanyotherideasyoumayhaveaboutsoftwaredesign.Ihope that the ensuing conversations will improve our collective understanding of softwaredesign.IwillincorporatewhatIlearninfutureeditionsofthisbook. Thebestwaytocommunicatewithmeaboutthebookistosendemailtothe followingaddress: software-design-bookgooglegroups.com Im interested in hearing specific feedback about the book, such as bugs or suggestionsforimprovement,aswellasgeneralthoughtsandexperiencesrelated tosoftwaredesign.ImparticularlyinterestedincompellingexamplesthatIcan use in future editions of the book. The best examples illustrate an important designprincipleandaresimpleenoughtoexplaininaparagraphortwo.Ifyou would like to see what other people are saying on the email address and participateindiscussions,youcanjointheGoogleGroupsoftware-design-book. Ifforsomereasonthesoftware-design-bookGoogleGroupshoulddisappear in the future, search on the Web for my home page; it will contain updated instructions for how to communicate about the book.

--- Chunk 9 ---
Tokens: 391
Type: sentence-based
Text:
Ifforsomereasonthesoftware-design-bookGoogleGroupshoulddisappear in the future, search on the Web for my home page; it will contain updated instructions for how to communicate about the book. Please dont send book- relatedemailtomypersonalemailaddress. Irecommendthatyoutakethesuggestionsinthisbookwithagrainofsalt. The overall goal is to reduce complexity; this is more important than any particularprincipleorideayoureadhere.Ifyoutryanideafromthisbookand findthatitdoesntactuallyreducecomplexity,thendontfeelobligatedtokeep usingit(but,doletmeknowaboutyourexperience;Idliketogetfeedbackon whatworksandwhatdoesnt). Manypeoplehaveofferedcriticismsormadesuggestionsthatimprovedthe Manypeoplehaveofferedcriticismsormadesuggestionsthatimprovedthe qualityofthebook.Thefollowingpeopleofferedhelpfulcommentsonvarious drafts of the book: Jeff Dean, Sanjay Ghemawat, John Hartman, Brian Kernighan,JamesKoppel,AmyOusterhout,KayOusterhout,RobPike,Partha Ranganathan,KeithSchwartz,andAlexSnaps.ChristosKozyrakissuggestedthe termsdeepandshallowforclassesandinterfaces,replacingpreviousterms thick and thin, which were somewhat ambiguous. I am indebted to the studentsinCS190;theprocessofreadingtheircodeanddiscussingitwiththem hashelpedtocrystallizemythoughtsaboutdesign. Chapter1 Introduction (ItsAllAboutComplexity) Writing computer software is one of the purest creative activities in the history of the human race. Programmers arent bound by practical limitations suchasthelawsofphysics;wecancreateexcitingvirtualworldswithbehaviors that could never exist in the real world.

--- Chunk 10 ---
Tokens: 375
Type: sentence-based
Text:
Programmers arent bound by practical limitations suchasthelawsofphysics;wecancreateexcitingvirtualworldswithbehaviors that could never exist in the real world. Programming doesnt require great physicalskillorcoordination,likeballetorbasketball.Allprogrammingrequires isacreativemindandtheabilitytoorganizeyourthoughts.Ifyoucanvisualizea system,youcanprobablyimplementitinacomputerprogram. Thismeansthatthegreatestlimitationinwritingsoftwareisourabilityto understandthesystemswearecreating.Asaprogramevolvesandacquiresmore features, it becomes complicated, with subtle dependencies between its components. Over time, complexity accumulates, and it becomes harder and harderforprogrammerstokeepalloftherelevantfactorsintheirmindsasthey modifythesystem.Thisslowsdowndevelopmentandleadstobugs,whichslow developmentevenmoreandaddtoitscost.Complexityincreasesinevitablyover thelifeofanyprogram.Thelargertheprogram,andthemorepeoplethatwork onit,themoredifficultitistomanagecomplexity. Gooddevelopmenttoolscanhelpusdealwithcomplexity,andmanygreat toolshavebeencreatedoverthelastseveraldecades.Butthereisalimittowhat wecandowithtoolsalone.Ifwewanttomakeiteasiertowritesoftware,sothat wecanbuildmorepowerfulsystemsmorecheaply,wemustfindwaystomake softwaresimpler.Complexitywillstillincreaseovertime,inspiteofourbest efforts,butsimplerdesignsallowustobuildlargerandmorepowerfulsystems beforecomplexitybecomesoverwhelming. Therearetwogeneralapproachestofightingcomplexity,bothofwhichwill be discussed in this book.

--- Chunk 11 ---
Tokens: 390
Type: sentence-based
Text:
Therearetwogeneralapproachestofightingcomplexity,bothofwhichwill be discussed in this book. The first approach is to eliminate complexity by makingcodesimplerandmoreobvious.Forexample,complexitycanbereduced byeliminatingspecialcasesorusingidentifiersinaconsistentfashion. Thesecondapproachtocomplexityistoencapsulateit,sothatprogrammers canworkonasystemwithoutbeingexposedtoallofitscomplexityatonce.This approach is called modular design. In modular design, a software system is divided up into modules, such as classes in an object-oriented language. The modules are designed to be relatively independent of each other, so that a programmercanworkononemodulewithouthavingtounderstandthedetailsof othermodules. Because software is so malleable, software design is a continuous process thatspanstheentirelifecycleofasoftwaresystem;thismakessoftwaredesign differentfromthedesignofphysicalsystemssuchasbuildings,ships,orbridges. However,softwaredesignhasnotalwaysbeenviewedthisway.Formuchofthe historyofprogramming,designwasconcentratedatthebeginningofaproject, asitisinotherengineeringdisciplines.Theextremeofthisapproachiscalled thewaterfallmodel,inwhichaprojectisdividedintodiscretephasessuchas requirements definition, design, coding, testing, and maintenance. In the waterfall model, each phase completes before the next phase starts; in many cases different people are responsible for each phase. The entire system is designedatonce,duringthedesignphase.Thedesignisfrozenattheendofthis phase,andtheroleofthesubsequentphasesistofleshoutandimplementthat design.

--- Chunk 12 ---
Tokens: 362
Type: sentence-based
Text:
The entire system is designedatonce,duringthedesignphase.Thedesignisfrozenattheendofthis phase,andtheroleofthesubsequentphasesistofleshoutandimplementthat design. Unfortunately,thewaterfallmodelrarelyworkswellforsoftware.Software systemsareintrinsicallymorecomplexthanphysicalsystems;itisntpossibleto visualizethedesignforalargesoftwaresystemwellenoughtounderstandallof itsimplicationsbeforebuildinganything.Asaresult,theinitialdesignwillhave manyproblems.Theproblemsdonotbecomeapparentuntilimplementationis wellunderway.However,thewaterfallmodelisnotstructuredtoaccommodate majordesignchangesatthispoint(forexample,thedesignersmayhavemoved ontootherprojects).Thus,developerstrytopatcharoundtheproblemswithout changingtheoveralldesign.Thisresultsinanexplosionofcomplexity. Because of these issues, most software development projects today use an incremental approach such as agile development, in which the initial design focusesonasmallsubsetoftheoverallfunctionality.Thissubsetisdesigned, implemented, and then evaluated. Problems with the original design are discoveredandcorrected,thenafewmorefeaturesaredesigned,implemented andevaluated.Eachiterationexposesproblemswiththeexistingdesign,which arefixedbeforethenextsetoffeaturesisdesigned.Byspreadingoutthedesign inthisway,problemswiththeinitialdesigncanbefixedwhilethesystemisstill small;laterfeaturesbenefitfromexperiencegainedduringtheimplementationof earlierfeatures,sotheyhavefewerproblems.

--- Chunk 13 ---
Tokens: 398
Type: sentence-based
Text:
Problems with the original design are discoveredandcorrected,thenafewmorefeaturesaredesigned,implemented andevaluated.Eachiterationexposesproblemswiththeexistingdesign,which arefixedbeforethenextsetoffeaturesisdesigned.Byspreadingoutthedesign inthisway,problemswiththeinitialdesigncanbefixedwhilethesystemisstill small;laterfeaturesbenefitfromexperiencegainedduringtheimplementationof earlierfeatures,sotheyhavefewerproblems. Theincrementalapproachworksforsoftwarebecausesoftwareismalleable enoughtoallowsignificantdesignchangespartwaythroughimplementation.In contrast,majordesignchangesaremuchmorechallengingforphysicalsystems: forexample,itwouldnotbepracticaltochangethenumberoftowerssupporting abridgeinthemiddleofconstruction. Incrementaldevelopmentmeansthatsoftwaredesignisneverdone.Design happens continuously over the life of a system: developers should always be thinking about design issues. Incremental development also means continuous redesign.Theinitialdesignforasystemorcomponentisalmostneverthebest one; experience inevitably shows better ways to do things. As a software developer,youshouldalwaysbeonthelookoutforopportunitiestoimprovethe designofthesystemyouareworkingon,andyoushouldplanonspendingsome fractionofyourtimeondesignimprovements. If software developers should always be thinking about design issues, and reducing complexity is the most important element of software design, then softwaredevelopersshouldalwaysbethinkingaboutcomplexity.Thisbookis about how to use complexity to guide the design of software throughout its lifetime. This book has two overall goals.

--- Chunk 14 ---
Tokens: 392
Type: sentence-based
Text:
This book has two overall goals. The first is to describe the nature of softwarecomplexity:whatdoescomplexitymean,whydoesitmatter,andhow can you recognize when a program has unnecessary complexity? The books second,andmorechallenging,goalistopresenttechniquesyoucanuseduring thesoftwaredevelopmentprocesstominimizecomplexity.Unfortunately,there isntasimplerecipethatwillguaranteegreatsoftwaredesigns.Instead,Iwill present a collection of higher-level concepts that border on the philosophical, such as classes should be deep or define errors out of existence. These conceptsmaynotimmediatelyidentifythebestdesign,butyoucanusethemto comparedesignalternativesandguideyourexplorationofthedesignspace. 1.1Howtousethisbook Manyofthedesignprinciplesdescribedherearesomewhatabstract,sotheymay Manyofthedesignprinciplesdescribedherearesomewhatabstract,sotheymay behardtoappreciatewithoutlookingatactualcode.Ithasbeenachallengeto findexamplesthataresmallenoughtoincludeinthebook,yetlargeenoughto illustrateproblems with real systems (if you encounter good examples, please sendthemtome).Thus,thisbookmaynotbesufficientbyitselfforyoutolearn howtoapplytheprinciples. Thebestwaytousethisbookisinconjunctionwithcodereviews.Whenyou read other peoples code, think about whether it conforms to the concepts discussedhereandhowthatrelatestothecomplexityofthecode.Itseasierto seedesignproblemsinsomeoneelsescodethanyourown.Youcanusethered flagsdescribedheretoidentifyproblemsandsuggestimprovements.Reviewing code will also expose you to new design approaches and programming techniques.

--- Chunk 15 ---
Tokens: 383
Type: sentence-based
Text:
Thebestwaytousethisbookisinconjunctionwithcodereviews.Whenyou read other peoples code, think about whether it conforms to the concepts discussedhereandhowthatrelatestothecomplexityofthecode.Itseasierto seedesignproblemsinsomeoneelsescodethanyourown.Youcanusethered flagsdescribedheretoidentifyproblemsandsuggestimprovements.Reviewing code will also expose you to new design approaches and programming techniques. Oneofthebestwaystoimproveyourdesignskillsistolearntorecognizered flags:signsthatapieceofcodeisprobablymorecomplicatedthanitneedstobe. Over the course of this book I will point out red flags that suggest problems relatedtoeachmajordesignissue;themostimportantonesaresummarizedat thebackofthebook.Youcanthenusethesewhenyouarecoding:whenyousee a red flag, stop and look for an alternate design that eliminates the problem. Whenyoufirsttrythisapproach,youmayhavetotryseveraldesignalternatives beforeyoufindonethateliminatestheredflag.Dontgiveupeasily:themore alternatives you try before fixing the problem, the more you will learn. Over time,youwillfindthatyourcodehasfewerandfewerredflags,andyourdesigns arecleanerandcleaner.Yourexperiencewillalsoshowyouotherredflagsthat youcanusetoidentifydesignproblems(Idbehappytohearaboutthese). Whenapplyingtheideasfromthisbook,itsimportanttousemoderationand discretion.Everyrulehasitsexceptions,andeveryprinciplehasitslimits.Ifyou take any design idea to its extreme, you will probably end up in a bad place. Beautiful designs reflect a balance between competing ideas and approaches.

--- Chunk 16 ---
Tokens: 380
Type: sentence-based
Text:
Beautiful designs reflect a balance between competing ideas and approaches. SeveralchaptershavesectionstitledTakingittoofar,whichdescribehowto recognizewhenyouareoverdoingagoodthing. AlmostalloftheexamplesinthisbookareinJavaorC,andmuchofthe discussion is in terms of designing classes in an object-oriented language. However,theideasapplyinotherdomainsaswell.Almostalloftheideasrelated tomethodscanalsobeappliedtofunctionsinalanguagewithoutobject-oriented features,suchasC.Thedesignideasalsoapplytomodulesotherthanclasses, suchassubsystemsornetworkservices. Withthisbackground,letsdiscussinmoredetailwhatcausescomplexity, andhowtomakesoftwaresystemssimpler. Chapter2 TheNatureofComplexity Thisbookisabouthowtodesignsoftwaresystemstominimizetheircomplexity. Thefirststepistounderstandtheenemy.Exactlywhatiscomplexity?How can you tell if a system is unnecessarily complex? What causes systems to become complex? This chapter will address those questions at a high level; subsequentchapterswillshowyouhowtorecognizecomplexityatalowerlevel, intermsofspecificstructuralfeatures. Theabilitytorecognizecomplexityisacrucialdesignskill.Itallowsyouto identifyproblemsbeforeyouinvestalotofeffortinthem,anditallowsyouto make good choicesamongalternatives. Itis easiertotell whether adesignis simplethanitistocreateasimpledesign,butonceyoucanrecognizethata system is too complicated, you can use that ability to guide your design philosophytowardssimplicity.Ifadesignappearscomplicated,tryadifferent approach and see if that is simpler.

--- Chunk 17 ---
Tokens: 390
Type: sentence-based
Text:
Itis easiertotell whether adesignis simplethanitistocreateasimpledesign,butonceyoucanrecognizethata system is too complicated, you can use that ability to guide your design philosophytowardssimplicity.Ifadesignappearscomplicated,tryadifferent approach and see if that is simpler. Over time, you will notice that certain techniques tend to result in simpler designs, while others correlate with complexity.Thiswillallowyoutoproducesimplerdesignsmorequickly. Thischapteralsolaysoutsomebasicassumptionsthatprovideafoundation fortherestofthebook.Laterchapterstakethematerialofthischapterasgiven anduseittojustifyavarietyofrefinementsandconclusions. 2.1Complexitydefined For the purposes of this book, I define complexity in a practical way. Complexity is anything related to the structure of a software system that makes it hard to understand and modify the system. Complexity can take manyforms.Forexample,itmightbehardtounderstandhowapieceofcode works;itmighttakealotofefforttoimplementasmallimprovement,oritmight not be clear which parts of the system must be modified to make the improvement;itmightbedifficulttofixonebugwithoutintroducinganother.If asoftwaresystemishardtounderstandandmodify,thenitiscomplicated;ifitis easytounderstandandmodify,thenitissimple. Youcanalsothinkofcomplexityintermsofcostandbenefit.Inacomplex system,ittakesalotofworktoimplementevensmallimprovements.Inasimple system,largerimprovementscanbeimplementedwithlesseffort. Complexity is what a developer experiences at a particular point in time when trying to achieve a particular goal.

--- Chunk 18 ---
Tokens: 388
Type: sentence-based
Text:
Complexity is what a developer experiences at a particular point in time when trying to achieve a particular goal. It doesnt necessarily relate to the overallsizeorfunctionalityofthesystem.Peopleoftenusethewordcomplex todescribelargesystemswithsophisticatedfeatures,butifsuchasystemiseasy toworkon,then,forthepurposesofthisbook,itisnotcomplex.Ofcourse, almostalllargeandsophisticatedsoftwaresystemsareinfacthardtoworkon,so theyalsomeetmydefinitionofcomplexity,butthisneednotnecessarilybethe case. It is also possible for a small and unsophisticated system to be quite complex. Complexityisdeterminedbytheactivitiesthataremostcommon.Ifasystem hasafewpartsthatareverycomplicated,butthosepartsalmostneverneedtobe touched, then they dont have much impact on the overall complexity of the system.Tocharacterizethisinacrudemathematicalway: Theoverallcomplexityofasystem(C)isdeterminedbythecomplexityof eachpartp(cp)weightedbythefractionoftimedevelopersspendworkingon thatpart(tp).Isolatingcomplexityinaplacewhereitwillneverbeseenisalmost asgoodaseliminatingthecomplexityentirely. Complexityismoreapparenttoreadersthanwriters.Ifyouwriteapieceof codeanditseemssimpletoyou,butotherpeoplethinkitiscomplex,thenitis complex.Whenyoufindyourselfinsituationslikethis,itsworthprobingthe other developers to find out why the code seems complex to them; there are probably some interesting lessons to learn from the disconnect between your opinionandtheirs.Yourjobasadeveloperisnotjusttocreatecodethatyoucan workwitheasily,buttocreatecodethatotherscanalsoworkwitheasily.

--- Chunk 19 ---
Tokens: 394
Type: sentence-based
Text:
Complexityismoreapparenttoreadersthanwriters.Ifyouwriteapieceof codeanditseemssimpletoyou,butotherpeoplethinkitiscomplex,thenitis complex.Whenyoufindyourselfinsituationslikethis,itsworthprobingthe other developers to find out why the code seems complex to them; there are probably some interesting lessons to learn from the disconnect between your opinionandtheirs.Yourjobasadeveloperisnotjusttocreatecodethatyoucan workwitheasily,buttocreatecodethatotherscanalsoworkwitheasily. 2.2Symptomsofcomplexity Complexity manifests itself in three general ways, which are described in the paragraphs below. Each of these manifestations makes it harder to carry out developmenttasks. Changeamplification:Thefirstsymptomofcomplexityisthataseemingly simple change requires code modifications in many different places. For example,consideraWebsitecontainingseveralpages,eachofwhichdisplaysa bannerwithabackgroundcolor.InmanyearlyWebsites,thecolorwasspecified explicitly on each page, as shown in Figure 2.1(a). In order to change the backgroundforsuchaWebsite,adevelopermighthavetomodifyeveryexisting pagebyhand;thiswouldbenearlyimpossibleforalargesitewiththousandsof pages.Fortunately,modernWebsitesuseanapproachlikethatinFigure2.1(b), where the banner color is specified once in a central place, and all of the individual pages reference that shared value. With this approach, the banner coloroftheentireWebsitecanbechangedwithasinglemodification.Oneof thegoalsofgooddesignistoreducetheamountofcodethatisaffectedbyeach designdecision,sodesignchangesdontrequireverymanycodemodifications.

--- Chunk 20 ---
Tokens: 398
Type: sentence-based
Text:
With this approach, the banner coloroftheentireWebsitecanbechangedwithasinglemodification.Oneof thegoalsofgooddesignistoreducetheamountofcodethatisaffectedbyeach designdecision,sodesignchangesdontrequireverymanycodemodifications. Cognitiveload:Thesecondsymptomofcomplexityiscognitiveload,which referstohowmuchadeveloperneedstoknowinordertocompleteatask.A highercognitiveloadmeansthatdevelopershavetospendmoretimelearning therequiredinformation,andthereisagreaterriskofbugsbecausetheyhave missed something important. For example, suppose a function in C allocates memory,returnsapointertothatmemory,andassumesthatthecallerwillfree thememory.Thisaddstothecognitiveloadofdevelopersusingthefunction;ifa developerfailstofreethememory,therewillbeamemoryleak.Ifthesystem can be restructured so that the caller doesnt need to worry about freeing the memory(thesamemodulethatallocatesthememoryalsotakesresponsibilityfor freeingit),itwillreducethecognitiveload.Cognitiveloadarisesinmanyways, such as APIs with many methods, global variables, inconsistencies, and dependenciesbetweenmodules. System designers sometimes assume that complexity can be measured by linesofcode.Theyassumethatifoneimplementationisshorterthananother, thenitmustbesimpler;ifitonlytakesafewlinesofcodetomakeachange,then thechangemustbeeasy.However,thisviewignoresthecostsassociatedwith cognitiveload.Ihaveseenframeworksthatallowedapplicationstobewritten withonlyafewlinesofcode,butitwasextremelydifficulttofigureoutwhat thoselineswere.Sometimesanapproachthatrequiresmorelinesofcodeis actuallysimpler,becauseitreducescognitiveload.

--- Chunk 21 ---
Tokens: 341
Type: sentence-based
Text:
System designers sometimes assume that complexity can be measured by linesofcode.Theyassumethatifoneimplementationisshorterthananother, thenitmustbesimpler;ifitonlytakesafewlinesofcodetomakeachange,then thechangemustbeeasy.However,thisviewignoresthecostsassociatedwith cognitiveload.Ihaveseenframeworksthatallowedapplicationstobewritten withonlyafewlinesofcode,butitwasextremelydifficulttofigureoutwhat thoselineswere.Sometimesanapproachthatrequiresmorelinesofcodeis actuallysimpler,becauseitreducescognitiveload. Figure2.1:EachpageinaWebsitedisplaysacoloredbanner.In(a)thebackgroundcolorforthebanneris specified explicitly in each page. In (b) a shared variable holds the background color and each page referencesthatvariable.In(c)somepagesdisplayanadditionalcolorforemphasis,whichisadarkershade ofthebannerbackgroundcolor;ifthebackgroundcolorchanges,theemphasiscolormustalsochange. Unknown unknowns: The third symptom of complexity is that it is not obvious which pieces of code must be modified to complete a task, or what information a developer must have to carry out the task successfully. Figure 2.1(c)illustratesthisproblem.TheWebsiteusesacentralvariabletodetermine thebannerbackgroundcolor,soitappearstobeeasytochange.However,afew Webpagesuseadarkershadeofthebackgroundcolorforemphasis,andthat darker color is specified explicitly in the individual pages.

--- Chunk 22 ---
Tokens: 397
Type: sentence-based
Text:
Figure 2.1(c)illustratesthisproblem.TheWebsiteusesacentralvariabletodetermine thebannerbackgroundcolor,soitappearstobeeasytochange.However,afew Webpagesuseadarkershadeofthebackgroundcolorforemphasis,andthat darker color is specified explicitly in the individual pages. If the background colorchanges,thenthetheemphasiscolormustchangetomatch.Unfortunately, developersareunlikelytorealizethis,sotheymaychangethecentralbannerBg variablewithoutupdatingtheemphasiscolor.Evenifadeveloperisawareofthe problem, it wont be obvious which pages use the emphasis color, so the developermayhavetosearcheverypageintheWebsite. Ofthethreemanifestationsofcomplexity,unknownunknownsaretheworst. Anunknownunknownmeansthatthereissomethingyouneedtoknow,butthere isnowayforyoutofindoutwhatitis,orevenwhetherthereisanissue.You wont find out about it until bugs appear after you make a change. Change amplification is annoying, but as long as it is clear which code needs to be modified,thesystemwillworkoncethechangehasbeencompleted.Similarly,a highcognitiveloadwillincreasethecostofachange,butifitisclearwhich information to read, the change is still likely to be correct. With unknown unknowns, it is unclear what to do or whether a proposed solution will even work.Theonlywaytobecertainistoreadeverylineofcodeinthesystem, which is impossible for systems of any size. Even this may not be sufficient, because a change may depend on a subtle design decision that was never documented. Oneofthemostimportantgoalsofgooddesignisforasystemtobeobvious. This is the opposite of high cognitive load and unknown unknowns.

--- Chunk 23 ---
Tokens: 362
Type: sentence-based
Text:
This is the opposite of high cognitive load and unknown unknowns. In an obvioussystem,adevelopercanquicklyunderstandhowtheexistingcodeworks and what is required to make a change. An obvious system is one where a developercanmakeaquickguessaboutwhattodo,withoutthinkingveryhard, andyetbeconfidentthattheguessiscorrect.Chapter18discussestechniquesfor makingcodemoreobvious. 2.3Causesofcomplexity Nowthatyouknowthehigh-levelsymptomsofcomplexityandwhycomplexity makessoftwaredevelopmentdifficult,thenextstepistounderstandwhatcauses complexity,sothatwecandesignsystemstoavoidtheproblems.Complexityis causedbytwothings:dependenciesandobscurity.Thissectiondiscussesthese factorsatahighlevel;subsequentchapterswilldiscusshowtheyrelatetolower- leveldesigndecisions. Forthepurposesofthisbook,adependencyexistswhenagivenpieceof codecannotbeunderstoodandmodifiedinisolation;thecoderelatesinsome waytoothercode,andtheothercodemustbeconsideredandormodifiedifthe givencodeischanged.IntheWebsiteexampleofFigure2.1(a),thebackground color creates dependencies between all ofthe pages. All of the pagesneed to havethesamebackground,soifthebackgroundischangedforonepage,thenit must be changed for all of them. Another example of dependencies occurs in networkprotocols.Typicallythereisseparatecodeforthesenderandreceiverfor theprotocol,buttheymusteachconformtotheprotocol;changingthecodefor thesenderalmostalwaysrequirescorrespondingchangesatthereceiver,andvice versa.

--- Chunk 24 ---
Tokens: 329
Type: sentence-based
Text:
Another example of dependencies occurs in networkprotocols.Typicallythereisseparatecodeforthesenderandreceiverfor theprotocol,buttheymusteachconformtotheprotocol;changingthecodefor thesenderalmostalwaysrequirescorrespondingchangesatthereceiver,andvice versa. The signature of a method creates a dependency between the implementationofthatmethodandthecodethatinvokesit:ifanewparameteris addedtoamethod,alloftheinvocationsofthatmethodmustbemodifiedto specifythatparameter. Dependencies are a fundamental part of software and cant be completely eliminated. In fact, we intentionally introduce dependencies as part of the software design process. Every time you write a new class you create dependencies around the API for that class. However, one of the goals of software design is to reduce the number of dependencies and to make the dependenciesthatremainassimpleandobviousaspossible. Consider the Web site example. In the old Web site with the background specifiedseparatelyoneachpage,alloftheWebpagesweredependentoneach other.ThenewWebsitefixedthisproblembyspecifyingthebackgroundcolor inacentralplaceandprovidinganAPIthatindividualpagesusetoretrievethat color when they are rendered. The new Web site eliminated the dependency betweenthepages,butitcreatedanewdependencyaroundtheAPIforretrieving the background color.

--- Chunk 25 ---
Tokens: 349
Type: sentence-based
Text:
The new Web site eliminated the dependency betweenthepages,butitcreatedanewdependencyaroundtheAPIforretrieving the background color. Fortunately, the new dependency is more obvious: it is clear that each individual Web page depends on the bannerBg color, and a developercaneasilyfindalltheplaceswherethevariableisusedbysearching foritsname.Furthermore,compilershelptomanageAPIdependencies:ifthe nameofthesharedvariablechanges,compilationerrorswilloccurinanycode that still uses the old name. The new Web site replaced a nonobvious and difficult-to-managedependencywithasimplerandmoreobviousone. The second cause of complexity is obscurity. Obscurity occurs when importantinformationisnotobvious.Asimpleexampleisavariablenamethat issogenericthatitdoesntcarrymuchusefulinformation(e.g, time).Or,the documentationforavariablemightnotspecifyitsunits,sotheonlywaytofind out is to scan code for places where the variable is used. Obscurity is often associatedwithdependencies,whereitisnotobviousthatadependencyexists. Forexample,ifanewerrorstatusisaddedtoasystem,itmaybenecessaryto addanentrytoatableholdingstringmessagesforeachstatus,buttheexistence ofthemessagetablemightnotbeobvioustoaprogrammerlookingatthestatus declaration.Inconsistencyisalsoamajorcontributortoobscurity:ifthesame variablenameisusedfortwodifferentpurposes,itwontbeobvioustodeveloper whichofthesepurposesaparticularvariableserves.

--- Chunk 26 ---
Tokens: 371
Type: sentence-based
Text:
Forexample,ifanewerrorstatusisaddedtoasystem,itmaybenecessaryto addanentrytoatableholdingstringmessagesforeachstatus,buttheexistence ofthemessagetablemightnotbeobvioustoaprogrammerlookingatthestatus declaration.Inconsistencyisalsoamajorcontributortoobscurity:ifthesame variablenameisusedfortwodifferentpurposes,itwontbeobvioustodeveloper whichofthesepurposesaparticularvariableserves. Inmanycases,obscuritycomesaboutbecauseofinadequatedocumentation; Chapter13dealswiththistopic.However,obscurityisalsoadesignissue.Ifa systemhasacleanandobviousdesign,thenitwillneedlessdocumentation.The needforextensivedocumentationisoftenaredflagthatthedesignisntquite right.Thebestwaytoreduceobscurityisbysimplifyingthesystemdesign. Together,dependenciesandobscurityaccountforthethreemanifestationsof complexitydescribedinSection2.2.Dependenciesleadtochangeamplification and a high cognitive load. Obscurity creates unknown unknowns, and also contributes to cognitive load. If we can find design techniques that minimize dependenciesandobscurity,thenwecanreducethecomplexityofsoftware. 2.4Complexityisincremental Complexityisntcausedbyasinglecatastrophicerror;itaccumulatesinlotsof smallchunks.Asingledependencyorobscurity,byitself,isunlikelytoaffect significantlythemaintainabilityofasoftwaresystem.Complexitycomesabout becausehundredsorthousandsofsmalldependenciesandobscuritiesbuildup overtime.Eventually,therearesomanyofthesesmallissuesthateverypossible changetothesystemisaffectedbyseveralofthem.

--- Chunk 27 ---
Tokens: 389
Type: sentence-based
Text:
2.4Complexityisincremental Complexityisntcausedbyasinglecatastrophicerror;itaccumulatesinlotsof smallchunks.Asingledependencyorobscurity,byitself,isunlikelytoaffect significantlythemaintainabilityofasoftwaresystem.Complexitycomesabout becausehundredsorthousandsofsmalldependenciesandobscuritiesbuildup overtime.Eventually,therearesomanyofthesesmallissuesthateverypossible changetothesystemisaffectedbyseveralofthem. Theincrementalnatureofcomplexitymakesithardtocontrol.Itseasyto convince yourself that a little bit of complexity introduced by your current changeisnobigdeal.However,ifeverydevelopertakesthisapproachforevery change,complexityaccumulatesrapidly.Oncecomplexityhasaccumulated,itis hard to eliminate, since fixing a single dependency or obscurity will not, by itself,makeabigdifference.Inordertoslowthegrowthofcomplexity,youmust adoptazerotolerancephilosophy,asdiscussedinChapter3. 2.5Conclusion Complexity comes from an accumulation of dependencies and obscurities. As complexityincreases,itleadstochangeamplification,ahighcognitiveload,and unknownunknowns.Asaresult,ittakesmorecodemodificationstoimplement each new feature. In addition, developers spend more time acquiring enough informationtomakethechangesafelyand,intheworstcase,theycantevenfind all the information they need. The bottom line is that complexity makes it difficultandriskytomodifyanexistingcodebase. Chapter3 WorkingCodeIsntEnough (Strategicvs.TacticalProgramming) Oneofthemostimportantelementsofgoodsoftwaredesignisthemindset you adopt when you approach a programming task.

--- Chunk 28 ---
Tokens: 396
Type: sentence-based
Text:
Chapter3 WorkingCodeIsntEnough (Strategicvs.TacticalProgramming) Oneofthemostimportantelementsofgoodsoftwaredesignisthemindset you adopt when you approach a programming task. Many organizations encourageatacticalmindset,focusedongettingfeaturesworkingasquicklyas possible.However,ifyouwantagooddesign,youmusttakeamorestrategic approachwhereyouinvesttimetoproducecleandesignsandfixproblems.This chapter discusses why the strategic approach produces better designs and is actuallycheaperthanthetacticalapproachoverthelongrun. 3.1Tacticalprogramming MostprogrammersapproachsoftwaredevelopmentwithamindsetIcalltactical programming. In the tactical approach, your main focus is to get something working,suchasanewfeatureorabugfix.Atfirstglancethisseemstotally reasonable: what could be more important than writing code that works? However, tactical programming makes it nearly impossible to produce a good systemdesign. Theproblemwithtacticalprogrammingisthatitisshort-sighted.Ifyoure programming tactically, youre trying to finish a task as quickly as possible. Perhaps you have a hard deadline. As a result, planning for the future isnt a priority.Youdontspendmuchtimelookingforthebestdesign;youjustwantto get something working soon. You tell yourself that its OK to add a bit of complexityorintroduceasmallkludgeortwo,ifthatallowsthecurrenttaskto becompletedmorequickly. This is how systems become complicated. As discussed in the previous chapter, complexity is incremental. Its not one particular thing that makes a systemcomplicated,buttheaccumulationofdozensorhundredsofsmallthings.

--- Chunk 29 ---
Tokens: 380
Type: sentence-based
Text:
Its not one particular thing that makes a systemcomplicated,buttheaccumulationofdozensorhundredsofsmallthings. Ifyouprogramtactically,eachprogrammingtaskwillcontributeafewofthese complexities. Each of them probably seems like a reasonable compromise in ordertofinishthecurrenttaskquickly.However,thecomplexitiesaccumulate rapidly,especiallyifeveryoneisprogrammingtactically. Beforelong,someofthecomplexitieswillstartcausingproblems,andyou will begin to wish you hadnt taken those early shortcuts. But, you will tell yourselfthatitsmoreimportanttogetthenextfeatureworkingthantogoback andrefactorexistingcode.Refactoringmayhelpoutinthelongrun,butitwill definitelyslowdownthecurrenttask.So,youlookforquickpatchestowork aroundanyproblemsyouencounter.Thisjustcreatesmorecomplexity,which then requires more patches. Pretty soon the code is a mess, but by this point thingsaresobadthatitwouldtakemonthsofworktocleanitup.Theresnoway your schedule can tolerate that kind of delay, and fixing one or two of the problems doesnt seem like it will make much difference, so you just keep programmingtactically. Ifyouhaveworkedonalargesoftwareprojectforverylong,Isuspectyou haveseentacticalprogrammingatworkandhaveexperiencedtheproblemsthat result.Onceyoustartdownthetacticalpath,itsdifficulttochange. Almosteverysoftwaredevelopmentorganizationhasatleastonedeveloper whotakestacticalprogrammingtotheextreme:atacticaltornado.Thetactical tornadoisaprolificprogrammerwhopumpsoutcodefarfasterthanothersbut works in a totally tactical fashion.

--- Chunk 30 ---
Tokens: 351
Type: sentence-based
Text:
Almosteverysoftwaredevelopmentorganizationhasatleastonedeveloper whotakestacticalprogrammingtotheextreme:atacticaltornado.Thetactical tornadoisaprolificprogrammerwhopumpsoutcodefarfasterthanothersbut works in a totally tactical fashion. When it comes to implementing a quick feature, nobody gets it done faster than the tactical tornado. In some organizations,managementtreatstacticaltornadoesasheroes.However,tactical tornadoesleavebehindawakeofdestruction.Theyarerarelyconsideredheroes bytheengineerswhomustworkwiththeircodeinthefuture.Typically,other engineersmustcleanupthemessesleftbehindbythetacticaltornado,which makesitappearthatthoseengineers(whoaretherealheroes)aremakingslower progressthanthetacticaltornado. 3.2Strategicprogramming The first step towards becoming a good software designer is to realize that working code isnt enough. Its not acceptable to introduce unnecessary complexitiesinordertofinishyourcurrenttaskfaster.Themostimportantthing is the long-term structure of the system. Most of the code in any system is written by extending the existing code base, so your most important job as a developeristofacilitatethosefutureextensions.Thus,youshouldnotthinkof workingcodeasyourprimarygoal,thoughofcourseyourcodemustwork. Your primary goal must be to produce a great design, which also happens to work.Thisisstrategicprogramming. Strategic programming requires an investment mindset.

--- Chunk 31 ---
Tokens: 399
Type: sentence-based
Text:
Strategic programming requires an investment mindset. Rather than taking thefastestpathtofinishyourcurrentproject,youmustinvesttimetoimprovethe designofthesystem.Theseinvestmentswillslowyoudownabitintheshort term,buttheywillspeedyouupinthelongterm,asillustratedinFigure3.1. Someoftheinvestmentswillbeproactive.Forexample,itsworthtakinga little extra time to find a simple design for each new class; rather than implementing the first idea that comes to mind, try a couple of alternative designsandpickthecleanestone.Trytoimagineafewwaysinwhichthesystem mightneedtobechangedinthefutureandmakesurethatwillbeeasywithyour design. Writing good documentation is another example of a proactive investment. Otherinvestmentswillbereactive.Nomatterhowmuchyouinvestupfront, there will inevitably be mistakes in your design decisions. Over time, these mistakeswillbecomeobvious.Whenyoudiscoveradesignproblem,dontjust ignore it or patch around it; take a little extra time to fix it. If you program strategically, you will continually make small improvements to the system design.Thisistheoppositeoftacticalprogramming,whereyouarecontinually addingsmallbitsofcomplexitythatcauseproblemsinthefuture. 3.3Howmuchtoinvest? So,whatistherightamountofinvestment?Ahugeup-frontinvestment,suchas trying to design the entire system, wont be effective. This is the waterfall method,andweknowitdoesntwork.Theidealdesigntendstoemergeinbits andpieces,asyougetexperiencewiththesystem.Thus,thebestapproachisto makelotsofsmallinvestmentsonacontinualbasis.Isuggestspendingabout10 20 of your total development time on investments.

--- Chunk 32 ---
Tokens: 367
Type: sentence-based
Text:
This is the waterfall method,andweknowitdoesntwork.Theidealdesigntendstoemergeinbits andpieces,asyougetexperiencewiththesystem.Thus,thebestapproachisto makelotsofsmallinvestmentsonacontinualbasis.Isuggestspendingabout10 20 of your total development time on investments. This amount is small enough that it wont impact your schedules significantly, but large enough to producesignificantbenefitsovertime.Yourinitialprojectswillthustake10 20longerthantheywouldinapurelytacticalapproach.Thatextratimewill resultinabettersoftwaredesign,andyouwillstartexperiencingthebenefits withinafewmonths.Itwontbelongbeforeyouredevelopingatleast1020 faster than you would if you had programmed tactically. At this point your investments become free: the benefits from your past investments will save enoughtimetocoverthecostoffutureinvestments.Youwillquicklyrecoverthe costoftheinitialinvestment.Figure3.1illustratesthisphenomenon. Figure3.1:Atthebeginning,atacticalapproachtoprogrammingwillmakeprogressmorequicklythana strategic approach. However, complexity accumulates more rapidly under the tactical approach, which reduces productivity. Over time, the strategic approach results in greater progress. Note: this figure is intendedonlyasaqualitativeillustration;Iamnotawareofanyempiricalmeasurementsoftheprecise shapesofthecurves. Conversely,ifyouprogramtactically,youwillfinishyourfirstprojects10 20 faster, but over time your development speed will slow as complexity accumulates.

--- Chunk 33 ---
Tokens: 360
Type: sentence-based
Text:
Conversely,ifyouprogramtactically,youwillfinishyourfirstprojects10 20 faster, but over time your development speed will slow as complexity accumulates. It wont be long before youre programming at least 1020 slower.Youwillquicklygivebackallofthetimeyousavedatthebeginning,and fortherestofsystemslifetimeyouwillbedevelopingmoreslowlythanifyou hadtakenthestrategicapproach.Ifyouhaventeverworkedinabadlydegraded codebase,talktosomeonewhohas;theywilltellyouthatpoorcodequality slowsdevelopmentbyatleast20. 3.4Startupsandinvestment In some environments there are strong forces working against the strategic approach.Forexample,early-stagestartupsfeeltremendouspressuretogettheir earlyreleasesoutquickly.Inthesecompanies,itmightseemthatevena1020 investmentisntaffordable.Asaresult,manystartupstakeatacticalapproach, spendinglittleeffortondesignandevenlessoncleanupwhenproblemspopup. Theyrationalizethiswiththethoughtthat,iftheyaresuccessful,theyllhave enoughmoneytohireextraengineerstocleanthingsup. Ifyouareinacompanyleaninginthisdirection,youshouldrealizethatonce acodebaseturnstospaghetti,itisnearlyimpossibletofix.Youwillprobably payhighdevelopmentcostsforthelifeoftheproduct.Furthermore,thepayoff forgood(orbad)designcomesprettyquickly,sotheresagoodchancethatthe tacticalapproachwontevenspeedupyourfirstproductrelease. Another thing to consider is that one of the most important factors for success of a company is the quality of its engineers.

--- Chunk 34 ---
Tokens: 389
Type: sentence-based
Text:
Another thing to consider is that one of the most important factors for success of a company is the quality of its engineers. The best way to lower development costs is to hire great engineers: they dont cost much more than mediocreengineersbuthavetremendouslyhigherproductivity.However,thebest engineerscaredeeplyaboutgooddesign.Ifyourcodebaseisawreck,wordwill getout,andthiswillmakeitharderforyoutorecruit.Asaresult,youarelikely to end up with mediocre engineers. This will increase your future costs and probablycausethesystemstructuretodegradeevenmore. Facebookisanexampleofastartupthatencouragedtacticalprogramming. For many years the companys motto was Move fast and break things. New engineers fresh out of college were encouraged to dive immediately into the companys code base; it was normal for engineers to push commits into production in their first week on the job. On the positive side, Facebook developedareputationasacompanythatempowereditsemployees.Engineers hadtremendouslatitude,andtherewerefewrulesandrestrictionstogetintheir way. Facebookhasbeenspectacularlysuccessfulasacompany,butitscodebase suffered because of the companys tactical approach; much of the code was unstableandhardtounderstand,withfewcommentsortests,andpainfultowork with. Over time the company realized that its culture was unsustainable. Eventually,FacebookchangeditsmottotoMovefastwithsolidinfrastructure toencourageitsengineerstoinvestmoreingooddesign.Itremainstobeseen whetherFacebookcansuccessfullycleanuptheproblemsthataccumulatedover yearsoftacticalprogramming.

--- Chunk 35 ---
Tokens: 337
Type: sentence-based
Text:
Eventually,FacebookchangeditsmottotoMovefastwithsolidinfrastructure toencourageitsengineerstoinvestmoreingooddesign.Itremainstobeseen whetherFacebookcansuccessfullycleanuptheproblemsthataccumulatedover yearsoftacticalprogramming. In fairness to Facebook, I should point out that Facebooks code probably isnt much worse than average among startups. Tactical programming is commonplaceamongstartups;Facebookjusthappenstobeaparticularlyvisible example. Fortunately,itisalsopossibletosucceedinSiliconValleywithastrategic approach.GoogleandVMwaregrewuparoundthesametimeasFacebook,but bothofthesecompaniesembracedamorestrategicapproach.Bothcompanies placed a heavy emphasis on high quality code and good design, and both companies built sophisticated products that solved complex problems with reliablesoftwaresystems.Thecompaniesstrongtechnicalculturesbecamewell known in Silicon Valley. Few other companies could compete with them for hiringthetoptechnicaltalent. These examples show that a company can succeed with either approach. However, its a lot more fun to work in a company that cares about software designandhasacleancodebase. 3.5Conclusion Good design doesnt come for free. It has to be something you invest in continually,sothatsmallproblemsdontaccumulateintobigones.Fortunately, gooddesigneventuallypaysforitself,andsoonerthanyoumightthink.

--- Chunk 36 ---
Tokens: 379
Type: sentence-based
Text:
It has to be something you invest in continually,sothatsmallproblemsdontaccumulateintobigones.Fortunately, gooddesigneventuallypaysforitself,andsoonerthanyoumightthink. Itscrucialtobeconsistentinapplyingthestrategicapproachandtothinkof investmentassomethingtodotoday,nottomorrow.Whenyougetinacrunchit willbetemptingtoputoffcleanupsuntilafterthecrunchisover.However,this isaslipperyslope;afterthecurrentcrunchtherewillalmostcertainlybeanother one,andanotherafterthat.Onceyoustartdelayingdesignimprovements,its easy for the delays to become permanent and for your culture to slip into the tacticalapproach.Thelongeryouwaittoaddressdesignproblems,thebigger theybecome;thesolutionsbecomemoreintimidating,whichmakesiteasyto put them off even more. The most effective approach is one where every engineermakescontinuoussmallinvestmentsingooddesign. Chapter4 ModulesShouldBeDeep Oneofthemostimportanttechniquesformanagingsoftwarecomplexityisto designsystemssothatdevelopersonlyneedtofaceasmallfractionoftheoverall complexityatanygiventime.Thisapproachiscalledmodulardesign,andthis chapterpresentsitsbasicprinciples. 4.1Modulardesign Inmodulardesign,asoftwaresystemisdecomposedintoacollectionofmodules thatarerelativelyindependent.Modulescantakemanyforms,suchasclasses, subsystems, or services. In an ideal world, each module would be completely independentoftheothers:adevelopercouldworkinanyofthemoduleswithout knowinganythingaboutanyoftheothermodules.Inthisworld,thecomplexity ofasystemwouldbethecomplexityofitsworstmodule.

--- Chunk 37 ---
Tokens: 371
Type: sentence-based
Text:
In an ideal world, each module would be completely independentoftheothers:adevelopercouldworkinanyofthemoduleswithout knowinganythingaboutanyoftheothermodules.Inthisworld,thecomplexity ofasystemwouldbethecomplexityofitsworstmodule. Unfortunately,thisidealisnotachievable.Modulesmustworktogetherby calling each otherss functions or methods. As a result, modules must know somethingabouteachother.Therewillbedependenciesbetweenthemodules:if onemodulechanges,othermodulesmayneedtochangetomatch.Forexample, theargumentsforamethodcreateadependencybetweenthemethodandany codethatinvokesthemethod.Iftherequiredargumentschange,allinvocations ofthemethodmustbemodifiedtoconformtothenewsignature.Dependencies cantakemanyotherforms,andtheycanbequitesubtle.Thegoalofmodular designistominimizethedependenciesbetweenmodules. Inordertomanagedependencies,wethinkofeachmoduleintwoparts:an interface and an implementation. The interface consists of everything that a developer working ina differentmodulemust knowin order touse the given module.Typically,theinterfacedescribeswhatthemoduledoesbutnothowit doesit.Theimplementationconsistsofthecodethatcarriesoutthepromises made by the interface. A developer working in a particular module must understandtheinterfaceandimplementationofthatmodule,plustheinterfaces ofanyothermodulesinvokedbythegivenmodule.Adevelopershouldnotneed tounderstandtheimplementationsofmodulesotherthantheoneheorsheis workingin. Consider a module that implements balanced trees.

--- Chunk 38 ---
Tokens: 386
Type: sentence-based
Text:
Consider a module that implements balanced trees. The module probably containssophisticatedcodeforensuringthatthetreeremainsbalanced.However, thiscomplexityisnotvisibletousersofthemodule.Usersseearelativelysimple interfaceforinvokingoperationstoinsert,remove,andfetchnodesinthetree.To invokeaninsertoperation,thecallerneedonlyprovidethekeyandvalueforthe new node; the mechanisms for traversing the tree and splitting nodes are not visibleintheinterface. For the purposes of this book, a module is any unit of code that has an interfaceandanimplementation.Eachclassinanobject-orientedprogramming languageisamodule.Methodswithinaclass,orfunctionsinalanguagethat isntobject-oriented,canalsobethoughtofasmodules:eachofthesehasan interfaceandanimplementation,andmodulardesigntechniquescanbeapplied tothem.Higher-levelsubsystemsandservicesarealsomodules;theirinterfaces maytakedifferentforms,suchaskernelcallsorHTTPrequests.Muchofthe discussionaboutmodulardesigninthisbookfocusesondesigningclasses,but thetechniquesandconceptsapplytootherkindsofmodulesaswell. The best modules are those whose interfaces are much simpler than their implementations. Such modules have two advantages. First, a simple interface minimizes the complexity that a module imposes on the rest of the system. Second,ifamoduleismodifiedinawaythatdoesnotchangeitsinterface,then noothermodulewillbeaffectedbythemodification.Ifamodulesinterfaceis muchsimplerthanitsimplementation,therewillbemanyaspectsofthemodule thatcanbechangedwithoutaffectingothermodules. 4.2Whatsinaninterface?

--- Chunk 39 ---
Tokens: 399
Type: sentence-based
Text:
4.2Whatsinaninterface? The interface to a module contains two kinds of information: formal and informal.Theformalpartsofaninterfacearespecifiedexplicitlyinthecode,and someofthesecanbecheckedforcorrectnessbytheprogramminglanguage.For example,theformalinterfaceforamethodisitssignature,whichincludesthe namesandtypesofitsparameters,thetypeofitsreturnvalue,andinformation about exceptions thrown by the method. Most programming languages ensure that each invocation of a method provides the right number and types of argumentstomatchitssignature.Theformalinterfaceforaclassconsistsofthe signaturesforallofitspublicmethods,plusthenamesandtypesofanypublic variables. Eachinterfacealsoincludesinformalelements.Thesearenotspecifiedina way that can be understood or enforced by the programming language. The informalpartsofaninterfaceincludeitshigh-levelbehavior,suchasthefactthat afunctiondeletesthefilenamedbyoneofitsarguments.Ifthereareconstraints ontheusageofaclass(perhapsonemethodmustbecalledbeforeanother),these arealsopartoftheclasssinterface.Ingeneral,ifadeveloperneedstoknowa particularpieceofinformationinordertouseamodule,thenthatinformationis partofthemodulesinterface.Theinformalaspectsofaninterfacecanonlybe described using comments, and the programming language cannot ensure that thedescriptioniscompleteoraccurate1.Formostinterfacestheinformalaspects arelargerandmorecomplexthantheformalaspects. Oneofthebenefitsofaclearlyspecifiedinterfaceisthatitindicatesexactly whatdevelopersneedtoknowinordertousetheassociatedmodule.Thishelps toeliminatetheunknownunknownsproblemdescribedinSection2.2.

--- Chunk 40 ---
Tokens: 399
Type: sentence-based
Text:
Oneofthebenefitsofaclearlyspecifiedinterfaceisthatitindicatesexactly whatdevelopersneedtoknowinordertousetheassociatedmodule.Thishelps toeliminatetheunknownunknownsproblemdescribedinSection2.2. 4.3Abstractions The term abstraction is closely related to the idea of modular design. An abstraction is a simplified view of an entity, which omits unimportant details.Abstractionsareusefulbecausetheymakeiteasierforustothinkabout andmanipulatecomplexthings. Inmodularprogramming,eachmoduleprovidesanabstractioninformofits interface.Theinterfacepresentsasimplifiedviewofthemodulesfunctionality; the details of the implementation are unimportant from the standpoint of the modulesabstraction,sotheyareomittedfromtheinterface. Inthedefinitionofabstraction,thewordunimportantiscrucial.Themore unimportantdetailsthatareomittedfromanabstraction,thebetter.However,a detailcanonlybeomittedfromanabstractionifitisunimportant.Anabstraction can go wrong in two ways. First, it can include details that are not really important;whenthishappens,itmakestheabstractionmorecomplicatedthan necessary, which increases the cognitive load on developers using the abstraction.Theseconderroriswhenanabstractionomitsdetailsthatreallyare important.Thisresultsinobscurity:developerslookingonlyattheabstraction willnothavealltheinformationtheyneedtousetheabstractioncorrectly.An abstraction that omits important details is a false abstraction: it might appear simple,butinrealityitisnt.Thekeytodesigningabstractionsistounderstand what is important, and to look for designs that minimize the amount of informationthatisimportant.

--- Chunk 41 ---
Tokens: 366
Type: sentence-based
Text:
First, it can include details that are not really important;whenthishappens,itmakestheabstractionmorecomplicatedthan necessary, which increases the cognitive load on developers using the abstraction.Theseconderroriswhenanabstractionomitsdetailsthatreallyare important.Thisresultsinobscurity:developerslookingonlyattheabstraction willnothavealltheinformationtheyneedtousetheabstractioncorrectly.An abstraction that omits important details is a false abstraction: it might appear simple,butinrealityitisnt.Thekeytodesigningabstractionsistounderstand what is important, and to look for designs that minimize the amount of informationthatisimportant. As an example, consider a file system. The abstraction provided by a file systemomitsmanydetails,suchasthemechanismforchoosingwhichblockson astoragedevicetouseforthedatainagivenfile.Thesedetailsareunimportant tousersofthefilesystem(aslongasthesystemprovidesadequateperformance). However,someofthedetailsofafilesystemsimplementationareimportantto users.Mostfilesystemscachedatainmainmemory,andtheymaydelaywriting new data to the storage device in order to improve performance. Some applications, such as databases, need to know exactly when data is written throughtostorage,sotheycanensurethatdatawillbepreservedaftersystem crashes.Thus,therulesforflushingdatatosecondarystoragemustbevisiblein thefilesystemsinterface. Wedependonabstractionstomanagecomplexitynotjustinprogramming, but pervasively in our everyday lives.

--- Chunk 42 ---
Tokens: 391
Type: sentence-based
Text:
Wedependonabstractionstomanagecomplexitynotjustinprogramming, but pervasively in our everyday lives. A microwave oven contains complex electronicstoconvertalternatingcurrentintomicrowaveradiationanddistribute that radiation throughout the cooking cavity. Fortunately, users see a much simpler abstraction, consisting of a few buttons to control the timing and intensityofthemicrowaves.Carsprovideasimpleabstractionthatallowsusto drivethemwithoutunderstandingthemechanismsforelectricalmotors,battery powermanagement,anti-lockbrakes,cruisecontrol,andsoon. 4.4Deepmodules Thebestmodulesarethosethatprovidepowerfulfunctionalityyethavesimple interfaces.Iusethetermdeeptodescribesuchmodules.Tovisualizethenotion ofdepth,imaginethateachmoduleisrepresentedbyarectangle,asshownin Figure 4.1. The area of each rectangle is proportional to the functionality implementedbythemodule.Thetopedgeofarectanglerepresentsthemodules interface;thelengthofthatedgeindicatesthecomplexityoftheinterface.The bestmodulesaredeep:theyhavealotoffunctionalityhiddenbehindasimple interface.Adeepmoduleisagoodabstractionbecauseonlyasmallfractionof itsinternalcomplexityisvisibletoitsusers. Figure4.1:Deepandshallowmodules.Thebestmodulesaredeep:theyallowalotoffunctionalitytobe accessedthroughasimpleinterface.Ashallowmoduleisonewitharelativelycomplexinterface,butnot muchfunctionality:itdoesnthidemuchcomplexity. Module depth is a way of thinking about cost versus benefit. The benefit provided by a module is its functionality. The cost of a module (in terms of system complexity) is its interface.

--- Chunk 43 ---
Tokens: 344
Type: sentence-based
Text:
The cost of a module (in terms of system complexity) is its interface. A modules interface represents the complexitythatthemoduleimposesontherestofthesystem:thesmallerand simplertheinterface,thelesscomplexitythatitintroduces.Thebestmodulesare thosewiththegreatestbenefitandtheleastcost.Interfacesaregood,butmore, orlarger,interfacesarenotnecessarilybetter! ThemechanismforfileIOprovidedbytheUnixoperatingsystemandits descendants,suchasLinux,isabeautifulexampleofadeepinterface.Thereare onlyfivebasicsystemcallsforIO,withsimplesignatures: intopen(constcharpath,intflags,mode_tpermissions); ssize_tread(intfd,voidbuffer,size_tcount); ssize_twrite(intfd,constvoidbuffer,size_tcount); off_tlseek(intfd,off_toffset,intreferencePosition); intclose(intfd); Theopensystemcalltakesahierarchicalfilenamesuchasabcandreturnsan integer file descriptor, which is used to reference the open file. The other argumentsforopenprovideoptionalinformationsuchaswhetherthefileisbeing openedforreadingorwriting,whetheranewfileshouldbecreatedifthereisno existingfile,andaccesspermissionsforthefile,ifanewfileiscreated.Theread and write system calls transfer information between buffer areas in the applicationsmemoryandthefile;closeendstheaccesstothefile.Mostfiles areaccessedsequentially,sothatisthedefault;however,randomaccesscanbe achievedbyinvokingthelseeksystemcalltochangethecurrentaccessposition.

--- Chunk 44 ---
Tokens: 373
Type: sentence-based
Text:
The other argumentsforopenprovideoptionalinformationsuchaswhetherthefileisbeing openedforreadingorwriting,whetheranewfileshouldbecreatedifthereisno existingfile,andaccesspermissionsforthefile,ifanewfileiscreated.Theread and write system calls transfer information between buffer areas in the applicationsmemoryandthefile;closeendstheaccesstothefile.Mostfiles areaccessedsequentially,sothatisthedefault;however,randomaccesscanbe achievedbyinvokingthelseeksystemcalltochangethecurrentaccessposition. A modern implementation of the Unix IO interface requires hundreds of A modern implementation of the Unix IO interface requires hundreds of thousandsoflinesofcode,whichaddresscomplexissuessuchas: Howarefilesrepresentedondiskinordertoallowefficientaccess? Howaredirectoriesstored,andhowarehierarchicalpathnamesprocessed tofindthefilestheyreferto? Howarepermissionsenforced,sothatoneusercannotmodifyordelete anotherusersfiles? Howarefileaccessesimplemented?Forexample,howisfunctionality dividedbetweeninterrupthandlersandbackgroundcode,andhowdothese twoelementscommunicatesafely? Whatschedulingpoliciesareusedwhenthereareconcurrentaccessesto multiplefiles? Howcanrecentlyaccessedfiledatabecachedinmemoryinordertoreduce thenumberofdiskaccesses? Howcanavarietyofdifferentsecondarystoragedevices,suchasdisksand flashdrives,beincorporatedintoasinglefilesystem? All of these issues, and many more, are handled by the Unix file system implementation;theyareinvisibletoprogrammerswhoinvokethesystemcalls.

--- Chunk 45 ---
Tokens: 345
Type: sentence-based
Text:
All of these issues, and many more, are handled by the Unix file system implementation;theyareinvisibletoprogrammerswhoinvokethesystemcalls. ImplementationsoftheUnixIOinterfacehaveevolvedradicallyovertheyears, butthefivebasickernelcallshavenotchanged. Another example of a deep module is the garbage collector in a language suchasGoorJava.Thismodulehasnointerfaceatall;itworksinvisiblybehind the scenes to reclaim unused memory. Adding garbage collection to a system actuallyshrinksitsoverallinterface,sinceiteliminatestheinterfaceforfreeing objects. The implementation of a garbage collector is quite complex, but that complexityishiddenfromprogrammersusingthelanguage. Deep modules such as Unix IO and garbage collectors provide powerful abstractions because they are easy to use, yet they hide significant implementationcomplexity. 4.5Shallowmodules Ontheotherhand,ashallowmoduleisonewhoseinterfaceisrelativelycomplex in comparison to the functionality that it provides. For example, a class that implements linked lists is shallow. It doesnt take much code to manipulate a linkedlist(insertingordeletinganelementtakesonlyafewlines),sothelinked listabstractiondoesnthideverymanydetails.Thecomplexityofalinkedlist interface is nearly as great as the complexity of its implementation. Shallow classes are sometimes unavoidable, but they dont provide help much in managingcomplexity.

--- Chunk 46 ---
Tokens: 376
Type: sentence-based
Text:
Shallow classes are sometimes unavoidable, but they dont provide help much in managingcomplexity. Hereisanextremeexampleofashallowmethod,takenfromaprojectina softwaredesignclass: privatevoidaddNullValueForAttribute(Stringattribute) data.put(attribute,null);  Fromthestandpointofmanagingcomplexity,thismethodmakesthingsworse, not better. The method offers no abstraction, since all of its functionality is visiblethroughitsinterface.Forexample,callersprobablyneedtoknowthatthe attributewillbestoredinthedatavariable.Itisnosimplertothinkaboutthe interface than to think about the full implementation. If the method is documentedproperly,thedocumentationwillbelongerthanthemethodscode. Iteventakesmorekeystrokestoinvokethemethodthanitwouldtakeforacaller to manipulate the data variable directly. The method adds complexity (in the formofanewinterfacefordeveloperstolearn)butprovidesnocompensating benefit. RedFlag:ShallowModule A shallow module is one whose interface is complicated relative to the functionality it provides. Shallow modules dont help much in the battle againstcomplexity,becausethebenefittheyprovide(nothavingtolearnabout howtheyworkinternally)isnegatedbythecostoflearningandusingtheir interfaces.Smallmodulestendtobeshallow. 4.6Classitis Unfortunately, the value of deep classes is not widely appreciated today. The conventionalwisdominprogrammingisthatclassesshouldbesmall,notdeep. Studentsareoftentaughtthatthemostimportantthinginclassdesignistobreak up larger classes into smaller ones.

--- Chunk 47 ---
Tokens: 259
Type: sentence-based
Text:
Studentsareoftentaughtthatthemostimportantthinginclassdesignistobreak up larger classes into smaller ones. The same advice is often given about methods: Any method longer than N lines should be divided into multiple methods (N can be as low as 10). Thisapproach results in large numbers of shallowclassesandmethods,whichaddtooverallsystemcomplexity. TheextremeoftheclassesshouldbesmallapproachisasyndromeIcall classitis,whichstemsfromthemistakenviewthatclassesaregood,somore classesarebetter.Insystemssufferingfromclassitis,developersareencouraged to minimize the amount of functionality in each new class: if you want more functionality, introduce more classes. Classitis may result in classes that are individuallysimple,butitincreasesthecomplexityoftheoverallsystem.Small classesdontcontributemuchfunctionality,sotherehavetobealotofthem, eachwithitsowninterface.Theseinterfacesaccumulatetocreatetremendous complexity at the system level. Small classes also result in a verbose programmingstyle,duetotheboilerplaterequiredforeachclass.

--- Chunk 48 ---
Tokens: 317
Type: sentence-based
Text:
Small classes also result in a verbose programmingstyle,duetotheboilerplaterequiredforeachclass. 4.7Examples:JavaandUnixIO OneofthemostvisibleexamplesofclassitistodayistheJavaclasslibrary.The Java language doesnt require lots of small classes, but a culture of classitis seemstohavetakenrootintheJavaprogrammingcommunity.Forexample,to open a file in order to read serialized objects from it, you must create three differentobjects: FileInputStreamfileStream newFileInputStream(fileName); BufferedInputStreambufferedStream newBufferedInputStream(fileStream); ObjectInputStreamobjectStream newObjectInputStream(bufferedStream); A FileInputStream object provides only rudimentary IO: it is not capable of performing buffered IO, nor can it read or write serialized objects. The BufferedInputStream object adds buffering to a FileInputStream, and the ObjectInputStreamaddstheabilitytoreadandwriteserializedobjects.Thefirst twoobjectsinthecodeabove,fileStreamand bufferedStream,areneverused oncethefilehasbeenopened;allfutureoperationsuseobjectStream. Itisparticularlyannoying(anderror-prone)thatbufferingmustberequested explicitly by creating a separate BufferedInputStream object; if a developer forgets to create this object, there will be no buffering and IO will be slow.

--- Chunk 49 ---
Tokens: 368
Type: sentence-based
Text:
Itisparticularlyannoying(anderror-prone)thatbufferingmustberequested explicitly by creating a separate BufferedInputStream object; if a developer forgets to create this object, there will be no buffering and IO will be slow. PerhapstheJavadeveloperswouldarguethatnoteveryonewantstousebuffering forfileIO,soitshouldntbebuiltintothebasemechanism.Theymightargue thatitsbettertokeepbufferingseparate,sopeoplecanchoosewhetherornotto useit.Providingchoiceisgood,butinterfacesshouldbedesignedtomakethe commoncaseassimpleaspossible(seetheformulaonpage6).Almostevery useroffileIOwillwantbuffering,soitshouldbeprovidedbydefault.Forthose few situations where buffering is not desirable, the library can provide a mechanism to disable it. Any mechanism for disabling buffering should be cleanly separated in the interface (for example, by providing a different constructorforFileInputStream,orthroughamethodthatdisablesorreplaces thebufferingmechanism),sothatmostdevelopersdonotevenneedtobeaware ofitsexistence. Incontrast,thedesignersoftheUnixsystemcallsmadethecommoncase simple. For example, they recognized that sequential IO is most common, so theymadethatthedefaultbehavior.Randomaccessisstillrelativelyeasytodo, usingthelseeksystemcall,butadeveloperdoingonlysequentialaccessneed not be aware of that mechanism. If an interface has many features, but most developersonlyneedtobeawareofafewofthem,theeffectivecomplexityof thatinterfaceisjustthecomplexityofthecommonlyusedfeatures.

--- Chunk 50 ---
Tokens: 341
Type: sentence-based
Text:
If an interface has many features, but most developersonlyneedtobeawareofafewofthem,theeffectivecomplexityof thatinterfaceisjustthecomplexityofthecommonlyusedfeatures. 4.8Conclusion Byseparatingtheinterfaceofamodulefromitsimplementation,wecanhidethe complexityoftheimplementationfromtherestofthesystem.Usersofamodule need only understand the abstraction provided by its interface. The most importantissueindesigningclassesandothermodulesistomakethemdeep,so that they have simple interfaces for the common use cases, yet still provide significant functionality. This maximizes the amount of complexity that is concealed. 1Thereexistlanguages,mostlyintheresearchcommunity,wheretheoverallbehaviorofamethodor function can be described formally using a specification language. The specification can be checked automaticallytoensurethatitmatchestheimplementation.Aninterestingquestioniswhethersuchaformal specification could replace the informal parts of an interface. My current opinion is that an interface describedinEnglishislikelytobemoreintuitiveandunderstandablefordevelopersthanonewrittenina formalspecificationlanguage. Chapter5 InformationHiding(andLeakage) Chapter4arguedthatmodulesshouldbedeep.Thischapter,andthenextfew thatfollow,discusstechniquesforcreatingdeepmodules. 5.1Informationhiding Themostimportanttechniqueforachievingdeepmodulesisinformationhiding.

--- Chunk 51 ---
Tokens: 249
Type: sentence-based
Text:
5.1Informationhiding Themostimportanttechniqueforachievingdeepmodulesisinformationhiding. ThistechniquewasfirstdescribedbyDavidParnas1.Thebasicideaisthateach moduleshouldencapsulateafewpiecesofknowledge,whichrepresentdesign decisions.Theknowledgeisembeddedinthemodulesimplementationbutdoes notappearinitsinterface,soitisnotvisibletoothermodules. The information hidden within a module usually consists of details about howtoimplementsomemechanism.Herearesomeexamplesofinformationthat mightbehiddenwithinamodule: HowtostoreinformationinaB-tree,andhowtoaccessitefficiently. Howtoidentifythephysicaldiskblockcorrespondingtoeachlogicalblock withinafile. HowtoimplementtheTCPnetworkprotocol. Howtoschedulethreadsonamulti-coreprocessor. HowtoparseJSONdocuments. The hidden information includes data structures and algorithms related to the mechanism.Itcanalsoincludelower-leveldetailssuchasthesizeofapage,and itcanincludehigher-levelconceptsthataremoreabstract,suchasanassumption thatmostfilesaresmall.

--- Chunk 52 ---
Tokens: 368
Type: sentence-based
Text:
The hidden information includes data structures and algorithms related to the mechanism.Itcanalsoincludelower-leveldetailssuchasthesizeofapage,and itcanincludehigher-levelconceptsthataremoreabstract,suchasanassumption thatmostfilesaresmall. Informationhidingreducescomplexityintwoways.First,itsimplifiesthe interfacetoamodule.Theinterfacereflectsasimpler,moreabstractviewofthe modulesfunctionalityandhidesthedetails;thisreducesthecognitiveloadon developerswhousethemodule.Forinstance,adeveloperusingaB-treeclass neednotworryabouttheidealfanoutfornodesinthetreeorhowtokeepthe treebalanced.Second,informationhidingmakesiteasiertoevolvethesystem.If apieceofinformationishidden,therearenodependenciesonthatinformation outsidethemodulecontainingtheinformation,soadesignchangerelatedtothat informationwillaffectonlytheonemodule.Forexample,iftheTCPprotocol changes(tointroduceanewmechanismforcongestioncontrol,forinstance),the protocolsimplementationwillhavetobemodified,butnochangesshouldbe neededinhigher-levelcodethatusesTCPtosendandreceivedata. When designing a new module, you should think carefully about what informationcanbehiddeninthatmodule.Ifyoucanhidemoreinformation,you shouldalsobeabletosimplifythemodulesinterface,andthismakesthemodule deeper. Note:hidingvariablesandmethodsinaclassbydeclaringthemprivateisnt thesamethingasinformationhiding.Privateelementscanhelpwithinformation hiding,sincetheymakeitimpossiblefortheitemstobeaccesseddirectlyfrom outside the class.

--- Chunk 53 ---
Tokens: 358
Type: sentence-based
Text:
Note:hidingvariablesandmethodsinaclassbydeclaringthemprivateisnt thesamethingasinformationhiding.Privateelementscanhelpwithinformation hiding,sincetheymakeitimpossiblefortheitemstobeaccesseddirectlyfrom outside the class. However, information about the private items can still be exposedthroughpublicmethodssuchasgetterandsettermethods.Whenthis happens the nature and usage of the variables are just as exposed as if the variableswerepublic. The best formofinformation hiding is when information is totally hidden within a module, so that it is irrelevant and invisible to users of the module. However,partialinformationhidingalsohasvalue.Forexample,ifaparticular featureorpieceofinformationisonlyneededbyafewofaclasssusers,anditis accessedthroughseparatemethodssothatitisntvisibleinthemostcommon usecases,thenthatinformationismostlyhidden.Suchinformationwillcreate fewerdependenciesthaninformationthatisvisibletoeveryuseroftheclass. 5.2Informationleakage Theoppositeofinformationhidingisinformationleakage.Informationleakage occurswhenadesigndecisionisreflectedinmultiplemodules.Thiscreatesa dependencybetweenthemodules:anychangetothatdesigndecisionwillrequire changestoalloftheinvolvedmodules.Ifapieceofinformationisreflectedin theinterfaceforamodule,thenbydefinitionithasbeenleaked;thus,simpler interfacestendtocorrelatewithbetterinformationhiding.However,information can be leaked even if it doesnt appear in a modules interface.

--- Chunk 54 ---
Tokens: 328
Type: sentence-based
Text:
5.2Informationleakage Theoppositeofinformationhidingisinformationleakage.Informationleakage occurswhenadesigndecisionisreflectedinmultiplemodules.Thiscreatesa dependencybetweenthemodules:anychangetothatdesigndecisionwillrequire changestoalloftheinvolvedmodules.Ifapieceofinformationisreflectedin theinterfaceforamodule,thenbydefinitionithasbeenleaked;thus,simpler interfacestendtocorrelatewithbetterinformationhiding.However,information can be leaked even if it doesnt appear in a modules interface. Suppose two classesbothhaveknowledgeofaparticularfileformat(perhapsoneclassreads filesinthatformatandtheotherclasswritesthem).Evenifneitherclassexposes thatinformationinitsinterface,theybothdependonthefileformat:iftheformat changes,bothclasseswillneedtobemodified.Back-doorleakagelikethisis moreperniciousthanleakagethroughaninterface,becauseitisntobvious. Information leakage is one of the most important red flags in software design.Oneofthebestskillsyoucanlearnasasoftwaredesignerisahighlevel of sensitivity to information leakage. If you encounter information leakage betweenclasses,askyourselfHowcanIreorganizetheseclassessothatthis particularpieceofknowledgeonlyaffectsasingleclass?Iftheaffectedclasses arerelativelysmallandcloselytiedtotheleakedinformation,itmaymakesense to merge them into a single class.

--- Chunk 55 ---
Tokens: 397
Type: sentence-based
Text:
If you encounter information leakage betweenclasses,askyourselfHowcanIreorganizetheseclassessothatthis particularpieceofknowledgeonlyaffectsasingleclass?Iftheaffectedclasses arerelativelysmallandcloselytiedtotheleakedinformation,itmaymakesense to merge them into a single class. Another possible approach is to pull the information out of all of the affected classes and create a new class that encapsulatesjustthatinformation.However,thisapproachwillbeeffectiveonly ifyoucanfindasimpleinterfacethatabstractsawayfromthedetails;ifthenew classexposesmostoftheknowledgethroughitsinterface,thenitwontprovide muchvalue(youvesimplyreplacedback-doorleakagewithleakagethroughan interface). RedFlag:InformationLeakage Information leakage occurs when the same knowledge is used in multiple places, such as two different classes that both understand the format of a particulartypeoffile. 5.3Temporaldecomposition One common cause of information leakage is a design style I call temporal decomposition.Intemporaldecomposition,thestructureofasystemcorresponds tothetimeorderinwhichoperationswilloccur.Consideranapplicationthat reads a file in a particular format, modifies the contents of the file, and then writesthefileoutagain.Withtemporaldecomposition,thisapplicationmightbe broken into three classes: one to read the file, another to perform the modifications,andathirdtowriteoutthenewversion.Boththefilereadingand file writing steps have knowledge about the file format, which results in informationleakage.Thesolutionistocombinethecoremechanismsforreading and writing files into a single class.

--- Chunk 56 ---
Tokens: 361
Type: sentence-based
Text:
5.3Temporaldecomposition One common cause of information leakage is a design style I call temporal decomposition.Intemporaldecomposition,thestructureofasystemcorresponds tothetimeorderinwhichoperationswilloccur.Consideranapplicationthat reads a file in a particular format, modifies the contents of the file, and then writesthefileoutagain.Withtemporaldecomposition,thisapplicationmightbe broken into three classes: one to read the file, another to perform the modifications,andathirdtowriteoutthenewversion.Boththefilereadingand file writing steps have knowledge about the file format, which results in informationleakage.Thesolutionistocombinethecoremechanismsforreading and writing files into a single class. This class will get used during both the readingandwritingphasesoftheapplication.Itseasytofallintothetrapof temporal decomposition, because the order in which operations must occur is often on your mind when you code. However, most design decisions manifest themselvesatseveraldifferenttimesoverthelifeoftheapplication;asaresult, temporaldecompositionoftenresultsininformationleakage. Order usually does matter, so it will be reflected somewhere in the application.However,itshouldntbereflectedinthemodulestructureunlessthat structureisconsistentwithinformationhiding(perhapsthedifferentstagesuse totally different information). When designing modules, focus on the knowledgethatsneededtoperformeachtask,nottheorderinwhichtasks occur.

--- Chunk 57 ---
Tokens: 309
Type: sentence-based
Text:
When designing modules, focus on the knowledgethatsneededtoperformeachtask,nottheorderinwhichtasks occur. RedFlag:TemporalDecomposition Intemporaldecomposition,executionorderisreflectedinthecodestructure: operationsthathappenatdifferenttimesareindifferentmethodsorclasses.If thesameknowledgeisusedatdifferentpointsinexecution,itgetsencodedin multipleplaces,resultingininformationleakage. 5.4Example:HTTPserver Toillustratetheissuesininformationhiding,letsconsiderthedesigndecisions madebystudentsimplementingtheHTTPprotocolinasoftwaredesigncourse. Itsusefultoseeboththethingstheydidwellandtheyareaswheretheyhad problems. HTTP is a mechanism used by Web browsers to communicate with Web servers.WhenauserclicksonalinkinaWebbrowserorsubmitsaform,the browserusesHTTPtosendarequestoverthenetworktoaWebserver.Oncethe server hasprocessedthe request, it sends a response back to the browser; the response normally contains a new Web page to display. The HTTP protocol specifies the format of requests and responses, both of which are represented textually.Figure5.1showsasampleHTTPrequestdescribingaformsubmission. Thestudentsinthecoursewereaskedtoimplementoneormoreclassestomake iteasyforWebserverstoreceiveincomingHTTPrequestsandsendresponses.

--- Chunk 58 ---
Tokens: 382
Type: sentence-based
Text:
Thestudentsinthecoursewereaskedtoimplementoneormoreclassestomake iteasyforWebserverstoreceiveincomingHTTPrequestsandsendresponses. Figure5.1:APOSTrequestintheHTTPprotocolconsistsoftextsentoveraTCPsocket.Eachrequest containsaninitialline,acollectionofheadersterminatedbyanemptyline,andanoptionalbody.Theinitial line contains the request type (POST is used for submitting form data), a URL indicating an operation (commentscreate)andoptionalparameters(photo_idhasthevalue246),andtheHTTPprotocolversion usedbythesender.EachheaderlineconsistsofanamesuchasContent-Lengthfollowedbyitsvalue.For thisrequest,thebodycontainsadditionalparameters(commentandpriority). 5.5Example:toomanyclasses Themostcommonmistakemadebystudentswastodividetheircodeintoalarge numberofshallowclasses,whichledtoinformationleakagebetweentheclasses. OneteamusedtwodifferentclassesforreceivingHTTPrequests;thefirstclass readtherequestfromthenetworkconnectionintoastring,andthesecondclass parsedthestring.Thisisanexampleofatemporaldecomposition(firstweread therequest,thenweparseit).InformationleakageoccurredbecauseanHTTP request cant be read without parsing much of the message; for example, the Content-Lengthheaderspecifiesthelengthoftherequestbody,sotheheaders mustbeparsedinordertocomputethetotalrequestlength.Asaresult,both classesneededtounderstandmostofthestructureofHTTPrequests,andparsing codewasduplicatedinbothclasses.Thisapproachalsocreatedextracomplexity forcallers,whohadtoinvoketwomethodsindifferentclasses,inaparticular order,toreceivearequest.

--- Chunk 59 ---
Tokens: 256
Type: sentence-based
Text:
OneteamusedtwodifferentclassesforreceivingHTTPrequests;thefirstclass readtherequestfromthenetworkconnectionintoastring,andthesecondclass parsedthestring.Thisisanexampleofatemporaldecomposition(firstweread therequest,thenweparseit).InformationleakageoccurredbecauseanHTTP request cant be read without parsing much of the message; for example, the Content-Lengthheaderspecifiesthelengthoftherequestbody,sotheheaders mustbeparsedinordertocomputethetotalrequestlength.Asaresult,both classesneededtounderstandmostofthestructureofHTTPrequests,andparsing codewasduplicatedinbothclasses.Thisapproachalsocreatedextracomplexity forcallers,whohadtoinvoketwomethodsindifferentclasses,inaparticular order,toreceivearequest. Becausetheclassessharedsomuchinformation,itwouldhavebeenbetterto merge them into a single class that handles both request reading and parsing. This provides better information hiding, since it isolates all knowledge of the requestformatinoneclass,anditalsoprovidesasimplerinterfacetocallers(just onemethodtoinvoke).

--- Chunk 60 ---
Tokens: 382
Type: sentence-based
Text:
This provides better information hiding, since it isolates all knowledge of the requestformatinoneclass,anditalsoprovidesasimplerinterfacetocallers(just onemethodtoinvoke). This example illustrates a general theme in software design: information hidingcanoftenbeimprovedbymakingaclassslightlylarger.Onereason fordoingthisistobringtogetherallofthecoderelatedtoaparticularcapability (suchasparsinganHTTPrequest),sothattheresultingclasscontainseverything relatedtothatcapability.Asecondreasonforincreasingthesizeofaclassisto raisetheleveloftheinterface;forexample,ratherthanhavingseparatemethods foreachofthreestepsofacomputation,haveasinglemethodthatperformsthe entirecomputation.Thiscanresultinasimplerinterface.Bothofthesebenefits apply in the example of the previous paragraph: combining the classes brings togetherallofthecoderelatedtoparsinganHTTPrequest,anditreplacestwo externally-visible methods with one. The combined class is deeper than the originalclasses. Ofcourse,itispossibletotakethenotionoflargerclassestoofar(suchasa singleclassfortheentireapplication).Chapter9willdiscussconditionsunder whichitmakessensetoseparatecodeintomultiplesmallerclasses. 5.6Example:HTTPparameterhandling AfteranHTTPrequesthasbeenreceivedbyaserver,theserverneedstoaccess someoftheinformationfromtherequest.Thecodethathandlestherequestin Figure5.1mightneedtoknowthevalueofthephoto_idparameter.Parameters can be specified in the first line of the request (photo_id in Figure 5.1) or, sometimes,inthebody(commentand priority in Figure 5.1).

--- Chunk 61 ---
Tokens: 354
Type: sentence-based
Text:
5.6Example:HTTPparameterhandling AfteranHTTPrequesthasbeenreceivedbyaserver,theserverneedstoaccess someoftheinformationfromtherequest.Thecodethathandlestherequestin Figure5.1mightneedtoknowthevalueofthephoto_idparameter.Parameters can be specified in the first line of the request (photo_id in Figure 5.1) or, sometimes,inthebody(commentand priority in Figure 5.1). Each parameter hasanameandavalue.Thevaluesofparametersuseaspecialencodingcalled URLencoding;forexample,inthevalueforcommentinFigure5.1,isusedto representaspacecharacter,and21isusedinsteadof.Inordertoprocess arequest,theserverwillneedthevaluesforsomeoftheparameters,anditwill wanttheminunencodedform. Most of the student projects made two good choices with respect to parameter handling. First, they recognized that server applications dont care whetheraparameterisspecifiedintheheaderlineorthebodyoftherequest,so they hid this distinction from callers and merged the parameters from both locations together. Second, they hid knowledge of URL encoding: the HTTP parserdecodesparametervaluesbeforereturningthemtotheWebserver,sothat thevalueofthecommentparameterinFigure5.1willbereturnedasWhatacute baby, not Whatacutebaby21). In both of these cases, information hidingresultedinsimplerAPIsforthecodeusingtheHTTPmodule. However,mostofthestudentsusedaninterfaceforreturningparametersthat wastooshallow,andthisresultedinlostopportunitiesforinformationhiding.

--- Chunk 62 ---
Tokens: 330
Type: sentence-based
Text:
However,mostofthestudentsusedaninterfaceforreturningparametersthat wastooshallow,andthisresultedinlostopportunitiesforinformationhiding. Most projects used an object of type HTTPRequest to hold the parsed HTTP request,andtheHTTPRequestclasshadasinglemethodlikethefollowingoneto returnparameters: publicMapString,StringgetParams() returnthis.params;  Ratherthanreturningasingleparameter,themethodreturnsareferencetothe Mapusedinternallytostorealloftheparameters.Thismethodisshallow,andit exposes the internal representation used by the HTTPRequest class to store parameters. Any change to that representation will result in a change to the interface,whichwillrequiremodificationstoallcallers.Whenimplementations aremodified,thechangesofteninvolvechangesintherepresentationofkeydata structures(toimproveperformance,forexample).Thus,itsimportanttoavoid exposinginternaldatastructuresasmuchaspossible.Thisapproachalsomakes more work for callers: a caller must first invoke getParams, then it must call another method to retrieve a specific parameter from the Map. Finally, callers mustrealizethattheyshouldnotmodifythe Mapreturnedby getParams, since thatwillaffecttheinternalstateoftheHTTPRequest. Hereisabetterinterfaceforretrievingparametervalues: publicStringgetParameter(Stringname). publicintgetIntParameter(Stringname).

--- Chunk 63 ---
Tokens: 396
Type: sentence-based
Text:
publicintgetIntParameter(Stringname). getParameterreturnsaparametervalueasastring.Itprovidesaslightlydeeper interface than getParams above; more importantly, it hides the internal representationofparameters.getIntParameterconvertsthevalueofaparameter from its string form in the HTTP request to an integer (e.g, the photo_id parameterinFigure5.1).Thissavesthecallerfromhavingtorequeststring-to- integer conversion separately, and hides that mechanism from the caller. Additionalmethodsforotherdatatypes,suchasgetDoubleParameter,couldbe defined if needed. (All of these methods will throw exceptions if the desired parameter doesnt exist, or if it cant be converted to the requested type; the exceptiondeclarationshavebeenomittedinthecodeabove). 5.7Example:defaultsinHTTPresponses TheHTTPprojectsalsohadtoprovidesupportforgeneratingHTTPresponses. Themostcommonmistakestudentsmadeinthisareawasinadequatedefaults. EachHTTPresponsemustspecifyanHTTPprotocolversion;oneteamrequired callers to specify this version explicitly when creating a response object. However,theresponseversionmustcorrespondtothatintherequestobject,and therequestmustalreadybepassedasanargumentwhensendingtheresponse(it indicateswheretosendtheresponse).Thus,itmakesmoresensefortheHTTP classestoprovidetheresponseversionautomatically.Thecallerisunlikelyto knowwhatversiontospecify,andifthecallerdoesspecifyavalue,itprobably resultsininformationleakagebetweentheHTTPlibraryandthecaller.HTTP responsesalsoincludeaDateheaderspecifyingthetimewhentheresponsewas sent;theHTTPlibraryshouldprovideasensibledefaultforthisaswell.

--- Chunk 64 ---
Tokens: 377
Type: sentence-based
Text:
However,theresponseversionmustcorrespondtothatintherequestobject,and therequestmustalreadybepassedasanargumentwhensendingtheresponse(it indicateswheretosendtheresponse).Thus,itmakesmoresensefortheHTTP classestoprovidetheresponseversionautomatically.Thecallerisunlikelyto knowwhatversiontospecify,andifthecallerdoesspecifyavalue,itprobably resultsininformationleakagebetweentheHTTPlibraryandthecaller.HTTP responsesalsoincludeaDateheaderspecifyingthetimewhentheresponsewas sent;theHTTPlibraryshouldprovideasensibledefaultforthisaswell. Defaultsillustratetheprinciplethatinterfacesshouldbedesignedtomake the common case as simple as possible. They are also an example of partial information hiding: in the normal case, the caller need not be aware of the existenceofthedefaulteditem.Intherarecaseswhereacallerneedstooverride adefault,itwillhavetoknowaboutthevalue,anditcaninvokeaspecialmethod tomodifyit. Whenever possible, classes should do the right thing without being explicitlyasked.Defaultsareanexampleofthis.TheJavaIOexampleonpage 26illustratesthispointinanegativeway.BufferinginfileIOissouniversally desirablethatnooneshouldeverhavetoaskexplicitlyforit,orevenbeawareof its existence; the IO classes should do the right thing and provide it automatically.Thebestfeaturesaretheonesyougetwithoutevenknowingthey exist. RedFlag:Overexposure If the API for a commonly used feature forces users to learn about other featuresthatarerarelyused,thisincreasesthecognitiveloadonuserswho dontneedtherarelyusedfeatures.

--- Chunk 65 ---
Tokens: 394
Type: sentence-based
Text:
RedFlag:Overexposure If the API for a commonly used feature forces users to learn about other featuresthatarerarelyused,thisincreasesthecognitiveloadonuserswho dontneedtherarelyusedfeatures. 5.8Informationhidingwithinaclass Theexamplesinthischapterfocusedoninformationhidingasitrelatestothe externallyvisibleAPIsforclasses,butinformationhidingcanalsobeappliedat other levels in the system, such as within a class. Try to design the private methodswithinaclasssothateachmethodencapsulatessomeinformationor capabilityandhidesitfromtherestoftheclass.Inaddition,trytominimizethe numberofplaceswhereeachinstancevariableisused.Somevariablesmayneed tobeaccessedwidelyacrosstheclass,butothersmaybeneededinonlyafew places;ifyoucanreducethenumberofplaceswhereavariableisused,youwill eliminatedependencieswithintheclassandreduceitscomplexity. 5.9Takingittoofar Informationhidingonlymakessensewhentheinformationbeinghiddenisnot neededoutsideitsmodule.Iftheinformationisneededoutsidethemodule,then youmustnothideit.Supposethattheperformanceofamoduleisaffectedby certain configuration parameters, and that different uses of the module will requiredifferentsettingsoftheparameters.Inthiscaseitisimportantthatthe parametersareexposedintheinterfaceofthemodule,sothattheycanbeturned appropriately. As a software designer, your goal should be to minimize the amountofinformationneededoutsideamodule;forexample,ifamodulecan automaticallyadjustitsconfiguration,thatisbetterthanexposingconfiguration parameters.But,itsimportanttorecognizewhichinformationisneededoutside amoduleandmakesureitisexposed.

--- Chunk 66 ---
Tokens: 394
Type: sentence-based
Text:
As a software designer, your goal should be to minimize the amountofinformationneededoutsideamodule;forexample,ifamodulecan automaticallyadjustitsconfiguration,thatisbetterthanexposingconfiguration parameters.But,itsimportanttorecognizewhichinformationisneededoutside amoduleandmakesureitisexposed. 5.10Conclusion Informationhidinganddeepmodulesarecloselyrelated.Ifamodulehidesalot ofinformation,thattendstoincreasetheamountoffunctionalityprovidedbythe module while also reducing its interface. This makes the module deeper. Conversely, if a module doesnt hide much information, then either it doesnt havemuchfunctionality,orithasacomplexinterface;eitherway,themoduleis shallow. Whendecomposingasystemintomodules,trynottobeinfluencedbythe orderinwhichoperationswilloccuratruntime;thatwillleadyoudownthepath oftemporaldecomposition,whichwillresultininformationleakageandshallow modules.Instead,thinkaboutthedifferentpiecesofknowledgethatareneeded tocarryoutthetasksofyourapplication,anddesigneachmoduletoencapsulate oneorafewofthosepiecesofknowledge.Thiswillproduceacleanandsimple designwithdeepmodules. 1DavidParnas,OntheCriteriatobeUsedinDecomposingSystemsintoModules,Communications oftheACM,December1972. Chapter6 General-PurposeModulesareDeeper One of the most common decisions that you will face when designing a new module is whether to implement it in a general-purpose or special-purpose fashion.Somemightarguethatyoushouldtakeageneral-purposeapproach,in whichyouimplementamechanismthatcanbeusedtoaddressabroadrangeof problems, not just the ones that are important today.

--- Chunk 67 ---
Tokens: 346
Type: sentence-based
Text:
Chapter6 General-PurposeModulesareDeeper One of the most common decisions that you will face when designing a new module is whether to implement it in a general-purpose or special-purpose fashion.Somemightarguethatyoushouldtakeageneral-purposeapproach,in whichyouimplementamechanismthatcanbeusedtoaddressabroadrangeof problems, not just the ones that are important today. In this case, the new mechanismmayfindunanticipatedusesinthefuture,therebysavingtime.The general-purpose approach seems consistent with the investment mindset discussedinChapter3,whereyouspendabitmoretimeupfronttosavetime lateron. Ontheotherhand,weknowthatitshardtopredictthefutureneedsofa softwaresystem,soageneral-purposesolutionmightincludefacilitiesthatare never actually needed. Furthermore, if you implement something that is too general-purpose,itmightnotdoagoodjobofsolvingtheparticularproblemyou have today. As a result, some might argue that its better to focus on todays needs,buildingjustwhatyouknowyouneed,andspecializingitforthewayyou plan to use it today. If you take the special-purpose approach and discover additionaluseslater,youcanalwaysrefactorittomakeitgeneral-purpose.The special-purpose approach seems consistent with an incremental approach to softwaredevelopment. 6.1Makeclassessomewhatgeneral-purpose Inmyexperience,thesweetspotistoimplementnewmodulesinasomewhat general-purpose fashion.

--- Chunk 68 ---
Tokens: 370
Type: sentence-based
Text:
6.1Makeclassessomewhatgeneral-purpose Inmyexperience,thesweetspotistoimplementnewmodulesinasomewhat general-purpose fashion. The phrase somewhat general-purpose means that the modules functionality should reflect your current needs, but its interface shouldnot.Instead,theinterfaceshouldbegeneralenoughtosupportmultiple uses.Theinterfaceshouldbeeasytousefortodaysneedswithoutbeingtied specificallytothem.Thewordsomewhatisimportant:dontgetcarriedaway andbuildsomethingsogeneral-purposethatitisdifficulttouseforyourcurrent needs. Themostimportant(andperhapssurprising)benefitofthegeneral-purpose approachisthatitresultsinsimpleranddeeperinterfacesthanaspecial-purpose approach.Thegeneral-purposeapproachcanalsosaveyoutimeinthefuture,if youreusetheclassforotherpurposes.However,evenifthemoduleisonlyused foritsoriginalpurpose,thegeneral-purposeapproachisstillbetterbecauseofits simplicity. 6.2Example:storingtextforaneditor Letsconsideranexamplefromasoftwaredesignclassinwhichstudentswere askedtobuildsimpleGUItexteditors.Theeditorshadtodisplayafileandallow userstopoint,click,andtypetoeditthefile.Theeditorshadtosupportmultiple simultaneous views of the same file in different windows; they also had to supportmulti-levelundoandredoformodificationstothefile. Eachofthestudentprojectsincludedaclassthatmanagedtheunderlyingtext of thefile. The text classes typically provided methods for loading afileinto memory,readingandmodifyingthetextofthefile,andwritingthemodifiedtext backtoafile.

--- Chunk 69 ---
Tokens: 411
Type: sentence-based
Text:
The text classes typically provided methods for loading afileinto memory,readingandmodifyingthetextofthefile,andwritingthemodifiedtext backtoafile. Many of the student teams implemented special-purpose APIs for the text class.Theyknewthattheclasswasgoingtobeusedinaninteractiveeditor,so theythoughtaboutthefeaturesthattheeditorhadtoprovideandtailoredtheAPI ofthetextclasstothosespecificfeatures.Forexample,ifauseroftheeditor typedthebackspacekey,theeditordeletedthecharacterimmediatelytotheleft ofthecursor;iftheusertypedthedeletekey,theeditordeletedthecharacter immediatelytotherightofthecursor.Knowingthis,someoftheteamscreated onemethodinthetextclasstosupporteachofthesespecificfeatures: voidbackspace(Cursorcursor); voiddelete(Cursorcursor); Eachofthesemethodstakesthecursorpositionasitsargument;aspecialtype Cursorrepresentsthisposition.Theeditoralsohadtosupportaselectionthat couldbecopiedordeleted.Thestudentshandledthisbydefininga Selection classandpassinganobjectofthisclasstothetextclassduringdeletions: voiddeleteSelection(Selectionselection); Thestudentsprobablythoughtthatitwouldbeeasiertoimplementtheuser interfaceifthemethodsofthetextclasscorrespondedtothefeaturesvisibleto users.Inreality,however,thisspecializationprovidedlittlebenefitfortheuser interfacecode,anditcreatedahighcognitiveloadfordevelopersworkingon eithertheuserinterfaceorthetextclass.Thetextclassendedupwithalarge number of shallow methods, each of which was only suitable for one user interfaceoperation.Manyofthemethods,suchasdelete,wereonlyinvokedina singleplace.Asaresult,adeveloperworkingontheuserinterfacehadtolearn aboutalargenumberofmethodsforthetextclass.

--- Chunk 70 ---
Tokens: 437
Type: sentence-based
Text:
Many of the student teams implemented special-purpose APIs for the text class.Theyknewthattheclasswasgoingtobeusedinaninteractiveeditor,so theythoughtaboutthefeaturesthattheeditorhadtoprovideandtailoredtheAPI ofthetextclasstothosespecificfeatures.Forexample,ifauseroftheeditor typedthebackspacekey,theeditordeletedthecharacterimmediatelytotheleft ofthecursor;iftheusertypedthedeletekey,theeditordeletedthecharacter immediatelytotherightofthecursor.Knowingthis,someoftheteamscreated onemethodinthetextclasstosupporteachofthesespecificfeatures: voidbackspace(Cursorcursor); voiddelete(Cursorcursor); Eachofthesemethodstakesthecursorpositionasitsargument;aspecialtype Cursorrepresentsthisposition.Theeditoralsohadtosupportaselectionthat couldbecopiedordeleted.Thestudentshandledthisbydefininga Selection classandpassinganobjectofthisclasstothetextclassduringdeletions: voiddeleteSelection(Selectionselection); Thestudentsprobablythoughtthatitwouldbeeasiertoimplementtheuser interfaceifthemethodsofthetextclasscorrespondedtothefeaturesvisibleto users.Inreality,however,thisspecializationprovidedlittlebenefitfortheuser interfacecode,anditcreatedahighcognitiveloadfordevelopersworkingon eithertheuserinterfaceorthetextclass.Thetextclassendedupwithalarge number of shallow methods, each of which was only suitable for one user interfaceoperation.Manyofthemethods,suchasdelete,wereonlyinvokedina singleplace.Asaresult,adeveloperworkingontheuserinterfacehadtolearn aboutalargenumberofmethodsforthetextclass. Thisapproachcreatedinformationleakagebetweentheuserinterfaceandthe textclass.Abstractionsrelatedtotheuserinterface,suchastheselectionorthe backspacekey,werereflectedinthetextclass;thisincreasedthecognitiveload for developers working on the text class.

--- Chunk 71 ---
Tokens: 397
Type: sentence-based
Text:
Thisapproachcreatedinformationleakagebetweentheuserinterfaceandthe textclass.Abstractionsrelatedtotheuserinterface,suchastheselectionorthe backspacekey,werereflectedinthetextclass;thisincreasedthecognitiveload for developers working on the text class. Each new user interface operation requiredanewmethodtobedefinedinthetextclass,soadeveloperworkingon theuserinterfacewaslikelytoendupworkingonthetextclassaswell.Oneof thegoalsinclassdesignistoalloweachclasstobedevelopedindependently,but thespecializedapproachtiedtheuserinterfaceandtextclassestogether. 6.3Amoregeneral-purposeAPI A better approach is to make the text class more generic. Its API should be definedonlyintermsofbasictextfeatures,withoutreflectingthehigher-level operationsthatwillbeimplementedwithit.Forexample,onlytwomethodsare neededformodifyingtext: voidinsert(Positionposition,StringnewText); voiddelete(Positionstart,Positionend); The first method inserts an arbitrary string at an arbitrary position within the text,andthesecondmethoddeletesallofthecharactersatpositionsgreaterthan or equal to start but less than end. This API also uses a more generic type Position instead of Cursor, which reflects a specific user interface. The text class should also provide general-purpose facilities for manipulating positions withinthetext,suchasthefollowing: PositionchangePosition(Positionposition,intnumChars); Thismethodreturnsanewpositionthatisagivennumberofcharactersaway fromagivenposition.IfthenumCharsargumentispositive,thenewpositionis laterinthefilethanposition;ifnumCharsisnegative,thenewpositionisbefore position.

--- Chunk 72 ---
Tokens: 363
Type: sentence-based
Text:
The text class should also provide general-purpose facilities for manipulating positions withinthetext,suchasthefollowing: PositionchangePosition(Positionposition,intnumChars); Thismethodreturnsanewpositionthatisagivennumberofcharactersaway fromagivenposition.IfthenumCharsargumentispositive,thenewpositionis laterinthefilethanposition;ifnumCharsisnegative,thenewpositionisbefore position. The method automatically skips to the next or previous line when necessary. With these methods, the delete key can be implemented with the followingcode(assumingthecursorvariableholdsthecurrentcursorposition): text.delete(cursor,text.changePosition(cursor,1)); Similarly,thebackspacekeycanbeimplementedasfollows: text.delete(text.changePosition(cursor,-1),cursor); With the general-purpose text API, the code to implement user interface functions such as delete and backspace is a bit longer than with the original approachusingaspecializedtextAPI.However,thenewcodeismoreobvious thantheoldcode.Adeveloperworkingintheuserinterfacemoduleprobably cares about which characters are deleted by the backspace key. With the new code,thisisobvious.Withtheoldcode,thedeveloperhadtogotothetextclass andreadthedocumentationandorcodeofthebackspacemethodtoverifythe behavior.Furthermore,thegeneral-purposeapproachhaslesscodeoverallthan the specialized approach, since it replaces a large number of special-purpose methodsinthetextclasswithasmallernumberofgeneral-purposeones.

--- Chunk 73 ---
Tokens: 356
Type: sentence-based
Text:
With the new code,thisisobvious.Withtheoldcode,thedeveloperhadtogotothetextclass andreadthedocumentationandorcodeofthebackspacemethodtoverifythe behavior.Furthermore,thegeneral-purposeapproachhaslesscodeoverallthan the specialized approach, since it replaces a large number of special-purpose methodsinthetextclasswithasmallernumberofgeneral-purposeones. Atextclassimplementedwiththegeneral-purposeinterfacecouldpotentially beusedforotherpurposesbesidesaninteractiveeditor.Asoneexample,suppose youwerebuildinganapplicationthatmodifiedaspecifiedfilebyreplacingall occurrences of a particular string with another string. Methods from the specializedtextclass,suchasbackspaceanddelete,wouldhavelittlevaluefor this application. However, the general-purpose text class would already have mostofthefunctionalityneededforthenewapplication.Allthatismissingisa methodtosearchforthenextoccurrenceofagivenstring,suchasthis: PositionfindNext(Positionstart,Stringstring); Ofcourse,aninteractivetexteditorislikelytohaveamechanismforsearching andreplacing,inwhichcasethetextclasswouldalreadyincludethismethod. 6.4Generalityleadstobetterinformationhiding Thegeneral-purposeapproachprovidesacleanerseparationbetweenthetextand userinterfaceclasses,whichresultsinbetterinformationhiding.Thetextclass neednotbeawareofspecificsoftheuserinterface,suchashowthebackspace key is handled; these details are now encapsulated in the user interface class.

--- Chunk 74 ---
Tokens: 378
Type: sentence-based
Text:
6.4Generalityleadstobetterinformationhiding Thegeneral-purposeapproachprovidesacleanerseparationbetweenthetextand userinterfaceclasses,whichresultsinbetterinformationhiding.Thetextclass neednotbeawareofspecificsoftheuserinterface,suchashowthebackspace key is handled; these details are now encapsulated in the user interface class. New user interface features can be added without creating new supporting functionsinthetextclass.Thegeneral-purposeinterfacealsoreducescognitive load:adeveloperworkingontheuserinterfaceonlyneedstolearnafewsimple methods,whichcanbereusedforavarietyofpurposes. Thebackspacemethodintheoriginalversionofthetextclasswasafalse abstraction.Itpurportedtohideinformationaboutwhichcharactersaredeleted, buttheuserinterfacemodulereallyneedstoknowthis;userinterfacedevelopers are likely to read the code of the backspace method in order to confirm its precisebehavior.Puttingthemethodinthetextclassjustmakesitharderforuser interfacedeveloperstogettheinformationtheyneed.Oneofthemostimportant elementsofsoftwaredesignisdeterminingwhoneedstoknowwhat,andwhen. Whenthedetailsareimportant,itisbettertomakethemexplicitandasobvious as possible, such as the revised implementation of the backspace operation. Hidingthisinformationbehindaninterfacejustcreatesobscurity. 6.5Questionstoaskyourself Itiseasiertorecognizeacleangeneral-purposeclassdesignthanitistocreate one.Herearesomequestionsyoucanaskyourself,whichwillhelpyoutofind therightbalancebetweengeneral-purposeandspecial-purposeforaninterface.

--- Chunk 75 ---
Tokens: 387
Type: sentence-based
Text:
6.5Questionstoaskyourself Itiseasiertorecognizeacleangeneral-purposeclassdesignthanitistocreate one.Herearesomequestionsyoucanaskyourself,whichwillhelpyoutofind therightbalancebetweengeneral-purposeandspecial-purposeforaninterface. Whatisthesimplestinterfacethatwillcoverallmycurrentneeds?Ifyou reducethenumberofmethodsinanAPIwithoutreducingitsoverallcapabilities, then you are probably creating more general-purpose methods. The special- purposetextAPIhadatleastthreemethodsfordeletingtext:backspace,delete, anddeleteSelection.Themoregeneral-purposeAPIhadonlyonemethodfor deletingtext,whichservedallthreepurposes.Reducingthenumberofmethods makessenseonlyaslongastheAPIforeachindividualmethodstayssimple;if youhavetointroducelotsofadditionalargumentsinordertoreducethenumber ofmethods,thenyoumaynotreallybesimplifyingthings. Inhowmanysituationswillthismethodbeused?Ifamethodisdesignedfor oneparticularuse,suchasthebackspacemethod,thatisaredflagthatitmaybe toospecial-purpose.Seeifyoucanreplaceseveralspecial-purposemethodswith asinglegeneral-purposemethod. IsthisAPIeasytouseformycurrentneeds?Thisquestioncanhelpyouto determinewhenyouhavegonetoofarinmakinganAPIsimpleandgeneral- purpose. If you have to write a lot of additional code to use a class for your current purpose, thats a red flag that the interface doesnt provide the right functionality.Forexample,oneapproachforthetextclasswouldbetodesignit aroundsingle-characteroperations:insertinsertsasinglecharacteranddelete deletes a single character. This API is both simple and general-purpose.

--- Chunk 76 ---
Tokens: 382
Type: sentence-based
Text:
This API is both simple and general-purpose. However,itwouldnotbeparticularlyeasytouseforatexteditor:higher-level code would contain lots of loops to insert or delete ranges of characters. The single-characterapproachwouldalsobeinefficientforlargeoperations.Thusits better for the text class to have built-in support for operations on ranges of characters. 6.6Conclusion General-purpose interfaces have many advantages over special-purpose ones. Theytendtobesimpler,withfewermethodsthataredeeper.Theyalsoprovidea cleaner separation between classes, whereas special-purpose interfaces tend to leak information between classes. Making your modules somewhat general- purposeisoneofthebestwaystoreduceoverallsystemcomplexity. Chapter7 DifferentLayer,DifferentAbstraction Softwaresystemsarecomposedinlayers,wherehigherlayersusethefacilities provided by lower layers. In a well-designed system, each layer provides a differentabstractionfromthelayersaboveandbelowit;ifyoufollowasingle operation as it moves up and down through layers by invoking methods, the abstractionschangewitheachmethodcall.Forexample: Inafilesystem,theuppermostlayerimplementsafileabstraction.Afile consistsofavariable-lengtharrayofbytes,whichcanbeupdatedby readingandwritingvariable-lengthbyteranges.Thenextlowerlayerinthe filesystemimplementsacacheinmemoryoffixed-sizediskblocks;callers canassumethatfrequentlyusedblockswillstayinmemorywheretheycan beaccessedquickly.Thelowestlayerconsistsofdevicedrivers,whichmove blocksbetweensecondarystoragedevicesandmemory.

--- Chunk 77 ---
Tokens: 397
Type: sentence-based
Text:
In a well-designed system, each layer provides a differentabstractionfromthelayersaboveandbelowit;ifyoufollowasingle operation as it moves up and down through layers by invoking methods, the abstractionschangewitheachmethodcall.Forexample: Inafilesystem,theuppermostlayerimplementsafileabstraction.Afile consistsofavariable-lengtharrayofbytes,whichcanbeupdatedby readingandwritingvariable-lengthbyteranges.Thenextlowerlayerinthe filesystemimplementsacacheinmemoryoffixed-sizediskblocks;callers canassumethatfrequentlyusedblockswillstayinmemorywheretheycan beaccessedquickly.Thelowestlayerconsistsofdevicedrivers,whichmove blocksbetweensecondarystoragedevicesandmemory. InanetworktransportprotocolsuchasTCP,theabstractionprovidedbythe topmostlayerisastreamofbytesdeliveredreliablyfromonemachineto another.Thislevelisbuiltonalowerlevelthattransmitspacketsofbounded sizebetweenmachinesonabest-effortbasis:mostpacketswillbedelivered successfully,butsomepacketsmaybelostordeliveredoutoforder. Ifasystemcontainsadjacentlayerswithsimilarabstractions,thisisared flagthatsuggestsaproblemwiththeclassdecomposition.Thischapterdiscusses situationswherethishappens,theproblemsthatresult,andhowtorefactorto eliminatetheproblems. 7.1Pass-throughmethods When adjacent layers have similar abstractions, the problem often manifests itselfintheformofpass-throughmethods.Apass-throughmethodisonethat doeslittleexceptinvokeanothermethod,whosesignatureissimilaroridentical tothatofthecallingmethod.Forexample,astudentprojectimplementingaGUI texteditorcontainedaclassconsistingalmostentirelyofpass-throughmethods.

--- Chunk 78 ---
Tokens: 291
Type: sentence-based
Text:
7.1Pass-throughmethods When adjacent layers have similar abstractions, the problem often manifests itselfintheformofpass-throughmethods.Apass-throughmethodisonethat doeslittleexceptinvokeanothermethod,whosesignatureissimilaroridentical tothatofthecallingmethod.Forexample,astudentprojectimplementingaGUI texteditorcontainedaclassconsistingalmostentirelyofpass-throughmethods. Hereisanextractfromthatclass: publicclassTextDocument. privateTextAreatextArea; privateTextDocumentListenerlistener; . publicCharactergetLastTypedCharacter() returntextArea.getLastTypedCharacter();  publicintgetCursorOffset() returntextArea.getCursorOffset();  publicvoidinsertString(StringtextToInsert, intoffset) textArea.insertString(textToInsert,offset);  publicvoidwillInsertString(StringstringToInsert,intoffset) if(listener!null) listener.willInsertString(this,stringToInsert,offset);   . 13ofthe15publicmethodsinthatclasswerepass-throughmethods. RedFlag:Pass-ThroughMethod Apass-throughmethodisonethatdoesnothingexceptpassitsargumentsto anothermethod,usuallywiththesameAPIasthepass-throughmethod.This typicallyindicatesthatthereisnotacleandivisionofresponsibilitybetween theclasses.

--- Chunk 79 ---
Tokens: 355
Type: sentence-based
Text:
RedFlag:Pass-ThroughMethod Apass-throughmethodisonethatdoesnothingexceptpassitsargumentsto anothermethod,usuallywiththesameAPIasthepass-throughmethod.This typicallyindicatesthatthereisnotacleandivisionofresponsibilitybetween theclasses. Pass-through methods make classes shallower: they increase the interface Pass-through methods make classes shallower: they increase the interface complexityoftheclass,whichaddscomplexity,buttheydontincreasethetotal functionalityofthesystem.Ofthefourmethodsabove,onlythelastonehasany functionality,andeventhereitistrivial:themethodchecksthevalidityofone variable.Pass-throughmethodsalsocreatedependenciesbetweenclasses:ifthe signature changes for the insertString method in TextArea, then the insertStringmethodinTextDocumentwillhavetochangetomatch. Pass-through methods indicate that there is confusion over the division of responsibility between classes. In the example above, the TextDocument class offers an insertString method, but the functionality for inserting text is implementedentirelyinTextArea.Thisisusuallyabadidea:theinterfacetoa piece of functionality should be in the same class that implements the functionality. When you see pass-through methods from one class to another, consider the two classes and ask yourself Exactly which features and abstractionsiseachoftheseclassesresponsiblefor?Youwillprobablynotice thatthereisanoverlapinresponsibilitybetweentheclasses.

--- Chunk 80 ---
Tokens: 399
Type: sentence-based
Text:
When you see pass-through methods from one class to another, consider the two classes and ask yourself Exactly which features and abstractionsiseachoftheseclassesresponsiblefor?Youwillprobablynotice thatthereisanoverlapinresponsibilitybetweentheclasses. Thesolutionistorefactortheclassessothateachclasshasadistinctand coherentsetofresponsibilities.Figure7.1illustratesseveralwaystodothis.One approach,showninFigure7.1(b),istoexposethelowerlevelclassdirectlytothe callersofthehigherlevelclass,removingallresponsibilityforthefeaturefrom the higher level class. Another approach is to redistribute the functionality between the classes, as in Figure 7.1(c). Finally, if the classes cant be disentangled,thebestsolutionmaybetomergethemasinFigure7.1(d). In the example above, there were three classes with intertwined responsibilities: TextDocument, TextArea, and TextDocumentListener. The student eliminated the pass-through methods by moving methods between classesandcollapsingthethreeclassesintojusttwo,whoseresponsibilitieswere moreclearlydifferentiated. 7.2WhenisinterfaceduplicationOK? Havingmethodswiththesamesignatureisnotalwaysbad.Theimportantthing isthateachnewmethodshouldcontributesignificantfunctionality.Pass-through methodsarebadbecausetheycontributenonewfunctionality. Oneexamplewhereitsusefulforamethodtocallanothermethodwiththe samesignatureisadispatcher.Adispatcherisamethodthatusesitsarguments toselectoneofseveralothermethodstoinvoke;thenitpassesmostorallofits argumentstothechosenmethod.Thesignatureforthedispatcherisoftenthe same as the signature for the methods that it calls.

--- Chunk 81 ---
Tokens: 386
Type: sentence-based
Text:
Oneexamplewhereitsusefulforamethodtocallanothermethodwiththe samesignatureisadispatcher.Adispatcherisamethodthatusesitsarguments toselectoneofseveralothermethodstoinvoke;thenitpassesmostorallofits argumentstothechosenmethod.Thesignatureforthedispatcherisoftenthe same as the signature for the methods that it calls. Even so, the dispatcher providesusefulfunctionality:itchooseswhichofseveralothermethodsshould carryouteachtask. Figure7.1:Pass-throughmethods.In(a),classC1containsthreepass-throughmethods,whichdonothing butinvokemethodswiththesamesignatureinC2(eachsymbolrepresentsaparticularmethodsignature). The pass-through methods can be eliminated by having C1s callers invoke C2 directly as in (b), by redistributingfunctionalitybetweenC1andC2toavoidcallsbetweentheclassesasin(c),orbycombining theclassesasin(d). Forexample,whenaWebserverreceivesanincomingHTTPrequestfroma Web browser, it invokes a dispatcher that examines the URL in the incoming requestandselectsaspecificmethodtohandletherequest.SomeURLsmightbe handledbyreturningthecontentsofafileondisk;othersmightbehandledby invoking a procedure in a language such as PHP or JavaScript. The dispatch process can be quite intricate, and is usually driven by a set of rules that are matchedagainsttheincomingURL. Itisfineforseveralmethodstohavethesamesignatureaslongaseachof them provides useful and distinct functionality. The methods invoked by a dispatcher have this property. Another example is interfaces with multiple implementations, such as disk drivers in an operating system.

--- Chunk 82 ---
Tokens: 391
Type: sentence-based
Text:
Another example is interfaces with multiple implementations, such as disk drivers in an operating system. Each driver providessupportforadifferentkindofdisk,buttheyallhavethesameinterface. Whenseveralmethodsprovidedifferentimplementationsofthesameinterface, itreducescognitiveload.Onceyouhaveworkedwithoneofthesemethods,its easier to work with the others, since you dont need to learn a new interface. Methodslikethisareusuallyinthesamelayerandtheydontinvokeeachother. 7.3Decorators Thedecoratordesignpattern(alsoknownasawrapper)isonethatencourages API duplication across layers. A decorator object takes an existing object and extendsitsfunctionality;itprovidesanAPIsimilaroridenticaltotheunderlying object,anditsmethodsinvokethemethodsoftheunderlyingobject.IntheJava IOexamplefromChapter4,theBufferedInputStreamclassisadecorator:given anInputStreamobject,itprovidesthesameAPIbutintroducesbuffering.For example,whenitsreadmethodisinvokedtoreadasinglecharacter,itinvokes readontheunderlyingInputStreamtoreadamuchlargerblock,andsavesthe extra characters to satisfy future read calls. Another example occurs in windowingsystems:aWindowclassimplementsasimpleformofwindowthatis not scrollable, and a ScrollableWindow class decorates the Window class by addinghorizontalandverticalscrollbars. Themotivationfordecoratorsistoseparatespecial-purposeextensionsofa classfromamoregenericcore.However,decoratorclassestendtobeshallow: they introduce a large amount of boilerplate for a small amount of new functionality. Decorator classesoften contain many pass-through methods.

--- Chunk 83 ---
Tokens: 343
Type: sentence-based
Text:
Decorator classesoften contain many pass-through methods. Its easytooverusethedecoratorpattern,creatinganewclassforeverysmallnew feature. This results in an explosion of shallow classes, such as the Java IO example. Beforecreatingadecoratorclass,consideralternativessuchasthefollowing: Couldyouaddthenewfunctionalitydirectlytotheunderlyingclass,rather thancreatingadecoratorclass?Thismakessenseifthenewfunctionalityis relativelygeneral-purpose,orifitislogicallyrelatedtotheunderlyingclass, orifmostusesoftheunderlyingclasswillalsousethenewfunctionality. Forexample,virtuallyeveryonewhocreatesaJavaInputStreamwillalso createaBufferedInputStream,andbufferingisanaturalpartofIO,so theseclassesshouldhavebeencombined. Ifthenewfunctionalityisspecializedforaparticularusecase,wouldit makesensetomergeitwiththeusecase,ratherthancreatingaseparate class? Couldyoumergethenewfunctionalitywithanexistingdecorator,rather thancreatinganewdecorator?Thiswouldresultinasingledeeper decoratorclassratherthanmultipleshallowones. Finally,askyourselfwhetherthenewfunctionalityreallyneedstowrapthe existingfunctionality:couldyouimplementitasastand-aloneclassthatis independentofthebaseclass?Inthewindowingexample,thescrollbars couldprobablybeimplementedseparatelyfromthemainwindow,without wrappingallofitsexistingfunctionality. Sometimesdecoratorsmakesense,butthereisusuallyabetteralternative.

--- Chunk 84 ---
Tokens: 354
Type: sentence-based
Text:
Sometimesdecoratorsmakesense,butthereisusuallyabetteralternative. 7.4Interfaceversusimplementation Anotherapplicationofthedifferentlayer,differentabstractionruleisthatthe interface of a class should normally be different from its implementation: the representations used internally should be different from the abstractions that appear in the interface. If the two have similar abstractions, then the class probably isnt very deep. For example, in the text editor project discussed in Chapter6,mostoftheteamsimplementedthetextmoduleintermsoflinesof text,witheachlinestoredseparately.SomeoftheteamsalsodesignedtheAPIs for the text class around lines, with methods such as getLine and putLine. However,thismadethetextclassshallowandawkwardtouse.Inthehigher-level userinterfacecode,itscommontoinserttextinthemiddleofaline(e.g,when the user is typing) or to delete a range of text that spans lines. With a line- oriented API for the text class, callers were forced to split and join lines to implement the user-interface operations. This code was nontrivial and it was duplicatedandscatteredacrosstheimplementationoftheuserinterface. The text classes were much easier to use when they provided a character- orientedinterface,suchasan insertmethodthatinsertsanarbitrarystringof text (which may include newlines) at an arbitrary position in the text and a deletemethodthatdeletesthetextbetweentwoarbitrarypositionsinthetext.

--- Chunk 85 ---
Tokens: 398
Type: sentence-based
Text:
The text classes were much easier to use when they provided a character- orientedinterface,suchasan insertmethodthatinsertsanarbitrarystringof text (which may include newlines) at an arbitrary position in the text and a deletemethodthatdeletesthetextbetweentwoarbitrarypositionsinthetext. Internally,thetextwasstillrepresentedintermsoflines.Acharacter-oriented interfaceencapsulatesthecomplexityoflinesplittingandjoininginsidethetext class, which makes the text class deeper and simplifies higher level code that usestheclass.Withthisapproach,thetextAPIisquitedifferentfromtheline- oriented storage mechanism; the difference represents valuable functionality providedbytheclass. 7.5Pass-throughvariables AnotherformofAPIduplicationacrosslayersisapass-throughvariable,which isavariablethatispasseddownthroughalongchainofmethods.Figure7.2(a) shows an example from a datacenter service. A command-line argument describescertificatestouseforsecurecommunication.Thisinformationisonly neededbyalow-levelmethodm3,whichcallsalibrarymethodtoopenasocket, butitispasseddownthroughallthemethodsonthepathbetweenmainandm3. Thecertvariableappearsinthesignatureofeachoftheintermediatemethods. Pass-through variables add complexity because they force all of the intermediatemethodstobeawareoftheirexistence,eventhoughthemethods have no use for the variables. Furthermore, if a new variable comes into existence(forexample,asystemisinitiallybuiltwithoutsupportforcertificates, butyoulaterdecidetoaddthatsupport),youmayhavetomodifyalargenumber ofinterfacesandmethodstopassthevariablethroughalloftherelevantpaths.

--- Chunk 86 ---
Tokens: 400
Type: sentence-based
Text:
Furthermore, if a new variable comes into existence(forexample,asystemisinitiallybuiltwithoutsupportforcertificates, butyoulaterdecidetoaddthatsupport),youmayhavetomodifyalargenumber ofinterfacesandmethodstopassthevariablethroughalloftherelevantpaths. Eliminatingpass-throughvariablescanbechallenging.Oneapproachisto see if there is already an object shared between the topmost and bottommost methods. In the datacenter service example of Figure 7.2, perhaps there is an object containing other information about network communication, which is availabletobothmainandm3.Ifso,maincanstorethecertificateinformationin thatobject,soitneedntbepassedthroughalloftheinterveningmethodsonthe pathtom3(seeFigure7.2(b)).However,ifthereissuchanobject,thenitmay itselfbeapass-throughvariable(howelsedoesm3getaccesstoit?). Anotherapproachistostoretheinformationinaglobalvariable,asinFigure 7.2(c).Thisavoidstheneedtopasstheinformationfrommethodtomethod,but global variables almost always create other problems. For example, global variables make it impossible to create two independent instances of the same systeminthesameprocess,sinceaccessestotheglobalvariableswillconflict.It may seem unlikely that you would need multiple instances in production, but theyareoftenusefulintesting. ThesolutionIusemostoftenistointroduceacontextobjectasinFigure 7.2(d).Acontextstoresalloftheapplicationsglobalstate(anythingthatwould otherwisebeapass-throughvariableorglobalvariable).Mostapplicationshave multiplevariablesintheirglobalstate,representingthingssuchasconfiguration options, shared subsystems, and performance counters.

--- Chunk 87 ---
Tokens: 378
Type: sentence-based
Text:
ThesolutionIusemostoftenistointroduceacontextobjectasinFigure 7.2(d).Acontextstoresalloftheapplicationsglobalstate(anythingthatwould otherwisebeapass-throughvariableorglobalvariable).Mostapplicationshave multiplevariablesintheirglobalstate,representingthingssuchasconfiguration options, shared subsystems, and performance counters. There is one context objectperinstanceofthesystem.Thecontextallowsmultipleinstancesofthe systemtocoexistinasingleprocess,eachwithitsowncontext. Unfortunately,thecontextwillprobablybeneededinmanyplaces,soitcan potentiallybecomeapass-throughvariable.Toreducethenumberofmethods thatmustbeawareofit,areferencetothecontextcanbesavedinmostofthe systemsmajorobjects.IntheexampleofFigure7.2(d),theclasscontainingm3 storesareferencetothecontextasaninstancevariableinitsobjects.Whena newobjectiscreated,thecreatingmethodretrievesthecontextreferencefromits objectandpassesittotheconstructorforthenewobject.Withthisapproach,the contextisavailableeverywhere,butitonlyappearsasanexplicitargumentin constructors. Figure7.2: Possible techniques for dealing with a pass-through variable. In (a), cert is passed through methodsm1andm2eventhoughtheydontuseit.In(b),mainandm3havesharedaccesstoanobject,so thevariablecanbestoredthereinsteadofpassingitthroughm1andm2.In(c),certisstoredasaglobal variable. In (d), cert is stored in a context object along with other system-wide information, such as a timeoutvalueandperformancecounters;areferencetothecontextisstoredinallobjectswhosemethods needaccesstoit.

--- Chunk 88 ---
Tokens: 313
Type: sentence-based
Text:
In (d), cert is stored in a context object along with other system-wide information, such as a timeoutvalueandperformancecounters;areferencetothecontextisstoredinallobjectswhosemethods needaccesstoit. Thecontextobjectunifiesthehandlingofallsystem-globalinformationand eliminates the need for pass-through variables. If a new variable needs to be added,itcanbeaddedtothecontextobject;noexistingcodeisaffectedexcept fortheconstructoranddestructorforthecontext.Thecontextmakesiteasyto identifyandmanagetheglobalstateofthesystem,sinceitisallstoredinone place.Thecontextisalsoconvenientfortesting:testcodecanchangetheglobal configurationoftheapplicationbymodifyingfieldsinthecontext.Itwouldbe muchmoredifficulttoimplementsuchchangesifthesystemusedpass-through variables. Contextsarefarfromanidealsolution.Thevariablesstoredinacontexthave mostofthedisadvantagesofglobalvariables;forexample,itmaynotbeobvious whyaparticularvariableispresent,orwhereitisused.Withoutdiscipline,a context can turn into a huge grab-bag of data that creates nonobvious dependencies throughout the system. Contexts may also create thread-safety issues; the best way to avoid problems is for variables in a context to be immutable.Unfortunately,Ihaventfoundabettersolutionthancontexts.

--- Chunk 89 ---
Tokens: 398
Type: sentence-based
Text:
Contexts may also create thread-safety issues; the best way to avoid problems is for variables in a context to be immutable.Unfortunately,Ihaventfoundabettersolutionthancontexts. 7.6Conclusion Each piece of design infrastructure added to a system, such as an interface, argument,function,class,ordefinition,addscomplexity,sincedevelopersmust learnaboutthiselement.Inorderforanelementtoprovideanetgainagainst complexity, it must eliminate some complexity that would be present in the absenceofthedesignelement.Otherwise,youarebetteroffimplementingthe system without that particular element. For example, a class can reduce complexitybyencapsulatingfunctionalitysothatusersoftheclassneedntbe awareofit. Thedifferentlayer,differentabstractionruleisjustanapplicationofthis idea:ifdifferentlayershavethesameabstraction,suchaspass-throughmethods or decorators, then theres a good chance that they havent provided enough benefittocompensatefortheadditionalinfrastructuretheyrepresent.Similarly, pass-through arguments require each of several methods to be aware of their existence (which adds to complexity) without contributing additional functionality. Chapter8 PullComplexityDownwards This chapter introduces another way of thinking about how to create deeper classes.Supposethatyouaredevelopinganewmodule,andyoudiscoverapiece ofunavoidablecomplexity.Whichisbetter:shouldyouletusersofthemodule dealwiththecomplexity,orshouldyouhandlethecomplexityinternallywithin the module? If the complexity is related to the functionality provided by the module, then the second answer is usually the right one.

--- Chunk 90 ---
Tokens: 298
Type: sentence-based
Text:
If the complexity is related to the functionality provided by the module, then the second answer is usually the right one. Most modules have moreusersthandevelopers,soitisbetterforthedeveloperstosufferthanthe users.Asamoduledeveloper,youshouldstrivetomakelifeaseasyaspossible fortheusersofyourmodule,evenifthatmeansextraworkforyou.Anotherway of expressing this idea is that it is more important for a module to have a simpleinterfacethanasimpleimplementation. Asadeveloper,itstemptingtobehaveintheoppositefashion:solvetheeasy problems and punt the hard ones to someone else. If a condition arises that yourenotcertainhowtodealwith,theeasiestthingistothrowanexceptionand letthecallerhandleit.Ifyouarenotcertainwhatpolicytoimplement,youcan defineafewconfigurationparameterstocontrolthepolicyandleaveituptothe systemadministratortofigureoutthebestvaluesforthem. Approacheslikethesewillmakeyourlifeeasierintheshortterm,butthey amplifycomplexity,sothatmanypeoplemustdealwithaproblem,ratherthan justoneperson.Forexample,ifaclassthrowsanexception,everycallerofthe classwillhavetodealwithit.Ifaclassexportsconfigurationparameters,every systemadministratorineveryinstallationwillhavetolearnhowtosetthem.

--- Chunk 91 ---
Tokens: 394
Type: sentence-based
Text:
Approacheslikethesewillmakeyourlifeeasierintheshortterm,butthey amplifycomplexity,sothatmanypeoplemustdealwithaproblem,ratherthan justoneperson.Forexample,ifaclassthrowsanexception,everycallerofthe classwillhavetodealwithit.Ifaclassexportsconfigurationparameters,every systemadministratorineveryinstallationwillhavetolearnhowtosetthem. 8.1Example:editortextclass ConsidertheclassthatmanagesthetextofafileforaGUItexteditor,whichwas discussedinChapters6and7.Theclassprovidesmethodstoreadafilefrom diskintomemory,queryandmodifythein-memorycopyofthefile,andwrite themodifiedversionbacktodisk.Whenstudentshadtoimplementthisclass, manyofthemchosealine-orientedinterface,withmethodstoread,insert,and deletewholelinesoftext.Thisresultedinasimpleimplementationfortheclass, but it created complexity for higher level software. At the level of the user interface,operationsrarelyinvolvewholelines.Forexample,keystrokescause individualcharacterstobeinsertedwithinanexistingline;copyingordeleting theselectioncanmodifypartsofseveraldifferentlines.Withtheline-oriented text interface, higher-level software had to split and join lines in order to implementtheuserinterface. Acharacter-orientedinterfacesuchastheonedescribedinSection6.3pulls complexity downward. The user interface software can now insert and delete arbitrary ranges of text without splitting and merging lines, so it becomes simpler.Theimplementationofthetextclassprobablybecomesmorecomplex: ifitrepresentsthetextinternallyasacollectionoflines,itwillhavetosplitand merge lines to implement the character-oriented operations.

--- Chunk 92 ---
Tokens: 370
Type: sentence-based
Text:
The user interface software can now insert and delete arbitrary ranges of text without splitting and merging lines, so it becomes simpler.Theimplementationofthetextclassprobablybecomesmorecomplex: ifitrepresentsthetextinternallyasacollectionoflines,itwillhavetosplitand merge lines to implement the character-oriented operations. This approach is betterbecauseitencapsulatesthecomplexityofsplittingandmergingwithinthe textclass,whichreducestheoverallcomplexityofthesystem. 8.2Example:configurationparameters Configurationparametersareanexampleofmovingcomplexityupwardsinstead of down. Rather than determining a particular behavior internally, a class can exportafewparametersthatcontrolitsbehavior,suchasthesizeofacacheor thenumberoftimestoretryarequestbeforegivingup.Usersoftheclassmust then specify appropriate values for the parameters. Configuration parameters have become very popular in systems today; some systems have hundreds of them. Advocatesarguethatconfigurationparametersaregoodbecausetheyallow userstotunethesystemfortheirparticularrequirementsandworkloads.Insome situationsitishardforlow-levelinfrastructurecodetoknowthebestpolicyto apply,whereasusersaremuchmorefamiliarwiththeirdomains.Forinstance,a user might know that some requests are more time-critical than others, so it makes sense for the user to specify a higher priority for those requests. In situations like this, configuration parameters can result in better performance acrossabroadervarietyofdomains.

--- Chunk 93 ---
Tokens: 288
Type: sentence-based
Text:
In situations like this, configuration parameters can result in better performance acrossabroadervarietyofdomains. However, configuration parameters also provide an easy excuse to avoid dealingwithimportantissuesandpassthemontosomeoneelse.Inmanycases, its difficult or impossible for users or administrators to determine the right values for the parameters. In other cases, the right values could have been determinedautomaticallywithalittleextraworkinthesystemimplementation. Consideranetworkprotocolthatmustdealwithlostpackets.Ifitsendsarequest butdoesntreceivearesponsewithinacertaintimeperiod,itresendstherequest. Onewaytodeterminetheretryintervalistointroduceaconfigurationparameter. However,thetransportprotocolcouldcomputeareasonablevalueonitsownby measuringtheresponsetimeforrequeststhatsucceedandthenusingamultiple ofthisfortheretryinterval.Thisapproachpullscomplexitydownwardandsaves users from having to figure out the right retry interval. It has the additional advantage of computing the retry interval dynamically, so it will adjust automatically if operating conditions change. In contrast, configuration parameterscaneasilybecomeoutofdate.

--- Chunk 94 ---
Tokens: 385
Type: sentence-based
Text:
In contrast, configuration parameterscaneasilybecomeoutofdate. Thus,youshouldavoidconfigurationparametersasmuchaspossible.Before exporting a configuration parameter, ask yourself: will users (or higher-level modules)beabletodetermineabettervaluethanwecandeterminehere?When you do create configuration parameters, see if you can compute reasonable defaults automatically, so users will only need to provide values under exceptionalconditions.Ideally,eachmoduleshouldsolveaproblemcompletely; configurationparametersresultinanincompletesolution,whichaddstosystem complexity. 8.3Takingittoofar Usediscretionwhenpullingcomplexitydownward;thisisanideathatcaneasily beoverdone.Anextremeapproachwouldbetopullallofthefunctionalityofthe entire application down into a single class, which clearly doesnt make sense. Pullingcomplexitydownmakesthemostsenseif(a)thecomplexitybeingpulled down is closely related to the classs existing functionality, (b) pulling the complexitydownwillresultinmanysimplificationselsewhereintheapplication, and(c)pullingthecomplexitydownsimplifiestheclasssinterface.Remember thatthegoalistominimizeoverallsystemcomplexity. Chapter6describedhowsomestudentsdefinedmethodsinthetextclassthat reflectedtheuserinterface,suchasamethodthatimplementsthefunctionality ofthebackspacekey.Itmightseemthatthisisgood,sinceitpullscomplexity downward. However, adding knowledge of the user interface to the text class doesntsimplifyhigher-levelcodeverymuch,andtheuser-interfaceknowledge doesnt relate to the core functions of the text class.

--- Chunk 95 ---
Tokens: 363
Type: sentence-based
Text:
However, adding knowledge of the user interface to the text class doesntsimplifyhigher-levelcodeverymuch,andtheuser-interfaceknowledge doesnt relate to the core functions of the text class. In this case, pulling complexitydownjustresultedininformationleakage. 8.4Conclusion When developing a module, look for opportunities to take a little bit of extra sufferinguponyourselfinordertoreducethesufferingofyourusers. Chapter9 BetterTogetherOrBetterApart? One of the most fundamental questions in software design is this: given two piecesoffunctionality,shouldtheybeimplementedtogetherinthesameplace, orshouldtheirimplementationsbeseparated?Thisquestionappliesatalllevels in a system, such as functions, methods, classes, and services. For example, shouldbufferingbeincludedintheclassthatprovidesstream-orientedfileIO, orshoulditbeinaseparateclass?ShouldtheparsingofanHTTPrequestbe implemented entirely in one method, or should it be divided among multiple methods(orevenmultipleclasses)?Thischapterdiscussesthefactorstoconsider whenmakingthesedecisions.Someofthesefactorshavealreadybeendiscussed inpreviouschapters,buttheywillberevisitedhereforcompleteness. When deciding whether to combine or separate, the goal is to reduce the complexityofthesystemasawholeandimproveitsmodularity.Itmightappear thatthebestwaytoachievethisgoalistodividethesystemintoalargenumber ofsmallcomponents:thesmallerthecomponents,thesimplereachindividual component is likely to be.

--- Chunk 96 ---
Tokens: 372
Type: sentence-based
Text:
When deciding whether to combine or separate, the goal is to reduce the complexityofthesystemasawholeandimproveitsmodularity.Itmightappear thatthebestwaytoachievethisgoalistodividethesystemintoalargenumber ofsmallcomponents:thesmallerthecomponents,thesimplereachindividual component is likely to be. However, the act of subdividing creates additional complexitythatwasnotpresentbeforesubdivision: Somecomplexitycomesjustfromthenumberofcomponents:themore components,thehardertokeeptrackofthemallandthehardertofinda desiredcomponentwithinthelargecollection.Subdivisionusuallyresults inmoreinterfaces,andeverynewinterfaceaddscomplexity. Subdivisioncanresultinadditionalcodetomanagethecomponents.For example,apieceofcodethatusedasingleobjectbeforesubdivisionmight nowhavetomanagemultipleobjects. Subdivisioncreatesseparation:thesubdividedcomponentswillbefarther apartthantheywerebeforesubdivision.Forexample,methodsthatwere togetherinasingleclassbeforesubdivisionmaybeindifferentclassesafter subdivision,andpossiblyindifferentfiles.Separationmakesitharderfor developerstoseethecomponentsatthesametime,oreventobeawareof theirexistence.Ifthecomponentsaretrulyindependent,thenseparationis good:itallowsthedevelopertofocusonasinglecomponentatatime, withoutbeingdistractedbytheothercomponents.Ontheotherhand,if therearedependenciesbetweenthecomponents,thenseparationisbad: developerswillendupflippingbackandforthbetweenthecomponents. Evenworse,theymaynotbeawareofthedependencies,whichcanleadto bugs.

--- Chunk 97 ---
Tokens: 322
Type: sentence-based
Text:
Evenworse,theymaynotbeawareofthedependencies,whichcanleadto bugs. Subdivisioncanresultinduplication:codethatwaspresentinasingle instancebeforesubdivisionmayneedtobepresentineachofthe subdividedcomponents. Bringingpiecesofcodetogetherismostbeneficialiftheyarecloselyrelated. If the pieces are unrelated, they are probably better off apart. Here are a few indicationsthattwopiecesofcodearerelated: Theyshareinformation;forexample,bothpiecesofcodemightdependon thesyntaxofaparticulartypeofdocument. Theyareusedtogether:anyoneusingoneofthepiecesofcodeislikelyto usetheotheraswell.Thisformofrelationshipisonlycompellingifitis bidirectional.Asacounter-example,adiskblockcachewillalmostalways involveahashtable,buthashtablescanbeusedinmanysituationsthat dontinvolveblockcaches;thus,thesemodulesshouldbeseparate. Theyoverlapconceptually,inthatthereisasimplehigher-levelcategory thatincludesbothofthepiecesofcode.Forexample,searchingfora substringandcaseconversionbothfallunderthecategoryofstring manipulation;flowcontrolandreliabledeliverybothfallunderthecategory ofnetworkcommunication. Itishardtounderstandoneofthepiecesofcodewithoutlookingatthe other. Therestofthischapterusesmorespecificrulesaswellasexamplestoshow whenitmakessensetobringpiecesofcodetogetherandwhenitmakessenseto separatethem.

--- Chunk 98 ---
Tokens: 383
Type: sentence-based
Text:
Therestofthischapterusesmorespecificrulesaswellasexamplestoshow whenitmakessensetobringpiecesofcodetogetherandwhenitmakessenseto separatethem. 9.1Bringtogetherifinformationisshared Section5.4introducedthisprincipleinthecontextofaprojectimplementingan HTTPserver.Initsfirstimplementation,theprojectusedtwodifferentmethods indifferentclassestoreadinandparseHTTPrequests.Thefirstmethodreadthe text of an incoming request from a network socket and placed it in a string object.Thesecondmethodparsedthestringtoextractthevariouscomponentsof the request. With this decomposition, both of the methods ended up with considerableknowledgeoftheformatofHTTPrequests:thefirstmethodwas onlytryingtoreadtherequest,notparseit,butitcouldntidentifytheendofthe requestwithoutdoingmostoftheworkofparsingit(forexample,ithadtoparse headerlinesinordertoidentifytheheadercontainingtheoverallrequestlength). Becauseofthissharedinformation,itisbettertobothreadandparsetherequest inthesameplace;whenthetwoclasseswerecombinedintoone,thecodegot shorterandsimpler. 9.2Bringtogetherifitwillsimplifytheinterface When two or more modules are combined into a single module, it may be possibletodefineaninterfaceforthenewmodulethatissimpleroreasiertouse thantheoriginalinterfaces.Thisoftenhappenswhentheoriginalmoduleseach implementpartofthesolutiontoaproblem.IntheHTTPserverexamplefrom theprecedingsection,theoriginalmethodsrequiredaninterfacetoreturnthe HTTPrequeststringfromthefirstmethodandpassittothesecond.Whenthe methodswerecombined,theseinterfaceswereeliminated.

--- Chunk 99 ---
Tokens: 295
Type: sentence-based
Text:
9.2Bringtogetherifitwillsimplifytheinterface When two or more modules are combined into a single module, it may be possibletodefineaninterfaceforthenewmodulethatissimpleroreasiertouse thantheoriginalinterfaces.Thisoftenhappenswhentheoriginalmoduleseach implementpartofthesolutiontoaproblem.IntheHTTPserverexamplefrom theprecedingsection,theoriginalmethodsrequiredaninterfacetoreturnthe HTTPrequeststringfromthefirstmethodandpassittothesecond.Whenthe methodswerecombined,theseinterfaceswereeliminated. Inaddition,whenthefunctionalityoftwoormoreclassesiscombined,it may be possible to perform some functions automatically, so that most users neednotbeawareofthem.TheJavaIOlibraryillustratesthisopportunity.Ifthe FileInputStreamandBufferedInputStreamclasseswerecombinedandbuffering wereprovidedbydefault,thevastmajorityofuserswouldneverevenneedtobe awareoftheexistenceofbuffering.Acombined FileInputStream class might providemethodstodisableorreplacethedefaultbufferingmechanism,butmost userswouldnotneedtolearnaboutthem. 9.3Bringtogethertoeliminateduplication If you find the same pattern of code repeated over and over, see if you can reorganize the code to eliminate the repetition.

--- Chunk 100 ---
Tokens: 387
Type: sentence-based
Text:
9.3Bringtogethertoeliminateduplication If you find the same pattern of code repeated over and over, see if you can reorganize the code to eliminate the repetition. One approach is to factor the repeatedcodeoutintoaseparatemethodandreplacetherepeatedcodesnippets withcallstothemethod.Thisapproachismosteffectiveiftherepeatedcode snippetislongandthereplacementmethodhasasimplesignature.Ifthesnippet isonlyoneortwolineslong,theremaynotbemuchbenefitinreplacingitwitha methodcall.Ifthesnippetinteractsincomplexwayswithitsenvironment(such asbyaccessingnumerouslocalvariables),thenthereplacementmethodmight requireacomplexsignature(suchasmanypass-by-referencearguments),which wouldreduceitsvalue. Another way to eliminate duplication is to refactor the code so that the snippet in question only needs to be executed in one place. Suppose you are writingamethodthatneedstoreturnerrorsatseveraldifferentpoints,andthe same cleanup actions need to be performed at each of these points before returning(seeFigure9.1foranexample).Iftheprogramminglanguagesupports goto,youcanmovethecleanupcodetotheveryendofthemethodandthengoto thatsnippetateachofthepointswhereanerrorreturnisrequired,asinFigure 9.2.Gotostatementsaregenerallyconsideredabadidea,andtheycanresultin indecipherablecodeifusedindiscriminately,buttheyareusefulinsituationslike thiswheretheyareusedtoescapefromnestedcode. 9.4Separategeneral-purposeandspecial-purposecode Ifamodulecontainsamechanismthatcanbeusedforseveraldifferentpurposes, then it should provide just that one general-purpose mechanism.

--- Chunk 101 ---
Tokens: 397
Type: sentence-based
Text:
9.4Separategeneral-purposeandspecial-purposecode Ifamodulecontainsamechanismthatcanbeusedforseveraldifferentpurposes, then it should provide just that one general-purpose mechanism. It should not includecodethatspecializesthemechanismforaparticularuse,norshouldit contain other general-purpose mechanisms. Special-purpose code associated with a general-purpose mechanism should normally go in a different module (typicallyoneassociatedwiththeparticularpurpose).TheGUIeditordiscussion in Chapter 6 illustrated this principle: the best design was one where the text classprovidedgeneral-purposetextoperations,whileoperationsparticulartothe user interface (such as deleting the selection) were implemented in the user interfacemodule.Thisapproacheliminatedinformationleakageandadditional interfaces that were present in an earlier design where the specialized user interfaceoperationswereimplementedinthetextclass. RedFlag:Repetition Ifthesamepieceofcode(orcodethatisalmostthesame)appearsoverand overagain,thatsaredflagthatyouhaventfoundtherightabstractions. Figure9.1:Thiscodeprocessesincomingnetworkpacketsofdifferenttypes;foreachtype,ifthepacketis tooshortforthattype,amessagegetslogged.Inthisversionofthecode,theLOGstatementisduplicated forseveraldifferentpackettypes. Figure 9.2: A reorganization of the code from Figure 9.1 so that there is only one copy of the LOG statement. Ingeneral,thelowerlayersofasystemtendtobemoregeneral-purposeand the upper layers more special-purpose. For example, the topmost layer of an application consists of features totally specific to that application.

--- Chunk 102 ---
Tokens: 313
Type: sentence-based
Text:
For example, the topmost layer of an application consists of features totally specific to that application. The way to separatespecial-purposecodefromgeneral-purposecodeistopullthespecial- purposecodeupwards,intothehigherlayers,leavingthelowerlayersgeneral- purpose. When you encounter a class that includes both general-purpose and special-purpose features for the same abstraction, see if the class can be separatedintotwoclasses,onecontainingthegeneral-purposefeatures,andthe otherlayeredontopofittoprovidethespecial-purposefeatures. 9.5Example:insertioncursorandselection The next sections work through three examples that illustrate the principles discussed above. In two of the examples the best approach is to separate the relevantpiecesofcode;inthethirdexampleitisbettertojointhemtogether. ThefirstexampleconsistsoftheinsertioncursorandtheselectionintheGUI editor project from Chapter 6. The editor displayed a blinking vertical line indicatingwheretexttypedbytheuserwouldappearinthedocument.Italso displayedahighlightedrangeofcharacterscalledtheselection,whichwasused forcopyingordeletingtext.Theinsertioncursorwasalwaysvisible,butthere couldbetimeswhennotextwasselected.Iftheselectionexisted,theinsertion cursorwasalwayspositionedatoneendofit.

--- Chunk 103 ---
Tokens: 349
Type: sentence-based
Text:
The editor displayed a blinking vertical line indicatingwheretexttypedbytheuserwouldappearinthedocument.Italso displayedahighlightedrangeofcharacterscalledtheselection,whichwasused forcopyingordeletingtext.Theinsertioncursorwasalwaysvisible,butthere couldbetimeswhennotextwasselected.Iftheselectionexisted,theinsertion cursorwasalwayspositionedatoneendofit. Theselectionandinsertioncursorarerelatedinsomeways.Forexample,the cursor is always positioned at one end of the selection, and the cursor and selectiontendtobemanipulatedtogether:clickinganddraggingthemousesets bothofthem,andtextinsertionfirstdeletestheselectedtext,ifthereisany,and theninsertsnewtextatthecursorposition.Thus,itmightseemlogicaltousea singleobjecttomanageboththeselectionandthecursor,andoneprojectteam took this approach. The object stored two positions in the file, along with booleansindicatingwhichendwasthecursorandwhethertheselectionexisted. However, the combined object was awkward. It provided no benefit for higher-level code, since the higher-level code still needed to be aware of the selection and cursor as distinct entities, and it manipulated them separately (duringtextinsertion,itfirstinvokedamethodonthecombinedobjecttodelete theselectedtext;thenitinvokedanothermethodtoretrievethecursorpositionin order to insert new text).The combined object was actually more complex to implement than separate objects.

--- Chunk 104 ---
Tokens: 339
Type: sentence-based
Text:
It provided no benefit for higher-level code, since the higher-level code still needed to be aware of the selection and cursor as distinct entities, and it manipulated them separately (duringtextinsertion,itfirstinvokedamethodonthecombinedobjecttodelete theselectedtext;thenitinvokedanothermethodtoretrievethecursorpositionin order to insert new text).The combined object was actually more complex to implement than separate objects. It avoided storing the cursor position as a separateentity,butinsteadhadtostoreabooleanindicatingwhichendofthe selectionwasthecursor.Inordertoretrievethecursorposition,thecombined objecthadtofirsttestthebooleanandthenchoosetheappropriateendofthe selection. RedFlag:Special-GeneralMixture Thisredflagoccurswhenageneral-purposemechanismalsocontainscode specializedforaparticularuseofthatmechanism.Thismakesthemechanism more complicated and creates information leakage between the mechanism andtheparticularusecase:futuremodificationstotheusecasearelikelyto requirechangestotheunderlyingmechanismaswell. In this case, the selection and cursor were not closely enough related to combine them. When the code was revised to separate the selection and the cursor,boththeusageandtheimplementationbecamesimpler.Separateobjects providedasimplerinterfacethanacombinedobjectfromwhichselectionand cursor information had to be extracted.

--- Chunk 105 ---
Tokens: 346
Type: sentence-based
Text:
When the code was revised to separate the selection and the cursor,boththeusageandtheimplementationbecamesimpler.Separateobjects providedasimplerinterfacethanacombinedobjectfromwhichselectionand cursor information had to be extracted. The cursor implementation also got simpler because the cursor position was represented directly, rather than indirectlythroughaselectionandaboolean.Infact,intherevisedversionno specialclasseswereusedforeithertheselectionorthecursor.Instead,anew Positionclasswasintroducedtorepresentalocationinthefile(alinenumber andcharacterwithinline).TheselectionwasrepresentedwithtwoPositionsand thecursorwithone.Positionsalsofoundotherusesintheproject.Thisexample also demonstrates the benefits of a lower-level but more general-purpose interface,whichwerediscussedinChapter6. 9.6Example:separateclassforlogging The second example involved error logging in a student project. A class containedseveralcodesequenceslikethefollowing: try rpcConnconnectionPool.getConnection(dest); catch(IOExceptione) NetworkErrorLogger.logRpcOpenError(req,dest,e); returnnull;  Rather than logging the error at the point where it was detected, a separate methodinaspecialerrorloggingclasswasinvoked.Theerrorloggingclasswas definedattheendofthesamesourcefile: privatestaticclassNetworkErrorLogger  Outputinformationrelevanttoanerrorthatoccurswhentrying toopenaconnectiontosendanRPC.

--- Chunk 106 ---
Tokens: 353
Type: sentence-based
Text:
A class containedseveralcodesequenceslikethefollowing: try rpcConnconnectionPool.getConnection(dest); catch(IOExceptione) NetworkErrorLogger.logRpcOpenError(req,dest,e); returnnull;  Rather than logging the error at the point where it was detected, a separate methodinaspecialerrorloggingclasswasinvoked.Theerrorloggingclasswas definedattheendofthesamesourcefile: privatestaticclassNetworkErrorLogger  Outputinformationrelevanttoanerrorthatoccurswhentrying toopenaconnectiontosendanRPC. paramreq TheRPCrequestthatwouldhavebeensentthroughthe connection paramdest ThedestinationoftheRPC parame Thecaughterror  publicstaticvoidlogRpcOpenError(RpcRequestreq,AddrPortTuple dest,Exceptione) logger.log(Level.WARNING,Cannotsendmessage:req.n Unabletofindoropenconnectiontodest: e);  . The NetworkErrorLogger class contained several methods such as logRpcSendErrorandlogRpcReceiveError,eachofwhichloggedadifferentkind oferror. Thisseparationaddedcomplexitywithnobenefit.Theloggingmethodswere shallow:mostconsistedofasinglelineofcode,buttheyrequiredaconsiderable amountofdocumentation.Eachmethodwasonlyinvokedinasingleplace.The loggingmethodswerehighlydependentontheirinvocations:someonereading theinvocationwouldmostlikelyflipovertotheloggingmethodtomakesure that the right information was being logged; similarly, someone reading the loggingmethodwouldprobablyflipovertotheinvocationsitetounderstandthe purposeofthemethod.

--- Chunk 107 ---
Tokens: 360
Type: sentence-based
Text:
Thisseparationaddedcomplexitywithnobenefit.Theloggingmethodswere shallow:mostconsistedofasinglelineofcode,buttheyrequiredaconsiderable amountofdocumentation.Eachmethodwasonlyinvokedinasingleplace.The loggingmethodswerehighlydependentontheirinvocations:someonereading theinvocationwouldmostlikelyflipovertotheloggingmethodtomakesure that the right information was being logged; similarly, someone reading the loggingmethodwouldprobablyflipovertotheinvocationsitetounderstandthe purposeofthemethod. In this example, it would be better to eliminate the logging methods and placetheloggingstatementsatthelocationswheretheerrorsweredetected.This wouldmakethecodeeasiertoreadandeliminatetheinterfacesrequiredforthe loggingmethods. 9.7Example:editorundomechanism In the GUI editor project from Section 6.2, one of the requirements was to supportmulti-levelundoredo,notjustforchangestothetextitself,butalsofor changes in the selection, insertion cursor, and view. For example, if a user selectedsometext,deletedit,scrolledtoadifferentplaceinthefile,andthen invokedundo,theeditorhadtorestoreitsstatetowhatitwasjustbeforethe deletion. This included restoring the deleted text, selecting it again, and also makingtheselectedtextvisibleinthewindow. Someofthestudentprojectsimplementedtheentireundomechanismaspart ofthetextclass.Thetextclassmaintainedalistofalltheundoablechanges.It automatically added entries to this list whenever the text was changed.

--- Chunk 108 ---
Tokens: 392
Type: sentence-based
Text:
Someofthestudentprojectsimplementedtheentireundomechanismaspart ofthetextclass.Thetextclassmaintainedalistofalltheundoablechanges.It automatically added entries to this list whenever the text was changed. For changes to the selection, insertion cursor, and view, the user interface code invokedadditionalmethodsinthetextclass,whichthenaddedentriesforthose changestotheundolist.Whenundoorredowasrequestedbytheuser,theuser interface code invoked a method in the text class, which then processed the entriesintheundolist.Forentriesrelatedtotext,itupdatedtheinternalsofthe textclass;forentriesrelatedtootherthings,suchastheselection,thetextclass calledbacktotheuserinterfacecodetocarryouttheundoorredo. Thisapproachresultedinanawkwardsetoffeaturesinthetextclass.The coreofundoredoconsistsofageneral-purposemechanismformanagingalist ofactionsthathavebeenexecutedandsteppingthroughthemduringundoand redo operations. The core was located in the text class along with special- purposehandlersthatimplementedundoandredoforspecificthingssuchastext andtheselection.Thespecial-purposeundohandlersfortheselectionandthe cursor had nothing to do with anything else in the text class; they resultedin informationleakagebetweenthetextclassandtheuserinterface,aswellasextra methodsineachmoduletopassundoinformationbackandforth.Ifanewsort of undoable entity were added to the system in the future, it would require changes to the text class, including new methods specific to that entity. In addition,thegeneral-purposeundocorehadlittletodowiththegeneral-purpose textfacilitiesintheclass.

--- Chunk 109 ---
Tokens: 368
Type: sentence-based
Text:
In addition,thegeneral-purposeundocorehadlittletodowiththegeneral-purpose textfacilitiesintheclass. Theseproblemscanbesolvedbyextractingthegeneral-purposecoreofthe undoredomechanismandplacingitinaseparateclass: publicclassHistory publicinterfaceAction publicvoidredo(); publicvoidundo();  History(). voidaddAction(Actionaction). voidaddFence(). voidundo(). voidredo(). Inthisdesign,theHistoryclassmanagesacollectionofobjectsthatimplement theinterfaceHistory.Action.EachHistory.Actiondescribesasingleoperation, such as a text insertion or a change in the cursor location, and it provides methodsthatcanundoorredotheoperation.TheHistoryclassknowsnothing abouttheinformationstoredintheactionsorhowtheyimplementtheirundoand redo methods. History maintains a history list describing all of the actions executed over the lifetime of an application, and it provides undo and redo methodsthatwalkbackwardsandforwardsthroughthelistinresponsetouser- requested undos and redos, calling undo and redo methods in the History.Actions. History.Actions are special-purpose objects: each one understands a particularkindofundoableoperation.TheyareimplementedoutsidetheHistory class,inmodulesthatunderstandparticularkindsofundoableactions.Thetext classmightimplementUndoableInsertand UndoableDeleteobjectstodescribe textinsertionsanddeletions.Wheneveritinsertstext,thetextclasscreatesanew UndoableInsertobjectdescribingtheinsertionandinvokes History.addAction to add it to the history list.

--- Chunk 110 ---
Tokens: 388
Type: sentence-based
Text:
History.Actions are special-purpose objects: each one understands a particularkindofundoableoperation.TheyareimplementedoutsidetheHistory class,inmodulesthatunderstandparticularkindsofundoableactions.Thetext classmightimplementUndoableInsertand UndoableDeleteobjectstodescribe textinsertionsanddeletions.Wheneveritinsertstext,thetextclasscreatesanew UndoableInsertobjectdescribingtheinsertionandinvokes History.addAction to add it to the history list. The editors user interface code might create UndoableSelection and UndoableCursor objects that describe changes to the selectionandinsertioncursor. TheHistoryclassalsoallowsactionstobegroupedsothat,forexample,a singleundorequestfromtheusercanrestoredeletedtext,reselectthedeleted text,andrepositiontheinsertioncursor.Thereareanumberofwaystogroup actions;theHistoryclassusesfences,whicharemarkersplacedinthehistory list to separate groups of related actions. Each call to History.redo walks backwards through the history list, undoing actions until it reaches the next fence.Theplacementoffencesisdeterminedbyhigher-levelcodebyinvoking History.addFence. Thisapproachdividesthefunctionalityofundointothreecategories,eachof whichisimplementedinadifferentplace: Ageneral-purposemechanismformanagingandgroupingactionsand invokingundoredooperations(implementedbytheHistoryclass). Thespecificsofparticularactions(implementedbyavarietyofclasses, eachofwhichunderstandsasmallnumberofactiontypes). Thepolicyforgroupingactions(implementedbyhigh-leveluserinterface codetoprovidetherightoverallapplicationbehavior).

--- Chunk 111 ---
Tokens: 370
Type: sentence-based
Text:
Thepolicyforgroupingactions(implementedbyhigh-leveluserinterface codetoprovidetherightoverallapplicationbehavior). Eachofthesecategoriescanbeimplementedwithoutanyunderstandingofthe othercategories.TheHistoryclassdoesnotknowwhatkindofactionsarebeing undone; it could be used in a variety of applications. Each action class understandsonlyasinglekindofaction,andneithertheHistoryclassnorthe actionclassesneedstobeawareofthepolicyforgroupingactions. Thekeydesigndecisionwastheonethatseparatedthegeneral-purposepart of the undo mechanism from the special-purpose parts and put the general- purposepartinaclassbyitself.Oncethatwasdone,therestofthedesignfell outnaturally. Note:thesuggestiontoseparategeneral-purposecodefromspecial-purpose code refers to code related to a particular mechanism. For example, special- purposeundocode(suchascodetoundoatextinsertion)shouldbeseparated from general-purpose undo code (such as code to manage the history list). However, it often makes sense to combine special-purpose code for one mechanismwithgeneral-purposecodeforanother.Thetextclassisanexample of this: it implements a general-purpose mechanism for managing text, but it includes special-purpose code related to undoing. The undo code is special- purposebecauseitonlyhandlesundooperationsfortextmodifications.Itdoesnt makesensetocombinethiscodewiththegeneral-purposeundoinfrastructurein theHistoryclass,butitdoesmakesensetoputitinthetextclass,sinceitis closelyrelatedtoothertextfunctions.

--- Chunk 112 ---
Tokens: 282
Type: sentence-based
Text:
The undo code is special- purposebecauseitonlyhandlesundooperationsfortextmodifications.Itdoesnt makesensetocombinethiscodewiththegeneral-purposeundoinfrastructurein theHistoryclass,butitdoesmakesensetoputitinthetextclass,sinceitis closelyrelatedtoothertextfunctions. 9.8Splittingandjoiningmethods Theissueofwhentosubdivideappliesnotjusttoclasses,butalsotomethods: are there times when it is better to divide an existing method into multiple smallermethods?Or,shouldtwosmallermethodsbecombinedintoonelarger one?Longmethodstendtobemoredifficulttounderstandthanshorterones,so many people argue that length alone is a good justification for breaking up a method.Studentsinclassesareoftengivenrigidcriteria,suchasSplitupany methodlongerthan20lines! However,lengthbyitselfisrarelyagoodreasonforsplittingupamethod.In general,developerstendtobreakupmethodstoomuch.Splittingupamethod introducesadditionalinterfaces,whichaddtocomplexity.Italsoseparatesthe piecesoftheoriginalmethod,whichmakesthecodehardertoreadifthepieces areactuallyrelated.Youshouldntbreakupamethodunlessitmakestheoverall systemsimpler;Illdiscusshowthismighthappenbelow.

--- Chunk 113 ---
Tokens: 345
Type: sentence-based
Text:
However,lengthbyitselfisrarelyagoodreasonforsplittingupamethod.In general,developerstendtobreakupmethodstoomuch.Splittingupamethod introducesadditionalinterfaces,whichaddtocomplexity.Italsoseparatesthe piecesoftheoriginalmethod,whichmakesthecodehardertoreadifthepieces areactuallyrelated.Youshouldntbreakupamethodunlessitmakestheoverall systemsimpler;Illdiscusshowthismighthappenbelow. Longmethodsarentalwaysbad.Forexample,supposeamethodcontains five20-lineblocksofcodethatareexecutedinorder.Iftheblocksarerelatively independent,thenthemethodcanbereadandunderstoodoneblockatatime; theresnotmuchbenefitinmovingeachoftheblocksintoaseparatemethod.If the blocks have complex interactions, its even more important to keep them togethersoreaderscanseeallofthecodeatonce;ifeachblockisinaseparate method, readers will have to flip back and forth between these spread-out methods in order to understand how they work together. Methods containing hundredsoflinesofcodearefineiftheyhaveasimplesignatureandareeasyto read.Thesemethodsaredeep(lotsoffunctionality,simpleinterface),whichis good. Figure9.3:Amethod(a)canbespliteitherbybyextractingasubtask(b)orbydividingitsfunctionality intotwoseparatemethods(c).Amethodshouldnotbesplitifitresultsinshallowmethods,asin(d). Whendesigningmethods,themostimportantgoalistoprovidecleanand simpleabstractions.Eachmethodshoulddoonethinganddoitcompletely.

--- Chunk 114 ---
Tokens: 371
Type: sentence-based
Text:
Whendesigningmethods,themostimportantgoalistoprovidecleanand simpleabstractions.Eachmethodshoulddoonethinganddoitcompletely. Themethodshouldhaveacleanandsimpleinterface,sothatusersdontneedto havemuchinformationintheirheadsinordertouseitcorrectly.Themethod shouldbedeep:itsinterfaceshouldbemuchsimplerthanitsimplementation.If amethodhasalloftheseproperties,thenitprobablydoesntmatterwhetheritis longornot. Splittingupamethodonlymakessenseifitresultsincleanerabstractions, overall.Therearetwowaystodothis,whicharediagrammedinFigure9.3.The bestwayisbyfactoringoutasubtaskintoaseparatemethod,asshowninFigure 9.3(b).Thesubdivisionresultsinachildmethodcontainingthesubtaskanda parent method containing the remainder of the original method; the parent invokes the child. The interface of the new parent method is the same as the originalmethod.Thisformofsubdivisionmakessenseifthereisasubtaskthat is cleanly separable from the rest of the original method, which means (a) someone reading the child method doesnt need to know anything about the parent method and (b) someone reading the parent method doesnt need to understandtheimplementationofthechildmethod.Typicallythismeansthatthe childmethodisrelativelygeneral-purpose:itcouldconceivablybeusedbyother methods besides the parent. If you make a split of this form and then find yourselfflippingbackandforthbetweentheparentandchildtounderstandhow theyworktogether,thatisaredflag(ConjoinedMethods)indicatingthatthe splitwasprobablyabadidea.

--- Chunk 115 ---
Tokens: 385
Type: sentence-based
Text:
If you make a split of this form and then find yourselfflippingbackandforthbetweentheparentandchildtounderstandhow theyworktogether,thatisaredflag(ConjoinedMethods)indicatingthatthe splitwasprobablyabadidea. Thesecondwaytobreakupamethodistosplititintotwoseparatemethods, eachvisibletocallersoftheoriginalmethod,asinFigure9.3(c). Thismakes senseiftheoriginalmethodhadanoverlycomplexinterfacebecauseittriedto do multiple things that were not closely related. If this is the case, it may be possibletodividethemethodsfunctionalityintotwoormoresmallermethods, eachofwhichhasonlyapartoftheoriginalmethodsfunctionality.Ifyoumake asplitlikethis,theinterfaceforeachoftheresultingmethodsshouldbesimpler thantheinterfaceoftheoriginalmethod.Ideally,mostcallersshouldonlyneed toinvokeoneofthetwonewmethods;ifcallersmustinvokebothofthenew methods,thenthataddscomplexity,whichmakesitlesslikelythatthesplitisa goodidea.Thenewmethodswillbemorefocusedinwhattheydo.Itisagood signifthenewmethodsaremoregeneral-purposethantheoriginalmethod(i.e, youcanimagineusingthemseparatelyinothersituations). Splits of the form shown in Figure 9.3(c) dont make sense very often, becausetheyresultincallershavingtodealwithmultiplemethodsinsteadof one.Whenyousplitthisway,youruntheriskofendingupwithseveralshallow methods, as in Figure 9.3(d). If the caller has to invoke each of the separate methods,passingstatebackandforthbetweenthem,thensplittingisnotagood idea.IfyoureconsideringasplitliketheoneinFigure9.3(c),youshouldjudge itbasedonwhetheritsimplifiesthingsforcallers.

--- Chunk 116 ---
Tokens: 355
Type: sentence-based
Text:
If the caller has to invoke each of the separate methods,passingstatebackandforthbetweenthem,thensplittingisnotagood idea.IfyoureconsideringasplitliketheoneinFigure9.3(c),youshouldjudge itbasedonwhetheritsimplifiesthingsforcallers. There are also situations where a system can be made simpler by joining methods together. For example, joining methods might replace two shallow methods with one deeper method; it might eliminate duplication of code; it mighteliminatedependenciesbetweentheoriginalmethods,orintermediatedata structures; it might result in better encapsulation, so that knowledge that was previouslypresentinmultipleplacesisnowisolatedinasingleplace;oritmight resultinasimplerinterface,asdiscussedinSection9.2. RedFlag:ConjoinedMethods Itshouldbepossibletounderstandeachmethodindependently.Ifyoucant understandtheimplementationofonemethodwithoutalsounderstandingthe implementationofanother,thatsaredflag.Thisredflagcanoccurinother contextsaswell:iftwopiecesofcodearephysicallyseparated,buteachcan onlybeunderstoodbylookingattheother,thatisaredflag. 9.9Conclusion Thedecisiontosplitorjoinmodulesshouldbebasedoncomplexity.Pickthe Thedecisiontosplitorjoinmodulesshouldbebasedoncomplexity.Pickthe structurethatresultsinthebestinformationhiding,thefewestdependencies,and thedeepestinterfaces. Chapter10 DefineErrorsOutOfExistence Exception handling is one of the worst sources of complexity in software systems.

--- Chunk 117 ---
Tokens: 394
Type: sentence-based
Text:
Chapter10 DefineErrorsOutOfExistence Exception handling is one of the worst sources of complexity in software systems. Code that deals with special conditions is inherently harder to write thancodethatdealswithnormalcases,anddevelopersoftendefineexceptions without considering how they will be handled. This chapter discusses why exceptions contribute disproportionately to complexity, then it shows how to simplifyexceptionhandling.Thekeyoveralllessonfromthischapteristoreduce the number of places where exceptions must be handled; in many cases the semanticsofoperationscanbemodifiedsothatthenormalbehaviorhandlesall situationsandthereisnoexceptionalconditiontoreport(hencethetitleofthis chapter). 10.1Whyexceptionsaddcomplexity I use the term exception to refer to any uncommon condition that alters the normalflowofcontrolinaprogram.Manyprogramminglanguagesincludea formalexceptionmechanismthatallowsexceptionstobethrownbylower-level codeandcaughtbyenclosingcode.However,exceptionscanoccurevenwithout usingaformalexceptionreportingmechanism,suchaswhenamethodreturnsa specialvalueindicatingthatitdidntcompleteitsnormalbehavior.Allofthese formsofexceptionscontributetocomplexity. A particular piece of code may encounter exceptions in several different ways: Acallermayprovidebadargumentsorconfigurationinformation. Aninvokedmethodmaynotbeabletocompletearequestedoperation.For example,anIOoperationmayfail,orarequiredresourcemaynotbe available. Inadistributedsystem,networkpacketsmaybelostordelayed,serversmay notrespondinatimelyfashion,orpeersmaycommunicateinunexpected ways.

--- Chunk 118 ---
Tokens: 384
Type: sentence-based
Text:
Inadistributedsystem,networkpacketsmaybelostordelayed,serversmay notrespondinatimelyfashion,orpeersmaycommunicateinunexpected ways. Thecodemaydetectbugs,internalinconsistencies,orsituationsitisnot preparedtohandle. Largesystemshavetodealwithmanyexceptionalconditions,particularlyifthey aredistributedorneedtobefault-tolerant.Exceptionhandlingcanaccountfora significantfractionofallthecodeinasystem. Exceptionhandlingcodeisinherentlymoredifficulttowritethannormal- casecode.Anexceptiondisruptsthenormalflowofthecode;itusuallymeans that something didnt work as expected. When an exception occurs, the programmercandealwithitintwoways,eachofwhichcanbecomplicated.The firstapproachistomoveforwardandcompletetheworkinprogressinspiteof theexception.Forexample,ifanetworkpacketislost,itcanberesent;ifdatais corrupted, perhaps it can be recovered from a redundant copy. The second approachistoaborttheoperationinprogressandreporttheexceptionupwards. However,abortingcanbecomplicatedbecausetheexceptionmayhaveoccurred atapointwheresystemstateisinconsistent(adatastructuremighthavebeen partiallyinitialized);theexceptionhandlingcodemustrestoreconsistency,such asbyunwindinganychangesmadebeforetheexceptionoccurred. Furthermore, exception handling code creates opportunities for more exceptions. Consider the case of resending a lost network packet. Perhaps the packetwasntactuallylost,butwassimplydelayed.Inthiscase,resendingthe packetwillresultinduplicatepacketsarrivingatthepeer;thisintroducesanew exceptional condition that the peer must handle.

--- Chunk 119 ---
Tokens: 386
Type: sentence-based
Text:
Perhaps the packetwasntactuallylost,butwassimplydelayed.Inthiscase,resendingthe packetwillresultinduplicatepacketsarrivingatthepeer;thisintroducesanew exceptional condition that the peer must handle. Or, consider the case of recoveringlostdatafromaredundantcopy:whatiftheredundantcopyhasalso beenlost?Secondaryexceptionsoccurringduringrecoveryareoftenmoresubtle andcomplexthantheprimaryexceptions.Ifanexceptionishandledbyaborting the operation in progress, then this must be reported to the caller as another exception. To prevent an unending cascade of exceptions, the developer must eventuallyfindawaytohandleexceptionswithoutintroducingmoreexceptions. Language support for exceptions tends to be verbose and clunky, which makesexceptionhandlingcodehardtoread.Forexample,considerthefollowing code, which reads a collection of tweets from a file using Javas support for objectserializationanddeserialization: try( FileInputStreamfileStream newFileInputStream(fileName); BufferedInputStreambufferedStream newBufferedInputStream(fileStream); ObjectInputStreamobjectStream newObjectInputStream(bufferedStream); ) for(inti0;itweetsPerFile;i) tweets.add((Tweet)objectStream.readObject());   catch(FileNotFoundExceptione) . catch(ClassNotFoundExceptione) . catch(EOFExceptione) Notaproblem:notalltweetfileshavefull setoftweets. catch(IOExceptione) . catch(ClassCastExceptione) . Just the basic try-catch boilerplate accounts for more lines of code than the codefornormal-caseoperation,withoutevenconsideringthecodethatactually handles the exceptions.

--- Chunk 120 ---
Tokens: 380
Type: sentence-based
Text:
Just the basic try-catch boilerplate accounts for more lines of code than the codefornormal-caseoperation,withoutevenconsideringthecodethatactually handles the exceptions. It is hard to relate the exception handling code to the normal-case code: for example, its not obvious where each exception is generated.Analternativeapproachistobreakupthecodeintomanydistincttry blocks;intheextremecasetherecouldbeatryforeachlineofcodethatcan generateanexception.Thiswouldmakeitclearwhereexceptionsoccur,butthe tryblocksthemselvesbreakuptheflowofthecodeandmakeithardertoread; inaddition,someexceptionhandlingcodemightendupduplicatedinmultiple tryblocks. Its difficult to ensure that exception handling code really works. Some Its difficult to ensure that exception handling code really works. Some exceptions,suchasIOerrors,canteasilybegeneratedinatestenvironment,so itshardtotestthecodethathandlesthem.Exceptionsdontoccurveryoftenin running systems, so exception handling code rarely executes. Bugs can go undetected for a long time, and when the exception handling code is finally needed,theresagoodchancethatitwontwork(oneofmyfavoritesayings: codethathasntbeenexecuteddoesntwork).Arecentstudyfoundthatmore than 90 of catastrophic failures in distributed data-intensive systems were caused by incorrect error handling1. When exception handling code fails, its difficulttodebugtheproblem,sinceitoccurssoinfrequently. 10.2Toomanyexceptions Programmersexacerbatetheproblemsrelatedtoexceptionhandlingbydefining unnecessary exceptions.

--- Chunk 121 ---
Tokens: 330
Type: sentence-based
Text:
10.2Toomanyexceptions Programmersexacerbatetheproblemsrelatedtoexceptionhandlingbydefining unnecessary exceptions. Most programmers are taught that its important to detect and report errors; they often interpret this to mean the more errors detected,thebetter.Thisleadstoanover-defensivestylewhereanythingthat looks even a bit suspicious is rejected with an exception, which results in a proliferation of unnecessary exceptions that increase the complexity of the system. ImadethismistakemyselfinthedesignoftheTclscriptinglanguage.Tcl contains an unset command that can be used to remove a variable. I defined unsetsothatitthrowsanerrorifthevariabledoesntexist.AtthetimeIthought thatitmustbeabugifsomeonetriestodeleteavariablethatdoesntexist,soTcl shouldreportit.However,oneofthemostcommonusesofunsetistocleanup temporary state created by some previous operation. Its often hard to predict exactly what state was created, particularly if the operation aborted partway through. Thus, the simplest thing is to delete all of the variables that might possibly have been created. The definition of unset makes this awkward: developers end up enclosing calls to unset in catch statements to catch and ignore errors thrown by unset. In retrospect, the definition of the unset commandisoneofthebiggestmistakesImadeinthedesignofTcl.

--- Chunk 122 ---
Tokens: 332
Type: sentence-based
Text:
In retrospect, the definition of the unset commandisoneofthebiggestmistakesImadeinthedesignofTcl. Its tempting to use exceptions to avoid dealing with difficult situations: ratherthanfiguringoutacleanwaytohandleit,justthrowanexceptionandpunt theproblemtothecaller.Somemightarguethatthisapproachempowerscallers, sinceitallowseachcallertohandletheexceptioninadifferentway.However,if youarehavingtroublefiguringoutwhattodofortheparticularsituation,theres a good chance that the caller wont know what to do either. Generating an exception in a situation like this just passes the problem to someone else and addstothesystemscomplexity. Theexceptionsthrownbyaclassarepartofitsinterface;classeswithlotsof exceptionshavecomplexinterfaces,andtheyareshallowerthanclasseswith fewerexceptions.Anexceptionisaparticularlycomplexelementofaninterface. Itcanpropagateupthroughseveralstacklevelsbeforebeingcaught,soitaffects not justthemethods caller, but potentially also higher-level callers (and their interfaces). Throwingexceptionsiseasy;handlingthemishard.Thus,thecomplexityof exceptionscomesfromtheexceptionhandlingcode.Thebestwaytoreducethe complexitydamagecausedbyexceptionhandlingistoreducethenumberof places where exceptions have to be handled. The rest of this chapter will discussfourtechniquesforreducingthenumberofexceptionhandlers.

--- Chunk 123 ---
Tokens: 337
Type: sentence-based
Text:
The rest of this chapter will discussfourtechniquesforreducingthenumberofexceptionhandlers. 10.3Defineerrorsoutofexistence ThebestwaytoeliminateexceptionhandlingcomplexityistodefineyourAPIs sothattherearenoexceptionstohandle:defineerrorsoutofexistence.This mayseemsacrilegious,butitisveryeffectiveinpractice.ConsidertheTclunset commanddiscussedabove.Ratherthanthrowinganerrorwhenunsetisaskedto delete an unknown variable, it should have simply returned without doing anything. I should have changed the definition of unset slightly: rather than deletingavariable,unsetshouldensurethatavariablenolongerexists.Withthe firstdefinition,unsetcantdoitsjobifthevariabledoesntexist,sogenerating anexceptionmakessense.Withtheseconddefinition,itisperfectlynaturalfor unsettobeinvokedwiththenameofavariablethatdoesntexist.Inthiscase,its workisalreadydone,soitcansimplyreturn.Thereisnolongeranerrorcaseto report. 10.4Example:filedeletioninWindows Filedeletionprovidesanotherexampleofhowerrorscanbedefinedaway.The Windowsoperatingsystemdoesnotpermitafiletobedeletedifitisopenina process. This is a continual source of frustration for developers and users. In ordertodeleteafilethatisinuse,theusermustsearchthroughthesystemto find the process that has the file open, and then kill that process. Sometimes usersgiveupandreboottheirsystem,justsotheycandeleteafile.

--- Chunk 124 ---
Tokens: 384
Type: sentence-based
Text:
Sometimes usersgiveupandreboottheirsystem,justsotheycandeleteafile. TheUnixoperatingsystemdefinesfiledeletionmoreelegantly.InUnix,ifa fileisopenwhenitisdeleted,Unixdoesnotdeletethefileimmediately.Instead, itmarksthefilefordeletion,thenthedeleteoperationreturnssuccessfully.The filenamehasbeenremovedfromitsdirectory,sonootherprocessescanopen theoldfileandanewfilewiththesamenamecanbecreated,buttheexisting filedatapersists.Processesthatalreadyhavethefileopencancontinuetoreadit and write it normally. Once the file has been closed by all of the accessing processes,itsdataisfreed. The Unix approach defines away two different kinds of errors. First, the delete operation no longer returns an error if the file is currently in use; the deletesucceeds,andthefilewilleventuallybedeleted.Second,deletingafile thats in use does not create exceptions for the processes using the file. One possibleapproachtothisproblemwouldhavebeentodeletethefileimmediately and mark all of the opens of the file to disable them; any attempts by other processes to read or write the deleted file would fail. However, this approach wouldcreatenewerrorsforthoseprocessestohandle.Instead,Unixallowsthem tokeepaccessingthefilenormally;delayingthefiledeletiondefineserrorsout ofexistence. ItmayseemstrangethatUnixallowsaprocesstocontinuetoreadandwrite a doomed file, but I have never encountered a situation where this caused significant problems. The Unix definition of file deletion is much simpler to workwith,bothfordevelopersandusers,thantheWindowsdefinition.

--- Chunk 125 ---
Tokens: 380
Type: sentence-based
Text:
The Unix definition of file deletion is much simpler to workwith,bothfordevelopersandusers,thantheWindowsdefinition. 10.5Example:Javasubstringmethod As a final example, considerthe Java String class and its substring method. Giventwoindexesintoastring, substringreturnsthesubstringstartingatthe charactergivenbythefirstindexandendingwiththecharacterjustbeforethe secondindex.However,ifeitherindexisoutsidetherangeofthestring,then substring throws IndexOutOfBoundsException. This exception is unnecessary andcomplicatestheuseofthismethod.Ioftenfindmyselfinasituationwhere oneorbothoftheindicesmaybeoutsidetherangeofthestring,andIwouldlike to extract all of the characters in the string that overlap the specified range. Unfortunately,thisrequiresmetocheckeachoftheindicesandroundthemupto zeroordowntotheendofthestring;aone-linemethodcallnowbecomes510 linesofcode. The Java substring method would be easier to use if it performed this adjustmentautomatically,sothatitimplementedthefollowingAPI:returnsthe charactersofthestring(ifany)withindexgreaterthanorequaltobeginIndex and less than endIndex. This is a simple and natural API, and it defines the IndexOutOfBoundsExceptionexceptionoutofexistence.Themethodsbehavioris nowwell-definedevenifoneorbothoftheindexesarenegative,orifbeginIndex isgreaterthanendIndex.ThisapproachsimplifiestheAPIforthemethodwhile increasingitsfunctionality,soitmakesthemethoddeeper.Manyotherlanguages havetakentheerror-freeapproach;forexample,Pythonreturnsanemptyresult forout-of-rangelistslices.

--- Chunk 126 ---
Tokens: 399
Type: sentence-based
Text:
This is a simple and natural API, and it defines the IndexOutOfBoundsExceptionexceptionoutofexistence.Themethodsbehavioris nowwell-definedevenifoneorbothoftheindexesarenegative,orifbeginIndex isgreaterthanendIndex.ThisapproachsimplifiestheAPIforthemethodwhile increasingitsfunctionality,soitmakesthemethoddeeper.Manyotherlanguages havetakentheerror-freeapproach;forexample,Pythonreturnsanemptyresult forout-of-rangelistslices. WhenIarguefordefiningerrorsoutofexistence,peoplesometimescounter thatthrowingerrorswillcatchbugs;iferrorsaredefinedoutofexistence,wont thatresultinbuggiersoftware?PerhapsthisiswhytheJavadevelopersdecided thatsubstringshouldthrowexceptions.Theerror-fulapproachmaycatchsome bugs,butitalsoincreasescomplexity,whichresultsinotherbugs.Intheerror- fulapproach,developersmustwriteadditionalcodetoavoidorignoretheerrors, and this increases the likelihood of bugs; or, they may forget to write the additionalcode,inwhichcaseunexpectederrorsmaybethrownatruntime.In contrast, defining errors out of existence simplifies APIs and it reduces the amountofcodethatmustbewritten. Overall,thebestwaytoreducebugsistomakesoftwaresimpler. 10.6Maskexceptions Thesecondtechniqueforreducingthenumberofplaceswhereexceptionsmust behandledisexceptionmasking.Withthisapproach,anexceptionalconditionis detected and handled at a low level in the system, so that higher levels of softwareneednotbeawareofthecondition.Exceptionmaskingisparticularly common in distributed systems. For instance, in a network transport protocol suchasTCP,packetscanbedroppedforvariousreasonssuchascorruptionand congestion.

--- Chunk 127 ---
Tokens: 372
Type: sentence-based
Text:
For instance, in a network transport protocol suchasTCP,packetscanbedroppedforvariousreasonssuchascorruptionand congestion. TCP masks packet loss by resending lost packets within its implementation,soalldataeventuallygetsthroughandclientsareunawareofthe droppedpackets. A more controversial example of masking occurs in the NFS network file A more controversial example of masking occurs in the NFS network file system.IfanNFSfileservercrashesorfailstorespondforanyreason,clients reissue their requests to the server over and over again until the problem is eventuallyresolved.Thelow-levelfilesystemcodeontheclientdoesnotreport anyexceptionstotheinvokingapplication.Theoperationinprogress(andhence theapplication)justhangsuntiltheoperationcancompletesuccessfully.Ifthe hanglastsmorethanashorttime,theNFSclientprintsmessagesontheusers consoleoftheformNFSserverxyzzynotrespondingstilltrying. NFSusersoftencomplainaboutthefactthattheirapplicationshangwhile waiting for an NFS server to resume normal operation. Many people have suggested that NFS should abort operations with an exception rather than hanging. However, reporting exceptions would make things worse, not better. Theres not much an application can do if it loses access to its files. One possibilitywouldbefortheapplicationtoretrythefileoperation,butthiswould stillhangtheapplication,anditseasiertoperformtheretryinoneplaceinthe NFSlayer,ratherthanateveryfilesystemcallineveryapplication(acompiler shouldnthavetoworryaboutthis!

--- Chunk 128 ---
Tokens: 377
Type: sentence-based
Text:
One possibilitywouldbefortheapplicationtoretrythefileoperation,butthiswould stillhangtheapplication,anditseasiertoperformtheretryinoneplaceinthe NFSlayer,ratherthanateveryfilesystemcallineveryapplication(acompiler shouldnthavetoworryaboutthis! ).Theotheralternativeisforapplicationsto abortandreturnerrorstotheircallers.Itsunlikelythatthecallerswouldknow whattodoeither,sotheywouldabortaswell,resultinginacollapseoftheusers workingenvironment.Usersstillwouldntbeabletogetanyworkdonewhilethe fileserverwasdown,andtheywouldhavetorestartalloftheirapplicationsonce thefileservercamebacktolife. Thus, the best alternative is for NFS to mask the errors and hang applications.Withthisapproach,applicationsdontneedanycodetodealwith serverproblems,andtheycanresumeseamlesslyoncetheservercomesbackto life.Ifusersgettiredofwaiting,theycanalwaysabortapplicationsmanually. Exceptionmaskingdoesntworkinallsituations,butitisapowerfultoolin the situations where it works. It results in deeper classes, since it reduces the classs interface (fewer exceptions for users to be aware of) and adds functionality in the form of the code that masks the exception. Exception maskingisanexampleofpullingcomplexitydownward. 10.7Exceptionaggregation The third technique forreducing complexity related to exceptions is exception aggregation.Theideabehindexceptionaggregationistohandlemanyexceptions with a single piece of code; rather than writing distinct handlers for many individualexceptions,handlethemallinoneplacewithasinglehandler.

--- Chunk 129 ---
Tokens: 356
Type: sentence-based
Text:
10.7Exceptionaggregation The third technique forreducing complexity related to exceptions is exception aggregation.Theideabehindexceptionaggregationistohandlemanyexceptions with a single piece of code; rather than writing distinct handlers for many individualexceptions,handlethemallinoneplacewithasinglehandler. ConsiderhowtohandlemissingparametersinaWebserver.AWebserver implementsacollectionofURLs.WhentheserverreceivesanincomingURL,it dispatchestoaURL-specificservicemethodtoprocessthatURLandgeneratea response. The URL contains various parameters that are used to generate the response. Each service method will call a lower-level method (lets call it getParameter)toextracttheparametersthatitneedsfromtheURL.IftheURL doesnotcontainthedesiredparameter,getParameterthrowsanexception. Whenstudentsinasoftwaredesignclassimplementedsuchaserver,manyof themwrappedeachdistinctcalltogetParameterinaseparateexceptionhandler tocatchNoSuchParameterexceptions,asinFigure10.1.Thisresultedinalarge numberofhandlers,allofwhichdidessentiallythesamething(generateanerror response). Figure10.1: The code at the top dispatches to one of several methods in a Web server, each of which handles a particular URL. Each of those methods (bottom) uses parameters from the incoming HTTP request.Inthisfigure,thereisaseparateexceptionhandlerforeachcalltogetParameter;thisresultsin duplicatedcode. A better approach is to aggregate the exceptions.

--- Chunk 130 ---
Tokens: 371
Type: sentence-based
Text:
A better approach is to aggregate the exceptions. Instead of catching the exceptionsintheindividualservicemethods,letthempropagateuptothetop- leveldispatchmethodfortheWebserver,asinFigure10.2.Asinglehandlerin this method can catch all of the exceptions and generate an appropriate error responseformissingparameters. The aggregation approach can be taken even further in the Web example. There are many other errors besides missing parameters that can occur while processingaWebpage;forexample,aparametermightnothavetherightsyntax (theservicemethodexpectedaninteger,butthevaluewasxyz),ortheuser mightnothavepermissionfortherequestedoperation.Ineachcase,theerror shouldresultinanerrorresponse;theerrorsdifferonlyintheerrormessageto include in the response (parameter quantity not present in URL or bad value xyz for quantity parameter; must be positive integer). Thus, all conditionsresultinginanerrorresponsecanbehandledwithasingletop-level exceptionhandler.Theerrormessagecanbegeneratedatthetimetheexception is thrown and included as a variable in the exception record; for example, getParameter will generate the parameter quantity not present in URL message. The top-level handler extracts the message from the exception and incorporatesitintotheerrorresponse. Figure 10.2: This code is functionally equivalent to Figure 10.1, but exception handling has been aggregated:asingleexceptionhandlerinthedispatchercatchesalloftheNoSuchParameterexceptionsfrom alloftheURL-specificmethods.

--- Chunk 131 ---
Tokens: 341
Type: sentence-based
Text:
Figure 10.2: This code is functionally equivalent to Figure 10.1, but exception handling has been aggregated:asingleexceptionhandlerinthedispatchercatchesalloftheNoSuchParameterexceptionsfrom alloftheURL-specificmethods. Theaggregation describedinthe preceding paragraphhas good properties from the standpoint of encapsulation and information hiding. The top-level exception handler encapsulates knowledge about how to generate error responses, but it knows nothing about specific errors; it just uses the error message provided in the exception. The getParameter method encapsulates knowledgeabouthowtoextractaparameterfromaURL,anditalsoknowshow to describe extraction errors in a human-readable form. These two pieces of information are closely related, so it makes sense for them to be in the same place.However,getParameterknowsnothingaboutthesyntaxofanHTTPerror response. As new functionality is added to the Web server, new methods like getParametermaybecreatedwiththeirownerrors.Ifthenewmethodsthrow exceptions in the same way as getParameter (by generating exceptions that inherit from the same superclass and including an error message in each exception),theycanplugintotheexistingsystemwithnootherchanges:thetop- levelhandlerwillautomaticallygenerateerrorresponsesforthem. This example illustrates a generally-useful design pattern for exception handling.

--- Chunk 132 ---
Tokens: 322
Type: sentence-based
Text:
This example illustrates a generally-useful design pattern for exception handling. If a system processes a series of requests, its useful to define an exception that aborts the current request, cleans up the systems state, and continueswiththenextrequest.Theexceptioniscaughtinasingleplacenearthe topofthesystemsrequest-handlingloop.Thisexceptioncanbethrownatany pointintheprocessingofarequesttoaborttherequest;differentsubclassesof the exception can be defined for different conditions. Exceptions of this type shouldbeclearlydistinguishedfromexceptionsthatarefataltotheentiresystem. Exceptionaggregationworksbestifanexceptionpropagatesseverallevelsup thestackbeforeitishandled;thisallowsmoreexceptionsfrommoremethodsto be handled in the same place. This is the opposite of exception masking: maskingusuallyworksbestifanexceptionishandledinalow-levelmethod.For masking,thelow-levelmethodistypicallyalibrarymethodusedbymanyother methods,soallowingtheexceptiontopropagatewouldincreasethenumberof places where it is handled. Masking and aggregation are similar in that both approachespositionanexceptionhandlerwhereitcancatchthemostexceptions, eliminatingmanyhandlersthatwouldotherwiseneedtobecreated. AnotherexampleofexceptionaggregationoccursintheRAMCloudstorage system for crash recovery.

--- Chunk 133 ---
Tokens: 392
Type: sentence-based
Text:
AnotherexampleofexceptionaggregationoccursintheRAMCloudstorage system for crash recovery. A RAMCloud system consists of a collection of storage servers that keep multiple copies of each object, so the system can recoverfromavarietyoffailures.Forexample,ifaservercrashesandlosesallof its data, RAMCloud reconstructs the lost data using copies stored on other servers.Errorscanalsohappenonasmallerscale;forexample,aservermay discoverthatanindividualobjectiscorrupted. RAMClouddoesnothaveseparaterecoverymechanismsforeachdifferent kindoferror.Instead,RAMCloudpromotesmanysmallererrorsintolarger ones.RAMCloudcould,inprinciple,handleacorruptedobjectbyrestoringthat one object from a backup copy. However, it doesnt do this. Instead, if it discovers a corrupted object it crashes the server containing the object. RAMCloudusesthisapproachbecausecrashrecoveryisquitecomplexandthis approachminimizedthenumberofdifferentrecoverymechanismsthathadtobe created.Creatingarecoverymechanismforcrashedserverswasunavoidable,so RAMCloudusesthesamemechanismforotherkindsofrecoveryaswell.This reducedtheamountofcodethathadtobewritten,anditalsomeantthatserver crashrecoverygetsinvokedmoreoften.Asaresult,bugsinrecoveryaremore likelytobediscoveredandfixed. Onedisadvantageofpromotingacorruptedobjectintoaservercrashisthat it increases the cost of recovery considerably. This is not a problem in RAMCloud,sinceobjectcorruptionisquiterare.However,errorpromotionmay notmakesenseforerrorsthathappenfrequently.Asoneexample,itwouldnot bepracticaltocrashaserveranytimeoneofitsnetworkpacketsislost.

--- Chunk 134 ---
Tokens: 384
Type: sentence-based
Text:
This is not a problem in RAMCloud,sinceobjectcorruptionisquiterare.However,errorpromotionmay notmakesenseforerrorsthathappenfrequently.Asoneexample,itwouldnot bepracticaltocrashaserveranytimeoneofitsnetworkpacketsislost. Onewayofthinkingaboutexceptionaggregationisthatitreplacesseveral special-purpose mechanisms, each tailored for a particular situation, with a single general-purpose mechanism that can handle multiple situations. This providesanotherillustrationofthebenefitsofgeneral-purposemechanisms. 10.8Justcrash? Thefourthtechniqueforreducingcomplexityrelatedtoexceptionhandlingisto crashtheapplication.Inmostapplicationstherewillbecertainerrorsthatitsnot worth trying to handle. Typically, these errors are difficult or impossible to handleanddontoccurveryoften.Thesimplestthingtodoinresponsetothese errorsistoprintdiagnosticinformationandthenaborttheapplication. Oneexampleisoutofmemoryerrorsthatoccurduringstorageallocation. ConsiderthemallocfunctioninC,whichreturns NULLifitcannotallocatethe desiredblockofmemory.Thisisanunfortunatebehavior,becauseitassumes thateverysinglecallerofmallocwillcheckthereturnvalueandtakeappropriate actionifthereisnomemory.Applicationscontainnumerouscallstomalloc,so checking the result after each call would add significant complexity. If a programmerforgetsthecheck(whichisfairlylikely),thentheapplicationwill dereference a null pointer if memory runs out, resulting in a crash that camouflagestherealproblem. Furthermore,thereisntmuchanapplicationcandowhenitdiscoversthat memory is exhausted.

--- Chunk 135 ---
Tokens: 282
Type: sentence-based
Text:
Furthermore,thereisntmuchanapplicationcandowhenitdiscoversthat memory is exhausted. In principle the application could look for unneeded memorytofree,butiftheapplicationhadunneededmemoryitcouldalready havefreedit,whichwouldhavepreventedtheout-of-memoryerrorinthefirst place.Todayssystemshavesomuchmemorythatmemoryalmostneverruns out;ifitdoes,itusuallyindicatesabugintheapplication.Thus,itrarelymake sensetotrytohandleout-of-memoryerrors;thiscreatestoomuchcomplexity fortoolittlebenefit. Abetterapproachistodefineanewmethod ckalloc,whichcalls malloc, checkstheresult,andabortstheapplicationwithanerrormessageifmemoryis exhausted. The application never invokes malloc directly; it always invokes ckalloc. In newer languages such as C and Java, the new operator throws an exception if memory is exhausted. Theres not much point in catching this exception,sincetheresagoodchancethattheexceptionhandlerwillalsotryto allocatememory,whichwillalsofail.Dynamicallyallocatedmemoryissucha fundamentalelementofanymodernapplicationthatitdoesntmakesensefor theapplicationtocontinueifmemoryisexhausted;itsbettertocrashassoonas theerrorisdetected.

--- Chunk 136 ---
Tokens: 380
Type: sentence-based
Text:
Theres not much point in catching this exception,sincetheresagoodchancethattheexceptionhandlerwillalsotryto allocatememory,whichwillalsofail.Dynamicallyallocatedmemoryissucha fundamentalelementofanymodernapplicationthatitdoesntmakesensefor theapplicationtocontinueifmemoryisexhausted;itsbettertocrashassoonas theerrorisdetected. There are many other examples of errors where crashing the application makessense.Formostprograms,ifanIOerroroccurswhilereadingorwriting anopenfile(suchasadiskharderror),orifanetworksocketcannotbeopened, theresnotmuchtheapplicationcandotorecover,soabortingwithaclearerror messageisasensibleapproach.Theseerrorsareinfrequent,sotheyareunlikely toaffecttheoverallusabilityoftheapplication.Abortingwithanerrormessage is also appropriate if an application encounters an internal error such as an inconsistent data structure. Conditions like this probably indicate bugs in the program. Whetherornotitisacceptabletocrashonaparticularerrordependsonthe application.Forareplicatedstoragesystem,itisntappropriatetoabortonanIO error.Instead,thesystemmustusereplicateddatatorecoveranyinformationthat was lost. The recovery mechanisms will add considerable complexity to the program, but recovering lost data is an essential part of the value the system providestoitsusers. 10.9Designspecialcasesoutofexistence Forthesamereasonthatitmakessensetodefineerrorsoutofexistence,italso Forthesamereasonthatitmakessensetodefineerrorsoutofexistence,italso makes sense to define other special cases out of existence.

--- Chunk 137 ---
Tokens: 277
Type: sentence-based
Text:
10.9Designspecialcasesoutofexistence Forthesamereasonthatitmakessensetodefineerrorsoutofexistence,italso Forthesamereasonthatitmakessensetodefineerrorsoutofexistence,italso makes sense to define other special cases out of existence. Special cases can resultincodethatisriddledwith ifstatements,whichmakethecodehardto understandandleadtobugs.Thus,specialcasesshouldbeeliminatedwherever possible.Thebestwaytodothisisbydesigningthenormalcaseinawaythat automaticallyhandlesthespecialcaseswithoutanyextracode. InthetexteditorprojectdescribedinChapter6,studentshadtoimplementa mechanismforselectingtextandcopyingordeletingtheselection.Moststudents introducedastatevariableintheirselectionimplementationtoindicatewhether ornottheselectionexists.Theyprobablychosethisapproachbecausethereare timeswhennoselectionisvisibleonthescreen,soitseemednaturaltorepresent thisnotionintheimplementation.However,thisapproachresultedinnumerous checkstodetectthenoselectionconditionandhandleitspecially. The selection handling code can be simplified by eliminating the no selection special case, so that the selection always exists.

--- Chunk 138 ---
Tokens: 321
Type: sentence-based
Text:
The selection handling code can be simplified by eliminating the no selection special case, so that the selection always exists. When there is no selectionvisibleonthescreen,itcanberepresentedinternallywithanempty selection,whosestartingandendingpositionsarethesame.Withthisapproach, the selection management code can be written without any checks for no selection.Whencopyingtheselection,iftheselectionisemptythen0byteswill beinsertedatthenewlocation(ifimplementedcorrectly,therewillbenoneedto checkfor0bytesasaspecialcase).Similarly,itshouldbepossibletodesignthe code for deleting the selection so that the empty case is handled without any special-case checks. Consider a selection all on a single line. To delete the selection,extracttheportionofthelineprecedingtheselectionandconcatenate itwiththeportionofthelinefollowingtheselectiontoformthenewline.Ifthe selectionisempty,thisapproachwillregeneratetheoriginalline. Thisexamplealsoillustratesthedifferentlayer,differentabstractionidea fromChapter7.Thenotionofnoselectionmakessenseintermsofhowthe userthinksabouttheapplicationsinterface,butthatdoesntmeanithastobe represented explicitly inside the application. Having a selection that always exists, but is sometimes empty and thus invisible, results in a simpler implementation.

--- Chunk 139 ---
Tokens: 339
Type: sentence-based
Text:
Having a selection that always exists, but is sometimes empty and thus invisible, results in a simpler implementation. 10.10Takingittoofar Definingawayexceptions,ormaskingtheminsideamodule,onlymakessenseif theexceptioninformationisntneededoutsidethemodule.Thiswastrueforthe examplesinthischapter,suchtheTcl unsetcommandandtheJava substring method; in the rare situations where a caller cares about the special cases detectedbytheexceptions,thereareotherwaysforittogetthisinformation. However, it is possible to take this idea too far. In a module for network communication,astudentteammaskedallnetworkexceptions:ifanetworkerror occurred,themodulecaughtit,discardedit,andcontinuedasiftherewereno problem.Thismeantthatapplicationsusingthemodulehadnowaytofindoutif messages were lost or a peer server failed; without this information, it was impossibletobuildrobustapplications.Inthiscase,itisessentialforthemodule to expose the exceptions, even though they add complexity to the modules interface. With exceptions, as with many other areas in software design, you must determine what is important and what is not important. Things that are not important should be hidden, and the more of them the better. But when somethingisimportant,itmustbeexposed. 10.11Conclusion Special cases of any form make code harder to understand and increase the likelihood of bugs.

--- Chunk 140 ---
Tokens: 396
Type: sentence-based
Text:
10.11Conclusion Special cases of any form make code harder to understand and increase the likelihood of bugs. This chapter focused on exceptions, which are one of the mostsignificantsourcesofspecial-casecode,anddiscussedhowtoreducethe numberofplaceswhereexceptionsmustbehandled.Thebestwaytodothisis byredefiningsemanticstoeliminateerrorconditions.Forexceptionsthatcant bedefinedaway,youshouldlookforopportunitiestomaskthematalowlevel, sotheirimpactislimited,oraggregateseveralspecial-casehandlersintoasingle moregenerichandler.Together,thesetechniquescanhaveasignificantimpact onoverallsystemcomplexity. 1Ding Yuan et. al, Simple Testing Can Prevent Most Critical Failures: An Analysis of Production FailuresinDistributedData-IntensiveSystems,2014USENIXConferenceonOperatingSystemDesign andImplementation. Chapter11 DesignitTwice Designingsoftwareishard,soitsunlikelythatyourfirstthoughtsabouthowto structureamoduleorsystemwillproducethebestdesign.Youllendupwitha much better result if you consider multiple options for each major design decision:designittwice. Supposeyouaredesigningtheclassthatwillmanagethetextofafilefora GUItexteditor.Thefirststepistodefinetheinterfacethattheclasswillpresent totherestoftheeditor;ratherthanpickingthefirstideathatcomestomind, consider several possibilities. One choice is a line-oriented interface, with operationstoinsert,modify,anddeletewholelinesoftext.Anotheroptionisan interfacebasedonindividualcharacterinsertionsanddeletions.Athirdchoiceis astring-orientedinterface,whichoperatesonarbitraryrangesofcharactersthat may cross line boundaries.

--- Chunk 141 ---
Tokens: 372
Type: sentence-based
Text:
One choice is a line-oriented interface, with operationstoinsert,modify,anddeletewholelinesoftext.Anotheroptionisan interfacebasedonindividualcharacterinsertionsanddeletions.Athirdchoiceis astring-orientedinterface,whichoperatesonarbitraryrangesofcharactersthat may cross line boundaries. You dont need to pin down every feature of each alternative;itssufficientatthispointtosketchoutafewofthemostimportant methods. Try to pick approaches that are radically different from each other; youll learnmorethatway.Evenifyouarecertainthatthereisonlyonereasonable approach,consideraseconddesignanyway,nomatterhowbadyouthinkitwill be.Itwillbeinstructivetothinkabouttheweaknessesofthatdesignandcontrast themwiththefeaturesofotherdesigns. Afteryouhaveroughedoutthedesignsforthealternatives,makealistofthe prosandconsofeachone.Themostimportantconsiderationforaninterfaceis easeofuseforhigherlevelsoftware.Intheexampleabove,boththeline-oriented interfaceandthecharacter-orientedinterfacewillrequireextraworkinsoftware that uses the text class. The line-oriented interface will require higher level softwaretosplitandjoinlinesduringpartial-lineandmulti-lineoperationssuch ascuttingandpastingtheselection.Thecharacter-orientedinterfacewillrequire loopstoimplementoperationsthatmodifymorethanasinglecharacter.Itisalso worthconsideringotherfactors: Doesonealternativehaveasimplerinterfacethananother?Inthetext example,allofthetextinterfacesarerelativelysimple. Isoneinterfacemoregeneral-purposethananother?

--- Chunk 142 ---
Tokens: 385
Type: sentence-based
Text:
Isoneinterfacemoregeneral-purposethananother? Doesoneinterfaceenableamoreefficientimplementationthananother?In thetextexample,thecharacter-orientedapproachislikelytobesignificantly slowerthantheothers,becauseitrequiresaseparatecallintothetext moduleforeachcharacter. Onceyouhavecomparedalternativedesigns,youwillbeinabetterposition toidentifythebestdesign.Thebestchoicemaybeoneofthealternatives,oryou maydiscoverthatyoucancombinefeaturesofmultiplealternativesintoanew designthatisbetterthananyoftheoriginalchoices. Sometimes none of the alternatives is particularly attractive; when this happens,seeifyoucancomeupwithadditionalschemes.Usetheproblemsyou identifiedwiththeoriginalalternativestodrivethenewdesign(s).Ifyouwere designing the text class and considered only the line-oriented and character- orientedapproaches,youmightnoticethateachofthealternativesisawkward because it requires higher level software to perform additional text manipulations. Thats a red flag: if theres going to be a text class, it should handle all of the text manipulation. In order to eliminate the additional text manipulations, the text interface needs to match more closely the operations happeninginhigherlevelsoftware.Theseoperationsdontalwayscorrespondto single characters or single lines. This line of reasoning should lead you to a range-oriented API for text, which eliminates the problem with the earlier designs. Thedesign-it-twiceprinciplecanbeappliedatmanylevelsinasystem.Fora module,youcanusethisapproachfirsttopicktheinterface,asdescribedabove.

--- Chunk 143 ---
Tokens: 397
Type: sentence-based
Text:
Thedesign-it-twiceprinciplecanbeappliedatmanylevelsinasystem.Fora module,youcanusethisapproachfirsttopicktheinterface,asdescribedabove. Thenyoucanapplyitagainwhenyouaredesigningtheimplementation:forthe text class, you might consider implementations such as a linked list of lines, fixed-sizeblocksofcharacters,oragapbuffer.Thegoalswillbedifferentfor the implementation than for the interface: for the implementation, the most important things are simplicity and performance. Its also useful to explore multipledesignsathigherlevelsinthesystem,suchaswhenchoosingfeatures forauserinterface,orwhendecomposingasystemintomajormodules.Ineach case, its easier to identify the best approach if you can compare a few alternatives. Designingittwicedoesnotneedtotakealotofextratime.Forasmaller Designingittwicedoesnotneedtotakealotofextratime.Forasmaller modulesuchasaclass,youmaynotneedmorethananhourortwotoconsider alternatives.Thisisasmallamountoftimecomparedtothedaysorweeksyou willspendimplementingtheclass.Theinitialdesignexperimentswillprobably resultinasignificantlybetterdesign,whichwillmorethanpayforthetimespent designing it twice. For larger modules youll spend more time in the initial design explorations, but the implementation will also take longer, and the benefitsofabetterdesignwillalsobehigher. Ihavenoticedthatthedesign-it-twiceprincipleissometimeshardforreally smartpeopletoembrace.Whentheyaregrowingup,smartpeoplediscoverthat theirfirstquickideaaboutanyproblemissufficientforagoodgrade;thereisno needtoconsiderasecondorthirdpossibility.Thismakesiteasytodevelopbad work habits.

--- Chunk 144 ---
Tokens: 387
Type: sentence-based
Text:
Ihavenoticedthatthedesign-it-twiceprincipleissometimeshardforreally smartpeopletoembrace.Whentheyaregrowingup,smartpeoplediscoverthat theirfirstquickideaaboutanyproblemissufficientforagoodgrade;thereisno needtoconsiderasecondorthirdpossibility.Thismakesiteasytodevelopbad work habits. However, as these people get older, they get promoted into environmentswithharderandharderproblems.Eventually,everyonereachesa pointwhereyourfirstideasarenolongergoodenough;ifyouwanttogetreally greatresults,youhavetoconsiderasecondpossibility,orperhapsathird,no matter how smart you are. The design of large software systems falls in this category:no-oneisgoodenoughtogetitrightwiththeirfirsttry. Unfortunately,Ioftenseesmartpeoplewhoinsistonimplementingthefirst idea that comes to mind, and this causes them to underperform their true potential (it also makes them frustrating to work with). Perhaps they subconsciouslybelievethatsmartpeoplegetitrightthefirsttime,soiftheytry multipledesignsitwouldmeantheyarenotsmartafterall.Thisisnotthecase. Itisntthatyouarentsmart;itsthattheproblemsarereallyhard!Furthermore, thatsagoodthing:itsmuchmorefuntoworkonadifficultproblemwhereyou have to think carefully, rather than an easy problem where you dont have to thinkatall. The design-it-twice approach not only improves your designs, but it also improves your design skills. The process of devising and comparing multiple approacheswillteachyouaboutthefactorsthatmakedesignsbetterorworse. Overtime,thiswillmakeiteasierforyoutoruleoutbaddesignsandhoneinon reallygreatones.

--- Chunk 145 ---
Tokens: 305
Type: sentence-based
Text:
Overtime,thiswillmakeiteasierforyoutoruleoutbaddesignsandhoneinon reallygreatones. Chapter12 WhyWriteComments?TheFourExcuses In-code documentation plays a crucial role in software design. Comments are essential to help developers understand a system and work efficiently, but the roleofcommentsgoesbeyondthis.Documentationalsoplaysanimportantrole in abstraction; without comments, you cant hide complexity. Finally, the process of writing comments, if done correctly, will actually improve a systemsdesign.Conversely,agoodsoftwaredesignlosesmuchofitsvalueifit ispoorlydocumented. Unfortunately,thisviewisnotuniversallyshared.Asignificantfractionof productioncodecontainsessentiallynocomments.Manydevelopersthinkthat commentsareawasteoftime;othersseethevalueincomments,butsomehow never get around to writing them. Fortunately, many development teams recognizethevalueofdocumentation,anditfeelsliketheprevalenceofthese teams is gradually increasing. However, even in teams that encourage documentation,commentsareoftenviewedasdrudgeworkandmanydevelopers dont understand how to write them, so the resulting documentation is often mediocre. Inadequate documentation creates a huge and unnecessary drag on softwaredevelopment.

--- Chunk 146 ---
Tokens: 323
Type: sentence-based
Text:
Inadequate documentation creates a huge and unnecessary drag on softwaredevelopment. In this chapter I will discuss the excuses developers use to avoid writing comments,andthereasonswhycommentsreallydomatter.Chapter13willthen describehowtowritegoodcommentsandthenextfewchaptersafterthatwill discuss related issues such as choosing variable names and how to use documentationtoimproveasystemsdesign.Ihopethesechapterswillconvince you of three things: good comments can make a big difference in the overall qualityofsoftware;itisnthardtowritegoodcomments;and(thismaybehard tobelieve)writingcommentscanactuallybefun. Whendevelopersdontwritecomments,theyusuallyjustifytheirbehavior withoneormoreofthefollowingexcuses: Goodcodeisself-documenting. Idonthavetimetowritecomments. Commentsgetoutofdateandbecomemisleading. ThecommentsIhaveseenareallworthless;whybother?Inthesections belowIwilladdresseachoftheseexcusesinturn. 12.1Goodcodeisself-documenting Some people believe that if code is written well, it is so obvious that no commentsareneeded.Thisisadeliciousmyth,likearumorthaticecreamis goodforyourhealth:wedreallyliketobelieveit!Unfortunately,itssimplynot true.Tobesure,therearethingsyoucandowhenwritingcodetoreducethe need for comments, such as choosing good variable names (see Chapter 14).

--- Chunk 147 ---
Tokens: 364
Type: sentence-based
Text:
12.1Goodcodeisself-documenting Some people believe that if code is written well, it is so obvious that no commentsareneeded.Thisisadeliciousmyth,likearumorthaticecreamis goodforyourhealth:wedreallyliketobelieveit!Unfortunately,itssimplynot true.Tobesure,therearethingsyoucandowhenwritingcodetoreducethe need for comments, such as choosing good variable names (see Chapter 14). Nonetheless,thereisstillasignificantamountofdesigninformationthatcantbe representedincode.Forexample,onlyasmallpartofaclasssinterface,suchas thesignaturesofitsmethods,canbespecifiedformallyinthecode.Theinformal aspects of an interface, such as a high-level description of what each method doesorthemeaningofitsresult,canonlybedescribedincomments.Thereare manyotherexamplesofthingsthatcantbedescribedinthecode,suchasthe rationaleforaparticulardesigndecision,ortheconditionsunderwhichitmakes sensetocallaparticularmethod. Somedevelopersarguethatifotherswanttoknowwhatamethoddoes,they should just read the code of the method: this will be more accurate than any comment.Itspossiblethatareadercoulddeducetheabstractinterfaceofthe method by reading its code, but it would be time-consuming and painful. In addition, if you write code with the expectation that users will read method implementations,youwilltrytomakeeachmethodasshortaspossible,sothat itseasytoread.Ifthemethoddoesanythingnontrivial,youwillbreakitupinto severalsmallermethods.Thiswillresultinalargenumberofshallowmethods.

--- Chunk 148 ---
Tokens: 350
Type: sentence-based
Text:
In addition, if you write code with the expectation that users will read method implementations,youwilltrytomakeeachmethodasshortaspossible,sothat itseasytoread.Ifthemethoddoesanythingnontrivial,youwillbreakitupinto severalsmallermethods.Thiswillresultinalargenumberofshallowmethods. Furthermore, it doesnt really make the code easier to read: in order to understandthebehaviorofthetop-levelmethod,readerswillprobablyneedto understand the behaviors of the nested methods. For large systems it isnt practicalforuserstoreadthecodetolearnthebehavior. Moreover,commentsarefundamentaltoabstractions.RecallfromChapter4 thatthegoalofabstractionsistohidecomplexity:anabstractionisasimplified viewofanentity,whichpreservesessentialinformationbutomitsdetailsthatcan safelybeignored.Ifusersmustreadthecodeofamethodinordertouseit, thenthereisnoabstraction:allofthecomplexityofthemethodisexposed. Without comments, the only abstraction of a method is its declaration, which specifies its name and the names and types of its arguments and results. The declaration is missing too much essential information to provide a useful abstractionbyitself.Forexample,amethodtoextractasubstringmighthavetwo arguments,startandend,indicatingtherangeofcharacterstoextract.Fromthe declaration alone, it isnt possible to tell whether the extracted substring will include the character indicated by end, or what happens if start  end.

--- Chunk 149 ---
Tokens: 399
Type: sentence-based
Text:
The declaration is missing too much essential information to provide a useful abstractionbyitself.Forexample,amethodtoextractasubstringmighthavetwo arguments,startandend,indicatingtherangeofcharacterstoextract.Fromthe declaration alone, it isnt possible to tell whether the extracted substring will include the character indicated by end, or what happens if start  end. Comments allow us to capture the additional information that callers need, therebycompletingthesimplifiedviewwhilehidingimplementationdetails.Its alsoimportantthatcommentsarewritteninahumanlanguagesuchasEnglish; thismakesthemlessprecisethancode,butitprovidesmoreexpressivepower,so wecancreatesimple,intuitivedescriptions.Ifyouwanttouseabstractionsto hidecomplexity,commentsareessential. 12.2Idonthavetimetowritecomments Itstemptingtoprioritizecommentslowerthanotherdevelopmenttasks.Givena choice between adding a new feature and documenting an existing feature, it seemslogicaltochoosethenewfeature.However,softwareprojectsarealmost always under time pressure, and there will always be things that seem higher priority than writing comments. Thus, if you allow documentation to be de- prioritized,youllendupwithnodocumentation. Thecounter-argumenttothisexcuseistheinvestmentmindsetdiscussedon page15.Ifyouwantacleansoftwarestructure,whichwillallowyoutowork efficientlyoverthelong-term,thenyoumusttakesomeextratimeupfrontin order to create that structure. Good comments make a huge difference in the maintainabilityofsoftware,sotheeffortspentonthemwillpayforitselfquickly. Furthermore, writing comments neednt take a lot of time.

--- Chunk 150 ---
Tokens: 370
Type: sentence-based
Text:
Furthermore, writing comments neednt take a lot of time. Ask yourself how much of your development time you spend typing in code (as opposed to designing,compiling,testing,etc. ),assumingyoudontincludeanycomments;I doubtthattheanswerismorethan10.Nowsupposethatyouspendasmuch timetypingcommentsastypingcode;thisshouldbeasafeupperbound.With theseassumptions,writinggoodcommentswontaddmorethanabout10to yourdevelopmenttime.Thebenefitsofhavinggooddocumentationwillquickly offsetthiscost. Furthermore, many of the most important comments are those related to abstractions, such as the top-level documentation for classes and methods. Chapter 15 will argue that these comments should be written as part of the design process, and that the act of writing the documentation serves as an importantdesigntoolthatimprovestheoveralldesign.Thesecommentspayfor themselvesimmediately. 12.3Commentsgetoutofdateandbecomemisleading Commentsdosometimesgetoutofdate,butthisneednotbeamajorproblemin practice.Keepingdocumentationup-to-datedoesnotrequireanenormouseffort. Largechangestothedocumentationareonlyrequirediftherehavebeenlarge changes to the code, and the code changes will take more time than the documentationchanges.Chapter16discusseshowtoorganizedocumentationso thatitisaseasyaspossibletokeepitupdatedaftercodemodifications(thekey ideasaretoavoidduplicateddocumentationandkeepthedocumentationcloseto thecorrespondingcode).Codereviewsprovideagreatmechanismfordetecting andfixingstalecomments.

--- Chunk 151 ---
Tokens: 360
Type: sentence-based
Text:
Largechangestothedocumentationareonlyrequirediftherehavebeenlarge changes to the code, and the code changes will take more time than the documentationchanges.Chapter16discusseshowtoorganizedocumentationso thatitisaseasyaspossibletokeepitupdatedaftercodemodifications(thekey ideasaretoavoidduplicateddocumentationandkeepthedocumentationcloseto thecorrespondingcode).Codereviewsprovideagreatmechanismfordetecting andfixingstalecomments. 12.4AllthecommentsIhaveseenareworthless Ofthefourexcuses,thisisprobablytheonewiththemostmerit.Everysoftware developer has seen comments that provide no useful information, and most existing documentation is so-so at best. Fortunately, this problem is solvable; writingsoliddocumentationisnothard,onceyouknowhow.Thenextchapters willlayoutaframeworkforhowtowritegooddocumentationandmaintainit overtime. 12.5Benefitsofwell-writtencomments Now that I have discussed (and, hopefully, debunked) the arguments against writing comments, lets consider the benefits that you will get from good comments.Theoverallideabehindcommentsistocaptureinformationthat wasinthemindofthedesignerbutcouldntberepresentedinthecode.This information ranges from low-level details, such as a hardware quirk that motivatesaparticularlytrickypieceofcode,uptohigh-levelconceptssuchas the rationale for a class. When other developers come along later to make modifications, the comments will allow them to work more quickly and accurately.

--- Chunk 152 ---
Tokens: 391
Type: sentence-based
Text:
When other developers come along later to make modifications, the comments will allow them to work more quickly and accurately. Without documentation, future developers will have to rederive or guessatthedevelopersoriginalknowledge;thiswilltakeadditionaltime,and there is a risk of bugs if the new developer misunderstands the original designersintentions.Commentsarevaluableevenwhentheoriginaldesigneris theonemakingthechanges:ifithasbeenmorethanafewweekssinceyoulast workedinapieceofcode,youwillhaveforgottenmanyofthedetailsofthe originaldesign. Chapter 2 described three ways in which complexity manifests itself in softwaresystems: Changeamplification:aseeminglysimplechangerequirescode modificationsinmanyplaces. Cognitiveload:inordertomakeachange,thedevelopermustaccumulatea largeamountofinformation. Unknownunknowns:itisunclearwhatcodeneedstobemodified,orwhat informationmustbeconsideredinordertomakethosemodifications. Gooddocumentationhelpswiththelasttwooftheseissues.Documentationcan reducecognitiveloadbyprovidingdeveloperswiththeinformationtheyneedto makechangesandbymakingiteasyfordeveloperstoignoreinformationthatis irrelevant.Withoutadequatedocumentation,developersmayhavetoreadlarge amountsofcodetoreconstructwhatwasinthedesignersmind.Documentation canalsoreducetheunknownunknownsbyclarifyingthestructureofthesystem, sothatitisclearwhatinformationandcodeisrelevantforanygivenchange. Chapter 2 pointed out that the primary causes of complexity are dependenciesandobscurity.Gooddocumentationcanclarifydependencies,and itfillsingapstoeliminateobscurity.

--- Chunk 153 ---
Tokens: 389
Type: sentence-based
Text:
Chapter 2 pointed out that the primary causes of complexity are dependenciesandobscurity.Gooddocumentationcanclarifydependencies,and itfillsingapstoeliminateobscurity. Thenextfewchapterswillshowyouhowtowritegooddocumentation.They willalsodiscusshowtointegratedocumentation-writingintothedesignprocess sothatitimprovesthedesignofyoursoftware. Chapter13 CommentsShouldDescribeThingsthatArent ObviousfromtheCode Thereasonforwritingcommentsisthatstatementsinaprogramminglanguage cant capture all of the important information that was in the mind of the developerwhenthecodewaswritten.Commentsrecordthisinformationsothat developerswhocomealonglatercaneasilyunderstandandmodifythecode.The guidingprincipleforcommentsisthatcommentsshoulddescribethingsthat arentobviousfromthecode. Therearemanythingsthatarentobviousfromthecode.Sometimesitslow- leveldetailsthatarentobvious.Forexample,whenapairofindicesdescribea range,itisntobviouswhethertheelementsgivenbytheindicesareinsidethe range or out. Sometimes its not clear why code is needed, or why it was implemented in a particular way. Sometimes there are rules the developer followed,suchasalwaysinvokeabeforeb.Youmightbeabletoguessatarule bylookingatallofthecode,butthisispainfulanderror-prone;acommentcan maketheruleexplicitandclear. One of the most important reasons for comments is abstractions, which include a lot of information that isnt obvious from the code. The idea of an abstractionistoprovideasimplewayofthinkingaboutsomething,butcodeis sodetailedthatitcanbehardtoseetheabstractionjustfromreadingthecode.

--- Chunk 154 ---
Tokens: 391
Type: sentence-based
Text:
The idea of an abstractionistoprovideasimplewayofthinkingaboutsomething,butcodeis sodetailedthatitcanbehardtoseetheabstractionjustfromreadingthecode. Comments can provide a simpler, higher-level view (after this method is invoked,networktrafficwillbelimitedtomaxBandwidthbytespersecond).Even ifthisinformationcanbededucedbyreadingthecode,wedontwanttoforce usersofamoduletodothat:readingthecodeistime-consumingandforcesthem toconsideralotofinformationthatisntneededtousethemodule.Developers shouldbeabletounderstandtheabstractionprovidedbyamodulewithout readinganycodeotherthanitsexternallyvisibledeclarations.Theonlyway todothisisbysupplementingthedeclarationswithcomments. Thischapterdiscusseswhatinformationneedstobedescribedincomments and how to write good comments. As you will see, good comments typically explainthingsatadifferentlevelofdetailthanthecode,whichismoredetailed insomesituationsandlessdetailed(moreabstract)inothers. 13.1Pickconventions Thefirststepinwritingcommentsistodecideonconventionsforcommenting, suchaswhatyouwillcommentandtheformatyouwilluseforcomments.Ifyou areprogramminginalanguageforwhichthereexistsadocumentcompilation tool,suchasJavadocforJava,DoxygenforC,orgodocforGo,followthe conventions of the tools. None of these conventions is perfect, but the tools provide enough benefits to make up for that. If you are programming in an environmentwheretherearenoexistingconventionstofollow,trytoadoptthe conventionsfromsomeotherlanguageorprojectthatissimilar;thiswillmakeit easierforotherdeveloperstounderstandandadheretoyourconventions.

--- Chunk 155 ---
Tokens: 362
Type: sentence-based
Text:
If you are programming in an environmentwheretherearenoexistingconventionstofollow,trytoadoptthe conventionsfromsomeotherlanguageorprojectthatissimilar;thiswillmakeit easierforotherdeveloperstounderstandandadheretoyourconventions. Conventionsservetwopurposes.First,theyensureconsistency,whichmakes commentseasiertoreadandunderstand.Second,theyhelptoensurethatyou actuallywritecomments.Ifyoudonthaveaclearideawhatyouaregoingto commentandhow,itseasytoendupwritingnocommentsatall. Mostcommentsfallintooneofthefollowingcategories: Interface:acommentblockthatimmediatelyprecedesthedeclarationofa modulesuchasaclass,datastructure,function,ormethod.Thecomment describesthemodulesinterface.Foraclass,thecommentdescribesthe overallabstractionprovidedbytheclass.Foramethodorfunction,the commentdescribesitsoverallbehavior,itsargumentsandreturnvalue,ifany, anysideeffectsorexceptionsthatitgenerates,andanyotherrequirementsthe callermustsatisfybeforeinvokingthemethod. Datastructuremember:acommentnexttothedeclarationofafieldinadata structure,suchasaninstancevariableorstaticvariableforaclass. Implementationcomment:acommentinsidethecodeofamethodor function,whichdescribeshowthecodeworksinternally. Cross-modulecomment:acommentdescribingdependenciesthatcross moduleboundaries. Themostimportantcommentsarethoseinthefirsttwocategories.Everyclass shouldhaveaninterfacecomment,everyclassvariableshouldhaveacomment, and every method should have an interface comment.

--- Chunk 156 ---
Tokens: 371
Type: sentence-based
Text:
Themostimportantcommentsarethoseinthefirsttwocategories.Everyclass shouldhaveaninterfacecomment,everyclassvariableshouldhaveacomment, and every method should have an interface comment. Occasionally, the declarationforavariableormethodissoobviousthatthereisnothingusefulto addinacomment(gettersandsetterssometimesfallinthiscategory),butthisis rare;itiseasiertocommenteverythingratherthanspendenergyworryingabout whetheracommentisneeded.Implementationcommentsareoftenunnecessary (seeSection13.6below).Cross-modulecommentsarethemostrareofalland theyareproblematictowrite,butwhentheyareneededtheyarequiteimportant; Section13.7discussestheminmoredetail. 13.2Dontrepeatthecode Unfortunately,manycommentsarenotparticularlyhelpful.Themostcommon reason is that the comments repeat the code: all of the information in the commentcaneasilybededucedfromthecodenexttothecomment.Hereisa codesamplethatappearedinarecentresearchpaper: ptr_copyget_copy(obj) Getpointercopy ifis_unlocked(ptr_copy): Isobjfree? returnobj returncurrentobj ifis_copy(ptr_copy): Alreadyacopy? returnobj returnobj thread_idget_thread_id(ptr_copy) ifthread_idctx.thread_id: Lockedbycurrentctx returnptr_copy Returncopy ThereisnousefulinformationinanyofthesecommentsexceptfortheLocked by comment, which suggests something about the thread that might not be obviousfromthecode.Noticethatthesecommentsareatroughlythesamelevel ofdetailasthecode:thereisonecommentperlineofcode,whichdescribesthat line.Commentslikethisarerarelyuseful.

--- Chunk 157 ---
Tokens: 386
Type: sentence-based
Text:
returnobj returnobj thread_idget_thread_id(ptr_copy) ifthread_idctx.thread_id: Lockedbycurrentctx returnptr_copy Returncopy ThereisnousefulinformationinanyofthesecommentsexceptfortheLocked by comment, which suggests something about the thread that might not be obviousfromthecode.Noticethatthesecommentsareatroughlythesamelevel ofdetailasthecode:thereisonecommentperlineofcode,whichdescribesthat line.Commentslikethisarerarelyuseful. Herearemoreexamplesofcommentsthatrepeatthecode: Addahorizontalscrollbar hScrollBarnewJScrollBar(JScrollBar.HORIZONTAL); add(hScrollBar,BorderLayout.SOUTH); Addaverticalscrollbar vScrollBarnewJScrollBar(JScrollBar.VERTICAL); add(vScrollBar,BorderLayout.EAST); Initializethecaret-positionrelatedvalues caretX0; caretY0; caretMemXnull; Noneofthesecommentsprovideanyvalue.Forthefirsttwocomments,thecode isalreadyclearenoughthatitdoesntreallyneedcomments;inthethirdcase,a comment might be useful, but the current comment doesnt provide enough detailtobehelpful. Afteryouhavewrittenacomment,askyourselfthefollowingquestion:could someonewhohasneverseenthecodewritethecommentjustbylookingatthe codenexttothecomment?Iftheanswerisyes,asintheexamplesabove,then the comment doesnt make the code any easier to understand. Comments like thesearewhysomepeoplethinkthatcommentsareworthless. Another common mistake is to use the same words in the comment that appearinthenameoftheentitybeingdocumented:  ObtainanormalizedresourcenamefromREQ. privatestaticStringgetNormalizedResourceNames( HTTPRequestreq). DowncastPARAMETERtoTYPE.

--- Chunk 158 ---
Tokens: 365
Type: sentence-based
Text:
DowncastPARAMETERtoTYPE. privatestaticObjectdownCastParameter(Stringparameter,Stringtype) . Thehorizontalpaddingofeachlineinthetext. privatestaticfinalinttextHorizontalPadding4; Thesecommentsjusttakethewordsfromthemethodorvariablename,perhaps addafewwordsfromargumentnamesandtypes,andformthemintoasentence. Forexample,theonlythinginthesecondcommentthatisntinthecodeisthe wordto!Onceagain,thesecommentscouldbewrittenjustbylookingatthe declarations, without any understanding the methods of variables; as a result, theyhavenovalue. RedFlag:CommentRepeatsCode Iftheinformationinacommentisalreadyobviousfromthecodenexttothe comment,thenthecommentisnthelpful.Oneexampleofthisiswhenthe comment uses the same words that make up the name of the thing it is describing. At the same time, there is important information that is missing from the comments:forexample,whatisanormalizedresourcename,andwhatarethe elements of the array returned by getNormalizedResourceNames? What does downcastmean?Whataretheunitsofpadding,andisthepaddingononeside ofeachlineorboth?Describingthesethingsincommentswouldbehelpful. Afirststeptowardswritinggoodcommentsistousedifferentwordsinthe commentfromthoseinthenameoftheentitybeingdescribed.Pickwords forthecommentthatprovideadditionalinformationaboutthemeaningofthe entity,ratherthanjustrepeatingitsname.Forexample,hereisabettercomment fortextHorizontalPadding:  Theamountofblankspacetoleaveontheleftand rightsidesofeachlineoftext,inpixels.

--- Chunk 159 ---
Tokens: 384
Type: sentence-based
Text:
Afirststeptowardswritinggoodcommentsistousedifferentwordsinthe commentfromthoseinthenameoftheentitybeingdescribed.Pickwords forthecommentthatprovideadditionalinformationaboutthemeaningofthe entity,ratherthanjustrepeatingitsname.Forexample,hereisabettercomment fortextHorizontalPadding:  Theamountofblankspacetoleaveontheleftand rightsidesofeachlineoftext,inpixels. privatestaticfinalinttextHorizontalPadding4; This comment provides additional information that is not obvious from the declarationitself,suchastheunits(pixels)andthefactthatpaddingappliesto both sides of each line. Instead of using the term padding, the comment explainswhatpaddingis,incasethereaderisntalreadyfamiliarwiththeterm. 13.3Lower-levelcommentsaddprecision Nowthatyouknowwhatnottodo,letsdiscusswhatinformationyoushouldput in comments. Comments augment the code by providing information at a differentlevelofdetail.Somecommentsprovideinformationatalower,more detailed, level than the code; these comments add precision by clarifying the exact meaning of the code. Other comments provide information at a higher, moreabstract,levelthanthecode;thesecommentsofferintuition,suchasthe reasoningbehindthecode,orasimplerandmoreabstractwayofthinkingabout thecode.Commentsatthesamelevelasthecodearelikelytorepeatthecode. This section discusses the lower-level approach in more detail, and the next sectiondiscussesthehigher-levelapproach. Precision is most useful when commenting variable declarations such as class instance variables, method arguments, and return values.

--- Chunk 160 ---
Tokens: 397
Type: sentence-based
Text:
Precision is most useful when commenting variable declarations such as class instance variables, method arguments, and return values. The name and typeinavariabledeclarationaretypicallynotveryprecise.Commentscanfillin missingdetailssuchas: Whataretheunitsforthisvariable? Aretheboundaryconditionsinclusiveorexclusive? Ifanullvalueispermitted,whatdoesitimply? Ifavariablereferstoaresourcethatmusteventuallybefreedorclosed,who isresponsibleforfreeingorclosingit? Aretherecertainpropertiesthatarealwaystrueforthevariable(invariants), suchasthislistalwayscontainsatleastoneentry? Someofthisinformationcouldpotentiallybefiguredoutbyexaminingallofthe code where the variable is used. However, this is time-consuming and error- prone;thedeclarationscommentshouldbeclearandcompleteenoughtomake thisunnecessary.WhenIsaythatthecommentforadeclarationshoulddescribe thingsthatarentobviousfromthecode,thecodereferstothecodenexttothe comment(thedeclaration),notallofthecodeintheapplication. The most common problem with comments for variables is that the commentsaretoovague.Herearetwoexamplesofcommentsthatarentprecise enough: CurrentoffsetinrespBuffer uint32_toffset; Containsallline-widthsinsidethedocumentand numberofappearances. privateTreeMapInteger,IntegerlineWidths; Inthefirstexample,itsnotclearwhatcurrentmeans.Inthesecondexample, its not clear that the keys in the TreeMap are line widths and values are occurrence counts. Also, are widths measured in pixels or characters? The revisedcommentsbelowprovideadditionaldetails: Positioninthisbufferofthefirstobjectthathasnt beenreturnedtotheclient.

--- Chunk 161 ---
Tokens: 386
Type: sentence-based
Text:
The revisedcommentsbelowprovideadditionaldetails: Positioninthisbufferofthefirstobjectthathasnt beenreturnedtotheclient. uint32_toffset; Holdsstatisticsaboutlinelengthsoftheformlength,count wherelengthisthenumberofcharactersinaline(including thenewline),andcountisthenumberoflineswith exactlythatmanycharacters.Iftherearenolineswith aparticularlength,thenthereisnoentryforthatlength. privateTreeMapInteger,IntegernumLinesWithLength; Theseconddeclarationusesalongernamethatconveysmoreinformation.Italso changeswidthtolength,becausethistermismorelikelytomakepeople think that the units are characters rather than pixels. Notice that the second commentdocumentsnotonlythedetailsofeachentry,butalsowhatitmeansif anentryismissing. Whendocumentingavariable,thinknouns,notverbs.Inotherwords,focus on what the variable represents, not how it is manipulated. Consider the followingcomment: FOLLOWERVARIABLE:indicatorvariablethatallowstheReceiverand the PeriodicTasksthreadtocommunicateaboutwhetheraheartbeathas been receivedwithinthefollowerselectiontimeoutwindow. ToggledtoTRUEwhenavalidheartbeatisreceived. ToggledtoFALSEwhentheelectiontimeoutwindowisreset. privatebooleanreceivedValidHeartbeat; Thisdocumentationdescribeshowthevariableismodifiedbyseveralpiecesof code in the class. The comment will be both shorter and more useful if it describeswhatthevariablerepresentsratherthanmirroringthecodestructure: Truemeansthataheartbeathasbeenreceivedsincethelasttime theelectiontimerwasreset.Usedforcommunicationbetweenthe ReceiverandPeriodicTasksthreads.

--- Chunk 162 ---
Tokens: 390
Type: sentence-based
Text:
The comment will be both shorter and more useful if it describeswhatthevariablerepresentsratherthanmirroringthecodestructure: Truemeansthataheartbeathasbeenreceivedsincethelasttime theelectiontimerwasreset.Usedforcommunicationbetweenthe ReceiverandPeriodicTasksthreads. privatebooleanreceivedValidHeartbeat; Giventhisdocumentation,itseasytoinferthatthevariablemustbesettotrue whenaheartbeatisreceivedandfalsewhentheelectiontimerisreset. 13.4Higher-levelcommentsenhanceintuition Thesecondwayinwhichcommentscanaugmentcodeisbyprovidingintuition. Thesecondwayinwhichcommentscanaugmentcodeisbyprovidingintuition. Thesecommentsarewrittenatahigherlevelthanthecode.Theyomitdetails andhelpthereadertounderstandtheoverallintentandstructureofthecode. Thisapproachiscommonlyusedforcommentsinsidemethods,andforinterface comments.Forexample,considerthefollowingcode: IfthereisaLOADINGreadRpcusingthesamesession asPKHashpointedtobyassignPos,andthelastPKHash inthatreadRPCissmallerthancurrentassigning PKHash,thenweputassigningPKHashintothatreadRPC. intreadActiveRpcIdRPC_ID_NOT_ASSIGNED; for(inti0;iNUM_READ_RPC;i) if(sessionreadRpci.session readRpci.statusLOADING readRpci.maxPosassignPos readRpci.numHashesMAX_PKHASHES_PERRPC) readActiveRpcIdi; break;   Thecommentistoolow-levelanddetailed.Ontheonehand,itpartiallyrepeats the code: if there is a LOADING readRPC just duplicates the test readRpci.statusLOADING.Ontheotherhand,thecommentdoesntexplain theoverallpurposeofthiscode,orhowitfitsintothemethodthatcontainsit.As aresult,thecommentdoesnthelpthereadertounderstandthecode.

--- Chunk 163 ---
Tokens: 372
Type: sentence-based
Text:
intreadActiveRpcIdRPC_ID_NOT_ASSIGNED; for(inti0;iNUM_READ_RPC;i) if(sessionreadRpci.session readRpci.statusLOADING readRpci.maxPosassignPos readRpci.numHashesMAX_PKHASHES_PERRPC) readActiveRpcIdi; break;   Thecommentistoolow-levelanddetailed.Ontheonehand,itpartiallyrepeats the code: if there is a LOADING readRPC just duplicates the test readRpci.statusLOADING.Ontheotherhand,thecommentdoesntexplain theoverallpurposeofthiscode,orhowitfitsintothemethodthatcontainsit.As aresult,thecommentdoesnthelpthereadertounderstandthecode. Hereisabettercomment: Trytoappendthecurrentkeyhashontoanexisting RPCtothedesiredserverthathasntbeensentyet. Thiscommentdoesntcontainanydetails;instead,itdescribesthecodesoverall functionatahigherlevel.Withthishigh-levelinformation,areadercanexplain almosteverythingthathappensinthecode:theloopmustbeiteratingoverallthe existingremoteprocedurecalls(RPCs);thesessiontestisprobablyusedtosee ifaparticularRPCisdestinedfortherightserver;theLOADINGtestsuggeststhat RPCs can have multiple states, and in some states it isnt safe to add more hashes; the MAX - PKHASHES_PERRPC test suggests that there is a limit to how manyhashescanbesentinasingleRPC.Theonlythingnotexplainedbythe commentisthemaxPostest.Furthermore,thenewcommentprovidesabasisfor readerstojudgethecode:doesitdoeverythingthatisneededtoaddthekey hashtoanexistingRPC?Theoriginalcommentdidntdescribetheoverallintent of the code, so its hard for a reader to decide whether the code is behaving correctly.

--- Chunk 164 ---
Tokens: 337
Type: sentence-based
Text:
Thiscommentdoesntcontainanydetails;instead,itdescribesthecodesoverall functionatahigherlevel.Withthishigh-levelinformation,areadercanexplain almosteverythingthathappensinthecode:theloopmustbeiteratingoverallthe existingremoteprocedurecalls(RPCs);thesessiontestisprobablyusedtosee ifaparticularRPCisdestinedfortherightserver;theLOADINGtestsuggeststhat RPCs can have multiple states, and in some states it isnt safe to add more hashes; the MAX - PKHASHES_PERRPC test suggests that there is a limit to how manyhashescanbesentinasingleRPC.Theonlythingnotexplainedbythe commentisthemaxPostest.Furthermore,thenewcommentprovidesabasisfor readerstojudgethecode:doesitdoeverythingthatisneededtoaddthekey hashtoanexistingRPC?Theoriginalcommentdidntdescribetheoverallintent of the code, so its hard for a reader to decide whether the code is behaving correctly. Higher-levelcommentsaremoredifficulttowritethanlower-levelcomments becauseyoumustthinkaboutthecodeinadifferentway.Askyourself:Whatis this code trying to do? What is the simplest thing you can say that explains everythinginthecode?Whatisthemostimportantthingaboutthiscode? Engineerstendtobeverydetail-oriented.Welovedetailsandaregoodat managing lots of them; this is essential for being a good engineer. But, great softwaredesignerscanalsostepbackfromthedetailsandthinkaboutasystem at a higher level.

--- Chunk 165 ---
Tokens: 389
Type: sentence-based
Text:
But, great softwaredesignerscanalsostepbackfromthedetailsandthinkaboutasystem at a higher level. This means deciding which aspects of the system are most important, and being able to ignore the low-level details and think about the systemonlyintermsofitsmostfundamentalcharacteristics.Thisistheessence ofabstraction(findingasimplewaytothinkaboutacomplexentity),andits alsowhatyoumustdowhenwritinghigher-levelcomments.Agoodhigher-level comment expresses one or a few simple ideas that provide a conceptual framework, such as append to an existing RPC. Given the framework, it becomeseasytoseehowspecificcodestatementsrelatetotheoverallgoal. Hereisanothercodesample,whichhasagoodhigher-levelcomment: if(numProcessedPKHashesreadRpci.numHashes) Someofthekeyhashescouldntbelookedupin thisrequest(eitherbecausetheyarentstored ontheserver,theservercrashed,orthere wasntenoughspaceintheresponsemessage). Marktheunprocessedhashessotheywillget reassignedtonewRPCs. for(size_tpremovePos;pinsertPos;p) if(activeRpcIdpi) if(numProcessedPKHashes0) numProcessedPKHashes--; else if(passignPos) assignPosp; activeRpcIdpRPC_ID_NOT_ASSIGNED;     This comment does two things. The second sentence provides an abstract descriptionofwhatthecodedoes.Thefirstsentenceisdifferent:itexplains(in highlevelterms)whythecodeisexecuted.Commentsoftheformhowweget hereareveryusefulforhelpingpeopletounderstandcode.Forexample,when documentingamethod,itcanbeveryhelpfultodescribetheconditionsunder whichthemethodismostlikelytobeinvoked(especiallyifthemethodisonly invokedinunusualsituations).

--- Chunk 166 ---
Tokens: 285
Type: sentence-based
Text:
The second sentence provides an abstract descriptionofwhatthecodedoes.Thefirstsentenceisdifferent:itexplains(in highlevelterms)whythecodeisexecuted.Commentsoftheformhowweget hereareveryusefulforhelpingpeopletounderstandcode.Forexample,when documentingamethod,itcanbeveryhelpfultodescribetheconditionsunder whichthemethodismostlikelytobeinvoked(especiallyifthemethodisonly invokedinunusualsituations). 13.5Interfacedocumentation Oneofthemostimportantrolesforcommentsistodefineabstractions.Recall from Chapter 4 that an abstraction is a simplified view of an entity, which preservesessentialinformationbutomitsdetailsthatcansafelybeignored.Code isnt suitable for describing abstractions; its too low level and it includes implementationdetailsthatshouldntbevisibleintheabstraction.Theonlyway todescribeanabstractioniswithcomments.Ifyouwantcodethatpresents goodabstractions,youmustdocumentthoseabstractionswithcomments. Thefirststepindocumentingabstractionsistoseparateinterfacecomments from implementation comments. Interface comments provide information that someone needs to know in order to use a class or method; they define the abstraction.

--- Chunk 167 ---
Tokens: 351
Type: sentence-based
Text:
Interface comments provide information that someone needs to know in order to use a class or method; they define the abstraction. Implementation comments describe how a class or method works internallyinordertoimplementtheabstraction.Itsimportanttoseparatethese two kinds of comments, so that users of an interface are not exposed to implementationdetails.Furthermore,thesetwoformshadbetterbedifferent.If interfacecommentsmustalsodescribetheimplementation,thentheclassor methodisshallow.This meansthatthe act of writingcommentscan provide cluesaboutthequalityofadesign;Chapter15willreturntothisidea. Theinterfacecommentforaclassprovidesahigh-leveldescriptionofthe abstractionprovidedbytheclass,suchasthefollowing:  Thisclassimplementsasimpleserver-sideinterfacetotheHTTP protocol:byusingthisclass,anapplicationcanreceiveHTTP requests,processthem,andreturnresponses.Eachinstanceof thisclasscorrespondstoaparticularsocketusedtoreceive requests.Thecurrentimplementationissingle-threadedand processesonerequestatatime. publicclassHttp. This comment describes the overall capabilities of the class, without any implementation details or even the specifics of particular methods. It also describes what each instance of the class represents. Finally, the comments describethelimitationsoftheclass(itdoesnotsupportconcurrentaccessfrom multiplethreads),whichmaybeimportanttodeveloperscontemplatingwhether touseit.

--- Chunk 168 ---
Tokens: 384
Type: sentence-based
Text:
Finally, the comments describethelimitationsoftheclass(itdoesnotsupportconcurrentaccessfrom multiplethreads),whichmaybeimportanttodeveloperscontemplatingwhether touseit. Theinterfacecommentforamethodincludesbothhigher-levelinformation forabstractionandlower-leveldetailsforprecision: Thecommentusuallystartswithasentenceortwodescribingthebehavior ofthemethodasperceivedbycallers;thisisthehigher-levelabstraction. Thecommentmustdescribeeachargumentandthereturnvalue(ifany). Thesecommentsmustbeveryprecise,andmustdescribeanyconstraintson argumentvaluesaswellasdependenciesbetweenarguments. Ifthemethodhasanysideeffects,thesemustbedocumentedinthe interfacecomment.Asideeffectisanyconsequenceofthemethodthat affectsthefuturebehaviorofthesystembutisnotpartoftheresult.For example,ifthemethodaddsavaluetoaninternaldatastructure,whichcan beretrievedbyfuturemethodcalls,thisisasideeffect;writingtothefile systemisalsoasideeffect. Amethodsinterfacecommentmustdescribeanyexceptionsthatcan emanatefromthemethod. Ifthereareanypreconditionsthatmustbesatisfiedbeforeamethodis invoked,thesemustbedescribed(perhapssomeothermethodmustbe invokedfirst;forabinarysearchmethod,thelistbeingsearchedmustbe sorted).Itisagoodideatominimizepreconditions,butanythatremain mustbedocumented. HereistheinterfacecommentforamethodthatcopiesdataoutofaBuffer object:  Copyarangeofbytesfromabuffertoanexternallocation. paramoffset Indexwithinthebufferofthefirstbytetocopy. paramlength Numberofbytestocopy. paramdest Wheretocopythebytes:musthaveroomforatleast lengthbytes.

--- Chunk 169 ---
Tokens: 384
Type: sentence-based
Text:
paramdest Wheretocopythebytes:musthaveroomforatleast lengthbytes. return Thereturnvalueistheactualnumberofbytescopied, whichmaybelessthanlengthiftherequestedrangeof bytesextendspasttheendofthebuffer.0isreturned ifthereisnooverlapbetweentherequestedrangeand theactualbuffer. uint32_t Buffer:copy(uint32_toffset,uint32_tlength,voiddest) . Thesyntaxofthiscomment(e.g,return)followstheconventionsofDoxygen, aprogramthatextractscommentsfromCCcodeandcompilesthemintoWeb pages. The goal of the comment is to provide all the information a developer needsinordertoinvokethemethod,includinghowspecialcasesarehandled (note how this method follows the advice of Chapter 10 and defines out of existence any errors associated with the range specification). The developer shouldnotneedtoreadthebodyofthemethodinordertoinvokeit,andthe interface comment provides no information about how the method is implemented,suchashowitscansitsinternaldatastructurestofindthedesired data. For a more extended example, lets consider a class called IndexLookup, which is part of a distributed storage system. The storage system holds a collectionoftables,eachofwhichcontainsmanyobjects.Inaddition,eachtable canhaveoneormoreindexes;eachindexprovidesefficientaccesstoobjectsin thetablebasedonaparticularfieldoftheobject.Forexample,oneindexmight beusedtolookupobjectsbasedontheirnamefield,andanotherindexmightbe usedtolookupobjectsbasedontheiragefield.Withtheseindexes,applications canquicklyextractalloftheobjectswithaparticularname,orallofthosewith anageinagivenrange.

--- Chunk 170 ---
Tokens: 318
Type: sentence-based
Text:
The storage system holds a collectionoftables,eachofwhichcontainsmanyobjects.Inaddition,eachtable canhaveoneormoreindexes;eachindexprovidesefficientaccesstoobjectsin thetablebasedonaparticularfieldoftheobject.Forexample,oneindexmight beusedtolookupobjectsbasedontheirnamefield,andanotherindexmightbe usedtolookupobjectsbasedontheiragefield.Withtheseindexes,applications canquicklyextractalloftheobjectswithaparticularname,orallofthosewith anageinagivenrange. The IndexLookup class provides a convenient interface for performing indexedlookups.Hereisanexampleofhowitmightbeusedinanapplication: querynewIndexLookup(table,index,key1,key2); while(true) objectquery.getNext(); if(objectNULL) break;  .processobject. The application first constructs an object of type IndexLookup, providing arguments that select a table, an index, and a range within the index (for example,iftheindexisbasedonanagefield,key1andkey2mightbespecified as 21 and 65 to select all objects with ages between those values). Then the application calls the getNext method repeatedly. Each invocation returns one objectthatfallswithinthedesiredrange;onceallofthematchingobjectshave beenreturned,getNextreturns NULL.Becausethestoragesystemisdistributed, the implementation of this class is somewhat complex.

--- Chunk 171 ---
Tokens: 316
Type: sentence-based
Text:
Each invocation returns one objectthatfallswithinthedesiredrange;onceallofthematchingobjectshave beenreturned,getNextreturns NULL.Becausethestoragesystemisdistributed, the implementation of this class is somewhat complex. The objects in a table maybespreadacrossmultipleservers,andeachindexmayalsobedistributed across a different set of servers; the code in the IndexLookup class must first communicatewithalloftherelevantindexserverstocollectinformationabout theobjectsintherange,thenitmustcommunicatewiththeserversthatactually storetheobjectsinordertoretrievetheirvalues. Now lets consider what information needs to be included in the interface commentforthisclass.Foreachpieceofinformationgivenbelow,askyourself whetheradeveloperneedstoknowthatinformationinordertousetheclass(my answerstothequestionsareattheendofthechapter): 1. The format of messages that the IndexLookup class sends to the servers holdingindexesandobjects. 2. The comparison function used to determine whether a particular object fallsinthedesiredrange(iscomparisondoneusingintegers,floating-point numbers,orstrings?). 3. Thedatastructureusedtostoreindexesonservers. 4. Whetherornot IndexLookup issuesmultiplerequests to differentservers concurrently. 5. Themechanismforhandlingservercrashes.

--- Chunk 172 ---
Tokens: 336
Type: sentence-based
Text:
Themechanismforhandlingservercrashes. Here is the original version of the interface comment for the IndexLookup class;theexcerptalsoincludesafewlinesfromtheclasssdefinition,whichare referredtointhecomment:  Thisclassimplementstheclientsideframeworkforindexrange lookups.ItmanagesasingleLookupIndexKeysRPCandmultiple IndexedReadRPCs.ClientsidejustincludesIndexLookup.hin itsheadertouseIndexLookupclass.Severalparameterscanbeset intheconfigbelow: -ThenumberofconcurrentindexedReadRPCs -ThemaxnumberofPKHashesaindexedReadRPCcanholdatatime -ThesizeoftheactivePKHashes  TouseIndexLookup,theclientcreatesanobjectofthisclassby providingallnecessaryinformation.Afterconstructionof IndexLookup,clientcancallgetNext()functiontomovetonext availableobject.IfgetNext()returnsNULL,itmeanswereached thelastobject.ClientcanusegetKey,getKeyLength,getValue, andgetValueLengthtogetobjectdataofcurrentobject. classIndexLookup . private: MaxnumberofconcurrentindexedReadRPCs staticconstuint8_tNUM_READ_RPC10; MaxnumberofPKHashesthatcanbesentinone indexedReadRPC staticconstuint32_tMAX_PKHASHES_PERRPC256; MaxnumberofPKHashesthatactiveHashescan holdatonce. staticconstsize_tMAX_NUM_PK(1LG_BUFFER_SIZE);  Beforereadingfurther,seeifyoucanidentifytheproblemswiththiscomment. HerearetheproblemsthatIfound: Mostofthefirstparagraphconcernstheimplementation,nottheinterface.

--- Chunk 173 ---
Tokens: 352
Type: sentence-based
Text:
HerearetheproblemsthatIfound: Mostofthefirstparagraphconcernstheimplementation,nottheinterface. Asoneexample,usersdontneedtoknowthenamesoftheparticular remoteprocedurecallsusedtocommunicatewiththeservers.The configurationparametersreferredtointhesecondhalfofthefirstparagraph areallprivatevariablesthatarerelevantonlytothemaintaineroftheclass, nottoitsusers.Allofthisimplementationinformationshouldbeomitted fromthecomment. Thecommentalsoincludesseveralthingsthatareobvious.Forexample, theresnoneedtotelluserstoincludeIndexLookup.h:anyonewhowrites Ccodewillbeabletoguessthatthisisnecessary.Inaddition,thetext byprovidingallnecessaryinformationsaysnothing,soitcanbeomitted. Ashortercommentforthisclassissufficient(andpreferable):  Thisclassisusedbyclientapplicationstomakerangequeries usingindexes.Eachinstancerepresentsasinglerangequery. Tostartarangequery,aclientcreatesaninstanceofthis class.TheclientcanthencallgetNext()toretrievetheobjects inthedesiredrange.ForeachobjectreturnedbygetNext(),the callercaninvokegetKey(),getKeyLength(),getValue(),and getValueLength()togetinformationaboutthatobject. The last paragraph of this comment is not strictly necessary, since it mostly duplicatesinformationinthecommentsforindividualmethods.However,itcan be helpful to have examples in the class documentation that illustrate how its methodsworktogether,particularlyfordeepclasseswithusagepatternsthatare nonobvious.

--- Chunk 174 ---
Tokens: 382
Type: sentence-based
Text:
The last paragraph of this comment is not strictly necessary, since it mostly duplicatesinformationinthecommentsforindividualmethods.However,itcan be helpful to have examples in the class documentation that illustrate how its methodsworktogether,particularlyfordeepclasseswithusagepatternsthatare nonobvious. Notethat the new comment does not mention NULL return values fromgetNext.Thiscommentisnotintendedtodocumenteverydetailofeach method;itjustprovideshighlevelinformationtohelpreadersunderstandhow themethodsworktogetherandwheneachmethodmightbeinvoked.Fordetails, readers can refer to the interface comments for individual methods. This commentalsodoesnotmentionservercrashes;thatisbecauseservercrashesare invisibletousersofthisclass(thesystemautomaticallyrecoversfromthem). RedFlag:ImplementationDocumentation ContaminatesInterface Thisredflagoccurswheninterfacedocumentation,suchasthatforamethod, describesimplementationdetailsthatarentneededinordertousethething beingdocumented. Now consider the following code, which shows the first version of the documentationfortheisReadymethodinIndexLookup:  CheckifthenextobjectisRESULT_READY.Thisfunctionis implementedinaDCFTmodule,eachexecutionofisReady()tries tomakesmallprogress,andgetNext()invokesisReady()ina whileloop,untilisReady()returnstrue. isReady()isimplementedinarule-basedapproach.Wecheck differentrulesbyfollowingaparticularorder,andperform certainactionsifsomeruleissatisfied. return TruemeansthenextObjectisavailable.Otherwise,return false. boolIndexLookup:isReady().

--- Chunk 175 ---
Tokens: 376
Type: sentence-based
Text:
boolIndexLookup:isReady(). Onceagain,mostofthisdocumentation,suchasthereferencetoDCFTandthe entiresecondparagraph,concernstheimplementation,soitdoesntbelonghere; this is one of the most common errors in interface comments. Some of the implementation documentation is useful, but it should go inside the method, whereitwillbeclearlyseparatedfrominterfacedocumentation.Inaddition,the firstsentenceofthedocumentationiscryptic(whatdoesRESULT_READYmean?) andsomeimportantinformationismissing.Finally,itisntnecessarytodescribe theimplementationofgetNexthere.Hereisabetterversionofthecomment:  Indicateswhetheranindexedreadhasmadeenoughprogressfor getNexttoreturnimmediatelywithoutblocking.Inaddition,this methoddoesmostoftherealworkforindexedreads,soitmust beinvoked(eitherdirectly,orindirectlybycallinggetNext)in orderfortheindexedreadtomakeprogress. return TruemeansthatthenextinvocationofgetNextwillnotblock (atleastoneobjectisavailabletoreturn,ortheendof the lookuphasbeenreached);falsemeansgetNextmayblock. This version of the comment provides more precise information about what readymeans,anditprovidestheimportantinformationthatthismethodmust eventuallybeinvokediftheindexedretrievalistomoveforward. 13.6Implementationcomments:whatandwhy,nothow Implementationcommentsarethecommentsthatappearinsidemethodstohelp readers understand how they work internally. Most methods are so short and simplethattheydontneedanyimplementationcomments:giventhecodeand theinterfacecomments,itseasytofigureouthowamethodworks.

--- Chunk 176 ---
Tokens: 364
Type: sentence-based
Text:
Most methods are so short and simplethattheydontneedanyimplementationcomments:giventhecodeand theinterfacecomments,itseasytofigureouthowamethodworks. The main goal of implementation comments is to help readers understandwhatthe code is doing (not how it does it). Once readers know whatthecodeistryingtodo,itsusuallyeasytounderstandhowthecodeworks. Forshortmethods,thecodeonlydoesonething,whichisalreadydescribedin its interface comment, so no implementation comments are needed. Longer methods have several blocks of code that do different things as part of the methodsoveralltask.Addacommentbeforeeachofthemajorblockstoprovide a high-level (more abstract) description of what that block does. Here is an example: Phase1:ScanactiveRPCstoseeifanyhavecompleted. Forloops,itshelpful tohave a comment before the loopthat describes what Forloops,itshelpful tohave a commentbeforetheloop thatdescribeswhat happensineachiteration: Eachiterationofthefollowingloopextractsonerequestfrom therequestmessage,incrementsthecorrespondingobject,and appendsaresponsetotheresponsemessage. Notice how this comment describes the loop at a more abstract and intuitive level; it doesnt go into any details about how a request is extracted from the request message or how the object is incremented. Loop comments are only neededforlongerormorecomplexloops,whereitmaynotbeobviouswhatthe loop is doing; many loops are short and simple enough that their behavior is alreadyobvious.

--- Chunk 177 ---
Tokens: 379
Type: sentence-based
Text:
Loop comments are only neededforlongerormorecomplexloops,whereitmaynotbeobviouswhatthe loop is doing; many loops are short and simple enough that their behavior is alreadyobvious. Inadditiontodescribingwhatthecodeisdoing,implementationcomments arealsousefultoexplainwhy.Iftherearetrickyaspectstothecodethatwontbe obviousfromreadingit,youshoulddocumentthem.Forexample,ifabugfix requirestheadditionofcodewhosepurposeisnttotallyobvious,addacomment describingwhythecodeisneeded.Forbugfixeswherethereisawell-written bugreportdescribingtheproblem,thecommentcanrefertotheissueinthebug trackingdatabaseratherthanrepeatingallitsdetails(FixesRAM-436,related to device driver crashes in Linux 2.4.x). Developers can look in the bug database for more details (this is an example of avoiding duplication in comments,whichwillbediscussedinChapter16). Forlongermethods,itcanbehelpfultowritecommentsforafewofthemost important local variables. However, most local variables dont need documentationiftheyhavegoodnames.Ifalloftheusesofavariablearevisible withinafewlinesofeach other, its usuallyeasytounderstandthevariables purposewithoutacomment.InthiscaseitsOKtoletreadersreadthecodeto figureoutthemeaningofthevariable.However,ifthevariableisusedovera largespanofcode,thenyoushouldconsideraddingacommenttodescribethe variable.Whendocumentingvariables,focusonwhatthevariablerepresents,not howitismanipulatedinthecode. 13.7Cross-moduledesigndecisions Inaperfectworld,everyimportantdesigndecisionwouldbeencapsulatedwithin a single class.

--- Chunk 178 ---
Tokens: 396
Type: sentence-based
Text:
13.7Cross-moduledesigndecisions Inaperfectworld,everyimportantdesigndecisionwouldbeencapsulatedwithin a single class. Unfortunately, real systems inevitably end up with design decisions that affect multiple classes. For example, the design of a network protocol will affect both the sender and the receiver, and these may be implementedindifferentplaces.Cross-moduledecisionsareoftencomplexand subtle, and they account for many bugs, so good documentation for them is crucial. Thebiggestchallengewithcross-moduledocumentationisfindingaplaceto putitwhereitwillnaturallybediscoveredbydevelopers.Sometimesthereisan obviouscentralplacetoputsuchdocumentation.Forexample,theRAMCloud storage system defines a Status value, which is returned by each request to indicatesuccessorfailure.Addinga Statusforanewerrorconditionrequires modifying many different files (one file maps Status values to exceptions, another provides a human-readable message for each Status, and so on). Fortunately,thereisoneobviousplacewheredeveloperswillhavetogowhen addinganewstatusvalue,whichisthedeclarationoftheStatusenum.Wetook advantageofthisbyaddingcommentsinthatenumtoidentifyalloftheother placesthatmustalsobemodified: typedefenumStatus STATUS_OK0, STATUS_UNKNOWN_TABLET1, STATUS_WRONG_VERSION2, . STATUS_INDEX_DOESNT_EXIST29, STATUS_INVALID_PARAMETER30, STATUS_MAX_VALUE30, Note:ifyouaddanewstatusvalueyoumustmakethefollowing additionalupdates: (1)ModifySTATUS_MAX_VALUEtohaveavalueequaltothe largestdefinedstatusvalue,andmakesureitsdefinition isthelastoneinthelist.STATUS_MAX_VALUEisused primarilyfortesting.

--- Chunk 179 ---
Tokens: 384
Type: sentence-based
Text:
STATUS_INDEX_DOESNT_EXIST29, STATUS_INVALID_PARAMETER30, STATUS_MAX_VALUE30, Note:ifyouaddanewstatusvalueyoumustmakethefollowing additionalupdates: (1)ModifySTATUS_MAX_VALUEtohaveavalueequaltothe largestdefinedstatusvalue,andmakesureitsdefinition isthelastoneinthelist.STATUS_MAX_VALUEisused primarilyfortesting. (2)Addnewentriesinthetablesmessagesandsymbolsin Status.cc. (3)AddanewexceptionclasstoClientException.h (4)AddanewcasetoClientException:throwExceptiontomap fromthestatusvaluetoastatus-specificClientException subclass. (5)IntheJavabindings,addastaticclassfortheexception toClientException.java (6)Addacaseforthestatusoftheexceptiontothrowthe exceptioninClientException.java (7)AddtheexceptiontotheStatusenuminStatus.java,making surethestatusisinthecorrectpositioncorrespondingto itsstatuscode. Newstatusvalueswillbeaddedattheendoftheexistinglist,sothecomments arealsoplacedattheend,wheretheyaremostlikelytobeseen. Unfortunately, in many cases there is not an obvious central place to put cross-moduledocumentation.OneexamplefromtheRAMCloudstoragesystem wasthecodefordealingwithzombieservers,whichareserversthatthesystem believeshavecrashed,butinfactarestillrunning.Neutralizingzombieservers requiredcodeinseveraldifferentmodules,andthesepiecesofcodealldepend on each other. None of the pieces of code is an obvious central place to put documentation.Onepossibilityistoduplicatepartsofthedocumentationineach locationthatdependsonit.However,thisisawkward,anditisdifficulttokeep such documentation up to date as the system evolves.

--- Chunk 180 ---
Tokens: 373
Type: sentence-based
Text:
None of the pieces of code is an obvious central place to put documentation.Onepossibilityistoduplicatepartsofthedocumentationineach locationthatdependsonit.However,thisisawkward,anditisdifficulttokeep such documentation up to date as the system evolves. Alternatively, the documentationcanbelocatedinoneoftheplaceswhereitisneeded,butinthis caseitsunlikelythatdeveloperswillseethedocumentationorknowwhereto lookforit. I have recently been experimenting with an approach where cross-module issuesaredocumentedinacentralfilecalleddesignNotes.Thefileisdividedup intoclearlylabeledsections,oneforeachmajortopic.Forexample,hereisan excerptfromthefile: . Zombies ------- Azombieisaserverthatisconsidereddeadbytherestofthe cluster;anydatastoredontheserverhasbeenrecoveredandwill bemanagedbyotherservers.However,ifazombieisnotactually dead(e.g,itwasjustdisconnectedfromtheotherserversfora while)twoformsofinconsistencycanarise: Azombieservermustnotservereadrequestsoncereplacementservers havetakenover;otherwiseitmayreturnstaledatathatdoesnot reflectwritesacceptedbythereplacementservers. Thezombieservermustnotacceptwriterequestsoncereplacement servershavebegunreplayingitslogduringrecovery;ifitdoes, thesewritesmaybelost(thenewvaluesmaynotbestoredonthe replacementserversandthuswillnotbereturnedbyreads). RAMCloudusestwotechniquestoneutralizezombies.First, . Then, in any piece of code that relates to one of these issues there is a short commentreferringtothedesignNotesfile: SeeZombiesindesignNotes.

--- Chunk 181 ---
Tokens: 400
Type: sentence-based
Text:
Then, in any piece of code that relates to one of these issues there is a short commentreferringtothedesignNotesfile: SeeZombiesindesignNotes. Withthisapproach,thereisonlyasinglecopyofthedocumentationanditis relativelyeasyfordeveloperstofinditwhentheyneedit.However,thishasthe disadvantagethatthedocumentationisnotnearanyofthepiecesofcodethat dependonit,soitmaybedifficulttokeepup-to-dateasthesystemevolves. 13.8Conclusion Thegoalofcommentsistoensurethatthestructureandbehaviorofthesystem is obvious to readers, so they can quickly find the information they need and makemodificationstothesystemwithconfidencethattheywillwork.Someof this information can be represented in the code in a way that will already be obvious to readers, but there is a significant amount of information that cant easilybededucedfromthecode.Commentsfillinthisinformation. When following the rule that comments should describe things that arent obviousfromthecode,obviousisfromtheperspectiveofsomeonereading your code for the first time (not you). When writing comments, try to put yourselfinthemindsetofthereaderandaskyourselfwhatarethekeythingshe orshewillneedtoknow.Ifyourcodeisundergoingreviewandareviewertells youthatsomethingisnotobvious,dontarguewiththem;ifareaderthinksits notobvious,thenitsnotobvious.Insteadofarguing,trytounderstandwhatthey foundconfusingandseeifyoucanclarifythat,eitherwithbettercommentsor bettercode. 13.9AnswerstoquestionsfromSection13.5 Doesadeveloperneedtoknoweachofthefollowingpiecesofinformationin Doesadeveloperneedtoknoweachofthefollowingpiecesofinformationin ordertousetheIndexLookupclass?

--- Chunk 182 ---
Tokens: 351
Type: sentence-based
Text:
13.9AnswerstoquestionsfromSection13.5 Doesadeveloperneedtoknoweachofthefollowingpiecesofinformationin Doesadeveloperneedtoknoweachofthefollowingpiecesofinformationin ordertousetheIndexLookupclass? 1. TheformatofmessagesthattheIndexLookupclasssendstotheservers holding indexes and objects. No: this is an implementation detail that shouldbehiddenwithintheclass. 2. The comparison function used to determine whether a particular object falls in the desired range (is comparison done using integers, floating- point numbers, or strings?). Yes: users of the class need to know this information. 3. Thedatastructureusedtostoreindexesonservers.No:thisinformation should be encapsulated on the servers; not even the implementation of IndexLookupshouldneedtoknowthis. 4. WhetherornotIndexLookupissuesmultiplerequeststodifferentservers concurrently.Possibly:ifIndexLookupusesspecialtechniquestoimprove performance, then the documentation should provide some high-level informationaboutthis,sinceusersmaycareaboutperformance. 5. The mechanism for handling server crashes. No: RAMCloud recovers automaticallyfromservercrashes,socrashesarenotvisibletoapplication- levelsoftware;thus,thereisnoneedtomentioncrashesintheinterface documentation for IndexLookup. If crashes were reflected up to applications,thentheinterfacedocumentationwouldneedtodescribehow theymanifestthemselves(butnotthedetailsofhowcrashrecoveryworks).

--- Chunk 183 ---
Tokens: 257
Type: sentence-based
Text:
If crashes were reflected up to applications,thentheinterfacedocumentationwouldneedtodescribehow theymanifestthemselves(butnotthedetailsofhowcrashrecoveryworks). Chapter14 ChoosingNames Selecting names for variables, methods, and other entities is one of the most underratedaspectsofsoftwaredesign.Goodnamesareaformofdocumentation: they make code easier to understand. They reduce the need for other documentation and make it easier to detect errors. Conversely, poor name choices increase the complexity of code and create ambiguities and misunderstandings that can result in bugs. Name choice is an example of the principle that complexity is incremental. Choosing a mediocre name for a particularvariable,asopposedtothebestpossiblename,probablywonthave muchimpactontheoverallcomplexityofasystem.However,softwaresystems havethousandsofvariables;choosinggoodnamesforallofthesewillhavea significantimpactoncomplexityandmanageability. 14.1Example:badnamescausebugs Sometimesevenasinglepoorlynamedvariablecanhavesevereconsequences.

--- Chunk 184 ---
Tokens: 360
Type: sentence-based
Text:
14.1Example:badnamescausebugs Sometimesevenasinglepoorlynamedvariablecanhavesevereconsequences. The most challenging bug I ever fixed came about because of a poor name choice.Inthelate1980sandearly1990smygraduatestudentsandIcreateda distributedoperatingsystemcalledSprite.Atsomepointwenoticedthatfiles wouldoccasionallylosedata:oneofthedatablockssuddenlybecameallzeroes, eventhoughthefilehadnotbeenmodifiedbyauser.Theproblemdidnthappen veryoften,soitwasexceptionallydifficulttotrackdown.Afewofthegraduate students tried to find the bug, but they were unable to make progress and eventuallygaveup.However,Iconsideranyunsolvedbugtobeanintolerable personalinsult,soIdecidedtotrackitdown. Ittooksixmonths,butIeventuallyfoundandfixedthebug.Theproblem wasactuallyquitesimple(asaremostbugs,onceyoufigurethemout).Thefile systemcodeusedthevariablename blockfortwodifferentpurposes.Insome situations,blockreferredtoaphysicalblocknumberondisk;inothersituations, blockreferredtoalogicalblocknumberwithinafile.Unfortunately,atonepoint inthecodetherewasablockvariablecontainingalogicalblocknumber,butit wasaccidentallyusedinacontextwhereaphysicalblocknumberwasneeded;as aresult,anunrelatedblockondiskgotoverwrittenwithzeroes. Whiletrackingdownthebug,severalpeople,includingmyself,readoverthe faultycode,butwenevernoticedtheproblem.Whenwesawthevariableblock used as a physical block number, we reflexively assumed that it really held a physical block number.

--- Chunk 185 ---
Tokens: 369
Type: sentence-based
Text:
Whiletrackingdownthebug,severalpeople,includingmyself,readoverthe faultycode,butwenevernoticedtheproblem.Whenwesawthevariableblock used as a physical block number, we reflexively assumed that it really held a physical block number. It took a long process of instrumentation, which eventually showed that the corruption must be happening in a particular statement,beforeIwasabletogetpastthementalblockcreatedbythenameand checktoseeexactlywhereitsvaluecamefrom.Ifdifferentvariablenameshad beenusedforthedifferentkindsofblocks,suchasfileBlockanddiskBlock,its unlikelythattheerrorwouldhavehappened;theprogrammerwouldhaveknown thatfileBlockcouldntbeusedinthatsituation. Unfortunately,mostdevelopersdontspendmuchtimethinkingaboutnames. Theytendtousethefirstnamethatcomestomind,aslongasitsreasonably closetomatchingthethingitnames.Forexample,blockisaprettyclosematch forbothaphysicalblockondiskandalogicalblockwithinafile;itscertainly notahorriblename.Evenso,itresultedinahugeexpenditureoftimetotrack downasubtlebug.Thus,youshouldntsettlefornamesthatarejustreasonably close. Take a bit of extra time to choose great names, which are precise, unambiguous,andintuitive.Theextraattentionwillpayforitselfquickly,and overtimeyoulllearntochoosegoodnamesquickly. 14.2Createanimage Whenchoosinganame,thegoalistocreateanimageinthemindofthereader about the nature of the thing being named. A good name conveys a lot of informationaboutwhattheunderlyingentityis,and,justasimportant,whatitis not.

--- Chunk 186 ---
Tokens: 318
Type: sentence-based
Text:
A good name conveys a lot of informationaboutwhattheunderlyingentityis,and,justasimportant,whatitis not. When considering a particular name, ask yourself: If someone sees this nameinisolation,withoutseeingitsdeclaration,itsdocumentation,oranycode thatusesthename,howcloselywilltheybeabletoguesswhatthenamerefers to?Istheresomeothernamethatwillpaintaclearerpicture?Ofcourse,thereis alimittohowmuchinformationyoucanputinasinglename;namesbecome unwieldyiftheycontainmorethantwoorthreewords.Thus,thechallengeisto findjustafewwordsthatcapturethemostimportantaspectsoftheentity. Namesareaformofabstraction:theyprovideasimplifiedwayofthinking aboutamorecomplexunderlyingentity.Likeotherformsofabstraction,thebest names are those that focus attention on what is most important about the underlyingentitywhileomittingdetailsthatarelessimportant. 14.3Namesshouldbeprecise Good names have two properties: precision and consistency. Lets start with precision.Themostcommonproblemwithnamesisthattheyaretoogenericor vague;asaresult,itshardforreaderstotellwhatthenamerefersto;thereader mayassumethatthenamereferstosomethingdifferentfromreality,asinthe blockbugabove.Considerthefollowingmethoddeclaration:  Returnsthetotalnumberofindexletsthisobjectismanaging. intIndexletManager:getCount().

--- Chunk 187 ---
Tokens: 392
Type: sentence-based
Text:
intIndexletManager:getCount(). Thetermcountistoogeneric:countofwhat?Ifsomeoneseesaninvocationof this method, they are unlikely to know what it does unless they read its documentation.AmoreprecisenamelikegetActiveIndexletsornumIndexlets wouldbebetter:withoneofthesenames,readerswillprobablybeabletoguess whatthemethodreturnswithouthavingtolookatitsdocumentation. Here are some other examples of names that arent precise enough, taken fromvariousstudentprojects: AprojectbuildingaGUItexteditorusedthenamesxandytorefertothe positionofacharacterinthefile.Thesenamesaretoogeneric.Theycould meanmanythings;forexample,theymightalsorepresentthecoordinates (inpixels)ofacharacteronthescreen.Someoneseeingthenamexin isolationisunlikelytothinkthatitreferstothepositionofacharacter withinalineoftext.Thecodewouldbeclearerifitusednamessuchas charIndexandlineIndex,whichreflectthespecificabstractionsthatthe codeimplements. Anothereditorprojectcontainedthefollowingcode: Blinkstate:truewhencursorvisible. privatebooleanblinkStatustrue; The name blinkStatus doesnt convey enough information. The word statusistoovagueforabooleanvalue:itgivesnoclueaboutwhatatrue or false value means. The word blink is also vague, since it doesnt indicatewhatisblinking.Thefollowingalternativeisbetter: Controlscursorblinking:truemeansthecursorisvisible, falsemeansthecursorisnotdisplayed. privatebooleancursorVisibletrue; ThenamecursorVisibleconveysmoreinformation;forexample,itallows readers to guess what a true value means (as a general rule, names of boolean variables should always be predicates).

--- Chunk 188 ---
Tokens: 382
Type: sentence-based
Text:
privatebooleancursorVisibletrue; ThenamecursorVisibleconveysmoreinformation;forexample,itallows readers to guess what a true value means (as a general rule, names of boolean variables should always be predicates). The word blink is no longerinthename,soreaderswillhavetoconsultthedocumentationifthey wanttoknowwhythecursorisntalwaysvisible;thisinformationisless important. Aprojectimplementingaconsensusprotocolcontainedthefollowingcode: Valuerepresentingthattheserverhasnotvoted(yet)for anyoneforthecurrentelectionterm. privatestaticfinalStringVOTED_FOR_SENTINEL_VALUEnull; Thenameforthisvalueindicatesthatitsspecialbutitdoesntsaywhatthe specialmeaningis.AmorespecificnamesuchasNOT_YET_VOTEDwouldbe better. Avariablenamedresultwasusedinamethodwithnoreturnvalue.This namehasmultipleproblems.First,itcreatesthemisleadingimpressionthat itwillbethereturnvalueofthemethod.Second,itprovidesessentiallyno informationaboutwhatitactuallyholds,exceptthatitissomecomputed value.Thenameshouldprovideinformationaboutwhattheresultactually is,suchasmergedLineortotalChars.Inmethodsthatdoactuallyhave returnvalues,thenusingthenameresultisreasonable.Thisnameisstilla bitgeneric,butreaderscanlookatthemethoddocumentationtoseeits meaning,anditshelpfultoknowthatthevaluewilleventuallybecomethe returnvalue. RedFlag:VagueName Ifavariableormethodnameisbroadenoughtorefertomanydifferentthings, thenitdoesntconveymuchinformationtothedeveloperandtheunderlying entityismorelikelytobemisused. Likeallrules,theruleaboutchoosingprecisenameshasafewexceptions.

--- Chunk 189 ---
Tokens: 376
Type: sentence-based
Text:
Likeallrules,theruleaboutchoosingprecisenameshasafewexceptions. For example, its fine to use generic names like i and j as loop iteration variables,aslongastheloopsonlyspanafewlinesofcode.Ifyoucanseethe entire range of usage of a variable, then the meaning of the variable will probablybeobviousfromthecodesoyoudontneedalongname.Forexample, considerthefollowingcode: for(i0;inumLines;i) . Itsclearfromthiscodethatiisbeingusedtoiterateovereachofthelinesin someentity.Iftheloopgetssolongthatyoucantseeitallatonce,orifthe meaningoftheiterationvariableishardertofigureoutfromthecode,thena moredescriptivenameisinorder. Itsalsopossibleforanametobetoospecific,suchasinthisdeclarationfor amethodthatdeletesarangeoftext: voiddelete(Rangeselection). Theargumentnameselectionistoospecific,sinceitsuggeststhatthetextbeing deleted is always selected in the user interface. However, this method can be invokedonanyrangeoftext,selectedornot.Thus,theargumentnameshouldbe moregeneric,suchasrange. Ifyoufinditdifficulttocomeupwithanameforaparticularvariablethatis precise,intuitive,andnottoolong,thisisaredflag.Itsuggeststhatthevariable may not have a clear definition or purpose. When this happens, consider alternative factorings. For example, perhaps you are trying to use a single variable to represent several things; if so, separating the representation into multiple variables may result in a simpler definition for each variable. The process of choosing good names can improve your design by identifying weaknesses.

--- Chunk 190 ---
Tokens: 335
Type: sentence-based
Text:
The process of choosing good names can improve your design by identifying weaknesses. RedFlag:HardtoPickName Ifitshardtofindasimplenameforavariableormethodthatcreatesaclear imageoftheunderlyingobject,thatsahintthattheunderlyingobjectmaynot haveacleandesign. 14.4Usenamesconsistently Thesecondimportantpropertyofgoodnamesisconsistency.Inanyprogram therearecertainvariablesthatareusedoverandoveragain.Forexample,afile systemmanipulatesblocknumbersrepeatedly.Foreachofthesecommonusages, pickanametouseforthatpurpose,andusethesamenameeverywhere.For example,afilesystemmightalwaysusefileBlocktoholdtheindexofablock withinafile.Consistentnamingreducescognitiveloadinmuchthesamewayas reusingacommonclass:oncethereaderhasseenthenameinonecontext,they can reuse their knowledge and instantly make assumptions when they see the nameinadifferentcontext. Consistencyhasthreerequirements:first,alwaysusethecommonnamefor thegivenpurpose;second,neverusethecommonnameforanythingotherthan thegivenpurpose;third,makesurethatthepurposeisnarrowenoughthatall variables with the name have the same behavior. This third requirement was violatedinthefilesystembugatthebeginningofthechapter.Thefilesystem used block for variables with two different behaviors (file blocks and disk blocks);thisledtoafalseassumptionaboutthemeaningofavariable,whichin turnresultedinabug.

--- Chunk 191 ---
Tokens: 203
Type: sentence-based
Text:
This third requirement was violatedinthefilesystembugatthebeginningofthechapter.Thefilesystem used block for variables with two different behaviors (file blocks and disk blocks);thisledtoafalseassumptionaboutthemeaningofavariable,whichin turnresultedinabug. Sometimes you will need multiple variables that refer to thesame general sortofthing.Forexample,amethodthatcopiesfiledatawillneedtwoblock numbers,oneforthesourceandoneforthedestination.Whenthishappens,use the common name for each variable but add a distinguishing prefix, such as srcFileBlockanddstFileBlock. Loopsareanotherareawhereconsistentnamingcanhelp.Ifyouusenames suchas iand j for loop variables, always use i in outermost loops and j for nestedloops.Thisallowsreaderstomakeinstant(safe)assumptionsaboutwhats happeninginthecodewhentheyseeagivenname.

--- Chunk 192 ---
Tokens: 392
Type: sentence-based
Text:
Loopsareanotherareawhereconsistentnamingcanhelp.Ifyouusenames suchas iand j for loop variables, always use i in outermost loops and j for nestedloops.Thisallowsreaderstomakeinstant(safe)assumptionsaboutwhats happeninginthecodewhentheyseeagivenname. 14.5Adifferentopinion:Gostyleguide Noteveryonesharesmyviewsaboutnaming.SomeofthedevelopersoftheGo languagearguethatnamesshouldbeveryshort,oftenonlyasinglecharacter.In apresentationonnamechoiceforGo,AndrewGerrandstatesthatlongnames obscurewhatthecodedoes.1Hepresentsthiscodesample,whichusessingle- lettervariablenames: funcRuneCount(bbyte)int i,n:0,0 forilen(b) ifbiRuneSelf i else _,size:DecodeRune(bi:) isize  n  returnn  andarguesthatitismorereadablethanthefollowingversion,whichuseslonger names: funcRuneCount(bufferbyte)int index,count:0,0 forindexlen(buffer) ifbufferindexRuneSelf index else _,size:DecodeRune(bufferindex:) indexsize  count  returncount  Personally,Idontfindthesecondversionanymoredifficulttoreadthanthe first.Ifanything,thenamecountgivesaslightlybettercluetothebehaviorof thevariablethann.WiththefirstversionIendedupreadingthroughthecode tryingtofigureoutwhatnmeans,whereasIdidntfeelthatneedwiththesecond version.But,if nisusedconsistentlythroughoutthesystemtorefertocounts (and nothing else), then the short name will probably be clear to other developers. The Go culture encourages the use of the same short name for multiple differentthings:chforcharacterorchannel,dfordata,difference,ordistance, andsoon.Tome,ambiguousnameslikethesearelikelytoresultinconfusion anderror,justasintheblockexample.

--- Chunk 193 ---
Tokens: 324
Type: sentence-based
Text:
The Go culture encourages the use of the same short name for multiple differentthings:chforcharacterorchannel,dfordata,difference,ordistance, andsoon.Tome,ambiguousnameslikethesearelikelytoresultinconfusion anderror,justasintheblockexample. Overall,Iwouldarguethatreadabilitymustbedeterminedbyreaders,not writers.Ifyouwritecodewithshortvariablenamesandthepeoplewhoreadit finditeasytounderstand,thenthatsfine.Ifyoustartgettingcomplaintsthat yourcodeiscryptic,thenyoushouldconsiderusinglongernames(aWebsearch forgolanguageshortnameswillidentifyseveralsuchcomplaints).Similarly, ifIstartgettingcomplaintsthatlongvariablenamesmakemycodeharderto read,thenIllconsiderusingshorterones. Gerrand makes one comment that I agree with: The greater the distance betweenanamesdeclarationanditsuses,thelongerthenameshouldbe.The earlierdiscussionaboutusingloopvariablesnamediandjisanexampleofthis rule. 14.6Conclusion Wellchosennameshelptomakecodemoreobvious;whensomeoneencounters thevariableforthefirsttime,theirfirstguessaboutitsbehavior,madewithout much thought, will be correct. Choosing good names is an example of the investmentmindsetdiscussedinChapter3:ifyoutakealittleextratimeupfront toselectgoodnames,itwillbeeasierforyoutoworkonthecodeinthefuture. In addition, you will be less likely to introduce bugs.

--- Chunk 194 ---
Tokens: 366
Type: sentence-based
Text:
In addition, you will be less likely to introduce bugs. Developing a skill for namingisalsoaninvestment.Whenyoufirstdecidetostopsettlingformediocre names,youmayfinditfrustratingandtime-consumingtocomeupwithgood names.However,asyougetmoreexperienceyoullfindthatitbecomeseasier; eventually,youllgettothepointwhereittakesalmostnoextratimetochoose goodnames,soyouwillgetthebenefitsalmostforfree. 1https:talks.golang.org2014names.slide1 Chapter15 WriteTheCommentsFirst (UseCommentsAsPartOfTheDesignProcess) Many developers put off writing documentation until the end of the developmentprocess,aftercodingandunittestingarecomplete.Thisisoneof thesurestwaystoproducepoorqualitydocumentation.Thebesttimetowrite commentsisatthebeginningoftheprocess,asyouwritethecode.Writingthe commentsfirstmakesdocumentationpartofthedesignprocess.Notonlydoes this produce better documentation, but it also produces better designs and it makestheprocessofwritingdocumentationmoreenjoyable. 15.1Delayedcommentsarebadcomments AlmosteverydeveloperIhaveevermetputsoffwritingcomments.Whenasked why they dont write documentation earlier, they say that the code is still changing.Iftheywritedocumentationearly,theysay,theyllhavetorewriteit when the code changes; better to wait until the code stabilizes. However, I suspectthatthereisalsoanotherreason,whichisthattheyviewdocumentation asdrudgework;thus,theyputitoffaslongaspossible. Unfortunately, this approach has several negative consequences.

--- Chunk 195 ---
Tokens: 398
Type: sentence-based
Text:
Unfortunately, this approach has several negative consequences. First, delayingdocumentationoftenmeansthatitnevergetswrittenatall.Onceyou startdelaying,itseasytodelayabitmore;afterall,thecodewillbeevenmore stableinafewmoreweeks.Bythetimethecodehasinarguablystabilized,there isalotofit,whichmeansthetaskofwritingdocumentationhasbecomehuge andevenlessattractive.Theresneveraconvenienttimetostopforafewdays andfillinallofthemissingcomments,anditseasytorationalizethatthebest thingfortheprojectistomoveonandfixbugsorwritethenextnewfeature. Thiswillcreateevenmoreundocumentedcode. Evenifyoudohavetheself-disciplinetogobackandwritethecomments Evenifyoudohavetheself-disciplinetogobackandwritethecomments (anddontfoolyourself:youprobablydont),thecommentswontbeverygood. Bythistimeintheprocess,youhavecheckedoutmentally.Inyourmind,this pieceofcodeisdone;youareeagertomoveontoyournextproject.Youknow thatwritingcommentsistherightthingtodo,butitsnofun.Youjustwantto getthroughitasquicklyaspossible.Thus,youmakeaquickpassoverthecode, adding just enough comments to look respectable. By now, its been a while since you designed the code, so your memories of the design process are becomingfuzzy.Youlookatthecodeasyouarewritingthecomments,sothe commentsrepeatthecode.Evenifyoutrytoreconstructthedesignideasthat arentobviousfromthecode,therewillbethingsyoudontremember.Thus,the commentsaremissingsomeofthemostimportantthingstheyshoulddescribe. 15.2Writethecommentsfirst Iuseadifferentapproachtowritingcomments,whereIwritethecommentsat theverybeginning: Foranewclass,Istartbywritingtheclassinterfacecomment.

--- Chunk 196 ---
Tokens: 394
Type: sentence-based
Text:
15.2Writethecommentsfirst Iuseadifferentapproachtowritingcomments,whereIwritethecommentsat theverybeginning: Foranewclass,Istartbywritingtheclassinterfacecomment. Next,Iwriteinterfacecommentsandsignaturesforthemostimportant publicmethods,butIleavethemethodbodiesempty. Iiterateabitoverthesecommentsuntilthebasicstructurefeelsaboutright. AtthispointIwritedeclarationsandcommentsforthemostimportantclass instancevariablesintheclass. Finally,Ifillinthebodiesofthemethods,addingimplementation commentsasneeded. Whilewritingmethodbodies,Iusuallydiscovertheneedforadditional methodsandinstancevariables.ForeachnewmethodIwritetheinterface commentbeforethebodyofthemethod;forinstancevariablesIfillinthe commentatthesametimethatIwritethevariabledeclaration. Whenthecodeisdone,thecommentsarealsodone.Thereisneverabacklogof unwrittencomments. The comments-first approach has three benefits. First, it produces better comments.Ifyouwritethecommentsasyouaredesigningtheclass,thekey designissueswillbefreshinyourmind,soitseasytorecordthem.Itsbetterto writetheinterfacecommentforeachmethodbeforeitsbody,soyoucanfocuson the methods abstraction and interface without being distracted by its implementation.Duringthecodingandtestingprocessyouwillnoticeandfix problemswiththecomments.Asaresult,thecommentsimproveoverthecourse ofdevelopment. 15.3Commentsareadesigntool The second, and most important, benefit of writing the comments at the beginningisthatitimprovesthesystemdesign.Commentsprovidetheonlyway to fully capture abstractions, and good abstractions are fundamental to good system design.

--- Chunk 197 ---
Tokens: 390
Type: sentence-based
Text:
15.3Commentsareadesigntool The second, and most important, benefit of writing the comments at the beginningisthatitimprovesthesystemdesign.Commentsprovidetheonlyway to fully capture abstractions, and good abstractions are fundamental to good system design. If you write comments describing the abstractions at the beginning,youcanreviewandtunethembeforewritingimplementationcode. Towriteagoodcomment,youmustidentifytheessenceofavariableorpieceof code:whatarethemostimportantaspectsofthisthing?Itsimportanttodothis earlyinthedesignprocess;otherwiseyouarejusthackingcode. Commentsserveasacanaryinthecoalmineofcomplexity.Ifamethodor variable requires a long comment, it is a red flag that you dont have a good abstraction. Remember from Chapter 4 that classes should be deep: the best classeshaveverysimpleinterfacesyetimplementpowerfulfunctions.Thebest waytojudgethecomplexityofaninterfaceisfromthecommentsthatdescribe it.Iftheinterfacecommentforamethodprovidesalltheinformationneededto usethemethodandisalsoshortandsimple,thatindicatesthatthemethodhasa simpleinterface.Conversely,iftheresnowaytodescribeamethodcompletely without a long and complicated comment, then the method has a complex interface. You can compare a methods interface comment with the implementation to get a sense of how deep the method is: if the interface commentmustdescribeallthemajorfeaturesoftheimplementation,thenthe methodisshallow.Thesameideaappliestovariables:ifittakesalongcomment tofullydescribeavariable,itsaredflagthatsuggestsyoumaynothavechosen the right variable decomposition.

--- Chunk 198 ---
Tokens: 380
Type: sentence-based
Text:
You can compare a methods interface comment with the implementation to get a sense of how deep the method is: if the interface commentmustdescribeallthemajorfeaturesoftheimplementation,thenthe methodisshallow.Thesameideaappliestovariables:ifittakesalongcomment tofullydescribeavariable,itsaredflagthatsuggestsyoumaynothavechosen the right variable decomposition. Overall,the act of writing comments allows you to evaluate your design decisions early, so you can discover and fix problems. RedFlag:HardtoDescribe Thecommentthatdescribesamethodorvariableshouldbesimpleandyet complete.Ifyoufinditdifficulttowritesuchacomment,thatsanindicator thattheremaybeaproblemwiththedesignofthethingyouaredescribing. Of course, comments are only a good indicator of complexity if they are completeandclear.Ifyouwriteamethodinterfacecommentthatdoesntprovide alltheinformationneededtoinvokethemethod,oronethatissocrypticthatits hardtounderstand,thenthatcommentdoesntprovideagoodmeasureofthe methodsdepth. 15.4Earlycommentsarefuncomments Thethirdandfinalbenefitofwritingcommentsearlyisthatitmakescomment- writingmorefun.Forme,oneofthemostenjoyablepartsofprogrammingisthe earlydesignphaseforanewclass,whereImfleshingouttheabstractionsand structurefortheclass.Mostofmycommentsarewrittenduringthisphase,and thecommentsarehowIrecordandtestthequalityofmydesigndecisions.Im lookingforthedesignthatcanbeexpressedcompletelyandclearlyinthefewest words.Thesimplerthecomments,thebetterIfeelaboutmydesign,sofinding simple comments is a source of pride.

--- Chunk 199 ---
Tokens: 370
Type: sentence-based
Text:
15.4Earlycommentsarefuncomments Thethirdandfinalbenefitofwritingcommentsearlyisthatitmakescomment- writingmorefun.Forme,oneofthemostenjoyablepartsofprogrammingisthe earlydesignphaseforanewclass,whereImfleshingouttheabstractionsand structurefortheclass.Mostofmycommentsarewrittenduringthisphase,and thecommentsarehowIrecordandtestthequalityofmydesigndecisions.Im lookingforthedesignthatcanbeexpressedcompletelyandclearlyinthefewest words.Thesimplerthecomments,thebetterIfeelaboutmydesign,sofinding simple comments is a source of pride. If you are programming strategically, whereyourmaingoalisagreatdesignratherthanjustwritingcodethatworks, then writing comments should be fun, since thats how you identify the best designs. 15.5Areearlycommentsexpensive? Nowletsrevisittheargumentfordelayingcomments,whichisthatitavoidsthe cost of reworking the comments as the code evolves. A simple back-of-the- envelopecalculationwillshowthatthisdoesntsavemuch.First,estimatethe totalfractionofdevelopmenttimethatyouspendtypingincodeandcomments together,includingtimetorevisecodeandcomments;itsunlikelythatthiswill bemorethanabout10ofalldevelopmenttime.Evenifhalfofyourtotalcode linesarecomments,writingcommentsprobablydoesntaccountformorethan about5ofyourtotaldevelopmenttime.Delayingthecommentsuntiltheend willsaveonlyafractionofthis,whichisntverymuch. Writing the comments first will mean that the abstractions will be more stablebeforeyoustartwritingcode.Thiswillprobablysavetimeduringcoding.

--- Chunk 200 ---
Tokens: 335
Type: sentence-based
Text:
Writing the comments first will mean that the abstractions will be more stablebeforeyoustartwritingcode.Thiswillprobablysavetimeduringcoding. Incontrast,ifyouwritethecodefirst,theabstractionswillprobablyevolveas you code, which will require more code revisions than the comments-first approach.Whenyouconsiderallofthesefactors,itspossiblethatitmightbe fasteroveralltowritethecommentsfirst. 15.6Conclusion Ifyouhaventevertriedwritingthecommentsfirst,giveitatry.Stickwithit longenoughtogetusedtoit.Thenthinkabouthowitaffectsthequalityofyour comments,thequalityofyourdesign,andyouroverallenjoymentofsoftware development.Afteryouhavetriedthisforawhile,letmeknowwhetheryour experiencematchesmine,andwhyorwhynot. Chapter16 ModifyingExistingCode Chapter1describedhowsoftwaredevelopmentisiterativeandincremental.A large software system develops through a series of evolutionary stages, where eachstageaddsnewcapabilitiesandmodifiesexistingmodules.Thismeansthat asystemsdesignisconstantlyevolving.Itisntpossibletoconceivetheright designforasystemattheoutset;thedesignofamaturesystemisdetermined more by changes made during the systems evolution than by any initial conception.Previouschaptersdescribedhowtosqueezeoutcomplexityduring the initial design and implementation; this chapter discusses how to keep complexityfromcreepinginasthesystemevolves.

--- Chunk 201 ---
Tokens: 329
Type: sentence-based
Text:
Chapter16 ModifyingExistingCode Chapter1describedhowsoftwaredevelopmentisiterativeandincremental.A large software system develops through a series of evolutionary stages, where eachstageaddsnewcapabilitiesandmodifiesexistingmodules.Thismeansthat asystemsdesignisconstantlyevolving.Itisntpossibletoconceivetheright designforasystemattheoutset;thedesignofamaturesystemisdetermined more by changes made during the systems evolution than by any initial conception.Previouschaptersdescribedhowtosqueezeoutcomplexityduring the initial design and implementation; this chapter discusses how to keep complexityfromcreepinginasthesystemevolves. 16.1Staystrategic Chapter3introducedthedistinctionbetweentacticalprogrammingandstrategic programming: in tactical programming, the primary goal is to get something working quickly, even if that results in additional complexity; in strategic programming,themostimportantgoalistoproduceagreatsystemdesign.The tacticalapproachveryquicklyleadstoamessysystemdesign.Ifyouwantto haveasystemthatiseasytomaintainandenhance,thenworkingisntahigh enoughstandard;youhavetoprioritizedesignandthinkstrategically.Thisidea alsoapplieswhenyouaremodifyingexistingcode. Unfortunately,whendevelopersgointoexistingcodetomakechangessuch as bug fixes or new features, they dont usually think strategically.

--- Chunk 202 ---
Tokens: 340
Type: sentence-based
Text:
Unfortunately,whendevelopersgointoexistingcodetomakechangessuch as bug fixes or new features, they dont usually think strategically. A typical mindsetiswhatisthesmallestpossiblechangeIcanmakethatdoeswhatI need?Sometimesdevelopersjustifythisbecausetheyarenotcomfortablewith thecodebeingmodified;theyworrythatlargerchangescarryagreaterriskof introducingnewbugs.However,thisresultsintacticalprogramming.Eachone oftheseminimalchangesintroducesafewspecialcases,dependencies,orother formsofcomplexity.Asaresult,thesystemdesigngetsjustabitworse,andthe problemsaccumulatewitheachstepinthesystemsevolution. Ifyouwanttomaintainacleandesignforasystem,youmusttakeastrategic approachwhenmodifyingexistingcode.Ideally,whenyouhavefinishedwith eachchange,thesystemwillhavethestructureitwouldhavehadifyouhad designeditfromthestartwiththatchangeinmind.Toachievethisgoal,you mustresistthetemptationtomakeaquickfix.Instead,thinkaboutwhetherthe currentsystemdesignisstillthebestone,inlightofthedesiredchange.Ifnot, refactorthesystemsothatyouendupwiththebestpossibledesign.Withthis approach,thesystemdesignimproveswitheverymodification. Thisisalsoanexampleoftheinvestmentmindsetintroducedonpage15:if youinvestalittleextratimetorefactorandimprovethesystemdesign,youllend upwithacleanersystem.Thiswillspeedupdevelopment,andyouwillrecoup the effort that you invested in the refactoring.

--- Chunk 203 ---
Tokens: 379
Type: sentence-based
Text:
Thisisalsoanexampleoftheinvestmentmindsetintroducedonpage15:if youinvestalittleextratimetorefactorandimprovethesystemdesign,youllend upwithacleanersystem.Thiswillspeedupdevelopment,andyouwillrecoup the effort that you invested in the refactoring. Even if your particular change doesnt require refactoring, you should still be on the lookout for design imperfectionsthatyoucanfixwhileyoureinthecode.Wheneveryoumodify anycode,trytofindawaytoimprovethesystemdesignatleastalittlebitinthe process.Ifyourenotmakingthedesignbetter,youareprobablymakingit worse. AsdiscussedinChapter3,aninvestmentmindsetsometimesconflictswith therealitiesofcommercialsoftwaredevelopment.Ifrefactoringthesystemthe rightwaywouldtakethreemonthsbutaquickanddirtyfixwouldtakeonlytwo hours,youmayhavetotakethequickanddirtyapproach,particularlyifyouare working against a tight deadline. Or, if refactoring the system would create incompatibilitiesthataffectmanyotherpeopleandteams,thentherefactoring maynotbepractical. Nonetheless,youshouldresistthesecompromisesasmuchaspossible.Ask yourselfIsthisthebestIcanpossiblydotocreateacleansystemdesign,given mycurrentconstraints?Perhapstheresanalternativeapproachthatwouldbe almostascleanasthe3-monthrefactoringbutcouldbedoneinacoupleofdays? Or,ifyoucantaffordtodoalargerefactoringnow,getyourbosstoallocatetime for you to come back to it after the current deadline. Every development organizationshouldplantospendasmallfractionofitstotaleffortoncleanup andrefactoring;thisworkwillpayforitselfoverthelongrun.

--- Chunk 204 ---
Tokens: 306
Type: sentence-based
Text:
Every development organizationshouldplantospendasmallfractionofitstotaleffortoncleanup andrefactoring;thisworkwillpayforitselfoverthelongrun. 16.2Maintainingcomments:keepthecommentsnearthe code When you change existing code, theres a good chance that the changes will When you change existing code, theres a good chance that the changes will invalidatesomeoftheexistingcomments.Itseasytoforgettoupdatecomments whenyoumodifycode,whichresultsincommentsthatarenolongeraccurate. Inaccurate comments are frustrating to readers, and if there are very many of them, readers begin to distrust all of the comments. Fortunately, with a little disciplineandacoupleofguidingrules,itspossibletokeepcommentsup-to- datewithoutahugeeffort.Thissectionandthefollowingonesputforthsome specifictechniques. Thebestwaytoensurethatcommentsgetupdatedistopositionthem closetothecodetheydescribe,sodeveloperswillseethemwhentheychange thecode.Thefartheracommentisfromitsassociatedcode,thelesslikelyitis that it will be updated properly. For example, the best place for a methods interfacecommentisinthecodefile,rightnexttothebodyofthemethod.Any changestothemethodwillinvolvethiscode,sothedeveloperislikelytoseethe interfacecommentsandupdatethemifneeded.

--- Chunk 205 ---
Tokens: 356
Type: sentence-based
Text:
For example, the best place for a methods interfacecommentisinthecodefile,rightnexttothebodyofthemethod.Any changestothemethodwillinvolvethiscode,sothedeveloperislikelytoseethe interfacecommentsandupdatethemifneeded. An alternative for languages like C and C that have separate code and headerfiles,istoplacetheinterfacecommentsnexttothemethodsdeclaration inthe.hfile.However,thisisalongwayfromthecode;developerswontsee thosecommentswhenmodifyingthemethodsbody,andittakesadditionalwork toopenadifferentfileandfindtheinterfacecommentstoupdatethem.Some mightarguethatinterfacecommentsshouldgoinheaderfilessothatuserscan learnhowtouseanabstractionwithouthavingtolookatthecodefile.However, usersshouldnotneedtoreadeithercodeorheaderfiles;theyshouldgettheir informationfromdocumentationcompiledbytoolssuchasDoxygenorJavadoc. Inaddition,manyIDEswillextractandpresentdocumentationtousers,suchas by displaying a methods documentation when the methods name is typed. Giventoolssuchasthese,thedocumentationshouldbelocatedintheplacethat ismostconvenientfordevelopersworkingonthecode. Whenwritingimplementationcomments,dontputallthecommentsforan entiremethodatthetopofthemethod.Spreadthemout,pushingeachcomment down to the narrowest scope that includes all of the code referred to by the comment. For example, if a method has three major phases, dont write one comment at the top of the method that describes all of the phases in detail.

--- Chunk 206 ---
Tokens: 321
Type: sentence-based
Text:
For example, if a method has three major phases, dont write one comment at the top of the method that describes all of the phases in detail. Instead,writeaseparatecommentforeachphaseandpositionthatcommentjust abovethefirstlineofcodeinthatphase.Ontheotherhand,itcanalsobehelpful tohaveacommentatthetopofamethodsimplementationthatdescribesthe overallstrategy,likethis: Weproceedinthreephases: Phase1:Findfeasiblecandidates Phase2:Assigneachcandidateascore Phase3:Choosethebest,andremoveit Additionaldetailscanbedocumentedjustabovethecodeforeachphase. In general, the farther a comment is from the code it describes, the more abstract it should be (this reduces the likelihood that the comment will be invalidatedbycodechanges). 16.3Commentsbelonginthecode,notthecommitlog Acommonmistakewhenmodifyingcodeistoputdetailedinformationabout thechangeinthecommitmessageforthesourcecoderepository,butthennotto document it in the code. Although commit messages can be browsed in the futurebyscanningtherepositoryslog,adeveloperwhoneedstheinformationis unlikelytothinkofscanningtherepositorylog.Eveniftheydoscanthelog,it willbetedioustofindtherightlogmessage. Whenwritingacommitmessage,askyourselfwhetherdeveloperswillneed tousethatinformationinthefuture.Ifso,thendocumentthisinformationinthe code.

--- Chunk 207 ---
Tokens: 339
Type: sentence-based
Text:
Whenwritingacommitmessage,askyourselfwhetherdeveloperswillneed tousethatinformationinthefuture.Ifso,thendocumentthisinformationinthe code. An example is a commit message describing a subtle problem that motivatedacodechange.Ifthisisntdocumentedinthecode,thenadeveloper mightcomealonglaterandundothechangewithoutrealizingthattheyhavere- createdabug.Ifyouwanttoincludeacopyofthisinformationinthecommit messageaswell,thatsfine,butthemostimportantthingistogetitinthecode. This illustrates the principle of placing documentation in the place where developersaremostlikelytoseeit;thecommitlogisrarelythatplace. 16.4Maintainingcomments:avoidduplication Thesecondtechniqueforkeepingcommentsuptodateistoavoidduplication.If documentationisduplicated,itismoredifficultfordeveloperstofindandupdate alloftherelevantcopies.Instead,trytodocumenteachdesigndecisionexactly once. If there are multiple placesin the code that are affected by a particular decision,dontrepeatthedocumentationateachofthesepoints.Instead,findthe mostobvioussingleplacetoputthedocumentation.Forexample,supposethere is tricky behavior related to a variable, which affects several different places wherethevariableisused.Youcandocumentthatbehaviorinthecommentnext tothevariablesdeclaration.Thisisanaturalplacethatdevelopersarelikelyto checkiftheyrehavingtroubleunderstandingcodethatusesthevariable.

--- Chunk 208 ---
Tokens: 378
Type: sentence-based
Text:
If there are multiple placesin the code that are affected by a particular decision,dontrepeatthedocumentationateachofthesepoints.Instead,findthe mostobvioussingleplacetoputthedocumentation.Forexample,supposethere is tricky behavior related to a variable, which affects several different places wherethevariableisused.Youcandocumentthatbehaviorinthecommentnext tothevariablesdeclaration.Thisisanaturalplacethatdevelopersarelikelyto checkiftheyrehavingtroubleunderstandingcodethatusesthevariable. If there is no obvious single place to put a particular piece of documentation where developers will find it, create a designNotes file as describedinSection13.7.Or,pickthebestoftheavailableplacesandputthe documentationthere.Inaddition,addshortcommentsintheotherplacesthat refertothecentrallocation:Seethecommentinxyzforanexplanationofthe codebelow.Ifthereferencebecomesobsoletebecausethemastercommentwas moved or deleted, this inconsistency will be self-evident because developers wont find the comment at the indicated place; they can use revision control historytofindoutwhathappenedtothecommentandthenupdatethereference. Incontrast,ifthedocumentationisduplicatedandsomeofthecopiesdontget updated, there will be no indication to developers that they are using stale information. Dont redocument one modules design decisions in another module. For example,dontputcommentsbeforeamethodcallthatexplainwhathappensin the called method. If readers want to know, they should look at the interface comments for the method.

--- Chunk 209 ---
Tokens: 357
Type: sentence-based
Text:
If readers want to know, they should look at the interface comments for the method. Good development tools will usually provide this informationautomatically,forexample,bydisplayingtheinterfacecommentsfor a method if you select the methods name or hover the mouse over it. Try to makeiteasyfordeveloperstofindappropriatedocumentation,butdontdoitby repeatingthedocumentation. Ifinformationisalreadydocumentedsomeplaceoutsideyourprogram, dont repeat the documentation inside the program; just reference the externaldocumentation.Forexample,ifyouwriteaclassthatimplementsthe HTTP protocol, theres no need for you to describe the HTTP protocol inside your code.There are already numerous sources for this documentation on the Web; just add a short comment to your code with a URL for one of these sources. Another example is features that are already documented in a user manual. Suppose you are writing a program that implements a collection of commands, with one method responsible for implementing each command. If there is a user manual that describes those commands, theres no need to duplicate this information in the code. Instead, include a short note like the followingintheinterfacecommentforeachcommandmethod: ImplementstheFoocommand;seetheusermanualfordetails. Its important that readers can easily find all the documentation needed to understand your code, but that doesnt mean you have to write all of that documentation.

--- Chunk 210 ---
Tokens: 398
Type: sentence-based
Text:
Its important that readers can easily find all the documentation needed to understand your code, but that doesnt mean you have to write all of that documentation. 16.5Maintainingcomments:checkthediffs One good way to make sure documentation stays up to date is to take a few minutesbeforecommittingachangetoyourrevisioncontrolsystemtoscanover allthechangesforthatcommit;makesurethateachchangeisproperlyreflected in the documentation. These pre-commit scans will also detect several other problems,suchasaccidentallyleavingdebuggingcodeinthesystemorfailingto fixTODOitems. 16.6Higher-levelcommentsareeasiertomaintain One final thought on maintaining documentation: comments are easier to maintain if they are higher-level and more abstract than the code. These commentsdonotreflectthedetailsofthecode,sotheywillnotbeaffectedby minor code changes; only changes in overall behavior will affect these comments.Ofcourse,asdiscussedinChapter13,somecommentsdoneedtobe detailed and precise. But in general, the comments that are most useful (they dontsimplyrepeatthecode)arealsoeasiesttomaintain. Chapter17 Consistency Consistency is a powerful tool for reducing the complexity of a system and makingitsbehaviormoreobvious.Ifasystemisconsistent,itmeansthatsimilar thingsaredoneinsimilarways,anddissimilarthingsaredoneindifferentways. Consistencycreatescognitiveleverage:onceyouhavelearnedhowsomethingis doneinoneplace,youcanusethatknowledgetoimmediatelyunderstandother placesthatusethesameapproach.Ifasystemisnotimplementedinaconsistent fashion, developers must learn about each situation separately.

--- Chunk 211 ---
Tokens: 350
Type: sentence-based
Text:
Consistencycreatescognitiveleverage:onceyouhavelearnedhowsomethingis doneinoneplace,youcanusethatknowledgetoimmediatelyunderstandother placesthatusethesameapproach.Ifasystemisnotimplementedinaconsistent fashion, developers must learn about each situation separately. This will take moretime. Consistency reduces mistakes. If a system is not consistent, two situations may appear the same when in fact they are different. A developer may see a pattern that looks familiar and make incorrect assumptions based on previous encounters with that pattern. On the other hand, if the system is consistent, assumptionsmadebasedonfamiliar-lookingsituationswillbesafe.Consistency allowsdeveloperstoworkmorequicklywithfewermistakes. 17.1Examplesofconsistency Consistencycanbeappliedatmanylevelsinasystem;hereareafewexamples. Names. Chapter 14 has already discussed the benefits of using names in a consistentway. Coding style. It is common nowadays for development organizations to have style guides that restrict program structure beyond the rules enforced by compilers.Modernstyleguidesaddressarangeofissues,suchasindentation, curly-brace placement, order of declarations, naming, commenting, and restrictions on language features considered dangerous. Style guidelines make codeeasiertoreadandcanreducesomekindsoferrors. Interfaces. An interface with multiple implementations is another example of Interfaces.

--- Chunk 212 ---
Tokens: 329
Type: sentence-based
Text:
An interface with multiple implementations is another example of Interfaces. An interface with multiple implementations is another example of consistency.Onceyouunderstandoneimplementationoftheinterface,anyother implementation becomes easier to understand because you already know the featuresitwillhavetoprovide. Design patterns. Design patterns are generally-accepted solutions to certain commonproblems,suchasthemodel-view-controllerapproachtouserinterface design. If you can use an existing design pattern to solve the problem, the implementationwillproceedmorequickly,itismorelikelytowork,andyour code will be more obvious to readers. Design patterns are discussed in more detailinSection19.5. Invariants.Aninvariantisapropertyofavariableorstructurethatisalways true.Forexample,adatastructurestoringlinesoftextmightenforceaninvariant thateachlineisterminatedbyanewlinecharacter.Invariantsreducethenumber ofspecialcasesthatmustbeconsideredincodeandmakeiteasiertoreason aboutthecodesbehavior. 17.2Ensuringconsistency Consistencyishardtomaintain,especiallywhenmanypeopleworkonaproject over a long time. People in one group may not know about conventions established in another group. Newcomers dont know the rules, so they unintentionallyviolatetheconventionsandcreatenewconventionsthatconflict with existing ones.

--- Chunk 213 ---
Tokens: 388
Type: sentence-based
Text:
Newcomers dont know the rules, so they unintentionallyviolatetheconventionsandcreatenewconventionsthatconflict with existing ones. Here are a few tips for establishing and maintaining consistency: Document.Createadocumentthatliststhemostimportantoverallconventions, suchascodingstyleguidelines.Placethedocumentinaspotwheredevelopers arelikelytoseeit,suchasaconspicuousplaceontheprojectWiki.Encourage new people joining the group to read the document, and encourage existing people to review it every once in a while. Several style guides from various organizations have been published on the Web; consider starting with one of these. For conventions that are more localized, such as invariants, find an appropriate spot in the code to document them. If you dont write the conventionsdown,itsunlikelythatotherpeoplewillfollowthem. Enforce.Evenwithgooddocumentation,itshardfordeveloperstoremember alloftheconventions.Thebestwaytoenforceconventionsistowriteatoolthat checks for violations, and make sure that code cannot be committed to the repository unless it passes the checker. Automated checkers work particularly wellforlow-levelsyntacticconventions. One of my recent projects had problems with line termination characters. SomedevelopersworkedonUnix,wherelinesareterminatedbynewlines;others workedonWindows,wherelinesarenormallyterminatedbyacarriage-return followedbyanewline.Ifadeveloperononesystemmadeasmalledittoafile previouslyeditedontheothersystem,theeditorwouldsometimesreplaceallof the line terminators with ones appropriate for that system.

--- Chunk 214 ---
Tokens: 375
Type: sentence-based
Text:
SomedevelopersworkedonUnix,wherelinesareterminatedbynewlines;others workedonWindows,wherelinesarenormallyterminatedbyacarriage-return followedbyanewline.Ifadeveloperononesystemmadeasmalledittoafile previouslyeditedontheothersystem,theeditorwouldsometimesreplaceallof the line terminators with ones appropriate for that system. This gave the appearancethateverylineofthefilehadbeenmodified,whichmadeithardto track the meaningful changes. We established a convention that files should containnewlinesonly,butitwashardtoensurethateverytoolusedbyevery developer followed the convention. Every time a new developer joined the project, we would experience a rash of line termination problems while that developeradjustedtotheconvention. Weeventuallysolvedthisproblembywritingashortscriptthatwasexecuted automaticallybeforechangesarecommittedtothesourcecoderepository.The scriptchecksallofthefilesthathavebeenmodifiedandabortsthecommitifany ofthemcontaincarriagereturns.Thescriptcanalsoberunmanuallytorepair damaged files by replacing carriage-returnnewline sequences with newlines. Thisinstantlyeliminatedtheproblems,anditalsohelpedtrainnewdevelopers. Codereviewsprovideanotheropportunityforenforcingconventionsandfor educatingnewdevelopersabouttheconventions.Themorenit-pickythatcode reviewersare,themorequicklyeveryoneontheteamwilllearntheconventions, andthecleanerthecodewillbe. WheninRome.Themostimportantconventionofallisthateverydeveloper should follow the old adage When in Rome, do as the Romans do.

--- Chunk 215 ---
Tokens: 388
Type: sentence-based
Text:
WheninRome.Themostimportantconventionofallisthateverydeveloper should follow the old adage When in Rome, do as the Romans do. When workinginanewfile,lookaroundtoseehowtheexistingcodeisstructured.Are allpublicvariablesandmethodsdeclaredbeforeprivateones?Arethemethods inalphabeticalorder?Dovariablesusecamelcase,asinfirstServerName,or snakecase,asinfirst_server_name?Whenyouseeanythingthatlookslikeit mightpossiblybeaconvention,followit.Whenmakingadesigndecision,ask yourselfifitslikelythatasimilardecisionwasmadeelsewhereintheproject;if so,findanexistingexampleandusethesameapproachinyournewcode. Dont change existing conventions. Resist the urge to improve on existing Dont change existing conventions. Resist the urge to improve on existing conventions.Having a better idea is not a sufficient excuse to introduce inconsistencies. Your new idea may indeed be better, but the value of consistency over inconsistency is almost always greater than the value of one approach over another. Before introducing inconsistent behavior, ask yourself two questions. First, do you have significant new information justifying your approachthatwasntavailablewhentheoldconventionwasestablished?Second, isthenewapproachsomuchbetterthatitisworthtakingthetimetoupdateall oftheolduses?Ifyourorganizationagreesthattheanswerstobothquestionsare yes,thengoaheadandmaketheupgrade;whenyouaredone,thereshouldbe no sign of the old convention. However, you still run the risk that other developerswillnotknowaboutthenewconvention,sotheymayreintroducethe old approach in the future.

--- Chunk 216 ---
Tokens: 369
Type: sentence-based
Text:
However, you still run the risk that other developerswillnotknowaboutthenewconvention,sotheymayreintroducethe old approach in the future. Overall, reconsidering established conventions is rarelyagooduseofdevelopertime. 17.3Takingittoofar Consistencymeansnotonlythatsimilarthingsshouldbedoneinsimilarways, but that dissimilar things should be done in different ways. If you become overzealousaboutconsistencyandtrytoforcedissimilarthingsintothesame approach, such as by using the same variable name for things that are really differentorusinganexistingdesignpatternforataskthatdoesntfitthepattern, youllcreatecomplexityandconfusion.Consistencyonlyprovidesbenefitswhen developershaveconfidencethatifitlookslikeanx,itreallyisanx. 17.4Conclusion Consistencyisanotherexampleoftheinvestmentmindset.Itwilltakeabitof extraworktoensureconsistency:worktodecideonconventions,worktocreate automatedcheckers,worktolookforsimilarsituationstomimicinnewcode, andworkincodereviewstoeducatetheteam.Thereturnonthisinvestmentis thatyourcodewillbemoreobvious.Developerswillbeabletounderstandthe codesbehaviormorequicklyandaccurately,andthiswillallowthemtowork faster,withfewerbugs. Chapter18 CodeShouldbeObvious ObscurityisoneofthetwomaincausesofcomplexitydescribedinSection2.3. Obscurityoccurswhenimportantinformationaboutasystemisnotobviousto newdevelopers.Thesolutiontotheobscurityproblemistowritecodeinaway thatmakesitobvious;thischapterdiscussessomeofthefactorsthatmakecode moreorlessobvious.

--- Chunk 217 ---
Tokens: 382
Type: sentence-based
Text:
Obscurityoccurswhenimportantinformationaboutasystemisnotobviousto newdevelopers.Thesolutiontotheobscurityproblemistowritecodeinaway thatmakesitobvious;thischapterdiscussessomeofthefactorsthatmakecode moreorlessobvious. Ifcodeisobvious,itmeansthatsomeonecanreadthecodequickly,without muchthought,andtheirfirstguessesaboutthebehaviorormeaningofthecode willbecorrect.Ifcodeisobvious,areaderdoesntneedtospendmuchtimeor efforttogatheralltheinformationtheyneedtoworkwiththecode.Ifcodeisnot obvious,thenareadermustexpendalotoftimeandenergytounderstandit.Not only does this reduce their efficiency, but it also increases the likelihood of misunderstanding and bugs. Obvious code needs fewer comments than nonobviouscode. Obvious is in the mind of the reader: its easier to notice that someone elsescodeisnonobviousthantoseeproblemswithyourowncode.Thus,the best way to determine the obviousness of code is through code reviews. If someonereadingyourcodesaysitsnotobvious,thenitsnotobvious,nomatter how clear it may seem to you. By trying to understand what made the code nonobvious,youwilllearnhowtowritebettercodeinthefuture. 18.1Thingsthatmakecodemoreobvious Two of the most important techniques for making code obvious have already beendiscussedinpreviouschapters.Thefirstischoosinggoodnames(Chapter 14).Preciseandmeaningfulnamesclarifythebehaviorofthecodeandreduce theneedfordocumentation.Ifanameisvagueorambiguous,thenreaderswill havereadthroughthecodeinordertodeducethemeaningofthenamedentity; this is time-consuming and error-prone.

--- Chunk 218 ---
Tokens: 338
Type: sentence-based
Text:
18.1Thingsthatmakecodemoreobvious Two of the most important techniques for making code obvious have already beendiscussedinpreviouschapters.Thefirstischoosinggoodnames(Chapter 14).Preciseandmeaningfulnamesclarifythebehaviorofthecodeandreduce theneedfordocumentation.Ifanameisvagueorambiguous,thenreaderswill havereadthroughthecodeinordertodeducethemeaningofthenamedentity; this is time-consuming and error-prone. The second technique is consistency (Chapter17).Ifsimilarthingsarealwaysdoneinsimilarways,thenreaderscan recognize patterns they have seen before and immediately draw (safe) conclusionswithoutanalyzingthecodeindetail. Here are a few other general-purpose techniques for making code more obvious: Judicioususeofwhitespace.Thewaycodeisformattedcanimpacthoweasyit is to understand. Consider the following parameter documentation, in which whitespacehasbeensqueezedout:  . paramnumThreadsThenumberofthreadsthatthismanagershould spinupinordertomanageongoingconnections.TheMessageManager spinsupatleastonethreadforeveryopenconnection,sothis shouldbeatleastequaltothenumberofconnectionsyouexpect tobeopenatonce.Thisshouldbeamultipleofthatnumberif youexpecttosendalotofmessagesinashortamountoftime. paramhandlerUsedasacallbackinordertohandleincoming messagesonthisMessageManagersopenconnections.See codeMessageHandlerandcodehandleMessagefordetails.

--- Chunk 219 ---
Tokens: 400
Type: sentence-based
Text:
paramhandlerUsedasacallbackinordertohandleincoming messagesonthisMessageManagersopenconnections.See codeMessageHandlerandcodehandleMessagefordetails. Itshardtoseewherethedocumentationforoneparameterendsandthenext begins.Itsnotevenobvioushowmanyparametersthereare,orwhattheirnames are.Ifalittlewhitespaceisadded,thestructuresuddenlybecomesclearandthe documentationiseasiertoscan:  paramnumThreads Thenumberofthreadsthatthismanagershouldspinupin ordertomanageongoingconnections.TheMessageManager spins upatleastonethreadforeveryopenconnection,sothis shouldbeatleastequaltothenumberofconnectionsyou expecttobeopenatonce.Thisshouldbeamultipleof that numberifyouexpecttosendalotofmessagesinashort amountoftime. paramhandler Usedasacallbackinordertohandleincomingmessageson thisMessageManagersopenconnections.See codeMessageHandlerandcodehandleMessagefor details. Blanklinesarealsousefultoseparatemajorblocksofcodewithinamethod, suchasinthefollowingexample: voidBuffer:allocAux(size_tnumBytes)  Roundupthelengthtoamultipleof8bytes,toensure alignment. uint32_tnumBytes32(downCastuint32_t(numBytes)7)0x7; assert(numBytes32!0);  IfthereisenoughmemoryatfirstAvailable,usethat.Work down fromthetop,becausethismemoryisguaranteedtobealigned (memoryatthebottommayhavebeenusedforvariable-size chunks). if(availableLengthnumBytes32) availableLength-numBytes32; returnfirstAvailableavailableLength;  Next,seeifthereisextraspaceattheendofthelastchunk. if(extraAppendBytesnumBytes32) extraAppendBytes-numBytes32; returnlastChunk-datalastChunk-lengthextraAppendBytes;  Mustcreateanewspaceallocation;allocatespacewithinit.

--- Chunk 220 ---
Tokens: 368
Type: sentence-based
Text:
if(extraAppendBytesnumBytes32) extraAppendBytes-numBytes32; returnlastChunk-datalastChunk-lengthextraAppendBytes;  Mustcreateanewspaceallocation;allocatespacewithinit. uint32_tallocatedLength; firstAvailablegetNewAllocation(numBytes32,allocatedLength); availableLengthallocatedLengthnumBytes32; returnfirstAvailableavailableLength;  Thisapproachworksparticularlywellifthefirstlineaftereachblanklineisa commentdescribingthenextblockofcode:theblanklinesmakethecomments morevisible. Whitespacewithinastatementhelpstoclarifythestructureofthestatement. Comparethefollowingtwostatements,oneofwhichhaswhitespaceandoneof whichdoesnt: for(intpass1;pass0!empty;pass--) for(intpass1;pass0!empty;pass--) Comments.Sometimesitisntpossibletoavoidcodethatisnonobvious.When this happens, its important to use comments to compensate by providing the missinginformation.Todothiswell,youmustputyourselfinthepositionofthe readerandfigureoutwhatislikelytoconfusethem,andwhatinformationwill clearupthatconfusion.Thenextsectionshowsafewexamples. 18.2Thingsthatmakecodelessobvious Therearemanythingsthatcanmakecodenonobvious;thissectionprovidesa fewexamples.Someofthese,suchasevent-drivenprogramming,areusefulin some situations, so you may end up using them anyway. When this happens, extradocumentationcanhelptominimizereaderconfusion. Event-driven programming. In event-driven programming, an application respondstoexternaloccurrences,suchasthearrivalofanetworkpacketorthe press of a mouse button.

--- Chunk 221 ---
Tokens: 359
Type: sentence-based
Text:
In event-driven programming, an application respondstoexternaloccurrences,suchasthearrivalofanetworkpacketorthe press of a mouse button. One module is responsible for reporting incoming events.Otherpartsoftheapplicationregisterinterestincertaineventsbyasking theeventmoduletoinvokeagivenfunctionormethodwhenthoseeventsoccur. Event-drivenprogrammingmakesithardtofollowtheflowofcontrol.The eventhandlerfunctionsareneverinvokeddirectly;theyareinvokedindirectlyby theeventmodule,typicallyusingafunctionpointerorinterface.Evenifyoufind thepointofinvocationintheeventmodule,itstillisntpossibletotellwhich specific function will be invoked: this will depend on which handlers were registeredatruntime.Becauseofthis,itshardtoreasonaboutevent-drivencode orconvinceyourselfthatitworks. Tocompensateforthisobscurity,usetheinterfacecommentforeachhandler Tocompensateforthisobscurity,usetheinterfacecommentforeachhandler functiontoindicatewhenitisinvoked,asinthisexample:  Thismethodisinvokedinthedispatchthreadbyatransportifa transport-levelerrorpreventsanRPCfromcompleting. void Transport:RpcNotifier:failed() . RedFlag:NonobviousCode If the meaning and behavior of code cannot be understood with a quick reading,itisaredflag.Oftenthismeansthatthereisimportantinformation thatisnotimmediatelycleartosomeonereadingthecode. Genericcontainers.Manylanguagesprovidegenericclassesforgroupingtwo ormoreitemsintoasingleobject,suchas PairinJavaor std:pairinC.

--- Chunk 222 ---
Tokens: 349
Type: sentence-based
Text:
Genericcontainers.Manylanguagesprovidegenericclassesforgroupingtwo ormoreitemsintoasingleobject,suchas PairinJavaor std:pairinC. These classes are tempting because they make it easy to pass around several objectswithasinglevariable.Oneofthemostcommonusesistoreturnmultiple valuesfromamethod,asinthisJavaexample: returnnewPairInteger,Boolean(currentTerm,false); Unfortunately,genericcontainersresultinnonobviouscodebecausethegrouped elementshavegenericnamesthatobscuretheirmeaning.Intheexampleabove, the caller must reference the two returned values with result.getKey() and result.getValue(),whichgivenoclueabouttheactualmeaningofthevalues. Thus,itsbetternottousegenericcontainers.Ifyouneedacontainer,define anewclassorstructurethatisspecializedfortheparticularuse.Youcanthen use meaningful names for the elements, and you can provide additional documentation in the declaration, which is not possible with the generic container. This example illustrates a general rule: software should be designed for easeofreading,noteaseofwriting.Genericcontainersareexpedientforthe personwritingthecode,buttheycreateconfusionforallthereadersthatfollow. Itsbetterforthepersonwritingthecodetospendafewextraminutestodefinea specificcontainerstructure,sothattheresultingcodeismoreobvious. Different types for declaration and allocation. Consider the following Java example: privateListMessageincomingMessageList; .

--- Chunk 223 ---
Tokens: 338
Type: sentence-based
Text:
Consider the following Java example: privateListMessageincomingMessageList; . incomingMessageListnewArrayListMessage(); ThevariableisdeclaredasaList,buttheactualvalueisanArrayList.Thiscode islegal,sinceListisasuperclassofArrayList,butitcanmisleadareaderwho seesthedeclarationbutnottheactualallocation.Theactualtypemayimpact how the variable is used (ArrayLists have different performance and thread- safety properties than other subclasses of List), so it is better to match the declarationwiththeallocation. Codethatviolatesreaderexpectations.Considerthefollowingcode,whichis themainprogramforaJavaapplication publicstaticvoidmain(Stringargs) . newRaftClient(myAddress,serverAddresses);  Mostapplicationsexitwhentheirmainprogramsreturn,soreadersarelikelyto assumethatwillhappenhere.However,thatisnotthecase.Theconstructorfor RaftClientcreatesadditionalthreads,whichcontinuetooperateeventhoughthe applicationsmainthreadfinishes.Thisbehaviorshouldbedocumentedinthe interface comment for the RaftClient constructor, but the behavior is nonobviousenoughthatitsworthputtingashortcommentattheendofmainas well.Thecommentshouldindicatethattheapplicationwillcontinueexecuting in other threads. Code is most obvious if it conforms to the conventions that readers will be expecting; if it doesnt, then its important to document the behaviorsoreadersarentconfused.

--- Chunk 224 ---
Tokens: 383
Type: sentence-based
Text:
Code is most obvious if it conforms to the conventions that readers will be expecting; if it doesnt, then its important to document the behaviorsoreadersarentconfused. 18.3Conclusion Anotherwayofthinkingaboutobviousnessisintermsofinformation.Ifcodeis nonobvious, that usually means there is important information about the code thatthereaderdoesnothave:intheRaftClientexample,thereadermightnot knowthattheRaftClientconstructorcreatednewthreads;inthePairexample, the reader might not know that result.getKey() returns the number of the currentterm. To make code obvious, you must ensure that readers always have the informationtheyneedtounderstandit.Youcandothisinthreeways.Thebest way is to reduce the amount of information that is needed, using design techniques such as abstraction and eliminating special cases. Second, you can take advantage of information that readers have already acquired in other contexts(forexample,byfollowingconventionsandconformingtoexpectations) so readers dont have to learn new information for your code. Third, you can presenttheimportantinformationtotheminthecode,usingtechniquessuchas goodnamesandstrategiccomments. Chapter19 SoftwareTrends As a way of illustrating the principles discussed in this book, this chapter considers several trends and patterns that have become popular in software developmentoverthelastfewdecades.Foreachtrend,Iwilldescribehowthat trend relates to the principles in this book and use the principles to evaluate whetherthattrendprovidesleverageagainstsoftwarecomplexity.

--- Chunk 225 ---
Tokens: 375
Type: sentence-based
Text:
Chapter19 SoftwareTrends As a way of illustrating the principles discussed in this book, this chapter considers several trends and patterns that have become popular in software developmentoverthelastfewdecades.Foreachtrend,Iwilldescribehowthat trend relates to the principles in this book and use the principles to evaluate whetherthattrendprovidesleverageagainstsoftwarecomplexity. 19.1Object-orientedprogrammingandinheritance Object-orientedprogrammingisoneofthemostimportantnewideasinsoftware development over the last 3040 years. It introduced notions such as classes, inheritance, private methods, and instance variables. If used carefully, these mechanismscanhelptoproducebettersoftwaredesigns.Forexample,private methodsandvariablescanbeusedtoensureinformationhiding:nocodeoutside aclasscaninvokeprivatemethodsoraccessprivatevariables,sotherecantbe anyexternaldependenciesonthem. One of the key elements of object-oriented programming is inheritance. Inheritancecomesintwoforms,whichhavedifferentimplicationsforsoftware complexity. The first form of inheritance is interface inheritance, in which a parent class defines the signatures for one or more methods, but does not implement the methods. Each subclass must implement the signatures, but different subclasses can implement the same methods in different ways. For example,theinterfacemightdefinemethodsforperformingIO;onesubclass mightimplementtheIOoperationsfordiskfiles,andanothersubclassmight implementthesameoperationsfornetworksockets.

--- Chunk 226 ---
Tokens: 376
Type: sentence-based
Text:
For example,theinterfacemightdefinemethodsforperformingIO;onesubclass mightimplementtheIOoperationsfordiskfiles,andanothersubclassmight implementthesameoperationsfornetworksockets. Interface inheritance provides leverage against complexity by reusing the same interface for multiple purposes. It allows knowledge acquired in solving oneproblem(suchashowtouseanIOinterfacetoreadandwritediskfiles)to beusedtosolveotherproblems(suchascommunicatingoveranetworksocket). Another way of thinking about this is in terms of depth: the more different implementationsthereareofaninterface,thedeepertheinterfacebecomes.In orderforaninterfacetohavemanyimplementations,itmustcapturetheessential featuresofalltheunderlyingimplementationswhilesteeringclearofthedetails thatdifferbetweentheimplementations;thisnotionisattheheartofabstraction. Thesecondformofinheritanceisimplementationinheritance.Inthisform,a parentclassdefinesnotonlysignaturesforoneormoremethods,butalsodefault implementations.Subclassescanchoosetoinherittheparentsimplementation ofamethodoroverrideitbydefininganewmethodwiththesamesignature. Without implementation inheritance, the same method implementation might need to be duplicated in several subclasses, which would create dependencies between those subclasses (modifications would need to be duplicated in all copiesofthemethod).Thus,implementationinheritancereducestheamountof codethatneedstobemodifiedasthesystemevolves;inotherwords,itreduces thechangeamplificationproblemdescribedinChapter2.

--- Chunk 227 ---
Tokens: 392
Type: sentence-based
Text:
Without implementation inheritance, the same method implementation might need to be duplicated in several subclasses, which would create dependencies between those subclasses (modifications would need to be duplicated in all copiesofthemethod).Thus,implementationinheritancereducestheamountof codethatneedstobemodifiedasthesystemevolves;inotherwords,itreduces thechangeamplificationproblemdescribedinChapter2. However, implementation inheritance creates dependencies between the parent class and each of its subclasses. Class instance variables in the parent class are often accessed by both the parent and child classes; this results in informationleakagebetweentheclassesintheinheritancehierarchyandmakesit hard to modify one class in the hierarchy without looking at the others. For example,adevelopermakingchangestotheparentclassmayneedtoexamineall ofthesubclassestoensurethatthechangesdontbreakanything.Similarly,ifa subclass overrides a method in the parent class, the developer of the subclass may need to examine the implementation in the parent. In the worst case, programmers will need complete knowledge of the entire class hierarchy underneaththeparentclassinordertomakechangestoanyoftheclasses.Class hierarchies that use implementation inheritance extensively tend to have high complexity. Thus,implementationinheritanceshouldbeusedwithcaution.Beforeusing implementationinheritance,considerwhetheranapproachbasedoncomposition can provide the same benefits. For instance, it may be possible to use small helper classes to implement the shared functionality.

--- Chunk 228 ---
Tokens: 380
Type: sentence-based
Text:
For instance, it may be possible to use small helper classes to implement the shared functionality. Rather than inheriting functionsfromaparent,theoriginalclassescaneachbuilduponthefeaturesof thehelperclasses. Ifthereisnoviablealternativetoimplementationinheritance,trytoseparate thestatemanagedbytheparentclassfromthatmanagedbysubclasses.Oneway todothisisforcertaininstancevariablestobemanagedentirelybymethodsin the parent class, with subclasses using them only in a read-only fashion or throughothermethodsintheparentclass.Thisappliesthenotionofinformation hidingwithintheclasshierarchytoreducedependencies. Although the mechanisms provided by object-oriented programming can assistinimplementingcleandesigns,theydonot,bythemselves,guaranteegood design.Forexample,ifclassesareshallow,orhavecomplexinterfaces,orpermit external access to their internal state, then they will still result in high complexity. 19.2Agiledevelopment Agiledevelopmentisanapproachtosoftwaredevelopmentthatemergedinthe late1990sfromacollectionofideasabouthowtomakesoftwaredevelopment more lightweight, flexible, and incremental; it was formally defined during a meetingofpractitionersin2001.Agiledevelopmentismostlyabouttheprocess ofsoftwaredevelopment(organizingteams,managingschedules,theroleofunit testing, interacting with customers, etc.) as opposed to software design. Nonetheless,itrelatestosomeofthedesignprinciplesinthisbook. Oneofthemostimportantelementsofagiledevelopmentisthenotionthat development should be incremental and iterative.

--- Chunk 229 ---
Tokens: 374
Type: sentence-based
Text:
Oneofthemostimportantelementsofagiledevelopmentisthenotionthat development should be incremental and iterative. In the agile approach, a softwaresystemisdevelopedinaseriesofiterations,eachofwhichaddsand evaluatesafewnewfeatures;eachiterationincludesdesign,test,andcustomer input.Ingeneral,thisissimilartotheincrementalapproachadvocatedhere.As mentioned in Chapter 1, it isnt possible to visualize a complex system well enoughattheoutsetofaprojecttodeterminethebestdesign.Thebestwayto end up with a good design is to develop a system in increments, where each incrementaddsafewnewabstractionsandrefactorsexistingabstractionsbased onexperience.Thisissimilartotheagiledevelopmentapproach. One of the risks of agile development is that it can lead to tactical programming. Agile development tends to focus developers on features, not abstractions,anditencouragesdeveloperstoputoffdesigndecisionsinorderto produce working software as soon as possible. For example, some agile practitioners argue that you shouldnt implement general-purpose mechanisms rightaway;implementaminimalspecial-purposemechanismtostartwith,and refactor into something more generic later, once you know that its needed. Although these arguments make sense to a degree, they argue against an investmentapproach,andtheyencourageamoretacticalstyleofprogramming. Thiscanresultinarapidaccumulationofcomplexity. Developing incrementally is generally a good idea, but the increments of development should be abstractions, not features.

--- Chunk 230 ---
Tokens: 377
Type: sentence-based
Text:
Developing incrementally is generally a good idea, but the increments of development should be abstractions, not features. Its fine to put off all thoughtsaboutaparticularabstractionuntilitsneededbyafeature.Onceyou need the abstraction,invest the time to design itcleanly;follow the advice of Chapter6andmakeitsomewhatgeneral-purpose. 19.3Unittests Itusedtobethatdevelopersrarelywrotetests.Iftestswerewrittenatall,they were written by a separate QA team. However, one of the tenets of agile developmentisthattestingshouldbetightlyintegratedwithdevelopment,and programmers should write tests for their own code. This practice has now become widespread. Tests are typically divided into two kinds: unit tests and systemtests.Unittestsaretheonesmostoftenwrittenbydevelopers.Theyare smallandfocused:eachtestusuallyvalidatesasmallsectionofcodeinasingle method. Unit tests can be run in isolation, without setting up a production environmentforthesystem.Unittestsareoftenruninconjunctionwithatest coverage tool to ensure that every line of code in the application is tested. Whenever developers write new code or modify existing code, they are responsibleforupdatingtheunitteststomaintainpropertestcoverage. Thesecondkindoftestconsistsofsystemtests(sometimescalledintegration tests),whichensurethatthedifferentpartsofanapplicationallworktogether properly. They typically involve running the entire application in a production environment. System tests are more likely to be written by a separate QA or testingteam.

--- Chunk 231 ---
Tokens: 400
Type: sentence-based
Text:
System tests are more likely to be written by a separate QA or testingteam. Tests, particularly unit tests, play an important role in software design becausetheyfacilitaterefactoring.Withoutatestsuite,itsdangeroustomake majorstructuralchangestoasystem.Theresnoeasywaytofindbugs,soits likelythatbugswillgoundetecteduntilthenewcodeisdeployed,wheretheyare muchmoreexpensivetofindandfix.Asaresult,developersavoidrefactoringin systems without good test suites; they try to minimize the number of code changes for each new feature or bug fix, which means that complexity accumulatesanddesignmistakesdontgetcorrected. Withagoodsetoftests,developerscanbemoreconfidentwhenrefactoring becausethetestsuitewillfindmostbugsthatareintroduced.Thisencourages developerstomakestructuralimprovementstoasystem,whichresultsinabetter design.Unittestsareparticularlyvaluable:theyprovideahigherdegreeofcode coveragethansystemtests,sotheyaremorelikelytouncoveranybugs. For example, during the development of the Tcl scripting language, we decidedtoimproveperformancebyreplacingTclsinterpreterwithabyte-code compiler.ThiswasahugechangethataffectedalmosteverypartofthecoreTcl engine.Fortunately,Tclhadanexcellentunittestsuite,whichweranonthenew byte-codeengine.Theexistingtestsweresoeffectiveinuncoveringbugsinthe newenginethatonlyasinglebugturnedupafterthealphareleaseofthebyte- codecompiler. 19.4Test-drivendevelopment Test-driven development is an approach to software development where programmerswriteunittestsbeforetheywritecode.Whencreatinganewclass, thedeveloperfirstwritesunittestsfortheclass,basedonitsexpectedbehavior.

--- Chunk 232 ---
Tokens: 392
Type: sentence-based
Text:
19.4Test-drivendevelopment Test-driven development is an approach to software development where programmerswriteunittestsbeforetheywritecode.Whencreatinganewclass, thedeveloperfirstwritesunittestsfortheclass,basedonitsexpectedbehavior. Noneofthetestspass,sincethereisnocodefortheclass.Thenthedeveloper worksthroughthetestsoneatatime,writingenoughcodeforthattesttopass. Whenallofthetestspass,theclassisfinished. AlthoughIamastrongadvocateofunittesting,Iamnotafanoftest-driven development. The problem with test-driven development is that it focuses attentionongettingspecificfeaturesworking,ratherthanfindingthebest design. This is tactical programming pure and simple, with all of its disadvantages.Test-drivendevelopmentistooincremental:atanypointintime, itstemptingtojusthackinthenextfeaturetomakethenexttestpass.Theresno obvioustimetododesign,soitseasytoendupwithamess. As mentioned in Section 19.2, the units of development should be abstractions,notfeatures.Onceyoudiscovertheneedforanabstraction,dont createtheabstractioninpiecesovertime;designitallatonce(oratleastenough toprovideareasonablycomprehensivesetofcorefunctions).Thisismorelikely toproduceacleandesignwhosepiecesfittogetherwell. Oneplacewhereitmakessensetowritethetestsfirstiswhenfixingbugs. Beforefixingabug,writeaunittestthatfailsbecauseofthebug.Thenfixthe bugandmakesurethattheunittestnowpasses.Thisisthebestwaytomake sureyoureallyhavefixedthebug.Ifyoufixthebugbeforewritingthetest,its possiblethatthenewunittestdoesntactuallytriggerthebug,inwhichcaseit wonttellyouwhetheryoureallyfixedtheproblem.

--- Chunk 233 ---
Tokens: 364
Type: sentence-based
Text:
Beforefixingabug,writeaunittestthatfailsbecauseofthebug.Thenfixthe bugandmakesurethattheunittestnowpasses.Thisisthebestwaytomake sureyoureallyhavefixedthebug.Ifyoufixthebugbeforewritingthetest,its possiblethatthenewunittestdoesntactuallytriggerthebug,inwhichcaseit wonttellyouwhetheryoureallyfixedtheproblem. 19.5Designpatterns Adesignpatternisacommonlyusedapproachforsolvingaparticularkindof problem,suchasaniteratororanobserver.Thenotionofdesignpatternswas popularizedbythebookDesignPatterns:ElementsofReusableObject-Oriented SoftwarebyGamma,Helm,Johnson,andVlissides,anddesignpatternsarenow widelyusedinobject-orientedsoftwaredevelopment. Design patterns represent an alternative to design: rather than designing a newmechanismfromscratch,justapplyawell-knowndesignpattern.Forthe most part, this is good: design patterns arose because they solve common problems,andbecausetheyaregenerallyagreedtoprovidecleansolutions.Ifa designpatternworkswellinaparticularsituation,itwillprobablybehardfor youtocomeupwithadifferentapproachthatisbetter. Thegreatestriskwithdesignpatternsisover-application.Noteveryproblem canbesolvedcleanlywithanexistingdesignpattern;donttrytoforceaproblem into a design pattern when a custom approach will be cleaner. Using design patternsdoesntautomaticallyimproveasoftwaresystem;itonlydoessoifthe designpatternsfit.Aswithmanyideasinsoftwaredesign,thenotionthatdesign patternsaregooddoesntnecessarilymeanthatmoredesignpatternsarebetter.

--- Chunk 234 ---
Tokens: 382
Type: sentence-based
Text:
Using design patternsdoesntautomaticallyimproveasoftwaresystem;itonlydoessoifthe designpatternsfit.Aswithmanyideasinsoftwaredesign,thenotionthatdesign patternsaregooddoesntnecessarilymeanthatmoredesignpatternsarebetter. 19.6Gettersandsetters In the Java programming community, getter andsetter methods are a popular designpattern.Agetterandasetterareassociatedwithaninstancevariablefora class.Theyhavenameslike getFooand setFoo,where Foo is the name of the variable. The getter method returns the current value of the variable, and the settermethodmodifiesthevalue. Gettersandsettersarentstrictlynecessary,sinceinstancevariablescanbe madepublic.Theargumentforgettersandsettersisthattheyallowadditional functions to be performed while getting and setting, such as updating related values when a variable changes, notifying listeners of changes, or enforcing constraintsonvalues.Evenifthesefeaturesarentneededinitially,theycanbe addedlaterwithoutchangingtheinterface. Although it may make sense to use getters and setters if you must expose instancevariables,itsbetternottoexposeinstancevariablesinthefirstplace. Exposed instance variables mean that part of the classs implementation is visibleexternally,whichviolatestheideaofinformationhidingandincreasesthe complexity of the classs interface. Getters and setters are shallow methods (typicallyonlyasingleline),sotheyaddcluttertotheclasssinterfacewithout providing much functionality. Its better to avoid getters and setters (or any exposureofimplementationdata)asmuchaspossible.

--- Chunk 235 ---
Tokens: 349
Type: sentence-based
Text:
Its better to avoid getters and setters (or any exposureofimplementationdata)asmuchaspossible. Oneoftherisksofestablishingadesignpatternisthatdevelopersassumethe patternisgoodandtrytouseitasmuchaspossible.Thishasledtooverusageof gettersandsettersinJava. 19.7Conclusion Wheneveryouencounteraproposalforanewsoftwaredevelopmentparadigm, challengeitfromthestandpointofcomplexity:doestheproposalreallyhelpto minimizecomplexityinlargesoftwaresystems?Manyproposalssoundgoodon thesurface,butifyoulookmoredeeplyyouwillseethatsomeofthemmake complexityworse,notbetter. Chapter20 DesigningforPerformance Upuntilthispoint,thediscussionofsoftwaredesignhasfocusedoncomplexity; thegoalhasbeentomakesoftwareassimpleandunderstandableaspossible. But what if you are working on a system that needs to be fast? How should performance considerations affect the design process? This chapter discusses how to achieve high performance without sacrificing clean design. The most important idea is still simplicity: not only does simplicity improve a systems design,butitusuallymakessystemsfaster. 20.1Howtothinkaboutperformance Thefirstquestiontoaddressishowmuchshouldyouworryaboutperformance duringthenormaldevelopmentprocess?Ifyoutrytooptimizeeverystatement for maximum speed, it will slow down development and create a lot of unnecessary complexity. Furthermore, many of the optimizations wont actually help performance.

--- Chunk 236 ---
Tokens: 352
Type: sentence-based
Text:
Furthermore, many of the optimizations wont actually help performance. On the other hand, if you completely ignore performance issues, its easy to end up with a large number of significant inefficienciesspreadthroughoutthecode;theresultingsystemcaneasilybe5 10xslowerthanitneedstobe.Inthisdeathbyathousandcutsscenarioits hardtocomebacklaterandimprovetheperformance,becausethereisnosingle improvementthatwillhavemuchimpact. Thebestapproachissomethingbetweentheseextremes,whereyouusebasic knowledge of performance to choose design alternatives that are naturally efficientyetalsocleanandsimple.Thekeyistodevelopanawarenessofwhich operationsarefundamentallyexpensive.Hereareafewexamplesofoperations thatarerelativelyexpensivetoday: Networkcommunication:evenwithinadatacenter,around-tripmessage exchangecantake1050s,whichistensofthousandsofinstructiontimes. Wide-arearound-tripscantake10100ms. IOtosecondarystorage:diskIOoperationstypicallytake510ms,which ismillionsofinstructiontimes.Flashstoragetakes10100s.New emergingnonvolatilememoriesmaybeasfastas1s,butthisisstill around2000instructiontimes. Dynamicmemoryallocation(mallocinC,newinCorJava)typically involvessignificantoverheadforallocation,freeing,andgarbagecollection. Cachemisses:fetchingdatafromDRAMintoanon-chipprocessorcache takesafewhundredinstructiontimes;inmanyprograms,overall performanceisdeterminedasmuchbycachemissesasbycomputational costs.

--- Chunk 237 ---
Tokens: 397
Type: sentence-based
Text:
Cachemisses:fetchingdatafromDRAMintoanon-chipprocessorcache takesafewhundredinstructiontimes;inmanyprograms,overall performanceisdeterminedasmuchbycachemissesasbycomputational costs. Thebestwaytolearnwhichthingsareexpensiveistorunmicro-benchmarks (smallprogramsthatmeasurethecostofasingleoperationinisolation).Inthe RAMCloudproject,wecreatedasimpleprogramthatprovidesaframeworkfor microbenchmarks.Ittookafewdaystocreatetheframework,buttheframework makesitpossibletoaddnewmicro-benchmarksinfiveortenminutes.Thishas allowed us to accumulate dozens of micro-benchmarks. We use these both to understandtheperformanceofexistinglibrariesusedinRAMCloud,andalsoto measuretheperformanceofnewclasseswrittenforRAMCloud. Onceyouhaveageneralsenseforwhatisexpensiveandwhatischeap,you canusethatinformationtochoosecheapoperationswheneverpossible.Inmany cases,amoreefficientapproachwillbejustassimpleasaslowerapproach.For example,whenstoringalargecollectionofobjectsthatwillbelookedupusinga key value, you could use either a hash table or an ordered map. Both are commonlyavailableinlibrarypackages,andbotharesimpleandcleantouse. However,hashtablescaneasilybe510xfaster.Thus,youshouldalwaysusea hashtableunlessyouneedtheorderingpropertiesprovidedbythemap. Asanotherexample,considerallocatinganarrayofstructuresinalanguage suchasCorC.Therearetwowaysyoucandothis.Onewayisforthearray toholdpointerstostructures,inwhichcaseyoumustfirstallocatespaceforthe array,thenallocatespaceforeachindividualstructure.Itismuchmoreefficient tostorethestructuresinthearrayitself,soyouonlyallocateonelargeblockfor everything.

--- Chunk 238 ---
Tokens: 333
Type: sentence-based
Text:
Asanotherexample,considerallocatinganarrayofstructuresinalanguage suchasCorC.Therearetwowaysyoucandothis.Onewayisforthearray toholdpointerstostructures,inwhichcaseyoumustfirstallocatespaceforthe array,thenallocatespaceforeachindividualstructure.Itismuchmoreefficient tostorethestructuresinthearrayitself,soyouonlyallocateonelargeblockfor everything. If the only way to improve efficiency is by adding complexity, then the choiceismoredifficult.Ifthemoreefficientdesignaddsonlyasmallamountof complexity,andifthecomplexityishidden,soitdoesntaffectanyinterfaces, thenitmaybeworthwhile(butbeware:complexityisincremental).Ifthefaster design adds a lot of implementation complexity, or if it results in more complicated interfaces, then it may be better to start off with the simpler approachandoptimizelaterifperformanceturnsouttobeaproblem.However, if you have clear evidence that performance will be important in a particular situation,thenyoumightaswellimplementthefasterapproachimmediately. IntheRAMCloudprojectoneofouroverallgoalswastoprovidethelowest possible latency for client machines accessing the storage system over a datacenter network. As a result, we decided to use special hardware for networking,whichallowedRAMCloudtobypassthekernelandcommunicate directly with the network interface controller to send and receive packets.

--- Chunk 239 ---
Tokens: 371
Type: sentence-based
Text:
As a result, we decided to use special hardware for networking,whichallowedRAMCloudtobypassthekernelandcommunicate directly with the network interface controller to send and receive packets. We madethisdecisioneventhoughitaddedcomplexity,becauseweknewfromprior measurements that kernel-based networking would be too slow to meet our needs.InmostoftherestoftheRAMCloudsystemwewereabletodesignfor simplicity;gettingthisonebigissuerightmademanyotherthingseasier. Ingeneral,simplercodetendstorunfasterthancomplexcode.Ifyouhave definedawayspecialcasesandexceptions,thennocodeisneededtocheckfor those cases and the system runs faster. Deep classes are more efficient than shallowones,becausetheygetmoreworkdoneforeachmethodcall.Shallow classesresultinmorelayercrossings,andeachlayercrossingaddsoverhead. 20.2Measurebeforemodifying Butsupposethatyoursystemisstilltooslow,eventhoughyouhavedesignedit as described above. Its tempting to rush off and start making performance tweaks,basedonyourintuitionsaboutwhatisslow.Dontdothis!Programmers intuitions about performance are unreliable. This is true even for experienced developers.Ifyoustartmakingchangesbasedonintuition,youllwastetimeon things that dont actually improve performance, and youll probably make the systemmorecomplicatedintheprocess. Before making any changes, measure the systems existing behavior. This serves two purposes. First, the measurements will identify the places where performance tuning will have the biggest impact.

--- Chunk 240 ---
Tokens: 332
Type: sentence-based
Text:
First, the measurements will identify the places where performance tuning will have the biggest impact. It isnt sufficient just to measurethetop-levelsystemperformance.Thismaytellyouthatthesystemis tooslow,butitwonttellyouwhy.Youllneedtomeasuredeepertoidentifyin detailthefactorsthatcontributetooverallperformance;thegoalistoidentifya smallnumberofveryspecificplaceswherethesystemiscurrentlyspendingalot oftime,andwhereyouhaveideasforimprovement.Thesecondpurposeofthe measurementsistoprovideabaseline,sothatyoucanre-measureperformance aftermakingyourchangestoensurethatperformanceactuallyimproved.Ifthe changesdidntmakeameasurabledifferenceinperformance,thenbackthemout (unlesstheymadethesystemsimpler).Theresnopointinretainingcomplexity unlessitprovidesasignificantspeedup. 20.3Designaroundthecriticalpath Atthispoint,letsassumethatyouhavecarefullyanalyzedperformanceandhave identified a piece of code that is slow enough to affect the overall system performance.Thebestwaytoimproveitsperformanceiswithafundamental change,suchasintroducingacache,orusingadifferentalgorithmicapproach (balanced tree vs. list, for instance). Our decision to bypass the kernel for networkcommunicationinRAMCloudisanexampleofafundamentalfix.If youcanidentifyafundamentalfix,thenyoucanimplementitusingthedesign techniquesdiscussedinpreviouschapters.

--- Chunk 241 ---
Tokens: 361
Type: sentence-based
Text:
Our decision to bypass the kernel for networkcommunicationinRAMCloudisanexampleofafundamentalfix.If youcanidentifyafundamentalfix,thenyoucanimplementitusingthedesign techniquesdiscussedinpreviouschapters. Unfortunately, situations will sometimes arise where there isnt a fundamentalfix.Thisbringsustothecoreissueforthischapter,whichishowto redesignanexistingpieceofcodesothatitrunsfaster.Thisshouldbeyourlast resort,anditshouldnthappenoften,buttherearecaseswhereitcanmakeabig difference.Thekeyideaistodesignthecodearoundthecriticalpath. Startoffbyaskingyourselfwhatisthesmallestamountofcodethatmustbe executedtocarryoutthedesiredtaskinthecommoncase.Disregardanyexisting code structure. Imagine instead that you are writing a new method that implements just the critical path, which is the minimum amount of code that mustbeexecutedinthethemostcommoncase.Thecurrentcodeisprobably clutteredwithspecialcases;ignoretheminthisexercise.Thecurrentcodemight passthroughseveralmethodcallsonthecriticalpath;imagineinsteadthatyou couldputalltherelevantcodeinasinglemethod.Thecurrentcodemayalsouse avarietyofvariablesanddatastructures;consideronlythedataneededforthe critical path, and assume whatever data structure is most convenient for the criticalpath.Forexample,itmaymakesensetocombinemultiplevariablesinto asinglevalue.Assumethatyoucouldcompletelyredesignthesysteminorderto minimizethecodethatmustbeexecutedforthecriticalpath.Letscallthiscode theideal.

--- Chunk 242 ---
Tokens: 360
Type: sentence-based
Text:
Imagine instead that you are writing a new method that implements just the critical path, which is the minimum amount of code that mustbeexecutedinthethemostcommoncase.Thecurrentcodeisprobably clutteredwithspecialcases;ignoretheminthisexercise.Thecurrentcodemight passthroughseveralmethodcallsonthecriticalpath;imagineinsteadthatyou couldputalltherelevantcodeinasinglemethod.Thecurrentcodemayalsouse avarietyofvariablesanddatastructures;consideronlythedataneededforthe critical path, and assume whatever data structure is most convenient for the criticalpath.Forexample,itmaymakesensetocombinemultiplevariablesinto asinglevalue.Assumethatyoucouldcompletelyredesignthesysteminorderto minimizethecodethatmustbeexecutedforthecriticalpath.Letscallthiscode theideal. Theidealcodeprobablyclasheswithyourexistingclassstructure,anditmay notbepractical,butitprovidesagoodtarget:thisrepresentsthesimplestand fastestthatthecodecaneverbe.Thenextstepistolookforanewdesignthat comesascloseaspossibletotheidealwhilestillhavingacleanstructure.You canapplyallofthedesignideasfrompreviouschaptersofthisbook,butwith theadditionalconstraintofkeepingtheidealcode(mostly)intact.Youmayhave toaddabitofextracodetotheidealinordertoallowcleanabstractions;for example,ifthecodeinvolvesahashtablelookup,itsOKtointroduceanextra methodcalltoageneral-purposehashtableclass.Inmyexperienceitsalmost alwayspossibletofindadesignthatiscleanandsimple,yetcomesverycloseto theideal.

--- Chunk 243 ---
Tokens: 382
Type: sentence-based
Text:
Theidealcodeprobablyclasheswithyourexistingclassstructure,anditmay notbepractical,butitprovidesagoodtarget:thisrepresentsthesimplestand fastestthatthecodecaneverbe.Thenextstepistolookforanewdesignthat comesascloseaspossibletotheidealwhilestillhavingacleanstructure.You canapplyallofthedesignideasfrompreviouschaptersofthisbook,butwith theadditionalconstraintofkeepingtheidealcode(mostly)intact.Youmayhave toaddabitofextracodetotheidealinordertoallowcleanabstractions;for example,ifthecodeinvolvesahashtablelookup,itsOKtointroduceanextra methodcalltoageneral-purposehashtableclass.Inmyexperienceitsalmost alwayspossibletofindadesignthatiscleanandsimple,yetcomesverycloseto theideal. Oneofthemostimportantthingsthathappensinthisprocessistoremove specialcasesfromthecriticalpath.Whencodeisslow,itsoftenbecauseitmust handle a variety of situations, and the code gets structured to simplify the handlingofallthedifferentcases.Eachspecialcaseaddsalittlebitofcodeto thecriticalpath,intheformofextraconditionalstatementsandormethodcalls. Each of these additions makes the code a bit slower. When redesigning for performance, try to minimize the number of special cases you must check. Ideally,therewillbeasingle ifstatementatthebeginning,whichdetectsall specialcaseswithonetest.Inthenormalcase,onlythisonetestwillneedtobe made,afterwhichthethecriticalpathcanbeexecutedwithnoadditionaltests forspecialcases.Iftheinitialtestfails(whichmeansaspecialcasehasoccurred) the code can branch to a separate place off the critical path to handle it.

--- Chunk 244 ---
Tokens: 352
Type: sentence-based
Text:
Ideally,therewillbeasingle ifstatementatthebeginning,whichdetectsall specialcaseswithonetest.Inthenormalcase,onlythisonetestwillneedtobe made,afterwhichthethecriticalpathcanbeexecutedwithnoadditionaltests forspecialcases.Iftheinitialtestfails(whichmeansaspecialcasehasoccurred) the code can branch to a separate place off the critical path to handle it. Performanceisntasimportantforspecialcases,soyoucanstructurethespecial- casecodeforsimplicityratherthanperformance. 20.4Anexample:RAMCloudBuffers Letsconsideranexample,inwhichtheBufferclassoftheRAMCloudstorage systemwasoptimizedtoachieveaspeedupofabout2xforthemostcommon operations. RAMCloudusesBufferobjectstomanagevariable-lengtharraysofmemory, suchasrequestandresponsemessagesforremoteprocedurecalls.Buffersare designed to reduce overheads from memory copying and dynamic storage allocation. A Buffer stores what appears to be a linear array of bytes, but for efficiency it allows the underlying storage to be divided into multiple discontiguouschunksofmemory,asshowninFigure20.1.ABufferiscreated by appending chunks of data. Each chunk is either external or internal. If a chunkisexternal,itsstorageisownedbythecaller;theBufferkeepsareference tothisstorage.Externalchunksaretypicallyusedforlargechunksinorderto avoidmemorycopies.Ifachunkisinternal,theBufferownsthestorageforthe chunk; data suppliedby the caller is copied into theBuffersinternal storage.

--- Chunk 245 ---
Tokens: 353
Type: sentence-based
Text:
If a chunkisexternal,itsstorageisownedbythecaller;theBufferkeepsareference tothisstorage.Externalchunksaretypicallyusedforlargechunksinorderto avoidmemorycopies.Ifachunkisinternal,theBufferownsthestorageforthe chunk; data suppliedby the caller is copied into theBuffersinternal storage. Each Buffer contains a small built-inallocation, which is a block of memory availableforstoringinternalchunks.Ifthisspaceisexhausted,thentheBuffer createsadditionalallocations,whichmustbefreedwhentheBufferisdestroyed. Internal chunks are convenient for small chunks where the memory copying costsarenegligible.Figure20.1showsaBufferwith5chunks:thefirstchunkis internal,thenexttwoareexternal,andthefinaltwochunksareinternal. Figure20.1:ABufferobjectusesacollectionofmemorychunkstostorewhatappearstobealineararray ofbytes.InternalchunksareownedbytheBufferandfreedwhentheBufferisdestroyed;externalchunks arenotownedbytheBuffer. TheBufferclassitselfrepresentsafundamentalfix,inthatiteliminates expensivememorycopiesthatwouldhavebeenrequiredwithoutit.Forexample, whenassemblingaresponsemessagecontainingashortheaderandthecontents of a large object in the RAMCloud storage system, RAMCloud uses a Buffer withtwochunks.Thefirstchunkisaninternalonethatcontainstheheader;the second chunk is an external one that refers to the object contents in the RAMCloudstoragesystem.TheresponsecanbecollectedintheBufferwithout copyingthelargeobject.

--- Chunk 246 ---
Tokens: 379
Type: sentence-based
Text:
TheBufferclassitselfrepresentsafundamentalfix,inthatiteliminates expensivememorycopiesthatwouldhavebeenrequiredwithoutit.Forexample, whenassemblingaresponsemessagecontainingashortheaderandthecontents of a large object in the RAMCloud storage system, RAMCloud uses a Buffer withtwochunks.Thefirstchunkisaninternalonethatcontainstheheader;the second chunk is an external one that refers to the object contents in the RAMCloudstoragesystem.TheresponsecanbecollectedintheBufferwithout copyingthelargeobject. Asidefromthefundamentalapproachofallowingdiscontiguouschunks,we did not attempt to optimize the code of the Buffer class in the original implementation.Overtime,however,wenoticedBuffersbeingusedinmoreand more situations; for example, at least four Buffers are created during the execution of each remote procedure call. Eventually, it became clear that speeding up the implementation of Buffer could have a noticeable impact on overall system performance. We decided to see if we could improve the performanceoftheBufferclass. The most common operation for Buffer is to allocate space for a small amountofnewdatausinganinternalchunk.Thishappens,forexample,when creating headers for request and response messages. We decided to use this operationasthecriticalpathforoptimization.Inthesimplestpossiblecase,the space can be allocated by enlarging the last existing chunk in the Buffer. However,thisisonlypossibleifthelastexistingchunkisinternal,andifthereis enough space in its allocation to accommodate the new data.

--- Chunk 247 ---
Tokens: 381
Type: sentence-based
Text:
However,thisisonlypossibleifthelastexistingchunkisinternal,andifthereis enough space in its allocation to accommodate the new data. The ideal code wouldperformasinglechecktoconfirmthatthesimpleapproachispossible, thenitwouldadjustthesizeoftheexistingchunk. Figure20.2showstheoriginalcodeforthecriticalpath,whichstartswiththe methodBuffer:alloc.Inthefastestpossiblecase,Buffer:alloccallsBuffer: allocateAppend, which calls Buffer:Allocation:allocateAppend. From a performancestandpoint,thiscodehastwoproblems.Thefirstproblemisthat numerousspecialcasesarecheckedindividually: Buffer:allocateAppendcheckstoseeiftheBuffercurrentlyhasany allocations. Thecodecheckstwicetoseeifthecurrentallocationhasenoughroomfor thenewdata:onceinBuffer:Allocation:allocateAppend,andagain whenitsreturnvalueistestedbyBuffer:allocateAppend. Buffer:allocteststhereturnvaluefromBuffer:allocAppendtoconfirm yetagainthattheallocationsucceeded. Furthermore, rather than trying to expand the last chunk directly, the code allocates new space without any consideration of the last chunk. Then Buffer:alloc checks to see if that space happens to be adjacent to the last chunk, in which case it merges the new space with the existing chunk. This resultsinadditionalchecks.Overall,thiscodetests6distinctconditionsinthe criticalpath. Thesecondproblemwiththeoriginalcodeisthatithastoomanylayers,all ofwhichareshallow.Thisisbothaperformanceproblemandadesignproblem. Thecriticalpathmakestwoadditionalmethodcallsinadditiontotheoriginal invocation of Buffer:alloc.

--- Chunk 248 ---
Tokens: 366
Type: sentence-based
Text:
Thecriticalpathmakestwoadditionalmethodcallsinadditiontotheoriginal invocation of Buffer:alloc. Each method call takes additional time, and the resultofeachcallmustbecheckedbyitscaller,whichresultsinmorespecial casestoconsider.Chapter7discussedhowabstractionsshouldnormallychange asyoupassfromonelayertoanother,butallthreeofthemethodsinFigure20.2 haveidenticalsignaturesandtheyprovideessentiallythesameabstraction;thisis a red flag. Buffer:allocateAppend is nearly a pass-though method; its only contributionistocreateanewallocationifneeded.Theextralayersmakethe codebothslowerandmorecomplicated. To fix these problems, we refactored the Buffer class so that its design is centeredaroundthemostperformance-criticalpaths.Weconsiderednotjustthe allocation code above but several other commonly executed paths, such as retrievingthetotalnumberofbytesofdatacurrentlystoredinaBuffer.Foreach ofthesecriticalpaths,wetriedtoidentifythesmallestamountofcodethatmust beexecutedinthecommoncase.Thenwedesignedtherestoftheclassaround these critical paths. We also applied the design principles from this book to simplify the class in general. For example, we eliminated shallow layers and createddeeperinternalabstractions.Therefactoredclassis20smallerthanthe originalversion(1476linesofcode,versus1886linesintheoriginal). Figure20.2:TheoriginalcodeforallocatingnewspaceattheendofaBuffer,usinganinternalchunk. Figure20.3:ThenewcodeforallocatingnewspaceinaninternalchunkofaBuffer.

--- Chunk 249 ---
Tokens: 359
Type: sentence-based
Text:
Figure20.3:ThenewcodeforallocatingnewspaceinaninternalchunkofaBuffer. Figure 20.3 shows the new critical path for allocating internal space in a Buffer.Thenewcodeisnotonlyfaster,butitisalsoeasiertoread,sinceitavoids shallowabstractions.Theentirepathishandledinasinglemethod,anditusesa singletesttoruleoutallofthespecialcases.Thenewcodeintroducesanew instancevariable,extraAppendBytes,inordertosimplifythecriticalpath.This variablekeepstrackofhowmuchunusedspaceisavailableimmediatelyafterthe lastchunkintheBuffer.Ifthereisnospaceavailable,orifthelastchunkinthe Bufferisntaninternalchunk,oriftheBuffercontainsnochunksatall,then extraAppendBytesiszero.ThecodeinFigure20.3representstheleastpossible amountofcodetohandlethiscommoncase. Note:theupdatetototalLengthcouldhavebeeneliminatedbyrecomputing the total Buffer length from the individual chunks whenever it is needed. However,thisapproachwouldbeexpensiveforalargeBufferwithmanychunks, and fetching the total Buffer length is another common operation. Thus, we chosetoaddasmallamountofextraoverheadtoallocinordertoensurethatthe Bufferlengthisalwaysimmediatelyavailable. Thenewcodeisabouttwiceasfastastheoldcode:thetotaltimetoappenda 1-bytestringtoaBufferusinginternalstoragedroppedfrom8.8nsto4.75ns. Many other Buffer operations also speeded up because of the revisions. For example,thetimetoconstructanewBuffer,appendasmallchunkininternal storage,anddestroytheBufferdroppedfrom24nsto12ns.

--- Chunk 250 ---
Tokens: 376
Type: sentence-based
Text:
For example,thetimetoconstructanewBuffer,appendasmallchunkininternal storage,anddestroytheBufferdroppedfrom24nsto12ns. 20.5Conclusion Themostimportantoveralllessonfromthischapteristhatcleandesignandhigh performancearecompatible.TheBufferclassrewriteimproveditsperformance by a factor of 2 while simplifying its design and reducing code size by 20. Complicated code tends to be slow because it does extraneous or redundant work. On the other hand, if you write clean, simple code, your system will probablybefastenoughthatyoudonthavetoworrymuchaboutperformancein thefirstplace.Inthefewcaseswhereyoudoneedtooptimizeperformance,the key is simplicity again: find the critical paths that are most important for performanceandmakethemassimpleaspossible. Chapter21 Conclusion Thisbookisaboutonething:complexity.Dealingwithcomplexityisthemost importantchallengeinsoftwaredesign.Itiswhatmakessystemshardtobuild andmaintain,anditoftenmakesthemslowaswell.Overthecourseofthebook I have tried to describe the root causes that lead to complexity, such as dependenciesandobscurity.Ihavediscussedredflagsthatcanhelpyouidentify unnecessarycomplexity,suchasinformationleakage,unneedederrorconditions, ornamesthataretoogeneric.Ihavepresentedsomegeneralideasyoucanuseto createsimplersoftwaresystems,suchasstrivingforclassesthataredeepand generic,definingerrorsoutofexistence,andseparatinginterfacedocumentation from implementation documentation. And, finally, I have discussed the investmentmindsetneededtoproducesimpledesigns.

--- Chunk 251 ---
Tokens: 382
Type: sentence-based
Text:
And, finally, I have discussed the investmentmindsetneededtoproducesimpledesigns. Thedownsideofallthesesuggestionsisthattheycreateextraworkinthe earlystagesofaproject.Furthermore,ifyouarentusedtothinkingaboutdesign issues, then you will slow down even more while you learn good design techniques. If the only thing that matters to you is making your current code workassoonaspossible,thenthinkingaboutdesignwillseemlikedrudgework thatisgettinginthewayofyourrealgoal. Ontheotherhand,ifgooddesignisanimportantgoalforyou,thentheideas inthisbookshouldmakeprogrammingmorefun.Designisafascinatingpuzzle: howcanaparticularproblembesolvedwiththesimplestpossiblestructure?Its funtoexploredifferentapproaches,anditsagreatfeelingtodiscoverasolution that is both simple and powerful. A clean, simple, and obvious design is a beautifulthing. Furthermore,theinvestmentsyoumakeingooddesignwillpayoffquickly. Themodulesyoudefinedcarefullyatthebeginningofaprojectwillsaveyou timelaterasyoureusethemoverandover.Thecleardocumentationthatyou wrotesixmonthsagowillsaveyoutimewhenyoureturntothecodetoadda newfeature.Thetimeyouspenthoningyourdesignskillswillalsopayforitself: as your skills and experience grow, you will find that you can produce good designs more and more quickly. Good design doesnt really take much longer thanquick-and-dirtydesign,onceyouknowhow. Therewardforbeingagooddesigneristhatyougettospendalargerfraction ofyourtimeinthedesignphase,whichisfun.Poordesignersspendmostof their time chasing bugs in complicated and brittle code.

--- Chunk 252 ---
Tokens: 81
Type: sentence-based
Text:
Therewardforbeingagooddesigneristhatyougettospendalargerfraction ofyourtimeinthedesignphase,whichisfun.Poordesignersspendmostof their time chasing bugs in complicated and brittle code. If you improve your designskills,notonlywillyouproducehigherqualitysoftwaremorequickly,but thesoftwaredevelopmentprocesswillbemoreenjoyable.

--- Chunk 253 ---
Tokens: 924
Type: sentence-based
Text:
If you improve your designskills,notonlywillyouproducehigherqualitysoftwaremorequickly,but thesoftwaredevelopmentprocesswillbemoreenjoyable. Index abstraction,21 aggregatingexceptions,82 agiledevelopment,2,153 changeamplification,7,99 classinterfacecomment,110 classitis,26 codingstyle,141 cognitiveload,7,43,99 comments asdesigntool,131 benefits,98 canaryinthecoalmine,131 conventionsfor,102 duplication,138 forintuition,107 forprecision,105 implementation,116 interface,110 nearcode,137 obsolete,98 procrastination,129 repeatingcode,103 roleinabstraction,101 worthless,98 writingbeforecode,129 complexity causesof,9 definition,5 incrementalnatureof,11,161 pullingdownwards,55,82 symptoms,7 composition,152 configurationparameters,56 conjoinedmethods,71 consistency,141,146 contextobject,51 cross-moduledesigndecisions,117 decorator,49 deepmodule,22 defaults,36 dependency,9 designittwice,91 designpatterns,142,156 designNotesfile,118,139 diskIO,160 dispatcher,47 dotherightthing,36 editortextclassexample,40,50,56 event-drivenprogramming,148 example linkedlist,25 examples configurationparameters,56 editortextclass,40,50,56,91 filedataloss,121 filedeletion,79 HTTPparameters,34 HTTPresponse,36 HTTPserver,32,60 IndexLookup,112 JavaIO,26,49,61 Javasubstring,80 missingparameter,82 NFSservercrash,81 non-existentselection,87 outofmemory,86 RAMCloudBuffer,163 RAMClouderrorpromotion,85 RAMCloudStatus,117 selectioncursor,65 Tclunset,78 undo,67 UnixIO,23 Websitecolors,7 exception,75 aggregation,82 masking,81 Facebook,17 falseabstraction,22,43 fence,forundo,69 filedatalossexample,121 filedeletionexample,79 filedescriptor,23 flashstorage,160 garbagecollection,160 general-purposeclass,40,66 general-purposecode,62,67 genericcontainers,149 getter,156 globalvariable,51 Golanguage,126 shortnamesin,126 Google,17 HTTPparametersexample,34 HTTPresponseexample,36 HTTPserverexample,32,60 implementation,19,50 implementationdocumentation,116 implementationinheritance,152 incrementaldevelopment,2,39 IndexLookupexample,112 informationhiding,29 informationleakage,30 inheritance,151 integrationtests,154 interface,19,50 formalparts,20 informalparts,21 interfacecomment class,110 method,110 interfacedocumentation,110 interfaceinheritance,151 invariants,142 investmentmindset,15,128,136,144 JavaIOexample,26,49,61 Javasubstringexample,80 linkedlistexample,25 longmethod,70 maskingexceptions,81 memoryallocation,dynamic,160 methodinterfacecomment,110 micro-benchmark,160 missingparameterexample,82 modulardesign,2,19 module,20 names consistency,126,141 generic,123 howtochoose,121 makingcodemoreobvious,146 precise,123 shortnamesinGo,126 networkcommunication,160 NFSservercrashexample,81 non-existentselectionexample,87 nonvolatilememory,160 object-orientedprogramming,151 obscurity,10,145 obviouscode,9,145 outofmemoryexample,86 Parnas,David,29 pass-throughmethod,46 pass-throughvariable,50 performance micro-benchmark,160 performance,designingfor,159 privatevariables,30 RAMCloudBufferexample,163 RAMClouderrorpromotionexample,85 RAMCloudStatusexample,117 selectioncursorexample,65 self-documentingcode,96 setter,156 shallowmodule,25 smallclasses,26 special-purposecode,62,67 specification,formal,21 strategicprogramming,14,135 style,coding,141 substringexample(Java),80 systemtests,154 tacticalprogramming,13,135,153 tacticaltornado,14 Tclunsetexample,78 temporaldecomposition,31 test-drivendevelopment,155 tests integration,154 system,154 unit,154 tryblock,77 undoexample,67 unittests,154 UnixIOexample,23 unknownunknowns,8,99 URLencoding,34 VMware,17 waterfallmodel,2 Websitecolorsexample,7 whitespace,146 SummaryofDesignPrinciples Herearethemostimportantsoftwaredesignprinciplesdiscussedinthisbook: 1.

--- Chunk 254 ---
Tokens: 904
Type: sentence-based
Text:
Index abstraction,21 aggregatingexceptions,82 agiledevelopment,2,153 changeamplification,7,99 classinterfacecomment,110 classitis,26 codingstyle,141 cognitiveload,7,43,99 comments asdesigntool,131 benefits,98 canaryinthecoalmine,131 conventionsfor,102 duplication,138 forintuition,107 forprecision,105 implementation,116 interface,110 nearcode,137 obsolete,98 procrastination,129 repeatingcode,103 roleinabstraction,101 worthless,98 writingbeforecode,129 complexity causesof,9 definition,5 incrementalnatureof,11,161 pullingdownwards,55,82 symptoms,7 composition,152 configurationparameters,56 conjoinedmethods,71 consistency,141,146 contextobject,51 cross-moduledesigndecisions,117 decorator,49 deepmodule,22 defaults,36 dependency,9 designittwice,91 designpatterns,142,156 designNotesfile,118,139 diskIO,160 dispatcher,47 dotherightthing,36 editortextclassexample,40,50,56 event-drivenprogramming,148 example linkedlist,25 examples configurationparameters,56 editortextclass,40,50,56,91 filedataloss,121 filedeletion,79 HTTPparameters,34 HTTPresponse,36 HTTPserver,32,60 IndexLookup,112 JavaIO,26,49,61 Javasubstring,80 missingparameter,82 NFSservercrash,81 non-existentselection,87 outofmemory,86 RAMCloudBuffer,163 RAMClouderrorpromotion,85 RAMCloudStatus,117 selectioncursor,65 Tclunset,78 undo,67 UnixIO,23 Websitecolors,7 exception,75 aggregation,82 masking,81 Facebook,17 falseabstraction,22,43 fence,forundo,69 filedatalossexample,121 filedeletionexample,79 filedescriptor,23 flashstorage,160 garbagecollection,160 general-purposeclass,40,66 general-purposecode,62,67 genericcontainers,149 getter,156 globalvariable,51 Golanguage,126 shortnamesin,126 Google,17 HTTPparametersexample,34 HTTPresponseexample,36 HTTPserverexample,32,60 implementation,19,50 implementationdocumentation,116 implementationinheritance,152 incrementaldevelopment,2,39 IndexLookupexample,112 informationhiding,29 informationleakage,30 inheritance,151 integrationtests,154 interface,19,50 formalparts,20 informalparts,21 interfacecomment class,110 method,110 interfacedocumentation,110 interfaceinheritance,151 invariants,142 investmentmindset,15,128,136,144 JavaIOexample,26,49,61 Javasubstringexample,80 linkedlistexample,25 longmethod,70 maskingexceptions,81 memoryallocation,dynamic,160 methodinterfacecomment,110 micro-benchmark,160 missingparameterexample,82 modulardesign,2,19 module,20 names consistency,126,141 generic,123 howtochoose,121 makingcodemoreobvious,146 precise,123 shortnamesinGo,126 networkcommunication,160 NFSservercrashexample,81 non-existentselectionexample,87 nonvolatilememory,160 object-orientedprogramming,151 obscurity,10,145 obviouscode,9,145 outofmemoryexample,86 Parnas,David,29 pass-throughmethod,46 pass-throughvariable,50 performance micro-benchmark,160 performance,designingfor,159 privatevariables,30 RAMCloudBufferexample,163 RAMClouderrorpromotionexample,85 RAMCloudStatusexample,117 selectioncursorexample,65 self-documentingcode,96 setter,156 shallowmodule,25 smallclasses,26 special-purposecode,62,67 specification,formal,21 strategicprogramming,14,135 style,coding,141 substringexample(Java),80 systemtests,154 tacticalprogramming,13,135,153 tacticaltornado,14 Tclunsetexample,78 temporaldecomposition,31 test-drivendevelopment,155 tests integration,154 system,154 unit,154 tryblock,77 undoexample,67 unittests,154 UnixIOexample,23 unknownunknowns,8,99 URLencoding,34 VMware,17 waterfallmodel,2 Websitecolorsexample,7 whitespace,146 SummaryofDesignPrinciples Herearethemostimportantsoftwaredesignprinciplesdiscussedinthisbook: 1. Complexityisincremental:youhavetosweatthesmallstuff(seep.11).

--- Chunk 255 ---
Tokens: 392
Type: sentence-based
Text:
Complexityisincremental:youhavetosweatthesmallstuff(seep.11). 2. Workingcodeisntenough(seep.14). 3. Makecontinualsmallinvestmentstoimprovesystemdesign(seep.15). 4. Modulesshouldbedeep(seep.22) 5. Interfacesshouldbedesignedtomakethemostcommonusageassimpleas possible(seep.27). 6. Itsmoreimportantforamoduletohaveasimpleinterfacethanasimple implementation(seepp.55,71). 7. General-purposemodulesaredeeper(seep.39). 8. Separategeneral-purposeandspecial-purposecode(seep.62). 9. Differentlayersshouldhavedifferentabstractions(seep.45). 10. Pullcomplexitydownward(seep.55). 11. Defineerrors(andspecialcases)outofexistence(seep.79). 12. Designittwice(seep.91). 13. Commentsshoulddescribethingsthatarenotobviousfromthecode(seep. 101). 14. Softwareshouldbedesignedforeaseofreading,noteaseofwriting(seep. 149). 15. Theincrementsofsoftwaredevelopmentshouldbeabstractions,not features(seep.154). SummaryofRedFlags Hereareafewofofthemostimportantredflagsdiscussedinthisbook.The presenceofanyofthesesymptomsinasystemsuggeststhatthereisaproblem withthesystemsdesign: ShallowModule:theinterfaceforaclassormethodisntmuchsimplerthanits implementation(seepp.25,110). InformationLeakage:adesigndecisionisreflectedinmultiplemodules(seep. 31). Temporal Decomposition: the code structure is based on the order in which operationsareexecuted,notoninformationhiding(seep.32). Overexposure:AnAPIforcescallerstobeawareofrarelyusedfeaturesinorder tousecommonlyusedfeatures(seep.36). Pass-ThroughMethod:amethoddoesalmostnothingexceptpassitsarguments toanothermethodwithasimilarsignature(seep.46).

--- Chunk 256 ---
Tokens: 355
Type: sentence-based
Text:
Pass-ThroughMethod:amethoddoesalmostnothingexceptpassitsarguments toanothermethodwithasimilarsignature(seep.46). Repetition:anontrivialpieceofcodeisrepeatedoverandover(seep.62). Special-GeneralMixture:special-purpose codeis not cleanly separatedfrom generalpurposecode(seep.65). ConjoinedMethods:twomethodshavesomanydependenciesthatitshardto understandtheimplementationofonewithoutunderstandingtheimplementation oftheother(seep.72). CommentRepeatsCode:alloftheinformationinacommentisimmediately obviousfromthecodenexttothecomment(seep.104). Implementation Documentation Contaminates Interface: an interface comment describes implementation details not needed by users of the thing beingdocumented(seep.114). VagueName:thenameofavariableormethodissoimprecisethatitdoesnt conveymuchusefulinformation(seep.123). HardtoPickName:itisdifficulttocomeupwithapreciseandintuitivename foranentity(seep.125). HardtoDescribe:inordertobecomplete,thedocumentationforavariableor methodmustbelong.(seep.131). Nonobvious Code: the behavior or meaning of a piece of code cannot be understoodeasily.(seep.148). AbouttheAuthor JohnOusterhoutistheBosackLernerProfessorofComputerScienceatStanford University.HeisthecreatoroftheTclscriptinglanguageandisalsowellknown for his work in distributed operating systems and storage systems. Ousterhout receivedaBSdegreeinPhysicsfromYaleUniversityandaPhDinComputer Science from Carnegie Mellon University.

--- Chunk 257 ---
Tokens: 94
Type: sentence-based
Text:
Ousterhout receivedaBSdegreeinPhysicsfromYaleUniversityandaPhDinComputer Science from Carnegie Mellon University. He is a member of the National AcademyofEngineeringandhasreceivednumerousawards,includingtheACM SoftwareSystemAward,theACMGraceMurrayHopperAward,theNational Science Foundation Presidential Young Investigator Award, and the U.C. BerkeleyDistinguishedTeachingAward.

================================================================================
SOURCE: design-principles4.pdf
TOTAL CHUNKS: 27
================================================================================

--- Chunk 0 ---
Tokens: 363
Type: sentence-based
Text:
Software Design Principles and Guidelines Douglas C. Schmidt d.schmidtvanderbilt.edu Vanderbilt University, St. Louis www.cs.wustl.eduschmidt May 25, 2003 Design Principles Design Principles and Guidelines Overview                                 Design Principles  Important design concepts  Useful design principles  Development Methodologies  Traditional approaches  Agile programming  Design Guidelines  Motivation  Common Design Mistakes  Design Rules 1 Design Principles Motivation: Goals of the Design Phase (12)                         Decompose system into components  i.e, identify the software architecture  Determine relationships between components  e.g, identify component dependencies  Determine intercomponent communication mechanisms  e.g, globals, function calls, shared memory, IPCRPC 2 Design Principles Motivation: Goals of the Design Phase (22)            Specify component interfaces  Interfaces should be well-dened  Facilitates component testing and team communication  Describe component functionality  e.g, informally or formally  Identify opportunities for systematic reuse  Both top-down and bottom-up 3 Design Principles Macro Steps in the Design Process  In the design process the orientation moves from  Customer to developer  What to how  Macro steps include: 1. Preliminary Design  External design describes the real-world model  Architectural design decomposes the requirement specication into software subsystems 2.

--- Chunk 1 ---
Tokens: 397
Type: sentence-based
Text:
Preliminary Design  External design describes the real-world model  Architectural design decomposes the requirement specication into software subsystems 2. Detailed Design  Specify each subsystem  Further decomposed subsystems, if necessary 4 Design Principles Micro Steps in the Design Process  Given a requirements spec, design is an iterative decision process with the following general steps: 1. List the hard decisions and decisions likely to change 2. Design a component specication to hide each such decision  Make decisions that apply to whole program family rst  Modularize most likely changes rst  Then modularize remaining difcult decisions and decisions likely to change  Design the uses hierarchy as you do this (include reuse decisions) 3. Treat each higher-level component as a specication and apply above process to each 4. Continue rening until all design decisions are:  hidden in a component  contain easily comprehensible components  provide individual, independent, low-level implementation assignments 5 Design Principles Example: Designing a Web Server                                         www.cs.wustl.edujxh research  Web server design decisions  Portability issues  IO demuxing and concurrency  HTTP protocol processing  File access  Web server components  Event dispatcher  Protocol handler  Cached virtual lesystem 6 Design Principles Key Design Concepts and Principles Key design concepts and design principles include: 1. Decomposition 2. Abstraction and information hiding 3. Component modularity 4. Extensibility 5. Virtual machine architectures 6.

--- Chunk 2 ---
Tokens: 338
Type: sentence-based
Text:
Virtual machine architectures 6. Hierarchical relationships 7. Program families and subsets Main goal of these concepts and principles is to:  Manage software system complexity  Improve software quality factors  Facilitate systematic reuse  Resolve common design challenges 7 Design Principles Challenge 1: Determining the Web Server Architecture  Context: A large and complex production web server  Problems:  Designing the web server as a large monolithic entity is tedious and error-prone  Web server developers must work concurrently to improve productivity  Portability and resuability are important quality factors 8 Design Principles Solution: Decomposition  Decomposition handles complexity by splitting large problems into smaller problems  This divide and conquer concept is common to all life-cycle processes and design techniques  Basic methodology: 1. Select a piece of the problem (initially, the whole problem) 2. Determine the components in this piece using a design paradigm, e.g, functional, structured, object-oriented, generic, etc. 3. Describe the components interactions 4. Repeat steps 1 through 3 until some termination criteria is met  e.g, customer is satised, run out of timemoney, etc. ;-) 9 Design Principles Decomposition Example: Web Server Framework Pipes and filters Component configurator Component configurator  home.

--- Chunk 3 ---
Tokens: 254
Type: sentence-based
Text:
;-) 9 Design Principles Decomposition Example: Web Server Framework Pipes and filters Component configurator Component configurator  home. Protocol handler Protocol filter Protocol pipeline framework Concurrency strategy framework Tilde expander Cached virtual filesystem IO strategy framework Adapter Active object Strategy State Acceptor Asynchronous completion token Memento ReactorProactor Strategy Singleton State Event dispatcher  Features  High-performance  Flexible concurrency, demuxing, and caching mechanisms  Uses frameworks based on ACE www.cs.wustl.eduschmidtPDFJAWS.pdf 10 Design Principles Object-Oriented Decomposition Principles 1. Dont design components to correspond to execution steps  Since design decisions usually transcend execution time 2. Decompose so as to limit the effect of any one design decision on the rest of the system  Anything that permeates the system will be expensive to change 3. Components should be specied by all information needed to use the component  and nothing more!

--- Chunk 4 ---
Tokens: 282
Type: sentence-based
Text:
Components should be specied by all information needed to use the component  and nothing more! 11 Design Principles Challenge 2: Implementing a Flexible Web Server  Context: The requirements that a production web server must meet will change over time, e.g:  New platforms  New compilers  New functionality  New performance goals  Problems:  If the web server is hard coded using low-level system calls it will be hard to port  If web server developers write software thats tightly coupled with internal implementation details the software will be hard to evolve 12 Design Principles Solution: Abstraction          Abstraction manages complexity by emphasizing essential characteristics and suppressing implementation details  Allows postponement of certain design decisions that occur at various levels of analysis, e.g,  Representational and algorithmic considerations  Architectural and structural considerations  External environment and platform considerations 13 Design Principles Common Types of Abstraction 1. Procedural abstraction  e.g, closed subroutines 2. Data abstraction  e.g, ADT classes and component models 3.

--- Chunk 5 ---
Tokens: 155
Type: sentence-based
Text:
Data abstraction  e.g, ADT classes and component models 3. Control abstraction  e.g, loops, iterators, frameworks, and multitasking                        14 Design Principles Information Hiding  Information hiding is an important means of achieving abstraction  i.e, design decisions that are subject to change should be hidden behind abstract interfaces  Application software should communicate only through well-dened interfaces  Each interface should be specied by as little information as possible  If internal details change, clients should be minimally affected  May not even require recompilation and relinking.

--- Chunk 6 ---
Tokens: 913
Type: sentence-based
Text:
Control abstraction  e.g, loops, iterators, frameworks, and multitasking                        14 Design Principles Information Hiding  Information hiding is an important means of achieving abstraction  i.e, design decisions that are subject to change should be hidden behind abstract interfaces  Application software should communicate only through well-dened interfaces  Each interface should be specied by as little information as possible  If internal details change, clients should be minimally affected  May not even require recompilation and relinking. 15 Design Principles Typical Information to be Hidden  Data representations  i.e, using abstract data types  Algorithms  e.g, sorting or searching techniques  Input and Output Formats  Machine dependencies, e.g, byte-ordering, character codes  Lower-level interfaces  e.g, ordering of low-level operations, i.e, process sequence  Separating policy and mechanism  Multiple policies can be implemented by same mechanisms  e.g, OS scheduling and virtual memory paging  Same policy can be implemented by multiple mechanisms  e.g, reliable communication service can be provided by multiple protocols 16 Design Principles Information Hiding Example: Message Queueing                                A Message_Queue is a list of ACE_Message_Blocks  Efciently handles arbitrarily-large message payloads  Design encapsulates and parameterizes various aspects  e.g, synchronization, memory allocators, and reference counting can be added transparently 17 Design Principles The ACE_Message_Block Class  base_ : char   refcnt_ : int ACE_Data_Block ACE_Message_Block  init (size : size_t) : int  msg_type (type : ACE_Message_Type)  msg_type () : ACE_Message_Type  msg_priority (prio : u_long)  msg_priority () : u_long  clone () : ACE_Message_Block   duplicate () : ACE_Message_Block   release () : ACE_Message_Block   set_flags (flags : u_long) : u_long  clr_flags (flags : u_long) : u_long  copy (buf : const char ,n : size_t) : int  rd_ptr (n : size_t)  rd_ptr () : char   wr_ptr (n : size_t)  wr_ptr () : char   length () : size_t  total_length () : size_t  size () : size_t  rd_ptr_ : size_t  wr_ptr_ : size_t  cont_ : ACE_Message_Block   next_ : ACE_Message_Block   prev_ : ACE_Message_Block   data_block_ : ACE_Data_Block   1 Class characteristics  Hide messaging implementations from clients                          18 Design Principles The ACE_Message_Queue Class  ACE_Message_Queue (high_water_mark : size_t  DEFAULT_HWM, low_water_mark : size_t  DEFAULT_LWM, notify : ACE_Notification_Strategy   0)  open (high_water_mark : size_t  DEFAULT_HWM, low_water_mark : size_t  DEFAULT_LWM, notify : ACE_Notification_Strategy   0) : int  flush () : int  notification_strategy (s : ACE_Notification_Strategy ) : void  is_empty () : int  is_full () : int  enqueue_tail (item : ACE_Message_Block , timeout : ACE_Time_Value   0) : int  enqueue_head (item : ACE_Message_Block , timeout : ACE_Time_Value   0) : int  enqueue_prio (item : ACE_Message_Block , timeout : ACE_Time_Value   0) : int  dequeue_head (item : ACE_Message_Block , timeout : ACE_Time_Value   0) : int  dequeue_tail (item : ACE_Message_Block , timeout : ACE_Time_Value   0) : int  high_water_mark (new_hwm : size_t) : void  high_water_mark (void) : size_t  low_water_mark (new_lwm : size_t) : void  low_water_mark (void) : size_t  close () : int  deactivate () : int  activate () : int  pulse () : int  state () : int  head_ : ACE_Message_Block   tail_ : ACE_Message_Block   high_water_mark_ : size_t  low_water_mark_ : size_t ACE_Message_Queue SYNCH_STRATEGY Class characteristics  Note how the synchronization aspect can be strategized!

--- Chunk 7 ---
Tokens: 1194
Type: sentence-based
Text:
15 Design Principles Typical Information to be Hidden  Data representations  i.e, using abstract data types  Algorithms  e.g, sorting or searching techniques  Input and Output Formats  Machine dependencies, e.g, byte-ordering, character codes  Lower-level interfaces  e.g, ordering of low-level operations, i.e, process sequence  Separating policy and mechanism  Multiple policies can be implemented by same mechanisms  e.g, OS scheduling and virtual memory paging  Same policy can be implemented by multiple mechanisms  e.g, reliable communication service can be provided by multiple protocols 16 Design Principles Information Hiding Example: Message Queueing                                A Message_Queue is a list of ACE_Message_Blocks  Efciently handles arbitrarily-large message payloads  Design encapsulates and parameterizes various aspects  e.g, synchronization, memory allocators, and reference counting can be added transparently 17 Design Principles The ACE_Message_Block Class  base_ : char   refcnt_ : int ACE_Data_Block ACE_Message_Block  init (size : size_t) : int  msg_type (type : ACE_Message_Type)  msg_type () : ACE_Message_Type  msg_priority (prio : u_long)  msg_priority () : u_long  clone () : ACE_Message_Block   duplicate () : ACE_Message_Block   release () : ACE_Message_Block   set_flags (flags : u_long) : u_long  clr_flags (flags : u_long) : u_long  copy (buf : const char ,n : size_t) : int  rd_ptr (n : size_t)  rd_ptr () : char   wr_ptr (n : size_t)  wr_ptr () : char   length () : size_t  total_length () : size_t  size () : size_t  rd_ptr_ : size_t  wr_ptr_ : size_t  cont_ : ACE_Message_Block   next_ : ACE_Message_Block   prev_ : ACE_Message_Block   data_block_ : ACE_Data_Block   1 Class characteristics  Hide messaging implementations from clients                          18 Design Principles The ACE_Message_Queue Class  ACE_Message_Queue (high_water_mark : size_t  DEFAULT_HWM, low_water_mark : size_t  DEFAULT_LWM, notify : ACE_Notification_Strategy   0)  open (high_water_mark : size_t  DEFAULT_HWM, low_water_mark : size_t  DEFAULT_LWM, notify : ACE_Notification_Strategy   0) : int  flush () : int  notification_strategy (s : ACE_Notification_Strategy ) : void  is_empty () : int  is_full () : int  enqueue_tail (item : ACE_Message_Block , timeout : ACE_Time_Value   0) : int  enqueue_head (item : ACE_Message_Block , timeout : ACE_Time_Value   0) : int  enqueue_prio (item : ACE_Message_Block , timeout : ACE_Time_Value   0) : int  dequeue_head (item : ACE_Message_Block , timeout : ACE_Time_Value   0) : int  dequeue_tail (item : ACE_Message_Block , timeout : ACE_Time_Value   0) : int  high_water_mark (new_hwm : size_t) : void  high_water_mark (void) : size_t  low_water_mark (new_lwm : size_t) : void  low_water_mark (void) : size_t  close () : int  deactivate () : int  activate () : int  pulse () : int  state () : int  head_ : ACE_Message_Block   tail_ : ACE_Message_Block   high_water_mark_ : size_t  low_water_mark_ : size_t ACE_Message_Queue SYNCH_STRATEGY Class characteristics  Note how the synchronization aspect can be strategized! 19 Design Principles Challenge 3: Determining the Units of Web Server Decomposition  Context: A production web server that uses abstraction and information hiding  Problems:  Need to determine the appropriate units of decomposition, which should  Possess well-specied abstract interfaces and  Have high cohesion and low coupling 20 Design Principles Solution: Component Modularity            A modular system is one thats structured into identiable abstractions called components  A software entity that represents an abstraction  A work assignment for developers  A unit of code that  has one or more names  has identiable boundaries  can be (re-)used by other components  encapsulates data  hides unnecessary details  can be separately compiled 21 Design Principles Designing Component Interfaces  A component interface consists of several types of ports:  Exports  Services provided to other components, e.g, facets and event sources  Imports  Services requested from other components, e.g, receptacles and event sinks  Access Control  Not all clients are equal, e.g, protectedprivatepublic            Dene components that provide multiple interfaces and implementations  Anticipate change 22 Design Principles Component Modularity Example: Stream Processing                         A Stream allows exible conguration of layered processing modules  A Stream component contains a stack of Module components  Each Module contains two Task components  i.e, read and write Tasks  Each Task contains a Message Queue component and a Thread Manager component 23 Design Principles Benets of Component Modularity Modularity facilitates software quality factors, e.g:  Extensibility !

--- Chunk 8 ---
Tokens: 433
Type: sentence-based
Text:
19 Design Principles Challenge 3: Determining the Units of Web Server Decomposition  Context: A production web server that uses abstraction and information hiding  Problems:  Need to determine the appropriate units of decomposition, which should  Possess well-specied abstract interfaces and  Have high cohesion and low coupling 20 Design Principles Solution: Component Modularity            A modular system is one thats structured into identiable abstractions called components  A software entity that represents an abstraction  A work assignment for developers  A unit of code that  has one or more names  has identiable boundaries  can be (re-)used by other components  encapsulates data  hides unnecessary details  can be separately compiled 21 Design Principles Designing Component Interfaces  A component interface consists of several types of ports:  Exports  Services provided to other components, e.g, facets and event sources  Imports  Services requested from other components, e.g, receptacles and event sinks  Access Control  Not all clients are equal, e.g, protectedprivatepublic            Dene components that provide multiple interfaces and implementations  Anticipate change 22 Design Principles Component Modularity Example: Stream Processing                         A Stream allows exible conguration of layered processing modules  A Stream component contains a stack of Module components  Each Module contains two Task components  i.e, read and write Tasks  Each Task contains a Message Queue component and a Thread Manager component 23 Design Principles Benets of Component Modularity Modularity facilitates software quality factors, e.g:  Extensibility ! well-dened, abstract interfaces  Reusability !

--- Chunk 9 ---
Tokens: 243
Type: sentence-based
Text:
well-dened, abstract interfaces  Reusability ! low-coupling, high-cohesion  Compatibility ! design bridging interfaces  Portability ! hide machine dependencies Modularity is important for good designs since it:  Enhances for separation of concerns  Enables developers to reduce overall system complexity via decentralized software architectures  Increases scalability by supporting independent and concurrent development by multiple personnel 24 Design Principles Criteria for Evaluating Modular Designs Component decomposability  Are larger components decomposed into smaller components? Component composability  Are larger components composed from existing smaller components? Component understandability  Are components separately understandable? Component continuity  Do small changes to the specication affect a localized and limited number of components? Component protection  Are the effects of run-time abnormalities conned to a small number of related components?

--- Chunk 10 ---
Tokens: 388
Type: sentence-based
Text:
Component protection  Are the effects of run-time abnormalities conned to a small number of related components? 25 Design Principles Principles for Ensuring Modular Designs Language support for components  Components should correspond to syntactic units in the language Few interfaces  Every component should communicate with as few others as possible Small interfaces (weak coupling)  If any two components communicate at all, they should exchange as little information as possible Explicit Interfaces  Whenever two components A and B communicate, this must be obvious from the text of A or B or both Information Hiding  All information about a component should be private unless its specically declared public 26 Design Principles Challenge 4: Future Proong the Web Server  Context: A production web server whose requirements will change over time  Problems:  Certain design aspects seem constant until they are examined in the overall structure of an application  Developers must be able to easily refactor the web server to account for new sources of variation 27 Design Principles Solution: Extensibility  Extensible software is important to support successions of quick updates and additions to address new requirements and take advantage of emerging opportunitiesmarkets  Extensible components must be both open and closed, i.e, the openclosed principle:  Open component ! still available for extension  This is necessary since the requirements and specications are rarely completely understood from the systems inception  Closed component !

--- Chunk 11 ---
Tokens: 495
Type: sentence-based
Text:
still available for extension  This is necessary since the requirements and specications are rarely completely understood from the systems inception  Closed component ! available for use by other components  This is necessary since code sharing becomes unmanageable when reopening a component triggers many changes 28 Design Principles Extensibility Example: Active Object Tasks                                           Features  Tasks can register with a Reactor  They can be dynamically linked  They can queue data  They can run as active objects  JAWS uses inheritance and dynamic binding to produce task components that are both open and closed 29 Design Principles Challenge 5: Separating Concerns for Layered Systems  Context: A production web server whose requirements will change over time  Problems:  To enhance reuse and exibility, it is often necessary to decompose a web server into smaller, more manageable units that are layered in order to  Enhance reuse, e.g, multiple higher-layer services can share lower-layer services  Transparently and incrementally enhancement functionality  Improve performance by allowing the selective omission of unnecessary service functionality  Improve implementations, testing, and maintenance 30 Design Principles Solution: Virtual Machine Architectures  A virtual machine provides an extended software instruction set  Extensions provide additional data types and associated software instructions  Modeled after hardware instruction set primitives that work on a limited set of data types  A virtual machine layer provides a set of operations that are useful in developing a family of similar systems                                                         31 Design Principles Virtual Machine Layers for the ACE Toolkit                                                                                    www.cs.wustl.eduschmidtACE.html 32 Design Principles Other Examples of Virtual Machines Computer architectures  e.g, compiler !

--- Chunk 12 ---
Tokens: 456
Type: sentence-based
Text:
available for use by other components  This is necessary since code sharing becomes unmanageable when reopening a component triggers many changes 28 Design Principles Extensibility Example: Active Object Tasks                                           Features  Tasks can register with a Reactor  They can be dynamically linked  They can queue data  They can run as active objects  JAWS uses inheritance and dynamic binding to produce task components that are both open and closed 29 Design Principles Challenge 5: Separating Concerns for Layered Systems  Context: A production web server whose requirements will change over time  Problems:  To enhance reuse and exibility, it is often necessary to decompose a web server into smaller, more manageable units that are layered in order to  Enhance reuse, e.g, multiple higher-layer services can share lower-layer services  Transparently and incrementally enhancement functionality  Improve performance by allowing the selective omission of unnecessary service functionality  Improve implementations, testing, and maintenance 30 Design Principles Solution: Virtual Machine Architectures  A virtual machine provides an extended software instruction set  Extensions provide additional data types and associated software instructions  Modeled after hardware instruction set primitives that work on a limited set of data types  A virtual machine layer provides a set of operations that are useful in developing a family of similar systems                                                         31 Design Principles Virtual Machine Layers for the ACE Toolkit                                                                                    www.cs.wustl.eduschmidtACE.html 32 Design Principles Other Examples of Virtual Machines Computer architectures  e.g, compiler ! assembler !

--- Chunk 13 ---
Tokens: 17
Type: sentence-based
Text:
assembler ! obj code ! microcode ! gates, transistors, signals, etc.

--- Chunk 14 ---
Tokens: 555
Type: sentence-based
Text:
gates, transistors, signals, etc. Operating systems  e.g, Linux Hardware Machine Software Virtual Machine instruction set set of system calls restartable instructions restartable system calls interruptstraps signals interrupttrap handlers signal handlers blocking interrupts masking signals interrupt stack signal stack Java Virtual Machine (JVM)  Abstracts away from details of the underlying OS 33 Design Principles Challenge 6: Separating Concerns for Hierarchical Systems  Context: A production web server whose requirements will change over time  Problems:  Developers need to program components at different levels of abstraction independently  Changes to one set of components should be isolated as much as possible from other components  Need to be able to visualize the structure of the web server design 34 Design Principles Solution: Hierarchical Relationships  Hierarchies reduce component interactions by restricting the topology of relationships  A relation denes a hierarchy if it partitions units into levels (note connection to virtual machine architectures)  Level 0 is the set of all units that use no other units  Level i is the set of all units that use at least one unit at level  i and no unit at level  i.  Hierarchies form the basis of architectures and designs  Facilitates independent development  Isolates ramications of change  Allows rapid prototyping 35 Design Principles Hierarchy Example: JAWS Architecture                          36 Design Principles Dening Hierarchies  Relations that dene hierarchies include:  Uses  Is-Composed-Of  Is-A  Has-A  The rst two are general to all design methods, the latter two are more particular to OO design and programming ACE_IPC_SAP ACE_Addr ACE_SOCK_IO ACE_SOCK ACE_SOCK_Acceptor ACE_INET_Addr ACE_SOCK_Stream ACE_SOCK_Connector 37 Design Principles The Uses Relation (13)    X Uses Y if the correct functioning of X depends on the availability of a correct implementation of Y  Note, uses is not necessarily the same as invokes:  Some invocations are not uses  e.g, error logging  Some uses dont involve invocations  e.g, message passing, interrupts, shared memory access  A uses relation does not necessarily yield a hierarchy (avoid cycles.)

--- Chunk 15 ---
Tokens: 666
Type: sentence-based
Text:
Operating systems  e.g, Linux Hardware Machine Software Virtual Machine instruction set set of system calls restartable instructions restartable system calls interruptstraps signals interrupttrap handlers signal handlers blocking interrupts masking signals interrupt stack signal stack Java Virtual Machine (JVM)  Abstracts away from details of the underlying OS 33 Design Principles Challenge 6: Separating Concerns for Hierarchical Systems  Context: A production web server whose requirements will change over time  Problems:  Developers need to program components at different levels of abstraction independently  Changes to one set of components should be isolated as much as possible from other components  Need to be able to visualize the structure of the web server design 34 Design Principles Solution: Hierarchical Relationships  Hierarchies reduce component interactions by restricting the topology of relationships  A relation denes a hierarchy if it partitions units into levels (note connection to virtual machine architectures)  Level 0 is the set of all units that use no other units  Level i is the set of all units that use at least one unit at level  i and no unit at level  i.  Hierarchies form the basis of architectures and designs  Facilitates independent development  Isolates ramications of change  Allows rapid prototyping 35 Design Principles Hierarchy Example: JAWS Architecture                          36 Design Principles Dening Hierarchies  Relations that dene hierarchies include:  Uses  Is-Composed-Of  Is-A  Has-A  The rst two are general to all design methods, the latter two are more particular to OO design and programming ACE_IPC_SAP ACE_Addr ACE_SOCK_IO ACE_SOCK ACE_SOCK_Acceptor ACE_INET_Addr ACE_SOCK_Stream ACE_SOCK_Connector 37 Design Principles The Uses Relation (13)    X Uses Y if the correct functioning of X depends on the availability of a correct implementation of Y  Note, uses is not necessarily the same as invokes:  Some invocations are not uses  e.g, error logging  Some uses dont involve invocations  e.g, message passing, interrupts, shared memory access  A uses relation does not necessarily yield a hierarchy (avoid cycles.) 38 Design Principles The Uses Relation (23)  Allow X to use Y when:  X is simpler because it uses Y  e.g, Standard C library classes  Y is not substantially more complex because it is not allowed to use X  There is a useful subset containing Y and not X  i.e, allows sharing and reuse of Y  There is no conceivably useful subset containing X but not Y  i.e, Y is necessary for X to function correctly  Uses relationships can exist between classes, frameworks, subsystems, etc.

--- Chunk 16 ---
Tokens: 214
Type: sentence-based
Text:
38 Design Principles The Uses Relation (23)  Allow X to use Y when:  X is simpler because it uses Y  e.g, Standard C library classes  Y is not substantially more complex because it is not allowed to use X  There is a useful subset containing Y and not X  i.e, allows sharing and reuse of Y  There is no conceivably useful subset containing X but not Y  i.e, Y is necessary for X to function correctly  Uses relationships can exist between classes, frameworks, subsystems, etc. Acceptor- Connector Reactor Proactor Service Configurator Streams Task 39 Design Principles The Uses Relation (33)  A hierarchy in the uses relation is essential for designing reusable software systems  However, certain software systems require controlled violation of a uses hierarchy  e.g, asynchronous communication protocols, OO callbacks in frameworks, signal handling, etc.

--- Chunk 17 ---
Tokens: 683
Type: sentence-based
Text:
Acceptor- Connector Reactor Proactor Service Configurator Streams Task 39 Design Principles The Uses Relation (33)  A hierarchy in the uses relation is essential for designing reusable software systems  However, certain software systems require controlled violation of a uses hierarchy  e.g, asynchronous communication protocols, OO callbacks in frameworks, signal handling, etc. Upcalls are one way to control these non-hierarchical dependencies  Rule of thumb:  Start with an invocation hierarchy and eliminate those invocations (i.e, calls) that are not uses relationships 40 Design Principles The Is-Composed-Of Relation  The is-composed-of relationship shows how the system is broken down in components  X is-composed-of fx i g if X is a group of components x i that share some common purpose  The following diagram illustrates some of the is-composed-of relationships in JAWS                  41 Design Principles The Is-Composed-Of Relation  Many programming languages support the is-composed-of relation via some higher-level component or record structuring technique  However, the following are not equivalent:  level (virtual machine)  component (an entity that hides one or more secrets)  a subprogram (a code unit)  Components and levels need not be identical, as a component may appear in several levels of a uses hierarchy 42 Design Principles The Is-A Relation  This ancestordescendant relationship is associated with object-oriented design and programming languages that possess inheritance and dynamic binding  class X possesses Is-A relationship with class Y if instances of class X are specialization of class Y.  e.g, an HTTP_1_0_Handler Is-A ACE_Event_Handler that is specialized for processing HTTP 1.0 requests        43 Design Principles The Has-A Relation  This client relationship is associated with object-oriented design and programming languages that possess classes and objects  class X possesses a Has-A relationship with class Y if instances of class X contain an instance(s) of class Y.  e.g, the JAWS web server Has-A Reactor, HTTP_Acceptor, and CV_Filesytem        44 Design Principles Challenge 7: Enabling Expansion and Contraction of Software  Context: A production web server whose requirements will change over time  Problems:  It may be necessary to reduce the overall functionality of the server to run in resource-constrained environments  To meet externally imposed schedules, it may be necessary to release the server without all the features enabled 45 Design Principles Solution: Program Families and Subsets  This principle should be applied to facilitate extension and contraction of large-scale software systems, particularly reusable middleware infrastructure  e.g, JAWS, ACE, etc.

--- Chunk 18 ---
Tokens: 848
Type: sentence-based
Text:
Upcalls are one way to control these non-hierarchical dependencies  Rule of thumb:  Start with an invocation hierarchy and eliminate those invocations (i.e, calls) that are not uses relationships 40 Design Principles The Is-Composed-Of Relation  The is-composed-of relationship shows how the system is broken down in components  X is-composed-of fx i g if X is a group of components x i that share some common purpose  The following diagram illustrates some of the is-composed-of relationships in JAWS                  41 Design Principles The Is-Composed-Of Relation  Many programming languages support the is-composed-of relation via some higher-level component or record structuring technique  However, the following are not equivalent:  level (virtual machine)  component (an entity that hides one or more secrets)  a subprogram (a code unit)  Components and levels need not be identical, as a component may appear in several levels of a uses hierarchy 42 Design Principles The Is-A Relation  This ancestordescendant relationship is associated with object-oriented design and programming languages that possess inheritance and dynamic binding  class X possesses Is-A relationship with class Y if instances of class X are specialization of class Y.  e.g, an HTTP_1_0_Handler Is-A ACE_Event_Handler that is specialized for processing HTTP 1.0 requests        43 Design Principles The Has-A Relation  This client relationship is associated with object-oriented design and programming languages that possess classes and objects  class X possesses a Has-A relationship with class Y if instances of class X contain an instance(s) of class Y.  e.g, the JAWS web server Has-A Reactor, HTTP_Acceptor, and CV_Filesytem        44 Design Principles Challenge 7: Enabling Expansion and Contraction of Software  Context: A production web server whose requirements will change over time  Problems:  It may be necessary to reduce the overall functionality of the server to run in resource-constrained environments  To meet externally imposed schedules, it may be necessary to release the server without all the features enabled 45 Design Principles Solution: Program Families and Subsets  This principle should be applied to facilitate extension and contraction of large-scale software systems, particularly reusable middleware infrastructure  e.g, JAWS, ACE, etc. Program families are natural way to detect and implement subsets  Minimize footprints for embedded systems  Promotes system reusability  Anticipates potential changes  Heuristics for identifying subsets:  Analyze requirements to identify minimally useful subsets  Also identify minimal increments to subsets 46 Design Principles Example of Program Families: JAWS and TAO (1) THE ACE ORB (TAO) NETWORK REAL-TIME ORB CORE ACE components IOP IOP PLUGGABLE ORB  XPORT PROTOCOLS PLUGGABLE ORB  XPORT PROTOCOLS REAL-TIME IO SUBSYSTEM HIGH-SPEED NETWORK INTERFACE OS KERNEL REAL-TIME IO SUBSYSTEM HIGH-SPEED NETWORK INTERFACE OS KERNEL ORB RUN-TIME SCHEDULER IDL SKELETON IDL STUBS operation () out args  return value OBJECT (SERVANT) in args REAL-TIME OBJECT ADAPTER CLIENT OBJ REF (2) The JAWS Web Server Framework Service Configurator Strategy Strategy Singleton State State Acceptor Pipes and Filters Active Object Adapter Service Configurator Event Dispatcher Concurrency Strategy Framework Protocol Handler Protocol Filter Tilde Expander home.

--- Chunk 19 ---
Tokens: 488
Type: sentence-based
Text:
Program families are natural way to detect and implement subsets  Minimize footprints for embedded systems  Promotes system reusability  Anticipates potential changes  Heuristics for identifying subsets:  Analyze requirements to identify minimally useful subsets  Also identify minimal increments to subsets 46 Design Principles Example of Program Families: JAWS and TAO (1) THE ACE ORB (TAO) NETWORK REAL-TIME ORB CORE ACE components IOP IOP PLUGGABLE ORB  XPORT PROTOCOLS PLUGGABLE ORB  XPORT PROTOCOLS REAL-TIME IO SUBSYSTEM HIGH-SPEED NETWORK INTERFACE OS KERNEL REAL-TIME IO SUBSYSTEM HIGH-SPEED NETWORK INTERFACE OS KERNEL ORB RUN-TIME SCHEDULER IDL SKELETON IDL STUBS operation () out args  return value OBJECT (SERVANT) in args REAL-TIME OBJECT ADAPTER CLIENT OBJ REF (2) The JAWS Web Server Framework Service Configurator Strategy Strategy Singleton State State Acceptor Pipes and Filters Active Object Adapter Service Configurator Event Dispatcher Concurrency Strategy Framework Protocol Handler Protocol Filter Tilde Expander home. ReactorProactor Memento IO Strategy Framework Cached Virtual Filesystem Protocol Pipeline Framework Asynchronous Completon Token  TAO is a high-performance, real-time implementation of the CORBA specication  JAWS is a high-performance, adaptive Web server that implements the HTTP specication  JAWS and TAO were developed using the wrapper facades and frameworks provided by the ACE toolkit 47 Design Principles Other Examples of Program Families and Subsets  Different services for different markets  e.g, different alphabets, different vertical applications, different IO formats  Different hardware or software platforms  e.g, compilers or OSs  Different resource trade-offs  e.g, speed vs space  Different internal resources  e.g, shared data structures and library routines  Different external events  e.g, UNIX IO device interface  Backward compatibility  e.g, sometimes it is important to retain bugs!

--- Chunk 20 ---
Tokens: 921
Type: sentence-based
Text:
ReactorProactor Memento IO Strategy Framework Cached Virtual Filesystem Protocol Pipeline Framework Asynchronous Completon Token  TAO is a high-performance, real-time implementation of the CORBA specication  JAWS is a high-performance, adaptive Web server that implements the HTTP specication  JAWS and TAO were developed using the wrapper facades and frameworks provided by the ACE toolkit 47 Design Principles Other Examples of Program Families and Subsets  Different services for different markets  e.g, different alphabets, different vertical applications, different IO formats  Different hardware or software platforms  e.g, compilers or OSs  Different resource trade-offs  e.g, speed vs space  Different internal resources  e.g, shared data structures and library routines  Different external events  e.g, UNIX IO device interface  Backward compatibility  e.g, sometimes it is important to retain bugs! 48 Design Principles Conventional Development Processes  Waterfall Model  Specify, analyze, implement, test (in sequence)  Assumes that requirements can be specied up front  Spiral Model  Supports iterative development  Attempts to assess risks of changes  Rapid Application Development  Build a prototype  Ship it :-) 49 Design Principles Agile Processes  Stresses customer satisfaction, and therefore, involvement  Provide what the customer wants, as quickly as possible  Provide only what the customer wants  Encourages changes in requirements  Relies on testing  For example, eXtreme Programming practices  Planning, designing, coding, testing 50 Design Principles eXtreme Programming: Planning Technology Spike System Prototype User Story Planning Game Iteration Commitment Schedule Change in Requirements, Risk, or Developement Environment Risk Estimates Time Requirements based on http:www.extremeprogramming.orgrulesplanninggame.html  Start with user stories  Written by customers, to specify system requirements  Minimal detail, typically just a few sentences on a card  Expected development time: 1 to 3 weeks each, roughly  Planning game creates commitment schedule for entire project  Each iteration should take 2-3 weeks 51 Design Principles eXtreme Programming: Designing  Defer design decisions as long as possible  Advantages:  Simplies current task (just build what is needed)  You dont need to maintain what you havent built  Time is on your side: youre likely to learn something useful by the time you need to decide  Tomorrow may never come: if a feature isnt needed now, it might never be needed  Disadvantages:  Future design decisions may require rework of existing implementation  Ramp-up time will probably be longer later  Therefore, always try to keep designs as simple as possible 52 Design Principles eXtreme Programming: Coding  Pair programming  Always code with a partner  Always test as you code  Pair programming pays off by supporting good implementation, reducing mistakes, and exposing more than one programmer to the designimplementation  If any deciencies in existing implementation are noticed, either x them or note that they need to be xed 53 Design Principles eXtreme Programming: Testing  Unit tests are written before code  Code must pass both its unit test and all regression tests before committing  In effect, the test suite denes the system requirements  Signicant difference from other development approaches  If a bug is found, a test for it must be added  If a feature isnt tested, it can be removed 54 Design Principles Agile Processes: Information Sources  Kent Beck, Extreme Programming Explained: Embrace Change, Addison-Wesley, ISBN 0201616416, 1999  Kent Beck, Extreme Programming, C Report 11:5, May 1999, pp.

--- Chunk 21 ---
Tokens: 722
Type: sentence-based
Text:
48 Design Principles Conventional Development Processes  Waterfall Model  Specify, analyze, implement, test (in sequence)  Assumes that requirements can be specied up front  Spiral Model  Supports iterative development  Attempts to assess risks of changes  Rapid Application Development  Build a prototype  Ship it :-) 49 Design Principles Agile Processes  Stresses customer satisfaction, and therefore, involvement  Provide what the customer wants, as quickly as possible  Provide only what the customer wants  Encourages changes in requirements  Relies on testing  For example, eXtreme Programming practices  Planning, designing, coding, testing 50 Design Principles eXtreme Programming: Planning Technology Spike System Prototype User Story Planning Game Iteration Commitment Schedule Change in Requirements, Risk, or Developement Environment Risk Estimates Time Requirements based on http:www.extremeprogramming.orgrulesplanninggame.html  Start with user stories  Written by customers, to specify system requirements  Minimal detail, typically just a few sentences on a card  Expected development time: 1 to 3 weeks each, roughly  Planning game creates commitment schedule for entire project  Each iteration should take 2-3 weeks 51 Design Principles eXtreme Programming: Designing  Defer design decisions as long as possible  Advantages:  Simplies current task (just build what is needed)  You dont need to maintain what you havent built  Time is on your side: youre likely to learn something useful by the time you need to decide  Tomorrow may never come: if a feature isnt needed now, it might never be needed  Disadvantages:  Future design decisions may require rework of existing implementation  Ramp-up time will probably be longer later  Therefore, always try to keep designs as simple as possible 52 Design Principles eXtreme Programming: Coding  Pair programming  Always code with a partner  Always test as you code  Pair programming pays off by supporting good implementation, reducing mistakes, and exposing more than one programmer to the designimplementation  If any deciencies in existing implementation are noticed, either x them or note that they need to be xed 53 Design Principles eXtreme Programming: Testing  Unit tests are written before code  Code must pass both its unit test and all regression tests before committing  In effect, the test suite denes the system requirements  Signicant difference from other development approaches  If a bug is found, a test for it must be added  If a feature isnt tested, it can be removed 54 Design Principles Agile Processes: Information Sources  Kent Beck, Extreme Programming Explained: Embrace Change, Addison-Wesley, ISBN 0201616416, 1999  Kent Beck, Extreme Programming, C Report 11:5, May 1999, pp. 2629  John Vlissides, XP, interview with Kent Beck in the Pattern Hatching Column, C Report 11:6, June 1999, pp.

--- Chunk 22 ---
Tokens: 244
Type: sentence-based
Text:
2629  John Vlissides, XP, interview with Kent Beck in the Pattern Hatching Column, C Report 11:6, June 1999, pp. 44-52  Kent Beck, Embracing Change with Extreme Programming, IEEE Computer 32:10, October 1999, pp. 70-77  http:www.extremeprogramming.org  http:www.xprogramming.com  http:c2.comcgiwiki?ExtremeProgrammingRoadmap 55 Design Principles Design Guidelines: Motivation  Design is the process of organizing structured solutions to tasks from a problem domain  This process is carried out in many disciplines, in many ways  There are many similarities and commonalities among design processes  There are also many common design mistakes . . . The following pages provide a number of design rules. Remember, these rules are simply suggestions on how to better organize your design process, not a recipe for success! 56 Design Principles Common Design Mistakes (12)  Depth-rst design  only partially satisfy the requirements  experience is best cure for this problem . . .

--- Chunk 23 ---
Tokens: 353
Type: sentence-based
Text:
. Directly rening requirements specication  leads to overly constrained, inefcient designs  Failure to consider potential changes  always design for extension and contraction  Making the design too detailed  this overconstrains the implementation 57 Design Principles Common Design Mistakes (22)  Ambiguously stated design  misinterpreted at implementation  Undocumented design decisions  designers become essential to implementation  Inconsistent design  results in a non-integratable system, because separately developed modules dont t together 58 Design Principles Rules of Design (18)  Make sure that the problem is well-dened  All design criteria, requirements, and constraints, should be enumerated before a design is started  This may require a spiral model approach  What comes before how  i.e, dene the service to be performed at every level of abstraction before deciding which structures should be used to realize the services  Separate orthogonal concerns  Do not connect what is independent  Important at many levels and phases . . . 59 Design Principles Rules of Design (28)  Design external functionality before internal functionality. First consider the solution as a black-box and decide how it should interact with its environment  Then decide how the black-box can be internally organized. Likely it consists of smaller black-boxes that can be rened in a similar fashion  Keep it simple.

--- Chunk 24 ---
Tokens: 744
Type: sentence-based
Text:
Likely it consists of smaller black-boxes that can be rened in a similar fashion  Keep it simple. Fancy designs are buggier than simple ones; they are harder to implement, harder to verify, and often less efcient  Problems that appear complex are often just simple problems huddled together  Our job as designers is to identify the simpler problems, separate them, and then solve them individually 60 Design Principles Rules of Design (38)  Work at multiple levels of abstraction  Good designers must be able to move between various levels of abstraction quickly and easily  Design for extensibility  A good design is open-ended, i.e, easily extendible  A good design solves a class of problems rather than a single instance  Do not introduce what is immaterial  Do not restrict what is irrelevant  Use rapid prototyping when applicable  Before implementing a design, build a high-level prototype and verify that the design criteria are met 61 Design Principles Rules of Design (48)  Details should depend upon abstractions  Abstractions should not depend upon details  Principle of Dependency Inversion  The granule of reuse is the same as the granule of release  Only components that are released through a tracking system can be effectively reused  Classes within a released component should share common closure  That is, if one needs to be changed, they all are likely to need to be changed  i.e, what affects one, affects all 62 Design Principles Rules of Design (58)  Classes within a released component should be reused together  That is, it is impossible to separate the components from each other in order to reuse less than the total  The dependency structure for released components must be a DAG  There can be no cycles  Dependencies between released components must run in the direction of stability  The dependee must be more stable than the depender  The more stable a released component is, the more it must consist of abstract classes  A completely stable component should consist of nothing but abstract classes 63 Design Principles Rules of Design (68)  Where possible, use proven patterns to solve design problems  When crossing between two different paradigms, build an interface layer that separates the two  Dont pollute one side with the paradigm of the other 64 Design Principles Rules of Design (78)  Software entities (classes, modules, etc) should be open for extension, but closed for modication  The OpenClosed principle  Bertrand Meyer  Derived classes must usable through the base class interface without the need for the user to know the difference  The Liskov Substitution Principle 65 Design Principles Rules of Design (88)  Make it work correctly, then make it work fast  Implement the design, measure its performance, and if necessary, optimize it  Maintain consistency between representations  e.g, check that the nal optimized implementation is equivalent to the high-level design that was veried  Also important for documentation .

--- Chunk 25 ---
Tokens: 720
Type: sentence-based
Text:
Fancy designs are buggier than simple ones; they are harder to implement, harder to verify, and often less efcient  Problems that appear complex are often just simple problems huddled together  Our job as designers is to identify the simpler problems, separate them, and then solve them individually 60 Design Principles Rules of Design (38)  Work at multiple levels of abstraction  Good designers must be able to move between various levels of abstraction quickly and easily  Design for extensibility  A good design is open-ended, i.e, easily extendible  A good design solves a class of problems rather than a single instance  Do not introduce what is immaterial  Do not restrict what is irrelevant  Use rapid prototyping when applicable  Before implementing a design, build a high-level prototype and verify that the design criteria are met 61 Design Principles Rules of Design (48)  Details should depend upon abstractions  Abstractions should not depend upon details  Principle of Dependency Inversion  The granule of reuse is the same as the granule of release  Only components that are released through a tracking system can be effectively reused  Classes within a released component should share common closure  That is, if one needs to be changed, they all are likely to need to be changed  i.e, what affects one, affects all 62 Design Principles Rules of Design (58)  Classes within a released component should be reused together  That is, it is impossible to separate the components from each other in order to reuse less than the total  The dependency structure for released components must be a DAG  There can be no cycles  Dependencies between released components must run in the direction of stability  The dependee must be more stable than the depender  The more stable a released component is, the more it must consist of abstract classes  A completely stable component should consist of nothing but abstract classes 63 Design Principles Rules of Design (68)  Where possible, use proven patterns to solve design problems  When crossing between two different paradigms, build an interface layer that separates the two  Dont pollute one side with the paradigm of the other 64 Design Principles Rules of Design (78)  Software entities (classes, modules, etc) should be open for extension, but closed for modication  The OpenClosed principle  Bertrand Meyer  Derived classes must usable through the base class interface without the need for the user to know the difference  The Liskov Substitution Principle 65 Design Principles Rules of Design (88)  Make it work correctly, then make it work fast  Implement the design, measure its performance, and if necessary, optimize it  Maintain consistency between representations  e.g, check that the nal optimized implementation is equivalent to the high-level design that was veried  Also important for documentation . .

--- Chunk 26 ---
Tokens: 165
Type: sentence-based
Text:
. . Dont skip the preceding rules! Clearly, this is the most frequently violated rule! ;-) 66 Design Principles Concluding Remarks  Good designs can generally be distilled into a few key principles:  Separate interface from implementation  Determine what is common and what is variable with an interface and an implementation  Allow substitution of variable implementations via a common interface  i.e, the openclosed principle  Dividing commonality from variability should be goal-oriented rather than exhaustive  Design is not simply the act of drawing a picture using a CASE tool or using graphical UML notation! Design is a fundamentally creative activity 67

================================================================================
SOURCE: designPrinciples.pdf
TOTAL CHUNKS: 11
================================================================================

--- Chunk 0 ---
Tokens: 307
Type: sentence-based
Text:
PRINCIPLES OF SOFTWARE DESIGN F. Tip and M. Weintraub Thanks go to Andreas Zeller for allowing incorporation of his materials THE CHALLENGE 1. Software may live much longer than expected 2. Software must be continuously adapted to a changing environment 3. Maintenance takes 5080 of the cost Goal: Make software maintainable and reusable  at little or no cost USE THE PRINCIPLES OF OBJECT-ORIENTED DESIGN TO ACHIEVE THE GOAL 1. Abstraction 2. Encapsulation 3. Modularity 4. Hierarchy Goal: Maintainability and Reusability PRINCIPLES OF OBJECT-ORIENTED DESIGN 1. Abstraction 2. Encapsulation 3. Modularity 4. Hierarchy ABSTRACTION Concrete Object General Principle ABSTRACTION 1. Highlights common properties of objects 2. Distinguishes important and unimportant properties 3. Must be understood even without a concrete object ABSTRACTION An abstraction denotes the essential characteristics of an object that distinguish it from all other kinds of objects and thus provide crisply defined conceptual boundaries, relative to the perspective of the viewer From Object Oriented Design with Applications by Grady Booch PERSPECTIVES EXAMPLE: SENSORS AN ENGINEERS SOLUTION void check_temperature()   see specs AEG sensor type 700, pp.

--- Chunk 1 ---
Tokens: 319
Type: sentence-based
Text:
Must be understood even without a concrete object ABSTRACTION An abstraction denotes the essential characteristics of an object that distinguish it from all other kinds of objects and thus provide crisply defined conceptual boundaries, relative to the perspective of the viewer From Object Oriented Design with Applications by Grady Booch PERSPECTIVES EXAMPLE: SENSORS AN ENGINEERS SOLUTION void check_temperature()   see specs AEG sensor type 700, pp. 53 short sensor  0x80004000; short low  sensor0x20; short high  sensor0x21; int temp_celsius  low  high  256; if (temp_celsius  50)  turn_heating_off()   C code where values read by a sensor are directly mapped to memory locations interface Temperature    interface Location    class TemperatureSensor  public TemperatureSensor(Location)   public void calibrate(Temperature actual)   public Temperature currentTemperature()   public Location location()    private methods below  ABSTRACT SOLUTION All implementation details are hidden MORE ABSTRACTION ITS A PROJECTION OF A SLIDE OF A PHOTO OF A PAINTING OF A PIPE PRINCIPLES OF OBJECT-ORIENTED DESIGN 1. Abstraction  hide details 2. Encapsulation 3. Modularity 4. Hierarchy PRINCIPLES OF OBJECT-ORIENTED DESIGN 1. Abstraction  Hide details 2. Encapsulation 3. Modularity 4.

--- Chunk 2 ---
Tokens: 124
Type: sentence-based
Text:
Modularity 4. Hierarchy ENCAPSULATION  No part of a complex system should depend on internal details of another Goal: keep software changes local Information hiding: Internal details (state, structure, behavior) become the objects secret GRADY BOOCH ON ENCAPSULATION Encapsulation is the process of compartmentalizing the elements of an abstraction that constitute its structure and its behavior; encapsulation serves to separate the contractual interface of an abstraction and its implementation.

--- Chunk 3 ---
Tokens: 421
Type: sentence-based
Text:
Hierarchy ENCAPSULATION  No part of a complex system should depend on internal details of another Goal: keep software changes local Information hiding: Internal details (state, structure, behavior) become the objects secret GRADY BOOCH ON ENCAPSULATION Encapsulation is the process of compartmentalizing the elements of an abstraction that constitute its structure and its behavior; encapsulation serves to separate the contractual interface of an abstraction and its implementation. Grady Booch, Object-Oriented Analysis and Design with Applications, Addison-Wesley, 2007, p. 51-52 class ActiveSensor  public ActiveSensor(Location) public void calibrate(Temperature actual)   public Temperature currentTemperature()   public Location location()   public void register(ActiveSensorObserver o)    private methods below  AN ACTIVE SENSOR notified when temperature changes Callback management is the sensors secret and this illustrates how the Observer design pattern is used to avoid giving external parties access to internal state of the ActiveSensor ANTICIPATING CHANGE Features you expect will change should be isolated in specific components  Number literals  String literals  Presentation and interaction NUMBER LITERALS int a100; for (int i  0; i  99; i) ai  0; int ONE_HUNDRED  100; int aONE_HUNDRED;  NUMBER LITERALS int a100; for (int i  0; i  99; i) ai  0; int SIZE  100; int aSIZE; for (int i  0; i  SIZE; i) ai  0; NUMBER LITERALS double sales_price  net_price  1.06; NUMBER LITERALS double sales_price  net_price  1.06; final double SALES_TAX  1.06; double sales_price  net_price  SALES_TAX; STRING LITERALS if (sensor.temperature()  100) System.out.println(Water is boiling!

--- Chunk 4 ---
Tokens: 396
Type: sentence-based
Text:
Grady Booch, Object-Oriented Analysis and Design with Applications, Addison-Wesley, 2007, p. 51-52 class ActiveSensor  public ActiveSensor(Location) public void calibrate(Temperature actual)   public Temperature currentTemperature()   public Location location()   public void register(ActiveSensorObserver o)    private methods below  AN ACTIVE SENSOR notified when temperature changes Callback management is the sensors secret and this illustrates how the Observer design pattern is used to avoid giving external parties access to internal state of the ActiveSensor ANTICIPATING CHANGE Features you expect will change should be isolated in specific components  Number literals  String literals  Presentation and interaction NUMBER LITERALS int a100; for (int i  0; i  99; i) ai  0; int ONE_HUNDRED  100; int aONE_HUNDRED;  NUMBER LITERALS int a100; for (int i  0; i  99; i) ai  0; int SIZE  100; int aSIZE; for (int i  0; i  SIZE; i) ai  0; NUMBER LITERALS double sales_price  net_price  1.06; NUMBER LITERALS double sales_price  net_price  1.06; final double SALES_TAX  1.06; double sales_price  net_price  SALES_TAX; STRING LITERALS if (sensor.temperature()  100) System.out.println(Water is boiling! ); STRING LITERALS if (sensor.temperature()  100) System.out.println(Water is boiling! ); if (sensor.temperature()  BOILING_POINT) System.out.println(message(BOILING_WARNING, Water is boiling! ); if (sensor.temperature()  BOILING_POINT) alarm.handle_boiling(); PRINCIPLES OF OBJECT-ORIENTED DESIGN 1. Abstraction  Hide details 2. Encapsulation  Keep changes local 3. Modularity 4.

--- Chunk 5 ---
Tokens: 315
Type: sentence-based
Text:
Modularity 4. Hierarchy PRINCIPLES OF OBJECT-ORIENTED DESIGN 1. Abstraction  Hide details 2. Encapsulation  Keep changes local 3. Modularity 4. Hierarchy MODULARITY Basic idea: Partition a system such that parts can be designed and revised independently (divide and conquer) System is partitioned into modules, with each one fulfilling a specific task Modules should be changeable and reuseable independent of other modules GRADY BOOCH ON MODULARITY Modularity is the property of a system that has been decomposed into a set of cohesive and loosely coupled modules. MODULE BALANCE Goal 1: Modules should hide information  and expose as little as possible Goal 2: Modules should cooperate  and therefore must exchange information These goals conflict with each other PRINCIPLES OF MODULARITY High cohesion Modules should contain functions that logically belong together Weak coupling Changes to modules should not affect other modules Law of Demeter Talk only to friends HIGH COHESION 1. Modules should contain functions that logically belong together 2. Achieved by grouping functions that work on the same data 3. Natural grouping in object oriented design WEAK COUPLING Changes in modules should not impact other modules Achieved via 1. Information hiding 2.

--- Chunk 6 ---
Tokens: 395
Type: sentence-based
Text:
Information hiding 2. Depending on as few modules as possible LAW OF DEMETER (OR: PRINCIPLE OF LEAST KNOWLEDGE) Basic idea: Assume as little as possible about other modules Approach: Restrict method calls to friends Proposed by Holland, Lieberherr, and Riel at Northeastern University in 1988 Demeter (aka Ceres) is the Greek mythical goddess of the harvest, and she presided also over the sacred law and the cycle of life and death. LoD: CALL YOUR FRIENDS A method M of an object O should only call methods of 1.O itself 2.Ms parameters 3.any objects created in M 4.Os direct component objects single dot rule DEMETER: EXAMPLE class Uni  Prof boring  new Prof(); public Prof getProf()  return boring;  public Prof getNewProf()  return new Prof();   class Test  Uni uds  new Uni(); public void one()  uds.getProf().fired();  public void two()  uds.getNewProf().hired();   DEMETER: EXAMPLE class Uni  Prof boring  new Prof(); public Prof getProf()  return boring;  public Prof getNewProf()  return new Prof();  public void fireProf(.) . class BetterTest  Uni uds  new Uni(); public void betterOne()  uds.fireProf(. );   DEMETER EFFECTS 1. Reduces coupling between modules 2. Disallow direct access to parts 3. Limit the number of accessible classes 4. Reduce dependencies 5. Results in several new wrapper methods  Demeter transmogrifiers PRINCIPLES OF OBJECT-ORIENTED DESIGN 1. Abstraction  Hide details 2. Encapsulation  Keep changes local 3. Modularity  Control information flow high cohesion weak coupling talk only to friends 4. Hierarchy PRINCIPLES OF OBJECT-ORIENTED DESIGN 1.

--- Chunk 7 ---
Tokens: 380
Type: sentence-based
Text:
Hierarchy PRINCIPLES OF OBJECT-ORIENTED DESIGN 1. Abstraction  Hide details 2. Encapsulation  Keep changes local 3. Modularity  Control information flow High cohesion weak coupling talk only to friends 4. Hierarchy HIERARCHY Hierarchy is a ranking or ordering of abstractions. CENTRAL HIERARCHIES 1. has-a hierarchy  Aggregation of abstractions A car has three to four wheels 1. is-a hierarchy  Generalization across abstractions An ActiveSensor is a TemperatureSensor HIERARCHY PRINCIPLES OpenClose Principle Classes should be open for extensions Liskov Substitution Principle Subclasses should not require more, and not deliver less Dependency Principle Classes should only depend on abstractions OPENCLOSE PRINCIPLE A class should be open for extension, but closed for changes Achieved via inheritance and dynamic binding AN INTERNET CONNECTION void connect()  if (connection_type  MODEM_56K)  Modem modem  new Modem(); modem.connect();  else if (connection_type  ETHERNET)  else if (connection_type  WLAN)  else if (connection_type  UMTS)   SOLUTION WITH HIERARCHIES AN INTERNET CONNECTION abstract class Connection  abstract int connect(); abstract int hangup();  class EthernetConnection extends Connection  int connect()  does Ethernet connection;   class ModemConnection extends Connection  int connect()  does dial-up connection;    CONSIDER BILLING PLANS enum  FUN50, FUN120, FUN240, . plan; enum  STUDENT, ADAC, ADAC_AND_STUDENT . special; enum  PRIVATE, BUSINESS, . customer_type; enum  T60_1, T60_60, T30_1, .

--- Chunk 8 ---
Tokens: 386
Type: sentence-based
Text:
customer_type; enum  T60_1, T60_60, T30_1, . billing_increment; int compute_bill(int seconds)  if (customer_type  BUSINESS) billing_increment  T1_1; else if (plan  FUN50  plan  FUN120) billing_increment  T60_1; else if (plan  FUN240  contract_year  2011) billing_increment  T30_1; else billing_increment  T60_60; if (contract_year  2011  special ! ADAC) billing_increment  T60_60;  etc.etc. HIERARCHY SOLUTION You can add a new plan at any time! HIERARCHY PRINCIPLES OpenClose principle  Classes should be open for extensions Liskov substitution principle  Subclasses should not require more, and not deliver less Dependency principle  Classes should only depend on abstractions LISKOV SUBSTITUTION PRINCIPLE An object of a superclass should always be substitutable by an object of a subclass: Same or weaker preconditions Same or stronger postconditions Derived methods should not assume more or deliver less CIRCLE VS ELLIPSE Every circle is an ellipse Does this hierarchy make sense? No, as a circle requires more and delivers less draw() stretchX() draw() Ellipse Circle HIERARCHY PRINCIPLES OpenClose principle  Classes should be open for extensions Liskov substitution principle  Subclasses should not require more, and not deliver less Dependency principle  Classes should only depend on abstractions DEPENDENCY PRINCIPLE A class should only depend on abstractions  never on concrete subclasses (dependency inversion principle) This principle can be used to break dependencies  Print current Web page to FILENAME after user clicks print.

--- Chunk 9 ---
Tokens: 325
Type: sentence-based
Text:
No, as a circle requires more and delivers less draw() stretchX() draw() Ellipse Circle HIERARCHY PRINCIPLES OpenClose principle  Classes should be open for extensions Liskov substitution principle  Subclasses should not require more, and not deliver less Dependency principle  Classes should only depend on abstractions DEPENDENCY PRINCIPLE A class should only depend on abstractions  never on concrete subclasses (dependency inversion principle) This principle can be used to break dependencies  Print current Web page to FILENAME after user clicks print. void print_to_file(string filename)  if (path_exists(filename))   FILENAME exists;  ask user to confirm overwrite in UserPresentation bool confirmed  confirm_loss(filename); if (!confirmed) return;   Proceed printing to FILENAME . DEPENDENCY CYCLIC DEPENDENCY constructing, testing, reusing individual modules becomes impossible! Print current Web page to FILENAME after user clicks print. void print_to_file(string filename, Presentation p)  if (path_exists(filename))   FILENAME exists;  ask user to confirm overwrite bool confirmed  p.confirm_loss(filename); if (!confirmed) return;   Proceed printing to FILENAME . DEPENDENCY DEPENDING ON ABSTRACTION 1. Which is the dominant abstraction? 2. How does this choice impact the remaining system?

--- Chunk 10 ---
Tokens: 197
Type: sentence-based
Text:
How does this choice impact the remaining system? CHOOSING ABSTRACTION PRINCIPLES OF OBJECT-ORIENTED DESIGN Abstraction  Hide details Encapsulation  Keep changes local Modularity  Control information flow high cohesion weak coupling talk only to friends Hierarchy  Order abstractions classes open for extensions, closed for changes subclasses that do not require more or deliver less depend only on abstractions PRINCIPLES OF OBJECT-ORIENTED DESIGN Abstraction  Hide details Encapsulation  Keep changes local Modularity  Control information flow high cohesion weak coupling talk only to friends Hierarchy  Order abstractions classes open for extensions, closed for changes subclasses that do not require more or deliver less depend only on abstractions Goal: Maintainability and Reusability

================================================================================
SOURCE: DesignPrinciplesAndPatterns.pdf
TOTAL CHUNKS: 37
================================================================================

--- Chunk 0 ---
Tokens: 373
Type: sentence-based
Text:
Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 1 Design Principles and Design Patterns Robert C. Martin www.objectmentor.com What is software architecture? The answer is multitiered. At the highest level, there are the architecture patterns that define the overall shape and structure of software applications1. Down a level is the architecture that is specifically related to the pur- pose of the software application. Yet another level down resides the architecture of the modules and their interconnections. This is the domain of design patterns2, pack- akges, components, and classes. It is this level that we will concern ourselves with in this chapter. Our scope in this chapter is quite limitted. There is much more to be said about the principles and patterns that are exposed here. Interested readers are referred to Martin99. Architecture and Dependencies What goes wrong with software? The design of many software applications begins as a vital image in the minds of its designers. At this stage it is clean, elegant, and com- pelling. It has a simple beauty that makes the designers and implementers itch to see it working. Some of these applications manage to maintain this purity of design through the initial development and into the first release. But then something begins to happen. The software starts to rot. At first it isnt so bad. An ugly wart here, a clumsy hack there, but the beauty of the design still shows through.

--- Chunk 1 ---
Tokens: 383
Type: sentence-based
Text:
An ugly wart here, a clumsy hack there, but the beauty of the design still shows through. Yet, over time as the rotting continues, the ugly festering sores and boils accumulate until they dominate the design of the application. The program becomes a festering mass of code that the developers find increasingly hard to maintain. Eventu- 1. Shaw96 2. GOF96 Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 2 ally the sheer effort required to make even the simplest of changes to the application becomes so high that the engineers and front line managers cry for a redesign project. Such redesigns rarely succeed. Though the designers start out with good intentions, they find that they are shooting at a moving target. The old system continues to evolve and change, and the new design must keep up. The warts and ulcers accumu- late in the new design before it ever makes it to its first release. On that fateful day, usually much later than planned, the morass of problems in the new design may be so bad that the designers are already crying for another redesign. Symptoms of Rotting Design There are four primary symptoms that tell us that our designs are rotting. They are not orthogonal, but are related to each other in ways that will become obvious. they are: rigidity, fragility, immobility, and viscosity. Rigidity. Rigidity is the tendency for software to be difficult to change, even in simple ways. Every change causes a cascade of subsequent changes in dependent modules.

--- Chunk 2 ---
Tokens: 397
Type: sentence-based
Text:
Every change causes a cascade of subsequent changes in dependent modules. What begins as a simple two day change to one module grows into a multi- week marathon of change in module after module as the engineers chase the thread of the change through the application. When software behaves this way, managers fear to allow engineers to fix non-critical problems. This reluctance derives from the fact that they dont know, with any reli- ability, when the engineers will be finished. If the managers turn the engineers loose on such problems, they may disappear for long periods of time. The software design begins to take on some characteristics of a roach motel -- engineers check in, but they dont check out. When the managers fears become so acute that they refuse to allow changes to soft- ware, official rigidity sets in. Thus, what starts as a design deficiency, winds up being adverse management policy. Fragility. Closely related to rigidity is fragility. Fragility is the tendency of the software to break in many places every time it is changed. Often the breakage occurs in areas that have no conceptual relationship with the area that was changed. Such errors fill the hearts of managers with foreboding. Every time they authorize a fix, they fear that the software will break in some unexpected way. As the fragility becomes worse, the probability of breakage increases with time, asymptotically approaching 1. Such software is impossible to maintain. Every fix makes it worse, introducing more problems than are solved. Robert C. Martin Copyright (c) 2000 by Robert C. Martin.

--- Chunk 3 ---
Tokens: 389
Type: sentence-based
Text:
Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 3 Such software causes managers and customers to suspect that the developers have lost control of their software. Distrust reigns, and credibility is lost. Immobility. Immobility is the inability to reuse software from other projects or from parts of the same project. It often happens that one engineer will discover that he needs a module that is similar to one that another engineer wrote. However, it also often happens that the module in question has too much baggage that it depends upon. After much work, the engineers discover that the work and risk required to separate the desirable parts of the software from the undesirable parts are too great to tolerate. And so the software is simply rewritten instead of reused. Viscosity. Viscosity comes in two forms: viscosity of the design, and viscosity of the environment. When faced with a change, engineers usually find more than one way to make the change. Some of the ways preserve the design, others do not (i.e. they are hacks.) When the design preserving methods are harder to employ than the hacks, then the viscosity of the design is high. It is easy to do the wrong thing, but hard to do the right thing. Viscosity of environment comes about when the development environment is slow and inefficient. For example, if compile times are very long, engineers will be tempted to make changes that dont force large recompiles, even though those changes are not optiimal from a design point of view.

--- Chunk 4 ---
Tokens: 399
Type: sentence-based
Text:
For example, if compile times are very long, engineers will be tempted to make changes that dont force large recompiles, even though those changes are not optiimal from a design point of view. If the source code control sys- tem requires hours to check in just a few files, then engineers will be tempted to make changes that require as few check-ins as possible, regardless of whether the design is preserved. These four symptoms are the tell-tale signs of poor architecture. Any application that exhibits them is suffering from a design that is rotting from the inside out. But what causes that rot to take place? Changing Requirements The immediate cause of the degradation of the design is well understood. The require- ments have been changing in ways that the initial design did not anticipate. Often these changes need to be made quickly, and may be made by engineers who are not familiar with the original design philosophy. So, though the change to the design works, it somehow violates the original design. Bit by bit, as the changes continue to pour in, these violations accumulate until malignancy sets in. However, we cannot blame the drifting of the requirements for the degradation of the design. We, as software engineers, know full well that requirements change. Indeed, most of us realize that the requirements document is the most volatile document in the Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 4 project. If our designs are failing due to the constant rain of changing requirements, it is our designs that are at fault.

--- Chunk 5 ---
Tokens: 375
Type: sentence-based
Text:
If our designs are failing due to the constant rain of changing requirements, it is our designs that are at fault. We must somehow find a way to make our designs resilient to such changes and protect them from rotting. Dependency Management What kind of changes cause designs to rot? Changes that introduce new and unplanned for dependencies. Each of the four symptoms mentioned above is either directly, or indirectly caused by improper dependencies between the modules of the software. It is the dependency architecture that is degrading, and with it the ability of the software to be maintained. In order to forestall the degradation of the dependency architecture, the dependencies between modules in an application must be managed. This management consists of the creation of dependency firewalls. Accross such firewalls, dependencies do not propogate. Object Oriented Design is replete with principles and techniques for building such firewalls, and for managing module dependencies. It is these principles and tech- niques that will be discussed in the remainder of this chapter. First we will examine the principles, and then the techniques, or design patterns, that help maintain the dependency architecture of an application. Principles of Object Oriented Class Design The Open Closed Principle (OCP)1 A module should be open for extension but closed for modification. Of all the principles of object oriented design, this is the most important. It originated from the work of Bertrand Meyer2.

--- Chunk 6 ---
Tokens: 386
Type: sentence-based
Text:
It originated from the work of Bertrand Meyer2. It means simply this: We should write our mod- ules so that they can be extended, without requiring them to be modified. In other words, we want to be able to change what the modules do, without changing the source code of the modules. 1. OCP97 2. OOSC98 Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 5 This may sound contradictory, but there are several techniques for achieving the OCP on a large scale. All of these techniques are based upon abstraction. Indeed, abstrac- tion is the key to the OCP. Several of these techniques are described below. Dynamic Polymorphism. Consider Listing 2-1. the LogOn function must be changed every time a new kind of modem is added to the software. Worse, since each different type of modem depends upon the Modem:Type enumeration, each modem must be recompiled every time a new kind of modem is added. Listing 2-1 Logon, must be modified to be extended. struct Modem  enum Type hayes, courrier, ernie) type; ; struct Hayes  Modem:Type type;  Hayes related stuff ; struct Courrier  Modem:Type type;  Courrier related stuff ; struct Ernie  Modem:Type type;  Ernie related stuff ; void LogOn(Modem m, string pno, string user, string pw)  if (m.type  Modem:hayes) DialHayes((Hayes)m, pno); else if (m.type  Modem:courrier) DialCourrier((Courrier)m, pno); else if (m.type  Modem:ernie) DialErnie((Ernie)m, pno)  .you get the idea  Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved.

--- Chunk 7 ---
Tokens: 381
Type: sentence-based
Text:
All Rights Reserved. www.objectmentor.com 6 Of course this is not the worst attribute of this kind of design. Programs that are designed this way tend to be littered with similar ifelse or switch statement. Every time anything needs to be done to the modem, a switch statement ifelse chain will need to select the proper functions to use. When new modems are added, or modem policy changes, the code must be scanned for all these selection statements, and each must be appropriately modified. Worse, programmers may use local optimizations that hide the structure of the selec- tion statements. For example, it might be that the function is exactly the same for Hayes and Courrier modems. Thus we might see code like this: if (modem.type  Modem:ernie) SendErnie((Ernie)modem, c); else SendHayes((Hayes)modem, c); Clearly, such structures make the system much harder to maintain, and are very prone to error. As an example of the OCP, consider Figure 2-13. Here the LogOn function depends only upon the Modem interface. Additional modems will not cause the LogOn func- tion to change. Thus, we have created a module that can be extended, with new modems, without requiring modification. See Listing 2-2. Figure 2-13 Listing 2-2 LogOn has been closed for modification class Modem  public:  Dial(pno)  Send(char)  Recv() : char  Hangup() Modem interface LogOn Courrier Modem Hayes Modem Ernies Modem function Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 7 Static Polymorphism.

--- Chunk 8 ---
Tokens: 382
Type: sentence-based
Text:
www.objectmentor.com 7 Static Polymorphism. Another technique for conforming to the OCP is through the use of templates or generics. Listing 2-3 shows how this is done. The LogOn func- tion can be extended with many different types of modems without requiring modifi- cation. Architectural Goals of the OCP. By using these techniques to conform to the OCP, we can create modules that are extensible, without being changed. This means that, with a little forethought, we can add new features to existing code, without changing the existing code and by only adding new code. This is an ideal that can be difficult to achieve, but you will see it achieved, several times, in the case studies later on in this book. Even if the OCP cannot be fully achieved, even partial OCP compliance can make dramatic improvements in the structure of an application. It is always better if changes do not propogate into existing code that already works. If you dont have to change working code, you arent likely to break it. virtual void Dial(const string pno)  0; virtual void Send(char)  0; virtual char Recv()  0; virtual void Hangup()  0; ; void LogOn(Modem m, string pno, string user, string pw)  m.Dial(pno);  you get the idea. Listing 2-3 Logon is closed for modification through static polymorphism template typename MODEM void LogOn(MODEM m, string pno, string user, string pw)  m.Dial(pno);  you get the idea. Listing 2-2 LogOn has been closed for modification Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved.

--- Chunk 9 ---
Tokens: 399
Type: sentence-based
Text:
All Rights Reserved. www.objectmentor.com 8 The Liskov Substitution Principle (LSP)1 Subclasses should be substitutable for their base classes. This principle was coined by Barbar Liskov2 in her work regarding data abstraction and type theory. It also derives from the concept of Design by Contract (DBC) by Bertrand Meyer3. The concept, as stated above, is depicted in Figure 2-14. Derived classes should be substitutable for their base classes. That is, a user of a base class should continue to function properly if a derivative of that base class is passed to it. In other words, if some function User takes an argument ot type Base, then as shown in Listing 2-4, it should be legal to pass in an instance of Derived to that function. This may seem obvious, but there are subtleties that need to be considered. The canonical example is the CircleEllipse dilemma. 1. LSP97 2. Liksov88 3. OOSC98 Figure 2-14 LSP schema. Listing 2-4 User, Based, Derived, example. void User(Base b); Derived d; User(d); User Base Derived Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 9 The CircleEllipse Dilemma. Most of us learn, in high school math, that a circle is just a degenerate form of an ellipse. All circles are ellipses with coincident foci. This is-a relationship tempts us to model circles and ellipses using inheritance as shown in Figure 2-15. While this satisfies our conceptual model, there are certain difficulties. A closer look at the declaration of Ellipse in Figure 2-16 begins to expose them. Notice that Ellipse has three data elements.

--- Chunk 10 ---
Tokens: 392
Type: sentence-based
Text:
Notice that Ellipse has three data elements. The first two are the foci, and the last is the length of the major axis. If Circle inherits from Ellipse, then it will inherit these data variables. This is unfortunate since Circle really only needs two data elements, a center point and a radius. Figure 2-15 Circle  Ellipse Dilemma Figure 2-16 Declaration of Ellipse Ellipse Circle  Circumference() : double  Area() : double  GetFocusA() : Point  GetFocusB() : Point  GetMajorAxis() : double  GetMinorAxis() : double  SetFoci(a:Point, b:Point)  SetMajorAxis(double) - itsFocusA : Point - itsFocusB : Point - itsMajorAxis : double Ellipse Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 10 Still, if we ignore the slight overhead in space, we can make Circle behave prop- erly by overriding its SetFoci method to ensure that both foci are kept at the same value. See Listing 2-5. Thus, either focus will act as the center of the circle, and the major axis will be its diameter. Clients Ruin Everything. Certainly the model we have created is self consis- tent. An instance of Circle will obeys all the rules of a circle. There is nothing you can do to it to make it violate those rules. So too for Ellipse. The two classes form a nicely consistent model, even if Circle has one too many data elements. However, Circle and Ellipse do not live alone in a universe by themselves. They cohabit that universe with many other entities, and provide their public inter- faces to those entities. Those interfaces imply a contract.

--- Chunk 11 ---
Tokens: 381
Type: sentence-based
Text:
Those interfaces imply a contract. The contract may not be explicitly stated, but it is there nonetheless. For example, users of Ellipse have the right to expect the following code fragment to succeed: void f(Ellipse e)  Point a(-1,0); Point b(1,0); e.SetFoci(a,b); e.SetMajorAxis(3); assert(e.GetFocusA()  a); assert(e.GetFocusB()  b); assert(e.GetMajorAxis()  3);  In this case the function expects to be working with an Ellipse. As such, it expects to be able to set the foci, and major axis, and then verify that they have been properly set. If we pass an instance of Ellipse into this function, it will be quite happy. However, if we pass an instance of Circle into the function, it will fail rather badly. If we were to make the contract of Ellipse explicit, we would see a postcondition on the SetFoci that guaranteed that the input values got copied to the member vari- ables, and that the major axis variable was left unchanged. Clearly Circle violates this guarantee because it ignores the second input variable of SetFoci. Design by Contract. Restating the LSP, we can say that, in order to be substitut- able, the contract of the base class must be honored by the derived class. Since Listing 2-5 Keeping the Circle Foci coincident. void Circle:SetFoci(const Point a, const Point b)  itsFocusA  a; itsFocusB  a;  Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 11 Circle does not honor the implied contract of Ellipse, it is not substitutable and violates the LSP.

--- Chunk 12 ---
Tokens: 378
Type: sentence-based
Text:
www.objectmentor.com 11 Circle does not honor the implied contract of Ellipse, it is not substitutable and violates the LSP. Making the contract explicit is an avenue of research followed by Bertrand Meyer. He has invented a language named Eiffel in which contracts are explicitly stated for each method, and explicitly checked at each invocation. Those of us who are not using Eiffel, have to make do with simple assertions and comments. To state the contract of a method, we declare what must be true before the method is called. This is called the precondition. If the precondition fails, the results of the method are undefined, and the method ought not be called. We also declare what the method guarantees will be true once it has completed. This is called the postcondition. A method that fails its postcondition should not return. Restating the LSP once again, this time in terms of the contracts, a derived class is substitutable for its base class if: 1. Its preconditions are no stronger than the base class method. 2. Its postconditions are no weaker than the base class method. Or, in other words, derived methods should expect no more and provide no less. Repercussions of LSP Violation. Unfortunately, LSP violations are difficult to detect until it is too late. In the CircleEllipse case, everything worked fine until some client came along and discovered that the implicit contract had been violated. If the design is heavily used, the cost of repairing the LSP violation may be too great to bear.

--- Chunk 13 ---
Tokens: 380
Type: sentence-based
Text:
If the design is heavily used, the cost of repairing the LSP violation may be too great to bear. It might not be economical to go back and change the design, and then rebuild and retest all the existing clients. Therefore the solution will likely be to put into an if else statement in the client that discovered the violation. This ifelse statement checks to be sure that the Ellipse is actually an Ellipse and not a Circle. See Listing 2-6. Listing 2-6 Ugly fix for LSP violation void f(Ellipse e)  if (typeid(e)  typeid(Ellipse))  Point a(-1,0); Point b(1,0); e.SetFoci(a,b); e.SetMajorAxis(3); assert(e.GetFocusA()  a); assert(e.GetFocusB()  b); Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 12 Careful examination of Listing 2-6 will show it to be a violation of the OCP. Now, whenever some new derivative of Ellipse is created, this function will have to be checked to see if it should be allowed to operate upon it. Thus, violations of LSP are latent violations of OCP. The Dependency Inversion Principle (DIP)1 Depend upon Abstractions. Do not depend upon concretions. If the OCP states the goal of OO architecture, the DIP states the primary mechanism. Dependency Inversion is the strategy of depending upon interfaces or abstract func- tions and classes, rather than upon concrete functions and classes. This principle is the enabling force behind component design, COM, CORBA, EJB, etc. Procedural designs exhibit a particular kind of dependency structure.

--- Chunk 14 ---
Tokens: 383
Type: sentence-based
Text:
Procedural designs exhibit a particular kind of dependency structure. As Figure 2-17 shows, this structure starts at the top and points down towards details. High level modules depend upon lower level modules, which depend upon yet lower level mod- ules, etc. A little thought should expose this dependency structure as intrinsically weak. The high level modules deal with the high level policies of the application. These policies generally care little about the details that implement them. Why then, must these high level modules directly depend upon those implementation modules? An object oriented architecture shows a very different dependency structure, one in which the majority of dependencies point towards abstractions. Morevoer, the mod- ules that contain detailed implementation are no longer depended upon, rather they depend themselves upon abstractions. Thus the dependency upon them has been inverted. See Figure 2-18. Depending upon Abstractions. The implication of this principle is quite sim- ple. Every dependency in the design should target an interface, or an abstract class. No dependency should target a concrete class. assert(e.GetMajorAxis()  3);  else throw NotAnEllipse(e);  1. DIP97 Listing 2-6 Ugly fix for LSP violation Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 13 Clearly such a restriction is draconian, and there are mitigating circumstatnces that we will explore momentarily. But, as much as is feasible, the principle should be fol- lowed.

--- Chunk 15 ---
Tokens: 394
Type: sentence-based
Text:
But, as much as is feasible, the principle should be fol- lowed. The reason is simple, concrete things change alot, abstract things change much less frequently. Morevoer, abstractions are hinge points, they represent the places where the design can bend or be extended, without themselves being modified (OCP). Figure 2-17 Dependency Structure of a Procedural Architecture Figure 2-18 Dependency Structure of an Object Oriented Architecture main mid 1 Mid 2 Mid 3 Detail Detail Detail Detail High level Policy Abstract Interface Abstract Interface Abstract Interface Detailed Implementation Detailed Implementation Detailed Implementation Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 14 Substrates such as COM enforce this principle, at least between components. The only visible part of a COM component is its abstract interface. Thus, in COM, there is little escape from the DIP. Mitigating Forces. One motivation behind the DIP is to prevent you from depending upon volatile modules. The DIP makes the assumption that anything con- crete is volatile. While this is frequently so, especially in early development, there are exceptions. For example, the string.h standard C library is very concrete, but is not at all volatile. Depending upon it in an ANSI string environment is not harmful. Likewise, if you have tried and true modules that are concrete, but not volatile, depending upon them is not so bad. Since they are not likely to change, they are not likely to inject volatility into your design. Take care however.

--- Chunk 16 ---
Tokens: 381
Type: sentence-based
Text:
Take care however. A dependency upon string.h could turn very ugly when the requirements for the project forced you to change to UNICODE characters. Non-vol- atility is not a replacement for the substitutability of an abstract interface. Object Creation. One of the most common places that designs depend upon con- crete classes is when those designs create instances. By definition, you cannot create instances of abstract classes. Thus, to create an instance, you must depend upon a concrete class. Creation of instances can happen all through the architecture of the design. Thus, it might seem that there is no escape and that the entire architecture will be littered with dependencies upon concrete classes. However, there is an elegant solution to this problem named ABSTRACTFACTORY1 -- a design pattern that well be examining in more detail towards the end of this chapter. The Interface Segregation Principle (ISP)2 Many client specific interfaces are better than one general purpose interface The ISP is another one of the enabling technologies supporting component substrates such as COM. Without it, components and classes would be much less useful and por- table. The essence of the principle is quite simple. If you have a class that has several cli- ents, rather than loading the class with all the methods that the clients need, create specific interfaces for each client and multiply inherit them into the class. 1. GOF96 p? 2. ISP97 Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved.

--- Chunk 17 ---
Tokens: 380
Type: sentence-based
Text:
All Rights Reserved. www.objectmentor.com 15 Figure 2-19 shows a class with many clients, and one large interface to serve them all. Note that whenever a change is made to one of the methods that ClientA calls, ClientB and ClientC may be affected. It may be necessary to recompile and redeploy them. This is unfortunate. A better technique is shown in Figure 2-20. The methods needed by each client are placed in special interfaces that are specific to that client. Those interfaces are multi- ply inherited by the Service class, and implemented there. If the interface for ClientA needs to change, ClientB and ClientC will remain unaffected. They will not have to be recompiled or redeployed. What does Client Specific Mean? The ISP does not recommend that every class that uses a service have its own special interface class that the service must inherit from. If that were the case, the service would depend upon each and every cli- ent in a bizarre and unhealthy way. Rather, clients should be categorized by their type, and interfaces for each type of client should be created. If two or more different client types need the same method, the method should be added to both of their interfaces. This is neither harmful nor confusing to the client. Changing Interfaces. When object oriented applications are maintained, the interfaces to existing classes and components often change. There are times when these changes have a huge impact and force the recompilation and redeployment of a very large part of the design.

--- Chunk 18 ---
Tokens: 387
Type: sentence-based
Text:
There are times when these changes have a huge impact and force the recompilation and redeployment of a very large part of the design. This impact can be mitigated by adding new interfaces to existing objects, rather than changing the existing interface. Clients of the old inter- Figure 2-19 Fat Service with Integrated Interfaces client A Methods  . client B methods  . client C methods  . Service Client A Client B Client C Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 16 face that wish to access methods of the new interface, can query the object for that interface as shown in the following code. void Client(Service s)  if (NewService ns  dynamic_castNewService(s))   use the new service interface   As with all principles, care must be taken not to overdo it. The specter of a class with hundreds of different interfaces, some segregated by client and other segregated by version, would be frightening indeed. Principles of Package Architecture Classes are a necessary, but insufficient, means of organizing a design. The larger granularity of packages are needed to help bring order. But how do we choose which classes belong in which packages. Below are three principles known as the Package Cohesion Principles, that attempt to help the software architect. Figure 2-20 Segregated Interfaces client A Methods  . client B methods  . client C methods  . Service Client A Client B Client C client A Methods  . Service A interface client B Methods  . Service B interface client C Methods  .

--- Chunk 19 ---
Tokens: 393
Type: sentence-based
Text:
Service B interface client C Methods  . Service C interface Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 17 The Release Reuse Equivalency Principle (REP)1 The granule of reuse is the granule of release. A reusable element, be it a component, a class, or a cluster of classes, cannot be reused unless it is managed by a release system of some kind. Users will be unwilling to use the element if they are forced to upgrade every time the author changes it. Thus. even though the author has released a new version of his reusable element, he must be willing to support and maintain older versions while his customers go about the slow business of getting ready to upgrade. Thus, clients will refuse to reuse an ele- ment unless the author promises to keep track of version numbers, and maintain old versions for awhile. Therefore, one criterion for grouping classes into packages is reuse. Since packages are the unit of release, they are also the unit of reuse. Therefore architects would do well to group reusable classes together into packages. The Common Closure Principle (CCP)2 Classes that change together, belong together. A large development project is subdivided into a large network of interelated pack- ages. The work to manage, test, and release those packages is non-trivial. The more packages that change in any given release, the greater the work to rebuild, test, and deploy the release. Therefore we would like to minimze the number of packages that are changed in any given release cycle of the product.

--- Chunk 20 ---
Tokens: 387
Type: sentence-based
Text:
Therefore we would like to minimze the number of packages that are changed in any given release cycle of the product. To achieve this, we group together classes that we think will change together. This requires a certain amount of precience since we must anticipate the kinds of changes that are likely. Still, when we group classes that change together into the same pack- ages, then the package impact from release to release will be minimzed. The Common Reuse Principle (CRP)3 Classes that arent reused together should not be grouped together. A dependency upon a package is a dependency upon everything within the package. When a package changes, and its release number is bumped, all clients of that pack- 1. Granularity97 2. Granularity97 3. Granularity97 Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 18 age must verify that they work with the new package -- even if nothing they used within the package actually changed. We frequently experience this when our OS vendor releases a new operating system. We have to upgrade sooner or later, because the vendor will not support the old ver- sion forever. So even though nothing of interest to us changed in the new release, we must go through the effort of upgrading and revalidating. The same can happen with packages if classes that are not used together are grouped together. Changes to a class that I dont care about will still force a new release of the package, and still cause me to go through the effort of upgrading and revalidating.

--- Chunk 21 ---
Tokens: 384
Type: sentence-based
Text:
Changes to a class that I dont care about will still force a new release of the package, and still cause me to go through the effort of upgrading and revalidating. Tension between the Package Cohesion Principles These three principles are mutually exclusive. They cannot simultaneously be satis- fied. That is because each principle benefits a different group of people. The REP and CRP makes life easy for reusers, whereas the CCP makes life easier for maintainers. The CCP strives to make packages as large as possible (after all, if all the classes live in just one package, then only one package will ever change). The CRP, however, tries to make packages very small. Fortunately, packages are not fixed in stone. Indeed, it is the nature of packages to shift and jitter during the course of development. Early in a project, architects may set up the package structure such that CCP dominates and develoipment and maintenance is aided. Later, as the architecture stabilizes, the architects may refactor the package structure to maximize REP and CRP for the external reusers. The Package Coupling Principles. The next three packages govern the interlationships between packages. Applications tend to be large networks of interlated packages. The rules that govern these interrela- tionship are some of the most important rules in object oriented architecture. The Acyclic Dependencies Principle (ADP)1 The dependencies betwen packages must not form cycles. Since packages are the granule of release, they also tend to focus manpower.

--- Chunk 22 ---
Tokens: 365
Type: sentence-based
Text:
Since packages are the granule of release, they also tend to focus manpower. Engi- neers will typically work inside a single package rather than working on dozens. This tedency is amplified by the package cohesion principles, since they tend to group 1. Granularity97 Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 19 together those classes that are related. Thus, engineers will find that their changes are directed into just a few package. Once those changes are made, they can release those packages to the rest of the project. Before they can do this release, however, they must test that the package works. To do that, they must compile and build it with all the packages that it depends upon. Hopefully this number is small. Consider Figure 2-21. Astute readers will recognize that there are a number of flaws in the architecture. The DIP seems to have been abandoned, and along with it the OCP. The GUI depends directly upon the communications package, and apparently is reponsible for transporting data to the analysis package. Yuk. Still, lets use this rather ugly structure for some examples. Consider what would be required to release the Protocol package. The engineers would have to build it with the latest release of the CommError package, and run their tests. Protocol has no other dependencies, so no other package is needed. This is nice. We can test and release with a minimal amount of work.

--- Chunk 23 ---
Tokens: 381
Type: sentence-based
Text:
We can test and release with a minimal amount of work. Figure 2-21 Acyclic Package Network GUI Comm Analysis Database Modem Control Protocol Comm Error Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 20 A Cycle Creeps In. But now lets say that I am an engineer working on the CommError package. I have decided that I need to display a message on the screen. Since the screen is controlled by the GUI, I send a message to one of the GUI objects to get my message up on the screen. This means that I have made CommError dependent upon GUI. See Figure 2-22. Now what happens when the guys who are working on Protocol want to release their package. They have to build their test suite with CommError, GUI, Comm, ModemControl, Analysis, and Database! This is clearly disastrous. The workload of the engineers has been increased by an abhorent amount, due to one sin- gle little dependency that got out of control. This means that someone needs to be watching the package dependency structure with regularity, and breaking cycles wherever they appear. Otherwise the transitive dependencies between modules will cause every module to depend upon every other module. Breaking a Cycle. Cycles can be broken in two ways. The first involves creating a new package, and the second makes use of the DIP and ISP. Figure 2-22 A cycle has been added. GUI Comm Analysis Database Modem Control Protocol Comm Error Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved.

--- Chunk 24 ---
Tokens: 399
Type: sentence-based
Text:
All Rights Reserved. www.objectmentor.com 21 Figure 2-23 shows how to break the cycle by adding a new package. The classes that CommError needed are pulled out of GUI and placed in a new package named MessageManager. Both GUI and CommError are made to depend upon this new package. This is an example of how the package structure tends to jitter and shift during devel- opment. New package come into existence, and classes move from old package to new packages, to help break cycles. Figure 2-24 shows a before and after picture of the other technique for breaking cycles. Here we see two packages that are bound by a cycle. Class A depends upon class X, and class Y depends upon class B. We break the cycle by inverting the depen- dency between Y and B. This is done by adding a new interface, BY, to B. This inter- face has all the methods that Y needs. Y uses this interface and B implements it. Notice the placement of BY. It is placed in the package with the class that uses it. This is a pattern that you will see repeated throughout the case studies that deal with pack- Figure 2-23 GUI Comm Analysis Database Modem Control Protocol Comm Error Message Manager Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 22 ages. Interfaces are very often included in the package that uses them, rather than in the package that implements them. The Stable Dependencies Principle (SDP)1 Depend in the direction of stability. Though this seems to be an obvious principle, there is quite a bit we can say about it. Stability is not always well understood.

--- Chunk 25 ---
Tokens: 397
Type: sentence-based
Text:
Stability is not always well understood. Stability. What is meant by stability? Stand a penny on its side. Is it stable in that position? Likely youd say not. However, unless disturbed, it will remain in that posi- Figure 2-24 1. Stability97 A B X Y A B X Y BY interface Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 23 tion for a very very long time. Thus stability has nothing direclty to do with frequency of change. The penny is not changing, but it is hard to think of it as stable. Stability is related to the amount of work required to make a change. The penny is not stable because it requires very little work to topple it. On the other hand, a table is very stable because it takes a considerable amount of effort to turn it over. How does this relate to software? There are many factors that make a software pack- age hard to change. Its size, complexity, clarity, etc. We are going to ignore all those factors and focus upon something different. One sure way to make a software pack- age difficult to change, is to make lots of other software packages depend upon it. A package with lots of incomming dependencies is very stable because it requires a great deal of work to reconcile any changes with all the dependent packages. Figure 2-25 shows X: a stable package. This package has three packages depending upon it, and therefore it has three good reasons not to change. We say that it is respon- sible to those three packages. On the other hand, X depends upon nothing, so it has no external influence to make it change.

--- Chunk 26 ---
Tokens: 389
Type: sentence-based
Text:
On the other hand, X depends upon nothing, so it has no external influence to make it change. We say it is independent. Figure 2-26, on the other hand, shows a very instable package. Y has no other pack- ages depending upon it; we say that it is irresponsible. Y also has three packages that it depends upon, so changes may come from three external sources. We say that Y is dependent. Stability Metrics. We can calculate the stability of a package using a trio of sim- ple metrics. Ca Afferent Coupling. The number of classes outside the package that depend upon classes inside the package. (i.e. incomming dependencies) Figure 2-25 X is a stable package X Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 24 Ce Efferent Coupling. The number of classes outside the package that classes inside the package depend upon. (i.e. outgoing dependencies) I Instability. . This is a metric that has the range: 0,1. If there are no outgoing dependencies, then I will be zero and the package is stable. If there are no incomming dependencies then I will be one and the package is instable. Now we can rephrase the SDP as follows: Depend upon packages whose I metric is lower than yours. Rationale. Should all software be stable? One of the most important attributes of well designed software is ease of change. Software that is flexible in the presence of changing requirements is thought well of. Yet that software is instable by our defini- tion. Indeed, we greatly desire that portions of our software be instable.

--- Chunk 27 ---
Tokens: 365
Type: sentence-based
Text:
Indeed, we greatly desire that portions of our software be instable. We want cer- tain modules to be easy to change so that when requirements drift, the design can respond with ease. Figure 2-27 shows how the SDP can be violated. Flexible is a package that we intend to be easy to change. We want Flexible to be instable. However, some engineer, working in the package named Stable, hung a dependency upon Flexible. This violates the SDP since the I metric for Stable is much lower than the I metric for Flexible. As a result, Flexible will no longer be easy to change. A change to Flexible will force us to deal with Stable and all its depen- dents. The Stable Abstractions Principle (SAP)1 Stable packages should be abstract packages. Figure 2-26 Y is instable. Y I Ce Ca  Ce  -------------------- Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 25 We can envision the packages structure of our application as a set of interconnected packages with instable packages at the top, and stable packages on the bottom. In this view, all dependencies point downwards. Those packages at the top are instable and flexible. But those at the bottom are very difficult to change. And this leads us to a dilemma: Do we want packages in our design that are hard to change? Clearly, the more packages that are hard to change, the less flexible our overall design will be. However, there is a loophole we can crawl through.

--- Chunk 28 ---
Tokens: 398
Type: sentence-based
Text:
However, there is a loophole we can crawl through. The highly stable pack- ages at the bottom of the dependency network may be very difficult to change, but according to the OCP they do not have to be difficult to extend! If the stable packages at the bottom are also highly abstract, then they can be easily extended. This means that it is possible to compose our application from instable packages that are easy to change, and stable packages that are easy to extend. This is a good thing. Thus, the SAP is just a restatement of the DIP. It states the packages that are the most depended upon (i.e. stable) should also be the most abstract. But how do we meaure abstractness? The Abstractness Metrics. We can derive another trio of metrics to help us cal- culate abstractness. 1. Stability97 Figure 2-27 Violation of SDP. Flexible Stable Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 26 Nc Number of classes in the package. Na Number of abstract classes in the package. Remember, an abstract class is a class with at least one pure interface, and cannot be instantiated. A Abstractness. The A metric has a range of 0,1, just like the I metric. A value of zero means that the package contains no abstract classes. A value of one means that the package contains nothing but abstract classes. The I vs A graph. The SAP can now be restated in terms of the I and A metrics: I should increase as A decreases. That is, concrete packages should be instable while abstract packages should be stable. We can plot this graphically on the A vs I graph.

--- Chunk 29 ---
Tokens: 371
Type: sentence-based
Text:
We can plot this graphically on the A vs I graph. See Figure 2-28. It seems clear that packages should appear at either of the two black dots on Figure 2- 28. Those at the upper left are completely abstract and very stable. Those at the lower right are completely concrete and very instable. This is just the way we like it. How- ever what about package X in Figure 2-29? Where should it go? Figure 2-28 The A vs I graph. A Na Nc -------  0 1 1 The Main Sequence The Zone of Uselessness The Zone of Pain I A Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 27 We can determine where we want Package X, by looking at where we dont want it to go. The upper right corner of the AI graph represents packages that are highly abstract and that nobody depends upon. This is the zone of uselessness. Certainly we dont want X to live there. On the other hand, the the lower left point of the AI graph repre- sents packages that are concrete and have lots of incomming dependencies. This point represents the worst case for a package. Since the elements there are concrete, they cannot be extended the way abstract entities can; and since they have lots of incom- ming dependencies, the change will be very painful. This is the zone of pain, and we certainly dont want our package to live there. Maximizing the distance between these two zones gives us a line called the main sequence. Wed like our packages to sit on this line if at all possible.

--- Chunk 30 ---
Tokens: 378
Type: sentence-based
Text:
Wed like our packages to sit on this line if at all possible. A position on this line means that the package is abstract in proportion to its incomming dependen- cies and is concrete in proportion to its outgoing dependencies. In other words, the classes in such a package are conforming to the DIP. Distance Metrics. This leaves us one more set of metrics to examine. Given the A and I values of any package, wed like to know how far that package is from the main sequence. D Distance. . This ranges from 0,0.707. D Normalized Distance. . This metric is much more convenient than D since it ranges from 0,1. Zero indicates that the package is directly on the main sequence. One indicates that the package is as far away as possi- ble from the main sequence. These metrics measure object oriented architecture. They are imperfect, and reliance upon them as the sole indicator of a sturdy architecture would be foolhardy. However, they can be, and have been, used to help measure the dependency structure of an application. Figure 2-29 What do we put X on the A vs I Graph? C X A D A I  1  2 ------------------------  D A I  1   Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 28 Patterns of Object Oriented Architecture When following the principles described above to create object oriented architectures, , one finds that one repeats the same structures over and over again. These repeating structures of design and architecture are known as design patterns1.

--- Chunk 31 ---
Tokens: 394
Type: sentence-based
Text:
These repeating structures of design and architecture are known as design patterns1. The essential definition of a design pattern is a well worn and known good solution to a common problem. Design patterns are definitively not new. Rather they are old techniques that have shown their usefulness over a period of many years. Some common design patterns are described below. These are the patterns that you will come accross while reading through the case studies later in the book. It should be noted that the topic of Design Patterns cannot be adequately covered in a single chapter of a single book. Interested readers are strongly encouraged to read GOF96. Abstract Server When a client depends directly on a server, the DIP is violated. Changes to the server will propogate to the client, and the client will be unable to easily use similar servers. This can be rectified by inserting an anbstract interface between the client and the server as shown in Figure 2-30. The abstract interface becomes a hinge point upon which the design can flex. Dif- ferent implementations of the server can be bound to an unsuspecting client. 1. GOF96 Figure 2-30 Abstract Server Consumer Resource Manager interface Resource Manager_I Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 29 Adapter When inserting an abstract interface is infeasible because the server is third party soft- ware, or is so heavily depended upon that it cannot easily be changed, an ADAPTER can be used to bind the abstract interface to the server. See Figure 2-31.

--- Chunk 32 ---
Tokens: 393
Type: sentence-based
Text:
See Figure 2-31. The adapter is an object that implements the abstract interface to delegate to the server. Every method of the adpater simply translates and then delegates. Observer It often occurs that one element of a design needs to take some form of action when another element in the design discovers that an event has occurred. However, we fre- quently dont want the detector to know about the actor. Consider the case of a meter that shows the status of a sensor. Every time the sensor changes its reading we want the meter to display the new value. However, we dont want the sensor to know anything about the meter. We can address this situation with an OBSERVER, see Figure 2-32. The Sensor derives from a class named Subject, and Meter derives from an interface called Observer. Subject contains a list of Observers. This list is loaded by the Regsiter method of Subject. In order to be told of events, our Meter must reg- ister with the Subject base class of the Sensor. Figure 2-33 describes the dynamics of the collaboration. Some entity passes control to the Sensor who determines that its reading has changed. The Sensor calls Notify on its Subject. The Subject then cycles through all the Observers Figure 2-31 Adapter Consumer Resource Manager interface Resource Manager_I Resource Manager Adapter Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 30 that have been registered, calling Update on each. The Update message is caught by the Meter who uses it to read the new value of the Sensor and display it.

--- Chunk 33 ---
Tokens: 398
Type: sentence-based
Text:
The Update message is caught by the Meter who uses it to read the new value of the Sensor and display it. Bridge One of the problems with implementing an abstract class with inheritance is that the derived class is so tightly coupled to the base class. This can lead to problems when other clients want to use the derived class functions without dragging along the bag- gage of the base hiearchy. Figure 2-32 Observer Structure Figure 2-33  Check()  GetValue() : double Sensor  Update() Meter Subject  Update Observer  interface  Register(Observer)  Notify Sensor Meter Check Subject Notify Update Observer GetValue Value Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 31 For example, consider a music synthesizer class. The base class translates MIDI input into a set of primitive EmitVoice calls that are implemented by a derived class. Note that the EmitVoice function of the derived class would be useful, in and of itself. Unforunately it is inextricably bound to the MusicSynthesizer class and the PlayMidi function. There is no way to get at the PlayVoice method without dragging the base class around with it. Also, there is no way to create different imple- mentations of the PlayMidi function that use the same EmitVoice function. In short, the hiearchy is just to coupled. The BRIDGE pattern solves this problem by creating a strong seperation between the interface and implementation. Figure 2-35 shows how this works. The MusicSynthesizer class contains an abstract PlayMidi function which is implemented by MusicSynthesizer_I.

--- Chunk 34 ---
Tokens: 387
Type: sentence-based
Text:
The MusicSynthesizer class contains an abstract PlayMidi function which is implemented by MusicSynthesizer_I. It calls the EmitVoice function that is implemented in MusicSynthesizer to delegate to the VoiceEmitter inter- face. This interface is implemented by VoiceEmitter_I and emits the necessary sounds. Now it is possible to implement both EmitVoice and PlayMidi separately from each other. The two functions have been decoupled. EmitVoice can be called with- out bringing along all the MusicSynthesizer baggage, and PlayMidi can be implemented any number of different ways, while still using the same EmitVoice function. Figure 2-34 Badly coupled hierarchy Music Synthesizer abstract  PlayMidi - EmitVoice  EmitVoice Music Synthesizer_I Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 32 Abstract Factory The DIP strongly recommends that modules not depend upon concrete classes. How- ever, in order ot create an instance of a class, you must depend upon the concrete class. ABSTRACTFACTORY is a pattern that allows that dependency upon the concrete class to exist in one, and only one, place. Figure 2-36 shows how this is accomplished for the Modem example. All the users who wish to create modems use an interface called ModemFactory. A pointer to this interface is held in a global variable named GtheFactory. The users call the Make function passing in a string that uniquely defines the particular subclass of Modem that they want. The Make function returns a pointer to a Modem interface.

--- Chunk 35 ---
Tokens: 396
Type: sentence-based
Text:
The Make function returns a pointer to a Modem interface. The ModemFactory interface it implemented by ModemFactory_I. This class is created by main, and a pointer to it is loaded into the GtheFactory global. Thus, no module in the system knows about the concrete modem classes except for ModemFactory_I, and no module knows about ModemFactory_I except for main. Conclusion This chapter has introduced the concept of object oriented architecture and defined it as the structure of classes and packages that keeps the software application flexible, robust, reusable, and developable. The principles and patterns presented here support Figure 2-35 Hierarchy decoupled with Bridge Music Synthesizer abstract  PlayMidi - EmitVoice - PlayMidi Music Synthesizer_I  EmitVoice Voice Emitter interface Voice Emitter_I Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 33 such architectures, and have been proven over time to be powerful aids in software architecture. This has been an overview. There is much more to be said about the topic of OO architecture than can be said in the few pages of this chapter, indeed by foreshorten- ing the topic so much, we have run the risk of doing the reader a disservice. It has been said that a little knowledge is a dangerous thing, and this chapter has provided a little knowledge. We strongly urge you to search out the books and papers in the cit- ings of this chapter to learn more. Bibliography Shaw96: Patterns of Software Architecture (? ), Garlan and Shaw, . GOF96: Design Patterns. OOSC98: OOSC.

--- Chunk 36 ---
Tokens: 192
Type: sentence-based
Text:
OOSC98: OOSC. Figure 2-36 Abstract Factory  Make(string) : Modem Modem Factory interface Users GtheFactory global Modem Factory_I main main program creates Hayes Courrier Ernie Modem interface creates Robert C. Martin Copyright (c) 2000 by Robert C. Martin. All Rights Reserved. www.objectmentor.com 34 OCP97: The Open Closed Principle, Robert C. Martin. LSP97: The Liskov Substitution Principle, Robert C. Martin DIP97: The Dependency Inversion Principle, Robert C. Martin ISP97: The Interface Segregation Principle, Robert C. Martin Granularity97: Granularity, Robert C. Martin Stability97: Stability, Robert C. Martin Liksov88: Data Abstraction and Hierarchy. Martin99: Designing Object Oriented Applications using UML, 2d. ed, Robert C. Martin, Prentice Hall, 1999.

================================================================================
SOURCE: MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf
TOTAL CHUNKS: 41
================================================================================

--- Chunk 0 ---
Tokens: 364
Type: sentence-based
Text:
Software Design Basics Software design is a process to transform user requirements into some suitable form, which helps the programmer in software coding and implementation. For assessing user requirements, an SRS (Software Requirement Specification) document is created whereas for coding and implementation, there is a need of more specific and detailed requirements in software terms. The output of this process can directly be used into implementation in programming languages. Software design is the first step in SDLC (Software Design Life Cycle), which moves the concentration from problem domain to solution domain. It tries to specify how to fulfill the requirements mentioned in SRS. Software Design Levels Software design yields three levels of results:  Architectural Design - The architectural design is the highest abstract version of the system. It identifies the software as a system with many components interacting with each other. At this level, the designers get the idea of proposed solution domain. High-level Design- The high-level design breaks the single entity-multiple component concept of architectural design into less-abstracted view of sub-systems and modules and depicts their interaction with each other. High-level design focuses on how the system along with all of its components can be implemented in forms of modules. It recognizes modular structure of each sub-system and their relation and interaction among each other.

--- Chunk 1 ---
Tokens: 381
Type: sentence-based
Text:
It recognizes modular structure of each sub-system and their relation and interaction among each other. Detailed Design- Detailed design deals with the implementation part of what is seen as a system and its sub- systems in the previous two designs. It is more detailed towards modules and their implementations. It defines logical structure of each module and their interfaces to communicate with other modules. Modularization Modularization is a technique to divide a software system into multiple discrete and independent modules, which are expected to be capable of carrying out task(s) independently. These modules may work as basic constructs for the entire software. Designers tend to design modules such that they can be executed andor compiled separately and independently. Modular design unintentionally follows the rules of divide and conquer problem-solving strategy this is because there are many other benefits attached with the modular design of a software. Advantage of modularization:  Smaller components are easier to maintain  Program can be divided based on functional aspects  Desired level of abstraction can be brought in the program  Components with high cohesion can be re-used again  Concurrent execution can be made possible  Desired from security aspect Concurrency Back in time, all software are meant to be executed sequentially. By sequential execution we mean that the coded instruction will be executed one after another implying only one portion of program being activated at any given time.

--- Chunk 2 ---
Tokens: 365
Type: sentence-based
Text:
By sequential execution we mean that the coded instruction will be executed one after another implying only one portion of program being activated at any given time. Say, a software has multiple modules, then only one of all the modules can be found active at any time of execution. In software design, concurrency is implemented by splitting the software into multiple independent units of execution, like modules and executing them in parallel. In other words, concurrency provides capability to the software to execute more than one part of code in parallel to each other. It is necessary for the programmers and designers to recognize those modules, which can be made parallel execution. Example The spell check feature in word processor is a module of software, which runs alongside the word processor itself. Coupling and Cohesion When a software program is modularized, its tasks are divided into several modules based on some characteristics. As we know, modules are set of instructions put together in order to achieve some tasks. They are though, considered as single entity but may refer to each other to work together. There are measures by which the quality of a design of modules and their interaction among them can be measured. These measures are called coupling and cohesion. Cohesion Cohesion is a measure that defines the degree of intra- dependability within elements of a module. The greater the cohesion, the better is the program design.

--- Chunk 3 ---
Tokens: 390
Type: sentence-based
Text:
The greater the cohesion, the better is the program design. There are seven types of cohesion, namely   Co-incidental cohesion - It is unplanned and random cohesion, which might be the result of breaking the program into smaller modules for the sake of modularization. Because it is unplanned, it may serve confusion to the programmers and is generally not-accepted. Logical cohesion - When logically categorized elements are put together into a module, it is called logical cohesion. Temporal Cohesion - When elements of module are organized such that they are processed at a similar point in time, it is called temporal cohesion. Procedural cohesion - When elements of module are grouped together, which are executed sequentially in order to perform a task, it is called procedural cohesion. Communicational cohesion - When elements of module are grouped together, which are executed sequentially and work on same data (information), it is called communicational cohesion. Sequential cohesion - When elements of module are grouped because the output of one element serves as input to another and so on, it is called sequential cohesion. Functional cohesion - It is considered to be the highest degree of cohesion, and it is highly expected. Elements of module in functional cohesion are grouped because they all contribute to a single well-defined function. It can also be reused. Coupling Coupling is a measure that defines the level of inter-dependability among modules of a program. It tells at what level the modules interfere and interact with each other.

--- Chunk 4 ---
Tokens: 373
Type: sentence-based
Text:
It tells at what level the modules interfere and interact with each other. The lower the coupling, the better the program. There are five levels of coupling, namely -  Content coupling - When a module can directly access or modify or refer to the content of another module, it is called content level coupling. Common coupling- When multiple modules have read and write access to some global data, it is called common or global coupling. Control coupling- Two modules are called control-coupled if one of them decides the function of the other module or changes its flow of execution. Stamp coupling- When multiple modules share common data structure and work on different part of it, it is called stamp coupling. Data coupling- Data coupling is when two modules interact with each other by means of passing data (as parameter). If a module passes data structure as parameter, then the receiving module should use all its components. Ideally, no coupling is considered to be the best. Design Verification The output of software design process is design documentation, pseudo codes, detailed logic diagrams, process diagrams, and detailed description of all functional or non-functional requirements. The next phase, which is the implementation of software, depends on all outputs mentioned above. It is then becomes necessary to verify the output before proceeding to the next phase. The early any mistake is detected, the better it is or it might not be detected until testing of the product.

--- Chunk 5 ---
Tokens: 396
Type: sentence-based
Text:
The early any mistake is detected, the better it is or it might not be detected until testing of the product. If the outputs of design phase are in formal notation form, then their associated tools for verification should be used otherwise a thorough design review can be used for verification and validation. By structured verification approach, reviewers can detect defects that might be caused by overlooking some conditions. A good design review is important for good software design, accuracy and quality. Software Design Strategies Software design is a process to conceptualize the software requirements into software implementation. Software design takes the user requirements as challenges and tries to find optimum solution. While the software is being conceptualized, a plan is chalked out to find the best possible design for implementing the intended solution. There are multiple variants of software design. Let us study them briefly: Structured Design Structured design is a conceptualization of problem into several well-organized elements of solution. It is basically concerned with the solution design. Benefit of structured design is, it gives better understanding of how the problem is being solved. Structured design also makes it simpler for designer to concentrate on the problem more accurately. Structured design is mostly based on divide and conquer strategy where a problem is broken into several small problems and each small problem is individually solved until the whole problem is solved. The small pieces of problem are solved by means of solution modules.

--- Chunk 6 ---
Tokens: 377
Type: sentence-based
Text:
The small pieces of problem are solved by means of solution modules. Structured design emphasis that these modules be well organized in order to achieve precise solution. These modules are arranged in hierarchy. They communicate with each other. A good structured design always follows some rules for communication among multiple modules, namely - Cohesion - grouping of all functionally related elements. Coupling - communication between different modules. A good structured design has high cohesion and low coupling arrangements. Function Oriented Design In function-oriented design, the system is comprised of many smaller sub-systems known as functions. These functions are capable of performing significant task in the system. The system is considered as top view of all functions. Function oriented design inherits some properties of structured design where divide and conquer methodology is used. This design mechanism divides the whole system into smaller functions, which provides means of abstraction by concealing the information and their operation. These functional modules can share information among themselves by means of information passing and using information available globally. Another characteristic of functions is that when a program calls a function, the function changes the state of the program, which sometimes is not acceptable by other modules. Function oriented design works well where the system state does not matter and programfunctions work on input rather than on a state.

--- Chunk 7 ---
Tokens: 391
Type: sentence-based
Text:
Function oriented design works well where the system state does not matter and programfunctions work on input rather than on a state. Design Process  The whole system is seen as how data flows in the system by means of data flow diagram. DFD depicts how functions changes data and state of entire system. The entire system is logically broken down into smaller units known as functions on the basis of their operation in the system. Each function is then described at large. Object Oriented Design Object oriented design works around the entities and their characteristics instead of functions involved in the software system. This design strategy focuses on entities and its characteristics. The whole concept of software solution revolves around the engaged entities. Let us see the important concepts of Object Oriented Design:  Objects - All entities involved in the solution design are known as objects. For example, person, banks, company and customers are treated as objects. Every entity has some attributes associated to it and has some methods to perform on the attributes. Classes - A class is a generalized description of an object. An object is an instance of a class. Class defines all the attributes, which an object can have and methods, which defines the functionality of the object. In the solution design, attributes are stored as variables and functionalities are defined by means of methods or procedures. Encapsulation - In OOD, the attributes (data variables) and methods (operation on the data) are bundled together is called encapsulation.

--- Chunk 8 ---
Tokens: 378
Type: sentence-based
Text:
Encapsulation - In OOD, the attributes (data variables) and methods (operation on the data) are bundled together is called encapsulation. Encapsulation not only bundles important information of an object together, but also restricts access of the data and methods from the outside world. This is called information hiding. Inheritance - OOD allows similar classes to stack up in hierarchical manner where the lower or sub-classes can import, implement and re-use allowed variables and methods from their immediate super classes. This property of OOD is known as inheritance. This makes it easier to define specific class and to create generalized classes from specific ones. Polymorphism - OOD languages provide a mechanism where methods performing similar tasks but vary in arguments, can be assigned same name. This is called polymorphism, which allows a single interface performing tasks for different types. Depending upon how the function is invoked, respective portion of the code gets executed. Design Process Software design process can be perceived as series of well- defined steps. Though it varies according to design approach (function oriented or object oriented, yet It may have the following steps involved:  A solution design is created from requirement or previous used system andor system sequence diagram. Objects are identified and grouped into classes on behalf of similarity in attribute characteristics. Class hierarchy and relation among them is defined. Application framework is defined.

--- Chunk 9 ---
Tokens: 388
Type: sentence-based
Text:
Application framework is defined. Software Design Approaches Here are two generic approaches for software designing: Top Down Design We know that a system is composed of more than one sub- systems and it contains a number of components. Further, these sub-systems and components may have their on set of sub-system and components and creates hierarchical structure in the system. Top-down design takes the whole software system as one entity and then decomposes it to achieve more than one sub-system or component based on some characteristics. Each sub-system or component is then treated as a system and decomposed further. This process keeps on running until the lowest level of system in the top-down hierarchy is achieved. Top-down design starts with a generalized model of system and keeps on defining the more specific part of it. When all components are composed the whole system comes into existence. Top-down design is more suitable when the software solution needs to be designed from scratch and specific details are unknown. Bottom-up Design The bottom up design model starts with most specific and basic components. It proceeds with composing higher level of components by using basic or lower level components. It keeps creating higher level components until the desired system is not evolved as one single component. With each higher level, the amount of abstraction is increased. Bottom-up strategy is more suitable when a system needs to be created from some existing system, where the basic primitives can be used in the newer system.

--- Chunk 10 ---
Tokens: 399
Type: sentence-based
Text:
Bottom-up strategy is more suitable when a system needs to be created from some existing system, where the basic primitives can be used in the newer system. Both, top-down and bottom-up approaches are not practical individually. Instead, a good combination of both is used. Software Implementation Structured Programming In the process of coding, the lines of code keep multiplying, thus, size of the software increases. Gradually, it becomes next to impossible to remember the flow of program. If one forgets how software and its underlying programs, files, procedures are constructed it then becomes very difficult to share, debug and modify the program. The solution to this is structured programming. It encourages the developer to use subroutines and loops instead of using simple jumps in the code, thereby bringing clarity in the code and improving its efficiency Structured programming also helps programmer to reduce coding time and organize code properly. Structured programming states how the program shall be coded. Structured programming uses three main concepts:  Top-down analysis - A software is always made to perform some rational work. This rational work is known as problem in the software parlance. Thus it is very important that we understand how to solve the problem. Under top-down analysis, the problem is broken down into small pieces where each one has some significance. Each problem is individually solved and steps are clearly stated about how to solve the problem. Modular Programming - While programming, the code is broken down into smaller group of instructions.

--- Chunk 11 ---
Tokens: 396
Type: sentence-based
Text:
Modular Programming - While programming, the code is broken down into smaller group of instructions. These groups are known as modules, subprograms or subroutines. Modular programming based on the understanding of top- down analysis. It discourages jumps using goto statements in the program, which often makes the program flow non- traceable. Jumps are prohibited and modular format is encouraged in structured programming. Structured Coding - In reference with top-down analysis, structured coding sub-divides the modules into further smaller units of code in the order of their execution. Structured programming uses control structure, which controls the flow of the program, whereas structured coding uses control structure to organize its instructions in definable patterns. Functional Programming Functional programming is style of programming language, which uses the concepts of mathematical functions. A function in mathematics should always produce the same result on receiving the same argument. In procedural languages, the flow of the program runs through procedures, i.e. the control of program is transferred to the called procedure. While control flow is transferring from one procedure to another, the program changes its state. In procedural programming, it is possible for a procedure to produce different results when it is called with the same argument, as the program itself can be in different state while calling it. This is a property as well as a drawback of procedural programming, in which the sequence or timing of the procedure execution becomes important.

--- Chunk 12 ---
Tokens: 396
Type: sentence-based
Text:
This is a property as well as a drawback of procedural programming, in which the sequence or timing of the procedure execution becomes important. Functional programming provides means of computation as mathematical functions, which produces results irrespective of program state. This makes it possible to predict the behavior of the program. Functional programming uses the following concepts:  First class and High-order functions - These functions have capability to accept another function as argument or they return other functions as results. Pure functions - These functions do not include destructive updates, that is, they do not affect any IO or memory and if they are not in use, they can easily be removed without hampering the rest of the program. Recursion - Recursion is a programming technique where a function calls itself and repeats the program code in it unless some pre-defined condition matches. Recursion is the way of creating loops in functional programming. Strict evaluation - It is a method of evaluating the expression passed to a function as an argument. Functional programming has two types of evaluation methods, strict (eager) or non-strict (lazy). Strict evaluation always evaluates the expression before invoking the function. Non- strict evaluation does not evaluate the expression unless it is needed. -calculus - Most functional programming languages use - calculus as their type systems. -expressions are executed by evaluating them as they occur. Common Lisp, Scala, Haskell, Erlang and F are some examples of functional programming languages.

--- Chunk 13 ---
Tokens: 383
Type: sentence-based
Text:
Common Lisp, Scala, Haskell, Erlang and F are some examples of functional programming languages. Programming style Programming style is set of coding rules followed by all the programmers to write the code. When multiple programmers work on the same software project, they frequently need to work with the program code written by some other developer. This becomes tedious or at times impossible, if all developers do not follow some standard programming style to code the program. An appropriate programming style includes using function and variable names relevant to the intended task, using well-placed indentation, commenting code for the convenience of reader and overall presentation of code. This makes the program code readable and understandable by all, which in turn makes debugging and error solving easier. Also, proper coding style helps ease the documentation and updation. Coding Guidelines Practice of coding style varies with organizations, operating systems and language of coding itself. The following coding elements may be defined under coding guidelines of an organization:  Naming conventions - This section defines how to name functions, variables, constants and global variables. Indenting - This is the space left at the beginning of line, usually 2-8 whitespace or single tab. Whitespace - It is generally omitted at the end of line. Operators - Defines the rules of writing mathematical, assignment and logical operators. For example, assignment operator  should have space before and after it, as in x  2.

--- Chunk 14 ---
Tokens: 369
Type: sentence-based
Text:
For example, assignment operator  should have space before and after it, as in x  2. Control Structures - The rules of writing if-then-else, case- switch, while-until and for control flow statements solely and in nested fashion. Line length and wrapping - Defines how many characters should be there in one line, mostly a line is 80 characters long. Wrapping defines how a line should be wrapped, if is too long. Functions - This defines how functions should be declared and invoked, with and without parameters. Variables - This mentions how variables of different data types are declared and defined. Comments - This is one of the important coding components, as the comments included in the code describe what the code actually does and all other associated descriptions. This section also helps creating help documentations for other developers. Software Documentation Software documentation is an important part of software process. A well written document provides a great tool and means of information repository necessary to know about software process. Software documentation also provides information about how to use the product. A well-maintained documentation should involve the following documents:  Requirement documentation - This documentation works as key tool for software designer, developer and the test team to carry out their respective tasks. This document contains all the functional, non-functional and behavioral description of the intended software.

--- Chunk 15 ---
Tokens: 399
Type: sentence-based
Text:
This document contains all the functional, non-functional and behavioral description of the intended software. Source of this document can be previously stored data about the software, already running software at the clients end, clients interview, questionnaires and research. Generally it is stored in the form of spreadsheet or word processing document with the high-end software management team. This documentation works as foundation for the software to be developed and is majorly used in verification and validation phases. Most test-cases are built directly from requirement documentation. Software Design documentation - These documentations contain all the necessary information, which are needed to build the software. It contains: (a) High-level software architecture, (b) Software design details, (c) Data flow diagrams, (d) Database design These documents work as repository for developers to implement the software. Though these documents do not give any details on how to code the program, they give all necessary information that is required for coding and implementation. Technical documentation - These documentations are maintained by the developers and actual coders. These documents, as a whole, represent information about the code. While writing the code, the programmers also mention objective of the code, who wrote it, where will it be required, what it does and how it does, what other resources the code uses, etc. The technical documentation increases the understanding between various programmers working on the same code. It enhances re-use capability of the code.

--- Chunk 16 ---
Tokens: 383
Type: sentence-based
Text:
It enhances re-use capability of the code. It makes debugging easy and traceable. There are various automated tools available and some comes with the programming language itself. For example java comes JavaDoc tool to generate technical documentation of code. User documentation - This documentation is different from all the above explained. All previous documentations are maintained to provide information about the software and its development process. But user documentation explains how the software product should work and how it should be used to get the desired results. These documentations may include, software installation procedures, how-to guides, user-guides, uninstallation method and special references to get more information like license updation etc. Software Implementation Challenges There are some challenges faced by the development team while implementing the software. Some of them are mentioned below:  Code-reuse - Programming interfaces of present-day languages are very sophisticated and are equipped huge library functions. Still, to bring the cost down of end product, the organization management prefers to re-use the code, which was created earlier for some other software. There are huge issues faced by programmers for compatibility checks and deciding how much code to re-use. Version Management - Every time a new software is issued to the customer, developers have to maintain version and configuration related documentation. This documentation needs to be highly accurate and available on time.

--- Chunk 17 ---
Tokens: 368
Type: sentence-based
Text:
This documentation needs to be highly accurate and available on time. Target-Host - The software program, which is being developed in the organization, needs to be designed for host machines at the customers end. But at times, it is impossible to design a software that works on the target machines. Design-notations Software Design Strategies Software analysis and design includes all activities, which help the transformation of requirement specification into implementation. Requirement specifications specify all functional and non- functional expectations from the software. These requirement specifications come in the shape of human readable and understandable documents, to which a computer has nothing to do. Software analysis and design is the intermediate stage, which helps human-readable requirements to be transformed into actual code. Let us see few analysis and design tools used by software designers: Data Flow Diagram Data flow diagram is graphical representation of flow of data in an information system. It is capable of depicting incoming data flow, outgoing data flow and stored data. The DFD does not mention anything about how data flows through the system. There is a prominent difference between DFD and Flowchart. The flowchart depicts flow of control in program modules. DFDs depict flow of data in the system at various levels. DFD does not contain any control or branch elements. Types of DFD Data Flow Diagrams are either Logical or Physical.

--- Chunk 18 ---
Tokens: 392
Type: sentence-based
Text:
Types of DFD Data Flow Diagrams are either Logical or Physical. Logical DFD - This type of DFD concentrates on the system process, and flow of data in the system.For example in a Banking software system, how data is moved between different entities. Physical DFD - This type of DFD shows how the data flow is actually implemented in the system. It is more specific and close to the implementation. DFD Components DFD can represent Source, destination, storage and flow of data using the following set of components -  Entities - Entities are source and destination of information data. Entities are represented by a rectangles with their respective names. Process - Activities and action taken on the data are represented by Circle or Round-edged rectangles. Data Storage - There are two variants of data storage - it can either be represented as a rectangle with absence of both smaller sides or as an open-sided rectangle with only one side missing. Data Flow - Movement of data is shown by pointed arrows. Data movement is shown from the base of arrow as its source towards head of the arrow as destination. Levels of DFD  Level 0 - Highest abstraction level DFD is known as Level 0 DFD, which depicts the entire information system as one diagram concealing all the underlying details. Level 0 DFDs are also known as context level DFDs. Level 1 - The Level 0 DFD is broken down into more specific, Level 1 DFD. Level 1 DFD depicts basic modules in the system and flow of data among various modules. Level 1 DFD also mentions basic processes and sources of information.

--- Chunk 19 ---
Tokens: 378
Type: sentence-based
Text:
Level 1 DFD also mentions basic processes and sources of information. Level 2 - At this level, DFD shows how data flows inside the modules mentioned in Level 1. Higher level DFDs can be transformed into more specific lower level DFDs with deeper level of understanding unless the desired level of specification is achieved. Structure Charts Structure chart is a chart derived from Data Flow Diagram. It represents the system in more detail than DFD. It breaks down the entire system into lowest functional modules, describes functions and sub-functions of each module of the system to a greater detail than DFD. Structure chart represents hierarchical structure of modules. At each layer a specific task is performed. Here are the symbols used in construction of structure charts -  Module - It represents process or subroutine or task. A control module branches to more than one sub-module. Library Modules are re-usable and inviolable from any module. Condition - It is represented by small diamond at the base of module. It depicts that control module can select any of sub-routine based on some condition. Jump - An arrow is shown pointing inside the module to depict that the control will jump in the middle of the sub- module. Loop - A curved arrow represents loop in the module. All sub-modules covered by loop repeat execution of module. Data flow - A directed arrow with empty circle at the end represents data flow. Control flow - A directed arrow with filled circle at the end represents control flow.

--- Chunk 20 ---
Tokens: 393
Type: sentence-based
Text:
Control flow - A directed arrow with filled circle at the end represents control flow. HIPO Diagram HIPO (Hierarchical Input Process Output) diagram is a combination of two organized method to analyze the system and provide the means of documentation. HIPO model was developed by IBM in year 1970. HIPO diagram represents the hierarchy of modules in the software system. Analyst uses HIPO diagram in order to obtain high-level view of system functions. It decomposes functions into sub-functions in a hierarchical manner. It depicts the functions performed by system. HIPO diagrams are good for documentation purpose. Their graphical representation makes it easier for designers and managers to get the pictorial idea of the system structure. In contrast to IPO (Input Process Output) diagram, which depicts the flow of control and data in a module, HIPO does not provide any information about data flow or control flow. Example Both parts of HIPO diagram, Hierarchical presentation and IPO Chart are used for structure design of software program as well as documentation of the same. Structured English Most programmers are unaware of the large picture of software so they only rely on what their managers tell them to do. It is the responsibility of higher software management to provide accurate information to the programmers to develop accurate yet fast code. Other forms of methods, which use graphs or diagrams, may are sometimes interpreted differently by different people. Hence, analysts and designers of the software come up with tools such as Structured English.

--- Chunk 21 ---
Tokens: 399
Type: sentence-based
Text:
Hence, analysts and designers of the software come up with tools such as Structured English. It is nothing but the description of what is required to code and how to code it. Structured English helps the programmer to write error-free code. Other form of methods, which use graphs or diagrams, may are sometimes interpreted differently by different people. Here, both Structured English and Pseudo-Code tries to mitigate that understanding gap. Structured English is the It uses plain English words in structured programming paradigm. It is not the ultimate code but a kind of description what is required to code and how to code it. The following are some tokens of structured programming. IF-THEN-ELSE, DO-WHILE-UNTIL Analyst uses the same variable and data name, which are stored in Data Dictionary, making it much simpler to write and understand the code. Example We take the same example of Customer Authentication in the online shopping environment. This procedure to authenticate customer can be written in Structured English as: Enter Customer_Name SEEK Customer_Name in Customer_Name_DB file IF Customer_Name found THEN Call procedure USER_PASSWORD_AUTHENTICATE() ELSE PRINT error message Call procedure NEW_CUSTOMER_REQUEST() ENDIF The code written in Structured English is more like day-to-day spoken English. It can not be implemented directly as a code of software. Structured English is independent of programming language. Pseudo-Code Pseudo code is written more close to programming language. It may be considered as augmented programming language, full of comments and descriptions.

--- Chunk 22 ---
Tokens: 393
Type: sentence-based
Text:
It may be considered as augmented programming language, full of comments and descriptions. Pseudo code avoids variable declaration but they are written using some actual programming languages constructs, like C, Fortran, Pascal etc. Pseudo code contains more programming details than Structured English. It provides a method to perform the task, as if a computer is executing the code. Example Program to print Fibonacci up to n numbers. void function Fibonacci Get value of n; Set value of a to 1; Set value of b to 1; Initialize I to 0 for (i0; i n; i)  if a greater than b  Increase b by a; Print b;  else if b greater than a  increase a by b; print a;   Decision Tables A Decision table represents conditions and the respective actions to be taken to address them, in a structured tabular format. It is a powerful tool to debug and prevent errors. It helps group similar information into a single table and then by combining tables it delivers easy and convenient decision-making. Creating Decision Table To create the decision table, the developer must follow basic four steps:  Identify all possible conditions to be addressed  Determine actions for all identified conditions  Create Maximum possible rules  Define action for each rule Decision Tables should be verified by end-users and can lately be simplified by eliminating duplicate rules and actions. Example Let us take a simple example of day-to-day problem with our Internet connectivity. We begin by identifying all problems that can arise while starting the internet and their respective possible solutions.

--- Chunk 23 ---
Tokens: 370
Type: sentence-based
Text:
We begin by identifying all problems that can arise while starting the internet and their respective possible solutions. We list all possible problems under column conditions and the prospective actions under column Actions. ConditionsActions Rules Conditions Shows Connected N N N N Y Y Y Y Ping is Working N N Y Y N N Y Y Opens Website Y N Y N Y N Y N Actions Check network cable X Check internet router X X X X Restart Web Browser X Contact Service provider X X X X X X Do no action Table : Decision Table  In-house Internet Troubleshooting Entity-Relationship Model Entity-Relationship model is a type of database model based on the notion of real world entities and relationship among them. We can map real world scenario onto ER database model. ER Model creates a set of entities with their attributes, a set of constraints and relation among them. ER Model is best used for the conceptual design of database. ER Model can be represented as follows :  Entity - An entity in ER Model is a real world being, which has some properties called attributes. Every attribute is defined by its corresponding set of values, called domain. For example, consider a school database. Here, a student is an entity. Student has various attributes like name, id, age and class etc. Relationship - The logical association among entities is called relationship. Relationships are mapped with entities in various ways. Mapping cardinalities define the number of associations between two entities.

--- Chunk 24 ---
Tokens: 341
Type: sentence-based
Text:
Mapping cardinalities define the number of associations between two entities. Mapping cardinalities: o one to one o one to many o many to one o many to many Data Dictionary Data dictionary is the centralized collection of information about data. It stores meaning and origin of data, its relationship with other data, data format for usage etc. Data dictionary has rigorous definitions of all names in order to facilitate user and software designers. Data dictionary is often referenced as meta-data (data about data) repository. It is created along with DFD (Data Flow Diagram) model of software program and is expected to be updated whenever DFD is changed or updated. Requirement of Data Dictionary The data is referenced via data dictionary while designing and implementing software. Data dictionary removes any chances of ambiguity. It helps keeping work of programmers and designers synchronized while using same object reference everywhere in the program. Data dictionary provides a way of documentation for the complete database system in one place. Validation of DFD is carried out using data dictionary. Contents Data dictionary should contain information about the following  Data Flow  Data Structure  Data Elements  Data Stores  Data Processing Data Flow is described by means of DFDs as studied earlier and represented in algebraic form as described.

--- Chunk 25 ---
Tokens: 379
Type: sentence-based
Text:
Contents Data dictionary should contain information about the following  Data Flow  Data Structure  Data Elements  Data Stores  Data Processing Data Flow is described by means of DFDs as studied earlier and represented in algebraic form as described. Composed of  Repetition () Optional  And    Or Example Address  House No  (Street  Area)  City  State Course ID  Course Number  Course Name  Course Level  Course Grades Data Elements Data elements consist of Name and descriptions of Data and Control Items, Internal or External data stores etc. with the following details:  Primary Name  Secondary Name (Alias)  Use-case (How and where to use)  Content Description (Notation etc. ) Supplementary Information (preset values, constraints etc.) Data Store It stores the information from where the data enters into the system and exists out of the system. The Data Store may include -  Files o Internal to software. o External to software but on the same machine. o External to software and system, located on different machine. Tables o Naming convention o Indexing property Data Processing There are two types of Data Processing:  Logical: As user sees it  Physical: As software sees it Principles of Software Design  Concepts in Software Engineering Once the requirements document for the software to be developed is available, the software design phase begins. While the requirement specification activity deals entirely with the problem domain, design is the first phase of transforming the problem into a solution.

--- Chunk 26 ---
Tokens: 397
Type: sentence-based
Text:
While the requirement specification activity deals entirely with the problem domain, design is the first phase of transforming the problem into a solution. In the design phase, the customer and business requirements and technical considerations all come together to formulate a product or a system. The design process comprises a set of principles, concepts and practices, which allow a software engineer to model the system or product that is to be built. This model, known as design model, is assessed for quality and reviewed before a code is generated and tests are conducted. The design model provides details about software data structures, architecture, interfaces and components which are required to implement the system. This chapter discusses the design elements that are required to develop a software design model. It also discusses the design patterns and various software design notations used to represent a software design. Basic of Software Design Software design is a phase in software engineering, in which a blueprint is developed to serve as a base for constructing the software system. IEEE defines software design as both a process of defining, the architecture, components, interfaces, and other characteristics of a system or component and the result of that process. In the design phase, many critical and strategic decisions are made to achieve the desired functionality and quality of the system. These decisions are taken into account to successfully develop the software and carry out its maintenance in a way that the quality of the end product is improved.

--- Chunk 27 ---
Tokens: 387
Type: sentence-based
Text:
These decisions are taken into account to successfully develop the software and carry out its maintenance in a way that the quality of the end product is improved. Principles of Software Design Developing design is a cumbersome process as most expansive errors are often introduced in this phase. Moreover, if these errors get unnoticed till later phases, it becomes more difficult to correct them. Therefore, a number of principles are followed while designing the software. These principles act as a framework for the designers to follow a good design practice. Some of the commonly followed design principles are as following. 1. Software design should correspond to the analysis model: Often a design element corresponds to many requirements, therefore, we must know how the design model satisfies all the requirements represented by the analysis model. 2. Choose the right programming paradigm: A programming paradigm describes the structure of the software system. Depending on the nature and type of application, different programming paradigms such as procedure oriented, object-oriented, and prototyping paradigms can be used. The paradigm should be chosen keeping constraints in mind such as time, availability of resources and nature of users requirements. 3. Software design should be uniform and integrated: Software design is considered uniform and integrated, if the interfaces are properly defined among the design components. For this, rules, format, and styles are established before the design team starts designing the software. 4.

--- Chunk 28 ---
Tokens: 389
Type: sentence-based
Text:
4. Software design should be flexible: Software design should be flexible enough to adapt changes easily. To achieve the flexibility, the basic design concepts such as abstraction, refinement, and modularity should be applied effectively. 5. Software design should ensure minimal conceptual (semantic) errors: The design team must ensure that major conceptual errors of design such as ambiguousness and inconsistency are addressed in advance before dealing with the syntactical errors present in the design model. 6. Software design should be structured to degrade gently: Software should be designed to handle unusual changes and circumstances, and if the need arises for termination, it must do so in a proper manner so that functionality of the software is not affected. 7. Software design should represent correspondence between the software and real-world problem: The software design should be structured in such away that it always relates with the real-world problem. 8. Software reuse: Software engineers believe on the phrase: do not reinvent the wheel. Therefore, software components should be designed in such a way that they can be effectively reused to increase the productivity. 9. Designing for testability: A common practice that has been followed is to keep the testing phase separate from the design and implementation phases. That is, first the software is developed (designed and implemented) and then handed over to the testers who subsequently determine whether the software is fit for distribution and subsequent use by the customer.

--- Chunk 29 ---
Tokens: 393
Type: sentence-based
Text:
That is, first the software is developed (designed and implemented) and then handed over to the testers who subsequently determine whether the software is fit for distribution and subsequent use by the customer. However, it has become apparent that the process of separating testing is seriously flawed, as if any type of design or implementation errors are found after implementation, then the entire or a substantial part of the software requires to be redone. Thus, the test engineers should be involved from the initial stages. For example, they should be involved with analysts to prepare tests for determining whether the user requirements are being met. 10. Prototyping: Prototyping should be used when the requirements are not completely defined in the beginning. The user interacts with the developer to expand and refine the requirements as the development proceeds. Using prototyping, a quick mock-up of the system can be developed. This mock-up can be used as a effective means to give the users a feel of what the system will look like and demonstrate functions that will be included in the developed system. Prototyping also helps in reducing risks of designing software that is not in accordance with the customers requirements. Note that design principles are often constrained by the existing hardware configuration, the implementation language, the existing file and data structures, and the existing organizational practices. Also, the evolution of each software design should be meticulously designed for future evaluations, references and maintenance.

--- Chunk 30 ---
Tokens: 380
Type: sentence-based
Text:
Also, the evolution of each software design should be meticulously designed for future evaluations, references and maintenance. Software Design Concepts Every software process is characterized by basic concepts along with certain practices or methods. Methods represent the manner through which the concepts are applied. As new technology replaces older technology, many changes occur in the methods that are used to apply the concepts for the development of software. However, the fundamental concepts underlining the software design process remain the same, some of which are described here. Abstraction Abstraction refers to a powerful design tool, which allows software designers to consider components at an abstract level, while neglecting the implementation details of the components. IEEE defines abstraction as a view of a problem that extracts the essential information relevant to a particular purpose and ignores the remainder of the information. The concept of abstraction can be used in two ways: as a process and as an entity. As a process, it refers to a mechanism of hiding irrelevant details and representing only the essential features of an item so that one can focus on important things at a time. As an entity, it refers to a model or view of an item. Each step in the software process is accomplished through various levels of abstraction. At the highest level, an outline of the solution to the problem is presented whereas at the lower levels, the solution to the problem is presented in detail.

--- Chunk 31 ---
Tokens: 400
Type: sentence-based
Text:
At the highest level, an outline of the solution to the problem is presented whereas at the lower levels, the solution to the problem is presented in detail. For example, in the requirements analysis phase, a solution to the problem is presented using the language of problem environment and as we proceed through the software process, the abstraction level reduces and at the lowest level, source code of the software is produced. There are three commonly used abstraction mechanisms in software design, namely, functional abstraction, data abstraction and control abstraction. All these mechanisms allow us to control the complexity of the design process by proceeding from the abstract design model to concrete design model in a systematic manner. 1. Functional abstraction: This involves the use of parameterized subprograms. Functional abstraction can be generalized as collections of subprograms referred to as groups. Within these groups there exist routines which may be visible or hidden. Visible routines can be used within the containing groups as well as within other groups, whereas hidden routines are hidden from other groups and can be used within the containing group only. 2. Data abstraction: This involves specifying data that describes a data object. For example, the data object window encompasses a set of attributes (window type, window dimension) that describe the window object clearly. In this abstraction mechanism, representation and manipulation details are ignored. 3. Control abstraction: This states the desired effect, without stating the exact mechanism of control.

--- Chunk 32 ---
Tokens: 340
Type: sentence-based
Text:
Control abstraction: This states the desired effect, without stating the exact mechanism of control. For example, if and while statements in programming languages (like C and C) are abstractions of machine code implementations, which involve conditional instructions. In the architectural design level, this abstraction mechanism permits specifications of sequential subprogram and exception handlers without the concern for exact details of implementation. Architecture Software architecture refers to the structure of the system, which is composed of various components of a program system, the attributes (properties) of those components and the relationship amongst them. The software architecture enables the software engineers to analyze the software design efficiently. In addition, it also helps them in decision-making and handling risks. The software architecture does the following. Provides an insight to all the interested stakeholders that enable them to communicate with each other  Highlights early design decisions, which have great impact on the software engineering activities (like coding and testing) that follow the design phase  Creates intellectual models of how the system is organized into components and how these components interact with each other. Currently, software architecture is represented in an informal and unplanned manner.

--- Chunk 33 ---
Tokens: 395
Type: sentence-based
Text:
Currently, software architecture is represented in an informal and unplanned manner. Though the architectural concepts are often represented in the infrastructure (for supporting particular architectural styles) and the initial stages of a system configuration, the lack of an explicit independent characterization of architecture restricts the advantages of this design concept in the present scenario. Note that software architecture comprises two elements of design model, namely, data design and architectural design. Patterns A pattern provides a description of the solution to a recurring design problem of some specific domain in such a way that the solution can be used again and again. The objective of each pattern is to provide an insight to a designer who can determine the following. 1. Whether the pattern can be reused 2. Whether the pattern is applicable to the current project 3. Whether the pattern can be used to develop a similar but functionally or structurally different design pattern. Types of Design Patterns Software engineer can use the design pattern during the entire software design process. When the analysis model is developed, the designer can examine the problem description at different levels of abstraction to determine whether it complies with one or more of the following types of design patterns. 1. Architectural patterns: These patterns are high-level strategies that refer to the overall structure and organization of a software system. That is, they define the elements of a software system such as subsystems, components, classes, etc.

--- Chunk 34 ---
Tokens: 379
Type: sentence-based
Text:
That is, they define the elements of a software system such as subsystems, components, classes, etc. In addition, they also indicate the relationship between the elements along with the rules and guidelines for specifying these relationships. Note that architectural patterns are often considered equivalent to software architecture. 2. Design patterns: These patterns are medium-level strategies that are used to solve design problems. They provide a means for the refinement of the elements (as defined by architectural pattern) of a software system or the relationship among them. Specific design elements such as relationship among components or mechanisms that affect component-to-component interaction are addressed by design patterns. Note that design patterns are often considered equivalent to software components. 3. Idioms: These patterns are low-level patterns, which are programming-language specific. They describe the implementation of a software component, the method used for interaction among software components, etc, in a specific programming language. Note that idioms are often termed as coding patterns. Modularity Modularity is achieved by dividing the software into uniquely named and addressable components,which are also known as modules. A complex system (large program) is partitioned into a set of discrete modules in such a way that each module can be developed independent of other modules. After developing the modules, they are integrated together to meet the software requirements.

--- Chunk 35 ---
Tokens: 382
Type: sentence-based
Text:
After developing the modules, they are integrated together to meet the software requirements. Note that larger the number of modules a system is divided into, greater will be the effort required to integrate the modules. Modularizing a design helps to plan the development in a more effective manner, accommodate changes easily, conduct testing and debugging effectively and efficiently, and conduct maintenance work without adversely affecting the functioning of the software. Information Hiding Modules should be specified and designed in such a way that the data structures and processing details of one module are not accessible to other modules. They pass only that much information to each other, which is required to accomplish the software functions. The way of hiding unnecessary details is referred to as information hiding. IEEE defines information hiding as the technique of encapsulating software design decisions in modules in such a way that the modules interfaces reveal as little as possible about the modules inner workings; thus each module is a black box to the other modules in the system. Information hiding is of immense use when modifications are required during the testing and maintenance phase. Some of the advantages associated with information hiding are listed below. 1. Leads to low coupling 2. Emphasizes communication through controlled interfaces 3. Decreases the probability of adverse effects 4. Restricts the effects of changes in one component on others 5. Results in higher quality software.

--- Chunk 36 ---
Tokens: 379
Type: sentence-based
Text:
Results in higher quality software. Stepwise Refinement Stepwise refinement is a top-down design strategy used for decomposing a system from a high level of abstraction into a more detailed level (lower level) of abstraction. At the highest level of abstraction, function or information is defined conceptually without providing any information about the internal workings of the function or internal structure of the data. As we proceed towards the lower levels of abstraction, more and more details are available. Software designers start the stepwise refinement process by creating a sequence of compositions for the system being designed. Each composition is more detailed than the previous one and contains more components and interactions. The earlier compositions represent the significant interactions within the system, while the later compositions show in detail how these interactions are achieved. To have a clear understanding of the concept, let us consider an example of stepwise refinement. Every computer program comprises input, process, and output. 1. INPUT  Get users name (string) through a prompt. Get users grade (integer from 0 to 100) through a prompt and validate. 2. PROCESS 3. OUTPUT This is the first step in refinement. The input phase can be refined further as given here. 1. INPUT o Get users name through a prompt. o Get users grade through a prompt. o While (invalid grade) Ask again: 2. PROCESS 3. OUTPUT Note: Stepwise refinement can also be performed for PROCESS and OUTPUT phase.

--- Chunk 37 ---
Tokens: 378
Type: sentence-based
Text:
OUTPUT Note: Stepwise refinement can also be performed for PROCESS and OUTPUT phase. Refactoring Refactoring is an important design activity that reduces the complexity of module design keeping its behaviour or function unchanged. Refactoring can be defined as a process of modifying a software system to improve the internal structure of design without changing its external behavior. During the refactoring process, the existing design is checked for any type of flaws like redundancy, poorly constructed algorithms and data structures, etc, in order to improve the design. For example, a design model might yield a component which exhibits low cohesion (like a component performs four functions that have a limited relationship with one another). Software designers may decide to refactor the component into four different components, each exhibiting high cohesion. This leads to easier integration, testing, and maintenance of the software components. Structural Partitioning When the architectural style of a design follows a hierarchical nature, the structure of the program can be partitioned either horizontally or vertically. In horizontal partitioning, the control modules are used to communicate between functions and execute the functions. Structural partitioning provides the following benefits. The testing and maintenance of software becomes easier. The negative impacts spread slowly. The software can be extended easily. Besides these advantages, horizontal partitioning has some disadvantage also.

--- Chunk 38 ---
Tokens: 389
Type: sentence-based
Text:
Besides these advantages, horizontal partitioning has some disadvantage also. It requires to pass more data across the module interface, which makes the control flow of the problem more complex. This usually happens in cases where data moves rapidly from one function to another. In vertical partitioning, the functionality is distributed among the modules--in a top-down manner. The modules at the top level called control modules perform the decision-making and do little processing whereas the modules at the low level called worker modules perform all input, computation and output tasks. Concurrency Computer has limited resources and they must be utilized efficiently as much as possible. To utilize these resources efficiently, multiple tasks must be executed concurrently. This requirement makes concurrency one of the major concepts of software design. Every system must be designed to allow multiple processes to execute concurrently, whenever possible. For example, if the current process is waiting for some event to occur, the system must execute some other process in the mean time. However, concurrent execution of multiple processes sometimes may result in undesirable situations such as an inconsistent state, deadlock, etc. For example, consider two processes A and B and a data item Q1 with the value 200. Further, suppose A and B are being executed concurrently and firstly A reads the value of Q1 (which is 200) to add 100 to it. However, before A updates es the value of Q1, B reads the value ofQ1 (which is still 200) to add 50 to it.

--- Chunk 39 ---
Tokens: 352
Type: sentence-based
Text:
However, before A updates es the value of Q1, B reads the value ofQ1 (which is still 200) to add 50 to it. In this situation, whether A or B first updates the value of Q1, the value of would definitely be wrong resulting in an inconsistent state of the system. This is because the actions of A and B are not synchronized with each other. Thus, the system must control the concurrent execution and synchronize the actions of concurrent processes. One way to achieve synchronization is mutual exclusion, which ensures that two concurrent processes do not interfere with the actions of each other. To ensure this, mutual exclusion may use locking technique. In this technique, the processes need to lock the data item to be read or updated. The data item locked by some process cannot be accessed by other processes until it is unlocked. It implies that the process, that needs to access the data item locked by some other process, has to wait. Developing a Design Model To develop a complete specification of design (design model), four design models are needed. These models are listed below. 1. Data design: This specifies the data structures for implementing the software by converting data objects and their relationships identified during the analysis phase. Various studies suggest that design engineering should begin with data design, since this design lays the foundation for all other design models. 2.

--- Chunk 40 ---
Tokens: 386
Type: sentence-based
Text:
2. Architectural design: This specifies the relationship between the structural elements of the software, design patterns, architectural styles, and the factors affecting the ways in which architecture can be implemented. 3. Component-level design: This provides the detailed description of how structural elements of software will actually be implemented. 4. Interface design: This depicts how the software communicates with the system that interoperates with it and with the end-users. Differentiate Between Top Down and Bottom UP Approaches In top down strategy we start by testing the top of the hierarchy and we incrementally add modules that it calls and then test the new combined system. This approach of testing requires stubs to be written. A stub is a dummy routine that simulates a module. In the top-down approach, a module cannot be tested in isolation because they invoke some other modules. To allow the modules to be tested before their subordinates have been coded, stubs simulate the behavior of the subordinates. The bottom-up approach starts from the bottom of the hierarchy. First the modules at the very bottom, which have no subordinates, are tested. Then these modules are combined with higher-level modules for testing. At any stage of testing all the subordinate modules exist and have been tested earlier. To perform bottom-up testing, drivers are needed to set up the appropriate environment and invoke the module. It is the job of the driver to invoke the module under testing with the different set of test cases.

================================================================================
SOURCE: PrinciplesOfSoftwareDesign.pdf
TOTAL CHUNKS: 24
================================================================================

--- Chunk 0 ---
Tokens: 377
Type: sentence-based
Text:
Principles of Software Design This paper presents fundamental principles of effective software design. If consistently applied, they help us to achieve simple, understandable, and robust software designs. They provide criteria for choosing between various design alternatives. All design decisions should be evaluated against them to ensure their consistent application. These principles also provide a framework for evaluating the quality of software designs created by others. Goals of Software Design Software design is primarily about managing complexity. Software systems are often very complex and have many moving parts. Most systems must support dozens of features simultaneously. Each feature by itself might not seem very complicated. However, when faced with the task of creating one coherent structure that supports all of the required functionality at once, things become complicated very quickly. Human capacity to deal with complexity is quite limited; people become overwhelmed and confused relatively quickly. Perhaps the primary objective of software design is to make and keep software systems well organized, thus enhancing our ability to understand, explain, modify, and fix them. Based on this view of software design, disorganization (or sloppiness) is the antithesis of good software design. As the laws of physics teach us, the universe tends to become more disorganized over time unless we take active steps to make and keep it organized. Software systems are very much the same way.

--- Chunk 1 ---
Tokens: 395
Type: sentence-based
Text:
Software systems are very much the same way. If created or modified without careful forethought, software systems quickly become incomprehensible, tangled messes that dont work right and are impossible to fix. This is especially true for systems that remain in use over extended periods of time, and are periodically upgraded to support new features. Even if a system starts out with a good design, we must consistently strive to preserve the integrity of its design throughout its lifetime by carefully considering all changes we make to it. Based on these principles, we can list several important goals of software design:  Software that works  Software that is easy to read and understand  Software that is easy to debug and maintain  Software that is easy to extend and holds up well under changes  Software that is reusable in other projects Design Is an Iterative Process Software design is a complex undertaking. Therefore, you will rarely get a design right the first time. Implementing a design provides new insights into its deficiencies: things you didnt think about, better ways of doing things, etc. Such insights should feed back into your design to make it better. For this reason, design and implementation activities are usually interleaved in short iterations: Design, code, test, debug, Design, code, test, debug,  The notion that a complex system can be completely designed in every detail before implementation begins is fallacious. Such an approach deprives designers of valuable knowledge and experience that come only from actually implementing the design.

--- Chunk 2 ---
Tokens: 393
Type: sentence-based
Text:
Such an approach deprives designers of valuable knowledge and experience that come only from actually implementing the design. The opposite extreme is also dangerous, starting implementation having done little or no design at all. Those who start coding immediately and wing it as they go are even more prone to failure than those who try to design everything up front. The truth lies between these two extremes. You should do enough design to have a fairly detailed idea of how things will work, and then implement the design to discover its deficiencies. Then, go back and incorporate what youve learned into the design, and then implement some more. This process will eventually converge on a good design. Abstraction Abstraction is one of the software designers primary tools for coping with complexity. Most programming languages and their associated libraries are meant to be general purpose. They can be used to implement solutions to problems in any application domain (finance, retail, biology, communications, etc.). Due to their general purpose nature, these languages provide only low-level abstractions such as bit, byte, character, string, integer, float, array, file, etc. that model the machines on which the software will run rather than the application domain of the problem being solved. Programs written solely in terms of these low-level abstractions are extremely difficult to understand. Effective software design requires the creation of new, higher-level abstractions that map directly to the application domain rather than the underlying computer.

--- Chunk 3 ---
Tokens: 396
Type: sentence-based
Text:
Effective software design requires the creation of new, higher-level abstractions that map directly to the application domain rather than the underlying computer. In object-oriented design, application-specific abstractions are represented as classes. Classes encapsulate the state (or data) and operations (or algorithms) associated with a particular higher-level application concept. For example, the design for a word processor would contain classes such as Document, Font, Table, Figure, and Printer. Similarly, the design for a web browser would contain classes such as Favorites, URL, Viewer, and NetworkProtocol. Software written in terms of such higher- level abstractions is far more understandable to the human reader because it is expressed in terms of the application domain rather than the underlying machine. There may also be mid-level abstractions such as ArrayList, ThreadPool, and ConnectionManager that dont map directly the concepts of the application domain, but that still play an important role in the implementation of the system. Such mid-level abstractions are helpful in bridging the gap between high-level application concepts and low-level facilities provided by the programming language. As stated above, part of effective abstraction is identifying a good set of classes that effectively model the application domain. Another part of effective abstraction is carefully defining the interfaces (i.e, operations) supported by those classes. While classes represent the nouns of the application domain, the operations supported by classes represent the verbs.

--- Chunk 4 ---
Tokens: 399
Type: sentence-based
Text:
While classes represent the nouns of the application domain, the operations supported by classes represent the verbs. The ability to execute a complex, domain-specific operation by calling a single method on an object leads to concise, highly-readable code. For example, the following line of code might be used to print a document: defaultPrinter.print(document); While only one line of code is required to print a document, it obviously requires a lot of low-level work underneath to actually send the documents contents to the printer. This work must be carried out by the implementation of the print method. How does print actually print the document? I dont know, and I dont want to know. Unless I am actually implementing the print method, I prefer to ignore those details, thus freeing me to think about something else. The ability to hide all of this complexity behind a simple method call demonstrates the power of abstraction: a complex idea can be conveyed very concisely, thus shielding the reader from many low-level details that might otherwise cloud their thinking. Naming Abstraction involves taking something that is complicated, giving it a simple name, and then referring to it by its simple name. This way, complex ideas can be conveyed very concisely. With this in mind, one of the most important tools for achieving effective abstraction is the identifier. An identifier is a name that we assign to something. We choose names for classes, methods, variables, constants, source files, etc. While selecting a name might seem to be a relatively inconsequential thing, it is not.

--- Chunk 5 ---
Tokens: 400
Type: sentence-based
Text:
While selecting a name might seem to be a relatively inconsequential thing, it is not. The names we choose for things go a long way toward determining how readable our code becomes. Even if I create the right class, if I name it poorly, much of the benefit to be gained from abstraction has been lost. For example, if I name the class that represents printers as Thingy instead of Printer, I have done significant harm to the readability of my design. The name assigned to a class, variable, or method should clearly and accurately reflect the function performed by that class, variable, or method. The name Printer implies that a class represents a printer; the name calculatePayrollTax implies that a method calculates payroll taxes; the name homeAddress implies that a variable stores a home address. In contrast, the names Thingy, doStuff, and info would convey no information whatsoever to the reader. Name selection makes a huge difference. In general, class names should be nouns, and method names should be verbs. There are occasional exceptions to this rule, but it applies in the vast majority of cases. One exception to this rule relates to methods that getset object attribute values, such as getName and setName. Depending on the style you prefer, one or both of these methods could alternatively be named with a noun. Cohesion Abstractions (i.e, classes and operations) should be highly cohesive. Each class should represent one well-defined concept, and should be given a name that clearly reflects the concept it represents (e.g, URL). Cohesive classes are almost always easy to name.

--- Chunk 6 ---
Tokens: 367
Type: sentence-based
Text:
Cohesive classes are almost always easy to name. In fact, the name they should be given is often obvious, because they represent only one concept. The operations on a class should all be highly-related to the concept represented by the class. For example, URL operations should all be highly related to storing and manipulating URLs. Operations like getPath, getFileName, and resolveRelative would be appropriate. Operations that are loosely related or unrelated to the concept represented by the class should be placed on some other class. For example, a URL class should not have a display method that renders the document referenced by the URL on the screen. The rendering function is only loosely related to the concept of a URL, and so should be placed on a different class (e.g, FileViewer). Class operations should also be highly cohesive. Each operation should perform one well-defined task, and should be given a name that clearly reflects the task it performs (e.g, rebootComputer). Cohesive operations are almost always easy to name, because they do only one thing. If a method does a bunch of loosely related or unrelated things, it will either be hard to find a good name that describes what the operation does, leading to inferior names like handleStuff, or the methods name will become too long (e.g, sweepFloorAndDoDishesAndPayBills). Abstracting All the Way A typical design contains many classes, some larger and more complex, others relatively simple.

--- Chunk 7 ---
Tokens: 378
Type: sentence-based
Text:
Abstracting All the Way A typical design contains many classes, some larger and more complex, others relatively simple. Some abstractions are simple enough that they can be directly represented using one of the built-in data types provided by the programming language (e.g, integer, string, float, etc.). For example, concepts such as title, pay grade, or credit card number could be directly represented using strings or integers. The question is: Is it worth creating classes to represent relatively simple abstractions such as these? Should a designer create classes named Title, PayGrade, and CreditCardNumber, or just go ahead and use strings or integers directly to represent this kind of information? Of course, even if we create such classes, internally they will store integers or strings anyway. Does it help to create such classes, or is it OK to just use the built-in types directly? Creating classes to represent relatively simple abstractions is often the better choice. Following are some criteria to help make the decision: 1) Domain Checking  Programs need to validate input values that come from end users, files, or other input sources. This is done by parsing or otherwise inspecting the input values to ensure they are valid and lie within acceptable ranges. For example, phone numbers might enter a program as string values, but most strings are not valid phone numbers. Rather than using strings to store phone numbers, it would be better to create a PhoneNumber class to store phone numbers.

--- Chunk 8 ---
Tokens: 362
Type: sentence-based
Text:
Rather than using strings to store phone numbers, it would be better to create a PhoneNumber class to store phone numbers. The PhoneNumber class would contain the code necessary to validate phone number inputs, probably in a constructor. Input strings containing phone numbers would be passed to the constructor, which would parse the string. If the string contained a valid phone number, the constructor would store it in the object for later use. If the string was not a valid phone number, an exception would be thrown. Domain checking is an excellent reason to create classes to represent data values that could otherwise be stored directly as built-in data types. 2) Additional Operations  Creating classes to represent simple data values provides a place to put operations that operate on those data types. For example, URLs could be stored directly as strings, but if we do so there will be no place to locate URL-related algorithms that may be needed as the program evolves (parsing URLs into their component parts, resolving relative URLs, etc.). Creating a URL class, however, would provide an excellent place to put such URL-related operations. 3) Code Readability  Creating classes for simple abstractions can enhance a programs readability. For example, if you see a variable of type String, you dont know much about what the variable represents. If you see a variable of type URL, you know a lot about what it represents (i.e, a URL).

--- Chunk 9 ---
Tokens: 385
Type: sentence-based
Text:
If you see a variable of type URL, you know a lot about what it represents (i.e, a URL). Creating classes for simple data types enhances readability because variable, parameter, and return types are much more descriptive about what kind of data they represent. Of course, giving good names to variables and parameters will go a long way toward telling the reader what kind of data they represent. Return values, however, dont have names (at least not directly). Decomposition In addition to abstraction, another fundamental technique for dealing with complexity is taking the original problem and dividing it into several smaller sub-problems. The sub- problems are smaller and hence less complex than the original, thus making them more approachable. After solving each sub-problem individually, the solutions to the sub- problems can be combined to create a solution to the original, larger problem. This approach is frequently called divide and conquer. After breaking the original problem into sub-problems, we may find that the sub- problems themselves are still too complex to solve directly. In this case, we decompose the sub-problems yet again to create second-level sub-problems that are even simpler. Sub-problems are divided into smaller and smaller parts until the smallest sub-problems are simple enough to solve directly, and thus require no further subdivision. In effect, we create a tree of problems, where the original problem is at the root, and each successive level of subdivision adds another level of nodes to the tree.

--- Chunk 10 ---
Tokens: 379
Type: sentence-based
Text:
In effect, we create a tree of problems, where the original problem is at the root, and each successive level of subdivision adds another level of nodes to the tree. The solution to each sub- problem makes use of the solutions to the sub-problems below it. This approach allows us to cope with the inherent complexity of the original problem in bite-size chunks. Decomposition is strongly related to abstraction. The solution to each sub-problem is abstracted as a class or method. The solution to the larger problem invokes the abstractions which encapsulate the sub-problem solutions. This results in a concise solution to the original problem, and allows the details of the sub-problem solutions to be temporarily ignored, thus reducing the cognitive burden of solving the original problem. It is through the decomposition process that many of the necessary abstractions are discovered (or invented). Levels of Design System Subsystems Packages Classes Routines Decomposition is inherently a top-down process. At the topmost level we have the entire system. The first level of decomposition divides the system into subsystems, each of which represents a major but somewhat independent chunk of the systems functionality. For example, the subsystems for a web browser might be Network Protocols, File Viewers, History, Favorites, Printing, etc. At the next level of decomposition, each subsystem is further subdivided into packages. Each package is responsible for implementing a part of the subsystems functionality.

--- Chunk 11 ---
Tokens: 390
Type: sentence-based
Text:
Each package is responsible for implementing a part of the subsystems functionality. For example, a web browsers File Viewers subsystem might contain a separate package for each different file format that the browser can display (HTML, PDF, XML, etc.). The package corresponding to a particular format would contain the code that implements the file viewer for that format. A package is further decomposed into a collection of one or more classes that together implement that packages functionality. For example, the web browsers HTML viewer might consist of a dozen different classes. The functionality of each class is further decomposed into routines which implement the operations (or algorithms) of the class. Significant algorithms are typically decomposed further into multiple levels of subroutines. Decomposition continues until the leaf-level subroutines are simple enough to implement directly. Hypo- and Hyper- Decomposition Many software designers, especially beginners, tend to not decompose things far enough. This might be referred to as hypo-decomposition (hypo means deficient). An extreme example of this would be implementing an entire program in a single class. The one and only class would implement all of the functionality for the entire program. Such a class would be an egregious violation of the cohesion principle discussed earlier, which states that a class should do one thing, and do it well. One could argue that a one-class application is very cohesive because the class does only one thing  it implements the entire application!

--- Chunk 12 ---
Tokens: 393
Type: sentence-based
Text:
One could argue that a one-class application is very cohesive because the class does only one thing  it implements the entire application! While there is nothing wrong (and often much right) with having a class that represents the entire application (e.g, a WebBrowser class), it is wholly inappropriate to actually implement all of the applications functionality on that one class. Instead, the main class should delegate to other, smaller classes which implement various subsets of the programs functionality. The main class, then, is primarily a delegator (or driver), and performs little or no actual work itself other than driving the other classes. In general, if a class represents a large or complex concept, its functionality should be decomposed into one or more smaller classes that perform the actual work. Often these second-level classes will also need to be decomposed further into even smaller classes. This decomposition should be repeated until the resulting classes are too simple to decompose further. At the other extreme are those who decompose things too far, which might be called hyper-decomposition (hyper means excessive). This mistake is harder to make and far more rare than hypo-decomposition. When decomposing a system, one must have a sense of when they have decomposed far enough. In general, we have said that a system has been decomposed sufficiently when its sub-parts are simple enough to implement directly. Everyone has a slightly different sense of when that point has been reached. Although rare, it is possible to decompose too far.

--- Chunk 13 ---
Tokens: 391
Type: sentence-based
Text:
Although rare, it is possible to decompose too far. For example, a CreditCardNumber class might be created to represent the concept of a credit card number. This seems like a good design choice. But, how should a CreditCardNumber object store the actual credit card number internally? A String seems like a natural representation for a credit card number (after it has been validated by the CreditCardNumber constructor, of course). Alternatively, it would also be possible to store a credit card number as an array of Digit objects. Most people would say that creating a Digit class to store individual digits in a credit card number is overkill, and an example of hyper-decomposition. Size and Length Metrics How shall we know when we have decomposed far enough? Length metrics, often measured in lines of code (LOC), can be helpful in making this determination. A method that contains a single LOC has been decomposed far enough, of course. A method that contains 500 LOC almost certainly has not been decomposed far enough. Methods that have been sufficiently decomposed are usually less than 50 LOC, and in many cases 50 LOC is still too long. Maybe 20 LOC would be a better goal. While there is no right method length, the basic principle is that when an algorithm has been decomposed sufficiently, the resulting subroutines which implement the algorithm tend to be short  frequently, very short. Size metrics such as the number of parameters can also be used to judge how well a method has been decomposed. A method that requires 10 parameters is too complex.

--- Chunk 14 ---
Tokens: 367
Type: sentence-based
Text:
A method that requires 10 parameters is too complex. The problem might be one of insufficient decomposition. Class size can also provide a clue as to whether or not a class has been decomposed far enough. A class with 50 methods has probably not been decomposed far enough. Such a class is probably doing the work of several classes. As a result, the class is also not cohesive, and should be further subdivided. Classes with a lot of internal variables are also usually insufficiently decomposed. If a class contains a lot of variables (e.g, 20), there are probably smaller subgroups of those variables that are closely related to each other. These clusters of related variables will often suggest new classes to be created, thus further decomposing the original class. The original class would then become a client of the newly discovered classes. Similarly, a class that contains 5,000 LOC has almost certainly not been decomposed far enough. A class containing 2,000 LOC often requires further decomposition, but not always. Well-designed classes often contain less than 500 LOC, frequently much less (but, not always). There is no right class length, but, in general, classes that have been decomposed sufficiently tend to be shorter rather than longer. Complexity Metrics Sometimes length metrics based on LOC measurements dont tell the whole story. It is possible for two methods with the same length measured in LOC to have radically different complexity levels.

--- Chunk 15 ---
Tokens: 368
Type: sentence-based
Text:
It is possible for two methods with the same length measured in LOC to have radically different complexity levels. For example, imagine two 100-line methods, the first containing only straight-line output statements (e.g, println), and the second containing complex logic with deeply nested loops and lots of branching. While these methods have the same length, their complexity levels are not even close. Straight-line output statements are readily understandable, while complex logic is far more difficult to understand. Both methods might benefit from further decomposition, but the second one demands it. In general, methods containing complex arithmetic expressions, deeply nested structures, and lots of branching should be simplified by breaking up the complex routine into simpler subroutines that each perform part of the original routines work. The original routine then becomes a driver routine that delegates much of the actual work to its subordinates. Many routines naturally contain multiple sections (or paragraphs) of related statements that can be easily factored out into a separate subroutines. Moving a paragraph of related statements to a separate subroutine, giving the new subroutine a good name, and replacing the original statements with a call to the new subroutine will do much to simplify the original routine. Consistently applying this technique of algorithm decomposition will have a significant positive impact on the quality of your code.

--- Chunk 16 ---
Tokens: 360
Type: sentence-based
Text:
Consistently applying this technique of algorithm decomposition will have a significant positive impact on the quality of your code. Algorithm  Data Structure Selection A major part of software design is selecting appropriate algorithms and data structures for the problem at hand. Using an algorithm that is O(n3) on data sets that become very large will almost certainly be far too slow, regardless of how well we have decomposed and abstracted the problem. Similarly, storing data values as unsorted, linear lists will be far too slow if the data set is large and needs to be searched frequently. Selecting (or inventing) algorithms and data structures with good performance characteristics (including running time and memory consumption) for the intended application is a fundamental design skill. No amount of decomposition or abstraction will hide a fundamentally flawed selection of algorithm or data structure. Minimize Dependencies (or, Low Coupling) Large systems contain many classes. As a system is decomposed into its constituent classes, it is important to keep each class as independent as possible from the other classes in the system. Classes A and B depend on each other if: 1) Class A invokes a method on class B 2) Class A accesses the internal state of class B 3) Class A inherits from class B 4) Class A has a method parameter of class B 5) Class A and Class B both access the same global data structure or file 6) Etc.

--- Chunk 17 ---
Tokens: 378
Type: sentence-based
Text:
Classes A and B depend on each other if: 1) Class A invokes a method on class B 2) Class A accesses the internal state of class B 3) Class A inherits from class B 4) Class A has a method parameter of class B 5) Class A and Class B both access the same global data structure or file 6) Etc. Minimizing the number of communication channels and interactions between different classes has several benefits: 1) A class with few dependencies on other classes is generally easier to understand than a class with many dependencies on other classes (i.e, dependencies increase a classs complexity) 2) A class with few dependencies on other classes is less prone to ripple effects caused by changes or defects in other classes (i.e, dependencies make a system harder to modify and debug). 3) A class with few dependencies on other classes is easier to reuse in a different program than a class with many dependencies (i.e, dependencies discourage reuse). Imagine a system in which every class depends on every other class. Every time any class is changed, we must consider the potential impact on all other classes (very confusing, indeed). Similarly, when a class has a defect, the defect will potentially impact the behavior of all other classes, thus making it difficult to track down where the defect actually resides (again, very confusing). At the other extreme, imagine a system where there are no dependencies between classes (i.e, each class is an island unto itself). In this case, the software doesnt do anything.

--- Chunk 18 ---
Tokens: 395
Type: sentence-based
Text:
In this case, the software doesnt do anything. Making a program perform useful functions requires a certain level of communication (and therefore dependency) between the classes in the system. The goal is not to remove all dependencies, but rather to minimize the number and strength of dependencies. When two classes must interact, it is desirable to keep the interaction as simple and straightforward as possible. The ideal form of interaction between two classes is through simple method calls. A method call is simple if it has a good name and the data passed through the parameter list and return value is easy to understand. Simple method calls have the advantage of being direct and obvious in the code. Other more indirect forms of communication between classes, such as accessing the same global data structure, make the dependency less explicit and harder to detect and comprehend. To the extent possible, interactions between classes should be through explicit, well-defined method interfaces. Separation of Interface and Implementation One important technique for minimizing dependencies between classes is maintaining a strict separation between a classs public interface and its internal implementation. A classs public interface consists of the operations (or methods) through which clients can access its services. In order to use a class, a client needs only to understand the classs public interface. The details of how the public interface is implemented internally are incidental to the client, and should not be accessed or relied upon by the client in any way.

--- Chunk 19 ---
Tokens: 397
Type: sentence-based
Text:
The details of how the public interface is implemented internally are incidental to the client, and should not be accessed or relied upon by the client in any way. The code that implements the public interface, including all variables and subroutines that support that code, should not be accessed by clients. By relying only on the details of the public interface, a classs internal implementation can be changed without affecting (i.e, breaking) its clients. Only changes to the public interface itself affect the clients. The strict separation of interface and implementation goes a long way toward minimizing dependencies between classes. Information Hiding Because the separation of interface and implementation is so central to good software design, programming languages often provide features to help enforce this separation. Some languages physically separate a classs public interface and internal implementation into separate source files. Other languages require the designer to declare all class features (variables and methods) as public, private, or protected, thus preventing clients from accessing private details. Such language features encourage designers to hide as much information as possible from clients, thus reducing opportunities for dependency between classes. A classs public interface should be as small (or thin) as possible, ideally including only a small number of methods. Each public methods parameters should be as simple as possible. All internal variables should be hidden, and only methods that are directly invoked by clients should be made public.

--- Chunk 20 ---
Tokens: 374
Type: sentence-based
Text:
All internal variables should be hidden, and only methods that are directly invoked by clients should be made public. This advice applies even to inheritance relationships. By making variables protected, it is easy for a superclass to directly expose its internal variables to its subclasses. This makes the subclasses highly dependent on the internal details of the superclass. As always, this makes it difficult to change the superclass implementation without breaking the subclasses. A designer may choose to make superclasses and subclasses highly coupled in this manner, but the downsides of doing so should be considered when making this decision. Another approach would be to define the superclasssubclass interface in terms of protected methods only (i.e, no protected variables), thus reducing the level of dependency between superclass and subclass. Designers should also be careful to ensure that internal implementation details do not leak out of a class. For example, a method that performs a search algorithm might be named binarySearch. Unfortunately, the name binarySearch reveals the methods internal implementation. This choice of name forever binds the method to use the binary search algorithm as its implementation. Alternatively, naming the method search would preserve the designers freedom to vary the internal algorithm without violating the client contract. Similarly, a grade-keeping program might represent the notion of a class roll with a class named StudentLinkedList.

--- Chunk 21 ---
Tokens: 385
Type: sentence-based
Text:
Similarly, a grade-keeping program might represent the notion of a class roll with a class named StudentLinkedList. However, doing so betrays the fact that the class uses a linked list as the internal data structure for storing a sequence of students. A better choice would be to name the class ClassRoll, thus hiding all details of how students are actually stored internally, and preserving freedom to change that representation at will. There are times, however, when a class or method is inherently tied to a particular implementation. In such cases, it is appropriate to name classes or methods in terms of their internal details. For example, a class whose sole purpose is to implement a hash table could appropriately be named HashTable because its implementation is an inherent part of its existence. A hash table will always be a hash table, and that will never change. However, clients of the HashTable class should not reveal their internal use of HashTable unless that choice is inherent and will never change. Avoid Code Duplication Another core principle of good software design is that code duplication should be strenuously avoided. Frequently, programs will contain duplicated sections of code, or sections of code that are very similar. For example, searching an array for a particular value is a common operation, and this code could easily be duplicated many times throughout a program. Similarly, formatting of datetime values for end-user display is a common operation that is often be duplicated throughout a program.

--- Chunk 22 ---
Tokens: 375
Type: sentence-based
Text:
Similarly, formatting of datetime values for end-user display is a common operation that is often be duplicated throughout a program. The disadvantages associated with duplication are fairly obvious: 1) If the duplicated code needs to be modified, we must remember to change all N copies, and do so correctly. 2) If the duplicated code contains a bug, the bug will the replicated N times. 3) Duplication makes the program longer, thus decreasing its maintainability. If the same or similar code appears in N places, the obvious solution is to isolate the duplicated code in one place, and then have all N clients invoke the shared copy. If all N copies are in the same class, the duplicated code can be factored out into a private method on that class. If the N copies are in different classes, the shared copy could be placed on one of the client classes, or placed on some other (possibly new) class that provides a logical home for the shared code. Another solution would be to place the shared code in a superclass, and then make each client class a subclass of the superclass. If the duplicated code is similar but not identical, it might be possible to create a generic version that will serve the needs of all clients. If the implementation language provides generic types (e.g, C templates), a generic type or subroutine will often be a good implementation choice for the shared code. Design Principles Summary 1. Abstraction a. Naming b. Cohesion c. Abstracting All the Way 2. Decomposition a.

--- Chunk 23 ---
Tokens: 84
Type: sentence-based
Text:
Decomposition a. Levels of Design (System, Subsystem, Package, Class, Routine) b. Hypo- and Hyper- Decomposition c. Size and Length Metrics d. Complexity Metrics 3. Algorithm  Data Structure Selection 4. Minimize Dependencies (or, Low Coupling) a. Separation of Interface and Implementation b. Information Hiding 5. Avoid Code Duplication

================================================================================
SOURCE: SD princple and guidance slide.pdf
TOTAL CHUNKS: 19
================================================================================

--- Chunk 0 ---
Tokens: 211
Type: sentence-based
Text:
UCLA Extension Course Software Design Principles and Guidelines Douglas C. Schmidt Department of Electrical Engineering and Computer Science Vanderbilt University d.schmidtvanderbilt.edu http:www.cs.wustl.edu schmidt UCLA Extension Course OO Programming with C Design Principles and Guidelines Overview  Design Principles  Important design concepts  Useful design principles  Development Methodologies  Traditional approaches  Extreme programming  Design Guidelines  Motivation  Common Design Mistakes  Design Rules Copyright c 1997-2003 Vanderbilt University 1 UCLA Extension Course OO Programming with C Motivation: Goals of the Design Phase  Decompose System into Modules  i.e, identify the software architecture  Modules are abstractions that should:  be independent,  have well-specied interfaces, and  have high cohesion and low coupling.

--- Chunk 1 ---
Tokens: 368
Type: sentence-based
Text:
Determine Relations Between Modules  Identify module dependencies  Determine the form of intermodule communication, e.g,  global variables  parameterized function calls  shared memory  RPC or message passing Copyright c 1997-2003 Vanderbilt University 2 UCLA Extension Course OO Programming with C Motivation: Goals of the Design Phase (contd)  Specify Module Interfaces  Interfaces should be well-dened  facilitate independent module testing  improve group communication  Describe Module Functionality  Informally  e.g, comments or documentation  Formally  e.g, via module interface specication languages Copyright c 1997-2003 Vanderbilt University 3 UCLA Extension Course OO Programming with C Primary Design Phases  Preliminary Design  External design describes the real-world model  Architectural design decomposes the requirement specication into software subsystems  Detailed Design  Formally specify each subsystem  Further decomposed subsystems, if necessary  Note: in design phases the orientation moves  from customer to developer  from what to how Copyright c 1997-2003 Vanderbilt University 4 UCLA Extension Course OO Programming with C Key Design Concepts and Principles  Important design concepts and design principles include:  Decomposition  Abstraction  Information Hiding  Modularity  Hierarchy  Separating Policy and Mechanism  Main purpose of these concepts and principles is to manage software system complexity and improve software quality factors.

--- Chunk 2 ---
Tokens: 321
Type: sentence-based
Text:
Copyright c 1997-2003 Vanderbilt University 5 UCLA Extension Course OO Programming with C Decomposition  Decomposition is a concept common to all life-cycle and design techniques. Basic concept is very simple: 1. Select a piece of the problem (initially, the whole problem) 2. Determine its components using the mechanism of choice, e.g, functional vs data structured vs object-oriented 3. Show how the components interact 4. Repeat steps 1 through 3 until some termination criteria is met (e.g, customer is satised, run out of money, etc;-)) Copyright c 1997-2003 Vanderbilt University 6 UCLA Extension Course OO Programming with C Decomposition (contd)  Some guiding decomposition principles  Because design decisions transcend execution time, modules might not correspond to execution steps . . . Decompose so as to limit the effect of any one design decision on the rest of the system  Remember, anything that permeates the system will be expensive to change  Modules should be specied by all information needed to use the module and nothing more Copyright c 1997-2003 Vanderbilt University 7 UCLA Extension Course OO Programming with C Abstraction  Abstraction provides a way to manage complexity by emphasizing essential characteristics and suppressing implementation details.

--- Chunk 3 ---
Tokens: 381
Type: sentence-based
Text:
Decompose so as to limit the effect of any one design decision on the rest of the system  Remember, anything that permeates the system will be expensive to change  Modules should be specied by all information needed to use the module and nothing more Copyright c 1997-2003 Vanderbilt University 7 UCLA Extension Course OO Programming with C Abstraction  Abstraction provides a way to manage complexity by emphasizing essential characteristics and suppressing implementation details. Allows postponement of certain design decisions that occur at various levels of analysis, e.g,  RepresentationalAlgorithmic considerations  ArchitecturalStructural considerations  ExternalFunctional considerations Copyright c 1997-2003 Vanderbilt University 8 UCLA Extension Course OO Programming with C Abstraction (contd)  Three basic abstraction mechanisms  Procedural abstraction  e.g, closed subroutines  Data abstraction  e.g, ADTs  Control abstraction  iterators, loops, multitasking, etc. Copyright c 1997-2003 Vanderbilt University 9 UCLA Extension Course OO Programming with C Information Hiding  Motivation: details of design decisions that are subject to change should be hidden behind abstract interfaces, i.e, modules. Information hiding is one means to enhance abstraction. Modules should communicate only through well-dened interfaces. Each module is specied by as little information as possible. If internal details change, client modules should be minimally affected (may require recompilation and relinking, however . . .)

--- Chunk 4 ---
Tokens: 235
Type: sentence-based
Text:
.) Copyright c 1997-2003 Vanderbilt University 10 UCLA Extension Course OO Programming with C Information Hiding (contd)  Information to be hidden includes:  Data representations  i.e, using abstract data types  Algorithms e.g, sorting or searching techniques  Input and Output Formats  Machine dependencies, e.g, byte-ordering, character codes  Policymechanism distinctions  i.e, when vs how  e.g, OS scheduling, garbage collection, process migration  Lower-level module interfaces  e.g, Ordering of low-level operations, i.e, process sequence Copyright c 1997-2003 Vanderbilt University 11 UCLA Extension Course OO Programming with C Modularity  A Modular System is a system structured into highly independent abstractions called modules. Modularity is important for both design and implementation phases. Module prescriptions:  Modules should possess well-specied abstract interfaces. Modules should have high cohesion and low coupling.

--- Chunk 5 ---
Tokens: 378
Type: sentence-based
Text:
Modules should have high cohesion and low coupling. Copyright c 1997-2003 Vanderbilt University 12 UCLA Extension Course OO Programming with C Modularity (contd)  Modularity facilitates certain software quality factors, e.g:  Extensibility - well-dened, abstract interfaces  Reusability - low-coupling, high-cohesion  Compatibility - design bridging interfaces  Portability - hide machine dependencies  Modularity is an important characteristic of good designs because it:  allows for separation of concerns  enables developers to reduce overall system complexity via decentralized software architectures  enhances scalability by supporting independent and concurrent development by multiple personnel Copyright c 1997-2003 Vanderbilt University 13 UCLA Extension Course OO Programming with C Modularity (contd)  A module is  A software entity encapsulating the representation of an abstraction, e.g, an ADT  A vehicle for hiding at least one design decision  A work assignment for a programmer or group of programmers  a unit of code that  has one or more names  has identiable boundaries  can be (re-)used by other modules  encapsulates data  hides unnecessary details  can be separately compiled (if supported) Copyright c 1997-2003 Vanderbilt University 14 UCLA Extension Course OO Programming with C Modularity (contd)  A module interface consists of several sections:  Imports  Services requested from other modules  Exports  Services provided to other modules  Access Control  not all clients are equal!

--- Chunk 6 ---
Tokens: 622
Type: sentence-based
Text:
Copyright c 1997-2003 Vanderbilt University 12 UCLA Extension Course OO Programming with C Modularity (contd)  Modularity facilitates certain software quality factors, e.g:  Extensibility - well-dened, abstract interfaces  Reusability - low-coupling, high-cohesion  Compatibility - design bridging interfaces  Portability - hide machine dependencies  Modularity is an important characteristic of good designs because it:  allows for separation of concerns  enables developers to reduce overall system complexity via decentralized software architectures  enhances scalability by supporting independent and concurrent development by multiple personnel Copyright c 1997-2003 Vanderbilt University 13 UCLA Extension Course OO Programming with C Modularity (contd)  A module is  A software entity encapsulating the representation of an abstraction, e.g, an ADT  A vehicle for hiding at least one design decision  A work assignment for a programmer or group of programmers  a unit of code that  has one or more names  has identiable boundaries  can be (re-)used by other modules  encapsulates data  hides unnecessary details  can be separately compiled (if supported) Copyright c 1997-2003 Vanderbilt University 14 UCLA Extension Course OO Programming with C Modularity (contd)  A module interface consists of several sections:  Imports  Services requested from other modules  Exports  Services provided to other modules  Access Control  not all clients are equal! (e.g, Cs distinction between protectedprivatepublic)  Heuristics for determining interface specication  dene one specication that allows multiple implementations  anticipate change  e.g, use structures and classes for parameters Copyright c 1997-2003 Vanderbilt University 15 UCLA Extension Course OO Programming with C Modularity Dimensions  Modularity has several dimensions and encompasses specication, design, and implementation levels:  Criteria for evaluating design methods with respect to modularity  Modular Decomposability  Modular Composability  Modular Understandability  Modular Continuity  Modular Protection  Principles for ensuring modular designs:  Language Support for Modular Units  Few Interfaces  Small Interfaces (Weak Coupling)  Explicit Interfaces  Information Hiding Copyright c 1997-2003 Vanderbilt University 16 UCLA Extension Course OO Programming with C Principles for Ensuring Modular Designs  Language Support for Modular Units  Modules must correspond to syntactic units in the language used.

--- Chunk 7 ---
Tokens: 373
Type: sentence-based
Text:
(e.g, Cs distinction between protectedprivatepublic)  Heuristics for determining interface specication  dene one specication that allows multiple implementations  anticipate change  e.g, use structures and classes for parameters Copyright c 1997-2003 Vanderbilt University 15 UCLA Extension Course OO Programming with C Modularity Dimensions  Modularity has several dimensions and encompasses specication, design, and implementation levels:  Criteria for evaluating design methods with respect to modularity  Modular Decomposability  Modular Composability  Modular Understandability  Modular Continuity  Modular Protection  Principles for ensuring modular designs:  Language Support for Modular Units  Few Interfaces  Small Interfaces (Weak Coupling)  Explicit Interfaces  Information Hiding Copyright c 1997-2003 Vanderbilt University 16 UCLA Extension Course OO Programming with C Principles for Ensuring Modular Designs  Language Support for Modular Units  Modules must correspond to syntactic units in the language used. Few Interfaces  Every module should communicate with as few others as possible. Small Interfaces (Weak Coupling)  If any two modules communicate at all, they should exchange as little information as possible. Copyright c 1997-2003 Vanderbilt University 17 UCLA Extension Course OO Programming with C Principles for Ensuring Modular Designs (contd)  Explicit Interfaces  Whenever two modules A and B communicate, this must be obvious from the text of A or B or both.

--- Chunk 8 ---
Tokens: 350
Type: sentence-based
Text:
Copyright c 1997-2003 Vanderbilt University 17 UCLA Extension Course OO Programming with C Principles for Ensuring Modular Designs (contd)  Explicit Interfaces  Whenever two modules A and B communicate, this must be obvious from the text of A or B or both. Information Hiding  All information about a module should be private to the module unless it is specically declared public. Copyright c 1997-2003 Vanderbilt University 18 UCLA Extension Course OO Programming with C The OpenClosed Principle  A satisfactory module decomposition technique should yield modules that are both open and closed:  Open Module: is one still available for extension. This is necessary because the requirements and specications are rarely completely understood from the systems inception. Closed Module: is available for use by other modules, usually given a well-dened, stable description and packaged in a library. This is necessary because otherwise code sharing becomes unmanageable because reopening a module may trigger changes in many clients. Copyright c 1997-2003 Vanderbilt University 19 UCLA Extension Course OO Programming with C The OpenClosed Principle (contd)  Traditional design techniques and programming languages do not offer an elegant solution to the problem of producing modules that are both open and closed. Object-oriented methods utilize inheritance and dynamic binding to solve this problem.

--- Chunk 9 ---
Tokens: 365
Type: sentence-based
Text:
Object-oriented methods utilize inheritance and dynamic binding to solve this problem. Copyright c 1997-2003 Vanderbilt University 20 UCLA Extension Course OO Programming with C Hierarchy  Motivation: reduces module interactions by restricting the topology of relationships  A relation denes a hierarchy if it partitions units into levels (note connection to virtual machines)  Level 0 is the set of all units that use no other units  Level i is the set of all units that use at least one unit at level  i and no unit at level  i.  Hierarchical structure forms basis of design  Facilitates independent development  Isolates ramications of change  Allows rapid prototyping Copyright c 1997-2003 Vanderbilt University 21 UCLA Extension Course OO Programming with C Hierarchy (contd)  Relations that dene hierarchies:  Uses  Is-Composed-Of  Is-A  Has-A  The rst two are general to all design methods, the latter two are more particular to object-oriented design and programming. Copyright c 1997-2003 Vanderbilt University 22 UCLA Extension Course OO Programming with C The Uses Relation  X Uses Y if the correct functioning of X depends on the availability of a correct implementation of Y  Note, uses is not necessarily the same as invokes:  Some invocations are not uses  e.g, error logging  Some uses dont involve invocations  e.g, message passing, interrupts, shared memory access  A uses relation does not necessarily yield a hierarchy (avoid cycles . . .)

--- Chunk 10 ---
Tokens: 371
Type: sentence-based
Text:
.) Copyright c 1997-2003 Vanderbilt University 23 UCLA Extension Course OO Programming with C The Is-Composed-Of Relation  The is-composed-of relationship shows how the system is broken down in components. X is-composed-of fx i g if X is a group of units x i that share some common purpose  The system structure graph description can be specied by the is- composed-of relation such that:  non-terminals are virtual code  terminals are the only units represented by actual (concrete) code Copyright c 1997-2003 Vanderbilt University 24 UCLA Extension Course OO Programming with C The Is-Composed-Of Relation, (contd)  Many programming languages support the is-composed-of relation via some higher-level module or record structuring technique. Note: the following are not equivalent: 1. level (virtual machine) 2. module (an entity that hides a secret) 3. a subprogram (a code unit)  Modules and levels need not be identical, as a module may have several components on several levels of a uses hierarchy. Copyright c 1997-2003 Vanderbilt University 25 UCLA Extension Course OO Programming with C The Is-A and Has-A Relations  These two relationships are associated with object-oriented design and programming languages that possess inheritance and classes. Is-A or Descendant relationship  class X possesses Is-A relationship with class Y if instances of class X are specialization of class Y.  e.g, a square is a specialization of a rectangle, which is a specialization of a shape . . .

--- Chunk 11 ---
Tokens: 344
Type: sentence-based
Text:
. Has-A or Containment relationship  class X possesses a Has-B relationship with class Y if instances of class X contain one or more instance(s) of class Y.  e.g, a car has an engine and four tires . . . Copyright c 1997-2003 Vanderbilt University 26 UCLA Extension Course OO Programming with C Separating Policy and Mechanism  Very important design principle, used to separate concerns at both the design and implementation phases. Multiple policies can be implemented by shared mechanisms. e.g, OS scheduling and virtual memory paging  Same policy can be implemented by multiple mechanisms. e.g, FIFO containment can be implemented using a stack based on an array, or a linked list, or . . . e.g, reliable, non-duplicated, bytestream service can be provided by multiple communication protocols. Copyright c 1997-2003 Vanderbilt University 27 UCLA Extension Course OO Programming with C Program Families and Subsets  Program families are a collection of related modules or subsystems that form a framework  e.g, BSD UNIX network protocol subsystem. Note, a framework is a set of abstract and concrete classes. Program families are natural way to detect and implement subsets. Reasons for providing subsets include cost, time, personnel resources, etc. Identifying subsets:  Analyze requirements to identify minimally useful subsets. Also identify minimal increments to subsets.

--- Chunk 12 ---
Tokens: 891
Type: sentence-based
Text:
Also identify minimal increments to subsets. Copyright c 1997-2003 Vanderbilt University 28 UCLA Extension Course OO Programming with C A General Design Process  Given a requirements specication, design involves an iterative decision making process with the following general steps:  List the difcult decisions and decisions likely to change  Design a module specication to hide each such decision  Make decisions that apply to whole program family rst  Modularize most likely changes rst  Then modularize remaining difcult decisions and decisions likely to change  Design the uses hierarchy as you do this (include reuse decisions) Copyright c 1997-2003 Vanderbilt University 29 UCLA Extension Course OO Programming with C A General Design Process (contd)  General steps (contd)  Treat each higher-level module as a specication and apply above process to each  Continue rening until all design decisions are:  hidden in a module  contain easily comprehensible components  provide individual, independent, low-level implementation assignments Copyright c 1997-2003 Vanderbilt University 30 UCLA Extension Course OO Programming with C Traditional Development Methodologies  Waterfall Model  Specify, analyze, implement, test (in sequence)  Assumes that requirements can be specied up front  Spiral Model  Supports iterative development  Attempts to assess risks of changes  Rapid Application Development  Build a prototype  Ship it :-) Copyright c 1997-2003 Vanderbilt University 31 UCLA Extension Course OO Programming with C eXtreme Programming  Stresses customer satisfaction, and therefore, involvement  Provide what the customer wants, as quickly as possible  Provide only what the customer wants  Encourages changes in requirements  Relies on testing  XP Practices  Planning, designing, coding, testing Copyright c 1997-2003 Vanderbilt University 32 UCLA Extension Course OO Programming with C eXtreme Programming: Planning Technology Spike System Prototype User Story Planning Game Iteration Commitment Schedule Change in Requirements, Risk, or Developement Environment Risk Estimates Time Requirements based on http:www.extremeprogramming.orgrulesplanninggame.html  Start with user stories  Written by customers, to specify system requirements  Minimal detail, typically just a few sentences on a card  Expected development time: 1 to 3 weeks each, roughly  Planning game creates commitment schedule for entire project  Each iteration should take 2-3 weeks Copyright c 1997-2003 Vanderbilt University 33 UCLA Extension Course OO Programming with C eXtreme Programming: Designing  Defer design decisions as long as possible  Advantages:  Simplies current task (just build what is needed)  You dont need to maintain what you havent built  Time is on your side: youre likely to learn something useful by the time you need to decide  Tomorrow may never come: if a feature isnt needed now, it might never be needed  Disadvantages:  Future design decisions may require rework of existing implementation  Ramp-up time will probably be longer later  Therefore, always try to keep designs as simple as possible Copyright c 1997-2003 Vanderbilt University 34 UCLA Extension Course OO Programming with C eXtreme Programming: Coding  Pair programming  Always code with a partner  Always test as you code  Pair programming pays off by supporting good implementation, reducing mistakes, and exposing more than one programmer to the designimplementation  If any deciencies in existing implementation are noticed, either x them or note that they need to be xed.

--- Chunk 13 ---
Tokens: 919
Type: sentence-based
Text:
Copyright c 1997-2003 Vanderbilt University 28 UCLA Extension Course OO Programming with C A General Design Process  Given a requirements specication, design involves an iterative decision making process with the following general steps:  List the difcult decisions and decisions likely to change  Design a module specication to hide each such decision  Make decisions that apply to whole program family rst  Modularize most likely changes rst  Then modularize remaining difcult decisions and decisions likely to change  Design the uses hierarchy as you do this (include reuse decisions) Copyright c 1997-2003 Vanderbilt University 29 UCLA Extension Course OO Programming with C A General Design Process (contd)  General steps (contd)  Treat each higher-level module as a specication and apply above process to each  Continue rening until all design decisions are:  hidden in a module  contain easily comprehensible components  provide individual, independent, low-level implementation assignments Copyright c 1997-2003 Vanderbilt University 30 UCLA Extension Course OO Programming with C Traditional Development Methodologies  Waterfall Model  Specify, analyze, implement, test (in sequence)  Assumes that requirements can be specied up front  Spiral Model  Supports iterative development  Attempts to assess risks of changes  Rapid Application Development  Build a prototype  Ship it :-) Copyright c 1997-2003 Vanderbilt University 31 UCLA Extension Course OO Programming with C eXtreme Programming  Stresses customer satisfaction, and therefore, involvement  Provide what the customer wants, as quickly as possible  Provide only what the customer wants  Encourages changes in requirements  Relies on testing  XP Practices  Planning, designing, coding, testing Copyright c 1997-2003 Vanderbilt University 32 UCLA Extension Course OO Programming with C eXtreme Programming: Planning Technology Spike System Prototype User Story Planning Game Iteration Commitment Schedule Change in Requirements, Risk, or Developement Environment Risk Estimates Time Requirements based on http:www.extremeprogramming.orgrulesplanninggame.html  Start with user stories  Written by customers, to specify system requirements  Minimal detail, typically just a few sentences on a card  Expected development time: 1 to 3 weeks each, roughly  Planning game creates commitment schedule for entire project  Each iteration should take 2-3 weeks Copyright c 1997-2003 Vanderbilt University 33 UCLA Extension Course OO Programming with C eXtreme Programming: Designing  Defer design decisions as long as possible  Advantages:  Simplies current task (just build what is needed)  You dont need to maintain what you havent built  Time is on your side: youre likely to learn something useful by the time you need to decide  Tomorrow may never come: if a feature isnt needed now, it might never be needed  Disadvantages:  Future design decisions may require rework of existing implementation  Ramp-up time will probably be longer later  Therefore, always try to keep designs as simple as possible Copyright c 1997-2003 Vanderbilt University 34 UCLA Extension Course OO Programming with C eXtreme Programming: Coding  Pair programming  Always code with a partner  Always test as you code  Pair programming pays off by supporting good implementation, reducing mistakes, and exposing more than one programmer to the designimplementation  If any deciencies in existing implementation are noticed, either x them or note that they need to be xed. Copyright c 1997-2003 Vanderbilt University 35 UCLA Extension Course OO Programming with C eXtreme Programming: Testing  Unit tests are written before code.

--- Chunk 14 ---
Tokens: 396
Type: sentence-based
Text:
Copyright c 1997-2003 Vanderbilt University 35 UCLA Extension Course OO Programming with C eXtreme Programming: Testing  Unit tests are written before code. Code must pass both its unit test and all regression tests before committing. In effect, the test suite denes the system requirements. Signicant difference from other development approaches. If a bug is found, a test for it must be added. If a feature isnt tested, it can be removed. Copyright c 1997-2003 Vanderbilt University 36 UCLA Extension Course OO Programming with C eXtreme Programming: Information Sources  Kent Beck, Extreme Programming Explained: Embrace Change, Addison-Wesley, ISBN 0201616416, 1999. Kent Beck, Extreme Programming, C Report 11:5, May 1999, pp. 2629. John Vlissides, XP, interview with Kent Beck in the Pattern Hatching Column, C Report 11:6, June 1999, pp. 44-52. Kent Beck, Embracing Change with Extreme Programming, IEEE Computer 32:10, October 1999, pp. 70-77.  http:www.extremeprogramming.org  http:www.xprogramming.com  http:c2.comcgiwiki?ExtremeProgrammingRoadmap Copyright c 1997-2003 Vanderbilt University 37 UCLA Extension Course OO Programming with C Rules of Design  Make sure that the problem is well-dened  All design criteria, requirements, and constraints, should be enumerated before a design is started. This may require a spiral model approach. What comes before how  i.e, dene the service to be performed at every level of abstraction before deciding which structures should be used to realize the services. Separate orthogonal concerns  Do not connect what is independent.

--- Chunk 15 ---
Tokens: 365
Type: sentence-based
Text:
Separate orthogonal concerns  Do not connect what is independent. Important at many levels and phases . . . Copyright c 1997-2003 Vanderbilt University 38 UCLA Extension Course OO Programming with C Rules of Design (contd)  Design external functionality before internal functionality. First consider the solution as a black-box and decide how it should interact with its environment. Then decide how the black-box can be internally organized. Likely it consists of smaller black-boxes that can be rened in a similar fashion. Keep it simple. Fancy designs are buggier than simple ones; they are harder to implement, harder to verify, and often less efcient. Problems that appear complex are often just simple problems huddled together. Our job as designers is to identify the simpler problems, separate them, and then solve them individually. Copyright c 1997-2003 Vanderbilt University 39 UCLA Extension Course OO Programming with C Rules of Design (contd)  Work at multiple levels of abstraction  Good designers must be able to move between various levels of abstraction quickly and easily. Design for extensibility  A good design is open-ended, i.e, easily extendible. A good design solves a class of problems rather than a single instance. Do not introduce what is immaterial. Do not restrict what is irrelevant. Use rapid prototyping when applicable  Before implementing a design, build a high-level prototype and verify that the design criteria are met.

--- Chunk 16 ---
Tokens: 588
Type: sentence-based
Text:
Use rapid prototyping when applicable  Before implementing a design, build a high-level prototype and verify that the design criteria are met. Copyright c 1997-2003 Vanderbilt University 40 UCLA Extension Course OO Programming with C Rules of Design (contd)  Details should depend upon abstractions  Abstractions should not depend upon details  Principle of Dependency Inversion  The granule of reuse is the same as the granule of release  Only components that are released through a tracking system can be effectively reused  Classes within a released component should share common closure  That is, if one needs to be changed, they all are likely to need to be changed  i.e, what affects one, affects all Copyright c 1997-2003 Vanderbilt University 41 UCLA Extension Course OO Programming with C Rules of Design (contd)  Classes within a released component should be reused together  That is, it is impossible to separate the components from each other in order to reuse less than the total  The dependency structure for released components must be a DAG  There can be no cycles  Dependencies between released components must run in the direction of stability  The dependee must be more stable than the depender  The more stable a released component is, the more it must consist of abstract classes  A completely stable component should consist of nothing but abstract classes Copyright c 1997-2003 Vanderbilt University 42 UCLA Extension Course OO Programming with C Rules of Design (contd)  Where possible, use proven patterns to solve design problems  When crossing between two different paradigms, build an interface layer that separates the two  Dont pollute one side with the paradigm of the other Copyright c 1997-2003 Vanderbilt University 43 UCLA Extension Course OO Programming with C Rules of Design (contd)  Software entities (classes, modules, etc) should be open for extension, but closed for modication  The OpenClosed principle  Bertrand Meyer  Derived classes must usable through the base class interface without the need for the user to know the difference  The Liskov Substitution Principle Copyright c 1997-2003 Vanderbilt University 44 UCLA Extension Course OO Programming with C Rules of Design (contd)  Make it work correctly, then make it work fast  Implement the design, measure its performance, and if necessary, optimize it.

--- Chunk 17 ---
Tokens: 591
Type: sentence-based
Text:
Copyright c 1997-2003 Vanderbilt University 40 UCLA Extension Course OO Programming with C Rules of Design (contd)  Details should depend upon abstractions  Abstractions should not depend upon details  Principle of Dependency Inversion  The granule of reuse is the same as the granule of release  Only components that are released through a tracking system can be effectively reused  Classes within a released component should share common closure  That is, if one needs to be changed, they all are likely to need to be changed  i.e, what affects one, affects all Copyright c 1997-2003 Vanderbilt University 41 UCLA Extension Course OO Programming with C Rules of Design (contd)  Classes within a released component should be reused together  That is, it is impossible to separate the components from each other in order to reuse less than the total  The dependency structure for released components must be a DAG  There can be no cycles  Dependencies between released components must run in the direction of stability  The dependee must be more stable than the depender  The more stable a released component is, the more it must consist of abstract classes  A completely stable component should consist of nothing but abstract classes Copyright c 1997-2003 Vanderbilt University 42 UCLA Extension Course OO Programming with C Rules of Design (contd)  Where possible, use proven patterns to solve design problems  When crossing between two different paradigms, build an interface layer that separates the two  Dont pollute one side with the paradigm of the other Copyright c 1997-2003 Vanderbilt University 43 UCLA Extension Course OO Programming with C Rules of Design (contd)  Software entities (classes, modules, etc) should be open for extension, but closed for modication  The OpenClosed principle  Bertrand Meyer  Derived classes must usable through the base class interface without the need for the user to know the difference  The Liskov Substitution Principle Copyright c 1997-2003 Vanderbilt University 44 UCLA Extension Course OO Programming with C Rules of Design (contd)  Make it work correctly, then make it work fast  Implement the design, measure its performance, and if necessary, optimize it. Maintain consistency between representations  e.g, check that the nal optimized implementation is equivalent to the high-level design that was veried.

--- Chunk 18 ---
Tokens: 81
Type: sentence-based
Text:
Maintain consistency between representations  e.g, check that the nal optimized implementation is equivalent to the high-level design that was veried. Also important for documentation . . . Dont skip the preceding rules! Clearly, this is the most frequently violated rule! ;-) Copyright c 1997-2003 Vanderbilt University 45

================================================================================
SOURCE: Software Engineering Design- Theory and Practice.pdf
TOTAL CHUNKS: 575
================================================================================

--- Chunk 0 ---
Tokens: 413
Type: sentence-based
Text:
Software Engineering Design Theory and Practice Carlos E. Otero www.allitebooks.com www.allitebooks.com Software Engineering Design Theory and Practice www.allitebooks.com Titles in the Auerbach Series on Applied Software Engineering Phillip A. Laplante, Pennsylvania State University, Series Editor Software Engineering Design: Theory and Practice Carlos E. Otero 978-1-4398-5168-5 Ethics in IT Outsourcing Tandy Gold 978-1-4398-5062-6 The ScrumMaster Study Guide James Schiel 978-1-4398-5991-9 Antipatterns: Managing Software Organizations and People, Second Edition Colin J. Neill, Philip A. Laplante, and Joanna F. DeFranco 978-1-4398-6186-8 Enterprise-Scale Agile Software Development James Schiel 978-1-4398-0321-9 Requirements Engineering for Software and Systems Phillip A. Laplante 978-1-4200-6467-4 Building Software: A Practioners Guide Nikhilesh Krishnamurthy and Amitabh Saran 978-0-8493-7303-9 Global Software Development Handbook Raghvinder Sangwan, Matthew Bass, Neel Mullick, Daniel J. Paulish, and Juergen Kazmeier 978-0-8493-9384-6 Software Engineering Quality Practices Ronald Kirk Kandt 978-0-8493-4633-0 www.allitebooks.com Software Engineering Design Theory and Practice Carlos E. Otero www.allitebooks.com CRC Press Taylor  Francis Group 6000 Broken Sound Parkway NW, Suite 300 Boca Raton, FL 33487-2742  2012 by Taylor  Francis Group, LLC CRC Press is an imprint of Taylor  Francis Group, an Informa business No claim to original U.S. Government works Version Date: 20120511 International Standard Book Number-13: 978-1-4665-6586-9 (eBook - PDF) This book contains information obtained from authentic and highly regarded sources.

--- Chunk 1 ---
Tokens: 386
Type: sentence-based
Text:
Reasonable efforts have been made to publish reliable data and information, but the author and publisher cannot assume responsibility for the valid- ity of all materials or the consequences of their use. The authors and publishers have attempted to trace the copyright holders of all material reproduced in this publication and apologize to copyright holders if permission to publish in this form has not been obtained. If any copyright material has not been acknowledged please write and let us know so we may rectify in any future reprint. Except as permitted under U.S. Copyright Law, no part of this book may be reprinted, reproduced, transmitted, or uti- lized in any form by any electronic, mechanical, or other means, now known or hereafter invented, including photocopy- ing, microfilming, and recording, or in any information storage or retrieval system, without written permission from the publishers. For permission to photocopy or use material electronically from this work, please access www.copyright.com (http: www.copyright.com) or contact the Copyright Clearance Center, Inc. (CCC), 222 Rosewood Drive, Danvers, MA 01923, 978-750-8400. CCC is a not-for-profit organization that provides licenses and registration for a variety of users. For organizations that have been granted a photocopy license by the CCC, a separate system of payment has been arranged. Trademark Notice: Product or corporate names may be trademarks or registered trademarks, and are used only for identification and explanation without intent to infringe.

--- Chunk 2 ---
Tokens: 396
Type: sentence-based
Text:
Trademark Notice: Product or corporate names may be trademarks or registered trademarks, and are used only for identification and explanation without intent to infringe. Visit the Taylor  Francis Web site at http:www.taylorandfrancis.com and the CRC Press Web site at http:www.crcpress.com www.allitebooks.com This book is dedicated to my wife, Kelly, children Allison, Amanda, Michael, and Ashley, and parents Angel L. Otero and Lydia E. Rivera. www.allitebooks.com www.allitebooks.com vii Contents Preface. xvii Acknowledgments.xix About.the.Author.xxi Chapter 1 Introduction.to.Software.Engineering.Design.1 Chapter.Objectives. 1 Conceptual.Overview. 1 Engineering.Design. 2 Engineering.Problem.Solving. 3 Initial.State. 4 Operational.State. 4 Thinking.about.the.Problem. 5 Problem.Solution. 6 Goal.State. 6 Software.Engineering.Design. 9 Why.Study.Software.Engineering.Design. 10 Reasons.for.Studying.Software.Design.in.Product.Development. 10 Reasons.for.Studying.Software.Design.in.Project.Management. 11 Software.Design.Challenges. 11 Design.Challenge.1.Requirements.Volatility. 12 Design.Challenge.2.Process. 12 Design.Challenge.3.Technology. 12 Design.Challenge.4.Ethical.and.Professional.Practices. 13 Design.Challenge.5.Managing.Design.Influences. 13 Stakeholders. 14 Development.Organizations.Structure. 14 Context.of.Software.Design. 15 Software.Design.Process. 17 Software.Architecture. 18 Detailed.Design. 19 Interface.Design. 19 Component.Design.20 Construction.Design.20 HumanComputer.Interface.Design. 21 Software.Design.Documentation. 21 Software.Design.Management.

--- Chunk 3 ---
Tokens: 399
Type: sentence-based
Text:
21 Software.Design.Management. 21 www.allitebooks.com viii  Contents Roles.of.the.Software.Designer. 22 Systems.Engineer. 23 Software.Architect. 23 Component.Designer. 23 Software.Design.Fundamentals. 24 General.Software.Design.Principles. 24 Modularization. 25 Abstraction. 25 Encapsulation. 26 Coupling. 27 Cohesion. 28 Separation.of.Interface.and.Implementation. 29 Completeness.and.Sufficiency. 30 Practical.Software.Design.Considerations. 30 Design.for.Minimizing.Complexity. 31 Design.for.Change. 31 Software.Design.Strategies. 31 Structured.Design. 31 Object-Oriented.Design. 32 Chapter.Summary. 32 Review.Questions. 33 References.34 Chapter 2 Software.Design.with.Unified Modeling.Language.35 Chapter.Objectives. 35 Conceptual.Overview. 35 What.Is.UML. 36 Why.Study.UML. 37 The.UMLs.Fundamentals. 37 Structural.Modeling.40 Component.Diagrams.40 Logical.versus.Physical.Components.42 Class.Diagrams. 43 Classes. 43 Name.Compartment.44 Attribute.Compartment.44 Operation.Compartment. 45 Relationships.46 Dependency. 47 Association. 47 Aggregation.48 Composition.48 www.allitebooks.com Contents  ix Generalization. 49 Realization. 50 Deployment.Diagrams. 53 Behavioral.Modeling. 55 Use.Case.Diagrams. 55 Interaction.Diagrams. 57 Communication.Diagrams. 58 Sequence.Diagrams. 59 Concurrency.in.Interaction.Diagrams. 59 Chapter.Summary. 63 Review.Questions. 63 Chapter.Exercises.64 References. 65 Chapter 3 Principles.of.Software.Architecture.67 Chapter.Objectives. 67 Conceptual.Overview. 67 What.Is.Software.Architecture.68 Why.Study.Software.Architecture. 70 Key.Tasks.in.Architectural.Design.

--- Chunk 4 ---
Tokens: 393
Type: sentence-based
Text:
70 Key.Tasks.in.Architectural.Design. 70 Identifying.Stakeholders.Concerns. 71 Identifying.Appropriate.Architectural.Views. 71 Identifying.Architectural.Styles.and.Patterns. 71 Identifying.System.Interfaces. 72 Identifying.Impact.of.Architectural.Decisions.in.Organization. 72 Impact.on.Customer.Base. 73 Impact.on.Budget.and.Schedule. 73 Impact.from.Resource.Availability.74 Identifying.the.Systems.Major.Components.and.Interfaces.74 Evaluating.and.Validating.the.Architecture.74 Introducing.Policies.for.Design.Synchronicity. 75 Problem.Solving.in.Software.Architecture. 76 Inputs. 77 Constraints. 77 Outputs. 77 Software.Architecture.Process. 78 Understand.and.Evaluate.Requirements. 79 Elicitation. 79 Requirement.Sources. 79 Elicitation.Techniques. 81 Analysis. 82 x  Contents Specification.and.Validation.84 Specific. 85 Correct. 86 Complete. 86 Consistent. 87 Attainable. 87 Verifiable. 88 Designing.the.Architecture. 88 The.4.1.View.Model. 89 User.View. 89 Process.View.90 Physical.View.90 Development.View. 91 Logical.View. 91 Components.and.Connectors. 92 Designing.Logical.Architectural.Elements.Using.Data.Flows. 92 Designing.Logical.Architectural.Elements.Using.Styles.and.Patterns. 93 Designing.the.Process.Architecture. 93 Processes. 93 Threads. 94 Evaluating.the.Architecture. 103 Chapter.Summary. 104 Review.Questions. 105 Chapter.Exercises. 106 References. 106 Chapter 4 Patterns.and.Styles.in.Software.Architecture. 107 Chapter.Objectives. 107 Conceptual.Overview. 107 Architectural.Styles.and.Patterns. 108 History.of.Architectural.Styles.and.Patterns.

--- Chunk 5 ---
Tokens: 399
Type: sentence-based
Text:
108 History.of.Architectural.Styles.and.Patterns. 108 Architectural.Pattern.Classification. 109 Data-Centered.Systems.111 Blackboard.Pattern.111 Data.Flow.Systems.116 Pipe.and.Filter.Pattern.116 Distributed.Systems.120 ClientServer.Pattern.120 Broker.Pattern. 122 Interactive.Systems. 127 ModelViewController.Pattern. 127 Contents  xi Hierarchical.Systems. 131 Main.Program.and.Subroutine. 131 Layered.Pattern. 133 Chapter.Summary. 136 Review.Questions. 136 Chapter.Exercises. 137 References. 137 Chapter 5 Principles.of.Detailed.Design. 139 Chapter.Objectives. 139 Conceptual.Overview. 139 What.Is.Detailed.Design. 140 Key.Tasks.in.Detailed.Design. 142 Detailed.Design.Process. 142 Understanding.the.Architecture.and.Requirements. 143 Creating.Detailed.Designs. 144 Interface.Design. 144 External.Interface.Design. 144 Internal.Interface.Design. 145 Graphical.User.Interface.Design. 145 Designing.Internal.Structure.of.Components. 145 Classes. 146 Interfaces.Types.Subtypes.Dynamic.Binding.and.Polymorphism. 147 Objects. 148 Design.Principles.for.Internal.Component.Design. 149 OpenClosed.Principle. 149 Liskov.Substitution.Principle. 156 Interface.Segregation.Principle. 157 Programming.Styles.in.Detailed.Design. 159 Function.Names. 160 Variable.Names. 162 Modeling.Internal.Behavior.of.Components. 164 Design.Components.Using.Design.Patterns. 166 Architectural.versus.Design.Patterns. 167 Classification.of.Design.Patterns. 167 Documenting.Design.Patterns. 168 Document.the.Software.Design. 169 Interface.Control.Document. 171 Software.Version.Document. 172 Monitor.and.Control.Implementation.

--- Chunk 6 ---
Tokens: 395
Type: sentence-based
Text:
172 Monitor.and.Control.Implementation. 173 Chapter.Summary. 173 Review.Questions.174 xii  Contents Chapter.Exercises. 175 References. 175 Chapter 6 Creational.Design.Patterns.in.Detailed.Design. 177 Chapter.Objectives. 177 Conceptual.Overview. 177 Creational.Design.Patterns. 178 Abstract.Factory. 178 Problem. 179 Structure. 179 Implementation.181 Benefits. 188 Factory.Method. 188 Problem. 189 Structure. 189 Implementation. 191 Benefits. 192 Builder. 193 Problem. 195 Structure. 195 Implementation. 197 Benefits. 197 Prototype. 201 Problem. 201 Structure.204 Implementation.205 Benefits.207 Singleton.207 Problem.208 Structure.208 Implementation.209 Benefits.211 Chapter.Summary.211 Review.Questions.211 Chapter.Exercises. 212 Reference.214 Chapter 7 Structural.and.Behavioral Patterns.in.Detailed.Design. 215 Chapter.Objectives. 215 Conceptual.Overview. 215 Structural.Design.Patterns.216 Contents  xiii Adapter.216 Problem. 217 Structure. 219 Implementation. 219 Benefits. 221 Composite.223 Problem.224 Structure.225 Implementation.227 Benefits. 231 Facade. 232 Problem.234 Structure. 235 Implementation. 237 Benefits.238 Behavioral.Design.Patterns.238 Iterator.238 Problem. 239 Structure. 241 Implementation.245 Benefits. 251 Observer. 252 Problem. 252 Structure. 252 Implementation.254 Benefits.254 Chapter.Summary.256 Review.Questions.256 Chapter.Exercises. 257 Reference.258 Chapter 8 Principles.of.Construction.Design. 259 Chapter.Objectives. 259 Conceptual.Overview. 259 What.Is.Construction.Design. 259 Why.Study.Construction.Design.260 Behavioral.Construction.Design.

--- Chunk 7 ---
Tokens: 399
Type: sentence-based
Text:
259 Why.Study.Construction.Design.260 Behavioral.Construction.Design. 261 Flow-Based.Designs. 261 State-Based.Designs.262 Table-Based.Designs.264 Limited-Entry.Decision.Table.266 Extended-Entry.Decision.Table.268 xiv  Contents Mixed-Entry.Decision.Table. 270 Table-Based.Construction. 270 Programming.Design.Language. 271 Software.Construction.Using.Styles. 274 Formatting.Conventions. 275 Indentation. 276 Brace.Placement. 278 Naming.Conventions. 279 Documentation.Conventions.282 Documenting.Files.282 Documenting.Functions.282 Minimizing.Complexity.in.Construction.Design.283 Quality.Evaluation.of.Construction.Design.284 Peer.Reviews.285 Unit.Testing.286 Cyclomatic.Complexity.286 Chapter.Summary.290 Review.Questions.290 Chapter.Exercises. 291 References.292 Chapter 9 HumanComputer.Interface.Design. 293 Jacob Somervell Chapter.Objectives. 293 Conceptual.Overview. 293 What.Is.HumanComputer.Interface.Design.294 Why.Study.HumanComputer.Interface.Design.294 General.HCI.Design.Principles.297 HumanComputer.Interface.Design.Methods.299 Getting.Started.299 Fidelity.in.Prototypes.300 Metaphors. 301 Gestalt.Principles.303 Reusing.Earlier.Designs.305 Evaluation.of.HCI.Quality.305 Usability.Testing.305 Analytic.Testing.306 Empirical.Testing.307 Chapter.Summary.309 Review.Questions.309 Chapter.Exercises.309 References.310 Contents  xv Chapter 10 Software.Design.Management.Leadership.and.Ethics. 311 Luis Daniel Otero Chapter.Objectives.311 Conceptual.Overview.311 What.Is.Software.Design.Management. 312 Why.Study.Design.Management. 312 The.Concept.of.Quality. 312 Design.Management.Framework.

--- Chunk 8 ---
Tokens: 369
Type: sentence-based
Text:
312 Design.Management.Framework. 313 Planning.Design.Efforts.314 Scoping. 315 Work.Breakdown.Structure. 315 Budgeting.316 Organizing.317 Linear.Responsibility.Chart.318 Scheduling.with.Gantt.Charts.and.Network.Diagrams.318 Probability.of.Time.to.Completion. 322 Establish.Change.Control.Policy.324 Implementation.Phase. 325 Earned.Value.Management. 326 Termination.Stage. 329 Leading.the.Design.Effort. 329 Personality.Traits.and.Leadership. 329 Personality.Dimensions. 329 Traits.of.Effective.Leaders. 330 Ethical.Leadership. 330 Power.331 Key.Leadership.Skills. 332 Communication.Skills. 332 Networking.Skills. 333 Motivation.Skills. 333 Negotiation.Skills. 334 Ethics.in.Software.Design. 335 Public.and.Product.Principles. 335 Judgment.Principle. 336 Management.Principle. 336 Chapter.Summary. 336 Review.Questions. 338 Chapter.Exercises. 339 References.340 xvii This.book.is.the.result.of.an.effort.that.I.began.in.2010.at.the.University.of.Virginias. College.at.Wise.to.create.a.course.in.software.engineering.design.consistent.with.the.2004. IEEEACM.curriculum.guidelines.for.undergraduate.programs.in.software.engineering. (SE).In.a.broad.context.the.recommended.topics.for.undergraduate.SE.programs.include. design.concepts.design.strategies.architectural.design.detailed.design.humancomputer. interface.design.and.design.evaluation.As.a.former.industry.practitioner.I.learned.first- hand.the.difference.between.hearing.or.learning.about.these.topics.and.developing.the.

--- Chunk 9 ---
Tokens: 391
Type: sentence-based
Text:
interface.design.and.design.evaluation.As.a.former.industry.practitioner.I.learned.first- hand.the.difference.between.hearing.or.learning.about.these.topics.and.developing.the. necessary.skills.to.apply.them.in.a.way.that.adds.value.to.some.development.team.pro- gram.project.or.business.With.that.in.mind.I.set.out.to.compile.material.that.I.could. use. (from. previous. industry. experience). to. help. students. become. proficient. in. design- ing.software-intensive.systems.Throughout.the.process.many.of.the.original.examples. considered.dry.or.hard.to.follow.by.students.were.replaced.with.new.problem.domains. (e.g, gaming. systems). that. helped. students. assimilate. the. concepts. better. Because. of. the.hands-on.approach.required.to.master.these.concepts.the.teaching.style.evolved. to.emphasize.both.theory.and.practice.The.theory.portion.was.used.to.present.accept- able.general.design.principles.or.a.body.of.design.principles.to.explain.successful.software. .systems.designs.The.practice.portion.provided.the.avenue.for.transforming.design.theory. into.skills.that.can.be.employed.directly.to.real-life.industrial.settings.The.knowledge. and.experience.gained.from.these.efforts.have.been.captured.in.this.textbook.which.can. be.useful.for.both.industry.practitioners.and.students.in.software.engineering.computer. .science.and.information.technology.programs. INTRODUCTION This.book.provides.an.introduction.to.the.essential.concepts.employed.by.software.engi- neers.who.design.large-scale.software-intensive.systems.in.a.professional.environment.

--- Chunk 10 ---
Tokens: 391
Type: sentence-based
Text:
INTRODUCTION This.book.provides.an.introduction.to.the.essential.concepts.employed.by.software.engi- neers.who.design.large-scale.software-intensive.systems.in.a.professional.environment. It bridges.the.gap.between.industry.and.academia.by.providing.students.with.a.comprehen- sive.view.of.software.design.using.industry-proven.concepts.for.designing.complex.software. systems.Its.unique.blend.of.theory.and.practice.provides.both.students.and.industry.prac- titioners.with.key.concepts.that.are.immediately.relevant.to.todays.software.designers.The. book.contains.examples.review.questions.and.chapter.exercises.carefully.selected.to.bring. real-world.problems.into.a.classroom.environment.More.importantly.it incorporates.an. effective.learn-by-doing.approach.that.allows.students.to.transform.design.theory.into.the. skills.required.to.design.complex.software.systems.The.book.starts.by.providing.a.general. overview.of.software.design.including.the.fundamentals.of.software.design.the.importance. of.studying.software.design.and.different.practical.concepts.used.for.designing.software. Preface xviii  Preface As.part.of.the.introductory.material.the.software.engineering.process.is.covered.briefly. to.provide.the.context.in.which.software.design.takes.place.and.a.formal.top-down.design. process.is.presented.The.top-down.approach.consists.of.several.design.phases.and.activi- ties.that.occur.at.varied.levels.of.detailabstraction.including.the.software.architecture. detailed. design. and. construction. design. As. part. of. the. top-down. approach. detailed.

--- Chunk 11 ---
Tokens: 399
Type: sentence-based
Text:
detailed. coverage.of.applied.architectural.creational.structural.and.behavioral.design.patterns.is. provided.and.a.collection.of.standards.and.guidelines.for.structuring.high-quality.code. is.presented.The.book.also.provides.techniques.for.evaluating.software.design.quality.at. different.stages.and.much.needed.coverage.of.management.and.engineering.leadership. for.software.designers.This.provides.software.engineers.with.the.necessary.management. .ethical.and.leadership.knowledge.required.to.build.products.for.the.public.domain.The. book.also.provides.coverage.of.the.software.design.document.and.other.forms.of.documen- tation.important.during.the.design.of.software.systems.Collectively.the.book.comprehen- sively.introduces.students.and.practitioners.to.software.engineering.design.and.provides. the.knowledge.required.to.emerge.and.succeed.as.tomorrows.professional.design.leaders. USE AS A TEXTBOOK The.textbook.provides.a.comprehensive. (sophomore-level).introduction.to.required.con- cepts.in.software.design.When.used.as.textbook.instructors.are.encouraged.to.visit.the. textbook.website.to.download.slides.the.solutions.manual.and.other.exercises.developed. as.part.of.the.ongoing.effort.to.improve.education.in.software.engineering.design.The. material.presented.in.the.books.10.chapters.can.be.easily.extended.to.16.weeks.espe- cially.when.covering.the.topics.of.design.patterns.A.recommended.approach.includes. conducting.microdesign.reviews.where.students.(or.student.groups).design.implement. and. present. their. work. regularly. while. other. students. evaluate. critique. and.

--- Chunk 12 ---
Tokens: 398
Type: sentence-based
Text:
and. provide. peer-review.comments.Because.of.the.nature.of.the.topics.covered.students.are.expected. to.meet.the.following.prerequisites: . Introduction.to.Programming. (with.object-oriented.language) . Data.Structures.and.Algorithms . Introduction.to.Software.Engineering Ultimately.the.most.important.feature.of.software.designs.is.their.applicability.to.build. software.therefore.the.course.should.require.students.to.implement.a.large.portion.of. the.designs.created.as.part.of.the.course.A.recommended.approach.(when.possible).is.to. adopt.a.unified.modeling.language.(UML).modeling.tool.capable.of.forward.and.reverse. engineering.and.use.the.textbook.as.a.guide.for.creating.and.assigning.design.problems. centered.around.the.topics.discussed.throughout.the.book.since.they.are.essential.to.all. software.engineering.students.from.ABET-accredited.programs. www.allitebooks.com xix Many.people.have.contributed.to.this.effort.in.one.way.or.another.First.I.would.like.to. thank.Dr.Jacob.Somervell.from.the.University.of.Virginias.College.at.Wise.and.Dr. Luis. Daniel.Otero.from.Florida.Institute.of.Technology.for.providing.the.material.for.Chapters. 9.and.10.respectively.Your.work.made.the.overall.product.complete.and.many.students. and.practitioners.will.benefit.from.your.contributions.I.also.thank.Dr.Ira.Weissberger. from.Harris.Corporation.for.his.contribution.on.the.section.on.software.design.docu- mentation.in.Chapter.5.and.Stefan.Joe-Yen.from.Northrop.Grumman.Corporation.for.his. contribution.to.the.architectural.patterns.chapter.I.would.also.like.to.thank.the.reviewers.

--- Chunk 13 ---
Tokens: 399
Type: sentence-based
Text:
contribution.to.the.architectural.patterns.chapter.I.would.also.like.to.thank.the.reviewers. and.staff.at.Taylor.Francisin.particular.John.Wyzalekfor.their.help.throughout.this. long.process.Finally.and.most.importantly.I.thank.my.wife.Kelly.and.children.Allison. Amanda.Michael.and.Ashley.for.their.sacrifices.patience.and.support. Acknowledgments xxi Carlos E. Otero, PhD.is.assistant.professor.in.the.College.of.Technology.and.Innovation. at.the.University.of.South.Florida.Polytechnic.(USFP).Prior.to.joining.USFP.Dr.Otero. worked.as.assistant.professor.of.software.engineering.in.the.Department.of.Mathematics. and.Computer.Science.at.the.University.of.Virginias.College.at.Wise.where.he.created. the.software.engineering.design.course.for.Virginias.first.and.(at.the.time.of.writing).only. ABET-accredited.BS.in.software.engineering. Prior.to.his.academic.career.Dr.Otero.spent.11.years.in.the.private.industry.where. he.worked.as.design.and.development.engineer.in.a.wide.variety.of.military.computer. .systems. including. satellite. communications. systems. command. and. control. systems. wireless.security.systems.and.unmanned.aerial.vehicle.systems.Currently.he.continues. to.consult.with.industry.in.the.areas.of.requirements.engineering.software.systems.design. and.development.quality.assurance.and.mobile.systems.engineering. Dr.Otero.received.his.BS.in.computer.science.MS.in.software.engineering.MS.in.systems. engineering.and.PhD.in.computer.engineering.from.Florida.Institute.of.Technology.in. Melbourne.He.has.published.over.25.technical.publications.in.scientific.peer-reviewed.

--- Chunk 14 ---
Tokens: 390
Type: sentence-based
Text:
Melbourne.He.has.published.over.25.technical.publications.in.scientific.peer-reviewed. journals.and.conferences.proceedings.He.is.a.senior.member.of.the.IEEE.a science.advisor. for.the.National.Aeronautics.and.Space.Administration.(NASA).DEVELOP.program.an. active.professional.member.of.the.Association.for.Computing.Machinery.(ACM).and.a. member.of.several.journal.editorial.boards.in.technology.and.engineering. About the Author 1 1 Introduction to Software Engineering Design CHAPTER OBJECTIVES . Understand.software.design.from.the.engineering.perspective . Understand.the.importance.of.software.design.in.developing.com- plex.products . Understand.the.issues.that.make.software.design.challenging . Understand.the.software.design.process.and.differentiate.between. its.activities . Become.familiar.with.software.design.principles.considerations.and. strategies CONCEPTUAL OVERVIEW Software.design.is.an.indispensable.phase.of.the.software.engineering.pro- cess.for.creating.and.evaluating.software.models.that.guide.the.construc- tion.effort.for.developing.high-quality.software.systems.on.time.and.within. budget.Conceptually.design.is.the.process.of.transforming.functional.and. nonfunctional.requirements.into.models.that.describe.the.technical.solution. before.construction.begins.To.achieve.this.the.concept.of.software.design. its.activities.and.tasks.must.be.well.understood.so.that.a.problem-solving. framework.for.designing.quality.into.software.products.can.be.established. In.todays.modern.software.systems.there.are.numerous.design.principles.

--- Chunk 15 ---
Tokens: 380
Type: sentence-based
Text:
In.todays.modern.software.systems.there.are.numerous.design.principles. processes.strategies.and.other.factors.affecting.how.designers.execute.the. software.design.phase.When.equipped.with.the.proper.design.foundation. knowledge.an.understanding.of.the.designers.roles.and.responsibilities. 2  Software Engineering Design can.be.acquired.allowing.designers.to.become.effective.in.designing.large-scale.software. systems.under.a.wide.variety.of.challenging.conditions.This.chapter.presents.the.funda- mental.concepts.of.software.engineering.design.within.context.and.provides.the.motiva- tion.for.the.rest.of.the.book. ENGINEERING DESIGN Design.is.an.integral.part.of.every.engineering.discipline.Airplanes.bridges.buildings. electronic.devices.cars.and.many.other.products.of.similar.complexity.are.all.designed. In.civil.engineering.designs.are.used.to.specify.detailed.plans.for.developing.physical.and. naturally.built.environments.such.as.bridges.roads.canals.dams.and.buildings.In.elec- trical.engineering.designs.are.used.to.capture.evaluate.and.specify.the.detailed.qualita- tive.and.quantitative.description.of.solutions.for.telecommunication.systems.electrical. systems.and.electronic.devices.In.mechanical.engineering.designs.are.used.for.analyzing. evaluating.and.specifying.technical.features.required.to.construct.machines.and.tools. such.as.industrial.equipment.heating.and.cooling.systems.aircrafts.robots.and.medical. devices.In.all.other.engineering.disciplines.design.provides.a.systematic.approach.for.

--- Chunk 16 ---
Tokens: 383
Type: sentence-based
Text:
devices.In.all.other.engineering.disciplines.design.provides.a.systematic.approach.for. creating.products.that.meet.their.intended.functions.and.users.expectations.Formally. Dym and.Little. (2008.p.6).define.engineering.design.as A.systematic.intelligent.process.in.which.designers.generate.evaluate.and.specify.designs.for. devices.systems.or.processes.whose.form(s).and.function(s).achieve.clients.objectives.and. users.needs.while.satisfying.a.specified.set.of.constraints. Design.is.a.lengthy.and.complex.process.requiring.significant.investments.in.time.and. effort.So.why.conduct.design.in.engineering.disciplines.There.are.many.possible.answers. to.this.question.stemming.from.simple.common.sense.to.more.complicated.ones.involv- ing.professional.ethical.social.and.legal.implications.From.the.commonsense.perspec- tive.products.of.such.complexity.are.hard.to.create.are.costly.to.change.and.when.built. carelessly.or.incorrectly.can.significantly.impact.human.life.When.working.toward.the. creation.of.complex.products.teams.must.organize.in.a.disciplined.manner.and.a.sys- tematic.approach.needs.to.be.employed.to.carefully.ensure.that.products.are.built.to.meet. their.specifications.Consider.the.construction.of.a.bridge.that.spans.over.a.body.of.water. and.is.required.to.support.a.particular.weight.to.maintain.access.to.watercrafts.navigating. underneath.to.withstand.expected.wind.speeds.and.to.provide.other.features.such.as.side- walksall.while.being.bound.by.a.schedule.and.budget.The.successful.construction.of.such.

--- Chunk 17 ---
Tokens: 391
Type: sentence-based
Text:
underneath.to.withstand.expected.wind.speeds.and.to.provide.other.features.such.as.side- walksall.while.being.bound.by.a.schedule.and.budget.The.successful.construction.of.such. a.bridge.is.a.nontrivial.task.and.requires.years.of.experience.formal.education.and.large. teams.collaborating.together.to.achieve.the.construction.goals.If.constructed.incorrectly. reconstructing.the.bridge.can.skyrocket.from.its.original.construction.cost.worse.yet. if.defects.are.undetected.the.bridge.could.collapse.resulting.in.the.catastrophic.loss.of. human.life.Similar.to.the.construction.of.the.bridge.teams.engineering.other.products. Introduction to Software Engineering Design  3 such.as.airplanes.watercrafts.medical.devices.and.safety-critical.software.systems.share. comparable.challenges.and.failure.of.these.products.can.also.result.in.catastrophic.events. In.an.engineering.environment.before.product.construction.begins.the.design.of.prod- ucts.needs.to.be.carefully.and.extensively.planned.evaluated.verified.and.validated.to. ensure.the.products.success.This.is.mainly.achieved.through.design. ENGINEERING PROBLEM SOLVING Throughout.the.design.process.designers.are.constantly.engaging.in.problem-solving.activ- ities.that.are.fundamental.to.all.modern.engineering.projects.In.a.broad.sense.engineers. can.be.characterized.as.specialized.problem.solvers.Their.work.requires.them.to.identify. evaluate.and.propose.solutions.to.complex.problems.(in.particular.domains).under.tight. project.constraints.In.some.situations.engineers.tackle.problems.that.have.never.been.

--- Chunk 18 ---
Tokens: 397
Type: sentence-based
Text:
project.constraints.In.some.situations.engineers.tackle.problems.that.have.never.been. solved.before.creating.challenges.to.meet.not.only.functional.aspects.of.products.but.also. their.established.schedule.and.budget.Before.engaging.in.more.concrete.design.topics.a. formal.discussion.on.problem.solving.is.necessary.to.identify.fundamental.concepts.that. are.well.understood.by.successful.designers.these.serve.as.basis.for.establishing.a.holistic. problem.solving.framework.that.can.be.employed.any.time.during.design. To.become.a.good.designer.engineers.must.be.good.problem.solvers.This.may.require. years.of.experience.solving.problems.in.a.particular.domain.In.many.cases.experience. allows.engineers.to.reuse.already.proven.solutions.across.separate.but.similar.problems. In. other. cases. where. unsolved. problems. are. encountered. designers. are. required. to. think out.of.the.box.and.carefully.craft.a.systematic.approach.for.solving.the.problem.in. an.acceptable.manner.which.may.require.problem.classification.identification.of.the.solu- tion.approach.and.type.of.adequate.solution.and.identifying.the.overall.strategy.for.reach- ing.its.solution.In.a.general.sense.problem.solving.during.design.occurs.in.three.different. states. (Plotnik.and.Kouyoumdjian.2010): . Initial.state . Operation.state . Goal.state Through.these.states.designers.employ.several.techniques.and.strategies.to.create.a. landscape.suitable.for.problem.solving.The.initial.state.is.where.problems.are.formulated. and.interpreted.In.some.cases.achieving.full.understanding.of.the.problem.is.a.problem.

--- Chunk 19 ---
Tokens: 379
Type: sentence-based
Text:
and.interpreted.In.some.cases.achieving.full.understanding.of.the.problem.is.a.problem. itself.Once.problems.are.well.understood.designers.move.to.the.operational.state.where. thinking.about.the.problem.occurs.and.viable.solutions.come.to.light.Once.an.appropri- ate.solution.is.identified.evaluated.and.validated.designers.move.to.the.goal.state.where. a.final.solution.to.the.problem.is.found.marking.the.end.of.the.problem-solving.process. 4  Software Engineering Design Initial State Design.problems.are.not.all.the.same.they.vary.in.size.complexity.and.based.on.these. characteristics.the.amount.of.time.and.effort.required.for.their.solution.In.some.cases.it. quickly.becomes.evident.that.certain.problems.are.harder.to.solve.than.others.When.this. determination.is.made.the.strategy.for.the.solution.approach.is.adjusted.to.account.for. the.additional.complexity.Being.able.to.differentiate.between.types.of.problem.is.crucial. in.helping.designers.account.for.the.amount.of.effort.time.and.risk.associated.with.the. solution.approach.Therefore.an.important.problem-solving.skill.involves.identifying.and. classifying.the.type.of.problem.encountered.which.includes.well-defined.ill-defined.and. wicked problems.as.presented.in.Table 1.1.(Giachetti.2010). Well-defined.problems.have.clear.defined.goals.and.their.constraints.are.well.under- stood.This.makes.scoping.the.problem.proposing.a.solution.approach.and.arriving.at. the.solution.easier.than.with.other.types.of.problems.such.as.ill-defined.and.wicked.

--- Chunk 20 ---
Tokens: 382
Type: sentence-based
Text:
the.solution.easier.than.with.other.types.of.problems.such.as.ill-defined.and.wicked. problems.Ill-defined.problems.are.problems.where.the.mere.interpretation.of.the.prob- lem.is.a.problem.itself.they.are.ambiguous.with.undefined.goals.and.require.more.time. and.effort.to.clarify.and.interpret.the.problem.to.arrive.at.a.solution.In.some.cases.with. additional.effort.ill-defined.problems.can.be.transformed.into.well-defined.problems. Finally.wicked.problems.are.problems.where.no.single.problem.formulation.exists.There. may.be.many.acceptable.formulations.of.the.problem.and.no.definite.solutions.and.solu- tions.are.not.deemed.correct.or.incorrect.but.good.or.bad. (Giachetti.2010).In many.cases. wicked.problems.can.lead.to.contradictive.goals.that.need.additional.resolution.before.the. problem.solving.can.occur.When.contradictive.goals.are.present.providing.a.solution. to.one.part.of.the.problem.results.in.the.inability.of.solving.other.parts.of.the.problem. In.these.types.of.problem.optimal.solutions.are.hard.to.find.requiring.additional.strug- gle.and.collaborative.brainstorming.Also.evaluation.of.alternative.designs.may.require. advanced.techniques.to.determine.the.best.course.of.action.which.tends.to.require.more. time.In.many.cases.the.solution.to.wicked.problems.is.not.known.until.after.the.problem. is.solved. Operational State The.operational.state.of.problem.solving.is.where.thinking.about.the.problem.solution. takes.place.It.requires.employing.multiple.techniques.for.problem.solving.such.as.using.

--- Chunk 21 ---
Tokens: 378
Type: sentence-based
Text:
takes.place.It.requires.employing.multiple.techniques.for.problem.solving.such.as.using. metaphors.decomposing.problems.into.smaller.less.complex.problems.(i.e.divide.and. conquer).reusing.solutions.(e.g.patterns).and.so.forth.In.all.of.the.techniques.designers. TABLE 1.1 Problem.Classification Problem Description Well-defined Problem.with.clear.goals.and.known.constraints Ill-defined Problem.with.undefined.or.ambiguous.goals.and.unknown.constraints Wicked Problem.with.no.definite.solution.not.understood.until.after.the.formulation.of.its.solution Introduction to Software Engineering Design  5 are.expected.to.exhibit.a.think.outside.the.box.mentality.to.be.able.to.solve.complex. problems.This.requires.shifting.the.mental.model.from.a.conventional.approach.to.uncon- ventional.methodology.where.solutions.to.complex.problems.may.arise.from.thinking.in. ways.that.deviate.from.conventional.wisdom.For.example.consider.the.popular.nine-dot. puzzle.illustrated.in.Figure 1.1.(Kershaw.and.Ohlsson.2004). The.requirements.for.solving.the.nine-dot.puzzle.problem.are.as.follows: . 1.Draw.four.straight.lines.to.connect.all.dots. . 2.The.pencil.cannot.be.lifted.from.the.paper.once.the.line-drawing.process.begins. . 3.No.lines.can.be.retraced. Before.moving.on.think.about.this.problem.and.attempt.to.provide.a.solution.At.first. this.may.seem.difficult.because.of.the.tendency.of.fixing.the.mental.process.to.operate.on. the.assumption.that.lines.should.begin.and.end.on.a.dot.This.functional fixedness.limits.

--- Chunk 22 ---
Tokens: 391
Type: sentence-based
Text:
the.assumption.that.lines.should.begin.and.end.on.a.dot.This.functional fixedness.limits. the.ability.to.find.solutions.based.on.objects.having.a.different.function.from.their.usual. ones. (Plotnik.and.Kouyoumdjian.2010).In.the.case.of.the.nine-dot.puzzle.for.some.func- tional.fixedness.makes.it.awkward.or.even.impossible.to.propose.solutions.that.involve.lines. going.past.the.dots.which.is.what.is.required.to.solve.this.problem.To.increase.the.chance. of.overcoming.functional.fixedness.problems.need.to.be.attempted.several.times.and.con- sidered.from.many.different.viewpoints.and.unusual.angles.(Plotnik.and.Kouyoumdjian). Overcoming.functional.fixedness.is.critical.for.designers.attempting.to.provide.solutions. at.the.operational.state.of.problem.solving. Thinking about the Problem Different.types.of.thinking.take.place.when.finding.solutions.to.problems.For.example. when.learning.about.a.problem.for.the.first.time.problem.solvers.may.begin.by.asking. questions.which.allows.them.to.think.about.many.different.alternative.solutions.as.the. problem-solving.process.moves.forward.problem.solvers.can.begin.narrowing.down.the. possibilities.and.think.about.the.single.best.solution.to.the.problem.These.types.of.think- ing.are.known.as.convergent thinking.and.divergent thinking.(Table.1.2). Both.convergent.and.divergent.thinking.have.significant.roles.in.solving.engineering. problems.In.many.cases.problem.solvers.begin.using.divergent.thinking.with.different. levels.of.abstraction.and.each.level.provides.finer-grained.solutions.to.the.problem.until.

--- Chunk 23 ---
Tokens: 390
Type: sentence-based
Text:
levels.of.abstraction.and.each.level.provides.finer-grained.solutions.to.the.problem.until. convergent.thinking.can.be.employed.to.solve.it. FIGURE 1.1 The.nine-dot.puzzle. 6  Software Engineering Design Problem Solution In.many.cases.determining.the.type.of.solution.required.for.a.given.problem.can.reduce. wasted.time.and.effort.spent.in.attempting.to.find.a.single.optimal.solution.In.such.cases. designers.can.elect.to.seek.approximate.solutionsas.opposed.to.optimal.solutionsthat. are.appropriate.and.acceptable.for.meeting.project.constraints.Determining.the.type.of. solution.for.a.given.problem.can.reduce.time.and.budget.required.for.building.the.system. Two.types.of.solutions.are.algorithms.and.heuristics.as.presented.in.Table 1.3. Algorithms.are.step-by-step.procedures.for.finding.the.correct.solution.to.given.prob- lems. Algorithms. do. not. normally. involve. subjective. decisions. or. rely. on. intuition. or. .creativity.to.find.solutions.(Brassard.and.Bratley.1995).For.some.types.of.problems.using. algorithms.to.find.solutions.can.be.unrealistic.especially.in.time-driven.practical.engi- neering.problems.In.these.cases.heuristics.provide.a.realistic.approach.for.finding.good. approximations.of.the.solution.In.some.cases.heuristics.can.lead.to.optimal.solutions.in. others.they.can.lead.to.solutions.that.are.far.from.optimal.or.no.solution.at.all.(Brassard. and.Bratley.1995).Algorithms.and.heuristics.are.both.used.heavily.in.the.design.of.engi- neering.systems.and.determining.their.appropriateness.for.solving.particular.problems.is.

--- Chunk 24 ---
Tokens: 373
Type: sentence-based
Text:
and.Bratley.1995).Algorithms.and.heuristics.are.both.used.heavily.in.the.design.of.engi- neering.systems.and.determining.their.appropriateness.for.solving.particular.problems.is. essential.to.meeting.other.project.demands. Goal State The.goal.state.represents.the.final.state.of.problem.solving.It.is.where.adequate.solutions. to.given.problems.are.determined.For.many.engineering.problems.reaching.the.goal.state. is.a.nontrivial.task.that.requires.careful.attention.to.all.important.aspects.of.the.problem. The.concepts.of.initial.operational.and.goal.state.can.be.fused.together.to.create.a.holistic. problem-solving.framework.adequate.to.solving.engineering.problems.at.all.stages.of.the. development.effort.The.approach.consists.of.the.following.tasks: . Interpret.problem . Evaluate.constraints . Collaborative.brainstorming TABLE 1.2 Types.of.Thinking Type Description Convergent.thinking Type.of.thinking.that.seeks.to.find.one.single.solution.to.a.problem Divergent.thinking Type.of.thinking.that.seeks.to.find.multiple.solutions.to.a.problem TABLE 1.3 Types.of.Problem.Solution Problem Description Algorithm Fixed.set.of.rules.that.lead.to.the.solution.of.a.problem Heuristic Rules.of.thumb. (or.procedure).that.may.or.may.not.lead.to.the.solution.of.a.problem www.allitebooks.com Introduction to Software Engineering Design  7 . Synthesize.possibilities . Evaluate.solution . Implement.solution The.first.task.of.the.problem-solving.approach.involves.interpreting the problem.This.

--- Chunk 25 ---
Tokens: 364
Type: sentence-based
Text:
Implement.solution The.first.task.of.the.problem-solving.approach.involves.interpreting the problem.This. is.where.problem.information.is.received.and.processed.problem.classification.is.identi- fied.(e.g.well-defined.ill-defined).and.activities.are.performed.to.formulate.the.problem. Interpreting.the.problem.is.a.task.performed.during.the.initial.state.of.problem.solving. During.the.initial.state.identification.of.stakeholderspersons.groups.or.organizations. that.have.direct.or.indirect.stake.in.the.problem.and.its.solutionis.essential.Once.the. problem.is.formulated.the.evaluate constraints.task.is.used.to.identify.external.problem.con- straints.which.are.negotiated.integrated.and.used.to.set.the.bounds.on.the.solution.land- scape.Once.the.problem.and.constraints.are.well.understood.collaborative brainstorming. can.begin.among.problem.solvers.and.stakeholders.During.collaborative.brainstorming. problem.solvers.use.mostly.divergent.thinking.to.come.up.with.alternative.solutions.that. may.bring.to.light.new.knowledge.which.can.trigger.a.transition.back.to.the.problem.inter- pretation.task.Once.a.set.of.acceptable.solutions.is.identified.problem.solvers.synthesize possibilities to.form.the.acceptable.proposed.solution.to.the.problem.During.this.task.prob- lem.solvers.shift.from.divergent.thinking.to.convergent.thinking.to.propose.the.best-known. solution.to.the.problem.The.solution.is.shared.and.evaluated.by.everyone.involved.in.the.

--- Chunk 26 ---
Tokens: 400
Type: sentence-based
Text:
solution.to.the.problem.The.solution.is.shared.and.evaluated.by.everyone.involved.in.the. problem-solving.process.Flaws.in.the.solution.may.trigger.a.transition.back.to.the.collab- orative.brainstorming.task.otherwise.implementation.begins.Collaborative brainstorming. synthesize possibilities.and.evaluate solutions.are.all.tasks.performed.as.part.of.the.opera- tional.state.of.problem.solving.During.implementation.the.proposed.solution.is.executed. until.the.problem.is.solved.which.is.a.task.performed.during.the.goal.state.of.problem.solv- ing.Together.these.tasks.are.combined.with.other.problem.variables.to.provide.a.holistic. approach.to.problem.solving. (Harrell.Ghosh.and.Bowden.2004).as.presented.in.Figure 1.2. As.seen.in.the.figure.inputs.are.items.that.require.processing.during.problem.solving. Inputs.come.from.many.different.sources.and.are.interpreted.and.formulated.for.particu- lar.problems.They.drive.all.activities.by.specifying.the.overarching.need.that.promotes. the.execution.of.the.problem-solving.tasks.Constraints.are.external.properties.that.come. inherent. with. any. problem. and. limit. the. solution. approach. Outputs. are. the. expected. outcome.in.problem.solving.In.many.engineering.projects.merely.coming.up.with.the. solution.to.a.given.problem.is.not.enough.since.the.solution.needs.to.be.documented. formatted.decorated.specified.in.graphical.model.format.or.placed.under.configuration. management.Outputs.coming.out.of.the.problem-solving.process.need.to.meet.the.appro- priate.standards.as.defined.by.the.developing.organization.The.development.organization.

--- Chunk 27 ---
Tokens: 398
Type: sentence-based
Text:
management.Outputs.coming.out.of.the.problem-solving.process.need.to.meet.the.appro- priate.standards.as.defined.by.the.developing.organization.The.development.organization. may.also.set.standards.for.activities.controls.and.resources.which.all.impact.problem. solving.These.variables.are.presented.in.Table 1.4. Activities.are.internal.tasks.determined.by.the.development.organization.that.must.be. followed.when.solving.problems.These.are.intended.to.help.manage.the.problem-solving. approach.and.may.include.review.activities.at.different.stages.of.problem.solving.includ- ing.preliminary.and.detailed.stages.status.reports.and.documentation.which.all.impact.the. 8  Software Engineering Design time.required.to.solve.the.problem.Controls.on.the.other.hand.are.internal.constraints.set.by. the.development.organization.that.limit.the.possible.solutions.so.that.they.align.well.with.the. organizational.goals.and.current.practices.These.controls.can.dictate.when.and.where.prob- lem.solving.takes.place.selection.of.strategies.permitted.tools.personnel.allowed.to.engage.in. problem.solving.and.measures.for.quality.control.Finally.resources.are.the.means.by.which. activities.are.performed.which.include.people.software.and.hardware.and.their.availability. which.all.impact.problem.solving.Together.all.of.these.variables.mix.together.to.define.the. problem-solving.landscape.which.must.be.considered.when.tackling.engineering.problems. Skill Development 1.1: Using the Holistic Approach in Problem Solving Use.and.document.all.the.steps.of.the.holistic.problem-solving.approach.presented.in.

--- Chunk 28 ---
Tokens: 389
Type: sentence-based
Text:
Skill Development 1.1: Using the Holistic Approach in Problem Solving Use.and.document.all.the.steps.of.the.holistic.problem-solving.approach.presented.in. Figure 1.2.to.solve.the.following.problem.If.possible.do.this.exercise.as.a.team.The. problem.specification.is.as.follows.there.are.six.equal.matches.connect.each.match.to. form.four.equilateral.triangles.When.done.explain.how.functional.fixedness.played.a. role.in.preventing.you.from.arriving.at.the.solution.to.this.problem. TABLE 1.4 Problem-Solving.Process.Variables Phase Description Activities One.or.more.tasks.identified.and.required.to.solve.the.problem Resources Means.by.which.activities.are.performed Controls Internal.properties.of.the.organization.that.place.bounds.on.the.solution.or.the.solution.process. for.the.problem Evaluate Constraints Synthesize Possibilities Interpret Problem Evaluate Inputs Constraints Outputs Collaborative Brainstorming Implement Generic Design Problem Resources Activities Controls FIGURE 1.2 Holistic.approach.to.problem.solving. Introduction to Software Engineering Design  9 SOFTWARE ENGINEERING DESIGN In.the.previous.sections.design.was.introduced.as.a.systematic.and.intelligent.process.for. generating.evaluating.and.specifying.designs.for.devices.systems.or.processes.To.support. this.process.the.problem-solving.skill.was.identified.as.an.essential.ingredient.for.design- ing.complex.products.These.discussions.provided.a.general.perspective.on.the.impor- tance.of.these.concepts.in.the.engineering.profession.As.in.other.engineering.disciplines.

--- Chunk 29 ---
Tokens: 387
Type: sentence-based
Text:
this.process.the.problem-solving.skill.was.identified.as.an.essential.ingredient.for.design- ing.complex.products.These.discussions.provided.a.general.perspective.on.the.impor- tance.of.these.concepts.in.the.engineering.profession.As.in.other.engineering.disciplines. design.and.problem-solving.are.crucial.to.the.development.of.professional.large-scale. software.systems.Software.systems.are.highly.complex.difficult.to.create.costly.to.change. anddepending. on. the. software. productcritical. to. human. safety. Similarly. to. other. engineering.disciplines.designs.in.software.engineering.are.used.to.identify.evaluate.and. specify.the.structural.and.behavioral.characteristics.of.software.systems.that.adhere.to. some.specification.Software.designs.provide.blueprints.that.capture.how.software.systems. meet.their.required.functions.and.how.they.are.shaped.to.meet.their.intended.quality. Formally.software.engineering.design.is.defined.as (1).The.process.of.identifying.evaluating.validating.and.specifying.the.architectural.detailed. and.construction.models.required.to.build.software.that.meets.its.intended.functional.and.non- functional.requirements.and.(2).the.result.of.such.process. The.term.software.design.is.used.interchangeably.in.practice.as.a.means.to.describe.both. the.process.and.product.of.software.design.From.a.process.perspective.software.design.is. used.to.identify.the.phase.activities.tasks.and.interrelationship.between.them.required. to.model.softwares.structure.and.behavior.before.construction.begins.From.a.product.

--- Chunk 30 ---
Tokens: 393
Type: sentence-based
Text:
to.model.softwares.structure.and.behavior.before.construction.begins.From.a.product. development.perspective.software.design.is.used.to.identify.the.design.artifacts.that.result. from.the.identified.phase.activities.and.tasks.therefore.these.products.by.themselves.or. collectively.are.referred.to.as.software.design.Design.products.vary.according.to.several. factors.including.design.perspective.language.purpose.and.their.capabilities.for.evalu- ation.and.analysis.For.example.designs.can.be.in.architectural.form.using.architectural. notations.targeted.for.specific.stakeholders.These.types.of.design.can.be.presented.using. block.diagrams.Unified.Modeling.Language.(UML).diagrams.or.other.descriptive.form. of.black-box.design.documentation.In.other.cases.design.can.be.in.detailed.form.where. a.more.white-box.representation.of.the.system.is.used.to.model.structural.and.behavioral. aspects.These.can.include.software.models.that.contain.class.diagrams.object.diagrams. sequence.diagrams.or.activity.diagrams.Other.design.products.include.models.that.rep- resent.interfaces.data.or.user.interface.designs.Due.to.the.many.ways.software.design.is. used.in.practice.a.common.pitfall.in.software.engineering.projects.is.to.associate.design. with.a.particular.type.of.design.artifact.therefore.neglecting.other.forms.of.design.or.the. activities.required.to.create.complete.and.correct.software.designs.Collectively.both.pro- cess.and.products.including.all.variety.of.design.products.are.considered.software.design. and.are.essential.in.most.professional.software.projects.

--- Chunk 31 ---
Tokens: 393
Type: sentence-based
Text:
and.are.essential.in.most.professional.software.projects. 10  Software Engineering Design WHY STUDY SOFTWARE ENGINEERING DESIGN? On.February.25.1991.a.software.error.on.the.Patriot.missile.defense.system.operating. during.operation.Desert.Storm.caused.it.to.fail.to.track.and.intercept.an.incoming.Scud. which.resulted.in.the.death.of.28.Americans.(GAO.1992).In.1996.a.software.error.caused. the.Ariane.501.satellite.launch.to.fail.catastrophically.resulting.in.a.direct.cost.of.approx- imately.370.million.(Dowson.1997).The.software.error.that.caused.Ariane.501.to.fail. could.be.attributed.to.its.software.design.Similarly.the.literature.is.swamped.with.many. examples.of.disastrous.results.of.software-based.products.The.reason.for.many.of.these. disasters.is.that.developing.high-quality.software.on.time.and.within.budget.is.a.daunting. task.From.the.outset.the.landscape.for.software.development.projects.is.plagued.with.a. variety.of.challenges.that.increase.complexity.in.software.projects.Software.design.plays. an.integral.part.in.managing.the.complexity.and.the.challenges.encountered.in.any.soft- ware.development.effort. During.the.software.design.phase.the.system.is.decomposed.to.allow.optimum.develop- ment.of.the.software.requirements.are.mapped.to.conceptual.models.of.the.operational. software.roles.are.assigned.to.software.teams.on.the.same.or.remote.sites.well-known. interfaces. for. software. components. are. created. quality. attributes. are. addressed. and. incorporated.into.the.design.of.the.system.the.user.interface.is.created.the.softwares.

--- Chunk 32 ---
Tokens: 388
Type: sentence-based
Text:
incorporated.into.the.design.of.the.system.the.user.interface.is.created.the.softwares. capability.is.analyzed.function.and.variable.names.are.identified.design.documentation. goals.are.established.and.the.foundation.for.the.rest.of.the.software.engineering.life.cycle. is.established.Given.its.impact.on.the.creation.and.management.of.software.products. .mastering.software.design.becomes.essential.to.successfully.engineer.software.products. The.reasons.for.studying.software.engineering.design.can.be.described.using.a.product. development.perspective.and.a.project.management.perspective. Reasons for Studying Software Design in Product Development From. the. product. development. view. studying. software. design. is. important. because. designs.form.the.foundation.for.all.other.software.construction.activities.Software.designs. allow.software.engineers.to.create.models.that.represent.the.structure.and.behavior.of. the.software.system.Through.these.models.the.main.components.and.their.interconnec- tion.for.the.solution.are.identified.Characteristics.of.quality.code.such.as.modularization. cohesiveness.and.coupling.are.all.born.in.the.design.phase.For.complex.tasks.abstrac- tions. and. encapsulation. are. used. in. software. design. as. means. to. provide. a. systematic. approach.for.problem.solving.In.addition.software.designs.are.reusable.therefore.they. can.be.applied.to.different.projects.to.provide.ready-made.solutions.to.common.problems. Software.design.also.provides.the.means.to.evaluate.and.incorporate.the.quality.attributes.

--- Chunk 33 ---
Tokens: 392
Type: sentence-based
Text:
Software.design.also.provides.the.means.to.evaluate.and.incorporate.the.quality.attributes. necessary.for.software.systems.Therefore.issues.such.as.performance.usability.portabil- ity.and.security.can.all.be.addressed.early.on.in.the.development.project.These.benefits. are.carried.over.to.all.other.subsequent.phases.of.the.software.development.life.cycle.and. have.direct.impact.on.the.implementation.testing.and.maintenance.phase. Introduction to Software Engineering Design  11 Reasons for Studying Software Design in Project Management Managing.software.projects.characterized.by.changing.requirements.tight.schedules.cost. constraints.and.high.expectations.for.software.quality.is.tough.Among.these.require- ment.changes.are.common.drivers.for.all.other.project.characteristics.This.means.that. as.requirements.change.projects.should.expect.some.impact.in.their.cost.schedule.and. quality.In.some.cases.requirement.changes.can.easily.translate.to.extended.schedules. and.increased.cost.in.others.where.schedules.are.not.extended.requirement.changes. translate.to.decreased.software.quality.Good.software.design.can.minimize.(or.counter). the.effects.of.requirements.volatility.in.managing.software.projects.From.the.manage- ments.point.of.view.software.design.is.important.because.it.helps.accommodate.changes. to.the.requirements.or.system.updates.therefore.minimizing.impact.on.schedule.cost. and.quality.In addition.good.software.design.increases.efficiency.in.human.resource. allocation.tasks.By.decomposing.the.software.into.independent.units.resources.can.be.

--- Chunk 34 ---
Tokens: 392
Type: sentence-based
Text:
allocation.tasks.By.decomposing.the.software.into.independent.units.resources.can.be. assigned.to.software.components.so.that.they.can.be.built.in.parallel.in.the.same.or.dif- ferent.construction.sites.therefore.having.significant.impact.on.software.schedules.and. cost.By.compartmentalizing.the.design.the.effects.of.unwanted.employment.attrition. (i.e, employees.leaving.the.company).can.also.be.minimized.since.new.employees.need. only.to.take.on.the.individual.design.component.assigned.to.that.employee.Good.soft- ware.designs.provide.an.efficient.mapping.of.customer.requirements.to.software.solu- tions.therefore.facilitating.requirements.tracing.throughout.the.design.Having.a.strong. grasp. on. software. design. helps. management. abstract. project. tasks. and. acquire. better. appreciation.of.the.work.to.be.done.Overall.having.a.strong.grasp.in.software.design. helps.management.improve.the.project.planning.organization.staffing.and.tracking.and. provide.overall.guidance.for.the.project. SOFTWARE DESIGN CHALLENGES Today.the.software.design.phase.has.evolved.from.an.ad.hoc.and.sometimes.overlooked. phase.to.an.essential.phase.of.the.development.life.cycle.Furthermore.the.increasing.com- plexity.of.todays.systems.has.created.a.set.of.particular.challenges.that.makes.it.hard.for.soft- ware.engineers.to.meet.the.continuous.customer.demand.for.higher.software.quality.These. challenges.have.prompted.software.engineers.to.pay.closer.attention.to.the.design.process. to.better.understand.apply.and.promulgate.well.known.design.principles.processes.and.

--- Chunk 35 ---
Tokens: 392
Type: sentence-based
Text:
to.better.understand.apply.and.promulgate.well.known.design.principles.processes.and. professional.practices.to.overcome.these.challenges.Some.of.the.major.challenges.include. requirements.volatility.design.process.quality.issues. (e.g.performance.usability.secu- rity).distributed.software.development.efficient.allocation.of.human.resources.to.devel- opment.tasks.limited.budgets.unreasonable.expectations.and.schedules.fast-changing. technology.and.accurate.transformation.from.software.requirement.to.a.software.product. A.brief.discussion.of.these.challenges.is.presented.next. 12  Software Engineering Design Design Challenge 1: Requirements Volatility A.major.reason.for.the.complexity.of.software.projects.is.the.constant.change.of.require- ments.When.designed.properly.software.can.be.modified.or.extended.easily.however.when. designed.poorly.modifying.software.can.become.overwhelming.and.lead.to.all.sorts.of.com- plex.problems.Unlike.the.development.of.computer.hardware.bridges.houses.or.mechanical. parts.softwares.very.own.nature.allows.itself.to.change.to.provide.different.or.new.function- ality.to.systems.This.same.trait.that.makes.software.so.desirable.is.what.makes.it.also.so.com- plex.Although.much.effort.is.put.into.the.requirements.phase.to.ensure.that.requirements.are. complete.and.consistent.that.is.rarely.the.case.leaving.the.software.design.phase.as.the.most. influential.one.when.it.comes.to.minimizing.the.effects.of.new.or.changing.requirements. Requirements.volatility.is.challenging.because.they.impact.future.or.current.development.

--- Chunk 36 ---
Tokens: 398
Type: sentence-based
Text:
Requirements.volatility.is.challenging.because.they.impact.future.or.current.development. efforts.This.forces.designers.to.create.designs.that.provide.solutions.to.problems.at.a.given. state.while.also.anticipating.changes.and.accommodating.them.with.minimal.effort.This. requires.designers.to.have.a.strong.understanding.of.the.principles.of.software.design.and. develop.skills.to.manage.complexity.and.change.in.software.development. Design Challenge 2: Process Software. engineering. is. a. process-oriented. field. Software. processes. allow. engineers. to. organize.the.steps.required.to.develop.software.solutions.with.schedule.and.cost.constraints. Therefore. at. the. core. of. every. software. development. company. there. should. be. a. sound. well-understood.and.consistent.process.for.software.development.Processes.can.also.be.devel- oped.and.customized.for.particular.phases.of.the.software.engineering.life.cycle.In.the.design. phase.software.processes.involve.a.broad.set.of.activities.and.tasks.that.bridge.the.gap.between. requirements.and.construction.while.adhering.to.a.set.of.project-specific.(or.company-specific). constraints.These.activities.include.common.ones.such.as.architectural.and.detailed.design. as.well.as.other.supporting.activities.These.supporting.activities.include.establishing.a.design. review.process.defining.design.quality.evaluation.criteria.evaluating.design.reuse.estab- lishing.design.change.management.and.version.control.procedures.adopting.design.tools. and.allocating.resources.In.many.cases.a.companys.design.process.is.not.well.established.

--- Chunk 37 ---
Tokens: 379
Type: sentence-based
Text:
and.allocating.resources.In.many.cases.a.companys.design.process.is.not.well.established. is.poorly.understood.or.is.approached.with.minimalistic.expectations.that.ignore.aspects. that.are.essential.to.executing.a.successful.design.phase.Focusing.design.efforts.on.creating. .independent.software.products.such.as.a.simple.class.diagram.or.user.interface.while.ignoring. other.design.activities.may.create.complexities.later.on.during.systems.test.and.maintenance. The.design.process.is.challenging.because.essential.design.process.activities.are.often.over- looked.done.in.an.ad.hoc.manner.or.simply.not.done.at.all.In.many.cases.a.well-established. and.well.carried.out.design.process.serves.an.indication.of.future.projects.success. Design Challenge 3: Technology Software.is.meant.to.be.everywhere.From.health-care.systems.and.education.to.defense. and.everyday.ubiquitous.devices.software.is.required.to.operate.on.a.massive.and.always. Introduction to Software Engineering Design  13 evolving. technology. landscape. Besides. the. operating. environment. the. technology. for. designing. and. implementing. todays. software. systems. continues. to. evolve. to. provide. improved.capabilities.Examples.of.these.include.modeling.languages.and.tools.program- ming.languages.development.environments.design.patterns.and.design.strategies.As. new.technologies.emerge.software.engineers.are.required.to.assimilate.and.employ.them. all.at.the.same.time.In.some.cases.emerging.technologies.do.not.completely.replace.old.

--- Chunk 38 ---
Tokens: 400
Type: sentence-based
Text:
all.at.the.same.time.In.some.cases.emerging.technologies.do.not.completely.replace.old. ones.Some.software.systems.are.required.to.interoperate.with.old.legacy.systems.designed. with.older.design.methodologies.This.results.in.software.designers.employing.different. design.methodologies.and.technologies.all.on.the.same.software.system.In.other.cases. design.models.need.to.be.derived.from.existing.code.modified.and.made.interopera- ble.with.newer.technologies.This.technology-driven.aspect.of.the.design.phase.creates.a. demand.for.capable.software.designers.that.can.assimilate.new.technology.quickly.and. effectively.to.succeed.at.designing.software.The.technology.aspect.of.software.design.is. challenging.because.it.is.fast.and.ever-changing.therefore.designers.must.keep.abreast.of. the.latest.advances.and.become.proficient.in.the.application.of.these.advancements.while. maintaining.rooted.in.legacy.technology. Design Challenge 4: Ethical and Professional Practices Designers.create.blueprints.that.drive.the.construction.of.the.software.During.this.cre- ation.process.designers.are.required.to.determine.how.design.decisions.affect.the.environ- ment.and.the.people.that.use.the.software.In.many.cases.the.software.development.process. is.traditionally.carried.out.under.tight.schedule.constraints.Inherently.all.phases.of.the. development.life.cycle.suffer.from.this.including.the.design.phase.This.creates.external. pressures.that.can.lead.designers.to.deviate.from.the.normal.design.approach.to.meet.these. demands.which.can.have.catastrophic.consequences.No.matter.how.tight.deadlines.are.

--- Chunk 39 ---
Tokens: 380
Type: sentence-based
Text:
demands.which.can.have.catastrophic.consequences.No.matter.how.tight.deadlines.are. how.much.animosity.exists.within.the.design.team.or.how.much.other.externalpersonal. factors.are.brought.into.the.design.phase.software.designers.must.exhibit.strong.ethical. and.professional.practices.to.ensure.that.the.systems.they.build.are.of.highest.quality.and. that.all.design.considerations.are.properly.evaluated.In.many.cases.this.requires.design- ers.to.exert.strong.leadership.skills.to.influence.and.negotiate.with.stakeholders.motivate. the.design.team.and.lead.the.design.process.to.accomplish.the.projects.goals.Designers. are.also.responsible.for.enforcing.ethical.guidelines.during.the.design.process.evaluating. the.social.impacts.of.their.designs.in.the.public.domain.or.in.safety-critical.systems.and. to.follow.the.appropriate.professional.practices.to.ensure.success.in.the.overall.system.The. .ethical.and.professional.practices.aspect.of.software.design.are.challenging.because.design- ers.are.constantly.faced.with.numerous.pressures.from.stakeholders.that.influence.designers. .decisions.most.of.which.have.consequences.of.social.ethical.or.professional.nature. Design Challenge 5: Managing Design Influences Designs.are.shaped.by.many.different.influences.from.stakeholders.the.development.orga- nization.and.other.factors.These.influences.can.have.cyclical.effects.between.the.system. 14  Software Engineering Design and.its.external.influences.such.that.external.factors.affect.the.development.of.the.system.

--- Chunk 40 ---
Tokens: 388
Type: sentence-based
Text:
14  Software Engineering Design and.its.external.influences.such.that.external.factors.affect.the.development.of.the.system. and.the.system.affects.its.external.factors.(Bass.Clements.and.Kazman.2003).Managing. these.influences.is.essential.for.maximizing.the.quality.of.systems.and.their.related.influ- ence.on.future.business.opportunities.Of.specific.importance.are.design.influences.that. come.from.the.system.stakeholders.and.its.developing.organization. Stakeholders Designing. software. is. a. nondeterministic. activity. If. given. the. same. task. to. different. designers.different.solutions.will.be.proposed.each.of.them.being.perfectly.acceptable. (McConnell.2004).Now.add.to.the.mix.the.multitude.of.influences.that.come.from.dif- ferent.stakeholders.and.you.can.easily.get.a.variety.of.design.alternatives.for.meeting.a. variety.of.stakeholders.concerns.all.conflicting.with.each.other.This.creates.a.challenge. when.trading.off.design.alternatives.that.meet.all.stakeholders.concerns.Making.such. design.trade-offs.is.difficult.especially.on.large-scale.design.efforts.Consider.a.project. with.multiple.customers.each.with.conflicting.goals.affecting.design.decisions.In.such. projects.creating.a.design.that.sacrifices.some.desired.customer.capability.but.provides. other.desired.properties.such.as.quick.time-to-market.reliability.or.lower.cost.can.lead. to.the.development.of.a.high-quality.system.that.maintains.acceptable.levels.of.satisfaction. among.stakeholders.This.is.an.example.of.how.stakeholders.affect.design.decision.and.the.

--- Chunk 41 ---
Tokens: 380
Type: sentence-based
Text:
among.stakeholders.This.is.an.example.of.how.stakeholders.affect.design.decision.and.the. design.in.turn.influences.the.stakeholder.goals.(Bass.et.al.2003).Managing.stakeholders. influences.is.challenging.because.it.requires.designers.to.exert.a.high-level.of.communica- tion.negotiation.and.technical.skills.to.ensure.that.design.decisions.are.made.to.accom- modate.all.concerns.without.negatively.affecting.the.project. Development Organizations Structure The.development.organizations.structure.influences.the.development.of.software.prod- ucts.in.particular.the.design.of.those.products.As.example.consider.the.case.of.distrib- uted.software.engineering.In.todays.global.market.more.and.more.cases.of.distributed. software.development.are.taking.place.A.wide.variety.of.reasons.exist.for.developing.soft- ware.at.different.sites.Consider.companies.that.have.sites.in.multiple.states.where.various. levels.of.domain.expertise.are.found.at.different.sites.Or.consider.the.case.of.software. engineers.resigning.creating.a.gap.in.the.development.team.that.is.hard.to.fill.with.local. resources.Finally.consider.companies.that.simply.want.to.reduce.cost.by.hiring.software. engineers.from.different.countries.These.and.many.other.reasons.exist.for.having.devel- opment.across.site.boundaries.In.each.of.these.cases.the.structure.of.the.developments. organization.makes.it.complicated.to.for.example.coordinate.design.efforts.evaluate.and. discuss.design.alternatives.conduct.peer.reviews.and.manage.version.control.In.these.

--- Chunk 42 ---
Tokens: 396
Type: sentence-based
Text:
discuss.design.alternatives.conduct.peer.reviews.and.manage.version.control.In.these. cases.designers.need.to.consider.not.only.technical.aspects.of.the.design.but.also.the.dis- tribution.of.employees.organizational.goals.resource.availability.and.so.forth.Designs. that.support.integration.of.distributed.expertise.across.sites.can.introduce.capabilities.for. building.new.software.products.that.could.not.be.engineered.otherwise.This.in.turn.can. Introduction to Software Engineering Design  15 influence.the.developing.organization.to.target.new.areas.of.businesses.therefore.allowing. the.software.design.to.influence.its.business.goals.Managing.the.influences.of.the.develop- ment.organization.is.challenging.because.it.requires.designers.to.span.out.of.the.technical. domain.to.have.a.keen.interest.on.the.organization.as.a.whole. CONTEXT OF SOFTWARE DESIGN In.todays.modern.software.systems.software.design.plays.a.key.role.in.the.development.of. software.products.however.it.is.only.one.phase.of.the.complete.software.engineering.life. cycle.To.understand.how.design.fits.within.the.whole.software.engineering.process.it.is. necessary.to.provide.the.appropriate.context.so.that.clear.distinctions.can.be.made.between. the.different.life.cycle.phases.and.an.appreciation.of.the.importance.of.software.design. activities.and.tasks.can.be.acquired.For.this.reason.an.overview.of.software.engineering. and.its.life.cycle.is.required.Software.engineering.is.defined.by.the.IEEE. (1990.p.67).as (1).The.application.of.a.systematic.disciplined.quantifiable.approach.to.the.development.

--- Chunk 43 ---
Tokens: 376
Type: sentence-based
Text:
(1990.p.67).as (1).The.application.of.a.systematic.disciplined.quantifiable.approach.to.the.development. operation.and.maintenance.of.software.that.is.the.application.of.engineering.to.software. (2).The.study.of.approaches.as.in.(1). The.fundamental.software.engineering.life.cycle.phases.include.requirements.design. construction.test.and.maintenance.as.presented.in.Table 1.5. The.requirements.phase.is.where.stakeholders.are.identified.and.customer.needs.wants. and.the.(often.overlooked).nonfunctional.requirements.are.determined.(Laplante.2009). During.this.phase.requirements.are.analyzed.in.their.raw.form.to.address.issues.such.as. requirements.that.dont.make.sense.contradict.each.other.or.are.incomplete.vague.or. just.wrong. (Laplante.2009).requirements.are.classified.and.prioritized.and.the.specifica- tion.of.the.software.system.which.typically.results.in.the.production.of.a.document.or. its.electronic.equivalent.is.reviewed.and.validated.(Abran.Moore.Bourque.and.Dupuis. TABLE 1.5 Fundamental.Software.Engineering.Phases Phase Description Requirements Initial.stage.in.the.software.development.life.cycle.where.requirements.are.elicited.analyzed. specified.and.validated Design The.requirements.specification.is.used.to.create.the.software.design.which.includes.its. architecture.and.detailed.design Construction Relies.on.the.requirements.specification.the.software.architecture.and.detailed.design.to. implement.the.solution.using.a.programming.language.a.great.deal.of.design.can.also.

--- Chunk 44 ---
Tokens: 390
Type: sentence-based
Text:
implement.the.solution.using.a.programming.language.a.great.deal.of.design.can.also. occur.at.this.phase Test Ensures.that.the.software.behaves.correctly.and.that.it.meets.the.specified.requirements Maintenance Modifies.software.after.delivery.to.correct.faults.improve.performance.or.adapt.it.for.a. different.environment 16  Software Engineering Design 2005).Once.the. requirements. for. the. system. are.specified. designing. the. system. takes. place.which.is.the.main.topic.of.this.book. The.construction.phase.begins.once.the.design.phase.has.been.executed.and.all.require- ments.can.be.traced.to.a.section.of.the.software.design.models.The.construction.phase.is. where.designs.are.implemented.using.the.programming.language.of.choice.In.this.phase. code.is.generated.according.to.a.style.guide.In.addition.the.code.is.unit.tested.debugged. and.peer-reviewed.programming.errors.are.detected.tracked.and.resolved.code.is.man- aged.by.using.change.management.and.version.control.software.and.finally.code.is.pre- pared.for.delivery.using.a.predefined.set.of.conventions.for.formatting.The.construction. phase.is.tightly.related.to.the.design.phase.and.in.some.cases.(typically.on.smaller.projects). the.line.dividing.both.phases.can.be.hard.to.identify.There.are.several.reasons.for.this. the.main.one.being.that.detailed.designs.can.be.directly.translated.to.code.therefore.soft- ware.engineers.tend.to.design.and.code.at.the.same.time.In.other.cases.where.design.and. construction.are.clearly.delineated.by.the.process.it.is.common.for.some.construction.

--- Chunk 45 ---
Tokens: 391
Type: sentence-based
Text:
construction.are.clearly.delineated.by.the.process.it.is.common.for.some.construction. tasks.such.as.identifying.appropriate.class.function.and.variable.names.to.be.performed. during.detailed.design.Finally.because.many.discoveries.made.well.into.the.construction. phase.give.rise.to.functionality.that.requires.design.work.engineers.must.iterate.back.and. forth.between.construction.and.design.activities.Once.all.the.design.artifacts.are.imple- mented.with.programming.and.all.assigned.requirements.can.be.validated.through.execu- tion.of.code.during.unit.testing.the.construction.phase.is.complete. The.testing.phase.is.typically.the.final.step.before.the.software.goes.out.the.door.The main. purpose.of.the.testing.phase.is.to.verify.and.validate.the.software.to.ensure.that.it.meets. the.predefined.functions.and.level.of.quality.defined.in.the.software.requirements.phase. Formally.the.IEEE. (1990.p.76).defines.testing.as (1).The.process.of.operating.a.system.or.component.under.specified.conditions.observing.or. recording.the.results.and.making.an.evaluation.of.some.aspect.of.the.system.or.component. (2).The.process.of.analyzing.a.software.item.to.detect.the.differences.between.existing.and. required.conditions.(that.is.bugs).and.to.evaluate.the.features.of.the.software.item. The.software.testing.phase.serves.as.a.gateway.between.product.development.and.product. release.Therefore.verification.and.validation.efforts.need.to.be.made.to.ensure.that.the.soft- ware.meets.the.specification.and.the.integrity.of.the.software.can.be.assured.under.normal.

--- Chunk 46 ---
Tokens: 385
Type: sentence-based
Text:
release.Therefore.verification.and.validation.efforts.need.to.be.made.to.ensure.that.the.soft- ware.meets.the.specification.and.the.integrity.of.the.software.can.be.assured.under.normal. and.harsh.conditions.It.is.important.to.note.that.no.desired.quality.attribute.can.be.verified. during.testing.if.it.hasnt.been.designed.into.the.product.first.Therefore.even.though.test- ing.is.typically.credited.for.ensuring.product.quality.design.is.fundamental.in.supporting.a. successful.testing.phase.Once.software.is.delivered.the.maintenance.phase.begins.to.imple- ment.corrections.adaptations.or.improvements.to.the.software.Corrections.are.typically. made.on.a.smaller.scale.to.rectify.faulty.behavior.or.output.of.the.software.These.typically. do.not.require.design.work.However.for.adaptations.or.improvements.design.work.may. be.required.to.accommodate.the.changes.Together.all.phases.of.the.software.engineering. life.cycle.work.together.to.define.the.functions.that.the.software.must.provide.to.transform. these.functions.into.technical.solutions.to.implement.those.solutions.and.to.validate.their. implementation.and.ensure.the.quality.of.the.system.throughout.future.versions. www.allitebooks.com Introduction to Software Engineering Design  17 SOFTWARE DESIGN PROCESS In.the.previous.section.the.design.phase.was.briefly.mentioned.as.a.means.for.determin- ing.its.place.within.the.software.engineering.process.However.as.it.will.be.seen.the.design. phase.incorporates.many.activities.and.tasks.conducted.by.different.teams.and.typically.

--- Chunk 47 ---
Tokens: 385
Type: sentence-based
Text:
phase.incorporates.many.activities.and.tasks.conducted.by.different.teams.and.typically. managed.by.personnel.other.than.designers.This.requires.a.formal.process.to.ensure.that.the. design.phase.is.conducted.properly.and.that.it.addresses.all.the.concerns.identified.for.the. software.system.being.built.Many.processes.exist.to.carry.out.phases.activities.and.tasks. throughout.the.software.engineering.life.cycle.including.the.unified.process.(UP).Scrum. and.the.dynamic.systems.development.method.(DSDM).(Pressman.2010).What.follows.is. a.discussion.on.the.software.design.process.in.terms.of.the.fundamental.activities.and.tasks. required.to.build.software.products.These.activities.and.tasks.are.essential.and.typically.built. into.other.formal.processes.such.as.the.ones.already.mentioned.The.hope.is.that.by.plac- ing.more.emphasis.on.the.fundamental.activities.and.tasks.and.less.on.particular.process. approaches.readers.can.obtain.a.more.concise.and.understandable.coverage.of.the.topic. In. todays. professional. software. engineering. landscape. software. engineers. are. being. asked.to.build.larger.and.more.complex.software.systems.in.the.same.or.different.sites. Therefore.both.design.processes.and.artifacts.are.increasing.in.complexity.This.means.that. it.is.not.enough.to.know.how.to.model.structural.and.behavioral.aspects.of.the.system.in. the.design.phase.but.it.is.also.essential.that.software.designers.know.about.the.particular. process. (e.g, UP.Scrum).required.to.manage.create.and.control.software.design.activities.

--- Chunk 48 ---
Tokens: 382
Type: sentence-based
Text:
(e.g, UP.Scrum).required.to.manage.create.and.control.software.design.activities. Sommerville.(2010).defines.a.software.process.as.a.set.of.activities.that.lead.to.the.production. of.a.software.product.Similarly.a.software.design.process.is.a.set.of.activities.and.controls. that.specify.how.resources.work.together.for.the.production.of.software.design.artifacts. The.software.engineering.body.of.knowledge.identifies.two.major.activities.for.software. design.software.architecture.and.detailed.design.(Abran.et.al.2005).These.are.the.essential. activities.for.managing.the.complexity.involved.in.developing.large-scale.software.systems. However.numerous.other.important.activities.are.required.for.supporting.the.creation.of. architectural.and.detailed.designs.Therefore.when.planning.and.identifying.an.appropri- ate.software.design.process.the.effort.required.for.these.activities.needs.to.be.considered. In.addition.because.of.the.emphasis.that.some.forms.of.design.place.on.construction.the. detailed.design.activity.process.can.be.modified.to.explicitly.present.the.construction.design. activity.that.addresses.design.issues.encountered.during.the.construction.phase.With.this. in.mind.a.holistic.approach.to.software.design.which.includes.architecture.detailed.and. construction.design.management.and.documentation.is.presented.in.Figure 1.3. As.seen.in.the.figure.software.architecture.is.the.first.activity.conducted.in.the.design. process.Architectural.designs.are.elaborated.through.detailed.designs.which.are.further.

--- Chunk 49 ---
Tokens: 374
Type: sentence-based
Text:
process.Architectural.designs.are.elaborated.through.detailed.designs.which.are.further. elaborated.through.construction.designs.All.of.these.design.activities.need.to.be.docu- mented.and.the.process.for.design.and.documentation.needs.to.be.managed.Figure 1.3. also.presents.a.necessary.differentiation.between.the.software.design.phase.and.the.distri- bution.of.its.activities.throughout.the.software.engineering.life.cycle.In.some.cases.the. architectural.design.activities.can.begin.during.the.analysis.activity.of.the.requirements. 18  Software Engineering Design phase.and.span.through.the.design.phase.in.others.it.begins.after.the.requirements.are. specified.and.validated.In.a.similar.fashion.the.detailed.design.activity.can.start.at.the. projects.design.phase.and.span.through.the.software.construction.phase.These.scenarios. are.highly.project.dependent.therefore.following.to.a.strict.waterfall-like.process.for.soft- ware.development.is.impractical.for.all.but.the.simplest.software.applications. Software Architecture The. software. architecture. activity. corresponds. to. a. macrodesign. approach. for. creating. .models.that.depict.the.quality.and.function.of.the.software.system.It.provides.black-box. models.used.to.evaluate.the.systems.projected.capabilities.as.well.as.its.expected.quality. all.from.multiple.perspectives.Therefore.architectural.designs.allow.different.stakeholders. with.different.backgrounds.and.expertise.to.evaluate.the.design.and.ensure.that.the.software.

--- Chunk 50 ---
Tokens: 400
Type: sentence-based
Text:
with.different.backgrounds.and.expertise.to.evaluate.the.design.and.ensure.that.the.software. Software Design Management Documentation Detailed Design: Interface Design Component Design Construction Design: Flow-Based Design Table-Based Design Software Requirements Software Construction Software Architecture: Architectural Views Architectural Patterns   H C I D E S I G N  Software Design Process Design Activities in Software Engineering Process Software Requirements Architectural Design Architectural  Detailed Design Detailed  Construction Design Software Design Software Construction FIGURE 1.3 The.software.design.process.and.design.activities.during.the.SWE.process. Introduction to Software Engineering Design  19 architecture.is.addressing.their.concerns.For.example.from.the.systems.engineering.per- spective.architectural.designs.can.provide.information.about.the.physical.deployment.of. the.system.including.subsystems.located.at.different.locations.the.artifacts.executing.in. the.subsystems.and.how.the.system.as.a.whole.communicates.From.the.configuration. management.perspective.architectural.designs.can.provide.information.about.the.hier- archy.of.files.in.the.file.system.and.how.these.files.are.interconnected.to.build.and.deploy. the.software.system.From.the.software.engineering.perspective.different.architectural. designs.can.help.decompose.the.software.and.define.the.major.structural.components.of. the.system.identify.interfaces.between.the.components.map.the.requirements.to.them. evaluate.concurrency.issues.and.provide.overall.insight.into.the.design.solution.A.major.

--- Chunk 51 ---
Tokens: 397
Type: sentence-based
Text:
evaluate.concurrency.issues.and.provide.overall.insight.into.the.design.solution.A.major. benefit.of.architectural.designs.is.their.capacity.to.evaluate.high-level.concerns.from.stake- holders.that.deal.mostly.with.nonfunctional.requirements.(e.g.performance.usability. security).For.these.purposes.architectural.designs.serve.as.important.communication. reasoning.and.analysis.tools.that.support.the.development.and.growth.of.the.systems. (Bass.et.al.2003).Software.architecture.lays.the.foundation.for.all.subsequent.work.in.the. software.engineering.life.cycle. Detailed Design The.detailed.design.step.begins.after.the.software.architecture.is.specified.reviewed.and. deemed. sufficiently. complete. for. detailed. design. to. begin. The. detailed. design. activity. builds.on.the.software.architecture.to.provide.white-box.design.elements.of.the.structure. and. behavior. of. the. software. system.and. in.many. cases.is. the. last.major. effort. before. .software.construction.begins.Detailed.design.is.the.activity.that.deals.with.refining.the. software.architecture.to.reach.a.point.where.the.software.design.including.architecture. and.detailed.design.is.deemed.sufficiently.complete.for.construction.to.begin.Whereas.the. software.architecture.places.a.major.emphasis.on.quality.(nonfunctional.requirements). the.detailed.design.activity.places.a.major.focus.on.addressing.functional.requirements.of. the.system.In.object-oriented.systems.the.detailed.design.activity.is.where.components. are.refined.into.one.or.more.classes.interfaces.are.realized.relationships.between.classes.

--- Chunk 52 ---
Tokens: 363
Type: sentence-based
Text:
are.refined.into.one.or.more.classes.interfaces.are.realized.relationships.between.classes. are.specified.class.functions.and.variable.names.are.created.design.patterns.are.identified. and.applied.and.if.applicable.design.tools.are.configured.for.code.generation.Two.major. tasks.of.the.detailed.design.activity.are.interface design.and.component design. Interface Design Interface. design. refers. to. the. design. activity. that. deals. with. specification. of. interfaces. between.components.in.the.design.(Sommerville.2010).Interface.design.can.be.focused. on. specifying. the. interfaces. used. internally. within. software. components. or. externally. across.software.components.In.both.cases.interfaces.provide.a.standardized.way.for.spec- ifying.how.services.are.accessed.and.provided.by.software.components.Interface.design. allows.subsystems.to.be.designed.independently.and.in.parallel.therefore.it.is.typically. one.of.the.first.tasks.performed.as.part.of.the.detailed.design.Other.forms.of.interface. 20  Software Engineering Design design.specify.communication.between.systems.for.example.custom.binary.or.Extensible. Markup.Language.(XML).messaging.specifications.used.for.communication.between.two. or.more.subsystems.through.the.network. Component Design During. architecture. the. software. system. is. decomposed. into. logical. components. that. abstract.required.system.functions.During.detailed.design.these.logical.components.are.

--- Chunk 53 ---
Tokens: 400
Type: sentence-based
Text:
abstract.required.system.functions.During.detailed.design.these.logical.components.are. refined.and.their.interactions.are.modeled.to.verify.the.validity.of.their.structural.compo- sition.The.execution.of.the.detailed.design.activity.requires.a.shift.from.the.macrodesign. approach.to.the.microdesign.approach.to.further.decompose.and.refine.system.components. into.one.or.more.fine-grained.elements.functions.and.data.variables.required.for.support- ing.the.internal.structure.and.behavior.of.components.that.meet.assigned.roles.during.the. software.architecture.activity.Component.design.refers.to.modeling.the.internal structure and behavior.of.componentswhich.includes.the.internal.structure.of.both.logical.and. physical. componentsidentified. during. the. software. architecture. phase. During. this. activity.fine-grained.components.are.derived.from.the.architecture.and.their.internal. structure. and. behavior. are. designed. Components. are. not. limited. to. object-oriented. .systems.therefore.component.designs.can.be.realized.in.many.ways.In object-oriented. systems.the.internal.structure.of.components.is.typically.modeled.using.UML.through. one.or.more.diagrams.including.class.and.sequence.diagrams.When.modeling.the.inter- nal.structure.of.components.several.design.principles.heuristics.and.patterns.are.used.to. create.and.evaluate.component.designs. Construction Design The.idea.of.the.detailed.design.activity.is.to.get.as.close.to.the.solution.as.possible.without. beginning.the.construction.phase.In.many.cases.in.object-oriented.systems.this.amounts. to. identifying. classes.

--- Chunk 54 ---
Tokens: 396
Type: sentence-based
Text:
classes. their. attributes. and. functions. and. interrelationships. with. other. classes.These.tasks.are.done.while.abstracting.and.deferring.details.of.implementation.to. the.construction.phase.In.some.cases.however.implementing.complex.software.functions. identified.during.the.detailed.design.activity.requires.additional.design.work.to.ensure.they. work.properly.and.maintain.the.quality.standards.sought.during.the.software.architecture. activities.In.these.cases.construction.design.is.necessary.Construction.design.is.not.a.new. concept.Many.other.authors.have.proposed.it.as.an.important.design.activity.For.example. McConnell.(2004).specifies.five.levels.of.software.design.one.of.them.being.at.the.lowest. level.deals.with.internal.routine.design.Similarly.Fox.(2006).identifies.a.form.of.low-level. design.that.fills.the.gap.between.detailed.design.and.programming.and.deals.with.issues. such.as.operation.specification.including.operation.name.parameter.types.and.return. types.among.others.Other.authors.such.as.Meyers. (2005).have.highlighted.the.impor- tance.of.designing.code.at.low.levels.during.construction.Construction.design.is.the.last. design.activitytypically.conducted.during.the.construction.phaserequired.to.support. the.systems.quality.attributes.such.as.performance.maintainability.and.testability. Introduction to Software Engineering Design  21 HumanComputer Interface Design The.humancomputer.Interface.(HCI).design.activity.is.where.general.principles.are.applied. to.optimize.the.interface.between.humans.and.computers.Visual.designs.have.a.major.role.

--- Chunk 55 ---
Tokens: 398
Type: sentence-based
Text:
to.optimize.the.interface.between.humans.and.computers.Visual.designs.have.a.major.role. on.the.success.or.failure.of.software.systems.Systems.that.meet.functional.requirements. but.that.are.not.usable.cannot.succeed.The.HCI.design.activity.can.be.executed.in.paral- lel.to.the.software.architecture.or.detailed.design.activities.In.some.cases.HCI.design.is. considered.an.architectural.task.while.in.others.it.is.considered.a.detailed.design.task. Regardless.of.where.HCI.design.fits.within.design.processes.adopted.by.specific.organiza- tions.it.is.a.major.design.activitiy.that.requires.careful.attention.The.major.concerns.of. the.HCI.designs.may.include.the.evaluation.and.use.of.modes.navigation.visual.designs. response.time.and.feedback.and.design.modalities.such.as.forms.and.menu-driven.HCI. designs.directly.influence.the.quality.of.any.system.and.are.essential.to.understanding.and. addressing.the.factors.that.affect.the.overall.usability.of.the.system.Many.design.principles. and.evaluation.techniques.exist.to.succesfully.design.user.interfaces. Software Design Documentation Similar.to.the.specification.activity.of.the.requirements.phase.software.design.documen- tation.also.known.as.software.design.description.(SDD).plays.a.big.role.in.professional. large-scale.or.software-intensive.systems.Its.importance.is.specified.by.the.IEEE.(1998. p. iii).as.follows: SDDs.play.a.pivotal.role.in.the.development.and.maintenance.of.software.systems.During. its.lifetime.a.given.design.description.is.used.by.project.managers.quality.assurance.staff. .configuration. managers. software.

--- Chunk 56 ---
Tokens: 395
Type: sentence-based
Text:
software. designers. programmers. testers. and. maintainers. Each. of.these.users.has.unique.needs.both.in.terms.of.required.design.information.and.optimal. organization.of.that.information.Hence.a.design.description.must.contain.all.the.design. .information.needed.by.those.users. SDD. should. include. the. necessary. information. that. properly. captures. the. design. of. the.system.As.part.of.this.activity.other.issues.such.as.tools.for.generating.design.docu- ments.validation.and.configuration.management.must.be.addressed.The.software.design. .documentation.activity.typically.begins.at.the.design.phase.and.continues.throughout.the. .lifetime.of.the.software.system. Software Design Management Management.plays.a.big.role.in.software.engineering.projects.Griffin.(2010.p.5).defines. .management.as A.set.of.activities. (including.planning.and.decision.making.organizing.leading.and.con- trolling).directed.at.an.organizations.resources. (human.financial.physical.and.informa- tion).with.the.aim.of.achieving.organizational.goals.in.an.efficient.and.effective.manner. 22  Software Engineering Design In.the.design.phase.management.refers.to.the.set.of.activities.required.to.efficiently.create. and.implement.quality.design.artifacts.within.schedule.and.budget.constraints.This.definition. encompasses.a.broad.set.of.activities.that.are.particular.to.specific.organizations.However.at. the.core.of.every.organizations.management.activities.quality.is.a.focal.point.The.quality.of. software.designs.can.be.assessed.in.various.ways.From.the.managements.perspective.quality.

--- Chunk 57 ---
Tokens: 391
Type: sentence-based
Text:
software.designs.can.be.assessed.in.various.ways.From.the.managements.perspective.quality. of.software.designs.can.be.evaluated.in.terms.of.cost.and.scheduling.From.the.engineering. point.of.view.quality.in.designs.can.be.evaluated.using.a.set.of.well-known.design.principles. as.well.as.modeling.and.evaluating.the.quality.attributes.that.the.software.must.exhibit.which. are.specified.via.nonfunctional.quality.requirements.From.the.configuration.managements. perspective.design.quality.can.be.achieved.through.change.management.processes.that.con- trol.how.designs.are.created.modified.and.improved.In large-scale.software.projects.soft- ware.design.management.is.essential.to.plan.organize.staff.track.and.lead.the.activities. required.to.carry.out.successfully.the.software.architecture.and.detailed.design.steps. ROLES OF THE SOFTWARE DESIGNER From.the.discussions.provided.so.far.it.should.be.evident.that.designers.are.not.all.equal. In.many.design.efforts.designers.have.different.roles.with.different.titles.and.responsibili- ties.that.focus.on.specific.design.problems.of.the.software.system.There.are.many.factors. in.place.that.determine.the.designers.role.including.an.engineers.work.preference.expe- rience.and.capabilities.When.studying.software.design.it.is.important.to.understand. how.these.roles.differ.the.type.of.work.performed.and.capabilities.required.to.perform. the.activities.required.of.each.role.In.some.cases.software.designers.are.heavily.involved. in.the.requirements. and. construction. phases.therefore.they.must.have.expertise.not.

--- Chunk 58 ---
Tokens: 356
Type: sentence-based
Text:
phases.therefore.they.must.have.expertise.not. only.in.design.but.also.in.requirements.engineering.and.software.construction.In.other. cases.a.clear.organizational.delineation.exists.allowing.designers.to.focus.on.their.area. of.expertise.A list.of.typical.designer.roles.is.presented.in.Table 1.6.(Giachetti.2010). TABLE 1.6 Typical.Roles.in.Software.Design Designer Description Enterprise.architect Designs.the.enterprises.strategy.processes.information.and.organizational. structure Software.architect Designs.software.systems.using.a.black-box.modeling.approach.concern.is.placed. on.the.external.properties.of.software.components.that.determine.the.systems. quality.and.support.the.further.design.of.functional.requirements Component.designer Focuses.on.designing.the.internal.structure.of.software.components.identified. during.the.software.architecture.phase.has.strong.programming.skills User.Interface.designer Designs.the.softwares.user.interface.skilled.in.determining.ways.that.increase. usability.of.the.system System.engineer Designs.systems.using.a.holistic.approach.which.include.designing.how.software. and.hardware.collaborate.to.achieve.the.systems.goals Introduction to Software Engineering Design  23 Systems Engineer The. systems. engineer. designs. the. overall. development. process. of. systems. as. a. whole. including.processes.for.development.of.both.the.software.and.hardware.that.are.part.of.the.

--- Chunk 59 ---
Tokens: 372
Type: sentence-based
Text:
including.processes.for.development.of.both.the.software.and.hardware.that.are.part.of.the. system.As.a.specialization.of.system.engineering.software.systems.engineers.design.soft- ware.at.the.system.level.in.many.cases.the.work.performed.by.software.systems.engineers. is.similar.to.that.of.a.software.architect.Systems.engineers.work.closely.with.customers.to. provide.a.holistic.view.of.systems.their.interfaces.and.the.distribution.of.requirements. to.subsystems.Software.systems.engineers.are.typically.experts.in.the.problem.domain. and.depending.on.the.type.of.system.(e.g.embedded.web).they.also.develop.expertise. on.other.nonsoftware-related.parts.such.as.hardware.communications.and.avionics.This. is.essential.at.all.phases.of.the.software.development.process.since.they.must.be.able.to. communicate.with.other.engineering.disciplines.such.as.electrical.mechanical.and.civil. In.this.role.designers.have.typically.accumulated.experience.in.other.design.roles.such.as. software.architecture.component.design.and.in.some.cases.construction.In.addition.to. technical.skills.systems.engineers.are.required.to.have.strong.leadership.skills.to.ensure. the.successful.system.development. Software Architect The.software.architect.is.in.charge.of.designing.the.software.architecture.Software.architects. can.be.found.under.a.wide.variety.of.titles.such.as.software.lead.senior.software.engineer. or.principal.software.engineer.Regardless.of.the.title.software.architects.have.extensive.

--- Chunk 60 ---
Tokens: 387
Type: sentence-based
Text:
or.principal.software.engineer.Regardless.of.the.title.software.architects.have.extensive. experience.architecting.systems.that.meet.their.intended.requirements.Experience.is.typi- cally.acquired.while.moving.up.through.the.ranks.from.software.programmer.all.the.way. up.to.software.architect.Software.architects.have.strong.leadership.skills.and.are.required. to.be.skilled.in.initiation.communication.and.negotiation.They.also.need.to.have.a.keen. understanding.of.the.developing.organization.to.determine.ways.software.systems.can. influence.the.organizational.business.goals.and.increase.new.business.ventures.leveraged. from.existing.architectures.Other.skills.beneficial.to.software.architects.include.project. management.skills. Component Designer Component. designers. are. highly. noticeable. during. detailed. and. construction. designs. since.they.are.typically.the.ones.constructing.the.software.Therefore.they.have.strong. programming.skills.and.a.strong.foundation.in.design.principles.For.object-oriented.com- ponent.designers.strong.object-oriented.skills.including.knowledge.of.design.patterns.are. essential.Component.designers.create.both.static.and.dynamic.models.of.the.software. system.at.levels.appropriate.to.drive.construction.these.include.(when.applicable).UML. class.diagrams.and.sequence.diagrams.They.have.deep.knowledge.and.understanding.of. the.software.requirements.assigned.to.them.they.are.knowledgeable.about.other.tools.that. support.the.design.and.development.effort.such.as.modeling.tools.integrated.development.

--- Chunk 61 ---
Tokens: 379
Type: sentence-based
Text:
support.the.design.and.development.effort.such.as.modeling.tools.integrated.development. 24  Software Engineering Design environments.forward.and.reverse.engineering.and.configuration.management.When. designing.at.the.component.level.component.designers.have.a.full.understanding.of.style. guides.for.the.project.since.they.dictate.naming.spacing.and.commenting.conventions. and.other.aspects.that.shape.the.structure.of.code.Component.designers.devise.construc- tion.designs.as.needed.and.are.proficient.at.creating.effective.unit.tests.that.verify.the. quality. of. their. product. developed. Finally. component. designers. need. to. be. comfort- able.scheduling.and.conducting.peer.reviews.and.accepting.feedback.and.evaluating.it. .objectively.to.improve.their.designs. SOFTWARE DESIGN FUNDAMENTALS Within.the.design.process.many.principles.considerations.and.strategies.help.designers. execute.the.software.design.process.in.an.effective.and.consistent.manner.For.the.most. part.these.help.designers.manage.and.simplify.problems.consider.the.impacts.of.their. proposed.solutions.and.establish.a.foundation.for.decision.making.during.design.In.this. context.design.principles.refer.to.knowledge.matter.that.has.been.found.effective.through- out.the.years.in.multiple.projects.on.different.domains.Design.principles.are.applicable.on. most.design.projects.therefore.their.use.is.expected.to.help.achieve.high-quality.designs. On.the.other.hand.design.considerations.are.recommendations.that.help.designers.in.the.

--- Chunk 62 ---
Tokens: 366
Type: sentence-based
Text:
On.the.other.hand.design.considerations.are.recommendations.that.help.designers.in.the. design.process.they.may.or.may.not.be.followed.Finally.design.strategies.consist.of.tacti- cal.approaches.in.which.design.principles.and.considerations.can.be.employed.to.drive.the. design.process.These.concepts.are.further.discussed.in.the.next.sections. General Software Design Principles Throughout.the.history.of.software.engineering.many.design.principles.have.emerged. to.become.fundamental.drivers.for.decision.making.during.the.software.design.process. These.design.principles.are.used.as.a.basis.for.reasoning.and.serve.as.justification.for.almost. all.design.decisions.They.also.provide.designers.with.a.foundation.from.which.other.more. sophisticated.design.methods.can.be.applied.(Pressman.2010).These.principles.are.not. specific.to.any.particular.design.strategy. (e.g.object.oriented).or.process.so.they.are.fun- damental.to.all.software.design.efforts.and.can.be.applied.during.architectural.detailed. and.construction.designs.The.principles.include. (Abran.et.al.2005): . Modularization . Abstraction . Encapsulation . Coupling.and.cohesion . Separation.of.interface.and.implementation . Sufficiency.and.completeness Introduction to Software Engineering Design  25 Modularization Modularization.is.one.of.the.most.important. (and.perhaps.oversimplified).design.prin- ciples.in.software.design.Modularity.allows.software.systems.to.be.manageable.at.all.levels.

--- Chunk 63 ---
Tokens: 387
Type: sentence-based
Text:
(and.perhaps.oversimplified).design.prin- ciples.in.software.design.Modularity.allows.software.systems.to.be.manageable.at.all.levels. of.the.development.life.cycle.That.is.the.work.products.of.the.requirements.design.con- struction.and.testing.efforts.can.all.be.modularized.to.efficiently.carry.out.the.operations. In the.design.phase.modularization.is.the.principle.that.drives.the.continuous.decompo- sition.of.the.software.system.until.fine-grained.components.are.created.Modularization. plays.a.key.role.during.all.design.activities.including.software.architecture.and.detailed. and. construction. design. when. applied. effectively. it. provides. a. roadmap. for. software. development.starting.from.coarse-grained.components.that.are.further.modularized.into. fine-grained.components.directly.related.to.code.If.applied.properly.modularization.can. lead.to.designs.that.are.easier.to.understand.resulting.in.systems.that.are.easier.to.develop. and.maintain.Efficient.modularization.can.be.achieved.by.following.and.applying.the. principles.of.abstraction.and.encapsulation.With.proper.modularization.software.systems. can.be.decomposed.into.modules.that.allow.the.systems.complexity.to.be.manageable.and. allow.the.system.to.be.efficiently.built.maintained.and.reused. Abstraction While.the.principle.of.modularization.specifies.what.needs.to.be.done.the.principle.of. abstraction.provides.the.guidance.as.to.how.it.should.be.done.Modularizing.systems.in. an.ad.hoc.manner.leads.to.designs.that.are.incoherent.hard.to.understand.and.hard.to.

--- Chunk 64 ---
Tokens: 397
Type: sentence-based
Text:
an.ad.hoc.manner.leads.to.designs.that.are.incoherent.hard.to.understand.and.hard.to. maintain.To.modularize.intelligently.a.thorough.understanding.of.abstraction.is.required. (Liskov.and.Guttag.2010).Abstraction.is.the.principle.that.deals.with.creating.conceptual. entities.required.to.facilitate.problem.solving.by.focusing.on.essential.characteristics.of. entitiesin.their.active.contextwhile.deferring.unnecessary.details.When.abstraction. is.applied.the.level.of.detail.required.to.think.about.a.problem.is.adjusted.to.productively. modularize.a.system.this.allows.for.the.creation.of.coherent.entities.that.can.be.used.to. represent.their.possible.variations.in.the.problems.context.and.domain.The.principle.of. abstraction.can.be.applied.iteratively.at.multiple.levels.during.the.design.phase.At.the.soft- ware.architecture.level.abstraction.helps.during.the.identification.of.software.components. and.their.interfaces.At.the.detailed.design.phase.abstraction.helps.identify.the.entities. functions.and.interfaces.required.to.realize.the.components.provided.services.At.the. construction.level.abstraction.helps.in.the.further.design.of.functions.identified.during. detailed.design.In.all.of.these.abstraction.is.used.to.facilitate.problem-solving.by.defer- ring.details.to.later.stages.The.principle.of.abstraction.can.be.classified.as. (Pressman.2010): . Procedural.abstraction . Data.abstraction Procedural. abstraction. is. a. specific. type. of. abstraction. that. simplifies. behavioral operations.containing.a.sequence.of.steps.or.other.procedural.abstractions.For.example.

--- Chunk 65 ---
Tokens: 397
Type: sentence-based
Text:
behavioral operations.containing.a.sequence.of.steps.or.other.procedural.abstractions.For.example. 26  Software Engineering Design consider.a.clientserver.application.in.which.the.client.sends.data.to.the.server.through. the.Internet.In.this.case.the.Send.procedural.abstraction.can.be.used.to.denote.a.series. of.operations.for.example.retrieving.the.servers.information.(e.g.Internet.Protocol.IP. address.port.number).opening.a.connection.sending.the.message.and.closing.the.con- nection.On.the.other.hand.data.abstraction.is.used.to.simplify.the.structural composition. of.data.objects.Using.the.previous.example.the.Message.data.abstraction.can.be.used.to. represent.various.messages.with.different.attributes.such.as.the.messages.ID.content.and. format.The.definition.of.all.of.these.properties.can.be.deferred.to.later.stages.Abstraction. is.fundamental.for.managing.complexity.in.all.activities.of.the.software.design.phase. Skill Development 1.2: The Abstraction Principle The.world.is.full.of.abstractions.without.abstractions.communicating.with.our.peers. would.be.much.more.difficult.As.an.exercise.look.for.the.nearest.rectangular.object. that. contains. a. knob. and. (maybe). a. keyhole. if. the. object. is. blocking. an. entrance. change.the.state.of.the.object.so.that.it.no.longer.blocks.the.entrance.Summarize.this. scenario.by.coming.up.with.two.abstractions.one.data.and.the.other.procedural.to. increase.communication.with.peers.When.done.create.a.list.of.four.other.abstractions. that.surround.you.and.provide.an.abstraction.as.well.as.the.detailed.object.description.

--- Chunk 66 ---
Tokens: 371
Type: sentence-based
Text:
that.surround.you.and.provide.an.abstraction.as.well.as.the.detailed.object.description. that.would.be.required.if.the.abstraction.is.not.used.Ensure.that.there.are.two.data. abstractions.and.two.procedural.abstractions. Encapsulation In.previous.sections.modularization.is.presented.as.principle.for.decomposing.mono- lithic.systems.into.manageable.units.While.abstraction.provides.the.principle.for.guid- ing.the.decomposition.of.the.systems.based.on.behavior.and.data.encapsulation.provides. the.principle.for.enhancing.the.efficiency.of.the.collaboration.among.modularized.units. Encapsulation.is.the.principle.that.deals.with.providing.access.to.the.services.of.concep- tual.entities.(e.g.modules.components).by.exposing.only.the.information.that.is.essential. to.carry.out.such.services.while.hiding.details.of.how.the.services.are.carried.out.While. abstraction.is.employed.to.find.conceptual.entities.encapsulation.enforces.that.abstracted. entities.communicate.between.each.other.using.a.need.to.know.only.basis.When.evalu- ated.this.way.the.abstraction.design.principle.helps.create.the.modules.and.the.encapsula- tion.design.principle.enforces.efficient.communication.between.them.These.principles.are. all.essential.in.achieving.efficient.modularization.The.relationship.among.modulariza- tion.abstraction.and.encapsulation.is.presented.in.Figure 1.4.As.seen.after.the.principle. of.abstraction.is.applied.the.encapsulation.principle.is.used.to.hide.irrelevant.details.from.

--- Chunk 67 ---
Tokens: 391
Type: sentence-based
Text:
of.abstraction.is.applied.the.encapsulation.principle.is.used.to.hide.irrelevant.details.from. the.abstraction.In.Figure 1.4.the.shaded.region.corresponds.to.information.that.is.irrel- evant.to.other.modules.while.the.white.region.corresponds.to.access.points.that.modules. can.use.to.interoperate. www.allitebooks.com Introduction to Software Engineering Design  27 Coupling Similar.to.abstraction.and.encapsulation.coupling.and.cohesion.are.design.principles.that.lead. to.efficient.module.creation.by.emphasizing.on.the.degree.of.dependency.and.belonging.of. modules.respectively.Formally.the.IEEE. (1990.p.22).defines.coupling.as The.manner.and.degree.of.interdependence.between.software.modules. Like.all.other.design.principles.discussed.so.far.coupling.can.be.applied.during.software. architecture.detailed.design.and.construction.design.to.measure.the.degree.of.depen- dency.of.design.units.such.as.an.architectural.subsystem.a.class.in.a.detailed.designs. class.diagram.or.a.function.in.code.In.other.words.the.coupling.principle.can.be.used. to.determine.how.much.an.architectural.subsystem.depends.on.other.architectural.sub- systems.how.much.a.class.depends.on.other.classes.and.how.much.a.function.depends.on. other.functions.When.measuring.coupling.the.number.of.dependencies.between.design. units.does.not.tell.the.whole.story.since.the.nature.of.the.dependencies.plays.an.impor- tant.role.in.decision.making.For.example.design.units.can.depend.on.well-defined.and. stable.interfaces.common.data.structures.and.internal.structure.of.other.design.units.

--- Chunk 68 ---
Tokens: 382
Type: sentence-based
Text:
stable.interfaces.common.data.structures.and.internal.structure.of.other.design.units. It is.not.hard.to.support.the.idea.that.dependencies.on.well-defined.and.stable.interfaces. are.less.troublesome.than.dependencies.on.the.internal.structure.of.other.design.units. Three.common.types.of.coupling.are . Content.coupling . Common.coupling . Data.coupling Content coupling.represents.the.most.severe.type.of.coupling.since.it.refers.to.modules.that. modify.and.rely.on.the.internal.details.of.other.modules.Common coupling.refers.to.depen- dencies.based.on.a.common.access.area.such.as.a.global.variable.(IEEE.1990).When.this. occurs.changes.to.the.global.data.area.causes.changes.in.all.dependent.modules.This.type. of.coupling.results.in.lesser.severity.than.content.coupling.however.it.shares.many.of.the. undesired.effects.as.content.coupling.Finally.data coupling.refers.to.the.type.of.dependency. Abstraction Modularization Encapsulation Monolithic System Modularized System FIGURE 1.4 The.modularization.abstraction.and.encapsulation.principles. 28  Software Engineering Design in.which.design.units.communicate.with.each.other.only.through.a.set.of.data.parameters. Unlike.content.coupling.data.coupling.does.not.depend.on.the.internals.of.other.design. units.and.unlike.common.coupling.it.provides.more.control.over.the.form.of.dependency. When.dependency.between.modules.relies.on.data.parameters.that.are.globally.inaccessible. design.units.are.shielded.from.undesired.changes.to.the.data.by.other.design.units.In.all.

--- Chunk 69 ---
Tokens: 400
Type: sentence-based
Text:
design.units.are.shielded.from.undesired.changes.to.the.data.by.other.design.units.In.all. cases.a.high.degree.of.coupling.gives.rise.to.negative.side.effects.For.example.as.coupling. increases.reusability.and.manageability.of.the.design.units.decrease.since.errors.or.changes. to.the.independent.unit.propagate.to.all.dependent.units.In other.cases.when.coupling. increases.so.does.the.complexity.of.managing.and.maintaining.design.units.Other.types. of.coupling.include.control coupling.hybrid coupling .and.pathological coupling.(IEEE.1990). Cohesion While.coupling.gives.insight.to.a.design.units.degree.of.dependency.cohesion.provides. insight.into.its.strengths.The.IEEE. (1990.p.17).defines.cohesion.as The.manner.and.degree.to.which.the.tasks.performed.by.a.single.software.module.are.related. to.one.another. Cohesion.measures.how.well.design.units.are.put.together.for.achieving.a.particular. purpose.and.can.be.classified.based.on.the.measurement.approach.as . Functional.cohesion . Procedural. (or.sequential).cohesion . Temporal.cohesion . Communication.cohesion Functional cohesion.measures.a.design.units.strength.by.the.degree.to.which.its.tasks. operations.or.subunits.all.contribute.to.perform.a.single.function.When.the.function. to.be.performed.has.a.single.logical.meaning.functional.cohesion.can.be.seen.as.a.form. of.logical.cohesion.A.highly.functionally.cohesive.module.is.one.whose.internal.details. work.toward.achieving.the.same.function.Functional.cohesion.is.the.most.typical.type. of.cohesion.Procedural cohesion.measures.the.strength.of.a.design.unit.by.the.degree.to.

--- Chunk 70 ---
Tokens: 396
Type: sentence-based
Text:
of.cohesion.Procedural cohesion.measures.the.strength.of.a.design.unit.by.the.degree.to. which.its.tasks.work.procedurally. (in.steps).to.achieve.the.units.purpose.Therefore.func- tional.and.procedural.cohesion.are.not.mutually.exclusive.that.is.modules.can.exhibit. both.high.functional.and.procedural.cohesion.Temporal cohesion.measures.strength.by. the.degree.to.which.all.tasks.in.a.design.unit.are.performed.at.specific.times.Consider. a.design.unit.responsible.for.carrying.out.the.initialization.of.a.system.This.unit.may. be.responsible.for.performing.a.power-on.self-test.that.may.include.memory.tests.file. system.checks.and.communication.checks.These.are.all.different.functions.but.need.to.be. .executed.at.the.same.time.during.initialization.therefore.the.unit.is.temporally.cohesive. Finally.communication cohesion.measures.a.units.strength.by.the.degree.to.which.its.tasks. produce.or.consume.the.same.data. Introduction to Software Engineering Design  29 Cohesion.provides.an.important.principle.that.measures.how.much.design.units.that.are. grouped.together.actually.belong.together.based.on.different.criteria.Cohesion.can.also. be.seen.at.different.levels.of.the.design.process.During.the.software.architecture.activity. logical.and.communication.cohesive.modules.are.typical.whereas.during.the.detailed. and.construction.design.activities.functional.procedural.and.temporal.cohesiveness.are. more.expected.In.all.cases.highly.cohesive.modules.increase.reusability.An.example.of. the.cohesion.and.coupling.principles.is.presented.in.Figure 1.5.As.seen.in.the.top.part.

--- Chunk 71 ---
Tokens: 383
Type: sentence-based
Text:
the.cohesion.and.coupling.principles.is.presented.in.Figure 1.5.As.seen.in.the.top.part. of.the.figure.Module 1.performs.three.unrelated.different.tasks. (i.e.Task.1.Task 2.and. Task.3).each.requiring.three.independent.subtasks.For.example.Task 1.requires.three. different.subtasks.denoted.by.the.labels.Task 1.1.Task 1.2.and.Task 1.3.As.seen.Module 1. has.dependencies.to.nine.different.unrelated.tasks.which.can.translate.to.a.high.degree. of.coupling.and.low.degree.of.cohesion.The.bottom.part.of.Figure 1.5.shows.how.the. system. is. decomposed. into. three. more. cohesive. units. each. with. lower. coupling. than. the.original.approach.In.this.case.the.system.is.transformed.to.a.modular.system.with. higher.cohesiveness.and.lower.coupling.With.this.transformation.Module 1.now.has.five. dependencies.and.stronger.functional.cohesion.Modules 2.and.3.have.lower.coupling.than. Module 1.(both.in.its.original.and.improve.form).and.are.highly.cohesive. Separation of Interface and Implementation The.principle.of.separation.of.interface.and.implementation.deals.with.creating.modules. in. such. way. that. a. stable. interface. is. identified. and. separated. from. its. implementation. This.design.principle.should.not.be.confused.with.encapsulation.During.encapsulation. Module 1 Task 1.1 Task 1.2 Task 1.3 Task 2.1 Task 2.2 Task 2.3 Task 3.1 Task 3.2 Task 3.3 Module 2 Module 3 Module 1 Task 1.1 Task 1.2 Task 1.3 Task 2.1 Task 2.2 Task 2.3 Task 3.1 Task 3.2 Task 3.3 FIGURE 1.5 Example.of.principles.of.coupling.and.cohesion.

--- Chunk 72 ---
Tokens: 360
Type: sentence-based
Text:
Module 1 Task 1.1 Task 1.2 Task 1.3 Task 2.1 Task 2.2 Task 2.3 Task 3.1 Task 3.2 Task 3.3 Module 2 Module 3 Module 1 Task 1.1 Task 1.2 Task 1.3 Task 2.1 Task 2.2 Task 2.3 Task 3.1 Task 3.2 Task 3.3 FIGURE 1.5 Example.of.principles.of.coupling.and.cohesion. 30  Software Engineering Design interfaces.are.created.to.provide.public.access.to.services.provided.by.the.design.unit.while. hiding.unnecessary.details.which.include.implementation.While.encapsulation.dictates. hiding.the.details.of.implementation.the.principle.of.separation.dictates.their.separation.so. that.different.implementation.of.the.same.interface.can.be.swapped.to.provide.modified.or. new.behavior.Figure 1.6.presents.these.concepts. As.seen.the.bottom.design.units.have.separated.interfaces.therefore.varied.implemen- tations.can.be.employed.without.changes.to.a.units.interface.and.subsequently.to.depen- dent.units.There.are.many.benefits.from.this.principle.including.increased.extensibility. reusability.and.maintainability.Since.implementation.is.compartmentalized.new.capa- bilities.can.be.added.simply.by.including.a.new.variation.of.the.implementation.without. changes.to.old.implementations.Also.in.this.way.specific.implementations.can.be.reused. Completeness and Sufficiency The. principles. of. completeness. and. sufficiency. deal. with. efficient. module. creation. Completeness.is.a.characteristic.that.measures.how.well.design.units.provide.the.required.

--- Chunk 73 ---
Tokens: 385
Type: sentence-based
Text:
Completeness.is.a.characteristic.that.measures.how.well.design.units.provide.the.required. services.to.achieve.their.intent.For.example.during.the.detailed.design.activity.a.commu- nication.class.can.be.considered.complete.for.a.particular.application.if.it.provides.services. for.establishing.and.terminating.connections.sending.and.receiving.messages.Missing. any.of.these.services.would.render.the.class.incomplete.On.the.other.hand.sufficiency. measures.how.well.design.units.are.at.providing.only.the.services.that.are.sufficient.for. achieving.their.intent.Consider.the.same.communication.class.which.can.include.services. for.logging.statistics.visualization.of.network.activity.or.any.other.capability.applicable. to.the.communication.task.Although.these.capabilities.enhance.the.class.service.list.the. class.is.considered.sufficient.by.providing.the.required.services.of.openingterminating. connections.sending.and.receiving.messages.That.is.these.sets.of.services.are.sufficient. to.achieve.the.units.required.functions.nothing.more.and.nothing.less. Practical Software Design Considerations Design.principles.are.well-known.throughout.the.software.engineering.community.and. are.applied.in.one.way.or.another.in.most.projects.However.other.considerations.need.to. Segregation of Interface and Implementation Encapsulation FIGURE 1.6 Principle.of.segregation.of.interface.and.implementation. Introduction to Software Engineering Design  31 be.made.to.provide.the.appropriate.context.in.which.these.principles.can.be.successfully.

--- Chunk 74 ---
Tokens: 385
Type: sentence-based
Text:
Introduction to Software Engineering Design  31 be.made.to.provide.the.appropriate.context.in.which.these.principles.can.be.successfully. applied.for.developing.high-quality.software.systems.These.considerations.are.discussed. in.the.next.sections. Design for Minimizing Complexity Design.is.about.minimizing.complexity.Every.decision.that.is.made.during.the.design.phase. must.take.into.account.reducing.complexity.(McConnell.2004).In.fact.the.majority.of.design. principles.(e.g.modularization.abstraction.encapsulation).are.meant.to.reduce.complexity. in.one.way.or.another.By.doing.this.details.of.the.problem.solution.can.be.pushed.further. down.the.process.where.they.can.be.appropriately.handled.As.another.example.consider. HCI.design.it.is.all.about.reducing.complexity.for.the.user.Finally.code.design.is.about. reducing.complexity.for.other.developers.maintaining.the.software.As.rule.of.thumb.when. faced.with.competing.design.options.always.choose.the.one.that.minimizes.complexity. Design for Change As.stated.before.software.will.change.therefore.design.with.extension.in.mind.There.are. numerous.reasons.for.this.for.example.customers.who.like.the.software.may.want.to.extend. its.functionalities.On.the.other.hand.customers.who.are.discontent.with.the.software.may. want.to.replace.or.remove.functionality.In.other.cases.hardware.changes.may.trigger.a. software.change.advances.in.communications.may.cause.software.to.change.or.simply. newer.better.software.technology.becomes.available.triggering.a.change.of.software.that.

--- Chunk 75 ---
Tokens: 396
Type: sentence-based
Text:
newer.better.software.technology.becomes.available.triggering.a.change.of.software.that. introduces.no.new.functionality.but.a.more.maintainable.development.technology.that. is.supported.by.current.practices.In.any.case.software.will.change.therefore.its.very. own.nature.requires.software.designers.to.plan.for.the.future.A.variety.of.techniques.is. .available.during.the.detailed.design.phase.to.achieve.this. Software Design Strategies Throughout.the.years.a.wide.variety.of.strategies.for.designing.software.has.been.proposed. Some.of.these.include.structured.design.object-oriented.design.aspect-oriented.design. data.component-based.design.and.data.structure-based.design.Two.popular.strategies.are. discussed.in.the.following.sections. Structured Design In.a.broad.context.structured.design.refers.to.any.disciplined.functional.design.approach. where.software.systems.are.decomposed.into.independent.single-purpose.modules.using. an.iterative.top-down.approach.The.main.focus.of.structured.design.is.on.the.functions. that.systems.need.to.provide.the.decomposition.of.these.functions.and.the.creation.of. modules. that. incorporate. these. functions. Structured. design. approaches. are. typically. employed.after.structured.analysis.where.the.main.purpose.is.to.derive.a.structure.chart. 32  Software Engineering Design (i.e.software.architecture).from.data.flow.diagrams.Structured.design.introduced.many. benefits. for. instance. by. decomposing. the. system. into. independent. single-purpose. modules.programs.were.simpler.to.understand.manage.code.debug.and.reuse.(Stevens.

--- Chunk 76 ---
Tokens: 390
Type: sentence-based
Text:
modules.programs.were.simpler.to.understand.manage.code.debug.and.reuse.(Stevens. 1981).However.structured.design.does.not.address.the.issues.of.data.abstraction.and.infor- mation.hiding.and.is.largely.inappropriate.for.use.with.object-based.and.object-oriented. programming.languages.(Booch.1994.p.22). Object-Oriented Design Unlike. structured. design. which. focuses. on. functional. decomposition. of. systems. object-oriented.design.focuses.on.object.decomposition.Formally.the.IEEE.(1990.p.51). defines.object-oriented.design.as A. design. strategy. in. which. a. system. or. component. is. expressed. in. terms. of. objects. and. .connections.between.those.objects. Objects.provide.numerous.capabilities.that.make.them.desirable.for.efficiently.designing. software.systems.For.example.objects.are.capable.of.maintaining.state.information.and. provide.services.that.can.be.used.independently.or.relative.to.the.objects.state.Therefore. they.are.naturally.good.building.blocks.for.creating.good.abstractions.Object-oriented. designs.also.provide.capabilities.for.inheritance.and.polymorphism.which.provide.vari- ous. advantages. when. designing. complex. and. large-scale. software. systems. Inheritance. allows.designers.to.create.families.of.objects.capable.of.reusing.each.others.interfaces.or. interfaces.with.implementations.While.inheritance.allows.objects.to.inherit.interfaces. and.implementations.polymorphism.allows.objects.to.change.the.behavior.of.inherited. interfaces.Numerous.design.methods.based.on.objects.have.been.proposed.Today.the.UP.

--- Chunk 77 ---
Tokens: 394
Type: sentence-based
Text:
interfaces.Numerous.design.methods.based.on.objects.have.been.proposed.Today.the.UP. provides.a.popular.framework.for.object-oriented.software.engineering.using.UML. CHAPTER SUMMARY Designs.in.software.engineering.are.used.to.identify.evaluate.and.specify.the.structural. and. behavioral. characteristics. of. software. systems. that. adhere. to. some. specification. Software.designs.provide.blueprints.that.capture.how.software.systems.meet.their.required. functions.and.how.they.are.shaped.to.meet.their.intended.quality.Formally.software.engi- neering.design.is.defined.as.the.process.of.identifying.evaluating.validating.and.specify- ing.the.architectural.detailed.and.construction.models.required.to.build.software.that. meets.its.intended.functional.and.nonfunctional.requirements.and.the.result.of.such.a.pro- cess.The term.software.design.is.used.interchangeably.in.practice.as.means.to.describe. both.the.process.and.product.of.software.design.Throughout.the.design.process.designers. are.constantly.engaging.in.problem-solving.activities.that.are.fundamental.to.all.modern. engineering.projects.therefore.they.can.be.characterized.as.specialized.problem.solvers. Introduction to Software Engineering Design  33 To.ensure.that.all.problem.considerations.are.incorporated.when.solving.design.problems. a. holistic. problem-solving. approach. must. be. adopted. including. all. relevant. concerns. Software.design.provides.numerous.advantages.from.both.product.development.and.pro- cess.however.many.challenges.must.be.considered.and.addressed.before.software.designs.

--- Chunk 78 ---
Tokens: 400
Type: sentence-based
Text:
Software.design.provides.numerous.advantages.from.both.product.development.and.pro- cess.however.many.challenges.must.be.considered.and.addressed.before.software.designs. can.lead.to.complete.and.sufficient.software.models.In.todays.modern.software.systems. numerous.design.principles.processes.strategies.and.other.factors.affect.how.designers. .execute. the. software. design. phase. When. equipped. with. the. proper. design. foundation. knowledge.an.understanding.of.the.designers.roles.and.responsibilities.can.be.acquired. allowing.designers.to.become.effective.in.designing.large-scale.software.systems.under.a. wide.variety.of.challenging.conditions. REVIEW QUESTIONS . 1.What.is.software.engineering.design.and.why.is.it.important? . 2.What.are.the.three.states.of.problem.solving.Describe.each.and.explain.how.they. apply.to.design.problems? . 3.What. are. two. types. of. thinking. employed. during. problem. solving. Provide. an. .example.of.how.they.are.applied.to.design.problems. . 4.What.is.the.difference.between.well-defined.ill-defined.and.wicked.problems.and. how.these.problems.can.affect.software.design? . 5.What.is.the.difference.between.an.algorithm.and.a.heuristic.Give.examples.of.how. both.approaches.can.be.applied.during.the.design.phase? . 6.What.is.the.holistic.approach.to.problem.solving.Explain. . 7.How.does.design.fits.within.the.software.engineering.life.cycle.Explain. . 8.What.are.the.major.activities.of.the.software.design.phase.and.how.do.they.differ. from.one.another? . 9.List.and.explain.the.challenges.faced.in.software.design. . 10.Why. is. important. to.

--- Chunk 79 ---
Tokens: 381
Type: sentence-based
Text:
to. emphasize. on. documentation. and. management. activities. .during.design? . 11.Compare. and. contrast. the. following. interface. design. user. interface. design. and. .construction.design. . 12.What.are.the.different.roles.of.software.designers.How.do.they.differ? . 13.Explain.the.difference.between.procedural.and.data.abstraction. . 14.What.is.content.coupling.and.how.does.it.differ.from.other.forms.of.coupling? . 15.Explain.in.detail.the.concept.of.cohesion. . 16.What.do.completeness.and.sufficiency.mean? . 17.What.is.the.difference.among.the.principles.of.modularization.abstraction.encapsu- lation.and.separation.of.interface.and.implementation.Provide.an.example.of.each. . 18.Compare.and.contrast.the.structured.design.strategy.with.the.object-oriented.design. strategy. 34  Software Engineering Design REFERENCES Abran.Alain.James.W.Moore.Pierre.Bourque.and.Robert.Dupuis.Guide to the Software Engineering Body of Knowledge2004 VersionSWEBOK.Los.Alamitos.CA.IEEE.Computer.Society.Press.2005. Bass.Len.Paul.Clements.and.Rick.Kazman.Software Architecture in Practice.2d.ed.Boston.Addison-Wesley. 2003. Booch.Grady.Object-Oriented Analysis and Design with Applications.2d.ed.Santa.Clara.CA.Addison-Wesley. 1994. Brassard.Gilles.and.Paul.Bratley.Fundamentals of Algorithmics.Upper.Saddle.River.NJ.Prentice.Hall.1995. Dowson.Mark.The.Ariane.5.Software.Failure.ACM SIGSOFT Software Engineering Notes.March.1997. Dym.Clive.L.and.Patrick.Little.Engineering Design: A Project-Based Introduction.Hoboken.NJ.Wiley.2008.

--- Chunk 80 ---
Tokens: 395
Type: sentence-based
Text:
Dym.Clive.L.and.Patrick.Little.Engineering Design: A Project-Based Introduction.Hoboken.NJ.Wiley.2008. Fox.Christopher.Introduction to Software Engineering Design: Processes, Principles, and Patterns with UML2. Boston.Addison.Wesley.2006. Giachetti.Ronald.E.Design of Enterprise Systems: Theory, Architecture, and Methods.Boca.Raton.FL.CRC Press. 2010. Griffin.Ricky.W.Management.10th.ed.Mayfield.Hts.Ohio.South-Western.College.Pub.2010. Harrell.C.Biman.K.Ghosh.and.Royce.O.Bowden.Simulation Using Promodel.New.York.McGraw-Hill.2004. IEEE.IEEE.Recommended.Practice.for.Software.Design.Descriptions.1998.http:ieeexplore.ieee.orgxpl freeabs_all.jsp?arnumber741934. IEEE.IEEE.Standard.Glossary.of.Software.Engineering.Terminology.IEEE.1990.http:ieeexplore.ieee.org xplfreeabs_all.jsp?arnumber159342. IEEEACM. Software Engineering 2004. August. 23. 2004. Available. at. http:sites.computer.orgccse SE2004Volume.pdf.(accessed.September.22.2010). Kershaw.T.C.and.S.Ohlsson.Multiple.Causes.of.Difficulty.in.Insight.The.Case.of.the.Nine-Dot.Problem. Journal of Experimental Psychology: Learning, Memory, and Cognition.30:315.2004. Laplante.Phillip.A.Requirements Engineering for Software and Systems.Boca.Raton.FL.Auerbach.Publications. 2009. Liskov.Barbara.and.John.Guttag.Program Development in Java: Abstraction, Specification, and Object-Oriented Design.Boston.Addison-Wesley.2000. McConnell.Steve.Code Complete.2d.ed.Redmond.WA.Microsoft.Press.2004. Meyers.Scott.Effective C: 55 Ways to Improve Your Programs and Designs.3d.ed.Boston.Addison-Wesley. 2005. U.S.General.Accounting.Office.

--- Chunk 81 ---
Tokens: 388
Type: sentence-based
Text:
U.S.General.Accounting.Office. (GAO).Patriot Missile Defense: Software Problem Led to System Failure at Dhahran, Saudi Arabia.Washington.DC.U.S.Government.Accountability.Office.1992. Plotnik.Rod.and.Haig.Kouyoumdjian.Introduction to Psychology.9th.ed.Wadsworth.Publishing.2010. Pressman.Roger.S.Software Engineering: A Practitioners Approach, 7th.ed.Belmont.CA.McGraw-Hill.2010. Sommerville.Ian.Software Engineering.9th.ed.Boston.Addison.Wesley.2010. Stevens.Wayne.P.Using Structured Design.How to Make Programs Simple, Changeable, Flexible and Reusable. Hoboken.NJ.John.Wiley.Sons.1981. 35 2 Software Design with Unified Modeling Language CHAPTER OBJECTIVES . Understand.the.role.and.importance.of.Unified.Modeling.Language. (UML).in.software.design . Become. familiar. with. UMLs. common. structural. and. behavioral. diagrams . Understand.the.relationship.between.structural.UML.models.and.code . Understand.how.to.model.concurrency.with.UML CONCEPTUAL OVERVIEW Communication.is.an.essential.critical.skill.for.engineers.Throughout.a. projects.life.cycle.software.engineers.spend.a.great.deal.of.time.and.effort. communicating.with.stakeholders.among.themselves.and.with.the.com- puter. via.programming.languages.By.unifying.the.communication.lan- guage.so.that.it.is.appropriate.for.stakeholders.software.engineers.and. translation.to.programming.languages.a.more.efficient.design.process.can. be.executed.and.better.framing.of.design.problem.and.their.solutions.can.be. achieved.to.account.for.all.intricacies.that.are.present.throughout.the.design.

--- Chunk 82 ---
Tokens: 357
Type: sentence-based
Text:
achieved.to.account.for.all.intricacies.that.are.present.throughout.the.design. process.Unified.Modeling.Language.(UML).provides.the.mechanisms.for. creating.detailed.models.that.portray.a.systems.design.By.providing.a.visu- alization.method.for.complex.design.concepts.communication.is.enhanced. at.all.phases.of.the.software.development.life.cycle.This.chapter.presents.the. fundamental.concepts.of.UML.to.establish.a.common.frame.of.reference.for. discussing.important.design.concepts.throughout.the.rest.of.the.book. 36  Software Engineering Design WHAT IS UML? The. Unified. Modeling. Language. is. a. visual. language. with. an. extensive. set. of. features. appropriate.for.designing.software.systems.across.a.broad.set.of.application.domains.It.is. the.result.of.years.of.collaborative.work.spent.in.devising.a.unified.approach.for.modeling. software.systems.The.first.efforts.focused.on.unifying.three.popular.modeling.methods. the.Booch.method.(devised.by.Grady.Booch).the.object-oriented.software.engineering. (OOSE).method.(devised.by.Ivar.Jacobson).and.the.object.modeling.technique.(OMT). method.(devised.by.James.Rumbaugh).The.goals.of.this.unification.project.were.specified. by.Booch.Rumbaugh.and.Jacobson. (2005.p.xvii).as.follows: . 1.To. model. systems. from. concept. to. executable. artifact. using. object-oriented. techniques . 2.To.address.the.issues.of.scale.inherent.in.complex.mission-critical.systems .

--- Chunk 83 ---
Tokens: 397
Type: sentence-based
Text:
2.To.address.the.issues.of.scale.inherent.in.complex.mission-critical.systems . 3.To.create.a.modeling.language.usable.by.both.humans.and.machines The.development.of.early.UML.versions.generated.interest.among.the.software.engi- neering.community.resulting.in.the.creation.of.UML.consortium.supported.by.numerous. influential.organizations.such.as.Microsoft.IBM.Oracle.and.Rational.This.collaboration. resulted.in.UML.1.0.which.after.revisions.was.adopted.by.the.Object.Management.Group. (OMG).in.1997.as.UML.1.1.(Booch.et.al.2005).Since.then.UML.has.evolved.through. many.versions.that.improve.capabilities.for.efficient.analysis.design.and.implementation. of.software.systems.of.varying.complexity.In.2005.a.major.revision.of.UML.1.was.pro- posed.and.adopted.by.the.OMG.as.UML.2.0.At.the.time.of.writing.UML.2.3.provides. the.latest.specification.(UML.2.3.Superstructure.2010).Formally.UML.can.be.defined.as.a. visual.language.for.specifying.analyzing.and.documenting.design.elements.essential.for. modeling.and.building.software.system.To.provide.an.organized.methodology.for.creat- ing.models.that.address.different.stakeholders.concerns.UML.defines.different.modeling. diagrams.and.provides.a.classification.scheme.that.delineates.clearly.between.the.static. and.dynamic.nature.of.software.systems.as.seen.in.Table 2.1. Every.diagram.in.UML.belongs.to.one.of.the.classes.presented.in.Table 2.1.Throughout. the.rest.of.the.chapter.UML.diagrams.fundamental.for.modeling.systems.from.both.struc- tural.and.behavioral.perspectives.are.presented.and.their.capabilities.for.addressing.issues.

--- Chunk 84 ---
Tokens: 360
Type: sentence-based
Text:
the.rest.of.the.chapter.UML.diagrams.fundamental.for.modeling.systems.from.both.struc- tural.and.behavioral.perspectives.are.presented.and.their.capabilities.for.addressing.issues. of.different.concerns.from.different.levels.of.abstractions.are.examined. TABLE 2.1 Classification.of.UML.Diagrams Classification Description Structural Concerned.with.capturing.and.specifying.static.elements.and.their.interrelationships. required.for.supporting.the.solution.to.a.given.problem.within.a.given.context Behavioral Concerned.with.capturing.and.specifying.the.dynamic.behavior.and.the.inherent.complexities. present.in.the.behavioral.aspects.of.software.systems www.allitebooks.com Software Design with Unified Modeling Language  37 WHY STUDY UML? UML.2.3.provides.14.different.types.of.diagrams.that.can.be.used.for.modeling.structural. and.behavioral.aspects.of.software.systems.Since.software.systems.vary.across.a.large.set. of.application.domains.not.all.14.diagrams.are.required.or.used.in.any.given.project.For. example.real-time.systems.may.employ.the.use.of.UML.timing.state.and.communica- tion.diagrams.to.model.behavior.and.real-time.constraints.related.to.real-time.systems. Distributed.systems.may.employ.sequence.diagrams.for.modeling.time-ordered.sequence. of. operations. among. components. and. deployment. diagrams. for. modeling. distributed. aspects.of.the.systems.Finally.object-oriented.systemswhich.can.also.be.distributed.or.

--- Chunk 85 ---
Tokens: 386
Type: sentence-based
Text:
aspects.of.the.systems.Finally.object-oriented.systemswhich.can.also.be.distributed.or. real-time.systemsmay.rely.heavily.on.class.and.object.diagrams.to.model.class.hierar- chies.and.particular.instances.of.their.interaction.Even.though.not.all.diagrams.are.used. in.system.modeling.efforts.it.is.important.to.identify.a.common.set.of.diagrams.that.pro- vide.appropriate.avenues.for.model.ing.essential.activities.during.the.software.development. process.Therefore.the.study.of.UML.becomes.important.so.that.the.modeling.capabilities. of.particular.diagrams.are.well.understood.and.applied.in.practical.efforts.The.two.main. reasons.for.studying.UML.include . The.UML.enhances.system.analysis.and.specification. . The.UML.enhances.communication. Modeling. software. is. essential. to. developing. high-quality. large-scale. and. software-. intensive. systems. The. UML. is. important. because. it. provides. well-known. and. widely. accepted.means.for.modeling.complex.systems.Through.UML.a.common.approach.can. be.used.for.analyzing.evaluating.and.specifying.systems.at.all.levels.of.abstraction.during. requirements.design.and.construction.After.systems.are.specified.at.one.level.of.abstraction. using.UML.the.models.are.transferred.downstream.for.subsequent.finer-grained.analy- sis.evaluation.and.specification.This.process.continues.until.the.software.is.constructed. and.ready.for.testing.and.verification.Throughout.this.process.UML.is.the.main.tool. for.transferring.knowledge.and.enhancing.communication.among.stakeholders.including.

--- Chunk 86 ---
Tokens: 399
Type: sentence-based
Text:
for.transferring.knowledge.and.enhancing.communication.among.stakeholders.including. customers.designers.(i.e.architects.component.and.construction).programmers.and. managers.By.providing.the.means.for.visualizing.complex.system.concepts.it.becomes. easier.to.reason.about.the.problem.at.hand.therefore.increasing.communication.during. the.problem-solving.process.The.UMLs.visualization.capabilities.enhance.communica- tion.greatly.throughout.especially.when.creating.documentation.deliverables.such.as.the. software.design.document.which.lives.long.after.the.development.effort.is.complete. THE UMLS FUNDAMENTALS The.UML.is.an.extensible.and.flexible.language.that.can.be.used.to.model.almost.any.aspect. of.todays.modern.software.systems.Given.the.rich.set.of.modeling.features.provided.by. 38  Software Engineering Design UML.its.application.can.become.confusing.at.times.resulting.in.model.inconsistencies. that.can.hinder.communication.during.the.development.effort.The.built-in.flexibility.in. UML.is.essential.for.modeling.systems.with.disparate.capabilities.therefore.understand- ing.its.fundamental.building.blocks.is.necessary.for.employing.the.built-in.flexibility.to. model.a.wide.variety.of.software.systems.The.UML.building.blocks.are.grouped.as.follows: . Classifiers . Relationships . Enhancing.features Classifiers.are.structural.things.that.represent.conceptual.or.physical.elements.of.a.model. (Booch.et.al.2005).They.are.typically.the.main.elements.of.UML.models.and.each.type.of. UML.diagram.has.a.specific.type.of.classifiers.so.that.not.all.classifiers.are.relevant.to.all.

--- Chunk 87 ---
Tokens: 392
Type: sentence-based
Text:
UML.diagram.has.a.specific.type.of.classifiers.so.that.not.all.classifiers.are.relevant.to.all. UML.diagrams.A.list.of.common.UML.classifiers.is.presented.in.Table 2.2. Classifiers.provide.designers.the.capability.of.defining.the.structure.for.achieving.some. desired.system.feature.This.capability.allows.designers.to.visualize.the.structural.design. of.systems.provide.analysis.and.make.design.improvements.all.at.design.time.Structural. designs.are.good.for.evaluating.logical.relationships.in.software.design.however.they.are. limited.when.it.comes.to.evaluating.the.systems.behavioral.aspectsthat.is.modeling. and.evaluating.the.manifestation.and.behavioral.aspects.of.classifiers.once.the.system.is. executed.For.this.purpose.UML.provides.techniques.for.representing.almost.all.classi- fiers.as.manifested.entities.For.example.structural.classes.can.be.modeled.as.behavioral. (executing).objects.the.behavior.of.active.classes.can.be.modeled.using.active.objects. components.can.be.modeled.as.component.instances.use.cases.can.be.modeled.as.use. case.executions.and.nodes.can.be.modeled.as.node.instances.(Booch.et.al.2005).The. TABLE 2.2 UML.2.3.Common.Classifiers Classifier Description Use.case Classifier.used.to.model.a.single.required.system.behavior.represented.with.icons.of. elliptical.shape Component Represents.a.modular.and.replaceable.part.of.the.system.modeled.using.a.box.with.the. keyword.component.and.optional.component.icon.on.the.top.right.corner Class Classifier.used.to.model.a.type.in.terms.of.operations.attributes.relationships.and.other.

--- Chunk 88 ---
Tokens: 399
Type: sentence-based
Text:
keyword.component.and.optional.component.icon.on.the.top.right.corner Class Classifier.used.to.model.a.type.in.terms.of.operations.attributes.relationships.and.other. semantics.modeled.with.a.rectangular.box Active.class Classifier.used.to.model.a.class.that.owns.an.independent.flow.of.execution.and.can.initiate. control.activity.modeled.as.a.class.with.double.lines.on.each.side Interface Classifier.that.models.the.set.of.operations.that.specify.the.services.provided.by.a.class.or. component.represented.as.stereotyped.classes.or.using.the.ball-and-socket.notation Node Classifier.used.to.model.a.physical.element.(e.g.computer).its.processing.capabilities.and. other.semantics.modeled.using.a.cube Artifact Classifier.that.models.a.physical.deployable.information.element.(e.g.exe.dll.script.etc.). modeled.using.a.rectangle.with.the.keyword.artifact Software Design with Unified Modeling Language  39 usefulness.of.modeling.classifiers.(and.their.behavioral.counterparts).is.maximized.when. defining.and.visualizing.the.interconnections.that.exist.among.them.A.list.of.UML.com- mon.relationship.types.is.presented.in.Table 2.3. The.UML.is.required.to.provide.enough.flexibility.to.allow.designers.to.enhance.and. evolve.the.fundamental.building.blocks.so.that.they.become.appropriate.for.modeling.par- ticular.systems.Therefore.it.provides.the.means.for.enhancing.and.extending.classifiers. behavioral. manifestations. and. relationships. through. common. extension. mechanisms. These.extension.mechanisms.allow.designers.to.redefine.UML.elements.so.that.they.can. represent. domain-specific.

--- Chunk 89 ---
Tokens: 399
Type: sentence-based
Text:
domain-specific. concepts. Also. extension. mechanisms. allow. detailed. design. information.to.be.captured.and.specified.in.the.models.The.common.mechanisms.for. enhancing.UML.are.presented.in.Table 2.4. Together. classifiers. relationships. and. enhancement. mechanisms. provide. powerful. .constructs.for.evaluating.both.structural.and.behavioral.design.elements.that.interact.and. collaborate. with. each. other. provide. the. means. for. evaluating. design. alternatives. and. .provide.the.sufficient.information.to.build.the.software.system. TABLE 2.3 Common.Types.of.UML.Relationships Relationship Description Dependency Dashed.line.(typically.directed.with.a.stick.arrow).used.to.model.the.relationship.between. two.UML.elements.indicating.that.changes.to.one.element.affect.the.other Association Line.used.to.model.the.relationship.between.two.UML.elements.indicating.that.a.connection. exists.between.associated.instances.at.run.time.associations.can.be.directed.using.a.stick. arrow Generalization Line.with.a.hollow.arrowhead.used.to.model.the.relationship.between.two.UML.elements. indicating.that.one.element.(i.e.the.child).inherits.features.from.another. (i.e.the.parent) Realization Relationship.between.two.UML.elements.indicating.that.one.element.realizes.a.specified. interface.modeled.using.a.dashed.line.with.hollow.arrowhead TABLE 2.4 Common.UML.Mechanisms.for.Enhancement Mechanism Description Notes Mechanism.for.adding.descriptive.information.to.UML.elements.and.diagrams.modeled. using.a.rectangle.with.a.dog-eared.corner.and.can.be.connected.to.a.design.element.using.a.

--- Chunk 90 ---
Tokens: 384
Type: sentence-based
Text:
using.a.rectangle.with.a.dog-eared.corner.and.can.be.connected.to.a.design.element.using.a. dashed.line Stereotypes Mechanism.for.extending.UML.by.adding.information.that.gives.existing.UML.element.a. different.meaning.therefore.creating.a.semantically.different.element.for.modeling. application-specific.concepts.modeled.as.existing.UML.elements.with.the.stereotype. mechanism. (e.g.subsystem) Tagged.Values Mechanism.for.adding.new.properties.to.a.stereotype.modeled.by.adding.the.tagged.value.in. the.form.of.property  value.to.existing.stereotyped.UML.elements. (e.g.data rate  5 Mbps) Constraints Mechanism.for.specifying.constraints.to.design.elements.associated.with.specific.design. elements.in.the.form.of.constraint description. (e.g.secure.line) 40  Software Engineering Design STRUCTURAL MODELING Structural.modeling.is.concerned.with.capturing.and.specifying.structural.elements.and. interrelationships.required.for.supporting.the.solution.to.a.given.problem.within.a.given. context.Structural.models.are.static.in.nature.since.they.model.structure.and.not.behav- ior.therefore.they.provide.the.main.avenues.for.evaluating.design.decisions.that.directly. support.functional.requirements.as.well.as.desired.quality.attributes.such.as.modularity. portability.and.maintainability.A.list.of.common.UML.structural.diagrams.is.presented. in.Table 2.5. Other.structural.diagrams.include.composite structure.and.profile.diagrams.As.seen.each. structural.diagram.addresses.a.particular.system.concern.therefore.the.set.of.classifiers.

--- Chunk 91 ---
Tokens: 385
Type: sentence-based
Text:
structural.diagram.addresses.a.particular.system.concern.therefore.the.set.of.classifiers. and.relationship.employed.varies.from.diagram.to.diagram.Understanding.the.capabilities. and.goals.of.each.structural.diagram.is.important.for.determining.the.selection.of.effective. constructs.that.are.appropriate.at.particular.levels.of.abstraction.during.system.design. COMPONENT DIAGRAMS A.component.represents.a.modular.part.of.a.system.that.encapsulates.its.contents.and. whose.manifestation.is.replaceable.within.its.environment.(UML.2.3.Superstructure.2010). For.this.reason.component.diagrams.can.be.used.to.decompose.systems.and.represent. their. structural. architecture. from. a. logical. perspective. Components. can. be. modeled. using.an.external.black-box.view.or.internal.white-box.view.With.the.black-box.view. components.encapsulate.their.internal.structure.therefore.collaboration.with.other.com- ponents.is.achieved.through.well-defined.interfaces.These.interfaces.can.be.classified.as. provided.or.required.interfaces.Provided.interfaces.are.used.by.other.external.components. to.interact.with.the.component.providing.the.interface.Required.interfaces.are.those.the. TABLE 2.5 UML.2.3.Structural.Diagrams Diagram Description Component High-level.used.to.model.the.software.as.group.of.components.connected.to.each.other. through.well-defined.interfaces.and.thus.said.to.be.replaceable.within.its.context Class Used.to.model.software.as.a.set.of.classes.including.their.operations.attributes.and. their mutual.relationships Object.

--- Chunk 92 ---
Tokens: 315
Type: sentence-based
Text:
their mutual.relationships Object. Used.to.model.an.instant.snapshot.of.the.life.of.an.object.during.execution.including. its state.and.attribute.values Deployment. Used.to.model.the.physical.realization.of.software.systems.including.physical.nodes. where.software.is.deployed.interfaces.between.nodes.software.artifacts.executing.on. nodes.and.the.manifestation.of.software.components.within.the.software.artifacts Package.Diagram Diagram.used.to.model.the.division.of.software.as.a.set.of.packages.including.the. relationships.between.packages Software Design with Unified Modeling Language  41 components.need.to.realize.a.components.function.Modeling.component.interfaces.in. UML.can.be.achieved.using.two.distinct.notations.the.ball-and-socket.notation.or.the. dependency.and.realization.relationships.as.seen.in.Figure 2.1. Figure 2.1. shows. the. basic. component. relationships. and. examples. of. component. diagrams.As.seen.the.basic.notations.for.modeling.components.are.components.assembly. connectors.and.providedrequired interfaces.The.notations.presented.in.Figure 2.1.are.used. to.model.components.using.an.external.black-box.view.however.components.can.also. be.designed.using.an.internal.white-box.view.not.presented.in.Figure 2.1.When.using.

--- Chunk 93 ---
Tokens: 397
Type: sentence-based
Text:
be.designed.using.an.internal.white-box.view.not.presented.in.Figure 2.1.When.using. Component Relationships Provided Interface component ComponentA Required Interface assembly Dependency Dependency Realization Realization component ComponentA component ComponentA component ComponentA component ComponentA component ComponentA component ComponentA component ComponentA component ComponentB component ComponentB interface InterfaceB interface InterfaceB ClassA IRequired IRequired IProvided IProvided Port 2 Port 1 Ports and Delegates delegate delegate component ComponentB component ClientCollectionSystem component SensorManager IClientData IClientData ISchedule ISchedule Port 2 Port 1 Sample Component Diagram delegate ISensorControl IVideoControl delegate component ClientManager component VideoManager FIGURE 2.1 Overview.of.UML.component.diagram. 42  Software Engineering Design the.black-box.approach.components.use.the.ports.and.delegates.concepts.to.model.how. components.interact.with.other. (external).components.and.how.the.responsibility.for.real- izing.external.requests.are.delegated.throughout.parts.of.components.As.seen.ports.are. used.to.model.access.points.for.allowing.the.external.environment.to.access.the.compo- nents.services.and.for.allowing.components.to.interact.with.their.external.environment. Delegation.connectors.are.used.to.model.the.link.between.the.external.provided.inter- faces.of.a.component.to.the.realization.of.those.interfaces.internally.within.the.component. (UML.2.3.Superstructure.2010).Similarly.delegation.connectors.model.the.link.between.

--- Chunk 94 ---
Tokens: 380
Type: sentence-based
Text:
(UML.2.3.Superstructure.2010).Similarly.delegation.connectors.model.the.link.between. internally.required.interfaces.to.ports.requiring.the.interface.from.external.components. Figure 2.1.presents.a.design.element.for.devising.a.logical.representation.for.the.software. architecture.of.a.sensor.collection.system.The.system.includes.a.client.collection.node. that.is.decomposed. into. ClientManager.SensorManager.and.VideoManager.The.client. .subsystem.requires.a.collection.schedule.which.provides.the.information.necessary.for. activating.sensor.and.video.nodes.to.begin.collection.The.client.subsystem.makes.this. information.available.to.other.nodes.upon.request.As.seen.the.ClientManager.component. requires.a.collection.schedule.which.is.delegated.to.Port.2.this.interface.requires.external. components.to.provide.the.collection.schedule.using.the.ISchedule.interface.In addition. the.ClientCollectionSystem.component.provides.status.information.to.external.components. via.Port.1.using.the.IClientData.interface.The.responsibility.of.realizing.the.IClientData. interface.to.provide.status.data.is.delegated.to.the.ClientManager.component.so.that.all. requests.received.at.Port.1.can.be.handled.by.the.target.component. Logical versus Physical Components The.UML.2.3.Superstructure.Specification.supports.the.specification.of.both.logical.and. physical.components.and.describes.them.as.substitutable.units.that.can.be.replaced.at. design.time.or.run.time.(UML.2.3.Superstructure.2010).This.combined.with.the.previous.

--- Chunk 95 ---
Tokens: 384
Type: sentence-based
Text:
design.time.or.run.time.(UML.2.3.Superstructure.2010).This.combined.with.the.previous. usage.(in.UML.1.x).of.components.creates.confusion.among.designers.Although.UML.1.x. and.UML.2.x.components.can.look.the.same.in.UML.the.context.in.which.they.are.used. should.make.the.distinction.between.physical.and.logical.components.evident.For.this. reason.a.thorough.discussion.is.needed. Logical. components. are. used. from. a. logical. perspective. while. physical. components. are.used.from.a.deployment.perspective.which.in.UML.2.0.can.be.modeled.as.artifacts. Logical.components.are.components.that.can.be.replaced.at.design.time.For.example. the.internal.structure.of.a.software.system.may.be.composed.of.three.logical.components. the. UI. component. the. business. logic. component. and. the. database. component. Each. of.these.has.well-known.interfaces.that.allow.them.to.be.replaceable.at.design.time.By. .having.well-known.interfaces.the.internal.design.of.components.(e.g.the.UI.component). becomes. irrelevant. to. other. external. components. (e.g. the. business. logic. component). Logical.components.specify.the.decomposed.structure.of.software.they.exist.in.the.context. of.the.logical.design.of.the.software.system. On.the.other.hand.physical.components.are.components.that.exist.within.the.context. of.deployment.they.are.distinctively.different.from.logical.components.in.that.they.are. Software Design with Unified Modeling Language  43 independently.deployable.units.that.reside.on.their.own.and.provide.services.to.other.

--- Chunk 96 ---
Tokens: 394
Type: sentence-based
Text:
Software Design with Unified Modeling Language  43 independently.deployable.units.that.reside.on.their.own.and.provide.services.to.other. physical.components.or.software.applications.They.provide.stable.interfaces.that.allows. them.to.be.replaceable.at.run.time.for.example.JavaBean.components.EJB.components. and.NET.components.which.can.be.deployed.independently.through.a.jar.file.ear.file. and.DLL.file.respectively.(Qian.Qian.Fu.Tao.Xu.and.Diaz-Herrera.2009). Using.components.to.denote.logical.units. (as.opposed.to.physical.units).is.new.to.UML 2.0. therefore.they.provide.modeling.features.that.are.specially.fitting.for.designing.logical.ele- ments.of.the.software.architecture.In.previous.versions.of.UML.components.were.reserved. exclusively.for.modeling.physical.entities.deployable.within.a.system.and.replaceable.at.run. time.Now.UML.supports.the.specification.of.both.logical.and.physical.components.together. with.the.artifacts.that.implement.them.and.the.nodes.on.which.they.are.executed.(UML.2.3. Superstructure.2010).This.new.paradigm.allows.designers.to.model.physical.deployment. aspects.of.components.using.the.artifact.classifier.deployed.on.a.node.(Booch.et.al.2007). CLASS DIAGRAMS Class.diagrams.exist.at.a.lower.level.of.abstractions.than.component.diagrams.That.is.whereas. component.diagrams.serve.well.to.modularize.the.system.they.do.not.have.a.direct.translation. from.model.to.code.Class.diagrams.have.direct.translation.to.object-oriented.programming. languages.In.simple.terms.class.diagrams.are.models.consisting.of.classes.and.relationships.

--- Chunk 97 ---
Tokens: 400
Type: sentence-based
Text:
languages.In.simple.terms.class.diagrams.are.models.consisting.of.classes.and.relationships. between.classes.necessary.to.achieve.a.systems.functionality.Therefore.whether.a.detailed. class.diagram.is.made.or.not.the.resulting.object-oriented.code.will.always.reflect.some.class. design.This.characteristic.of.class.designs.results.in.a.two-way.relationship.between.class. .diagrams.and.code.which.allows.designers.to.generate.code.from.class.diagrams. (i.e, code. generation.or.forward.engineering).or.to.generate.class.diagrams.from.code.(i.e.reverse. engineering).This.makes.class.diagrams.the.most.powerful.tool.for.component.designers.to. model.the.design.characteristics.of.object-oriented.software.before.the.construction.phase. Class. diagrams. vary. in. complexity. ranging. from. diagrams. with. a. few. classes. with. .simple.relationships.to.diagrams.with.many.classes.interconnected.via.elegant.and.effi- cient.relationships.Class.diagrams.are.perhaps.the.most.important.UML.diagrams.for. object-oriented. component. designers. To. effectively. model. object-oriented. software. designers.need.to.have.an.understanding.of.the.basic.class.constructs.relationships.and. the.direct.mapping.that.result.from.model.to.code. Classes A.class.is.the.specification.of.a.type.nothing.more.nothing.less.For.a.class.to.be.useful.to. software.programs.objects.of.that.class.need.to.be.instantiated.during.the.programs.execu- tion.Instantiation.is.the.process.of.manifesting.a.class.in.the.computers.memory.A.single. class.specification.can.be.manifested.in.the.computers.memory.during.program.execution.

--- Chunk 98 ---
Tokens: 399
Type: sentence-based
Text:
class.specification.can.be.manifested.in.the.computers.memory.during.program.execution. as.multiple.objects.their.specific.values.for.each.having.operations.and.relationships.with. 44  Software Engineering Design other.objects.Classes.are.the.building.blocks.of.object-oriented.systems.therefore.being. able.to.model.classes.in.an.efficient.and.reusable.way.is.essential.In.UML.a.class.is.mod- eled.with.a.rectangular.shape.with.three.main.compartments.namely.the.name.attribute. and.operation.compartments. Name Compartment The.name.compartment.is.reserved.for.the.class.name.and.its.stereotype.A.class.name.is. a.string.value.that.uniquely.identifies.a.class.from.other.classes.in.the.system.Class.names. can.be.qualified.to.show.the.package.that.they.belong.to.in.the.form.of.Owner:ClassName. where.Owner.refers.to.the.package.that.owns.the.class.and.ClassName.refers.to.the.class. name.UML.classes.can.be.enhanced.to.convey.more.information.by.using.stereotypes. Stereotypes.are.displayed.above.the.class.name.using.the.format.stereotype.Commonly. used.stereotypes.for.classes.include.the.interface.and.utility.stereotypes.The. interface.stereotype.is.used.to.model.interfaces.which.specify.the.services.of.a.class. The.utility.stereotype.is.used.to.model.a.class.that.has.no.instances.but.instead.repre- sents.a.named.collection.of.class-scoped.(i.e.static).attributes.and.operations. Attribute Compartment Attributes.are.named.properties.used.to.specify.the.information.required.by.objects.to.carry. out.their.intended.function.or.to.represent.the.object.modeled.by.the.class.The.attribute.

--- Chunk 99 ---
Tokens: 284
Type: sentence-based
Text:
out.their.intended.function.or.to.represent.the.object.modeled.by.the.class.The.attribute. compartment.is.reserved.for.specifying.the.class.attributes.including.their.name.type.and. other.properties.such.as.visibility.and.scope.Attribute.names.similar.to.class.names.are. string.values.that.uniquely.identify.one.attribute.from.all.other.attributes.The.attribute.type. specifies.the.type.of.data.appropriate.for.the.attribute.for.example.integer.string.or.double. Typically.the.attribute.compartment.is.used.to.specify.primitive.types.whereas.attributes. that.result.as.consequence.of.relationships.with.user-defined.types.are.kept.from.the.attri- bute.compartment.these.are.modeled.using.the.appropriate.UML.relationship.with.a.label. containing.the.attributes.name.The.attributes.visibility.specifies.policies.on.how.attributes. are.accessed.by.clients.In.UML.visibility.can.be.set.to.the.types.represented.in.Table.2.6. The.scope.of.an.attribute.can.be.specified.to.be.class-specific.(i.e.static).or.object-specific. which.allows.each.individual.object.to.have.individual.copies.that.help.keep.track.of.attri- bute.values.independently.

--- Chunk 100 ---
Tokens: 262
Type: sentence-based
Text:
which.allows.each.individual.object.to.have.individual.copies.that.help.keep.track.of.attri- bute.values.independently. TABLE 2.6 Common.Visibility.Types.in.Class.Diagrams Visibility Symbol Description Public  Allows.access.to.external.clients Private  Hides.private.members.or.operations.from.external.clients Protected  Allows.access.internally.within.the.class.and.to.derived.classes Package  Allows.access.to.entities.within.the.same.package Software Design with Unified Modeling Language  45 Operation Compartment Operations.are.services.provided.by.classes.The.operation.compartment.is.reserved.for. specifying.the.class.operations.including.their.name.return.type.parameters.and.other. properties.such.as.visibility.scope.type. (e.g.abstract).and.constraints.as.seen.in Figure 2.2. The.class.concept.is.easier.to.understand.for.most.programmers.since.it.directly.maps. to.code.in.object-oriented.languages.An.important.aspect.of.modeling.software.with.class. diagrams.is.the.understanding.of.how.classes.modeled.in.the.design.translate.to.code.

--- Chunk 101 ---
Tokens: 395
Type: sentence-based
Text:
diagrams.is.the.understanding.of.how.classes.modeled.in.the.design.translate.to.code. Class Stereotype ClassName interface AbstractClass interfaceMethod(): void attribute: int operation1(): void operation2(): void publicAttribute: int privateMethod(param: int): void protectedMethod(): int abstractMethod(): void publicStaticMethod(): void Class Structure Class Diagram Relationships Sample Class Diagram ClassA Dependency ClassB ClassA Association ClassB ClassA Directed Association ClassB ClassA Aggregation ClassB ClassA Composition ClassB ClassA Generalization ClassB ClassA Realization ClassB PartClassA ConcreteClass interfaceMethod(): void WholeClass DerivedClass PartClassD IndependentClass SampleClass BaseClass pConcrete pPartA objectD FIGURE 2.2 Overview.of.class.diagram. 46  Software Engineering Design UML.as.a.universal.language.provides.the.appropriate.mechanisms.to.allow.designers.to. model.almost.any.aspect.of.modern.object-oriented.programming.languages.Therefore. when.modeling.UML.classes.it.is.important.to.understand.what.decisions.made.at.design. time.result.in.code.As.an.example.consider.Listing.2.1.which.presents.C.code.for.the. SampleClass.designed.in.the.Sample.Class.Diagram.section.of.Figure 2.2. As.seen.generation.of.code.from.UML.SampleClass.results.in.the.manifestation.of.UML. class.as.code.both.versions.(i.e.code.and.UML.class.drawing).of.the.SampleClass.design. element.convey.identical.information.The.same.UML.class.can.be.used.to.generate.code.in. other.programming.languages.as.well.For.example.Listing.2.2.presents.the.manifestation.

--- Chunk 102 ---
Tokens: 349
Type: sentence-based
Text:
other.programming.languages.as.well.For.example.Listing.2.2.presents.the.manifestation. of.UML.SampleClass.class.design.using.the.Java.programming.language. Relationships Classes. that. do. not. collaborate. with. each. other. may. not. accomplish. much. Therefore. depicting.the.relationships.among.classes.is.an.essential.part.of.class.diagrams.UML.rela- tionships.can.be.used.to.model.the.connection.between.UML.classes.in.a.class.diagram. The.UML.relationships.identified.in.Table 2.3.can.all.be.used.in.class.diagrams.to.pro- vide. connections. appropriate. to. model. relationships. found. in. object-oriented. systems. Similar.to.the.modeling.of.classes.it.is.essential.for.designers.to.understand.how.UML. relationships.translate.to.code.Since.UML.is.programming.language-agnostic.some.of.the. relationships.that.have.different.meanings.in.the.modeling.domain.will.translate.with.no. difference.in.the.code.domain. Listing 2.1: C Code Generated from SampleClass Designed in Figure 2.2 class SampleClass  public:  Methods in this section are made public. void operation1()   Code here. private:  Methods and attributes in this section are made private. void operation2()   Code here   Private attribute. int attribute; ; www.allitebooks.com Software Design with Unified Modeling Language  47 Dependency In.a.class.diagram.the.dependency.relationship.rendered.as.a.dashed.line.and.stick.arrow.

--- Chunk 103 ---
Tokens: 400
Type: sentence-based
Text:
int attribute; ; www.allitebooks.com Software Design with Unified Modeling Language  47 Dependency In.a.class.diagram.the.dependency.relationship.rendered.as.a.dashed.line.and.stick.arrow. is.used.to.model.the.relationship.between.two.UML.classes.Dependency.models.the.rela- tionship.that.indicates.that.changes.to.one.class.affect.the.other.In.C.dependency.rela- tionship.may.translate.to.a.include.statement.as.seen.in.Listing.2.3. Association Associations.are.structural.relationships.that.is.they.affect.the.structure.of.UML.classes. In.a.class.diagram.associations.are.modeled.with.solid.lines.connecting.two.classes.as.seen. in.Figure 2.2.from.BaseClass.to.SampleClass.This.structural.relationship.indicates. that.a.connection.exists.between.associated.instances.at.run.time.Associations.are.bidirec- tional.by.default.When.using.bidirectional.associations.classes.on.each.end.of.the.associa- tion.are.structurally.modified.to.provide.navigation.to.their.associated.classes.providing. Listing 2.2: Java Code Generated from SampleClass Designed in Figure 2.2 class SampleClass   Public method. public void operation1()    Private method. private void operation2()    Private attribute. private int attribute;  Listing 2.3: C Code Generated for UML Dependency Relationship  The dependency relationship can result in code as a include. include IndependentClass.h class DependentClass   Other attributes. Other operations. ; 48  Software Engineering Design objects.of.one.type.ability.to.navigate.to.objects.of.another.type.and.vice.versa.Navigation. can. be. limited. to. one-way.by. modeling. the.

--- Chunk 104 ---
Tokens: 387
Type: sentence-based
Text:
the. association. relationship. with. a. directional. arrow.When.this.is.the.case.only.the.structure.of.one.class.is.modified.to.provide.navi- gational.capabilities.to.the.other.In.C.the.structural.modification.resulting.from.using. associations.is.presented.in.Listing.2.4.As.seen.the.association.from.WholeClass.and. ConcreteClass.may.translate.to.a.pointer.type. Aggregation Aggregation.is.a.specialized.form.of.association.to.denote.a.wholepart.relationship.That.is. aggregation.can.be.seen.as.association.with.special.semantics.for.modeling.that.one.object. is.part.of.another.This.added.semantic.is.purely.conceptual.and.its.use.is.constrained.to. design.time.that.is.forward-engineered.aggregation.relationships.may.translate.to.code.in. the.same.way.that.associations.are.translated.Therefore.aggregation.is.used.to.increase.the. communication.language.at.design.time.Aggregation.is.modeled.using.an.association.line. with.a.hollow.diamond.at.one.end.Similar.to.association.aggregation.can.be.made.direc- tional.as.seen.in.Figure 2.2.When.aggregation.is.used.the.class.connected.to.the.diamond. part.of.the.aggregation.arrow.is.said.to.be.the.whole.and.the.one.connected.to.the.arrow.is. the.part.As.seen.in.Listing.2.4.aggregation.may.not.be.differentiable.from.association.in. code.since.both.associations.and.aggregation.can.translate.the.same.way.in.code. Composition Object.composition.is.a.specialized.form.of.aggregation.used.to.model.ownership.rela- tionship.Similar. to.aggregation. object.composition.models.a.wholepart.relationship.

--- Chunk 105 ---
Tokens: 360
Type: sentence-based
Text:
object.composition.models.a.wholepart.relationship. Listing 2.4: C Code Generated for UML Association Relationship include PartClassA.h include ConcreteClass.h class WholeClass   Code here. private:  Association relationship. ConcreteClass pConcrete;  Aggregation relationship. PartClassA pPartA; ; Software Design with Unified Modeling Language  49 however.unlike.aggregation.composition.provides.deeper.semantics.to.indicate.that.the. lifetime.of.the.part.is.owned.by.the.whole.Therefore.when.the.whole.object.goes.out.of. scope.so.does.the.part.In.UML.object.composition.is.modeled.similarly.to.aggregation. but.instead.of.using.a.hollow.diamond.a.solid.diamond.is.used.In.code.object.composition. can.be.manifested.in.different.ways.For.example.Listing.2.5.presents.the.forward.engi- neering.(using.C).of.some.designed.EventLogger.class.which.is.used.to.log.events. in.a.system. As.seen.the.EventLogger.will.own.at.run.time.an.instance.of.the.File.class.there- fore.once.the.EventLogger.goes.out.of.scope.so.will.the.instance.of.the.File.class. This.relationship.can.be.translated.differently.in.C.via.pointers.Listing.2.6.presents. the.forward.engineering.of.the.EventLogger.class.with.a.different.manifestation.of.the. object.composition.relationship. As. seen. object. composition. is. achieved. using. a. different. approach. that. creates. and. destroys.the._file.object.It.is.important.to.emphasize.once.again.that.UML.is.a.flexible.

--- Chunk 106 ---
Tokens: 400
Type: sentence-based
Text:
destroys.the._file.object.It.is.important.to.emphasize.once.again.that.UML.is.a.flexible. language.therefore.forward.engineering.of.UML.models.can.be.realized.differently.by.dif- ferent.tools.and.different.programming.languages.For.example.association.aggregation. and.object.composition.can.all.look.different.in.other.object-oriented.languages.such.as. Java.and.C.which.have.no.pointer.notation. Generalization Generalization.is.a.relationship.that.denotes.inheritance.that.is.one. (child).class.inher- its.the.structure.and.behavior.of.another.(parent).class.Child.classes.can.reuse.services. provided. by. parent. classes. override. these. services. or. add. entirely. new. ones. In. class. .diagrams.generalization.is.modeled.using.a.solid.line.with.a.hollow.arrowhead.connecting. two.classes.as.seen.in.Figure 2.2.Generalization.always.translates.to.code.as.inheritance. as.seen.in.Listing.2.7. Listing 2.5: C Code Generated for UML Composition Relationship  Object composition requires this dependency. include File.h class EventLogger   Code here. private: The Object Composition Relationship. File _file; ; 50  Software Engineering Design Realization Whereas.generalization.allows.classes.to.inherit.a.parents.class.interface.and.behavior. realization.allows.classes.to.inherit.the.interface.Realization.is.used.to.model.a.contract. relationship.in.which.one.class.specifies.an.interface.contract.and.another.buys.into.that. contract.When.realization.is.used.classes.that.realize.interfaces.are.required.by.contract. to. provide. implementations. for. those. interfaces. before. objects. of.

--- Chunk 107 ---
Tokens: 344
Type: sentence-based
Text:
of. those. classes. can. be. instantiated.In.UML.realization.is.modeled.using.a.dashed.line.with.a.hollow.arrowhead. Listing 2.6: C Code Generated for UML Composition Relationship include File.h class EventLogger   Constructor. EventLogger()   Instantiate the message object during initialization. _file  new File;   Destructor. EventLogger()   Because of UML composition relationship, once the this object  goes out of scope, so does the _file object. delete _file;  private:  Object composition via pointers. File _file; ; Listing 2.7: C Implementation for UML Generalization Relationship include BaseClass.h  Generalization results in inheritance. class DerivedClass : public BaseClass   Code here. ; Software Design with Unified Modeling Language  51 connecting.two.classes.In.code.realization.can.translate.in.different.ways.depending.on. the.target.programming.language.however.the.semantics.remain.the.same.In.the.code. context.an.interface.is.the.collection.of.public.methods.that.define.the.services.provided. by.class.In.C.interfaces.are.created.using.pure.virtual.methods.as.seen.in.Listing.2.8. As.seen.the.Gps.class.is.made.up.of.two.pure.virtual.methods.which.means.that.objects. of.the.Gps.class.cannot.be.instantiated.the.Gps.class.is.typically.referred.to.as.an.interface. to.define.a.common.set.of.services.in.this.case.global.positioning.system.(GPS).services.

--- Chunk 108 ---
Tokens: 388
Type: sentence-based
Text:
to.define.a.common.set.of.services.in.this.case.global.positioning.system.(GPS).services. Similar.to.all.other.relationships.discussed.so.far.the.realization.relationship.trans- lates.different.in.different.languages.In.C.the.realization.relationship.translates.iden- tical.to.the.generalization.relationship.As.seen.in.Listing.2.9.the.forward.engineering. Listing 2.8: C Code Generation for Interfaces class Gps  public:  The interface method to obtain latitude information. virtual double getLatitude()  0;  The start interface method. virtual double getLongitude()  0; ; Listing 2.9: C Implementation for UML Realization Relationship include Gps.h  SimulatedGps realizes the Gps interface. class SimulatedGps : public Gps  public:  The interface method to obtain latitude information. double getLatitude()   Generate a sample latitude and return. The interface method to obtain longitude information. double getLongitude()   Generate a sample longitude and return. ; 52  Software Engineering Design of. the. SimulatedGps. class. results. in. inheritance. with. provided. methods. for. both. interface methods. Gps. services. can. be. realized. by. different. Gps. classes. differently. for. example. one. derived.Gps.class.(e.g.HardwareGps).may.realize.the.Gps.interface.by.providing.code. that.interfaces.with.specific.hardware.to.obtain.actual.readings.for.latitude.and.longi- tude.Another.derived.Gps.class.(e.g.SimulatedGps).can.realize.the.Gps.interface.by. providing.code.that.simulates.latitude.and.longitude.readings.in.case.the.Gps.hardware.

--- Chunk 109 ---
Tokens: 367
Type: sentence-based
Text:
providing.code.that.simulates.latitude.and.longitude.readings.in.case.the.Gps.hardware. is.not.available.By.designing.such.framework.(i.e.Gps.interface.HardwareGps.and. SimulatedGps).clients.can.create.their.designs.relying.on.using.the.Gps.interface.by. relying.on.a.well-defined.interface.objects.of.type.HardwareGps.or.SimulatedGps. can.be.swapped.without.ever.having.to.change.the.client.code. Interfaces.and.the.realization.relationship.are.so.essential.to.object-oriented.systems.that. modern.languages.include.keywords.to.support.this.relationship.In.Java.the.forward.engi- neering.of.the.Gps.interface.translates.to.an.interface.as.seen.in.Listing.2.10. The. forward. engineering. of. the. realization. relationship. in. Java. results. in. a. class. that. implements. and. interface. Listing. 2.11. presents. the. forward. engineering. of. the. .realization.relationship.for.the.SimulatedGps.class.in.Java. Listing 2.10: Java Code Generated for Interfaces interface Gps   The interface method to obtain latitude information. public double getLatitude();  The interface method to obtain longitude information. public double getLongitude();  Listing 2.11: Java Code Generated for UML Realization Relationship class SimulatedGps implements Gps   The interface method to obtain latitude information. public double getLatitude()   Generate a sample latitude and return. The start interface method. public double getLongitude()   Generate a sample longitude and return.

--- Chunk 110 ---
Tokens: 386
Type: sentence-based
Text:
public double getLongitude()   Generate a sample longitude and return. Software Design with Unified Modeling Language  53 Skill Development 2.1: Modeling Structure with Class Diagrams Using.pencil.and.paper.create.the.class.diagram.that.models.the.following.relation- ships.Class.B.inherits.from.class.A.Class.B.is.directionally.associated.with.class.F.and. has.a.special.wholepart.relationship.with.class.C.so.that.when.B.goes.out.of.scope. so.does.C.Class.B.has.another.wholepart.relationship.with.class.D.which.depends. on.interface.E.When.class.B.goes.out.of.scope.D.remains.active.as.an.object.during. run.time.Both.classes.G.and.H.realize.the.E.interface.When.done.replace.the.class. names.A.B.C.D.E.F.G.and.H.with.names.that.represent.types.appropriate.for.these. relationships.Discuss.your.results.with.your.peers. DEPLOYMENT DIAGRAMS Deployment. diagrams. are. structural. diagrams. used. to. model. the. physical. realization. of.software.systems.They.provide.the.means.for.visualizing.the.environment.in.which. software.executes.and.how.different.entities.communicate.with.each.other.to.achieve.the. .systems.functions.Deployment.diagrams.provide.a.static.holistic.view.of.the.software. system.from.the.deployment.perspective.by.providing.avenues.for.modeling.and.speci- fication.of.the.physical.nodes.software.artifacts.and.the.interrelationship.among.them. A.node.is.a.computational.resource.that.host.software.artifacts.for.execution.(UML.2.3. Superstructure.2010).In.UML.nodes.are.named.classifiers.modeled.as.a.cube.Nodes.can.be.

--- Chunk 111 ---
Tokens: 394
Type: sentence-based
Text:
Superstructure.2010).In.UML.nodes.are.named.classifiers.modeled.as.a.cube.Nodes.can.be. associated.with.other.nodes.to.model.the.communication.path.between.them.these.com- munication.paths.can.be.enhanced.with.stereotypes.multiplicity.and.other.adornments. to.further.specify.their.properties.and.constraints.For.example.in.Figure 2.3.communi- cation.paths.are.enhanced.by.specifying.the.communication.protocol.(e.g.Transmission. Control.ProtocolInternet.Protocol.TCPIP.Universal.Serial.Bus.USB.and.ZigBee). In.addition.multiplicity.is.used.to.model.the.number.of.elements.connected.to.other. .elements.As.seen.there.is.a.plurality.of.sensor.nodes.connected.to.the.embedded.client. computer. via. the. ZigBee. wireless. protocol. This. deployment. diagram. also. models. the. optional.use.of.mobile.devices.in.the.system.that.is.the.embedded.client.computer.may. or.may.not.have.mobile.devices.interfacing.to.it.Nodes.can.also.be.modeled.as.hosts.by. including.the.components.that.execute.in.the.node.and.their.manifestation.as.artifacts. Artifacts.are.used.to.model.physical.units.of.information.that.form.part.of.the.software. system.such.as.binary.executable.files.configuration.files.and.scripts.Artifacts.are.modeled. using.the.artifact.keyword.and.can.be.related.to.nodes.components.and.other.arti- facts.using.the.dependency.relationship.as.seen.in.Figure 2.3.Artifacts.that.collaborate.with. other.artifacts.can.be.modeled.using.the.dependency.relationship.To.model.the.deployment. relationship.artifacts.are.connected.to.nodes.using.the.dependency.relationship.with.the.

--- Chunk 112 ---
Tokens: 393
Type: sentence-based
Text:
relationship.artifacts.are.connected.to.nodes.using.the.dependency.relationship.with.the. deploy.stereotype.When.connected.this.way.it.is.said.that.the.artifact.is.deployed.on. the.node.connected.to.the.other.end.of.the.dependency.relationship.When.necessary.the. 54  Software Engineering Design manifestation.of.components.(designed.in.component.diagrams).on.a.target.node.can.be. modeled.using.the.dependency.relationship.from.the.artifact.to.the.component.with.the. manifest.stereotype. Together.the.concepts.of.nodes.relationships.and.artifacts.can.be.used.to.create.deploy- ment.diagrams.that.include.the.physical.nodes.where.software.is.deployed.communica- tion.paths.between.nodes.software.artifacts.executing.on.nodes.and.the.manifestation.of. software.components.within.the.software.artifacts.as.seen.in.Figure 2.3. NodeA SensorNode Wireless 3G Card MobilePhone DatabaseServer EmbeddedClientComputer VideoNode NodeB artifact ArtifactA Association Deployment Diagram Relationships deploy manifest manifest deploy manifest TCPIP ZigBee USB 1 1 1 1 TCPIP TCPIP 0. 1 artifact ClientCollectionSystem.exe TCPIP 1. 1. 1 1 1 1 Dependency NodeB artifact ArtifactA component ComponentA component ClientCollectionSystem component ServerMonitorSystem ApplicationServer artifact MonitorSystem.exe artifact ArtifactA artifact ArtifactB Sample Deployment Diagram FIGURE 2.3 Overview.of.UML.deployment.diagram. Software Design with Unified Modeling Language  55 BEHAVIORAL MODELING Structural. modeling. is. essential. to. evaluate. characterize. and. visualize. the. structural.

--- Chunk 113 ---
Tokens: 388
Type: sentence-based
Text:
structural. design.of.software.systems.from.various.perspectives.These.static.diagrams.provide.good. avenues.for.analyzing.properties.that.are.the.direct.result.of.structural.designs.such.as. their.ability.to.meet.functional.requirements.reusability.and.maintainability.however. they.are.not.adequate.for.modeling.the.inherent.complexities.present.in.the.behavioral. aspects.of.software.systems.For.this.reason.behavioral.diagrams.are.necessary.to.models. and.specify.the.dynamic.aspects.and.evaluate.the.quality.attributes.related.to.the.system. behavior.To this.end.UML.provides.several.diagrams.that.can.be.used.to.model.impor- tant.behavioral.aspects.of.software.These.are.presented.in.Table 2.7. Table 2.7.does.not.present.an.exhaustive.list.of.UML.behavioral.diagrams.However.these. diagrams.can.be.used.to.model.almost.any.behavioral.aspect.of.modern.software.systems. and.their.use.is.ubiquitous.in.practical.development.efforts.Therefore.their.understanding. and.applicability.must.be.well.understood.Other.diagrams.such.as.timing.and.interaction. overview.diagrams.are.not.covered.here. USE CASE DIAGRAMS Use.case.diagrams.are.behavioral.diagrams.used.to.capture.specify.and.visualize.required. system.behavior.The.main.elements.of.use.case.diagrams.are.actors.use.cases.and.the. relationships.connecting.them.together.Actors.are.entities.used.to.model.users.or.other. systems.that.interact.with.the.system.being.modeled.(i.e.the.subject).that.is.operators. using.the.system.sensors.providing.information.and.a.client.computer.in.a.clientserver.

--- Chunk 114 ---
Tokens: 380
Type: sentence-based
Text:
using.the.system.sensors.providing.information.and.a.client.computer.in.a.clientserver. system.can.all.be.modeled.as.actors.Use.cases.are.entities.used.in.use.case.diagrams.to. TABLE 2.7 UML.2.3.Behavioral.Diagrams Diagram Description Use.case.diagram Used.to.capture.specify.and.visualize.required.system.behavior. (i.e.requirements) Sequence.diagram Used.to.capture.specify.and.visualize.system.interactions.with.emphasis.on.the. time-order.sequence.of.messages.exchanged Communication.diagram Used.to.capture.specify.and.visualize.system.interactions.with.emphasis.on.the. structural.order.of.entities.participating.in.the.message.exchange State.machine.diagram Used.to.capture.specify.and.visualize.system.behavior.as.a.set.of.discrete.states. and.the.transitions.between.them Activity.diagram Used.to.capture.specify.and.visualize.system.behavior.provide.mechanisms.for. modeling.that.includes.conditional.statements.repetition.concurrency.and. parallel.execution.and.thus.can.be.used.at.many.different.levels.of.abstraction. from.modeling.business.work.flows.to.code 56  Software Engineering Design specify.the.required.behavior.of.a.system.Therefore.they.provide.the.means.necessary.to. capture.model.and.visualize.the.requirements.of.a.system. Use.case.modeling.provides.an.avenue.for.presenting.a.holistic.view.of.the.system.to. be. designed. and. increasing. communication. among. stakeholders. before. more. detailed. approaches. to. design. can. begin. For. example. Figure 2.4. presents. a. use. case. diagram.

--- Chunk 115 ---
Tokens: 390
Type: sentence-based
Text:
diagram. for.a.clientserver.system.The.system.interacts.with.both.an.operator.and.server.and.is. required.to.provide.the.operator.with.the.capability.for.searching.for.a.product.updating. the.product.displaying.the.location.of.the.product.and.receiving.notifications.from.the. server.In.addition.the.client.system.is.required.to.check.for.software.updates.Collectively. these.use.cases.together.with.the.actors.and.relationships.capture.the.requirements.of.the. Actor Operator Use Case A Use Case A Use Case A Search Product Use Case B Use Case B Use Case B Use Case B Common Use Case Diagram Relationships Use Case Diagram Client System Association include extend Generalization Update Product Update Software Display Location Receive Notication Server FIGURE 2.4 Sample.UML.use.case.diagram.and.common.relationships. Software Design with Unified Modeling Language  57 system.and.provide.a.context.for.the.development.of.the.client.system.In.UML.use.cases. are.modeled.using.a.named.ellipsis.and.actors.as.stick.figures.as.seen.in.Figure 2.4. As.seen.the.association.relationship.is.used.to.model.the.link.between.actors.and.use. cases.however.other.relationships.such.as.include.extend.and.generalization. can.be.used.to.include.extend.and.generalize.respectively.other.use.cases.In.addition. a.system.boundary.is.used.to.delineate.the.boundaries.of.the.client.system.within.context. of.other.relevant.actors.Use.case.diagrams.provide.a.valuable.means.for.establishing.a. framework.for.eliciting.requirements.identifying.major.system.functions.and.specifying.

--- Chunk 116 ---
Tokens: 386
Type: sentence-based
Text:
framework.for.eliciting.requirements.identifying.major.system.functions.and.specifying. the.context.of.the.subject.being.modeled. Skill Development 2.2: Modeling Behavior with Use Cases Consider.what.you.think.the.five.most.important.functions.that.your.home.personal. computer.system.needs.to.provide.Using.pencil.and.paper.create.a.use.case.diagram. that.depicts.the.personal.computer.system.its.five.major.functions.and.the.interaction. between.you.and.the.computing.system.For.one.of.the.created.use.cases.create.a.list.of. detailed.steps.that.you.think.the.computer.needs.to.do.internally.to.achieve.the.speci- fied.behavior. INTERACTION DIAGRAMS Interaction.diagrams.exist.at.lower.levels.of.abstraction.than.use.case.diagrams.and.can. be.used.extensively.during.the.complete.life.cycle.of.software.projects.At.the.architectural. (system).level.interaction.diagrams.can.be.used.for.modeling.interactions.among.software. components.during.detailed.design.they.provide.interaction.modeling.capabilities.among. objects.at.run.time.and.at.the.construction.level.they.can.be.used.to.model.collaborative. algorithms.that.include.conditional.and.repetition.structures.such.as.loops.Interaction. diagrams.are.popular.because.they.provide.avenues.for.modeling.complex.interactions. among.software.units.together.with.the.messages.exchanged.and.the.type.of.the.exchange. By.modeling.the.interactions.required.to.realize.a.particular.system.function.designers. can.determine.if.current.structural.diagrams.are.adequate.to.support.the.system.this.gives.

--- Chunk 117 ---
Tokens: 382
Type: sentence-based
Text:
can.determine.if.current.structural.diagrams.are.adequate.to.support.the.system.this.gives. designers.the.ability.to.model.interactions.for.which.the.capability.of.the.structural.design. to.meet.its.functional.and.quality.requirements.may.be.in.question.In.these.cases.inter- action.diagrams.can.serve.as.validation.tool.before.construction.can.begin.In.many.situa- tions.interaction.diagrams.can.reveal.many.important.issues.related.to.the.overall.quality. of.the.system. (e.g.performance).Two.types.of.interaction.diagrams.are . Communication.diagrams . Sequence.diagrams 58  Software Engineering Design Communication Diagrams Communication.diagrams.are.behavioral.diagram.used.to.capture.specify.evaluate.and. visualize.system.interactions.with.emphasis.on.the.structural.order.of.entities.participating. in.the.message.exchange.When.using.communication.diagrams.entities.can.be.modeled. as.objects.representing.instances.of.classes.or.as.roles.representing.prototypical.instances.of. other.entities.such.as.classes.and.components.(Booch.et.al.2005).Both.objects.and.roles. can.be.connected.to.model.the.exchange.of.messages.using.links.or.connectors.respectively. As seen.in.Figure 2.5.a.role.is.modeled.using.a.named.box. (similar.to.a.class).without.under- lining.the.roles.type.In.addition.roles.can.be.named.or.anonymous.as.seen.in.Figure.2.5. On.the.other.hand.objects.are.modeled.using.similar.notation.but.the.name.of.the.object. is.underlined.In.many.practical.situations.designers.are.interested.in.modeling.how.roles.

--- Chunk 118 ---
Tokens: 365
Type: sentence-based
Text:
is.underlined.In.many.practical.situations.designers.are.interested.in.modeling.how.roles. interact.with.each.other.to.model.a.system.behavior.and.not.on.how.individual.objects. interact.For.these.situations.roles.provide.the.appropriate.modeling.entity.When.using. roles.for.modeling.behavior.they.can.be.connected.using.a.solid.connector.line.to.represent. : FileSystemMgr db : EventLogger synchronous message Communication Modeling Object-Based Communication : FileSystemMgr db : EventLogger asynchonous message fs : FileSystemMgr el : EventLogger synchronous message fs : FileSystemMgr cm : CommMgr 1 : put(msg) 2 : decodeMsg() 4 : format(fast) 3 : log(received,msgId) 5 : log(success) am : AppMgr el : EventLogger fs : FileSystemMgr el : EventLogger asynchronous message FIGURE 2.5 Sample.UML.communication.diagram. Software Design with Unified Modeling Language  59 a.prototypical.connection.between.roles.Similarly.when.using.objects.their.connection. is. made. using. links. which. represent. an. instance. of. an. association. (Booch. et al. 2005). Connectors.and.links.look.exactly.alike.and.differ.only.semantically. To.model.the.message.exchanges.in.communication.diagrams.messages.in.the.form.of. arrows.are.used.Two.common.types.of.messages.include.synchronous.and.asynchronous. messages.Synchronous.messagesmodeled.using.a.solid.arrowheadare.used.to.model. interactions.in.which.both.sender.and.receiver.work.in.lock-step.to.achieve.an.operation.

--- Chunk 119 ---
Tokens: 391
Type: sentence-based
Text:
interactions.in.which.both.sender.and.receiver.work.in.lock-step.to.achieve.an.operation. Asynchronous.messagesmodeled.using.a.stick.arrowmodel.interactions.that.are.car- ried.out.by.receivers.independently.from.the.sender.That.is.upon.sending.an.asynchro- nous.message.the.sender.continues.working.while.the.receiver.carries.out.the.message. request.The.main.elements.present.in.communication.diagrams.together.with.sample. object-based.communication.diagram.design.are.presented.in.Figure 2.5. The.communication.diagram.presented.in.Figure 2.5.models.a.system.receiving.a.message. to.initiate.a.file.system.format.As.seen.the.cm.object.sends.a.message.to.the.application. manager.object.am.which.decodes.the.message.logs.the.receipt.of.the.message.by.sending. a.message.to.the.event.logger.object.el.and.initiates.a.format.by.sending.a.message.to.the. file.system.manager.object.fs.Once.finished.formatting.the.file.system.the.fs.object.logs. an.event.All.messaging.in.the.communication.is.done.synchronously.using.links. Sequence Diagrams Sequence.diagrams.are.behavioral.diagrams.used.to.capture.specify.and.visualize.system. interactions.with.emphasis.on.the.time-order.sequence.of.messages.exchanged.Sequence. diagrams.are.closely.related.to.communication.diagrams.Therefore.many.of.the.modeling. techniques.are.the.same.that.is.sequence.diagrams.include.objects.roles.synchronous. and.asynchronous.messages.Sequence.diagrams.put.emphasis.on.the.time.order.of.mes- sages.by.introducing.a.lifeline.and.activation.bar.Lifelines.are.modeled.with.the.objectrole.

--- Chunk 120 ---
Tokens: 400
Type: sentence-based
Text:
and.asynchronous.messages.Sequence.diagrams.put.emphasis.on.the.time.order.of.mes- sages.by.introducing.a.lifeline.and.activation.bar.Lifelines.are.modeled.with.the.objectrole. connected.to.a.vertical.dashed.line.that.represents.the.lifetime.of.the.objectrole.Typically. objectsroles.in.a.sequence.diagram.are.aligned.from.left.to.right.depending.on.the.order. in.which.messages.are.sent.Once.a.message.is.sent.the.activation.bar.is.rendered.on. the.objects.lifeline.to.model.the.relative.processing.time.that.results.from.the.message. exchange.Asynchronous.and.synchronous.messaging.are.modeled.similar.to.communica- tion.diagrams.and.return.messages.can.be.modeled.using.a.dashed.line.with.a.stick.arrow. Figure 2.6.presents.an.equivalent.sequence.diagram.for.the.formatting.operation.modeled. with.a.communication.diagram.in.Figure 2.5. Concurrency in Interaction Diagrams In.previous.sections.the.discussion.on.messaging.in.interaction.diagrams.eluded.the.topic. of.concurrency.When.using.the.synchronous.mode.of.communication.an.implication.is. not.made.as.to.the.presence.of.independent.flows.of.execution.however.the.same.is.not. true.for.asynchronous.communications.As.explained.before.the.asynchronous.mode.of. communication.provides.the.ability.to.model.independent.flows.of.execution.since.the. 60  Software Engineering Design sender.of.an.asynchronous.message.continues.on.executing.while.the.receiver.carries.out. the.work.requested.Typically.independent.flows.of.executions.are.manifested.as.multiple. processes.or.threads.When.applications.are.multiprocessed.or.multithreaded.concurrency.

--- Chunk 121 ---
Tokens: 382
Type: sentence-based
Text:
processes.or.threads.When.applications.are.multiprocessed.or.multithreaded.concurrency. issues.arise.when.they.execute.in.parallel.(or.pseudo-parallel).with.each.other.Therefore. it is.important.to.model.concurrent.design.issues.so.that.their.impacts.are.well.understood. before.construction.begins. Concurrent.designs.require.designers.to.decompose.applications.into.multiple.processes. or.threads.to.meet.performance.(e.g.usability.throughput).requirements.Processes.can. execute.concurrently.with.other.processes.while.threads.can.execute.concurrently.with. other.threads.(within.the.same.process).The.importance.of.modeling.concurrent.designs.up. front.is.often.overlooked.in.many.design.efforts.that.is.too.much.concurrency.can.end.up. degrading.the.systems.while.insufficient.concurrency.results.in.decreased.systems.through- put.(Booch.et.al.2005).Developing.these.systems.requires.skills.typically.acquired.through. : Operator 1 : asyncMessage objectA : ClassA objectB : ClassB 2 : selfMessage() 3 : syncMessage() 5 : returnMessage 4 : syncMessage() General Sequence Diagram Applied Sequence Diagram 1 : put(msg) 7 : return status am : AppMgr cm : CommMgr el : EventLogger fs: FileSystemMgr 2 : msgId : decodeMsg() 3 : log(received,msgId) 4 : format(fast) 6 : return status 5 : log(success) FIGURE 2.6 UML.sequence.diagram. Software Design with Unified Modeling Language  61 experience.therefore.novice.designers.are.encouraged.to.create.concurrency.models.and. when.possible.to.have.more.experienced.personnel.review.them.

--- Chunk 122 ---
Tokens: 381
Type: sentence-based
Text:
when.possible.to.have.more.experienced.personnel.review.them. UML.provides.the.necessary.mechanisms.to.model.independent.flows.of.controls.such.as. processes.or.threads.using.the.concept.of.an.active object.within.sequence.and.communica- tion.diagrams.Active.objects.are.represented.in.UML.as.an.instance.of.an.active.class.with. certain.concurrency.semantics.to.aid.in.the.synchronization.of.interactions.among.inde- pendent.flows.(Booch.et.al.2005).Models.that.include.active.objects.can.be.used.to.reason. about.quality.issues.that.deal.with.concurrency.communication.and.synchronization.An. .example.of.a.concurrent.system.is.presented.in.Figure 2.7.using.a.communication.diagram. In.this.diagram.objects.are.modeled.as.active.objects.by.adding.double.lines.to.the.left. and.right.side.of.the.objects.rectangle.This.denotes.independent.flows.of.execution.and. ability.to.initiate.control.activity.The.model.is.also.enhanced.by.using.the.location.tagged value.to.specify.the.location.of.the.running.processes. 3 : powerOn() 4 : powerOn() 5 : forwardStatus() 6 : postResults( ) 1 : SystemOn( ) Interprocess Communication Active Object process systemMgr : SystemManager stereotype activeObject : ActiveClass taggedValue  value process serverMgr : SystemManager location  server process manager : SiteManager location  client laptop process nodeOne : SensorNode location  sensor node process nodeTwo : SensorNode location  sensor node location  client PC 2 : forwardCommand() FIGURE 2.7 Sample.UML.interprocess.communication.

--- Chunk 123 ---
Tokens: 398
Type: sentence-based
Text:
3 : powerOn() 4 : powerOn() 5 : forwardStatus() 6 : postResults( ) 1 : SystemOn( ) Interprocess Communication Active Object process systemMgr : SystemManager stereotype activeObject : ActiveClass taggedValue  value process serverMgr : SystemManager location  server process manager : SiteManager location  client laptop process nodeOne : SensorNode location  sensor node process nodeTwo : SensorNode location  sensor node location  client PC 2 : forwardCommand() FIGURE 2.7 Sample.UML.interprocess.communication. 62  Software Engineering Design The.model.in.Figure 2.7.relies.on.active.objects.asynchronous.and.synchronous.mes- sages.to.properly.model.the.interprocess.operations.in.a.multiprocess.distributed.system. As.seen.the.system.is.composed.of.five.processes.executing.in.different.locations.namely. the.client.PC.server.client.laptop.and.embedded.sensor.nodes.The.model.uses.asynchro- nous.messages.from.the.client.PC.to.the.server.and.from.the.server.to.the.client.laptop.to. communicate.to.initiate.a.power.on.sequence.of.the.embedded.sensor.nodes.This.makes. sense.because.of.the.nature.of.a.distributed.system.Remember.that.asynchronous.messages. allow.the.sender.to.continue.operation.(and.not.block).waiting.for.the.message.response. In.this.case.the.client.PC.will.send.a.systemOn.message.to.the.distributed.system.and. continue.serving.operators.without.waiting.for.a.response.to.come.back.Communication. between.server.and.client.laptop.is.done.in.a.similar.fashion.however.communication. between.the.client.laptop.and.embedded.sensor.nodes.occurs.in.synchronous.fashion.That.

--- Chunk 124 ---
Tokens: 396
Type: sentence-based
Text:
between.the.client.laptop.and.embedded.sensor.nodes.occurs.in.synchronous.fashion.That. is.once.a.systemOn.message.is.received.the.client.laptop.will.synchronously.power.up.sen- sor.node.one.control.returns.back.once.the.power.up.operation.is.complete.at.which.point. it.can.initiate.the.power.on.message.to.sensor.node.two.When.both.sensor.nodes.are.up. status.is.returned.asynchronously.from.the.site.manager.to.the.system.manager. Concurrent.designs.that.work.on.the.same.data.are.tougher.to.manage.since.they.can. lead.to.errors.that.are.hard.to.find.during.construction.When.this.happens.access.to. shared.sections.of.data.needs.to.be.designed.properly.and.carefully.to.ensure.the.integrity. of.the.data.To.this.end.UML.provides.synchronization.properties.that.can.be.used.to. constrain.the.model.so.that.it.supports.concurrency.by.controlling.the.way.multiple.flows. of.execution.access.critical.sections.of.code.These.are.presented.in.Table 2.8. The. Sequential. synchronization. property. specifies. that. no. concurrency. management. mechanism. is. associated. with. an. operation. With. sequential. access. concurrency. con- flicts.may.occur.so.clients.that.rely.on.the.operation.need.to.coordinate.so.that.only.one. .invocation.occurs.at.any.given.point.The.Guarded.property.specifies.that.the.operation. can. be. invoked. from. multiple. independent. flows. simultaneously. but. only. one. flow. of. execution.is.allowed.to.commence.other.independent.flows.are.blocked.until.the.execu- tion.of.currently.executing.operation.under.the.currently.executing.thread.is.complete.

--- Chunk 125 ---
Tokens: 386
Type: sentence-based
Text:
execution.is.allowed.to.commence.other.independent.flows.are.blocked.until.the.execu- tion.of.currently.executing.operation.under.the.currently.executing.thread.is.complete. When.using.the.Guarded.synchronization.property.it.is.the.responsibility.of.the.designer. to.ensure.that.concurrency.issues.such.as.starvation.and.deadlocks.do.not.occur.Finally. TABLE 2.8 UML.Synchronization.Properties Synchronization Description Sequential No.concurrency.management.mechanism.are.associated.with.the.operation. Guarded Concurrency.management.mechanisms.are.in.place.so.that.operations.can.be.invoked. from.multiple.independent.flows.simultaneously.each.call.waits.for.the.previous.one.to. finish.execution. Concurrent Multiple.invocations.may.occur.simultaneously.and.all.of.them.may.proceed. concurrently. Software Design with Unified Modeling Language  63 the Concurrent.synchronization.property.specifies.that.multiple.invocations.may.occur. simultaneously.and.that.all.of.them.may.proceed.concurrently.Concurrent synchroni- zation.is.achieved.in.languages.with.built-in.support.for.concurrency.such.as.Java.with. the.use.of.the.synchronized.property.All.three.of.these.properties.can.be.modeled.as. .constraints.to.fully.specify.the.behavior.of.concurrent.systems. CHAPTER SUMMARY UML.is.a.visual.language.with.an.extensive.set.of.features.appropriate.for.designing.soft- ware.systems.across.a.broad.set.of.application.domains.The.current.version.of.UML.(2.3). provides.14.diagrams.for.structural.and.behavioral.modeling.of.software.systems.These.

--- Chunk 126 ---
Tokens: 396
Type: sentence-based
Text:
provides.14.diagrams.for.structural.and.behavioral.modeling.of.software.systems.These. diagrams.support.software.design.during.architectural.detailed.design.and.construction. design.activities.Since.UML.has.been.designed.with.flexibility.in.mind.it.is.important. to.understand.how.the.its.fundamental.building.blocks.(i.e.classifiers.relationships.and. enhancing.features).can.be.used.to.model.systems.of.disparate.capabilities.and.domains. While.some.UML.diagrams.provide.modeling.concepts.that.are.too.abstract.for.direct. translation. to. code. others. are. not. Therefore. it. is. essential. that. designers. understand. how.these.models.translate.to.code.and.how.they.are.used.to.model.quality.attributes. By.providing.a.unified.communication.language.for.software.design.UML.is.appropri- ate.and.efficient.for.capturing.and.conveying.information.that.can.be.evaluated.by.many. .stakeholders.including.customers.and.software.engineers.alike.resulting.in.a.more.effi- cient.design.process. REVIEW QUESTIONS . 1.What.is.UML.and.why.is.it.important.in.software.design? . 2.What.are.the.two.main.classifications.for.UML.diagrams.and.how.do.these.differ. from.one.another? . 3.List.and.explain.two.important.reasons.for.software.designers.to.study.UML. . 4.In.UML.context.what.are.classifiers.Provide.examples.of.classifiers. . 5.What.are.the.main.relationships.used.in.UML.diagrams.Provide.examples.of.each. . 6.List.and.explain.the.main.mechanisms.for.extending.UML. . 7.What.is.structural.modeling? . 8.Compare.and.contrasts.the.following: . a. Component.diagram . b. Class.diagram .

--- Chunk 127 ---
Tokens: 393
Type: sentence-based
Text:
b. Class.diagram . c. Deployment.diagram 64  Software Engineering Design . 9.Explain.the.following.relationships.and.show.how.they.are.modeled.in.component. diagrams: . a. Provided.and.required.interfaces . b. Assembly.connector . c. Delegates . 10.What.is.a.UML.artifact.How.are.artifacts.different.from.components? . 11.List.and.explain.the.main.compartments.of.UML.class. . 12.What.are.the.possible.types.of.visibility.that.can.be.used.in.items.of.class.diagrams. Explain. . 13.In.a.class.diagram.what.is.the.difference.between.the.following.relationships: . a. Generalization.vs.realization . b. Aggregation.vs.object.composition . c. Dependency.vs.association . 14.How.can.the.manifestation.of.software.components.in.a.deployed.environment.be. modeled.in.UML.Explain. . 15.In.a.UML.deployment.diagram.what.is.a.node? . 16.Compare.and.contrasts.the.following: . a. Use.case.diagram . b. Sequence.diagram . c. Communication.diagram . 17.What.is.the.difference.between.synchronous.and.asynchronous.messages? . 18.Explain.how.concurrency.issues.can.be.addressed.using.UML. . 19.Compare.and.contrasts.the.following: . a. Sequential.synchronization . b. Guarded.synchronization . c. Concurrent.synchronization CHAPTER EXERCISES . 1.Consider.the.software.design.of.a.car.in.a.racing.game.Use.a.software.modeling.tool. to.identify.the.major.components.of.the.car.define.the.components.interfaces.and. connect.all.components.the.way.you.think.provides.the.best.design.for.developing.the. car.Create.a.list.of.design.factors.that.influenced.the.final.cars.design.and.the.benefits.

--- Chunk 128 ---
Tokens: 385
Type: sentence-based
Text:
car.Create.a.list.of.design.factors.that.influenced.the.final.cars.design.and.the.benefits. provided.by.your.approach.When.done.ask.a.peer.to.do.the.same.and.compare.your. approach.and.final.results. . 2.Use.the.component.design.created.in.Exercise.1.to.design.the.classes.required.to.sup- port.the.components.interfaces.and.provided.services.Create.a.list.of.design.factors. that.influenced.the.final.cars.design.and.the.benefits.provided.by.your.approach. When.done.ask.a.peer.to.do.the.same.and.compare.your.approach.and.final.results. Software Design with Unified Modeling Language  65 . 3.Create.a.UML.class.diagram.containing.the.following.information. Class Name Operations Attributes Relationships Name Type Return Name Visibility Return Name Visibility Inherits.from. ClassZ.and. uses. aggregation. with.ClassT ClassA Class void operation1 public char x private int operation2 private bool y protected ClassB Interface void operation3 public None Depends.on. ClassA.and.is. associated.with. ClassO.using.a. directional. association void operation4 public ClassC Class none None Realizes.ClassB. and.is. composed.of. ClassA . 4.Matt.and.Alice.are.starting.a.bed-and-breakfast.in.a.small.Virginia.town.They.will. have.three.bedrooms.for.guests.They.want.a.system.to.manage.the.reservations.and. to.monitor.expenses.and.profits.When.a.potential.customer.calls.for.a.reservation. they.will.check.the.calendar.and.if.there.is.a.vacancy.they.will.enter.the.customer. name.address.phone.number.dates.agreed.upon.price.credit.card.number.and.

--- Chunk 129 ---
Tokens: 399
Type: sentence-based
Text:
name.address.phone.number.dates.agreed.upon.price.credit.card.number.and. room.number.To.facilitate.reservations.the.system.needs.to.print.weekly.schedules. including.available.rooms.their.locations.price.and.special.rates.Reservations.must. be.guaranteed.by.one.days.payment.Reservations.will.be.held.without.guarantee.for. an.agreed.upon.time.If.not.guaranteed.by.that.date.the.reservation.will.be.dropped. Create.a.UML.use.case.diagram.using.a.system.boundary.for.this.system. REFERENCES Booch.Grady.Robert.A.Maksimchuk.Michael.W.Engle.Bobbi.J.Young.Jim.Conallen.and.Kelli.A.Houston. Object-Oriented Analysis and Design with Applications. Upper. Saddle. River. NJ. Addison-Wesley. Professional.2007. Booch.Grady.James.Rumbaugh.and.Ivar.Jacobson.The Unified Modeling Language User Guide.Santa.Clara. CA.Addison-Wesley.2005. Qian.Kai.Xiang.Fu.Lixin.Tao.Chong-Wei.Xu.and.Jorge.L.Diaz-Herrera.Software Architecture and Design Illuminated.Sudbury.MA.Jones.Barlett.2009. UML.2.3.Superstructure.Vers.2.3.Object.Management.Group.May.2010.Available.from.http:www.omg.org. 67 3 Principles of Software Architecture CHAPTER OBJECTIVES . Understand. the. role. of. software. architecture. within. the. software. design.phase . Become.familiar.with.architectural.tasks.and.problem.solving.during. architecture . Understand.the.importance.and.role.of.architectural.views.in.software. architecture . Become.familiar.with.the.software.architecture.process . Become.familiar.with.the.concept.of.architecture.evaluation CONCEPTUAL OVERVIEW The.software.architecture.activity.corresponds.to.a.macrodesign.approach.

--- Chunk 130 ---
Tokens: 400
Type: sentence-based
Text:
Become.familiar.with.the.concept.of.architecture.evaluation CONCEPTUAL OVERVIEW The.software.architecture.activity.corresponds.to.a.macrodesign.approach. for.transforming.software.requirements.into.design.elements.that.support. quality.and.functions.of.software.systems.During.software.architecture. perspectives. appropriate. for. modeling. particular. concerns. are. identified. and.design.elements.created.to.address.those.concerns.These.design.ele- ments.present.systems.from.different.perspectives.thus.providing.stake- holders.with.different.background.and.expertise.the.means.to.evaluate.the. appropriateness.of.architectural.decisions.for.supporting.the.construction. of.the.desired.system.The.software.architecture.activity.places.emphasis. on.systems.quality.and.therefore.provides.the.earliest.means.for.ensur- ing.that.identified.quality.goals.are.evaluated.and.incorporated.into.the. design.before.moving.on.to.more.detailed.design.and.construction.work. The.software.architecture.lays.the.foundation.for.all.subsequent.work.in.the. development.process.and.serves.as.an.important.communication.reason- ing.and.analysis.tool.for.developing.and.maintaining.software.systems. 68  Software Engineering Design WHAT IS SOFTWARE ARCHITECTURE? In.a.broad.context.software.architecture.refers.to.both.the.process.and.design.products. required.to.systematically.build.software.systems.that.meet.their.intended.functions.and. quality.Of course.such.broad.definition.of.software.architecture.leaves.out.many.of.the. details.that.make.architecture.essential.in.designing.todays.complex.software.systems.

--- Chunk 131 ---
Tokens: 396
Type: sentence-based
Text:
details.that.make.architecture.essential.in.designing.todays.complex.software.systems. To.understand.the.meaning.and.importance.of.software.architecture.it.helps.to.examine. how.other.engineering.disciplines.employ.architectural.designs.to.build.complex.systems. with.demanding.functional.and.quality.requirements.Consider.the.role.of.architecture.in. civil.engineering.where.designing.and.building.structures.such.as.houses.bridges.and. high-rises.is.a.nontrivial.task.In.these.cases.architectural.designs.are.used.to.specify.the. overall.appearance.of.physical.structures.When.examined.closer.it.becomes.evident.that. this.broad.definition.is.insufficient.to.describe.to.actual.role.of.architecture.in.the.process.of. building.these.systems.which.involve.far.more.than.structural.appearance.Architectural. designs.must.also.specify.a.variety.of.quality.properties.that.make.structures.functional. safe.and.economical.This.requires.architects.to.incorporate.design.alternatives.that.con- sider.a.wide.variety.of.factors.(e.g.social.aesthetic.and.cost).supporting.the.needs.of. stakeholders.including.the.people.who.use.these.physical.structures. In.software.engineering.architects.work.to.create.the.overall.design.elements.appro- priate.for.supporting.efficient.refinement.and.construction.of.software.systems.However. as.in.the.previous.discussion.architectural.designs.in.software.engineering.involve.far. more.than.structural.composition.They.must.also.address.numerous.quality.properties. (e.g, performance. usability. and. maintainability). that. combine. together. to. produce.

--- Chunk 132 ---
Tokens: 380
Type: sentence-based
Text:
produce. software.systems.that.meet.the.quality.expected.by.their.stakeholders.To.address.these. numerous.concerns.software.architects.create.different.models.of.the.software.system. each.addressing.the.system.design.from.different.perspectives.From.the.structural.logical. perspective.the.software.architecture.should.address.the.needs.of.downstream.designers. and.developers.by.decomposing.the.software.(in.an.efficient.manner).and.defining.the. major.components.of.the.system.identifying.their.interfaces.and.interrelationships.and. providing.support.for.both.functional.and.quality.attributes.of.the.system.From.the.con- figuration.management.perspective.the.architecture.should.provide.information.about. the.hierarchy.of.files.in.the.file.system.their.interrelationships.and.the.process.for.building. one.or.more.versions.of.the.software.system.From.a.systems.engineering.perspective.the. architecture.provides.information.about.the.physical.deployment.of.the.system.including. the.location.of.distributed.subsystems.their.interfaces.and.interrelationship.and.specifi- cation.of.communication.protocols.between.them.Other.architectural.perspectives.exist. for.addressing.various.concerns.that.stakeholders.may.have.and.should.be.considered.and. designed.for.during.the.software.architecture.activity.Since.the.nature.of.stakeholders. .varies.greatly.in.software.systems.the.perspective.used.to.model.the.structure.and.behav- ior.of.software.systems.varies.as.well.Therefore.it.is.almost.never.the.case.that.a.single.

--- Chunk 133 ---
Tokens: 399
Type: sentence-based
Text:
.varies.greatly.in.software.systems.the.perspective.used.to.model.the.structure.and.behav- ior.of.software.systems.varies.as.well.Therefore.it.is.almost.never.the.case.that.a.single. design.element.from.a.single.perspective.can.represent.the.software.architecture.espe- cially.for.large-scale.software.intensive.systems.In.these.cases.the.collection.of.design. Principles of Software Architecture  69 elements.and.their.detailed.descriptions.help.form.the.software.architecture.Formally. software.architecture.is.defined.as The. foundational. software. design. activity. that. evaluates. and. translates. software. require- ments.(both.functional.and.non-functional).into.a.collection.of.design.elements.that.specify. structural.and.behavioral.aspects.of.the.major.components.of.the.system.together.with.their. provided.quality.and.interrelationships.required.to.support.the.detailed.design.and.con- struction.of.software.systems.and.the.product.resulting.from.such.activity. From.this.definition.a.few.things.are.of.interest.and.need.further.explanation.First.as. foundational design.software.architecture.provides.the.groundwork.essential.for.meeting. functional.and.nonfunctional.requirements.The.architectural.design.foundation.provides. the.necessary.structure.for.achieving.quality.throughout.subsequent.phases.of.the.software. engineering.life.cycle.This.suggests.that.architecture.is.not.an.optional.design.activity.or. an.activity.performed.as.a.means.of.documenting.software.systems.long.after.they.are. implemented.Although.deriving.and.documenting.a.systems.software.architecture.from.

--- Chunk 134 ---
Tokens: 400
Type: sentence-based
Text:
implemented.Although.deriving.and.documenting.a.systems.software.architecture.from. its.implementation.in.legacy.systems.provides.an.excellent.avenue.for.capturing.and.trans- ferring.knowledge.about.the.systems.design.new.development.efforts.should.approach. software.architecture.as.a.forward.engineering.activity.that.leads.to.the.implementation.of. systems.and.not.as.a.reverse.engineering.mechanism.for.documentation.Second.software. architecture.provides.abstractions.for.software.requirements.in.the.design.domain.so.that. design.elements.components.and.alternatives.all.derive.from.requirements.This.suggests. that.as.part.of.the.architectural.effort.architects.must.be.proficient.in.activities.related.to. requirements.engineering.Third.by.specifying.that.architecture.is.a.collection of design elements.it.is.implied.that.software.architectures.are.composed.of.multiple.structures.and. that.no.one.structure.can.fully.describe.the.software.architecture.(Bass.Clements.and. Kazman.2003).Fourth.as.a.design.activity.that.deals.with.the.major system components. it is.suggested.that.software.architecture.works.at.a.distinct.level.of.abstraction.that.differs. from.other.forms.of.design.such.as.detailed.design.This.means.that.architectural.work. focuses.on.the.major.componentswhich.become.the.units.of.system.compositionand. the.properties.and.services.that.these.components.exhibit.and.provide.to.other.compo- nents.This.clearly.delineates.architectural.efforts.from.other.detailed.design.efforts.Fifth. a.sometimes.overlooked.or.underappreciated.piece.of.the.software.architecture.definition.

--- Chunk 135 ---
Tokens: 384
Type: sentence-based
Text:
a.sometimes.overlooked.or.underappreciated.piece.of.the.software.architecture.definition. is.its.support for.detailed design and construction.Even.though.architects.do.not.need.to. be.proficient.with.particular.programming.languages.they.benefit.greatly.from.having. proficiency.with.general.programming.design.concepts.so.that.their.architectural.designs. provide.sufficient.avenues.for.efficient.construction.of.the.system.Finally.software.archi- tecture.supportsas.opposed.to.ensuresthe.achievement.of.quality.goals.that.is.soft- ware.architecture.cannot.single-handedly.provide.the.work.necessary.for.achieving.the. desired.quality.properties.of.the.system.Since.work.performed.during.subsequent.activi- ties.and.phases.significantly.shapes.the.systems.quality.software.architecture.can.play. only.the.initial.(indispensable).role.of.establishing.the.design.quality.framework.for.the. rest.of.the.development.process. 70  Software Engineering Design WHY STUDY SOFTWARE ARCHITECTURE? Architectural.designs.identify.the.necessary.elementsand.attributes.of.those.elements that.support.detailed.design.and.construction.efforts.These.design.elements.are.presented. in.context.for.examining.how.well.the.system.as.a.whole.collaborates.to.meet.its.intended. functions. In. many. cases. this. includes. the. modeling. of. other. nonsoftware. .elements. (e.g, physical.nodes).that.play.a.key.role.in.assessing.the.systems.capabilities.for.achieving. a.desired.quality.goal.An.understanding.of.architectural.modeling.capabilities.is.essential.

--- Chunk 136 ---
Tokens: 378
Type: sentence-based
Text:
a.desired.quality.goal.An.understanding.of.architectural.modeling.capabilities.is.essential. in.problem.solving.since.they.provide.the.means.to.overcome.functional fixedness.early.on. in.the.development.process.by.allowing.designers.to.model.and.evaluate.the.same.problem. from.different.perspectives.Benefits.from.studying.software.architecture.are.also.evident.in. numerous.aspects.of.both.product.development.and.management.From.the.product.devel- opment.perspective.studying.software.architecture.is.important.for.creating.an.efficient. bridge.between.the.software.requirements.phase.and.the.detailed.design.phase.Having. extended.knowledge.of.software.architecture.provides.architects.with.a.wider.pool.of.design. alternatives.some.of.which.have.been.proven.successful.in.previously.developed.and.similar. systems.In.these.cases.architects.can.reuse.structural.design.elements.and.interconnec- tions.and.their.responsibilities.and.can.gain.insight.into.their.quality.properties.all.based. on.previously.used.architectures.This.provides.quick.insight.into.the.systems.or.individ- ual.components.ability.to.meet.quality.expectations.Besides.aiding.in.product.develop- ment.activities.studying.software.architecture.also.enhances.project.managers.activities. because.it.helps.dictate.units.of.planning.scheduling.and.budget.it.helps.establish.inter- team.communication.channels.configuration.control.and.file.system.organization.and.it. helps.manage.the.integration.test.and.maintenance.efforts.(Bass.et.al.2003).

--- Chunk 137 ---
Tokens: 400
Type: sentence-based
Text:
helps.manage.the.integration.test.and.maintenance.efforts.(Bass.et.al.2003). KEY TASKS IN ARCHITECTURAL DESIGN Defining.the.structure.of.software.systems.requires.consideration.of.many.project-specific. aspects.and.how.those.aspects.relate.to.the.organizations.goals.Therefore.examining.the. business.impact.of.architectural.decisions.in.the.organization.is.a.major.task.of.software. architects.(Bass.et.al.2003).This.requires.a.holistic.approach.that.considers.all.factors. that.help.shape.the.system.in.an.efficient.manner.Some.of.the.key.tasks.that.need.to.be. .performed.during.the.software.architectural.design.effort.include . Identifying.stakeholders.concerns . Identifying.appropriate.architectural.views . Identifying.architectural.styles.and.patterns . Identifying.influences.of.architectural.decisions.in.organization . Identifying.the.systems.major.components.and.interfaces . Evaluating.and.validating.the.architecture . Establish.policies.for.ensuring.architectural.design.synchronicity Principles of Software Architecture  71 Identifying Stakeholders Concerns Stakeholders.are.persons.groups.or.organizations.that.have.a.direct.or.indirect.stake.in.the. system.They.include.systems.engineers.software.engineers.hardware.engineers.project. management.customers.and.their.representatives.testing.teams.quality.assurance.teams. and.members.of.the.configuration.management.team.The.list.of.stakeholders.and.the.abil- ity.to.manage.them.from.an.architectural.designs.perspective.varies.in.magnitude.and. complexity.per.project.An.important.job.of.the.software.architect.is.to.ensure.that.the.

--- Chunk 138 ---
Tokens: 367
Type: sentence-based
Text:
complexity.per.project.An.important.job.of.the.software.architect.is.to.ensure.that.the. software.to.be.developed.addresses.stakeholders.concerns.Stakeholders.concerns.provide. high-level.information.about.desired.characteristics.of.the.software.system.Therefore.a key. factor.in.the.architectural.design.activity.is.identifying.and.understanding.the.different. ways.stakeholders.influence.the.system.and.how.they.interact.with.each.other.These.con- cerns.need.to.be.elicited.and.captured.before.any.design.effort.can.begin.Stakeholders. concerns.(e.g.requirements).are.the.driving.force.behind.architectural.decisions.and.can. influence.both.product.and.processes.may.be.functional.or.quality.in.nature.and.may.have. different.levels.of.abstraction.During.project.inception.stakeholders.concerns.are.cap- tured.and.specified.in.a.clear.and.consistent.manner.to.define.the.expected.functions.and. quality.of.the.software.system.An.essential.characteristic.of.the.specification.of.concerns. is.their.ability.to.provide.verifiable.specifications.which.are.used.as.evaluation.criteria.for. all.architectural.design.activities.Therefore.when.identifying.stakeholders.concerns.addi- tional.effort.is.required.so.that.they.are.understandable.achievable.and.consistent.with.all. other.identified.concerns.from.all.other.stakeholders. Identifying Appropriate Architectural Views Software.architects.work.hard.to.create.designs.that.achieve.all.functional.and.quality.features.

--- Chunk 139 ---
Tokens: 395
Type: sentence-based
Text:
Identifying Appropriate Architectural Views Software.architects.work.hard.to.create.designs.that.achieve.all.functional.and.quality.features. expected.from.stakeholders.In.complex.software.systems.there.can.be.a.multitude.of.stake- holders.with.myriad.backgrounds.all.shaping.the.way.the.system.development.is.approached. based.on.their.perception.of.what.the.final.product.should.be.Different.perceptions.signifi- cantly.influence.the.way.these.stakeholders.evaluate.the.systems.design.and.determine.the. appropriateness.of.the.design.to.meet.their.goals.For.this.reason.architectural.designs.must. support.different.architectural.views.used.to.evaluate.the.design.from.a.particular.stakeholders. perspective.By.providing.different.architectural.views.of.the.system.communication.among. stakeholders.is.enhanced.during.new.or.ongoing.development.or.during.a.systems.mainte- nance.phase.These.architectural.views.provide.designers.the.ability.to.address.concerns.using. a.perspective.and.design.elements.well.suited.for.analyzing.and.evaluating.the.particular.prob- lem.By.using.appropriate.views.architectural.design.can.be.placed.in.context.to.yield.better. modeling.and.evaluation.capabilities.Therefore.the.result.of.any.architectural.effort.must. contain.design.solutions.that.address.one.or.more.viewpoints.specific.to.the.problem.at.hand. Identifying Architectural Styles and Patterns The.concepts.of.architectural.styles.and.patterns.are.fundamental.to.the.efficient.creation. of. software. architectures. Architectural. styles. and. patterns. provide. an. overall. strategy.

--- Chunk 140 ---
Tokens: 375
Type: sentence-based
Text:
strategy. 72  Software Engineering Design for.designing.a.family.of.software.systems.They.provide.generic.reusable.architectural. solutions.documented.in.a.way.that.is.easily.understood.and.applied.to.new.problems. requiring.similar.architectural.features.For.this.reason.identifying.architectural.styles. and.patterns.is.one.of.the.first.decisions.that.software.architects.make.This.decision.has. long-lasting.effects.on.all.subsequent.design.and.construction.efforts.Decisions.based.on. architectural.styles.and.patterns.benefit.from.years.of.documented.experience.that.high- light.the.solution.approach.to.given.problems.from.the.advantages.of.these.approaches. and.from.gaining.understanding.of.the.consequences.of.designing.the.system.with.a.par- ticular.style.Today.numerous.architectural.styles.and.patterns.have.been.documented. so.software.architects.need.to.identify.and.determine.the.appropriateness.benefits.and. consequences.of.choosing.a.particular.style.or.pattern.for.their.systems.design. Identifying System Interfaces Interface. identification. and. definition. compose. another. essential. task. of. the. software. architecture.activity.Interfaces.are.defined.for.components.residing.within.single.physical. nodes.within.a.single.process.space.for.components.residing.within.a.single.node.in.dif- ferent.process.spaces.or.for.components.residing.in.separate.processes.distributed.across.a. network.Interface.definition.may.include.the.definition.of.stable.interfaces.such.as.abstract.

--- Chunk 141 ---
Tokens: 386
Type: sentence-based
Text:
network.Interface.definition.may.include.the.definition.of.stable.interfaces.such.as.abstract. classes.in.object-oriented.environments.When.using.a.structured.design.approach.identi- fying.internal.interfaces.can.result.in.determining.the.set.of.services.required.by.each.archi- tectural.component.to.collaborate.with.all.other.architectural.components.These.identify. the.major.access.points.for.architectural.components.together.with.the.communication. rules.that.must.be.followed.during.the.detailed.design.activity.Having.well-defined.inter- faces.allows.the.software.system.to.evolve.gracefully.with.time.when.existing.capabilities. are.modified.or.new.capabilities.are.added.to.the.system.Defining.the.interfaces.between. components.that.reside.in.different.nodes.may.include.specifying.messaging.structures. protocols. and. other. communication. mechanisms. for. allowing. communication. across. distributed.components.These.can.include.identification.of.physical.medium.data-link. protocols.network.and.transport.protocols.messaging.specification.and.application-level. protocols.Identification.of.external.interfaces.can.significantly.impact.a.systems.ability.to. support.its.identifying.quality.properties. Identifying Impact of Architectural Decisions in Organization During.the.architectural.design.activity.software.architects.are.required.to.make.decisions. that.support.the.efficient.development.of.the.software.system.within.bounds.placed.by. the.organization.mission.and.goals.These.restrictions.are.company-specific.and.in.many.

--- Chunk 142 ---
Tokens: 385
Type: sentence-based
Text:
the.organization.mission.and.goals.These.restrictions.are.company-specific.and.in.many. cases.appear.outside.the.scope.of.architects.work.nonetheless.these.restrictions.need.to. be.considered.and.are.typically.manifested.in.software.architectures.For.example.con- sider.the.case.of.software.system.decomposition.From.a.pure.logical.standpoint.decom- position.is.made.to.define.units.of.manageable.complexity.that.can.be.evaluated.built.and. maintained.These.criteria.are.typically.used.as.basis.for.system.decomposition.however. Principles of Software Architecture  73 in practical.applications.other.key.organizational.issues.need.to.be.addressed.to.determine. the.right.granularity.of.components.when.decomposing.a.system.When.approached.this. way.architectural.decisions.are.driven.not.only.by.common.design.principles.discussed.in. Chapter.1.but.also.by.other.organizational.and.project-specific.factors.such.as.stakeholders. concerns.resource.availability.resource.location.schedule.and.budget.These.factors.drive. architectural.decisions.to.create.design.solutions.that.are.appropriate.for.meeting.both. product.and.organizational.requirements.therefore.bridging.the.gap.between.the.business. organization.and.its.technical.products. Impact on Customer Base Decisions.made.during.the.architectural.activity.affect.not.only.subsequent.activities.in.the. software.life.cycle.but.also.stakeholders.especially.customers.When.faced.with.competing. alternatives.each.benefiting.one.customer.more.than.others.architects.have.to.find.ways.to.

--- Chunk 143 ---
Tokens: 388
Type: sentence-based
Text:
alternatives.each.benefiting.one.customer.more.than.others.architects.have.to.find.ways.to. make.decisions.that.accommodate.each.customer.and.minimize.overall.customer.dissatis- faction.In.these.cases.software.architects.must.be.skilled.at.predicting.verifying.and.vali- dating.the.effects.of.their.design.decisions.This.issue.is.further.complicated.by.the.presence. of.quality.requirements.The.problem.with.quality.attributes.is.that.they.typically.contradict. each.other.This.property.of.quality.attributes.is.described.in.detail.by.Gorton. (2011.p.37): Quality.attributes.are.not.orthogonal.They.interact.in.subtle.ways.meaning.a.design.that. .satisfies.one.quality.attribute.requirement.may.have.a.detrimental.effect.on.another.For.exam- ple.a.highly.secure.system.may.be.difficult.or.impossible.to.integrate.in.an.open.environment. Software.architects.are.constantly.faced.with.the.challenging.task.of.determining.the. effects.of.individual.design.alternatives.identifying.conflicting.design.solutions.negotiat- ing.systems.features.among.stakeholders.and.verifying.and.documenting.the.final.archi- tectural.solution.all.of.which.impact.the.customer.base. Impact on Budget and Schedule Architectural.designs.provide.project.management.with.more.concrete.representations.of. the.effort.required.to.build.the.software.system.Specifically.they.provide.the.best.source. of.information.for.creating.or.reevaluating.schedules.and.cost.so.that.they.reflect.realistic. and.achievable.milestones.Once.schedule.and.budget.are.established.other.attributes.of.

--- Chunk 144 ---
Tokens: 399
Type: sentence-based
Text:
and.achievable.milestones.Once.schedule.and.budget.are.established.other.attributes.of. the.project.can.be.fine-tuned.to.meet.the.established.goals.For.example.architectural. designs.can.highlight.inadequacy.in.resources.required.for.completing.the.system.on.time. and.within.budget.In.these.cases.architectural.designs.are.used.as.concrete.justifica- tion.for.requesting.more.resources.early.on.in.the.project.life.cycle.In.cases.where.adding. resources.is.infeasible.architectural.designs.can.help.justify.reevaluation.of.the.strategy. which.requires.decision.making.in.all.aspects.of.the.project.such.as.schedule.budget. or make.versus.buy.decisions.These.adjustments.based.on.architectural.designs.impact. 74  Software Engineering Design the.development.organizations.budget.and.schedule.and.are.necessary.to.manage.risks. to maintain.customer.satisfaction.and.to.ensure.the.projects.success. Impact from Resource Availability The.previous.section.introduced.human.resource.availability.as.an.impacting.factor.in.the. development. project. However. architectural. decisions. are. also. affected. by. other. differ- ent.forms.of.resource.availability.Resource.availability.such.as.employees.software.and. hardware.can.all.prompt.adjustments.to.the.architecture.Architectural.designs.that.take. into.account.human.resources.can.maximize.employee.efficiency.throughout.the.detailed. design.and.construction.phase.By.taking.into.account.employee.availability.location.and. team.composition.work.can.be.compartmentalized.and.developed.in.parallel.Employees. that. are. distributed. across. different.

--- Chunk 145 ---
Tokens: 360
Type: sentence-based
Text:
different. sites. can. prompt. the. creation. of. components. with. well-defined.interfaces.that.can.be.developed.independently.and.integrated.into.the.sys- tem.with.minimal.effort.Hardware.availability.can.also.prompt.adjustment.in.the.software. architecture.In.cases.where.hardware.availability.is.essential.to.the.development.and.test. of.software.the.architecture.may.be.adjusted.to.provide.simulation.components.that.can.be. used.to.move.the.development.effort.forward.in.case.hardware.is.unavailable.In.these.cases. construction.and.test.can.continue.until.the.hardware.becomes.available.At.any.point.the. simulation.component.can.be.swapped.easily.for.the.real.hardware.component.without. changes.to.the.overall.architecture.or.software.The.same.approach.can.be.employed.for. other.software.resources.that.are.essential.to.the.development.of.the.system. Identifying the Systems Major Components and Interfaces A.major.task.performed.during.the.software.architecture.activity.involves.decomposing. systems.into.manageable.component.units.In.doing.so.it.is.important.to.identify.the.inter- faces.that.these.components.use.to.collaborate.with.each.other.Components.and.interfaces. are.identified.during.system.decomposition.however.the.nature.of.these.significant.ele- ments.varies.according.to.the.perspective.used.for.system.decomposition.In.the.broad. context.of.system.decomposition.identifying.the.major.components.and.interfaces.may.

--- Chunk 146 ---
Tokens: 365
Type: sentence-based
Text:
context.of.system.decomposition.identifying.the.major.components.and.interfaces.may. involve.for.example.logical.components.physical.nodes.files.or.directories.and.physi- cal.or.logical.interfaces.required.for.these.components.to.interoperate.with.each.other. Examples.of.identifying.logical.and.physical.components.and.their.interfaces.are.presented. in.Chapter.4. Evaluating and Validating the Architecture Consider.designing.a.large-scale.secure.high-performing.distributed.system.composed. of.multiple.nodes.each.with.usable.interfaces.all.while.emphasizing.the.systems.testability. and.maintainability.In.addition.the.system.needs.to.be.built.using.a.joint.approach.among. three.organizations.in.separate.geographical.locations.For.such.development.efforts.an. unsuitable.architecture.is.a.recipe.for.disaster.Therefore.software.architecture.evaluation. Principles of Software Architecture  75 and.validation.are.essential.tasks.of.the.software.architecture.activity.In.most.cases.failure. to.evaluate.and.validate.the.architecture.significantly.impacts.the.effort.and.cost.incurred. to.develop.the.system.Typically.defects.found.during.earlier.stages.of.the.development.life. cycle.(e.g.architecture).take.much.less.effort.to.correct.than.if.found.at.later.stages.such.as. during.the.testing.phase. (Clements.Kazman.and.Klein.2001).For.this.reason.it is.essen- tial.to.evaluate.and.validate.the.suitability.of.the.architecture.to.meet.its.intended.purpose.

--- Chunk 147 ---
Tokens: 394
Type: sentence-based
Text:
(Clements.Kazman.and.Klein.2001).For.this.reason.it is.essen- tial.to.evaluate.and.validate.the.suitability.of.the.architecture.to.meet.its.intended.purpose. before.attempting.to.construct.the.system.Evaluation.and.validation.can.focus.on.compo- nents.subsystems.or.the.entire.system.depending.on.how.the.architecture.is.structured. and.the.requirements.placed.on.the.system.In.all.of.these.cases.evaluation.and.validation. ensure.that.architectural.components.and.the.architecture.itself.are.sufficiently.complete. to.support.the.expected.services.and.quality.of.those.services. Introducing Policies for Design Synchronicity A.most.often.overlooked.issue.in.software.design.efforts.is.the.concept.of.design.syn- chronicity.Design.synchronicity.is.a.measurement.of.the.degree.of.how.well.the.software. systems.implementation.reflects.its.software.architecture.and.detailed.design.In.many. cases.design.synchronicity.reflects.the.quality.of.the.software.process.in.place.in.others. it.reflects.the.organizations.capability.for.monitoring.and.controlling.processes.through- out.The.software.architecture.establishes.the.foundation.required.for.subsequent.design. and.construction.work.to.meet.the.system.requirements.(including.quality.requirements). Therefore.unmanaged.deviations.from.the.software.architecture.during.detailed.design. and.construction.can.reshape.the.properties.of.the.system.and.affect.its.overall.capability. to.meet.requirements.For.any.software.architecture.effort.to.result.in.successful.imple- mentation.of.a.system.all.subsequent.phases.and.activities.

--- Chunk 148 ---
Tokens: 387
Type: sentence-based
Text:
to.meet.requirements.For.any.software.architecture.effort.to.result.in.successful.imple- mentation.of.a.system.all.subsequent.phases.and.activities. (i.e.detailed.design.and.con- struction).must.be.synchronized.with.the.software.architecture.Therefore.designers.and. programmers.need.to.work.closely.and.communicate.to.ensure.that.the.detailed.design.and. software.implementation.are.consistent.with.architectural.decisions.In.addition.project. managers.need.to.set.processes.in.place.to.support.design.synchronicity.throughout.the. software.development.life.cycle.which.is.difficult.for.large-scale.multiyear.efforts.or.for. projects.entering.the.maintenance.phase. Skill Development 3.1: Key Tasks in Architectural Design A. building. architect. is. hired. to. design. an. indoor. sports. complex. with. capacity. of. 3,000 people. The. building. will. be. used. to. host. sports. concerts. and. other. major. activities.The.initial.design.consists.of.a.futuristic.building.with.single.door.for.both. entrance.and.exit.The.buildings.design.is.technically.sound.and.can.even.withstand. major.natural.disasters.common.to.the.area.Create.an.exhaustive.list.of.stakehold- ers.and.identify.the.concerns.they.may.have.and.how.they.can.be.addressed.in.the. proposed.buildings.architectural.design.Do.any.of.the.identified.key.tasks.of.software. .architecture.apply.to.this.problem.Explain. 76  Software Engineering Design PROBLEM SOLVING IN SOFTWARE ARCHITECTURE In.Chapter.1.a.generic.model.for.problem.solving.was.introduced.based.on.inputs.constraints.

--- Chunk 149 ---
Tokens: 388
Type: sentence-based
Text:
76  Software Engineering Design PROBLEM SOLVING IN SOFTWARE ARCHITECTURE In.Chapter.1.a.generic.model.for.problem.solving.was.introduced.based.on.inputs.constraints. and.outputs.where.each.input.problem.is.interpreted.and.carefully.formulated.is.evaluated. against. its. external. constraints. and. is. ultimately. processed. evaluated. and. documented. Different.instances.of.this.problem-solving.model.can.be.created.for.particular.activities.in.the. design.process.such.as.the.software.architecture.activity.During.software.architecture.the. problem-solving.landscape.can.be.characterized.by.a.particular.set.of.inputs.constraints.and. outputs.common.to.architectural.problems.encountered.during.the.design.effort.These.prop- erties.can.be.consistently.defined.for.most.architectural.design.efforts.therefore.it.becomes. essential.for.software.architects.to.understand.the.types.of.inputs.constraints.and.outputs. expected.during.architectural.problem.solving.Using.the.holistic.problem-solving.approach. presented.in.Chapter.1.the.generic.problem-solving.model.is.modified.to.account.for.common. properties.present.during.the.software.architecture.activity.and.is.presented.in.Figure 3.1. As.seen.in.the.figure.typical.inputs.present.during.the.software.architecture.activity. include. requirements. system. goals. and. scenarios. These. are. interpreted. and. carefully. formulated.as.part.of.the.requirements.engineering. (RE).phase.however.it.is.not.uncom- mon.for.software.architects.to.perform.RE.activities.since.requirements.may.not.be.well.

--- Chunk 150 ---
Tokens: 379
Type: sentence-based
Text:
(RE).phase.however.it.is.not.uncom- mon.for.software.architects.to.perform.RE.activities.since.requirements.may.not.be.well. understood.or.defined.or.new.requirements.may.be.created.as.knowledge.of.the.system.is. acquired.throughout.the.design.phase.These.inputs.are.interpreted.and.evaluated.against. the.architectural.and.project.constraints.are.transformed.through.collaborative.work.into. architectural.design.products.and.are.evaluated.and.documentedtypically.as.part.of.the. software.design.documentas.architectural.design.elements.for.future.activities.or.phases. in.the.development.life.cycle. Evaluate Constraints Architectural Design Interpret Problem Evaluate Collaborative Brainstorming Document Resources Activities Controls Schedule Constraints, Cost Constraints, Quality Constraints Requirements, System Goals, Scenarios Architectural Designs, Documentation FIGURE 3.1 Holistic.architectural.problem-solving.model. Principles of Software Architecture  77 Inputs The.most.typical.inputs.encountered.in.problem.solving.during.the.software.architecture. activity.are.requirements.and.system.goals.which.both.can.be.represented.using.scenarios. These.inputs.are.elicited.from.stakeholders.and.provide.the.driving.forces.behind.all.prob- lems.and.solutions.devised.during.the.architectural.design.activity.Requirement.inputs. must.have.certain.characteristics.so.that.they.can.be.well.understood.by.designers.Bad.or. misunderstood.requirements.lead.to.problems.that.are.hard.to.solve.or.solved.incorrectly.

--- Chunk 151 ---
Tokens: 399
Type: sentence-based
Text:
misunderstood.requirements.lead.to.problems.that.are.hard.to.solve.or.solved.incorrectly. In.some.cases.requirement.input.can.be.incomplete.misleading.or.inconsistent.in.others. they.may.specify.unverifiable.or.unachievable.capabilities.which.makes.problem.solving. difficult.or.impossible.at.times.In.these.cases.requirement.input.results.in.ill-defined.or. wicked.problems.which.are.hard.to.solve.On.the.other.hand.system.goals.which.estab- lish.a.high-level.desired.capability.need.to.be.transformed. (when.possible).into.require- ment.form.so.that.they.are.appropriate.for.problem.solving.Before.any.problem.solving. can.occur.during.architecture.issues.with.requirements.system.goals.and.scenarios.need. to.be.resolved.so.that.the.proper.problem.interpretation.and.formulation.can.be.made. Therefore.careful.attention.needs.to.be.placed.when.interpreting.inputs.so.that.their.cor- rect.solution.can.be.integrated.into.the.design.and.evaluated.and.validated.appropriately. These.tasks.belong.mostly.to.the.requirements.phase.however.in.many.cases.it.is.common. for.software.architects.to.iterate.back.and.forth.from.requirements.to.design. Constraints Whereas.inputs.define.the.problems.that.need.solutions.during.the.architectural.design. activity.constrains.specify.bounds.identified.for.their.proposed.solutions.At.the.architec- tural.design.level.typical.constraints.include.schedule.budget.and.process.constraints. Besides.constraints.derived.from.nonfunctional.requirements.other.constraints.include. specific.platform.constraints.(e.g.embedded.mobile.web).constraints.from.existing.and.

--- Chunk 152 ---
Tokens: 380
Type: sentence-based
Text:
specific.platform.constraints.(e.g.embedded.mobile.web).constraints.from.existing.and. reused.architectures.constraints.on.new.technology. (e.g.cloud-based.solutions).incorpo- rating.commercial.of-the-shelf.(COTS).products.and.numerous.other.constraints.placed. on.both.product.and.processes.During.architectural.problem.solving.architects.must.be. quick.to.learn.technology.aspects.of.product.constraints.and.also.must.have.a.keen.sense. of.project.management.aspects.to.account.for.both.schedule.and.budget.constraints.when. decomposing.the.major.software.components.of.the.architectural.design.Other.character- istics.of.the.software.project.may.give.rise.to.constraints.placed.on.the.architectural.design. process.For.example.process.constraints.may.dictate.the.type.of.architectural.designs. required.the.views.supported.by.the.architecture.and.other.supporting.activities.required. to.meet.constraints.placed.on.the.architectural.design.process. Outputs Problem.solving.during.architectural.design.should.lead.to.further.understanding.of.the. major.structure.and.behavior.of.software.systems.Therefore.outputs.consist.of.design. 78  Software Engineering Design elements.and.descriptions.that.differ.from.other.forms.of.design.such.as.detailed.design. Outputs.during.the.architecture.activity.are.in.the.form.of.black-box.solutions.which. require.refinement.in.subsequent.design.work.In.many.cases.it.is.difficult.to.delineate. between.where.an.architectural.design.solution.ends.and.its.respective.detailed.design.

--- Chunk 153 ---
Tokens: 391
Type: sentence-based
Text:
between.where.an.architectural.design.solution.ends.and.its.respective.detailed.design. solution.begins.From.the.logical.perspective.architectural.solutions.need.to.account.for. the.necessary.components.and.interfaces.required.to.achieve.functional.requirements.and. to.support.its.quality.requirements.Once.architectural.solutions.can.account.for.these. .criteria.details.of.implementation.can.be.deferred.to.detailed.designs. The.output.of.problem.solving.during.the.architectural.design.activity.is.essential.to. producing.a.high-quality.software.system.Problem.solutions.during.software.architec- ture.need.to.be.evaluated.and.documented.accordingly.so.that.they.can.be.used.in.future. design.and.construction.work.The.documentation.format.varies.from.project.to.project. and.from.organization.to.organization.Typically.solutions.found.during.the.architectural. design.activity.are.documented.in.the.form.of.diagrams.documents.or.a.combination. of.the.two.They.can.contain.analysis.and.documentation.for.major.design.decisions.the. concerns.and.stakeholders.related.to.the.problem.design.trade-offs.identified.conflicting. goals.prioritization.schemes.design.synchronization.plans.and.a.mapping.of.require- ments.to.the.architectural.solution.This.information.can.be.incorporated.into.an.official. architectural.design.document.that.is.maintained.independently.or.incorporated.into.the. official.software.design.document.which.is.completed.reviewed.and.approved.after.com- pletion.of.the.design.phase.Regardless.of.the.documentation.format.solutions.to.problems.

--- Chunk 154 ---
Tokens: 398
Type: sentence-based
Text:
official.software.design.document.which.is.completed.reviewed.and.approved.after.com- pletion.of.the.design.phase.Regardless.of.the.documentation.format.solutions.to.problems. .during.the.architectural.design.activity.must.be.understandable.complete.and.sufficient. to.support.the.detailed.design.phase. SOFTWARE ARCHITECTURE PROCESS The.architectural.design.activity.involves.many.problems.that.need.to.be.solved.before.the. software.architecture.is.created.and.the.development.effort.can.move.forward.Each.problem. solved.during.architecture.helps.address.a.particular.concern.and.has.an.associated.set.of. inputs. (e.g.requirements).constraints.and.desired.output.Outputs.of.the.architectural.prob- lem-solving.process.produce.design.elements.of.the.software.architecture.and.the.collective. set.of.elements.is.combined.to.form.the.software.architecture.Therefore.problem.solving. during. architecture. forms. part. of. a. broader. process. for. creating. software. .architectures. On.a.larger.scale.the.process.for.creating.software.architecture.can.be.executed.using.the. following tasks: . Understand.and.evaluate.requirements . Design.the.architecture . Evaluate.the.architecture . Document.the.architecture . Monitor.and.control.implementation Principles of Software Architecture  79 UNDERSTAND AND EVALUATE REQUIREMENTS Software.architects.spend.a.great.deal.of.time.working.with.software.requirements.Even. after.requirements.are.specified.software.architects.find.themselves.going.back.and.forth. between.requirements.and.design.to.clarify.them.correct.them.or.completely.revise.them.

--- Chunk 155 ---
Tokens: 381
Type: sentence-based
Text:
between.requirements.and.design.to.clarify.them.correct.them.or.completely.revise.them. In.some.cases.software.architects.are.completely.immersed.in.the.requirements.process. playing.a.key.role.in.specifying.the.requirements.of.the.system.For.this.reason.software. architects.need.to.understand.RE.the.discipline.within.software.engineering.that.is.con- cerned.with.the.systematic.approach.to.requirements.specification.mainly.through.the. following.activities. (Abran.Moore.Bourque.and.Dupuis.2005): . Elicitation . Analysis . Specification . Validation Together.these.activities.are.performed.to.express.the.needs.and.constraints.placed.on.the. software.system.which.provides.the.foundation.for.all.architectural.and.subsequent.design. and.construction.work.Understanding.RE.and.how.the.fundamental.activities.relate.to. designing.software.architectures.provides.architects.with.a.different.dimension.for.design- ing.successful.systems.by.filling.gaps.or.making.appropriate.corrections.to.the.software. .specification.before.committing.to.a.particular.design.solution. Elicitation Elicitation. is. the. requirement. activity. that. deals. with. identifying. stakeholders. with. uncovering.what.the.customer.needs.and.wants.and.with.determining.the. (often.over- looked).nonfunctional.requirements.(Laplante.2009).Elicitation.begins.by.identifying.all. sources.of.information.that.can.be.used.to.generate.requirements.Sources.of.informa- tion.vary.from.project.to.project.and.can.provide.bias.information.to.shape.the.system.

--- Chunk 156 ---
Tokens: 387
Type: sentence-based
Text:
sources.of.information.that.can.be.used.to.generate.requirements.Sources.of.informa- tion.vary.from.project.to.project.and.can.provide.bias.information.to.shape.the.system. in.a.way.that.addresses.their.particular.needs.Sources.of.information.also.come.from.a. variety.of.backgrounds.therefore.the.use.of.techniques.that.are.effective.in.extracting. important.information.from.a.variety.of.sources.with.different.expertise.and.background. is.essential. Requirement Sources Software.requirements.originate.from.many.different.sources.In.some.cases.require- ments.may.originate.from.one.source.with.an.overall.strategy.and.consistent.vision.for. the.system.which.makes.analyzing.specifying.and.validating.requirements.more.man- ageable.In.most.large-scale.software.efforts.requirements.originate.from.many.different. sources.with.similar.but.inconsistent.visions.for.the.system.In.these.cases.identifying. 80  Software Engineering Design and.managing.these.sources.becomes.a.nontrivial.task.that.requires.additional.time.and. effort.Some.of.the.most.common.sources.of.requirements.include. (Abran.et.al.2005): . Stakeholders . Goals . Domain.knowledge . Operational.and.organizational.environment Multiple.stakeholders.view.the.system.differently.and.provide.different.input.and.con- straints.for.the.system.Having.an.increased.number.of.stakeholders.causes.almost.every. aspect.of.requirements.elicitation.to.be.more.complex.Particularly.having.a.greater.num- ber.of.stakeholders.increases.the.goals.for.the.system.System.goals.can.specify.desirable.

--- Chunk 157 ---
Tokens: 388
Type: sentence-based
Text:
aspect.of.requirements.elicitation.to.be.more.complex.Particularly.having.a.greater.num- ber.of.stakeholders.increases.the.goals.for.the.system.System.goals.can.specify.desirable. aspects.of.the.business.process.or.product.and.are.typically.referred.to.as.quality.attri- butes.When.goals.are.identified.they.must.be.evaluated.and.(if.possible).transformed.into. nonfunctional.(quality).requirements.Nonfunctional.requirements.can.be.used.to.place. constraints.on.the.devised.solutions.so.that.they.support.acceptable.levels.of.quality.as. defined.by.stakeholders. (Abran.et.al.2005).As.mentioned.before.an.essential.character- istic.of.requirements. (both.functional.and.nonfunctional).is.their.ability.to.provide.verifi- able.specifications.By.transforming.goals.to.nonfunctional.requirements.they.can.be.used. not.only.for.decision.making.during.architectural.detailed.and.construction.design.but. also.as.evaluation.criteria.during.system.test.after.the.system.is.designed.constructed.and. unit.tested.A.list.of.common.quality.attributes.with.descriptions.is.presented.in.Table 3.1. Domain. knowledge. provides. an. essential. source. for. requirements. since. it. provides. details.of.how.the.system.should.behave.and.help.determine.obscure.functions.that.the. TABLE 3.1 Common.Quality.Attributes.for.Software.Systems Quality Description Usability A.goal.that.seeks.to.minimize.the.degree.of.complexity.involved.when.learning.or.using.the. system Modifiability A.goal.that.seeks.to.minimize.the.degree.of.complexity.involved.when.changing.the.system.

--- Chunk 158 ---
Tokens: 385
Type: sentence-based
Text:
system Modifiability A.goal.that.seeks.to.minimize.the.degree.of.complexity.involved.when.changing.the.system. to.fit.current.or.future.needs Security A.goal.that.seeks.to.maximize.the.systems.ability.to.protect.and.defend.its.information.or. information.system Performance A.goal.that.seeks.to.maximize.the.systems.capacity.to.accomplish.useful.work.under.time. and.resource.constraints Reliability A.goal.that.seeks.to.minimize.the.systems.failure.rate Portability A.goal.that.seeks.to.minimize.the.degree.of.complexity.involved.when.adapting.the.system. to.other.software.or.hardware.environments Testability A.goal.that.seeks.to.minimize.the.degree.of.complexity.involved.when.verifying.and. validating.the.systems.required.functions Availability A.goal.that.seeks.to.maximize.the.systems.uptime Interoperability A.goal.that.seeks.to.maximize.the.systems.ability.to.collaborate.with.other.software.or. hardware.systems Principles of Software Architecture  81 system.needs.to.provide.in.special.cases.This.knowledge.is.obtained.through.the.design. and.development.of.similar.systems.or.through.involvement.in.the.development.effort. under.different.disciplines.such.as.hardware.test.and.management.Finally.the.opera- tional.and.organizational.environment.can.be.used.as.a.source.for.requirements.common. to.software.product.lines.within.the.organization.to.maintain.consistency.among.all.prod- ucts.developed.in.the.organization. Elicitation Techniques Different.stakeholders.view.systems.differently.based.on.their.specific.background.and.

--- Chunk 159 ---
Tokens: 388
Type: sentence-based
Text:
Elicitation Techniques Different.stakeholders.view.systems.differently.based.on.their.specific.background.and. specialization.When.eliciting.information.from.different.stakeholders.it.is.sometimes. difficult.to.compile.a.consistent.set.of.requirements.since.needs.from.stakeholders.may. contradict.each.other.Therefore.effective.elicitation.techniques.are.required.to.gather.and. consolidate.a.consistent.set.of.requirements.for.the.system.Some.of.the.most.common. techniques.for.requirements.elicitation.include. (Abran.et.al.2005): . Interviews . Facilitated.meetings . Observation . Scenarios Interviews.and.facilitated.meetings.are.both.common.techniques.for.requirement.elicita- tion.During.interviews.meetings.are.scheduled.individually.with.different.stakeholders. to.bring.forth.their.particular.needs.and.gain.understanding.of.their.particular.expecta- tions.for.the.system.On.the.other.hand.facilitated.meetings.are.performed.with.a.group. of.stakeholders.to.bring.forth.a.collective.vision.and.to.gain.more.insight.into.the.overall. expectations.of.the.system.Typically.facilitated.meetings.include.a.moderator.the.design. team.and.peer.reviewers. (including.stakeholders).By.eliciting.requirements.in.a.collec- tive.fashion.details.that.affect.different.stakeholders.can.be.identified.negotiations.can.be. made.and.collective.resolutions.can.be.achieved.Information.from.both.interviews.and. facilitated.meetings.needs.to.be.carefully.documented.further.elaborated.and.iteratively. refined.until.a.solid.grasp.of.the.system.needs.is.acquired.

--- Chunk 160 ---
Tokens: 390
Type: sentence-based
Text:
refined.until.a.solid.grasp.of.the.system.needs.is.acquired. In.many.cases.stakeholders.are.unaware.or.cannot.articulate.desirable.system.features. When.this.occurs.observations.of.similar.systems.can.help.capture.desired.functions.of. the.system.behavior.under.particular.(nonobvious).conditions.This.information.can.be. learned.to.gain.insight.into.a.particular.system.behavior.quality.or.interaction.and.used. to.generate.appropriate.requirements.for.the.system.When.systems.are.hard.to.specify. observation.allows.both.engineers.and.stakeholders.to.effectively.conceptualize.and.trans- fer.knowledge.required.to.yield.important.system.information.however.in.some.cases.it. can.be.intrusive.expensive.or.impossible. Finally.a.popular.approach.to.eliciting.requirements.is.through.scenarios.Scenarios. are.popular.because.they.allow.software.architects.to.create.and.present.to.stakeholders. .storylines.about.different.behaviors.that.the.system.is.expected.to.provide.These.storylines. 82  Software Engineering Design are.born.out.of.perceived.expected.behavior.by.the.software.architect.and.refined.and.vali- dated.through.stakeholders.reviews.Scenarios.provide.a.valuable.means.for.establishing. a.framework.for.eliciting.requirements.identifying.major.system.functions.and.details.of. the.software.and.providing.initial.insight.in.the.required.testing.of.the.software.In Unified. Modeling.Language.(UML).scenarios.can.be.grouped.by.use.cases.as.presented.in.Chapter. 2.For.each.use.case.one.or.more.scenariosone.for.the.main.flow.of.events.and.others.for.

--- Chunk 161 ---
Tokens: 387
Type: sentence-based
Text:
2.For.each.use.case.one.or.more.scenariosone.for.the.main.flow.of.events.and.others.for. alternate.scenariosare.created.to.document.the.expected.system.behavior.and.deviations. from.its.main.flow.of.events.Scenarios.represent.instances.of.use.cases.therefore.there. exists.a.one-to-many.relationship.between.use.cases.and.scenarios.Since.there.are.no.uni- versal.methods.accepted.as.standard.for.formatting.and.capturing.scenarios.scenarios.can. be.created.as.paragraphs.numbered.list.tabular.or.graphical.form.or.any.other.convenient. form.that.is.appropriate.for.systems.analysis.and.knowledge.transfer.Table 3.2.contains.a. sample.scenario.for.the.Search Product.use.case.presented.in.Chapter 2. Scenarios.provide.an.effective.method.for.eliciting.the.systems.functions.and.serve.as. excellent.communication.avenue.between.stakeholders.and.engineers.They.also.provide. an.effective.method.for.identifying.quality.information.that.can.lead.to.the.creation.of. nonfunctional.requirements.By.presenting.a.particular.quality.attribute.within.context. stakeholders.can.get.a.better.appreciation.of.how.it.relates.and.affects.the.system.For. example.as.seen.in.step.3.of.the.search.products.main.scenario.a.statement.of.perfor- mance.is.initially.brought.forth.for.evaluation.and.(if.necessary).modification.to.specify. the.actual.expected.performance.of.the.system.In.this.example.the.scenario.helped.iden- tify.an.important.quality.of.the.system.and.if.required.prototypes.can.be.developed.to. further.evaluate.the.adequacy.of.the.desired.performance.

--- Chunk 162 ---
Tokens: 372
Type: sentence-based
Text:
further.evaluate.the.adequacy.of.the.desired.performance. Skill Development 3.2: Eliciting Requirements Using Scenarios Use.any.of.the.other.remaining.use.cases.presented.in.Figure 2.4.and.create.a.detailed. scenario. description. including. steps. operator. actions. and. system. actions. After. .completing.the.task.can.you.think.of.any.quality.requirements.that.can.be.derived.from. the.scenario.Explain.Lists.the.steps.that.would.you.consider.taking.after.completion. of.the.scenario.to.ensure.that.requirements.derived.from.the.scenario.are.incorporated. into.the.system. Analysis In.the.analysis.activity.requirements.are.analyzed.in.their.raw.form.to.address.issues.such. as.requirements.that.are.contradicting.incomplete.vague.or.just.wrong.(Laplante.2009). During.analysis.software.architects.spend.a.great.deal.of.time.evaluating.each.require- ment.to.determine.its.impact.on.the.system.design.as.well.as.its.impact.on.all.other.identi- fied.requirements.Analysis.allows.architects.to.clear.the.air.in.regards.to.what.needs.to.be. Principles of Software Architecture  83 done.before.devising.more.detailed.designs.Software.architects.may.be.required.to.carry. out.important.tasks.such.as . Requirement.classification . Requirement.prioritization . Requirement.negotiation . Conceptual.modeling Requirement. classification. refers. to. the. activity. and. process. required. for. identifying. the.nature.of.each.requirement.Classification.is.important.in.determining.the.relative.

--- Chunk 163 ---
Tokens: 395
Type: sentence-based
Text:
the.nature.of.each.requirement.Classification.is.important.in.determining.the.relative. TABLE 3.2 Main.Scenario.for.Search.Product.Use.Case UC-00-Search Product Main Scenario Description: This.scenario.describes.the.main.flow.of.operations.for.requesting.a.product.search.with.the. server.system. Actors: Operator.Server.System Preconditions: The.client.and.server.system.have.been.initialized. Requirements: MCR-001.MCR-002 Alternate scenario.UC-10-Invalid.Search.UC-11-Connection.Failure.UC-12-Response.Timeout Revision History Date Version Description Revised By 9172010 1.0 Initial.scenario.creation John.Doe Description Step Operator Action System Action 1 Operator.enters.valid.product.ID. and.clicks.on.the.search.button. Validates the data.Retrieves.servers.communication. information.from.config.file. 2 Establishes.a.connection.with.the.server.system.and. sends.product.request.data.to.the.server. 3 Waits.a.maximum.of.3.seconds.for.a.server.response. 4 . . 5 Response.received.and.product.information.is.displayed. 6 Save response data.in.file.system.and.ask.user.to.search. for.another.product. 7 Operator.clicks.the.cancel.button. to.finish.searching.for.products. Notes For.details.of.data.validation.and.saving.response.data.to.file.system.see.use.cases.UC-05.and.UC-06. respectively. Approval Signatures Software.engineer: Stakeholder(s): Quality.auditor: 84  Software Engineering Design importance.of.each.requirement.and.can.serve.as.a.driver.for.prioritization.of.work.units. and.negotiation.and.trade-off.throughout.Common.criteria.for.classifying.requirements.

--- Chunk 164 ---
Tokens: 366
Type: sentence-based
Text:
and.negotiation.and.trade-off.throughout.Common.criteria.for.classifying.requirements. are.presented.in.Table 3.3. Prioritization.of.requirements.is.done.to.help.identify.the.most.important.functions.of.the. software.system.When.done.properly.prioritization.can.help.refine.the.projected.schedule. by.determining.which.requirements.(or.component.carrying.out.these.requirements).need. to.be.developed.first.or.can.help.identify.different.builds.of.the.software.system.which. can.be.designed.developed.and.deployed.at.different.times.Prioritization.also.helps.dur- ing.requirement.negotiation.when.conflicts.between.requirements.are.identified.during. analysis.When.this.occurs.negotiation.takes.place.among.stakeholders.and.resolutions. to.conflicts.are.made.while.taking.into.account.requirement.priorities.Finally.an.integral. task.of.the.analysis.activity.is.conceptual.modeling.Conceptual.models.are.created.to.fur- ther.identify.the.requirements.by.understanding.their.context.discovering.the.bounds.of. the.software.system.and.conceptualizing.how.the.system.interacts.with.its.environment. In.many.projects.conceptual.modeling.is.where.architectural.design.begins.since.system. decomposition.is.essential.to.developing.effective.conceptual.models. Specification and Validation Specification.is.the.activity.of.the.requirements.phase.where.the.results.of.elicitation.and. analysis.are.formally.captured.and.documented.in.an.appropriate.format.for.the.use.and.

--- Chunk 165 ---
Tokens: 370
Type: sentence-based
Text:
analysis.are.formally.captured.and.documented.in.an.appropriate.format.for.the.use.and. review.of.all.stakeholders.The.format.of.the.specification.varies.depending.on.the.develop- ing.organization.or.project.however.it.is.typically.produced.as.a.document.or.its.electronic. equivalent. (Abran.et.al.2005).and.is.referred.to.as.the.software.requirements.specifica- tion.(SRS).When.specifying.requirements.it.is.important.that.each.requirement.exhibit. .certain.characteristics.desired.for.designing.successful.systems.including.the.following: . Specific . Correct . Complete . Consistent . Attainable . Verifiable TABLE 3.3 Common.Criteria.for.Requirement.Classification Criteria Description Functional.vs. nonfunctional Classification.that.differentiates.between.requirements.that.specify.the.functional. aspects.of.the.system.versus.the.ones.that.place.constraints.on.how.the.functional. aspects.are.achieved Product.vs.process Requirement.placed.on.the.system.product.versus.requirements.placed.on.the.process. employed.to.build.the.product Imposed.vs.derived Requirements.imposed.by.stakeholders.versus.requirements.that.are.derived.by.the. development.team Principles of Software Architecture  85 Once. requirements. are. specified. and. the. SRS. is. created. validation. can. occur. .Requirements.validation.is.the.process.of.ensuring.(through.well-known.techniques).that. the.SRS.provides.a.complete.and.correct.representation.of.what.the.stakeholders.need. (Laplante 2009).

--- Chunk 166 ---
Tokens: 389
Type: sentence-based
Text:
(Laplante 2009). Specific Requirements.need.to.be.specified.in.a.clear.concise.and.exclusive.manner.Clear.require- ments.are.not.open.to.interpretation.unclear.or.ambiguous.requirements.lead.to.incorrect. designs.incorrect.implementations.and.deceptive.validation.during.test.Concise.require- ments.are.brief.and.to.the.point.and.are.therefore.easier.to.understand.Finally.exclusive. requirements.specify.one.and.only.one.thing.making.them.easier.to.verify.Consider.the. following.statements: . The.software.needs.to.provide.an.easy-to-use.interface.that.is.it.must.be.usable. . Speed.is.a.concern.therefore.the.software.should.operate.with.high.performance. . Software. evolution. is. a. concern. therefore. the. software. shall. be. testable. and. maintainable. These.statements.provide.important.information.to.begin.thinking.about.what.the.cus- tomer.wants.and.expects.from.the.software.system.However.in.their.current.form.the. statements.are.too.generic.to.use.as.a.basis.for.design.construction.and.verification.of. software.systems.For.example.a.console-based.user.interface.may.be.highly.visible.for. the.systems.developers.but.not.its.customers.or.intended.users.Alternatively.the.systems. technical. developers. may. interpret. speed. as. the. system. responding. to. received. mes- sage.within.5.milliseconds.anything.above.would.be.considered.an.infeasible.solution. Designing.the.system.based.on.this.interpretation.may.entail.sacrificing.other.functions. that.may.be.important.to.customers.and.users.when.all.the.while.customers.and.intended.

--- Chunk 167 ---
Tokens: 395
Type: sentence-based
Text:
that.may.be.important.to.customers.and.users.when.all.the.while.customers.and.intended. users.perceived.speed.as.receiving.responses.within.2.seconds.When.left.unresolved.state- ments.like.these.become.a.major.reason.for.the.failure.of.the.project.Examples.of.specific. requirements.are.presented.in.Table 3.4. TABLE 3.4 Example.of.Specific.and.Nonspecific.Requirements Specific Requirement No The.software.shall.search.the.database. Yes The.software.shall.search.for.a.product.using.the.product.ID. No The.software.shall.be.secure. Yes The.software.shall.authenticate.users.with.user.ID.and.password. No The.software.shall.be.secure.and.fast. Yes The.software.shall.authenticate.users.with.user.ID.and.password. Server.acknowledgment.message.shall.be.sent.within.12.second.from.the.time.a.request.is.received. 86  Software Engineering Design Correct Requirements.need.to.be.correct.in.the.sense.that.they.must.accurately.describe.a.desired. system.function.Similar.to.ambiguous.or.unclear.requirements.specifying.incorrect.system. functions.leads.to.a.chain.of.incorrect.solutions.in.subsequent.development.phases.In.some. cases.correctness.of.requirements.is.easily.identified.in.others.it.is.not.To.illustrate.this. problem.Laplante. (2009).presents.an.example.based.on.requirements.for.a.computer.secu- rity.system.for.which.it.requires.users.to.log.on.using.a.unique combination.of.user.ID.and. password.In.this.case.when.users.attempt.to.log.on.using.an.already.existing.user.name.or. password.the.system.is.required.to.reject.the.attempt.therefore.giving.insight.into.someone.

--- Chunk 168 ---
Tokens: 364
Type: sentence-based
Text:
password.the.system.is.required.to.reject.the.attempt.therefore.giving.insight.into.someone. elses.logon.information.Incorrect.requirements.when.left.unchecked.can.lead.to.incor- rect.or.undesired.behavior.such.as.the.vulnerability.found.in.the.computer.security.system. described.above.Examples.of.correct.and.incorrect.requirements.are.presented.in.Table 3.5. Complete Requirements.should.be.complete.both.individually.and.as.collective.set.This.means.that. each.requirement.should.be.specified.thoroughly.so.that.it.absolutely.describes.the.func- tions.required.to.meet.some.need.Collectively.requirements.need.to.provide.complete. specification.of.the.softwares.required.functionality.in.the.SRS.Incomplete.requirements. lead.to.incomplete.designs.which.in.turn.leads.to.incomplete.construction.of.the.software. system.Requirements.that.are.complete.help.clarify.questions.during.construction.and. testing.by.providing.the.information.necessary.to.disambiguate.or.prevent.misinterpre- tations.of.required.functionality.Consider.requirements.for.a.software.system.that.sup- ports.generation.of.product.reports.An.example.of.an.incomplete.requirement.created.for. this.system.is.presented.in.Table 3.6.As.seen.determining.incomplete.requirements.is.not. always.an.easy.task. As.seen.the.first.requirement.presented.in.Table 3.6.specifies.the.systems.function.to. generate.product.reports.this.is.a.good.requirement.in.the.sense.that.it.specifies.a.function.

--- Chunk 169 ---
Tokens: 356
Type: sentence-based
Text:
generate.product.reports.this.is.a.good.requirement.in.the.sense.that.it.specifies.a.function. TABLE 3.5 Example.of.Correct.and.Incorrect.Requirements Correct Requirement No The.software.shall.require.users.to.log.on.using.a.unique.combination.of.user.ID.and.password. Yes The.software.shall.require.users.to.log.on.using.a.user.ID.and.password. The.software.shall.require.users.to.log.on.using.a.valid.e-mail.address. TABLE 3.6 Example.of.Complete.and.Incomplete.Requirements Complete Requirement No The.software.shall.generate.product.reports. Yes The.software.shall.generate.product.reports.consisting.of.product.description.picture.and.price. Product.reports.shall.be.in.PDF.format. Principles of Software Architecture  87 that.the.system.must.perform.However.when.additional.information.is.available.this. requirement.becomes.incomplete.when.this.information.is.not.specified.and.is.necessary. for.providing.the.correct.function.that.meets.a.particular.stakeholders.need.Consider.the. case.where.products.have.vast.amounts.of.information.such.as.color.dimensions.store. location.history.and.other.product.information.Generating.reports.containing.all.prod- uct.information.may.be.undesirable.if.the.intended.reporting.function.requires.only.the. products.description.picture.and.price.In.this.case.making.requirements.as.complete. as.possible.improves.the.efficiency.of.the.construction.and.verification.phases.Consider.

--- Chunk 170 ---
Tokens: 389
Type: sentence-based
Text:
as.possible.improves.the.efficiency.of.the.construction.and.verification.phases.Consider. another.case.where.there.is.a.need.for.a.client.system.to.interoperate.with.two.existing.leg- acy.servers.by.sending.and.receiving.messages.back.and.forth.using.two.different.(already. existing).messaging.specifications.A.requirement.that.fails.to.specify.a.mandate.to.inter- operate.with.both.existing.servers.supporting.both.messaging.specification.may.easily.lead. to.client.systems.that.are.unable.to.interoperate.with.one.of.the.servers.therefore.render- ing.the.client.unusable.for.the.system.in.mind.Completeness.is.hard.because.it.is.not. always.obvious.or.it.is.sometimes.too.difficult.to.determine.when.information.is.missing. (Laplante 2009). Consistent Requirements. are. consistent. when. they. do. not. preclude. the. design. or. construction. of. other.requirements.When.they.do.individual.requirements.or.the.SRS.as.a.whole.are. referred.to.as.inconsistent.Inconsistent.requirements.are.hard.to.resolve.since.they.almost. always.originate.from.different.stakeholders.needs.When.this.occurs.negotiation.and. trade-offs.need.to.occur.to.consolidate.the.requirements.and.provide.a.consistent.specifica- tion.Requirements.can.also.be.inconsistent.due.to.incorrect.requirements.In.these.cases. requirements.are.made.consistent.easily.by.removing.them.from.the.SRS. Attainable Requirements.that.are.unattainable.serve.no.purpose.Attainability.is.a.property.that.spans. many.different.characteristics.of.the.software.system.including.product.characteristics.

--- Chunk 171 ---
Tokens: 383
Type: sentence-based
Text:
many.different.characteristics.of.the.software.system.including.product.characteristics. such.as.functionality.as.well.as.project.characteristics.such.as.cost.and.schedule.When. specifying.requirements.it.is.important.to.evaluate.their.attainability.under.both.cost.and. schedule.constraints.Examples.of.attainable.and.unattainable.requirements.are.presented. in.Table 3.7.As.seen.although.it.is.nice.to.develop.software.without.platform.limitations. now.or.in.the.future.verifying.this.requirement.is.impossible.since.it.is.unattainable. TABLE 3.7 Example.of.Attainable.and.Unattainable.Requirements Attainable Requirement No The.software.shall.execute.on.all.future.operating.systems. Yes The.software.shall.execute.on.the.Microsoft.Windows.7.platform. 88  Software Engineering Design Verifiable Perhaps.the.most.obvious.desirable.characteristic.of.requirements.in.practical.applications.is. their.verifiability.Requirements.that.cannot.be.verified.cannot.be.claimed.as.met.Inability. to.verify.requirements.points.to.a.serious.flaw.early.on.in.the.development.project.since. requirements.are.the.driving.force.of.all.software.development.activities.In.some.cases.veri- fying.requirements.can.include.a.complex.and.costly.task.Typically.requirements.that.are. unclear.or.ambiguous.lead.to.unverifiable.requirements.Before.engaging.in.any.design.or. construction.work.all.requirements.in.the.SRS.must.be.evaluated.and.analyzed.for.their. verifiability.Examples.of.verifiable.and.unverifiable.requirements.are.presented.in.Table 3.8.

--- Chunk 172 ---
Tokens: 386
Type: sentence-based
Text:
verifiability.Examples.of.verifiable.and.unverifiable.requirements.are.presented.in.Table 3.8. Skill Development 3.3: Requirements Engineering Consider.the.use.case.models.created.as.part.of.Skill.Development.2.2.that.show.the. five.most.important.functions.that.your.home.personal.computer.system.needs.to.pro- vide.Create.a.list.of.requirements.(three.per.characteristic).for.the.computer.system. that.meet.the.following.characteristics.specific.correct.complete.consistent.attain- able.and.verifiable.Share.the.list.of.18.requirements.with.a.peer.and.have.him.or.her. explain.to.you.what.the.requirements.specify.Is.your.understanding.of.the.require- ments.consistent.with.that.of.your.peer? DESIGNING THE ARCHITECTURE In. a. typical. waterfall. model. for. software. development. once. the. software. specification. (i.e, SRS).is.validated.the.architectural.design.effort.can.begin.In.practical.applications. following.a.strict.waterfall.model.is.rarely.productive.since.new.knowledge.acquired.dur- ing.the.development.process.forces.iterative.approaches.between.requirements.and.archi- tectural.design.As.discussed.in.previous.sections.architectural.designs.can.begin.as.early. as.the.analysis.activity.of.the.requirements.phase.where.conceptual.models.of.the.system. are.devised.In.either.case.be.it.during.requirements.or.design.designing.architectures. require.the.selection.of.particular.perspectives.for.design.that.are.appropriate.for.describ- ing.the.system.to.be.developed.To.this.end.several.models.have.been.created.that.suggest.

--- Chunk 173 ---
Tokens: 389
Type: sentence-based
Text:
require.the.selection.of.particular.perspectives.for.design.that.are.appropriate.for.describ- ing.the.system.to.be.developed.To.this.end.several.models.have.been.created.that.suggest. popular.views.that.are.useful.in.the.design.of.most.systems.These.models.propose.address- ing.the.systems.architectural.design.from.perspectives.that.are.common.to.most.software. TABLE 3.8 Example.of.Verifiable.and.Unverifiable.Requirements Verifiable Requirement No The.system.shall.maximize.communication.speed. Yes The.systems.data.rate.shall.be.no.less.than.1.Mbps. Principles of Software Architecture  89 systems.and.provide.designers.with.a.structured.approach.for.modeling.the.architecture. of.software-intensive.systems.Two.popular.models.are.Kruchtens.(1995).4.1.view.model. and.Siemens.4.views.model.(Hofmeister.Nord.and.Soni.2000). The 4  1 View Model In.1995.Philippe.Kruchten.published.an.influential.paper.that.proposed.modeling.software. architectures.using.different.perspectives.each.perspective.provides.avenues.for.address- ing.problems.from.different.angles.and.when.combined.the.set.of.models.created.from. each. perspective. helps. form. the. software. architecture. Kruchtens. model. concentrated. on.four.main.views.logical.process.development.and.physical.Modeling.systems.from. each.view.requires.addressing.design.problems.of.different.natures.such.as.problems.that. deal.with.the.logical.system.structure.or.problems.that.deal.with.dynamic.concurrency. .system.issues.To.ensure.consistency.among.all.four.views.the.users.perpective.is.captured.

--- Chunk 174 ---
Tokens: 387
Type: sentence-based
Text:
.system.issues.To.ensure.consistency.among.all.four.views.the.users.perpective.is.captured. through.several.key.use.cases.Today.Kructhens.41.view.model.presented.in.Figure 3.2. is.used.as.a.basis.for.the.rational.unified.process.(Bass.et.al.2003). The.41.model.provides.an.adequate.framework.for.modeling.the.architecture.of.most. software.systems.However.adoption.of.the.model.varies.from.organization.to.organiza- tion.and.from.project.to.project.For.example.when.concurrency.is.not.an.issue.modeling. the.system.from.a.process.view.makes.little.to.no.sense.Similarly.for.systems.that.reside. in.one.node.and.in.which.the.physical.properties.of.their.deployment.are.not.of.concern. modeling.them.using.the.physical.view.provides.little.to.no.benefit.Typically.all.software. systems.benefit.from.the.logical.view.therefore.designs.elements.from.this.view.should.be. incorporated.into.the.software.architecture. User View The.user.view.of.a.software.system.represents.the.behavior.that.the.system.exhibits.to.its. users.Specifically.the.user.view.depicts.how.users.interact.with.the.system.and.how.the. specific.sequences.of.inputs.and.outputs.occur.during.software.operation.Users.represent. anyone.who.interacts.with.the.software.system.such.as.operators.software.testers.analysts. and.quality.As.part.of.this.view.UML.use.case.models.can.be.used.to.drive.scenarios.that. provide.storylines.and.to.promote.consistency.among.all.other.models.The.scenarios.cre- ated.can.help.capture.important.system.functions.and.discover.new.knowledge.that.drives.

--- Chunk 175 ---
Tokens: 394
Type: sentence-based
Text:
provide.storylines.and.to.promote.consistency.among.all.other.models.The.scenarios.cre- ated.can.help.capture.important.system.functions.and.discover.new.knowledge.that.drives. Logical View Development View Process View Physical View User View FIGURE 3.2 41.view.model.for.software.architecture. 90  Software Engineering Design architectural.design.decisions.The.user.view.also.provides.an.effective.source.of.informa- tion.for.verifying.and.validating.system.functions.after.the.system.is.built.In addition.to. UML.use.cases.UML.activity.diagrams.can.be.used.to.flush.out.important.user.interactions. that.are.important.during.architectural.design.(Pressman.2010). Process View The.process.view.of.a.software.system.represents.the.dynamic.or.behavioral.aspects.of.the. software.system.where.the.main.units.of.analysis.are.processes.and.threads.Using.this. view.software.systems.are.decomposed.into.processes.and.threads.to.address.design.issues. that.deal.with.the.dynamic.flow.of.control.between.architectural.elements.such.as.concur- rency.distribution.systems.integrity.fault.tolerance.and.other.nonfunctional.require- ments. (Kruchten. 1995). Since. analysis. using. the. process. view. is. behavioral. in. nature. behavioral.UML.diagrams.can.be.used.efficiently.to.address.issues.pertinent.to.the.process. views.Particularly.UML.sequence.and.communication.diagrams.together.with.the.active. object.notation.(presented.in.Chapter.2).can.be.used.to.evaluate.analyze.and.characterize. the.systems.capabilities.from.the.process.perspective.This.view.is.necessary.for.projects.

--- Chunk 176 ---
Tokens: 396
Type: sentence-based
Text:
the.systems.capabilities.from.the.process.perspective.This.view.is.necessary.for.projects. that.need.to.meet.performance.and.availability.requirements.by.modeling.aspects.of.con- currency.distribution.and.fault.tolerance. Physical View The.physical.view.of.a.software.system.represents.the.deployment.aspects.of.software.systems. where.the.main.elements.of.analysis.are.nodes.connections.between.nodes.and.maps.of. software.artifacts.to.nodes.The.physical.view.focuses.on.modeling.of.elements.that.directly. affect. quality. requirements. such. as. availability. performance. and. scalability. (Kruchten. 1995).For.example.consider.a.case.where.system.quality.is.measured.in.part.by.the.avail- ability.of.the.system.That.is.systems.are.perceived.as.low.quality.when.they.fail.to.provide.a. specified.behavior.In.this.case.availability.can.be.addressed.via.redundancy.of.processors.or. complete.nodes.which.both.can.be.depicted.using.UML.deployment.diagrams.The.identifi- cation.of.redundant.nodes.using.the.physical.view.requires.downstream.design.and.develop- ment.to.think.about.techniques.for.identifying.faults.and.swapping.between.primary.and. redundant.nodes.when.necessary.to.support.the.systems.availability.Similarly.aspects.that. affect.system.performance.must.be.addressed.using.the.physical.view.When.performance. is.measured.with.throughput.the.physical.view.of.systems.must.identify.the.elements.that. directly.impact.this.metric.such.as.required.bandwidth.between.a.client.and.server. In. some. applications. modeling. system. deployment. may. require. one. or. more. UML.

--- Chunk 177 ---
Tokens: 388
Type: sentence-based
Text:
UML. deployment.diagrams.Different.deployment.diagrams.may.be.necessary.to.model.dif- ferent.deployment.configurations.of.the.same.software.system.for.example.deployments. of.software.systems.in.testing.environments.or.in.different.locations.where.deployment. configurations.may.differ.In.each.case.the.physical.view.provides.insight.into.necessary. elements.that.directly.affect.the.perceived.quality.of.the.software.system.An.example.of. the.physical.view.of.software.systems.is.presented.as.a.deployment.diagram.in.Chapter.2. Principles of Software Architecture  91 Development View The.development.view.of.software.systems.represents.the.software.development.configu- ration.aspects.of.the.software.system.where.the.main.units.of.decomposition.are.actual. physical.files.and.directories.The.development.view.is.used.to.analyze.the.system.from.the. perspective.of.how.logical.components.map.to.physical.files.and.directories.These.analyses. can.be.employed.to.address.concerns.that.deal.with.ease.of.development.reusability.con- straints.imposed.by.tool.sets.allocation.of.work.to.teams.cost.evaluation.and.planning. monitoring. the. projects. progress. portability. and. security. (Kruchten. 1995). In UML. architectural.elements.resulting.from.analyzing.systems.from.the.developments.perspec- tive.can.be.documented.using.package.diagrams.in.combination.with.components.and. class.diagrams.as.well.as.notes.tagged.values.and.constraints.to.enhance.the.meaning. of.the.diagrams.This.way.components.can.be.mapped.to.the.hierarchy.of.files.in.the.file.

--- Chunk 178 ---
Tokens: 360
Type: sentence-based
Text:
of.the.diagrams.This.way.components.can.be.mapped.to.the.hierarchy.of.files.in.the.file. system.and.their.interrelationships.and.process.for.building.one.or.more.versions.of.the. software.system.can.be.carefully.specified. Logical View The.logical.view.of.a.software.system.is.used.to.decompose.systems.into.logical.compo- nents.that.represent.the.structural.integrity.that.supports.functional.and.nonfunctional. requirements.Examples.of.architectural.design.elements.using.the.logical.view.are.pre- sented.in.Figure 2.1.Using.this.view.the.static.structure.of.the.system.can.be.modeled. using.high-level.diagrams.to.decompose.abstract.and.encapsulate.the.services.that.the. system.needs.to.provide.to.its.users.By.using.these.diagrams.the.major.components.their. interfaces.and.their.associations.with.all.other.components.are.identified.Architectural. logical.designs.exist.at.a.higher.level.of.abstraction.than.detailed.designs.and.can.be.mod- eled.using.box.and.line.diagrams.UML.component.diagrams.package.diagrams.or.class. diagrams.Architectural.logical.designs.provide.the.building.blocks.for.detailed.design. therefore.they.are.indispensable.in.the.architectural.design.of.software.systems. Skill Development 3.4: Designing with Architectural Views As. seen. views. are. used. to. present. the. system.from. particular. perspectives. so. that. design.elements.particular.to.that.perspective.can.serve.as.tool.for.evaluating.a.desired.

--- Chunk 179 ---
Tokens: 383
Type: sentence-based
Text:
design.elements.particular.to.that.perspective.can.serve.as.tool.for.evaluating.a.desired. property.of.the.system.Using.the.logical.view.the.systems.reusability.can.be.evalu- ated.through.the.physical.view.the.systems.availability.can.be.examined.and.the.pro- cess.view.can.be.used.to.evaluate.the.systems.performance.Consider.the.architectural. design.of.two.systems.a.banking.information.system.and.a.safety-critical.medical.sys- tem.For.each.system.come.up.with.appropriate.viewsfeel.free.to.come.up.with.ones. other.than.those.presented.in.this.chapterand.how.they.could.help.address.particular. concerns.in.each.Discuss.and.justify.your.results.with.peers. 92  Software Engineering Design Components and Connectors In. Chapter. 2. components. were. presented. to. depict. units. of. the. logical. architecture. Conceptually.a.component.is.an.entity.that.encapsulates.some.functionality.and.provides. services.through.well-known.interfaces.By.definition.then.components.can.be.replace- able.by.other.components.that.provide.equal.interfaces.Components.are.building.blocks. that.exemplify.the.general.design.principles.of.abstraction.encapsulation.and.modular- ization.presented.in.Chapter.1.Prior.to.UML.2.0.the.concept.of.components.was.different. in.that.it.denoted.specifically.a.physically.deployable.unit.which.limited.the.use.of.the. component.entity.in.architectural.diagrams.However.this.is.not.the.case.in.the.current. version.of.the.UML.so.the.component.concept.can.be.used.to.model.logical.modular. parts.of.a.system.

--- Chunk 180 ---
Tokens: 361
Type: sentence-based
Text:
parts.of.a.system. Components.do.not.exist.in.isolation.they.are.part.of.a.logical.architecture.that.depicts. interactions.with.other.components.In.some.applications.interactions.between.compo- nents.are.far.more.complicated.than.what.UMLs.typical.relationships.(e.g.association. dependency). can. reflect. In. these. systems. the. proper. identification. and. description. of. such.interactions.can.have.a.profound.impact.on.quality.requirements.For.this.reason.the. concept.of.a.connector.is.devised.A.connector.is.an.architectural.entity.that.abstracts.the. complexities.of.the.interactions.between.components.Therefore.connectors.can.represent. interaction.between.components.as.simple.procedure.calls.shared.data.access.or.more. advanced.mechanisms.such.as.remote.procedure.calls.(Taylor.Medvidovic.and.Dashofy. 2009).Together.components.and.connectors.can.be.used.as.fundamental.building.blocks. for.large-scale.software.architectures. Designing Logical Architectural Elements Using Data Flows There.are.many.approaches.for.designing.logical.architectures.These.approaches.are.typi- cally.associated.with.the.overall.design.strategy.selected.for.a.given.product.For.example. when.using.the.structured.design.strategy.a.disciplined.approach.is.employed.to.decom- pose. systems. into. independent. single-purpose. modules. using. an. iterative. top-down. approach.The.main.focus.of.structured.design.is.on.the.functions.that.systems.need.to.

--- Chunk 181 ---
Tokens: 398
Type: sentence-based
Text:
approach.The.main.focus.of.structured.design.is.on.the.functions.that.systems.need.to. provide.the.decomposition.of.these.functions.and.the.creation.of.modules.that.incorpo- rate.these.functions.Structured.design.approaches.are.typically.employed.after.structured. analysis.where.the.main.purpose.is.to.derive.a.structure.chart. (i.e.logical.software.archi- tecture).from.data.flow.diagrams.(DFDs).A.popular.approach.for.creating.structure.charts. includes.employing.transform.analysis.(Pressman.2010).When.using.transform.analysis. the.flow.of.data.through.the.system.is.analyzed.using.DFDs.to.derive.data.transformations. (i.e.functions).required.to.generate.the.systems.outputs.Initially.a.level.0.DFD.is.used.to. represent.the.initial.context.of.the.system.As.the.DFD.is.refined.further.levels.of.the.DFD. are.produced.to.expose.further.transformations.of.different.scope.This.refinement.process. is.iteratively.done.until.all.transformations.are.identified.and.grouped.into.components.to. form.the.logical.architecture.of.the.system. Principles of Software Architecture  93 Designing Logical Architectural Elements Using Styles and Patterns In.the.1990s.the.software.engineering.community.began.paying.attention.to.recurring. architectural.solutions.in.terms.of.specific.elements.and.their.relationships.These.solu- tions.were.known.as.architectural.styles.and.patterns.these.terms.are.used.interchangeably. throughout.(see.Chapter.4).Architectural.patterns.provide.the.means.for.software.architects. to.reuse.architectural.design.solutions.in.different.projects.Buschmann.Meunier.Rohnert.

--- Chunk 182 ---
Tokens: 389
Type: sentence-based
Text:
to.reuse.architectural.design.solutions.in.different.projects.Buschmann.Meunier.Rohnert. Sommerlad.and.Stal.(1996).introduced.a.catalog.of.architectural.patterns.that.conveyed. fundamental.structural.organization.for.software.systems.including.predefined.compo- nents.their.responsibility.and.rules.for.specifying.the.relationship.between.them.Together. these.architectural.patterns.serve.as.a.blueprint.for.designing.elements.of.the.logical.archi- tecture.of.particular.groups.of.systems.The.application.of.architectural.patterns.to.the. development.of.software.systems.occurs.at.the.highest.level.of.abstraction.in.the.design.pro- cess.Since.they.are.used.to.create.architectural.elements.they.do.not.describe.the.detailed. design.of.the.system.and.therefore.cannot.be.directly.translated.into.code.Identifying.pat- terns.at.the.architectural.level.(and.designing.around.them).improves.the.quality.of.the.final. system.by.reducing.the.design.of.logical.architectural.elements.to.a.collection.of.interacting. components.whose.expected.behavior.is.well.understood.Examples.of.architectural.design. elements.using.architectural.patterns.are.presented.in.Chapter.4. Designing the Process Architecture Whereas.logical.elements.of.the.software.architecture.model.static.structural.aspects.of.the. software.system.process.elements.model.how.elements.interact.to.evaluate.certain.aspects. of.the.softwares.quality.such.as.concurrency.In.software.systems.concurrency.is.achieved. mainly. though. multithreading. or. multiprocessing. the. system. Multithreading. or.

--- Chunk 183 ---
Tokens: 378
Type: sentence-based
Text:
or. multi- processing.applications.introduce.concurrency.issues.that.require.careful.analysis.to.ensure. that. architectural. designs. account. for. effective. synchronization. techniques. Concurrent. designs.that.work.on.the.same.data.are.tougher.to.design.and.manage.since.they.can.lead.to. software.errors.that.are.hard.to.find.(e.g.race.conditions).and.increase.the.complexity.of.the. software.development.effort.To.fully.understand.and.model.issues.such.as.performance.one. must.have.some.understanding.of.the.universal.mechanisms.in.place.when.software.applica- tions.execute.Although.code has no place during the software architecture activity.every.soft- ware.architect.must.understand.how.the.modeling.of.process.elements.affects.the.downstream. work.performed.during.construction.For.this.reason.an.unconventional.learning.approach. involving.code.in.the.study.of.software.architecture.to.introduce.important.architectural. concepts.and.present.the.process.view.of.software.architecture.is.employed.This.under- standing.is.essential.when.modeling.parts.of.the.software.that.will.affect.its.process.quality. Processes Processes. and. threads. are. fundamental. units. of. execution. in. todays. modern. software. .systems.They.are.created.managed.and.terminated.by.the.operating.system.A.process.is. 94  Software Engineering Design a.unit.of.software.execution.that.is.a.program.in.execution.When.you.execute.software. for.example.an.executable.(.exe).file.in.Windows.a.process.is.created.by.the.Windows.

--- Chunk 184 ---
Tokens: 396
Type: sentence-based
Text:
for.example.an.executable.(.exe).file.in.Windows.a.process.is.created.by.the.Windows. operating.system.This.process.has.some.unique.characteristics.that.distinguish.from.other. processes.Whenever.a.process.is.created.the.operating.system.creates.a.process.control. block.(PCB).with.information.required.by.the.operating.systems.to.schedule.and.manage. the.process.This.information.can.include.the.program.counter.process.state.registers.and. stack.In.single-processor.systems.the.operating.system.uses.this.information.to.switch. between.different.processes.while.maintaining.the.integrity.of.all.processes.This.switch- ing.known.as.a.context switch.requires.saving.the.information.from.a.PCB.of.the.active. process.and.loading.a.PCB.of.the.new.process.into.memory.to.continue.execution.A.con- text.switch.is.pure.overhead.since.the.processors.time.is.spent.doing.management.tasks. rather.than.useful.work.for.the.software.system.however.it.enables.concurrency.These. operations.happen.so.quickly.that.programs.executing.are.perceived.as.executing.concur- rently.In.single-processor.systems.this.pseudo-concurrency.allows.designers.to.model.the. system.with.concurrency.in.mind.In.multiprocessor.systems.processes.are.scheduled.for. execution.in.more.than.one.processor.so.actual.concurrency.is.achieved.In.either.case. concurrency.is.used.to.increase.the.performance.of.the.software.system.Software.systems. especially.distributed.systems.can.be.designed.as.systems.of.multiple.processes.executing. on.the.same.or.different.networked.computing.platforms.Multiple.processes.are.used.to.

--- Chunk 185 ---
Tokens: 381
Type: sentence-based
Text:
on.the.same.or.different.networked.computing.platforms.Multiple.processes.are.used.to. leverage.off.the.operating.system.to.achieve.concurrency.of.operations.and.increase.the. .systems.performance.That.is.modern.operating.systems.provide.scheduling.mechanisms. that.allow.multiple.processes.to.execute.concurrently.to.maximize.CPU.usage. Threads Threads.sometimes.called.lightweight.processes.are.similar.to.processes.in.that.they.allow. code.to.be.compartmentalized.in.a.way.that.they.are.schedulable.as.independent.flows. of.control.by.the.operating.systems.In.most.modern.operating.systems.threads.execute. within.a.single.process.in.a.one-to-many.fashionthat.is.one.process.can.contain.one.or. more.threads.Threads.therefore.can.be.thought.of.as.small.schedulable.and.sequential. program.units.executing.(typically).within.a.process.Processes.that.execute.with.only.one. thread.can.be.described.as.sequential.or.serial.which.means.that.the.commands.in.the. programs.are.executed.in.turn.so.that.a.specific.command.is.executed.only.after.the.previ- ous.command.is.finished.In.single-threaded.applications.if.one.statement.halts.waiting. for.some.computer.resource.(e.g.inputoutput.resource).the.execution.of.the.program. blocks. until. the. resource. becomes. available. and. execution. can. continue. For. example. .consider.the.code.in.Listing.3.1. In.the.Windows.operating.system.when.the.code.in.Listing.3.1.is.compiled.and.built. a.file.with.an.exe.extension.is.created.When.this.file.is.executed.a.process.is.created.

--- Chunk 186 ---
Tokens: 392
Type: sentence-based
Text:
a.file.with.an.exe.extension.is.created.When.this.file.is.executed.a.process.is.created. with.one.thread.whose.body.of.execution.is.defined.by.the.main.function.In.this.case. the.operations.in.the.main.thread.will.execute.sequentially.until.the.return.operation.is. encountered.at.which.point.the.operating.system.destroys.both.thread.and.process.and.the. program.is.finished.Since.there.is.only.one.independent.flow.of.execution.(i.e.one.thread). Principles of Software Architecture  95 the.program.will.halt.at.the.cinnumber.line.until.a.number.followed.by.the.return. key.is.entered.as.input.This.is.true.because.the.cin.line.results.in.a.blocking call.to.the. operating.system.that.is.the.main.thread.will.block.execution.until.input.is.provided. While.blocking.the.program.wastes.execution.time.in.the.sense.that.it.is.not.utilizing.the. processor.for.achieving.other.necessary.application-dependent.tasks.When.the.thread.is. blocked.the.process.can.accomplish.nothing.else.since.there.is.only.one.flow.of.execution. When.multiple.threads.execute.multiple.independent.flows.of.control.exit.so.that.if.one.is. in.a.blocking state.others.can.continue.executing.To.achieve.this.the.operating.system.needs. to.execute.context.switches.to.manage.the.program.execution.among.the.different.threads. in.pseudo-concurrent.fashion.at.the.expense.of.causing.similar.but.reduced.overhead.as.the. ones.described.with.processes.By.allowing.the.executing.software.to.perform.other.activi- ties.while.waiting.for.some.resource.its.performance.may.be.enhanced.Consider.Listing.3.2.

--- Chunk 187 ---
Tokens: 396
Type: sentence-based
Text:
ones.described.with.processes.By.allowing.the.executing.software.to.perform.other.activi- ties.while.waiting.for.some.resource.its.performance.may.be.enhanced.Consider.Listing.3.2. for.a.number-guessing.game.where.the.executing.software.counts.until.user.input.is.received. and.then.determines.if.the.input.(i.e.guessed.number).matches.the.counted.number. When.this.program.executes.a.single.process.is.created.and.its.main.thread.is.executed. As.the.main.thread.executes.sequentially.a.counter.object.of.ThreadCounter.type. is.created.The.ThreadCounter.type.abstracts.the.creation.of.another.thread.that.is. started.by.calling.the.objects.count().method.which.results.in.an.independent.flow.of. Listing 3.1: C Code for Single-Threaded Application include iostream using namespace std; int main( int argc, char argv )   A number to be guessed. const int THE_NUMBER  10;  User input. int number;  Display message to user. coutGuess a number from 0-100:n;  Block waiting for user input. cinnumber;  Display results to user. coutYour guess is number, actual number is  THE_NUMBERendl;  End of program. return 0;  96  Software Engineering Design execution.created.tasked.with.counting.This.allows.the.main.thread.to.continue.execut- ing.sequentially.while.the.counter.thread.counts.The.main.thread.will.block.waiting.for. user.input.(via.cin).while.the.counter.thread.continues.to.count.therefore.introducing. concurrency.into.the.software.Once.user.input.is.received.the.main.thread.terminates. the.counter.thread.and.displays.the.results.This.process.is.presented.in.Figure 3.3.using.a.

--- Chunk 188 ---
Tokens: 379
Type: sentence-based
Text:
the.counter.thread.and.displays.the.results.This.process.is.presented.in.Figure 3.3.using.a. sequence.diagram.with.active.objects.relying.on.synchronous.and.asynchronous.messages. Notice.that.once.the.counter.threads.calls.its.start().method.it.counts.and.does.nothing. else.until.it.is.finished.counting.which.is.triggered.by.the.stop().method.This.is.modeled. using.the.synchronous.message.to.self. The.code.presented.in.Listing.3.2.serves.as.a.good.example.for.introducing.the.concept. of. concurrency. in. a. simplified. manner. Concurrency. issues. are. always. amplified. when. data. need. to. be. shared. among. concurrent. flows. of. executions. In. these. cases. correct. Listing 3.2: C Code for Concurrent Number-Guessing Game include iostream include ThreadCounter.h using namespace std; int main( int argc, char argv )   User input. int number;  Create the thread counter object. ThreadCounter counter;  Start the counter. counter.count();  Display message to user. coutGuess a number from 0-100:n;  Block waiting for user input. cinnumber;  Stop the counter. counter.stop();  Display results to user. coutYour guess is number, actual number is  counter.current()endl;  End of program. return 0;  Principles of Software Architecture  97 synchronization.mechanisms.need.to.be.in.place.to.ensure.the.proper.execution.of.the.soft- ware.system.Consider.the.case.of.a.communication.system.receiving.messages.concurrently. through.two.different.interfaces.Upon.receiving.messages.the.system.updates.its.message.

--- Chunk 189 ---
Tokens: 379
Type: sentence-based
Text:
through.two.different.interfaces.Upon.receiving.messages.the.system.updates.its.message. count.statistic.and.continues.on.to.process.each.message.Listing.3.3.presents.the.code.for. the.MessageStatistics.type.used.to.abstract.services.for.managing.message.statistics. As.seen.the.MessageStatistics.type.has.an.interface.method.to.increment.the. number.of.received.messages.throughout.the.system.Since.the.system.requires.concur- rency. each. independent. flow. of. message. processing. is. carried. out. using. two. different. threads.therefore.it.is.assumed.that.a.base.Thread.class.exists.that.abstracts.the.creation. and.management.of.threads.providing.a.simplified.interface.that.contains.start().and. stop().methods.to.execute.and.terminate.the.thread.In.addition.the.Thread.base.class. provides.an.abstract.method.run().used.by.derived.classes.to.provide.the.implementation. of.the.threads.main.(entry).function.and.an.isActive().method.to.determine.if.the. thread.should.continue.executing.or.not.With.such.framework.in.place.the.code.for.the. SerialReceiverThread.class.used.to.receive.messages.through.the.serial.communi- cation.interface.is.presented.in.Listing.3.4. As. seen. the. class. is. configured. with. a. reference. to. an. object. of. type. Message- Statistics.which.is.used.to.update.the.message.count.once.a.serial.message.is.received. Similarly.the.EthernetReceiverThread.class.is.designed.to.be.a.thread.that.waits. for.incoming.messages.via.the.Ethernet.interface.as.presented.in.Listing.3.5.

--- Chunk 190 ---
Tokens: 390
Type: sentence-based
Text:
for.incoming.messages.via.the.Ethernet.interface.as.presented.in.Listing.3.5. As.seen.this.class.is.also.initialized.using.a.reference.to.a.MessageStatistics.object. so.that.both.serial.and.Ethernet.threads.rely.on.the.same.data.structure.to.update.message. statistics.Consider.what.happens.when.objects.of.type.SerialReceiverThread.and. main : MainTread 1 : count( ) 2 : start( ) counter  1, wait 1 sec. counter  2, wait 1 sec. counter  3, wait 1 sec. counter  4, wait 1 sec. counter  5, wait 1 sec. counter  6, wait 1 sec. counter  7, wait 1 sec. 4 : stop( ) 3 : user input sd Concurrent Number Guessing Design counter : TreadCounter FIGURE 3.3 UML.design.for.concurrent.guessing.game. 98  Software Engineering Design EthernetReceiverThread.are.both.initialized.using.the.same.object.instance.of.the. MessageStatistics.class.as.illustrated.in.Listing.3.6.Once.instantiated.both.threads. start.to.receive.messages.via.their.respective.interfaces.The.main.thread.simply.waits.until. all.expected.messages.are.received. The.main.problem.with.Listing.3.6.can.be.traced.to.the.critical.section.of.code.inside.the. increment().method.of.the.MessageStatistics.class.A.critical section.is.a.code.segment. that.makes.changes.to.common.variables.such.as.the._messageCount.This.makes.software. more.challenging.to.design.and.evaluate.since.the.integrity.of.the.data.inside.the.critical.section. needs.to.be.preserved.Since.there.are.no.safeguards.to.ensure.the.proper.synchronization.of. multiple.threads.when.updating.the._messageCount.variable.both.threads.may.attempt.

--- Chunk 191 ---
Tokens: 380
Type: sentence-based
Text:
multiple.threads.when.updating.the._messageCount.variable.both.threads.may.attempt. to.update.the.message.count.at.the.same.time.therefore.resulting.in.unpredictable.results.that. may.hinder.the.systems.integrity.To.illustrate.this.point.consider.the.assembly.(lower-level). code.generated.to.increment.the._messageCount.variable.as.seen.in.Listing.3.7. Using.a.disassembly.tool.it.can.be.seen.that.the._messageCount.written.in.C. requires.three.assembly.lines.of.code.one.to.move.the.current.value.of._messageCount. Listing 3.3: C Code for Specification of the MessageStatistics Type class MessageStatistics  public:  Use constructor to set messageCount  0;  Method to increment number of received messages. void increment()   A message has been received, increment the current count. _messageCount;   Method to return the current number of messages received. int count()   Return the number of messages received. return _messageCount;   . private:  Variable used to keep track of the number of messages received. int _messageCount;  . ; Principles of Software Architecture  99 to.the.accumulator.eax.register.one.to.increment.the.value.and.the.last.one.to.move.the. results.back.from.the.eax.register.to.the.address.referenced.by.the._messageCount.vari- able.in.C.When.executed.concurrently.both.threads.of.execution.will.execute.the.opera- tions.However.the.order.in.which.they.are.executed.cannot.be.guaranteed.that.is.the.order. can.be.interleaved.in.some.arbitrary.fashion.Consider.the.interleaved.order.of.execution.

--- Chunk 192 ---
Tokens: 396
Type: sentence-based
Text:
can.be.interleaved.in.some.arbitrary.fashion.Consider.the.interleaved.order.of.execution. among.the.two.threadseach.receiving.messages.at.the.same.timepresented.in.Table 3.9. After.execution.the.value.of._messageCount.is.incorrectly.set.to.1.when.it.should. be 2.since.two.messages.were.received.This.phenomenon.is.known.as.a.race condition. and.occurs.when.two.processes.or.threads.operate.concurrently.on.the.same.data.and.the. outcome.of.the.execution.depends.on.the.particular.order.in.which.the.access.takes.place. This.example.shows.the.importance.of.designing.and.evaluating.architectural.elements. using. the. process. view. which. provides. the. appropriate. perspective. for. detecting. such. Listing 3.4: C Code for the Serial Message Processor Thread Class class SerialReceiverThread : public Thread  public:  Constructor. SerialReceiverThread(MessageStatistics stats)   Save the statistics object for later use. _stats  stats;  protected:  Threads main function. virtual void run()  while( isActive() )   Wait for a message via the serial interface. Once a message is received, increment count in the stats  object. _stats-increment();  Process received serial message. end while loop. end run() method. private:  The pointer to the stats object. MessageStatistics _stats; ; 100  Software Engineering Design cases.When.these.cases.are.detected.guards.in.the.design.can.be.introduced.to.protect.the. integrity.of.such.critical.sections.of.code.In.UML.such.design.evaluations.and.decisions. can.be.captured.using.the.synchronization.properties.such.as.Sequential, Guarded.and.

--- Chunk 193 ---
Tokens: 368
Type: sentence-based
Text:
can.be.captured.using.the.synchronization.properties.such.as.Sequential, Guarded.and. Concurrent.presented.in.Chapter.2.These.properties.place.constraints.in.process.models. to.support.concurrency.by.controlling.the.way.multiple.flows.of.execution.access.critical. sections.of.code.The.Sequential.synchronization.property.specifies.that.no.concurrency. management.mechanism.is.associated.with.an.operation.such.as.in.the.case.of.the.existing. increment.method.in.Listing.3.3.With.sequential.access.concurrency.conflicts.may.occur. so.clients.that.rely.on.the.operation.need.to.coordinate.so.that.only.one.invocation.occurs. at.any.given.point.The.Guarded.property.specifies.that.the.operation.can.be.invoked.from. Listing 3.5: C Code for the Serial Message Processor Thread Class class EthernetReceiverThread : public Thread  public:  Constructor. EthernetReceiverThread(MessageStatistics stats)   Save the statistics object for later use. _stats  stats;  protected:  Threads main function. virtual void run()  while( isActive() )   Block waiting for a message via the serial interface. Once a message is received, increment count in the stats  object. _stats-increment();  Process received Ethernet message. end while loop. end run() method. private:  The pointer to the stats object. MessageStatistics _stats; ; Principles of Software Architecture  101 Listing 3.6: C Code for Concurrent Application  Code to demonstrate the critical section concept in concurrent programs.

--- Chunk 194 ---
Tokens: 391
Type: sentence-based
Text:
MessageStatistics _stats; ; Principles of Software Architecture  101 Listing 3.6: C Code for Concurrent Application  Code to demonstrate the critical section concept in concurrent programs. include iostream include SerialReceiverThread.h include EthernetReceiverThread.h include MessageStatistics.h using namespace std; int main( int argc, char argv )   Number of messages received. int messagesReceived  0;  Number of messages expected. const int MESSAGES_EXPECTED  10;  Create the object to keep track of message statistics. MessageStatistics msgStats;  Create the thread to receive messages via serial interface. SerialReceiverThread serial(msgStats);  Create the thread to receive messages via Ethernet interface. EthernetReceiverThread ethernet(msgStats);  Start receiving messages through both interfaces. serial.start(); ethernet.start(); while( msgStats.count()  MESSAGES_EXPECTED )  coutMessages received: msgStats.count()endl;  if flag set, exit loop. Blocking call. Wait one second before checking again. sleep(1000);   Stop receiving through serial interface. serial.stop();  Stop receiving through Ethernet interface. ethernet.stop();  End of program. return 0;  102  Software Engineering Design multiple.independent.flows.simultaneously.but.only.one.flow.of.execution.is.allowed.to. commence.other.independent.flows.are.blocked.until.the.execution.of.a.currently.execut- ing.operation.under.the.currently.executing.thread.is.complete.When.using.the.Guarded. synchronization.property.it.is.the.responsibility.of.the.designer.to.ensure.that.concurrency.

--- Chunk 195 ---
Tokens: 400
Type: sentence-based
Text:
synchronization.property.it.is.the.responsibility.of.the.designer.to.ensure.that.concurrency. issues.such.as.starvation.and.deadlocks.do.not.occur.Finally.the.Concurrent.synchroniza- tion.property.specifies.that.multiple.invocations.may.occur.simultaneously.and.all.of.them. may.proceed.concurrently.Concurrency.is.achieved.in.languages.with.built-in.support.for. concurrency.such.as.Java.with.the.use.of.the.synchronized.property.To.resolve.the. issue.of.concurrency.caused.by.the.increment().method.the.Guarded.synchronization. concept.can.be.modeled.and.manifested.in.code.by.ensuring.that.the.critical.section.of.code. that.increments.the._messageCount.is.mutually.exclusive.to.both.threads.of.execution. This.can.be.achieved.by.employing.a.mutually.exclusive.(Mutex).object.typically.provided. by.the.operating.system.The.code.from.Listing.3.3.is.modified.using.pseudo-code.to.sup- port.concurrency.as.seen.in.Listing.3.8. The.concepts.presented.in.Listings.3.3.3.4.3.5.3.6.and.3.8.can.all.be.summarized.using. two.simple.UML.designs.as.seen.in.Figure 3.4. The.concepts.presented.so.far.are.essential.for.understanding.how.the.process.view.of. software.architecture.is.used.to.evaluate.and.design.for.performance.in.software.systems. These.concepts.play.a.key.role.in.designing.systems.that.meet.performance.and.availability. requirements.by.modeling.aspects.of.concurrency.distribution.and.fault.tolerance. Listing 3.7: Sample Assembly Program to Increment _ messageCount ; Move contents of _messageCount to eax register. mov eax, dword ptr _messageCount (417140h) ; Add one to the number in eax.

--- Chunk 196 ---
Tokens: 374
Type: sentence-based
Text:
mov eax, dword ptr _messageCount (417140h) ; Add one to the number in eax. add eax, 1 ; Copy the result from eax to _messageCount. mov dword ptr _messageCount (417140h), eax TABLE 3.9 Interleaved.Execution.in.Concurrent.Designs Time Source Operation _messageCount T0 Thread.1 mov.eax.dword.ptr._messageCount. (417140h) 0 T1 Thread.1 add.eax.1 0 T2 Thread.2 mov.eax.dword.ptr._messageCount. (417140h) 0 T3 Thread.2 add.eax.1 0 T4 Thread.1 mov.dword.ptr._messageCount. (417140h).eax 1 T5 Thread.2 mov.dword.ptr._messageCount. (417140h).eax 1 Principles of Software Architecture  103 EVALUATING THE ARCHITECTURE Architecture.evaluation.is.the.process.of.determining.how.well.suited.architecture.is.for. developing.a.system.that.meets.both.its.intended.functional.and.quality.requirements. From.a.functional.perspective.architectures.need.to.introduce.the.appropriate.abstrac- tions.for.the.services.that.the.system.is.required.to.provide.The.functional.properties.of.the. architecture.can.be.evaluated.using.the.identified.logical.components.assigning.require- ments.to.them.and.modeling.the.interactions.required.among.components.to.support.all. functional.requirements.On.the.other.hand.evaluating.the.architectures.ability.to.sup- port.expected.system.quality.requires.more.effort.to.ensure.that.the.proposed.architecture. provides.a.good.approach.for.a.systems.development.Evaluating.architectures.for.their. provided.quality.requires.the.investigation.and.breakdown.of.quality.goals.to.attributes.

--- Chunk 197 ---
Tokens: 378
Type: sentence-based
Text:
provided.quality.requires.the.investigation.and.breakdown.of.quality.goals.to.attributes. that.are.adequate.for.evaluation.The.architectural.evaluation.determines.the.appropriate- ness.for.supporting.these.quality.features.and.can.be.used.for.determining.their.relative. importance.and.how.they.impact.other.quality.attributes.supported.by.the.architecture. This.information.in.turn.is.used.to.evaluate.different.proposed.architectures.and.to.pri- oritize.quality.goals.so.that.design.trade-off.among.stakeholders.can.occur.Ultimately.the. evaluation.process.is.performed.until.a.solution.that.is.sufficiently.complete.and.accept- able.for.all.stakeholders.is.found.Although.there.is.no.universally.accepted.methodol- ogy.for.analyzing.and.evaluating.software.architectures.the.architecture.trade-off.analysis. method.(ATAM).approach.(Bass.et.al.2003).provides.a.rigorous.and.proven.methodology. for.such.endeavors. Listing 3.8: C Code for Guarded Implementation of the increment() method  Method to increment number of received messages. void increment()   Access Mutex. If unavailable, block until it becomes available. If you are here, it means that you have access to the Mutex. Once  in possession, no other thread of execution can gain access to the  Mutex, therefore this critical section of code is protected. Increment the message count. _messageCount;  Release the Mutex. The next thread waiting for the Mutex will gain  access to it, therefore gaining protected access to the critical  section of code.

--- Chunk 198 ---
Tokens: 396
Type: sentence-based
Text:
The next thread waiting for the Mutex will gain  access to it, therefore gaining protected access to the critical  section of code. 104  Software Engineering Design CHAPTER SUMMARY The.software.architecture.activity.corresponds.to.a.macrodesign.approach.for.transform- ing. software. requirements. into. design. elements. that. support. quality. and. functions. of. software.systems.Formally.software.architecture.is.defined.as.the.foundational.software. design.activity.that.evaluates.and.translates.software.requirements.(both.functional.and. nonfunctional).into.a.collection.of.design.elements.that.specify.structural.and.behavioral. aspects.of.the.major.components.of.the.system.together.with.their.provided.quality.and. _stats messageCount: int increment(): void Guarded count(): int _stats thread serial : SerialReceiverTread increment() Guarded increment() Guarded msqStats : MessageStatistics run(): void thread ethernet : EthernetReceiverTread EthernetReceiverTread MessageStatistics run(): void Structural View Behavioral View start(): void stop(): void run(): void isActive() : bool SerialReceiverTread Tread FIGURE 3.4 UML.concurrent.design.for.communication.elements. Principles of Software Architecture  105 interrelationships.required.to.support.the.detailed.design.and.construction.of.software. systems.and.the.product.resulting.from.such.activity.To.accomplish.all.of.this.software. architects.must.be.familiar.with.activities.from.the.requirements.engineering.discipline.so. that.inputs.to.the.software.architecture.activity.can.be.well.understood.and.formulated.in.

--- Chunk 199 ---
Tokens: 400
Type: sentence-based
Text:
that.inputs.to.the.software.architecture.activity.can.be.well.understood.and.formulated.in. such.a.way.that.supports.the.design.and.development.of.the.software.system.To.address. the.concerns.from.multiple.stakeholders.architects.model.architectural.elements.using. different.views.which.may.be.prescribed.by.popular.view.models.such.as.the.41.view. model.All.systems.use.the.logical.view.to.identify.and.structure.the.major.components. assign.responsibility.to.them.and.model.their.interactions.In.some.cases.architectural. styles.and.patterns.can.be.used.to.provide.architectural.(logical).solutions.to.common. architectural.problems.All.architectural.elements.designed.from.all.particular.views.form. the.software.architecture.which.can.be.used.to.establish.the.initial.framework.for.the. quality.of.the.system.Since.architecture.alone.cannot.guarantee.the.quality.of.the.system. processes.need.to.be.in.place.to.ensure.that.architectural.decisions.made.to.address.quality. concerns.are.maintained.throughout.the.development.life.cycle.The.software.architecture. lays.the.foundation.for.all.subsequent.work.in.the.development.process.and.serves.as.an. important.communication.reasoning.and.analysis.tool.for.the.development.and.mainte- nance.of.software.systems.Once.complete.the.detailed.design.activity.can.begin. REVIEW QUESTIONS . 1.What.is.software.architecture.and.how.does.it.differ.from.other.forms.of.design? . 2.How.can.software.architecture.affect.both.product.development.and.product.man- agement.activities? . 3.List.and.explain.the.common.tasks.performed.during.software.architecture. .

--- Chunk 200 ---
Tokens: 385
Type: sentence-based
Text:
. 4.What.are.the.common.input.constraints.and.outputs.found.during.architectural. problem.solving? . 5.Why. is. it. important. for. software. architects. to. be. familiar. with. the. discipline. of. requirements.engineering? . 6.What.are.the.four.main.activities.performed.during.requirements.engineering.Explain. . 7.List.and.explain.four.common.quality.attributes.for.software.systems. . 8.What.are.the.essential.characteristics.that.requirements.must.exhibit.when.specify- ing.requirements.Provide.an.example.of.each. . 9.What.are.architectural.views.and.why.are.they.important.in.software.architecture? . 10.Explain.Kruchtens.(1995).41.view.model. . 11.What.are.architectural.styles.and.patterns.and.why.are.they.important.in.software. architecture? . 12.What.are.the.following.concepts.and.how.do.they.relate.to.the.process.architecture. of.software.systems? . a. Process.versus.threads . b. Blocking.calls 106  Software Engineering Design . c. Race.condition . d. Critical.section . 13.In.UML.what.synchronization.properties.are.available.to.constraints.process.models. that.support.concurrency.Explain.each. CHAPTER EXERCISES . 1.Select.a.problem.of.interest.and.write.a.statement.of.work.that.describes.the.over- view.of.the.problem.Use.this.statement.of.work.to.generate.a.list.of.requirements.for. the.system.and.to.explain.how.each.requirement.meets.the.desired.characteristics.of. requirements.Once.the.list.of.requirements.is.defined.complete.the.following.steps: . a. Determine.at.least.two.views.appropriate.for.this.problem. .

--- Chunk 201 ---
Tokens: 388
Type: sentence-based
Text:
. b. Using.a.UML.modeling.tool.create.design.elements.appropriate.for.each.view. . c. For.each.design.element.write.a.paragraph.describing.how.the.design.element. help.address.particular.concerns.for.the.system. . d. Assume.that.portability.and.performance.have.been.identified.as.new.quality.attri- butes.for.the.system.Integrate.these.into.the.design.Note.that.you.will.have.to.make. assumptions.to.complete.this.step.Make.sure.that.you.document.all.assumptions. . e. Evaluate. how. all. assumptions. identified. requirements. and. quality. attributes. are.supported.by.the.resulting.architectural.elements.Create.a.report.that.docu- ments.the.result.of.the.evaluation.process. REFERENCES Abran.Alain.James.W.Moore.Pierre.Bourque.and.Robert.Dupuis.Guide to the Software Engineering Body of Knowledge2004 VersionSWEBOK.Los.Alamitos.CA.IEEE.Computer.Society.Press.2005. Bass.Len.Paul.Clements.and.Rick.Kazman.Software Architecture in Practice.2d.ed.Boston.Addison-Wesley. 2003. Buschmann. Frank. Regine. Meunier. Hans. Rohnert. Peter. Sommerlad. and. Michael. Stal. Pattern-Oriented Software Architecture: A System of Patterns.West.Sussex.UK.Wiley.1996. Clements.Paul.Rick.Kazman.and.Mark.Klein.Evaluating Software Architectures.Santa.Clara.CA.Addison. Wesley.2001. Gorton.Ian.Essential Software Architecture.Heidelberg.Germany.Springer.2011. Hofmeister.C.R.Nord.and.D.Soni.Applied Software Architecture.Boston.Addison-Wesley.2000. Kruchten.Philippe.Architectural.BlueprintsThe.41.View.Model.of.Software.Architecture.IEEE Software.12. no.6.(1995).4250.

--- Chunk 202 ---
Tokens: 386
Type: sentence-based
Text:
no.6.(1995).4250. Laplante.Phillip.A.Requirements Engineering for Software and Systems.Boca.Raton.FL.Auerbach.Publications. 2009. Pressman.Roger.S.Software Engineering: A Practitioners Approach.7th.ed.Chicago.McGraw-Hill.2010. Taylor.Richard.N.Nenad.Medvidovic.and.Eric.M.Dashofy.Software Architecture: Foundations, Theory, and Practice.Hoboken.NJ.Wiley.2009. 107 4 Patterns and Styles in Software Architecture CHAPTER OBJECTIVES . Understand.the.concept.of.architectural.styles.and.patterns . Understand.the.importance.and.role.of.architectural.patterns.in.archi- tectural.designs . Identify.understand.and.apply.the.major.types.of.architectural.patterns . Understand.the.quality.benefits.associated.with.using.different.archi- tectural.patterns CONCEPTUAL OVERVIEW During.software.architecture.designers.spend.a.great.deal.of.time.devising. architectural.solutions.that.provide.the.necessary.components.and.interfaces. to. achieve. system. requirements. At. the. architectural. level. common. pat- terns.have.emerged.that.describe.elements.of.the.system.together.with.their. interrelationships.and.quality.characteristics.These.patterns.allow.designers. to. quickly. and. systematically. identify. structural. characteristics. of. systems. (or subsystems.).and.provide.the.means.for.examining.interactions.and.the. proposed.quality.of.the.system.During.the.past.decade.many.styles.and.pat- terns.for.software.architecture.have.been.researched.and.published.Many.of. these.patterns.have.been.identified.in.pattern.catalogue.books.some.of.these.

--- Chunk 203 ---
Tokens: 374
Type: sentence-based
Text:
these.patterns.have.been.identified.in.pattern.catalogue.books.some.of.these. are.common.design.patterns.in.enterprise-level.systems.while.others.address. specific. needs. such. as. distributed. systems. This. chapter. explores. several. well-established.architectural.patterns.and.examines.the.problems.they.are. designed.to.address.together.with.their.exhibited.quality.attributes.Identify- ing.and.designing.using.architectural.patterns.can.improve.the.efficiency.of. the.development.process.and.the.quality.of.the.final.system. 108  Software Engineering Design ARCHITECTURAL STYLES AND PATTERNS As.seen.in.Chapter.3.software.systems.need.to.be.carefully.architected.and.evaluated.from. various.perspectives.to.properly.address.multiple.concerns.that.affect.the.quality.of.the. end.product.Modeling.systems.from.each.view.requires.addressing.design.problems.of. different.natures.such.as.problems.that.deal.with.the.logical.system.structure.or.problems. that.deal.with.dynamic.concurrency.system.issues.In.all.cases.it.is.essential.to.identify. the.necessary.components.and.interfaces.(at.the.right.granularity).and.the.responsibility. of.each.component.and.to.model.behavioral.interactions.among.them.before.moving.on.to. detailed.design.Of.particular.interest.is.the.logical.architecture.of.software.systems.since. it.includes.system.decomposition.into.logical.components.that.are.refined.throughout.the. design.phase.and.ultimately.implemented.during.construction.From.this.perspective.it is.

--- Chunk 204 ---
Tokens: 398
Type: sentence-based
Text:
design.phase.and.ultimately.implemented.during.construction.From.this.perspective.it is. important.to.use.past.experience.with.logical.decompositions.together.with.their.inter- faces.when.designing.todays.software.systems.To.this.end.the.concepts.of.architectural styles. and. architectural patterns. have. emerged. as. mainstream. approach. for. achieving. (mostly.logical.design).reuse.at.the.architectural.level.These.concepts.are.fundamental.to. the.efficient.creation.of.software.architectures.by.providing.an.overall.strategy.for.design- ing.families.of.software.systems.They.provide.generic.reusable.architectural.solutions. documented.in.a.way.that.can.be.easily.understood.and.applied.to.new.problems.requiring. similar.architectural.features.Decisions.based.on.architectural.styles.and.patterns.benefit. from.years.of.documented.experience.that.highlights.the.solution.approach.to.given.prob- lems.the.benefits.of.these.approaches.and.the.consequences.of.designing.the.system.with. a.particular.style. Today.the.terms.architectural styles.and.architectural patterns.are.used.loosely.to.refer. to.similar.concept.The.fuzzy.line.that.may.exist.among.them.can.be.a.source.of.confu- sion.which.shifts.the.focus.away.from.the.true.importance.and.role.of.both.concepts.in. designing.todays.complex.software.Since.numerous.architectural.styles.and.patterns.are. documented.today.a.brief.history.of.the.concepts.is.required.to.consolidate.the.terms.and. provide.a.consistent.approach.for.applying.them.throughout.the.rest.of.the.chapter. History of Architectural Styles and Patterns In. 1977.

--- Chunk 205 ---
Tokens: 399
Type: sentence-based
Text:
1977. Christopher. Alexander. presented. a. language. intended. to. help. individuals. or. teams.of.individuals.design.quality.structures.of.different.sizes.shapes.and.complexities. (Ishikawa.Silverstein.Jacobson.Fiksdahl-King.and.Angel.1977.p.x).This.languageborn. out.of.experiencehad.at.its.core.entities.called.patterns.According.to.Alexander.et.al: Each.pattern.describes.a.problem.which.occurs.over.and.over.again.in.our.environment.and. then.describes.the.core.of.the.solution.to.that.problem.in.such.a.way.that.you.can.use.this. solution.a.million.times.over.without.ever.doing.it.the.same.way.twice. Alexanders.work.resulted.in.a.catalogue.of.253.patterns.each.describing.in.detail.the. essential.information.required.for.documenting.the.patterns.Each.patterns.description. Patterns and Styles in Software Architecture  109 included.a.picture.of.the.pattern.the.context.of.the.pattern.the.problem.that.it.attempts. to.solve.evidence.for.its.validity.solution.for.the.problem.and.related.patterns.among. .others. (Alexander.et.al.1977).Together.these.patterns.formed.a.language.for.use.dur- ing.the.design.and.construction.process.Although.Alexanders.work.on.patterns.appears. .relevant.and.appropriate.for.the.software.engineering.profession.it.actually.referred.to. patterns.found.in.the.design.of.buildings.and.towns. Alexanders.work.significantly.impacted.the.field.of.software.engineering.Even.though. his.patterns.dealt.with.design.quality.in.buildings.and.towns.it.inspired.computer.scien- tists.to.answer.the.same.types.of.questions.about.quality.in.object-oriented.designs.In.the.

--- Chunk 206 ---
Tokens: 364
Type: sentence-based
Text:
his.patterns.dealt.with.design.quality.in.buildings.and.towns.it.inspired.computer.scien- tists.to.answer.the.same.types.of.questions.about.quality.in.object-oriented.designs.In.the. early.1990s.the.software.engineering.community.began.researching.and.finding.recur- ring. high-level. problem. solutions. in. terms. of. specific. elements. and. their. relationships. these. were. originally. referred. to. as. architectural. styles. (Clements. Kazman. and. Klein. 2001).Architectural.styles.provided.the.means.for.software.architects.to.reuse.architectural. design.solutions.in.different.projects.In.1995.Gamma.Helm.Johnson.and.Vlissidesbet- ter.known.as.the.Gang.of.Four. (or.GoF)embarked.on.a.similar.quest.to.find.and.docu- ment.detailed.object-oriented.solutions.successfully.applied.more.than.once.in.different. systems.Their.influential.work.focused.on.a.finer-grained.set.of.detailed.design.patterns. and.resulted.in.the.creation.of.a.catalogue.of.23.patterns.commonly.known.as.design.pat- terns.In.1996.the.work.of.Buschmann.Meunier.Rohnert.Sommerland.and.Stal.(1996). meshed.the.work.of.styles.and.patterns.by.providing.a.set.of.well-known.architectural.styles. documented.using.a.pattern-like.approach.(Clements.et.al.2001).In.their.original.work. Bushman.and.colleagues.indicate.that.patterns.and.styles.are.essentially.the.same.thing.by. stating. (Buschman.et.al.1996.p.395): Every.architectural.style.can.be.described.as.an.architectural.pattern.

--- Chunk 207 ---
Tokens: 389
Type: sentence-based
Text:
(Buschman.et.al.1996.p.395): Every.architectural.style.can.be.described.as.an.architectural.pattern. Today.the.terms.architectural.styles.and.architectural.patterns.are.used.to.convey.funda- mental.structural.and.architectural.organization.for.software.systems.Other.authors.such. as.Bass.Clements.and.Kazman.(2003).and.Qian.Tao.Xu.and.Diaz-Herrera. (2009).con- sider.both.concepts.to.be.the.same.thing.Throughout.this.chapter.(and.the.rest.of.the.book). the.terms.architectural.patterns.and.architectural.styles.are.used.interchangeably.to.denote. architectural.solutions.for.software.systems.that.occur.at.the.highest.level.of.abstraction.in.the. design.process.The.concern.of.the.work.presented.in.this.chapter.is.to.understand.not.how. to.document.specific.architectural.solutions.but.how.and.when.to.apply.a.particular.pattern. and.the.quality.attributes.these.patterns.provide.Architectural.patterns.do.not.describe.the. detailed.design.of.the.system.and.therefore.cannot.be.directly.translated.into.code.However. they.are.appropriately.used.as.basis.for.system.decomposition.and.for.analyzing.the.structure. of.systems.in.principled.manner.which.is.essential.to.constructing.high-quality.systems. Architectural Pattern Classification The. choice. of. applying. architectural. patterns. for. designing. some. architectural. element. depends.on.the.particular.system.type.requirements.and.desired.quality.attributes.These. 110  Software Engineering Design characteristics. help. guide. the. choice. of. selecting. one. particular. pattern. over. another.

--- Chunk 208 ---
Tokens: 388
Type: sentence-based
Text:
another. In some.cases.several.recognized.patterns.can.all.meet.the.identified.characteristics.of.the. system.therefore.leaving.the.design.team.with.the.decision.of.choosing.the.most.appro- priate.pattern.for.the.design.In.other.cases.various.architectural.patterns.can.be.used.in. combination.to.collectively.provide.the.appropriate.architectural.solution.that.best.fits.the. identified.system.type.requirements.and.quality.attributes.Since.architectural.patterns.are. found.at.the.highest.level.of.system.decomposition.they.are.too.abstract.to.yield.a.concrete. system.design.therefore.they.are.not.tied.to.a.particular.system.implementation.but.can. be.associated.with.types.(or.families).of.systems.so.that.their.solution.can.be.reused.across. systems.of.the.same.type.For.example.a.data-centered.type.of.system.can.employ.architec- tural.patterns.that.provide.the.logical.design.that.reflects.various.components.interacting. with.a.main.component.where.data.are.hosted.The.architectural.pattern.for.such.a.system. would.include.the.structural.entity.that.manages.the.data.components.that.perform.work. on.the.data.their.data-centered.interrelationships.and.the.quality.of.those.components. for.providing.the.application-specific.structure.for.the.data-centered.software.system.As. another.example.consider.the.design.of.a.distributed.software.system.with.components. that.communicate.and.collaborate.across.the.network.In.such.cases.architectural.patterns. that.support.these.components.and.their.interrelationships.in.a.distributed.manner.can.be.

--- Chunk 209 ---
Tokens: 367
Type: sentence-based
Text:
that.support.these.components.and.their.interrelationships.in.a.distributed.manner.can.be. employed.to.define.the.overall.strategy.of.the.distributed.systems.A.list.of.common.types.of. systems.appropriate.for.classifying.architectural.patterns.is.presented.in.Table 4.1. For.large-scale.systems.a.single.architectural.pattern.is.inadequate.for.describing.all.the. interactions.of.the.complete.system.In.these.cases.several.patterns.may.be.required.to.aid. in.the.composition.of.architectural.designs.of.the.system.and.subsystems.That.is.at.the. highest.level.the.logical.design.of.a.distributed.system.can.incorporate.an.architectural. pattern.fitting.of.such.system.however.at.finer.levels.of.abstraction.the.system.can.include. in.its.logical.architecture.other.patterns.that.address.other.nondistributed.system.issues. Consider.for.example.both.distributed.and.data-centered.systems.already.discussed.The. overall.architectural.logical.composition.may.include.an.architectural.pattern.that.includes. client.and.server.components.collaborating.in.distributed.fashion.When.further.refined. the.architectural.design.of.the.servers.logical.composition.may.employ.an.architectural. pattern.appropriate.for.data-centered.systems.while.the.design.of.the.clients.architectural. TABLE 4.1 Type.of.Software.Systems.for.Classifying.Architectural.Patterns Type Description Data-centered Systems.that.serve.as.a.centralized.repository.for.data.while.allowing.clients.to.access.and.

--- Chunk 210 ---
Tokens: 400
Type: sentence-based
Text:
TABLE 4.1 Type.of.Software.Systems.for.Classifying.Architectural.Patterns Type Description Data-centered Systems.that.serve.as.a.centralized.repository.for.data.while.allowing.clients.to.access.and. perform.work.on.the.data Data.flow Systems.oriented.around.the.transport.and.transformation.of.a.stream.of.data Distributed Systems.that.primarily.involve.interaction.between.several.independent.processing.units. connected.via.a.network Interactive Systems.that.serve.users.or.user-centric.systems Hierarchical Systems.where.components.can.be.structured.as.a.hierarchy.(vertically.and.horizontally).to. reflect.different.levels.of.abstraction.and.responsibility Patterns and Styles in Software Architecture  111 composition.may.employ.an.architectural.pattern.appropriate.for.data-flow.systems.All. of.these.issues.are.architectural.and.different.design.elements.addressing.these.concerns. throughout.the.system.are.required.to.form.the.software.architecture.This.way.architec- tural.patterns.are.combined.to.describe.the.complete.layout.of.a.system.In.the.rest.of.the. chapter.common.architectural.patterns.for.each.of.these.major.system.types.are.presented. and.examined.The.central.features.of.the.pattern.and.the.problems.addressed.are.shown. along.with.a.summary.of.the.benefits.and.limitations.of.each.pattern. DATA-CENTERED SYSTEMS Data-centered.systems.are.systems.primarily.decomposed.around.a.main.central.reposi- tory. of. data. Therefore. typical. responsibilities. found. in. components. of. data-centered. system. include. a. centralized. data. manager. and. various. worker. components.

--- Chunk 211 ---
Tokens: 394
Type: sentence-based
Text:
components. The. data. manager.component.controls.provides.and.manages.access.to.system.data.while.worker. components.execute.operations.and.perform.work.based.on.the.data.The.communica- tion.in.data-centered.systems.is.characterized.by.a.one-to-one.bidirectional.communica- tion.between.workers.and.data.manager.components.That.is.worker.components.do.not. interact.with.each.other.directly.all.communication.goes.through.the.data.manager.Some. considerations.for.these.systems.are.data.manipulation.communications.protocols.trans- actions.and.recovery.(also.known.as.roll-back).and.security.Examples.of.data-centered. systems.include.expert.systems.which.interact.with.a.database.management.system.for. storing.and.retrieving.knowledge.information.An.example.of.an.architectural.pattern.for. data-centered.systems.includes.the.blackboard.architectural.pattern. Blackboard Pattern The.blackboard.architectural.pattern.decomposes.software.systems.into.components.that. work.around.a.central.data.component.to.provide.solutions.to.complex.problems.These. components.work.independently.of.each.other.to.provide.partial.solutions.to.problems. using.an.opportunistic.problem-solving.approach.That.is.there.are.no.predetermined. or correct.sequences.of.operations.for.reaching.the.problems.solution.Each.component. provides.solutions.that.build.upon.the.problems.current.state.which.is.defined.by.the. .collective. set. of. solutions. provided. by. the. blackboards. components. The. access. to. the. central.data.component.can.be.made.through.direct.memory.reference.procedure.calls.

--- Chunk 212 ---
Tokens: 384
Type: sentence-based
Text:
central.data.component.can.be.made.through.direct.memory.reference.procedure.calls. or.database.query.(Taylor.Medvidovic.and.Dashofy.2009).Other.forms.of.access.to.the. data.central.store.may.require.complex.and.distributed.remote.method.invocations.which. may. prompt. designing. blackboard. systems. as. part. of. a. broader. architectural. pattern. Nevertheless.this.data-driven.and.opportunistic.problem-solving.approach.is.typical.in. the.development.of.expert.systems.(Buschmann.et.al.1996). Using. the. blackboard. architectural. pattern. systems. can. be. broken. down. to. include. a. common. repository. where. data. and. solutions. to. particular. problems. reside. (i.e. the. 112  Software Engineering Design blackboard). a. controller. and. various. agents. that. work. to. refine. and. further. solutions. to.arrive.at.an.acceptable.solution.The.blackboard.architectural.pattern.resembles.the. approach.a.group.of.scientists.would.employ.to.solve.a.complex.problem.Consider.a.group. of. scientists. at. one. location. using. a. blackboard. (chalkboard. whiteboard. or. electronic. blackboard).to.solve.a.complex.problem.Assume.that.to.manage.the.problem-solving.pro- cess.among.scientists.a.mediator.controls.access.to.the.blackboard.Once.the.controller. assigns.control.to.the.blackboard.a.scientist.evaluates.the.current.problems.state.as.pre- sented.in.the.blackboard.and.if.possible.advances.its.solution.before.releasing.control.of. the.blackboard.With.new.knowledge.obtained.from.the.previous.solution.attempt.control.

--- Chunk 213 ---
Tokens: 357
Type: sentence-based
Text:
the.blackboard.With.new.knowledge.obtained.from.the.previous.solution.attempt.control. is.assigned.to.the.next.scientist.who.can.further.improve.the.problems.state.This.pro- cess.continues.until.no.more.progress.can.be.made.at.which.point.the.blackboard.system. reaches.a.solution.Similar.to.this.example.the.blackboard.architectural.pattern.identifies. specialized.agents.that.independently.contribute.to.a.problems.solution.Together.one.or. more.agent.components.the.controller.component.the.blackboard.component.and.their. interrelationships.form.the.essence.of.the.blackboard.architectural.pattern.as.presented.in. the.box-and-line.diagram.in.Figure 4.1. Consider. the. application. of. the. blackboard. architectural. pattern. for. the. design. of. a. university. software. system. that. manages. student. registrations. Registrations. are. man- aged.based.on.course.availability.students.course.history.and.students.work.schedule. Controller Agent 2 Agent n Box-and-Line Diagram UML Component Diagram component ScheduleManager component ScheduleBlackboard component ScheduleHistory ISchedule IStudentHistory IWorkSchedule ISchedule ISchedule ISchedule ICourseOerings component WorkSchedule component CourseOerings Agent 1 Blackboard FIGURE 4.1 The.blackboard.architectural.pattern. Patterns and Styles in Software Architecture  113 Acquiring.each.independent.piece.of.information.may.require.the.system.to.interface.with.

--- Chunk 214 ---
Tokens: 384
Type: sentence-based
Text:
Patterns and Styles in Software Architecture  113 Acquiring.each.independent.piece.of.information.may.require.the.system.to.interface.with. other.systems.with.for.example.particular.messaging.protocols.and.interfaces.The.cur- rent.state.of.students.schedule.is.managed.in.a.central.component.housed.with.a.data- base.system.containing.the.schedule.details.To.update.schedules.the.student.scheduling. system.needs.to.interface.with.these.external.systems.to.retrieve.information.pertinent.to. create.an.optimized.student.schedule.In.addition.future.implementations.of.the.schedul- ing.system.may.include.other.information.pertinent.to.the.problem.therefore.the.logical. architecture.needs.to.provide.flexibility.for.incorporating.new.specialized.agents.capable. of.further.improving.the.scheduling.generation.capabilities.Using.the.blackboard.archi- tectural.pattern.the.following.components.are.identified.in.Table 4.2.and.presented.in. Figure 4.1.using.the.Unified.Modeling.Language.(UML).component.diagram. The. ScheduleManager. corresponds. to. the. controller component. of. the. blackboard. architectural.pattern.seen.in.the.box-and-line.diagram.of.Figure 4.1.The.StudentHistory. WorkSchedule. and. CourseOfferings. components. correspond. to. the. worker. agents. pre- scribed.in.the.blackboard.architectural.pattern.which.work.independently.to.contribute. to.the.problem.solution.by.addressing.a.particular.part.of.the.problem.and.injecting.their. results.back.into.the.main.data.repository.component.Finally.the.ScheduleBlackboard.

--- Chunk 215 ---
Tokens: 397
Type: sentence-based
Text:
results.back.into.the.main.data.repository.component.Finally.the.ScheduleBlackboard. corresponds.to.the.prescribed.blackboard.component.from.the.blackboard.architectural. pattern.which.manages.and.controls.access.to.the.current.state.of.students.schedules. Assuming.the.design.configuration.presented.in.Figure 4.1.the.solution.approach.to.gen- erate.a.schedule.that.maximizes.both.the.number of courses.taken.and.work hours.(.subject. to.some.constraints).can.be.devised.as.follows.First.the.ScheduleManager.component. initializes.all.other.components.including.agents.and.ScheduleBlackboard components. Once.components.in.the.blackboard.system.are.initialized.the.StudentHistory.component. is.activated.to.search.for.a.particular.students.course.history.and.retrieves.information. regarding.courses.left.to.complete.a.particular.degree.the.students.preference.between. day.and.night.courses.and.their.preference.between.face-to-face.and.online.courses.This. information.is.stored.in.the.ScheduleBlackboard.component.and.is.used.to.generate.the.first. version.of.the.students.schedule.Next.the.ScheduleManager.activates.the.CourseOffering. component.to.search.for.the.particular.semesters.course.offering.including.courses.offered. online.within.the.university.system.from.local.and.remote.branch.campuses.This.may. require.the.CourseOfferings.component.to.have.the.capability.of.interfacing.with.different. distributed.information.systems.The.course.offering.information.is.used.to.modify.the. original.schedule.to.include.a.schedule.that.reflects.the.students.preference.fused.with.the.

--- Chunk 216 ---
Tokens: 394
Type: sentence-based
Text:
original.schedule.to.include.a.schedule.that.reflects.the.students.preference.fused.with.the. TABLE 4.2 Architectural.Components.for.Students.Scheduling.System Component Description ScheduleManager Manages.access.to.the.ScheduleBlackboard.and.controls.the.problem-solving.process StudentHistory Knowledge.source.for.students.history.including.course.and.other.preferences WorkSchedule Knowledge.source.for.students.work.schedule CourseOfferings Knowledge.source.for.universitys.course.offerings ScheduleBlackboard Central.data.store.where.elements.of.the.solution.space.are.stored 114  Software Engineering Design course.offerings.That.is.if.the.student.prefers.face-to-face.night.courses.the.CourseOffering. component.will.combine.this.information.to.propose.the.schedule.most.appropriate.for. meeting.these.preferences.After.the.CourseOfferings.component.releases.control.of.the. ScheduleBlackboard.component.the.ScheduleManager.activates.the.WorkScheduler.com- ponent.to.determine.the.students.federal.work-study.schedule.which.is.accessible.through. the.university.system.Assuming.the.students.work.schedule.includes.alternatives.for.var- ious.shifts.the.WorkScheduler.component.evaluates.the.current.state.of.the.scheduling. problem.stored.in.the.ScheduleBlackboard.and.determines.the.best.shift.based.on.the.cur- rent.schedule.When.doing.this.the.WorkSchedule.component.may.modify.the.schedule. by.removing.classes.that.conflict.with.the.most.desirable.and.proposed.work.schedule. After.releasing.control.of.the.ScheduleBlackboard.future.iterations.of.the.problem-solving.

--- Chunk 217 ---
Tokens: 393
Type: sentence-based
Text:
After.releasing.control.of.the.ScheduleBlackboard.future.iterations.of.the.problem-solving. process.may.include.the.CourseOffering.component.filling.the.gaps.in.the.master.schedule. by.selecting.different.classes.that.may.or.may.not.be.of.the.students.preference.but.result.in. the.schedule.that.maximizes.both.the.number.of.courses.taken.and.work.hours.This.pro- cess.as.presented.in.Figure 4.2.can.be.repeated.many.times.until.the.process.is.complete. Client ScheduleManager 1 : sch : generateSchedule() 2 : nextScheduler() 3 : workOnSchedule() 6 : return 11 return 18 return 16 : return 12 : nextScheduler() 13 : workOnSchedule() 7 : nextScheduler() 17 : sch : getSchedule() 14 : sch : getSchedule() 9 : sch : getSchedule() 15 : setSchedule(sch) 10 : setSchedule(sch) 8 : workOnSchedule() 4 : sch : getSchedule() 5 : setSchedule(sch) StudentHistory CourseOerings WorkSchedule ScheduleBlackboard 19 return Modify Schedule FIGURE 4.2 Interactions.among.components.in.the.blackboard.architectural.pattern. Patterns and Styles in Software Architecture  115 and.the.schedule.provides.the.best.possible.solution.Because.the.number.of.agents.can. vary.the.solutions.provided.by.blackboard.systems.are.(typically).nondeterministic.and. vary.depending.on.the.number.of.agents.and.the.available.information. As.seen.each.component.in.the.system.abstracts.the.process.and.capabilities.for.acquir- ing. information. necessary. for. carrying. out. work. to. improve. the. solution. from. their. particular.standpoint.By.abstracting.each.agents.work.the.details.employed.inside.the.

--- Chunk 218 ---
Tokens: 400
Type: sentence-based
Text:
particular.standpoint.By.abstracting.each.agents.work.the.details.employed.inside.the. component.such.as.interprocess.communication.with.external.or.distributed.sources.of. data.protocols.messaging.interfaces.and.others.can.be.separated.from.the.overall.sys- tem.design.Also.as.seen.interactions.between.workers.and.the.blackboard.are.limited.to. retrieving.and.injecting.new.knowledge.to.the.blackboard.This.way.changes.to.one.agent. component.do.not.affect.other.agents.or.the.blackboard.components. The.major.benefits.of.using.the.blackboard.architectural.pattern.include.its.modifiability. reusability.and.maintainability.These.quality.properties.come.as.a.result.of.compartmen- talizing.knowledge.sources.and.establishing.a.standard.method.for.using.the.blackboard. Since.each.agent.needs.to.know.only.how.to.communicate.with.the.blackboard.new.agents. can.be.introduced.without.much.effort.to.improve.the.systems.capabilities.Also.by.com- partmentalizing.knowledge.sources.changes.to.the.system.are.also.compartmentalized. therefore.changes.to.one.agent.do.not.affect.other.agents.in.the.system.Finally.compart- mentalization.of.agents.supports.easy.reuse.in.future.systems.The.list.of.quality.properties. associated.with.the.blackboard.architectural.pattern.is.presented.in.Table 4.3. An.important.element.to.consider.when.applying.any.architectural.pattern.including. the.blackboard.is.their.deployment.aspect.Going.back.to.the.example.with.the.scientists. it.was.explicitly.stated.that.they.were.located.in.the.same.room.in.front.of.the.blackboard. However. scientists. can. be. distributed.

--- Chunk 219 ---
Tokens: 393
Type: sentence-based
Text:
distributed. all. over. the. world. collaborating. via. electronic. .avenues.Similarly.blackboard.systems.and.other.systems.based.on.architectural.patterns. discussed.in.this.chapter.may.be.distributed.through.the.network.in.which.case.describ- ing.the.nature.of.their.connectors.becomes.important.This.would.be.presented.using.an. architectural.design.element.from.a.deployment.perspective. Skill Development 4.1: The Blackboard Architectural Pattern Consider. the. existence. of. the. new. HolidaySchedule. software. component. that. can. retrieve.information.regarding.the.university.systems.holiday.schedule.This.includes. information.regarding.operation.hours.during.for.example.holidays.and.spring.break. TABLE 4.3 Quality.Properties.of.the.Blackboard.Architectural.Pattern Quality Description Modifiability Agents.are.compartmentalized.and.independent.from.each.other.therefore.it.is.easy.to. add.or.remove.agents.to.fit.new.systems. Reusability Specialized.components.can.be.reused.easily.in.other.applications. Maintainability Allows.for.separation.of.concerns.and.independence.of.the.knowledge-based.agents. therefore.maintaining.existing.components.becomes.easier. 116  Software Engineering Design Using.pencil.and.paper.redraw.Figure 4.1.to.include.this.component.How.can.such.a. component.be.used.in.the.students.schedule.blackboard.system.to.further.increase.the. number.of.hours.worked.Using.Figure 4.2.as.context.how.much.effort.and.how.many. architectural.changes.would.be.required.to.add.this.new.component.to.the.system. Discuss.this.problem.with.a.peer.

--- Chunk 220 ---
Tokens: 379
Type: sentence-based
Text:
Discuss.this.problem.with.a.peer. DATA FLOW SYSTEMS Data-flow.systems.are.primarily.decomposed.around.the.central.theme.of.transporting. data.(or.data.streams).and.transforming.the.data.along.the.way.to.meet.application-specific. requirements.Therefore.typical.responsibilities.found.in.components.of.data-flow.systems. include.worker.componentsthose.who.perform.work.on.dataand.transport.compo- nents.which.transmit.data.among.worker.components.The.worker.components.abstract. data.transformations.that.need.to.take.place.before.passing.data.streams.forward.in.the. system.such.as.encryption.decryption.compression.decompression.and.changing.data. format.form.binary.to.Extensible.Markup.Language.(XML).The.transport.components. abstract. the. management. and. control. of. the. data. transport. mechanisms. which. could. include.interprocess.communication.socket-based.communication.and.serial.interfaces. Together.these.components.combine.to.form.architectural.elements.of.data-flow.systems. The.data.transformation.and.transport.in.data-flow.systems.can.entail.transporting.and. transforming.data.among.different.components.within.a.single.node.or.between.nodes. in.distributed.fashion.Data-flow.systems.provide.the.means.for.data.transformation.to. take.place.in.series.or.in.parallel.fashion.which.helps.the.system.improve.performance.by. adding.concurrency.to.the.system.Other.considerations.for.these.system.include.modi- fiability.security.and.reusability.of.worker.components.capable.of.performing.complex.

--- Chunk 221 ---
Tokens: 393
Type: sentence-based
Text:
adding.concurrency.to.the.system.Other.considerations.for.these.system.include.modi- fiability.security.and.reusability.of.worker.components.capable.of.performing.complex. operations.An.example.of.an.architectural.pattern.for.data-flow.systems.is.the.pipe.and. filter.architectural.pattern. Pipe and Filter Pattern The.pipe.and.filter.architectural.pattern.decomposes.software.systems.into.components. that.carry.out.two.major.functions.processing.and.transforming.data.and.transferring. data.between.components.Components.responsible.for.processing.and.transforming.data. are.referred.as.filters.while.components.that.transfer.data.between.components.are.referred. as.pipes.Together.these.components.are.combined.in.various.ways.to.create.families.of. related.systems.that.process.streams.of.data.(Buschmann.et.al.1996).The.pipes.and.filters. architectural.pattern.is.commonly.seen.in.data-flow.systems.where.data.inputs.need.to.be. transformed.into.data.output.through.a.series.of.computational.or.manipulative.compo- nents.(Pressman.2010).The.structure.of.the.pipe.and.filter.architectural.pattern.is.often. presented.using.a.box-and-line.diagram.such.as.the.one.in.Figure 4.3.As.seen.systems. Patterns and Styles in Software Architecture  117 based.on.the.pipe.and.filter.architectural.pattern.require.a.data.source.one.or.more.filter. components.and.a.data.sink.all.connected.via.filters. Using.the.box-and-line.diagram.presented.in.Figure 4.3.the.flow.of.operations.of.pipe. and.filter.systems.can.be.described.as.follows.Initially.the.DataSource.component.produces.

--- Chunk 222 ---
Tokens: 379
Type: sentence-based
Text:
and.filter.systems.can.be.described.as.follows.Initially.the.DataSource.component.produces. data.and.sends.it.to.the.Filter 1.component.through.a.Pipe.denoted.by.an.arrow.flowing.out. of.the.DataSource.component.and.into.Filter 1.The.Filter 1.component.processes.the.data. transforms.it.and.outputs.the.transformed.data.to.three.other.filters.for.further.processing. At.this.point.three.independent.and.concurrent.data.transformations.occur.and.their.results. sent.to.Filter 5.This.process.continues.until.the.final.formatted.output.is.sent.to.the.DataSink. Filter 2 Filter 3 Filter 5 Box-and-Line Diagram UML Component Diagram UML Deployment Diagram ISecurityFilter component LocalPipe component DataSource TCPIP component SecurityFilter manifests manifests manifests manifests component DistributedPipe component DataSource component DataSink component DistributedPipe component DistributedPipe artifact data_collector.exe artifact data_processor.exe Node A Node B component DataSink IDistributedPipe IDistributedPipe Pipes Data Sink Filter 1 ILocalPipe Data Source Filter 4 FIGURE 4.3 The.pipe.and.filter.architectural.pattern. 118  Software Engineering Design When.using.the.pipe.and.filter.architectural.pattern.the.software.system.consumes.and. processes.input.data.incrementally.in.separate.filters.instead.of.consuming.and.process- ing.all.of.its.input.data.at.once.This.allows.the.system.to.become.more.efficient.mainly. by.achieving.low.latency.which.can.be.achieved.through.parallel.processing.(Buschmann.

--- Chunk 223 ---
Tokens: 390
Type: sentence-based
Text:
by.achieving.low.latency.which.can.be.achieved.through.parallel.processing.(Buschmann. et al.1996).Also.by.segregating.the.processing.components.and.abstracting.the.data.trans- ferring.process.processing.and.computations.can.be.performed.across.process.boundaries. or.across.node.boundaries.In.these.cases.the.pipe.and.filter.architectural.pattern.can.exist. within.another.architectural.pattern.for.distributed.systems.That.is.several.computers. executing.different.processes.can.work.together.to.process.input.data.transform.the.data. and.generate.the.desired.output.data. Consider.the.design.of.a.signal.processing.system.that.operates.on.real-time.video.or. audio.streams.and.is.designed.to.collect.data.encrypt.it.and.forward.it.for.further.process- ing.This.process.can.be.repeated.for.various.steps.of.data.processing.however.for.simplic- ity.the.number.of.pipes.and.filters.is.limited.to.present.the.concept.in.a.concise.manner. Using.the.pipe.and.filter.architectural.pattern.the.components.in.Table 4.4.are.identified. Together.these.components.work.to.collect.video.and.audio.data.streams.to.encrypt. them.and.to.transmit.them.to.a.remote.location.where.data.can.be.further.processed.and. distributed.The.pipe.and.filter.logical.architecture.for.the.real-time.collection.system.is. presented.using.the.component.notation.in.Figure 4.3.As.seen.the.component.notation.is. used.to.model.and.abstract.the.major.functions.identified.for.the.system.however.it.may. still.be.difficult.to.envision.the.actual.system.simply.by.viewing.the.logical.distribution.

--- Chunk 224 ---
Tokens: 365
Type: sentence-based
Text:
still.be.difficult.to.envision.the.actual.system.simply.by.viewing.the.logical.distribution. of.components.Consider.the.following.flow.of.operations.Once.data.become.available. at.the.DataSource.component.they.are.transferred.locally.to.the.SecurityFilter.compo- nent.using.the.LocalPipe.component.At.the.SecurityFilter.component.the.data.stream.is. transformed.using.encryption.and.is.transferred.to.the.DataSink.component.using.mecha- nisms.provided.by.the.DistributedPipe.component.In.this.case.the.DistributedPipe.com- ponent.abstracts.the.details.of.transferring.data.across.the.network.since.the.DataSource. and.DataSink.are.hosted.on.different.nodes.therefore.a.deployment.view.is.necessary.to. properly.characterize.the.system.As.seen.in.the.deployment.diagram.in.Figure 4.3.the. DataSource.and.DistributedPipe.components.are.manifested.in.Node A.while.the.DataSink. and. (another).DistributedPipe.components.are.manifested.in.Node B.The.manifestation.of. TABLE 4.4 Architectural.Components.for.Distributed.Signal.Processing.System Component Description Data.source Produces.real-time.video.or.audio.streams Local.pipe Mechanism.for.transferring.video.or.audio.data.streams.locally.from.data.source.to. security.filter Security.filter Transforms.data.streams.by.encrypting.flow.of.data Distributed.pipe Mechanism.for.transferring.encrypted.data.streams.wirelessly.(e.g.Satellite. Communications.SATCOM).from.local.site.to.remote.site.provides.the.logical.

--- Chunk 225 ---
Tokens: 384
Type: sentence-based
Text:
Communications.SATCOM).from.local.site.to.remote.site.provides.the.logical. connection.between.data.source.and.data.sink Data.sink Destination.component.where.data.streams.are.stored.for.later.review Patterns and Styles in Software Architecture  119 the.LocalPipe.and.SecurityFilter.components.is.omitted.for.simplicity.however.they.would. be.presented.in.Node A.This.example.shows.how.using.different.architectural.views.can. enhance.the.understanding.of.the.true.architecture.of.a.system. The.presentation.of.the.pipe.and.filter.system.using.component.diagrams.is.appropriate. since.the.piping.mechanisms.entail.more.advanced.mechanisms.than.a.simple.method. call. to. another. component. However. the. same. knowledge. can. be. conveyed. using. a. box-and-line.diagram.or.other.non-UML.diagram.approach.The.problem.with.using.a. simple.box-and-line.diagram.is.that.it.becomes.difficult.to.capture.or.abstract.the.work. required.to.realize.the.work.required.by.the.pipe.(or.connector).When.components.are. identified.during.the.software.architecture.activity.they.are.slated.for.refinement.during. detailed.design.work.therefore.providing.an.explicit.and.manageable.unit.of.design.work. By.modeling.complex.pipes.as.components.the.details.of.their.work.are.abstracted.and. future.planned.work.for.providing.the.details.of.such.abstraction.can.be.integrated.into.the. designs.and.construction.schedule.similar.to.any.other.component.in.the.system. The.pipe.and.filter.architectural.pattern.can.be.applied.to.a.problem.of.smaller.scope.

--- Chunk 226 ---
Tokens: 399
Type: sentence-based
Text:
The.pipe.and.filter.architectural.pattern.can.be.applied.to.a.problem.of.smaller.scope. where.both.pipe.and.filter.components.reside.within.a.single.node.and.communicate.using. simple.method.calls.or.using.simple.mechanisms.provided.by.the.operating.systems.such. as.message.queues.In.other.cases.creating.a.customized.pipe.such.as.the.DistributedPipe. presented.earlier.may.require.additional.work.Filters.can.be.designed.as.multiple.com- ponents.manifested.by.as.single.process.or.by.multiple.independent.processes.executing. within. a. node. and. communicating. through. common. inter-process. pipe. mechanisms. Typically.once.the.pipe.and.filter.framework.is.in.place.numerous.filters.can.be.added. (serially. or. in. parallel). to. provide. additional. capabilities. The. major. quality. properties. associated.with.pipes.and.filter.systems.are.presented.in.Table 4.5. Skill Development 4.2: Designing with the Pipes and Filter Architectural Pattern Using.pencil.and.paper.complete.the.design.for.Node.B.required.to.distribute.the. audio.and.video.feed.Once.the.data.reach.the.data.sink.all.data.need.to.be.decrypted. TABLE 4.5 Qualities.of.the.Pipes.and.Filter.Architectural.Pattern Quality Description Extensibility Processing.filters.can.be.added.easily.for.more.capabilities. Efficiency By.connecting.filters.in.parallel.concurrency.can.be.achieved.to.reduce.latency.in.the. system. Reusability By.compartmentalizing.pipes.and.filters.they.can.both.be.reused.as.is.in.other.systems. Modifiability Filters.are.compartmentalized.and.independent.from.each.other.therefore.it.is.easy.to.add.

--- Chunk 227 ---
Tokens: 399
Type: sentence-based
Text:
Modifiability Filters.are.compartmentalized.and.independent.from.each.other.therefore.it.is.easy.to.add. or.remove.filters.to.enhance.the.system Security At.any.point.during.data.flow.security.components.can.be.injected.to.the.work.flow.to. provide.different.types.of.security.mechanisms.to.the.data. Maintainability Allows.for.separation.of.concerns.and.independence.of.the.filters.and.pipes.therefore. maintaining.existing.components.becomes.easier. 120  Software Engineering Design compressed.and.stored.in.the.file.systemoperations.that.can.take.a.long.time.due.to. the.expected.massive.amounts.of.data.In.addition.data.need.to.be.prepared.for.view- ing.in.real-time.using.a.web.server.and.client.PCs.and.provided.to.a.client.(non-web. page).application.hosted.on.a.mobile.phone.In.all.of.these.efficiency.is.the.most.impor- tant.characteristic.of.the.system.so.that.the.quality.of.audio.and.video.is.appropriate. Assuming.that.there.are.no.resource.constraints.also.draw.a.deployment.diagram.to. helps.support.the.required.efficiency.of.the.system.How.does.the.pipe.and.filter.pattern. help.in.meeting.efficiency.expectations? DISTRIBUTED SYSTEMS Distributed.systems.are.commonly.known.as.systems.decomposed.into.multiple.processes. that. collaborate. through. the. network. These. systems. are. ubiquitous. in. todays. modern. .systems.thanks.to.wireless.mobile.and.Internet.technology.In.some.distributed.systems. one.or.more.distributed.processes.perform.work.on.behalf.of.client.users.and.provide.a. bridge.to.some.server.computer.typically.located.remotely.and.performing.work.delegated.

--- Chunk 228 ---
Tokens: 385
Type: sentence-based
Text:
bridge.to.some.server.computer.typically.located.remotely.and.performing.work.delegated. to.it.by.the.client.part.of.the.system.Once.complete.results.are.typically.returned.back.to. clients.for.viewing.and.further.processing.Other.distributed.systems.may.be.composed.of. peer.nodes.each.with.similar.capabilities.and.collaborating.together.to.provide.enhanced. .services.such.as.music-sharing.distributed.applications.These.forms.of.distributed.systems. are.well-known.in.the.sense.that.their.deployment.architecture.typically.entails.multiple. nodes.However.with.the.advent.of.multiple.CPU.architectures.distributed.architectures. are.also.relevant.to.software.that.executes.on.a.single.node.with.multiprocessor.capability. The.main.concerns.for.distributed.systems.may.include.performance.reliability.availability. security.and.interoperability.Some.examples.are.Internet.systems.with.web.services.and. high-performance. scientific. computing. projects. such. as. the. Search. for. Extraterrestrial. Intelligence.(SETI).program.or.the.Large.Hadron.Collider.(LHC).at.CERN.In.such.systems. multiple.processors.that.may.reside.on.different.physical.machines.or.in.different.concurrent. processes.on.a.single.machine.cooperate.to.solve.the.tasks.required.of.the.system.Common. architectural.patterns.for.these.systems.include . Clientserver . Broker ClientServer Pattern The.clientserver.architecture.is.a.popular.architectural.pattern.present.in.todays.modern. systems.It.decomposes.software.systems.into.two.main.components.the.client.and.the.

--- Chunk 229 ---
Tokens: 395
Type: sentence-based
Text:
systems.It.decomposes.software.systems.into.two.main.components.the.client.and.the. server.These.components.are.manifested.as.individual.processes.that.can.be.distributed. over.the.network.or.within.a.single.node.Clientserver.systems.are.not.determined.merely. by.separating.processes.or.by.distributing.processes.across.the.network.but.by.having.one. Patterns and Styles in Software Architecture  121 process.the.client.depend.on.the.services.provided.by.another.process.the.server.The. most.pervasive.example.of.a.clientserver.system.today.includes.the.web.browser.client. and.the.web.server.When.searching.for.a.particular.site.using.the.web.browser.client. a connection.is.made.to.the.server.a.request.is.sent.and.received.by.the.server.and.the. server.processes.the.requests.and.sends.a.response.back.to.the.client.Note.that.this.is.also. true.regardless.of.the.locationwhich.can.be.on.the.same.node.as.the.server.of.the.web. client.as.long.as.it.can.connect.to.the.server.In.addition.web.browser.clients.are.not.very. useful.without.the.services.provided.by.the.server.therefore.they.are.dependent.on.the. server.Figure 4.4.presents.the.clientserver.architectural.pattern. Clientserver.systems.are.particularly.useful.for.distributed.systems.with.a.large.client. base.since.they.provide.localization.of.data.in.one.central.place.Therefore.making.updates. or.adding.new.information.in.once.central.place.is.all.that.it.is.needed.for.a.multitude. of.clients.to.receive.this.information.The.quality.attributes.associated.with.clientserver. .systems.are.identified.in.Table 4.6.

--- Chunk 230 ---
Tokens: 377
Type: sentence-based
Text:
.systems.are.identified.in.Table 4.6. TABLE 4.6 Qualities.of.the.ClientServer.Architectural.Pattern Quality Description Interoperability Allows.clients.on.different.platforms.to.interoperate.with.servers.of.different.platforms Modifiability Allows.for.centralized.changes.in.the.server.and.quick.distribution.among.many.clients Availability By.separating.server.data.multiple.server.nodes.can.be.connected.as.backup.to.increase. the.server.data.or.services.availability Reusability By.separating.server.from.clients.services.or.data.provided.by.the.server.can.be.reused.in. different.applications Client artifact pc_browser.exe Request Response HTTP HTTP Box-and-LineDiagram UML Deployment Diagram PC Node Server Node Server artifact mp_browser.exe Mobile Phone Node artifact pc_browser.exe artifact web_server.exe FIGURE 4.4 The.clientserver.architectural.pattern. 122  Software Engineering Design Servers.can.abstract.the.servicesand.the.details.of.providing.those.servicesprovided. by.the.host.platform.therefore.creating.a.window.for.clients.to.interoperate.with.the.host. platform.When.done.properly.this.allows.interoperation.between.systems.of.different. platforms.Clientserver.systems.can.also.lead.to.highly.modifiable.systems.Consider.a. corporate.web-based.intranet.system.where.modifying.or.adding.completely.new.system. capabilities.may.require.creating.the.necessary.server.code.including.a.new.hyperlink.to. the.existing.corporate.portal.and.deploying.the.modified.code.to.the.production.server.

--- Chunk 231 ---
Tokens: 355
Type: sentence-based
Text:
the.existing.corporate.portal.and.deploying.the.modified.code.to.the.production.server. Once.deployed.everyone.in.the.corporate.network.would.have.instant.access.to.the.modi- fied.system.Also.by.separating.the.client.application.from.the.server.data.clientserver. systems.allow.designers.to.render.multiple.views.of.the.same.data.clients.can.be.improved. or.replaced.independently.of.the.resources.needed.to.perform.computations.on.the.data. multiple.clients.can.share.the.resources.of.a.server.allowing.for.increased.efficiency.or. the.user.interface.can.be.replaced.completely.allowing.specialized.clients.to.consume.and. perform.additional.processing.on.the.data.for.further.processing. Broker Pattern The. broker. architectural. pattern. provides. mechanisms. for. achieving. better. flexibil- ity.between.clients.and.servers.in.a.distributed.environment.Consider.the.clientserver. example.presented.in.Figure 4.4.In.the.typical.clientserver.architectural.pattern.clients. directly.access.services.of.servers.which.may.require.them.to.establish.direct.connection. (e.g, Transmission.Control.ProtocolInternet.Protocol.TCPIP).or.employ.other.inter- process.communication.mechanisms.for.communicating.with.the.server.This.result.in.a. higher.degree.of.coupling.between.clients.and.servers.which.leads.to.complexity.for.systems. expected.to.evolve.by.providing.services.from.different.servers.hosted.at.different.locations.

--- Chunk 232 ---
Tokens: 398
Type: sentence-based
Text:
expected.to.evolve.by.providing.services.from.different.servers.hosted.at.different.locations. In.some.cases.client.terminals.need.to.be.able.to.access.services.from.multiple.servers.with- out.knowing.their.actual.locations.or.particular.details.of.communication.for.accessing. those.services.This.leads.to.systems.with.increased.interoperability.and.flexibility. The. broker. architectural. pattern. decreases. coupling. between. clients. and. servers. by. mediating.between.them.so.that.one.client.can.transparently.access.the.services.of.multiple. servers.Instead.of.accessing.servers.directly.clients.access.their.functionality.via.a.bro- ker.component.which.locates.appropriate.servers.forwards.requests.and.relays.responses. (including.exceptions).back.to.clients.(Buschmann.et.al.1996).With.this.mechanism.in. place.clients.can.request.services.as.if.they.were.provided.locally.on.the.same.node.as.the. server.when.they.are.in.fact.being.provided.in.distributed.fashion.over.the.network.by. different.nodes.The.main.participants.in.the.broker.architectural.pattern.are.presented. in.Table 4.7.and.examples.of.modeling.broker.systems.are.presented.in.Figure 4.5.using. box-and-line.UML.components.and.UML.deployment.diagrams. In.the.box-and-line.diagram.presented.in.Figure 4.5.it.can.be.seen.that.broker.compo- nents.can.interoperate.with.other.brokers.so.that.if.a.service.requested.by.a.client.is.acces- sible.through.a.separate.broker.this.communication.can.be.established.to.provide.clients. additional.services.For.example.Client 1.may.forward.a.request.to.Broker 1.for.a.particular.

--- Chunk 233 ---
Tokens: 392
Type: sentence-based
Text:
additional.services.For.example.Client 1.may.forward.a.request.to.Broker 1.for.a.particular. service.Broker 1.after.determining.that.Server 2.provides.the.service.requested.forwards. Patterns and Styles in Software Architecture  123 TABLE 4.7 Components.of.the.Broker.Architectural.Pattern Component Description Client Applications.that.use.the.services.provided.by.one.or.more.servers ClientProxy Component.that.provides.transparency.(at.client).between.remote.and.local.components.so. that.remote.components.appear.as.local.ones Broker Component.that.mediates.between.client.and.server.components ServerProxy Component.that.provides.transparency.(at.server).between.remote.and.local.components.so. that.remote.components.appear.as.local.ones Server Provide.services.to.clients.may.also.act.as.client.to.the.broker Bridge Optional.component.for.encapsulating.interoperation.among.brokers Broker 1 Client Broker 2 Server 1 Box-and-Line Diagram UML Component Diagram Server 2 component UserInterface component DvrClient IDvrStatus IDvrRemoteControl IBroker IDvrControl component DvrClientProxy delegate artifact iexplore.exe OcePC delegate component DvrBroker component DvrClient manifests HTTP HTTP component UserInterface component DvrServer IDvrStatus IDvrStatus IDvrRemoteControl IDvrRemoteControl IDvrControl IDvrControl UML Deployment Diagram component DvrSystem component DvrServerProxy artifact dvr_server.exe FamilyRoomDvr component DvrServer manifests artifact dvr_server.exe BedroomDvr component DvrServer manifests FIGURE 4.5 The.broker.architectural.pattern.

--- Chunk 234 ---
Tokens: 392
Type: sentence-based
Text:
that.remote.components.appear.as.local.ones Server Provide.services.to.clients.may.also.act.as.client.to.the.broker Bridge Optional.component.for.encapsulating.interoperation.among.brokers Broker 1 Client Broker 2 Server 1 Box-and-Line Diagram UML Component Diagram Server 2 component UserInterface component DvrClient IDvrStatus IDvrRemoteControl IBroker IDvrControl component DvrClientProxy delegate artifact iexplore.exe OcePC delegate component DvrBroker component DvrClient manifests HTTP HTTP component UserInterface component DvrServer IDvrStatus IDvrStatus IDvrRemoteControl IDvrRemoteControl IDvrControl IDvrControl UML Deployment Diagram component DvrSystem component DvrServerProxy artifact dvr_server.exe FamilyRoomDvr component DvrServer manifests artifact dvr_server.exe BedroomDvr component DvrServer manifests FIGURE 4.5 The.broker.architectural.pattern. 124  Software Engineering Design the.requests.to.Broker 2.which.in.turn.forwards.the.requests.to.Server 2.Once.the.opera- tions.required.for.the.particular.service.are.executed.Server 2.establishes.a.connection. with.Broker 2.and.supplies.it.with.a.response.which.is.forwarded.to.Broker 1.and.subse- quently.to.the.Client.This.sequence.highlights.a.major.difference.between.clientserver. and.broker.architectural.patterns.in.the.broker.architectural.pattern.servers.may.also.act. as.clients.to.the.broker.whereas.in.clientserver.architectures.roles.are.exclusive.so.that. servers.are.never.clients.(Buschmann.et.al.1996). Consider.the.architectural.design.of.the.distributed.digital.video.recording.

--- Chunk 235 ---
Tokens: 396
Type: sentence-based
Text:
Consider.the.architectural.design.of.the.distributed.digital.video.recording. (DVR).sys- tem.presented.in.the.UML.component.diagram.in.Figure 4.5.In.this.example.two.proxies. are.created.to.provide.transparency.at.both.client.and.server.side.The.DvrClientProxy. component.realizes.the.IDvrStatus.and.IDvrControl.in.a.remote.environment.while.the. DvrServerProxy.realizes.these.interfaces.in.a.local.environment.providing.direct.connec- tion.to.the.DVR.computer.Therefore.both.user.interfaces.at.the.client.and.server.locations. can.be.interchangeable.since.they.both.interface.with.the.DvrSystem.component.through. well-defined.methods.provided.by.these.interfaces.With.these.mechanisms.in.place.the. broker.system.begins.by.initializing.the.DVR.system.to.find.appropriate.servers.and.iden- tify.their.provided.services.as.seen.in.Figure 4.6.Notice.that.in.this.example.the.optional. bridge.component.identified.in.Table 4.7.is.not.used. UserInterface DvrClientProxy DvrServerProxy DvrBroker 2 : aMsg : intBrokerMsg() 1 : int() 4 : ndServer() 5 : callService(aMsg) 6 : recv() 3 : forwardRequest(aMg) aResponse contains a list of services supported by the server. At this point, the borker has knowledge of all services supported by the server. 7 : callService(aResponse) 8 : registerServices(aResponse) FIGURE 4.6 The.broker.architectural.patterninitialization. Patterns and Styles in Software Architecture  125 As.seen.once.the.system.begins.initialization.an.initialization.message.containing.a. request.for.services.and.client.information.is.created.and.forwarded.to.the.DvrBroker.

--- Chunk 236 ---
Tokens: 381
Type: sentence-based
Text:
request.for.services.and.client.information.is.created.and.forwarded.to.the.DvrBroker. component.which.finds.appropriate.servers.and.transmits.the.message.for.processing. At this.point.the.DvrBroker.waits.for.a.response.which.contains.the.services.provided. by.the.particular.server.these.services.are.registered.and.become.available.to.the.client. during.system.operation.Once.the.system.is.initialized.services.from.remote.severs.can. be.accessed.through.the.broker.as.seen.in.Figure 4.7.In.this.example.the.client.requests. information.about.the.DVRs.available.disk.space.Notice.that.the.clients.UserInterface. component.the.getDiskSpace().interface.method.can.be.called.as.if.the.DVR.system.were. local.to.the.client. An. important. architectural. design. element. for. this. system. involves. the. deployment. aspect.of.the.DVR.system.The.logical.view.for.architectural.design.does.not.convey.enough. information.to.fully.provide.the.context.for.the.operations.that.take.place.in.the.DVR. system.Figure 4.5.provides.a.UML.deployment.diagram.to.add.this.context.to.the.archi- tectural.effort.As.seen.the.system.employs.two.DVR.nodes.which.manifest.the.DvrServer. component.identified.in.the.UML.component.diagram.This.means.that.the.getDiskSpace(). operation.can.be.mapped.to.either.FamilyroomDvr.or.BedroomDvr.systems.all.performed. transparently. from. clients. That. is. the. call. made. to. the. DvrServerProxy. to. get. service. (i.e, callService(aMsg)).can.be.made.to.either.node.(i.e.FamilyroomDvr.or.BedroomDvr).

--- Chunk 237 ---
Tokens: 388
Type: sentence-based
Text:
(i.e, callService(aMsg)).can.be.made.to.either.node.(i.e.FamilyroomDvr.or.BedroomDvr). UserInterface DvrClientProxy DvrServerProxy DvrBroker 2 : aMsg : pack() 1 : getDiskSpace() 4 : ndServer() 5 : callService(aMsg) 6 : recv() 3 : forwardRequest(aMsg) 8 return 10 return 7 : callService(aResponse) 9 : unpack(aResponse) aMsg contains information about the servers s destination (e.g, IP address) and service requested. At this point, the Broker waits for a response. Once received, aResponse will contain the information requested. In this case, the amount of disk space available. FIGURE 4.7 The.broker.architectural.patternclient.operation. 126  Software Engineering Design transparently.from.clients.and.the.response.is.processed.identically.by.the.client.In.similar. fashion.many.other.nodes.can.be.added.to.the.system.without.affecting.the.client.applica- tion.This.provides.additional.flexibility.when.modifying.the.system.to.add.more.nodes. On.the.server.side.messages.received.are.processed.as.presented.in.Figure 4.8. As.seen.the.DvrServerProxy.interfaces.directly.with.the.DvrSystem.to.relay.requests.from. clients.and.prepare.responses.for.transmission.back.to.one.or.more.clients.In.this.case. once.the.DvrServerProxy.receives.a.message.interprets.it.and.makes.the.getDiskSpace(). operation.call.to.the.DvrSystem.component.the.getDiskSpace().operation.encapsulates.the. details.of.the.protocols.required.for.the.direct.communication.between.the.server.compo- nent.and.the.actual.DVR.computer.Once.a.response.is.received.from.the.DVR.computer.

--- Chunk 238 ---
Tokens: 399
Type: sentence-based
Text:
details.of.the.protocols.required.for.the.direct.communication.between.the.server.compo- nent.and.the.actual.DVR.computer.Once.a.response.is.received.from.the.DVR.computer. the.getDiskSpace() returns.with.results.from.the.disk.space.availability.these.are.packaged. into.a.message.and.sent.back.to.the.broker.as.response.for.the.clients.requests.This.process. is.repeated.for.all.other.services.requested.by.clients. In.practice.there.are.numerous.variations.of.architectural.designs.based.on.the.broker. architectural.pattern.Some.broker.systems.may.have.the.broker.component.deployed. on.separate.nodes.from.the.client.others.allow.clients.to.communicate.directly.with. .servers.in.special.cases.some.rely.on.remote.procedure.calls.(vs.the.messaging.approach. presented.here).and.others.rely.on.reactive.models.where.callback.methods.from.reg- istered.components.are.invoked.by.the.broker.whenever.an.event.is.triggered.However. all.broker.systems.typically.benefit.mainly.from.the.flexibility.provided.by.decoupling. clients.and.servers.The.quality.attributes.associated.with.broker.systems.are.identified. in.Table 4.8. DvrSystem DvrServerProxy DvrBroker 1 : waitForRequests() 3 : unpack(aMsg) 4 : getDiskSpace() 2 : callService(aMsg) 7 : callService(aResponse) 6 : aResponse : pack() 5 return At this point, a Broker has been intialized on the client side and a request to retrieve the available disk space has been sent. FIGURE 4.8 The.broker.architectural.patternserver.operation. Patterns and Styles in Software Architecture  127 INTERACTIVE SYSTEMS Interactive. systems. are. systems. that.

--- Chunk 239 ---
Tokens: 372
Type: sentence-based
Text:
that. support. user. interactions. typically. through. user. interfaces.When.designing.interactive.systems.design.alternatives.concentrate.on.two. main.quality.attributes.usability.and.modifiability.As.stated.before.usability.refers.to. the.quality.goal.that.seeks.to.minimize.the.degree.of.complexity.involved.when.learning. or.using.the.system.Usable.systems.are.designed.in.such.way.that.operators.can.quickly. become.proficient.with.the.system.they.also.respond.to.user.requests.rapidly.to.support. high.interactivity.requirements.A.large.portion.of.usability.design.takes.place.during.the. user.interface.design.activity.Whereas.usability.is.achieved.mostly.through.user.interface. design.modifiability.and.interactive.performance.are.mainly.functions.of.the.architec- tural.logical.design.To.maximize.modifiability.and.performance.in.interactive.systems. the.graphic.user.interface.that.represents.the.system.data.needs.to.be.efficiently.decoupled. from.the.functional.system.core.By.doing.this.the.functional.corewhich.is.typically. stable.since.it.is.largely.based.on.functional.requirementsis.separated.from.user.displays. which.are.largely.based.on.quality.requirements.Since.user.interfaces.are.more.likely.to. change.and.adapted.to.future.versions.of.software.systems.segregating.them.from.the.sys- tem.core.increases.the.modifiability.of.interactive.systems.Examples.of.interactive.systems. include.gaming.systems.simulations.and.Internet.applications.where.such.systems.need.

--- Chunk 240 ---
Tokens: 379
Type: sentence-based
Text:
include.gaming.systems.simulations.and.Internet.applications.where.such.systems.need. to.respond.to.user.requests.rapidly.and.update.the.display.so.the.user.can.interact.appro- priately.The.mainstream.architectural.pattern.employed.in.most.interactive.systems.is.the. modelviewcontroller.(MVC). ModelViewController Pattern The. MVC. architectural. pattern. is. used. in. interactive. applications. that. require. flexible. incorporation.of.humancomputer.interfaces.With.the.MVC.systems.are.decomposed. into.three.main.components.that.handle.independently.the.systems.input.processing.and. output.By.separating.the.systems.output.from.its.core.processing.functions.different.rep- resentations.of.the.system.core.can.be.easily.supported.The.main.components.present.in. the.MVC.architectural.pattern.are.presented.in.Table 4.9. TABLE 4.8 Qualities.of.the.Broker.Architectural.Pattern Quality Description Interoperability Allows.clients.on.different.platforms.to.interoperate.with.servers.of.different.platforms. also.allows.clients.to.interoperate. (transparently).with.multiple.servers Modifiability Allows.for.centralized.changes.in.the.server.and.quick.distribution.among.many.clients Portability By.porting.the.broker.to.different.platforms.services.provided.by.the.system.can.be.easily. acquired.by.new.clients.in.different.platforms Reusability Brokers.abstract.many.system.calls.required.for.providing.communication.between.nodes. when.using.brokers.many.complex.services.can.be.reused.in.other.applications.that.

--- Chunk 241 ---
Tokens: 400
Type: sentence-based
Text:
when.using.brokers.many.complex.services.can.be.reused.in.other.applications.that. require.similar.distributed.operations 128  Software Engineering Design View.and.controller.components.work.together.as.part.of.the.user.interface.to.accept. user.input.and.transform.this.input.into.format.compatible.with.the.model.component. In.some.variants.of.the.MVC.the.responsibility.of.controllers.and.views.are.fused.into. one.component.The.relationship.among.the.model.view.and.controller.components.can. vary.depending.on.the.application.however.at.minimum.MVC.designs.provide.relation- ships.that.allow.changes.in.the.model.to.be.propagated.to.its.view.and.when.necessary.to. controllers.This.way.MVC.systems.provide.a.systematic.flexible.and.controlled.approach. for.accepting.system.inputs.and.providing.system.outputs. As.an.architectural.pattern.MVC.defines.the.interfaces.required.for.the.change.propa- gation.mechanisms.among.the.model.view.and.controller.components.However.it.does. not. (and.should.not).specify.the.details.of.how.the.change.propagation.mechanism.is.actu- ally.implemented.Details.of.such.mechanisms.are.left.to.the.detailed.design.activity.which. can.provide.design.patterns.such.as.the.observer.to.realize.the.intent.of.the.MCV.As.an. architectural.pattern.MVC.designs.should.specify.the.components.their.interfaces.and. the.nature.of.those.interfaces.to.support.system.development.This.fundamental.difference. provides.a.clear.delineation.between.MVC.and.other.detailed.design.patterns.Figure 4.9. presents. a. generic. box-and-line. design. of. the. MVC. architectural. pattern.

--- Chunk 242 ---
Tokens: 364
Type: sentence-based
Text:
pattern. This. diagram. presents.the.MVC.in.its.most.connected.form.in.which.bidirectional.relationships.exist. among.all.components.However.many.variants.exist.that.customize.relationships.among. components.depending.on.the.application. Figure 4.9.also.presents.a.UML.component.diagram.for.a.hypothetical.real.estate.hous- ing.market.system.that.allows.users.to.find.properties.for.sale.The.real.estate.system.is. based.on.the.MVC.architectural.pattern.and.is.composed.of.two.views.each.with.their. own.controller.and.a.model.that.contains.all.real.estate.information.The.two.views.are. designed.uniquely.for.usability.on.a.standard.PC.and.large.SMART.board.environment. Since.the.form.factor.of.PC.monitors.and.SMART.Boards.differ.significantly.two.differ- ent.views.are.created.for.the.system.Since.the.PC.monitor.is.significantly.smaller.than.the. SMART.board.the.user.interface.created.by.the.PCView.component.will.cover.the.whole. monitor.screen.and.rely.on.speech.recognition.technology.for.its.input.mechanism.Since. the.SMART.board.provides.larger.space.for.viewing.the.software.the.SmartboardView. component.provides.more.informative.buttons.and.menu.options.to.use.the.software.The. SMART.board.version.of.the.software.relies.on.direct.human.touch.interface.or.hand.ges- ture.recognition.For.this.reason.two.different.controller.componentsone.that.performs. speech.processing.and.the.other.for.hand.touch.or.hand.gesture.recognitionare.designed.

--- Chunk 243 ---
Tokens: 397
Type: sentence-based
Text:
speech.processing.and.the.other.for.hand.touch.or.hand.gesture.recognitionare.designed. TABLE 4.9 Components.of.the.MVC.Architectural.Pattern Component Description Model Component.that.represents.the.systems.core.including.its.major.processing.capabilities. and data View Component.that.represents.the.output.representation.of.the.system.(e.g.graphical.output.or. console.based) Controller Component. (associated.with.a.view).that.handles.user.inputs Patterns and Styles in Software Architecture  129 When.using.the.system.on.a.PC.users.can.command.the.system.using.speech.such.as. Find.single.family.homes.in.Lakeland.Florida.Once.this.input.is.received.through.the. PCs.microphone.the.speech.controller.transforms.it.into.a.command.that.is.passed.on. the.model.using.the.provided.IModel.interface.Once.the.request.is.processed.by.the.model. component.it.uses.the.IObserver.interface.to.employ.the.change.propagation.mechanisms. to.let.the.PCView.componentor.any.other.view.associated.with.the.modelknow.that. the.request.has.been.processed.At.this.point.the.PCView.component.retrieves.the.data. using.the.models.IModel.interface.and.displays.them.to.users.A similar.approach.is.con- ducted.in.the.SMART.board.version.of.the.system.These.sequences.of.operations.for.the. MVC.system.are.presented.in.Figure 4.10. From. this. trivial. example. the. major. advantage. in. the. flexibility. that. MVC. systems. provide.can.be.clearly.examined.For.example.consider.the.case.where.a.more.advanced. speech. processor. is. created. In. this. case. neither. view. nor. model. components. need. to.

--- Chunk 244 ---
Tokens: 364
Type: sentence-based
Text:
to. be.modified.for.this.addition.This.means.that.support.for.enhanced.speech.processing. or.new.languages.can.be.added.to.the.real.estate.system.without.much.effort.Similarly. other.views.for.the.same.data.can.be.incorporated.easily.to.the.system.for.example.a.view. providing.graphical.descriptive.or.inferential.statistics.for.housing.markets.based.on.the. models.data.Finally.advanced.computational.features.can.be.added.to.the.real.estate.sys- tems.by.adding.faster.search.algorithms.to.the.model.component.independently.from.both. view.and.controller.This.flexibility.can.be.extended.to.distributed.environments.such.as. View 1 View 2 View n Box-and-Line Diagram UML Component Diagram Controller 1 Controller 2 Model Controller n component SmartBoardView component RealEstateModel IModel IObserver IObserver IPenController component PCView component SbController IModel IObserver IObservable IObserver ISpeechController component SpeechController FIGURE 4.9 The.modelviewcontroller.architectural.pattern. 130  Software Engineering Design Internet.systems.where.MVC.architectures.are.very.popular.Systems.based.on.the.MVC. benefit.from.flexibility.that.allows.them.to.evolve.gracefully.over.time.The.main.quality. attributes.associated.with.MVC.systems.are.presented.in.Table 4.10. There.are.some.variations.of.the.MVC.architectural.pattern.One.popular.variation.of. designing.MVC.systems.includes.the.fusion.of.views.and.controller.components.into.one.

--- Chunk 245 ---
Tokens: 392
Type: sentence-based
Text:
designing.MVC.systems.includes.the.fusion.of.views.and.controller.components.into.one. component.This.variant.was.very.popular.in.the.1990s.as.part.of.Microsofts.Document- View.architecture.integrated.in.the.Microsoft.Foundation.Classes. (MFC).Visual.C.envi- ronment.The.Document-View.architecture.sacrificed.exchangeability.of.the.controller.for. simplicity. Other. more. extensive. variations. include. the. processabstractioncontroller. (PAC).architectural.pattern.(Qian.et.al.2009).The.PAC.is.an.extension.of.the.MVC.where. systems.are.decomposed.into.agents.each.containing.a.process.abstraction.and.controller. components.arranged.in.hierarchical.fashion. TABLE 4.10 Qualities.of.the.MVC.Architectural.Pattern Quality Description Modifiability Easy.to.exchange.enhance.or.add.additional.user.interfaces Usability By.allowing.easy.exchangeability.of.user.interfaces.systems.can.be.configured.with.different. user.interfaces.to.meet.different.usability.needs.of.particular.groups.of.customers Reusability By.separating.the.concerns.of.the.model.view.and.controller.components.they.can.all.be. reused.in.other.systems PCView Application RealEstateModel SpeechController 5 : show() 6 : show() 9 : sendCommand(FIND_CMD,SFH,33803) 10 : processCommand() 12 : getResults() 11 : update() 4 : attach(aView) 2 : aView : new SpeechCustomizedView() 3 : aController : new VoiceController() 7 : onVoiceInput(nd single family homes in Lakeland, FL) 8 : processSpeech() 1 : aModel : new Model() Once the view is displayed, it enables the voice input mode to receive voice input.

--- Chunk 246 ---
Tokens: 378
Type: sentence-based
Text:
reused.in.other.systems PCView Application RealEstateModel SpeechController 5 : show() 6 : show() 9 : sendCommand(FIND_CMD,SFH,33803) 10 : processCommand() 12 : getResults() 11 : update() 4 : attach(aView) 2 : aView : new SpeechCustomizedView() 3 : aController : new VoiceController() 7 : onVoiceInput(nd single family homes in Lakeland, FL) 8 : processSpeech() 1 : aModel : new Model() Once the view is displayed, it enables the voice input mode to receive voice input. : User FIGURE 4.10 The.sequence.for.searching.for.single-family.homes.in.Lakeland.Florida. Patterns and Styles in Software Architecture  131 Skill Development 4.3: Distributed MVC Real Estate System Consider.a.distributed.Internet.version.of.the.MVC.real.estate.system.Using.pencil. and.paper.use.UML.ports.and.delegate.relationships.to.modify.the.component.dia- gram.of.Figure 4.9.to.support.the.development.of.this.system.under.the.new.environ- ment.constraints.Draw.also.a.deployment.diagram.that.shows.how.the.system.can.be. deployed.on.tablets.and.mobile.phones.Feel.free.to.modify.the.original.MVC.relation- ships.and.diagram.to.account.for.this.new.problem. HIERARCHICAL SYSTEMS Hierarchical.systems.are.systems.in.which.components.can.be.structured.in.hierarchical. fashion.so.that.components.exist.at.different.levels.of.abstraction.and.each.level.addresses. a.particular.concern.of.the.software.system.For.each.level.identified.in.the.hierarchical. system.one.or.more.components.can.be.identified.each.possibly.branching.downward.

--- Chunk 247 ---
Tokens: 379
Type: sentence-based
Text:
system.one.or.more.components.can.be.identified.each.possibly.branching.downward. to.other.components.necessary.to.carry.out.a.particular.operation.Conceptually.compo- nents.residing.at.higher.levels.of.the.hierarchy.structure.dispatch.requests.and.rely.on.the. services.of.those.in.lower.levels.of.the.hierarchy.In.some.cases.access.to.the.services.pro- vided.at.the.different.levels.can.be.unified.and.strictly.controlled.therefore.compartmen- talizing.them.and.increasing.the.reusability.of.their.services.In.other.cases.the.hierarchy. structure.is.mapped.conceptually.to.the.processing.of.data.resulting.in.a.set.of.functional. cohesive.components.at.appropriate.levels.of.abstraction.for.creating.modular.systems. In any.case.designing.systems.in.hierarchical.fashion.typically.leads.to.well-structured. and.modular.systems.Two.common.architectural.patterns.for.hierarchical.systems.are . Main.program.and.subroutine . Layered Main Program and Subroutine The. main. program. and. subroutine. architectural. pattern. is. popular. in. systems. that. are. designed. using. the. structured. (or. functional). design. strategy. In. these. systems. a. main. component. (or program.).contains.the.main.data.for.the.program.which.is.shared.among. components.residing.at.lower.levels.of.the.hierarchy.Each.level.of.the.hierarchy.represents. refinements.of.the.system.so.that.level.n.provides.the.main.level.level.n .1.provides.further. refinements.of.services.n .2.provides.even.further.refinements.and.so.on.This.process.

--- Chunk 248 ---
Tokens: 388
Type: sentence-based
Text:
refinements.of.services.n .2.provides.even.further.refinements.and.so.on.This.process. continues.until.the.system.is.decomposed.into.an.appropriate.set.of.finer-grained.compo- nents.(or.subroutines).To.illustrate.this.concept.consider.creating.the.logical.architecture. for.a.printer.system.based.on.its.data-flow.diagram.(DFD).When.using.a.DFD.inputs.and. outputs.are.represented.by.boxes.data.flowing.through.systems.are.represented.by.arrows. and.data.transformations.are.represented.by.circles.as.presented.in.Figure 4.11.As.seen.a. 132  Software Engineering Design Level.0.DFD.represents.the.initial.context.of.the.system.The.input.source.1.(IS1).represents.a. keypad.for.configuration.of.the.printer.and.the.input.source.2.(IS2).represents.input.from.the. computer.that.sends.jobs.to.the.printer.Two.system.outputs.are.presented.one.to.the.printers. onboard.display.(OD1).and.another.for.the.paper.printout.(OD2).The.initial.context.of.the. system.(i.e.Level.0).design.indicates.that.the.system.transforms.two.inputs.to.generate.two. different.outputs.As.the.DFD.is.refined.a.Level.1.DFD.is.produced.to.indicate.that.two. Keypad Input Computer Input Keypad Display Level 0 DFD System Tray Output Keypad Input Computer Input Keypad Display Level 1 DFD DT1 DT2 Tray Output Keypad Input Computer Input Structure Chart - Logical Architecture Keypad Display Level 2 DFD Tray Output component Printer IComputer ITray IKeypad component Tray Output component Computer IF component Keypad IO FIGURE 4.11 The.main.program.and.subroutine.architectural.pattern.

--- Chunk 249 ---
Tokens: 364
Type: sentence-based
Text:
Keypad Input Computer Input Keypad Display Level 0 DFD System Tray Output Keypad Input Computer Input Keypad Display Level 1 DFD DT1 DT2 Tray Output Keypad Input Computer Input Structure Chart - Logical Architecture Keypad Display Level 2 DFD Tray Output component Printer IComputer ITray IKeypad component Tray Output component Computer IF component Keypad IO FIGURE 4.11 The.main.program.and.subroutine.architectural.pattern. Patterns and Styles in Software Architecture  133 distinct.transformations.are.required.one.for.transforming.data.from.the.keypad.input.to. the.keypad.display.and.the.other.for.transforming.computer.input.into.a.printout.In.the. Level.2.DFD.two.distinct.flows.of.data.are.identified.one.to.generate.printouts.in.black.and. white.and.the.other.to.generate.printouts.in.color.In.each.flow.different.transformations. are.required.This.refinement.is.iteratively.done.and.once.all.transformations.are.identified. they.can.be.grouped.into.components.to.form.the.logical.architecture.of.the.system.In.this. example.the.print.manager.(PM).which.is.the.main.program.consists.of.three.independent. components.which.provide.the.subroutines.identified.based.on.the.data.transformations. A more.detailed.coverage.of.this.approach.is.represented.by.Pressman.(2010.p.265). The.main.components.identified.for.the.main.program.and.subroutine.architectural. .pattern.include.one.main.component.which.stores.all.the.data.and.various.finer-grained.

--- Chunk 250 ---
Tokens: 387
Type: sentence-based
Text:
.pattern.include.one.main.component.which.stores.all.the.data.and.various.finer-grained. subcomponents.that.carry.out.detailed.system.operations.Systems.based.on.this.archi- tectural.pattern.benefit.mainly.from.its.structured.decomposing.such.that.independent. single-purpose.components.become.easier.to.understand.manage.code.debug.and.reuse. The.main.quality.properties.associated.with.the.main.program.and.subroutine.architec- tural.pattern.are.presented.in.Table 4.11. Layered Pattern The.main.program.and.subroutine.architectural.pattern.leads.to.hierarchical.structures.that. expand.vertically.and.horizontally.with.each.level.of.the.hierarchy.containing.one.or.more. components.that.can.interact.with.one.or.more.components.at.lower-levels.of.the.hierarchy. A.more.constrained.form.of.hierarchical.structure.involves.each.layer.having.one.main. componentwhich.can.be.composed.internally.of.multiple.componentsthat.provides.a. unified.interface.for.communicating.with.components.residing.immediately.below.in.the. hierarchy.structure.This.form.of.constrained.collaboration.of.hierarchical.architectures. is.captured.with.the.layered.architectural.pattern.With.the.layered.architectural.pattern. the.work.performed.to.accomplish.a.system.function.is.somewhat.independent.and.more. compartmentalized.than.in.the.main.program.and.subroutine.It.is.used.when.systems.can. be.decomposed.into.cohesive.layers.with.a.structured.way.of.interfacing.between.layers. The.layered.architecture.is.widely.used.in.systems.software.such.as.an.operating.systems.

--- Chunk 251 ---
Tokens: 378
Type: sentence-based
Text:
The.layered.architecture.is.widely.used.in.systems.software.such.as.an.operating.systems. communication.stack.where.each.layer.is.an.abstraction.of.a.major.function.of.communi- cation.systems.Each.layer.also.relies.on.services.from.other.layers.directly.below.to.create. communication.packets.and.to.provide.quality.of.service.routing.services.node-to-node. communication. and. transmission. using. varied. physical. layers. This. way. rules. can. be. TABLE 4.11 Quality.Properties.of.the.Main.Program.and.Subroutine.Pattern Quality Description Modifiability By.decomposing.the.system.into.independent.single-purpose.components.each.component. becomes.easier.to.understand.and.manage. Reusability Independent.finer-grained.components.can.be.reused.in.other.systems. 134  Software Engineering Design imposed.on.the.systems.logical.architecture.to.restrict.access.among.components.therefore. decreasing.the.systems.coupling.and.increasing.its.modifiability.and.portability.That.is.by. compartmentalizing.major.system.functions.and.controlling.access.to.their.services.(via. well-defined.and.stable.interfaces).system.modifiability.and.portability.can.be.increased. Consider.the.logical.architecture.of.an.environmental.embedded.monitor.and.control. system.capable.of.being.remotely.deployed.to.monitor.and.control.other.nodes.in.a.sys- tem.that.provides.environmental.information.The.system.works.by.receiving.a.collection. schedule.that.is.used.to.activate.and.deactivate.other.nodes.in.the.system.to.control.their.

--- Chunk 252 ---
Tokens: 390
Type: sentence-based
Text:
schedule.that.is.used.to.activate.and.deactivate.other.nodes.in.the.system.to.control.their. operations.and.to.retrieve.their.collected.data.Since.the.system.is.deployed.in.environmen- tal.areas.where.communication.infrastructure.may.not.be.present.it.uses.satellite.commu- nications.to.receive.collection.schedules.and.to.provide.environmental.information.back. to.a.central.station.where.it.can.be.safely.analyzed.Collection.schedules.are.encrypted.to. provide.additional.level.of.security.which.means.that.upon.receipt.the.remotely.deployed. system.needs.to.decrypt.the.messages.and.perform.application-dependent.logic.to.inter- pret.and.execute.them.Once.a.collection.schedule.for.a.particular.node.in.the.system.is. executed.the.system.interfaces.with.the.hardware.to.send.appropriate.commands.to.other. collection.nodes.The.logical.architecture.for.this.system.is.designed.using.the.layered. architectural.pattern.as.seen.in.Figure 4.12. The. box-and-line. design. of. Figure 4.12. presents. a. generic. approach. to. designing. .layered.software.It.shows.each.independent.layer.collaborating.only.with.the.services. of.the.layers.immediately.below.This.way.replacing.services.at.one.layer.does.not.affect. the. whole. system. When. applied. to. the. environmental. monitor. and. control. system. the.UML.component.diagram.results.in.the.one.presented.in.Figure 4.12.As.seen.the. SatcomLayer.component.abstracts.the.services.required.to.receive.a.monitor.plan.which. when.received.is.passed.down.to.the.SecurityLayer.component.for.decryption.and.further.

--- Chunk 253 ---
Tokens: 318
Type: sentence-based
Text:
when.received.is.passed.down.to.the.SecurityLayer.component.for.decryption.and.further. passed.down.the.layered.hierarchy.for.processing.in.the.ApplicationLayer.Once.environ- mental. monitoring. is. activated. the. ApplicationLayer. component. interfaces. with. the. HardwareComponent.to.initiate.activation.of.the.external.nodes.As.seen.UML.ports.are. used.to.show.the.boundaries.of.the.remote.monitor.system.and.the.delegate.label.is.used. to.indicate.that.the.responsibility.for.fulfilling.the.required.services.is.delegated.to.one.or. more.components.in.the.system.The.main.quality.attributes.associated.with.the.layered. architectural.pattern.are.presented.in.Table 4.12. Skill Development 4.4: Layered Architectural Pattern Conduct.an.online.search.for.the.Open.Systems.Interconnection.(OSI).reference.model. or.TCPIP.model.Select.one.and.explain.how.the.layered.architectural.pattern.applies. to.the.selected.model.Clearly.identify.each.layer.their.services.and.how.they.interact. with.other.layers.in.the.system.Can.you.think.of.other.system.software.that.can.be. designed.using.the.layered.architectural.pattern.Come.up.with.such.examples.and. then.identify.the.layers.that.you.would.create.and.the.services.(and.interaction.with. other.layers).within.the.system.

--- Chunk 254 ---
Tokens: 356
Type: sentence-based
Text:
other.layers).within.the.system. Patterns and Styles in Software Architecture  135 Layer 1 Layer 2 Box-and-Line Diagram Layer 3 Layer n UML Component Diagram component SatcomLayer subsystem RemoteMonitorSystem ISatcom ISecure component SecurityLayer delegate component ApplicationLayer component HardwareLayer ISecure IApplication IHardware IApplication INodeMonitor INodeMonitor delegate IMonitorPlan IMonitorPlan FIGURE 4.12 The.layered.architectural.pattern. TABLE 4.12 Quality.Attributes.Associated.with.the.Layered.Architectural.Pattern Quality Description Modifiability Dependencies.are.kept.local.within.layer.components.Since.components.can.access.other. components.only.through.a.well-defined.and.unified.interface.the.system.can.be.modified. easily.by.swapping.layer.components.with.other.enhanced.or.new.layer.components. Portability Services.that.deal.directly.with.a.platforms.application.programming.interface.(API).can.be. encapsulated.using.a.system.layer.component.Higher-level.layers.rely.on.this.component.for. providing.system.services.to.the.application.therefore.by.porting.the.systems.API.layer.to. other.platforms.the.systems.become.more.portable. Security The.controlled.hierarchical.structure.of.layered.systems.allows.for.easy.incorporation.of. security.components.to.encrypt.or.decrypt.incoming.or.outgoing.data. Reusability By.compartmentalizing.each.layers.services.they.become.easier.to.reuse.

--- Chunk 255 ---
Tokens: 379
Type: sentence-based
Text:
Reusability By.compartmentalizing.each.layers.services.they.become.easier.to.reuse. 136  Software Engineering Design CHAPTER SUMMARY During.software.architecture.designers.spend.a.great.deal.of.time.devising.architectural.solu- tions.that.provide.the.necessary.components.and.interfaces.to.achieve.systems.requirements. At.the.architectural.level.common.patterns.have.emerged.that.describe.the.elements.of.the. system.and.the.quality.characteristics.of.those.elements.These.patterns.also.known.as.archi- tectural.styles.have.emerged.as.the.mainstream.approach.for.achieving.reuse.of.successful. design.solutions.at.the.architectural.level.and.are.fundamental.to.the.efficient.creation.of.soft- ware.architectures.Architectural.patterns.provide.generic.reusable.architectural.solutions. documented.in.a.way.that.can.be.easily.understood.and.applied.to.new.problems.requiring. similar.architectural.features.Decisions.based.on.architectural.patterns.benefit.from.years.of. documented.experience.that.highlights.the.solution.approach.to.given.problems.the.benefits. of.these.approaches.and.the.consequences.of.designing.the.system.with.a.particular.style. Architectural. patterns. can. be. classified. by. the. type. of. systems. they. support. such. as. data-centered. data-flow. distributed. interactive. and. hierarchical. systems. Examples. of. architectural. patterns. include. blackboard. pipe. and. filter. clientserver. broker. modelviewcontroller.main.program.and.subroutine.and.layered.patterns.These.patterns.

--- Chunk 256 ---
Tokens: 399
Type: sentence-based
Text:
modelviewcontroller.main.program.and.subroutine.and.layered.patterns.These.patterns. allow.designers.to.efficiently.conduct.principled.analyses.of.the.layout.of.sub.systems.and. components.that.need.to.communicate.in.the.operational.system.During.the.past.decade. many.styles.and.patterns.for.software.architecture.have.been.researched.and.published. Many.of.these.patterns.have.been.identified.in.pattern.catalogue.books.some.of.these.are. common.design.patterns.in.enterprise-level.systems.while.others.address.specific.needs. such. as. distributed. systems. Identifying. and. designing. using. architectural. patterns. can. improve.the.efficiency.of.the.development.process.and.the.quality.of.the.final.system. REVIEW QUESTIONS . 1.What.is.an.architectural.pattern.and.how.does.it.differ.from.detailed.design.patterns? . 2.List. and. explain. the. different. types. of. systems. discussed. for. which. architectural. .patterns.can.be.employed. . 3.Are.software.architectures.restricted.to.only.one.architectural.pattern.for.its.logical. design.or.can.they.include.more.than.one.architectural.pattern.Explain.with.examples. . 4.Can.architectural.patterns.lead.to.direct.translation.to.code.Explain. . 5.Explain.the.following.architectural.patterns.and.provide.an.example.of.a.system. (different.from.the.one.discussed.in.this.chapter).appropriate.for.them.Explain.how. these.patterns.support.particular.quality.attributes. . a. Blackboard . b. Pipe.and.filter . c. MVC . d. Layered Patterns and Styles in Software Architecture  137 . 6.Compare.and.contrasts.the.following.architectural.patterns: .

--- Chunk 257 ---
Tokens: 398
Type: sentence-based
Text:
6.Compare.and.contrasts.the.following.architectural.patterns: . a. Clientserver.vs.broker . b. Layered.vs.main.program.and.subroutine . 7.How.can.the.pipe.and.filter.architectural.pattern.enhance.the.performance.of.software. systems? . 8.How.can.the.MVC.enhance.a.systems.modifiability.usability.and.reusability? . 9.How.can.the.broker.pattern.enhance.a.systems.interoperability? . 10.How.can.the.layered.pattern.support.a.systems.security.and.portability? . 11.Explain.how.using.design.elements.from.different.architectural.views.can.support. the.use.of.architectural.patterns.for.providing.a.complete.picture.of.an.architectural. design.element. CHAPTER EXERCISES . 1.Find.a.computer.using.the.Microsoft.Windows.operation.systems.and.Microsoft.Office. Word.Perform.a.Google.search.on.how.to.split.the.window.horizontally.of.the.par- ticular.version.of.Word.that.you.are.executing.so.that.you.can.split.a.document.hori- zontally.into.two.windows.that.mirror.each.other.Position.each.window.on.the.same. document.location.and.begin.typing.in.the.topmost.window.As.you.type.you.should. see.the.bottom.window.getting.updated.in.real.time.to.incorporate.the.newly.entered. text.Explain.how.architectural.patterns.can.help.achieve.this.capability.Provide.spe- cific.examples.of.architectural.patterns.that.can.be.used.for.this.capability. . 2.Using.the.UML.tool.of.choice.create.the.logical.design.using.patterns.for.a.portable. interactive.and.distributed.software.system.State.your.assumptions.and.accompany. your.design.with.a.rationale.of.why.the.particular.patterns.were.selected.and.how.they.

--- Chunk 258 ---
Tokens: 394
Type: sentence-based
Text:
your.design.with.a.rationale.of.why.the.particular.patterns.were.selected.and.how.they. support.the.required.quality.attributes.Feel.free.to.design.around.the.patterns.to.pro- vide.other.views.and.to.present.a.whole.picture.of.the.system.design. REFERENCES Alexander.Christopher.Sara.Ishikawa.Murray.Silverstein.Max.Jacobson.Ingrid.Fiksdahl-King.and.Shlomo. Angel.A Pattern Language: Towns, Buildings, Construction.New.York.Oxford.University.Press.1977. Bass.Len.Paul.Clements.and.Rick.Kazman.Software Architecture in Practice.2d.ed.Boston.Addison-Wesley.2003. Buschmann. Frank. Regine. Meunier. Hans. Rohnert. Peter. Sommerlad. and. Michael. Stal. Pattern-Oriented Software Architecture: A System of Patterns.West.Sussex.UK.Wiley.1996. Clements.Paul.Rick.Kazman.and.Mark.Klein.Evaluating Software Architectures.Santa.Clara.CA.Addison. Wesley.2001. Pressman.Roger.S.Software Engineering: A Practitioners Approach.7th.ed.Belmont.CA.McGraw-Hill.2010. Qian.Kai.Xiang.Fu.Lixin.Tao.Chong-Wei.Xu.and.Jorge.L.Diaz-Herrera.Software Architecture and Design Illuminated.Sudbury.MA.Jones.Barlett.2009. Taylor.Richard.N.Nenad.Medvidovic.and.Eric.M.Dashofy.Software Architecture: Foundations, Theory, and Practice.Hoboken.NJ.Wiley.2009. 139 5 Principles of Detailed Design CHAPTER OBJECTIVES . Understand.the.role.of.detailed.design.within.the.software.design.phase . Become.familiar.with.detailed.design.tasks.during.software.design . Become.familiar.with.the.detailed.design.process . Understand. fundamental. concepts. of. object-oriented. concepts. and. principles.for.component.designs .

--- Chunk 259 ---
Tokens: 379
Type: sentence-based
Text:
principles.for.component.designs . Understand.the.role.of.documentation.in.software.design.and.how.to. create.a.software.design.document CONCEPTUAL OVERVIEW The. previous. chapters. presented. the. software. architecture. activity. as. a. macrodesign.approach.for.transforming.software.requirements.into.design. elements.that.specify.the.main.components.and.interfaces.of.software.sys- tems.This.holistic.black-box.approach.is.essential.for.establishing.the.initial. design.and.a.framework.of.quality.that.guides.and.supports.the.detailed. design.and.construction.of.software.systems.During.detailed.design.the. design. process. continues. where. software. architecture. leaves. off. for. pro- viding.a.white-box.approach.to.design.where.details.left.undefined.and. deferred.to.downstream.designers.are.created.to.define.the.necessary.details. for.fully.specifying.the.internal.structure.and.behavior.of.components.iden- tified.during.architecture.These.detailed.designs.fill.the.gaps.in.the.design. and.provide.a.complete.picture.of.how.the.system.achieves.its.functional. requirements. within. the. quality. framework. established. by. the. software. architecture.Detailed.design.decisions.can.significantly.shape.the.systems. quality.properties.(e.g.portability.performance.usability).therefore.they. 140  Software Engineering Design must.exist.within.the.bounds.of.the.software.architecture.In.some.cases.where.modeling. tools.are.used.to.generate.code.detailed.designs.can.also.significantly.impact.the.quality.

--- Chunk 260 ---
Tokens: 369
Type: sentence-based
Text:
tools.are.used.to.generate.code.detailed.designs.can.also.significantly.impact.the.quality. properties.of.the.construction.phase.Upon.completion.of.the.detailed.design.activity.the. .systems.design.is.sufficiently.complete.so.that.it.can.be.formally.documented.reviewed. and.approved.by.the.systems.stakeholders.which.marks.the.end.of.the.design.phase. WHAT IS DETAILED DESIGN? The.detailed.design.activity.begins.once.the.software.architecture.is.specified.reviewed.and. approved.by.all.stakeholders.in.the.project.During.detailed.design.logical.components.are. refined.and.their.interactions.are.modeled.to.verify.the.validity.of.their.structural.compo- sition.The.execution.of.the.detailed.design.activity.requires.a.shift.from.the.macro.design. approach.to.the.microdesign.approach.to.further.decompose.and.refine.system.components. into.one.or.more.fine-grained.elements.functions.and.data.variables.required.for.support- ing.the.internal.structure.and.behavior.of.components.that.meet.assigned.roles.during.the. software.architecture.activity.IEEE. (1990.p.26).defines.detailed.design.as . 1.The.process.of.refining.and.expanding.the.preliminary.design.phase.of.a.system.or. component.to.the.extent.that.the.design.is.sufficiently.complete.to.be.implemented. . 2.The.result.of.the.process.in.1. Extending.the.IEEE.definition.detailed.design.is.both.the.process.of.refining.the.soft- ware.architecture.to.reach.a.point.where.construction.can.begin.and.the.result.of.such.

--- Chunk 261 ---
Tokens: 378
Type: sentence-based
Text:
Extending.the.IEEE.definition.detailed.design.is.both.the.process.of.refining.the.soft- ware.architecture.to.reach.a.point.where.construction.can.begin.and.the.result.of.such. process.The.detailed.design.activity.is.the.last.major.design.effort.before.the.software.con- struction.phase.A.fundamental.difference.between.architectural.and.detailed.design.is. that.whereas.the.former.is.concerned.mostly.with.defining.the.major.components.of.the. system.and.their.interfaces.the.latter.is.concerned.with.how.these.components.realize.their. assigned.responsibility.This.suggests.that.architectural.designs.employ.a.holistic.approach. to.software.system.design.which.emphasizes.system.quality.while.detailed.design.focuses. on.particular.components.within.the.system.which.emphasizes.the.functional.aspects.of. a.system.This.fundamental.difference.is.essential.in.determining.what.and.how.work.is. performed.during.these.activities.For.example.whereas.the.component.notation.provides. an.appropriate.mechanism.for.designing.logical.architectures.their.level.of.abstraction. is.inappropriate.for.modeling.detailed.design.elements.Therefore.in.object-oriented.sys- tems.classes.and.interfaces.become.the.major.unit.of.design.work.This.in.turn.influences. the.type.of.analyses.performed.during.both.activities.The.modeling.and.analyses.that. occur.during.architecture.help.answer.the.questions.of.what.needs.to.be.developed.and.by. themselves.these.models.and.analyses.cannot.be.used.to.build.directly.a.working.software.

--- Chunk 262 ---
Tokens: 386
Type: sentence-based
Text:
themselves.these.models.and.analyses.cannot.be.used.to.build.directly.a.working.software. system.Detailed.design.goes.deep.into.each.component.to.define.its.internal.structure.and. behavioral.capabilities.and.the.resulting.design.leads.to.natural.and.efficient.construction. of.software.Clements.Bachmann.Bass.Garlan.Ivers.Little.Nord.and.Stafford.(2002.p. 5). differentiate.between.architectural.and.detailed.design.as.follows: Principles of Detailed Design  141 Architecture.is.design.but.not.all.design.is.architecture.That.is.many.design.decisions.are. left.unbound.by.the.architecture.and.are.happily.left.to.the.discretion.and.good.judgement.of. downstream.designers.and.implementers.The.architecture.establishes.constraints.on.down- stream.activities.and.those.activities.must.produce.artifactsfiner-grained.design.and.code that.are.compliant.with.the.archtiecture.but.architecture.does.not.define.an.implementation. Detailed.design.is.closely.related.to.architecture.and.construction.therefore.successful. designers.(during.detailed.design).are.required.to.have.a.full.understanding.of.the.systems. requirements.and.architecture.design.strategy.programming.language.and.methods.and. processes.for.software.quality.control.Detailed.designers.must.also.work.closely.with.stake- holders.(e.g.hardware.team.test.team.quality.team.management).to.provide.designs.that. accommodate.multiple.concerns.appropriate.to.the.detailed.design.activity.This.requires. a.holistic.visiondifferent.from.that.of.the.software.architecture.designerto.envision.

--- Chunk 263 ---
Tokens: 367
Type: sentence-based
Text:
a.holistic.visiondifferent.from.that.of.the.software.architecture.designerto.envision. detailed.designs.and.how.they.relate.to.requirements.architecture.and.construction.as. presented.in.Figure 5.1. The. conceptual. model. presented. in. Figure 5.1. shows. interrelationships. that. detailed. design.elements.have.with.other.architectural.or.construction.elements.In.this.context. C Requirements, Architecture Detailed Design Requirements, Architecture Designers Mental Model Code Code Detailed Design FIGURE 5.1 Context.of.detailed.design.activity. 142  Software Engineering Design detailed.designs.provide.the.essential.structure.that.acts.as.bridge.connecting.the.work. performed.during.architecture.and.construction.Detailed.designs.need.to.incorporate. design.alternatives.that.support.the.requirements.and.quality.attributes.(e.g.testability. maintainability.modifiability).identified.in.previous.phases.and.activities.of.the.software. engineering.life.cycle.When.presented.with.requirements.or.concerns.from.other.stake- holders.detailed.designers.are.able.to.visualize.designs.that.provide.the.required.struc- tural.and.behavioral.capabilities.for.achieving.those.needs.As.they.work.to.shape.new. or.existing.designs.they.are.also.capable.of.visualizing.the.executing.code.to.help.them. formalize.the.design.When.given.code.such.as.the.case.during.the.maintenance.phase. detailed.designers.are.required.to.envision.detailed.designs.or.even.reverse.engineer.the.

--- Chunk 264 ---
Tokens: 390
Type: sentence-based
Text:
detailed.designers.are.required.to.envision.detailed.designs.or.even.reverse.engineer.the. code.into.designs.and.to.understand.how.both.code.and.designs.relate.to.the.original.soft- ware.requirements.This.mental.model.allows.designers.to.understand.the.complex.inter- dependencies.that.exist.among.these.different.life.cycle.phases.and.how.requirements.and. quality.attributes.are.achieved.throughout.the.software.project.Achieving.such.visions. from.designers.helps.in.all.aspects.of.designing.high-quality.large-scale.software.systems. KEY TASKS IN DETAILED DESIGN It.can.be.argued.that.the.detailed.design.phase.is.where.most.of.the.problem-solving.activi- ties.occur.in.software.projects.Consider.the.case.where.formal.design.processes.are.fol- lowed.so.that.the.requirements.phase.is.followed.by.the.architectural.design.activity.which. is.followed.by.detailed.design.In.many.practical.applications.the.architectural.design. activity.defers.complex.problem.solving.to.the.detailed.design.activity.mainly.through. abstraction.In.some.cases.even.defining.the.requirements.is.deferred.to.the.detailed.design. phase.leaving.the.detailed.design.activity.as.the.gatekeeper.for.ensuring.that.the.systems. specification.and.design.are.sufficiently.complete.before.construction.begins.Deferring. such.problems.to.the.construction.phase.is.a.recipe.for.failure.since.this.typically.results. in.higher.cost.(Clements.Kazman.and.Klein.2001).When.done.properly.detailed.designs. should.provide.a.ready-made.solution.that.eases.the.construction.process.To.achieve.this.

--- Chunk 265 ---
Tokens: 384
Type: sentence-based
Text:
should.provide.a.ready-made.solution.that.eases.the.construction.process.To.achieve.this. during.detailed.design.designers.must.fully.understand.requirements.assigned.to.com- ponents.and.architectural.decisions.deriving.detailed.design.they.must.design.complex. interfaces.identify.design.patterns.evaluate.and.validate.detailed.designs.generate.code. from.the.models.and.establish.policies.for.ensuring.design.synchronicity.throughout.the. construction.phase. DETAILED DESIGN PROCESS The.detailed.design.process.is.carried.out.to.identify.how.architectural.components.are. designed.with.enough.detail.so.that.their.implementation.using.programming.languages. Principles of Detailed Design  143 can.follow.without.much.effort.Many.process.flows.can.be.identified.and.used.to.carry. out. and. manage. detailed. design. activity. including. iterative. sequential. and. spiral. (Pressman 2010).Regardless.of.the.particular.process.flow.selected.for.a.given.project. carrying.out.the.detailed.design.activity.requires.the.following.fundamental.tasks: . Understanding.the.architecture.and.requirements . Creating.detailed.design . Evaluating.detailed.design . Documenting.detailed.design . Monitoring.and.controlling.implementation UNDERSTANDING THE ARCHITECTURE AND REQUIREMENTS Unlike.the.software.architecture.activity.where.the.complete.set.of.system.requirements. are.evaluated.and.well.understood.designers.during.the.detailed.design.activity.focus. on.requirements.allocated.to.their.specific.components.In.some.cases.requirements.can.

--- Chunk 266 ---
Tokens: 383
Type: sentence-based
Text:
on.requirements.allocated.to.their.specific.components.In.some.cases.requirements.can. cross-cut.several.components.therefore.communication.with.other.designers.is.essential. to.coordinating.the.design.solution.without.duplicating.work.Besides.addressing.require- ments.passed.on.from.the.architectural.activity.it.is.also.common.during.detailed.design. to.derive.new.software.requirements.as.knowledge.of.the.system.is.enhanced.throughout. the.detailed.design.activity.Derived.requirements.are.requirements.based.on.higher-level. specifications.created.to.address.a.finer-grained.function.or.process.during.detailed.design. and. construction. These. requirements. can. help. standardize. operations. for. higher-level. requirements. identified. in. previous. phases. and. activities. of. the. project. Consider. an. embedded. real-time. software. system. broken. down. into. five. different. major. subsystem. components.each.executed.on.different.target.hardware.and.broken.down.further.into. numerous.other.components.During.requirements.the.functional.capability.to.log.events. in.the.system.is.specified.To.carry.out.this.function.of.the.system.a.detailed.design.activ- ity.is.done.to.create.a.common.event.logger.so.that.all.components.in.the.systems.rely.on. a.standardized.way.for.logging.events.in.the.system.Because.of.the.resource-constrained. environment.of.the.particular.embedded.system.simply.having.one.functional.require- ment.to.log.events.provides.insufficient.specification.for.the.desired.behavior.Consider.the.

--- Chunk 267 ---
Tokens: 385
Type: sentence-based
Text:
environment.of.the.particular.embedded.system.simply.having.one.functional.require- ment.to.log.events.provides.insufficient.specification.for.the.desired.behavior.Consider.the. case.where.the.event.logger.is.designed.to.log.all.events.in.the.system.to.a.file.without.limits. or.policies.to.manage.how.events.are.stored.purged.and.so.forth.In.such.a.resource- constrained.environment.enforcing.and.verifying.policies.for.such.behavior.is.essential. since.a.large.number.of.events.depending.on.the.target.resources.can.slow.or.bring.the. system.down.In.such.cases.deriving.requirements.that.specify.these.policies. (e.g.maxi- mum.number.of.events.logged.event.purge.policy.such.as.first-in.first-out.(FIFO).last-in. last-out.(LIFO)).provides.essential.items.of.verification.for.the.system.These.requirements. are.imposed.not.by.customers.but.by.the.design.team.to.enforce.a.desired.capability.of.the. software.or.process.to.develop.the.software.When.conducting.the.detailed.design.activity. 144  Software Engineering Design assigned.requirements.for.the.components.have.to.be.well.understood.and.when.appro- priate.derived.requirements.need.to.be.specified.before.construction.begins. Besides.understanding.requirements.during.detailed.design.understanding.and.adhering. to.the.software.architecture.are.essential.for.building.high-quality.systems.The.concept.of. design.synchronicity.was.presented.in.Chapter.3.as.the.degree.to.which.the.software.imple- mentation.conforms.to.its.design.To.maintain.synchronicity.throughout.the.development.

--- Chunk 268 ---
Tokens: 399
Type: sentence-based
Text:
design.synchronicity.was.presented.in.Chapter.3.as.the.degree.to.which.the.software.imple- mentation.conforms.to.its.design.To.maintain.synchronicity.throughout.the.development. effort.all.decisions.made.during.detailed.design.must.conform.to.the.systems.identified. architecture.To.achieve.this.software.processes.must.be.in.place.for.monitoring.and.con- trolling.detailed.designs.throughout.Unmanaged.deviations.from.the.software.architec- ture.during.detailed.design.and.construction.can.reshape.the.properties.of.the.system.and. affect.its.overall.capability.to.meet.requirements.Therefore.detailed.designers.need.to.work. closely.with.each.other.and.with.software.architects.to.ensure.that.their.design.choices.are. consistent.with.the.overall.system.plan.This.is.especially.true.during.maintenance.phases. where.deviations.may.occur.long.after.the.initial.system.design.is.devised. CREATING DETAILED DESIGNS After.requirements.and.the.software.architecture.are.well.understood.the.detailed.design. of.software.components.can.begin.The.detailed.design.consists.of.structural.and.behav- ioral.designs.required.to.specify.components.sufficiently.so.that.they.can.be.consistently. constructed.by.one.or.more.programmers.This.entails.various.design.tasks.including. refining. or. .creating. components. interface. design. internal. structure. and. behavioral. design.identifying.design.patterns.applying.design.principles.adopting.naming.conven- tions.and.evaluating.and.documenting.detailed.designs.These.are.discussed.in.more. detail.throughout.the.following.sections. Interface Design Interface.

--- Chunk 269 ---
Tokens: 363
Type: sentence-based
Text:
Interface Design Interface. design. refers. to. the. design. activity. that. deals. with. specification. of. interfaces. between.components.in.the.design.(Sommerville.2010).Interface.design.can.be.focused.on. specifying.the.interfaces.used.internally.within.software.components.or.externally.across. software.components.In.both.cases.interfaces.provide.a.standardized.way.for.specifying. how.services.are.accessed.and.provided.by.software.components.Interface.design.allows. subsystems.to.be.designed.independently.and.in.parallel.therefore.it.is.typically.done.first. within.the.detailed.design.step. External Interface Design During.the.software.architecture.activity.externally.visible.interfaces.are.specified.The. realization.of.these.interfaces.may.involve.much.detailed.design.work.before.they.can. be. used. in. construction. These. may. include. a. customized. binary. message. definition. Principles of Detailed Design  145 Extensible.Markup.Language.(XML).schemas.and.messages.or.other.interfaces.required. for.specifying.how.components.interact.with.other.external.components.Depending.on. the.interface.design.effort.a.formal.interface.document.can.be.created.and.managed.inde- pendently.similar.to.the.requirements.specification.or.design.document.This.document. known.as.the.interface.control.document.(ICD).is.an.important.piece.of.documentation. that.serves.as.a.written.contract.between.components.of.the.software.system.to.specify.how.

--- Chunk 270 ---
Tokens: 393
Type: sentence-based
Text:
that.serves.as.a.written.contract.between.components.of.the.software.system.to.specify.how. they.will.communicate.The.ICD.defines.the.important.data.and.protocols.used.for.com- munication.between.components.therefore.providing.developers.during.construction.the. required.information.needed.to.write.the.software. Internal Interface Design The.Internal.interface.definition.establishes.policies.for.subsequent.development.in.the. software.design.It.provides.a.way.for.abstracting.common.operations.so.that.problems. during. detailed. design. can. be. reasoned. in. terms. of. these. interfaces. which. provides. a. higher.level.of.abstraction.for.specifying.rules.that.apply.to.a.larger.set.of.entities.that. rely.on.them.In.object-oriented.systems.Unified.Modeling.Language.(UML).can.be.used. to.create.interface.designs.using.class.diagrams.that.include.the.interface.stereotype. in.the.name.section.of.the.class.as.presented.in.Chapter.2.These.help.identify.the.major. classes.and.functions.that.allow.intercomponent.communication.and.provide.the.rules. of.communication.that.must.be.followed.by.other.classes.that.implement.these.interfaces. during.the.detailed.design.activity. Graphical User Interface Design Visual.designs.have.a.major.role.in.the.success.or.failure.of.software.systems.Systems.that. meet.functional.requirements.but.are.not.usable.cannot.succeed.During.detailed-design. the.initial.Human.Computer.Interface. (HCI).design.identified.during.the.software.archi- tecture.activity.is.refined.and.the.appropriate.design.for.interfacing.the.Graphical.User.

--- Chunk 271 ---
Tokens: 368
Type: sentence-based
Text:
(HCI).design.identified.during.the.software.archi- tecture.activity.is.refined.and.the.appropriate.design.for.interfacing.the.Graphical.User. Interface.(GUI).to.the.whole.system.is.done.During.detailed.design.all.aspects.of.the. GUIsuch.as.modes.navigation.visual.designs.(e.g.color.icons.fonts).response.time.and. feedback.design.modalities.(e.g.forms.menu-driven).localization.internationalization. and.general.humancomputer.design.principlesare.fine-tuned. Designing Internal Structure of Components Component.design.is.not.restricted.to.object-oriented.systems.however.the.discussion. and.approach.presented.in.this.section.and.throughout.the.book.focus.on.object-oriented. systems.Other.forms.of.component.design.can.be.employed.based.on.the.design.strategy. such.as.the.structured.design.strategy.In.object-oriented.systems.the.internal.structure. of. components. is. typically. modeled. using. UML. through. one. or. more. class. diagrams. Component.design.refers.to.the.detailed.design.task.of.defining.the.internal.logical.structure. of.components.That.is.the.internal.data.structures.algorithms.interface.characteristics. 146  Software Engineering Design and. communication. mechanisms. of. all. components. are. all. defined. during. component. design.For.this.reason.component.design.provides.the.most.significant.mechanism.for. determining.the.functional.correctness.of.the.software.system.and.allows.for.evaluating. alternative.solutions.before.coding.begins.

--- Chunk 272 ---
Tokens: 392
Type: sentence-based
Text:
alternative.solutions.before.coding.begins. A.multitude.of.principles.guidelines.and.patterns.exist.for.creating.quality.component- level.design.These.principles.guide.engineers.to.make.appropriate.decisions.when.refining. components. into. other. components. and. classes. and. defining. the. relationships. between. them. The. work. produced. during. component. design. serves. as. strong. indication. of. the. functional.success.of.the.software.system.Before.these.concepts.can.be.understood.it.is. .necessary.to.understand.the.basic.concepts.in.component.design.of.object-oriented.systems. These.include. (Gamma.et.al.1995): . Classes.and.objects . Interfaces.types.and.subtypes . Dynamic.binding . Polymorphism Classes The.main.unit.of.composition.in.object-oriented.component.design.is.the.class.Chapter.2. introduced.classes.as.modeling.entities.in.UML.class.diagrams.However.before.becoming. efficient.during.component.design.a.clear.distinction.between.classes.and.objects.needs.to. be.made.A.class.is.a.specification.that.defines.the.data.and.services.used.and.provided.by. particular.objects.There.are.two.types.of.classes.in.object-oriented.component.designs.as. presented.in.Table 5.1. Concrete.classes.specify.the.data.services.and.implementation.of.those.services.required. for. instantiating. objects. Concrete. classes. provide. complete. information. that. supports. instantiation.of.objects.at.run.time.that.have.state.and.behavior.On.the.other.hand.abstract. classes.are.special.types.of.classes.that.contain.one.or.more.abstract.methods.which.have.

--- Chunk 273 ---
Tokens: 382
Type: sentence-based
Text:
classes.are.special.types.of.classes.that.contain.one.or.more.abstract.methods.which.have. no.implementation.Because.abstract.methods.contain.no.implementation.abstract.classes. cannot.be.instantiated.at.run.time.A.special.type.of.abstract.class.is.one.where.all.methods. are.abstract.These.are.equivalent.to.Java.interfaces.and.the.pure.virtual.classes.in.C. As.abstract.classes.interfaces.and.pure.virtual.classes.cannot.be.instantiated.at.run.time. At first.glance.it.seems.logical.to.think.that.classes.that.cannot.be.instantiated.serve.little.to. no.purpose.in.software.designs.However.these.classes.provide.powerful.mechanisms.for. creating.elegant.and.reusable.designs.that.can.lead.to.increased.maintainability.reusability. TABLE 5.1 Types.of.Classes.in.Component.Designs Type Description Concrete Ordinary.class.for.specifying.objects.data.and.behavior Abstract Special.class.that.contains.at.least.one.abstract.method Principles of Detailed Design  147 and.efficient.software.evolution.Abstract.classes.provide.the.means.for.designers.to.create. contracts.that.dictate.the.use.of.interfaces.throughout.software.designs.These.contracts.are. enforced.by.compilers.and.are.founded.on.the.principles.and.concepts.of.interfaces.types. subtypes.dynamic.binding.and.polymorphism. Interfaces, Types, Subtypes, Dynamic Binding, and Polymorphism In.a.broad.sense.an.interface.is.the.set.of.functions.that.specify.the.services.provided.by. objects.of.a.particular.type.An.interface.method.is.simply.one.method.that.belongs.to.an.

--- Chunk 274 ---
Tokens: 385
Type: sentence-based
Text:
objects.of.a.particular.type.An.interface.method.is.simply.one.method.that.belongs.to.an. objects.interface.The.concepts.of.types.and.interfaces.are.interrelated.that.is.since.an. interface.specifies.the.services.provided.by.a.particular.type.it.follows.that.a.particular. type.refers.to.a.particular.interface.In.popular.object-oriented.systems.the.concept.of. types.is.used.interchangeably.with.classes.A.subtype.refers.to.an.interface.that.includes. the.interface.of.another.type.referred.to.as.its.supertype. (Gamma.et.al.1995).This.con- cept.is.reflected.in.object-oriented.languages.as.inheritance.At.design.time.the.concepts. of.interfaces.types.and.subtypes.are.used.to.create.software.that.is.extensible.at.run.time. mainly. through. the. techniques. of. dynamic. binding. and. polymorphism. Consider. the. specification.of.an.interface.using.an.abstract.class.which.as.discussed.before.cannot. be.instantiated.In.such.cases.abstract.classes.are.useful.for.defining.the.common.set.of. services.provided.by.a.specific.type.Through.inheritance.one.or.more.subtypes.can.be. specified.at.design.time.to.provide.implementations.for.the.defined.interfaces.therefore. creating.concrete.classes.that.share.the.same.interface.as.defined.by.the.abstract.class. By designing.classes.this.way.different.objects.can.be.instantiated.at.run.time.to.share.the. same.interface.but.to.provide.completely.different.implementations.(Gamma.et.al.1995). Consider.the.type.Shape.with.a.single.interface.method.named.draw().Now.consider. two.other.subtypes.

--- Chunk 275 ---
Tokens: 386
Type: sentence-based
Text:
two.other.subtypes. (inheriting.from.Shape).named.Circle.and.Rectangle.By.defi- nition.since.Circle.and.Rectangle.are.subtypes.of.Shape.then.they.share.its.inter- face.which.in.this.example.includes.the.draw().interface.method.This.scenario.is.easily. designed.in.modern.programming.languages.by.specifying.Shape.as.pure.virtual.class. in.C.or.interface.in.Java.Both.Circle.and.Rectangle.would.be.designed.using.a. (UML).realization.relationship.with.the.Shape.type.Since.Circle.and.Rectangle.are. meant.to.be.concrete.classes.they.both.must.provide.an.implementation.for.the.draw(). interface.method.otherwise.they.would.both.be.abstract.classes.that.cannot.be.instanti- ated.With.this.framework.in.place.portions.of.the.software.at design time.can.be.specified. using.the.Shape.interface.which.both.Circle.and.Rectangle.support.At.run time. services.specified.by.the.Shape.interface.are.carried.out.by.the.particular.run-time.object. attached.to.the.request.which.could.be.objects.of.either.Circle.or.Rectangle.sub- types.This.way.when.calling.upon.the.objects.draw.interface.method.the.software.can. behave.differently.at.run.time.by.drawing.to.the.screen.either.a.circle.or.a.rectangle. The.mechanism.for.providing.the.run-time.association.between.an.object.and.an.inter- face.method.is.known.as.dynamic.binding.(Gamma.et.al.1995).This.allows.objects.of.the. same.type.hierarchy.to.behave.differently.at.run.time.simply.by.associating.the.interface. method.call.to.the.appropriate.run-time.instance.This.capability.is.known.as.polymorphism.

--- Chunk 276 ---
Tokens: 396
Type: sentence-based
Text:
method.call.to.the.appropriate.run-time.instance.This.capability.is.known.as.polymorphism. 148  Software Engineering Design Interfaces.types.subtypes.dynamic.binding.and.polymorphisms.are.essential.to.achieving. efficient.designs.of.components.in.object-oriented.systems.and.are.the.fundamental.mecha- nisms.for.achieving.most.object-oriented.design.principles.and.patterns. Objects Whereas.classes.are.design-time.entities.objects.are.run-time.entities.that.is.objects.are. the.manifestation.of.classes.and.therefore.occupy.space.and.time.during.software.exe- cution.For.classes.to.be.of.use.in.executing.programs.objects.have.to.be.instantiated. Instantiation.is.the.process.of.manifesting.a.class.in.the.computers.memory.this.manifes- tation.is.referred.to.as.an.object.of.that.class.Therefore.one.class.can.be.manifested.in.the. computers.memory.as.multiple.objects.since.we.can.instantiate.a.class.numerous.times. This.concept.is.presented.in.the.conceptual.model.presented.in.Figure 5.2. As.seen.the.code.in.the.main.function.of.the.ProgramDriver.class.instructs.the. compiler.to.instantiate.three.different.objects.of.type.ListNode.type.In.this.example. the.specification.for.objects.of.type.ListNode.is.provided.by.the.ListNode.class.and. instantiation.of.objects.of.that.class.is.done.by.employing.the.new.keyword.When.the. compiled.and.built.version.of.the.code.is.executed.three.different.objects.of.the.same. classtogether.with.the.object.of.type.ProgramDriverwill.occupy.some.space.in.the. computers.memory.These.three.objects.of.type.ListNode.occupy.specific.locations.in.

--- Chunk 277 ---
Tokens: 398
Type: sentence-based
Text:
computers.memory.These.three.objects.of.type.ListNode.occupy.specific.locations.in. memory.and.are.addressable.by.their.own.memory.address.This.is.possible.because.each. object.has.its.own.identity.Notice.also.in.the.figure.that.the.ProgramDriver.object.has. links.to.the.three.different.node.objects.since.it.has.variables.holding.the.addresses.to. Compile and Build into Executable  Execute in Computer Memory for Executable Computer Memory         FIGURE 5.2 Conceptual.model.for.classes.and.objects. Principles of Detailed Design  149 these.objects.therefore.programDriver.can.always.access.these.objects.through.these. .variables. (i.e, nodeOne.nodeTwo.nodeThree).Unlike.classes.objects.exist.at.run.time.and. have.specific.characteristics.such.as.the.ones.presented.in.Table 5.2.(Douglas.1999). When.designing.at.the.component.level.careful.class.specification.is.essential.to.allow. objects.at.run.time.to.behave.in.such.a.way.that.flexibility.and.reusability.are.added.to. the.software.This.in.turn.allows.component.designs.to.provide.the.means.to.allow.the. software.to.evolve.gracefully.over.time.and.to.become.more.reusable.Designing.efficient. component.structures.allows.todays.software.to.adapt.to.future.technology.or.new.system. functionality.Therefore.when.designing.component-level.software.careful.attention.has. to.be.paid.in.the.application.of.fundamental.detailed.design.principles. Design Principles for Internal Component Design Several. principles. have. been. identified. throughout. the. literature. that. help. in. making. component-level.design.decisions.including .

--- Chunk 278 ---
Tokens: 332
Type: sentence-based
Text:
component-level.design.decisions.including . The.openclosed.principle. (OCP) . The.Liskov.substitution.principle. (LSP) . The.interface.segregation.principle. (ISP) OpenClosed Principle The.OCP.is.an.essential.principle.for.creating.reusable.detailed.designs.It.promotes.designs. that.allow.changes.to.be.made.by.extension.of.designs.rather.than.by.modification.of.exist- ing.code.The.main.idea.behind.the.OCP.is.that.code.that.works.should.remain.untouched. and.that.new.additions.incorporated.to.address.new.concerns.should.be.extensions.of.the. original.work.The.OCP.was.originally.coined.by.Bertrand.Meyer.(1997).and.states.that. software.designs.should.be.open.to.extension.but.closed.for.modification.At.first.glance. the.OCP.sounds.contradictory.since.it.promotes.designs.that.are.closed.to.modification. However.in.the.OCP.context.being.closed.to.modification.does.not.mean.that.designs. cannot. be. modified. it. means. that. modifications. should. be. made. as. extensions. to. the. design.by.adding.new.design.and.code.instead.of.modifying.existing.working.designs.and. code.(Marin.2003).This.is.possible.in.object-oriented.systems.through.the.use.of.abstract. classes.and.interfaces.Consider.a.gaming.system.that.includes.several.types.of.terrestrial. characters.which.can.roam.freely.over.land.as.shown.in.Listing.5.1.

--- Chunk 279 ---
Tokens: 387
Type: sentence-based
Text:
characters.which.can.roam.freely.over.land.as.shown.in.Listing.5.1. TABLE 5.2 Characteristics.of.Objects Characteristic Description Attributes The.objects.data Behavior The.objects.designed.behavior.as.specified.by.its.public.functions State The.current.state.of.the.object.as.defined.by.the.values.of.its.data Identity Their.own.individual.memory.address Responsibilities Two.objects.of.the.same.class.can.be.instantiated.for.specific.purposes 150  Software Engineering Design As.seen.the.GameEngine.class.is.designed.with.an.interface.method.that.accepts. references. (i.e. pointer). to. objects. that. share. the. TerrestrialCharacter. interface. When. an. object. of. type. TerrestrialCharacter. is. passed. into. the. addCharacter(. ).method.the.method.draws.it.to.the.screen.and.calls.the.char- acters.run().method.which.activates.the.character.to.move.over.land.in.a.random. pattern.This.design.works.fine.for.all.kinds.of.terrestrial.characters.however.it.does. little.to.support.efficient.addition.of.other.types.of.characters.to.the.game.This.is.true. because.the.design.of.the.GameEngine.class.relies.on.the.interface.of.the.concrete. TerrestrialCharacter.class.Consider.the.case.where.characters.that.move.dif- ferentlyfor.example.aerial.characters.or.aquatic.charactersare.added.to.the.gam- ing.system.design.In.such.cases.the.addCharacter.method.needs.to.be.modified.to. account.for.these.new.types.of.characters.Therefore.the.design.of.the.GameEngine. class.is.not.closed.for.modification.That.is.the.code.inside.the.GameEngine.class.

--- Chunk 280 ---
Tokens: 346
Type: sentence-based
Text:
class.is.not.closed.for.modification.That.is.the.code.inside.the.GameEngine.class. would.have.to.change.which.violates.the.OCP.To.prevent.this.the.OCP.promotes.and. relies.on.an.indispensable.design.principle.in.object-oriented.systems.which.states. that.software designs should rely on interfaces and not on implementations.(Gamma. Listing 5.1: C Code for the Gaming System  The terrestrial character. class TerrestrialCharacter  public:  Draw the character on the screen. virtual void draw()  Code to draw the terrestrial character. Make the character run! virtual void run()   Code to make the character run. ;  The game engine responsible for managing the game. class GameEngine  public:  Add the character to the screen. void add(TerrestrialCharacter pCharacter)   Display the character. pCharacter-draw();  Make the character move! pCharacter-run();  ; Principles of Detailed Design  151 et al.1995).Consider.the.addition.of.the.Character.interface.to.the.gaming.systems. design.as.presented.in.Listing.5.2. As.seen.the.Character.class.is.abstract.as.specified.by.the.two.pure.virtual.methods. getType().and.draw().The.character.interface.can.be.used.to.define.interface.methods. that.are.common.to.all.characters.in.the.gaming.system.With.this.interface.in.place.the. aerial.character.is.added.to.the.design.by.implementing.the.Character.interface.as. .presented.in.Listing.5.3. .

--- Chunk 281 ---
Tokens: 397
Type: sentence-based
Text:
. For.those.of.you.interested.in.compiling.the.code.e.g.the.Character.code.you.will.need.to.include.in.your.code.appro- priate.libraries.and.namespace.In.this.case.to.use.the.string.type.you.will.need.to.include.string.and.namespace. std.to.compile.the.Character.class.This.approach.is.generally.followed.throughout.the.rest.of.the.book. Listing 5.2: C Code for the Character Interface class Character  public:  Get the type of character. virtual string getType()  0;  Draw the character on the screen. virtual void draw()  0; ; Listing 5.3: C Code for the AerialCharacter Class class AerialCharacter : public Character  public:  Get the type of character. virtual string getType()   Return the type of character. return aerial;   Draw the character on the screen. virtual void draw()   Code to draw the aerial character. coutdrawing aerial character!n;   Make the character fly! virtual void fly()   Code to make the character fly. coutcharacter flying!n;  ; 152  Software Engineering Design As.seen.the.AerialCharacter.class.implements.both.getType().and.draw().in. terms.of.aerial.characters.The.AerialCharacter.class.also.specifies.the.interface.method. fly().to.make.the.character.fly.in.random.patterns.during.the.characters.activation.in.the. game.With.the.Character.interface.added.to.the.design.the.TerrestrialCharacter. is.now.modified.to.implement.the.newly.added.interface.so.that.anywhere.in.the.design. where. objects. sharing. the. Character. interface. are. expected. both. terrestrial-. and. aerial-type.objects.can.be.used.The.redesigned.TerrestrialCharacter.class.which.

--- Chunk 282 ---
Tokens: 365
Type: sentence-based
Text:
aerial-type.objects.can.be.used.The.redesigned.TerrestrialCharacter.class.which. now.implements.the.Character.interface.is.presented.in.Listing.5.4. With.this.new.framework.in.place.consider.the.redesign.of.the.GameEngine.from. Listing. 5.1. presented. in. Listing. 5.5. Two. major. modifications. have. been. made. to. the. GameEngine.design.First.the.add(.).method.is.modified.to.rely.on.the.Character. interface.instead.of.on.concrete.classes.second.the.code.inside.the.add(.).method.now. accounts.for.different.types.of.characters.To support.this.new.behavior.the.getType(.). method.has.been.added.to.retrieve.the.type.of.the.character.at.run.time.so.that.the.code. inside.the.add().method.can.determine.whether.to.make.characters.run.or.fly.depending. on.their.type.This.fixes.the.problem.of.not.being.able.to.handle.various.types.of.characters. with.different.movements.This.is.an.improvement.from.the.first.design.version.however. the.design.still.violates.the.OCP.Anytime.that.a.new.character.is.added.to.the.game.the. Listing 5.4: C Code for Redesigned TerrestrialCharacter Class class TerrestrialCharacter : public Character  public:  Get the type of character. virtual string getType()   Return the type of character. return terrestrial;   Draw the character on the screen. virtual void draw()   Code to draw the terrestrial character. coutdrawing terrestrial character!n;   Make the character run! virtual void run()   Code to make the character run.

--- Chunk 283 ---
Tokens: 381
Type: sentence-based
Text:
virtual void run()   Code to make the character run. coutcharacter running!n;  ; Principles of Detailed Design  153 add(.).method.needs.to.be.modified.to.add.another.conditional.statement.to.test.for. the.new.character.and.call.the.appropriate.method.to.make.the.new.character.move.This. is.a.direct.effect.of.designs.that.violate.the.OCP.The.gaming.systems.design.is.redesigned. one.last.time.to.make.it.conform.to.the.OCP.as.presented.in.Listing.5.6.As.seen.to.make. the.design.OCP-compliant.better.abstractions.are.introduced.to.the.Character.interface. which.now.includes.the.move(.).interface.method. A.major.design.decision.made.in.the.redesign.of.the.gaming.system.includes.the.addi- tion.of.the.move().interface.method.to.the.Character.interface.This.provides.a.higher. level.of.abstraction.that.allows.the.design.to.appropriately.abstract.moving.behavior.for.all. characters.in.the.system.By.introducing.a.higher.level.of.abstraction.that.is.appropriate. for.characterizing.the.behavior.required.by.characters.(e.g.walk.run.swim.or.fly).the. design.now.allows.the.GameEngine.class.to.rely.on.this.abstraction.to.support.multiple. existing.and.future.characters.in.the.game.as.seen.in.Listing.5.7. Listing 5.5: C Code for the GameEngine Class class GameEngine  public:  Add a character to the game. void add( Character pCharacter )   Draw the character on the screen. pCharacter-draw();  If aerial, make it fly, otherwise, make it run. if( pCharacter-getType()  aerial )   Downcast the pointer to an aerial character.

--- Chunk 284 ---
Tokens: 396
Type: sentence-based
Text:
if( pCharacter-getType()  aerial )   Downcast the pointer to an aerial character. AerialCharacter pAerial  dynamic_castAerialCharacter (pCharacter);  Assume a valid pointer and make the character fly! pAerial-fly();  else   Downcast the pointer to a terrestrial character. TerrestrialCharacter pTerrestrial  dynamic_castTerrestrialCharacter(pCharacter);  Make the character run! pTerrestrial-run();   end if statement. end add function. ; 154  Software Engineering Design With.the.redesign.in.place.the.GameEngine.can.be.used.throughout.to.draw.and. .activate.all.types.of.characters.that.share.the.Character.interface.as.seen.in.Listing.5.8. Consider.the.addition.of.an.aquatic.character.under.this.new.gaming.systems.design. In.the.OCP-compliant.case.the.new.character.is.added.with.new.code.by.implementing. the.Character.interface.At.run.time.objects.that.share.the.Character.interface.can. be.passed.into.the.GameEngine.which.draws.and.activates.the.new.character.using.the. interface.methods.specified.by.the.Character.interface.The.OCP-compliant.design.of. the.gaming.system.with.all.three.supported.characters.is.presented.in.Figure 5.3. An.important.caveat.to.the.OCP.is.that.no.design.is.100.closed.for.modification.At. some.point.some.code.has.to.be.readily.available.for.modifications.The.main.idea.of.the. OCP.is.to.locate.the.areas.of.the.software.that.are.likely.to.vary.and.encapsulate.them.so. Listing 5.6: C Code for the OCP-Compliant Gaming Systems Design class Character  public:  Draw the character on the screen. virtual void draw()  0;  Make the character move.

--- Chunk 285 ---
Tokens: 392
Type: sentence-based
Text:
virtual void draw()  0;  Make the character move. virtual void move()  0; ;  The aerial character. class AerialCharacter : public Character  public:  Draw the character on the screen. virtual void draw()   Code to draw the aerial character. Make the character fly. virtual void move()   Code to make the character fly! ;  The terrestrial character. class TerrestialCharacter : public Character  public:  Draw the character on the screen. virtual void draw()   Code to draw the terrestrial character. Make the character run. virtual void move()   Code to make the character run! ; Principles of Detailed Design  155 that.variations.required.to.account.for.particular.behaviors.can.be.compartmentalized.and. made.interchangeable.through.polymorphism. Skill Development 5.1: OpenClosed Design Principle Using.the.IDE.of.choice.implement.the.OCP-compliant.design.presented.in.Figure 5.4. Create.a.test.driver.function.that.uses.the.GameEngine.to.add.all.three.characters.to. the.game.Once.the.code.compiles.and.executes.design.a.fourth.character.and.add.it. to.the.game.How.do.you.think.the.OCP.made.the.addition.of.the.new.character.easy. or.hard.Explain. Listing 5.7: C OCP-Compliant Design for the GameEngine Class  The game engine responsible for managing the game. class GameEngine  public:  Add the character to the screen. void add(Character pCharacter)   Display the character. pCharacter-draw();  Activate the character. make it move! pCharacter-move();   end add function. ; Listing 5.8: C Client Code that Uses the GameEngine Class  Create the main game engine.

--- Chunk 286 ---
Tokens: 387
Type: sentence-based
Text:
; Listing 5.8: C Client Code that Uses the GameEngine Class  Create the main game engine. GameEngine game;  Create the aerial character object. AerialCharacter aerialCharacter;  Crete the terrestrial character object. TerrestrialCharacter terrestrialCharacter;  Add all characters to the game. game.add(aerialCharacter); game.add(terrestrialCharacter); 156  Software Engineering Design Liskov Substitution Principle The.OCP.from.the.previous.section.provides.guidance.to.design.extensible.systems.by. making.designs.open.to.extension.but.closed.to.modification.In.some.cases.it.can.be.seen. that.adhering.to.the.OCP.alone.does.not.guarantee.correct.designs.or.designs.that.lead.to. reusability.throughout.the.system.To.maintain.the.integrity.of.designs.that.adhere.to.the. OCP.designs.must.honor.any.implied.contract.between.base.classes.and.the.components. that.use.them.(Pressman.2010).This.concept.is.captured.by.the.LSP.which.was.originally. proposed.by.Barbara.Liskov.The.LSP.serves.as.basis.for.creating.designs.that.allow.clients. that.use.derived.classes.to.behave.just.as.they.would.if.they.used.the.corresponding.base. classes.(Liskov.and.Guttag.2000).The.LSP.requires.not.only.that.signatures.between.base. and.derived.classes.are.maintained.but.also.that.the.subtype.specification.supports.reason- ing.based.on.the.supertype.specification.(Liskov.and.Guttag.2000). Consider.the.following.implementation.for.a.new.EntryLevelTerrestrial Character. in.the.gaming.system.The.new.entry-level.character.inherits.from.the.terrestrial.character.

--- Chunk 287 ---
Tokens: 397
Type: sentence-based
Text:
in.the.gaming.system.The.new.entry-level.character.inherits.from.the.terrestrial.character. class.which.provides.the.interface.method.move().and.information.about.the.semantics. of.the.operation.through.pre-.and.postcondition.specification.as.presented.in.Listing.5.9. As.seen.EntryLevelTerrestrialCharacter.implements.the.move.method.to. make.terrestrial.characters.fly.therefore.providing.a.design.that.can.adhere.to.the.OCP.but. that.violates.the.LSP.since.the.semantics.of.the.TerrestrialCharacter.are.not.main- tained.Anywhere.in.the.design.where.objects.of.type.TerrestrialCharacter.are. called.upon.to.move.the.postconditions.defined.for.this.type.specify.that.terrestrial.char- acters.will.walk.or.run.Upon.extending.this.design.with.its.entry-level.subtype.characters. TerrestrialCharacter Adheres to OCP Violates OCP GameEngine interface Character draw(): void run(): void draw(): void move(): void add(pCharacter : TerrestrialCharacter): void GameEngine AerialCharacter add(pCharacter : Character): void draw(): void move(): void TerrestrialCharacter draw(): void move(): void AquaticCharacter draw(): void move(): void FIGURE 5.3 UML.class.diagrams.for.the.OCP.examples.of.the.gaming.systems.design. Principles of Detailed Design  157 no.longer.walk.but.fly.When.designing.systems.that.adhere.to.the.LSP.subtypes.must. conform.both.syntactically.and.semantically.to.their.base.types.so.they.can.be.replaceable. at.run.time.throughout.the.software.execution. Interface Segregation Principle Well-designed.classes.should.have.one.(and.only.one).reason.to.change.When.this.concept.

--- Chunk 288 ---
Tokens: 397
Type: sentence-based
Text:
Interface Segregation Principle Well-designed.classes.should.have.one.(and.only.one).reason.to.change.When.this.concept. is.violated.there.is.a.strong.indication.that.the.interfaces.provided.by.these.classes.are.pro- viding.more.information.than.they.should.which.makes.designs.harder.to.maintain.and. reuse.The.SIP.states.that.clients.should.not.be.forced.to.depend.on.methods.that.they.do. not.use.(Marin.2003).As.example.consider.incorporating.into.the.gaming.system.a.set.of. different.types.of.enemy.characters.each.with.specific.capabilities.for.moving.over.land. under.water.or.over.the.air.In.addition.a.fourth.type.of.enemy.character.is.added.to.the. system.which.incorporates.moving.capabilities.from.all.other.enemy.characters.into.the. .system. (e.g, run.swim.and.fly).To.allow.characters.to.be.interchangeable.at.run.time.these. characters.are.designed.initially.with.a.common.EnemyCharacter.base.class.as.seen.in. sm : ScheduleManager s : Schedule HeatSensor : Sensor VibrationSensor : Sensor 2 : getMsg() 1 : timer expires 4 : msgId  interpretMsg() msgId  HEAT_MSG_ID alt msgId  VIBRATE_MSG_ID return 5 : activate() 6 : activate() sd Activate Sensors FIGURE 5.4 Sequence.diagram.during.detailed.design. 158  Software Engineering Design the.top.part.of.Figure 5.5.Notice.that.since.the.SuperCharacter.class.requires.behavior. from.all.other.enemy.characters.the.EnemyCharacter.base.class.is.designed.to.con- tain.the.implementations.for.all.enemy.characters.in.the.system.This.way.through.inheri- tance.the.SuperCharacter.can.reuse.all.behaviors.What.is.wrong.with.this.design.

--- Chunk 289 ---
Tokens: 387
Type: sentence-based
Text:
from.all.other.enemy.characters.the.EnemyCharacter.base.class.is.designed.to.con- tain.the.implementations.for.all.enemy.characters.in.the.system.This.way.through.inheri- tance.the.SuperCharacter.can.reuse.all.behaviors.What.is.wrong.with.this.design. For.starters.the.design.violates.the.LSP.since.only.the.SuperCharacter.conforms.both. syntactically.and.semantically.to.the.base.type.However.of.more.interest.is.the.fact.that. the.interface.for.all.other.characters.in.the.system.has.now.been.polluted.with.unnecessary. methods.As.enemy.characters.and.capabilities.continue.to.increase.so.will.the.complexity. of.the.EnemyCharacter.interface.which.in.turn.passes.this.complexity.on.to.its.derived. types.Designs.such.as.this.where.clients.or.subtypes.are.forced.to.depend.and.maintain. methods.that.they.do.not.use.leads.to.designs.that.are.hard.to.reuse.and.maintain. The.SIP.implies.that.many.client-specific.interfaces.are.better.than.one.general.purpose. interface.For.example.consider.the.redesign.presented.in.the.lower.part.of.Figure 5.5.As. y(): void run(): void swin(): void AerialCharacterClient TerrestrialCharacterClient AquaticCharacterClient AerialCharacter TerrestrialCharacter EnemyCharacter y(): void run(): void swim(): void interface SuperCharacter SuperCharacterClient y(): void run(): void swim(): void AquaticCharacter SuperCharacter Violates ISP Adheres to ISP interface AerialCharacter interface TerrestrialCharacter interface AquaticCharacter FIGURE 5.5 The.interface.segregation.principle.for.the.enemy.character.design.

--- Chunk 290 ---
Tokens: 398
Type: sentence-based
Text:
y(): void run(): void swin(): void AerialCharacterClient TerrestrialCharacterClient AquaticCharacterClient AerialCharacter TerrestrialCharacter EnemyCharacter y(): void run(): void swim(): void interface SuperCharacter SuperCharacterClient y(): void run(): void swim(): void AquaticCharacter SuperCharacter Violates ISP Adheres to ISP interface AerialCharacter interface TerrestrialCharacter interface AquaticCharacter FIGURE 5.5 The.interface.segregation.principle.for.the.enemy.character.design. Principles of Detailed Design  159 seen.the.bloated.EnemyCharacter.interface.has.been.dissolved.and.many.client-specific. interfaces.have.been.created.These.interfaces.are.easier.to.maintain.and.reuse.and.lead.to. easier.adherence.to.both.OCP.and.LSP. Programming Styles in Detailed Design During.detailed.design.styles.are.used.to.provide.a.consistent.approach.for.structuring.code. by.specifying.a.standard.for.code.elements.such.as.code.formatting.naming.conventions. documentation.and.many.other.programming.language-specific.conventions.The.appli- cation.of.styles.is.typically.an.activity.that.is.emphasized.during.construction.however. due.to.the.capabilities.of.todays.modeling.tools.the.application.of.styles.is.prevalent.during. the.detailed.design.phase.For.example.when.modeling.tools.are.used.in.software.proj- ects.the.detailed.design.activity.is.where.for.example.classes.variables.functions.func- tion.parameters.and.return.types.are.specified.When.modeling.tools.are.used.to.generate. code.other.construction.styles.such.as.formatting.styles.(e.g.spaces.bracket.positioning).

--- Chunk 291 ---
Tokens: 378
Type: sentence-based
Text:
code.other.construction.styles.such.as.formatting.styles.(e.g.spaces.bracket.positioning). can.also.be.specified.In.all.of.these.cases.styles.are.used.to.specify.the.way.these.elements. appear.in.code.in.such.way.that.it.is.consistent.readable.and.therefore.more.maintainable. Programming.styles.provide.the.means.for.ensuring.consistency.in.code.when.designs.are. transformed.to.code.by.different.engineers. Listing 5.9: C Implementation for EntryLevelTerrestrialCharacter class TerrestrialCharacter : public Character   Pre-Condition: Character is drawn on screen. Post-Condition: Character roams around randomly over land, either  walking or running. virtual void move()  code to make the character walk or run. code here to implement all other interfaces. ; class EntryLevelTerrestrialCharacter : public TerrestrialCharacter  public:  Override move to make the character fly! virtual void move()   code to make the character fly. Code here to implement all other interfaces. ; 160  Software Engineering Design Since. programming. styles. are. mostly. programming. language-specific. styles. for. one. particular. programming. language. may. not. apply. to. another. programming. language. However.some.styles.can.be.applied.in.a.general.fashion.to.a.wide.variety.of.modern.pro- gramming.languages.in.particular.those.that.share.similar.language.characteristics.such. as.C.Java.and.C.When.creating.detailed.designs.the.focus.of.programming.styles.can. be.placed.on.the.following: . Type.names . Function.names .

--- Chunk 292 ---
Tokens: 395
Type: sentence-based
Text:
Function.names . Variable.names Type.names.are.names.selected.for.defining.types.in.a.programming.language.Examples. include.classes.interfaces.structs.and.enumeration.Type.names.are.commonly.specified. using.nouns.and.the.PascalCase.style.Type.names.that.refer.to.collections.can.be.pluralized. to.explicitly.convey.this.information.Styles.for.interface.names.vary.from.most.other.type. names.Popular.styles.for.interface.names.include.the.use.of.nouns.adjectives.the.letter.I. before.the.interface.name.and.a.combination.of.all.of.these.Both.the.Java.language.and.C. use.nouns.and.adjectives.when.specifying.interface.names.In.addition.the.C.language. employs.the.style.of.applying.I.before.interface.names.For.custom-defined.interfaces. Vermeulen.Ambler. Bumgardner. Metz.Misfeldt. Shur.et.al.(2000). recommend.using. nouns.for.interfaces.that.act.as.service.declarations. (e.g.Javas.ActionListener).and.adjec- tives.for.interfaces.that.act.as.description.of.capabilities.(e.g.Javas.Runnable).Examples.of. type.name.conventions.are.presented.in Listing.5.10. Function Names Whereas.type.names.typically.use.the.PascalCase.style.in.the.naming.convention.func- tion.names.vary.significantly.between.PascalCase.and.lowerCamelCase.styles.Naming. conventions.for.function.names.also.vary.among.the.software.engineering.community. with.camps.strongly.supporting.each.side.This.is.largely.due.to.the.way.in.which.differ- ent.programming.languages.use.styles.for.function.names.For.example.it.is.not.uncom- mon.for.C.programmers.to.support.lowerCamelCase.style.since.every.function.name.

--- Chunk 293 ---
Tokens: 389
Type: sentence-based
Text:
with.camps.strongly.supporting.each.side.This.is.largely.due.to.the.way.in.which.differ- ent.programming.languages.use.styles.for.function.names.For.example.it.is.not.uncom- mon.for.C.programmers.to.support.lowerCamelCase.style.since.every.function.name. in.the.standard.template.library.uses.this.style.The.same.is.true.about.Java.programmers. However.the.C.programming.language.employs.the.PascalCase.style.for.function.names. therefore.programmers.coming.from.Java.or.C.background.may.tend.to.disagree.with. the.C.convention.Consider.for.example.the.function.calls.for.displaying.text.to.the.con- sole.in.both.Java.and.C.as.seen.in.Listing.5.11. Notice.how.pintnln.and.WriteLine.use.different.styles.built.into.the.Java.and.NET. frameworks.respectively.Ultimately.projects.should.adopt.a.style.for.the.function.naming. convention.that.fits.the.project.team.and.target.programming.language.to.maintain.con- sistency.If.in.doubt.follow.the.convention.provided.by.the.target.programming.language. Another.characteristic.of.quality.function.names.is.how.well.they.conform.to.all.other. parts.of.a.functions.signature.Function.names.should.be.chosen.so.that.they.relate. Principles of Detailed Design  161 accurately.to.the.main.intention.of.the.function.and.its.return.type.Function.names. that.accurately.describe.the.functions.intent.can.be.referred.as.action-conforming.func- tions. Alternatively. function. names. that. do. not. are. referred. as. action-contradictive. these.are.function.names.that.do.not.accurately.relate.to.the.functions.main.intent.

--- Chunk 294 ---
Tokens: 397
Type: sentence-based
Text:
these.are.function.names.that.do.not.accurately.relate.to.the.functions.main.intent. Examples.of.action-contradictive.and.action-conforming.function.names.are.presented. in.Listing 5.12. Listing 5.10: Example of Type Name Conventions  Class name for a single node. class MobileNode  ;  Class name for a collection of nodes, therefore name is pluralized. class MobileNodes  public: void addNode( int nodeId ); void removeNode( int nodeId ); MobileNode getNode( int nodeId ); ;  Another example of a collection name in C. listMobileNode mobileNodes;  Custom-defined interface name in Java. interface SampleInterface    Custom-defined interface name in C. interface ISampleInterface    Built-in interface name in Java java.util.Observable  Built-in interface name in C System.ICloneable; Listing 5.11: Example of Both PascalCase and lowerCamelCase for Function Names  Displaying text to the console in Java. System.out.println(console message. );  Displaying text to the console in C. System.Console.WriteLine(console message. ); 162  Software Engineering Design As.seen.in.Listing.5.13.the.identified.purpose.for.Function.1.is.to.display.validity.status. to.the.console.however.this.is.not.evident.by.the.choice.of.function.name.isValid. Furthermore.the.use.of.is.in.front.of.function.names.typically.implies.the.return.of.a. Boolean.value.therefore.clients.may.be.more.inclined.to.expect.the.function.isValid(). to. provide. information. regarding. the. validity. of. an. object. by. returning. a. Boolean. value.instead.of.displaying.a.message.to.the.console.The.function.name.of.isValid.is.

--- Chunk 295 ---
Tokens: 392
Type: sentence-based
Text:
value.instead.of.displaying.a.message.to.the.console.The.function.name.of.isValid.is. action-contradictive.since.it.does.not.accurately.reflect.the.functions.main.intent.which. is.to.display.validity.to.the.console.The.function.name.is.made.action-conforming.in. Listing 5.12: Action-Conforming and Action-Contradictive Function Names  Function 1 Purpose: Display validity to the console. void isValid()  if( some condition )  coutX is valid;  else  coutX is invalid;    Function 2 Purpose: Display validity to the console. void displayValidity()  if( some condition )  coutX is valid;  else  coutX is invalid;    Function 3 Purpose: Display element count number to the console. void hasElements()  coutElement count: 0;   Function 4 Purpose: Display element count number to the console. void displayElementCount()  coutElement count: 0;   Function 5 Purpose: Determine if a function has elements. bool hasElements()  return true;  Principles of Detailed Design  163 Function 2.by.changing.the.name.to.more.accurately.reflect.its.purpose.Similarly.the. action-contradictive.name.of.Function.3.can.be.changed.to.action-conforming.by.chang- ing.it.as.presented.in.Function.4.In.Function.5.the.same.name.as.in.Function.3.is.used. with.a.different.purpose.In.this.case.the.name.results.in.an.action-conforming.type.since. the.name.accurately.relates.to.the.main.intent.of.the.function. Type-conforming. function. names. are. those. in. which. the. function. name. relates. and. conform. to. the. function. return. type. Function. names. that. are. inconsistent. with. the.

--- Chunk 296 ---
Tokens: 381
Type: sentence-based
Text:
the. return.type.used.are.referred.as.type-contradictive.Examples.of.type-contradictive.and. type-conforming.function.names.are.presented.in.Listing.5.13. In.the.case.of.Function.5.the.name.toString.implies.the.return.of.a.string.value. however.the.return.type.of.the.function.is.set.to.bool.to.determine.if.the.conversion.was. successful.Users.of.this.function.may.come.to.expect.the.function.to.return.a.string.value. therefore.this.function.is.type-contradictive.The.type-conforming.version.of.the.function. is.presented.in.Function.6. The.last.commonly.accepted.style.for.function.names.includes.the.use.of.verbs.to.prop- erly.describe.actions.in.the.code.In.code.function.names.are.abstractions.of.some.action. therefore.the.use.of.verbs.as.function.names.can.result.in.code.that.maps.accurately.to. mental.models.used.to.reason.about.the.code.as.seen.in.Listing.5.14. Variable Names The.styles.for.variable.names.also.include.the.use.of.CamelCase.however.unlike.styles.for. type.names.which.are.typically.PascalCase.and.unlike.styles.for.function.names.which. Listing 5.13: Type-Contradictive and Type-Conforming Function Names class Message  public:  Function 5: Type-contradictive function! bool toString()   Convert this object to a string. return true if success, false otherwise. Function 6: Type-conforming function. string toString()   Convert this object to a string. return the string to the calling function. ; 164  Software Engineering Design typically.vary.according.to.programming.language.variable.names.

--- Chunk 297 ---
Tokens: 393
Type: sentence-based
Text:
; 164  Software Engineering Design typically.vary.according.to.programming.language.variable.names. (including.parame- ter.names).typically.use.the.lowerCamelCase.style.Two.main.reasons.exist.for.preferring. .lowerCamelCase.for.variable.names.First.the.difference.in.styles.can.be.used.to.differen- tiate.between.variables.and.types.Second.the.lowerCamelCase.style.in.variables.can.be. used.to.differentiate.between.variables.and.constants.which.typically.use.PascalCase.or.all. uppercase.as.seen.in.Listing.5.15. As.seen.two.different.styles.are.used.for.the.constant.max.value.When.the.uppercase. style. is. selected. compound. words. are. separated. using. the. underscore. _. character. Listing 5.15: Example of Styles for Variable Names class Receiver  public:  The style use for case differentiates types from variables. void receive(Message message)   Prefix used to identify member variables. _message  message;  private: Message _message; ;  Style 1 for a constant. const int MaxValue  10;  Style 2 for a constant. const int MAX_VALUE  10; Listing 5.14: Example of Function Names Using Verbs class Door  public: void open(.) Open door. void close(.) Close door. ; Principles of Detailed Design  165 In addition.Listing.5.15.presents.a.common.style.for.identifying.member.variables.such. as.the _message.variable.Identifying.member.variables.can.improve.readability.of.code. where.function.parameters.use.the.same.name.as.member.variables.In.such.cases.a.pre- fix.or.suffix.can.be.used.to.clearly.identify.the.member.variable.especially.in.large.mem- ber.functions.

--- Chunk 298 ---
Tokens: 393
Type: sentence-based
Text:
where.function.parameters.use.the.same.name.as.member.variables.In.such.cases.a.pre- fix.or.suffix.can.be.used.to.clearly.identify.the.member.variable.especially.in.large.mem- ber.functions. Modeling Internal Behavior of Components Modeling. interactions. among. entities. designed. during. component. design. provides. an. efficient.approach.for.visualizing.complex.interactions.required.for.achieving.a.particu- lar.system.function.This.helps.verify.the.component.designs.before.construction.begins. Sequence. or. communication. diagrams. can. be. employed. to. model. objects. representing. instances.of.classes.or.roles.representing.prototypical.instances.of.other.entities.such.as. classes.(Booch.Rumbaugh.and.Jacobson.2005).Both.objects.and.roles.can.be.connected. to.model.the.exchange.of.messages.using.links.or.connectors.respectively.to.carry.out.a. particular.function.of.the.design.typically.as.part.of.the.systems.functional.requirements. During.detailed.designs.the.majority.of.behavioral.models.include.objects.since.analyses. are.made.with.detailed.information.that.is.already.been.designed.In.many.cases.class.dia- grams.are.accompanied.by.one.or.more.behavioral.diagrams.to.provide.a.complete.picture. of.the.detailed.design.both.of.these.are.reviewed.and.documented.as.part.of.the.software. design.document.An.example.of.a.detailed.sequence.diagram.is.presented.in.Figure 5.5. The. sequence. diagram. from. Figure 5.5. presents. the. behavioral. modeling. of. objects. belonging.to.three.classes.namely.the.ScheduleManager.Schedule.and.Sensor.classes.The.

--- Chunk 299 ---
Tokens: 381
Type: sentence-based
Text:
belonging.to.three.classes.namely.the.ScheduleManager.Schedule.and.Sensor.classes.The. sequence.diagramidentified.by.the.sd.keyword.and.name.Activate.Sensorsuses.the. Frame.notation.which.provides.the.means.to.model.combined.fragments.of.interactions. throughout.sequence.diagrams.Each.interaction.frame.inside.the.sequence.diagram.can. be.classified.using.the.operators.presented.in.Table 5.3.(UML.2.3.Superstructure.2010). The.alt.operator.is.used.to.denote.a.conditional.statement.where.more.than.one.case. is.examined.The.opt.operator.is.employed.when.a.single.optional.fragment.exists.in.a. sequence.When.this.occurs.the.operations.inside.the.fragment.are.either.executed.or. not.This.differs.from.the.alt.operator.which.includes.additional.conditional.statements. The.loop.operator.specifies.a.repetition.structure.The.format.of.the.loop.operator.is.as. TABLE 5.3 Common.Interaction.Operators.Used.in.Sequence.Diagrams Operator Description seq Default.operator.that.specifies.a.weak.sequencing.between.the.behaviors.of.the.operands alt Specifies.a.choice.of.behavior.where.at.most.one.of.the.operands.will.be.chosen opt Specifies.a.choice.of.behavior.where.either.the. (sole).operand.happens.or.nothing.happens loop Specifies.a.repetition.structure.within.the.combined.fragment par Specifies.parallel.operations.inside.the.combined.fragment critical Specifies.a.critical.section.within.the.combined.fragment 166  Software Engineering Design .follows.loop (min, max).where.min.specifies.the.minimum.bound.of.the.loop.and.

--- Chunk 300 ---
Tokens: 356
Type: sentence-based
Text:
(sole).operand.happens.or.nothing.happens loop Specifies.a.repetition.structure.within.the.combined.fragment par Specifies.parallel.operations.inside.the.combined.fragment critical Specifies.a.critical.section.within.the.combined.fragment 166  Software Engineering Design .follows.loop (min, max).where.min.specifies.the.minimum.bound.of.the.loop.and. max.represents.the.maximum.bound.of.the.loop.When.these.are.omitted.then.it.implies. that.min.0.and.max.infinity.In.these.cases.the.loop.typically.includes.a.separate.inter- action.constraint.called.a.Guard.which.evaluates.to.true.or.false.The.loop.will.continue. only.if.the.guard.evaluates.to.true.during.execution.regardless.of.the.minimum.number. of.iterations.specified.in.the.loop.The.Guard.interaction.constraint.is.in.the.format.of. constraint.Guards.can.also.be.used.in.other.interactions.throughout.sequence.dia- grams.For.example.in.Figure 5.5.a.Guard.is.used.to.explicitly.specify.the.condition.used. to.determine.alternate.paths.in.the.alt.combined.fragment. Design Components Using Design Patterns In.Chapters.3.and.4.the.concept.of.patterns.was.introduced.with.an.emphasis.on.software. architecture.During.detailed.design.a.wide.variety.of.design.patterns.exists.for.providing. solutions.to.recurring.problems.in.the.form.of.structural.designs.for.components.Design. patterns.are.recurring.solutions.to.object-oriented.design.problems.in.a.particular.context.

--- Chunk 301 ---
Tokens: 379
Type: sentence-based
Text:
patterns.are.recurring.solutions.to.object-oriented.design.problems.in.a.particular.context. When.used.effectively.they.can.help.improve.efficiency.in.the.detailed.design.effort.by.pro- viding.high-quality.reusable.solutions.that.can.be.applied.in.many.practical.applications. To.properly.and.consistently.capture.design.patterns.detailed.descriptions.are.required.to. identify.the.patterns.the.problem.that.they.solve.and.their.solution.approach. Designing.high-quality.object-oriented.software.is.hard.Typically.designers.of.systems. that.evolve.gracefully.have.time.to.develop.their.skills.through.years.of.experience.This. experience.gives.designers.the.ability.to.identify.classes.with.the.right.granularity.appro- priate.relationships.among.the.classes.and.inheritance.hierarchies.that.are.reusable.and. maintainable.Experience.also.allows.designers.to.evaluate.the.effects.of.their.design.deci- sion.in.the.overall.development.of.a.working.software.system.The.more.we.experience. the.design.of.systems.the.more.knowledge.and.skill.we.acquire.to.design.better.systems. Unfortunately.for.novice.designers.this.experience.can.take.years.to.acquire.Because. detailed.design.entails.a.great.deal.of.problem-solving.skills.novice.designers.can.spend. much.time.trying.to.determine.how.to.efficiently.structure.their.designs.in.a.way.that.the. system.can.exhibit.a.certain.level.of.quality.Fortunately.many.of.the.common.design.prob- lemsthose.recurring.over.and.over.in.different.systemshave.been.solved.already.and.

--- Chunk 302 ---
Tokens: 398
Type: sentence-based
Text:
system.can.exhibit.a.certain.level.of.quality.Fortunately.many.of.the.common.design.prob- lemsthose.recurring.over.and.over.in.different.systemshave.been.solved.already.and. captured.as.design.patterns.Design.patterns.are.experience.captured.in.a.well-structured. and.consistent.format.they.provide.blueprints.that.guide.designers.to.solve.specific.prob- lems.by.specifying.important.design.characteristics.such.as.the.classes.that.need.to.be. created.their.level.of.granularity.their.relationships.and.how.all.these.classes.and.rela- tionships.work.together.to.solve.a.problem.They.provide.this.information.in.a.generic. sense.so.that.they.can.be.reused.many.times.over.in.different.software.systems.without. ever.doing.it.the.same.way.twice. There. are. many. benefits. from. studying. and. applying. design. patterns. First. they. can. help.designers.and.programmers.become.more.efficient.It.is.now.common.to.find.built-in. support.for.design.patterns.in.todays.popular.language.frameworks.such.as.Java.and.the. .NET.framework.Therefore.knowing.about.design.patterns.can.help.programmers.come. Principles of Detailed Design  167 up.to.speed.quicker.in.these.environments.and.enable.them.to.quickly.apply.them.to.par- ticular.problems.In.the.work.reported.by.Walter.Tichy.(2010).strong.empirical.evidence. suggested.that.merely.documenting.design.patterns.can.already.lead.to.an.increase.in.pro- grammer.productivity.and.reduce.errors.during.maintenance.tasks.Design.patterns.also. help.enhance.communication.during.the.problem-solving.process.by.providing.abstractions. of. problem-solving.

--- Chunk 303 ---
Tokens: 393
Type: sentence-based
Text:
problem-solving. techniques. Tichys. work. also. shows. evidence. of. improvements in communication when team members shared design patterns knowledge. In.his.work.it.was. noticed.that.weaker designers catch up with more experienced ones when using patterns. Design.patterns.also.serve.as.starting.point.for.the.design.(or.redesign).effort.of.software. components.therefore.they.help.reduce.the.time.to.design.new.systems.Finally.design. .patterns. provide. examples. of. the. application. of. many. object-oriented. design. principles. therefore.they.can.serve.as.practical.methods.for.learning.object-oriented.design.techniques. Architectural versus Design Pattern Before.diving.deeply.into.the.topic.of.design.patterns.in.the.next.chapters.it.is.impor- tant.to.make.a.clear.distinction.between.(detailed).design.patternsthe.topic.of.the.next. two. chaptersand. architectural. (design). patterns. which. were. covered. in. Chapter 4. As mentioned.in.Chapters.3.and.4.architectural.patterns.serve.mostly.at.higher.levels. of.abstraction.to.identify.the.major.components.and.interfaces.of.the.software.system. Therefore.their.application.is.too.abstract.to.be.translated.directly.to.code.In.contrast. design.patterns.are.detailed.solutions.to.particular.problems.that.can.be.directly.trans- lated.to.code.Architectural.patterns.have.a.direct.effect.on.the.architecture.of.a.software. system. and. are. associated. to. particular. application. domains. (e.g. interactive. systems). whereas.design.patterns.are.independent.of.a.particular.application.domain.(Buschmann. et.al.

--- Chunk 304 ---
Tokens: 392
Type: sentence-based
Text:
et.al. 1996).These.differences.should.become.evident.in.Chapters.6.and.7. Classification of Design Patterns When. first. studying. design. patterns. it. is. important. to. understand. what. each. pattern. does.and.how.it.does.it.In.the.influential.work.presented.by.Gamma.Helm.Johnson. and.Vlissides. (1995).design.patterns.are.classified.based.on.purpose.and.scope.The.pur- pose.of.a.design.pattern.identifies.the.functional.essence.of.the.pattern.therefore.it.serves. as.fundamental.differentiation.criteria.between.design.patterns.Three.different.purposes. are.identified.by.the.Gang.of.Four.(GoF).including.creational.structural.and.behavioral. Creational.design.patterns.are.the.ones.that.attempt.to.efficiently.manage.the.creation. or.creational.process.of.objects.in.a.software.system.A.common.characteristic.of.cre- ational.pattern.is.the.presence.of.creational.classes.and.product.classes.In.some.cases. the.creational.and.product.classes.are.combined.into.one.class.Creational.patterns.are. overall.known.for.abstracting.the.instantiation.process.of.one.or.more.objects.Structural. design.patterns.are.the.ones.that.attempt.to.create.larger.structures.from.the.composition. of.existing.classes.objects.or.other.structures.Finally.behavioral.design.patterns.are.con- cerned.with.how.classes.and.object.interact.the.variation.of.behavior.and.the.assignment. 168  Software Engineering Design of.responsibility.between.objects.The.purpose.criteria.apply.to.a.large.number.of.patterns. therefore.it.serves.well.for.classifying.a.large.variety.of.design.solutions.

--- Chunk 305 ---
Tokens: 392
Type: sentence-based
Text:
therefore.it.serves.well.for.classifying.a.large.variety.of.design.solutions. While.the.purpose.criteria.of.design.patterns.captures.the.overview.of.what.the.pattern. does.the.scope.of.a.design.pattern.captures.whether.the.design.pattern.primarily.applies. to.classes.or.objects.Class.patterns.apply.primarily.to.classes.by.defining.the.relationship. between.classes.and.subclasses.at.compile.time.via.inheritance.Object.patterns.apply. primarily.to.objects.by.defining.the.patterns.relationship.between.objects.at.run.time. via.object.composition.Since.the.relationships.in.object.patterns.are.defined.via.object. composition.they.result.in.more.dynamic.designs.and.flexible.designs.Since.the.large. majority.of.design.patterns.rely.on.inheritance.it.can.be.difficult.to.draw.the.line.to.dif- ferentiate.between.class.patterns.and.object.patterns.Furthermore.some.design.patterns. can.be.applied.in.different.ways.so.that.the.same.pattern.can.be.classified.as.class.pattern. or. object. pattern. depending. on. the. design. implementation. Typically. the. distinction. between.class.patterns.and.object.patterns.becomes.clearer.after.having.experience.with. patterns.for.some.time.When.it.comes.to.scope.classification.the.most.efficient.differen- tiation.criteria.lies.in.the.focus.that.the.design.pattern.puts.on.inheritance.versus.object. composition.Design.patterns.that.place.focus.on.inheritance.as.key.relationship.for.the. pattern.are.classified.as.class.patterns.whereas.design.patterns.that.place.focus.on.object. composition.are.classified.as.object.patterns.

--- Chunk 306 ---
Tokens: 390
Type: sentence-based
Text:
composition.are.classified.as.object.patterns. Purpose.and.scope.can.be.used.in.combination.to.fully.classify.design.patterns.For. example.design.patterns.can.be.classified.as.class.creational.or.object.creational.class. structural.or.object.structural.or.class.behavioral.or.object.behavioral.In.addition.to. purpose.scope.and.their.combination.many.other.types.of.classification.and.domains. have.been.identified.throughout.the.years.Example.of.these.include.design.patterns. in.real-time.programming.(Douglass.2002).patterns.in.web.applications.(Vora.2009). and.patterns.for.parallel.software.(Ortega-Arjona.2010). Documenting Design Patterns Documenting.design.patterns.in.a.consistent.format.is.important.to.the.dissemination.of. pattern.knowledge.Although.design.patterns.can.be.documented.in.many.ways.the.GoF. identified.13.categories.that.can.be.used.as.standard.for.fully.documenting.design.pat- terns.Together.these.categories.provide.detailed.information.of.existing.design.patterns. and.provide.direction.for.documenting.future.patterns.In.practical.applications.well- documented.patterns.are.important.because.they.allow.designers.to.quickly.study.a.design. pattern.to.determine.its.applicability.in.a.particular.scenario.Well-documented.patterns. also.provide.the.means.to.compare.patterns.and.evaluate.important.characteristics.such. as.consequences.that.can.help.designers.in.selecting.the.best.pattern.for.the.problem.at. hand.The.13.categories.for.documenting.patterns.proposed.by.the.GoF.and.their.descrip- tions.are.presented.in.Table 5.4.

--- Chunk 307 ---
Tokens: 387
Type: sentence-based
Text:
hand.The.13.categories.for.documenting.patterns.proposed.by.the.GoF.and.their.descrip- tions.are.presented.in.Table 5.4. Chapters.6.and.7.provide.throughout.coverage.of.common.design.patterns.used.during. the.detailed.design.activity.For.extensive.coverage.of.design.patterns.readers.are.encour- aged.to.study.the.original.design.patterns.book.by.the.GoF.(Gamma.et.al.1995). Principles of Detailed Design  169 DOCUMENT THE SOFTWARE DESIGN Documentation.of.a.projects.software.design.is.captured.in.the.software.design.docu- ment. (SDD).a.document.that.contains.the.designs.or.plans.of.the.software.to.be.imple- mented.From.the.time.the.SDD.is.written.in.the.design.phase.it.may.be.used.by.various. stakeholders.and.until.the.end.of.the.software.life.cycle.During.the.code.and.unit.test. phase.it.may.be.referred.to.in.order.to.construct.the.software.to.develop.unit.test.plans. or.to.write.script.files.and.driver.code.to.automate.the.running.of.tests.System.integrators. may.use.the.SDD.in.the.system.integration.test.phase.to.better.plan.integration.activities. and.maintainers.will.use.and.possibly.have.to.update.the.SDD.in.the.maintenance.phase. To.provide.relevant.information.to.the.stakeholders.the.SDD.must.contain.certain.items. that.document.everything.that.goes.into.the.design.of.the.software.The.proposed.con- tents.of.an.SDD.are.as.shown.in.Table 5.5.(IEEE.2009). Providing.this.SDD.information.is.important.not.only.to.communicate.the.design.to. stakeholders.but.also.to.properly.maintain.the.SDD.to.ensure.the.version.stakeholders.

--- Chunk 308 ---
Tokens: 391
Type: sentence-based
Text:
stakeholders.but.also.to.properly.maintain.the.SDD.to.ensure.the.version.stakeholders. receive.is.current.and.consistent.The.body.section.of.the.SDD.contains.architectural.and. detailed.design.elements.presented.in.a.format.specified.by.design.viewpoints.Design. viewpoints.dictate.the.way.design.views.are.presented.within.an.SDD.and.each.design. view.has.exactly.one.design.viewpoint.to.go.along.with.it.The.IEEE.(2009).recommends. each.design.viewpoint.specification.to.contain. (among.others).the.following.information: TABLE 5.4 Categories.and.Descriptions.for.Documenting.Design.Patterns Category Description Name.and.classification The.unique.pattern.name.that.reflects.the.essence.of.the.patterns.and.its.classification Intent Describes.the.purpose.of.the.pattern.in.such.way.that.it.is.clear.what.types.of.design. problems.the.pattern.solves.what.the.pattern.does.its.rationale.and.intent Also.Known.As A.list.of.alternate.well-known.names.for.the.pattern Motivation An.example.scenario.that.serves.as.motivation.for.the.application.of.the.pattern Applicability Describes.the.situations.or.design.problems.that.lend.themselves.for.the. application.of.the.design.pattern.provides.examples.of.poor.designs.that.can. benefit.from.the.pattern.and.ways.for.identifying.these.situations Structure Provides.a.structural. (e.g.UML.class.diagram).view.of.the.design.pattern Participants List.the.classes.and.objects.required.in.the.design.pattern.and.their.responsibilities Collaborations Provides.information.about.how.the.participants.work.together.to.carry.out.

--- Chunk 309 ---
Tokens: 387
Type: sentence-based
Text:
(e.g.UML.class.diagram).view.of.the.design.pattern Participants List.the.classes.and.objects.required.in.the.design.pattern.and.their.responsibilities Collaborations Provides.information.about.how.the.participants.work.together.to.carry.out. their responsibilities Consequences Describes.the.effects.of.the.design.pattern.good.or.bad.on.the.software.solution Implementation Provides.information.and.techniques.for.successfully.implementing.the.design.pattern Sample.Code Provides.sample.code.that.demonstrates.how.to.implement.the.design.pattern.in. different.programming.languages Known.Uses Provides.examples.of.real.systems.that.employ.the.design.pattern Related.Patterns Provides.information.about.other.design.patterns.that.are.related.or.that.can.be. used.in.combination.with.the.design.pattern 170  Software Engineering Design . Viewpoint.name . Relevant.design.concerns . Design.elements. (e.g.elements.of.design.language) . Analytical.methods.or.other.operations.for.supporting.the.view . Viewpoint.authorship.or.citation . Patterns.heuristics.or.other.guidelines.used.in.the.creation.of.the.viewpoint The.specification.of.design.viewpoints.can.be.done.fully.in.the.SDD.or.incorporated. by.reference.(IEEE.2009).Once.specified.viewpoints.can.be.used.throughout.the.SDD. to.document.software.designs.The.SDD.should.also.present.the.rationale.for.selecting. the.specific.design.viewpoint.Long.after.the.design.phase.is.complete.the.SDD.will.be. referred.to.several.times.during.the.software.life.cycle.Therefore.it.is.useful.if.the.rationale.

--- Chunk 310 ---
Tokens: 388
Type: sentence-based
Text:
referred.to.several.times.during.the.software.life.cycle.Therefore.it.is.useful.if.the.rationale. for.making.certain.design.decisions.is.included.in.the.SDD.so.developers.can.gain.addi- tional.insight.into.why.decisions.were.made.for.certain.parts.of.the.software.design.Design. rationale.includes.justification.for.choosing.a.particular.design.approach.and.can.be.found. in.commentary.throughout.the.SDD.Examples.of.design.rationale.include.design.issues. raised.in.response.to.design.concerns.of.stakeholders.trade-offs.evaluated.criteria.used. to.make.decisions.and.design.options.considered.(IEEE.2009).With.this.information. a sample.table.of.contents.for.the.SDD.is.provided.in.Table 5.6. TABLE 5.5 Sections.of.the.Software.Design.Document Section Description Date.of.issue.and.status Date.of.issue.is.the.day.on.which.the.SDD.has.been.formally.released.Every.time. the.SDD.is.updated.and.formally.released.there.should.be.a.new.date.of.issue. Scope Scope.provides.a.high-level.overview.of.the.intended.purpose.of.the.software. It sets.a.limit.as.to.what.the.SDD.will.describe.and.defines.the.objectives.of. the software. Issuing.organization Issuing.organization.is.the.company.that.produced.the.SDD. Authorship Authorship.pertains.to.who.wrote.the.SDD.and.certain.copyright.information. References References.provide.a.list.of.all.applicable.documents.that.are.referred.to.within.the. SDD.If.there.is.a.certain.technology.that.is.used.within.the.design.it.is.important. to.refer.to.the.corresponding.documentation.on.that.technology.so.it.may.be.

--- Chunk 311 ---
Tokens: 392
Type: sentence-based
Text:
to.refer.to.the.corresponding.documentation.on.that.technology.so.it.may.be. referenced.When.reading.the.referenced.documents.stakeholders.may.uncover. inconsistencies.in.how.the.technology.should.be.used.and.how.it.is.used.in.the. software.design. Context Description.of.the.context.of.the.SDD. Body Body.is.the.main.section.of.the.SDD.where.the.design.is.documented. This is where.stakeholders.look.to.understand.the.software.and.how.it.is.to. be constructed. Summary Glossary A.glossary.provides.definitions.for.all.software-related.terms.and.acronyms.used.in. the SDD. Change.history Change.history.is.a.brief.description.of.the.items.added.to.deleted.from.or. changed.within.the.SDD. Principles of Detailed Design  171 Interface Control Document The.interface.control.document.(ICD).is.an.important.piece.of.documentation.that.serves.as. a.written.contract.between.components.of.the.system.software.as.to.how.they.communicate. This.document.is.usually.intended.to.cover.only.the.software.components.that.are.internal. to.the.software.development.effort.Many.times.in.software.engineering.there.exists.a.sys- tem.in.which.two.pieces.of.software.need.to.communicate.to.share.information.or.possibly. to.invoke.function.calls.For.developers.to.write.software.they.need.to.know.what.to.expect. when.asking.for.certain.data.or.how.to.perform.a.particular.action.on.another.piece.of.soft- ware.A.classic.example.of.this.is.a.clientserver.based.system.The server.may.contain.and. manage.certain.data.or.it.may.provide.a.set.of.actions.that.a.client.may.invoke.An.ICD.is.

--- Chunk 312 ---
Tokens: 400
Type: sentence-based
Text:
manage.certain.data.or.it.may.provide.a.set.of.actions.that.a.client.may.invoke.An.ICD.is. much.like.documentation.on.how.to.speak.a.particular.language.If two.pieces.of.software. cannot.speak.the.same.language.they.will.not.be.able.to.communicate.and.a.software.sys- tem.will.not.be.able.to.work.ICDs.can.also.be.an.important.part.of.communication.within. a.single.component.of.a.software.system.For.instance.the.example.in.Figure 5.6.has.two. TABLE 5.6 Sample.Table.of.Contents.for.the.Software.Design.Document 1. Introduction . 1.1. Date.of.Issue . 1.2. Context . 1.3. Scope . 1.4. Authorship . 1.5. Change.history . 1.6. Summary 2. Software.Architecture . 2.1. Overview . 2.2. Stakeholders . 2.3. System.Design.Concerns . 2.4. Architectural.Viewpoint.1 . . 2.4.1. Design.View.1 . 2.5. Architectural.Viewpoint.2 . . 2.5.1. Design.View.2 . 2.6. Architectural.Viewpoint.n . . 2.6.1. Design.View.n 3. Detailed.Design . 3.1. Overview . 3.2. Component.Design.Viewpoint.1 . . 3.2.1. Design.View.1 . 3.3. Component.Design.Viewpoint.2 . . 3.3.1. Design.View.2 . 3.4. Component.Design.Viewpoint.n . . 3.4.1. Design.View.n 4. Glossary 5. References 172  Software Engineering Design different.kinds.of.interfaces.There.is.one.interface.between.the.client.and.server.and.then. there.are.several.interfaces.that.are.just.internal.to.the.server. The.server.may.be.running.three.different.processes.but.it.could.be.thought.of.as.one. cohesive.component.in.the.entire.software.system.These.two.different.kinds.of.interfaces. do.not.have.to.use.the.same.kind.of.technology.either.The.interfaces.described.in.an.ICD.

--- Chunk 313 ---
Tokens: 391
Type: sentence-based
Text:
do.not.have.to.use.the.same.kind.of.technology.either.The.interfaces.described.in.an.ICD. can.be.either.proprietary.such.as.a.company-developed.protocol.using.Extensible.Markup. Language.(XML).or.something.standard.such.as.Simple.Network.Management.Protocol. (SNMP).or.Common.Object.Request.Broker.Architecture. (CORBA).However.the.descrip- tions.of.the.data.contents.or.what.actions.to.take.will.surely.be.proprietary.To.make.an. ICD.effective.it.must.describe.all.the.interfaces.in.as.much.detail.as.possible.ICDs.can. detail.for.example.which.data.item.on.a.server.corresponds.with.what.screen.element.on.a. GUI.Messages.can.also.be.formed.in.an.ICD.to.detail.all.items.coming.back.from.a.server. to.a.client.It.is.much.of.this.content.that.makes.the.bulk.of.an.ICD.However.other.docu- ments.may.be.referenced.so.that.developers.can.get.a.better.understanding.of.the.commu- nication.process.For.example.if.a.system.uses.SNMP.the.ICD.may.reference.the Request. for.Comments.(RFCs).related.to.SNMP.This.could.further.help.a.reader.to.understand. certain.parts.of.the.software.as.related.to.communications. Software Version Document The.software.version.description.(SVD).is.a.document.containing.information.about. what.is.included.in.a.software.release.including.different.files.scripts.and.executables. It.also.contains.information.about.how.to.build.the.code.how.to.set.up.a.computer.that. will.host.the.software.and.the.software.requirements.for.the.host.computer.The.SVD.is. also.an.important.document.that.tracks.what.changes.have.been.made.between.different.

--- Chunk 314 ---
Tokens: 395
Type: sentence-based
Text:
also.an.important.document.that.tracks.what.changes.have.been.made.between.different. releases.of.software.It.also.details.what.problems.might.be.encountered.with.a.specific. release.of.software.and.what.problems.have.been.fixed.Not.every.release.of.software.is. going.to.be.perfect.Software.can.sometimes.contain.unfixed.problems.that.go.unidenti- fied.even.after.testing.These.problems.are.then.often.noticed.by.the.end.users.who.report. them.to.the.software.developers.To.keep.the.customers.satisfied.the.software.developers. must.fix.the.problems.noted.in.the.most.recent.release.and.issue.a.new.release.with.the. fixes.In.other.cases.changes.are.made.to.the.design.and.code.to.create.different.versions. of.the.software.for.different.customers.When.these.modifications.result.in.changes.to. FIGURE 5.6 Conceptual.model.for.system.interfaces. Principles of Detailed Design  173 the.design.the.SVD.must.document.the.appropriate.steps.to.build.software.versions. which.requires.inclusion.of.the.appropriate.software.design. The.SVD.will.often.contain.a.section.called.the.version.description.It.is.in.this.section.that. the.bulk.of.the.material.concerning.the.new.release.of.software.is.documented.Even.though. this.document.may.not.be.released.to.a.customer.it.could.still.prove.to.be.very.useful.for. internal.tracking.of.different.releases.of.software.The.first.section.of.the.version.description. is.the.inventory.of.software.contents.This.part.lists.all.the.files.scripts.and.executables.that. have.gone.into.making.the.software.build.or.are.an.output.of.the.build.process.

--- Chunk 315 ---
Tokens: 384
Type: sentence-based
Text:
have.gone.into.making.the.software.build.or.are.an.output.of.the.build.process. The.section.after.the.inventories.of.the.materials.released.and.software.contents.is.the.list. of.changes.installed.As.previously.stated.these.could.either.be.fixes.to.problems.identi- fied.in.previous.releases.or.entirely.new.capabilities.Installation.instructions.detail.any. necessary.steps.it.takes.to.install.the.software.to.properly.run.on.the.host.computers.The. SVD.also.lists.any.potential.problems.that.may.be.encountered.when.using.the.software.or. known.and.verified.errors.for.which.developers.have.yet.to.find.a.solution. MONITOR AND CONTROL IMPLEMENTATION Detailed.design.synchronicity.is.concerned.with.the.degree.of.how.well.detailed.designs. adhere.to.the.software.architecture.and.how.well.software.code.adheres.to.the.detailed. design.Detailed.designs.provide.a.design.structure.carefully.crafted.to.ensure.desired. characteristics. of. the. software. such. as. reusability. or. maintainability. Typically. soft- ware.engineers.are.good.at.respecting.detailed.design.decisions.early.on.in.a.project.life. cycle.however.as.the.development.process.continues.detailed.designs.are.more.prompt. to. deviations. during. construction. For. any. software. architecture. and. detailed. design. to.result.in.a.successful.system.implementation.the.construction.phase.must.be.syn- chronized.with.the.software.products.resulting.from.both.efforts.Therefore.the.engi- neering.team.must.ensure.that.detailed.design.decisions.are.enforced.throughout.the.

--- Chunk 316 ---
Tokens: 384
Type: sentence-based
Text:
to.result.in.a.successful.system.implementation.the.construction.phase.must.be.syn- chronized.with.the.software.products.resulting.from.both.efforts.Therefore.the.engi- neering.team.must.ensure.that.detailed.design.decisions.are.enforced.throughout.the. construction.phase.Particular.attention.needs.to.be.paid.to.design.synchronicity.when. projects.enter.the.maintenance.phase.or.when.new.engineers.are.brought.into.the.project. Similarly.to.achieving.architectural.design.synchronicity.processes.must.be.in.place.and. enforced.to.ensure.that.overall.design.synchronicity.is.high. CHAPTER SUMMARY The.detailed.design.activity.begins.after.the.software.architecture.is.specified.reviewed. and.approved.by.all.stakeholders.in.the.project.The.detailed.design.activity.corresponds. to.a.microdesign.view.of.the.structure.and.behavior.of.the.software.system.and.is.the. last.major.effort.before.software.construction.begins.IEEE.(1990).defines.detailed.design. as.the.process.of.refining.and.expanding.the.preliminary.design.phase.of.a.system.or. 174  Software Engineering Design component.to.the.extent.that.the.design.is.sufficiently.complete.to.be.implemented.That. is.the.process.of.refining.the.software.architecture.to.reach.a.point.where.construction.can. begin.It.is.important.to.note.that.most.of.the.detailed.design.activities.deal.directly.with. addressing.functional.requirements.of.the.system.The.detailed.design.process.requires. designers. to. understand. the. architecture. and. requirements. before. creation. of. detailed.

--- Chunk 317 ---
Tokens: 389
Type: sentence-based
Text:
detailed. designs.Detailed.design.decisions.can.significantly.shape.the.systems.quality.properties. therefore.they.must.exist.within.the.bounds.of.the.software.architecture.In.some.cases. where.modeling.tools.are.used.to.generate.code.detailed.designs.can.also.have.significant. impact.on.the.quality.properties.of.the.construction.phase.Once.created.detailed.designs. can.be.documented.together.with.architectural.design.to.form.the.software.design.docu- ment.which.is.reviewed.and.approved.before.construction.begins.The.design.document. establishes.the.general.framework.of.reference.for.all.construction.work.therefore.policies. must.be.in.place.to.maintain.synchronicity.between.the.design.document.and.construc- tion.work.Upon.completion.of.the.detailed.design.activity.the.systems.design.is.suffi- ciently.complete.so.that.it.can.be.formally.documented.reviewed.and.approved.by.the. systems.stakeholders.which.marks.the.end.of.the.design.phase. REVIEW QUESTIONS . 1.What.is.detailed.design.and.how.does.it.differ.from.architectural.design? . 2.Explain. the. relationship. among. requirements. architecture. detailed. design. and. construction. . 3.What.key.tasks.are.performed.during.detailed.design.Explain. . 4.What.steps.are.involved.in.the.detailed.design.process? . 5.What.are.derived.requirements.and.how.do.they.play.a.role.during.detailed.design? . 6.What.is.the.role.of.software.architecture.during.detailed.design.Can.detailed. design.succeed.without.architecture.Explain. . 7.Explain.the.concept.of.interface.design.during.detailed.design. .

--- Chunk 318 ---
Tokens: 391
Type: sentence-based
Text:
. 8.In.object-oriented.systems.what.is.the.difference.between.a.class.and.an.object? . 9.What.is.the.difference.between.concrete.and.abstract.classes? . 10.Explain.the.following.concepts: . a. Interfaces . b. Types.and.subtypes . c. Dynamic.binding . d. Polymorphism . 11.Compare.and.contrast.the.OCP.LSP.and.ISP. . 12.Why.are.programming.styles.important.during.detailed.design.Give.examples.of. some.styles.used.during.detailed.design. . 13.Explain.the.concepts.of.combined.fragments.operators.and.guards.in.interaction. .diagrams.Give.an.example.of.each. . 14.What.is.the.difference.between.architectural.patterns.and.detailed.design.patterns? Principles of Detailed Design  175 . 15.What.are.the.sections.of.the.software.design.document.Explain.each. . 16.What.is.the.interface.control.document.and.why.is.it.necessary.in.practical.develop- ment.efforts? . 17.What.is.the.version.control.document.and.how.does.it.relate.to.the.software.design? CHAPTER EXERCISES . 1.Create.a.class.diagram.and.sequence.diagram.to.design.and.validate.the.following. system.The.system.will.consist.of.a.traffic.light.object.that.communicates.with.three. light.bulb.objects.Each.light.bulb.object.cannot.exist.without.the.traffic.light.object. All.light.bulb.objects.have.capabilities.to.turn.green.yellow.and.red.In.fact.all.light. bulb.objects.are.identical.except.that.they.communicate.with.different.light.bulb. hardware.controllers.to.turn.specific.light.bulbs.on.and.off.All.light.bulb.objects. must.support.a.turnOn().turnOff().and.setColor(int.color).method.which.will.turn.

--- Chunk 319 ---
Tokens: 391
Type: sentence-based
Text:
must.support.a.turnOn().turnOff().and.setColor(int.color).method.which.will.turn. the.light.bulb.on.off.and.set.the.color.respectively.The.system.will.use.a.custom. timer.object.for.managing.the.transition.of.the.light.bulbs.and.a.sensor.object.to. detect.when.cars.arrived.at.the.traffic.light.system.Both.timer.and.sensor.are.part.of. the.traffic.light.system.but.are.also.used.in.other.sections.of.the.system.so.their.life- time.is.not.controlled.by.the.traffic.light.object.When.the.sensor.object.fires.off.the. traffic.light.object.will.activate.the.green.light.and.the.timer.When.the.timer.expires. the.traffic.light.object.will.deactivate.the.green.light.and.activate.the.yellow.light.It. will.also.activate.the.timer.again.When.the.timer.expires.the.traffic.light.system.will. deactivate.the.yellow.light.and.activate.the.red.light. REFERENCES Booch.Grady.James.Rumbaugh.and.Ivar.Jacobson.The Unified Modeling Langauge User Guide.2d.ed.Addison- Wesley.Professional.2005. Buschmann. Frank. Regine. Meunier. Hans. Rohnert. Peter. Sommerlad. and. Michael. Stal. Pattern-Oriented Software Architecture: A System of Patterns.West.Sussex.UK.Wiley.1996. Clements.Paul.Felix.Bachmann.Len.Bass.David.Garlan.James.Ivers.Reed.Little.Robert.Nord.and.Judith.Stafford. Documenting Software Architectures.Boston.MA.Addison.Wesley.2002. Clements.Paul.Rick.Kazman.and.Mark.Klein.Evaluating Software Architectures.Addison.Wesley.2001. Douglas.Bruce.P.Doing Hard Time: Developing Real-Time Systems with UML, Objects, Frameworks, and Patterns. Addison-Wesley.Professional.1999.

--- Chunk 320 ---
Tokens: 384
Type: sentence-based
Text:
Addison-Wesley.Professional.1999. Douglass.Bruce.P.Real-Time Design Patterns: Robust Scalable Architecture for Real-Time Systems.Addison-Wesley. Professional.2002. Gamma. Erich. Richard. Helm. Ralph. Johnson. and. John. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software.Boston.Addison-Wesley.1995. IEEE. IEEE. Standard. for. Information. Technology-Systems. Design-Software. Design. Descriptions. 2009. http:ieeexplore.ieee.orgxplfreeabs_all.jsp?arnumber5167255. IEEE.IEEE.Standard.Glossary.of.Software.Engineering.Terminology.IEEE.1990.p.34. 176  Software Engineering Design Liskov.Barbara.and.John.Guttag.Program Development in Java: Abstraction, Specification, and Object-Oriented Design.Boston.Addison-Wesley.2000. Marin. Robert. C. Agile Software Development: Principles, Patterns, and Practices. Upper. Saddle. River. NJ. Prentice.Hall.2003. Meyer.Bertrand.Object-Oriented Software Construction.2d.ed.Upper.Saddle.River.NJ.Prentice.Hall.1997. Ortega-Arjona.Jorge.L.Patterns for Parallel Software Design.West.Sussex.UK.Wiley.2010. Pressman.Roger.S.Software Engineering: A Practitioners Approach.7th.ed.Chicago.McGraw-Hill.2010. Sommerville.Ian.Software Engineering.9th.ed.Boston.Addison.Wesley.2010. Tichy.Walter.Making Software: What Really Works, and Why We Believe It.Sebastopol.CA.OReilly.Media. 2010. UML.2.3.Superstructure.Vers.2.3.Object.Management.Group.May.2010.Available.at.http:www.omg.org Vermeulen. Allan. Felix. Bachmann. Len. Bass. David. Garlan. James. Ivers. Reed. Little. Robert. Nord. and.

--- Chunk 321 ---
Tokens: 399
Type: sentence-based
Text:
and. Judith Stafford.The Elements of Java Styles.Cambridge.UK.Cambridge.University.Press.2000. Vora.Pawan.Web Application Design Patterns.Burlington.MA.Morgan.Kaufmann.2009. 177 6 Creational Design Patterns in Detailed Design CHAPTER OBJECTIVES . Understand.the.importance.and.role.of.creational.design.patterns.in. detailed.design . Identify.understand.and.model.common.creational.design.patterns . Become.proficient.in.implementing.models.of.creational.design.patterns . Understand. the. benefits. of. creational. patterns. when. implementing. software.systems CONCEPTUAL OVERVIEW During.detailed.design.software.engineers.spend.a.great.deal.of.time.devis- ing.component.design.solutions.that.fill.in.the.gaps.in.architectural.designs. and.provide.the.necessary.internal.design.of.components.and.their.inter- faces.to.achieve.system.functionality.At.the.detailed.design.level.common. patterns. in. object-oriented. designs. have. emerged. that. provide. detailed. design.solutions.to.problems.that.recur.many.times.over.in.different.systems. A particular. problem. in. these. systems. involves. the. efficient. creation. of. objects.so.that.concepts.highlighted.in.previous.chapters. (i.e, interfaces. types. dynamic. binding. and. polymorphism). can. be. used. effectively. to. generate. reusable. and. maintainable. software. Creational. design. patterns. help. identify. problems. that. deal. with. creating. quality. detailed. designs. that.are.efficient.in.the.creation.of.object.in.the.system.They.prescribe.the. classes.required.for.their.design.solution.and.interrelationships.required.

--- Chunk 322 ---
Tokens: 400
Type: sentence-based
Text:
classes.required.for.their.design.solution.and.interrelationships.required. to.support.object.creation.These.patterns.allow.designers.to.quickly.and. 178  Software Engineering Design systematically.identify.structural.layouts.of.systems.(or.subsystems).and.provide.avenues. for.examining.system.interactions.and.quality.evaluation.within.the.operational.system. This.chapter.explores.several.well-established.creational.design.patterns.and.examines.the. problems.they.are.designed.to.address.together.with.their.exhibited.quality.attributes. Identifying.and.designing.using.creational.design.patterns.can.improve.the.efficiency.of. the.development.process.and.the.quality.of.the.final.system. CREATIONAL DESIGN PATTERNS Creational.design.patterns.are.patterns.for.abstracting.and.controlling.the.way.objects.are. created.in.software.applications.They.play.a.key.role.in.the.design.of.systems.by.making. them.independent.of.how.objects.in.the.system.are.created.composed.and.represented. (Gamma.Helm.Johnson.and.Vlissides.1995).Therefore.parts.of.the.system.responsible. for.creating.(or.instantiating).objects.do.so.through.a.common.creational.interface.without. knowledge.of.how.the.actual.object.or.group.of.objects.are.created.In.addition.by.control- ling.the.creational.process.with.a.common.interface.enforcing.creational.policies.becomes. easier.therefore.giving.the.system.the.ability.to.create.product.objects.that.share.a.com- mon.interface.but.vary.widely.in.structure.and.behavior.Examples.of.creational.patterns. include.the.abstract.factory.factory.method.builder.prototype.and.singleton.

--- Chunk 323 ---
Tokens: 398
Type: sentence-based
Text:
include.the.abstract.factory.factory.method.builder.prototype.and.singleton. ABSTRACT FACTORY The.abstract.factory.is.an.object.creational.design.pattern.intended.to.manage.and.encap- sulate.the.creation.of.a.set.of.objects.that.conceptually.belong.together.and.that.represent.a. specific.family.of.products.According.to.the.Gang.of.Four.(Gamma.et.al.1995.p.87).the. intent.of.the.abstract.factory.is.to Provide.an.interface.for.creating.families.of.related.or.dependent.objects.without.specifying. their.concrete.classes. In.the.abstract.factory.pattern.the.terms.family of products.or.family of objects.are.used. to.denote.a.group.of.objects.that.belong.together.and.therefore.must.be.created.together. When.designing.software.that.uses.a.group.of.objects.that.need.to.be.created.and.used. together.problems.can.arise.when.there.is.no.consistent.way.for.managing.the.creation. of.these.objects.For.example.consider.two.distinct.families.of.computers.one.represent- ing.standard.computers.made.up.of.standard.computer.parts.and.another.representing. advanced.computers.made.up.of.advanced.computer.parts.Assume.that.the.family.of. standard.computers.can.be.composed.only.of.standard.computer.parts.such.as.a.stan- dard.monitor.standard.keyboard.and.standard.CPU.and.that.the.family.of.advanced. Creational Design Patterns in Detailed Design  179 computers.can.consist.only.of.advanced.computer.parts.such.as.an.advanced.monitor. advanced.keyboard.and.advanced.CPU.When.left.unmanaged.designing.software.that. instantiates.both.standard.and.advanced.computers.can.be.prone.to.various.problems.

--- Chunk 324 ---
Tokens: 394
Type: sentence-based
Text:
instantiates.both.standard.and.advanced.computers.can.be.prone.to.various.problems. First.there.is.the.possibility.that.advanced.computer.objects.can.be.created.using.standard. products.or.vice.versa.that.is.standard.computer.objects.created.using.advanced.com- puter.parts.products.Moreover.without.a.standardized.common.interface.identified.for. the.different.computer.parts.the.code.inside.the.computer.classes.would.be.required.to. know.about.the.correct.computer.parts.type.to.use.therefore.the.addition.of.new.prod- ucts.or.new.product.types.would.require.changing.the.code.inside.the.computer.classes.a. clear.violation.of.the.openclosed.principle.discussed.in.Chapter.5.These.problems.result. in.code.that.is.hard.to.maintain.and.reuse.The.abstract.factory.design.pattern.addresses. these.problems.by.encapsulating.the.creation.of.these.families.of.products.in.such.a.way. that.they.can.be.interchangeable.at.run.time.and.by.ensuring.that.products.that.belong.to. a.specific.group.or.family.are.instantiated.together. Problem A.computer.store.needs.stand-alone.software.that.keeps.track.of.computer.inventory.which. includes.computers.and.different.computer.parts.made.by.different.hardware.manufactur- ers.The.software.for.the.computer.store.needs.capabilities.for.displaying.information.about. computer.parts.including.information.from.the.manufacturers.site.and.various.other.sites. that.contain.customer.satisfaction.reviews.and.other.relevant.information.Therefore.each. computer.part.object.needs.to.be.capable.of.extracting.information.in.real.time.from.a.list.

--- Chunk 325 ---
Tokens: 379
Type: sentence-based
Text:
computer.part.object.needs.to.be.capable.of.extracting.information.in.real.time.from.a.list. of.predefined.remote.locations.of.aggregating.the.information.and.of.providing.this.infor- mation.upon.request.Upon.requesting.the.information.for.a.particular.computer.all.com- puter.part.objects.communicate.over.the.network.and.find.out.the.latest.comments.and. statistics.about.a.component.from.all.predefined.sources.and.make.this.information.avail- able.to.the.requesting.object.Initially.the.store.supports.only.two.types.of.computers.stan- dard.computers.and.advanced.computers.composed.of.standard.and.advanced.computer. parts.(i.e.CPU.monitor.and.mouse).respectively.Due.to.store.policy.standard.computers. cannot.be.composed.of.advanced.computer.parts.and.advanced.computers.cannot.be.com- posed.of.standard.computer.parts.The.software.solution.needs.to.provide.a.maintainable. and.modifiable.design.for.creating.these.families.of.objects.to.support.easy.addition.of.new. families.of.computers.and.to.promote.consistency.with.computer.products. Structure The.general.and.applied.structure.for.the.abstract.factory.design.pattern.is.presented.in. Figure 6.1.As.seen.the.abstract.factory.is.presented.in.general.and.applied.form.and.for. simplicity. the. details. of. both. abstract. and. concrete. computer. part. classes. are. omitted. in.the.applied.form.The.general.structure.of.the.abstract.factory.design.pattern.serves. as.a.blueprint.that.depicts.the.participants.and.relationships.required.to.design.abstract.

--- Chunk 326 ---
Tokens: 305
Type: sentence-based
Text:
as.a.blueprint.that.depicts.the.participants.and.relationships.required.to.design.abstract. .factories.it.presents.the.essence.of.the.pattern.which.needs.to.be.fitted.for.the.particular. 180  Software Engineering Design problem.at.hand.The.applied.view.of.Figure 6.1.presents.an.instantiation.of.the.general. structure. for. depicting. the. solution. for. the. particular. computer. store. problem. which. consists.of.abstract.products.(e.g.monitor).concrete.products.(e.g.standard.monitor). abstract.creators. (e.g, computer.parts.factory).and.concrete.creators. (e.g.standard.com- puter.parts.factory).These.participants.are.interrelated.via.realization.and.association.rela- tionships.From.this.example.it.should.be.evident.how.a.new.family.of.computer.parts.can. be.added.to.the.design.by.adding.the.required.pattern.classes.that.make.up.the.new.family. of.computers. Implementing.the.abstract.factory.design.pattern.can.be.confusing.because.of.the.num- ber.of.classes.required.However.when.looking.closely.at.the.Unified.Modeling.Language. (UML).diagram.for.the.application.view.it.is.evident.that.regardless.of.the.number.of. computer.factories.or.computer.products.the.structural.relationship.among.these.classes.

--- Chunk 327 ---
Tokens: 387
Type: sentence-based
Text:
computer.factories.or.computer.products.the.structural.relationship.among.these.classes. interface AbstractFactory interface ComputerPartsFactory createProductA() createProductB() createProductA() createProductB() interface AbstractProductA interface CPU ConcreteProductA1 ConcreteFactory1 createMonitor(): Monitor createCPU(): CPU createKeyboard(): Keyboard createMonitor(): Monitor createCPU(): CPU createKeyboard(): Keyboard createProductA() createProductB() ConcreteFactory2 ConcreteProductB1 ConcreteProductA2 interface Monitor Computer interface Keyboard ConcreteProductB2 AdvancedKeyboard AdvancedMonitor AdvancedCPU StandardKeyboard StandardMonitor StandardCPU AdvancedComputerPartsFactory createMonitor(): Monitor createCPU(): CPU createKeyboard(): Keyboard StandardComputerPartsFactory Client interface AbstractProductB General View Applied View FIGURE 6.1 Abstract.factory.design.pattern. Creational Design Patterns in Detailed Design  181 is.always.the.same.This.is.true.for.all.other.patterns.studied.throughout.this.and.other. chapters.Therefore.a.step-by-step.approach.can.be.taken.to.design.abstract.factories: . 1.Design.the.product.interfaces.(e.g.CPU.monitor.keyboard). . 2.Identify.the.different.families.or.groups.required.for.the.problem.(e.g.standard.and. advanced.computers). . 3.For.each.group.identified.design.concrete.products.that.realize.the.respective.prod- uct.interface.(e.g.standard.monitor.vs.advanced.monitor).identified.in.Step.1. . 4.Create.the.factory.interface.(e.g.ComputerPartsFactory).The.factory.interface.

--- Chunk 328 ---
Tokens: 358
Type: sentence-based
Text:
4.Create.the.factory.interface.(e.g.ComputerPartsFactory).The.factory.interface. contains.n.interface.methods.where.n.is.the.number.interfaces.created.in.Step.1. . 5.For.each.group.identified.in.Step.2.create.concrete.factories.that.realize.the.factory. interface.created.in.Step.4. . 6.Create.the.factory.client.(e.g.Computer).which.is.associated.with.both.products. and.factory.interfaces.created.in.Steps.1.and.4.respectively. Abstract. factory. designs. contain. two. fundamental. sets. of. class. designs. products. and. .factories.Once.both.products.and.factories.portions.of.the.design.are.complete.dynamic. binding.can.be.used.at.run.time.to.allow.the.computer.client.to.create.different.computer. objects.(e.g.standard.vs.advanced.computers).and.use.them.throughout.programs.without. actually.knowing.the.specific.type.of.the.object.This.way.adding.other.computer.types.to. the.system.can.be.done.by.extending.the.design.and.not.by.modifying.already.working.code. Implementation When.studying.the.abstract.factory.(and.all.other.design.patterns).it.is.important.that. UML.models.are.translated.to.code.compiled.and.executed.When.necessary.it.is.also. helpful. to. step. through. the. code. with. a. debugger. to. keep. track. of. dynamic. binding. throughout.the.softwares.execution.This.provides.additional.insight.and.helps.further. the.understanding.of.both.concepts.and.benefits.of.using.a.particular.design.pattern.Once.

--- Chunk 329 ---
Tokens: 400
Type: sentence-based
Text:
the.understanding.of.both.concepts.and.benefits.of.using.a.particular.design.pattern.Once. the.structural.design.of.the.abstract.factory.is.created.its.translation.to.code.is.straight- forward.Listing 6.1.presents.the.C.implementation.for.the.ComputerPartsFactory.class. As.seen.the.ComputerPartsFactory.abstract.class.simply.defines.interface.methods. required.for.creating.each.computer.part.designed.for.the.system.Therefore.there.is.a. one-to-one.relationship.between.interface.methods.and.product.interfaces.Since.the. code.for.the.abstract.factory.interface.is.presented.in.C.each.interface.method.is. defined.as.pure.virtual.which.includes.the.virtual.keyword.and.is.set.to.0.In.the. Java.programming.language.the.ComputerPartsFactory.would.be.defined.as.a. Java.interface.using.the.interface.keyword.Once.the.interface.for.the.computer. parts.factory.is.established.all.other.concrete.factories.can.be.implemented.to.create. products. of. specific. computer. types. upon. request. Consider. the. implementation. for. creating.advanced.computer.parts.where.the.advanced.computer.part.factory.instan- tiates.advanced.computer.products.The.header.file.for.the.advanced.computer.parts. computer.factory.is.presented.in.Listing.6.2. 182  Software Engineering Design As.seen.the.AdvancedComputerPartsFactory.realizes.the.ComputerParts- Factory.interface.by.inheriting.from.it.and.defining.concrete.methods.for.each.of.its. defined.interface.methods.Each.interface.method.is.implemented.in.terms.of.advanced. computer. parts. such. that. the. createMonitor(). method. returns. an. instance. of. type.

--- Chunk 330 ---
Tokens: 383
Type: sentence-based
Text:
type. AdvancedMonitor. the. createKeyboard(). returns. an. instance. of. type. AdvancedKeyboard.and.so.on.This.behavior.is.presented.in.the.source.file.for.the. AdvancedComputerParts.factory.as.presented.in.Listing.6.3. Listing 6.2: C Header File for the Advanced Computer Parts Concrete Factory  Forward references class Monitor; class Keyboard; class Cpu;  Concrete advanced computer parts factory. class AdvancedComputerPartsFactory : public ComputerPartsFactory  public:  Create and return an advanced monitor. Monitor createMonitor();  Create and return an advanced keyboard. Keyboard createKeyboard();  Create and return an advanced cpu. Cpu createCpu(); ; Listing 6.1: C Code for the Computer Parts Factory Interface  Computer parts factory interface. class ComputerPartsFactory  public:  Define the interface to create a monitor object. virtual Monitor createMonitor(void)  0;  Define the interface to create a keyboard object. virtual Keyboard createKeyboard  0;  Define the interface to create a CPU object. virtual Cpu createCpu  0; ; Creational Design Patterns in Detailed Design  183 In.Listing.6.3.it.is.assumed.that.the.concrete.products.for.the.advanced.computer.parts. factory have.been.defined.In.fact.before.any.concrete.computer.parts.factory.code.can. be.compiled.its.parts.need.to.be.defined.Using.this.pattern.the.implementation.for.the. standard.computer.parts.factory.is.similar.to.the.advanced.one.but.instead.of.creating. advanced.concrete.products.it.implements.the.creational.methods.in.terms.of.standard.

--- Chunk 331 ---
Tokens: 390
Type: sentence-based
Text:
advanced.concrete.products.it.implements.the.creational.methods.in.terms.of.standard. computer.parts.products.Listings.6.4.and.6.5.present.the.generated.code.for.the.UML. model.of.the.standard.computer.parts.factory.together.with.its.implementation.In.a.simi- lar.fashion.the.creation.of.all.other.required.computer.parts.factories.in.the.system.can.be. designed.and.implemented.the.same.way. The.final.piece.of.the.abstract.factory.design.pattern.includes.the.factory.client.object. In.this.example.the.client.is.a.computer.object.that.is.composed.of.different.computer. part.products.The.concept.employed.in.this.example.is.that.computers.are.composed.of. different.computer.parts.therefore.by.configuring.computer.objects.with.computer.parts. factories.they.can.delegate.the.creation.of.computer.parts.to.run-time.objects.mapped. using.dynamic.binding.This.allows.the.creational.code.for.computer.objects.to.be.open.to. extension.but.closed.for.modification.The.header.and.source.code.for.the.Computer.class. are.presented.in.Listings.6.6.and.6.7. Listing 6.3: C Source File for the Advanced Computer Parts Concrete Factory include AdvancedComputerPartsFactory.h include AdvancedMonitor.h include AdvancedKeyboard.h include AdvancedCpu.h  Create and return an advanced monitor. Monitor AdvancedComputerPartsFactory:createMonitor()   Caller is responsible for cleaning up the memory. return new AdvancedMonitor;   Create and return an advanced keyboard. Keyboard AdvancedComputerPartsFactory:createKeyboard()   Caller is responsible for cleaning up the memory.

--- Chunk 332 ---
Tokens: 400
Type: sentence-based
Text:
Keyboard AdvancedComputerPartsFactory:createKeyboard()   Caller is responsible for cleaning up the memory. return new AdvancedKeyboard;   Create and return an advanced cpu. Cpu AdvancedComputerPartsFactory:createCpu()   Caller is responsible for cleaning up the memory. return new AdvancedCpu;  184  Software Engineering Design Listing 6.4: C Header File for the Standard Computer Parts Concrete Factory  Forward references class Monitor; class Keyboard; class Cpu;  Concrete standard computer parts factory. class StandardComputerPartsFactory : public ComputerPartsFactory  public:  Create and return a standard monitor. Monitor createMonitor();  Create and return a standard keyboard. Keyboard createKeyboard();  Create and return a standard CPU. Cpu createCpu(); ; Listing 6.5: C Source File for the Standard Computer Parts Concrete Factory include StandardComputerPartsFactory.h include StandardMonitor.h include StandardKeyboard.h include StandardCpu.h  Create and return a standard monitor. Monitor StandardComputerPartsFactory:createMonitor()   Caller is responsible for cleaning up the memory. return new StandardMonitor;   Create and return a standard keyboard. Keyboard StandardComputerPartsFactory:createKeyboard()   Caller is responsible for cleaning up the memory. return new StandardKeyboard;   Create and return a standard CPU. Cpu StandardComputerPartsFactory:createCpu()   Caller is responsible for cleaning up the memory. return new StandardCpu;  Creational Design Patterns in Detailed Design  185 The.key.concept.presented.in.Listing.6.6.is.the.reliance.of.the.Computer.class.on.four.

--- Chunk 333 ---
Tokens: 391
Type: sentence-based
Text:
return new StandardCpu;  Creational Design Patterns in Detailed Design  185 The.key.concept.presented.in.Listing.6.6.is.the.reliance.of.the.Computer.class.on.four. interfaces.namely.the.ComputerPartsFactory.Monitor.Cpu.and.Keyboard. interfaces.This.highlights.a.desirable.attribute.of.component.designs.which.is.to.rely. on.interfaces.instead.of.on.concrete.implementations.Together.these.interface.refer- ences. (i.e.pointers).will.hold.the.addresses.of.run-time.objects.that.adhere.to.the.par- ticular.interface.Therefore.upon.creation.objects.of.the.computer.type.will.use.these. interface.references.to.save.the.addresses.of.concrete.products.created.by.a.particular. computer.parts.factory.object. The.implementation.code.for.this.behavior.is.presented. in.Listing.6.7. Once.a.concrete.factory.is.passed.into.the.constructor.of.the.Computer.class.the.respon- sibility.for.creating.each.product.is.delegated.to.the.factory.object.This.way.a.Computer. object.can.be.created.the.same.way.for.all.computer.types.simply.by.changing.the.factory. Listing 6.6: C Header File for the Computer Client  Forward references. class ComputerPartsFactory; class Monitor; class Cpu; class Keyboard; class Computer  public:  Constructor parameterized with a computer parts factory. Computer(ComputerPartsFactory computerPartsFactory);  Display detailed information about the monitor. void displayMonitorInfo();  Display detailed information about the CPU. void displayCpuInfo();  Display detailed information about the keyboard. void displayKeyboardInfo();  Display computer cost.

--- Chunk 334 ---
Tokens: 386
Type: sentence-based
Text:
void displayKeyboardInfo();  Display computer cost. void displayCost();  All other computer methods. Destructor needs to clean up memory. private: Monitor _monitor;  Pointer to the monitor interface. Cpu _cpu;  Pointer to the Cpu interface. Keyboard _keyboard;  Pointer to the Keyboard interface. ; 186  Software Engineering Design Listing 6.7: C Source File for the Computer Client include Computer.h include ComputerPartsFactory.h include Monitor.h include Cpu.h include Keyboard.h  Constructor Computer:Computer(ComputerPartsFactory computerPartsFactory)   Delegate the creation of the monitor object to the Factory. _monitor  computerPartsFactory-createMonitor();  Delegate the creation of the keyboard object to the Factory. _keyboard  computerPartsFactory-createKeyboard();  Delegate the creation of the Cpu object to the Factory. _cpu  computerPartsFactory-createCpu();   Display detailed information about the monitor. void Computer:displayMonitorInfo()   Display monitors info. _monitor-displayInformation();   Display detailed information about the CPU. void Computer:displayCpuInfo()   Display Cpus info. _cpu-displayInformation();   Display detailed information about the keyboard. void Computer:displayKeyboardInfo()   Display keyboards info. _keyboard-displayInformation();   Display computer cost. void Computer:displayCost()   Use all computer products to compute total cost and display it. Creational Design Patterns in Detailed Design  187 that.creates.the.products.Consider.the.code.the.computer.store.software.that.provides.

--- Chunk 335 ---
Tokens: 379
Type: sentence-based
Text:
Creational Design Patterns in Detailed Design  187 that.creates.the.products.Consider.the.code.the.computer.store.software.that.provides. and.manages.inventory.information.using.the.ComputerStore.class.Using.the.abstract. factory.design.pattern.the.implementation.code.for.displaying.computer.information.is. presented.in.Listing 6.8.As.seen.the.display.computer.method.is.passed.in.a.string.to. determine.the.type.of.computer.to.be.displayed.Once.the.type.is.identified.the.appropri- ate.computer.parts.factory.object.is.instantiated.and.passed.into.the.constructor.of.the. computer.object.From.this.point.forward.all.operations.called.on.the.computer.object.are. implemented.in.terms.of.the.factory.used.to.create.its.parts.Similarly.many.different.com- puter.types.can.be.supported.by.creating.additional.factories.to.parameterize.computer. objects.with.newly.supported.computer.types. Listing 6.8: C Implementation of the Computer Store  Assume that the ComputerStore class has been defined and contains  the method displayComputer and the member attributes used below. Method to display a computers information. void ComputerStore:displayComputer(string type)   Determine which computer needs to be created. if( type.compare(standard)  0 )   Create the standard computer factory object. computerPartsFactory  new StandardComputerPartsFactory;  else   Create the advanced computer factory object. computerPartsFactory  new AdvancedComputerPartsFactory;   Create the computer object using the appropriate factory.

--- Chunk 336 ---
Tokens: 375
Type: sentence-based
Text:
computerPartsFactory  new AdvancedComputerPartsFactory;   Create the computer object using the appropriate factory. _computer  new Computer(computerPartsFactory);  Display the computer information, including its cost. This  information varies according to the factory object used to create  the computer. _computer-displayMonitorInfo(); _computer-displayCpuInfo(); _computer-displayKeyboardInfo(); _computer-displayCost();  Do more stuff with the computer object here. Clean up the all memory allocated when done. 188  Software Engineering Design When.applying.the.abstract.factory.design.pattern.depending.on.the.problem.a.large. number.of.classes.may.be.required.causing.confusion.to.those.who.are.new.to.the.pattern. However.it.is.important.to.keep.in.mind.that.the.core.classes.and.relationships.identified.in. the.general.structure.of.the.pattern.remain.the.same.regardless.of.the.problem.That.is.an. abstract.factory.has.one.or.more.factory.objects.defined.by.an.abstract.factory.interface.and. one.or.more.products.defined.by.one.or.more.product.interfaces. Benefits . Isolates.concrete.product.classes.so.that.reusing.them.becomes.easier . Promotes.consistency.within.specific.product.families . Adding.new.families.of.products.which.requires.no.modification.of.existing.code Skill Development 6.1: Abstract Factory Design Pattern Using.the.UML.tool.of.choice.replicate.the.UML.model.presented.in.Figure 6.1.and. generate.code.from.the.model.Using.the.Integrated.Development.Environment.(IDE).

--- Chunk 337 ---
Tokens: 394
Type: sentence-based
Text:
generate.code.from.the.model.Using.the.Integrated.Development.Environment.(IDE). of.choice.fill.in.the.gaps.in.the.code.generated.using.Listings.6.1.through.6.8.and.com- pile.and.execute.the.software.Once.the.software.executes.go.back.to.the.UML.model. and.add.a.third.factory.named.SpecialComputerFactory.together.with.special. computer.products. (e.g, SpecialMonitor.SpecialKeyboard.SpecialCpu). Repeat.the.code.generation.process.fill.in.the.gaps.of.the.new.generated.code.compile. and.execute.When.complete.explain.the.steps.required.to.make.this.new.modification. and.how.the.abstract.factory.design.pattern.made.this.change.easy.or.hard. FACTORY METHOD The.factory.method.design.pattern.is.a.class.creational.pattern.used.to.encapsulate.and. defer.object.instantiation.to.derived.classes.Structurally.the.factory.method.can.be.mod- eled. as. a. simplified. version. of. the. abstract. factory. design. pattern. since. both. patterns. require.creator.and.product.interfaces.However.unlike.the.abstract.factory.design.pat- tern.in.which.the.creator.objects. (i.e.factories).are.responsible.for.instantiating.a.plural- ity.of.products.that.belong.to.a.specific.family.type.creator.objects.in.the.factory.method. design.pattern.are.responsible.for.the.creation.of.a.single.product.of.specific.type.Therefore. the.creator.interface.for.the.factory.method.design.pattern.provides.only.one.creational. method.whereas.the.creator.interface.for.the.abstract.factory.design.pattern.provides.two. or.more.creational.methods.In.addition.unlike.the.abstract.factory.design.pattern.the.

--- Chunk 338 ---
Tokens: 398
Type: sentence-based
Text:
or.more.creational.methods.In.addition.unlike.the.abstract.factory.design.pattern.the. factory.method.design.pattern.defers.object.creation.to.subtypes.that.realize.the.creational. interface.a.relationship.specified.by.inheritance.therefore.the.factory.method.design.pat- tern.is.classified.as.a.class.creational.design.pattern.as.opposed.to.an.object.creational. Creational Design Patterns in Detailed Design  189 design.pattern.These.fundamental.differences.are.essential.for.understanding.the.differ- ence.between.both.patterns.According.to.the.Gang.of.Four.(Gamma.et.al.1995.p.107). the.intent.of.the.factory.method.is.to Define.an.interface.for.creating.an.object.but.let.subclasses.decide.which.class.to.instantiate. Factory.Method.lets.a.class.defer.instantiation.to.subclasses. The.factory.method.design.pattern.provides.the.ability.for.designers.to.model.and.imple- ment.code.in.terms.of.the.factory.method.and.product.interfaces.The.factory.method. design.pattern.is.mainly.characterized.by.one.creational.method.which.is.used.to.instan- tiate.and.return.objects.of.a.specified.product.interface.This.creational.method.is.made. abstract.at.the.factory.base.class.so.that.objects.of.the.factory.base.class.cannot.be.directly. instantiated.This.is.done.to.create.a.framework.that.allows.the.factory.base.class.to.define. a.series.of.operations.that.rely.on.the.product.interface.however.before.executing.opera- tions.object.creation.is.delegated.to.derived.classes.that.are.required.to.implement.the. factory.(creational).method.This.way.new.derived.factories.can.override.the.method.to.

--- Chunk 339 ---
Tokens: 398
Type: sentence-based
Text:
factory.(creational).method.This.way.new.derived.factories.can.override.the.method.to. instantiate.and.return.the.appropriate.product.for.the.particular.situation.that.is.then.used. to.carry.out.the.operations.specified.in.the.factory.base.class.This.way.through.inheri- tance.new.factories.can.be.added.to.the.design.of.the.system.to.extend.the.factory.base. class.without.modifying.its.code.With.the.factory.method.in.place.reasoning.about.appli- cation.logic.can.be.made.in.terms.of.the.product.interface.and.not.on.concrete.products. therefore.resulting.in.code.that.can.be.extended.easily. Problem The.computer.store.from.the.previous.example.has.expanded.its.operations.to.have.three. different.stores.at.different.locations.Because.of.demographics.at.each.location.particu- lar.types.of.computers.are.offered.at.specific.locations.The.computer.store.in.Location.1. .supports.standard.computers.only.the.computer.store.at.Location.2.supports.advanced. computers.and.the.computer.store.at.Location.3.supports.a.new.type.of.special.computer. The.software.system.is.now.required.to.display.information.about.computers.carried.at. specific.stores.Therefore.the.software.design.requires.modification.so.that.the.display.of. computer.information.is.site-specific.A.desired.feature.for.the.redesigned.software.is.the. ability.to.keep.the.logic.code.separate.from.specific.types.of.computer.stores.so.that.future. stores.carrying.different.computers.can.be.added.to.the.system.with.minimal.effort. Structure The.generic.and.applied.structure.of.the.factory.method.design.pattern.is.presented.in.

--- Chunk 340 ---
Tokens: 219
Type: sentence-based
Text:
Structure The.generic.and.applied.structure.of.the.factory.method.design.pattern.is.presented.in. Figure 6.2.As.seen.the.pattern.requires.both.creational.and.product.classes.similar.to. the.abstract.factory.design.pattern.However.unlike.the.abstract.factory.design.pattern. creator.classes.in.the.factory.method.design.pattern.require.only.one.creational.interface. 190  Software Engineering Design method.for.creating.products.that.share.the.same.interface.Therefore.for.each.product.in. the.system.the.design.incorporates.concrete.product.and.concrete.creator.classes. A. step-by-step. approach. to. designing. the. factory. method. design. patterns. includes. the following: . 1.Identify.and.design.the.product.interface.(e.g.computer). . 2.Identify. and. design. the. concrete. products. that. realize. the. interface. from. Step. 1. (e.g, StandardComputer.AdvancedComputer).

--- Chunk 341 ---
Tokens: 382
Type: sentence-based
Text:
(e.g, StandardComputer.AdvancedComputer). createProduct() someOperator() Creator createComputer(type: string): Computer displayComputer(type: string): void ComputerStore StandardComputerStore createComputer(type: string): Computer AdvancedComputerStore createComputer(type: string): Computer displayMonitorInfo(): void displayCpuInfo(): void displayKeyboardInfo(): void displayCost(): void createProduct() ConcreteCreator productOperation1() createOperation2() interface Product General View Applied View interface Computer displayMonitorInfo(): void displayCpuInfo(): void displayKeyboardInfo(): void displayCost(): void StandardComputer displayMonitorInfo(): void displayCpuInfo(): void displayKeyboardInfo(): void displayCost(): void AdvancedComputer displayMonitorInfo(): void displayCpuInfo(): void displayKeyboardInfo(): void displayCost(): void NullComputer productOperation1() productOperation2() ConcreteProduct FIGURE 6.2 UML.class.diagram.for.the.factory.method.design.pattern. Creational Design Patterns in Detailed Design  191 . 3.Design. the. factory. base. class. (e.g. ComputerStore). which. contains. one. abstract. factory.interface.method.for.delegating.product.creation.to.derived.classes.Product. creation.must.conform.to.the.interface.defined.in.Step.1. . 4.Design.one.or.more.concrete.factories.for.each.product.identified.in.Step.2. As.seen.in.the.applied.version.a.standard.computer.store.capable.of.displaying.computer. information.is.added.to.the.design.Displaying.computer.information.is.performed.with.

--- Chunk 342 ---
Tokens: 380
Type: sentence-based
Text:
information.is.added.to.the.design.Displaying.computer.information.is.performed.with. the.displayComputer().method.that.performs.operations.and.requests.services.using.the. computer.interface.Two.creator.classes.have.been.added.to.the.design.one.for.the.standard. computer.store.and.another.for.the.advanced.computer.store.As.seen.each.computer.store. is.associated.with.the.specific.product.that.it.supports.In.addition.a.NullComputer.class.is. added.to.ensure.that.computer.stores.do.not.return.null.pointers.to.clients.in.the.case.that. a.requested.computer.is.not.supported.by.a.particular.computer.store. Implementation Once.the.structural.design.is.complete.translating.it.to.code.is.straightforward.Listings 6.9. and.6.10.present.the.C.implementation.for.the.ComputerStore.class. As.seen.in.Listing.6.10.the.computer.store.displays.a.computers.information.by.relying. on.the.computer.product.interface.therefore.once.derived.computer.stores.override.the. factory.method.to.instantiate.and.return.objects.of.the.computer.types.supported.in.par- ticular.stores.the.displayComputer().method.will.display.the.computer.information. according.to.the.object.bound.to.it.at.run.time.Listing.6.11.presents.the.factory.method. code.for.a.standard.computer.store. Listing 6.9: Header File for the ComputerStore Class include string  Forward reference. class Computer;  The computer store creator class. This is an abstract class,  therefore to instantiate computer stores, specific derived  computer store classes are required.

--- Chunk 343 ---
Tokens: 378
Type: sentence-based
Text:
This is an abstract class,  therefore to instantiate computer stores, specific derived  computer store classes are required. class ComputerStore  public:  The standard factory method for creating computer products. virtual Computer createComputer(std:string type)  0;  Method to display a computers information. void displayComputer(std:string type); ; 192  Software Engineering Design As. seen. the. implementation. for. the. factory. method. for. standard. computer. stores. supports. only. standard. computers. Internally. objects. of. type. StandardComputer can.use.the.abstract.factory.design.pattern.from.Listings.6.4.and.6.5.to.create.the.stan- dard. computer. which. is. common. in. many. practical. applications. To. remain. concise. this.part.of.the.problem.is.not.presented.in.this.example.however.to.accomplish.this. the. design. of. the. StandardComputer. class. would. require. an. association. with. the. StandardComputerPartsFactory.from.the.previous.section. With.this.association. the.standard.computer.parts.factory.is.used.inside.the.StandardComputer.object.to. create.standard.products.such.as.standard.monitor.keyboard.and.CPU.In.many.prac- tical.applications.both.factory.method.and.abstract.factory.design.patterns.are.used.in. conjunction.for.providing.extensible.and.reusable.code.To.support.new.products.at.the. standard.computer.store.the.factory.method.can.be.modified.with.different.conditional. statements.for.creating.the.new.product.therefore.changes.to.support.new.products.at.a.

--- Chunk 344 ---
Tokens: 400
Type: sentence-based
Text:
statements.for.creating.the.new.product.therefore.changes.to.support.new.products.at.a. specific.computer.store.are.compartmentalized.and.do.not.affect.all.other.computer.stores. Benefits . Separates.code.from.product-specific.classes.therefore.the.same.code.can.work.with. various.existing.or.newly.created.product.classes. . By.separating.the.code.development.becomes.efficient.since.different.developers.can. work.on.the.different.parts.of.the.project.at.the.same.time. . By.separating.the.code.it.becomes.easier.to.reuse.and.maintain.specific.parts.of.the.code. Listing 6.10: Source File for the ComputerStore Class include Computer.h  Method to display a computers information. void ComputerStore:displayComputer(string type)   Delegate the responsibility of creating a computer object to  derived classes using the factory method. Computer computer  createComputer(type);  Display the computer information, including its cost. This  information varies according to the factory object used to create  the computer. computer-displayMonitorInfo(); computer-displayCpuInfo(); computer-displayKeyboardInfo(); computer-displayCost();  Do more stuff with the computer object here. Clean up the pComputer and pFactory objects when done. Creational Design Patterns in Detailed Design  193 Skill Development 6.2: Factory Method Design Pattern Using. the. UML. tool. of. choice. replicate. the. UML. model. presented. in. Figure 6.2. and.generate.code.from.the.model.Using.the.IDE.of.choice.fill.in.the.gaps.in.the. code. generated. using. Listings. 6.9. and. 6.11. and. compile. and. execute. the. software.

--- Chunk 345 ---
Tokens: 388
Type: sentence-based
Text:
software. Once. the. software. .executes. go. back. to. the. UML. model. and. add. a. third. factory. SpecialComputerStore. that. carries. SpecialComputers. Repeat. the. code. generation.process.fill.in.the.gaps.of.the.new.generated.code.compile.and.execute. When.complete.explain.the.steps.required.to.make.this.new.modification.and.how.the. factory.method.design.pattern.made.this.change.easy.or.hard. BUILDER The. builder. design. pattern. is. an. object. creational. pattern. that. encapsulates. both. the. .creational.process.and.the.representation.of.product.objects.Unlike.the.abstract.factory. Listing 6.11: Implementation of the Factory Method for the Standard Computer Store  Implement the factory method. Computer StandardComputerStore:createComputer(string type)   Pointer to a computer object. Computer computer;  Determine which computer needs to be created. if( type.compare(standard)  0   Create the StandardComputer. Clients are responsible for  cleaning up the memory for the computer object. Internally,  StandardComputer uses StandardComputerPartsFactory to create  a standard computer. computer  new StandardComputer;  else   Create and return a null computer. computer  new NullComputer;   Return the newly created computer object. Clients are responsible  for cleaning up the computer object. return computer;  194  Software Engineering Design design.pattern.in.which.various.product.objects.are.created.all.at.once.the.builder.design. pattern.allows.clients.to.control.the.(multistep).creational.process.of.a.single.product.object.

--- Chunk 346 ---
Tokens: 384
Type: sentence-based
Text:
pattern.allows.clients.to.control.the.(multistep).creational.process.of.a.single.product.object. allowing.them.to.dictate.the.creation.of.individual.parts.of.the.object.at.discrete.points. throughout.software.operations.To.accomplish.this.the.builder.design.pattern.introduces. a.creator.class.(i.e.the.builder).that.species.the.(abstract).interface.methods.required.to. build.a.particular.product.These.methods.are.used.to.build.parts.of.a.product.and.once. all.parts.of.the.product.are.created.(using.the.builder.interface).clients.can.request.the. builder.to.return.the.created.object.as.a.whole.Since.the.creation.of.the.product.object.is. delegated.to.the.concrete.builder.objects.the.products.representation.can.vary.accord- ing.to.the.specific.concrete.builder.creating.the.object.This.provides.added.flexibility.for. managing.the.creational.process.and.representation.of.products.that.is.not.present.in.other. creational.patterns.According.to.the.Gang.of.Four.(Gamma.et.al.1995.p.97).the.intent. of.the.builder.is.to Separate.the.construction.of.a.complex.object.from.its.representation.so.that.the.same.con- struction.process.can.create.different.representations. The.idea.of.separating.the.process.of.constructing.objects.from.their.representations. is.essential.when.considering.using.the.builder.design.pattern.Consider.a.clientserver. system.consisting.of.three.clients.that.work.in.a.distributed.fashion.and.report.to.a.central- ized.server.The.server.can.request.status.from.all.three.clients.compile.the.status.received.

--- Chunk 347 ---
Tokens: 369
Type: sentence-based
Text:
system.consisting.of.three.clients.that.work.in.a.distributed.fashion.and.report.to.a.central- ized.server.The.server.can.request.status.from.all.three.clients.compile.the.status.received. into.an.object.of.the.Message.type.and.forward.it.for.further.processing.within.the.server. system.In.this.scenario.the.creational.process.of.the.Message.object.depends.on.receiving. information.from.three.different.clients.Once.information.from.the.first.client.is.received. the.part.of.the.Message.object.that.contains.information.about.this.client.can.be.created. Similarly.once.information.from.the.second.and.third.clients.is.received.the.parts.of.the. Message.object.that.require.this.information.can.be.built.Once.all.parts.of.the.Message. object.are.built.the.Message.object.can.be.forwarded.to.the.rest.of.the.system.In.this. example.two.important.characteristics.should.be.noted.First.the.Message.object.cannot. be.instantiated.all.at.once.therefore.a.finer-grained.method.of.Message.construction.is. required.so.that.events.occurring.at.discrete.points.in.time.can.be.used.to.build.individual. parts.of.the.Message.object.The.second.important.and.perhaps.more.important.charac- teristic.is.the.fact.that.the.multistep.process.that.allows.for.the.construction.of.the.Message. object.is.the.same.regardless.of.the.representation.of.the.Message.object.In.this.exam- ple.the.Message.object.can.be.forwarded.within.the.server.system.using.a.binary.format. Extensible.Markup.Language.

--- Chunk 348 ---
Tokens: 391
Type: sentence-based
Text:
Extensible.Markup.Language. (XML).or.any.other.custom-defined.format.A.major.prac- tical.benefit.can.be.gained.by.separating.the.construction.process.of.objects.from.their. representation.Since.objects.using.the.builder.design.pattern.can.be.constructed.one.step. at.a.time.complex.algorithms.necessary.to.create.these.objects.can.be.separated.from.the. actual.construction.of.objects.so.that.the.same.algorithms.can.be.used.to.build.different. representations.of.an.object.This.results.in.code.that.can.evolve.to.provide.new.representa- tion.of.objects.by.adding.new.builder.classes.without.modifying.the.code.for.the.algorithm. used.for.creating.objects. Creational Design Patterns in Detailed Design  195 Problem A.company.develops.software.to.monitor.and.control.custom-built.hardware.developed. by.a.separate.vendor.The.equipment.supports.100.different.messages.defined.using.a. custom-defined.interface.control.document. (ICD).Every.time.the.messaging.specifica- tion.changes.the.code.that.represents.all.100.messages.has.to.be.changed.manually.The. company.has.decided.to.develop.a.message.generator.that.reads.the.message.specifica- tion.document.finds.the.appropriate.information.for.each.message.and.generates.code. to.represent.them.This.way.once.the.ICD.changes.all.the.company.has.to.do.is.regen- erate. the. messages. Currently. the. software. for. monitoring. and. control. is. developed. in.C.so.the.message.generator.generates.C.code.However.the.need.for.creating. .message.libraries.for.both.Java.C.and.other.languages.is.being.evaluated.This.means.

--- Chunk 349 ---
Tokens: 366
Type: sentence-based
Text:
.message.libraries.for.both.Java.C.and.other.languages.is.being.evaluated.This.means. that.changes.to.the.ICD.will.require.message.regeneration.for.all.supported.languages. The.software.company.wants.a.design.for.the.message.generator.that.separates.the.algo- rithm.for.parsing.the.messaging.specification.from.the.code.that.generates.classes.for. the.messages.in.specific.programming.languages.(e.g.C.Java).This.way.changes. to.the.messaging.specification.will.not.affect.the.code.that.generates.the.messages.in. specific.programming.languages.and.vice.versa.changes.or.addition.to.support.new. programming.language.generation.will.not.affect.the.code.that.parses.the.messaging. specification.To.keep.track.of.changes.in.the.ICD.and.messaging.libraries.the.company. also.wants.to.keep.history.and.statistics.of.code.generation.such.as.build.number.build. date.number.of.methods.generated.and.number.of.classes.generated. Structure The. general. and. applied. structural. view. of. the. builder. design. pattern. for. the. message. builder.problem.is.presented.in.Figure 6.3.In.the.general.view.of.the.patterns.structure. notice.that.the.association.with.the.Product.class.and.the.method.for.returning.the. product.are.specified.in.the.ConcreteBuilder.class.In.many.practical.situations.the. products.being.built.can.have.dissimilar.interfaces.therefore.making.it.difficult.to.add. the.interface.method.that.returns.the.product.in.the.AbstractBuilder.base.class.and.

--- Chunk 350 ---
Tokens: 389
Type: sentence-based
Text:
the.interface.method.that.returns.the.product.in.the.AbstractBuilder.base.class.and. reducing.flexibility.in.code.In.the.message.builder.example.since.the.products.gener- ated.can.be.represented.using.the.same.interface.the.method.that.returns.the.product. (i.e, getGeneratedProduct()).is.moved.to.the.base.class.so.that.client.code.can.rea- son.about.builders.in.terms.of.the.AbstractBuilder.interface.and.not.based.on.con- crete.builders.The.creational.process.is.represented.using.the.builder.base.class.which. delineates.the.creational.process.using.abstract.interface.methods.For.each.identified.rep- resentation.of.the.product.a.class.is.created.that.inherits.from.the.builder.base.class.These. classes.provide.the.specific.creational.details.for.their.particular.representation.Finally. builders.are.associated.with.the.product.class.to.generate.the.information.required.to.build. the.product.as.a.whole. There.are.two.main.driving.forces.behind.the.application.of.the.builder.design.pattern. to.the.message.builder.problem.First.since.messages.are.generated.from.a.document.the. 196  Software Engineering Design sections.in.the.document.that.specify.the.parts.of.a.particular.message.may.be.scattered. throughout.the.document.therefore.the.message.object.may.not.be.able.to.be.created.all.at. once.Second.the.processing.of.the.ICD.file.is.the.same.regardless.of.the.target.program- ming.language.used.for.generating.messaging.code.This.means.that.the.same.parsing. algorithm.can.be.used.to.identify.the.key.document.elements.used.for.code.generation.

--- Chunk 351 ---
Tokens: 224
Type: sentence-based
Text:
algorithm.can.be.used.to.identify.the.key.document.elements.used.for.code.generation. regardless.of.the.target.language.Once.these.characteristics.are.identified.a.step-by-step. approach.can.be.used.to.design.the.builder.design.pattern.The.steps.for.applying.the. builder.design.pattern.are.as.follows: . 1.Identify.and.design.the.product.class.(e.g.GeneratedProduct). . 2.Identify.the.products.creational.process.and.algorithm.and.design.a.class.for.its.exe- cution.(e.g.CodeGenerator).Each.creational.step.(when.necessary).must.be.made.in. terms.of.a.standard.product.builder.interface.(instead.of.concrete.product.interface). . 3.Using.the.knowledge.acquired.from.Steps.1.and.2.design.the.builder.interface.which. specifies.the.parts.that.need.to.be.created.for.the.whole.object.to.exist.These.are.captured. as.abstract.interface.methods.that.need.to.be.implemented.by.derived.concrete.builders.

--- Chunk 352 ---
Tokens: 394
Type: sentence-based
Text:
as.abstract.interface.methods.that.need.to.be.implemented.by.derived.concrete.builders. interface AbstractBuilder buildProductPartA() buildProductPartB() buildProductPartC() ConcreteBuilder buildProductPartA() buildProductPartB() buildProductPartC() getProduct() Director construct() CodeGenerator generateCode(): void MessageBuilder buildNewClass(name: stiring): void buildClassAttributes(attributes: string): void buildClassOperations(operations: string): void closeClass(): void getFileExtension(): string getGeneratedProduct(): GeneratedProduct buildNewClass(name: string): void buildClassAttributes(attributes: string): void buildClassOperations(operations: string): void closeClass(): void getFileExtension(): string buildNewClass(name: string): void buildClassAttributes(attributes: string): void buildClassOperations(operations: string): void closeClass(): void getFileExtension(): string JavaMessageBuilder CppMessageBuilder GeneratedProduct addCode(code : string) getCode(): string getStats(): string getdate() string getBuild(): string getAttributes(): string getClasses() : string stats: string Product General View Application View FIGURE 6.3 UML.class.diagram.for.the.builder.design.pattern. Creational Design Patterns in Detailed Design  197 . 4.Identify. and. design. classes. for. the. different. representations. of. the. product. (e.g, CppMessageBuilder.and.JavaMessageBuilder).These.classes.realize.the.inter- face.from.Step.3.in.terms.of.the.particular.representations. When.using.the.builder.design.pattern.the.representation.of.each.object.is.encapsulated.

--- Chunk 353 ---
Tokens: 389
Type: sentence-based
Text:
When.using.the.builder.design.pattern.the.representation.of.each.object.is.encapsulated. in.one.or.more.concrete.builder.classes.therefore.adding.new.representation.can.be.done. easily.by.extending.the.design.and.not.modifying.existing.working.code. Implementation Using.the.structural.design.from.Figure 6.3.the.implementation.for.the.MesageBuilder. class.is.presented.in.Listing.6.12.As.seen.the.purpose.of.this.class.is.to.specify.the.creational. steps.required.for.the.generation.of.each.message.Since.messages.in.the.ICD.are.generated. as.classes.the.MessageBuilder.has.methods.for.creating.new.classes.adding.attributes. adding.methods.and.generating.code.for.closing.classes.(e.g.in.C.and.in.Java). and.retrieving.the.extension.used.for.the.generated.file.These.interface.methods.serve.as. indication.of.the.parts.required.to.create.a.whole.GeneratedProduct.object.By.sepa- rating.these.parts.into.multiple.interface.methods.the.creational.process.can.call.upon. them.individually.to.create.the.product.object.at.discrete.points.during.software.execution. when.information.becomes.available. Once.the.creational.parts.are.identified.and.incorporated.into.the.MessageBuilder. base.class.different.derived.classes.can.be.implemented.to.provide.the.required.object. representation. Since. this. behavior. is. incorporated. into. the. design. using. inheritance. the.number.of.representations.can.be.extended.easily.in.future.versions.of.the.software. Listing 6.13.presents.the.code.for.the.concrete.message.builder.that.generates.C.code.for. the.messages.

--- Chunk 354 ---
Tokens: 388
Type: sentence-based
Text:
the.messages. For.each.creational.method.in.the.CppMessageBuilder.class.the.parameters.passed. in.are.processed.and.transformed.to.C.code.before.adding.it.to.the.product.being.gener- ated.The.same.process.is.used.for.any.other.language.that.needs.to.be.supported.such.as. Java.or.C.Finally.the.algorithm.for.product.creation.is.created.and.encapsulated.using. the.CodeGenerator.class.As.seen.by.varying.the.builder.object.passed.to.the.code. generators.constructor.message.generation.can.occur.in.different.languages.as.presented. in.Listing.6.14. Benefits . The. builder. separates. an. objects. construction. process. with. its. representation. therefore.future.representations.can.be.added.easily.to.the.software. . Changes.to.the.existing.representation.can.be.made.without.modifying.the.code.for. the.creational.process. . The.builder.provides.finer.control.over.the.construction.process.so.that.objects.can.be. created.at.discrete.points.in.time. 198  Software Engineering Design Skill Development 6.3: Builder Design Pattern Using.pencil.and.paper.modify.the.UML.class.diagram.for.the.message.builder.prob- lem.to.include.message.generation.using.the.C.programming.language.Explain.the. steps.taken.and.how.the.addition.of.the.new.program.feature.impacts.the.existing. design.List.the.pros.and.cons.of.using.the.builder.design.pattern.for.this.problem. Listing 6.12: C Implementation of the MessageBuilder Class include string  Forward reference. class GeneratedProduct; class MessageBuilder  public:  The interface method for building a new class.

--- Chunk 355 ---
Tokens: 388
Type: sentence-based
Text:
class GeneratedProduct; class MessageBuilder  public:  The interface method for building a new class. virtual void buildNewClass(string name)  0;  The interface method for building class attributes. virtual void buildClassAttributes(string attributeList)  0;  The interface method for building class operations. virtual void buildClassOperations(string operationList)  0;  The interface method for closing a new class. virtual void closeClass()  0;  The file extension for the target programming language. virtual string getFileExtension()  0;  Return the generated product. GeneratedProduct getGeneratedProduct()  return _codeProduct;  private:  The product containing generated code and stats about code  generated. GeneratedProduct _codeProduct; ; Creational Design Patterns in Detailed Design  199 Listing 6.13: C Implementation for the Message Builder that Generates C class CppMessageBuilder : public MessageBuilder  public:  The interface method for building a new class. virtual void buildNewClass(string name)   Generate code for creating a class using CPP style and the  name argument. Once code is generated, add it to the product. getGeneratedProduct()-addCode(new C class code);   The interface method for building class attributes. virtual void buildClassAttributes(string attributeList)   For all items in attributeList, generate attributes using CPP  style and add them to the generated code. Once code is generated, add it to the product. getGeneratedProduct()-addCode(C attributes);   The interface method for building class operations.

--- Chunk 356 ---
Tokens: 387
Type: sentence-based
Text:
getGeneratedProduct()-addCode(C attributes);   The interface method for building class operations. virtual void buildClassOperations(string operationList)   For all items in operationList, generate operations using CPP  style and add them to the generated code. Once code is generated, add it to the product. getGeneratedProduct()-addCode(C operations);   The interface method for closing a new class. virtual void closeClass()   Generate code to close a class in Cpp, and add it to the  generated code. Once code is generated, add it to the product. getGeneratedProduct()-addCode(n;nn); ; 200  Software Engineering Design Listing 6.14: C Implementation for the CodeGenerator class CodeGenerator  public:  Constructor. CodeGenerator(MessageBuilder pBuilder) : m_pBuilder(pBuilder)   Assume a valid builder pointer. Notice that m_pBuilder is  initialized in the constructors initialization list above. The interface method for building a new class. virtual void generateCode(string fileName)   Open file for reading: fileName. while (  not end of file )   read next token in file. if( class name found)   Assume that variable className holds the name. m_pBuilder-buildNewClass(className);  else if( attribute list found)   Assume that attributeList contains the attributes m_pBuilder-buildClassAttributes(attributeList);  else if( operation list found)   Assume that operationList contains the operations. m_pBuilder-buildClassOperations(operationList);  Close the class. m_pBuilder-closeClass();    end while(  not end of file )  Close file: fileName.

--- Chunk 357 ---
Tokens: 395
Type: sentence-based
Text:
m_pBuilder-closeClass();    end while(  not end of file )  Close file: fileName. Create file using file extension from generated product object. write(m_pBuilder-getGeneratedProduct()-getCode());  Close file. logCodeGeneration(m_pBuilder-getGeneratedProduct());   end generateCode(.) private: MessageBuilder m_pBuilder; ; Creational Design Patterns in Detailed Design  201 PROTOTYPE The.prototype.design.pattern.is.a.class.creational.design.pattern.that.allows.clients.to.create. duplicates.of.prototype.objects.at.run.time.without.knowing.the.objects.specific.type. Previous.creational.design.patterns.such.as.abstract.factory.and.builder.required.two. distinct.set.of.classes.one.or.more.creational.classes.and.one.or.more.product.classes.to. support.the.creational.process.Unlike.these.in.which.creator.and.product.classes.were. separate.prototype.objects.are.both.creators.and.products.This.characteristic.allows.them. to.support.a.generic.interface.for.object.creation.while.having.the.capability.to.access.inter- nal.product.data.to.create.(deep).copies.of.prototypical.objects.These.copies.are.returned. to.clients.and.used.independently.from.the.original.prototype.object.According.to.the. Gang.of.Four. (Gamma.et.al.1995.p.117).the.intent.of.the.prototype.design.pattern.is.to Specify.the.kinds.of.objects.to.create.using.a.prototypical.instance.and.create.new.objects.by. copying.this.prototype. The.prototype.design.pattern.is.typically.used.when.clients.need.to.duplicate.products. at.run.time.without.regarding.how.products.are.created.or.their.specific.concrete.types.

--- Chunk 358 ---
Tokens: 395
Type: sentence-based
Text:
at.run.time.without.regarding.how.products.are.created.or.their.specific.concrete.types. This.allows.copies.from.a.variety.of.objects.within.the.same.class.hierarchy.to.be.created. uniformly.which.simplifies.client.code.and.adds.flexibility.to.designs. Problem Consider.the.enemy.component.created.for.a.gaming.system.The.detailed.design.of.the. enemy.component.includes.a.wide.variety.of.enemy.specifications.defined.for.the.game. each.including.different.profiles.and.weapons.The.game.designers.have.identified.the. need.to.have.each.character.provide.a.method.for.creating.copies.of.themselves.so.that. at.any.given.point.during.the.game.a.character.clone.can.be.made.including.identical. energy.level.weapons.and.profiles.This.functionality.is.required.to.develop.an.enemy. registry.of.different.Character.subtypes.to.create.and.add.enemies.at.any.point.dur- ing.the.game.Consider.the.initial.proposed.solution.to.the.problem.as.presented.in. Listing.6.15. As. seen. both. TerrestrialEnemyCharacter. and. AerialEnemyCharacter. have. been. designed.to.support.an.interface.method.for.duplication.of.objects.at.run.time.The.prob- lem.with.the.code.in.Listing.6.15.is.that.clients.are.required.to.know.about.the.specific. concrete.class.to.create.a.copy.of.each.different.character.Therefore.it.is.inefficient.to. design.an.enemy.character.registry.that.can.be.used.throughout.the.game.to.create.char- acters.uniformly.since.the.creational.process.requires.knowledge.about.the.particular. interface.method.for.duplicating.a.run-time.object.This.decreases.the.designs.flexibility.

--- Chunk 359 ---
Tokens: 398
Type: sentence-based
Text:
interface.method.for.duplicating.a.run-time.object.This.decreases.the.designs.flexibility. since.it.does.not.support.object.extension.without.code.modification.That.is.for.every. new.type.of.enemy.character.the.enemy.registry.code.for.creating.and.adding.characters. 202  Software Engineering Design to.the.game.needs.to.be.modified.for.including.the.new.character.This.problem.is.pre- sented.in.Listing.6.16. As.seen.the.code.required.to.create.copies.of.enemy.characters.using.the.enemy.regis- try.with.only.two.characters.is.quite.large.Consider.the.case.where.100.different.enemy. characters.are.designed.for.the.gaming.system.In.such.a.case.the.size.of.the.function. would.increase.significantly.since.a.conditional.statement.is.required.for.each.character. This.problem.can.be.solved.easily.by.using.a.prototypical.interface.for.creating.copies. that.does.not.require.clientsin.this.case.the.function.to.create.the.enemy.characterto. know.which.object.they.are.creating. Listing 6.15: C Implementation for the Terrestrial and Aerial Enemy Characters  The character interface. class Character  public: virtual void attack()  0;  Other methods such as defend, move, etc. ; class TerrestrialEnemyCharacter : public Character  public:  Method definitions for terrestrial attack, defend, etc. Duplicate this object. TerrestrialEnemyCharacter duplicateTerrestrial()   Use the copy constructor to create a copy of this object and  return it. return new TerrestrialEnemyCharacter (this);  ; class AerialEnemyCharacter : public Character  public:  Method definitions for aerial attack, defend, etc.

--- Chunk 360 ---
Tokens: 385
Type: sentence-based
Text:
return new TerrestrialEnemyCharacter (this);  ; class AerialEnemyCharacter : public Character  public:  Method definitions for aerial attack, defend, etc. Duplicate this object. AerialEnemyCharacter duplicateAerial()   Use the copy constructor to create a copy of this object and  return it. return new AerialEnemyCharacter(this);  ; Creational Design Patterns in Detailed Design  203 Listing 6.16: C Implementation of the Client that Creates New Enemy Character  Pre-Condition: A registry of 2 Enemy Characters has been created. Character createNextEnemyCharacter()   Randomly pick the location of the next enemy character to be  created. int nextEnemyLocation  rand()  MaxNumberOfEnemies;  Make sure that nextEnemyLocation is within proper bounds. Retrieve the character at the nextEnemyLocation. Character pCharacter  enemyRegistrynextEnemyLocation;  The enemy character to be returned. Character pNewCharacter  0;  Determine if the character located at nextEnemyLocation is  Terrestrial. if( dynamic_castTerrestrialEnemyCharacter(pCharacter) ! 0 )   Terrestrial Character, downcast it so that the  duplicateTerrestrial method can be used to duplicate the  terrestrial character. TerrestrialEnemyCharacter pTerrestrial  dynamic_castTerrestrialEnemyCharacter(pCharacter);  Create the copy. Clients are responsible for cleaning up memory  allocated for the copy. pNewCharacter  pTerrestrial-duplicateTerrestrial();   Determine if the character located at nextEnemyLocation is Aerial. else if( dynamic_castAerialEnemyCharacter(pCharacter) !

--- Chunk 361 ---
Tokens: 400
Type: sentence-based
Text:
else if( dynamic_castAerialEnemyCharacter(pCharacter) ! 0 )   Aerial Character, downcast it so that the duplicateAerial  method can be used to duplicate the aerial character. AerialEnemyCharacter pAerial  dynamic_castAerialEnemyCharacter(pCharacter);  Create the copy. Clients are responsible for cleaning up memory  allocated for the copy. pNewCharacter  pAerial-duplicateAerial();  else   Invalid Character. pNewCharacter  new InvalidEnemyCharacter;   Return the newly created enemy character. return pNewCharacter;  204  Software Engineering Design Structure The.general.and.applied.structural.view.of.the.prototype.design.pattern.for.the.gaming. system.problem.is.presented.in.Figure 6.4.As.seen.from.the.structural.point.of.view.the. only.thing.required.to.implement.the.prototype.design.pattern.is.the.addition.of.the.clone. interface.method.to.the.Character.type.By.adding.the.clone().method.in.the.char- acter.interface.the.behavior.for.creating.character.duplicates.throughout.the.game.is.stan- dardized.and.delegated.to.derived.classes.Therefore.by.deriving.from.this.base.class.and. implementing.the.clone.interface.derived.classes.can.abstract.the.process.of.creating.a. copy.of.themselves. The.driving.forces.behind.this.design.are.the.ability.of.client.objects.to.create.duplicates. of.character.objects.without.knowing.the.objects.internal.true.composition.and.providing. clients.the.ability.to.reason.about.character.objects.using.the.character.interface.Once.these. characteristics.are.identified.applying.the.prototype.design.pattern.is.straightforward. . 1.Identify. and. design. the.

--- Chunk 362 ---
Tokens: 384
Type: sentence-based
Text:
the. common. interface.that. needs. duplication.As. part.of. the. interface.the.clone.interface.method.needs.to.be.specified. . 2.Identify.and.design.concrete.products.which.realize.the.interface.created.in.Step.1. . 3.For.each.concrete.product.created.in.Step.2.implement.the.clone.method.in.terms.of. that.particular.concrete.product. interface Prototype clone(): Prototype ConcretePrototypeA clone(): Prototype GemeEngine createNextEnemyCharacter(): Character clone(): Character attack(): void TerrestrialEnemyCharacter clone(): Character attack(): void AerialEnemyCharacter clone(): Character attack(): void interface Character ConcretePrototypeB clone(): Prototype Client operation() General View Applied View FIGURE 6.4 UML.class.diagram.for.the.prototype.design.pattern. Creational Design Patterns in Detailed Design  205 Implementation From.the.structural.point.of.view.application.of.the.prototype.design.pattern.is.straight- forward.In.Listing.6.17.the.Character.interface.is.specified.which.includes.the.clone(). interface.method.By.specifying.the.clone.method.as.a.pure.virtual.method.derived.classes. are.forced.to.provide.an.implementation.before.they.can.be.instantiated.For.simplicity. Listing 6.17: C Implementation of the Terrestrial Character and New Character Interface  The character interface. class Character  public:  Interface method for initiating an attack. virtual void attack()  0;  Interface method for duplicating objects at run-time. virtual Character clone()  0;  Other methods such as defend, move, etc.

--- Chunk 363 ---
Tokens: 379
Type: sentence-based
Text:
virtual Character clone()  0;  Other methods such as defend, move, etc. ; class TerrestrialEnemyCharacter : public Character  public:  Method definitions for terrestrial attack, defend, etc. void attack()   Display to the console the type of attack. coutTerrestrialEnemyCharacter:attack()!n;   Duplicate this object. TerrestrialEnemyCharacter duplicateTerrestrial()   Use the copy constructor to create a copy of this object and  return it. return new TerrestrialEnemyCharacter (this);   Implementation of the clone interface method to duplicate a  terrestrial enemy character. Character clone(void)   Delegate duplication to existing method. return duplicateTerrestrial();  ; 206  Software Engineering Design (and.to.make.the.point.clearer).the.clone().method.is.implemented.in.terms.of.the.pre- viously.existing.duplicateTerrestrial().method.from.Listing.6.15.In.a.practical. development.effort.such.a.method.is.removed.so.that.the.clone.method.can.directly.create. the.objects.copy. As.seen.the.prototypes.clone.method.results.in.a.call.to.the.copy.constructor.In.this. example.the.C.default.copy.constructor.is.called.upon.to.create.a.copy.of.the.specific. character.object.However.careful.attention.must.be.in.place.when.copying.more.complex. objects.In.these.cases.where.the.default.copy.constructor.is.insufficient.to.provide.a.deep. copy.of.the.object.a.specialized.copy.constructor.must.be.provided.The.same.approach.for. creating.duplicates.is.repeated.for.the.AerialEnemyCharacter.as.seen.in.Listing.6.18.

--- Chunk 364 ---
Tokens: 382
Type: sentence-based
Text:
creating.duplicates.is.repeated.for.the.AerialEnemyCharacter.as.seen.in.Listing.6.18. Once.both.TerrestrialEnemyCharacter.and.AerialEnemyCharacter.imple- ment.the.clone.interface.the.client.code.presented.in.Listing.6.16.is.modified.to.randomly. create.enemy.characters.using.prototypical.instances.that.support.the.clone().method. as.seen.in.Listing.6.19.By.using.the.prototype.design.pattern.the.original.client.function.is. reduced.significantly.More.importantly.the.addition.of.new.enemy.characters.or.removal. Listing 6.18: C Implementation for the AerialEnemyCharacter class AerialEnemyCharacter : public Character  public:  Implement the attack interface method for aerial characters. void attack(void)   Display to the console the type of attack. coutAerialEnemyCharacter:attack()!n;   Duplicate this object. AerialEnemyCharacter duplicateAerial(void)   Use the copy constructor to create a copy of this object and  return it. return new AerialEnemyCharacter(this);   Implementation of the clone interface method to duplicate a  aerial enemy character. Character clone(void)   Delegate duplication to existing method. return duplicateAerial();  ; Creational Design Patterns in Detailed Design  207 of.existing.characters.will.not.affect.the.clients.implementation.This.provides.added.flex- ibility.to.support.change.in.future.versions.of.the.gaming.system. Benefits . Clients.are.shielded.from.knowing.the.internal.structure.of.objects.therefore.adding. products.at.run.time.is.easier.This.reduces.the.clients.complexity. .

--- Chunk 365 ---
Tokens: 394
Type: sentence-based
Text:
. Reduced.number.of.classes.instead.of.having.two.classes.for.object.creation.(i.e.creator. and.product.classes).the.prototype.is.both.therefore.eliminating.the.need.for.one.class. for.each.product. SINGLETON The.singleton.design.pattern.is.an.object.creational.design.pattern.used.to.prevent.objects. from.being.instantiated.more.than.once.in.a.running.program.It.is.meant.to.provide.a. design.solution.that.enforces.the.conceptual.representation.of.entities.that.must.be.sin- gular.within.the.problem.domain.For.example.consider.the.simulation.of.an.operat- ing.system.In.the.operating.systems.domain.the.simulation.software.may.contain.types. (i.e.classes).for.processes.threads.and.so.forth.that.can.be.instantiated.multiple.times.to. properly.represent.running.programs.within.the.simulation.In.these.cases.the.multiple. instantiation.of.these.types.is.conceptually.consistent.with.the.problem.domain.However. consider.an.entity.type.for.singular.items.such.as.the.file.system.In.this.case.for.a.typical. operating.system.it.would.be.conceptually.incorrect.to.have.multiple.file.system.object. instances.running.within.the.simulation.Furthermore.if.the.simulation.were.to.create. two.file.systems.by.mistake.the.results.would.not.be.reliable.In.cases.such.as.this.one.the. singleton.design.pattern.can.be.used.to.enforce.the.policy.that.only.one.instance.of.the.file. Listing 6.19: C Code for the Client that Creates New Characters Using the Prototype Interface Character createNextEnemyCharacter()   Randomly pick the location of the next enemy character to be  created.

--- Chunk 366 ---
Tokens: 391
Type: sentence-based
Text:
Listing 6.19: C Code for the Client that Creates New Characters Using the Prototype Interface Character createNextEnemyCharacter()   Randomly pick the location of the next enemy character to be  created. int nextEnemyLocation  rand()  MaxNumberOfEnemies;  Make sure that nextEnemyLocation is within proper bounds. Retrieve the character at the nextEnemyLocation. return enemyRegistrynextEnemyLocation-clone();  208  Software Engineering Design system.object.is.running.at.all.times.According.to.the.Gang.of.Four.(Gamma.et.al.1995. p.127).the.intent.of.the.singleton.is.to Ensure.a.class.only.has.one.instance.and.provide.a.global.point.of.access.to.it. Since.the.singleton.limits.object.creation.to.one.instance.it.is.important.that.the.one. instance.can.be.accessible.through.a.standard.method.Therefore.the.singleton.design.pat- tern.also.provides.a.global.point.of.access.to.it. Problem Consider.an.application.that.requires.event-logging.capabilities.The.application.consists.of. many.different.objects.that.generate.events.to.keep.track.of.their.actions.status.of.opera- tions.errors.or.any.other.information.of.interest.A.decision.is.made.to.create.an.event. manager.that.can.be.accessed.by.all.objects.and.used.to.manage.all.events.in.the.system. Upon.instantiation.the.event.manager.creates.an.event.list.that.gets.updated.as.events.are. logged.At.specific.points.during.the.software.systems.operation.these.events.are.written. to.a.file.To.prevent.conflicts.it.is.desirable.that.at.any.given.time.there.is.only.one.instance. of.the.event.manager.executing.

--- Chunk 367 ---
Tokens: 387
Type: sentence-based
Text:
of.the.event.manager.executing. Structure The.general.and.applied.structural.view.of.the.singleton.design.pattern.for.the.event.man- ager.is.presented.in.Figure 6.5.As.seen.from.the.structural.point.of.view.the.singleton.is. the.simplest.design.pattern.since.it.requires.only.one.class.The.driving.force.behind.this. General View Application View instance_: Singleton operation() Singleton() getInstance(): Singleton Singleton instance : EventManager EventManager() getInstance(): EventManager logEvent(eventDescription: string): void EventManager FIGURE 6.5 UML.class.diagram.for.the.singleton.design.pattern. Creational Design Patterns in Detailed Design  209 design.is.the.ability.for.clients.to.have.global.access.to.the.event.manager.and.the.assurance. that.there.is.only.one.instance.of.the.event.manager.at.all.times.Assuming.a.single-threaded. application.these.characteristics.are.typically.a.good.indication.for.applying.the.singleton. design.pattern.To.apply.the.singleton.design.pattern.a.three-step.approach.is.employed: . 1.Set.the.visibility.of.the.constructor.to.private. . 2.Define.a.private.static.member.attribute.that.can.store.a.reference.(or.pointer).to.the. one.instance.of.the.singleton. . 3.Create.a.public.static.getInstance.method.that.can.access.the.private.constructor. to.instantiate.objects.of.the.singleton.type.and.return.it.to.clients. When.designing.singletons.the.class.constructor.needs.to.be.specified.as.private.to.pre- vent.clients.from.instantiating.objects.of.the.singleton.type.via.the.direct.access.to.the.

--- Chunk 368 ---
Tokens: 387
Type: sentence-based
Text:
When.designing.singletons.the.class.constructor.needs.to.be.specified.as.private.to.pre- vent.clients.from.instantiating.objects.of.the.singleton.type.via.the.direct.access.to.the. constructor.Since.access.to.the.constructor.is.prohibited.the.second.step.involves.creating. a.method.that.can.access.the.private.constructor.to.instantiate.objects.of.the.singletons. type.This.method.needs.to.be.a.class.method.(i.e.static).so.that.it.can.be.called.at.the.class. level.without.instantiating.an.object.of.the.class.This.is.done.by.specifying.the.method.as. static.with.public.visibility.Finally.a.private.static.member.attribute.that.can.store.a.refer- ence.or.pointer.to.the.running.instance.of.the.singleton.needs.to.be.created.to.keep.track. of.the.one.and.only.one.instance.of.the.singleton.This.attribute.is.initially.set.to.zero.or. null.and.once.a.call.to.the.getInstance().method.is.made.the.attribute.is.checked.to. determine.if.the.instance.of.the.singleton.has.been.created.If.it.hasnt.the.method.instanti- ates.it.and.returns.it.to.the.caller.After.the.first.initialization.process.further.calls.to.the. getInstance().method.will.fail.the.condition.that.determines.that.the.attribute.is.null. therefore.directly.returning.the.existing.singleton.object. Implementation As.specified.before.the.implementation.of.the.singleton.consists.of.three.main.steps.First. the.visibility.of.the.constructor.needs.to.be.private.to.prevent.direct.instantiation.from. .clients.Next.a.public.class.(static).member.function.must.be.created.to.provide.clients.

--- Chunk 369 ---
Tokens: 375
Type: sentence-based
Text:
.clients.Next.a.public.class.(static).member.function.must.be.created.to.provide.clients. with.a.globally.accessible.function.for.the.singleton.Finally.the.globally.accessible.func- tion.must.instantiate.the.singleton.object.while.enforcing.that.only.one.instance.is.created. throughout. program. The. C. implementation. of. the. EventManager. singleton. class. is. .presented.in.Listings.6.19.and.6.20. Once.the.singleton.design.pattern.is.applied.to.the.EventManager.client.objects.can. use.it.easily.via.the.standardized.and.globally.accessible.getInstance().method.as. presented.in.Listing.6.21. The.singleton.design.pattern.has.been.known.to.fail.in.multithreaded.applications.result- ing.in.the.creation.of.more.than.one.instance.of.the.singleton.Therefore.its.usage.in.these. types.of.environments.should.be.carefully.evaluated.before.implementation. 210  Software Engineering Design Listing 6.19: C Header File for the EventManager Singleton include string class EventManager  public:  The global point of access to the EventManager. static EventManager getInstance();  The method that logs events. void logEvent(std:string eventDescription); private:  Private Constructor. EventManager();  The one and only instance of the EventManager. static EventManager _instance; ; Listing 6.20: C Source File for the EventManager Singleton include EventManager.h  Initialize the instance_ static member attribute. EventManager EventManager:_instance  0;  The global point of access to the EventManager.

--- Chunk 370 ---
Tokens: 382
Type: sentence-based
Text:
EventManager EventManager:_instance  0;  The global point of access to the EventManager. EventManager EventManager:getInstance()   Determine if an instance of the EventManager has been created. if( _instance  0 )   Create the one and only instance. _instance  new EventManager;  return _instance;   The method that logs events. void EventManager:logEvent(std:string eventDescription)   Code to log event. Private Constructor. EventManager:EventManager()   Intentionally left blank. Creational Design Patterns in Detailed Design  211 Benefits . The.singleton.provides.controlled.access.to.a.single.instance.of.a.given.type. . It.has.reduced.name.space.since.it.provides.an.alternative.to.global.variables. . It.can.be.customized.to.permit.variable.number.of.instances. CHAPTER SUMMARY Creational.design.patterns.are.patterns.for.abstracting.and.controlling.the.way.objects.are. created.in.software.applications.They.play.a.key.role.in.the.design.of.systems.by.making.them. independent.of.how.objects.in.the.system.are.created.composed.and.represented.Therefore. parts.of.the.system.responsible.for.creating.(or.instantiating).objects.do.so.through.a.common. creational.interface.without.knowledge.of.how.the.actual.object.or.group.of.objects.are.created. In.addition.by.controlling.the.creational.process.with.a.common.interface.enforcing.cre- ational.policies.becomes.easier.therefore.giving.the.system.the.ability.to.create.product.objects. that.share.a.common.interface.but.that.vary.widely.in.structure.and.behavior.Examples.

--- Chunk 371 ---
Tokens: 399
Type: sentence-based
Text:
that.share.a.common.interface.but.that.vary.widely.in.structure.and.behavior.Examples. of.creational.patterns.include.the.abstract.factory.factory.method.builder.prototype.and. singleton.This.chapter.explored.several.well-established.creational.design.patterns.and.pre- sented.the.problems.they.are.designed.to.address.together.with.the.benefits.that.each.of.the. discussed.patterns.provides.Identifying.and.designing.using.creational.design.patterns.can. improve.the.efficiency.of.the.development.process.and.the.quality.of.the.final.system. REVIEW QUESTIONS . 1.What.are.creational.design.patterns.What.are.they.used.for? . 2.Compare.and.contrasts.the.following.patterns: . a. Abstract.factory . b. Factory.method Listing 6.21: C Implementation for Client Objects Using the EventManager Singleton int main()   Log events using the singleton event manager. EventManager:getInstance()-logEvent(log some event here);  Or store the pointer to log events later. EventManager pEventManager  EventManager:getInstance(); pEventManager-logEvent(log some event here);  212  Software Engineering Design . c. Builder . d. Prototype . 3.List.and.explain.the.benefits.of.applying.the.abstract.factory.design.pattern. . 4.What.is.the.builder.design.pattern.List.and.explain.the.main.features.of.the.builder. design.pattern. . 5.What.particular.problems.are.addressed.by.the.builder.design.pattern? . 6.What.is.the.essential.structural.element.required.in.the.prototype.design.pattern? . 7.Explain.the.steps.required.to.implement.the.singleton.design.pattern.Are.there.any. limitations.to.this.pattern.Explain.

--- Chunk 372 ---
Tokens: 374
Type: sentence-based
Text:
limitations.to.this.pattern.Explain. CHAPTER EXERCISES . 1.A. company. is. designing. software. for. monitoring. and. controlling. a. custom-built. system.consisting.of.multiple.hardware.components.(i.e.Equipment1.Equipment2. and. Equipment3). Each. equipment. component. provides. unique. status. unique. commands. and. specific. interface. for. communicating. such. as. a. Universal. Serial. Bus.(USB).Serial.and.Transmission.Control.ProtocolInternet.Protocol.(TCPIP). Regardless.of.the.communication.type.each.class.representing.an.equipment.must. provide. functionality. to. get. specific. status. (e.g. getEquipmentOneStatus1. getE- quipmentTwoStatus1).and.send.specific.commands.to.the.device. (e.g.sendEquip- mentOneCmd1.sendEquipmentTwoCmd1).The.software.provides.a.graphical.user. interface. (GUI).that.polls.each.hardware.component.for.its.status.data.and.also.pro- vides.means.for.sending.commands.to.the.components.Since.hardware.development. is.expected.to.take.longer.than.the.expected.GUI.development.management.has. decided.to.simulate.the.components.so.that.GUI.development.and.testing.can.move. forward.That.is.there.are.two.streams.of.equipments.real.equipment.composed.of. Equipment1.Equipment2.and.Equipment3.and.simulated.equipments.composed. of.SimEquipment1.SimEquipment2.and.SimEquipment3.Design.this.system.using. the.abstract.factory.design.pattern.so.that.the.GUI.software.can.work.the.same.way. using.real.or.simulated.components.regardless.of.the.type.of.component. .

--- Chunk 373 ---
Tokens: 392
Type: sentence-based
Text:
. 2.Your.company.develops.software.to.monitor.and.control.custom-built.hardware.devel- oped.by.a.separate.vendor.The.equipment.supports.100.different.messages.defined. with.the.format.specified.in.the.following.box.Every.time.the.messaging.specifica- tion.changes.the.code.for.all.100.messages.has.to.change.manually.To.make.things. worse.your.company.supports.two.versions.of.the.software.one.in.Java.and.one.in. C.so.these.changes.must.be.made.to.both.versions.In.addition.there.are.future. plans.for.providing.a.messaging.library.in.C.as.well.based.on.the.messaging.specifica- tion.Clearly.there.has.to.be.a.more.efficient.way.to.manage.this.process.Management. has.asked.you.the.design.team.to.come.up.with.a.design.that.separates.the.algorithm. for.parsing.the.messaging.specification.from.the.code.that.generates.classes.for.the. Creational Design Patterns in Detailed Design  213 messages.in.a.specific.programming.language.(e.g.Java.or.C).This.way.changes. to.the.messaging.specification.will.not.affect.the.code.that.generates.the.messages.in. specific.programming.languages.and.vice.versa.that.is.changes.or.additions.to.support. new.programming.language.generation.will.not.affect.the.code.that.parses.the.messag- ing.specification.A.sample.of.the.messaging.specification.containing.three.messages.is. given.to.you.so.that.you.can.propose.a.design.that.can.improve.the.code.generation.pro- cess.Management.would.be.thrilled.if.your.design.would.support.different.generators. (at.run.time).capable.of.producing.the.messages.in.different.programming.languages.

--- Chunk 374 ---
Tokens: 395
Type: sentence-based
Text:
(at.run.time).capable.of.producing.the.messages.in.different.programming.languages. That.way.by.swapping.generators.different.programming.languages.can.be.supported. The.generated.code.should.provide.get().and.set().methods.for.all.attributes. . 3.Apply.the.builder.design.pattern.to.design.this.system. . 4.Use.the.tool.of.your.choice.(e.g.rational.rose.starUML.MS.PowerPoint.Visio).to. create.the.UML.class.diagram.for.the.problem . 5.Write.code.in.C.to.demonstrate.the.implementation.of.your.design.Your.pro- gram.must.create.files.containing.Java.or.C.code.for.the.generated.messages. depending.on.the.builder.used. Messaging Specification Sample Name:PowerOnCmd; Attributes:4; byte:headerSize; byte:msgId; byte:sourceId; byte:destinationId; Operations:0; Name:SelfTestCmd Attributes:5; byte:headerSize; byte:msgId; byte:sourceId; byte:destinationId; byte:testId; Operations:0; Name:SetDataCmd; Attributes:6; byte:headerSize; byte:msgId; byte:sourceId; byte:destinationId; byte:dataType; byte:dataSize; Operations:2; byte,getData,void; void,setData,byte; 214  Software Engineering Design . 6.Prepare.a.10-.to.15-minute.PowerPoint.presentation.consisting.of.the.following: . a. Introduction.to.the.problem . b. Solution.approach. (UML.class.diagram) . c. Presentation.of.the.builder.code . d. Demo.of.the.program . e. Be.ready.to.state your assumptions.and.to.justify.and.defend.all.of.your.design. decisions. REFERENCE Gamma. Erich. Richard. Helm. Ralph. Johnson. and. John. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software.Boston.Addison-Wesley.1995.

--- Chunk 375 ---
Tokens: 397
Type: sentence-based
Text:
Design Patterns: Elements of Reusable Object-Oriented Software.Boston.Addison-Wesley.1995. 215 7 Structural and Behavioral Patterns in Detailed Design CHAPTER OBJECTIVES . Understand. the. importance. and. role. of. structural. and. behavioral. design.patterns.in.detailed.design . Identify.understand.and.model.common.structural.and.behavioral. design.patterns . Become. proficient. in. implementing. models. of. both. structural. and. behavioral.design.patterns . Understand.the.benefits.of.important.structural.and.behavioral.design. patterns CONCEPTUAL OVERVIEW As. seen. in. the. previous. chapter. common. patterns. in. object-oriented. designs.exist.to.provide.detailed.design.solutions.to.problems.that.recur. many.times.over.in.different.systems.Beside.the.creational.design.patterns. studied.so.far.other.common.and.popular.design.patterns.have.been.iden- tified.to.address.structural.and.behavioral.problems.commonly.encoun- tered.in.software.applications.Structural.and.behavioral.designs.patterns. help.identify.problems.that.deal.with.the.structure.and.behavior.of.software. designs.they.prescribe.the.classes.required.for.their.design.solution.and. interrelationships.required.to.support.object.creation.their.behavior.These. patterns.allow.designers.to.quickly.and.systematically.identify.structural. layouts.of.systems.(or.subsystems).and.provide.avenues.for.examining.the. systems.interactions.and.quality.evaluation.within.the.operational.system. 216  Software Engineering Design This.chapter.explores.several.well-established.structural.and.behavioral.design.patterns.

--- Chunk 376 ---
Tokens: 384
Type: sentence-based
Text:
216  Software Engineering Design This.chapter.explores.several.well-established.structural.and.behavioral.design.patterns. and.examines.the.problems.they.are.designed.to.address.together.with.the.benefits.they. provide.Identifying.and.designing.using.these.design.patterns.can.improve.the.efficiency. of.the.development.process.and.the.quality.of.the.final.system. STRUCTURAL DESIGN PATTERNS Structural.design.patterns.are.patterns.that.deal.with.designing.larger.structures.from. existing.classes.or.objects.at.run.time.They.play.a.key.role.in.the.design.and.evolution.of. systems.by.allowing.integration.of.new.designs.with.existing.ones.via.object.composition. (i.e.object.structural).or.inheritance.(i.e.class.structural).Class.structural.design.patterns. identify.the.inheritance.relationship.necessary.to.create.new.interfaces.or.implementa- tions.that.may.be.compatible.with.the.older.design.structure.Object.structural.patterns. provide.the.relationships.required.to.create.larger.structures.through.object.composition. at.run.time.therefore.providing.more.flexibility.to.extend.the.system.at.run.time.which. is.impossible.for.class.structural.solutions.In.both.cases.by.allowing.designs.to.build.on. other. existing. structures. systems. can. be. made. interoperable. by. designing. compatible. interfaces.for.otherwise.incompatible.systems.Structural.design.patterns.have.also.signifi- cant.impact.on.the.reusability.and.modifiability.of.systems.Examples.of.structural.design. patterns.include.the.adapter.composite.and.facade.

--- Chunk 377 ---
Tokens: 388
Type: sentence-based
Text:
patterns.include.the.adapter.composite.and.facade. ADAPTER The.adapter.design.pattern.is.a.classobject.structural.design.pattern.used.to.adapt.an.exist- ing.interface.to.another.interface.that.is.expected.in.a.software.system.It.can.be.designed. as.both.class.structural.in.which.the.major.composition.relationships.are.defined.at.com- pile.time.and.object.structural.where.structural.object.composition.occurs.at.run.time. In either. case. the. adapter. design. pattern. allows. systems. with. incompatible. interfaces. to.work.together.therefore.increasing.the.reusability.and.evolution.of.software.systems. According.to.the.Gang.of.Four.(Gamma.Elm.Johnson.and.Vlissides.1995.p.139).the. intent.of.the.adapter.is.to Convert.the.interface.of.a.class.into.another.interface.clients.expect.Adapter.lets.classes.work. together.that.couldnt.otherwise.because.of.incompatible.interfaces. Conceptually. adapters. are. used. everywhere. For. example. electrical. adapters. can. be.used.to.connect.devices.with.incompatible.interfaces.such.as.European.plugs.and. American. sockets. In. gardening. adapters. are. used. to. connect. water. hoses. with. Structural and Behavioral Patterns in Detailed Design  217 incompatible.interfaces.to.extend.their.reach.In.computer.hardware.adapters.are.used. to.covert.between.many.different.interfaces.such.as.serial.to.Universal.Serial.Bus.(USB). In.software.the.adapter.concept.is.applied.similar.to.adapters.in.the.previous.examples. Consider.the.graphical.user.interface.(GUI).for.an.application.to.monitor.and.control.

--- Chunk 378 ---
Tokens: 399
Type: sentence-based
Text:
Consider.the.graphical.user.interface.(GUI).for.an.application.to.monitor.and.control. a.satellite.communication.system.composed.of.several.independent.hardware.devices. For. each. hardware. device. complex. GUI. screens. are. designed. to. monitor. and. con- trol.each.device.All.screens.rely.on.a.class.named.HardwareDevice.that.provides. methods. (e.g.string getStatusA(), string getStatusB()).designed.and.developed.assuming. that.commands.and.status.for.each.device.use.the.string.type. (in.C).When.receiv- ing. the. hardware. devices. from. their. manufacturers. and. the. binary. compiled. library. that.provides.monitor.and.control.capabilities.for.each.device.it.is.noticed.that.the.class. ManufacturerHardwareDevice. (provided.by.the.manufacturer).provides.all.func- tions. for. command. and. control. using. the. char. type. or. other. nonstring. type. which. creates.an.incompatible.interface.between.the.existing.GUI.code.and.the.library.code. Since.the.code.inside.the.library.cannot.be.changed.and.changing.the.code.for.all.screens. (.depending.on.the.number.of.screens).may.be.impractical.the.provided.class.in.the.binary. library.can.be.adapted.using.the.adapter.design.pattern.to.fit.the.expected.interfaces.in. the.GUI.software.or.vice.versa. Problem Consider. the. completed. gaming. system. discussed. in. Chapter. 5. which. includes. the. design.and.development.for.all.10.levels.of.a.gaming.system.including.the.design.and. implementation.of.all.gaming.characters.At.each.level.the.core.of.the.gaming.system. (i.e, GameEngine). uses. the. Character. interface. to. add. enemy.

--- Chunk 379 ---
Tokens: 336
Type: sentence-based
Text:
enemy. characters. to. the. game. making.them.move.defend.and.attack.using.the.move().defend().and.attack(). interface.methods.respectively.Each.character.in.the.game.implements.the.Character. interface.to.provide.specific.behavior.appropriate.for.the.character.and.the.level.of.the. game.That.is.depending.on.the.character.and.the.game.level.the.behavior.for.moving. defending.and.attacking.varies.among.characters.An.online.character.developer.has. created.a.special.character.that.is.compatible.with.the.game.developments.application. programming.interface.(API).but.not.with.the.particular.Character.interface.that.is. the.special.character.designed.by.the.online.developer.includes.the.following.interface. methods.specialMove().specialAttack().and.specialDefend().The.special. character.is.made.available.freely.to.the.gaming.community.however.the.special.charac- ter.code.can.be.downloaded.and.incorporated.into.other.gaming.systems.only.as.a.binary. compiled.library.which.can.be.incorporated.into.the.existing.game.Since.all.levels.of.the. game.are.complete.it.is.impractical.to.change.the.code.in.all.places.to.detect.the.new.spe- cial.character.and.make.different.calls.for.moving.attacking.and.defending.therefore. the.adapter.design.pattern.is.required.to.adapt.the.special.characters.interface.to.the. current.character.interface.

--- Chunk 380 ---
Tokens: 392
Type: sentence-based
Text:
current.character.interface. 218  Software Engineering Design Client request() Target Client request() Target GameEngine attack(): void defend() : void move(): void interface Character request() Adapter specicRequest() Adaptee request() Adapter specicRequest() General Class Structural View General Object Structural View Applied Object Structural View Adaptee attack(): void defend(): void move(): void CharacterAdapter borrowedAttack(): void borrowedDefend(): void borrowedMove(): void interface BorrowedCharacter borrowedAttack(): void borrowedDefend(): void borrowedMove(): void ConcreteBorrowedCharacter FIGURE 7.1 UML.class.diagram.for.the.classobject.structural.adapter.design.pattern. Structural and Behavioral Patterns in Detailed Design  219 Structure The.general.and.applied.structure.of.the.adapter.design.pattern.is.presented.in.Figure 7.1. As.seen.the.adapter.can.be.designed.using.multiple.inheritance.or.object.composition. In.the.multiple.inheritance.version.the.patterns.relationships.between.classes.and.sub- classes.are.defined.at.compile.time.via.inheritance.therefore.this.version.is.classified.as. class.structural.When.the.adapter.design.pattern.is.designed.using.object.composition. object.relationships.are.defined.at.run.time.therefore.the.adapter.design.pattern.in.this. case.is.classified.as.object.structural.The.object.structural.version.of.the.adapter.design. pattern.results.in.a.more.dynamic.and.flexible.design.therefore.it.is.the.recommended. and.followed.approach.for.the.gaming.system.The.step-by-step.approach.for.designing.the.

--- Chunk 381 ---
Tokens: 389
Type: sentence-based
Text:
and.followed.approach.for.the.gaming.system.The.step-by-step.approach.for.designing.the. object.structural.adapter.design.pattern.is.presented.as.follows: . 1.Identify.the.source.and.destination.interfaces.that.need.adapting.in.the.new.system. (e.g.target.and.adaptee.or.character.and.SpecialCharacter). . 2.Add.a.new.class.(e.g.adapter.or.AdaptedCharacter).in.the.design.that.realizes.the. target.interface.and.implements.it.in.terms.of.the.adaptees.implementation.This. requires.a.realization.relationship.between.the.adapter.and.target.and.an.association. between.the.adapter.and.the.adaptee. . 3.In.the.new.system.whenever.objects.that.share.the.target.interface.are.expected. it can.now.be.possible.to.use.the.adapter.objects.created.in.Step.2. The.driving.forces.for.applying.the.adapter.design.pattern.are.reusability.and.integration. of.code.between.two.mature.software.structures.Under.these.conditions.changing.the. code.to.match.either.of.the.two.software.entities.is.impractical.Furthermore.access.to.the. code.for.either.software.entity.may.not.be.possible.therefore.to.reuse.and.integrate.code. from.one.entity.to.the.other.the.adapter.is.required.When.this.is.the.case.the.adapter. design.pattern.is.easily.applied.by.creating.an.adapter.class.that.inherits.from.the.target. class.By.incorporating.new.adapter.objects.that.share.the.Target interface.clients.can.use. them.the.same.way.they.used.original.Target.objects.however.these.new.adapter.objects. implement.the.Target.functions.in.terms.of.the.Adaptee.which.is.the.object.providing.the.

--- Chunk 382 ---
Tokens: 382
Type: sentence-based
Text:
implement.the.Target.functions.in.terms.of.the.Adaptee.which.is.the.object.providing.the. new.functionality.under.a.different.incompatible.interface. Implementation The.implementation.of.the.object.structural.adapter.design.pattern.simply.requires.the. creation. of. one. class. with. two. relationshipsrealization. and. association. In. practical. applications.the.Target.and.Adaptee.classes.are.typically.part.of.larger.mature.and.sable. software.structures.In.this.example.the.Target.and.Adaptee.classes.are.represented.by.the. Character.and.BorrowedCharacter.classes.as.seen.in.Listings.7.1.and.7.2. 220  Software Engineering Design As.seen.the.interfaces.for.the.Character.and.BorrowedCharacters.are.different. therefore. client. code. that. expects. objects. with. the. Character. interface. cannot. accept. objects.with.the.BorrowedCharacter interface.even.though.conceptually.both.objects.do. the.same.operations.To.allow.the.existing.code.to.process.objects.of.the.borrowed.charac- ter.type.as.if.they.were.objects.of.the.character.type.a.CharacterAdapter.is.required. as.seen.in.Listing.7.3. Listing 7.1: C Code for the Character Interface  The Target class. class Character  public:  Interface method for attack functionality. virtual void attack()  0;  Interface method for defend functionality. virtual void defend()  0;  Interface method for moving functionality. virtual void move()  0; ; Listing 7.2: C Code for the BorrowedCharacter Interface and ConcreteBorrowedCharacter  Interface for the borrowed character.

--- Chunk 383 ---
Tokens: 371
Type: sentence-based
Text:
virtual void move()  0; ; Listing 7.2: C Code for the BorrowedCharacter Interface and ConcreteBorrowedCharacter  Interface for the borrowed character. class BorrowedCharacter  public:  Interface methods for the borrowed character. virtual void borrowedAttack()  0; virtual void borrowedDefend()  0; virtual void borrowedMove()  0; ;  Concrete borrowed character. class ConcreteBorrowedCharacter : public BorrowedCharacter  public:  Implementations for the BorrowedCharacter interface methods. void borrowedAttack()   attack code here. void borrowedDefend()   defense code here. void borrowedMove()   code to move here. ; Structural and Behavioral Patterns in Detailed Design  221 As.seen.the.CharacterAdapter.inherits.from.the.Character.to.implement.the. realization.relationship.in.C.It.is.also.associated.with.the.BorrowedCharacter.class. via.member.attribute.To.finalize.the.object.adaptation.the.newly.created.character.adapter. type.is.required.to.implement.all.interface.methods.defined.by.the.character.interface.in. terms.of.the.associated.borrowed.character.as.seen.in.Listing.7.4. Once.the.adapter.design.pattern.is.applied.it.is.easy.to.use.borrowed.characters.in.the. gaming. system. Consider. the. method. presented. in. Listing. 7.5. for. triggering. character. behavior.in.the.GameEngine.class. As.seen.this.and.other.methods.defined.in.the.GameEngine.class.can.now.employ.the. adapter.design.pattern.to.accept.character.objects.that.comply.with.the.character.interface.

--- Chunk 384 ---
Tokens: 386
Type: sentence-based
Text:
adapter.design.pattern.to.accept.character.objects.that.comply.with.the.character.interface. but.provide.behavior.from.the.borrowed.character.An.example.of.client.code.used.to.acti- vate.a.borrowed.character.in.the.gaming.system.is.presented.in.Listing.7.6.As.seen.the. borrowed.character.is.created.and.passed.into.the.character.adapter.during.its.initialization. through.the.constructor.From.this.point.forward.the.adapted.character.is.used.instead.of. the.borrowed.character.to.provide.the.new.features.to.the.game. Benefits . Allows.classes.with.incompatible.interfaces.to.work.together.therefore.increasing. reusability.and.ease.of.code.integration . Provides.a.standard.way.for.integrating.a.plurality.of.different.types.to.existing.software Listing 7.3: C Header File for the CharacterAdapter Class  Forward reference. class BorrowedCharacter; class CharacterAdapter : public Character  public:  Constructor. CharacterAdapter(BorrowedCharacter pCharacter);  Adapt the attack method. void attack(void);  Adapt the defend method. void defend(void);  Adapt the move method. void move(void); private:  BorrowedCharacter that needs adapting to the Character interface. BorrowedCharacter _borrowedCharacter; ; 222  Software Engineering Design Skill Development 7.1: Adapter Design Pattern Using. the. Unified. Modeling. Language. (UML). tool. of. choice. replicate. the. UML. model.presented.in.Figure 7.1.and.generate.code.from.the.model.Using.the.Integrated. Development.Environment.(IDE).of.choice.fill.in.the.gaps.in.the.code.generated.using.

--- Chunk 385 ---
Tokens: 398
Type: sentence-based
Text:
Development.Environment.(IDE).of.choice.fill.in.the.gaps.in.the.code.generated.using. Listings.7.1.through.7.6.and.compile.and.execute.the.software.Create.two.additional. classes.one.that.derives.from.the.character.class.in.which.its.methods.are.implemented. to.simply.display.some.output.to.the.console.and.another.adapter.class.that.adapts. another.character.with.different.interface.methods.for.attacking.defending.and.mov- ing.(e.g.slowAttack.slowDefend.and.slowMove).Use.the.triggeredAction. method.to.pass.in. (one.at.a.time).objects.of.all.the.types.created.Observe.how.the.trig- geredAction.method.accepts.both.objects.of.the.original.character.interface.and.the.new. adapted.objects.(since.they.now.all.share.the.character.interface).How.does.the.adapter. design.pattern.increase.reusability.maintainability.and.modifiability.in.such.system? Listing 7.4: C Source File for the CharacterAdapter Class include CharacterAdapter.h include BorrowedCharacter.h  Constructor. CharacterAdapter:CharacterAdapter(BorrowedCharacter pCharacter)   For simplicity, assume a valid pointer. _borrowedCharacter  pCharacter;   Adapt the attack method. void CharacterAdapter:attack()   Implement the attack functionality in terms of the  BorrowedCharacter. _borrowedCharacter-borrowedAttack();   Adapt the defend method. void CharacterAdapter:CharacterAdapter:defend()   Implement the defend functionality in terms of the  BorrowedCharacter. _borrowedCharacter-borrowedDefend();   Adapt the move method. void CharacterAdapter:move()   Implement the move functionality in terms of the  BorrowedCharacter.

--- Chunk 386 ---
Tokens: 396
Type: sentence-based
Text:
void CharacterAdapter:move()   Implement the move functionality in terms of the  BorrowedCharacter. _borrowedCharacter-borrowedMove();  Structural and Behavioral Patterns in Detailed Design  223 COMPOSITE The. composite. design. pattern. is. an. object. structural. pattern. that. allows. designers. to. compose.(large).tree-like.design.structures.by.strategically.structuring.objects.that.share. a. wholepart.relationship. Wholepart.relationships. are.those.in.which. a.larger.entity. (i.e, the.whole).is.created.by.the.composition.of.smaller.entities.(i.e.the.parts).The.key. Listing 7.5: C Code for the GameEngine Method to Trigger a Characters Actions class GameEngine  public:  . Method to activate a character. void GameEngine:triggeredAction(Character pCharacter)   Activate the character and make it move randomly for a short  time. pCharacter-move();  Once the character stops moving, if being attacked, defend! pCharacter-defend();  Once the characters stops defending, if others characters are  detected, attack! pCharacter-attack();   . ; Listing 7.6: C Code for Client Code in the Gaming System to Activate a Borrowed Character  Instantiate the game engine. GameEngine engine;  Create the borrowed character that needs adapting. ConcreteBorrowedCharacter borrowedCharacter;  Create the character adapter and pass in the borrowed character. From this point on, the adapterCharacter object can be used  throughout the game engine as if it were a Character! CharacterAdapter adaptedCharacter(borrowedCharacter);  Move, attack, and defend with the borrowed characters features!

--- Chunk 387 ---
Tokens: 378
Type: sentence-based
Text:
CharacterAdapter adaptedCharacter(borrowedCharacter);  Move, attack, and defend with the borrowed characters features! engine.triggeredAction(adaptedCharacter); 224  Software Engineering Design advantage.of.using.the.composite.design.pattern.is.that.it.provides.a.design.structure.that. allows.both.whole.and.part.objects.to.be.treated.uniformly.therefore.operations.that.are. common.to.both.type.of.objects.can.be.applied.the.same.way.to.both.types.of.objects. According.to.the.Gang.of.Four. (Gamma.et.al.1995.p.163).the.intent.of.the.composite.is to Compose. objects. into.tree.structures.to. represent.part-whole. hierarchies. Composite. lets. .clients.treat.individual.objects.and.composites.of.objects.uniformly. Many.situations.exist.that.require.objects.to.be.composed.of.many.parts.However.in. some.specific.instances.some.problems.require.both.objects.and.their.parts.to.be.treated. uniformly.In.the.software.domain.perhaps.the.most.common.example.is.seen.in.modern. user.interfaces.which.contain.both.Menu.and.MenuItem objects.A.Menu.in.the.graphical. user.interface.context.is.a.mechanism.of.the.software.that.allows.users.to.select.and.activate. features.of.the.system.A.Menu.can.also.provide.access.to.other.Menus or.MenuItems.that. can.be.selected.to.trigger.software.execution.Both.Menu.and.MenuItem.may.contain.func- tions.to.change.their.visible.text.size.and.background.color.or.to.handle.events.Therefore. both.must.be.treated.uniformly.In.this.case.the.composite.design.pattern.can.be.used.to.

--- Chunk 388 ---
Tokens: 395
Type: sentence-based
Text:
both.must.be.treated.uniformly.In.this.case.the.composite.design.pattern.can.be.used.to. create.a.flexible.design.structure.that.groups.both.Menu.and.MenuItems.that.provides.easy. addition.and.removal.of.both.Menu.and.MenuItems to.the.design.structure.and that.pro- vides.a.uniform.interface.so.that.operations.common.to.both.can.be.easily.performed.using. the.composite.interface.Although.the.composite.design.pattern.is.prevalent.in.examples. such.as.this.its.application.can.be.found.in.numerous.practical.applications. Problem A.wireless.sensor.system.is.remotely.deployed.to.collect.environmental.information.The. sensor.system.communicates.via.satellite.to.a.central.location.where.a.schedule.of.tasks. (i.e.a.mission.plan).is.created.and.sent.over.satellite.communications.A.mission.plan.is.a. composite.message.that.contains.one.or.more.messages.that.command.the.sensor.system. to.perform.particular.tasks.These.messages.contain.information.on.how.and.when.to.per- form.particular.tasks.Mission.plan.messages.can.be.created.with.many.different.com- binations.of.messages.Upon.creating.the.mission.plan.message.it.is.sent.to.the.wireless. sensor.system.which.retrieves.each.message.and.message.information.from.the.mission. plan.and.executes.them.to.collect.environmental.data.store.it.and.send.it.back.to.the. central.location.as.directed.by.the.mission.plan.message.The.sensor.system.is.extensible. and.contains.many.capabilities.provided.by.numerous.sensors. (e.g.temperature.vibra- tion).still-shot.camera.and.video.recording.To.operate.the.sensor.system.the.operators.at.

--- Chunk 389 ---
Tokens: 390
Type: sentence-based
Text:
(e.g.temperature.vibra- tion).still-shot.camera.and.video.recording.To.operate.the.sensor.system.the.operators.at. the.central.location.are.requesting.a.message.generator.capable.of.allowing.them.to.easily. create.a.mission.plan.message.The.mission.plan.message.may.contain.both.primitive.and. composite.messages.Numerous.mission.plan.messages.can.be.created.to.support.different. missions.and.it.is.expected.that.more.sensing.capabilities.will.be.added.in.the.future. Therefore.the.design.of.the.message.generator.must.provide.easy.addition.and.removal.of. Structural and Behavioral Patterns in Detailed Design  225 both.messages.and.composite.messages.to.a.mission.plan.A.graphical.representation.of.the. message.generator.is.presented.in.Figure 7.2. As.seen.the.topmost.composite.message.represents.the.mission.plan.message.(or.schedule). The.message.generator.provides.a.series.of.menu.items.that.allows.operators.to.select.a.par- ticular.message.to.configure.its.parameters.and.to.add.it.to.the.mission.plan.message.In.this. example.Message.3.is.a.composite.message.that.can.be.configured.to.contain.Messages 5.6. and.7.Message.3.can.also.be.configured.individually.and.added.to.the.mission.plan.Both. primitive.and.composite.messages.need.to.be.treated.uniformly.so.that.methods.such.as. getId().setId().and.toXml().can.be.supported.by.both.types.of.messages. Structure The.general.and.applied.structure.of.the.composite.design.pattern.is.presented.in.Figure 7.3. As.seen.the.general.structure.of.the.composite.design.pattern.requires.three.main.classes.

--- Chunk 390 ---
Tokens: 386
Type: sentence-based
Text:
As.seen.the.general.structure.of.the.composite.design.pattern.requires.three.main.classes. the.Composite.Leaf.and.Component.classes.The.Component.class.defines.the.operations. that.are.common.to.both.Composite.and.Leaf.objects.for.example.print().toXml(). getId().setId(), etc.as shown.in.the.Applied.View.portion.of.Figure 7.3.The.com- ponent.class.also.defines.the.methods.specific.to.support.the.composite.design.pattern. namely.the.add().and.remove().methods.The.add.and.remove.methods.are.intended. for.use.by.composite.objects.and.not.by.leaf.objects.therefore.they.must.be.specified.as. overridable.methods.with.default.implementation.that.indicates.an.unsupported.operation. Composite Message Message Composite Message Message Message Message Message Message Param1: Include Message Message 3 Message 5 MessagesMenu Message 1 Message 2 Message 3 Message 4 Message 5 Message 6 Message 7 Param2: Param3: FIGURE 7.2 Message.generator.graphical.user.interface.concept. 226  Software Engineering Design This.means.that.if.at.any.point.during.run.time.a.leaf.object.is.called.upon.to.add.or.remove. objects.to.the.hierarchy.the.default.implementation.for.these.methods.is.executed.to.reflect. the.unsupported.requests.In.many.cases.a.good.alternative.for.the.default.implementation. involves.writing.code.that.throws.exceptions.within.the.add.and.remove.methods.On the. other.hand.composite.objects.that.derive.from.the.component.base.class.are.required.to. override.the.default.implementation.so.that.objects.can.be.added.and.removed.from.the.

--- Chunk 391 ---
Tokens: 191
Type: sentence-based
Text:
override.the.default.implementation.so.that.objects.can.be.added.and.removed.from.the. hierarchy.This.way.when.composite.objects.are.bound.dynamically.at.run.time.to.a.ref- erence.of.the.component.type.the.appropriate.code.for.adding.and.removing.objects.is. called.preventing.the.default.implementation.from.being.executed.The.steps.required.to. apply.the.composite.design.pattern.include . 1.Identify.understand.and.plan.the.tree-like.structure.required.for.the.system. . 2.With. the. knowledge. from. Step. 1. identify. and. design. the. component. base. class. which.includes.overridable.methods.common.to.both.leaf.and.composite.objects.as. well.as.methods.specific.to.composite.objects.which.provide.capability.for.adding. and.removing.objects.to.the.hierarchy.

--- Chunk 392 ---
Tokens: 379
Type: sentence-based
Text:
and.removing.objects.to.the.hierarchy. operation() add(param1 : Component) remove(param1: Component) getChild(int) Client Leaf Component operation() add(param1 : Component) remove(param1: Component) getChild(int) operation() VideoControlMessage MessageGenerator General View Applied View Composite getId(: void): int getName(: void): string setId(id: int): void setName(name: string): void add(message : Message): void print(: void): void toXml(): string clone(): Message setFrameRate(framesPerSecond: int): void toXml(): string clone(): Message SelfTestMessage toXml(): string clone(): Message CompositeMessage CompositeMessage(other : const CompositeMessage) CompositeMessage(name : string) add(message : Message): void print(): void toXml(): string clone(): Message messages_: listMessage id_: int name_: string Message FIGURE 7.3 UML.class.diagram.for.the.composite.design.pattern. Structural and Behavioral Patterns in Detailed Design  227 . 3.For.the.methods.specified.in.Step.2.for.adding.and.removing.objects.to.the.hierarchy. implement.default.behavior.that.if.not.overridden.will.result.in.an.exception.or.error. message.indicating.an.unsupported.operation. . 4.Identify.and.design.the.composite.class.which.overrides.methods.for.adding.and. removing. objects. to. the. hierarchy. The. composite. class. requires. an. internal. data. structure.to.store.leaf.nodes.added.to.the.hierarchy.In.addition.the.composite.class.is. required.to.override.all.other.operational.methods.identified.in.Step.2.to.implement.

--- Chunk 393 ---
Tokens: 391
Type: sentence-based
Text:
required.to.override.all.other.operational.methods.identified.in.Step.2.to.implement. functionality.in.terms.of.the.composite.object.and.all.of.its.contained.leaf.objects. . 5.Identify.and.design.the.leaf.class.which.overrides.operational.methods.specified.in. Step.2.to.implement.behavior.in.terms.of.the.leaf.object.Leaf.objects.do.not.override. the.add.and.remove.methods.identified.in.Step.2. . 6.Identify.and.design.the.client.that.uses.both.composite.and.leaf.objects. In.the.message.generator.example.add().and.remove().are.used.to.add.and.remove. both. CompositeMessage and. all. other. derived. messages. to. the. design. structure. (e.g, VideoControlMessage.SelfTestMessage).Therefore.to.support.the.addi- tion.of.new.messages.that.provide.control.of.future.sensing.capabilities.a.new.class.that. derives.from.the.Message.base.class.needs.to.be.added.to.the.message.generator.design. In.addition.to.support.easy.duplication.of.both.types.of.messages.the.prototype.design. pattern.is.incorporated.into.the.message.generator.design.so.that.message.copies.can.be. easily.created.throughout.the.application.This.is.reflected.in.the.design.with.the.addition. of.the.clone().method.to.the.Message.class. The.driving.forces.behind.the.design.include.the.ability.to.treat.both.individual.messages. and.mission.plan.messages.uniformly.so.that.the.complexity.of.client.code.is.minimized. The.composite.design.pattern.is.also.chosen.to.achieve.design.flexibility.so.that.new.mes- sages.can.be.created.easily.to.support.future.systems.demands.The.most.influential.step.

--- Chunk 394 ---
Tokens: 386
Type: sentence-based
Text:
The.composite.design.pattern.is.also.chosen.to.achieve.design.flexibility.so.that.new.mes- sages.can.be.created.easily.to.support.future.systems.demands.The.most.influential.step. when.applying.the.composite.design.pattern.is.the.addition.of.the.add().method.in.the. Component.base.class.Once.this.method.is.created.composite.objects.override.it.to.store. the.primitive.objects.contained.by.it. Implementation Most.of.the.implementation.work.for.the.composite.design.pattern.takes.place.in.both. the.component.and.composite.classes.which.are.represented.in.the.message.generator.by. the.Message.and.CompositeMessage.classes.Once.these.are.created.other.message. classes.that.share.the.same.Message.interface.can.be.added.easily.by.deriving.from.the. Message.class.The.implementation.for.the.Message.class.is.presented.in.Listing.7.7. As.seen.the.toXml().and.clone().methods.are.incorporated.in.the.Message.type. interface. These. methods. are. application. specific. and. are. not. related. to. the. composite. design.pattern.The.toXml().method.is.added.to.enforce.the.policy.that.all.messages.in. the.system.are.required.to.provide.implementation.appropriate.to.convert.the.particular. message.data.into.Extensible.Markup.Language.(XML).format.Other.application-specific. methods.include.the.getId().setId().getName().and.setName(). 228  Software Engineering Design The.add(Message).method.is.specific.to.the.composite.design.pattern.Specifically.it. gives.composite.classes.the.ability.to.add.messages.to.their.structure.so.that.the.wholepart.

--- Chunk 395 ---
Tokens: 375
Type: sentence-based
Text:
gives.composite.classes.the.ability.to.add.messages.to.their.structure.so.that.the.wholepart. relationship.can.be.realized.Because.this.method.is.intended.specifically.for.composite. classes.it.violates.the.Liskov.substitution.principle.presented.in.Chapter.5.However.it.pro- vides.the.functionality.necessary.to.support.efficient.solution.to.the.problem.therefore.its. usage.can.be.easily.justified.during.design.reviews.To.minimize.the.effects.of.this.viola- tion.careful.attention.needs.to.be.paid.when.implementing.the.default.behavior.of.the. add(Message).method.in.the.Message.base.class.The.easiest.solution.is.to.provide.a.base. implementation.that.notifies.the.operator.stating.that.the.operation.is.not.supported.That. way.derived.classes.that.do.not.support.the.add.method.would.simply.inherit.the.default. Listing 7.7: C Header File for the Message Class class Message  public:  Method to retrieve the messages id. int getId() const;  Method to retrieve the messages name. string getName() const;  Method to set the messages id. void setId(int id);  Method to set the messages name. void setName(string name);  Method to add messages to a composite message. virtual void add(Message message);  Method to display messages to the console. virtual void print();  Method to transform the contents of this message to XML format. virtual string toXml()  0;  Duplicate Messages using the prototype design pattern. virtual Message clone()  0; private:  The messages id. int _id;  The messages name.

--- Chunk 396 ---
Tokens: 386
Type: sentence-based
Text:
int _id;  The messages name. string _name; ; Structural and Behavioral Patterns in Detailed Design  229 implementation.A.more.sophisticated.approach.includes.writing.code.that.throws.an.excep- tion.indicating.that.the.operation.is.not.supported.This.way.calls.to.the.add(Message). method.from.leaf.classes.will.result.in.exceptions.that.can.explicitly.notify.developers.of. this.unsupported.operation.The.default.implementation.for.both.the.add().and.print(). methods.is.presented.in.Listing.7.8.Notice.that.the.print.method.can.be.defined.in.the. Message.base.class.to.display.the.messages.information.This.implementation.is.appropri- ate.for.leaf.objects.but.not.for.composite.objects.therefore.leaf.objects.can.inherit.this. implementation.without.further.changes. The.main.difference.between.the.CompositeMessage.class.and.all.other.messages.in. the.design.is.that.the.operations.of.the.CompositeMessage.need.to.support.its.contained. messages.For.example.the.print().method.needs.to.display.the.information.of.the.com- posite.message.and.all.of.its.contained.messages.Similarly.the.CompositeMessage. class.needs.to.override.the.add().toXml().and.clone().methods.to.appropriately.sup- port.all.of.its.contained.objects.The.CompositeMessage.class.is.specified.in.Listing.7.9. To. support. the. addition. of. primitive. messages. in. the. composite. structure. a. C. .template.list.is.used.so.the.implementation.of.the.add(Message).method.simply.pushes. .messages.to.the.back.of.the.list.By.using.a.list.implementing.the.print().method.is.made.

--- Chunk 397 ---
Tokens: 393
Type: sentence-based
Text:
.messages.to.the.back.of.the.list.By.using.a.list.implementing.the.print().method.is.made. easy.since.all.it.has.to.do.is.iterate.through.the.list.and.call.each.of.the.message.objects. print().methods.as.displayed.in.Listing.7.10. Primitive.objects.of.the.message.type.are.created.by.deriving.from.the.Message base.class. and.implementing.all.other.application-specific.required.methods.For.example.the.video Listing 7.8: C Implementation for the Add() and Print() Methods of the Message Class include Message.h include string include iostream  Method to add messages to a composite message. void Message:add(Message message)   The default implementation lets clients know that the operation  is unsupported. This behavior is inherited by Leaf classes, but  overridden by Composite classes. std:coutMessages cannot be added to Leaf objects!n;   Method to display messages to the console. void Message:print(void)   The default behavior for displaying a messages information. This behavior is inherited by Leaf classes, but overridden by  Composite classes. std:coutMessage _name.c_str(), Id: _idendl;  230  Software Engineering Design control message for the system.is.required.to.provide.implementation.for.required.toXml().and. clone().methods.and.all.other.methods.required.to.execute.video.control.messages.such.as.the. setFrameRate().method.An.example.of.the.VideoControlMessage.implementation. is.presented.in.Listing.7.11.In.similar.fashion.all.other.messages.in.the.system.are.created. Once.the.CompositeMessage.and.primitive.messages.are.designed.and.implemented.

--- Chunk 398 ---
Tokens: 400
Type: sentence-based
Text:
Once.the.CompositeMessage.and.primitive.messages.are.designed.and.implemented. the.client.message.generator.can.be.implemented.as.seen.in.Listing.7.12. As.seen.by.using.the.composite.design.patterns.message.hierarchies.containing.both. primitive.and.composite.objects.can.be.created.easily.simply.by.adding.objects.to.the.com- posite. objects. via. the. add(). interface. method. For. example. the. .powerOnMessage. .selfTestMessage. and. transmitStatusMessage. all. sharing. the. Message. interface. are. added. to. the. composite. message. initializeTaskingMessage. Listing 7.9: C Header File for the CompositeMessage Class include list include Message.h class CompositeMessage : public Message  public:  Copy constructor. CompositeMessage(const CompositeMessage other);  Overloaded constructor to set the messages name. CompositeMessage(string name);  Destructor to clean up memory for messages in _message. virtual CompositeMessage();  Method to add messages to this Composite Message. void add(Message message);  Override the print method to display all messages in _message. virtual void print();  Method to transform the contents of this message to XML format. string Message:toXml();  Create a duplicate of the Composite Message using the prototype  design pattern. Message clone(); private:  The Messages that make up the Composite Message. listMessage _messages; ; Structural and Behavioral Patterns in Detailed Design  231 which. in. turn. is. added. to. the. composite. message. missionPlanMessage. Similarly. .collectionMessage.which.is.a.composite.message.and.shutdownMessage.which. is.

--- Chunk 399 ---
Tokens: 398
Type: sentence-based
Text:
is. a. primitive. message. are. both. added. to. the. missionPlanMessage. to. create. a. full. .collection. mission. plan. message. Once. the. whole.message.is.created.from.its.parts.the. .mission.plan.message.can.be.used.to.display.its.content.and.convert.all.messages.contained. in. the. missionPlanMessage. to. XML. before. being. sent. out. via. the. communication. link. The sample.output.for.the.code.in.Listing.7.12.is.presented.in.Listing.7.13. Benefits . Provides.a.design.structure.that.supports.both.composite.and.primitive.objects . Minimizes.complexity.on.clients.by.shielding.them.from.knowing.the.operational. differences.between.primitive.and.composite.objects.clients.that.expect.a.primitive. object.will.also.work.with.a.composite.object.since.operations.are.called.uniformly. on.both.primitive.and.composite.objects . Easy.to.create.and.add.new.component.objects.to.applications Listing 7.10: C Implementation of the Composites Add() and Print() Methods  Add a message to the collection of messages in the Composite  Message. void CompositeMessage:add(Message message)   Add this message. _messages.push_back(message);  void CompositeMessage:print()   Display the Composite Messages name and id. coutnComposite Message: getName().c_str() , Id: getId()endl;  Retrieve an iterator for the _messages collection. listMessage:iterator pIter  _messages.begin();  Iterate through the messages that make up this composite  message and display their info. for( unsigned int i  0; i  _messages.size(); i )   Display the messages information and move the iterator to  the next position.

--- Chunk 400 ---
Tokens: 392
Type: sentence-based
Text:
for( unsigned int i  0; i  _messages.size(); i )   Display the messages information and move the iterator to  the next position. (pIter)-print();   232  Software Engineering Design FACADE The.facade.design.pattern.is.an.object.structural.pattern.that.provides.a.simplified.inter- face.to.complex.subsystems.By.providing.a.simplified.interface.the.facade.design.pattern. provides.a.higher.level.of.abstraction.that.liberates.clients.from.the.responsibility.of.know- ing.the.internal.structure.of.various.elements.of.the.subsystem.which.in.turn.reduces. coupling.and.simplifies.client.code.Facade.also.shields.clients.from.changes.that.occur. in.the.subsystem.by.having.a.standardized.facade.interface.the.internal.structure.of.the. subsystem.can.vary.without.affecting.clients.According.to.the.Gang.of.Four.(Gamma. et al.1995.p.185).the.intent.of.the.facade.design.pattern.is.to Provide.a.unified.to.a.set.of.interfaces.in.a.subsystem.Facade.defines.a.higher-level.interface. that.makes.the.subsystem.easier.to.use. In. most. practical. applications. components. or. subsystems. are. created. to. abstract. a. complex. behavior. that. the. system. must. provide. In. these. cases. executing. a. complex. Listing 7.11: C Header File for the VideoControlMessage Leaf Class include Message.h class VideoControlMessage : public Message  public:  Constructor. VideoControlMessage(void);  Destructor. VideoControlMessage(void);  TODO: Specific video control methods. void setFrameRate(int framesPerSecond);  . . . Method to transform the contents of this message to XML format.

--- Chunk 401 ---
Tokens: 362
Type: sentence-based
Text:
Method to transform the contents of this message to XML format. string toXml(void);  Duplicate the VideoControlMessage using the prototype design  pattern. Message clone(void); ; Structural and Behavioral Patterns in Detailed Design  233 Listing 7.12: C Implementation for the Message Generator and Sample Usage  Create the initialization primitive messages. PowerOnMessage powerOnMessage; SelfTestMessage selfTestMessage; TransmitStatusMessage transmitStatusMessage;  The message to task the system to initialize properly. CompositeMessage initializeTaskingMessage(Initialize System);  Add copies of the power on, self test, and transmit status messages  to the initialize tasking composite message. initializeTaskingMessage.add( powerOnMessage.clone() ); initializeTaskingMessage.add( selfTestMessage.clone() ); initializeTaskingMessage.add( transmitStatusMessage.clone() );  Collection Control Messages. TemperatureSensorControlMessage temperatureSensorControlMessage; VideoControlMessage videoControlMessage;  The message to task the system to collect information. CompositeMessage collectionMessage(Information Collection);  Add the temp. sensor and video control messages to the collection  tasking composite message. collectionMessage.add( temperatureSensorControlMessage.clone() ); collectionMessage.add( videoControlMessage.clone() );  Shutdown Messages. ShutdownMessage shutdownMessage;  The message to task the system to complete Mission 1.

--- Chunk 402 ---
Tokens: 398
Type: sentence-based
Text:
ShutdownMessage shutdownMessage;  The message to task the system to complete Mission 1. CompositeMessage missionPlanMessage(Mission 1 - Temperature and Video Collection);  Add the messages to the initialize, collection, and shutdown  messages to the mission plan composite message. missionPlanMessage.add( initializeTaskingMessage.clone() ); missionPlanMessage.add( collectionMessage.clone() ); missionPlanMessage.add( shutdownMessage.clone() );  Before sending message, verify its content. missionPlanMessage.print();  If content is valid, send the message through the system. Before  being sent out through the communication link, a call to  missionPlanMessage.toXml() is made to convert all of the  messages content to XML format. 234  Software Engineering Design subsystem.behavior.may.require.the.combination.of.multiple.function.calls.from.multi- ple.component.and.subsystem.elements.For.example.consider.a.software.component. that.provides.various.elements.and.functionality.for.assessing.the.integrity.of.a.particu- lar.computer.This.component.may.contain.elements.responsible.for.particular.items.of. .interests.such.as.a.file.system.element.memory.element.and.communication.element. In this.case.the.facade.design.pattern.can.be.used.to.abstract.all.elements.in.the.sub- system.by.creating.a.method.testSystem().that.in.turns.calls.upon.the.various.elements.of. the.subsystem.in.the.appropriate.order.to.evaluate.the.integrity.of.the.system.This.allows. clients.to.be.associated.only.with.the.facade.and.relieves.them.from.knowing.the.internals. of.the.integrity.assessment.component.

--- Chunk 403 ---
Tokens: 400
Type: sentence-based
Text:
of.the.integrity.assessment.component. Problem Consider.the.sensor.system.described.as.part.of.the.message.generator.in.the.previous. .section.Upon.field.deployment.it.is.desirable.to.test.the.systems.capabilities.to.ensure. that.the.system.works.properly.before.engaging.in.autonomous.operation.For.this.reason. a.graphical.user.interface.is.required.to.monitor.and.control.the.system.in.the.field.during. installation.A.conceptual.diagram.of.both.subsystems.and.their.interactions.is.presented. in.Figure 7.4. The.sensor.subsystem.consists.of.the.following.elements.SystemManager.SerialComm. FileSystem.DataAnalyzer.and.WirelessComm.A.typical.set.of.operations.to.assess.the. integrity.of.the.system.would.require.clients.to.know.about.all.subsystem.elementsfor. example.opening.the.serial.port.sending.a.collection.message.to.the.system.manager.and. opening.the.wireless.communication.link.This.adds.complexity.to.the.developers.of.the.UI. subsystem.since.they.are.required.to.know.the.details.of.the.sensor.sub.system.In.addition. in.many.practical.applications.the.internals.of.subsystem.are.prone.to.change.therefore. Listing 7.13: Sample Output for the Message Generator Problem Composite Message: Mission 1 - Temperature and Video Collection, Id: 20 Composite Message: Initialize System, Id: 20 Message Power On Message, Id: 0 Message Self Test Message, Id: 1 Message Transmit Status Message, Id: 2 Composite Message: Information Collection, Id: 20 Message Temperature Sensor Control Message, Id: 3 Message Video Control Message, Id: 4 Message Shutdown Message, Id: 5 Press any key to continue .

--- Chunk 404 ---
Tokens: 389
Type: sentence-based
Text:
Listing 7.13: Sample Output for the Message Generator Problem Composite Message: Mission 1 - Temperature and Video Collection, Id: 20 Composite Message: Initialize System, Id: 20 Message Power On Message, Id: 0 Message Self Test Message, Id: 1 Message Transmit Status Message, Id: 2 Composite Message: Information Collection, Id: 20 Message Temperature Sensor Control Message, Id: 3 Message Video Control Message, Id: 4 Message Shutdown Message, Id: 5 Press any key to continue . . . Structural and Behavioral Patterns in Detailed Design  235 clients.relying.on.the.internal.of.subsystems.must.keep.up.with.changes.throughout.devel- opment.and.maintenance.phases.The.designers.of.the.sensor.system.wants.an.easy.solu- tion.to.shield.UI.subsystem.developers.from.changes.in.the.sensor.subsystemone.that. allows.developers.of.the.sensor.subsystem.to.identify.and.set.interfaces.for.the.visible. aspects.of.the.sensor.subsystem.so.that.clients.can.rely.on.this.interface.giving.develop- ers.of.the.sensor.subsystem.the.ability.to.change.the.internals.of.the.subsystem.without. affecting.clients. Structure The.general.and.applied.structure.of.the.facade.design.pattern.is.presented.in.Figure 7.5. As.seen.the.facade.provides.functionality.in.terms.of.existing.classes.through.a.sim- plified.interface.In.most.cases.a.facades.functions.will.be.implemented.in.terms.of. several.functions.from.different.subsystem.classes.This.prevents.clients.from.depending. on.these.internal.subsystems.therefore.both.complexity.and.dependencies.on.the.client. side.are reduced.

--- Chunk 405 ---
Tokens: 380
Type: sentence-based
Text:
side.are reduced. Consider.the.set.of.operations.required.to.retrieve.sensor.data.which.may.require.open- ing.communication.links.testing.the.connections.and.scheduling.a.collection.message. These.operations.require.interfacing.with.several.components.within.the.sensor.sub.system. In.such.cases.the.UI.subsystem.is.required.to.know.the.details.required.to.carry.out.all.of. these.operations.which.increases.coupling.and.complexity.of.the.UI.However.with.the. facade.design.pattern.an.interface.method.named.transmitSensorData().can be. used.to.abstract.all.of.the.required.operations.to.transmit.sensor.data.such.as.opening. Serial Comm. Msg In Congure Massages Out System Manager Sensor Subsystem User Interface Subsystem Decode Execute Send Recv Send Recv Wireless Comm. Congure Read Data Out Write Data In File System Data Analyzer FIGURE 7.4 Conceptual.diagram.of.wireless.sensor.system. 236  Software Engineering Design the. serial. connection. opening. the. wireless. connection. testing. both. connections. and. .scheduling.a.collection.message.A.step-by-step.procedure.for.applying.the.facade.design. pattern.includes . 1.Identify.all.components.involved.in.carrying.out.a.subsystem.operation. . 2.Create.an.ordered.list.of.the.operations.required.to.execute.the.subsystem.operation. . 3.Design.a.facade.class.that.includes.an.interface.method.to.carry.out.the.subsystem. operation. The. facade. class. has. dependencies. to. all. other. subsystem. components. required.to.carry.out.the.subsystem.operation. .

--- Chunk 406 ---
Tokens: 394
Type: sentence-based
Text:
. 4.Implement.the.facade.interface.method.by.calling.operations.on.one.or.more.sub- system.components.in.the.order.identified.in.Step.2. . 5.Allow.one.or.more.clients.to.access.the.objects.of.the.facade.type.so.that.they.can.gain. access.to.the.subsystem.operation.This.creates.a.many-to-one.relationship.between. external.subsystems.and.the.facade.interface.instead.of.many-to-many.relationships. The.driving.forces.behind.the.facade.are.simplicity.of.client.code.and.lower.coupling. The.facade.design.pattern.can.be.simply.applied.by.creating.an.additional.facade.class. that.provides.simple.functions.summarizing.the.major.external.functions.expected.and. required.by.clients. Client SubsystemClassA SubsystemClassB SubsystemClassC Facade SensorSystem simpliedInterface() SerialComm SystemManager FileSystem DataAnalyzer WirelessComm client enableSensor(sensorNum: int): void enableAllSensors(): void disableSensor(sensorNum: int): void disableAllSensor(): void transmitSensorData(sensorNum: int): void transmitAllSensorData(): void scheduleCollection(): void Applied View General View FIGURE 7.5 UML.class.diagram.for.the.facade.design.pattern. Structural and Behavioral Patterns in Detailed Design  237 Implementation Implementing.the.facade.design.pattern.is.straightforward.since.it.simply.provides.behav- ior.in.terms.of.other.subsystems.An.example.facade.method.for.transmitting.sensor.data. is.presented.in.Listing.7.14.As.seen.many.of.the.complexities.associated.with.using.the. subsystem.elements.are.hidden.by.the.facade.By.depending.only.on.the.facade.clients.are.

--- Chunk 407 ---
Tokens: 384
Type: sentence-based
Text:
subsystem.elements.are.hidden.by.the.facade.By.depending.only.on.the.facade.clients.are. shielded.from.unnecessary.details.required.to.perform.the.operation. Listing 7.14: C Implementation of One Method of the SensorSystem Facade void SensorSystem:transmitSensorData(int sensorNumber)   Create an object for serial communications parameters. SerialParams params; params.setCommPort( SerialParams:COM_1 ); params.setBaudRate( SerialParams:BR_9600 ); params.setParity( SerialParams:PARITY_NO_PARITY ); params.setByteSize( SerialParams:BYTE_SIZE_8 ); params.setStopBits( SerialParams:STOP_BIT_ONE );  Retrieve pointer to the serial communication object. SerialComm pSerialComm  SerialComm:getInstance();  Open the serial communication with the specified parameters. if( serialComm-open(params) )   Ready to communicate with collection nodes, now get ready for  transmitting the data via the wireless link. TcpConnection pConnection  TcpConnection:getInstance(); if( pConnection-open(TcpConnection:PORT_NUMBER, TcpConnection:IP_ADDRESS) )   Schedule a collection message. SystemManager:getInstance()-scheduleMessage(. );  else   Log TCP error here. Close serial connection. end if( pConnection-open(.) else   Log serial connection error here. end if( serialComm-open(.) end transmitSensorData function. 238  Software Engineering Design Benefits . Shields.clients.from.knowing.the.internals.of.complex.subsystem.therefore.minimiz- ing.complexity.in.clients . Since.the.internals.of.the.subsystem.are.prone.to.change.provides.a.stable.interface.

--- Chunk 408 ---
Tokens: 393
Type: sentence-based
Text:
Since.the.internals.of.the.subsystem.are.prone.to.change.provides.a.stable.interface. that.hides.changes.to.internal.subsystems.therefore.making.client.code.more.stable . Promotes.weak.coupling.on.clients.clients.depend.on.only.one.interface.instead.of. multiple.interfaces BEHAVIORAL DESIGN PATTERNS Behavioral. design. patterns. deal. with. encapsulating. behavior. with. objects. assigning. responsibility.and.managing.object.cooperation.when.achieving.common.tasks.(Gamma. et.al.1995).Behavioral.design.patterns.include.many.of.the.mainstream.design.patterns. used.in.modern.object-oriented.frameworks.and.play.a.key.role.in.the.design.of.systems. by.making.them.independent.of.specific.behavior.which.is.made.replaceable.with.objects. throughout.these.design.patterns.Therefore.parts.of.the.system.responsible.for.perform- ing.some.algorithm.or.behavior.do.so.by.relying.on.a.common.interface.without.knowl- edge.of.how.the.actual.behavior.or.algorithm.is.carried.out.In.addition.by.controlling.the. behavioral.process.with.common.interfaces.enforcing.behavioral.policies.becomes.easier. therefore.giving.systems.the.ability.to.create.algorithms.that.share.a.common.interface. but.that.vary.widely.in.behavior.Examples.of.behavioral.patterns.include.the.iterator.and. the observer. ITERATOR The.iterator.design.pattern.is.an.object.behavioral.pattern.that.provides.a.standardized.way. for.accessing.and.traversing.objects.in.a.collection.data.structure.A.collection.data.struc- ture.may.consist.of.arrays.vectors.lists.or.other.custom-designed.structures.The.iterator.

--- Chunk 409 ---
Tokens: 400
Type: sentence-based
Text:
for.accessing.and.traversing.objects.in.a.collection.data.structure.A.collection.data.struc- ture.may.consist.of.arrays.vectors.lists.or.other.custom-designed.structures.The.iterator. design.pattern.works.by.abstracting.the.way.each.specific.collection.structure.operates.on. the.data.so.that.clients.are.not.required.to.have.knowledge.of.the.details.of.their.internal. structure.According.to.the.Gang.of.Four.(Gamma.et.al.1995.p.257).the.intent.of.the. iterator.design.pattern.is.to Provide.a.way.to.access.the.elements.of.an.aggregate.object.sequentially.without.exposing.its. underlying.representation. By.providing.a.standard.interface.and.encapsulated.methodology.for.accessing.elements. of.a.collection.structure.client.code.becomes.more.consistent.and.easier.to.maintain.since. Structural and Behavioral Patterns in Detailed Design  239 changing.the.internal.structure.of.the.data.collection.structure.does.not.affect.the.way. client.code.interacts.with.the.structure.Iterators.are.prevalent.in.software.engineering. their.presence.can.be.found.built-in.in.todays.most.common.programming.languages.and. frameworks.such.as.C.Java.and.the.NET.framework. Problem A.companys.software.system.manages.inventory.financials.and.all.other.information. available.from.its.two.store.branches.Each.store.carries.specific.computer.products.appro- priate.for.its.locations.demographics.During.design.the.software.system.is.decomposed. into.several.components.including.two.components.for.deferring.and.abstracting.design. information.relevant.to.requirements.for.each.computer.store.branch.The.detailed.design.

--- Chunk 410 ---
Tokens: 391
Type: sentence-based
Text:
information.relevant.to.requirements.for.each.computer.store.branch.The.detailed.design. of. each. component. is. carried. out. separately. by. two. different. software. engineers. this. results.in.two.different.versions.of.data.structures.for.managing.and.providing.store.prod- uct.information.Now.anytime.the.software.system.is.called.upon.to.display.information. about.store.products.it.is.required.to.identify.between.the.two.store.branches.so.that.the. correct.implementation.for.accessing.store.information.can.be.executed.This.problem.is. encountered.every.time.a.new.computer.store.branch.is.added.to.the.system.therefore. a uniform.and.standardized.method.for.accessing.computer.store.products.from.different. collection.data.structures.is.highly.desirable.Consider.the.existing.ComputerProduct. code.for.the.stores.software.system.as.presented.in.Listing.7.15.The.ComputerProduct. is.the.product.class.for.all.products.carried.at.all.store.branches.which.includes.simple.or. advanced.computer.products. Consider. the. case. where. the. designer. of. one. computer. store. branch. uses. a. list. data. structure.to.save.computer.products.for.the.computer.store.branch.carrying.simple.com- puter. products. To. retrieve. the. products. from. the. simple. computer. store. a. method. is. Listing 7.15: C Specification of the ComputerProduct Type class ComputerProduct  public:  Return the products id. int getProductId();  Return the products price. int getPrice() const;  Return the products description. string getDescription() const;  Other methods here.

--- Chunk 411 ---
Tokens: 376
Type: sentence-based
Text:
string getDescription() const;  Other methods here. ; 240  Software Engineering Design provided.getProducts().which.returns.a.reference.or.pointer.to.the.object.of.type. SimpleProductList.as.seen.in.Listing.7.16. The.second.computer.store.which.carries.advanced.computer.products.is.designed.to. keep.track.of.computer.products.using.a.custom-made.list.data.structure.for.the.advanced. computer.products. class.This.list.provides. a.method. getProducts().that.returns. a. reference.or.pointer.to.a.collection.object.of.type.AdvancedProductList.as.seen.in. Listing.7.17. As.trivial.as.this.problem.may.seem.it.highlights.problems.in.code.that.occur.typically. in.software.teams.during.practical.applications.Different.developers.want.to.work.with. their.own.code.they.may.want.to.showcase.their.skills.by.developing.a.better.collection. data.structure.or.the.lack.of.oversight.in.the.design.process.results.in.work.redundancy. This.example.presents.the.problem.using.two.different.(but.almost.similar).lists.however. in.practical.situations.the.difference.in.design.and.implementation.may.involve.signifi- cantly.different.approaches.like.arrays.versus.custom-defined.lists.versus.library-specific. lists.such.as.the.C.standard.template.library.list.Lack.of.standardization.in.the.way. that.computer.stores.access.and.traverse.through.their.products.creates.complexity.for. clients.Consider.the.software.system.code.for.displaying.computer.product.information. from.both.stores.as.presented.in.Listing.7.18.

--- Chunk 412 ---
Tokens: 366
Type: sentence-based
Text:
from.both.stores.as.presented.in.Listing.7.18. Listing 7.16: C Code for the SimpleComputerStore Class include SimpleProductList.h  Simple Computer Store class SimpleComputerStore  public:  Constructor. SimpleComputerStore()  Connect to DB and initialize all products. Computer store methods. Return the computer products carried by the simple computer store. SimpleProductList getProducts()   Return the simple product list. return _products;  private:  The list of simple computer products. SimpleProductList _products; ; Structural and Behavioral Patterns in Detailed Design  241 Notice. that. by. having. different. methods. to. retrieve. each. product. (i.e. getSimple- Product.and.getAdvancedProduct).the.client.code.now.requires.a.conditional.state- ment.to.differentiate.between.the.two.store.branches.which.results.in.two.versions.of.code. for.displaying.product.information.For.each.store.added.to.the.system.a.new.conditional. statement.is.required.to.support.the.display.of.the.new.computer.store.branch. Structure The.general.and.applied.structure.of.the.iterator.design.pattern.is.presented.in.Figure 7.6. The.key.to.designing.the.iterator.design.pattern.lies.in.the.Iterator.interface.As.seen.in. the.General.View.portion.of.Figure 7.6.the.Iterator.interface.consists.of.the.first(). next().isDone().and.currentItem().interface.methods.These.methods.specify.the. fundamental.operations.that.need.to.be.provided.by.iterator.objects.that.implement.the.

--- Chunk 413 ---
Tokens: 375
Type: sentence-based
Text:
fundamental.operations.that.need.to.be.provided.by.iterator.objects.that.implement.the. interface.Regardless.of.the.collection.data.structure.employed.to.store.products.these.inter- face.methods.can.be.used.uniformly.to.traverse.the.items.contained.by.the.data.structure. The.first().method.is.used.to.return.the.first.item.in.the.collection.the.next().method. is.used.to.move.the.current.item.to.the.next.element.of.the.list.the.currentItem(). method.is.used.to.return.the.product.stored.at.the.current.location.of.the.iterator.and. the.isDone().method.is.used.to.determine.if.there.are.more.products.to.traverse.in.the. .collection.item. Listing 7.17: C Code for the AdvancedComputerStore Class include AdvancedProductList.h  Advanced Computer Store class AdvancedComputerStore  public:  Constructor. AdvancedComputerStore()  Initialize all products. Computer store methods. Return a pointer to the advanced product list. AdvancedProductList getProducts()   Return the advanced product list. return _products;  private:  The computer products. in ProductList form. AdvancedProductList _products; ; 242  Software Engineering Design Also.in.the.General.View.of.the.iterator.design.pattern.the.Aggregate.interface.speci- fies.the.method.for.instantiating.and.returning.an.iterator.object.Clients.use.this.object.to. traverse.the.collection.using.the.iterator.interface.instead.of.the.concrete.aggregate.object. This.version.of.the.iterator.design.pattern.is.the.preferred.version.for.new.design.efforts.

--- Chunk 414 ---
Tokens: 398
Type: sentence-based
Text:
This.version.of.the.iterator.design.pattern.is.the.preferred.version.for.new.design.efforts. However.in.practice.the.iterator.can.be.designed.differently.from.project.to.project.espe- cially.when.existing.code.is.in.place.For.example.in.the.Applied.View.of.Figure 7.6.some. Listing 7.18: C Code for the Centralized Server Software to Display Computer Products  Simple store. SimpleComputerStore simpleStore; ComputerProduct pProduct  0; SimpleProductList simpleStoreProducts  simpleStore.getProducts();  Display simple store products. for( int i  0; i  simpleStoreProducts-size(); i )   Retrieve the product at index i. pProduct  simpleStoreProducts-getSimpleProduct(i);  Make sure pProduct is valid before using it! Display products information. coutProduct id: pProduct-getProductId()endl Product price: pProduct-getPrice()endl Product Description: pProduct-getDescription().c_str()endl;  Advanced store. AdvancedComputerStore advancedStore; AdvancedProductList advancedProducts  advancedStore.getProducts();  Display advanced store products. for( int i  0; i  advancedProducts-length(); i )   Retrieve the product at location i. pProduct  advancedProducts-getAdvancedProduct(i);  Make sure pProduct is valid before using it! Display products information. coutProduct id: pProduct-getProductId()endl Product price: pProduct-getPrice()endl Product Description: pProduct-getDescription().c_str()endl;   Repeat here for all other types of lists! Structural and Behavioral Patterns in Detailed Design  243 of.the.iterator.interface.methods.are.omitted.and.the.names.are.modified.from.the.original.

--- Chunk 415 ---
Tokens: 395
Type: sentence-based
Text:
Structural and Behavioral Patterns in Detailed Design  243 of.the.iterator.interface.methods.are.omitted.and.the.names.are.modified.from.the.original. pattern.In.addition.each.concrete.aggregate.class.is.designed.as.of.two.independent.and. existing.classes.in.the.system.This.is.necessary.when.code.for.the.existing.collection.data. structures.(e.g. SimpleProductList). cannot.be.modified.When. examined. closely. the.Applied.View.of.Figure 7.6.consists.of.the.same.relationships.and.similar.interface. methods.but.are.structured.differently.to.account.for.the.existing.code.Similar.variations. of.the.iterator.design.pattern.can.be.found.in.practice.therefore.modifying.the.iterator. relationships.to.fit.a.particular.problem.is.common.Notice.however.that.if.code.for.both. SingleProductList.and.AdvancedProductList.is.available.for.modification.the. Aggregate Iterator createIterator() ConcreteAggregate createIterator() SimpleProductList createIterator(): StoreProductIterator interface ComputerStore createIterator(): StoreProductIterator AdvancedComputerStore createIterator(): StoreProductIterator AdvancedComputerStore AdvancedProductList hasNext(): bool getNext(): ComputerProduct reset(): void interface StoreProductIterator hasNext(): bool getNext(): ComputerProduct reset(): void SimpleStoreProductIterator hasNext(): bool getNext(): ComputerProduct reset(): void AdvancedStoreProductIterator rst() next() isDone() currentItem() General View ConcreteIterator rst() next() isDone() currentItem() Applied View FIGURE 7.6 UML.class.diagram.for.the.iterator.design.pattern.

--- Chunk 416 ---
Tokens: 390
Type: sentence-based
Text:
Aggregate Iterator createIterator() ConcreteAggregate createIterator() SimpleProductList createIterator(): StoreProductIterator interface ComputerStore createIterator(): StoreProductIterator AdvancedComputerStore createIterator(): StoreProductIterator AdvancedComputerStore AdvancedProductList hasNext(): bool getNext(): ComputerProduct reset(): void interface StoreProductIterator hasNext(): bool getNext(): ComputerProduct reset(): void SimpleStoreProductIterator hasNext(): bool getNext(): ComputerProduct reset(): void AdvancedStoreProductIterator rst() next() isDone() currentItem() General View ConcreteIterator rst() next() isDone() currentItem() Applied View FIGURE 7.6 UML.class.diagram.for.the.iterator.design.pattern. 244  Software Engineering Design design.of.these.classes.would.take.the.place.of.the.simple.and.advanced.computer.store. from.the.Applied.View.of.Figure 7.6.to.match.the.general.view.of.the.design.pattern. In.the.applied.version.the.hasNext().method.is.specified.to.return.true.if.the.col- lection.data.structure.has.more.elements.for.traversal.the.getNext().interface.method. is.used.to.move.the.iterators.pointer.to.the.next.element.in.the.collection.and.return.the. product.stored.at.that.location.finally.the.reset().interface.method.is.designed.to.reset. the.collection.index.to.the.first.item.in.the.collection.Similar.to.the.applied.design.for.the. computer.store.software.the.iterator.design.pattern.is.applied.in.software.systems.with.dif- ferent.interface.methods.to.solve.the.original.problem.that.the.pattern.describes.

--- Chunk 417 ---
Tokens: 399
Type: sentence-based
Text:
computer.store.software.the.iterator.design.pattern.is.applied.in.software.systems.with.dif- ferent.interface.methods.to.solve.the.original.problem.that.the.pattern.describes. Once.the.iterator.is.designed.the.next.key.element.of.the.design.pattern.involves.design- ing.the.concrete.iterators.that.provide.a.uniform.level.of.abstraction.for.each.collection. structure. (e.g.array.linked.list).in.the.system.As.seen.in.Figure 7.6.for.each.concrete. iterator.designed.an.association.is.made.to.the.appropriate.collection.structure.This.means. that.each.iterator.knows.the.specific.interface.methods.provided.by.its.associated.collection. structure.so.that.it.can.use.them.to.traverse.and.access.its.products.This.way.when.clients. of.the.iterator.call.a.method.from.the.iterator.interface.(e.g.getNext()).the.concrete. iterator.can.carry.out.the.request.internally.in.terms.of.the.collection.structures.inter- face.method.hiding.these.details.from.its.clients.Therefore.regardless.of.the.collection. structure.clients.of.the.iterator.can.always.rely.on.the.Iterator.interface.to.traverse.any. collection.structure.supported.by.concrete.iterators.This.property.of.the.iterator.design. patterns.is.desirable.in.many.practical.applications. Finally.the.iterator.design.pattern.requires.the.design.of.the.Aggregate.interface.which. is.manifested.in.the.computer.store.problem.as.the.ComputerStore.interface.The.impor- tance.of.this.interface.is.that.it.allows.clients.of.the.computer.store.to.create.iterators.for. traversing.through.the.different.store.product.items.As.discussed.earlier.the.aggregate.

--- Chunk 418 ---
Tokens: 400
Type: sentence-based
Text:
traversing.through.the.different.store.product.items.As.discussed.earlier.the.aggregate. .interface.can.be.directly.implemented.by.the.class.representing.the.collection.structure. or.if.this.code.is.unavailable.by.another.class.that.provides.one.more.levels.of.abstrac- tion.such.as.the.ComputerStore.in.Figure 7.6.With.this.in.place.clients.rely.on.the. ComputerStore.interface.to.create.and.return.an.iterator.without.needing.to.know.the. particular.type.of.store.once.the.iterator.is.returned.clients.use.the.iterator.interface.to. traverse.through.the.products.therefore.providing.a.design.that.relies.fully.on.interfaces. rather.than.concrete.implementations.This.results.in.flexible.designs.that.can.be.modified. and.adapted.easily.to.future.demands.The.step-by-step.approach.for.applying.the.iterator. design.pattern.is.as.follows: . 1.Identify.and.design.the.Iterator.interface. . 2.For.each.class.representing.a.collection.data.structure.in.the.software.system.design. a.concrete.iterator.and.associate.it.with.it.Implement.the.concrete.iterators.methods. in.terms.of.the.collection.data.structure. . 3.Create.the.aggregate.interface.which.includes.the.interface.method.to.create.iterators. . 4.For. each. class. representing. a. collection. data. structure. implement. the. aggregate. interface.to.instantiate.and.return.a.concrete.iterator. Structural and Behavioral Patterns in Detailed Design  245 The.driving.forces.behind.the.design.are.decreased.complexity.for.clients.and.flexibility. By. applying. the. iterator. design. pattern. clients. are. shielded. from. the. internals. of. the.

--- Chunk 419 ---
Tokens: 398
Type: sentence-based
Text:
the. .collection.data.structure.This.in.turn.provides.flexibility.by.allowing.new.stores.to.be. added.easily.or.different.existing.iterators.to.be.swapped.without.changes.to.the.client.code. Implementation The. implementation. of. the. iterator. design. pattern. for. the. computer. store. system. assumes.that.both.collection.data.structures.(i.e.simple.and.advanced.lists).cannot.be. modified.Therefore.the.aggregate.portion.of.the.pattern.is.split.as.seen.in.Figure 7.6. The. implementation. of. the. iterator. design. pattern. begins. with. the. specification. of. the. StoreProductIterator.interface.as.seen.in.Listing.7.19.This.interface.is.designed. Listing 7.19: C Specification of the StoreProductIterator Interface  Forward reference. class ComputerProduct;  The base for all store product iterators. class StoreProductIterator  public:  Constructor. StoreProductIterator() : _position(0)  Intentionally left blank. Interface method for determining if more products are available. virtual bool hasNext()  0;  Interface method for retrieving the next available product. virtual ComputerProduct getNext()  0; protected:  Give access to derived classes for setting the iterators  position. void setPosition(int position)  _position  position;   Allow derived classes to retrieve the iterators position. int getPosition(void)  return _position;   Reset the iterators position. void reset(void)  _position  0;  private:  The iterators current position. int _position; ; 246  Software Engineering Design with.simplicity.in.mind.therefore.it.contains.two.main.methods.for.iteration.hasNext().

--- Chunk 420 ---
Tokens: 385
Type: sentence-based
Text:
int _position; ; 246  Software Engineering Design with.simplicity.in.mind.therefore.it.contains.two.main.methods.for.iteration.hasNext(). and.getNext().There.are.many.different.ways.iterators.can.be.designed.in.this.case. if the.method.hasNext().returns.true.a.subsequent.call.to.getNext().can.be.made.to. move.the.iterator.to.the.next.element.and.to.retrieve.the.product.stored.at.that.location. Once.the.StoreProductIterator.interface.is.specified.each.concrete.iterator.can.be. created.Listing.7.20.presents.the.specification.of.the.SimpleStoreProductIterator. which.is.the.iterator.used.for.traversing.through.in.the.simple.computer.store.which.stores. computer.products.in.a.simple.product.list.Since.this.iterator.is.designed.to.work.with.the. simple.computer.store.a.SimpleProductList.memory.reference.or.pointer.is.passed. to.it.in.the.constructor. As.expected.the.interface.methods.for.the.SimpleStoreProductIterator.type. are.implemented.in.terms.of.the.SimpleProductList.type.as.seen.in.Listing.7.21. Of particular.interest.is.the.getNext().method.which.encapsulates.the.specific.call.to. getSimpleProduct().to.retrieve.a.computer.product. The.specification.of.the.AdvancedStoreProductIterator.is.similar.to.the.one. presented.in.Listing.7.21.but.is.specific.to.the.AdvancedProductList.collection.data. structure.Therefore.implementation.of.the.AdvancedStoreProductIterator.is. made.in.terms.of.this.data.structure.as.seen.in.Listing.7.22. To.enforce.the.policy.that.all.computer.stores.must.support.the.iterator.design.pattern.a.

--- Chunk 421 ---
Tokens: 399
Type: sentence-based
Text:
To.enforce.the.policy.that.all.computer.stores.must.support.the.iterator.design.pattern.a. standard.ComputerStore.interface.is.specified.as.seen.in.Listing.7.23. Computer. stores. deriving. from. this. interface. must. provide. an. implementation. for. the. .createIterator().method.before.they.can.be.instantiated.This.provides.clients.with. a.standard.method.for.retrieving.iterators.from.all.computer.stores.Listings.7.24.and.7.25. present.the.C.implementation.for.both.simple.and.advanced.computer.stores.respectively. Listing 7.20: C Specification of the SimpleStoreProductIterator class SimpleStoreProductIterator : public StoreProductIterator  public:  Constructor. SimpleStoreProductIterator(SimpleProductList products);  Determine if more products are available. bool hasNext();  If more products are available, get the next one. ComputerProduct getNext(); private:  Pointer to the simple computer product list. SimpleProductList _products; ; Structural and Behavioral Patterns in Detailed Design  247 Listing 7.21: C Implementation for the SimpleStoreProductIterator include SimpleStoreProductIterator.h include SimpleProductList.h  Constructor. SimpleStoreProductIterator: SimpleStoreProductIterator(SimpleProductList products)   For simplicity, assume a valid pointer. _products  products;   Determine if more products are available. bool SimpleStoreProductIterator:hasNext()   The return value. bool isNextProductAvailable  false; if( getPosition()  _products-size() )  isNextProductAvailable  true;  return isNextProductAvailable;   If more products are available, get the next one.

--- Chunk 422 ---
Tokens: 380
Type: sentence-based
Text:
bool isNextProductAvailable  false; if( getPosition()  _products-size() )  isNextProductAvailable  true;  return isNextProductAvailable;   If more products are available, get the next one. ComputerProduct SimpleStoreProductIterator:getNext()   Temporary pointer to computer product. ComputerProduct pProduct  0;  Get the iterators current position. int nextItem  getPosition();  Determine if there are more products. if( hasNext() )   Get the address of the next product and move the iterators  position. pProduct  _products-getSimpleProduct(nextItem);  Set the new position of the Iterator. setPosition(nextItem);   Return the requested product. return pProduct;  248  Software Engineering Design Listing 7.22: C Implementation for the AdvancedStoreProductIterator include AdvancedStoreProductIterator.h include AdvancedProductList.h  Constructor. AdvancedStoreProductIterator: AdvancedStoreProductIterator(AdvancedProductList products)   For simplicity, assume valid pointer. _products  products;   Determine if more products are available. bool AdvancedStoreProductIterator:hasNext()   The return value. bool nextProductAvailable  false; if( getPosition()  _products-length() )  nextProductAvailable  true;  return nextProductAvailable;   If more products are available, get the next one. ComputerProduct AdvancedStoreProductIterator:getNext()   Temporary pointer to computer product. ComputerProduct pProduct  0;  Get the iterators current position. int nextItem  getPosition();  Determine if there are more products.

--- Chunk 423 ---
Tokens: 390
Type: sentence-based
Text:
int nextItem  getPosition();  Determine if there are more products. if( hasNext() )   Get the address of the next product and move the iterators  position. pProduct  _products-getAdvancedProduct(nextItem);  Set the new position of the iterator. setPosition(nextItem);   Return the requested product. return pProduct;  Structural and Behavioral Patterns in Detailed Design  249 With.the.iterator.design.pattern.in.place.the.function.to.display.computer.products.in. the.software.system.can.be.modified.to.work.in.terms.of.the.iterator.interface.as.seen.in. Listing.7.26. The.software.system.can.now.display.each.stores.product.using.a.unified.interface.as. seen.in.Listing.7.27.This.design.supports.adding.new.computer.stores.without.much.effort. Listing 7.23: C Specification of the ComputerStore Interface class StoreProductIterator;  Forward reference. The interface for all computer stores. class ComputerStore  public:  The interface method to create an iterator. virtual StoreProductIterator createIterator()  0; ; Listing 7.24: C Implementation for the Simple Computer Store include SimpleStoreProductIterator.h include SimpleProductList.h  Simple Computer Store class SimpleComputerStore : public ComputerStore  public:  Override the createIterator interface method to create the  appropriate iterator for simple computer stores. StoreProductIterator createIterator()   Create and return a simple store product iterator. return new SimpleStoreProductIterator(_products);   All other methods for simple computer stores. private:  The simple product list.

--- Chunk 424 ---
Tokens: 386
Type: sentence-based
Text:
private:  The simple product list. SimpleProductList _products; ; 250  Software Engineering Design Listing 7.25: C Implementation for the Advanced Computer Store  Advanced Computer Store class AdvancedComputerStore : public ComputerStore  public:  Override the createIterator interface method to create the  appropriate iterator for advanced computer stores. StoreProductIterator createIterator()   Create and return an advanced store product iterator. return new AdvancedStoreProductIterator(_products);   All other methods for advanced computer stores. private:  The advanced product list. AdvancedProductList _products; ; Listing 7.26: C Implementation of the Display Function in the Centralized Software  Display the products using the iterator. void displayProducts(StoreProductIterator pIterator)   Temporary pointer to hold a computer product. ComputerProduct pProduct  0;  Determine if there are more products to browse. while( pIterator-hasNext() )   Retrieve the next product. pProduct  pIterator-getNext();  Display the products information. coutnProduct id: pProduct-getProductId()endl Product price: pProduct-getPrice()endl Product Description: pProduct-getDescription().c_str();   Structural and Behavioral Patterns in Detailed Design  251 Benefits . Provides.a.consistent.way.for.clients.to.iterate.through.the.objects.in.a.collection . Abstracts.the.internals.of.the.collection.objects.so.that.if.they.change.clients.do.not. have.to.change . Allows.client.code.to.be.extended.easily.numerous.iterators.can.be.created.to.support.

--- Chunk 425 ---
Tokens: 395
Type: sentence-based
Text:
Allows.client.code.to.be.extended.easily.numerous.iterators.can.be.created.to.support. different.traversals.from.the.same.or.different.collection.structure Skill Development 7.2: Iterator Design Pattern Using.the.UML.tool.of.choice.create.the.design.presented.in.the.Applied.View.Section. of.Figure 7.6.Rename.the.aggregate.interface.method.from.ComputerStore.to. .create. Product Iterator. Make. the. appropriate. modifications. to. both. simple. and. advanced.computer.stores.so.that.they.work.with.the.new.interface.method.Generate. code.from.the.model.and.create.a.test.driver.code.to.verify.the.design.Once.the.code. compiles.and.executes.describe.how.your.design.benefited.from.using.the.iterator. design.pattern. Listing 7.27: C Code for the Centralized Software to Create Iterators and Display Products  Simple store. SimpleComputerStore simpleStore;  Iterator for the simple store. StoreProductIterator pIterator  simpleStore.createIterator();  Display the products using the iterator. displayProducts(pIterator);  Cleanup the simple computer store iterator. delete pIterator;  Advanced store. AdvancedComputerStore advancedStore;  The advanced store iterator. pIterator  advancedStore.createIterator();  Display the products using the iterator. displayProducts(pIterator);  Cleanup the advanced computer store iterator. delete pIterator; 252  Software Engineering Design OBSERVER The.observer.design.pattern.is.an.object.behavioral.pattern.that.standardizes.the.opera- tions.between.objects.that.interoperate.using.a.one-to-many.relationship.According.to.the. Gang.of.Four.

--- Chunk 426 ---
Tokens: 394
Type: sentence-based
Text:
Gang.of.Four. (Gamma.et.al.1995.p.293).the.intent.of.the.observer.is.to Define.a.one-to-many.dependency.between.objects.so.that.when.one.object.changes.state.all. its.dependents.are.notified.and.updated.automatically. In.many.practical.applications.a.common.design.structure.is.required.to.support.inter- action.between.objects.that.monitor.a.common.data.source.so.that.when.changes.occur.in. the.data.source.the.objects.react.appropriately.Consider.a.detailed.design.that.supports.the. modelviewcontroller. (MVC).architectural.pattern.from.Chapter.4.In.the.MVC.archi- tectural.pattern.once.the.data.in.the.model.component.changes.all.views.must.change.as. well.In.cases.such.as.the.MVC.the.observer.design.pattern.provides.the.necessary.struc- tural.interfaces.to.allow.one.or.more.views.to.register.with.the.model.component.Once. registered.the.observer.design.pattern.provides.the.structural.interfaces.for.executing.a. uniform.change.propagation.mechanism.for.the.model.to.notify.all.registered.views.of.the. recent.changes.The.observer.design.pattern.is.very.popular.and.prevalent.in.todays.modern. languages.and.frameworks.such.as.Java.(i.e.Observable.and.Observer.interfaces).and.NET. Problem A.local.university.is.designing.a.system.for.weather-alert.notification.that.allows.students. faculty.and.staff.to.receive.notifications.of.class.cancellations.(due.to.weather).via.e-mail. voice. call. or. SMS. text. messages. Other. methods. of. notification. may. be. added. in. the. future.The.system.is.based.on.the.weather.data.decision.engine.that.interfaces.with.several.

--- Chunk 427 ---
Tokens: 400
Type: sentence-based
Text:
future.The.system.is.based.on.the.weather.data.decision.engine.that.interfaces.with.several. weather-related.data.sources.fuses.the.information.and.automatically.decides.whether. class.cancellations.are.in.effect.The.university.is.interested.in.integrating.the.existing.com- munication.services.(i.e.e-mail.SMS.and.voice).with.the.decision.engine.so.that.these. services.can.be.triggered.to.initiate.notification.via.their.respective.communication.types. The.design.must.be.flexible.so.that.other.types.of.communication.mechanisms.can.be. added.to.the.system.in.the.future. Structure The.general.and.applied.structure.of.the.observer.design.pattern.is.presented.in.Figure 7.7. The.typical.application.of.the.observer.design.pattern.includes.one.concrete.subject.and. one.or.more.concrete.observers.as.seen.in.the.Applied.View.of.Figure 7.7. Each.concrete.observer.is.required.to.implement.the.update().interface.method.spec- ified.by.the.Observer.interface.Similar.to.other.design.patterns.implementation.of.the. observer.design.pattern.varies.depending.on.particular.details.of.projects.Specifically. Structural and Behavioral Patterns in Detailed Design  253 the.implementation.of.the.update.method.is.typically.seen.in.two.common.versions.One. version.includes.passing.as.parameter.the.details.of.the.change.notification.Using.this. approach.concrete.observers.examine.notification.information.using.the.update.param- eter.and.act.accordingly.This.is.possible.when.the.type.of.notification.can.be.abstracted. so.that.it.provides.a.common.interface.for.all.other.concrete.observers.Another.popular.

--- Chunk 428 ---
Tokens: 314
Type: sentence-based
Text:
so.that.it.provides.a.common.interface.for.all.other.concrete.observers.Another.popular. approach.involves.designing.the.update().method.without.parameters.Upon.receiving. change.notification.concrete.objects.call.a.method.of.the.concrete.subject.to.retrieve.the. details.of.the.notified.change.Since.the.behavior.for.attaching.detaching.and.notifying. observers.is.the.same.the.Subject.base.class.can.specify.and.implement.these.methods. which.are.inherited.by.all.other.concrete.subjects.The.step-by-step.approach.for.applying. the.observer.design.pattern.includes . 1.Design.the.subject.interface.and.implement.code.for.attaching.detaching.and.noti- fying.observer.objects.The.code.for.keeping.track.of.observers.can.be.done.using. linked-lists.data.structures. . 2.For.classes.that.manage.information.of.interest.to.observers.inherit.from.the.subject. class.created.in.Step.1. . 3.Design.the.observer.interface.which.includes.the.abstract.update.interface.method. . 4.For.all.observers.in.the.system.implement.the.observer.interface.which.requires. implementing.the.update.method. . 5.At.run.time.create.each.observer.and.attach.it.to.the.subject.When.changes.occur. the.subject.iterates.through.its.list.of.registered.objects.and.calls.its.update.method.

--- Chunk 429 ---
Tokens: 394
Type: sentence-based
Text:
the.subject.iterates.through.its.list.of.registered.objects.and.calls.its.update.method. attach(pObserver: Observer): void dettach(pObserver: Observer): void notify(): void Subject EmailService update(): void interface Observer update(): void ConcreteObserver ConcreteSubject DecisionEngine ServiceNotier Applied View General View update(msg: string): void attach(pService: Service): void detach(pService: Service): void notify(): void interface Service update(msg: string): void PhoneService update(msg: string): void SmsService update(msg: string): void FIGURE 7.7 UML.class.diagram.for.the.observer.design.pattern. 254  Software Engineering Design The.driving.force.behind.the.application.of.the.observer.design.pattern.is.flexibility. By applying.the.observer.design.pattern.future.additions.of.services.can.be.done.automati- cally.therefore.leading.to.software.that.is.easy.to.maintain. Implementation Implenting.the.observer.design.pattern.begins.with.the.ServiceNotifier.class.which. serves.as.base.class.for.the.subjects.As.seen.the.methods.to.provide.registration.and.noti- fication.services.are.implemented.in.terms.of.a.C.STL.list.as.presented.in.Listing.7.28. With.the.registration.mechanism.in.place.all.services.realize.the.Service.interface.to. acquire.notification.capabilities.Listing.7.29.presents.an.example.for.the.EmailService. observer. An.example.of.the.registration.and.notification.mechanism.is.presented.in.Listing.7.30. As.seen.many.different.observers.can.register.with.the.DecisionEngine.object.to.get. notifications.of.weather.alerts. Benefits .

--- Chunk 430 ---
Tokens: 380
Type: sentence-based
Text:
Benefits . Flexibility.for.adding.new.services.to.the.system . Maintaining.and.modifying.existing.system.services.become.easier.because.specific. services.are.compartmentalized Listing 7.28: C Code to Provide Registration and Notification to Observers  Provide the registration mechanism for all observers. void ServiceNotifier:attach(Service pService)   Add this observer to the list of registered observers. Assume a  valid pointer. _services.push_back(pService); ;  The trigger mechanism to notify all observers of class cancellation. void ServiceNotifier:notify(string message)   Get an Iterator that points to the beginning of the  observers_ list. listService:iterator pIter  _services.begin();  Iterate through the list of observers and notify them. for( int i  0; i  _services.size(); i )   Pass the message along to all registered observers. (pIter)-update(message);   Structural and Behavioral Patterns in Detailed Design  255 Skill Development 7.3: Observer Design Pattern Using.the.UML.tool.of.choice.create.the.detailed.component.design.of.the.MVC.archi- tectural.design.presented.in.Figure 4.9.using.the.observer.design.pattern.Generate. code.from.the.model.and.create.a.test.driver.method.to.validate.the.design.Explain. the.differences.between.the.MVC.architectural.pattern.and.the.observer.design.pattern. in.this.example. Listing 7.29: C Code for the Update() Method of the EmailService Observer class EmailService : public Service  public:  Once the Observable object changes, it will call this method.

--- Chunk 431 ---
Tokens: 392
Type: sentence-based
Text:
Listing 7.29: C Code for the Update() Method of the EmailService Observer class EmailService : public Service  public:  Once the Observable object changes, it will call this method. void update(string message)   Open file containing all users registered for email  notification. Open connection to the Email server. For all registered clients, notify them via email. . ; Listing 7.30: C Registration and Notification Mechanism of the WeatherDataObject  Sends message as email. EmailHandler emailHandler;  Sends message as text message. SmsHandler smsHandler;  Translates message to speech and sends it via the voice interface. VoiceHandler voiceHandler;  Assume that the decision engine object is a singleton. DecisionEngine:getInstance()-register(emailHandler); DecisionEngine:getInstance()-register(smsHandler); DecisionEngine:getInstance()-register(voiceHandler); 256  Software Engineering Design CHAPTER SUMMARY Structural.and.behavioral.designs.patterns.help.identify.problems.that.deal.with.the.structure. and.behavior.of.software.designs.they.prescribe.the.classes.required.for.their.design.solu- tion.and.interrelationships.required.to.support.object.creation.These.patterns.allow.design- ers.to.quickly.and.systematically.identify.structural.layouts.of.systems. (or subsystems).and. provide.avenues.for.examining.the.systems.interactions.and.quality.evaluation.within.the. operational.system.Structural.design.patterns.are.patterns.that.deal.with.designing.larger. structures.from.existing.classes.or.objects.at.run.time.They.play.a.key.role.in.the.design.and.

--- Chunk 432 ---
Tokens: 383
Type: sentence-based
Text:
structures.from.existing.classes.or.objects.at.run.time.They.play.a.key.role.in.the.design.and. evolution.of.systems.by.allowing.integration.of.new.designs.with.existing.ones.via.object. composition.(i.e.object.structural).or.inheritance. (i.e.class.structural).By allowing.designs. to.build.on.other.existing.structures.systems.can.be.made.interoperable.by.designing.com- patible.interfaces.for.otherwise.incompatible.systems.Examples.of.structural.design.patterns. include.adapter.composite.and.facade.design.patterns.Behavioral.design.patterns.deal.with. encapsulating.behavior.with.objects.assigning.responsibility.and.managing.object.coopera- tion.when.achieving.common.tasks.Behavioral.design.patterns.include.many.of.the.main- stream.design.patterns.used.in.modern.object-oriented.frameworks.and.play.a.key.role.in.the. design.of.systems.by.making.them.independent.of.specific.behavior.which.is.made.replace- able.with.objects.throughout.these.design.patterns.Therefore.parts.of.the.system.respon- sible.for.performing.some.algorithm.or.behavior.do.so.by.relying.on.a.common.interface. without.knowledge.of.how.the.actual.behavior.or.algorithm.is.carried.out.In addition.by. controlling.the.behavioral.process.with.common.interfaces.enforcing.behavioral.policies. becomes.easier.therefore.giving.systems.the.ability.to.create.algorithms.that.share.a.com- mon.interface.but.vary.widely.in.behavior.Examples.of.behavioral.patterns.include.the. iterator.and.the.observer.This.chapter.explored.each.structural.and.behavioral.design.

--- Chunk 433 ---
Tokens: 400
Type: sentence-based
Text:
iterator.and.the.observer.This.chapter.explored.each.structural.and.behavioral.design. pattern.to.present.the.problems.they.are.designed.to.address.together.with.the.benefits. they.provide.Identifying.and.designing.using.these.design.patterns.can.improve.the.effi- ciency.of.the.development.process.and.the.quality.of.the.final.system. REVIEW QUESTIONS . 1.What.are.structural.design.patterns.What.are.they.used.for? . 2.Compare.and.contrasts.the.following.patterns: . a. Adapter . b. Composite . 3.What.is.the.adapter.design.pattern.Explain.its.main.benefits.and.features. . 4.What. is. the. composite. design. pattern. List. and. explain. the. main. features. of. the. builder.design.pattern. . 5.Give.an.example.each.of.both.adapter.and.composite.design.patterns.Do.not.use.the. ones.presented.in.the.chapter. Structural and Behavioral Patterns in Detailed Design  257 . 6.Explain.the.steps.required.to.implement.the.composite.design.pattern. . 7.What.is.the.facade.design.pattern.What.does.it.do? . 8.What.are.the.essential.structural.elements.required.in.the.composite.design.pattern? . 9.What.are.the.main.benefits.of.using.the.iterator.design.pattern? . 10.What. is. the. observer. design. pattern. Give. one. example. of. a. particular. software. .feature.that.you.think.is.appropriate.for.applying.the.observer. . 11.What.are.the.essential.elements.required.in.the.observer.design.pattern? CHAPTER EXERCISES . 1.You.have.been.hired.to.work.on.a.car.testing.utility.class.The.car.testing.utility. class.has.one.method.with.the.following.signature.void testCar(Car pCar). As. seen. the. testCar.

--- Chunk 434 ---
Tokens: 400
Type: sentence-based
Text:
testCar. function. is.designed.to.test.objects.of.the.type. Car. The. car. interface. supports. the. following. methods. void. enableCruise(). void. .openWindow().void.closeWindow().and.void.accelerate(int mph).The. test.utility.function.is.currently.being.used.to.test.objects.of.type.TypicalCar. which.support.all.interface.methods.However.the.test.utility.is.now.needed.to.test. objects.of.the.new.type.RaceCar.however.the.RaceCar.type.only.supports.the. accelerateReallyFast(int mph).method.Use.an.appropriate.design.pattern. to.allow.the.RaceCar.type.to.be.used.in.the.testCar.utility.function.Feel.free.to. make.any.assumptions.necessary.to.complete.the.design.The.usage.and.output.are. presented.below. void testCar(Car pCar)  pCar-enableCruise(); pCar-openWindow(); pCar-closeWindow(); pCar-accelerate(50);   Sample output - if typical car passed in to the test utility  function. TypicalCar:enabling smart cruise control. TypicalCar:opening 2 windows. TypicalCar:closing 2 windows. TypicalCar:accelerating fast to 50 mph. Sample output - if race car passed in to the test utility  function. ConcreteRaceCar:no cruise control available. ConcreteRaceCar:no window available. ConcreteRaceCar:no window available. ConcreteRaceCar:accelerating really fast to 50 mph. 258  Software Engineering Design REFERENCE Gamma. Erich. Richard. Helm. Ralph. Johnson. and. John. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software.Boston.Addison-Wesley.1995. 259 8 Principles of Construction Design CHAPTER OBJECTIVES . Understand.the.importance.and.role.of.construction.design . Identify.

--- Chunk 435 ---
Tokens: 399
Type: sentence-based
Text:
Identify. understand. and.apply.table-based.and.state-based.func- tion.design . Identify.understand.and.apply.the.general.construction.styles . Understand.how.quality.can.be.evaluated.during.construction.design CONCEPTUAL OVERVIEW The. transition. from. software. design. to. construction. should. occur. with. minimal.effort.In.some.cases.component.designs.provide.enough.detail. to.allow.their.transformation.from.design.artifact.into.code.easily.how- ever.in.other.cases.a.more.fine-grained.level.of.design.detail.is.required. Construction.design.provides.a.form.of.design.that.closely.resembles.code.so. that.complex.operations.can.be.planned.and.evaluated.prior.to.implemen- tation.in.code.Once.the.correctness.of.operations.is.verified.the.construc- tion.design.activity.provides.additional.heuristics.to.enforce.consistency. in.the.code.Construction.design.provides.the.last.form.of.design.to.create. high-quality.software.operations.that.are.correct.consistent.and.efficient. WHAT IS CONSTRUCTION DESIGN? The. idea. of. the. detailed. design. phase. is. to. manage. complexity. so. that. design.artifacts.can.be.translated.to.code.with.minimal.effort.Even.though. 260  Software Engineering Design significant.attempts.can.be.made.during.the.detailed.(component).design.activity.to.create. extensive.designs.in.most.practical.applications.transitioning.from.the.component.design. domain.to.code.can.still.be.daunting.Regardless.of.the.amount.of.effort.spent.during. the.design.phase.additional.design.efforts.may.still.be.required.during.construction.to. .identify. plan. and. manage. the.

--- Chunk 436 ---
Tokens: 388
Type: sentence-based
Text:
the. construction. of. complex. operations. This. form. of. con- struction.design.extends.the.work.performed.during.detailed.design.to.provide.essential. information.that.is.used.to.generate.correct.efficient.and.consistent.code.Construction. design.is.the.lowest.level.of.detailed.design.that.addresses.the.modeling.and.specification. of.function.implementations.By.designing.complex.operations.problem.solutions.can.be. evaluated.analyzed.and.verified.for.correctness.and.efficiency.before.construction.using. programming.languages.Construction.design.provides.the.means.for.evaluating.problem. solutions.using.a.form.of.design.that.closely.relates.to.codethat.is.a.form.of.design.that. models.what.the.code.does.and.how.the.code.is.specified. Construction.design.can.address.problem.solving.from.a.dynamic. (behavioral).perspec- tive.which.provides.the.description.of.operations.(such.as.methods.and.functions).and.the. internal details.and.logic.of.each.design.entity. (IEEE.2009).This.approach.involves.graph- ical.tabular.or.other.methods.to.model.and.specify.the.internal.structure.of.functions. (e.g, operations.routines).so.that.the.algorithms.or.flows.required.to.carry.out.a.functions. intent.are.evaluated.and.clearly.specified.The.algorithm.approach.minimizes.complexity. during.construction.by.providing.a.graphical.method.for.specifying.the.details.required. by.programmers.to.implement.the.functions.code.A.separate.but.closely.related.task.per- formed.when.evaluating.the.quality.of.software.construction.deals.with.enforcing.styles.for.

--- Chunk 437 ---
Tokens: 365
Type: sentence-based
Text:
by.programmers.to.implement.the.functions.code.A.separate.but.closely.related.task.per- formed.when.evaluating.the.quality.of.software.construction.deals.with.enforcing.styles.for. establishing.a.consistent.approach.to.structuring.function.implementations.These.styles. play.a.significant.role.in.shaping.the.systems.maintainability.complexity.and.testability. Therefore.they.are.included.as.part.of.the.construction.design.activity. Construction.design.is.not.a.new.concept.In.fact.there.are.many.books.covering.con- struction.design.under.different.names.McConnell.(2004).specifies.five.levels.of.software. design.the.lowest.two.of.which.deal.with.division.of.data.and.routines.within.classes.and. internal.routine.design.Similarly.Fox.(2006).identifies.a.form.of.low-level.design.that.fills. the.gap.between.detailed.design.and.programming.and.deals.with.issues.such.as.opera- tion.specification.including.operation.name.parameter.types.and.return.types.Similarly. Meyer.(1997).and.Misfeldt.Bumgardner.Gray.and.Xiaoping.(2004).provide.coverage.of. construction.design. WHY STUDY CONSTRUCTION DESIGN? Construction.design.is.about.developing.abstract.models.of.the.structure.and.behavior.of. the.internal.implementation.of.operations.From.a.behavioral.perspective.construction. design.is.important.because.it.provides.the.means.for.evaluating.different.implementations. for.a.particular.function.before.committing.to.it.Behavioral.designs.at.this.level.provide.

--- Chunk 438 ---
Tokens: 398
Type: sentence-based
Text:
for.a.particular.function.before.committing.to.it.Behavioral.designs.at.this.level.provide. Principles of Construction Design  261 the.means.to.evaluate.a.functions.completeness.complexity.testability.and.maintainabil- ity.They.also.provide.the.means.for.analysts.to.evaluate.algorithms.in.regard.to.timespace. performance.and.processing.logic.prior.to.implementation.(IEEE.2009).Finally.since.they. provide.a.representation.of.the.code.through.graphical.and.tabular.ways.they.increase. collaborative.evaluation.efforts.since.other.members.without.knowledge.of.the.particu- lar.programming.language.in.use.can.evaluate.the.design.and.contribute.to.the.solution. These.collaboration.efforts.can.lead.to.improvement.in.future.phases.for.example.the. testing.phase.where.construction.designs.can.be.used.to.generate.unit.test.cases.or.the. maintenance.phase.where.construction.designs.can.be.used.to.increase.knowledge.and. understanding.of.the.software.behavior. From.the.structural.perspective. (i.e.construction.styles).construction.design.is.impor- tant.because.it.provides.heuristics.for.establishing.a.common.criterion.for.evaluating.the. quality.of.the.structure.of.code.which.directly.affects.code.readability.and.thus.mainte- nance.Code.with.low.readability.leads.to.higher.maintenance.costs.since.it.requires.more. effort.to.understand.(Collar.2005).Construction.styles.are.important.during.the.design. and.construction.phases.so.that.code.generation.from.design.models.can.be.done.correctly. From.a.construction.phase.perspective.construction.styles.serve.as.a.blueprint.that.ensures.

--- Chunk 439 ---
Tokens: 388
Type: sentence-based
Text:
From.a.construction.phase.perspective.construction.styles.serve.as.a.blueprint.that.ensures. consistency.among.teams.of.developers.Finally.as.mentioned.before.during.the.testing. and.maintenance.phase.construction.styles.increase.code.readability.and.understanding. which.can.result.in.minimized.cost.during.these.phases. BEHAVIORAL CONSTRUCTION DESIGN Behavioral. designs. at. the. construction. level. are. used. to. model. complex. logic. that. is. unknown.or.difficult.to.understand.This.way.details.required.to.describe.an.operation. can.be.discovered.or.evaluated.without.requiring.code.The.purpose.of.behavioral.design. is.to.model.the.dynamic.aspects.of.code.that.makes.up.a.particular.function.Behavioral. designs.have.been.the.topic.of.much.research.work.in.software.engineering.and.are.an. integral.part.of.all.major.software.design.strategies.(e.g.structured.and.object-oriented. designs).Behavioral.designs.provide.the.means.for.assessing.the.completeness.correct- ness.and.quality.of.functions.before.actual.implementation.occurs.and.therefore.are.an. essential.activity.for.complex.operations.Four.major.approaches.to.behavioral.design.at. the.construction.level.are.flow-based.designs.state-based.designs.table-based.designs.and. programming.design.languages. Flow-Based Designs Flow-based.designs.provide.a.systematic.methodology.for.specifying.the.logic.of.opera- tions.using.a.graphical.approach.Two.popular.approaches.for.creating.flow-based.designs. include.flowcharts.and.Unified.Modeling.Language.(UML).activity.diagrams.Both.work.

--- Chunk 440 ---
Tokens: 388
Type: sentence-based
Text:
include.flowcharts.and.Unified.Modeling.Language.(UML).activity.diagrams.Both.work. 262  Software Engineering Design well.for.modeling.the.internal.flow.of.routines.because.they.can.be.defined.using.sequential. process.flows.loops.conditional.statements.and.other.useful.mechanisms.needed.to.model. complex.business.logic.or.complicated.algorithms.UML.activity.diagrams.provide.power- ful.constructs.for.modeling.complex.logic.at.different.stages.of.the.software.engineering. life.cycle.however.when.applied.toward.modeling.logic.activity.diagrams.provide.similar. features.to.flowcharts.Four.important.modeling.constructs.for.flow-based.designs.are . If.statements . Case.statements . Do.while.loop . While.loops The.common.elements.used.to.model.flow-based.designs.using.UML.activity.diagrams. are.presented.in.Figure 8.1.together.with.examples.of.modeling.conditional.and.repeti- tion.statements. State-Based Designs Flow-based.designs.can.be.used.to.model.operational.logic.by.identifying.the.transitions. from.activity.to.activity.required.to.perform.an.operation.However.in.some.cases.the. operational.logic.of.a.function.or.system.is.dictated.by.the.different.states.that.the.system. exhibits.during.its.lifetime.That.is.certain.activities.can.be.performed.only.when.a.system. is.in.a.particular.state.When.this.occurs.the.operational.logic.of.a.system.can.be.modeled. as.a.state.machine.using.a.(UML).state.diagram.State.diagrams.are.typically.used.to.model. the.behavior.of.complete.system.However.in.many.practical.applications.state.diagrams.

--- Chunk 441 ---
Tokens: 383
Type: sentence-based
Text:
the.behavior.of.complete.system.However.in.many.practical.applications.state.diagrams. can.be.used.to.guide.the.logical.design.of.one.or.more.operations.in.the.system.Consider. the.state.design.presented.in.Figure 8.2. Figure 8.2. depicts. the. design. of. a. software. system. that. receives. messages. and. per- forms.operations.based.on.the.messages.received.and.the.systems.state.That.is.during. the.power-on.initialization.state.the.system.only.reacts.to.the.GetStatus.SelfTest.and.the. SoftwareUpdate. message. Once. the. SelfTest message. is. received. the. system. transitions. to.the.self-test.state.where.system.capabilities.are.evaluated.to.determine.the.integrity. of.the.system.Once.the.self-test.state.is.complete.two.transitions.can.occur.if.the.tests. were.successful.then.the.system.transitions.to.the.operational.state.and.if.any.failures.are. encountered.then.the.system.enters.a.fault.state.in.which.no.commands.can.be.executed. Once.the.fault.state.is.complete.the.system.transitions.to.a.power-down.state.which.allows. the.system.to.save.all.pertinent.information.to.the.file.system.before.transitioning.to.the. .initialization. (Power On).state. Upon.successfully.execution.of.the.self-test.state.the.system.transitions.to.the.operational. state.where.all.messages.in.the.system.can.be.processed.including.the.SelfTest.message.and. ShutDown.message.As.seen.the.state.diagram.presents.the.state.of.the.system.together. with.the.transitions.and.the.events.that.trigger.each.transition.Unlike.the.flow-based.design.

--- Chunk 442 ---
Tokens: 388
Type: sentence-based
Text:
with.the.transitions.and.the.events.that.trigger.each.transition.Unlike.the.flow-based.design. Principles of Construction Design  263 approach.in.the.previous.section.the.systems.state-based.designs.show.the.flow.of.opera- tions.from.state.to.state.it.acts.like.a.well-structured.algorithm.that.is.efficient.simple. adaptable.and.understandable.(Booch.Rumbaugh.and.Jacobson.2005).It.also.presents. the.full.operation.of.a.complete.system.during.its.lifetime.which.can.be.derived.from.the. design.Consider.the.implementation.of.Listing.8.1.which.implements.the.state.machine. Initially.the.system.is.set.to.the.Power-OnState.therefore.upon.executing.the.code.the. executePowerOnState().method.is.called.to.process.the.received.message.and.deter- mines.if.a.state.change.is.required.(or.not).as.seen.in.Listing.8.2.Listing.8.2.uses.a.message. queue.for.retrieving.messages.received.in.the.system. Branch Transition If Statement Case Statement true true true true Action Final State Activity 1 Activity Diagram Examples Initial State Elements in Activity Diagram Activity2 Activity3 Activity5 Activity6 Activity1 false false false false Do While Loop Activity4 Activity7 Activity8 true false While Loop FIGURE 8.1 Flow-based.logic.design.using.UML.activity.diagrams. 264  Software Engineering Design The.source.of.the.code.presented.in.Listing.8.2.can.be.traced.back.to.the.state.design. presented.in.Figure 8.2.As.seen.once.the.EmbeddedComponent.is.in.the.power-on.state. it.can.execute.the.messages.only.for.updating.the.software.retrieving.the.components.

--- Chunk 443 ---
Tokens: 392
Type: sentence-based
Text:
it.can.execute.the.messages.only.for.updating.the.software.retrieving.the.components. status.and.executing.a.self-test.Messages.containing.different.IDs.cannot.be.executed.in. this.state.therefore.upon.receiving.any.other.message.the.system.logs.an.event.and.waits. for.the.next.message.to.be.received.In.a.similar.fashion.the.code.for.all.other.states.is. implemented.according.to.the.state.design.as.presented.in.Listings.8.3.and.8.4. As.seen.once.the.EmbeddedComponent.enters.the.self-test.state.it.executes.the.appro- priate.tests.and.based.on.the.tests.results.it.sets.the.new.system.state.to.the.operational. or.fault.state.as.defined.in.the.state.design.Assuming.all.tests.are.performed.successfully. the.EmbeddedComponent.transitions.to.the.operational.state.where.all.messages.can.be. received.and.processed.by.the.EmbeddedComponent.The.implementation.for.the.opera- tional.sate.is.presented.in.Listing.8.4. Table-Based Designs Many.times.the.internal.logic.of.routines.is.made.up.of.complex.conditional.statements. each.statement.evaluating.a.condition.(i.e.a.cause).and.providing.some.action. (i.e, an. effect). as. a. result. This. can. lead. to. an. increasingly. complex. nesting. structure. that. is. error-prone.hard.to.read.and.hard.to.maintain.In.these.cases.the.logic.design.can.be. managed.using.a.decision.table.(Hurley.1982).A.decision.table.is.a.well-structured.table. that.provides.the.means.to.formulate.evaluate.and.improve.the.design.of.complex.prob- lems.that.deal.with.cause.and.effect.The.format.of.decision.tables.is.presented.in.Table 8.1.

--- Chunk 444 ---
Tokens: 394
Type: sentence-based
Text:
that.provides.the.means.to.formulate.evaluate.and.improve.the.design.of.complex.prob- lems.that.deal.with.cause.and.effect.The.format.of.decision.tables.is.presented.in.Table 8.1. Table 8.1.has.four.different.sections.The.first.section.is.the.Condition.section.which. contains.a.list.of.all.of.the.conditions.present.in.the.decision.problem.The.second.section. is.the.Action.section.which.contains.a.list.of.all.possible.outcomes.that.can.result.from.one. or.more.conditions.occurring.The.third.and.fourth.sections.are.found.in.matrix.form. adjacent.to.the.Condition.and.Action.sections.The.matrix.adjacent.to.the.Condition.section. indicates. all. possible. combinations. of. conditions. for. the. decision. problem. while. the. matrix.adjacent.to.the.Action.section.indicates.the.corresponding.actions.Combined.the. SelfTest Fault Operational Power On SelfTest Msg Received SelfTest Msg Received Fault Processing Complete All Other Messages Received Power Down Process Complete GetStatus Msg UpdateSoftware Msg ShutDown Msg Received Test Passed Tests did not pass Power Down FIGURE 8.2 Example.of.a.state.design.using.UML.state.diagrams. Principles of Construction Design  265 respective.columns.in.both.matrices.provide.a.policy.for.decision.making.in.the.decision. .problem.Four.types.of.decision.tables.are.as.follows. (Hurley.1982): . Limited-entry.decision.table. (LEDT) . Extended-entry.decision.table. (EEDT) . Mixed-entry.decision.table. (MEDT) . Hybrid-entry.decision.table. (HEDT) Listing 8.1: C Implementation of the State Design  The state machines execute method.

--- Chunk 445 ---
Tokens: 400
Type: sentence-based
Text:
(HEDT) Listing 8.1: C Implementation of the State Design  The state machines execute method. void EmbeddedComponent:execute()   Execute the state machine. _compnentState is a member variable  of the EmbeddedComponent class. switch( _componentState )  case PowerOnState:  Execute in the power on state. When finished, allow the  executing function to determine if a state change is required  (or not) and set the state appropriately. This capability is  provided by executing functions in all other states. executePowerOnState(); break; case SelfTestState:  Execute in the self test state. executeSelfTestState(); break; case OperationalState:  Execute in the operational state. executeOperationalState(); break; case FaultState:  Execute in the fault state. executeFaultState(); break; case PowerDownState:  Execute in the power down state. executePowerDownState(); break; default:  invalid state, log error. break;   266  Software Engineering Design Limited-Entry Decision Table The.LEDT.is.the.simplest.type.of.decision.table.in.which.the.condition.section.of.the. LEDT.presents.Boolean.conditional.statements.That.is.the.condition.section.of.the.LEDT. .presents.features.of.the.design.problem.that.are.either.present.or.not.and.their.combined. presence.(or.absence).triggers.specific.actions.Therefore.the.condition.entry.section.of. the.LEDT.consists.of.Boolean.values.such.as.true.or.false.or.yes.or.no.that.can.be.used.to. define.different.policies.in.the.decision.problem.For.example.consider.the.LEDT.design. for.a.function.that.computes.discounts.for.the.purchase.of.mobile.phones.Two.types.of.

--- Chunk 446 ---
Tokens: 355
Type: sentence-based
Text:
for.a.function.that.computes.discounts.for.the.purchase.of.mobile.phones.Two.types.of. discounts.are.available.a.store.discount.of.15.and.a.manufacturer.discount.of.30.as. presented.in.Table 8.2. Using.the.information.specified.in.the.LEDT.from.Table 8.2.the.code.for.the.function. used.to.compute.phone.discounts.can.be.easily.implemented.simply.by.translating.the. information.captured.in.the.LEDT.to.code.as.presented.in.Listing.8.5.The.table.name.is. Listing 8.2: C Implementation of the PowerOn State void EmbeddedComponent:executePowerOnState()   Assume messages are received and placed in a blocking message  queue. Therefore, the messageQueue.read call is a blocking call. Message message  messageQueue.read(WAIT_FOREVER);  Retrieve the messages id. MessageIdType messageId  message-getId();  This state only processes three messages according to the state  diagram. if( messageId  UpdateSoftwareMsgId )   Cast message to an UpdateSoftwareMsg. Retrieve the software image from the message and update  software. else if( messageId  GetStatusMsgId )   Retrieve status from File System and return to client. else if( messageId  SelfTestMsgId )   Cast message to a SelfTestMsg. Retrieve the type of self test and change state. selfTestType_  message-getTestType(); _componentState  SelfTestState;  else   Any other message received in this state results in an error. Log the specific error here and do not change state.

--- Chunk 447 ---
Tokens: 380
Type: sentence-based
Text:
Log the specific error here and do not change state. Principles of Construction Design  267 Listing 8.3: C Implementation of the SelfTest State void EmbeddedComponent:executeSelfTestState()   No messages are processed during self test. Perform either a simple, normal, or advanced test. Advanced tests  perform a complete test of the system, therefore they take  longer to complete. if( performTest(_selfTestType) )   Software and hardware are working properly. Log results and  change state to the operational state. _componentState  OperationalState;  else   Faulty system software or hardware! Log results and change  state to the Fault state. _componentState  FaultState;   Listing 8.4: C Implementation of the Operational State void EmbeddedComponent:executeOperationalState()   Assume messages are received and placed in a blocking message  queue. Therefore, the messageQueue.read call is a blocking call. Message message  messageQueue.read(WAIT_FOREVER);  Retrieve the messages id. MessageIdType messageId  message-getId();  Process messages according to the state diagram. if(  messageId  x  )   Process message x.  else if(  messageId  y  )   Process message y.  else if ( . . else   Invalid message. Log error. 268  Software Engineering Design used.to.name.the.function.and.the.two.items.in.the.conditional.section.of.the.table.are. translated.as.conditional.statements.in.the.code.The.action.portion.of.the.table.is.used. to.determine.the.code.executed.when.each.of.the.conditional.statements.evaluate.to.true.

--- Chunk 448 ---
Tokens: 395
Type: sentence-based
Text:
to.determine.the.code.executed.when.each.of.the.conditional.statements.evaluate.to.true. For example.Policy.1.(P1).states.that.the.15.and.30.discounts.are.applied.when.both.store. and.manufacturer.discounts.are.active.(as.seen.by.the.xs.in.the.table).This.behavior.is.seen. in.Listing.8.5. Although.such.a.simple.problem.hardly.requires.effort.to.design.it.is.valuable.in.point- ing.out.several.important.characteristics.of.LEDTs.As.seen.the.condition.section.contains. features.that.are.either.present.or.not.for.each.policy.defined.in.the.problem.These.condi- tions.represent.questions.for.determining.the.types.of.discounts.(i.e.store.or.manufacturer. discounts).that.are.in.effect.and.the.types.of.polices.required.for.each.possible.combination. of.discounts.The.condition.entry.section.follows.by.providing.answers.to.all.possible.com- binations.for.the.given.problem.As.seen.for.an.LEDT.the.number.of.distinct.elementary. policies.is.2n.where.n.is.the.number.of.conditions.in.the.condition.section.In this.example. where.n .2.there.are.four.distinct.policies.It.is.also.evident.that.the.fourth.policy.(P4).is. never.applied.to.the.implementation.presented.in.Listing.8.5.Therefore.this.policy.could. have.been.left.out.of.the.decision.table.since.it.represents.not.an.action.but.the.absence.of. one.Such.policies.that.are.left.out.of.the.decision.table.are.referred.to.as.missing policies. Finally.it.can.be.seen.that.all.policies.result.in.a.unique.set.of.actions.When.two.or.more. policies.result.in.identical.actions.the.actions.are.considered.redundant actions.and.can.be.

--- Chunk 449 ---
Tokens: 369
Type: sentence-based
Text:
policies.result.in.identical.actions.the.actions.are.considered.redundant actions.and.can.be. combined.to.simplify.the.decision.table. Extended-Entry Decision Table Whereas. the. condition. and. action. sections. of. LEDTs. contain. complete. questions. and. actions.the.condition.and.action.sections.of.the.EEDT.are.extended.into.the.entry.sections. (i.e.upper-condition.entry.section.and.lower-action.entry.section).of.the.decision.table. That.is.in.LEDTs.the.condition.section.contained.information.that.can.be.used.to.ask.a. TABLE 8.1 Fundamental.Structure.of.Decision.Tables Condition Condition Entry Action Action Entry TABLE 8.2 Limited-Entry.Decision.Table.for.the.Phone.Discount.Logic Get Phone Discount P1 P2 P3 P4 Store.Discount T T F F Manufacturer.Discount T F T F 15.Discount x x 30.Manufacturer.Discount x x No.Discount. (0) x Principles of Construction Design  269 complete.questions.such.as.Is.there.a.store.discount.in.effect.In.EEDTs.the.condition. and.condition.entry.sections.of.the.table.are.required.to.formulate.a.complete.question. such.as.Is.the.customer.a.regular.preferred.or.VIP.customer.Similarly.the.action. .section.must.be.combined.with.the.action.entry.section.of.the.decision.table.to.formulate. a.complete.action.such.as.add.a.free.car.kit.to.the.purchase.In.addition.the.number.of. possible.values.for.each.condition.and.action.in.EEDTs.is.not.bounded.to.two.An.example. of.the.EEDT.for.the.customer.discount.logic.is.presented.in.Table 8.3.

--- Chunk 450 ---
Tokens: 394
Type: sentence-based
Text:
of.the.EEDT.for.the.customer.discount.logic.is.presented.in.Table 8.3. Listing 8.5: Implementation of the LEDT for the Phone Discount Function int getPhoneDiscount()  const int StoreDiscount  15; const int ManufacturerDiscount  30;  The total added phone discount. int phoneDiscount  0;  Determine if the store discount applies. if( isStoreDiscountActive )   Apply the stores discount. phoneDiscount  StoreDiscount;   Determine if the manufacturer discount applies. if( isManufacturerDiscountActive )   Apply the manufacturers discount. phoneDiscount  ManufacturerDiscount;   Return the total added phone discount. return phoneDiscount;  TABLE 8.3 Extended-Entry.Decision.Table.for.the.Customer.Discount.Logic Get Phone Discount P1 P2 P3 P4 P5 P6 Customer.type.is REG REG PRE PRE VIP VIP Credit.score.is BAD GOOD BAD GOOD BAD GOOD Discount 0 15 10 25 50 100 Add.a.free HOLSTER CHARGER BLUE. TOOTH CAR. KIT DATA. PLAN CAR.KIT. DATA.PLAN 270  Software Engineering Design As.seen.customers.can.be.of.type.regular.(REG).preferred.(PRE).or.very.important. (VIP).therefore.the.number.of.possible.values.for.the.type.of.customer.condition.is.three. Also.actions.can.take.on.any.form.the.X.used.for.denoting.the.presence.or.absence.of. actions.in.LEDTs.cannot.be.applied.in.EEDTs.In.this.example.the.number.of.possible. .values.for.the.credit.score.condition.is.two.denoting.good.and.bad.credit.scores.Finally. the.number.of.distinct.elementary.policies.in.EEDTs.is.the.product.of.all.maximum.num- bers.of.possible.values.for.each.condition.In.this.example.this.result.in.3.2.6.policies.

--- Chunk 451 ---
Tokens: 390
Type: sentence-based
Text:
the.number.of.distinct.elementary.policies.in.EEDTs.is.the.product.of.all.maximum.num- bers.of.possible.values.for.each.condition.In.this.example.this.result.in.3.2.6.policies. (i.e, 3 for.Condition.1.and.2.for.Condition.2). Mixed-Entry Decision Table The.MEDT.combines.features.from.both.LEDTs.and.EEDTs.For.example.consider.a.com- pany.that.sells.mobile.phones.of.different.kinds.and.with.different.promotional.discounts. based.on.the.type.of.mobile.phone.The.software.used.to.manage.inventory.and.discounts. uses.a.method.to.return.the.total.discount.that.can.be.applied.toward.the.purchase.of.a. phone.The.company.carries.three.types.of.phones.a.simple.second-generation.(2G).phone. an.advanced.third-generation.phone.(3G).and.a.special.fourth-generation.(4G).phone. Depending.on.the.type.of.phone.different.store.discounts.are.applied.toward.the.total. purchase.of.the.phone.For.simple.phones.when.the.manufacturers.discount.is.in.effect. a.30.discount.can.be.applied.whereas.when.the.store.discount.is.in.effect.a.15.discount. can.be.applied.When.both.discounts.are.in.effect.a.45.discount.can.be.applied.toward. the.purchase.of.the.phone.For.advanced.phones.a.default.store.discount.of.60.is.always. applied.In.addition.when.the.manufacturers.discount.is.in.effect.an.additional.50.is. applied.when.the.store.discount.is.in.effect.an.additional.60.can.be.applied.since.a.free. Bluetooth.ear.piece.is.included.and.when.all.discounts.are.in.effect.all.discounts.can.be. applied.toward.the.price.of.the.phone.Finally.for.special.phones.a.default.discount.of.

--- Chunk 452 ---
Tokens: 400
Type: sentence-based
Text:
applied.toward.the.price.of.the.phone.Finally.for.special.phones.a.default.discount.of. 120.is.always.applied.Additionally.discounts.of.70.180.or.370. (i.e.the.sum.of.all.dis- counts).can.be.applied.toward.the.purchase.of.a.special.phone.The.problem.is.formulated. using.the.decision.table.presented.in.Table 8.4. Using.the.information.presented.in.Table 8.4.the.construction.of.the.function.applying.dis- counts.to.phone.products.can.take.place.Listing.8.6.presents.the.code.for.the.phone.type.used. in.this.problem.As.seen.the.phone.type.includes.interface.methods.for.returning.a.phones. type.(i.e.simple.advanced.or.special.phone).and.the.particular.discount.that.applies.the. phone.type. Using.the.phone.type.created.the.code.for.the.(getPhoneDiscount).function.is.presented. in.Listing.8.7.As.seen.the.code.matches.the.table-based.design.presented.in.Table 8.4. Table-Based Construction Table-based. construction. is. a. technique. for. transforming. table-based. designs. to. code. that.is.easy.to.maintain.read.and.so.forth.As.seen.the.resulting.code.for.implementing. the.table-based.design.from.Table 8.4.contains.various.conditional.statements.Similarly. table-based.designs.can.result.in.complex.code.that.is.hard.to.read.and.maintain.When. Principles of Construction Design  271 this.occurs.table-based.construction.can.be.used.to.shift.the.complexity.of.logic.to.the. problems. data. structure. Consider. the. data. structures. in. Listing. 8.8. designed. for. the. table-based.design.of.Table 8.4. As.seen.the.logic.defined.in.Table 8.4.is.now.captured.using.data.structures.through.the.

--- Chunk 453 ---
Tokens: 388
Type: sentence-based
Text:
As.seen.the.logic.defined.in.Table 8.4.is.now.captured.using.data.structures.through.the. discounts.array.The.discounts.array.consists.of.12.different.elements.of.the.Discount. type.Each.index.in.the.array.represents.one.of.the.12.policies.defined.during.the.table-based. design.from.Table 8.4.For.example.the.element.at.index.0.of.the.discounts.array.contains. the.discounts.defined.by.P1.of.Table 8.4.the.element.at.Index.1.contains.the.discounts. defined.by.P2.and.so.on.With.this.framework.in.place.the.code.from.Listing.8.7.can.be. reduced.to.the.one.presented.in.Listing.8.9.which.drastically.reduces.the.amount.of.code. required.to.achieve.the.same.operation. Programming Design Language Programming.design.language.(PDL).is.a.form.of.pseudo-code.used.widely.for.designing. internal.function.behavior.Its.popularity.stems.from.the.use.of.natural.languagesas. opposed.to.computer.languages.or.graphical.techniquesto.define.the.required.behav- ior.of.functions.This.results.in.detailed.function.designs.that.are.easier.to.create.review. and. translate. to. code. In. addition. the. usage. of. a. natural. language. in. PDL. provides. a. .comments-first.approach.to.constructing.code.for.any.programming.language.Therefore. PDL.should.be.written.without.concern.given.to.the.target.programming.language.and. detailed.enough.that.code.can.be.generated.with.minimal.effort. PDL.can.be.effectively.employed.using.a.top-down.approach.that.first.describes.the.gen- eral.work.performed.by.the.function.and.then.more.specific.operations.within.the.function.

--- Chunk 454 ---
Tokens: 394
Type: sentence-based
Text:
PDL.can.be.effectively.employed.using.a.top-down.approach.that.first.describes.the.gen- eral.work.performed.by.the.function.and.then.more.specific.operations.within.the.function. (McConnell.2004).The.description.of.the.general.work.performed.by.the.function.should. TABLE 8.4 Mixed-Entry.Decision.Table.for.the.Phone.Discount.Logic Get Phone Discount Simple Phone Policies Advanced Phone Policies Special Phone Policies P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 Phone.type.is S S S S A A A A SP SP SP SP Manufacturer.discount F T F T F T F T F T F T Store.discount F F T T F F T T F F T T 15.discount x x 60.discount x x x x 120.discount x x x x 30.manufacturer.discount x x 50.manufacturer.discount x x 70.manufacturer.discount x x Bluetooth.discount. (60) x x 6-month.data.discount. (180) x x No.discount. (0) x 272  Software Engineering Design include.the.functions.intent.inputs.and.outputs.Once.the.general.purpose.of.the.function. is.in.PDL.form.individual.parts.are.elaborated.in.PDL.form.to.provide.complete.design. details.for.the.function.When.finished.the.functions.detailed.PDL.should.result.in.the. identification.of.operations.that.support.the.general.description.of.the.function.Therefore. PDL.can.be.used.as.both.design.technique.and.effective.documentation.approach.for.func- tions.and.code.within.functions.An.example.of.a.detailed.function.design.using.PDL.is. presented.in.Listing.8.10. There.are.many.benefits.of.using.PDL.First.PDL.provides.a.programming.language- independent. technique. for. creating. detailed. function. designs. therefore. collaborative.

--- Chunk 455 ---
Tokens: 380
Type: sentence-based
Text:
collaborative. efforts.with.all.disciplines.involved.in.the.project.can.be.achieved.to.provide.complete. reviews.for.the.design.of.a.function.That.is.members.from.the.systems.hardware.quality. and.test.groups.can.all.chime.in.to.help.the.function.design.meet.the.required.capabilities. Listing 8.6: Implementation of the Phone Class to Support the Table-Based Design  The different types of phones. typedef enum SIMPLE_PHONE  0, ADVANCED_PHONE  1, SPECIAL_PHONE  2 PhoneType;  The different types of discounts options. typedef enum NO_DISCOUNT  0, MANUFACTURER_DISCOUNT  3, STORE_DISCOUNT  6, COMBINED_DISCOUNT  9 DiscountType;  The Phone class. class Phone  public:  Constructor. Phone(PhoneType type, DiscountType discountType)  _type  type; _discountType  discountType;   Return the type of phone. PhoneType getType() return _type;   Return the discount type for this phone. DiscountType getDiscountType()  return _discountType;  private: PhoneType _type; DiscountType _discountType; ; Principles of Construction Design  273 Listing 8.7: Implementation for the Phone Discount Function int getPhoneDiscount(const Phone phone)  int totalDiscount  0;  The total computer discount. if( phone.getType()  SIMPLE_PHONE )  if( phone.getDiscountType()  MANUFACTURER_DISCOUNT)   Add 30 manufacturers discount to totalDiscount. else if( phone.getDiscountType()  STORE_DISCOUNT )   Add 15 store discount to totalDiscount. else if( phone.getDiscountType()  COMBINED_DISCOUNT )   Add 30 and 15 to totalDiscount. else   No discount.

--- Chunk 456 ---
Tokens: 387
Type: sentence-based
Text:
else   No discount. else if( phone.getType()  ADVANCED_PHONE )   Add 60 default advanced phone discount to totalDiscount. if( phone.getDiscountType()  MANUFACTURER_DISCOUNT)   Add additional 50 manufacturers discount to totalDiscount. else if( phone.getDiscountType()  STORE_DISCOUNT )   Add additional Bluetooth ear piece discount (60) to  totalDiscount. else if( phone.getDiscountType()  COMBINED_DISCOUNT )   Add additional 50 and 60 to totalDiscount. else   No additional discount. else if( phone.getType()  SPECIAL_PHONE )   Add 120 default special phone discount to totalDiscount. if( phone.getDiscountType()  MANUFACTURER_DISCOUNT)   Add additional 70 manufacturers discount to totalDiscount. else if( phone.getDiscountType()  STORE_DISCOUNT )   Add additional 6 month data plan discount (180). else if( phone.getDiscountType()  COMBINED_DISCOUNT )   A additional 70 and 180 to totalDiscount. else   No additional discount. return totalDiscount;  Return the computed phone discount. 274  Software Engineering Design from.different.viewpoints.Another.important.benefit.from.using.PDL.is.the.reduction.of. commenting.efforts.Since.PDL.is.written.at.the.construction.design.level.it.provides.full. documentation.of.what.the.function.does.and.the.meaning.of.actions.within.operations. therefore.once.code.is.generated.PDL.is.turned.into.complete.and.meaningful.program- ming-language. comments. for. the. function. (McConnell. 2004). Finally. using. the. PDL. approach.greatly.benefits.the.documentation.effort.especially.when.using.documentation.

--- Chunk 457 ---
Tokens: 391
Type: sentence-based
Text:
approach.greatly.benefits.the.documentation.effort.especially.when.using.documentation. techniques.that.allow.for.the.creation.of.software.documentation.from.the.comments.in. code.(e.g.Javadoc).In.these.cases.PDL.provides.the.process.for.creating.reviewing.and. evaluating.the.function.documentation.therefore.increasing.its.quality. SOFTWARE CONSTRUCTION USING STYLES Construction.styles.are.not.about.programming.but.about.defining.the.rules.or.guidelines. for.everyone.in.the.project.for.writing.the.source.code.for.a.computer.program.Combined. with.the.logic.design.styles.provide.the.final.piece.to.generate.high-quality.and.consistent. Listing 8.8: Table-Based Implementation for Computing Phone Discounts struct Discounts  int smallStoreDiscount;  For this example, it should be 15. int mediumStoreDiscount;  For this example, it should be 60. int highStoreDiscount;  For this example, it should be 120. int smallManufacturerDiscount;  For this example, it should be 30. int mediumManufacturerDiscount;  For this example, it should be 50. int highManufacturerDiscount;  For this example, it should be 70. int bluetoothDiscount;  For this example, it should be 60. int dataPlanDiscount;  For this example, it should be 180. ;  The discounts available for simple phones (SIM), advanced phones (ADV),  and special phones (SPE), all accessible via discount keys (DK). Discounts discounts    0, 0, 0, 0, 0, 0, 0, 0 ,  DK0, SIM No discounts. 0, 60, 0, 0, 0, 0, 0, 0 ,  DK1, ADV Stores default discount. 0, 0, 120, 0, 0, 0, 0, 0 ,  DK2, SPE Stores default discount.

--- Chunk 458 ---
Tokens: 385
Type: sentence-based
Text:
0, 0, 120, 0, 0, 0, 0, 0 ,  DK2, SPE Stores default discount. 0, 0, 0, 30, 0, 0, 0, 0 ,  DK3, SIM Manufacturers discount. 0, 60, 0, 0, 50, 0, 0, 0 ,  DK4, ADV Manufacturers discount. 0, 0, 120, 0, 0, 70, 0, 0 ,  DK5, SPE Manufacturers discount. 15, 0, 0, 0, 0, 0, 0, 0 ,  DK6, SIM Special store discount. 0, 60, 0, 0, 0, 0, 60, 0 ,  DK7, ADV Default  spec. store disc. 0, 0, 120, 0, 0, 0, 0, 180 ,  DK8, SPE Default  spec. store disc. 15, 0, 0, 30, 0, 0, 0, 0 ,  DK9, SIM All applicable discounts. 0, 60, 0, 0, 50, 0, 60, 0 ,  DK10, ADV All applicable discounts. 0, 0, 120, 0, 0, 70, 0, 180   DK11, SPE All applicable disc. ; Principles of Construction Design  275 implementations.for.programming.problems.As.a.general.principle.programming.styles. must. provide. rules. that. ensure. consistency. simplicity. and. clarity. of. code. Numerous. styles.have.been.proposed.Baldwin.Gray.and.Misfeldt.(2006).provide.an.extensive.list.of. guidelines.for.formatting.code.using.the.C.programming.language.Similarly.Misfeldt. Bumgardner.and.Gray.(2004).and.Vermeulen.Ambler.Bumgardner.Metz.Misfeldt.and. Shur.(2000).presented.equivalent.work.for.the.C.and.Java.language.Besides.the.styles. covered.in.Chapter 5.typical.styles.used.during.construction.design.include . Formatting.conventions . Naming.conventions . Documentation.conventions Formatting Conventions Common. styles. for. formatting. code. include. the. use. of. white. spaces. indentation. and. bracket. placement. White. spaces. can. be. used. to. separate. keywords. parentheses. curly.

--- Chunk 459 ---
Tokens: 382
Type: sentence-based
Text:
curly. braces.binary.operators.and.commas.(Baldwin.et.al.2006).in.such.a.way.that.the.resulting. code.is.consistent.easier.to.read.and.easier.to.maintain.For.example.consider.the.use.of. white.spaces.to.separate.keywords.parentheses.and.curly.braces.in.control.flow.statements. Listing 8.9: Table-Based Construction of the Phone Discount Function  The table-based version for retrieving discounts. int getPhoneDiscount( const Phone phone )   Compute the key for accessing the corresponding table row. int discountKey  phone.getType()  phone.getDiscountType();  Add all discounts associated with the discount key. int totalDiscount  discountsdiscountKey.smallStoreDiscount  discountsdiscountKey.mediumStoreDiscount  discountsdiscountKey.highStoreDiscount  discountsdiscountKey.smallManufacturerDiscount  discountsdiscountKey.mediumManufacturerDiscount  discountsdiscountKey.highManufacturerDiscount  discountsdiscountKey.bluetoothDiscount  discountsdiscountKey.dataPlanDiscount;  Return the total discount. return totalDiscount;   Create a simple phone with manufacturers discount. Phone phone(SIMPLE_PHONE, MANUFACTURER_DISCOUNT);  Display the phones discount. coutTotal Phone Discount: getPhoneDiscount( phone )endl; 276  Software Engineering Design Listing.8.11.presents.three.different.ways.white.space.can.be.used.Adopt.a.consistent.style. for.spacing.elements.and.follow.it.consistently.in.your.organization.In.the.case.of.binary. operators.which.require.two.operands.it.is.suggested.that.a.single.space.be.used.on.both.sides.

--- Chunk 460 ---
Tokens: 371
Type: sentence-based
Text:
operators.which.require.two.operands.it.is.suggested.that.a.single.space.be.used.on.both.sides. of.the.operator.when.applicable.as.seen.in.Listing.8.12.Another.important.place.to.apply. white.spaces.in.common.languages.such.as.C.Java.and.C.is.after.commas.and.semi- colons.which.are.delimiters.also.demonstrated.in.Listing.8.12. Indentation Indentation.is.a.simple.way.to.improve.program.readability.Programs.that.do.not.apply. indentation.consistently.can.be.hard.to.read.Similarly.programs.that.do.not.apply.appropri- ate.forms.of.indentation.may.result.in.inappropriately.formatted.text.when.viewing.on.dif- ferent.platforms.Indentation.is.typically.employed.by.applying.two.white.spacesthis.varies. per.projectin.front.of.one.or.more.related.program.statements.that.need.to.be.differentiated. from.other.statements.However.the.choice.of.number.of.white.spaces.must.be.defined.by.the. project.policy.For.example.one.or.more.statements.related.in.code.can.be.grouped.by.the. Listing 8.10: Example PDL for a Systems Event-Handling Capabilities This function writes events occurring in the system to the event console. Events are displayed together with their classification and description, which are both provided by the clients calling func- tion. In addition, the number of events received for each type of event is computed and displayed in the event console. Events are required to have id and description. The function returns a value indicating successfailure of the operation.

--- Chunk 461 ---
Tokens: 394
Type: sentence-based
Text:
The function returns a value indicating successfailure of the operation. Set the value of the function status to failure Determine if the event id is valid If the event id is valid Use the event id to determine the type of event Increment by one the counter that keeps track of the number of events logged of this type to reflect this newly received event. Write the event id, description, and event counter to the event console and set the return value to success If the event id is not valid Set the event id to unknown Set the event description to invalid event . Write the event id and description to the event console Return the value of the function status Principles of Construction Design  277 number.of.white.spaces.used.in.indentation.Consider.the.example.presented.in.Listing 8.13. where.conditional.statements.are.indented.consistently.throughout.the.program. An.important.thing.to.consider.when.applying.indentation.is.the.prevention.of.tab. characters.since.they.are.interpreted.differently.in.different.development.environments. (Misfeldt. et. al. 2004). This. means. that. code. that. appears. properly. indented. can. look. drastically.different.when.viewed.by.other.developers.reviewing.the.code.in.a.different. environment.In.todays.popular.code.editors.(e.g.MS.Visual.Studio.and.Eclipse).this. problem.can.be.easily.solved.by.configuring.the.editor.to.replace.tab.characters.with. white.spaces.automatically.on.new.or.existing.code.Another.important.characteristic. highlighted.by.Listing.8.13.is.the.difficulty.of.matching.opening.and.closing.brackets.in.

--- Chunk 462 ---
Tokens: 395
Type: sentence-based
Text:
highlighted.by.Listing.8.13.is.the.difficulty.of.matching.opening.and.closing.brackets.in. nested.statements.This.can.lead.to.complex.code.that.is.hard.to.maintain.When.encoun- tered.with.a.highly.nested.code.statement.in.programming.languages.that.use.brackets. it is.desirable.to.match.closing.brackets.with.opening.ones.as.seen.in.Listing 8.14. Listing 8.11: Styles for Whitespaces to Separate Keywords, Parentheses, and Curly Braces  Style 1: White space after keyword. if(x)   Style 2: White space after parenthesis and parameter. if(x)   Style 3: White space after keyword, parenthesis and parameter. if(x)  Listing 8.12: Styles for White Spaces in Binary Operators and after Commas and Semicolons  White before and after binary operators. int xyz;  Using Style 2 of white spaces. White space after comma. int x,y,z;  White space after semicolon. for( int i  0;i  maxSize;i )   278  Software Engineering Design Brace Placement Brace.placement.is.another.commonly.used.technique.for.formatting.code.Styles.for. brace.placement.are.applied.in.many.languages.for.class.definitions.function.defini- tions.conditional.and.repetitive.statements.and.exception.handlers.Two.major.styles. include.the.application.of.the.opening.brace.in-line.or.the.application.of.the.opening. brace.on.a.new.line.aligned.with.the.first.character.of.the.statement.that.controls.the. statements.inside.the.braces.Regardless.of.the.style.applied.for.the.opening.brace.the. closing.brace.is.applied.on.a.new.line.Listings.8.15.and.8.16.present.examples.of.both. in-line.and.new-line.styles.respectively.

--- Chunk 463 ---
Tokens: 393
Type: sentence-based
Text:
in-line.and.new-line.styles.respectively. Listing 8.13: Styles for White Spaces in Nested Statements  Indentation of nested statements. if( x  y )   Code here is appropriately indented with 2 white spaces. if( z  r )   Code here is appropriately indented with 4 white spaces. if( c  a )   Code here is appropriately indented with 6 white spaces. Listing 8.14: Matching Closing and Opening Brackets in Nested Statements void computeValue()  while( some condition )  for( some condition, iterate )  if( some condition )  switch( some condition )   . end switch   end if   end for   end while  Principles of Construction Design  279 Naming Conventions Naming.conventions.can.help.programmers.develop.models.for.differentiating.different. aspects.of.software.programs.and.maintain.consistency.through.software.items.This.can. in.turn.result.in.code.that.is.self-documented.by.the.use.of.conventions.applied.consis- tently.in.the.code.Naming.conventions.can.be.used.to.differentiate.all.elements.that.com- pose.a.software.program.therefore.consistent.use.of.naming.style.can.help.software.teams. to.better.understand.the.work.done.by.each.other.When.applied.consistently.styles.can. easily.help.software.developers.testers.and.maintainers.understand.the.code.and.make. assumptions.about.it.based.on.the.programming.style. A.general.naming.convention.that.applies.to.all.elements.in.a.software.program.is.the. use.of.meaningful.names.Meaningful.names.are.ones.that.are.complete.and.contextually. correct.Naming.conventions.should.lead.to.names.that.unambiguously.and.completely.

--- Chunk 464 ---
Tokens: 368
Type: sentence-based
Text:
correct.Naming.conventions.should.lead.to.names.that.unambiguously.and.completely. define.the.intent.of.the.entity.that.they.represent.Names.should.be.chosen.so.that.they. clearly.define.entities.so.that.they.quickly.become.familiar.to.those.who.read.and.maintain. the.code.Failure.to.select.meaningful.names.can.result.in.code.that.is.hard.to.understand. follow.and.maintain.Examples.of.bad.and.good.examples.of.meaningful.names.are.pre- sented.in.Listing.8.17. Listing. 8.17. presents. several. cases. of. good. and. bad. names. Example. 1. presents. the. choice.of.using.rdo1 and rdo2.for.names.to.describe.two.Radio.objects.These.names. are.incomplete.and.as.a.consequence.can.make.the.code.hard.to.understand.debug.and. Listing 8.15: In-line Bracket Placement Style  Inline brace placement style in C class definition. class List   . ;  Inline brace placement style in function definition. void append()   . Inline brace placement style in conditional statements. if( condition  true )   . else   . Inline brace placement style in loops. while( condition  true )   . 280  Software Engineering Design maintain.Example.2.shows.the.usage.of.the.name.xmit.to.abstract.the.transmission.func- tion.of.a.radio.object.Developers.who.are.not.familiar.with.this.abbreviation.of.the.word. transmit.may.find.it.difficult.to.find.the.appropriate.function.call.in.the.documentation. to.transmit.a.message.In.addition.consider.the.case.where.the.integrated.development. environment.

--- Chunk 465 ---
Tokens: 391
Type: sentence-based
Text:
environment. (IDE).supports.the.intellisense.feature.In.this.case.developers.would.intui- tively.and.without.success.type.the.letter.t.in.hopes.that.the.IDE.would.reveal.a.function. name.that.somewhat.relates.to.the.transmission.behavior.required.by.the.radio.object. Example.3.presents.the.case.where.the.name.chosen.is.both.incomplete.and.inappropri- ate.for.the.programs.context.That.is.it.is.hard.to.determine.the.correct.meaning.of.the. code.when.using.s.and.MaxAmount.This.is.mainly.because.s.does.not.describe.the.entity. being.evaluated.and.MaxAmount.can.refer.to.multiple.limits.that.relate.to.different.prop- erties.(e.g.max.salary.max.number.of.items).These.names.are.improved.by.making.them. complete.and.appropriate.for.the.context.Finally.Example 4.presents.an.example.of.a. contextually.inappropriate.name.for.an.object.of.type.DirectoryManager.In.this.case. objects.of.type.DirectoryManager.monitor.a.directory.for.cleanup.Once.the.directory. reaches.a.specified.threshold.objects.of.the.DirectoryManger.type.would.begin.delet- ing.files.The.choice.of.name.reaper.and.destroy.are.not.appropriate.for.this.context. Reaper.and.destroy.seem.more.appropriate.for.a.gaming.context.therefore.the.names.are. improved.by.replacing.them.to.describe.better.the.actions.of.these.objects. Listing 8.16: New-Line Bracket Placement Style  Newline brace placement style in C class definition. class List   . ;  Newline brace placement style in function definition. void append()   . Newline brace placement style in conditional statements. if( condition  true )   .

--- Chunk 466 ---
Tokens: 384
Type: sentence-based
Text:
if( condition  true )   . Newline brace placement style in loops. while( condition  true )   . Principles of Construction Design  281 Listing 8.17: Styles for Naming Conventions  Example 1:  Incomplete variable names. Radio rdo1; Radio rdo2;  Complete variable name. Radio activeRadio; Radio backupRadio;  Example 2: class Radio  public:  Incomplete function name. void xmit(Message message); ; class Radio  public:  Complete function name. void transmit(Message message); ;  Example 3:  Incomplete and contextually inappropriate variable names. if( s  MaxAmount )   s is ambiguous! MaxAmount of what? MaxAmount does not reflect the appropriate context! Complete and contextually appropriate variable names. if( salary  MaxSalaryAmount )   . Example 4:  Contextually inappropriate names. DirectoryManager reaper; reaper.destroy();  Contextually appropriate names. DirectoryManager directoryManager; directoryManager.deleteFiles(); 282  Software Engineering Design Documentation Conventions Similar. to. formatting. and. naming. conventions. documentation. conventions. can. also. be. (almost.universally).applied.to.projects.in.different.domains.and.with.different.pro- gramming.languages.Documentation.conventions.deal.with.styles.and.specifications.for. what.to.document.and.how.to.document.during.construction.Generally.if.the.naming. conventions.are.followed.comments.should.provide.information.that.describes.why.an. operation.is.written.as.opposed.to.what.the.operation.is.doing.In.many.cases.the.actions. performed.by.operations.

--- Chunk 467 ---
Tokens: 400
Type: sentence-based
Text:
performed.by.operations. (or.blocks.of.codes).can.be.inferred.from.the.naming.conven- tions.or.programming.syntax.however.the.reasons.behind.the.choice.of.code.cannot.be. inferred.as.easily.Therefore.comments.should.provide.the.reasons.why.code.was.written. and.when.necessary.what.the.code.is.doing. Documenting Files In.software.construction.files.are.units.of.cohesive.work.In.some.architectural.efforts. using.the.development.view.discussed.in.Chapter.3.systems.are.decomposed.using.files. (and.directories).as.a.main.unit.of.system.decomposition.Therefore.files.should.be.well. documented.in.a.clear.and.concise.manner.so.that.clients.of.the.file.can.understand.the. actions.carried.out.by.its.contents.Depending.on.the.language.files.can.contain.one.or. more.classes.one.or.more.functions.or.one.or.more.variable.constant.or.type.definitions. In.all.cases.file.documentation.is.necessary.for.managing.the.file.throughout.its.lifetime. File.documentation.can.vary.from.company.to.company.or.even.from.project.to.proj- ect.within.a.same.company.However.at.a.minimum.file.documentation.should.contain. header.information.that.identifies.the.contents.of.the.file.description.and.original.author. In.addition.file.documentation.can.include.other.important.information.such.as.revision. information.(e.g.bug.fixes.or.enhancements).classification.(mostly.for.companies.that. write.software.for.national.security.purposes).of.the.files.content.and.any.restrictions.asso- ciated.with.the.files.content.An.example.of.file.documentation.is.presented.in.Listing 8.18. Documenting Functions Similar. to. files.

--- Chunk 468 ---
Tokens: 381
Type: sentence-based
Text:
files. functions. are. units. of. work. however. they. operate.on. a. smaller. scale. Therefore.their.intent.should.be.well.documented.in.a.clear.and.concise.manner.so.that. their.clients.can.understand.the.actions.carried.out.by.the.functions.contents.Functions. operate.on.a.finer-grained.context.than.files.therefore.their.documentation.should.be. specific.to.the.work.performed.by.the.functions.Information.such.as.classification.and. history. can. be. deferred. to. the. files. documentation. At. a. minimum. function. docu- mentation.should. contain. information. about.its.intent.parameters.and.return. values. In addition.it.can.include.any.pre-.and.postconditions.applicable.An.example.of.func- tion.documentation.header.is.presented.in.Listing.8.19.As.seen.an.important.relation- ship.exists.between.PDL.and.function.documentation.When.using.PDL.a.comments.first. approach.is.employed.to.designing.code.at.the.construction.level.PDL.generated.as.part.of. Principles of Construction Design  283 a.particular.functions.behavior.can.be.directly.used.to.create.the.functions.documenta- tion.In.Listing 8.19.PDL.generated.and.presented.in.Listing.8.10.is.used.word.for.word.in. the.functions.documentation. MINIMIZING COMPLEXITY IN CONSTRUCTION DESIGN Construction.design.is.an.activity.directly.related.to.the.construction.phase.In.some.cases. construction.design.begins.during.the.design.phase.and.continues.throughout.the.con- struction.phase.This.activity.is.heavily.collaborative.since.construction.design.represents.

--- Chunk 469 ---
Tokens: 389
Type: sentence-based
Text:
construction.design.begins.during.the.design.phase.and.continues.throughout.the.con- struction.phase.This.activity.is.heavily.collaborative.since.construction.design.represents. parts.of.a.whole.system.Complexity.encountered.during.construction.design.can.be.mini- mized.through.making.use.of.standards.(Abran.Moore.Bourque.and.Dupuis.2005).The. use.of.standards.is.an.important.part.of.the.software.development.process.In the.con- struction.design.activity.standards.can.be.used.to.define.common.processes.and.practices. for.improving.the.efficiency.of.engineers.Standards.can.help.designers.become.more.effi- cient.by.allowing.them.to.quickly.understand.for.example.complex.data.structures.com- plex.messaging.interfaces.and.configuration.management.processes.They.can.also.help. minimize.complexity.by.defining.the.basis.for.implementing.construction.designs.that.are. Listing 8.18: Style for File Documentation   FILE: MyFile.h   DESCRIPTION: This file contains the definition of class x. Class x is used in the system for . Clients of  this class are required to . REVISION: Revision 1.0   CLASSIFICATION: Unclassified   RESTRICTIONS: None   AUTHOR: Joe Developer   HISTORY:  PROBLEM  INITIALS DATE DESCRIPTION  --------------------------------------------------------------------  NA JD 112011 Initial Design and Code. 10 TAE 512011 Removed dead code. . . . . --------------------------------------------------------------------   284  Software Engineering Design simple.and.readable.rather.than.clever.(Abran.et.al.2005).Some.important.standards.that.

--- Chunk 470 ---
Tokens: 366
Type: sentence-based
Text:
--------------------------------------------------------------------   284  Software Engineering Design simple.and.readable.rather.than.clever.(Abran.et.al.2005).Some.important.standards.that. can.be.created.for.software.projects.include.the.software.development.plan.the.software. version.document.the.interface.control.document.and.the.programming.style.standard. as.presented.in.Chapter.5. QUALITY EVALUATION OF CONSTRUCTION DESIGN The.construction.design.activity.is.the.last.major.design.step.performed.before.construc- tion.Therefore.it.provides.the.last.opportunity.to.evaluate.the.quality.of.the.system. to.be.built.There.are.numerous.project-specific.quality.characteristics.(e.g.security. usability).that.can.be.identified.and.evaluated.for.construction.designs.However.at. a. minimum. the. designs. completeness. correctness. testability. and. maintainability. should.be.evaluated.since.these.generally.apply.to.all.software.projects. Completeness.and.correctness.deal.with.the.degree.to.which.construction.designs.cor- rectly.meet.the.allocated.requirements.Construction.designs.that.are.correct.but.incom- plete.complete.but.incorrect.or.incomplete.and.incorrectthose.that.do.not.meet.all. requirements.are.incorrect.or.bothneed.to.be.addressed.and.resolved.to.maintain.the. envisioned.software.quality.of.the.product.Completeness.and.correctness.can.both.be. evaluated.through.peer.reviews.unit.testing.and.audits.In.all.of.these.activities.the.use.of.

--- Chunk 471 ---
Tokens: 382
Type: sentence-based
Text:
evaluated.through.peer.reviews.unit.testing.and.audits.In.all.of.these.activities.the.use.of. checklistsone.of.the.seven.common.tools.of.qualityis.essential.In.other.cases.incom- plete.designs.are.the.product.of.incomplete.specifications.In.these.cases.construction. Listing 8.19: Style for File Documentation   METHOD: EventLogger:log(EventId id, string description)   DESCRIPTION: This function writes events occurring in the system  to the event console. Events are displayed together  with their classification and description, which are  both provided by the clients calling function. In addition, the number of events received for each  type of event is computed and displayed in the event  console. Events are required to have id and  description. RETURNS: The function returns a boolean value indicating  successfailure of the operation. PRE-CONDITIONS: . POST-CONDITIONS: . Principles of Construction Design  285 designs.can.be.further.analyzed.using.prototypes.for.eliciting.the.required.capabilities.to. complete.the.specifications.and.therefore.the.construction.design. Testability.quality.(in.construction.design).deals.with.the.amount.of.effort.required.to. test.artifacts.that.are.the.result.of.construction.design.On.the.other.hand.a.designs.main- tainability.deals.with.the.amount.of.effort.required.to.maintain.a.tested.artifact.that.is.the. result.of.construction.design.Both.testability.and.maintainability.goals.can.be.achieved. in.many.ways.as.determined.by.nonfunctional.requirements.of.the.project.A.common.

--- Chunk 472 ---
Tokens: 387
Type: sentence-based
Text:
in.many.ways.as.determined.by.nonfunctional.requirements.of.the.project.A.common. approach.for.evaluating.the.testability.and.maintainability.of.construction.designs.includes. the.measurement.of.the.designs.cyclomatic.complexity. (McCabe.1976).therefore.testabil- ity.and.maintainability.goals.can.be.transformed.into.requirements.that.are.based.on.the. cyclomatic.complexity.In.addition.maintainability.quality.can.also.be.evaluated.by.the. compliance.of.the.resulting.implementation.of.construction.design.to.the.programming. style.defined.for.the.project.Pressman.(2010.p.437).states.that.source.code.and.related. work.products.must.conform.to.local.coding.standards.and.exhibit.characteristics.that.will. facilitate.maintainability.Therefore.evaluation.techniques.that.enforce.100.compliance. with.local.styles.of.programming.must.be.in.place. Peer Reviews Peer. reviews. are. tasks. that. concentrate. on. verifying. and. validating. designs. and. code. (i.e, design.reviews.and.code.reviews.respectively).Peer.reviews.must.be.planned.orga- nized.and.conducted.in.such.a.way.that.a.collective.approval.among.all.members.of.the. project. (with.different.disciplines).is.reached.The.main.tasks.are.performed.by.techno- logically.savvy.engineers.and.domain.experts.that.can.verify.and.validate.the.items.of. review.In.addition.the.presence.of.an.auditor.(or.software.quality.personnel).is.required. to.inspect.both.processes.and.products.Finally.members.of.the.software.testing.and.main- tenance.team.can.contribute.highly.to.the.review.of.items.

--- Chunk 473 ---
Tokens: 389
Type: sentence-based
Text:
to.inspect.both.processes.and.products.Finally.members.of.the.software.testing.and.main- tenance.team.can.contribute.highly.to.the.review.of.items. A.great.deal.of.time.during.code.review.is.spent.evaluating.code.In.many.practical.situ- ations.where.requirements.have.been.established.to.meet.a.specific.programming.style.it. can.be.time-consuming.to.read.code.line.by.line.to.validate.that.the.code.meets.the.styles. requirements.In.these.cases.the.use.of.automated.style.checkers.can.provide.significant. benefits.Automated.style.checkers.are.tools.that.can.be.configured.to.enforce.a.specific. style. of. programming. Some. of. the. capabilities. provided. by. automated. style. checkers. include.checks.for.numerous.conventions.For.example.the.open-source.CheckStyle.5.3. (2010).is.a.Java.code.auditor.that.can.be.incorporated.into.the.Eclipse.integrated.develop- ment.environment.to.enforce.coding.styles.and.identify.areas.of.potential.errors.in.code. Some.of.the.capabilities.included.by.CheckStyle.include.the.following: . Naming.conventions.of.attributes.and.methods . Formatting.conventions . Limit.of.the.number.of.function.parameters.line.lengths . Comments. (Javadoc).for.classes.attributes.and.methods . Presence.of.mandatory.headers 286  Software Engineering Design . Good.practices.for.class.design . Checks.for.duplicated.code.sections . Checks.cyclomatic.complexity.against.a.specified.threshold . Other.multiple.complexity.measurements Unit Testing Ultimately.the.quality.of.construction.designs.in.terms.of.completeness.and.correctness.

--- Chunk 474 ---
Tokens: 389
Type: sentence-based
Text:
Other.multiple.complexity.measurements Unit Testing Ultimately.the.quality.of.construction.designs.in.terms.of.completeness.and.correctness. is evaluated.through.unit.testing.Therefore.as.construction.designs.are.created.so.are.unit. tests.One.or.more.unit.test.cases.are.essential.for.verifying.and.validating.construction. designs.A.sample.unit.test.case.is.presented.in.Table 8.5. Cyclomatic Complexity Cyclomatic.complexity.is.a.technique.developed.by.McCabe.(1976).that.can.be.used.for. evaluating.the.quality.of.flow-based.designs.It.is.a.mathematical.technique.based.on.graph. theory.that.provides.a.quantitative.justification.for.making.design.decisions.that.lead.to. higher.quality.in.terms.of.a.designs.maintainability.and.testability.The.cyclomatic.com- plexity.computation.allows.designers.to.measure.the.complexity.of.flow-based.operational. designs.by.determining.the.complexity.of.the.decision.structure.of.operations.instead.of. lines.of.code.In.his.original.work.McCabe.illustrated.the.correlation.between.intuitive. complexity.and.the.graph-theoretic.complexity.of.several.programming.operations.and. showed.that.the.complexity.of.an.operation.had.less.to.do.with.physical.size.and.more.to. do.with.the.decision.structure.of.the.operation.By.using.this.approach.the.cyclomatic. complexity.provides.not.only.a.measurement.of.the.complexity.of.flow-based.designs.but. also.a.measurement.of.the.maximum.number.of.independent.paths.required.to.fully.test. the.operation.(Galin.2003).Therefore.cyclomatic.complexity.can.be.used.to.determine.the.

--- Chunk 475 ---
Tokens: 393
Type: sentence-based
Text:
the.operation.(Galin.2003).Therefore.cyclomatic.complexity.can.be.used.to.determine.the. maintainability.(i.e.understandability).and.testability.of.flow-based.designs. The.cyclomatic.complexity.technique.works.by.computing.the.cyclomatic.number.v(G). of.a.graph.G.with.n.vertices.e.edges.and.p.connected.components.as.seen.in.Equation.8.1. . v G e n p ( )   2 . (8.1) For.a.strongly.connected.graph.Gin.which.there.is.a.path.connecting.any.pair.of.arbi- trary.distinct.nodesthe.cyclomatic.number.is.equal.to.the.maximum.number.of.linearly. independent.circuits.(McCabe.1976).Therefore.flow-based.designs.can.be.associated.with. directed.strongly.connected.graphs.that.have.unique.entry.and.exit.points.where.each.node. can.be.reached.from.the.entry.node.and.each.node.can.reach.the.exit.node.When.this.is. the.case.the.graph.is.referred.as.the.program.control.graph.and.Equation.(8.1).can.be.used. to.compute.the.cyclomatic.complexity.of.the.function.based.on.its.flow-based.design.For. example.consider.a.UML.flow-based.design.(i.e.activity.diagram).constructed.as.a.directed. strongly.connected.graph.consisting.of.five.activities.(i.e.nodes).and.six.transitional.arrows. (i.e.edges).each.activity.accessible.from.the.starting.node.and.capable.of.reaching.the.exit. Principles of Construction Design  287 activity.In.this.case.the.cyclomatic.complexity.of.the.design.is.v(G)  6  5  2(1) .3. In most.cases.the.value.of.p .1.is.expected.since.p.is.the.number.of.connected.components. in.the.graph.Given.the.characteristics.specified.for.the.program.control.graph.(i.e.unique.

--- Chunk 476 ---
Tokens: 375
Type: sentence-based
Text:
in.the.graph.Given.the.characteristics.specified.for.the.program.control.graph.(i.e.unique. entry.and.exit.points.all.nodes.reachable.from.the.entry.and.all.nodes.capable.of.reaching. the.exit.node).all.program.control.graphs.will.end.up.having.only.one.connected.compo- nent. (McCabe.1976).However.in.some.cases.complexity.may.be.evaluated.as.the.com- bined.complexity.of.several.operations.Consider.a.parent.operation.that.calls.on.several. child.operations.in.this.case.the.complexity.of.the.operation.is.the.combined.complexity.of. the.parents.operation.complexity.and.the.complexity.of.all.other.child.operations.that.are. called.within.the.parent.In.these.cases.p will.equal.the.number.of.connected.components. TABLE 8.5 Sample.Unit.Test.Case.Template Unit Test Case Unit.test.name: Description: Requirements: Preconditions: S Operator Action System Action PF N 1 Operator.enters.invalid.product.data. and.clicks.on.the.send.button. Detects.invalid.data.and.displays.error.message.to. the.operator 2 Operator.enters.valid.product.data. and.clicks.on.the.send.button. Validates.the.data.retrieves.servers.Internet. Protocol. (IP).address.and.port.number 3 Opens.a.socket.connection.and.send.product. request.data.to.the.server 4 Waits.a.maximum.of.3.seconds.for.a.server.response 5 . . 6 Response.received.and.product.information.is. displayed. 7 Save.response.data.in.file.system.and.ask.user.to. search.for.another.product 8 Operator.clicks.the.cancel.button.to. finish.searching.for.products.

--- Chunk 477 ---
Tokens: 389
Type: sentence-based
Text:
finish.searching.for.products. Test Result Notes Approval Signatures Software.engineer: Test.engineer: Quality.auditor: 288  Software Engineering Design in.the.parent.and.child.operations.which.can.be.equal.to.the.number.of.operations.(parent. and.child.operations).being.evaluated.It.is.important.to.note.that.when.p .1.the.complex- ity.measure.will.be.equal.to.the.summation.of.the.individual.complexities.of.each.connected. component.since.complexity.measures.are additive. Computing. the. cyclomatic. complexity. for. large. operations. can. be. tedious. therefore. two.simplification.methods.are.available.for.easily.computing.the.cyclomatic.complexity. of.single-component.graphs. (i.e.p .1).The.first.method.allows.for.the.computation.of. complexity.in.terms.of.a.programs.decision.constructs.such.as.if.statements.while.loop.for. loop.and.case.statements.Mills.(1972).proved.that.the.cyclomatic.complexity. (C).of.a.struc- tured.program.meeting.the.control.graphs.requirements.previously.mentioned.is.equal.to. the.number.of.conditions.in.the.code.().plus.1.as.seen.in.Equation.(8.2). . C    1. (8.2) The.number.of.conditions.().can.be.easily.measured.as.follows.Conditional.statements. such.as.if.statements.while.loop.and.for.loop.all.count.as.one.unit.of.complexity.Compound. conditional.statements.such.as.if x and y then z.count.as.two.complexity.units.since.with- out.the.connective.and.the.condition.would.have.to.be.specified.as.if x then, if y then z. (McCabe.1976).Case.statements.such.as.the.switch.statement.in.C.Java.and.C.or.other.

--- Chunk 478 ---
Tokens: 396
Type: sentence-based
Text:
(McCabe.1976).Case.statements.such.as.the.switch.statement.in.C.Java.and.C.or.other. conditional.statements.containing.multiple.n.branching.statements.are.counted.as.  n .1. unit.of.complexity. The.second.simplification.approach.allows.for.the.visual.determination.of.complexity.via. the.programs.control.graph.(i.e.flow-based.design).This.approach.is.based.on.the.work.of. mathematician.Leonhard.Euler.who.proved.that.for.connected.planar.graphsthose.with- out.intersecting.edgesthe.regions. (r).of.a.graph.can.be.computed.using.Equation (8.3). known.as.Eulers.formula. . 2  n  e r . (8.3) A.region.is.an.area.enclosed.by.arcs.therefore.given.the.characteristics.of.the.program. control.chart.the.number.of.regions.enclosed.by.arcs.plus.one.that.resides.outside.the. graph.is.equal.to.the.cyclomatic.complexity.of.the.graph.All.three.methods.for.computing. the.cyclomatic.complexity.of.a.program.control.graph.are.presented.in.Figure 8.3. The.top-left.corner.of.Figure 8.3.represents.the.program.control.graph.designed.using.a. (flow-based).activity.diagram.As.seen.the.program.control.graph.represents.a.case.state- ment.with.five.branches.therefore.the.number.of.conditions.().is.equal.to.5.1.4.and. the.cyclomatic.complexity.using.Equation. (8.2).is.C .4.1.5.This.can.be.easily.verified. with.Equations.(8.1).and.(8.3).For.example.using.Equation. (8.1).the.cyclomatic.complex- ity.is.v(G) .10.7.2(1).5. The.top-right.corner.presents.the.evaluation.of.complexity.of.a.program.control.graph. using.the.regions.visual.inspection.As.seen.the.number.of.regions.of.the.planar.graph.is.

--- Chunk 479 ---
Tokens: 327
Type: sentence-based
Text:
using.the.regions.visual.inspection.As.seen.the.number.of.regions.of.the.planar.graph.is. five.therefore.the.cyclomatic.complexity.of.the.design.is.five.This.can.easily.be.verified. by.rearranging.Equation. (8.3).to.solve.for.r.which.results.in.r .9.6.2.5.Finally.the. bottom.of.Figure 8.3.presents.a.more.complex.program.design.which.includes.23.nodes. Principles of Construction Design  289 and.31.edges.By.using.the.regions.visual.inspection.the.complexity.of.the.design.can.be. evaluated.quickly.which.results.in.a.complexity.of.10.Since.designs.like.this.one.involve.a. relatively.large.number.of.nodes.and.edges.it.is.a.good.idea.to.verify.the.complexity.mea- surement.using.any.of.the.other.techniques.presented.For.example.using.Equation.(8.1). the.complexity.results.in.v(G) .31.23.2(1).10. An.important.consideration.when.evaluating.quality.in.terms.of.cyclomatic.complexity. is.the.establishment.of.a.threshold.value.for.determining.when.the.complexity.of.designs.is. acceptable.This.threshold.value.can.be.used.to.create.quality.requirements.for.the.software. development.process.for.example.the cyclomatic complexity of functions shall not exceed 10. Typically.a.value.of.10.is.acceptable.based.on.McCabes.(1976).work.Other.studies.have.shown. results.similar.to.McCabe.for.example.Casper.Jones.

--- Chunk 480 ---
Tokens: 387
Type: sentence-based
Text:
results.similar.to.McCabe.for.example.Casper.Jones. (2008.p.415).reports.the.following: Empirical.studies.reveal.that.program.with.cyclomatic.complexities.of.less.than.5.are.gener- ally.considered.simple.and.easy.to.understand.Cyclomatic.complexities.of.10.or.less.are.con- sidered.not.too.difficult.When.the.cyclomatic.complexity.is.greater.than.20.the.complexity.is. perceived.as.high.When.the.McCabe.number.exceeds.50.the.software.for.practical.purposes. becomes.untestable. 1 2 3 4 7 5 6 1 1 2 R1 R2 2 3 10 17 2 3 4 5 6 R5 R3 R4 R2 R4 R5 R3 R7 R6 R9 R10 R8 R1 18 19 11 6 12 13 15 16 22 20 21 23 8 9 14 5 7 FIGURE 8.3 Cyclomatic.complexity.for.three.flow-based.designs. 290  Software Engineering Design Ultimately.a.threshold.value.that.makes.sense.for.the.project.team.(e.g.10).should.be. selected.and.enforced.throughout.the.design.and.construction.phase.metrics.should.be. collected.and.analyzed.and.the.threshold.value.should.be.reevaluated.(for.new.projects). according.to.the.results. CHAPTER SUMMARY The.transition.from.software.design.to.construction.should.occur.with.minimal.effort. In some.cases.component.designs.provide.enough.detail.to.allow.their.transformation.from. design.artifact.into.code.easily.however.in.other.cases.a.more.fine-grained.level.of.design. detail.is.required.Construction.design.provides.a.form.of.design.that.closely.resembles.code. so.that.complex.operations.can.be.planned.and.evaluated.prior.to.implementation.in.code. Once.the.correctness.of.operations.is.verified.the.construction.design.activity.provides.

--- Chunk 481 ---
Tokens: 399
Type: sentence-based
Text:
Once.the.correctness.of.operations.is.verified.the.construction.design.activity.provides. additional.heuristics.to.enforce.consistency.in.the.code.Construction.designs.are.typically. created.using.the.following.techniques.flow-based.state-based.table-based.and.program- ming.design.language.Each.method.provides.its.own.benefits.therefore.careful.attention. should. be. paid. when. selecting. the. appropriateness. of. construction. designs. in. practical. applications.The.benefits.acquired.from.designing.complex.functions.and.enforcing.styles. for.consistency.are.essential.to.maintaining.each.systems.envisioned.quality. REVIEW QUESTIONS . 1.What.is.construction.design.and.why.is.it.important? . 2.List.and.explain.common.quality.attributes.that.can.be.addressed.during.construc- tion.design. . 3.Why.are.styles.important.during.construction? . 4.What.are.flow-based.designs.and.how.do.they.relate.to.UML.activity.diagrams? . 5.Describe.the.following.elements.of.an.activity.diagram: . a. Initial.state . b. Final.state . c. Action . d. Branch . e. Transition . 6.What.are.state-based.designs.and.why.are.they.important.for.construction.design? . 7.How.are.state-based.designs.typically.translated.to.code? . 8.What.are.table-based.designs.and.why.are.they.important.for.construction.design? . 9.Compare.and.contrasts.the.following: . a. Limited-entry.decision.table . b. Extended-entry.decision.table . c. Mixed-entry.decision.table Principles of Construction Design  291 . 10.How.are.table-based.designs.used.to.decrease.codes.complexity.and.increase.both. readability.and.maintainability? .

--- Chunk 482 ---
Tokens: 372
Type: sentence-based
Text:
. 11.In.decision.tables.what.are.missing.policies.and.redundant.actions.How.does.iden- tifying.these.help.make.more.efficient.tables? . 12.What.is.programming.design.language.and.what.is.the.main.benefit.that.it.provides. over.other.construction.design.methods? . 13.How.are.construction.styles.used.to.decrease.codes.complexity.and.increase.both. readability.and.maintainability? . 14.What.are.the.main.methods.used.for.evaluating.quality.of.construction.designs? . 15.List.and.explain.an.efficient.method.for.enforcing.styles.during.construction. . 16.What.is.cyclomatic.complexity.Name.three.different.ways.to.compute.the.cyclo- matic.complexity.of.a.function.during.construction.design. . 17.What. is. the. relationship. between. cyclomatic. complexity. and. software. quality. Explain. CHAPTER EXERCISES . 1.Select.a.project.of.choice.and.identify.three.different.functions.that.can.be.designed. using.flow-based.table-based.and.state-based.design.Create.the.designs.for.these. functions. and. prepare. a. 5-. to. 10-minute. presentation. including. designs. code. and justification. . 2.Compute.the.cyclomatic.complexity.of.the.following.code.using.all.three.methods: switch( state )  case ONE:  Perform activity. if( some condition )   Perform activity. else if( some condition )   Perform activity. else   Perform activity. break; case TWO:  Perform activity FIVE. break; 292  Software Engineering Design case THREE:  Perform activity FOUR. break; default:  Intentionally left blank.

--- Chunk 483 ---
Tokens: 383
Type: sentence-based
Text:
break; default:  Intentionally left blank. break;  REFERENCES Abran.Alain.James.W.Moore.Pierre.Bourque.and.Robert.Dupuis.Guide to the Software Engineering Body of Knowledge2004 VersionSWEBOK.Los.Angeles.CA.IEEE.Computer.Society.Press.2005. Baldwin.Kenneth.Andrew.Gray.and.Trevor.Misfeldt.The Elements of C Style.Cambridge.UK.Cambridge. University.Press.2006. Booch. Grady. James. Rumbaugh. and. Ivar. Jacobson. The Unified Modeling Language User Guide. 2d. ed. Boston: Addison-Wesley.2005. Checkstyle 5.3.October.19.2010.Available.from.http:checkstyle.sourceforge.netindex.html.(accessed.March. 11.2011). Collar.Emilio.Jr.An.Investigation.of.Programming.Code.Textbase.Readability.Based.on.a.Cognitive.Readability. Model.PhD.thesis.University.of.Colorado.at.Boulder.2005. Fox.Christopher.Introduction to Software Engineering Design: Processes, Principles, and Patterns with UML2. Boston.Addison.Wesley.2006. Galin.Daniel.Software Quality Assurance: From Theory to Implementation.Harlow.UK.Pearson.Addison.Wesley. 2003. Hurley.Richard.B.Decision Tables in Software Engineering.New.York.Van.Nostrand.Reinhold.1982. IEEE. IEEE. Standard. for. Information. Technology-Systems. Design-Software. Design. Descriptions. 2009. p. 175. Jones.Capers.Applied Software Measurement: Global Analysis of Productivity and Quality.3d.ed.New.York. McGraw-Hill.Osborne.Media.2008. McCabe.Thomas.J.A.Complexity.Measure.IEEE Transactions on Software Engineering.SE-2.no.4.(1976). 308320. McConnell.Steve.Code Complete.2d.ed.Redmond.WA.Microsoft.Press.2004.

--- Chunk 484 ---
Tokens: 388
Type: sentence-based
Text:
McConnell.Steve.Code Complete.2d.ed.Redmond.WA.Microsoft.Press.2004. Meyer.Bertrand.Object-Oriented Software Construction.2d.ed.Upper.Saddle.River.NJ.Prentice.Hall.1997. Mills. Harlan. D. Mathematical Foundations for Structured Programming. Gaithersburg. MD. IBM. Federal. Systems.Division.IBM.Corporation.1972. Misfeldt. Trevor. Gregory. Bumgardner. and. Andrew. Gray. The Elements of C Style. Cambridge. UK. Cambridge.University.Press.2004. Pressman.Roger.S.Software Engineering: A Practitioners Approach.7th.ed.Chicago.McGraw-Hill.2010. Vermeulen. Allan. Scott. W. Ambler. Greg. Bumgardner. Eldon. Metz. Trevor. Misfeldt. Jim. Shur. and. Patrick Thompson.The Elements of Java Style.Cambridge.UK.Cambridge.University.Press.2000. 293 9 HumanComputer Interface Design Jacob Somervell University of Virginia, College at Wise CHAPTER OBJECTIVES . Understand.the.role.that.the.computer.interface.plays.in.high-quality. and.successful.software.systems . Describe.how.to.address.interface.design.and.evaluation.within.the. software.development.life.cycle . Provide.usable.guidance.for.evaluating.designs CONCEPTUAL OVERVIEW To.end.users.the.interface.is.the.system.Most.end.users.do.not.know.nor. do.they.even.need.to.know.about.the.underlying.structure.and.implemen- tation.of.the.software.system.They.are.concerned.only.with.the.interface. presented.to.them.and.the.capabilities.provided.by.that.interface.Consider. the.analogy.of.driving.a.car.the.driver.does.not.need.to.know.anything. about.how.an.internal.combustion.engine.works.and.how.it.is.connected.

--- Chunk 485 ---
Tokens: 371
Type: sentence-based
Text:
about.how.an.internal.combustion.engine.works.and.how.it.is.connected. to.the.transmission.to.send.power.to.the.wheels.nor.do.they.need.to.know. about. hydraulics. and. fluid. dynamics. of. the. braking. system. to. actually. drive.a.car.Indeed.mainly.the.driver.needs.to.know.that.D.means.drive. (assuming.an.automatic.transmission).press.gas.pedal.to.go.press.brake. pedal.to.stop.The.same.concept.applies.to.software.systems.End.users.are. concerned.only.with.what.they.can.do.with.the.system.and.how.they.do.it. not.with.how.it.works.under.the.hood.Hence.it.is.of.vital.importance.to. get.the.interface.design.sufficiently.correct.so.that.it.serves.users.in.an.efficient. and.usable.manner.This.chapter.shifts.the.focus.away.from.the.detailed. under-the-hood.approach.to.design.to.cover.the.essential.humancomputer. design.activity.The.chapter.focuses.on.providing.valuable.information.on. how.to.create.effective.and.usable.interfaces.for.software.systems. 294  Software Engineering Design WHAT IS HUMANCOMPUTER INTERFACE DESIGN? So.what.does.it.mean.to.get.it.right.As.part.of.the.software.design.process.humancomputer. interaction.(HCI).design.must.account.for.the.user.of.the.software.While.designing.the. architecture.and.detailed.design.of.software.systems.is.essential.for.meeting.most.quality. attributes.designing.an.efficient.user.interface.that.is.understandable.by.the.end.user.is. paramount.to.the.usability.quality.of.all.successful.software.systems.The.most.elegant.

--- Chunk 486 ---
Tokens: 365
Type: sentence-based
Text:
paramount.to.the.usability.quality.of.all.successful.software.systems.The.most.elegant. efficient.and.high-quality.architectural.and.detailed.designs.can.be.felled.by.a.poor.inter- face.In.the.context.of.HCI.interface.design.refers.to.the.creation.of.the.user.interface. IEEE. (1990.p.80).defines.the.user.interface.as.follows: An.interface.that.enables.information.to.be.passed.between.a.human.user.and.hardware.or. software.components.of.a.computer.systems. For.most.software.this.entails.designing.the.graphical.user.interface.(GUI).This.involves. selecting.appropriate.information.presentation.and.interaction.techniques.for.the.various. end-user.classes. (Rosson.and.Carroll.2002).More.specifically.this.entails.selecting.appro- priate.information.layouts.correct.language.appropriate.interface.controls. (e.g.radio.but- tons.versus.check.boxes).and.tying.the.detailed.design.to.the.various.input.mechanisms. provided.in.the.interface. An.essential.task.of.the.HCI.design.activity.involves.making.sure.that.the.interface.provides. appropriate.means.for.using.the.system.in.an.efficient.manner.The.best.way.to.ensure.an.inter- face.is.sufficiently.good.is.to.iteratively.improve.the.design.through.user.testing.The.implication. is.that.there.will.be.multiple.iterations.of.a.process.that.includes.the.following.HCI.design.tasks: . Creating.a.prototype.of.the.system . Having.end.users.use.that.prototype.in.realistic.ways . Gathering.data.from.these.tests .

--- Chunk 487 ---
Tokens: 364
Type: sentence-based
Text:
Gathering.data.from.these.tests . Redesigning.the.interface.to.address.discovered.problems All.of.this.work.(choosing.appropriate.information.representation.and.interaction.methods). hinges.on.a.thorough.understanding.of.the.users.of.the.system.It.is.paramount.to.learn. how.the.users.typically.perform.similar.actions.and.what.their.expectations.of.the.new. system.may.be.This.information.is.gleaned.through.detailed.requirements.gathering.and. analysis.and.through.significant.user.testing. WHY STUDY HUMANCOMPUTER INTERFACE DESIGN? The.HCI.design.activity.is.where.general.principles.are.applied.to.optimize.the.interface. between.humans.and.computers.Visual.designs.have.a.major.role.in.the.success.or.failure. HumanComputer Interface Design  295 of.software.systems.Systems.that.meet.functional.requirements.but.are.not.usable.cannot. succeed.The.major.concerns.of.the.HCI.designs.may.include.the.evaluation.and.use.of. modes.navigation.visual.designs.response.time.and.feedback.and.design.modalities. such.as.forms.and.menu-driven.HCI.designs.directly.influence.the.quality.of.any.system. and.are.essential.to.understanding.and.addressing.the.factors.that.affect.the.overall.usabil- ity.of.the.system.Many.design.principles.and.evaluation.techniques.exist.to.successfully. design.user.interfaces.Therefore.understanding.the.techniques.and.tools.for.designing. interfaces.allows.designers.to.become.proficient.in.creating.efficient.interfaces.Providing.

--- Chunk 488 ---
Tokens: 391
Type: sentence-based
Text:
interfaces.allows.designers.to.become.proficient.in.creating.efficient.interfaces.Providing. an.interface.that.allow.users.to.accomplish.their.goals.with.the.software.without.unneces- sary.effort.is.the.ultimate.goal.of.the.user.interface.designer. The.without.unnecessary.effort.clause.is.important.Consider.a.system.that.requires.a. date.from.the.user.as.presented.on.Iteration.1.of.Figure 9.1. The.user.interface.could.ask.the.user.to.type.in.the.date.in.a.text.box.Without.any.extra. information.a.user.could.type.any.of.the.following: . Jan.1.2011 . 1.1.11 . 1.-.1.-.11 . 1.January.2011 Which.format.was.expected.by.the.software.If.the.information.typed.by.the.user.doesnt. match.the.format.what.happens.An.error.message.Program.crash.The.most.flexible. option.involves.allowing.all.of.these.and.others.as.valid.input.and.then.correctly.parsing.the. input.to.find.the.appropriate.fields.for.month.day.and.year.from.that.input.string.This.is.a. nontrivial.solution.and.does.not.help.the.user.form.a.basis.or.understanding.of.the.desired. input.A.simpler.solution.involves.adding.a.label.to.the.input.box.specifying.the.appropriate. format. (i.e.MMDDYYYY).as.presented.on.Iteration.2.of.Figure 9.1.This.option.works. Date: Date: (MMDDYYYY) Date: (MMDDYYYY) Invalid Date Iteration 3 Iteration 2 Iteration 1 FIGURE 9.1 Simple.data.entry.user.interface. 296  Software Engineering Design fine.and.helps.the.user.understand.the.expected.formats.for.date.objects.knowledge.that. can.be.leveraged.in.other.software.systems.with.similar.requirements.Finally.to.address.

--- Chunk 489 ---
Tokens: 400
Type: sentence-based
Text:
can.be.leveraged.in.other.software.systems.with.similar.requirements.Finally.to.address. input.errors.error.indicators.in.the.interface.are.introduced.to.help.guide.the.user.to.the. correct.input.format.as.presented.on.Iteration.3.of.Figure 9.1.Typically.a.red.error.indica- tor.(e.g.as.a.background.color.on.input.boxes).is.a.passive.way.of.accomplishing.this. Many.other.options.for.date.input.could.be.used.instead.including.drop-down.lists.graph- ical.mini-calendars.for.selecting.the.date.and.spinners.Each.of.these.options.has.been.used. with.varying.levels.of.success.in.various.applications.Learning.which.method.works.for. a.specific.software.system.requires.end-user.testing.create.prototype.systems.or.mock-ups. with.each.design.choice.have.users.complete.realistic.tasks.using.these.systems.record.infor- mation.about.the.users.performance.(e.g.speed.accuracy).and.empirically.determine.the. best.design.This.effort.is.significant.and.requires.time.and.resources.to.accomplish.correctly. The.point.of.this.discussion.is.that.the.interface.(the.presented.information.to.the.user). plays.a.significant.role.in.the.utility.of.the.software.and.the.experience.of.the.user.Carefully. considering.the.user.and.the.users.abilities.when.designing.the.interface.can.only.increase. the.usability.of.the.software.system.Thorough.testing.of.the.design.with.end.users.is. paramount.to.designing.successful.software.systems. So.how.do.we.go.about.involving.the.user.in.the.process.One.must.spend.time.early.in. the.software.development.life.cycle.identifying.the.user.classes.for.the.software.A.user.class.

--- Chunk 490 ---
Tokens: 378
Type: sentence-based
Text:
the.software.development.life.cycle.identifying.the.user.classes.for.the.software.A.user.class. is.a.set.of.users.who.share.common.tasks.with.the.software.Consider.a.student.information. system.that.may.be.used.by.a.university.Clearly.one.class.of.user.would.be.the.students. Another.obvious.class.would.be.the.faculty.Other.classes.that.might.not.be.immediately. obvious.could.include.department.chairs.registrar.advisors.enrollment.management.staff. and.financial.aid.staff.There.could.be.others.Furthermore.a.single.person.could.take.on.the. characteristics.of.multiple.classes.For.example.a.faculty.member.could.also.be.an.advisor. and.a.department.chair.Each.of.the.user.classes.to.which.a.user.belongs.contributes.to.the. type.of.work.that.that.user.should.be.able.to.perform.with.the.software. After.identifying.the.user.classes.it.is.then.necessary.to.hold.requirements.meetings.with. representatives.of.each.user.class.These.meetings.should.elicit.the.tasks.that.the.target.user. class.should.be.able.to.do.with.the.software.as.well.as.tasks.that.would.be.nice.to.have. Recall.that.these.meetings.would.normally.occur.as.part.of.the.requirements.gathering. process.in.the.overall.software.development.life.cycle.not.as.a.separate.activity.although.it. could.be.separate.if.needed.Similar.to.software.architects.it.is.common.for.user.interface. designers.to.go.back.and.forth.between.requirements.and.design.until.the.interface.is. .sufficiently.appropriate.to.accommodate.the.needs.of.users.of.each.class.

--- Chunk 491 ---
Tokens: 397
Type: sentence-based
Text:
.sufficiently.appropriate.to.accommodate.the.needs.of.users.of.each.class. Skill Development 9.1: Eliciting Needs from Different User Classes Create.a.list.of.10.questions.you.would.ask.a.group.of.students.about.their.expectations. for.a.new.student.information.system.Create.a.list.of.10.questions.you.would.ask.a. group.of.faculty.about.their.expectations.for.the.same.system. HumanComputer Interface Design  297 After.learning.about.the.typical.interactions.your.user.classes.will.have.with.the.system. one.can.begin.designing.the.user.interface.to.meet.those.needs.One.of.the.most.challenging. things.for.software.engineers.is.to.disconnect.from.the.system.they.are.designing.and.try.to. see.the.world.through.the.eyes.of.the.end.user.It.is.tempting.to.simply.design.an.interface. that.meets.the.needs.of.the.engineer.or.developer.(e.g.for.testing.verification).instead.of. designing.an.interface.that.meets.the.needs.of.the.end.user.It.is.up.to.software.developers.to. maintain.a.clear.focus.on.the.end.user.while.developing.the.user.interface.for.a.system.The. following.sections.provide.specific.information.to.aid.the.designer.in.focusing.on.the.user. GENERAL HCI DESIGN PRINCIPLES Several.design.principles.and.heuristics.exist.for.guiding.user.interface.designers.Accord- ing.to.Nielsen.and.Mack.(1994).there.are.10.major.heuristics.to.follow.when.creating.a.user. interface: . 1.Visibility of system status.The.interface.should.have.some.mechanism.for.showing. where.users.are.in.their.task. . 2.Match between system and the real world.The.interface.should.provide.interaction.

--- Chunk 492 ---
Tokens: 387
Type: sentence-based
Text:
2.Match between system and the real world.The.interface.should.provide.interaction. techniques.that.mimic.or.model.what.is.expected.in.the.real.world. . 3.User control and freedom.The.interface.should.support.user.exploration.without.fear. of.breaking.anything.Undo.and.redo.should.be.supported. . 4.Consistency and standards.The.interface.should.use.for.example.language.or.wording. that.is.consistent.with.users.expectations.Follow.style.guides.and.platform.standards. . 5.Error prevention.The.interface.should.help.users.avoid.mistakes.Always.ask.them. when.they.initiate.a.destructive.command. . 6.Recognition rather than recall.The.interface.should.support.rapid.and.easy.learning. of.the.system.and.support.recognizing.features.and.their.associated.actions.rather. than.relying.on.memorization.of.unique.interface.widgets. . 7.Flexibility and efficiency of use.The.interface.should.provide.users.with.shortcuts.or. other.accelerators.This.helps.the.interface.get.out.of.the.way.of.expert.users.while. allowing.novice.users.the.opportunity.to.become.more.efficient. . 8.Aesthetic and minimalist design.The.interface.should.present.only.the.necessary.infor- mation.and.no.more.Extra.visual.elements.can.distract.from.the.important.information. . 9.Help users recognize, diagnose, and recover from errors.Error.messages.should.be. expressed.in.plain.language. (no.codes).precisely.indicate.the.problem.and.con- structively.suggest.a.solution. . 10.Help and documentation.Make.sure.the.help.and.documentation.is.clearly.available. in.the.interface.

--- Chunk 493 ---
Tokens: 398
Type: sentence-based
Text:
in.the.interface. These.10.guidelines.or.heuristics.are.generic.and.open.This.is.intentional.so.that.they.can. be.applied.across.a.large.cross.section.of.software.systems.This.generality.can.sometimes. 298  Software Engineering Design lead.to.ambiguity.and.confusion.on.the.part.of.the.developer.More.specific.heuristics. can.be.useful.when.developing.software.for.specific.platforms.or.systems.(Somervell.and. McCrickard.2005).However.the.point.is.that.there.are.some.simple.straightforward.things. to.consider.when.designing.any.user.interface.More.importantly.these.10.guidelines.are. focused.on.users.and.strive.to.keep.them.in.control.of.the.system.the.system.serves.the. user.Applying.these.rules.in.a.specific.application.can.help.create.an.interface.that.users. will.find.both.useful.and.usable.Consider.a.popular.online.calendar.application.as.pre- sented.in.Figure.9.2. In.this.particular.calendar.application.creating.an.appointment.relies.mostly.on.direct. manipulationdirectly. clicking. on. the. desired. day. typing. in. a. description. including. time.and.hitting.the.return.key.This.action.is.analogous.to.writing.that.information.on. a.desk.calendar.or.other.paper.calendar.It.is.exactly.what.users.expect.to.be.able.to.do. with.a.calendar.In.addition.there.is.a.button.(Create.event).that.allows.users.to.add. appointments.by.filling.in.a.form.some.users.may.prefer.this.method.of.entry.especially. for.events.that.occur.in.the.future.which.would.require.navigation.within.the.calendar.to. enter.through.the.direct.manipulation.route.A.new.appointment.is.shown.immediately.in.

--- Chunk 494 ---
Tokens: 389
Type: sentence-based
Text:
enter.through.the.direct.manipulation.route.A.new.appointment.is.shown.immediately.in. the.day.for.which.it.is.assigned. Now.consider.the.10.guidelines.in.relation.to.this.interface.In.terms.of.system.status.this. interface.shows.an.entire.month.(or.week.or.day).of.appointments.in.the.expected.monthly. format. A. newly. created. appointment. appears. immediately. within. the. day. for. which. it. FIGURE 9.2 Example.calendar.user.interface. HumanComputer Interface Design  299 occurs.Error.conditions.are.displayed.prominently.in.the.top.center.of.the.display.in.red. text.In.terms.of.matching.the.real.world.it.clearly.mimics.the.desktop.calendar.and.heavily. utilizes.that.metaphor.The.form.and.layout.closely.resembles.other.calendar.applications. so.consistency.and.standards.are.followed.Users.can.really.commit.no.errors.in.the.soft- ware.and.any.mistakes.are.easily.corrected.through.undo.or.deletion.capabilities.As.a. GUI.application.there.are.no.commands.to.learn.and.remember.from.usage.to.usage.and. help.is.available.through.pop-up.labels.on.hover.The.design.is.minimal.in.that.only.the. necessary.information.is.shown.with.extra.functionality.available.in.submenus.Overall. this.particular.interface.performs.well.with.respect.to.Nielsen.and.Macks.(1994).heuristics. This.high-level.analysis.of.the.calendar.application.serves.to.illustrate.a.good.interface. and.how.a.good.interface.will.typically.meet.most.of.the.general.heuristics.Improvements. to.an.interface.will.often.revolve.around.one.of.the.10.areas.described.by.these.guidelines.

--- Chunk 495 ---
Tokens: 384
Type: sentence-based
Text:
to.an.interface.will.often.revolve.around.one.of.the.10.areas.described.by.these.guidelines. However.these.guidelines.are.just.that.guidance.How.does.one.go.about.starting.the.inter- face.design.process.How.do.we.get.a.prototype.of.the.system? HUMANCOMPUTER INTERFACE DESIGN METHODS HCI.sits.at.the.intersection.of.design.science.and.engineering.(McCrickard.Chewar.and. Somervell.2004).To.create.an.effective.interface.the.designer.must.rely.on.information.from. psychology.sociology.graphic.design.human.factors.and.ergonomics.computer.science. and.mathematics.(among.a.plethora.of.other.specialty.areas).This.implies.that.designers. work.on.or.with.a.multidisciplinary.team.Each.of.the.aforementioned.areas.contributes.to. the.design.of.the.interface.in.some.specific.waywhether.it.be.in.leveraging.the.intricacies. of.the.human.information.systems.(e.g.visual.audible.haptic).through.color.choice.font. choice.line.width.and.so.forth.or.in.leveraging.the.societal.norms.or.customs.of.the.target. user.class.through.for.example.wording.ordering.of.information.or.icon.design. Getting Started Almost.all.design.activities.regardless.of.discipline.start.with.some.form.of.brainstorm- ing.activity.There.is.no.specific.structure.required.or.followed.the.designer.simply.starts. thinking.about.ways.to.solve.a.problem.and.then.drawing.or.writing.out.descriptions.of. that.solution.Often.at.this.stage.in.design.the.only.technologies.needed.are.kindergarten. tools.pencils.paper.crayons.markers.scissors.tape.Some.people.prefer.to.work.on.a.

--- Chunk 496 ---
Tokens: 398
Type: sentence-based
Text:
tools.pencils.paper.crayons.markers.scissors.tape.Some.people.prefer.to.work.on.a. chalkboard.or.whiteboard.and.take.pictures.of.the.drawings.for.record.keeping.In.any. case.the.point.is.to.capture.ideas.and.thoughts.on.paper.for.later.access. It.is.interesting.(but.not.surprising).to.note.that.the.majority.of.interfaces.(electronic). are.rectangular.We.use.rectangular.paper.rectangular.calendars.rectangular.screens.and. rectangular.books.Humans.like.rectangles.Most.of.the.interfaces.you.will.design.will.be. contained.in.rectangles.This.fact.can.be.leveraged.when.creating.an.interface.Furthermore. at.least.in.North.America.people.read.from.left.to.right.and.from.top.to.bottom.This.is. 300  Software Engineering Design taught.from.early.childhood.when.parents.read.to.their.children.and.trace.their.finger. along.with.the.words.Certainly.by.kindergarten.even.before.they.know.how.to.read.most. children.are.trained.to.look.at.readable.objects.and.materials.at.the.top.left.and.proceed.to. the.right.and.down.This.knowledge.is.used.in.interface.design.by.placing.prominent.infor- mation.in.the.upper.left.corner.of.the.interface.Take.a.moment.to.examine.your.favorite. program.Check.out.the.interface.and.identify.the.type.of.information.placed.in.the.upper. left.quadrant.Most.programs.will.have.some.important.functionality.located.in.that.area. of.the.interface.One.notable.exception.is.the.Start.menu.in.Windows.operating.systems. (but.it.is.still.on.the.left).This.type.of.understanding.of.the.human.element.can.help.the. interface.designer.create.effective.and.usable.interfaces.

--- Chunk 497 ---
Tokens: 390
Type: sentence-based
Text:
interface.designer.create.effective.and.usable.interfaces. Fidelity in Prototypes Early.design.efforts.generate.low-fidelity.prototypes.of.the.system.interface.Fidelity.in.this. sense.means.the.level.of.sophistication.or.realism.in.the.interface.(Virzi.Sokolov.and.Karis. 1996).Certainly.a.drawing.of.an.interface.on.paper.done.in.pencil.would.require.lots.of. imagination.on.the.part.of.end.users.or.clients.if.they.were.to.get.a.feel.for.the.intent.of. the.interface.More.realism.is.needed.when.communicating.design.ideas.to.customers. perhaps.screen.shots.or.a.simple.presentation.Mostly.working.high-fidelity.prototypes. are.required.for.summative.evaluations.(Hix.and.Hartson.1993).The.idea.is.that.there.is. a.spectrum.of.fidelity.when.it.comes.to.designing.prototypes.Low-fidelity.prototypes.are. useful.in.early.design.for.communicating.and.eliciting.requirements.from.the.client.and. end.users.Medium-fidelity.prototypes.are.useful.for.illustrating.interaction.sequences.and. specific.design.choices.High-fidelity.prototypes.are.required.for.effective.end-user.testing. Each.level.of.fidelity.is.useful.to.the.designer.and.will.likely.be.utilized.during.the.interface. creation.process. Skill Development 9.2: Low-Fidelity User Interface Design Using.only.paper.and.pencil.draw.an.interface.for.a.ticket.purchasing.kiosk.The.hard- ware.supports.touch-screen.interaction. Low-fidelity.prototypes.are.useful.to.the.designer.in.the.early.stages.for.several.reasons. They.cost.very.little.Pencil.and.paper.and.other.similar.materials.are.cheap.The.time.and.

--- Chunk 498 ---
Tokens: 395
Type: sentence-based
Text:
They.cost.very.little.Pencil.and.paper.and.other.similar.materials.are.cheap.The.time.and. energy.required.to.create.a.simple.sketch.of.an.interface.are.also.negligible.Often.if.the. ideas.come.during.the.initial.requirements.gathering.meetings.designers.can.create.mock- ups.on.the.spot.to.clarify.ideas.and.get.a.better.grasp.of.the.customers.wants.and.needs. Low-fidelity.prototypes.can.also.be.thrown.away.easily.Often.designers.simply.crum- ple.up.a.piece.of.paper.and.start.over.with.the.design.This.is.much.more.difficult.and. time-consuming.when.using.higher-fidelity.tools. (e.g.commercial.tools.integrated.devel- opment.environments.presentation.software).Figure 9.3.presents.an.example.of.a.low- HumanComputer Interface Design  301 fidelity.prototype.of.a.fictional.document.editor.in.which.the.major.interface.components. are.illustrated.without.any.real.details. After.identifying.requirements.and.getting.initial.feedback.from.customers.on.early.pro- totypes.designers.must.then.work.toward.creating.a.more.realistic.prototype.that.can.be. used.for.specific.testing.Interface.design.tools.with.drag-and-drop.support.for.widgets. like.text.boxes.labels.buttons.and.other.controls.are.highly.useful.for.this.phase.Most. popular.programming.languages.have.graphical.development.environments.with.support. for.interface.design.One.popular.example.is.Visual.Studio.which.has.excellent.support. for.C.and.Visual.Basic.Using.these.types.of.tools.and.others.the.designer.then.creates.a. more.realistic.prototype.of.the.system.with.either.stubbed.functionality.or.some.Wizard.

--- Chunk 499 ---
Tokens: 399
Type: sentence-based
Text:
more.realistic.prototype.of.the.system.with.either.stubbed.functionality.or.some.Wizard. of.Oz.approach.(Carroll.and.Aaronson.1998).In.the.high-fidelity.prototype.of.the.system. all.controls.are.functional.and.do.what.is.expected.of.them.so.that.it.can.be.used.for.more. extensive.testing.purposes.It.is.during.this.phase.of.creation.that.guidelines.like.the.afore- mentioned.heuristics.can.aid.the.designer.in.creating.an.interface.that.will.be.useful.and. usable.Style.guides.system.compatibility.issues.and.other.external.constraints.must.be. followed.and.can.impact.the.flexibility.of.the.designer.Considerations.such.as.these.serve. as.input.to.the.design.process.and.the.resulting.interface.should.meet.as.many.of.these. constraints.as.possible. Metaphors Helping.the.end.user.learn.and.use.a.new.interface.requires.thought.and.effort.on.the.part. of.the.interface.designer.One.highly.used.technique.is.the.incorporation.of.metaphors.in. .The Wonderful Wizard of Oz is.a.childrens.story.by.L.Frank.Baum.In.this.story.an.all-powerful.wizard.turns.out.to.be.a. normal.man.operating.some.sophisticated.machinery.behind.a.curtain.The.relevance.here.is.that.the.designers.or.testers. fake.the.functionality.for.testing.purposes. FIGURE 9.3 Low-fidelity.prototype.of.a.fictional.document.editor. 302  Software Engineering Design the.design.A.metaphor.is.the.application.of.a.known.often.real-world.object.and.its.char- acteristics.to.an.electronic.interface.A.classic.example.is.the.desktop.metaphor.used.in.all. major.operating.system.graphical.shells.(GUIs).Before.computers.became.ubiquitous.in.

--- Chunk 500 ---
Tokens: 398
Type: sentence-based
Text:
major.operating.system.graphical.shells.(GUIs).Before.computers.became.ubiquitous.in. the.workplace.people.sat.at.desks.where.all.of.the.tools.needed.in.their.work.were.available. within.arms.reach.This.work.environment.and.management.style.was.copied.in.the.cre- ation.of.the.virtual.desktop.People.now.rely.on.their.graphical.user.interface.to.access.all. of.the.tools.they.need.to.get.their.work.done.Learning.this.environment.is.straightforward. and.relatively.simple.for.those.familiar.with.a.physical.desk. Other.similar.metaphors.abound.in.electronic.interfaces.Consider.e-mail.which.consists. of.a.blend.of.two.physical.objects.that.are.heavily.used.in.interoffice.communications.letters. and.memos.Most.e-mail.composition.programs.provide.an.interface.that.includes.text.entry. areas. for.the. recipient. copies.and. subjectall.requirements.for.most.interoffice.memos. E-mail.also.supports.both.formal.and.informal.letter.writing.and.copies.the.idea.of.sending. a.letter.to.someone.The.e-mailmemo.metaphor.is.readily.understood.by.newcomers.and. .easily.mastered.by.those.who.have.never.dealt.with.the.real-world.counterparts.an.all-around. excellent.use.of.a.metaphor.to.aid.the.end.user.in.learning.and.using.a.software.system. One.must.be.mindful.of.overusing.metaphors.While.the.benefits.include.ease.of.learn- ing.and.ease.of.use.overapplication.or.too.literal.an.application.of.a.metaphor.can.limit. the.designer.and.prevent.improvements.Take.the.classic.calculator.A.handheld.calculator. with.basic.functionality.is.simple.and.easy.to.use.Creating.a.calculator.for.use.within.an.

--- Chunk 501 ---
Tokens: 396
Type: sentence-based
Text:
with.basic.functionality.is.simple.and.easy.to.use.Creating.a.calculator.for.use.within.an. operating.system.is.a.normal.thing.and.many.users.employ.the.software.calculator.for. various.tasks.Figure 9.4.presents.a.simple.software.calculator.interface. FIGURE 9.4 Simple.software.calculator. HumanComputer Interface Design  303 Notice.that.the.software.version.looks.much.like.a.handheld.calculator.This.is.good.for. learning.how.the.interface.works.and.what.is.possible.A.novice.user.can.easily.use.the.inter- face.to.perform.simple.calculations.However.the.interface.is.a.literal.copy.of.the.real-world. interface.and.as.such.does.not.provide.any.extra.features.that.might.be.expected.in.soft- ware. including. selectable. history. multiple. storage. areas. (variables). and. visualizations. (like graphing.or.showing.the.equation.that.yielded.the.answer).In.this.case.the.designers. took.the.metaphor.too.far.and.restricted.the.utility.of.the.program.Unfortunately.there.are. no.hard-and-fast.rules.to.tell.when.a.designer.has.taken.a.metaphor.too.far.The.only.way. to.discern.this.information.is.through.beta.testing.or.actual.use.People.will.use.a.product. and.indicate.functionality.they.would.like.to.see.in.the.product.Good.designers.try.their. best.to.anticipate.that.functionality.but.that.ability.comes.with.experience. Skill Development 9.3: Metaphors in User Interface Design Describe.three.metaphors.used.on.the.popular.social.website.Facebook.(http:www. facebook.com). Gestalt Principles Another.set.of.useful.design.guidance.comes.from.perceptual.psychology.Knowing.how.

--- Chunk 502 ---
Tokens: 393
Type: sentence-based
Text:
Gestalt Principles Another.set.of.useful.design.guidance.comes.from.perceptual.psychology.Knowing.how. the.human.brain.processes.information.should.be.high.on.the.list.of.things.with.which.an. interface.designer.should.be.familiar.German.psychologists.described.several.principles. of.perception.in.the.1920s.They.used.the.term.gestalt.which.means.whole.to.illustrate. how.the.human.brain.recognizes.and.organizes.information.Take.a.moment.to.examine. Figure 9.5.What.do.you.see.in.the.image.on.the.left.Most.people.would.describe.it.as.a.plus. sign.Very.few.if.any.would.describe.it.as.two.symmetric.right.angles.sharing.a.common. point.The.image.on.the.right.shows.the.two.right.angles.slightly.separated.for.emphasis. There.are.six.major.gestalt.principles.proximity.similarity.closure.area.symmetry.and. continuity.(Rosson.and.Carroll.2002).Proximity.relies.on.the.fact.that.objects.arranged. close.together.are.considered.grouped.together.Similarity.simply.means.that.objects.that. FIGURE 9.5 Illustration.of.continuity. 304  Software Engineering Design share.visual.characteristics.(e.g.color.shape).will.be.considered.as.a.group.or.as.similar. in.functionality.Closure.is.the.idea.that.humans.try.to.organize.things.into.closed.figures. Area.is.similar.to.closure.but.with.the.extra.emphasis.on.the.fact.that.humans.try.to.create. the.figure.with.the.smallest.area.Symmetry.refers.to.the.fact.that.humans.often.treat.sym- metric.elements.as.part.of.the.same.figure.or.group.Finally.continuity.refers.to.the.human. predisposition.to.see.continuous.contours.or.patterns.

--- Chunk 503 ---
Tokens: 383
Type: sentence-based
Text:
predisposition.to.see.continuous.contours.or.patterns. Skill Development 9.4: Gestalt Principles in User Interface Design Identify.instances.of.the.six.gestalt.principles.in.the.interface.presented.in.Figure 9.6. Knowledge.of.the.gestalt.principles.is.useful.in.and.of.itself.but.knowing.how.to.utilize. and.capitalize.on.them.for.effective.interface.design.requires.extensive.practice.In.addition. to.the.gestalt.principles.there.are.some.other.useful.design.guidelines.to.consider.Consider. white.space.in.interface.designs.White.space.is.the.area.in.a.graphical.display.with.no. visual.elements.White.space.becomes.very.important.for.helping.the.end.user.understand. the.graphical.elements.in.a.display.For.example.tabs.are.often.used.for.alignment.pur- poses.and.it.is.the.extra.white.space.between.the.columns.in.a.tabbed.display.that.allows. users.to.perceive.the.data.as.columns.thus.allowing.them.to.more.readily.understand.the. presented.information.Be.generous.with.white.space.as.it.directly.reinforces.several.of. the.gestalt.principles.Simultaneously.be.very.careful.about.superfluous.design.elements. Anything.extra.in.an.interface.that.does.not.provide.useful.information.has.the.potential. to.detract.from.the.utility.of.the.interface. (Carroll.1990).Consider.the.interface.in.the.pre- vious.skill.development.All.of.the.vertical.and.horizontal.lines.can.be.removed.from.the. interface.without.detracting.the.utility.or.communication.provided.Be.careful.about.any. FIGURE 9.6 Common.user.interface.for.printer.systems.

--- Chunk 504 ---
Tokens: 400
Type: sentence-based
Text:
FIGURE 9.6 Common.user.interface.for.printer.systems. HumanComputer Interface Design  305 graphical.element.Whenever.a.graphical.element.is.added.to.an.interface.always.ask.the. question.Is.this.necessary? Reusing Earlier Designs Sometimes.interface.designers.do.not.need.to.start.from.scratch.Instead.they.have.access. to.similar.products.or.have.rough.designs.given.to.them.In.these.types.of.situations.inter- face.designers.are.likely.to.work.with.designs.that.do.need.heavy.modification.to.meet.the. unique.needs.of.the.new.system.In.such.situations.designers.need.to.rely.on.field.studies. and.other.empirical.testing.to.identify.areas.for.improvement.In.other.words.reusing. an.existing.interface.can.sometimes.reduce.the.design.effort.but.will.usually.increase.the. .testing.effort. EVALUATION OF HCI QUALITY Before.systems.are.deployed.significant.efforts.must.be.made.to.ensure.that.user.interfaces. are.sufficiently.complete.understandable.and.efficient.for.providing.users.with.systems. that.exhibit.high.quality.in.terms.of.usability.IEEE. (1990.p.80).defines.usability.as The.ease.with.which.a.user.can.learn.to.operate.prepare.inputs.for.and.interpret.outputs.of. a.system.or.component. Therefore.evaluation.of.the.HCI.quality.is.essential.during.the.design.process.Several. approaches. can. be. taken. when. evaluating. and. minimizing. the. degree. of. complexity. involved.when.learning.or.using.the.system.including.usability.testing.analytic.testing. and.empirical.testing. Usability Testing At.this.point.during.the.interface.design.process.there.should.be.some.usable.prototype.of.

--- Chunk 505 ---
Tokens: 392
Type: sentence-based
Text:
Usability Testing At.this.point.during.the.interface.design.process.there.should.be.some.usable.prototype.of. the.interface.that.can.be.used.for.testing.purposes.It.is.beneficial.to.understand.testing.and. how.to.go.about.doing.it.First.it.should.be.noted.that.there.are.two.classes.of.evaluation. (Scriven.1967): . Formative . Summative Formative. evaluation. occurs. within. the. design. process. and. focuses. on. alternatives. and.clarification.Summative.evaluation.occurs.after.the.design.process.and.focuses.on. assessing.the.result.Formative.evaluation.should.be.heavily.utilized.throughout.the.inter- face. design. process. iteratively. improving. the. design. Summative. evaluation. should. be. 306  Software Engineering Design utilized.when.a.solid.version.of.the.interface.is.completed.(Note.this.does.not.mean.after. the.design.is.complete.but.rather.when.a.version.of.the.interface.is.considered.ready.for. testing.).An.easy.way.to.distinguish.between.formative.and.summative.evaluation.is.that. formative.evaluation.is.like.the.cook.tasting.the.soup.and.summative.evaluation.is.like.the. customer.tasting.the.soup. There.are.two.main.methods.of.user.interface.testing.analytic.and.empiric.(Scriven. 1967).Each.can.be.used.for.both.formative.and.summative.evaluations.Analytic.testing. involves.domain.or.usability.experts.analyzing.an.interface.for.design.issues.Empirical. testing.(also.known.as.user.testing).involves.representative.end.users.performing.realistic. tasks.with.the.interface.Each.type.of.test.reveals.different.information.to.the.interface.

--- Chunk 506 ---
Tokens: 390
Type: sentence-based
Text:
tasks.with.the.interface.Each.type.of.test.reveals.different.information.to.the.interface. designer.and.ideally.both.should.be.utilized.in.a.mediated.evaluation.(Scriven.1967). Analytic Testing Analytic.testing.is.often.used.earlier.in.the.development.process.than.empirical.testing. The.reason.for.this.is.that.early.in.the.interface.design.process.there.is.usually.no.working. .system.with.which.to.test.end.users.Instead.there.are.low-.or.high-fidelity.prototypes.These. prototypes.can.be.examined.by.knowledgeable.experts.for.compliance.with.for.example. design.guidelines.style.guides.and.compatibility.guides.The.key.result.of.an.analytic.eval- uation.is.a.subjective.opinion.about.the.interface.Multiple.specific.tests.fall.under.the.ana- lytic.umbrella.usability.inspections.heuristic.evaluations.and.cognitive.walkthroughs. Usability.inspections.are.simply.experts.using.the.prototype.in.intended.ways.while.ensur- ing.usability.guidelines.are.followed.Often.these.types.of.inspections.have.checklists.or. other.guidelines.(e.g.style.guides).that.are.noted.by.evaluators.The.end.result.is.often.a. list.of.usability.issues.identified.and.sometimes.rated.by.severity.(how.much.an.impact.the. issue.might.have.on.end.users.ability.to.complete.their.task).Cognitive.walkthroughs.are. an.example.of.a.usability.inspection.In.this.specific.type.of.inspection.experts.are.given. a.script.to.work.through.in.an.interface.while.looking.for.violations.of.usability.guidelines. and.standards.while.assessing.the.interface.for.visual.cues.(Lewis.Polson.Wharton.and.

--- Chunk 507 ---
Tokens: 400
Type: sentence-based
Text:
and.standards.while.assessing.the.interface.for.visual.cues.(Lewis.Polson.Wharton.and. Rieman.1990).The.goal.is.to.identify.aspects.of.the.interface.that.detract.from.users.ability. to.complete.their.tasks.with.the.system.and.to.identify.missing.information.that.could.be. useful.The.result.of.a.cognitive.walkthrough.is.a.detailed.listing.of.good.and.bad.aspects. of.interfaces.with.respect.to.specific.tasks. Heuristic.evaluation.is.similar.to.usability.inspection.whereas.it.involves.multiple.experts. reviewing.an.interface.with.respect.to.a.list.of.heuristics.(see.Nielsens.heuristics.described. earlier.Nielsen.and.Mack.1994).The.difference.is.that.the.evaluator.may.be.a.representa- tive.stakeholder.(e.g.developer.end.user).Again.the.result.is.a.list.of.problems.identified. in.the.interface.These.can.be.rated.by.severity.The.interesting.thing.to.note.about.this. approach.is.the.utility.it.brings.A.few.(35).experts.can.find.about.80.of.the.usability. issues.in.an.interface.with.this.method.(Nielsen.and.Molich.1990).However.heuristic. evaluation.and.all.analytic.methods.suffer.a.major.weakness.the.results.are.mainly.the. opinion. (albeit educated).of.evaluators.Whether.an.identified.issue.will.negatively.impact. HumanComputer Interface Design  307 real.users.of.the.system.is.unknown.without.further.testing.This.type.of.data.is.subjective. and.often.holds.less.weight.than.objective.data. Empirical Testing The.opposite.of.subjective.data.is.objective.data.or.empirical.data.This.type.of.data.is. highly.respected.because.it.is.hard.to.argue.aboutit.is.factual.data.about.the.system.

--- Chunk 508 ---
Tokens: 397
Type: sentence-based
Text:
highly.respected.because.it.is.hard.to.argue.aboutit.is.factual.data.about.the.system. of.interest.Empirical.testing.provides.this.type.of.data.to.the.designers.Unfortunately. empirical.testing.is.difficult.and.expensive.Why.It.costs.time.and.money.to.set.up.and. execute.a.good.empirical.study.Costs.revolve.around.securing.space.development.time. (of.the.tests).hiring.participants.data.collection.analysis.and.reporting.Nonetheless. empirical.testing.is.highly.respected.and.should.be.utilized.in.the.interface.design.process. Many.types.of.empirical.testing.can.be.used.for.interface.evaluation.field.studies.lab. based.experiments.and.user.surveys.The.recorded.data.can.vary.from.observations.of.use. to.survey.responses.to.measured.data.from.lab-based.experiments.This.data.is.objective. and.the.data.itself.is.unquestionable.The.issue.with.empirical.data.is.the.interpretation.of. the.data.and.the.validity.of.the.setting.from.which.the.data.came. Field.studies.involve.designers.or.design.teams.going.into.the.field.and.observing.the.end. users.in.their.current.work.environment.Observations.of.work.practices.data.flow.and. communication.channels.can.provide.insight.for.what.to.include.in.user.interfaces.The. raw.data.from.a.field.study.is.typically.not.as.useful.as.the.analysis.of.the.data.through.cate- gorization.or.content.classification.(higher-level.issues.that.caused.the.observed.behavior). A.major.drawback.of.field.studies.is.the.cost.involved.Significant.time.(and.thus.money). would.need.to.be.invested.to.fully.understand.the.existing.work.environment.On.projects.

--- Chunk 509 ---
Tokens: 372
Type: sentence-based
Text:
would.need.to.be.invested.to.fully.understand.the.existing.work.environment.On.projects. with.tight.schedules.this.type.of.evaluation.may.not.be.feasible.It.is.useful.to.note.that. field.studies.are.highly.useful.for.formative.evaluations. Lab-based.studies.are.highly.useful.in.usability.evaluation. (whether.formative.or.sum- mative).Often.the.prohibitive.cost.of.doing.field.work.implies.testing.should.be.done.in. a.computer.lab.In.this.situation.the.designers.work.with.testers.to.create.a.testing.envi- ronment.with.which.to.isolate.and.study.specific.aspects.of.an.interface.Participants.are. brought.into.the.lab.environment.and.asked.to.perform.the.required.tasks.In.these.settings. excellent.data.on.usage.can.be.collected.The.major.issue.with.lab-based.studies.comes.from. validity.Validity.refers.to.how.realistic.the.experiment.happens.to.behow.well.does.the. testing.situation.model.the.real-world.situation.Are.the.participants.representative.of.the. real.end.users.Did.the.participants.used.in.the.test.have.more.knowledge.of.this.type.of. system.than.the.average.user.Would.the.participants.be.more.distracted.in.their.normal. work.environment.All.of.these.questions.and.others.take.away.from.the.utility.of.the.data. that.comes.from.a.lab-based.study.Controlling.for.validity.is.difficult.and.time-consuming. Results.should.always.be.considered.in.light.of.any.validity.issues. A.specific.type.of.lab-based.study.is.the.controlled.experiment.If.a.specific.design.choice.

--- Chunk 510 ---
Tokens: 396
Type: sentence-based
Text:
A.specific.type.of.lab-based.study.is.the.controlled.experiment.If.a.specific.design.choice. needs.to.be.validated.through.experimental.means.one.can.design.an.experiment.to.objec- tively.determine.the.performance.of.competing.options.Suppose.a.design.team.wants.to. determine.which.color.scheme.to.use.for.a.system.display.The.choices.have.been.narrowed. 308  Software Engineering Design to.black.text.on.a.white.background.or.white.text.on.a.black.background.Before.determin- ing.the.best.approach.a.criteria.for.evaluation.needs.to.be.in.place.In other.words.what. does.best.approach.mean.Does.it.mean.faster.reading.times.higher.reading.comprehen- sion.or.less.eye.strain.We.could.actually.study.all.three.with.a.single.experiment.In this. situation.the.read.time.reading.comprehension.and.eye.strain.would.be.the.dependent. variables.The.values.obtained.from.the.test.participants.are.dependent.upon.the.color. scheme.This.means.that.the.color.scheme.is.the.independent.variable.in.this.case.with.two. levels.black.on.white.and.white.on.black. There.are.many.ways.to.design.the.actual.experimental.setting.for.this.test.We.could.use. a.between-subjects.design.and.have.two.separate.sets.of.participants.work.with.each.level. of.the.independent.variable.Or.we.could.use.a.within-subjects.design.and.have.the.same. groups.of.people.read.text.with.both.color.schemes.The.latter.choice.would.imply.the.need. for.two.different.sets.of.text.so.that.a.person.who.reads.a.passage.in.white.on.black.would. not.read.the.same.passage.in.black.on.white.but.a.different.passage.We.would.need.to.

--- Chunk 511 ---
Tokens: 394
Type: sentence-based
Text:
not.read.the.same.passage.in.black.on.white.but.a.different.passage.We.would.need.to. account.for.the.passage.used.in.a.within-subjects.test.because.reading.one.passage.before. the.other.might.influence.the.speed.of.reading.or.comprehension.We.would.also.need.to. vary.the.order.of.the.presentation.of.the.white-on-black.black-on-white.conditions.half. of.the.participants.would.start.with.white.on.black.first.the.other.half.would.start.with. black.on.white.first.In.all.cases.we.need.to.be.concerned.with.the.number.of.participants. for.our.test.A.good.rule-of-thumb.is.10.participants.per.condition.(Scriven.1967).For. our.experimental.setup.(two.levels.of.the.independent.variable.and.two.passages.to.read). we.would.need.2.2.10.40.participants.It.should.be.clear.that.a.within-subjects.test. requires.more.participants.(if.there.are.more.conditions).Within-subjects.tests.are.often. more.highly.regarded.with.respect.to.the.findings.The.reason.is.that.individual.variability. in.the.participants.can.be.controlled.for.in.a.within-subjects.test. Skill Development 9.5: Designing Experiments for Empirical Testing Design.a.between-subjects.and.a.within-subjects.experimental.setup.for.determining. whether.direct.entry.or.a.drop-down.list.would.provide.faster.input.times.for.dates. in.a.database.form.In.the.direct-entry.condition.invalid.date.formats.are.errors.and. cost.an.extra.3.seconds.to.correct.Identify.the.dependent.and.independent.variables. Determine.the.number.of.participants.required.for.each.type.of.test.(assume.a.minimal. of.10.participants.per.condition).

--- Chunk 512 ---
Tokens: 397
Type: sentence-based
Text:
of.10.participants.per.condition). Another.way.to.gather.empirical.data.is.through.user.surveys.These.can.be.stand-alone. surveys.or.part.of.a.lab-based.experiment.The.goal.is.to.have.end.users.comment.on.the. system.and.their.experiences.This.type.of.data.can.be.useful.in.identifying.high-level. usability.issues.as.well.as.provide.insight.into.how.users.will.perform.with.the.system. Depending.on.the.type.of.data.it.can.be.analyzed.using.statistical.methods.for.concrete. HumanComputer Interface Design  309 evidence.for.specific.design.choices.Often.survey.results.are.used.for.categorization.of.the. participants.and.aid.in.interpreting.results. CHAPTER SUMMARY This. chapter. has. provided. high-level. guidance. for. completing. the. humancomputer. interface.design.phase.within.system.design.The.main.focus.is.users.It.is.the.duty.of.the. designer.to.keep.users.and.their.interests.as.the.focus.of.the.interface.The.application. of.design.guidelines.perceptual.psychology.and.sound.scientific.method.are.all.used.to. provide.and.justify.concrete.interface.designs.that.meet.the.needs.of.the.users.It.is.on. the.shoulders.of.the.designer.to.make.sure.the.system.is.going.to.be.easy.to.use.easy.to. learn.and.enjoyable.for.the.end.user.Balancing.these.fundamental.requirements.with. the.various.system.requirements.and.functional.constraints.is.the.core.of.the.interface. designers.challenge. REVIEW QUESTIONS . 1.What.is.humancomputer.interface.design? . 2.What.are.the.steps.in.the.HCI.design.phase? . 3.Why.is.the.focus.on.the.user.so.important.to.successful.interface.design? .

--- Chunk 513 ---
Tokens: 397
Type: sentence-based
Text:
. 4.What.is.a.metaphor.with.regards.to.interface.design? . 5.What.are.the.gestalt.principles? . 6.Why.is.white.space.so.important? . 7.What.are.the.two.major.types.of.evaluations? . 8.What.are.the.two.major.evaluation.methods? . 9.Why.are.analytic.methods.typically.cheaper.and.faster.and.empirical.methods? . 10.What.is.the.difference.between.a.between-subjects.design.and.a.within-subjects.design? CHAPTER EXERCISES . 1.Using.presentation.software. (e.g.PowerPoint.Impress).create.a.high-fidelity.pro- totype.of.the.ticket.purchasing.kiosk.described.in.Skill.Development.7.2.Fake.the. functionality.by.linking.to.different.slides.in.your.prototype. . 2.Repeat.Exercise.1.using.a.high-level.graphical.language.(e.g.Visual.Basic.Visual.C). . 3.Analyze.your.favorite.e-mail.client.with.regards.to.Nielsens.10.heuristics.Create.a. list.of.usability.issues.and.rank.them.by.severity. 310  Software Engineering Design . 4.Walk.through.the.process.of.creating.and.sending.an.e-mail.in.your.favorite.e-mail. client.Identify.gestalt.principles.that.are.in.use.in.the.system.Identify.improvements. that.could.be.made.through.the.application.of.gestalt.principles. . 5.A.common.metaphor.used.for.online.shopping.is.the.idea.of.a.shopping.cart.Thor- oughly.discuss.the.usage.of.this.metaphor.for.your.favorite.online.shopping.system. Focus.on.how.the.similarities.to.the.real.world.enhance.the.experience.and.how.the. differences.detract.from.the.experience. . 6.Look.up.discount.usability.evaluation.Describe.the.process.and.identify.whether.it.is. more.useful.for.formative.or.summative.evaluation.

--- Chunk 514 ---
Tokens: 382
Type: sentence-based
Text:
more.useful.for.formative.or.summative.evaluation. REFERENCES Carroll.J.M.The Nurnberg Funnell: Designing Minimalist Instruction for Practical Computer Skill.Cambridge. MA.MIT.Press.1990. Carroll.J.M.and.P.Aaronson.Learning.by.Doing.with.Simulated.Intelligent.Help.Communications of the Association for Computing Machinery.1998.10641079. Hix. D. and. H. R. Hartson. Developing User Interfaces: Ensuring Usability Through Product  Process. New York.John.Wiley.Sons.1993. IEEE. IEEE. Standard. Glossary. of. Software. Engineering. Terminology. 1990. http:ieeexplore.ieee.orgxpl freeabs_all.jsp?arnumber159342. Lewis.C.P.Polson.C.Wharton.and.J.Rieman.Testing.a.Walkthrough.Methodology.for.Theory-Based.Design. of.Walk-Up-and-Use.Interfaces.Chi 90 Proceedings, 1990.235242. McCrickard.D.S.C.M.Chewar.and.J.Somervell.Design.Science.and.Engineering.Topics.Teaching.HCI. with.a.Unified.Method.Technical Symposium on Computer Science Education (SigCSE04).Norfolk.VA. 2004.3135. Nielsen.J.and.R.L.Mack.Usability Inspection Methods.New.York.John.Wiley.Sons.1994. Nielsen.J.and.R.Molich.Heuristic.Evaluation.of.User.Interfaces.Proc. ACM CHI90 Conference, Seattle. 1990.249256. Rosson. M. B. and. J. M. Carroll. Usability Engineering: Scenario-Based Development of HumanComputer Interaction. San.Franciso.Morgan.Kaufmann.2002. Scriven.M.The Methodology of Evaluation in Perspectives of Curriculum Evaluation.Chicago.IL.Rand.McNally. 1967. Somervell.J.and.D.S.McCrickard.Better.Discount.Evaluation.Illustrating.How.Critical.Parameters.Support.

--- Chunk 515 ---
Tokens: 397
Type: sentence-based
Text:
Somervell.J.and.D.S.McCrickard.Better.Discount.Evaluation.Illustrating.How.Critical.Parameters.Support. Heuristic.Creation.Interacting with Computers: Special Issue on Social Impact of Emerging Technologies 17.no.5.(September.2005).592612. Virzi.R.A.J.L.Sokolov.and.D.Karis.Usability.Problem.Identification.Using.both.Low-.and.High-Fidelity. Prototypes.Proceedings of ACM CHI 96, British.Columbia.Canada.1996.236243. 311 10 Software Design Management, Leadership, and Ethics Luis Daniel Otero Florida Institute of Technology CHAPTER OBJECTIVES . Understand.the.definition.and.importance.of.software.design.man- agement . Describe.various.techniques.to.manage.the.software.design.phase . Describe.leadership.in.the.context.of.design.management . Describe.relevant.ethics.items.from.the.software.engineering.code.of. ethics CONCEPTUAL OVERVIEW Software.design.is.an.essential.phase.of.the.software.engineering.life.cycle. Conceptually.design.is.the.process.of.transforming.functional.and.non- functional.requirements.into.models.that.describe.a.technical.solution.This. transformation.process.can.be.viewed.as.a.complex.decision.problem.that. must.be.managed.to.ensure.an.effective.use.of.resources.to.deliver.quality. products.that.meet.requirements.It.is.regarded.as.a.decision.problem.since. there.are.many.ways.to.design.a.software.system.and.software.engineers. must.make.design.decisions.to.achieve.the.required.goals.of.the.software. system.in.the.most.effective.manner.Obviously.quality.must.be.considered. at.every.step.of.the.design.phase.The.idea.is.that.proper.design.efforts.are.

--- Chunk 516 ---
Tokens: 382
Type: sentence-based
Text:
at.every.step.of.the.design.phase.The.idea.is.that.proper.design.efforts.are. expected.to.minimize.the.complexity.of.subsequent.phases.in.the.life.cycle.as. well.as.the.impact.of.requirements.changes.on.the.overall.cost.and.schedule. The.objective.of.this.chapter.is.to.describe.three.major.elements.that.are. critical.for.the.success.of.any.major.design.project.management.leadership. and.ethics.It.is.not.intended.to.be.a.complete.tutorial.on.any.of.these.three. 312  Software Engineering Design elements.Instead.the.chapter.develops.a.design.management.framework.that.describes. important.concepts.related.to.each.element.with.the.hope.of.facilitating.the.successful.man- agement.of.this.complex.phase.For.this.purpose.the.chapter.begins.by.describing.the.soft- ware.design.phase.as.a.complex.task.that.must.be.managed.to.achieve.acceptable.quality. levels.Various.project.management.techniques.to.monitor.and.control.the.resources.that.are. responsible.for.the.completion.of.design.tasks.are.presented.The.chapter.then.describes.the. relationship.between.management.and.leadership.and.highlights.several.leadership.traits. that.are.important.for.successful.results.Finally.the.chapter.presents.various.ethic.items. from.the.Software.Engineering.Code.of.Ethics.that.are.relevant.to.software.design projects. WHAT IS SOFTWARE DESIGN MANAGEMENT? Griffin. (2010.p.5).defines.management.as.a.set.of.activitiesincluding.planning.and.deci- sion.making.organizing.leading.and.controllingdirected.at.an.organizations.resources. (i.e.

--- Chunk 517 ---
Tokens: 394
Type: sentence-based
Text:
(i.e. human.financial.physical.and.information).with.the.aim.of.achieving.organizational. goals.in.an.efficient.and.effective.manner.Management.plays.a.big.role.in.software.engi- neering.projects.In.the.design.phase.management.refers.to.a.set.of.activities.required.to. efficiently.create.quality.design.artifacts.within.schedule.and.budget.constraints.This.def- inition.encompasses.a.broad.set.of.activities.that.are.particular.to.specific.organizations. However.at.the.core.of.every.organizations.management.activities.quality.is.a.focal.point. WHY STUDY DESIGN MANAGEMENT? In.large-scale.software.projects.software.design.management.is.essential.to.plan.organize. staff.track.and.lead.the.activities.required.to.carry.out.successfully.the.software.architecture. and.detailed.design.steps.Key.to.the.success.of.software.design.management.is.an.effective. use.of.resources.to.achieve.the.various.goals.set.forth.for.each.main.component.in.the.design. phase.(i.e.software.architecture.detailed.design.and.documentation).Therefore.software. design.management.is.needed.to.controlmonitor.the.processes.and.resources.necessary.for. completing.quality.design.artifacts.according.to.organizational.goals. THE CONCEPT OF QUALITY Quality.is.a.term.that.can.be.loosely.defined.as.a.performance.measure.for.a.service.pro- vided.or.a.product.produced.and.it.is.relative.to.a.particular.stakeholder.For.example. a.personal.website.can.be.classified.as.high.quality.by.the.programmer.that.developed.it. and.as.low.quality.by.user.clients.That.is.two.stakeholders.of.the.software.system.have.

--- Chunk 518 ---
Tokens: 395
Type: sentence-based
Text:
and.as.low.quality.by.user.clients.That.is.two.stakeholders.of.the.software.system.have. Software Design Management, Leadership, and Ethics  313 different.opinions.regarding.the.quality.of.the.product.produced.Why.Because.both.of. these.stakeholders.have.different.parameters.by.which.they.measure.quality.For.example. the.programmer.may.perceive.quality.in.terms.of.being.able.to.use.appropriate.colors.and. organize.the.website.to.run.on.a.particular.web.browser.On.the.other.hand.a.client.using. a.different.web.browser.may.not.see.the.websites.organization.and.colors.as.intended.thus. perceiving.the.websites.quality.as.poor.Similarly.the.quality.of.a.software.design.can. be.assessed.in.various.ways.However.from.a.management.perspective.quality.of.soft- ware.design.tends.to.be.evaluated.in.terms.of.cost.and.scheduling.Therefore.this.chapter. focuses.on.various.project.management.techniques.that.can.be.used.to.keep.the.design. artifacts.within.cost.and.schedule.thresholds. DESIGN MANAGEMENT FRAMEWORK To.efficiently.and.effectively.manage.the.software.design.activities.of.a.project.it.is.beneficial. to.view.the.design.phase.as.a.project.itself.The.managerial.benefit.of.this.approach.is.that. project.management.techniques.can.be.directly.applied.to.the.design.phase.For.example.the. life.cycle.of.the.design.phase.can.be.represented.with.three.stages.similar.to.Figure 10.1.This. life.cycle.represents.a.typical.project.pattern.where.contributions.to.a.projects.completion. are.relatively.small.during.the.initial.and.termination.phases.and.significantly.high.during.

--- Chunk 519 ---
Tokens: 400
Type: sentence-based
Text:
are.relatively.small.during.the.initial.and.termination.phases.and.significantly.high.during. the.implementation.phase.Defining.a.life.cycle.structure.for.a.project.helps.to.decompose. the.project.into.its.appropriate.stages.where.each.stage.can.be.managed.individually. There.are.two.main.objectives.associated.with.the.initial.stage.The.first.objective.is.to. achieve.a.clear.understanding.of.the.tasks.to.be.accomplished.and.the.resources.that.are.nec- essary.to.successfully.complete.the.tasks.The.second.main.objective.is.to.develop.a.plan.to. complete.the.projects.tasks.within.schedule.and.budget.constraints.Thus.the.initial.phase.is. 100 Initial Implementation Termination Time Project Completion () 0 FIGURE 10.1 Project.life.cycle. 314  Software Engineering Design characterized.by.planning.activities.Although.some.of.the.artifacts.resulting.from.this.phase. (e.g.schedule).may.be.deliverables.to.clients.this.phase.is.not.viewed.as.contributing.signifi- cantly.to.the.percentage.project.completion.The.implementation.stage.on.the.other.hand. is.where.most.of.the.effort.is.employed.and.where.most.of.the.design.project.deliverables. are.achieved.including.completed.design.documents.Therefore.the.percent.project.comple- tion.is.the.highest.during.this.stage.In.the.termination.stage.key.activities.involve.verifica- tion.that.everything.is.in.place.for.a.smooth.transition.into.the.code.construction.phase. Activities.include.for.example.making.sure.that.the.latest.versions.of.the.design.documents. are.securely.stored.according.to.configuration.management.procedures.updating.schedule.

--- Chunk 520 ---
Tokens: 365
Type: sentence-based
Text:
are.securely.stored.according.to.configuration.management.procedures.updating.schedule. and.cost.current.values.reevaluating.schedule.and.budget.plans.based.on.the.resulting.per- formance.measures.of.the.design.phase.and.communicating.results.to.upper.management. The.design.documents.generated.in.this.stage.are.critical.for.the.robustness.and.maintain- ability.of.the.software.designed.However.the.relative.impact.of.this.stage.to.project.comple- tion.is.not.viewed.as.significant.as.that.of.the.implementation.phase.The.key.is.that.each of these phases must be individually managed to ensure that all phases meet acceptable levels of quality and performance measures.For.example.an.important.outcome.of.the.planning.stage. is.a.clear.understanding.of.the.tasks.to.be.accomplished.and.the.resources.that.are.neces- sary.to.successfully.complete.the.tasks.Various.project.management.techniques.exist.to.help. achieve.this.outcome.Therefore.it.is.important.to.know.how.to.apply.these.project.manage- ment.techniques.to.your.particular.design.project.and.go.through.a.peer-review.process.to. ensure.that.the.objectives.of.the.planning.stage.are.achieved.Performance.measures.in.the. planning.stage.are.thoroughness.(everything.is.considered).completeness. (complete.defini- tion.of.plans).and.accuracy.of.estimates.In.the.executionimplementation.stage.quality.is.a. function.of.a.series.of.technical.attributes.of.software.designs.Managing.during.this.stage.is.

--- Chunk 521 ---
Tokens: 383
Type: sentence-based
Text:
function.of.a.series.of.technical.attributes.of.software.designs.Managing.during.this.stage.is. mainly.a.monitoring.approach.to.make.sure.that.the.plan.is.being.followed.and.to.take.cor- rective.actions.if.necessary.Important.factors.that.affect.the.effectiveness.of.managing.these. phases.are.leadership.and.good.ethical.conduct.Therefore.a.design.management.framework. composed.of.the.following.four.main.areas.is.proposed: . Planning . Executionimplementation . Termination . Leadership.and.ethics PLANNING DESIGN EFFORTS The.planning.stage.is.critical.to.the.success.of.any.major.project.In.a.holistic.view.plan- ning.exists.to.lay.out.a.strong.foundation.for.a.successful.project.by.clearly.specifying.the. . Peer.reviews.must.be.conducted.throughout.these.stages.to.minimize.the.propagation.of.errors.to.subsequent.stages.and. apply.corrective.actions. Software Design Management, Leadership, and Ethics  315 tasks.that.must.be.completed.resources.in.terms.of.personnel.skills.required.to.complete. each.task.and.any.hardware.and.software.required.the.durations.of.tasks.and.the.specific. points.within.the.projects.life.cycle.phases.where.resources.will.be.needed.Basically.plan- ning.establishes.the.directions.to.follow.to.complete.the.project.and.improve.its.probability. of.success.It.is.intended.to.facilitate.future.project.accomplishments.The.key.functions.in. the.project.planning.stage.are.scoping.and.organizing. Scoping Project.scoping.is.the.first.key.function.of.the.planning.stage.It.involves.two.main.activities.

--- Chunk 522 ---
Tokens: 395
Type: sentence-based
Text:
Scoping Project.scoping.is.the.first.key.function.of.the.planning.stage.It.involves.two.main.activities. identify.the.tasks.and.develop.the.budget.The.idea.is.to.follow.the.divide.and.conquer.para- digm.to.utilize.a.mechanism.for.identifying.lower-level.assignable.activities.that.need.to.be. completed.Then.expected.costs.for.each.activity.are.estimated.to.develop.the.budget.Two. commonly.used.techniques.for.project.scoping.are.the.work.breakdown.function (WBS). and.budgeting. Work Breakdown Structure In.the.project.management.point.of.view.a.project.begins.as.a.statement.of.work.(SOW). which.mainly.consists.as.the.set.of.main.objectives.to.be.achieved.The.SOW.is.decomposed. into.tasks.where.these.tasks.are.decomposed.into.subtasks.and.subtasks.into.work packages. A.management.technique.to.represent.either.graphically.or.in.list.format.a.project.modu- larized.into.task.activities.is.called.WBS.Also.known.as.hierarchical planning.the.WBS.is. a.simple.but.powerful.technique.that.helps.to.plan.clearly.define.and.organize.the.activi- ties.related.to.reach.specific.milestones.and.complete.a.project.Milestones.are.defined. as.specific.events.to.be.reached.at.specific.points.in.time.For.example.obtaining.budget. and.schedule.approvals.for.a.project.are.typically.considered.important.project.milestones. Given.that.the.major.artifacts.in.the.design.phase.are.the.main.components.of.the.design. process.these.are.considered.the.main.milestones.That.is.the.completion.of.the.architec- ture.design.detailed.design.and.documentation.constitute.the.main.project.milestones.of.

--- Chunk 523 ---
Tokens: 392
Type: sentence-based
Text:
process.these.are.considered.the.main.milestones.That.is.the.completion.of.the.architec- ture.design.detailed.design.and.documentation.constitute.the.main.project.milestones.of. a.design.project.Therefore.the.objective.of.a.WBS.in.the.design.phase.is.to.establish.the. work.elements.for.each.of.these.major.milestones. Table 10.1.shows.an.example.of.a.WBS.for.the.design.of.a.software.application.This. figure.shows.the.managerial.levels.for.each.component.The.top.level.is.the.design.project. itself.This.level.represents.the.overall.objective.to.be.achieved.which.is.to.successfully. complete.the.design.phase.Then.this.top.level.is.decomposed.into.the.three.main.mile- stones. of. the. design. phase. which. are. the. development. of. architectural. and. detailed. designs.and.the.completion.of.the.design.document.These.tasks.are.direct.sublevels.of.the. design.project.therefore.they.are.labeled.1.1.1.2.and.1.3.Each.task.is.then.decomposed. into.appropriate.subtasks.For.the.architectural.design.task.two.subtasks.were.identified. evaluation.of.alternative.designs.and.selection.of.the.final.architectural.design.Since.these. are.sublevels.of.the.architectural.design.task.they.are.labeled.1.1.1.and.1.1.2.Each.of.these. subtasks.is.decomposed.into.appropriate.work.packages.For.example.the.evaluation.of. 316  Software Engineering Design alternative.architecture.designs.was.decomposed.into.prioritizing.objectives.and.conduct- ing.formal.evaluation.peer.reviews.Consequently.these.two.work.packages.were.labeled.as. the.four-level.activities.1.1.1.1.and.1.1.1.2.

--- Chunk 524 ---
Tokens: 374
Type: sentence-based
Text:
the.four-level.activities.1.1.1.1.and.1.1.1.2. Evaluating.the.usefulness.of.a.WBS.is.often.more.a.matter.of.subjective.assessments. than. not. We. can. define. three. criteria. for. this. evaluation. The. first. criterion. is. called. scope accuracy .That.is.we.need.to.agree.that.the.WBS.serves.its.overall.objective.of.being. a.breakdown.of.the.project.into.tasks.and.nothing.else.A.WBS.does.not.contain.informa- tion.regarding.tasks.relationships.such.as.task.precedence.or.task.durations.and.it.does. not.include.personnel.skills.required.for.the.completion.of.tasks.Instead.each.element.of. a.WBS.represents.an.activity.that.consumes.resources.time.and.effort.This.brings.us.to. the.second.criteria.completeness.The.purpose.of.this.evaluation.criterion.is.to.ensure.that. the.WBS.includes.the.complete.set.of.tasks.necessary.to.complete.the.project.The.third. criterion.is.level of detail.This.criterion.evaluates.if.the.WBS.breaks.down.the.projects. tasks.into.appropriate.levels.such.that.it.facilitates.the.estimation.of.effort.for.each.task. Budgeting Budgeting.is.the.process.of.estimating.the.cost.of.a.project.It.is.basically.a.forecasting. problem.since.cost.is.a.function.of.various.parameters.that.are.uncertain.such.as.the. number.of.resources.required.throughout.the.project.their.cost.hardware.and.software. equipment.inflation.changes.and.requirement.changes.The.accuracy.of.a.budget.is.a. function.of.the.uncertainty.of.these.individual.cost.parameters.For.example.a.budget.for.

--- Chunk 525 ---
Tokens: 386
Type: sentence-based
Text:
function.of.the.uncertainty.of.these.individual.cost.parameters.For.example.a.budget.for. TABLE 10.1 Example.of.a.WBS.for.a.Design.Project Outline Number Task Name 1 Design.project 1.1 Architectural.design 1.1.1 Evaluate.alternative.designs 1.1.1.1 Prioritize.objectives 1.1.1.2 Formal.review.of.evaluations 1.1.2 Select.architectural.design 1.1.2.1 Make.initial.selection 1.1.2.2 Formal.review.to.select.final.design 1.2 Detailed.design 1.2.1 Evaluate.alternatives 1.2.2 Select.among.alternatives 1.3 Documentation 1.3.1 Write.architectural.design.documentation 1.3.2 Formal.review. (architecture.design) 1.3.3 Final.architectural.design.document 1.3.4 Write.detailed.design.documentation 1.3.5 Formal.review. (detailed.design) 1.3.6 Final.architectural.design.document Software Design Management, Leadership, and Ethics  317 the.construction.of.a.house.is.expected.to.be.more.accurate.than.the.budget.for.develop- ing.a.complex.software.application.For.the.project.of.constructing.a.house.planners.often. have.a.very.good.idea.of.the.resources.that.are.needed.cost.of.permits.and.so.forth.For. the.software.project.it.becomes.a.more.challenging.task.due.to.the.level.of.uncertainty.in. key.elements.such.as.the.number.of.software.lines.of.code.that.it.would.take.to.develop.the. application.the.number.of.software.engineers.required.and.unknown.learning.curves.for. newer.technology.to.name.a.few.Compared.with.the.house.construction.project.the.typi- cal.error.size.for.the.estimation.of.cost.parameters.in.software.projects.is.much.higher.Due.

--- Chunk 526 ---
Tokens: 310
Type: sentence-based
Text:
newer.technology.to.name.a.few.Compared.with.the.house.construction.project.the.typi- cal.error.size.for.the.estimation.of.cost.parameters.in.software.projects.is.much.higher.Due. to.these.uncertainties.monitoring.and.controlling.activities.must.be.enforced.throughout. the.course.of.the.project.to.determine.any.deviations.from.the.plan.(i.e.budget).and.study. the.causes.of.these.deviations.(monitoring.and.control.mechanisms.will.be.discussed.later. in.the.chapter).As.such.the.budget.serves.as.a.baseline.to.compare.differences.between. actual.and.estimated.costs.at.any.point.in.the.life.of.a.project. Conceptually.a.common.strategy.to.develop.a.budget.is.to.simply.cost.each.element.in. the.WBS.To.accomplish.this.elements.are.associated.with.direct.and.indirect costs.Direct. costs.are.those.that.can.be.directly.tied.to.the.development.of.the.design.The.most.often. used.direct.costs.are.labor.and.equipment.(i.e.hardware.and.software.equipment).Indirect. costs.on.the.other.hand.include.costs.such.as.fringe.benefits.and.administrative.expenses. One.of.the.most.significant.and.hard-to-estimate.direct.costs.for.each.task.is.the.cost.of. the.staff.that.will.be.directly.working.on.the.completion.of.the.task.The.level.of.difficulty.

--- Chunk 527 ---
Tokens: 393
Type: sentence-based
Text:
the.staff.that.will.be.directly.working.on.the.completion.of.the.task.The.level.of.difficulty. in.developing.accurate.cost.estimates.related.to.task.durations.is.a.function.of.the.complex- ity.of.the.design.project.itself.Given.that.software.projects.are.typically.custom-made.solu- tions.to.particular.problems.tasks.are.considered.nonrepetitive.and.often.involve.learning rates.This.is.particularly.true.for.tasks.that.involve.new.technologies.or.the.use.of.skills. that.the.staff.is.unfamiliar.with.Therefore.it.is.important.to.account.for.learning.rates.in. the.budgeting.process. It.is.important.to.understand.that.developing.accurate.budgets.for.design.projects.is.often. very.difficult.due.to.the.complexity.of.the.projects.Data.from.previous.similar.projects.as. well.as.input.from.experienced.personnel.are.used.as.resources.to.prepare.budgets.After.the. .budget.for.a.project.is.created.and.approved.it.becomes.more.of.a.control.mechanism.for.man- agers.because.it.establishes.the.cost.threshold.for.the.entire.project. Organizing Organizing.is.the.second.key.function.of.the.planning.stage.It.involves.two.main.activi- ties.responsibility.assignments.and.scheduling.That.is.after.identifying.and.organizing. the.tasks.in.the.scoping.function.with.the.WBS.the.organizing.function.conducts.task. assignments.establishes.task.durations.and.identifies.any.predecessors.for.each.task.Task. durations.are.critical.because.they.are.an.integral.part.of.the.monitoring.and.controlling. mechanisms.in.the.implementation.stage.The.next.subsections.describe.various.project.

--- Chunk 528 ---
Tokens: 369
Type: sentence-based
Text:
mechanisms.in.the.implementation.stage.The.next.subsections.describe.various.project. management.tools.that.are.applicable.for.the.organizing.function. . A.predecessor.is.a.task.that.must.be.completed.before.another.task.can.begin. 318  Software Engineering Design Linear Responsibility Chart An.important.outcome.of.the.planning.stage.is.to.have.a.clear.understanding.of.the.roles. that.each.staff.member.plays.in.the.process.of.completing.each.element.of.the.WBS.This.can. be.viewed.as.a.plan.for.task.assignments.The.goal.here.is.to.clearly.identify.the.staff.mem- bers.that.will.be.mainly.responsible.for.each.task.and.those.that.will.serve.as.reviewers.or. support.the.task.in.any.way.A.project.management.tool.that.allows.such.outcome.is.called. a.linear responsibility chart (LRC).which.is.a.tabular.representation.of.task.assignments. Table 10.2.shows.an.example.of.an.LRC.for.a.particular.design.project.This.table.clearly. shows.the.staff.members.that.are.mainly.responsible.for.each.of.the.tasks.and.those.that. will.be.supporting.the.tasks.in.any.way.or.acting.as.reviewers.Other.than.clearly.establish- ing.the.responsibilities.of.each.team.member.having.a.clear.understanding.of.task.assign- ments.is.important.for.scheduling.purposes.For.example.finding.skilled.personnel.to.act. as.reviewers.for.a.particular.artifact.(e.g.detailed.design).later.in.the.projects.life.cycle. can.become.a.challenging.task.because.employees.get.regularly.reassigned.to.new.tasks.

--- Chunk 529 ---
Tokens: 372
Type: sentence-based
Text:
can.become.a.challenging.task.because.employees.get.regularly.reassigned.to.new.tasks. Therefore.it.is.beneficial.to.establish.their.roles.with.the.design.project.early.in.the.plan- ning.stage.to.minimize.the.probability.of.not.having.adequate.reviewers.and.the.chance.of. overrunning.the.schedule.or.compromising.quality.standards. Scheduling with Gantt Charts and Network Diagrams After.task.assignments.a.key.activity.in.the.planning.stage.is.scheduling.A.basic.function.of. the.scheduling.process.is.to.determine.task.relationships.in.order.to.convert.the.WBS.into.an. operating.timetable.Scheduling.helps.to.identify.the.critical.project.activities.that.cannot.be. delayed.without.delaying.the.overall.project.duration.as.well.as.those.that.will.not.affect.the. overall.project.duration.if.delayed.Furthermore.scheduling.allows.tasks.to.be.ordered.so. that.for.each.task.preceding.and.subsequent.tasks.are.easily.identified. Various.project.management.techniques.are.used.in.scheduling.Two.of.the.most.common. ones.are.Gantt.charts.and.network.diagrams.They.are.basically.graphical.representations.of. the.logical.flow.between.tasks.(i.e.activities).and.their.durations.The.Gantt.chart.technique.is. very.simple.to.follow.Because.of.its.simplicity.this.approach.is.often.used.to.show.schedule.and. progress.as.well.as.to.serve.as.a.control.and.monitoring.mechanism.The.three.basic.param- eters.needed.for.a.Gantt.chart.are.tasks.their.durations.and.their.predecessors.and.successors.

--- Chunk 530 ---
Tokens: 380
Type: sentence-based
Text:
progress.as.well.as.to.serve.as.a.control.and.monitoring.mechanism.The.three.basic.param- eters.needed.for.a.Gantt.chart.are.tasks.their.durations.and.their.predecessors.and.successors. These.parameters.are.used.to.develop.a.graph.that.depicts.the.durations.of.tasks.and.their.rela- tionship.For.example.consider.a.snapshot.of.a.Gantt chart.presented.in.Figure 10.2.from.the. Microsoft.Project.software.package.The.left-hand.side.of.this.figure.shows.the.list.of.tasks.from. a.WBS.with.expected.duration.start.date.and.finish.date.It.also.shows.any.predecessor.for. each.task.For.example.the.predecessor.to.evaluate.detailed.design.alternatives. (WBS 1.2.1). is.to.have.selected.a.final.architectural.design.(WBS.1.1.2.2).On.the.right-hand.side.we.can. see.the.actual.Gantt.chart.showing.predecessors.of.tasks.and.their.durations.We.can.see.for. example.that.the.documentation.for.the.architectural.design.can.be.started.as.soon.as.the. architectural.design.passes.a.formal.review.and.the.detailed.design.is.ready.to.begin. Software Design Management, Leadership, and Ethics  319 Similar.to.Gantt.charts.network.diagrams.are.also.graphical.representations.of.logi- cal.flow.among.tasks.describe.task.durations.and.need.the.same.three.basic.parameters. tasks.their.durations.and.their.predecessors.and.successors.Moreover.network.diagrams. are.used.to.show.additional.important.information.such.as.critical paths, earliest and latest completion times, and.slack times.We.will.use.information.from.the.WBS.from.Table 10.1.to.

--- Chunk 531 ---
Tokens: 393
Type: sentence-based
Text:
are.used.to.show.additional.important.information.such.as.critical paths, earliest and latest completion times, and.slack times.We.will.use.information.from.the.WBS.from.Table 10.1.to. explain.the.activity-on-node.(AON).network.diagram.technique.First.we.need.estimates. for.task.durations.Estimating.accurate.task.durations.is.often.a.very.complex.endeavor. One.common.approach.is.to.estimate.minimum.maximum.and.most.likely.duration. TABLE 10.2 Example.of.a.Linear.Responsibility.Chart Outline  Task Name Staff_1 Staff_2 Staff_3 Staff_4 Staff_5 1 Design.project 1.1 Architectural.design 1 2 3 1.1.1 Evaluate.alternative.designs 1 2 1.1.1.1 Prioritize.objectives 1 2 1.1.1.2 Formal.review.of.evaluations 1 3 3 1.1.2 Select.architectural.design 1 1.1.2.1 Make.initial.selection 1 1.1.2.2 Formal.review.to.select.final.design 1 2 3 3 1.2 Detailed.design 1 3 1.2.1 Evaluate.alternatives 2 1 11.2.2 Select.among.alternatives 2 1 3 1.3 Documentation 1.3.1 Write.architectural.design.documentation 1 2 1.3.2 Formal.review. (architecture.design) 1 3 3 1.3.3 Final.architectural.design.document 1 3 1.3.4 Write.detailed.design.documentation 2 1 3 1.3.5 Formal.review. (detailed.design) 2 1 3 1.3.6 Final.detailed.design.document 3 1 3 Legend: 1.Primary.responsibility 2.Support.development.role 3.Review.role FIGURE 10.2 Snapshot.of.Gantt.chart.from.Microsoft.project. 320  Software Engineering Design times.Table 10.3.gives.an.example.of.task.durations.for.the.three-level.tasks.described.in. the.WBS.For.each.task.this.table.shows.an.estimated.minimum.duration.a.a.most.likely.

--- Chunk 532 ---
Tokens: 380
Type: sentence-based
Text:
the.WBS.For.each.task.this.table.shows.an.estimated.minimum.duration.a.a.most.likely. duration.m.and.a.maximum.duration.b.These.three.parameters.are.used.to.calculate. the.expected.time.ET.of.each.task.ET.durations.are.calculated.using.the.beta.distribu- tion.with.Equation.(10.1).because.of.its.simplicity.and.flexibility.A.key.benefit.for.having. three.estimates.for.task.durations.is.that.we.can.use.them.to.develop.variance.calculations. which.can.then.be.used.to.estimate.the.probability.of.completing.the.project.within.a.spe- cific.time.The.variance.of.the.duration.of.a.task.is.calculated.using.Equation.(10.2). . Expected Time    a 4m b 6 . (10.1) . Variance  b a 6 2 . (10.2) Figure 10.3a.shows.the.resulting.network.diagram.from.the.information.described.in. Table 10.3.Notice.the.inclusion.of.start.and.end.nodes.These.two.extra.nodes.are.included. to.make.the.network.easier.to.follow.The.network.diagram.clearly.shows.the.predecessors. for.each. After.estimating.task.durations.and.variances.the.next.step.is.to.calculate.the.critical. path.A.path.is.any.combination.of.nodes.from.the.start.node.to.the.last.node.For.example. our.network.diagram.shows.the.following.two.paths: . Path.1.(1.1.1).(1.1.2).(1.2.1).(1.2.2).(1.3.4).(1.3.5). (1.3.6) . Path.2.(1.1.1).(1.1.2).(1.3.1).(1.3.2).(1.3.3).(1.3.4).(1.3.5). (1.3.6) Using. the. expected. times. from. Table 10.3. the. expected. duration. of. the. first. path. is. 55 days.The.expected.duration.of.the.second.path.is.46.days.The.critical.path.is.the.one.with.

--- Chunk 533 ---
Tokens: 387
Type: sentence-based
Text:
55 days.The.expected.duration.of.the.second.path.is.46.days.The.critical.path.is.the.one.with. .For.a.refresher.on.elementary.statistics.please.refer.to.books.such.as.Pelosi.and.Sandifer.(2003). TABLE 10.3 Task.Durations.for.the.Three-Level.Tasks.Described.in.the.WBS Outline  Time (Days) Minimum (a) Most Likely (m) Maximum (b) Immediate Predecessors Expected Time (ET) Variance (2) 1.1.1 3 5 13  6 2.78 1.1.2 1 2 9 1.1.1 3 1.78 1.2.1 8 15 22 1.1.2 15 5.44 1.2.2 5 10 21 1.2.1 11 7.11 1.3.1 5 10 21 1.1.2 11 7.11 1.3.2 1 2 9 1.3.1 3 1.78 1.3.3 3 5 13 1.3.2 6 2.78 1.3.4 5 10 21 1.2.2.1.3.3 11 7.11 1.3.5 1 2 9 1.3.4 3 1.78 1.3.6 3 5 13 1.3.5 6 2.78 Software Design Management, Leadership, and Ethics  321 the.longest.duration.hence.the.critical.path.for.this.problem.is.Path.1.The.critical.path.is. shown.in.Figure 10.3b.with.heavy.lines.Identifying.the.critical.path.of.a.project.is.important. because.it.pinpoints.the.activities.that.cannot.be.delayed.without.delaying.the.entire.project. That.is.if.any.of.the.activities.along.the.critical.path.get.delayed.the.entire.project.will.be. delayed.Identifying.the.critical.path.also.marks.the.activities.that.can.be.delayed.without. affecting.the.project.duration.These.activities.are.the.ones.outside.of.the.critical.path. After.calculating.the.critical.path.the.next.step.is.to.calculate.earliest.and.latest.times. for.activities.to.start.and.finish.That.is.we.need.to.calculate.the.earliest.time.that.we.can. begin.each.activity.and.the.earliest.time.that.the.activity.can.be.completed.We.denote.

--- Chunk 534 ---
Tokens: 376
Type: sentence-based
Text:
begin.each.activity.and.the.earliest.time.that.the.activity.can.be.completed.We.denote. these.terms.as.earliest start (ES).and.earliest finish (EF) times.Similarly.we.calculate.the. latest.time.that.we.can.begin.each.activity.and.the.latest.time.that.the.activity.can.be.com- pleted.We.denote.these.terms.as.latest start (LS).and.latest finish (LF) times.The.difference. between.the.LS.and.ES.of.an.activity.is.called.the.slack.time.for.the.activity.Because.activi- ties.along.the.critical.path.cannot.be.delayed.without.delaying.the.entire.projects.duration. only.noncritical.path.activities.can.have.slack.times. To.calculate.earliest.times.we.move.from.the.start.node.to.the.other.nodes.Logically. the.first.activity.(i.e.node.1.1.1).begins.at.time.0.Therefore.the.ES.for.activity.1.1.1.is.0. and.its.EF.time.is.its.expected.time.duration.(6.days).Any.immediate.subsequent.activity. can.start.as.early.as.activity.1.1.1.ends.Therefore.the.ES.of.activity.1.1.2.is.6.days.and.its. EF.is.9.days.which.is.the.sum.of.its.ES.and.expected.time.duration.Similarly.the.ES.of. activity.1.3.1.is.9.days.and.its.EF.is.20.days.In.cases.where.an.activity.has.more.than.one. predecessor.the.largest.EF.time.of.the.predecessors.becomes.the.ES.time.of.the.activity. For.example.activity.1.3.4.has.two.predecessors.1.2.2.(with.an.EF.time.of.35.days).and. 1.3.3.(with.an.EF.time.of.29.days).Since.activity.1.3.4.can.be.started.only.when.both.of.its. .predecessors.are.complete.its.earliest.possible.start.time.is.35.days.

--- Chunk 535 ---
Tokens: 388
Type: sentence-based
Text:
.predecessors.are.complete.its.earliest.possible.start.time.is.35.days. Start 1.1.1 1.1.2 1.2.1 1.3.1 1.2.2 1.3.2 1.3.3 1.3.4 1.3.5 1.3.6 End Start 1.1.1 1.1.2 1.2.1 1.3.1 1.2.2 1.3.2 1.3.3 1.3.4 1.3.5 1.3.6 End ES EF LS LF 0 6 0 6 6 9 6 9 0 0 0 0 9 24 9 24 24 35 24 35 9 20 15 26 20 23 23 29 23 29 29 35 35 46 35 46 46 49 46 49 49 55 49 55 55 55 55 55 (a) (b) FIGURE 10.3 AON.network.diagram. 322  Software Engineering Design To.calculate.latest.times.we.move.from.the.last.node.to.the.start.node.The.LF.time.for. activities.in.the.critical.path.is.the.same.as.their.EF.times.Similarly.the.LS.time.for.critical. activities.is.the.same.as.their.ES.For.noncritical.activities.such.as.1.3.3.this.is.not.the.case. If.this.activity.finishes.at.its.EF.time.of.29.days.activity.1.3.4.(i.e.its.successor).will.still. be.unable.to.start.because.it.needs.to.wait.for.activity.1.2.2.to.finish.at.day.35.Therefore. activity.1.3.3.can.actually.finish.as.late.as.day.35.and.not.affect.the.critical.path.duration. of.the.project.Consequently.the.LF.time.for.activity.1.3.3.is.35.days.and.its.LS.time.is. 29 days.which.is.its.LF.minus.its.expected.time.duration.of.6.days.Activity.1.3.2.can.finish. as.late.as.the.LF.time.of.its.successor.1.3.3.Therefore.its.LF.time.is.29.days.and.its.LS.time. is.26.days.When.the.earliest.and.latest.times.for.each.activity.are.completed.it.can.be. easily.seen.that.only.the.noncritical.activities.(i.e.1.3.1.1.3.2.and.1.3.3).have.slack.times. The.total.allowable.slack.time.for.these.activities.is.6.days.This.means.that.for.example.

--- Chunk 536 ---
Tokens: 362
Type: sentence-based
Text:
The.total.allowable.slack.time.for.these.activities.is.6.days.This.means.that.for.example. if a.slack.time.of.5.days.is.used.in.activity.1.3.1.then.only.one.of.the.remaining.noncritical. activities.can.be.delayed.by.1.day.If.for.example.a.slack.time.of.6.days.is.used.in.activity. 1.3.1.then.the.network.will.have.two.critical.paths.This.means.that.in.this.case.noncritical. activities.1.3.2.and.1.3.3.will.become.critical.activities.(i.e.no.slack.times). Probability of Time to Completion In.our.network.diagram.example.from.the.previous.section.expected.task.durations.were. calculated.based.on.estimates.of.minimum.average.and.maximum.durations.using.the. beta.distribution.The.other.obvious.option.is.to.overlook.these.three.parameters.and.esti- mate.a.single.average.task.duration.instead.This.option.tends.to.be.troublesome.for.decision. .makers.since.it.does.not.explicitly.consider.a.range.of.possibilities.(e.g.maxmin.values).and. accurate.estimates.of.task.durations.with.a.single.parameter.seem.unlikely.Consequently. setting.values.for.these.three.parametersinstead.of.one.estimatealleviates.the.estima- tion.process.for.decision.makers.Another.benefit.from.using.these.three.parameters.is.that. we.can.use.them.to.develop.variance.calculations.and.then.use.the.variances.to.estimate.the. probability.of.completing.the.project.within.a.specific.time. To.estimate.the.probability.of.completing.a.project.by.a.particular.time.period.we.use.

--- Chunk 537 ---
Tokens: 396
Type: sentence-based
Text:
To.estimate.the.probability.of.completing.a.project.by.a.particular.time.period.we.use. the.cumulative standard normal distribution.to.obtain.Z-values.The.standard.normal.dis- tribution.is.a.normal.distribution.with.a.mean.equal.to.zero.and.a.standard.deviation.equal. to.one.A.Z-value.represents.the.number.of.standard.deviations.from.the.mean.(either.to. the.right.or.to.the.left.of.the.mean).of.the.standard.normal.distribution. The.critical.path.contains.the.activities.that.establish.the.duration.of.a.project.We.basi- cally.use.the.expected.completion.times.of.the.critical.activities.and.their.variances.to. determine.the.probability.of.completing.the.critical.path.activities.by.a.deadline.Before. we.continue.it.is.worth.mentioning.that.there.is.an.assumption.that.must.be.made.when. using.the.standard.normal.distribution.to.make.our.probability.estimates.The.assump- tion.is.that.the.durations.of.each.activity.in.the.critical.path.are.statistically.independent. of.each.other.In.other.words.they.must.be.independent.random.variables.This.allows.us. .Again.for.a.refresher.on.elementary.statistics.please.refer.to.books.such.as.Pelosi.and.Sandifer.(2003). Software Design Management, Leadership, and Ethics  323 to.invoke.the.central limit theorem (CLT).to.find.the.mean.and.standard.deviation.of.the. project.duration.which.is.basically.the.sum.of.each.activity.in.the.critical.path.The.CLT. says.that.the.sum.of.independent.and.identically.distributed.(iid).random.variables.forms.a. normal.distribution.as.the.number.of.random.variables.increases.In.our.case.we.treat.the.

--- Chunk 538 ---
Tokens: 385
Type: sentence-based
Text:
normal.distribution.as.the.number.of.random.variables.increases.In.our.case.we.treat.the. project.duration.as.the.sum.of.the.critical.path.activities. (i.e.iid.random.variables).there- fore.by.virtue.of.the.CLT.we.can.assume.that.the.project.duration.is.normally.distributed. Armed.with.the.CLT.we.can.use.the.standard.normal.distribution.to.make.estimates.about. the.probability.of.completing.the.project.by.a.certain.time. First.we.need.to.transform. (sometimes.called.normalize).the.estimated.project.dura- tion.time.into.a.Z-value.using.Equation.10.3 . Z D EPT EPT   2 . (10.3) where Z. .the.number.of.standard.deviations.of.a.standard.normal.distribution D. .the.desired.completion.time. (usually.in.days).of.a.project EPT. .expected.project.completion.time. (this.is.the.critical.path.duration) EPT 2 .the.variance.of.the.critical.path Regarding. the. variance. parameter. (and. refreshing. some. statistics. concepts). if. the. .random.variables.in.a.set.are.independent.of.each.other.then.the.sum.of.the.variances. of.the.individual.random.variables.equals.the.variance.of.the.entire.set.Since.we.assume. that.the.critical.path.activities.are.independent.of.each.other.the.sum.of.their.variances. .corresponds.to.the.variance.of.the.expected.project.duration. After.calculating.the.Z-value.we.find.the.probability.of.completing.the.project.by.a.certain. time.using.a.cumulative.normal.distribution.table.similar.to.the.one.found.in.Table 10.4. In.this.table.we.can.find.the.probability.associated.with.a.Z-value.For.example.assume.

--- Chunk 539 ---
Tokens: 380
Type: sentence-based
Text:
In.this.table.we.can.find.the.probability.associated.with.a.Z-value.For.example.assume. that.a.design.project.has.an.expected.critical.path.duration.of.75.days.with.a.critical.path. variance.of.36.days.We.would.like.to.know.the.probability.of.completing.the.project.in. 85 days.Using.Equation. (10.3).we.calculate.a.Z-value.of.1.67.Then.we.go.to.Table 10.4.and. find.the.probability.to.be.0.9525.(go.down.the.left.column.until.1.6.then.across.to.the.right. until.column.0.07).This.means.that.there.is.a.95.25.percent.probability.of.finishing.the. design.project.in.85.days.given.the.variance.in.the.expected.project.duration.time. Skill Development 10.1: Negative Z-Value Assume.that.a.design.project.has.an.expected.critical.path.duration.of.75.days.with.a. critical.path.variance.of.36.days.We.would.like.to.know.the.probability.of.completing. the.project.in.65.days.As.you.will.see.the.resulting.Z-value.will.be.a.negative.number. How.do.you.get.its.associated.probability.from.Table 10.4.which.gives.you.only.positive. Z-values? Hint.Remember.that.the.standard.normal.distribution.has.a.symmetrical. shape.around.the.mean.and.that.its.area.under.the.entire.bell-shape.curve.equals.1. 324  Software Engineering Design Establish Change Control Policy Managing.the.design.of.software.systems.is.often.a.very.complex.endeavor.especially.when. changes.to.the.design.occur.after.the.design.has.successfully.gone.through.peer.reviews. Even.a.small.design.change.can.result.in.system.failures.if.not.managed.appropriately.To.

--- Chunk 540 ---
Tokens: 69
Type: sentence-based
Text:
Even.a.small.design.change.can.result.in.system.failures.if.not.managed.appropriately.To. avoid.major.problems.later.in.the.project.it.is.critical.that.a.formal.change.control.process. gets.adopted.early.in.the.planning.phase.A.change.control.process.also.serves.to.ensure.the.

--- Chunk 541 ---
Tokens: 756
Type: sentence-based
Text:
gets.adopted.early.in.the.planning.phase.A.change.control.process.also.serves.to.ensure.the. TABLE 10.4 Probabilities.of.the.Cumulative.Standard.Normal.Distribution Z 0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.0 0.5000 0.5040 0.5080 0.5120 0.5160 0.5199 0.5239 0.5279 0.5319 0.5359 0.1 0.5398 0.5438 0.5478 0.5517 0.5557 0.5596 0.5636 0.5675 0.5714 0.5754 0.2 0.5793 0.5832 0.5871 0.5910 0.5948 0.5987 0.6026 0.6064 0.6103 0.6141 0.3 0.6179 0.6217 0.6255 0.6293 0.6331 0.6368 0.6406 0.6443 0.6480 0.6517 0.4 0.6554 0.6591 0.6628 0.6664 0.6700 0.6736 0.6772 0.6808 0.6844 0.6879 0.5 0.6915 0.6950 0.6985 0.7019 0.7054 0.7088 0.7123 0.7157 0.7190 0.7224 0.6 0.7258 0.7291 0.7324 0.7357 0.7389 0.7422 0.7454 0.7486 0.7518 0.7549 0.7 0.7580 0.7612 0.7642 0.7673 0.7704 0.7734 0.7764 0.7794 0.7823 0.7852 0.8 0.7881 0.7910 0.7939 0.7967 0.7996 0.8023 0.8051 0.8079 0.8106 0.8133 0.9 0.8159 0.8186 0.8212 0.8238 0.8264 0.8289 0.8315 0.8340 0.8365 0.8389 1.0 0.8413 0.8438 0.8461 0.8485 0.8508 0.8531 0.8554 0.8577 0.8599 0.8621 1.1 0.8643 0.8665 0.8686 0.8708 0.8729 0.8749 0.8770 0.8790 0.8810 0.8830 1.2 0.8849 0.8869 0.8888 0.8907 0.8925 0.8944 0.8962 0.8980 0.8997 0.9015 1.3 0.9032 0.9049 0.9066 0.9082 0.9099 0.9115 0.9131 0.9147 0.9162 0.9177 1.4 0.9192 0.9207 0.9222 0.9236 0.9251 0.9265 0.9279 0.9292 0.9306 0.9319 1.5 0.9332 0.9345 0.9357 0.9370 0.9382 0.9394 0.9406 0.9418 0.9430 0.9441 1.6 0.9452 0.9463 0.9474 0.9485 0.9495 0.9505 0.9515 0.9525 0.9535 0.9545 1.7 0.9554 0.9564 0.9573 0.9582 0.9591 0.9599 0.9608 0.9616 0.9625 0.9633 1.8 0.9641 0.9649 0.9656 0.9664 0.9671 0.9678 0.9686 0.9693 0.9700 0.9706 1.9 0.9713 0.9719 0.9726 0.9732 0.9738 0.9744 0.9750 0.9756 0.9762 0.9767 2.0 0.9773 0.9778 0.9783 0.9788 0.9793 0.9798 0.9803 0.9808 0.9812 0.9817 2.1 0.9821 0.9826 0.9830 0.9834 0.9838 0.9842 0.9846 0.9850 0.9854 0.9857 2.2 0.9861 0.9865 0.9868 0.9871 0.9875 0.9878 0.9881 0.9884 0.9887 0.9890 2.3 0.9893 0.9896 0.9898 0.9901 0.9904 0.9906 0.9909 0.9911 0.9913 0.9916 2.4 0.9918 0.9920 0.9922 0.9925 0.9927 0.9929 0.9931 0.9932 0.9934 0.9936 2.5 0.9938 0.9940 0.9941 0.9943 0.9945 0.9946 0.9948 0.9949 0.9951 0.9952 2.6 0.9953 0.9955 0.9956 0.9957 0.9959 0.9960 0.9961 0.9962 0.9963 0.9964 2.7 0.9965 0.9966 0.9967 0.9968 0.9969 0.9970 0.9971 0.9972 0.9973 0.9974 2.8 0.9974 0.9975 0.9976 0.9977 0.9977 0.9978 0.9979 0.9980 0.9980 0.9981 2.9 0.9981 0.9982 0.9983 0.9983 0.9984 0.9984 0.9985 0.9985 0.9986 0.9986 3.0 0.9987 0.9987 0.9987 0.9988 0.9988 0.9989 0.9989 0.9989 0.9990 0.9990 3.1 0.9990 0.9991 0.9991 0.9991 0.9992 0.9992 0.9992 0.9992 0.9993 0.9993 3.2 0.9993 0.9993 0.9994 0.9994 0.9994 0.9994 0.9994 0.9995 0.9995 0.9995 3.3 0.9995 0.9995 0.9996 0.9996 0.9996 0.9996 0.9996 0.9996 0.9996 0.9997 3.4 0.9997 0.9997 0.9997 0.9997 0.9997 0.9997 0.9997 0.9997 0.9998 0.9998 3.5 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 Software Design Management, Leadership, and Ethics  325 technical.integrity.of.the.design.in.the.presence.of.changes.Figure 10.4.shows.an.example.

--- Chunk 542 ---
Tokens: 755
Type: sentence-based
Text:
TABLE 10.4 Probabilities.of.the.Cumulative.Standard.Normal.Distribution Z 0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.0 0.5000 0.5040 0.5080 0.5120 0.5160 0.5199 0.5239 0.5279 0.5319 0.5359 0.1 0.5398 0.5438 0.5478 0.5517 0.5557 0.5596 0.5636 0.5675 0.5714 0.5754 0.2 0.5793 0.5832 0.5871 0.5910 0.5948 0.5987 0.6026 0.6064 0.6103 0.6141 0.3 0.6179 0.6217 0.6255 0.6293 0.6331 0.6368 0.6406 0.6443 0.6480 0.6517 0.4 0.6554 0.6591 0.6628 0.6664 0.6700 0.6736 0.6772 0.6808 0.6844 0.6879 0.5 0.6915 0.6950 0.6985 0.7019 0.7054 0.7088 0.7123 0.7157 0.7190 0.7224 0.6 0.7258 0.7291 0.7324 0.7357 0.7389 0.7422 0.7454 0.7486 0.7518 0.7549 0.7 0.7580 0.7612 0.7642 0.7673 0.7704 0.7734 0.7764 0.7794 0.7823 0.7852 0.8 0.7881 0.7910 0.7939 0.7967 0.7996 0.8023 0.8051 0.8079 0.8106 0.8133 0.9 0.8159 0.8186 0.8212 0.8238 0.8264 0.8289 0.8315 0.8340 0.8365 0.8389 1.0 0.8413 0.8438 0.8461 0.8485 0.8508 0.8531 0.8554 0.8577 0.8599 0.8621 1.1 0.8643 0.8665 0.8686 0.8708 0.8729 0.8749 0.8770 0.8790 0.8810 0.8830 1.2 0.8849 0.8869 0.8888 0.8907 0.8925 0.8944 0.8962 0.8980 0.8997 0.9015 1.3 0.9032 0.9049 0.9066 0.9082 0.9099 0.9115 0.9131 0.9147 0.9162 0.9177 1.4 0.9192 0.9207 0.9222 0.9236 0.9251 0.9265 0.9279 0.9292 0.9306 0.9319 1.5 0.9332 0.9345 0.9357 0.9370 0.9382 0.9394 0.9406 0.9418 0.9430 0.9441 1.6 0.9452 0.9463 0.9474 0.9485 0.9495 0.9505 0.9515 0.9525 0.9535 0.9545 1.7 0.9554 0.9564 0.9573 0.9582 0.9591 0.9599 0.9608 0.9616 0.9625 0.9633 1.8 0.9641 0.9649 0.9656 0.9664 0.9671 0.9678 0.9686 0.9693 0.9700 0.9706 1.9 0.9713 0.9719 0.9726 0.9732 0.9738 0.9744 0.9750 0.9756 0.9762 0.9767 2.0 0.9773 0.9778 0.9783 0.9788 0.9793 0.9798 0.9803 0.9808 0.9812 0.9817 2.1 0.9821 0.9826 0.9830 0.9834 0.9838 0.9842 0.9846 0.9850 0.9854 0.9857 2.2 0.9861 0.9865 0.9868 0.9871 0.9875 0.9878 0.9881 0.9884 0.9887 0.9890 2.3 0.9893 0.9896 0.9898 0.9901 0.9904 0.9906 0.9909 0.9911 0.9913 0.9916 2.4 0.9918 0.9920 0.9922 0.9925 0.9927 0.9929 0.9931 0.9932 0.9934 0.9936 2.5 0.9938 0.9940 0.9941 0.9943 0.9945 0.9946 0.9948 0.9949 0.9951 0.9952 2.6 0.9953 0.9955 0.9956 0.9957 0.9959 0.9960 0.9961 0.9962 0.9963 0.9964 2.7 0.9965 0.9966 0.9967 0.9968 0.9969 0.9970 0.9971 0.9972 0.9973 0.9974 2.8 0.9974 0.9975 0.9976 0.9977 0.9977 0.9978 0.9979 0.9980 0.9980 0.9981 2.9 0.9981 0.9982 0.9983 0.9983 0.9984 0.9984 0.9985 0.9985 0.9986 0.9986 3.0 0.9987 0.9987 0.9987 0.9988 0.9988 0.9989 0.9989 0.9989 0.9990 0.9990 3.1 0.9990 0.9991 0.9991 0.9991 0.9992 0.9992 0.9992 0.9992 0.9993 0.9993 3.2 0.9993 0.9993 0.9994 0.9994 0.9994 0.9994 0.9994 0.9995 0.9995 0.9995 3.3 0.9995 0.9995 0.9996 0.9996 0.9996 0.9996 0.9996 0.9996 0.9996 0.9997 3.4 0.9997 0.9997 0.9997 0.9997 0.9997 0.9997 0.9997 0.9997 0.9998 0.9998 3.5 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 0.9998 Software Design Management, Leadership, and Ethics  325 technical.integrity.of.the.design.in.the.presence.of.changes.Figure 10.4.shows.an.example. of.a.change.control.process.Here.a.change.request.is.submitted.to.the.change.control.

--- Chunk 543 ---
Tokens: 384
Type: sentence-based
Text:
of.a.change.control.process.Here.a.change.request.is.submitted.to.the.change.control. authority.which.in.many.cases.corresponds.to.the.project.manager.the.design.lead.or. the.group.that.makes.the.final.decision.on.the.status.and.priority.of.a.change.The.request. is.then.evaluated.based.on.technical.merit.complexity.of.integration.and.potential.side. effects.From.these.assessments.the.request.is.assigned.a.change.priority.Developers.then. take.their.initial.design.documents.through.another.round.of.formal.reviews.to.obtain. updated.estimates.for.the.budget.schedule.and.staffing.Finally.updated.design.docu- ments.and.schedule.estimates.must.then.be.approved.by.the.customer.since.they.represent. changes.to.the.original.estimates. IMPLEMENTATION PHASE During.the.implementation.stage.the.main.managerial.activities.are.monitoring.and.con- trolling.that.the.design.project.activities.are.being.accomplished.according.to.the.plan. (i.e, schedule.and.budget).Monitoring.and.controlling.mechanisms.exist.to.identify.any. deviations.from.the.plan.and.to.ensure.that.these.deviations.get.corrected.in.a.timely. manner.in.order.to.avoid.major.future.problems.Appropriate.project.management.tools. for.this.phase.are.Gantt.charts.and.earned value management (EVM).Recall.that.in.our. earlier.discussion.on.Gantt.charts.we.mentioned.that.they.are.a.useful.mechanism.to. manage.progress.within.the.design.phase.Since.we.have.already.covered.Gantt.charts.in. the.previous.section.we.will.limit.our.discussion.only.to.earned.value.management.

--- Chunk 544 ---
Tokens: 380
Type: sentence-based
Text:
the.previous.section.we.will.limit.our.discussion.only.to.earned.value.management. Internal Analysis and Evaluation Customer Requirements Higher Level Management Change Request Priority Evaluations Assess Complexity of Integration Update Documents (e.g, design) Update Budget  Schedule, and Sta Requirements Get Customer Approval of Updates FIGURE 10.4 Example.of.a.change.control.process. 326  Software Engineering Design Earned Value Management Earned. value. management. (EVM). is. an. important. project. management. technique. to. determine.the.progress.of.tasks.based.on.the.value.of.the.work.currently.completed.versus. the.work.that.was.expected.to.be.completed.at.that.particular.time.The.term.used.to.define. the.dollar.amount.of.the.work.currently.completed.is.called.earned value (EV).which.is. calculated.by.multiplying.the.percentage.work.completed.times.the.planned.total.cost.of. the.work.when.completed.Therefore.a.key.factor.is.to.accurately.estimate.the.percentage. of.work.completed.which.can.be.hard.to.do.because.of.the.complexity.of.tasks.and.the. high.degree.of.subjectivity.that.is.typically.involved.Furthermore.workers.tend.to.inflate. the.percentage.of.work.completed.to.give.the.perception.that.work.is.progressing.smoothly. for.the.completion.of.the.task.Portraying.a.false.sense.of.work.completion.is.very.danger- ous.for.a.project.and.can.result.in.significant.schedule.and.budget.overruns.Knowing. that.the.percent.completion.of.a.task.at.a.particular.point.in.time.is.lower.than.expected.

--- Chunk 545 ---
Tokens: 383
Type: sentence-based
Text:
that.the.percent.completion.of.a.task.at.a.particular.point.in.time.is.lower.than.expected. provides.managers.the.opportunity.to.implement.corrective.actions.to.mitigate.the.risks.of. not.completing.the.task.within.established.cost.and.schedule.constraints.There.are.various. ways.to.estimate.percentage.completion.Meredith.and.Mantel.(2009).provide.a.rough.set. of.guidelines.that.can.be.used.to.help.in.the.estimation.process.which.are.briefly.described. in.Table 10.5. Armed.with.EV.calculations.for.each.task. (i.e.each.element.in.the.WBS).we.can.exam- ine.deviations.to.cost.and.schedule.and.then.establish.a.dollar.amount.to.these.devia- tions.The.terms.used.to.define.current.deviations.to.schedule.and.cost.are.called.schedule variance (SV).and.cost variance (CV).SV.is.calculated.as.the.difference.between.the.EV. and.the.planned value (PV).which.is.the.costvalue.of.the.work.that.was.expected.to.be. completed.at.that.point.in.time.of.the.schedule.CV.is.the.difference.between.the.EV.and. the.actual cost (AC).which.is.the.amount.of.money.that.was.spent.on.the.work.currently. completed.Two.other.important.measures.are.the.cost performance index (CPI).and.the. schedule performance index (SPI).The.CPI.value.is.calculated.as.the.ratio.of.EV.to.AC.This. measure.can.be.used.to.estimate.the.projected.cost.to.complete.some.work.The.SPI.value.is. calculated.as.the.ratio.of.EV.to.PV.This.measure.can.be.used.to.estimate.the.projected.time. to.complete.some.work.Table 10.6.provides.a.brief.description.of.the.EVM.parameters.

--- Chunk 546 ---
Tokens: 394
Type: sentence-based
Text:
to.complete.some.work.Table 10.6.provides.a.brief.description.of.the.EVM.parameters. defined.so.far.as.well.as.budget at completion (BAC).estimate cost to complete (ETC).and. estimate at completion (EAC).Table 10.7.shows.the.equations.for.the.parameters.Notice. TABLE 10.5 Some.Guidelines.for.Estimating.Percentage.Completion.of.a.Task Approach Name Brief Description 5050. Assumes.50.task.completion.as.soon.as.the.task.begins.and.100.completion.when. the.task.is.completed 0100.percent Assumes.0.until.the.task.gets.fully.completed Critical.input.use Percent.completion.is.a.function.of.how.much.of.a.critical.input.is.used.versus.its.overall. expected.total.to.be.used Proportionality Assumes.work.completion.as.the.proportion.of.actual.time.(or.cost).spent.over.the.total. time. (or.cost).planned.for.the.task.to.be.completed Software Design Management, Leadership, and Ethics  327 that.the.EV.parameter.is.present.in.all.of.these.calculations.This.highlights.the.importance. of.establishing.accurate.estimations.of.percent.work.completion.which.is.the.key.factor. used.to.define.EV. Lets. show. the. implementation. of. the. EVM. equations. discussed. so. far. through. an. example.Assume.the.following.scenario: Sara.is.managing.a.software.design.project.composed.of.10.tasks.Each.task.was.estimated.to. cost.1,000.therefore.BAC.10,000.Each.task.was.estimated.to.be.completed.in.a.month. therefore.the.total.planned.duration.for.the.project.was.estimated.to.be.10.months.Since. each.task.is.expected.to.have.the.same.cost.and.duration.the.completion.of.an.individual.task.

--- Chunk 547 ---
Tokens: 378
Type: sentence-based
Text:
each.task.is.expected.to.have.the.same.cost.and.duration.the.completion.of.an.individual.task. represents.10.completion.of.the.design.project.In.the.current.fifth.month.only.three.tasks. have.been.fully.completed.at.a.cost.of.4,000.Sara.needs.to.provide.upper.management.with. current.progress.status. TABLE 10.6 EVM.Definition.of.Parameters Parameter Description EV Also.called.budgeted cost of work performed (BCWP).it.is.the.dollar.amount.of.the.work. currently.completed AC Also.called.actual cost of work performed (ACWP).it.represents.the.amount.of.money.that.was. spent.on.the.work.currently.completed PV Also.called.budgeted cost of work scheduled (BCWS).it.represents.the.value.of.the.work.that.was. expected.to.be.completed.at.that.point.in.time.of.the.schedule CV Describes.the.difference.between.the.value.of.work.completed.and.the.actual.cost.spent.to. complete.it SV Describes.the.difference.between.the.value.of.work.currently.completed.and.the.cost.of.the. work.that.was.expected.to.be.completed CPI Describes.the.current.cost.efficiency.of.the.work.(CPI.1.means.over.budget.CPI.1.means. under.budget.CPI.1.means.right.on.budget) SPI Describes.the.current.schedule.efficiency.of.the.work.(SPI.1.means.behind.schedule.SPI.1. means.ahead.of.schedule.SPI.1.means.right.on.schedule) BAC Total.budget.for.the.project ETC Represents.the.estimated.cost.remaining.to.complete.the.project EAC Represents.the.total.cost.of.the.entire.project TABLE 10.7 Equations.for.EVM.parameters Parameter Equation EV EV.

--- Chunk 548 ---
Tokens: 385
Type: sentence-based
Text:
means.ahead.of.schedule.SPI.1.means.right.on.schedule) BAC Total.budget.for.the.project ETC Represents.the.estimated.cost.remaining.to.complete.the.project EAC Represents.the.total.cost.of.the.entire.project TABLE 10.7 Equations.for.EVM.parameters Parameter Equation EV EV. (.work.completed).planned.cost.for.the.work CV CV.EV.AC SV SV.EV.PV CPI CPI.EVAC SPI SPI.EVPV ETC ETC. (BAC.EV)CPI EAC EAC.ETC.AC 328  Software Engineering Design In.this.scenario.Sara.can.use.the.set.of.equations.from.Table 10.7.to.present.upper.man- agement.with.a.complete.progress.status.of.the.project.EV.is.calculated.to.be.3,000.given. that.the.three.tasks.completed.represent.30.of.the.project.and.the.budget.for.the.entire. project.is.10,000.To.calculate.SV.we.use.a.PV.of.5,000.because.each.task.was.budgeted.at. 1,000.and.five.tasks.should.have.been.completed.in.the.fifth.month.Table 10.8.shows.the. calculations.for.the.rest.of.the.EVM.parameters.These.results.clearly.show.that.the.project.is. over.both.budget.and.schedule.estimates.The.CPI.index.for.example.shows.that.only.0.75. of.earned.value.was.received.for.every.dollar.actually.spent.The.EAC.shows.an.estimated. 6,333.over.budget.amount.These.alarming.values.give.Sara.and.upper.management.the. opportunity.to.implement.risk.mitigation.policies.to.either.get.the.project.to.its.budgeted. path.or.at.least.attempt.to.minimize.losses. Skill Development 10.2: Estimating Project Completion via Simple Simulation Estimating.the.percent.completion.of.tasks.is.not.an.exact.science.In.fact.we.can.say.

--- Chunk 549 ---
Tokens: 348
Type: sentence-based
Text:
Skill Development 10.2: Estimating Project Completion via Simple Simulation Estimating.the.percent.completion.of.tasks.is.not.an.exact.science.In.fact.we.can.say. that.estimated.values.of.percentage.completion.are.uncertain. and.therefore. can.be. treated.as.random.variables.from.assumed.probabilistic.distributions.An.example.of. a.probabilistic.distribution.is.the.uniform.distribution.which.is.a.continuous.distri- bution.where.possible.events. (within.a.lower.and.upper.bound).have.the.same.prob- ability.of.occurrence.This.distribution.is.expressed.as.U(a, b).where.a.and.b.denote. lower.and.upper.limits.respectively.In.the.example.related.to.Table 10.8.assume.that. the. costs. for. the. tasks. are. considered. random. variables. More. specifically. assume. that.the.estimated.costs.for.Tasks.1.3.5.7.and.9.can.be.modeled.with.the.following. distribution.U(700.1,300).Similarly.assume.that.the.estimated.costs.for.Tasks.2. 4.6.8.and.10.can.be.modeled.with.the.following.distribution.U(800.1,200).In.a. spreadsheet. (e.g, Microsoft.Excel).simulate.10.values.for.the.cost.of.each.task.What. is.the.average.cost.of.the.project.using.simulation.Are.there.any.benefits.from.using. simulation.modeling.for.project.cost.estimation? Note.In.Excel.to.model.a.U(a, b) random.variable.type.the.following.function.in.an.empty.cell.a.(b.a)RAND(). Remember.that.it.is.critical.to.begin.with.the.sign.

--- Chunk 550 ---
Tokens: 380
Type: sentence-based
Text:
Remember.that.it.is.critical.to.begin.with.the.sign. TABLE 10.8 Example.EVM.Parameters Parameter Calculation EV 0.3.10,000.3,000 CV 3,000.4,000.-1,000 SV 3,000.5,000.-2,000 CPI 3,0004,000.0.75 SPI 3,0005,000.0.6000 ETC (10,000.3,000)0.75.9,333 EAC 9,333.7,000.16,333 Software Design Management, Leadership, and Ethics  329 TERMINATION STAGE During.the.termination.stage.key.activities.involve.verification.that.everything.is.in.place. for.a.smooth.transition.into.the.code.construction.phase.Activities.include.for.example. making.sure.that.the.latest.versions.of.the.design.documents.are.securely.stored.based. on. configuration. management. procedures. updating. schedule. and. cost. current. values. reevaluating.schedule.and.budget.plans.based.on.the.resulting.performance.measures.of. the.design.phase.and.communicating.results.to.upper.management. LEADING THE DESIGN EFFORT Without.a.doubt.leadership.plays.a.key.role.in.the.success.or.failure.of.complex.projects. As.such.it.is.necessary.to.cover.important.concepts.related.to.leadership.in.the.design. effort.It is.important.to.mention.that.the.field.of.leadership.is.one.that.has.been.researched. by.academicians.and.practitioners.for.many.years.Therefore.there.is.an.extensive.body. of.knowledge.and.literature.related.to.this.field.The.purpose.of.this.section.is.to.high- light. some. key. leadership. concepts. that. are. relevant. to. our. study. of. software. designs. A significant.part.of.the.material.covered.in.this.section.was.gathered.from.Lussier.and.

--- Chunk 551 ---
Tokens: 393
Type: sentence-based
Text:
A significant.part.of.the.material.covered.in.this.section.was.gathered.from.Lussier.and. Achua.(2010).therefore.readers.are.referred.to.this.work.for.more.detailed.explanations.of. .leadership.concepts. Personality Traits and Leadership Traits.are.personal.characteristics.that.help.to.describe.a.person.For.example.someone. who.has.the.ability.to.communicate.well.with.others.and.start.friendly.conversations.with. unknown.people.can.be.said.to.have.a.highly.sociable.trait.Someone.who.works.hard.and. tends.to.go.the.extra.mile.to.complete.assigned.tasks.can.be.said.to.possess.an.achieve- ment.trait.The.combination.of.traits.that.a.person.has.defines.that.persons.personality. and.personality.significantly.affects.our.decisions.For.example.a.highly.sociable.person. with.an.achievement.trait.is.expected.to.make.decisions.such.as.volunteering.to.make. presentations.to.clients.Given.that.a.good.decision-making.ability.is.a.major.part.of.being. an.effective.leader.it.is.important.to.understand.the.relationship.among.traits.personality. decision.making.and.leadership. Personality Dimensions Researchers.have.identified.five.personality.dimensions.to.categorize.groups.of.traits.The. idea.behind.this.is.to.be.able.to.classify.someones.personality.into.one.of.these.dimen- sions.The.five.dimensions.are.agreeableness.surgency.adjustment.conscientiousness.and. 330  Software Engineering Design .openness to experience.Although.called.by.different.names.by.various.researchers.we.will. refer.to.Lussier.and.Achua. (2010).and.call.them.the.Big Five Model of Personality.

--- Chunk 552 ---
Tokens: 390
Type: sentence-based
Text:
(2010).and.call.them.the.Big Five Model of Personality. The.agreeableness.dimension.contains.traits.that.are.related.to.getting.along.with.people. Individuals.who.are.strong.in.agreeableness.are.friendly.sociable.and.compassionate.The. surgency.dimension.on.the.other.hand.corresponds.to.personalities.that.are.dominant. (i.e.want.to.be.in.control).enjoy.competition.and.are.willing.to.confront.others.among. other.things.Individuals.who.are.weak.in.surgency.are.typically.followers.The.adjust- ment.dimension.is.related.to.emotional.stability.Individuals.who.are.strong.in.this.dimen- sion.are.considered.stable.people.who.are.in.control.of.themselves.are.positive.minded. and.react.well.under.pressure.Those.who.are.weak.in.adjustment.are.considered.unstable. and.typically.are.characterized.by.being.negative.and.performing.poorly.under.pressure. The conscientiousness.dimension.contains.traits.related.to.achievement.Basically.indi- viduals.who.are.strong.in.this.dimension.are.those.who.are.willing.to.work.extra.hours.and. make.sacrifices.to.reach.the.assigned.objectives.Last.but.not.least.the.openness.to.experi- ence.dimension.is.related.to.individuals.who.are.flexible.to.change.are.open-minded.and. attempt.enjoy.trying.new.things.Understanding.these.dimensions.is.important.because. researchers.have.found.varying.degrees.of.correlations.between.leadership.and.each.of.the. five.personality.dimensions.For.example.Judge.Ilies.Bono.and.Gerhardt.(2007).analyzed. over.70.prior.studies.to.determine.correlations.among.the.five.personality.dimensions.and.

--- Chunk 553 ---
Tokens: 399
Type: sentence-based
Text:
over.70.prior.studies.to.determine.correlations.among.the.five.personality.dimensions.and. leadership.The.results.of.this.study.showed.that.the.surgency.dimension.was.the.highest. with.a.0.31.correlation.This.means.that.traits.corresponding.to.surgency.can.be.used.to. some.extent.to.describe.leadership.The.second.highest.was.conscientiousness.with.a.0.28. correlation.followed.by.openness.to.experience.with.0.24.and.agreeableness.with.0.08. Traits of Effective Leaders As.already.stated.personality.dimensions.are.defined.by.groups.of.traits.and.can.provide. an.understanding.of.leadership.in.individuals.A.different.approach.to.studying.personal- ity.dimensions.is.to.investigate.common.individual.traits.that.effective.leaders.possess. without.grouping.traits.into.personality.dimensions.Some.of.the.most.important.traits. are.presented.in.Table 10.9. Ethical Leadership Ethics.can.be.defined.as.a.set.of.moral.principles.that.facilitates.the.process.to.distinguish. between.right.and.wrong.behavior.Research.has.shown.that.ethical.behavior.positively. correlates.with.leadership.effectiveness.(Veiga.2004).Furthermore.it.is.well-known.that. one.of.the.best.ways.to.lead.is.by.example.Therefore.an.ethical.leader.sets.the.tone.for. employees.to.conduct.themselves.in.an.ethical.manner.However.being.an.ethical.leader. can.be.very.challenging.because.of.the.risk.of.rejection.or.loss.associated.with.ethical.deci- sions.A.few.things.can.be.done.to.overcome.this.challenge.one.of.which.is.to.focus.on.a. higher.purpose.while.going.through.the.decision.process.that.involves.moral.behavior.For.

--- Chunk 554 ---
Tokens: 341
Type: sentence-based
Text:
higher.purpose.while.going.through.the.decision.process.that.involves.moral.behavior.For. example.assume.that.the.design.lead.of.a.major.top.secret.software.project.is.approached. Software Design Management, Leadership, and Ethics  331 by.a.foreign.citizen.with.a.proposition.to.sell.the.software.design.and.other.important. documents.to.an.enemy.country.If.focused.on.the.safety.of.the.people.(i.e.the.higher. purpose).then.ethical.values.will.provide.the.answer.of.not.accepting.the.offer.and.report- ing.the.foreign.person.to.the.authorities.Another.approach.that.can.be.taken.to.over- come.the.challenges.associated.with.ethical.decisions.is.to.find.support.from.other.ethical. people.(e.g.friends.family.coworkers).To.help.employees.distinguish.between.ethical.and. unethical.activities.most.companies.have.their.own.internal.documents.that.describe.the. expected.ethical.behavior.from.employees.It.is.very.important.for.leaders.to.conform.to. these.guidelines.and.discuss.them.with.employees. Power Leading.is.about.influencing.others.The.potential.influence.that.leaders.have.over.others. is.called.power.The.word.potential.means.that.it.is.actually.the.perception.of.power.and. not.the.power.itself.that.influences.followers.The.two.main.sources.of.power.are.position. power.and.personal.power.Position power.is.related.to.hierarchical.position.levels.More.

--- Chunk 555 ---
Tokens: 381
Type: sentence-based
Text:
power.and.personal.power.Position power.is.related.to.hierarchical.position.levels.More. specifically.higher.hierarchical.levels.mean.higher.potential.power.Therefore.the.presi- dent.of.a.software.company.has.more.potential.power.than.any.other.employee.in.the.com- pany.because.of.position.power.Position.power.is.important.because.it.allows.managers. to.influence.employees.to.reach.planned.objectives.There.are.various.types.of.position. power.An.example.of.one.is.called.the.reward power.This.type.of.power.gives.managers. the.ability.to.influence.employees.with.something.of.value.to.them.namely.performance. evaluations.Employees.will.be.influenced.to.complete.their.corresponding.assignments. because. of. their. managers. reward. power. to. provide. good. performance. evaluations. Another.type.of.position.powerrelated.to.reward.poweris.called.coercive power.The. coercive.power.basically.says.that.managers.have.the.ability.to.influence.others.by.the.idea. of.punishment.and.withholding.of.rewards.Following.the.same.example.employees.can. TABLE 10.9 Traits.of.Effective.Leaders Principle Description (Traits Characteristics in a Person) Dominance This.trait.describes.a.person.who.wants.to.be.a.manager.and.takes.control.Successful. leaders.with.this.trait.are.not.overly.bossy.and.avoid.the.bullying.style. High.energy This.trait.describes.a.positive-minded.person.who.works.hard.to.achieve.objectives.and. is.good.at.taking.initiative. Integrity This.trait.describes.a.person.who.is.highly.ethical.and.trustworthy.

--- Chunk 556 ---
Tokens: 398
Type: sentence-based
Text:
Integrity This.trait.describes.a.person.who.is.highly.ethical.and.trustworthy. Flexibility This.trait.describes.a.person.who.can.adapt.well.to.new.and.different.situations. Self-confidence This.trait.describes.a.person.who.trusts.his.or.her.judgment.initiatives.intelligence. and.ideas.This.is.not.to.be.confused.with.arrogance. Stability This.trait.describes.a.person.who.is.able.to.control.emotions.and.act.well.under.pressure. Intelligence This.trait.describes.a.person.who.possesses.a.high.cognitive.ability.to.solve.problems. and.make.decisions. Sensitivity.to.others This.trait.describes.a.person.who.focuses.on.the.feelings.of.others.and.strongly. considers.them. 332  Software Engineering Design be.influenced.to.complete.their.corresponding.assignments.because.of.their.managers. coercive.power.to.provide.bad.performance.evaluations.and.withhold.salary.increases. Personal power relates.to.the.potential.influence.that.a.persons.behavior.has.to.influ- ence.others.Being.positive.assertive.and.hard-working.are.some.of.the.characteristics.that. increase.personal.power.As.with.position.power.there.are.also.various.types.of.personal. power.One.example.is.the.expert power.This.type.of.power.is.based.on.the.ability.to.influ- ence.others.based.on.a.leaders.skill.and.knowledge.For.example.being.an.expert.in.devel- oping.architectural.designs.will.influence.others.to.follow.the.expert.The.expert.power.of. an.individual.gets.stronger.as.people.with.similar.expertise.levels.become.fewer.Another. type.of.personal.power.is.called.connection.power.Connection power.refers.to.the.ability.

--- Chunk 557 ---
Tokens: 379
Type: sentence-based
Text:
type.of.personal.power.is.called.connection.power.Connection power.refers.to.the.ability. of.a.person.to.influence.others.because.of.the.persons.relationships.with.influential.people. KEY LEADERSHIP SKILLS Various.skills.are.important.to.leadership.Some.of.these.skills.include.communication. networking.motivation.and.negotiation.These.are.described.in.the.following.subsections. Communication Skills Good. communication. skills. are. essential. for. effective. leadership. Various. researchers. (see, e.g.Li.and.Liu.2010.Simkin.1996).have.mentioned.that.a.high.percent.of.a.managers. time.is.spent.in.communications.As.already.mentioned.leadership.is.about.influencing. others.Leaders.can.influence.and.establish.productive.relationships.with.others.through. communication.Truly.effective.communication.occurs.when.the.information.passed.is. equally.and.fully.understood.by.all.parties.One.way.to.achieve.effective.communication.is. to.plan.in.advance.the.message.that.needs.to.be.conveyed.To.achieve.this.the.goal.of.the. message.needs.to.be.clearly.understood.Also.it.is.important.to.think.about.the.best.timing. to.convey.the.message.how.the.message.will.be.delivered.(e.g.oral.written).and.where. (e.g.companys.auditorium.employees.office). One.type.of.communication.is.oral communication.To.become.an.effective.oral.commu- nicator.can.be.challenging.and.often.takes.much.practice.One.way.to.become.effective.is.to. have.a.process.in.place.so.that.focus.can.be.placed.in.the.individual.elements.of.the.process.

--- Chunk 558 ---
Tokens: 385
Type: sentence-based
Text:
have.a.process.in.place.so.that.focus.can.be.placed.in.the.individual.elements.of.the.process. Lussier.and.Achua.(2010).describe.a.five-step.process.for.effectively.sending.oral.messages. The.first.step.is.to.develop.a.rapport.This.means.to.try.establishing.a.good.relationship.with. the.receiving.party.and.begin.small.conversations.related.to.the.message.The.second.step.is. to.clearly.state.the.objective.of.the.message.This.is.crucial.as.it.helps.the.receiver.to.under- stand.what.the.message.is.expected.to.accomplish.before.the.details.of.the.message.are.trans- mitted.This.will.engage.the.receivers.mind.to.focus.on.the.message.to.be.received.The.third. step.is.to.actually.transmit.the.message.The.fourth.step.is.to.perceive.the.receivers.under- standing.of.the.message.It.is.important.that.the.message.was.well.understood.otherwise.its. objectives.were.not.achieved.This.can.be.accomplished.by.asking.direct.questions.or.reading. Software Design Management, Leadership, and Ethics  333 the.receivers.expressions.When.convinced.that.the.message.was.understood.the.final.step. of.the.process.is.to.get.a.commitment.from.the.receiver.This.is.unnecessary.if.the.goal.of.the. message.is.to.merely.inform.However.if.the.goal.is.to.influence.the.receiver.to.accomplish. a.task.(e.g.design.document).then.a.commitment.from.the.receiver.to.complete.the.task.is. necessary.For.this.the.leader.must.be.convinced.that.the.receiver.is.capable.of.completing. the.task.by.its.deadline.When.a.commitment.from.the.receiver.is.received.the.leader.must.

--- Chunk 559 ---
Tokens: 386
Type: sentence-based
Text:
the.task.by.its.deadline.When.a.commitment.from.the.receiver.is.received.the.leader.must. follow.up.to.make.sure.that.the.task.is.being.accomplished.If.not.the.leader.can.make.use.of. the.power.concept.to.persuade.the.receiver.to.complete.the.task. Another.type.of.communication.is.written communication.This.type.of.communication. is.now.more.important.than.ever.and.it.is.mainly.attributed.to.e-mail.technology.Today. people.around.the.world.communicate.with.each.other.via.e-mails.and.e-mailing.between. managers.and.employees.is.almost.always.the.preferred.type.of.written.communication. The.key.elements.for.effective.written.communication.are.content.and.structure.That.is. the.message.must.be.structured.in.such.a.way.that.the.information.it.intends.to.transmit. (i.e.content).is.clearly.described.and.the.flow.of.information.is.smooth.and.easy.to.follow. As.with.oral.communication.it.is.critical.for.the.communicator.to.clearly.understand. the.intended.objective.of.the.message.before.writing.it.One.way.to.do.this.is.to.make.an. .outline.with.the.main.points.that.need.to.be.transmitted.Making.an.outline.also.helps.to. establish.an.appropriate.flow.for.the.message.which.is.necessary.for.a.clear.understanding. of.it.Another.way.to.improve.message.flow.is.to.avoid.including.unnecessary.information. Messages.must.be.kept.short.simple.and.to.the.point. A. final. point. on. written. communication. is. that. we. must. understand.that. writing. is. a.skill.As.such.it.takes.effort.(e.g.reading.books.on.proper.grammar).and.practice.to.

--- Chunk 560 ---
Tokens: 393
Type: sentence-based
Text:
a.skill.As.such.it.takes.effort.(e.g.reading.books.on.proper.grammar).and.practice.to. become.good.at.it.One.way.to.improve.this.skill.is.to.have.others.review.your.work.so. that.you.can.learn.from.their.feedback.It.is.important.to.keep.in.mind.that.editing.and. rewriting.are.often.necessary.actions.to.ensure.the.quality.of.messages.With.continued. advances.in.technology.the.value.of.becoming.an.effective.writer.is.becoming.more.and. more.important.to.leadership.Consider.for.example.the.relatively.recent.technology.of. social.networking.and.electronic.chatting.rooms.which.allow.real-time.written.commu- nication.between.parties.around.the.world. Networking Skills Networking. can. be. defined. as. a. skill. that. focuses. on. building. relationships. with. others. through.effective.communications.Thus.communications.and.networking.skills.are.closely. related.to.each.other.Networking.is.particularly.important.for.leadership.because.it.facilitates. the.process.of.meeting.objectives.As.with.any.skill.networking.can.be.improved.with.practice. Motivation Skills It.can.be.safe.to.say.that.there.exists.a.positive.correlation.between.employees.motivation. levels.and.their.productivity.Therefore.the.ability.to.motivate.others.to.work.hard.to.achieve. particular.project.goals.is.a.major.part.of.being.a.leader.For.various.decades.now.motivation. 334  Software Engineering Design has.been.an.area.of.investigation.to.many.researchers.Various.theories.have.been.developed. to.describe.a.set.of.motivational.factors.that.significantly.affect.individuals.behavior.The.

--- Chunk 561 ---
Tokens: 399
Type: sentence-based
Text:
to.describe.a.set.of.motivational.factors.that.significantly.affect.individuals.behavior.The. general.benefit.sought.from.these.research.studies.was.that.identifying.and.understand- ing.these.factors.would.provide.leaders.with.necessary.resources.to.positively.influence.and. inspire.employees.to.successfully.complete.their.tasks. One.of.the.motivational.theories.developed.is.called.the.hierarchy of needs theory.(Lussier. and.Achua.2010).This.theory.describes.five.types.of.needs.through.which.employees.are. motivated.Table 10.10.shows.the.five.types.and.provides.some.of.the.activities.that.can. help.meet.the.particular.needs.associated.with.each.type. Negotiation Skills Negotiation.skills.are.an.important.part.of.any.management.job.Good.negotiators.are. capable.of.leading.by.looking.out.for.the.best.interests.of.the.people.that.they.are.leading. There.are.many.research.studies.related.to.negotiations.some.of.which.have.resulted.in. guidelines.that.can.help.to.improve.a.persons.negotiation.skills.One.such.set.of.guidelines. called.principled negotiation.was.developed.by.Fisher.and.Ury. (1991).Principled.negotia- tion.is.composed.of.four.guidelines.The.first.one.is.to.separate the people from the problem. This.principle.helps.to.keep.the.focus.on.the.problem.at.hand.rather.than.on.interpersonal. issues.The.second.guideline.is.to.focus on interests rather than positions.This.principle.helps. to.keep.the.focus.of.the.negotiation.on.the.interests.of.people.rather.than.their.positions. The.third.guideline.is.to.generate options before trying to reach an agreement.This principle.

--- Chunk 562 ---
Tokens: 389
Type: sentence-based
Text:
The.third.guideline.is.to.generate options before trying to reach an agreement.This principle. promotes.creativity.and.reminds.the.negotiating.parties.to.brainstorm.to.find.potential. TABLE 10.10 Types.of.Needs.and.Activities.to.Meet.Them Type of Need Activities to Meet the Needs Physiological Adequate.salaries Allowance.of.breaks Adequate.working.conditions Safety Safe.working.conditions Salary.increases. (considering.inflation) Fringe.benefits Social Social.activities.that.conform.to.individual.behavior Team-building.retreats Team.sports Lunch.gatherings Esteem Raises.based.on.performance Awards Public.recognition Participation.in.decision.making Self-actualization Skill.development.activities Promotions Increase.control.of.an.employees.task Software Design Management, Leadership, and Ethics  335 solutions.that.can.be.brought.to.the.negotiation.The.fourth.guideline.is.to.insist on using objective criteria.This.principle.promotes.decision.making.based.on.reasonable.standards. rather.than.on.subjective.ones. ETHICS IN SOFTWARE DESIGN Software.engineers.must.abide.to.the.highest.possible.standards.when.developing.soft- ware.systems.to.make.the.software.engineering.profession.beneficial.and.highly.respected. Engineers. have. the. responsibility. to. public. welfare. including. health. and. safety. The. IEEE-CSACM.organizations.developed.a.Software.Engineering.Code.of.Ethics. (SECE) (IEEE. 2010). as. the. standard. set. of. ethical. guidelines. that. engineers. must. adhere. to. This code.contains.the.principles.shown.in.Table 10.11.

--- Chunk 563 ---
Tokens: 377
Type: sentence-based
Text:
This code.contains.the.principles.shown.in.Table 10.11. As.seen.these.principles.collectively.ensure.that.professionals.in.the.software.engineer- ing.field.adhere.to.high.levels.of.ethical.conduct.In.one.way.or.another.all.of.these.prin- ciples.can.be.directly.related.with.the.design.of.software.systems.The.SECE.provides.a.very. clear.set.of.guidelines.for.each.principle.Following.is.a.brief.description.of.some.of.these. principles.as.well.as.their.specific.guidelines.from.the.SECE. Public and Product Principles The.public.principle.is.the.first.principle.included.in.the.SECE. (Table 10.12).Basically.this. principle.states.that.professionals.in.the.software.engineering.field.must.take.responsibil- ity.for.their.own.work.and.must.ensure.that.their.work.positively.affects.the.public.good. The.product.principle. (Table 10.13).states.among.other.things.that.professionals.must. strive.for.high.quality.within.acceptable.cost.and.schedule.thresholds. TABLE 10.11 Principles.of.Ethics.in.Software.Engineering Principle Description Public Software.engineers.shall.act.consistently.with.the.public.interest. Client.and.Employer Software.engineers.shall.act.in.a.manner.that.is.in.the.best.interests.of.their.client.and. employer.consistent.with.the.public.interest. Product Software.engineers.shall.ensure.that.their.products.and.related.modifications.meet. the.highest.professional.standards.possible. Judgment Software.engineers.shall.maintain.integrity.and.independence.in.their. professional judgment.

--- Chunk 564 ---
Tokens: 399
Type: sentence-based
Text:
professional judgment. Management Software.engineering.managers.and.leaders.shall.subscribe.to.and.promote.an.ethical. approach.to.the.management.of.software.development.and.maintenance. Profession Software.engineers.shall.advance.the.integrity.and.reputation.of.the.profession. consistent.with.the.public.interest. Colleagues Software.engineers.shall.be.fair.to.and.supportive.of.their.colleagues. Self Software.engineers.shall.participate.in.lifelong.learning.regarding.the.practice.of.their. profession.and.shall.promote.an.ethical.approach.to.the.practice.of.the.profession. Source. IEEE.Computer.Society.Software.Engineering.Code.of.Ethics.and.Professional.Practice.2010. 336  Software Engineering Design Judgment Principle Although.maintaining.integrity.in.professional.judgment.should.be.implicitly.under- stood.for.every.principle.in.the.SECE.a.high.level.of.individual.integrity.is.so.impor- tant.that.the.code.explicitly.included.it.into.a.single.principle.the.judgment.principle. (Table 10.14).Making.decisions.that.conform.to.the.highest.ethical.levels.can.be.very. challenging.at.times.therefore.the.integrity.and.moral.values.of.a.person.play.a.major. role.when.making.judgment.calls. Management Principle The.management.principle.is.of.particular.relevance.to.this.chapter.Therefore.Table 10.15. outlines.the.guidelines.included.for.software.engineering.managers.in.the.code.of.ethics. CHAPTER SUMMARY This.chapter.presented.an.introduction.to.software.design.management.In.particular.this. chapter.focused.on.describing.three.major.elements.that.are.critical.for.the.success.of.any.

--- Chunk 565 ---
Tokens: 380
Type: sentence-based
Text:
chapter.focused.on.describing.three.major.elements.that.are.critical.for.the.success.of.any. major.design.project.management.leadership.and.ethics.In.doing.so.the.chapter.developed. a.design.management.framework.that.describes.important.concepts.related.to.each.element. with.the.hope.of.facilitating.the.successful.management.of.this.complex.phase. TABLE 10.12 Guidelines.Concerning.the.Public.Principle No. Guideline Description 1.01 Engineers.must.accept.full.responsibility.for.their.own.work. 1.02 Moderate.the.interests.of.the.software.engineer.the.employer.the.client.and.the.users.with.the. public good. 1.03 Approve.software.only.if.they.have.a.well-founded.belief.that.it.is.safe.meets.specifications.passes.tests. and.does.not.diminish.quality.of.life.diminish.privacy.or.harm.the.environment.The.ultimate.effect.of. the.work.should.be.to.the.public.good. 1.04 Disclose.to.appropriate.persons.or.authorities.any.actual.or.potential.danger.to.the.user.the.public.or. the.environment.that.they.reasonably.believe.to.be.associated.with.software.or.related.documents. 1.05 Cooperate.in.efforts.to.address.matters.of.grave.public.concern.caused.by.software.its.installation. maintenance.support.or.documentation. 1.06 Be.fair.and.avoid.deception.in.all.statements.particularly.public.ones.concerning.software.or.related. documents.methods.and.tools. 1.07 Consider.issues.of.physical.disabilities.allocation.of.resources.economic.disadvantage.and.other. factors.that.can.diminish.access.to.the.benefits.of.software.

--- Chunk 566 ---
Tokens: 386
Type: sentence-based
Text:
factors.that.can.diminish.access.to.the.benefits.of.software. 1.08 Be.encouraged.to.volunteer.professional.skills.to.good.causes.and.contribute.to.public.education. concerning.the.discipline. Source. IEEE.Computer.Society.Software.Engineering.Code.of.Ethics.and.Professional.Practice.2010. Software Design Management, Leadership, and Ethics  337 TABLE 10.13 Guidelines.Concerning.the.Product.Principle No. Guideline Description 3.01 Strive.for.high.quality.acceptable.cost.and.a.reasonable.schedule.ensuring.significant.tradeoffs.are. clear.to.and.accepted.by.the.employer.and.the.client.and.are.available.for.consideration.by.the.user. and.the.public. 3.02 Ensure.proper.and.achievable.goals.and.objectives.for.any.project.on.which.they.work.or.propose. 3.03 Identify.define.and.address.ethical.economic.cultural.legal.and.environmental.issues.related.to. work projects. 3.04 Ensure.that.they.are.qualified.for.any.project.on.which.they.work.or.propose.to.work.by.an. appropriate.combination.of.education.and.training.and.experience. 3.05 Ensure.an.appropriate.method.is.used.for.any.project.on.which.they.work.or.propose.to.work. 3.06 Work.to.follow.professional.standards.when.available.that.are.most.appropriate.for.the.task.at.hand. departing.from.these.only.when.ethically.or.technically.justified. 3.07 Strive.to.fully.understand.the.specifications.for.software.on.which.they.work. 3.08 Ensure.that.specifications.for.software.on.which.they.work.have.been.well.documented.satisfy.the.users. requirements.and.have.the.appropriate.approvals.

--- Chunk 567 ---
Tokens: 394
Type: sentence-based
Text:
requirements.and.have.the.appropriate.approvals. 3.09 Ensure.realistic.quantitative.estimates.of.cost.scheduling.personnel.quality.and.outcomes.on. any project.on.which.they.work.or.propose.to.work.and.provide.an.uncertainty.assessment.of. these estimates. 3.10 Ensure.adequate.testing.debugging.and.review.of.software.and.related.documents.on.which.they.work. 3.11 Ensure.adequate.documentation.including.significant.problems.discovered.and.solutions.adopted. for any.project.on.which.they.work. 3.12 Work.to.develop.software.and.related.documents.that.respect.the.privacy.of.those.who.will.be.affected. by.that.software. 3.13 Be.careful.to.use.only.accurate.data.derived.by.ethical.and.lawful.means.and.use.it.only.in.ways. properly.authorized. 3.14 Maintain.the.integrity.of.data.being.sensitive.to.outdated.or.flawed.occurrences. 3.15 Treat.all.forms.of.software.maintenance.with.the.same.professionalism.as.new.development. Source. IEEE.Computer.Society.Software.Engineering.Code.of.Ethics.and.Professional.Practice.2010. TABLE 10.14 Guidelines.Concerning.the.Judgment.Principle No. Guideline Description 4.01 Temper.all.technical.judgments.by.the.need.to.support.and.maintain.human.values. 4.02 Only.endorse.documents.either.prepared.under.their.supervision.or.within.their.areas.of.competence. and.with.which.they.are.in.agreement. 4.03 Maintain.professional.objectivity.with.respect.to.any.software.or.related.documents.they.are.asked. to evaluate. 4.04 Not.engage.in.deceptive.financial.practices.such.as.bribery.double.billing.or.other.improper. financial practices.

--- Chunk 568 ---
Tokens: 389
Type: sentence-based
Text:
financial practices. 4.05 Disclose.to.all.concerned.parties.those.conflicts.of.interest.that.cannot.reasonably.be.avoided.or.escaped. 4.06 Refuse.to.participate.as.members.or.advisors.in.a.private.governmental.or.professional.body. concerned.with.software.related.issues.in.which.they.their.employers.or.their.clients.have. undisclosed.potential.conflicts.of.interest. Source. IEEE.Computer.Society.Software.Engineering.Code.of.Ethics.and.Professional.Practice.2010. 338  Software Engineering Design The.chapter.described.the.software.design.phase.as.a.complex.task.that.must.be.man- aged.in.order.to.achieve.acceptable.quality.levels.Various.project.management.techniques. were.presented.These.included.techniques.for.planning.such.as.work.breakdown.struc- tures.linear.responsibility.charts.and.network.diagrams.for.scheduling.It.also.included. a.description.of.earned.value.management.as.a.tool.for.determining.the.progress.of.tasks. based.on.the.value.of.the.work.currently.completed.versus.the.work.that.was.expected.to. be.completed.at.that.particular.time.The.chapter.also.described.the.relationship.between. management.and.leadership.highlighted.several.leadership.traits.that.are.important.for. successful.results.and.presented.various.ethic.items.from.the.Software.Engineering.Code. of.Ethics.that.are.relevant.to.software.design.projects. REVIEW QUESTIONS . 1.What.is.software.design.management.and.why.is.it.important? . 2.Why.is.it.important.to.view.the.software.design.phase.as.a.project? . 3.What.are.the.phases.of.the.software.design.phase? .

--- Chunk 569 ---
Tokens: 390
Type: sentence-based
Text:
. 4.What.are.the.managerial.objectives.of.the.planning.stage? . 5.What.project.management.tools.can.be.used.to.manage.the.planning.phase.of.a.soft- ware.design.project.Briefly.explain.them. . 6.What.project.management.tools.can.be.used.to.manage.the.implementation.phase.of. a.software.design.project.Briefly.explain.them. TABLE 10.15 Guidelines.Concerning.the.Management.Principle No. Guideline Description 5.01 Ensure.good.management.for.any.project.on.which.they.work.including.effective.procedures.for. promotion.of.quality.and.reduction.of.risk. 5.02 Ensure.that.software.engineers.are.informed.of.standards.before.being.held.to.them. 5.03 Ensure.that.software.engineers.know.the.employers.policies.and.procedures.for.protecting.passwords. files.and.information.that.is.confidential.to.the.employer.or.confidential.to.others. 5.04 Assign.work.only.after.taking.into.account.appropriate.contributions.of.education.and.experience. tempered.with.a.desire.to.further.that.education.and.experience. 5.05 Ensure.realistic.quantitative.estimates.of.cost.scheduling.personnel.quality.and.outcomes.on.any project. on.which.they.work.or.propose.to.work.and.provide.an.uncertainty.assessment.of.these estimates. 5.06 Attract.potential.software.engineers.only.by.full.and.accurate.description.of.the.conditions. of employment. 5.07 Offer.fair.and.just.remuneration. 5.08 Not.unjustly.prevent.someone.from.taking.a.position.for.which.that.person.is.suitably.qualified. 5.09 Ensure.that.there.is.a.fair.agreement.concerning.ownership.of.any.software.processes.research.

--- Chunk 570 ---
Tokens: 379
Type: sentence-based
Text:
5.09 Ensure.that.there.is.a.fair.agreement.concerning.ownership.of.any.software.processes.research. writing.or.other.intellectual.property.to.which.a.software.engineer.has.contributed. 5.10 Provide.for.due.process.in.hearing.charges.of.violation.of.an.employers.policy.or.of.this.Code. 5.11 Not.ask.a.software.engineer.to.do.anything.inconsistent.with.this.Code. 5.12 Not.punish.anyone.for.expressing.ethical.concerns.about.a.project. Source. IEEE.Computer.Society.Software.Engineering.Code.of.Ethics.and.Professional.Practice.2010. Software Design Management, Leadership, and Ethics  339 . 7.What.is.the.importance.of.a.change.control.process? . 8.Why.is.estimating.the.percent.completion.of.a.task.so.important.in.earned.value. management? . 9.What.are.the.four.guidelines.described.in.the.chapter.to.estimate.percent.work. completion? . 10.What.are.some.of.the.traits.of.effective.leaders? . 11.How.do.management.and.leadership.relate.to.each.other? . 12.Explain.the.concept.of.power.and.how.it.can.influence.others. . 13.What.are.the.key.leadership.skills.described.in.the.chapter? . 14.How.do.ethics.and.leadership.relate.to.each.other? CHAPTER EXERCISES . 1.The.following.table.contains.task.durations.for.a.project. Task ID Time (Days) Minimum (a) Most Likely (m) Maximum (b) Immediate Predecessors A 10 22 38  B 3 7 12 A C 11 25 44 B D 11 24 42 B E 4 9 17 B.C F 2 5 9 D.E G 4 8 14 F H 11 24 43 G . a. Construct.an.AON.network.diagram.and.identify.the.critical.path.What.is.the. duration.of.the.critical.path? .

--- Chunk 571 ---
Tokens: 381
Type: sentence-based
Text:
. b. What.is.the.probability.that.the.project.gets.completed.by.85.of.the.critical.path. duration? . 2.The.following.table.contains.expected.duration.times.and.expected.cost.for.the.set.of. tasks.corresponding.to.a.major.design.project.that.Dr.Christian.Daniel.is.managing. Task ID Expected Duration (Months) Expected Cost () Task Predecessor 1 1 1,500  2 2 3,000 1 3 1 1,500 2 4 2 3,000 3 5 1 1,500 4 6 2 3,000 5 7 1 1,500 6 8 2 3,000 7 340  Software Engineering Design . a. Assume.a.scenario.where.at.the.end.of.the.seventh.month.five.tasks.have.been. completed.at.a.cost.of.11,500.Use.the.EVM.equations.to.understand.and.show.the. current.status.of.the.project.Also.based.on.this.scenario.what.is.the.EAC.value? . b. Assume.a.scenario.where.at.the.end.of.the.sixth.month.two.tasks.have.been.com- pleted.at.a.cost.of.8,500.Use.the.EVM.equations.to.understand.and.show.the. current.status.of.the.project.Also.based.on.this.scenario.what.is.the.EAC.value? . c. Assume.a.scenario.where.at.the.end.of.the.tenth.month.seven.tasks.have.been. completed.at.a.cost.of.14,500.Use.the.EVM.equations.to.understand.and.show.the. current.status.of.the.project.Also.based.on.this.scenario.what.is.the.EAC.value? REFERENCES Fisher.R.and.W.Ury.Getting to Yes.2d.ed.New.York.Penguin.Books.1991. Griffin.Ricky.W.Management.10th.ed.Mason.OH.South-Western.Publications.2010. IEEE.Computer.Society.Software.Engineering.Code.of.Ethics.and.Professional.Practice.2010.Available.at. http:www.computer.orgportalwebcertificationresourcescode_of_ethics.

--- Chunk 572 ---
Tokens: 386
Type: sentence-based
Text:
http:www.computer.orgportalwebcertificationresourcescode_of_ethics. Judge.T.A.R.Ilies.J.E.Bono.and.M.W.Gerhardt.Personality.and.Leadership.A.Qualitative.and.Quantitative. Review.Journal of Applied Psychology.87.no.4.(2002).765768. Li.Mei.Yan.and.Ying.Zong.Liu.Study.on.Line.Managers.Competence-Based.Abilities.of.Performance. Management.Applied Mechanics and Materials.4041.(2010).820824. Lussier.Robert.and.Christopher.Achua.Leadership: Theory, Application,  Skill Development.4th.ed.Florence. KY.Cengage.Learning.2010. Meredith. Jack. and. Samuel. Mantel. Project Management: A Managerial Approach. 7th. ed. Hoboken. NJ. John Wiley.Sons.2009. Nebus.J.Building.Collegial.Information.Networks.A.Theory.of.Advice.Network.Generation.Academy of Management Review.31.no.3.(2006).615637. Pelosi.Marilyn.K.and.Theresa.M.Sandifer.Elementary Statistics: From Discovery to Decision.Hoboken.NJ. John.Wiley.Sons.2003. Simkin.Mark.The.Importance.of.Good.Communication.Skills.on.IS.Career.Paths.Journal of Technical Writing and Communication.26.no.1.(1996).6978. Veiga.J.F.Special.Topic.Ethical.Behavior.in.Management.Bringing.Ethics.into.the.Mainstream.An.Introduction. to.the.Special.Topic.Academy of Management Executive.18.no.2.(2004).3738. Software Engineering  Systems Development Taking a learn-by-doing approach, Software Engineering Design: Theory and Practice uses examples, review questions, chapter exercises, and case study assign- ments to provide students and practitioners with the understanding required to de- sign complex software systems.

--- Chunk 573 ---
Tokens: 303
Type: sentence-based
Text:
Software Engineering  Systems Development Taking a learn-by-doing approach, Software Engineering Design: Theory and Practice uses examples, review questions, chapter exercises, and case study assign- ments to provide students and practitioners with the understanding required to de- sign complex software systems. Explaining the concepts that are immediately rele- vant to software designers, it begins with a review of software design fundamentals. The text presents a formal top-down design process that consists of several design activities with varied levels of detail, including the macro-, micro-, and construction- design levels. As part of the top-down approach, it provides in-depth coverage of applied architectural, creational, structural, and behavioral design patterns. For each design issue covered, it includes a step-by-step breakdown of the execution of the design solution, along with an evaluation, discussion, and justification for using that particular solution. The book outlines industry-proven software design practices for leading large-scale software design efforts, developing reusable and high-quality software systems, and producing technical and customer-driven design documentation.

--- Chunk 574 ---
Tokens: 318
Type: sentence-based
Text:
The book outlines industry-proven software design practices for leading large-scale software design efforts, developing reusable and high-quality software systems, and producing technical and customer-driven design documentation. It also:  Offers one-stop guidance for mastering the Software Design  Construction sections of the official Software Engineering Body of Knowledge (SWEBOK)  Details a collection of standards and guidelines for structuring high-quality code  Describes techniques for analyzing and evaluating the quality of software designs Collectively, the text supplies comprehensive coverage of the software design concepts students will need to succeed as professional design leaders. The section on engineering leadership for software designers covers the necessary ethical and leadership skills required of software developers in the public domain. The section on creating software design documents (SDD) familiarizes students with the software design notations, structural descriptions, and behavioral models required for SDDs. Course notes, exercises with answers, online resources, and an instructors manual are available upon qualified course adoption. ISBN: 978-1-4398-5168-5 9 781439 851685 90000 K12371 www.auerbach-publications.com www.crcpress.com

================================================================================
SOURCE: SOLID princple.pdf
TOTAL CHUNKS: 10
================================================================================

--- Chunk 0 ---
Tokens: 429
Type: sentence-based
Text:
TCSS 360 C: Software Development  Quality Assurance Techniques Winter 2017 Institute of Technology, UW-Tacoma 1232017 Slides by Wes J. Lloyd L8.1 Software Design and SOLID Principles Wes J. Lloyd Institute of Technology University of Washington - Tacoma TCSS 360: SOFTWARE DEVELOPMENT AND QUALITY ASSURANCE SessionMgr SessionMgr Database Database read_from_db() store_in_db() read_from_db() store_in_db() SessionMgr SessionMgr get_session() store_session() get_session() store_session() interface SessionStore interface SessionStore Database Database  From chapter 11: Engineering SaaS SOLID Design Principles Design Patterns Software Metrics February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.2 OBJECTIVES  Single Responsibility  A class should have one and only one reason to change  OpenClosed  Classes should be open for extension but closed for modification  Liskov Substitution  Substituting a subclass for a class should preserve correct program behavior  Interface Segregation  No client should depend on methods it does not use  Injecting Dependencies  Collaborating classes who implementation may vary at runtime should depend on an intermediate injected dependency February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.3 SOLID DESIGN GUIDELINES  A class should have one and only one responsibility  Example: class named Reviewers in CoffeeFinder which defines information about users who review coffee shops  A sign-on operation could be added to Reviewers to enable a reviewer to log in  This does not separate responsibility!

--- Chunk 1 ---
Tokens: 366
Type: sentence-based
Text:
Single Responsibility: Use a Sessions class  Decouples the design of logging-in from the Reviewers Class  What if the authentication strategy changes? Reviewers class would need to change February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.4 SINGLE RESPONSIBILITY PRINCIPLE  Sign-on operation added to Reviewers Class  How do other classes of users sign-on? Does each user class implement their own? Decouple key featuresfunctions into reusable classes  MVC: Controllers  Each controller provides business logic for system components  Components  ReviewerController: User who contributes coffee shop reviews  UserController: General system user  AdminController: Admin user that performs DB maintenance February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.5 SINGLE RESPONSIBILITY - 2  Classes should be: open for extension, but closed for modification  Extending a class shouldnt require modifying existing code  Case statement code smell:  Factory pattern  Template pattern  Strategy pattern February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.6 OPENCLOSED PRINCIPLE (OCP) Class Report def output formatter  case format when :html HtmlFormatter.new(self) when :pdf PdfFormatted.new(self)  . . .

--- Chunk 2 ---
Tokens: 334
Type: sentence-based
Text:
. Etc end end end TCSS 360 C: Software Development  Quality Assurance Techniques Winter 2017 Institute of Technology, UW-Tacoma 1232017 Slides by Wes J. Lloyd L8.2  Class subtypes can substitute for base types  Current formulation attributed to (Turing Award winner) Barbara Liskov Typesubtype ! Classsubclass All of Ts subtypes should preserve Ts contract February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.7 LISKOV SUBSTITUTION PRINCIPLE (LSP) A method that works on an instance of type T, should also work on any subtype of T  Clients should not be forced to depend on methods they do not use  Split large interfaces into smaller, more specific ones  ISP reduces coupling  High code coupling is correlates with higher software maintenance costs  Code is harder to modify, refactor, extend February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.8 INTERFACE SEGREGATION PRINCIPLE (ISP)  Coupling measures dependencies between subsystems  High coupling: changes to one subsystem will have high impact on the other subsystem  BAD! Require change of model, massive compilation  Low coupling: change in one subsystem does not affect any other subsystem - - GOOD!

--- Chunk 3 ---
Tokens: 217
Type: sentence-based
Text:
Require change of model, massive compilation  Low coupling: change in one subsystem does not affect any other subsystem - - GOOD! February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.9 ISP: COUPLING SUMMARY  Also called dependency injection  If two classes depend on each other, but their implementations may change, it is better if they depend on an abstract interface that is injected dynamically  Enables interface to change with changing original class  Code is not statically bound to the external dependency February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.10 DEPENDENCY INVERSION PRINCIPLE (DIP)  Example: one class (user code), makes use of a 3rd party library or framework (e.g.

--- Chunk 4 ---
Tokens: 454
Type: sentence-based
Text:
February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.9 ISP: COUPLING SUMMARY  Also called dependency injection  If two classes depend on each other, but their implementations may change, it is better if they depend on an abstract interface that is injected dynamically  Enables interface to change with changing original class  Code is not statically bound to the external dependency February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.10 DEPENDENCY INVERSION PRINCIPLE (DIP)  Example: one class (user code), makes use of a 3rd party library or framework (e.g. logging API)  Without dependency injection, the user class is dependent (coupled) to the 3rd party library or framework  Coupling becomes pandemic throughout the code  Its everywhere  If the 3rd party library goes defunct (company or group disbands), program code is now dependent on an unsupported library  Solution: Inject an abstract logging interface (which a 3rd party library or framework implements) February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.11 DIP: EXAMPLE  Traditional coupling to logging class (API)  Program must have access to a specific 3rd party library February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.12 DIP: JAVA EXAMPLE package com.example.e4.rcp.todo.parts; import java.util.logging.Logger; public class MyClass  private final static Logger logger; public MyClass(Logger logger)  this.logger  logger;  write an info log message logger.info(This is a log message.)

--- Chunk 5 ---
Tokens: 678
Type: sentence-based
Text:
logging API)  Without dependency injection, the user class is dependent (coupled) to the 3rd party library or framework  Coupling becomes pandemic throughout the code  Its everywhere  If the 3rd party library goes defunct (company or group disbands), program code is now dependent on an unsupported library  Solution: Inject an abstract logging interface (which a 3rd party library or framework implements) February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.11 DIP: EXAMPLE  Traditional coupling to logging class (API)  Program must have access to a specific 3rd party library February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.12 DIP: JAVA EXAMPLE package com.example.e4.rcp.todo.parts; import java.util.logging.Logger; public class MyClass  private final static Logger logger; public MyClass(Logger logger)  this.logger  logger;  write an info log message logger.info(This is a log message.) TCSS 360 C: Software Development  Quality Assurance Techniques Winter 2017 Institute of Technology, UW-Tacoma 1232017 Slides by Wes J. Lloyd L8.3  Using Java annotations to inject to dependent logger  Enables use of mock objects for testing  Can inject a mock object of a library not yet available  Another developer may be completing the code  Mock object implements generic interface February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.13 DIP: JAVA EXAMPLE - 2 public class MyPart  Inject private Logger logger;  inject class for database access Inject private DatabaseAccessClass dao; Inject public void createControls(Composite parent)  logger.info(UI will start to build); Label label  new Label(parent, SWT.NONE); label.setText(Eclipse 4); Text text  new Text(parent, SWT.NONE); text.setText(dao.getNumber());    Annotation location  where the dependency is injected  Constructor of the class (construction injection)  Field variable (field injection)  Parameters of a method (method injection)  Dependency injection occurs in same order: constructor, fields, method parameters  Frameworks exist to assist native dependency injection  AspectJ Aspect Oriented Programming February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.14 DIP: JAVA ANNOTATIONS  Language extension for dynamic dependency injection (AspectJ)  Less coupling that with Java annotations (interface)  Programming paradigm to increase modularity by separating cross- cutting concerns.

--- Chunk 6 ---
Tokens: 430
Type: sentence-based
Text:
TCSS 360 C: Software Development  Quality Assurance Techniques Winter 2017 Institute of Technology, UW-Tacoma 1232017 Slides by Wes J. Lloyd L8.3  Using Java annotations to inject to dependent logger  Enables use of mock objects for testing  Can inject a mock object of a library not yet available  Another developer may be completing the code  Mock object implements generic interface February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.13 DIP: JAVA EXAMPLE - 2 public class MyPart  Inject private Logger logger;  inject class for database access Inject private DatabaseAccessClass dao; Inject public void createControls(Composite parent)  logger.info(UI will start to build); Label label  new Label(parent, SWT.NONE); label.setText(Eclipse 4); Text text  new Text(parent, SWT.NONE); text.setText(dao.getNumber());    Annotation location  where the dependency is injected  Constructor of the class (construction injection)  Field variable (field injection)  Parameters of a method (method injection)  Dependency injection occurs in same order: constructor, fields, method parameters  Frameworks exist to assist native dependency injection  AspectJ Aspect Oriented Programming February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.14 DIP: JAVA ANNOTATIONS  Language extension for dynamic dependency injection (AspectJ)  Less coupling that with Java annotations (interface)  Programming paradigm to increase modularity by separating cross- cutting concerns. Behavior is declared into advices, similar to a classes - they define behavior (e.g.

--- Chunk 7 ---
Tokens: 227
Type: sentence-based
Text:
Behavior is declared into advices, similar to a classes - they define behavior (e.g. logging) without modifying main program. Pointcut specifications define where advices are to be automatically weaved into the main program  Example pointcut: log all function calls when the functions name begins with set. Behaviors not central to the business logic (such as logging) can be added to a program without changing or cluttering main program  AOP forms the basis for aspect-oriented software development. February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.15 DIP: ASPECT ORIENTED PROGRAMMING February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.16 COUPLING LEVELS  Content: one module relies on internal workings or data of another.

--- Chunk 8 ---
Tokens: 461
Type: sentence-based
Text:
February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.15 DIP: ASPECT ORIENTED PROGRAMMING February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.16 COUPLING LEVELS  Content: one module relies on internal workings or data of another. One class readsdepends on another internal variables  Common: two modules share global data; all modules using the global data are impacted by a change  External: two modules share an externally imposed data format, communication protocol, device interface  Control: one module controls the flow of another by passing it information on what to do  Stamp: modules share a common data structure, though may only sparsely use some of its fields  Data: modules share data through parameters passing  Message: modules communicate through message passing code not explicitly coupled, messages come through channels AspectJ (functionality injected at joinpoints) Java annotations (interface coupling)  Alternate solution to dependency inversion  Define an Adapter class  Serves to convert an existing API into one thats compatible with an existing caller February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.17 DIP: ADAPTER PATTERN February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.18 DIP: ADAPTER PATTERN public interface MediaPlayer  public void play(String audioType, String fileName);  public interface AdvancedMediaPlayer  public void playVlc(String fileName); public void playMp4(String fileName);  public class VlcPlayer implements AdvancedMediaPlayer .

--- Chunk 9 ---
Tokens: 818
Type: sentence-based
Text:
One class readsdepends on another internal variables  Common: two modules share global data; all modules using the global data are impacted by a change  External: two modules share an externally imposed data format, communication protocol, device interface  Control: one module controls the flow of another by passing it information on what to do  Stamp: modules share a common data structure, though may only sparsely use some of its fields  Data: modules share data through parameters passing  Message: modules communicate through message passing code not explicitly coupled, messages come through channels AspectJ (functionality injected at joinpoints) Java annotations (interface coupling)  Alternate solution to dependency inversion  Define an Adapter class  Serves to convert an existing API into one thats compatible with an existing caller February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.17 DIP: ADAPTER PATTERN February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.18 DIP: ADAPTER PATTERN public interface MediaPlayer  public void play(String audioType, String fileName);  public interface AdvancedMediaPlayer  public void playVlc(String fileName); public void playMp4(String fileName);  public class VlcPlayer implements AdvancedMediaPlayer . public class MediaAdapter implements MediaPlayer  AdvancedMediaPlayer advancedMusicPlayer; public MediaAdapter(String audioType) if(audioType.equalsIgnoreCase(vlc) ) advancedMusicPlayer  new VlcPlayer(); else if (audioType.equalsIgnoreCase(mp4)) advancedMusicPlayer  new Mp4Player();   Override public void play(String audioType, String fileName)  if(audioType.equalsIgnoreCase(vlc)) advancedMusicPlayer.playVlc(fileName);  else if(audioType.equalsIgnoreCase(mp4)) advancedMusicPlayer.playMp4(fileName);    Adapter Class Adapter pattern: Supports adding new media player features without changing dependent code TCSS 360 C: Software Development  Quality Assurance Techniques Winter 2017 Institute of Technology, UW-Tacoma 1232017 Slides by Wes J. Lloyd L8.4  Single Responsibility  A class should have one and only one reason to change  OpenClosed  Classes should be open for extension but closed for modification  Liskov Substitution  Substituting a subclass for a class should preserve correct program behavior  Interface Segregation  No client should depend on methods it does not use  Injecting Dependencies  Collaborating classes who implementation may vary at runtime should depend on an intermediate injected dependency February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.19 SOLID DESIGN GUIDELINES  Postgresql database persistence, heroku  http:faculty.washington.eduwlloydcoursestcss360tutori alsTCSS360_w2017_Tutorial_3.pdf February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L8.20 TUTORIAL 3 QUESTIONS February 1, 2017 TCSS360: Software Development and Quality Assurance Winter 2017 Institute of Technology, University of Washington - Tacoma L23.21

================================================================================
SOURCE: swebok-v4.pdf
TOTAL CHUNKS: 905
================================================================================

--- Chunk 0 ---
Tokens: 375
Type: sentence-based
Text:
EDITOR Hironori Washizaki Waseda University, IEEE Computer Society 2024 President-Elect, 2025 President Guide to the Software Engineering Body of Knowledge v4.0 A PROJECT OF THE IEEE COMPUTER SOCIETY Guide to the Software Engineering Body of Knowledge v4.0 EDITOR Hironori Washizaki, Waseda University (IEEE Computer Society 2024 President-Elect, 2025 President) Guide to the Software Engineering Body of Knowledge v4.0 iv SWEBOK  GUIDE V4.0 Copyright and Reprint Permissions. Educational or personal use of this material is permitted without fee provided such copies 1) are not made for profit or in lieu of purchasing copies for classes, and that this notice and a full citation to the original work appear on the first page of the copy and 2) do not imply IEEE endorsement of any third-party products or services. Permission to reprintrepublish this material for commercial, advertising or promotional purposes or for creating new collective works for resale or redistribution must be obtained from IEEE by writing to the IEEE Intellectual Property Rights Office, 445 Hoes Lane, Piscataway, NJ 08854-4141 or pubs-permissionsieee.org. Reference to any specific commercial products, process, or service does not imply endorsement by IEEE. Products, services, and company names mentioned in this document may be the trademarks of their respective owners. Mention in this document does not constitute an endorsement. The views and opinions expressed in this work do not necessarily reflect those of IEEE.

--- Chunk 1 ---
Tokens: 301
Type: sentence-based
Text:
The views and opinions expressed in this work do not necessarily reflect those of IEEE. IEEE makes this document available on an as is basis and makes no warranty, express or implied, as to the accuracy, capability, efficiency merchantability, or functioning of this document. In no event will IEEE be liable for any general, consequential, indirect, incidental, exemplary, or special damages, even if IEEE has been advised of the possibility of such damages. Copyright  20142024 IEEE. All rights reserved. Digital copies of SWEBOK Guide V4.0 may be downloaded free of charge for personal and academic use via www.swebok.org. IEEE COMPUTER SOCIETY STAFF FOR THIS PUBLICATION Melissa A. Russell, Executive Director Eric Berkowitz, Director of Membership Michelle Phon, Professional Education  Certification Program Coordinator Jennie Zhu-Mai, Creative Design Manager IEEE Computer Society Products and Services. The world-renowned IEEE Computer Society publishes, promotes, and distributes a wide variety of authoritative computer science and engineering journals, magazines, conference proceedings, and professional education products. Visit the Computer Society at www.computer.org for more information.

--- Chunk 2 ---
Tokens: 395
Type: sentence-based
Text:
Visit the Computer Society at www.computer.org for more information. v Table of Contents Foreword xxv Foreword to the 2014 Edition xxvi Foreword to the 2004 Edition xxvii Editor xxix Knowledge Area Editors xxix Contributing Editors xxx Steering Group xxxi Knowledge Area Editors of Previous SWEBOK Versions xxxi Review Team xxxiii Acknowledgements xxxiv IEEE Computer Society Presidents xxxiv Professional and Educational Activities Board, 2024 Membership xxxiv Motions Regarding the Approval of SWEBOK Guide V4.0 xxxv Motions Regarding the Approval of SWEBOK Guide V3.0 xxxv Motions Regarding the Approval of SWEBOK Guide 2004 Version xxxvi Introduction to the Guide xxxvii CHAPTER 01 Software Requirements 1-1 Introduction 1-1 1. Software Requirements Fundamentals 1-2 1.1. Definition of a Software Requirement 1-2 1.2. Categories of Software Requirements 1-3 1.3. Software Product Requirements and Software Project Requirements 1-3 1.4. Functional Requirements 1-4 1.5. Nonfunctional Requirements 1-4 1.6. Technology Constraints 1-4 1.7. Quality of Service Constraints 1-4 1.8. Why Categorize Requirements This Way? 1-5 1.9. System Requirements and Software Requirements 1-5 1.10. Derived Requirements 1-6 1.11. Software Requirements Activities 1-6 2. Requirements Elicitation 1-6 2.1. Requirements Sources 1-6 2.2. Common Requirements Elicitation Techniques 1-7 3. Requirements Analysis 1-8 3.1. Basic Requirements Analysis 1-8 3.2. Economics of Quality of Service Constraints 1-8 3.3. Formal Analysis 1-9 vi SWEBOK  GUIDE V4.0 3.4. Addressing Conflict in Requirements 1-10 4.

--- Chunk 3 ---
Tokens: 395
Type: sentence-based
Text:
Addressing Conflict in Requirements 1-10 4. Requirements Specification 1-10 4.1. Unstructured Natural Language Requirements Specification 1-11 4.2. Structured Natural Language Requirements Specification 1-12 4.3. Acceptance Criteria-Based Requirements Specification 1-12 4.4. Model-Based Requirements Specification 1-14 4.5. Additional Attributes of Requirement 1-14 4.6. Incremental and Comprehensive Requirements Specification 1-15 5. Requirements Validation 1-15 5.1. Requirements Reviews 1-15 5.2. Simulation and Execution 1-16 5.3. Prototyping 1-16 6. Requirements Management Activities 1-16 6.1. Requirements Scrubbing 1-16 6.2. Requirements Change Control 1-17 6.3. Scope Matching 1-17 7. Practical Considerations 1-17 7.1. Iterative Nature of the Requirements Process 1-17 7.2. Requirements Prioritization 1-17 7.3. Requirements Tracing 1-18 7.4. Requirements Stability and Volatility 1-19 7.5. Measuring Requirements 1-19 7.6. Requirements Process Quality and Improvement 1-19 8. Software Requirements Tools 1-20 8.1. Requirements Management Tools 1-20 8.2. Requirements Modeling Tools 1-20 8.3. Functional Test Case Generation Tools 1-20 Matrix of Topics vs. Reference Material 1-21 Further Readings 1-22 References 1-23 CHAPTER 02 Software Architecture 2-1 Introduction 2-1 1. Software Architecture Fundamentals 2-1 1.1. The Senses of Architecture 2-1 1.2. Stakeholders and Concerns 2-3 1.3. Uses of Architecture 2-4 2. Software Architecture Description 2-4 2.1. Architecture Views and Viewpoints 2-5 2.2. Architecture Patterns, Styles and Reference Architectures 2-6 2.3.

--- Chunk 4 ---
Tokens: 391
Type: sentence-based
Text:
Architecture Patterns, Styles and Reference Architectures 2-6 2.3. Architecture Description Languages and Architecture Frameworks 2-7 2.4. Architecture as Significant Decisions 2-7 3. Software Architecture Process 2-8 3.1. Architecture in Context 2-8 3.1.1. Relation of Architecture to Design 2-9 TABLE OF CONTENTS vii 3.2. Architectural Design 2-9 3.2.1. Architecture Analysis 2-9 3.2.2. Architecture Synthesis 2-9 3.2.3. Architecture Evaluation 2-10 3.3. Architecture Practices, Methods, and Tactics 2-10 3.4. Architecting in the Large 2-10 4. Software Architecture Evaluation 2-10 4.1. Goodness in Architecture 2-10 4.2. Reasoning about Architectures 2-11 4.3. Architecture Reviews 2-11 4.4. Architecture Metrics 2-11 Matrix of Topics vs. Reference Material 2-12 Further Readings 2-13 References 2-14 CHAPTER 03 Software Design 3-1 Introduction 3-1 1. Software Design Fundamentals 3-2 1.1. Design Thinking 3-2 1.2. Context of Software Design 3-2 1.3. Key Issues in Software Design 3-3 1.4. Software Design Principles 3-3 2. Software Design Processes 3-5 2.1. High-Level Design 3-6 2.2. Detailed Design 3-6 3. Software Design Qualities 3-6 3.1. Concurrency 3-6 3.2. Control and Event Handling 3-6 3.3. Data Persistence 3-7 3.4. Distribution of Components 3-7 3.5. Errors and Exception Handling, Fault Tolerance 3-7 3.6. Integration and Interoperability 3-7 3.7. Assurance, Security, and Safety 3-7 3.8. Variability 3-7 4. Recording Software Designs 3-7 4.1. Model-Based Design 3-8 4.2. Structural Design Descriptions 3-8 4.3. Behavioral Design Descriptions 3-9 4.4.

--- Chunk 5 ---
Tokens: 396
Type: sentence-based
Text:
Behavioral Design Descriptions 3-9 4.4. Design Patterns and Styles 3-10 4.5. Specialized and Domain-Specific Languages 3-10 4.6. Design Rationale 3-11 5. Software Design Strategies and Methods 3-11 5.1. General Strategies 3-11 5.2. Function-Oriented (or Structured) Design 3-11 5.3. Data-Centered Design 3-11 viii SWEBOK  GUIDE V4.0 5.4. Object-Oriented Design 3-11 5.5. User-Centered Design 3-12 5.6. Component-Based Design (CBD) 3-12 5.7. Event-Driven Design 3-12 5.8. Aspect-Oriented Design (AOD) 3-12 5.9. Constraint-Based Design 3-12 5.10. Domain-Driven Design 3-13 5.11. Other Methods 3-13 6. Software Design Quality Analysis and Evaluation 3-13 6.1. Design Reviews and Audits 3-13 6.2. Quality Attributes 3-13 6.3. Quality Analysis and Evaluation Techniques 3-13 6.4. Measures and Metrics 3-14 6.5. Verification, Validation, and Certification 3-14 Matrix of Topics vs. Reference Material 3-14 Further Readings 3-16 References 3-16 CHAPTER 04 Software Construction 4-1 Introduction 4-1 1. Software Construction Fundamentals 4-2 1.1. Minimizing Complexity 4-2 1.2. Anticipating and Embracing Change 4-2 1.3. Constructing for Verification 4-4 1.4. Reusing Assets 4-4 1.5. Applying Standards in Construction 4-4 2. Managing Construction 4-4 2.1. Construction in Life Cycle Models 4-4 2.2. Construction Planning 4-5 2.3. Construction Measurement 4-5 2.4. Managing Dependencies 4-5 3. Practical Considerations 4-6 3.1. Construction Design 4-6 3.2. Construction Languages 4-6 3.3. Coding 4-7 3.4. Construction Testing 4-7 3.5. Reuse in Construction 4-7 3.6. Construction Quality 4-8 3.7.

--- Chunk 6 ---
Tokens: 388
Type: sentence-based
Text:
Construction Quality 4-8 3.7. Integration 4-9 3.8. Cross-Platform Development and Migration 4-9 4. Construction Technologies 4-10 4.1. API Design and Use 4-10 4.2. Object-Oriented Runtime Issues 4-10 4.3. Parameterization, Templates, and Generics 4-10 4.4. Assertions, Design by Contract, and Defensive Programming 4-10 4.5. Error Handling, Exception Handling, and Fault Tolerance 4-11 TABLE OF CONTENTS ix 4.6. Executable Models 4-11 4.7. State-Based and Table-Driven Construction Techniques 4-11 4.8. Runtime Configuration and Internationalization 4-12 4.9. Grammar-Based Input Processing 4-12 4.10. Concurrency Primitives 4-12 4.11. Middleware 4-12 4.12. Construction Methods for Distributed and Cloud-Based Software 4-13 4.13. Constructing Heterogeneous Systems 4-13 4.14. Performance Analysis and Tuning 4-13 4.15. Platform Standards 4-13 4.16. Test-First Programming 4-14 4.17. Feedback Loop for Construction 4-14 5. Software Construction Tools 4-14 5.1. Development Environments 4-14 5.2. Visual Programming and Low-CodeZero-Code Platforms 4-14 5.3. Unit Testing Tools 4-15 5.4. Profiling, Performance Analysis, and Slicing Tools 4-15 Matrix of Topics vs. Reference Material 4-15 Further Readings 4-18 References 4-18 CHAPTER 05 Software Testing 5-1 Introduction 5-1 1. Software Testing Fundamentals 5-3 1.1. Faults vs. Failures 5-3 1.2. Key Issues 5-4 1.2.1. Test Case Creation 5-4 1.2.2. Test Selection and Adequacy Criteria 5-4 1.2.3. PrioritizationMinimization 5-4 1.2.4. Purpose of Testing 5-4 1.2.5. Assessment and Certification 5-4 1.2.6.

--- Chunk 7 ---
Tokens: 393
Type: sentence-based
Text:
Assessment and Certification 5-4 1.2.6. Testing for Quality AssuranceImprovement 5-4 1.2.7. The Oracle Problem 5-4 1.2.8. Theoretical and Practical Limitations 5-5 1.2.9. The Problem of Infeasible Paths 5-5 1.2.10. Testability 5-5 1.2.11. Test Execution and Automation 5-5 1.2.12. Scalability 5-5 1.2.13. Test Effectiveness 5-5 1.2.14. Controllability, Replication, and Generalization 5-5 1.2.15. Off-Line vs. Online Testing 5-6 1.3. Relationship of Testing to Other Activities 5-6 2. Test Levels 5-6 2.1. The Target of the Test 5-6 2.1.1. Unit Testing 5-6 2.1.2. Integration Testing 5-7 x SWEBOK  GUIDE V4.0 2.1.3. System Testing 5-7 2.1.4. Acceptance Testing 5-7 2.2. Objectives of Testing 5-7 2.2.1. Conformance Testing 5-7 2.2.2. Compliance Testing 5-8 2.2.3. Installation Testing 5-8 2.2.4. Alpha and Beta Testing 5-8 2.2.5. Regression Testing 5-8 2.2.6. Prioritization Testing 5-8 2.2.7. Non-functional Testing 5-8 2.2.8. Security Testing 5-9 2.2.9. Privacy Testing 5-9 2.2.10. Interface and Application Program Interface (API) Testing 5-10 2.2.11. Configuration Testing 5-10 2.2.12. Usability and Human-Computer Interaction Testing 5-10 3. Test Techniques 5-10 3.1. Specification-Based Techniques 5-10 3.1.1. Equivalence Partitioning 5-11 3.1.2. Boundary-Value Analysis 5-11 3.1.3. Syntax Testing 5-11 3.1.4. Combinatorial Test Techniques 5-11 3.1.5. Decision Table 5-11 3.1.6. Cause-Effect Graphing 5-11 3.1.7. State Transition Testing 5-12 3.1.8. Scenario-Based Testing 5-12 3.1.9. Random Testing 5-12 3.1.10. Evidence-Based 5-12 3.1.11. Forcing Exception 5-12 3.2.

--- Chunk 8 ---
Tokens: 395
Type: sentence-based
Text:
Forcing Exception 5-12 3.2. Structure-Based Test Techniques 5-13 3.2.1. Control Flow Testing 5-13 3.2.2. Data Flow Testing 5-13 3.2.3. Reference Models for Structure-Based Test Techniques 5-13 3.3. Experience-Based Techniques 5-13 3.3.1. Error Guessing 5-13 3.3.2. Exploratory Testing 5-13 3.3.3. Further Experience-Based Techniques 5-14 3.4. Fault-Based and Mutation Techniques 5-14 3.5. Usage-Based Techniques 5-15 3.5.1. Operational Profile 5-15 3.5.2. User Observation Heuristics 5-15 3.6. Techniques Based on the Nature of the Application 5-15 3.7. Selecting and Combining Techniques 5-16 3.7.1. Combining Functional and Structural 5-16 3.7.2. Deterministic vs. Random 5-16 3.8. Techniques Based on Derived Knowledge 5-16 4. Test-Related Measures 5-16 4.1. Evaluation of the SUT 5-17 4.1.1. SUT Measurements that Aid in Planning and Designing Tests 5-17 TABLE OF CONTENTS xi 4.1.2. Fault Types, Classification and Statistics 5-17 4.1.3. Fault Density 5-17 4.1.4. Life Test, Reliability Evaluation 5-17 4.1.5. Reliability Growth Models 5-17 4.2. Evaluation of the Tests Performed 5-18 4.2.1. Fault Injection 5-18 4.2.2. Mutation Score 5-18 4.2.3. Comparison and Relative Effectiveness of Different Techniques 5-18 5. Test Process 5-18 5.1. Practical Considerations 5-19 5.1.1. AttitudesEgoless Programming 5-19 5.1.2. Test Guides and Organizational Process 5-19 5.1.3. Test Management and Dynamic Test Processes 5-19 5.1.4. Test Documentation 5-19 5.1.5. Test Team 5-20 5.1.6. Test Process Measures 5-20 5.1.7. Test Monitoring and Control 5-20 5.1.8. Test Completion 5-20 5.1.9.

--- Chunk 9 ---
Tokens: 387
Type: sentence-based
Text:
Test Completion 5-20 5.1.9. Test Reusability 5-21 5.2. Test Sub-Processes and Activities 5-21 5.2.1. Test Planning Process 5-21 5.2.2. Test Design and Implementation 5-21 5.2.3. Test Environment Set-up and Maintenance 5-21 5.2.4. Controlled Experiments and Test Execution 5-22 5.2.5. Test Incident Reporting 5-22 5.3. Staffing 5-22 6. Software Testing in the Development Processes and the Application Domains 5-23 6.1. Testing Inside Software Development Processes 5-23 6.1.1. Testing in Traditional Processes 5-23 6.1.2. Testing in Line with Shift-Left Movement 5-23 6.2. Testing in the Application Domains 5-24 7. Testing of and Testing Through Emerging Technologies 5-26 7.1. Testing of Emerging Technologies 5-26 7.2. Testing Through Emerging Technologies 5-27 8. Software Testing Tools 5-29 8.1. Testing Tool Support and Selection 5-29 8.2. Categories of Tools 5-29 Matrix of Topics vs. Reference Material 5-31 References 5-34 CHAPTER 06 Software Engineering Operations 6-1 Introduction 6-1 1. Software Engineering Operations Fundamentals 6-3 1.1. Definition of Software Engineering Operations 6-3 1.2. Software Engineering Operations Processes 6-4 xii SWEBOK  GUIDE V4.0 1.3. Software Installation 6-5 1.4. Scripting and Automating 6-5 1.5. Effective Testing and Troubleshooting 6-5 1.6. Performance, Reliability and Load Balancing 6-6 2. Software Engineering Operations Planning 6-6 2.1. Operations Plan and Supplier Management 6-6 2.1.1. Operations Plan 6-6 2.1.2. Supplier Management 6-7 2.2. Development and Operational Environments 6-7 2.3.

--- Chunk 10 ---
Tokens: 393
Type: sentence-based
Text:
Development and Operational Environments 6-7 2.3. Software Availability, Continuity, and Service Levels 6-8 2.4. Software Capacity Management 6-8 2.5. Software Backup, Disaster Recovery, and Failover 6-8 2.6. Software and Data Safety, Security, Integrity, Protection, and Controls 6-9 3. Software Engineering Operations Delivery 6-9 3.1. Operational Testing, Verification, and Acceptance 6-9 3.2. DeploymentRelease Engineering 6-10 3.3. Rollback and Data Migration 6-10 3.4. Change Management 6-11 3.5. Problem Management 6-11 4. Software Engineering Operations Control 6-11 4.1. Incident Management 6-11 4.2. Monitor, Measure, Track, and Review 6-11 4.3. Operations Support 6-12 4.4. Operations Service Reporting 6-12 5. Practical Considerations 6-12 5.1. Incident and Problem Prevention 6-12 5.2. Operational Risk Management 6-12 5.3. Automating Software Engineering Operations 6-12 5.4. Software Engineering Operations for Small Organizations 6-13 6. Software Engineering Operations Tools 6-13 6.1. Containers and Virtualization 6-13 6.2. Deployment 6-13 6.3. Automated Test 6-14 6.4. Monitoring and Telemetry 6-14 Matrix of Topics vs. Reference Material 6-14 References 6-15 CHAPTER 07 Software Maintenance 7-1 Introduction 7-1 1. Software Maintenance Fundamentals 7-2 1.1. Definitions and Terminology 7-2 1.2. Nature of Software Maintenance 7-2 1.3. Need for Software Maintenance 7-3 1.4. Majority of Maintenance Costs 7-3 1.5. Evolution of Software 7-3 TABLE OF CONTENTS xiii 1.6. Categories of Software Maintenance 7-4 2. Key Issues in Software Maintenance 7-5 2.1.

--- Chunk 11 ---
Tokens: 395
Type: sentence-based
Text:
Key Issues in Software Maintenance 7-5 2.1. Technical Issues 7-5 2.1.1 Limited Understanding 7-5 2.1.2 Testing 7-5 2.1.3 Impact Analysis 7-6 2.1.4 Maintainability 7-6 2.2. Management Issues 7-7 2.2.1. Alignment with Organizational Objectives 7-7 2.2.2. Staffing 7-7 2.2.3. Process 7-8 2.2.4. Supplier Management 7-8 2.2.5. Organizational Aspects of Maintenance 7-8 2.3. Software Maintenance Costs 7-9 2.3.1. Technical Debt Cost Estimation 7-9 2.3.2. Maintenance Cost Estimation 7-9 2.4. Software Maintenance Measurement 7-10 3. Software Maintenance Processes 7-11 3.1. Software Maintenance Processes 7-11 3.2. Software Maintenance Activities and Tasks 7-11 3.2.1. Supporting and Monitoring Activities 7-12 3.2.2. Planning Activities 7-12 3.2.3. Configuration Management 7-13 3.2.4. Software Quality 7-13 4. Software Maintenance Techniques 7-13 4.1. Program Comprehension 7-13 4.2. Software Reengineering 7-13 4.3. Reverse Engineering 7-14 4.4. Continuous Integration, Delivery, Testing, and Deployment 7-14 4.5. Visualizing Maintenance 7-15 5. Software Maintenance Tools 7-15 Matrix of Topics vs. Reference Material 7-16 Further Readings 7-17 References 7-17 CHAPTER 08 Software Configuration Management 8-1 Introduction 8-1 1. Management of the SCM Process 8-2 1.1. Organizational Context for SCM 8-2 1.2. Constraints and Guidance for the SCM Process 8-3 1.3. Planning for SCM 8-3 1.3.1. SCM Organization and Responsibilities 8-4 1.3.2. SCM Resources and Schedules 8-4 1.3.3. Tool Selection and Implementation 8-4 1.3.4. VendorSubcontractor Control 8-5 xiv SWEBOK  GUIDE V4.0 1.3.5.

--- Chunk 12 ---
Tokens: 399
Type: sentence-based
Text:
VendorSubcontractor Control 8-5 xiv SWEBOK  GUIDE V4.0 1.3.5. Interface Control 8-5 1.4. SCM Plan 8-5 1.5. Monitoring of Software Configuration Management 8-5 1.5.1 SCM Measures and Measurement 8-6 1.5.2 In-Process Audits of SCM 8-6 2. Software Configuration Identification 8-6 2.1. Identifying Items to Be Controlled 8-6 2.1.1 Software Configuration 8-6 2.1.2 Software Configuration Item 8-6 2.2. Configuration Item Identifiers and Attributes 8-7 2.3. Baseline Identification 8-7 2.4. Baseline Attributes 8-7 2.5. Relationships Scheme Definition 8-7 2.6. Software Libraries 8-8 3. Software Configuration Change Control 8-9 3.1. Requesting, Evaluating, and Approving Software Changes 8-9 3.1.1 Software Configuration Control Board 8-10 3.1.2 Software Change Request Process 8-10 3.1.3 Software Change Request Forms Definition 8-10 3.2. Implementing Software Changes 8-10 3.3. Deviations and Waivers 8-11 4. Software Configuration Status Accounting 8-11 4.1. Software Configuration Status Information 8-11 4.2. Software Configuration Status Reporting 8-11 5. Software Configuration Auditing 8-12 5.1. Software Functional Configuration Audit 8-12 5.2. Software Physical Configuration Audit 8-12 5.3. In-Process Audits of a Software Baseline 8-12 6. Software Release Management and Delivery 8-13 6.1. Software Building 8-13 6.2. Software Release Management 8-13 7. Software Configuration Management Tools 8-14 Matrix of Topics vs. Reference Material 8-15 Further Readings 8-16 References 8-17 CHAPTER 09 Software Engineering Management 9-1 Introduction 9-1 1. Initiation and Scope Definition 9-6 1.1.

--- Chunk 13 ---
Tokens: 391
Type: sentence-based
Text:
Initiation and Scope Definition 9-6 1.1. Determination and Negotiation of Requirements 9-6 1.2. Feasibility Analysis 9-6 1.3. Process for the Review and Revision of Requirements 9-7 2. Software Project Planning 9-7 2.1. Process Planning 9-8 2.2. Determine Deliverables 9-8 TABLE OF CONTENTS xv 2.3. Effort, Schedule, and Cost Estimation 9-8 2.4. Resource Allocation 9-9 2.5. Risk Management 9-9 2.6. Quality Management 9-9 2.7. Plan Management 9-10 3. Software Project Execution 9-11 3.1. Implementation of Plans 9-11 3.2. Software Acquisition and Supplier Contract Management 9-11 3.3. Implementation of Measurement Process 9-12 3.4. Monitor Process 9-12 3.5. Control Process 9-12 3.6. Reporting 9-13 4. Software Review and Evaluation 9-13 4.1. Determining Satisfaction of Requirements 9-13 4.2. Reviewing and Evaluating Performance 9-13 5. Closure 9-13 5.1. Determining Closure 9-13 5.2. Closure Activities 9-14 6. Software Engineering Measurement 9-14 6.1. Establish and Sustain Measurement Commitment 9-14 6.2. Plan the Measurement Process 9-15 6.3. Perform the Measurement Process 9-15 6.4. Evaluate Measurement 9-16 7. Software Engineering Management Tools 9-16 Matrix of Topics vs. Reference Material 9-17 Further Readings 9-18 References 9-18 CHAPTER 10 Software Engineering Process 10-1 Introduction 10-1 1. Software Engineering Process Fundamentals 10-1 1.1. Introduction 10-1 1.2. Software Engineering Process Definition 10-3 2. Life Cycles 10-3 2.1. Life Cycle Definition, Process Categories, and Terminology 10-3 2.2. Rationale for Life Cycles 10-4 2.3.

--- Chunk 14 ---
Tokens: 389
Type: sentence-based
Text:
Rationale for Life Cycles 10-4 2.3. The Concepts of Process Models and Life Cycle Models 10-5 2.4. Some Paradigms for Development Life Cycle Models 10-5 2.5. Development Life Cycle Models and Their Engineering Dimension 10-6 2.6. The Management of SLCPs 10-7 2.7. Software Engineering Process Management 10-8 2.8. Software Life Cycle Adaptation 10-8 2.9. Practical Considerations 10-8 2.10. Software Process Infrastructure, Tools, Methods 10-9 2.11. Software Engineering Process Monitoring and xvi SWEBOK  GUIDE V4.0 its Relationship with the Software Product 10-9 3. Software Process Assessment and Improvement 10-9 3.1. Overview of Software Process Assessment and Improvement 10-9 3.2. Goal-Question-Metric (GQM) 10-10 3.3. Framework-Based Methods 10-10 3.4. Process Assessment and Improvement in Agile 10-10 Matrix of Topics vs. Reference Material 10-10 References 10-11 CHAPTER 11 Software Engineering Models and Methods 11-1 Introduction 11-1 1. Modeling 11-1 1.1. Modeling Principles 11-2 1.2. Properties and Expression of Models 11-3 1.3. Syntax, Semantics, and Pragmatics 11-3 1.4. Preconditions, Postconditions, and Invariants 11-4 2. Types of Models 11-4 2.1. Structural Modeling 11-5 2.2. Behavioral Modeling 11-5 3. Analysis of Models 11-5 3.1. Analyzing for Completeness 11-6 3.2. Analyzing for Consistency 11-6 3.3. Analyzing for Correctness 11-6 3.4. Analyzing for Traceability 11.6 3.5. Analyzing for Interaction 11-6 4. Software Engineering Methods 11-7 4.1. Heuristic Methods 11-7 4.2. Formal Methods 11-8 4.3. Prototyping Methods 11-9 4.4.

--- Chunk 15 ---
Tokens: 396
Type: sentence-based
Text:
Prototyping Methods 11-9 4.4. Agile Methods 11-10 Matrix of Topics vs. Reference Material 11-11 References 11-12 CHAPTER 12 Software Quality 12-1 Introduction 12-1 1. Software Quality Fundamentals 12-3 1.1. Software Engineering Culture and Ethics 12-3 1.2. Value and Costs of Quality 12-4 1.3. Standards, Models, and Certifications 12-4 1.4. Software Dependability and Integrity Levels 12-5 1.4.1 Dependability 12-5 1.4.2. Integrity Levels of Software 12-6 TABLE OF CONTENTS xvii 2. Software Quality Management Process 12-6 2.1. Software Quality Improvement 12-7 2.2. Plan Quality Management 12-7 2.3. Evaluate Quality Management 12-8 2.3.1 Software Quality Measurement 12-8 2.4. Perform Corrective and Preventive Actions 12-9 2.4.1. Defect Characterization 12-9 3. Software Quality Assurance Process 12-10 3.1. Prepare for Quality Assurance 12-10 3.2. Perform Process Assurance 12-10 3.3. Perform Product Assurance 12-11 3.4. VV and Testing 12-12 3.4.1 Static Analysis Techniques 12-13 3.4.2. Dynamic Analysis Techniques 12-13 3.4.3. Formal Analysis Techniques 12-13 3.4.4. Software Quality Control and Testing 12-13 3.4.5. Technical Reviews and Audits 12-14 4. Software Quality Tools 12-15 Matrix of Topics vs. Reference Material 12-15 Further Readings 12-16 References 12-17 CHAPTER 13 Software Security 13-1 Introduction 13-1 1. Software Security Fundamentals 13-1 1.1. Software Security 13-1 1.2. Information Security 13-1 1.3. Cybersecurity 13-2 2. Security Management and Organization 13-2 2.1. Capability Maturity Model 13-2 2.2. Information Security Management System 13-2 2.3.

--- Chunk 16 ---
Tokens: 400
Type: sentence-based
Text:
Information Security Management System 13-2 2.3. Agile Practice for Software Security 13-3 3. Software Security Engineering and Processes 13-3 3.1. Security Engineering and Secure Development Life Cycle (SDLC) 13-3 3.2. Common Criteria for Information Technology Security Evaluation 13-3 4. Security Engineering for Software Systems 13-3 4.1. Security Requirements 13-3 4.2. Security Design 13-4 4.3. Security Patterns 13-4 4.4. Construction for Security 13-4 4.5. Security Testing 13-5 4.6. Vulnerability Management 13-5 5. Software Security Tools 13-5 5.1. Security Vulnerability Checking Tools 13-5 5.2. Penetration Testing Tools 13-6 xviii SWEBOK  GUIDE V4.0 6. Domain-Specific Software Security 13-6 6.1. Security for Container and Cloud 13-6 6.2. Security for IoT Software 13-6 6.3. Security for Machine Learning-Based Application 13-6 Matrix of Topics vs. Reference Material 13-7 Further Readings 13-8 References 13-8 CHAPTER 14 Software Engineering Professional Practice 14-1 Introduction 14-1 1. Professionalism 14-2 1.1. Accreditation, Certification and Qualification, and Licensing 14-2 1.1.1. Accreditation 14-2 1.1.2. Certification and Qualification 14-3 1.1.3. Licensing 14-3 1.2. Codes of Ethics and Professional Conduct 14-3 1.3. Nature and Role of Professional Societies 14-4 1.4. Nature and Role of Software Engineering Standards 14-4 1.5. Economic Impact of Software 14-5 1.6. Employment Contracts 14-5 1.7. Legal Issues 14-6 1.7.1. Standards 14-6 1.7.2. Trademarks 14-6 1.7.3. Patents 14-6 1.7.4. Copyrights 14-6 1.7.5. Trade Secrets 14-6 1.7.6. Professional Liability 14-7 1.7.7.

--- Chunk 17 ---
Tokens: 397
Type: sentence-based
Text:
Professional Liability 14-7 1.7.7. Legal Requirements 14-7 1.7.8. Trade Compliance 14-7 1.7.9. Cybercrime 14-7 1.7.10. Data Privacy 14-8 1.8. Documentation 14-8 1.9. Trade-Off Analysis 14-9 2. Group Dynamics and Psychology 14-9 2.1. Dynamics of Working in TeamsGroups 14-9 2.2. Individual Cognition 14-10 2.3. Dealing with Problem Complexity 14-10 2.4. Interacting with Stakeholders 14-10 2.5. Dealing with Uncertainty and Ambiguity 14-11 2.6. Dealing with Equity, Diversity, and Inclusivity 14-11 3. Communication Skills 14-11 3.1. Reading, Understanding, and Summarizing 14-12 3.2. Writing 14-12 3.3. Team and Group Communication 14-12 3.4. Presentation Skills 14-12 TABLE OF CONTENTS xix Matrix of Topics vs. Reference Material 14-13 Further Readings 14-14 References 14-14 CHAPTER 15 Software Engineering Economics 15-1 Introduction 15-1 1. Software Engineering Economics Fundamentals 15-3 1.1. Proposals 15-3 1.2. Cash Flow 15-3 1.3. Time-Value of Money 15-3 1.4. Equivalence 15-4 1.5. Bases for Comparison 15-4 1.6. Alternatives 15-4 1.7. Intangible Assets 15-4 1.8. Business Model 15-5 2. The Engineering Decision-Making Process 15-5 2.1. Process Overview 15-5 2.2. Understand the Real Problem 15-5 2.3. Identify All Reasonable Technically Feasible Solutions 15-6 2.4. Define the Selection Criteria 15-6 2.5. Evaluate Each Alternative Against the Selection Criteria 15-6 2.6. Select the Preferred Alternative 15-6 2.7. Monitor the Performance of the Selected Alternative 15-7 3. For-Profit Decision-Making 15-7 3.1. Minimum Acceptable Rate of Return 15-7 3.2. Economic Life 15-7 3.3.

--- Chunk 18 ---
Tokens: 397
Type: sentence-based
Text:
Economic Life 15-7 3.3. Planning Horizon 15-8 3.4. Replacement Decisions 15-8 3.5. Retirement Decisions 15-9 3.6. Advanced For-Profit Decision Considerations 15-9 4. Nonprofit Decision-Making 15-9 4.1. Benefit-Cost Analysis 15-9 4.2. Cost-Effectiveness Analysis 15-9 5. Present Economy Decision-Making 15-9 5.1. Break-Even Analysis 15-9 5.2. Optimization Analysis 15-9 6. Multiple-Attribute Decision-Making 15-10 6.1. Compensatory Techniques 15-10 6.2. Non-Compensatory Techniques 15-10 7. Identifying and Characterizing Intangible Assets 15-10 7.1. Identify Processes and Define Business Goals 15-10 7.2. Identify Intangible Assets Linked with Business Goal 15-11 7.3. Identify Software Products That Support Intangible Assets 15-11 7.4. Define and Measure Indicators 15-11 7.5. Intangible Asset Characterization 15-11 xx SWEBOK  GUIDE V4.0 7.6. Link Specific Intangible Assets with the Business Model 15-13 7.7. Decision-Making 15-13 8. Estimation 15-13 8.1. Expert Judgment 15-14 8.2. Analogy 15-15 8.3. Decomposition 15-15 8.4. Parametric 15-15 8.5. Multiple Estimates 15-15 9. Practical Considerations 15-16 9.1. Business Case 15-16 9.2. Multiple-Currency Analysis 15-16 9.3. Systems Thinking 15-16 10. Related Concepts 15-16 10.1. Accounting 15-16 10.2. Cost and Costing 15-16 10.3. Finance 15-17 10.4. Controlling 15-17 10.5. Efficiency and Effectiveness 15-17 10.6. Productivity 15-18 10.7. Product or Service 15-18 10.8. Project 15-18 10.9. Program 15-18 10.10. Portfolio 15-18 10.11. Product Life Cycle 15-19 10.12. Project Life Cycle 15-19 10.13. Price and Pricing 15-19 10.14.

--- Chunk 19 ---
Tokens: 399
Type: sentence-based
Text:
Price and Pricing 15-19 10.14. Prioritization 15-19 Matrix of Topics vs. Reference Material 15-20 Further Readings 15-22 References 15-22 CHAPTER 16 Computing Foundations 16-1 Introduction 16-2 1. Basic Concepts of a System or Solution 16-2 2. Computer Architecture and Organization 16-3 2.1. Computer Architecture 16-3 2.2. Types of Computer Architectures 16-3 2.2.1. Von Neumann Architecture 16-3 2.2.2. Harvard Architecture 16-4 2.2.3. Instruction Set Architecture 16-4 2.2.4. Flynns Architecture or Taxonomy 16-5 2.2.5. System Architecture 16-5 2.3. Microarchitecture or Computer Organization 16-5 2.3.1. Arithmetic Logic Unit 16-5 2.3.2. Memory Unit 16-6 TABLE OF CONTENTS xxi 2.3.3. InputOutput Devices 16-6 2.3.4. Control Unit 16-6 3. Data Structures and Algorithms 16-6 3.1. Types of Data Structures 16-6 3.2. Operations on Data Structures 16-7 3.3. Algorithms and Attributes of Algorithms 16-7 3.4. Algorithm Complexity 16-8 3.5. Measurement of Complexity 16-8 3.6. Designing Algorithms 16-8 3.7. Sorting Techniques 16-9 3.8. Searching Techniques 16-10 3.9. Hashing 16-10 4. Programming Fundamentals and Languages 16-10 4.1. Programming Language Types 16-10 4.2. Programming Syntax, Semantics, Type Systems 16-11 4.3. Subprograms and Coroutines 16-11 4.4. Object-Oriented Programming 16-12 4.5. Distributed Programming and Parallel Programming 16-13 4.6. Debugging 16-13 4.7. Standards and Guidelines 16-13 5. Operating Systems 16-15 5.1. Processor Management 16-15 5.2. Memory Management 16-16 5.3. Device Management 16-16 5.4. Information Management 16-16 5.5. Network Management 16-16 6.

--- Chunk 20 ---
Tokens: 399
Type: sentence-based
Text:
Network Management 16-16 6. Database Management 16-17 6.1. Schema 16-17 6.2. Data Models and Storage Models 16-17 6.3. Database Management Systems 16-18 6.4. Relational Database Management Systems and Normalization 16-18 6.5. Structured Query Language 16-19 6.6. Data Mining and Data Warehousing 16-19 6.7. Database Backup and Recovery 16-20 7. Computer Networks and Communications 16-20 7.1. Types of Computer Networks 16-20 7.2. Layered Architectures of Networks 16-21 7.3. Open Systems Interconnection Model 16-21 7.4. Encapsulation and Decapsulation 16-22 7.5. Application Layer Protocols 16-22 7.6. Design Techniques for Reliable and Efficient Network 16-22 7.7. Internet Protocol Suite 16-23 7.8. Wireless and Mobile Networks 16-23 7.9. Security and Vulnerabilities 16-23 8. User and Developer Human Factors 16-24 8.1. User Human Factors 16-24 8.2. Developer Human Factors 16-24 9. Artificial Intelligence and Machine Learning 16-25 xxii SWEBOK  GUIDE V4.0 9.1. Reasoning 16-25 9.2. Learning 16-26 9.3. Models 16-26 9.4. Perception and Problem-Solving 16-27 9.5. Natural Language Processing 16-27 9.6. AI and Software Engineering 16-27 Matrix of Topics vs. Reference Material 16-28 References 16-32 CHAPTER 17 Mathematical Foundations 17-1 Introduction 17-1 1. Basic Logic 17-1 1.1. Propositional Logic 17-1 1.2. Predicate Logic 17-3 2. Proof Techniques 17-3 2.1. Direct Proof 17-4 2.2. Proof by Contradiction 17-4 2.3. Proof by Induction 17-4 2.4. Proof by Example 17-5 3. Set, Relation, Function 17-5 3.1. Set Operations 17-6 3.2. Properties of Sets 17-6 3.3. Relation and Function 17-7 4.

--- Chunk 21 ---
Tokens: 391
Type: sentence-based
Text:
Relation and Function 17-7 4. Graph and Tree 17-8 4.1. Graph 17-8 4.2. Tree 17-10 5. Finite-State Machine 17-12 6. Grammar 17-13 6.1. Language Recognition 17-14 7. Number Theory 17-14 7.1. Types of Numbers 17-15 7.2. Divisibility 17-15 7.3. Prime Number 17-15 7.4. Greatest Common Divisor 17-16 8. Basics of Counting 17-16 9. Discrete Probability 17-17 10. Numerical Precision, Accuracy, and Error 17-18 11. Algebraic Structures 17-19 11.1. Group 17-19 11.2. Ring 17-20 12. Engineering Calculus 17-21 13. New Advancements 17-21 13.1. Computational Neurosciences 17-21 13.2. Genomics 17-21 Matrix of Topics vs. Reference Material 17-22 References 17-22 TABLE OF CONTENTS xxiii CHAPTER 18 Engineering Foundations 18-1 Introduction 18-1 1. The Engineering Process 18-1 2. Engineering Design 18-2 2.1. Engineering Design in Engineering Education 18-2 2.2. Design as a Problem-Solving Activity 18-3 3. Abstraction and Encapsulation 18-3 3.1. Levels of Abstraction 18-4 3.2. Encapsulation 18-4 3.3. Hierarchy 18-4 3.4. Alternate Abstractions 18-4 4. Empirical Methods and Experimental Techniques 18-4 4.1. Designed Experiment 18-5 4.2. Observational Study 18-5 4.3. Retrospective Study 18-5 5. Statistical Analysis 18-5 5.1. Unit of Analysis (Sampling Units), Population, and Sample 18-5 5.2. Correlation and Regression 18-8 6. Modeling, Simulation, and Prototyping 18-8 6.1. Modeling 18-8 6.2. Simulation 18-9 6.3. Prototyping 18-9 7. Measurement 18-10 7.1. Levels (Scales) of Measurement 18-10 7.2. Implications of Measurement Theory for Programming Languages 18-12 7.3.

--- Chunk 22 ---
Tokens: 398
Type: sentence-based
Text:
Implications of Measurement Theory for Programming Languages 18-12 7.3. Direct and Derived Measures 18-13 7.4. Reliability and Validity 18-14 7.5. Assessing Reliability 18-14 7.6. Goal-Question-Metric Paradigm: Why Measure? 18-15 8. Standards 18-15 9. Root Cause Analysis 18-16 9.1. Root Cause Analysis Techniques 18-16 9.2. Root CauseBased Improvement 18-17 10. Industry 4.0 and Software Engineering 18-17 Matrix of Topics vs. Reference Material 18-18 Further Readings 18-19 References 18-20 APPENDIX A Knowledge Area Description Specifications A-1 Introduction A-1 The Swebok Guide is a Foundational Document for the IEEE Computer Society Suite of Software Engineering Products A-1 xxiv SWEBOK  GUIDE V4.0 Baseline and Change Control A-1 Criteria and Requirements for the Breakdown of Topics Within a Knowledge Area A-2 Criteria and Requirements for Describing Topics A-2 Criteria and Requirements for Reference Material A-2 Common Structure A-4 What Do We Mean by Generally Recognized Knowledge? A-4 Length of KA Description A-5 Important Related Documents A-5 Other Detailed Guidelines A-6 Editing A-6 Release of Copyright A-6 References A-6 APPENDIX B IEEE and ISOIEC Standards Supporting the Software Engineering Body of Knowledge (SWEBOK) B-1 1. Overview B-1 1.1. The SWEBOK and standards B-1 1.2. Types of Standards B-2 1.3. Sources of Software Engineering Standards B-2 2. The software engineering standards landscape B-3 3. Life cycle process standards B-4 4. Extensions and specialized applications of ISOIECIEEE 12207 B-5 4.1. Explanations of concepts and several processes B-5 4.2.

--- Chunk 23 ---
Tokens: 366
Type: sentence-based
Text:
Explanations of concepts and several processes B-5 4.2. More specialized extensions B-8 4.3. SoS standards B-9 5. Single Process Standards B-9 6. Standards for product line, methods, and tools B-9 7. Process assessment standards B-10 8. Professional Skills and Knowledge Standards B-11 9. Selected Software Engineering Standards B-11 APPENDIX C Consolidated Reference List C-1 Consolidated Reference List C-1 FOREWORD The Guide to the Software Engineering Body of Knowledge (SWEBOK Guide), published by the IEEE Computer Society (IEEE CS), represents the current state of generally accepted, con- sensus-based knowledge emanating from the interplay between software engineering theory and practice. Its objectives include the provision of guidance for learners, researchers, and prac- titioners to identify and share a common understanding of generally accepted knowledge in software engineering, defining the boundary between software engineering and related disci- plines, and providing a foundation for certifications and educational curricula. The origins of the Guide go back to the early 2000s. Much like the software engineering dis- cipline, the Guide has continued to evolve over the last 20 years to reflect societys industrial, educational, social, technical, and technological changes. Publication of the 2014 version of the Guide (SWEBOK Guide V3) was a significant milestone in establishing software engineering as a recognized engineering discipline.

--- Chunk 24 ---
Tokens: 371
Type: sentence-based
Text:
Publication of the 2014 version of the Guide (SWEBOK Guide V3) was a significant milestone in establishing software engineering as a recognized engineering discipline. The goal of developing this update (SWEBOK Guide V4) to the Guide is to improve the Guides currency, readability, consistency, and usability. The Guide consists of 18 knowledge areas (KAs) followed by several appendixes. A KA is an identified area of software engineering defined by its knowledge requirements and described in terms of its component processes, prac- tices, inputs, outputs, tools, and techniques. Three appendixes provide, respectively, the speci- fications for the KA descriptions, an annotated set of relevant standards for each KA, and a list of references cited in the Guide. All KAs have been updated to reflect changes in software engineering since the publication of Guide V3, including modern development practices, new techniques, and the advancement of standards. One significant change is that Agile and DevOps have been incorporated into almost all KAs because these models have been widely accepted since the previous publication of the Guide. Agile models typically involve frequent demonstrations of working software to a customer in short, iterative cycles. Agile practices exist across KAs. Furthermore, emerging platforms and technologies, including artificial intelligence (AI), machine learning (ML), and the internet of things (IoT), have been incorporated into the foundation KAs.

--- Chunk 25 ---
Tokens: 372
Type: sentence-based
Text:
Furthermore, emerging platforms and technologies, including artificial intelligence (AI), machine learning (ML), and the internet of things (IoT), have been incorporated into the foundation KAs. To reflect areas that are becoming particularly important in modern software engineering, the following KAs have been added: the Software Architecture KA, Software Security KA, and Software Engineering Operations KA. This Guide, written under the auspices of the Professional and Educational Activities Board of the IEEE Computer Society, represents the next step in the evolution of the software engi- neering profession. Steve McConnell Chief Executive Officer, Construx Software Hironori Washizaki President-Elect 2024, President 2025, IEEE Computer Society xxv xxvi SWEBOK  GUIDE V4.0 FOREWORD TO THE 2014 EDITION Every profession is based on a body of knowledge, although that knowledge is not always defined in a concise manner. In cases where no formality exists, the body of knowledge is gen- erally recognized by practitioners and may be codified in a variety of ways for a variety of dif- ferent uses. But in many cases, a guide to a body of knowledge is formally documented, usually in a form that permits it to be used for such purposes as development and accreditation of aca- demic and training programs, certification of specialists, or professional licensing. Generally, a professional society or similar body maintains stewardship of the formal definition of a body of knowledge.

--- Chunk 26 ---
Tokens: 396
Type: sentence-based
Text:
Generally, a professional society or similar body maintains stewardship of the formal definition of a body of knowledge. During the past forty-five years, software engineering has evolved from a conference catch- phrase into an engineering profession, characterized by 1) a professional society, 2) standards that specify generally accepted professional practices, 3) a code of ethics, 4) conference proceed- ings, 5) textbooks, 6) curriculum guidelines and curricula, 7) accreditation criteria and accred- ited degree programs, 8) certification and licensing, and 9) this Guide to the Body of Knowledge. In this Guide to the Software Engineering Body of Knowledge, the IEEE Computer Society presents a revised and updated version of the body of knowledge formerly documented as SWEBOK 2004; this revised and updated version is denoted SWEBOK Guide V3. This work is in partial fulfillment of the Societys responsibility to promote the advancement of both theory and practice for the profession of software engineering. It should be noted that this Guide does not present the entire body of knowledge for soft- ware engineering but rather serves as a guide to the body of knowledge that has been devel- oped over more than four decades. The software engineering body of knowledge is constantly evolving. Nevertheless, this Guide constitutes a valuable characterization of the software engi- neering profession. In 1958, John Tukey, the world-renowned statistician, coined the term software. The term software engineering was used in the title of a NATO conference held in Germany in 1968.

--- Chunk 27 ---
Tokens: 376
Type: sentence-based
Text:
The term software engineering was used in the title of a NATO conference held in Germany in 1968. The IEEE Computer Society first published its Transactions on Software Engineering in 1972, and a committee for developing software engineering standards was established within the IEEE Computer Society in 1976. In 1990, planning was begun for an international standard to provide an overall view of software engineering. The standard was completed in 1995 with designation ISOIEC 12207 and given the title of Standard for Software Life Cycle Processes. The IEEE version of 12207 was published in 1996 and provided a major foundation for the body of knowledge captured in SWEBOK 2004. The current version of 12207 is designated as ISOIEC 12207:2008 and IEEE 12207-2008; it provides the basis for this SWEBOK Guide V3. This Guide to the Software Engineering Body of Knowledge is presented to you, the reader, as a mechanism for acquiring the knowledge you need in your lifelong career development as a soft- ware engineering professional. Dick Fairley, Chair Software and Systems Engineering Committee IEEE Computer Society Don Shafer, Vice President Professional Activities Board IEEE Computer Society FOREWORD TO THE 2004 EDITION In this Guide, the IEEE Computer Society establishes for the first time a baseline for the body of knowledge for the field of software engineering, and the work partially fulfills the Societys responsibility to promote the advancement of both theory and practice in this field.

--- Chunk 28 ---
Tokens: 367
Type: sentence-based
Text:
Dick Fairley, Chair Software and Systems Engineering Committee IEEE Computer Society Don Shafer, Vice President Professional Activities Board IEEE Computer Society FOREWORD TO THE 2004 EDITION In this Guide, the IEEE Computer Society establishes for the first time a baseline for the body of knowledge for the field of software engineering, and the work partially fulfills the Societys responsibility to promote the advancement of both theory and practice in this field. In so doing, the Society has been guided by the experience of disciplines with longer histories but was not bound either by their problems or their solutions. It should be noted that the Guide does not purport to define the body of knowledge but rather to serve as a compendium and guide to the body of knowledge that has been developing and evolving over the past four decades. Furthermore, this body of knowledge is not static. The Guide must, necessarily, develop and evolve as software engineering matures. It nevertheless constitutes a valuable element of the software engineering infrastructure. In 1958, John Tukey, the world-renowned statistician, coined the term software. The term software engineering was used in the title of a NATO conference held in Germany in 1968. The IEEE Computer Society first published its Transactions on Software Engineering in 1972. The committee established within the IEEE Computer Society for developing software engi- neering standards was founded in 1976.

--- Chunk 29 ---
Tokens: 390
Type: sentence-based
Text:
The committee established within the IEEE Computer Society for developing software engi- neering standards was founded in 1976. The first holistic view of software engineering to emerge from the IEEE Computer Society resulted from an effort led by Fletcher Buckley to develop IEEE standard 730 for software quality assurance, which was completed in 1979. The purpose of IEEE Std. 730 was to provide uniform, minimum acceptable requirements for preparation and content of software quality assurance plans. This standard was influential in completing the developing standards in the following topics: configuration management, software testing, software requirements, software design, and software verification and validation. During the period 19811985, the IEEE Computer Society held a series of workshops con- cerning the application of software engineering standards. These workshops involved practi- tioners sharing their experiences with existing standards. The workshops also held sessions on planning for future standards, including one involving measures and metrics for software engi- neering products and processes. The planning also resulted in IEEE Std. 1002, Taxonomy of Software Engineering Standards (1986), which provided a new, holistic view of software engi- neering. The standard describes the form and content of a software engineering standards tax- onomy. It explains the various types of software engineering standards, their functional and external relationships, and the role of various functions participating in the software life cycle.

--- Chunk 30 ---
Tokens: 387
Type: sentence-based
Text:
It explains the various types of software engineering standards, their functional and external relationships, and the role of various functions participating in the software life cycle. In 1990, planning for an international standard with an overall view was begun. The plan- ning focused on reconciling the software process views from IEEE Std. 1074 and the revised US DoD standard 2167A. The revision was eventually published as DoD Std. 498. The inter- national standard was completed in 1995 with designation, ISOIEC 12207, and given the title of Standard for Software Life Cycle Processes. Std. ISO IEC 12207 provided a major point of departure for the body of knowledge captured in this book. It was the IEEE Computer Society Board of Governors approval of the motion put forward in May 1993 by Fletcher Buckley which resulted in the writing of this book. The Association for Computing Machinery (ACM) Council approved a related motion in August 1993. The two motions led to a joint committee under the leadership of Mario Barbacci and Stuart Zweben who served as cochairs. The mission statement of the joint committee was To establish the appropriate set(s) of criteria and norms for professional practice of software engineering upon which industrial decisions, professional certification, and educational curricula can be based. The steering committee organized task forces in the following areas: xxvii xxviii SWEBOK  GUIDE V4.0 1. Define Required Body of Knowledge and Recommended Practices. 2. Define Ethics and Professional Standards. 3.

--- Chunk 31 ---
Tokens: 377
Type: sentence-based
Text:
3. Define Educational Curricula for undergraduate, graduate, and continuing education. This book supplies the first component: required body of knowledge and recommended practices. The code of ethics and professional practice for software engineering was completed in 1998 and approved by both the ACM Council and the IEEE Computer Society Board of Governors. It has been adopted by numerous corporations and other organizations and is included in sev- eral recent textbooks. The educational curriculum for undergraduates is being completed by a joint effort of the IEEE Computer Society and the ACM and is expected to be completed in 2004. Every profession is based on a body of knowledge and recommended practices, although they are not always defined in a precise manner. In many cases, these are formally documented, usually in a form that permits them to be used for such purposes as accreditation of academic programs, development of education and training programs, certification of specialists, or pro- fessional licensing. Generally, a professional society or related body maintains custody of such a formal definition. In cases where no such formality exists, the body of knowledge and recom- mended practices are generally recognized by practitioners and may be codified in a variety of ways for different uses. It is hoped that readers will find this book useful in guiding them toward the knowledge and resources they need in their lifelong career development as software engineering professionals.

--- Chunk 32 ---
Tokens: 397
Type: sentence-based
Text:
It is hoped that readers will find this book useful in guiding them toward the knowledge and resources they need in their lifelong career development as software engineering professionals. The book is dedicated to Fletcher Buckley in recognition of his commitment to promoting software engineering as a professional discipline and his excellence as a software engineering practitioner in radar applications. Leonard L. Tripp, IEEE Fellow 2003 Chair, Professional Practices Committee, IEEE Computer Society (20012003) Chair, Joint IEEE Computer Society and ACM Steering Committee for the Establishment of Software Engineering as a Profession (19981999) Chair, Software Engineering Standards Committee, IEEE Computer Society (19921998) EDITOR Hironori Washizaki, Waseda University  National Institute of Informatics  eXmotion  University of Human Environments, Japan, washizakiwaseda.jp KNOWLEDGE AREA EDITORS Software Requirements Steve Tockey, Construx Software, USA. Software Architecture Rich Hilliard, USA. Software Design Rich Hilliard, USA. Software Construction Xin Peng, Software School, Fudan University, China. Steve Schwarm, Synopsys - Black Duck Software, USA. Software Testing Eda Marchetti, ISTI-CNR, Italy. Said Daoudagh, ISTI-CNR, Italy. Software Engineering Operations Francis Bordeleau, cole de technologie suprieure (TS), Canada. Alain April, cole de technologie suprieure (TS), Canada. Software Maintenance Ali Ouni, cole de technologie suprieure (TS), Canada Alain April, cole de technologie suprieure (TS), Canada Peter Leather, Exceptional Performance, UK.

--- Chunk 33 ---
Tokens: 385
Type: sentence-based
Text:
Software Maintenance Ali Ouni, cole de technologie suprieure (TS), Canada Alain April, cole de technologie suprieure (TS), Canada Peter Leather, Exceptional Performance, UK. Software Configuration Management Maria Isabel Snchez Segura, Universidad Carlos III de Madrid, Spain. Bob Aiello, CM Best Practices, USA. Software Engineering Management Kenneth E. Nidiffer, George Mason University, USA. Software Engineering Process Juan Garbajosa, Universidad Politcnica de Madrid, Spain. Software Engineering Models and Methods Hironori Washizaki, Waseda University, Japan. Akinori Ihara, Wakayama University, Japan. Shinpei Ogata, Shinshu University, Japan. xxix xxx SWEBOK  GUIDE V4.0 Software Quality Alain April, cole de technologie suprieure (TS), Canada. Steve Tockey, Construx Software, USA. Steve Schwarm, Synopsys - Black Duck Software, USA. Software Security Nobukazu Yoshioka, Waseda University, Japan. Seiji Munetoh, IBM Research, Japan. Software Engineering Professional Practice Katsuhisa Shintani, Waseda University, Japan. Eiji Hayashiguchi, Waseda University, Japan. Software Engineering Economics Maria Isabel Snchez Segura, Universidad Carlos III de Madrid, Spain. Steve Tockey, Construx Software, USA. Computing Foundations Yatheendranath TJ, DhiiHii Labs Private Limited, India. Mathematical Foundations Yatheendranath TJ, DhiiHii Labs Private Limited, India. Steve Tockey, Construx Software, USA. Engineering Foundations Yatheendranath TJ, DhiiHii Labs Private Limited, India. Steve Tockey, Construx Software, USA.

--- Chunk 34 ---
Tokens: 300
Type: sentence-based
Text:
Steve Tockey, Construx Software, USA. Appendix A: Knowledge Area Description Specifications Juan Garbajosa, Universidad Politcnica de Madrid, Spain. Hironori Washizaki, Waseda University, Japan. Appendix B: IEEE and ISOIEC Standards Supporting SWEBOK Annette Reilly, USA. Appendix C: Consolidated Reference List Hironori Washizaki, Waseda University, Japan. CONTRIBUTING EDITORS The following persons contributed to editing the SWEBOK Guide V4: Michelle Phon Eric Berkowitz STEERING GROUP The following experts served on the SWEBOK Guide V4 Steering Group that guided the initial architecture of the Guide at the beginning of the project: Hironori Washizaki Yatheendranath TJ Rich Hilliard Kenneth Nidiffer Pete Brink V.S. Mani Hari Prasad Devarapalli Annette Reilly Narendra S Chowdhury Dharanipragada Janakiram Juan Garbajosa Maria Isabel Snchez Segura Peter Leather Andy Chen Steve Schwarm KNOWLEDGE AREA EDITORS OF PREVIOUS SWEBOK VERSIONS The following persons served as Knowledge Area Editors for either the Trial version published in 2001, the 2004 version, andor the 2014 version (SWEBOK V3). The affiliations listed are as they belonged to when each person served as a knowledge area editor.

--- Chunk 35 ---
Tokens: 747
Type: sentence-based
Text:
The affiliations listed are as they belonged to when each person served as a knowledge area editor. Software Requirements Peter Sawyer, Computing Department, Lancaster University, UK Gerald Kotonya, Computing Department, Lancaster University, UK Software Design Guy Tremblay, Dpartement dinformatique, UQAM, Canada Yanchun Sun, School of Electronics Engineering and Computer Science, Peking University, China Software Construction Steve McConnell, Construx Software, USA Terry Bollinger, the MITRE Corporation, USA Philippe Gabrini, Dpartement dinformatique, UQAM, Canada Louis Martin, Dpartement dinformatique, UQAM, Canada Xin Peng, Software School, Fudan University, China Software Testing Antonia Bertolino, ISTI-CNR, Italy Eda Marchetti, ISTI-CNR, Italy Software Maintenance Thomas M. Pigoski, Techsoft Inc, USA Alain April, cole de technologie suprieure, Canada Mira Kajko-Mattsson, School of Information and Communication Technology, KTH Royal Institute of Technology Software Configuration Management John A. Scott, Lawrence Livermore National Laboratory, USA David Nisse, USA Roger Champagne, cole de technologie suprieure (TS), Canada Alain April, cole de technologie suprieure (TS), Canada xxxi xxxii SWEBOK  GUIDE V4.0 Software Engineering Management Dennis Frailey, Raytheon Company, USA Stephen G. MacDonell, Auckland University of Technology, New Zealand Andrew R. Gray, University of Otago, New Zealand James McDonald, Department of Computer Science and Software Engineering, Monmouth University, USA Software Engineering Process Khaled El Emam, served while at the Canadian National Research Council, Canada Annette Reilly, Lockheed Martin Information Systems  Global Solutions, USA Richard E. Fairley, Software and Systems Engineering Associates (S2EA), USA Software Engineering Tools and Methods David Carrington, School of Information Technology and Electrical Engineering, The University of Queensland, Australia Michael F. Siok, Lockheed Martin Aeronautics Company, USA Software Quality Alain April, cole de technologie suprieure, Canada Dolores Wallace, retired from the National Institute of Standards and Technology, USA Larry Reeker, NIST, USA J. David Blaine, USA Durba Biswas, Tata Consultancy Services, India Software Engineering Professional Practice Aura Sheffield, USA Hengming Zou, Shanghai Jiao Tong University, China Software Engineering Economics Christof Ebert, Vector Consulting Services, Germany Computing Foundations Hengming Zou, Shanghai Jiao Tong University, China Mathematical Foundations Nabendu Chaki, University of Calcutta, India Engineering Foundations Amitava Bandyopadhayay, Indian Statistical Institute, India Mary Jane Willshire, Software and Systems Engineering Associates (S2EA), USA Appendix B: IEEE and ISOIEC Standards Supporting SWEBOK James W. Moore, USA References Editor Marc Bouisset, Dpartement dinformatique, UQAM REVIEW TEAM The people listed below participated in the public review process of SWEBOK Guide V4.

--- Chunk 36 ---
Tokens: 763
Type: sentence-based
Text:
Software Requirements Peter Sawyer, Computing Department, Lancaster University, UK Gerald Kotonya, Computing Department, Lancaster University, UK Software Design Guy Tremblay, Dpartement dinformatique, UQAM, Canada Yanchun Sun, School of Electronics Engineering and Computer Science, Peking University, China Software Construction Steve McConnell, Construx Software, USA Terry Bollinger, the MITRE Corporation, USA Philippe Gabrini, Dpartement dinformatique, UQAM, Canada Louis Martin, Dpartement dinformatique, UQAM, Canada Xin Peng, Software School, Fudan University, China Software Testing Antonia Bertolino, ISTI-CNR, Italy Eda Marchetti, ISTI-CNR, Italy Software Maintenance Thomas M. Pigoski, Techsoft Inc, USA Alain April, cole de technologie suprieure, Canada Mira Kajko-Mattsson, School of Information and Communication Technology, KTH Royal Institute of Technology Software Configuration Management John A. Scott, Lawrence Livermore National Laboratory, USA David Nisse, USA Roger Champagne, cole de technologie suprieure (TS), Canada Alain April, cole de technologie suprieure (TS), Canada xxxi xxxii SWEBOK  GUIDE V4.0 Software Engineering Management Dennis Frailey, Raytheon Company, USA Stephen G. MacDonell, Auckland University of Technology, New Zealand Andrew R. Gray, University of Otago, New Zealand James McDonald, Department of Computer Science and Software Engineering, Monmouth University, USA Software Engineering Process Khaled El Emam, served while at the Canadian National Research Council, Canada Annette Reilly, Lockheed Martin Information Systems  Global Solutions, USA Richard E. Fairley, Software and Systems Engineering Associates (S2EA), USA Software Engineering Tools and Methods David Carrington, School of Information Technology and Electrical Engineering, The University of Queensland, Australia Michael F. Siok, Lockheed Martin Aeronautics Company, USA Software Quality Alain April, cole de technologie suprieure, Canada Dolores Wallace, retired from the National Institute of Standards and Technology, USA Larry Reeker, NIST, USA J. David Blaine, USA Durba Biswas, Tata Consultancy Services, India Software Engineering Professional Practice Aura Sheffield, USA Hengming Zou, Shanghai Jiao Tong University, China Software Engineering Economics Christof Ebert, Vector Consulting Services, Germany Computing Foundations Hengming Zou, Shanghai Jiao Tong University, China Mathematical Foundations Nabendu Chaki, University of Calcutta, India Engineering Foundations Amitava Bandyopadhayay, Indian Statistical Institute, India Mary Jane Willshire, Software and Systems Engineering Associates (S2EA), USA Appendix B: IEEE and ISOIEC Standards Supporting SWEBOK James W. Moore, USA References Editor Marc Bouisset, Dpartement dinformatique, UQAM REVIEW TEAM The people listed below participated in the public review process of SWEBOK Guide V4. Membership of the IEEE Computer Society was not a requirement to participate in this review process, and membership information was not requested from reviewers.

--- Chunk 37 ---
Tokens: 57
Type: sentence-based
Text:
Membership of the IEEE Computer Society was not a requirement to participate in this review process, and membership information was not requested from reviewers. Over 1300 individual comments were collected and duly adjudicated.

--- Chunk 38 ---
Tokens: 585
Type: sentence-based
Text:
Over 1300 individual comments were collected and duly adjudicated. Aakashjit Bhattacharya Adil Aliyev Alaa Mahjoub Alberto Crdoba Izaguirre Ang Boon Chong Antonio Navarro Arjun Remadevi Somanathan Atilla Elci Beatri Beltrn Martnez Biswaranjan Senapati Brandon Thorin Klein Brian Kirkpatrick Carol Woody ChandraSR K Christof Ebert Claude Laporte Clive Boughton Dale Dzielski Daniel Medeiros Rocha David Budgen David Mack Endres Dmytro Lenda Duncan Hall Ed Zuk Eka Arriyanti Elena Williams Emmanuelle Wintergerst Ernesto Cuadros-Vargas Fabrcio Laguna Fabricio Lantieri Fedor Dzerzhinskiy Fernando Pinciroli Francisco Valds-Souto Gabriel Tamura Gavin Howard Gopal T V Graham Lee Hector Teran Helmut Neukirchen Hernan Guarda Hiroyuki Sato Hossein Saiedian Ian Hirst Irina Marudina Jack McKenzie Jack Pope James C Davis James Purtilo Jason Adcock Javier Gonzalez Huerta Joanna Isabelle Olszewska Joanna Leng Joao Marcelo Borovina Josko Jon D Hagar Jonathan Oliver Joshua Cook Juris Borzovs Karol Szkudlarek Kiyoshi Endo Kiyoshi Honda Konstantinos Domdouzis Kun Hsiang Wu Lolita Narag Magesh Kasthuri Maher Ben Abdessalem Manu Mitra Marc Blumberg Marcia Ito Maria-Isabel Sanchez-Segura Martin Kropp Masahiko Ishikawa Matteo Groe-Kampmann Micheal Tuape Mirna Muoz Mohammad Samarah Muthu Ramachandran Myneni Madhu Bala Nancy Mead Nandakumar Ramanathan Nauman Ahmad Nenad Medvidovi Nicolae Giurescu Norha Villegas Omar Oscar A. Schivo Pankaj Kamthan Paola Britos Peter Schoo Phillip A. Laplante Pieter Botman Piotr Karocki Prashant Verma Qusay F. Hassan Radoslav Rakovic Ravindra Joshi Ren-Her Hwang Robert Lemay Rodrigo Martins Pagliares Rupesh Sreeraman Samuel J. Crawford Saurabh Kumar Shailendra Suryawanshi Shelly Sachdeva Sheydi Anel Zamudio Lpez Sravan Kumar Reddy Kamidi Raja Stefan Malich Stefano Pietroiusti xxxiii xxxiv SWEBOK  GUIDE V4.0 Steffen Becker Steve France Sudheer Kumar Reddy Gowrigari Susanne Mller Sushil Birla Syed Mohamed Thameem Nizamudeen T V Gopal Takehisa Okazaki Tarig Ahmed Khalid Tateki Sano Tetsu Nagata Thomas M. Prinz Tim Bond Trent Leopold Tyler Thomas Procko Vivek Dave Vivienne Biak Walter Green Weihan Goh Weijia Yang William Uemura Yarlagadda Padma Sai Yasuko Okazaki Yuseon Yu Zheng Wang ACKNOWLEDGEMENTS Funding for the development of SWEBOK Guide V4 has been provided by the IEEE Computer Society.

--- Chunk 39 ---
Tokens: 609
Type: sentence-based
Text:
Aakashjit Bhattacharya Adil Aliyev Alaa Mahjoub Alberto Crdoba Izaguirre Ang Boon Chong Antonio Navarro Arjun Remadevi Somanathan Atilla Elci Beatri Beltrn Martnez Biswaranjan Senapati Brandon Thorin Klein Brian Kirkpatrick Carol Woody ChandraSR K Christof Ebert Claude Laporte Clive Boughton Dale Dzielski Daniel Medeiros Rocha David Budgen David Mack Endres Dmytro Lenda Duncan Hall Ed Zuk Eka Arriyanti Elena Williams Emmanuelle Wintergerst Ernesto Cuadros-Vargas Fabrcio Laguna Fabricio Lantieri Fedor Dzerzhinskiy Fernando Pinciroli Francisco Valds-Souto Gabriel Tamura Gavin Howard Gopal T V Graham Lee Hector Teran Helmut Neukirchen Hernan Guarda Hiroyuki Sato Hossein Saiedian Ian Hirst Irina Marudina Jack McKenzie Jack Pope James C Davis James Purtilo Jason Adcock Javier Gonzalez Huerta Joanna Isabelle Olszewska Joanna Leng Joao Marcelo Borovina Josko Jon D Hagar Jonathan Oliver Joshua Cook Juris Borzovs Karol Szkudlarek Kiyoshi Endo Kiyoshi Honda Konstantinos Domdouzis Kun Hsiang Wu Lolita Narag Magesh Kasthuri Maher Ben Abdessalem Manu Mitra Marc Blumberg Marcia Ito Maria-Isabel Sanchez-Segura Martin Kropp Masahiko Ishikawa Matteo Groe-Kampmann Micheal Tuape Mirna Muoz Mohammad Samarah Muthu Ramachandran Myneni Madhu Bala Nancy Mead Nandakumar Ramanathan Nauman Ahmad Nenad Medvidovi Nicolae Giurescu Norha Villegas Omar Oscar A. Schivo Pankaj Kamthan Paola Britos Peter Schoo Phillip A. Laplante Pieter Botman Piotr Karocki Prashant Verma Qusay F. Hassan Radoslav Rakovic Ravindra Joshi Ren-Her Hwang Robert Lemay Rodrigo Martins Pagliares Rupesh Sreeraman Samuel J. Crawford Saurabh Kumar Shailendra Suryawanshi Shelly Sachdeva Sheydi Anel Zamudio Lpez Sravan Kumar Reddy Kamidi Raja Stefan Malich Stefano Pietroiusti xxxiii xxxiv SWEBOK  GUIDE V4.0 Steffen Becker Steve France Sudheer Kumar Reddy Gowrigari Susanne Mller Sushil Birla Syed Mohamed Thameem Nizamudeen T V Gopal Takehisa Okazaki Tarig Ahmed Khalid Tateki Sano Tetsu Nagata Thomas M. Prinz Tim Bond Trent Leopold Tyler Thomas Procko Vivek Dave Vivienne Biak Walter Green Weihan Goh Weijia Yang William Uemura Yarlagadda Padma Sai Yasuko Okazaki Yuseon Yu Zheng Wang ACKNOWLEDGEMENTS Funding for the development of SWEBOK Guide V4 has been provided by the IEEE Computer Society. The editors and coeditors appreciate the important work performed by the KA editors and the contributing editors, as well as by the members of the Steering Group.

--- Chunk 40 ---
Tokens: 388
Type: sentence-based
Text:
The editors and coeditors appreciate the important work performed by the KA editors and the contributing editors, as well as by the members of the Steering Group. The editorial team must also acknowledge the indispensable contribution of reviewers. Finally, there are surely other people who have contributed to this Guide, either directly or indirectly, whose names we have inadvertently omitted. To those people, we offer our tacit appreciation and apologize for having omitted explicit recognition. IEEE COMPUTER SOCIETY PRESIDENTS Leila De Floriani, 2020 President Forrest Shull, 2021 President William Bill Gropp, 2022 President Nita Patel, 2023 President Jyotika Athavale, 2024 President Hironori Washizaki, 2025 President PROFESSIONAL AND EDUCATIONAL ACTIVITIES BOARD, 2024 MEMBERSHIP Cyril Onwubiko, Chair Deborah Silver Hironori Washizaki Rajendra Raj Ernesto Cuadros-Vargas Sao-Jie Chen Akinori Ihara Kiyoshi Honda Andrew Seely Megha Ben Kwabena Boateng Eric Berkowitz Michelle Phon TABLE OF CONTENTS xxxv MOTIONS REGARDING THE APPROVAL OF SWEBOK GUIDE V4.0 The following motion was unanimously adopted by the Professional and Educational Activities Board of the IEEE Computer Society in September 2024: The Professional Activities Board of the IEEE Computer Society finds that the Guide to the Software Engineering Body of Knowledge Version 4.0 has been successfully completed; and endorses the Guide to the Software Engineering Body of Knowledge Version 4.0 and commends it to the IEEE Computer Society Board of Governors for their approval.

--- Chunk 41 ---
Tokens: 345
Type: sentence-based
Text:
IEEE COMPUTER SOCIETY PRESIDENTS Leila De Floriani, 2020 President Forrest Shull, 2021 President William Bill Gropp, 2022 President Nita Patel, 2023 President Jyotika Athavale, 2024 President Hironori Washizaki, 2025 President PROFESSIONAL AND EDUCATIONAL ACTIVITIES BOARD, 2024 MEMBERSHIP Cyril Onwubiko, Chair Deborah Silver Hironori Washizaki Rajendra Raj Ernesto Cuadros-Vargas Sao-Jie Chen Akinori Ihara Kiyoshi Honda Andrew Seely Megha Ben Kwabena Boateng Eric Berkowitz Michelle Phon TABLE OF CONTENTS xxxv MOTIONS REGARDING THE APPROVAL OF SWEBOK GUIDE V4.0 The following motion was unanimously adopted by the Professional and Educational Activities Board of the IEEE Computer Society in September 2024: The Professional Activities Board of the IEEE Computer Society finds that the Guide to the Software Engineering Body of Knowledge Version 4.0 has been successfully completed; and endorses the Guide to the Software Engineering Body of Knowledge Version 4.0 and commends it to the IEEE Computer Society Board of Governors for their approval. The following motion was adopted by the IEEE Computer Society Board of Governors in October 2024: MOVED, that the Board of Governors of the IEEE Computer Society approves Version 4.0 of the Guide to the Software Engineering Body of Knowledge and authorizes the Chair of the Professional Activities Board to proceed with printing.

--- Chunk 42 ---
Tokens: 370
Type: sentence-based
Text:
The following motion was adopted by the IEEE Computer Society Board of Governors in October 2024: MOVED, that the Board of Governors of the IEEE Computer Society approves Version 4.0 of the Guide to the Software Engineering Body of Knowledge and authorizes the Chair of the Professional Activities Board to proceed with printing. MOTIONS REGARDING THE APPROVAL OF SWEBOK GUIDE V3.0 The SWEBOK Guide V3.0 was submitted to ballot by verified IEEE Computer Society mem- bers in November 2013 with the following question: Do you approve this manuscript of the SWEBOK Guide V3.0 to move forward to formatting and publication? The results of this ballot were 259 Yes votes and 5 No votes. The following motion was unanimously adopted by the Professional Activities Board of the IEEE Computer Society in December 2013: The Professional Activities Board of the IEEE Computer Society finds that the Guide to the Software Engineering Body of Knowledge Version 3.0 has been successfully completed; and endorses the Guide to the Software Engineering Body of Knowledge Version 3.0 and commends it to the IEEE Computer Society Board of Governors for their approval. The following motion was adopted by the IEEE Computer Society Board of Governors in December 2013: MOVED, that the Board of Governors of the IEEE Computer Society approves Version 3.0 of the Guide to the Software Engineering Body of Knowledge and authorizes the Chair of the Professional Activities Board to proceed with printing.

--- Chunk 43 ---
Tokens: 334
Type: sentence-based
Text:
The following motion was adopted by the IEEE Computer Society Board of Governors in December 2013: MOVED, that the Board of Governors of the IEEE Computer Society approves Version 3.0 of the Guide to the Software Engineering Body of Knowledge and authorizes the Chair of the Professional Activities Board to proceed with printing. Please also note that The SWEBOK Guide V3.0 was submitted by the IEEE Computer Society to ISOIEC without any change and was recognized as Technical Report ISOIEC TR 19759:2015. xxxvi SWEBOK  GUIDE V4.0 MOTIONS REGARDING THE APPROVAL OF SWEBOK GUIDE 2004 VERSION The following motion was unanimously adopted by the Industrial Advisory Board of the SWEBOK Guide project in February 2004: The Industrial Advisory Board finds that the Software Engineering Body of Knowledge project initiated in 1998 has been successfully completed; and endorses the 2004 Version of the Guide to the SWEBOK and commends it to the IEEE Computer Society Board of Governors for their approval. The following motion was adopted by the IEEE Computer Society Board of Governors in February 2004: MOVED, that the Board of Governors of the IEEE Computer Society approves the 2004 Edition of the Guide to the Software Engineering Body of Knowledge and authorizes the Chair of the Professional Practices Committee to proceed with printing.

--- Chunk 44 ---
Tokens: 376
Type: sentence-based
Text:
The following motion was adopted by the IEEE Computer Society Board of Governors in February 2004: MOVED, that the Board of Governors of the IEEE Computer Society approves the 2004 Edition of the Guide to the Software Engineering Body of Knowledge and authorizes the Chair of the Professional Practices Committee to proceed with printing. Please also note that the 2004 edition of the Guide to the Software Engineering Body of Knowledge was submitted by the IEEE Computer Society to ISOIEC without any change and was recog- nized as Technical Report ISOIEC TR 19759:2005. xxxvii Introduction to the Guide ACRONYMS KA Knowledge Area SWEBOK Software Engineering Body of Knowledge Publication of the 2014 version of the Guide to the Software Engineering Body of Knowledge (SWEBOK Guide V3) was a major milestone in establishing software engineering as a recog- nized engineering discipline. The goal of devel- oping this update (Version 4) to the SWEBOK Guide is to improve the Guides currency, read- ability, consistency and usability. The content of the Guide consists of 18 knowledge areas (KAs) followed by several appendixes. A KA is an identified area of software engineering and is described in terms of its generally accepted knowledge, such as its component processes, practices, inputs, outputs, tools and tech- niques. Three appendixes provide, respectively, the specifications for the KA descriptions, an annotated set of relevant standards for each KA, and a list of references cited in the Guide.

--- Chunk 45 ---
Tokens: 356
Type: sentence-based
Text:
Three appendixes provide, respectively, the specifications for the KA descriptions, an annotated set of relevant standards for each KA, and a list of references cited in the Guide. All KAs have been updated to reflect changes in software engineering since the publication of the Guide V3, including modern development practices, new techniques, and the advancement of standards. One signifi- cant change is that Agile and DevOps have been incorporated into almost all KAs because these models have been widely accepted since the previous publication of the Guide. Agile models typically involve frequent demonstra- tions of working software to a customer in short, iterative cycles. Agile practices exist across KAs. Furthermore, emerging plat- forms and technologies, including artificial 1 http:pascal.computer.orgsev_displayindex.action. intelligence (AI), machine learning (ML) and the internet of things (IoT), have been incor- porated into the foundation KAs. To reflect areas that are becoming partic- ularly important in modern software engi- neering, the following KAs have been added: the Software Architecture KA, Software Security KA and Software Engineering Operations KA. This Guide, written under the auspices of the Professional and Educational Activities Board of the IEEE Computer Society, rep- resents a next step in the evolution of the soft- ware engineering profession. 1. What Is Software Engineering?

--- Chunk 46 ---
Tokens: 359
Type: sentence-based
Text:
What Is Software Engineering? ISOIECIEEE Systems and Software Engineering Vocabulary (SEVOCAB)1 defines software as computer programs, pro- cedures and possibly associated documenta- tion and data pertaining to the operation of a computer system.1 And software engineering is defined as the application of a systematic, disciplined, quantifiable approach to the devel- opment, operation, and maintenance of soft- ware; that is, the application of engineering to software 1. Historically, software engi- neering has been defined in various ways, such as the practical application of scientific knowledge to the design and construction of computer programs and the associated docu- mentation required to develop, operate, and maintain them 2 and the technological and managerial discipline concerned with system- atic production and maintenance of software products that are developed and modified on time and within cost estimates 3. Although xxxviii SWEBOK  GUIDE V4.0 these definitions differ in detail, they have an essential commonality in that they both deal with software development and maintenance. Furthermore, the application of scientific knowledge (mentioned in the first definition) can be described as a technological discipline (a phrase used in the second definition). As scientific implies a systematic and quan- tifiable approach, the initial definition also expresses an idea common in past definitions of the discipline.

--- Chunk 47 ---
Tokens: 371
Type: sentence-based
Text:
As scientific implies a systematic and quan- tifiable approach, the initial definition also expresses an idea common in past definitions of the discipline. Software engineering occupies a position between the mathematical and physical disci- plines of computer science and technology on the one hand and the work of applying those findings to solve the problems of particular application domains on the other 3. Science is about discovering new things. On the other hand, engineering is about applying that knowledge to solve real-world problems with limited resources cost-effectively. As such, the engineering discipline of a given scientific field requires skills and knowledge about rel- evant practice. Further, as engineering con- cerns cost-effective solutions to real-world problems, all engineering disciplines involve engineering economics, which is the analysis of theoretically possible solutions to identify the most cost-effective one. In essence, this Guide distills the relevant theory of computer science and engineering into the three foun- dation KAs, while the remaining KAs cat- alog the practice and engineering economics of software engineering. Software engineering techniques can be viewed as specializations of techniques of more general disciplines, such as project manage- ment, systems engineering and quality man- agement 3. Furthermore, a software project must implement requirements imposed by cross-cutting disciplines such as dependability and safety.

--- Chunk 48 ---
Tokens: 399
Type: sentence-based
Text:
Furthermore, a software project must implement requirements imposed by cross-cutting disciplines such as dependability and safety. Software engineering and com- puter science are related but distinct in the same way chemical engineering and chemistry are related but distinct. Scientific disciplines, such as computer science and chemistry, aim to extend human knowledge. Effective require- ments elicitation techniques, design princi- ples like cohesion and coupling, appropriate branch-merge strategies, conducting a proper peer review, and assessing the cost of quality are a few examples of critical software engi- neering practices that are of little or no concern to computer science. In engineering, science and practice are applied to generate poten- tial solutions to the real-world problem, and engineering economics is used to identify the most cost-effective one. In the same way that it would not make sense to send a chemist to solve a chemical engineering problem, it does not make sense to send a computer scientist to solve a software engineering problem. In addition to computer science, software engineering is related to several other disci- plines and professional areas, such as indus- trial engineering, dependability engineering, and safety and security engineering. 2. What Are the Objectives of the SWEBOK Guide? The Guide should not be confused with the body of knowledge itself, which exists in the published literature. The Guides purpose is to describe the generally accepted portion of the body of knowledge, organize that portion, and provide topical access to it.

--- Chunk 49 ---
Tokens: 379
Type: sentence-based
Text:
The Guides purpose is to describe the generally accepted portion of the body of knowledge, organize that portion, and provide topical access to it. The SWEBOK Guide was established with the following five objectives: 1. To promote a consistent view of software engineering worldwide 2. To specify the scope and clarify the place of software engineering with respect to other disciplines, such as computer sci- ence, project management, computer engineering and mathematics 3. To characterize the contents of the soft- ware engineering discipline 4. To provide topical access to the Software Engineering Body of Knowledge 5. To provide a foundation for curriculum development and for individual certifica- tion and licensing materials The first objective, to promote a consis- tent worldwide view of software engineering, was supported by a development process that INTRODUCTION TO THE GUIDE xxxix engaged about 130 reviewers from various countries. More information regarding the development process can be found at www. swebok.org. Professional and learned soci- eties and public agencies involved in soft- ware engineering were contacted, made aware of this project to update the SWEBOK Guide, and invited to participate in the review process. Associate editors were recruited from America, Asia, Europe, and Oceania. Presentations on the project were made at var- ious international venues. The second objective, to specify the scope of software engineering, underlies the fun- damental organization of the Guide.

--- Chunk 50 ---
Tokens: 356
Type: sentence-based
Text:
The second objective, to specify the scope of software engineering, underlies the fun- damental organization of the Guide. Material that falls within this discipline is organized into the 18 KAs listed in Table I.1. Each KA is treated as a chapter in this Guide. Among them, Chapters 1-15 are regarded as the soft- ware engineering KAs, while Chapters 16-18 address foundation KAs. TABLE I.1. THE 18 SWEBOK KAS 1. Software Requirements 2. Software Architecture 3. Software Design 4. Software Construction 5. Software Testing 6. Software Engineering Operations 7. Software Maintenance 8. Software Configuration Management 9. Software Engineering Management 10. Software Engineering Process 11. Software Engineering Models and Methods 12. Software Quality 13. Software Security 14. Software Engineering Professional Practice 15. Software Engineering Economics 16. Computing Foundations 17. Mathematical Foundations 18. Engineering Foundations In specifying the scope of the discipline, it is also important to identify disciplines that intersect with software engineering. To this end, the SWEBOK V4 Guide continues to recognize eleven related disciplines, listed in Table I.2. Software engineers should, of course, be knowledgeable about these dis- ciplines (and KA descriptions in this Guide might refer to them). However, characterizing the knowledge of related disciplines is not an objective of the SWEBOK Guide. TABLE I.2.

--- Chunk 51 ---
Tokens: 392
Type: sentence-based
Text:
TABLE I.2. RELATED DISCIPLINES Business Analysis Computer Engineering Computer Science Cybersecurity Data Science General Management Information Systems and Technology Mathematics Project Management Quality Management Systems Engineering The relevant elements of computer science, mathematics, and engineering foundations are presented in the Computing Foundations KA, Mathematical Foundations KA, and Engineering Foundations KA of the Guide (Chapters 16, 17 and 18). HIERARCHICAL ORGANIZATION The organization of the KA chapters supports the third project objective  to characterize the contents of software engineering. The detailed specifications provided by the proj- ects editorial team to the associate editors regarding the contents of the KA descriptions can be found in Appendix A. The Guide uses a hierarchical organiza- tional structure to decompose each KA into a set of topics with recognizable labels. Each xl SWEBOK  GUIDE V4.0 KA provides a two- or three-level break- down, which provides a reasonable way to find topics of interest. The Guide treats the selected topics in a way that is compatible with major schools of thought and sepa- rates the topics into subtopics that are gen- erally found in industry and in software engineering literature and standards. The breakdowns are not designed for particular application domains, business uses, manage- ment philosophies, development methods and so forth. Each topic description is meant only to give the reader a general understanding of the topic and to enable the reader to find reference material.

--- Chunk 52 ---
Tokens: 382
Type: sentence-based
Text:
Each topic description is meant only to give the reader a general understanding of the topic and to enable the reader to find reference material. The body of knowledge is found in the reference materials, not in the Guide. Software plays a core role in various appli- cation and technological domains, such as automotive, legal, health care, and finance. Differences in application domains and busi- ness models (e.g, custom applications, and open source applications) and system types (e.g, enterprise and cloud systems, embedded and IoT systems, and AIML-based sys- tems) may influence what practices are adopted. Major special techniques and prac- tices specific to certain system types are also discussed in some KAs, especially the Software Requirements KA, the Software Testing KA, the Software Quality KA, the Software Security KA and the Computing Foundations KA. REFERENCE MATERIAL AND MATRIX To provide topical access to the knowledge  the fourth project objective  the Guide identifies authoritative reference material for each KA. In addition, Appendix C provides a Consolidated Reference List for the entire Guide. Each KA includes relevant references from the Consolidated Reference List as well as a matrix connecting the reference materials to the topics covered. 2 A Guide to the Project Management Body of Knowledge, 7th ed, Project Management Institute, 2021, www.pmi.org. Please note that the Guide does not attempt to be comprehensive in its citations. Much suitable and excellent material is not refer- enced.

--- Chunk 53 ---
Tokens: 388
Type: sentence-based
Text:
Much suitable and excellent material is not refer- enced. However, the material included in the Consolidated Reference List provides further information about the topics described. DEPTH OF TREATMENT To achieve the Guides fifth objective  to provide a foundation for curriculum devel- opment, certification and licensing  the criterion of generally accepted knowledge has been applied. This is distinct from advanced and research knowledge (on the grounds of maturity) and from specialized knowledge (on the grounds of generality of applica- tion). The equivalent term generally recog- nized comes from the Project Management Institute:2 Generally recognized means the knowl- edge and practices described are applicable to most projects most of the time, and there is consensus about their value and usefulness. However, the terms generally accepted and generally recognized do not imply that the desig- nated knowledge should be uniformly applied to all software engineering endeavors  each projects needs determine what knowledge to apply, and how. However, competent, capable software engineers should be equipped with this knowledge for potential application. Therefore, appropriate selection of generally accepted knowledge should be included in the study material for the software engineering professional certification and licensing exam- inations that graduates take after gaining four years of work experience. STRUCTURE OF THE KA DESCRIPTIONS Each chapter provides a description of one of the KAs. These descriptions are structured as follows.

--- Chunk 54 ---
Tokens: 391
Type: sentence-based
Text:
These descriptions are structured as follows. INTRODUCTION TO THE GUIDE xli The introduction briefly defines the KA and presents an overview of its scope and its relationship with other KAs. The breakdown of topics in each KA consti- tutes the core of the KA description, showing the decomposition of the KA into subareas, topics and subtopics. For each topic or sub- topic, a short description is given, along with one or more references. These reference materials were selected as the best available presentation of knowledge related to the topic. A matrix links the topics to the reference materials. The last part of each KA description is the list of recommended references and suggested further reading. Relevant standards for each KA are presented in Appendix B of the Guide. APPENDIX A. KA DESCRIPTION SPECIFICATIONS Appendix A describes the specifications provided by the editorial team to the asso- ciate editors for the content, recommended references, format and style of the KA descriptions. APPENDIX B. IEEE AND ISOIEC STANDARDS Appendix B presents an annotated list of the relevant standards, mostly from the IEEE and the ISO, for each of the SWEBOK Guides KAs. APPENDIX C. CONSOLIDATED REFERENCE LIST Appendix C contains the consolidated list of recommended references cited in the KAs. These references are marked with an asterisk () in the text. REFERENCES 1 ISOIECIEEE, ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, 2nd ed. 2017. 2 Barry W. Boehm, Software Engineering, IEEE Transactions on Computers, Vol. C-25, No. 12, 1976.

--- Chunk 55 ---
Tokens: 398
Type: sentence-based
Text:
12, 1976. 3 James W. Moore, Software Engineering Standards: A Users Road Map, IEEE Computer Society, 1998. 1-1 CHAPTER 01 Software Requirements ACRONYMS ATDD Acceptance Test Driven Development BDD Behavior Driven Development CIA Confidentiality, Integrity, and Availability FSM Functional Size Measurement INCOSE International Council on Systems Engineering JAD Joint Application Development JRP Joint Requirements Planning SME Subject Matter Expert SysML Systems Modeling Language TDD Test Driven Development UML Unified Modeling Language INTRODUCTION Software requirements should be viewed from two perspectives. The first is as an expres- sion of the needs and constraints on a soft- ware product or project that contribute to the solution of a real-world problem. The second is that of the activities necessary to develop and maintain the requirements for a software product and for the project that constructs it. Both perspectives are presented in this knowledge area (KA). If a team does a poor job of determining the requirements, the project, the product or both are likely to suffer from added costs, delays, cancellations and defects. One reason is that each software product requirement generally leads to many design decisions. Each design decision generally leads to many code-level decisions. Each decision can involve several test decisions, as well. In other words, deter- mining the requirements correctly is high- stakes work. If not detected and repaired early, missing, misinterpreted and incorrect requirements can induce exponentially cas- cading rework to correct them.

--- Chunk 56 ---
Tokens: 388
Type: sentence-based
Text:
If not detected and repaired early, missing, misinterpreted and incorrect requirements can induce exponentially cas- cading rework to correct them. Real-world software projects tend to suffer from two primary requirements-re- lated problems: 1. incompleteness: stakeholder require- ments, and necessary detail, exist that are not revealed and communicated to the software engineers; 2. ambiguity: requirements are communi- cated in a way that is open to multiple interpretations, with only one possible interpretation being correct. Beyond the obvious short-term role requirements play in initial software con- struction, they also play a less recognized but still important role in long-term mainte- nance. Upon receiving software without any supporting documentation, a software engi- neer has several means to determine what that code does, such as execute it, step through it with a debugger, hand-execute it, stati- cally analyze it, and so on. The challenge is determining what that code is intended to do. What is generally referred to as a bug  but is better called a defect  is simply an observ- able difference between what the software is intended to do and what it does. The role of requirements documentation throughout the service life of the software is to capture and 1-2 SWEBOK  GUIDE V4.0 communicate intent for software engineers who maintain the code but might not have been its original authors. The Software Requirements KA concerns developing software requirements and man- aging those requirements over the softwares service life.

--- Chunk 57 ---
Tokens: 381
Type: sentence-based
Text:
The Software Requirements KA concerns developing software requirements and man- aging those requirements over the softwares service life. This KA provides an under- standing that software requirements:  are not necessarily a discrete front-end activity of the software development life cycle but rather a process initiated at a projects beginning that often continues to be refined throughout the softwares entire service life;  need to be tailored to the organization and project context. The term requirements engineering is often used to denote the systematic handling of requirements. For consistency, the term engi- neering will not be used in this KA other than for software engineering per se. The Software Requirements KA is most closely related to the Software Architecture, Software Design, Software Construction, Software Testing, and Software Maintenance KAs, as well as to the models topic in the Software Engineering Models and Methods KA, in that there can be high value in speci- fying requirements in model form. This KA is also related to the Software Life Cycles topic in the Software Engineering Process KA, in that this KAs focus is on what and how requirements work can and should be done, whereas the projects life cycle deter- mines when that work is done. For example, in a waterfall life cycle, all requirements work is essentially done in a discrete Requirements phase and is expected to be substantially com- plete before any architecture, design and con- struction work occurs in subsequent phases.

--- Chunk 58 ---
Tokens: 382
Type: sentence-based
Text:
For example, in a waterfall life cycle, all requirements work is essentially done in a discrete Requirements phase and is expected to be substantially com- plete before any architecture, design and con- struction work occurs in subsequent phases. Under some iterative life cycles, initial, high- level requirements work is done during an Inception phase, and further detailing is done during one or more Elaboration phases. In an Agile life cycle, requirements work is done incrementally, just in time, as each additional element of functionality is constructed. The whats and hows of software require- ments work on a project should be determined by the nature of the software constructed, not by the life cycle under which it is constructed. Insofar as requirements documentation cap- tures and communicates the softwares intent, downstream maintainers should not be able to discern the life cycle used in earlier devel- opment from the form of those require- ments alone. This KA is also related, but somewhat less so, to the Software Configuration Management, Software Engineering Management and Software Quality KAs. Software CM approaches can be applied to trace and manage requirements; software quality looks at how well formed the require- ments are, and engineering management can use the status of requirements to evaluate the completion of the project. BREAKDOWN OF TOPICS FOR SOFTWARE REQUIREMENTS The topic breakdown for the Software Requirements KA is shown in Figure 1.1. 1. Software Requirements Fundamentals 1.1.

--- Chunk 59 ---
Tokens: 393
Type: sentence-based
Text:
Software Requirements Fundamentals 1.1. Definition of a Software Requirement 1, c1pp5-6 2, c4p102 Formally, a software requirement has been defined as 28:  a condition or capability needed by a user to solve a problem or achieve an objective;  a condition or capability that must be met or possessed by a system or system component to satisfy a contract, stan- dard, specification or other formally imposed document;  a documented representation or capa- bility as in (1) or (2) above. This formal definition is extended in this KA to include expressions of a software proj- ects needs and constraints. SOFTWARE REQUIREMENTS 1-3 At its most basic, a software requirement is a property that must be exhibited to solve a real-world problem. It might aim to automate all or part of a task supporting an organiza- tions business policies and processes, correct existing softwares shortcomings, or control a device  just a few of the many problems for which software solutions are possible. Business policies and processes, as well as device functions, are often very complex. By extension, software requirements are often a complex combination of requirements from various stakeholders at different organiza- tional levels who are involved or connected with some aspect of the environment in which the software will operate. Clients, customers and users usually impose requirements. However, other third parties, like regulatory authorities and, in some cases, the software organization or the project itself, might also impose requirements. (See also 5, c1 6, c1 9, c4.) 1.2.

--- Chunk 60 ---
Tokens: 370
Type: sentence-based
Text:
1.2. Categories of Software Requirements 1, c1pp7-12 2, s4.1 Figure 1.2 shows the categories of software requirements defined in this KA and the relationships among those categories. (See also 5, c1 6, c1 9, c4.) Each category is further described below. 1.3. Software Product Requirements and Software Project Requirements 1, c1pp14-15 Software product requirements specify the softwares expected form, fit or function. Software project requirements  also called process requirements or, sometimes business requirements constrain the project that constructs the software. Project require- ments often constrain cost, schedule andor staffing but can also constrain other aspects of a software project, such as testing envi- ronments, data migration, user training, and maintenance. Software project require- ments can be captured in a project charter or other high-level project initiation doc- ument. They are most relevant to how the project is managed (see the Software Engineering Management KA) or what life cycle process should be used (see the Software Engineering Process KA). This KA does not discuss software project requirements further. Software Requirements Software Requirements Fundamentals Denition of a Software Requirement Categories of Software Requirements Software Product Requirements and Software Project Requirements Functional Requirements Nonfunctional Requirements Technology Constraints Quality of Service Constraints Why Categorize Requirements Tis Way?

--- Chunk 61 ---
Tokens: 383
Type: sentence-based
Text:
Software Requirements Software Requirements Fundamentals Denition of a Software Requirement Categories of Software Requirements Software Product Requirements and Software Project Requirements Functional Requirements Nonfunctional Requirements Technology Constraints Quality of Service Constraints Why Categorize Requirements Tis Way? System Requirements and Software Requirements Derived Requirements Software Requirements Activities Requirements Sources Common Requirements Elicitation Techniques Basic Requirements Analysis Economics of Quality of Service Constraints Formal Analysis Addressing Conict in Requirements Unstructured Natural Language Requirements Specication Structured Natural Language Requirements Specication Acceptance Criteria-based Requirements Specication Model-Based Requirements Specication Additional Attributes of Requirements Incremental and Comprehensive Requirements Specication Requirements Reviews Simulation and Execution Prototyping Requirements Scrubbing Requirements Change Control Scope Matching Iterative Nature of the Requirements Process Requirements Prioritization Requirements Tracing Requirements Stability and Volatility Measuring Requirements Requirements Process Quality and Improvement Requirements Elicitation Requirements Analysis Requirements Specication Requirements Validation Requirements Management Activities Practical Considerations Software Requirements Tools Requirements Management Tools Requirements Modeling Tools Functional Test Case Generation Tools Figure 1.1.

--- Chunk 62 ---
Tokens: 365
Type: sentence-based
Text:
System Requirements and Software Requirements Derived Requirements Software Requirements Activities Requirements Sources Common Requirements Elicitation Techniques Basic Requirements Analysis Economics of Quality of Service Constraints Formal Analysis Addressing Conict in Requirements Unstructured Natural Language Requirements Specication Structured Natural Language Requirements Specication Acceptance Criteria-based Requirements Specication Model-Based Requirements Specication Additional Attributes of Requirements Incremental and Comprehensive Requirements Specication Requirements Reviews Simulation and Execution Prototyping Requirements Scrubbing Requirements Change Control Scope Matching Iterative Nature of the Requirements Process Requirements Prioritization Requirements Tracing Requirements Stability and Volatility Measuring Requirements Requirements Process Quality and Improvement Requirements Elicitation Requirements Analysis Requirements Specication Requirements Validation Requirements Management Activities Practical Considerations Software Requirements Tools Requirements Management Tools Requirements Modeling Tools Functional Test Case Generation Tools Figure 1.1. Breakdown of Topics for the Software Requirements KA 1-4 SWEBOK  GUIDE V4.0 1.4. Functional Requirements 1, c1p9 2, s4.1.1 Functional requirements specify observable behaviors that the software is to provide  policies to be enforced and processes to be carried out.

--- Chunk 63 ---
Tokens: 394
Type: sentence-based
Text:
Functional Requirements 1, c1p9 2, s4.1.1 Functional requirements specify observable behaviors that the software is to provide  policies to be enforced and processes to be carried out. Example policies in banking soft- ware might be an account shall always have at least one customer as its owner, and the balance of an account shall never be negative. Example processes could specify the meanings of depositing money into an account, with- drawing money from an account and trans- ferring money from one account to another. Even highly technical (nonbusiness-ori- ented) software, such as software that imple- ments the transmission control protocol internet protocol (TCPIP) network com- munications protocol, has policies and pro- cesses: a Port shall be able to exist with zero, one, or many associated Connections, but a Connection shall exist on exactly one associ- ated Port, acceptable states of a Connection shall be listen, syn sent, established, closing, . . . , and if the time-to-live of a Segment reaches zero, that Segment shall be deleted. (See 5, c1 6, c10 9, c4.) 1.5. Nonfunctional Requirements 1, c1pp10-11 2, s4.1.2 Nonfunctional requirements in some way con- strain the technologies to be used in the implementation: What computing plat- form(s)? What database engine(s)? How accu- rate do results need to be? How quickly must results be presented? How many records of a certain type need to be stored? Some non- functional requirements might relate to the operation of the software. (See the Operation and Maintenance KA.) (See also 5, c1 6, c11 9, c4.)

--- Chunk 64 ---
Tokens: 380
Type: sentence-based
Text:
(See also 5, c1 6, c11 9, c4.) The nonfunctional requirements can be further divided into technology constraints and quality of service constraints. They have essential relationships among themselves, which affect them positively or negatively and require that, whenever a nonfunctional requirement is modified, the impact it may cause on others should be considered. 1.6. Technology Constraints These requirements mandate  or prohibit  use of specific, named automation technolo- gies or defined infrastructures. Examples are requirements to use specific computing plat- forms (e.g, Windows, MacOS, Android OS, iOS), programming languages (e.g, Java, C, C, Python), compatibility with specific web browsers (e.g, Chrome, Safari, Edge), given database engines (e.g, Oracle, SQL Server, MySQL), and gen- eral technologies (e.g, reduced instruction set computer (RISC), Relational Database). A requirement prohibiting use of pointers would be another example. (See also 9, c4.) 1.7. Quality of Service Constraints These requirements do not constrain the use of specific, named technologies. Instead, these specify acceptable performance levels an automated solution must exhibit. Examples are response time, throughput, accuracy, reliability and scalability. ISOIEC 25010: System and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  System and software quality models 27 contains a large list of the kinds of quality characteristics that can be relevant for software. (See also 9, c4.)

--- Chunk 65 ---
Tokens: 388
Type: sentence-based
Text:
(See also 9, c4.) Safety Software Requirements Software Project Requirements Functional Requirements Nonfunctional Requirements Technology Constraints Quality of Service Constraints Software Product Requirements Figure 1.2. Categories of Software Requirements SOFTWARE REQUIREMENTS 1-5 and security are also a particularly important topic where requirements tend to be over- looked. (See the Security KA for details on the kinds of specific security requirements that should be considered.) (See also 2, c13.) 1.8. Why Categorize Requirements This Way? Categorizing requirements this way is useful for the following reasons:  requirements in one category tend to come from different sources than other categories;  elicitation techniques often vary by source;  analysis techniques vary by category;  specification techniques vary by category;  validation authorities vary by category;  the different categories affect the resulting software in different ways. In addition, organizing the requirements in these categories is beneficial in the fol- lowing ways:  complexity can be better managed because different areas can be addressed sepa- rately; software engineers can deal with policy and process complexities without worrying about automation technology issues at the same time (and vice versa). One large problem becomes two smaller ones. This is classic divide and conquer complexity management;  distinct areas of expertise can be iso- lated; stakeholders, not software engi- neers, are the experts in the policies and processes to be automated.

--- Chunk 66 ---
Tokens: 367
Type: sentence-based
Text:
This is classic divide and conquer complexity management;  distinct areas of expertise can be iso- lated; stakeholders, not software engi- neers, are the experts in the policies and processes to be automated. Software engineers, not stakeholders, are the technology experts. When a business expert is given interspersed functional and nonfunctional requirements for review or validation, they might give up because they dont understand  or even care about  the technology issues. The relevant requirements reviewer can focus on just the subset of requirements relevant to them. The Perfect Technology Filter originally described in 18, c1-4 but also explained in 8 and 9, c4 helps separate functional from nonfunctional requirements. Simply put, functional requirements are those that would still need to be stated even if a computer with infinite speed, unlimited memory, zero cost, no failures, etc, existed on which to construct the software. All other software product requirements are constraints on automation technologies and are therefore nonfunctional. Large systems often span more than one subject matter area, or domain. As explained in 9, c6, recursive design shows how non- functional requirements in a parent domain can become, or can induce, functional require- ments in a child domain. For example, a non- functional requirement about user security in a parent banking domain can become or can induce functional requirements in a child security domain.

--- Chunk 67 ---
Tokens: 381
Type: sentence-based
Text:
For example, a non- functional requirement about user security in a parent banking domain can become or can induce functional requirements in a child security domain. Similarly, cross-cutting non- functional requirements about auditing and transaction management in a parent banking domain can become or induce functional requirements in a child auditing domain and a child transaction domain. Decomposing large systems into a set of related domains signifi- cantly reduces complexity. 1.9. System Requirements and Software Requirements The International Council on Systems Engineering (INCOSE) defines a system as an interacting combination of elements to accomplish a defined objective. These include hardware, software, firmware, people, infor- mation, techniques, facilities, services, and other support elements 24. In some cases, it is either useful or manda- tory to distinguish system requirements from software requirements. System requirements apply to larger systems  for example, an autonomous vehicle. Software requirements apply only to an element of software in that larger system. Some software requirements may be derived from system requirements. (See also 5, c1.) In other cases, the software is itself the system of interest, and hardware and 1-6 SWEBOK  GUIDE V4.0 support system are regarded as the platform or infrastructure, so that the system require- ments are mostly software requirements. 1.10. Derived Requirements In practice, requirements can be context-sensi- tive and can depend on perspective.

--- Chunk 68 ---
Tokens: 400
Type: sentence-based
Text:
Derived Requirements In practice, requirements can be context-sensi- tive and can depend on perspective. An external stakeholder can impose a scope requirement, and this would be a requirement for the entire project  even if that project involves hun- dreds of software engineers. An architects decision to use a pipes-and-filters architecture style would not be a requirement from the per- spective of the overall project stakeholders, but a design decision. But that same decision, when seen from the perspective of a sub-team responsible for constructing a particular filter, would be considered a requirement. The aerospace industry has long used the term derived requirement to mean a require- ment that was not made by a stakeholder external to the overall project but that was imposed inside the larger development team. The architects pipes-and-filters decision fits this definition. That choice would be seen as a design decision from the point of view of external stakeholders, but as a requirement for the sub-teams responsible for developing each filter. (See also 9, c4.) 1.11. Software Requirements Activities 1, c1pp15-18 2, s4.2 Figure 1.3 shows the requirements develop- ment and management activities. Requirements development, as a whole, can be thought of as reaching an agreement on what software is to be constructed. In contrast, requirements management can be considered maintaining that agreement over time. Each activity is presented in this KA. Requirements development activities are pre- sented as separate topics, with requirements management presented as a single topic.

--- Chunk 69 ---
Tokens: 385
Type: sentence-based
Text:
Requirements development activities are pre- sented as separate topics, with requirements management presented as a single topic. (See also 5, c1 6, 2.) 2. Requirements Elicitation 1, c6-7 2, s4.3 The goal of requirements elicitation is to sur- face candidate requirements. It is also called requirements capture, requirements discovery or requirements acquisition. As stated earlier, one problem in requirements work on real-world software projects is incompleteness. This can be the result of inadequate elicitation. Although there is no guarantee that a set of requirements is complete, well-executed elic- itation helps minimize incompleteness. (See also 5, c2-3 6, c3-7.) 2.1. Requirements Sources 1, c6 2, s4.3 Requirements come  can be elicited  from many different sources. All potential require- ments sources should be identified and eval- uated. A stakeholder can be defined as any person, group or organization that:  is actively involved in the project;  is affected by the projects outcome;  can influence the projects outcome. Typical stakeholders for software projects include but are not limited to the following:  clients  those who pay for the software to be constructed (e.g, organizational management);  customers  those who decide whether a software product will be put into service;  users  those who interact directly or indirectly with the software; users can Requirements Requirements Development Elicitation Analysis Specication Validation Scrubbing Change Control Scope Matching Requirements Management Figure 1.3.

--- Chunk 70 ---
Tokens: 371
Type: sentence-based
Text:
Typical stakeholders for software projects include but are not limited to the following:  clients  those who pay for the software to be constructed (e.g, organizational management);  customers  those who decide whether a software product will be put into service;  users  those who interact directly or indirectly with the software; users can Requirements Requirements Development Elicitation Analysis Specication Validation Scrubbing Change Control Scope Matching Requirements Management Figure 1.3. Software Requirements Activities SOFTWARE REQUIREMENTS 1-7 often be further broken down into dis- tinct user classes that vary in frequency of use, tasks performed, skill and knowl- edge level, privilege level, and so on;  subject matter experts (SMEs);  operations staff;  first-level product support staff;  relevant professional bodies;  regulatory agencies;  special interest groups;  people who can be negatively affected if the project is successful;  developers. Stakeholder classes are groups of stake- holders that have similar perspectives and needs. Working on a software project in terms of stakeholder classes rather than with indi- vidual stakeholders can produce important, additional insight. Many projects benefit from performing a stakeholder analysis to identify as many important stakeholder classes as possible. This reduces the possibility that the requirements are biased toward better-represented stake- holders and away from less well-represented stakeholders.

--- Chunk 71 ---
Tokens: 394
Type: sentence-based
Text:
This reduces the possibility that the requirements are biased toward better-represented stake- holders and away from less well-represented stakeholders. The stakeholder analysis can also inform negotiation and conflict resolu- tion when requirements from one stakeholder class conflict with requirements from another. (See also 5, c3 6, c3.) Requirements are not limited to only coming from people. Other, non-person requirements sources can include:  documentation such as requirements for previous versions, mission statements, concept of operations;  other systems;  larger business context including organi- zational policies and processes;  computing environment. 2.2. Common Requirements Elicitation Techniques 1, c7 2, s4.3 A wide variety of techniques can be used to elicit requirements from stakeholders. Some techniques work better with certain stake- holder classes than others. Common stake- holder elicitation techniques include the following:  interviews;  meetings, possibly including brainstorming;  joint application development (JAD) 13, joint requirements planning (JRP) 14 and other facilitated workshops;  protocol analysis;  focus groups;  questionnaires and market surveys;  exploratory prototyping, including low-fidelity and high-fidelity user inter- face prototyping 1, c15;  user story mapping. Elicitation can be difficult, and the software engineer needs to know that (for example) users might have difficulty describing their tasks, leave important information unstated or be unwilling or unable to cooperate. Elicitation is not a passive activity.

--- Chunk 72 ---
Tokens: 389
Type: sentence-based
Text:
Elicitation is not a passive activity. Even if cooperative and articulate stakeholders are available, the software engineer must work hard to elicit the right information. Many product require- ments are tacit or can be found only in infor- mation that has yet to be collected. Requirements can also be elicited from sources other than stakeholders. Such sources and techniques include the following:  previous versions of the system;  defect tracking database for previous ver- sions of the system;  systems that interface with the system under development;  competitive benchmarking;  literature search;  quality function deployment (QFD)s House of Quality 15;  observation, where the software engineer studies the work and the environment where the work is being done;  apprenticing, where the software engi- neer learns by doing the work;  usage scenario descriptions; 1-8 SWEBOK  GUIDE V4.0  decomposition (e.g, capabilities into epics into features into stories);  task analysis 16;  design thinking (empathize, define, ideate, prototype, test) 17;  ISOIEC 25010: System and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  System and software quality models 27;  security requirements, as discussed in the Security KA;  applicable standards and regulations. (See also 5, c3 6, c4-7.) 3. Requirements Analysis 1, c8-9 Requirements are unlikely to be elicited in their final form. Further investigation is usu- ally needed to reveal the full, true require- ments suggested by the originally elicited information.

--- Chunk 73 ---
Tokens: 397
Type: sentence-based
Text:
Further investigation is usu- ally needed to reveal the full, true require- ments suggested by the originally elicited information. Requirements analysis helps software developers understand the meaning and implications of candidate requirements, both individually and in the context of the overall set of requirements. 3.1. Basic Requirements Analysis 1, c8-9 The following list of desirable properties of requirements can guide basic requirements analysis. The software engineer seeks to establish any of these properties that do not hold yet. Each requirement should:  be unambiguous (interpretable in only one way);  be testable (quantified), meaning that compliance or noncompliance can be clearly demonstrated;  be binding, meaning that clients are willing to pay for it and unwilling not to have it;  atomic, represent a single decision  represent true, actual stakeholder needs;  use stakeholder vocabulary;  be acceptable to all stakeholders. The overall collection of requirements should be:  complete  The requirements adequately address boundary conditions, exception conditions and security needs;  concise  No extraneous content in the requirements  internally consistent  No requirement conflicts with any other;  externally consistent  No requirement conflicts with any source material;  feasible  A viable, cost-effective solu- tion can be created within cost, schedule, staffing, and other constraints. In some cases, an elicited statement rep- resents a solution to be implemented rather than the true problem to be solved. This risks implementing a suboptimal solution.

--- Chunk 74 ---
Tokens: 388
Type: sentence-based
Text:
This risks implementing a suboptimal solution. The 5-whys technique (e.g, 3, c4) involves repeatedly asking, Why is this the require- ment? to converge on the true problem. Repetition stops when the answer is, If that isnt done, then the stakeholders problem has not been solved. Often, the true problem is reached in two or three cycles, but the tech- nique is called 5-whys to incentivize engineers to push it as far as possible. 3.2. Economics of Quality of Service Constraints 3 Quality of service constraints can be partic- ularly challenging. This is generally because engineers do not consider them from an eco- nomic perspective 9, c4. Figure 1.4 illus- trates the economic perspective of a typical quality of service constraint, such as capacity, throughput and reliability, where value increases with performance level. This curve is mirrored vertically for quality of service con- straints whose value decreases as performance level increases (response time and mean time to repair would be examples). Over the relevant range of performance levels, the stakeholders have a corresponding value if the system performs at that level. The value curve has two important points: SOFTWARE REQUIREMENTS 1-9 1. Perfection point  This is the most favorable level of performance, beyond which there is no additional benefit. Even if the system can perform better than the perfection point, the customer cannot use that capacity. For example, a social media system that supports more members than the world population would have this excess capacity. 2.

--- Chunk 75 ---
Tokens: 374
Type: sentence-based
Text:
2. Fail point  This is the least favorable level of performance, beyond which there is no further reduction in benefit. For example, the social media system might need to support at least a minimum market share to be viable as a platform. A quantified requirement point, even if stated explicitly, is usually arbitrary. It is often based on what a client feels justified requesting, given what they are paying for the software. Even if the software engineers cannot construct a system that fully achieves the stated requirement point, the software typically still has value; it just has less value than the client expected. Further, the ability to exceed the requirement point can signifi- cantly increase value in some cases. The cost to achieve a given performance level is usually a step function. First, for a given investment level, there is some max- imum achievable performance level. Then, additional investment is needed, and that further investment enables performance up to a new, more favorable maximum. Figure 1.5 illustrates the most cost-effective perfor- mance level  the performance level with the maximum positive difference between the value at that performance level and the cost to achieve it. (See the Software Engineering Economics KA or 3 for more information on per- forming economic analyses such as this.) The software engineer should pay particular attention to positive and negative relation- ships between quality of service constraints (e.g, Figure 14-1 in 1, c14).

--- Chunk 76 ---
Tokens: 367
Type: sentence-based
Text:
The software engineer should pay particular attention to positive and negative relation- ships between quality of service constraints (e.g, Figure 14-1 in 1, c14). Some quality of service constraints are mutually supporting; improving ones performance level will auto- matically improve the others performance level. For example, the more modifiable code is, the more reliable it tends to be, as both modifiability and reliability are, to a degree, a consequence of how clean the code is. On the other hand, the higher the codes speed, the less modifiable it might be, because high speed is often achieved through optimizations that make the code more complex. 3.3. Formal Analysis 2, s12.3.2-12.3.3 Formal analysis has shown benefits in some application domains, particularly high-integ- rity systems (e.g, 5, c6). The formal expres- sion of requirements depends on the use of a specification language with formally defined semantics. Formality has two benefits. First, formal requirements are precise and concise, Value Level of Performance Fail Perfection Figure 1.4. Value as a Function of Level of Performance  Value Cost to deliver Most cost-eective level of performance Level of performance Figure 1.5. Most Cost-Effective Level of Performance 1-10 SWEBOK  GUIDE V4.0 which (in principle) will reduce the possibility for misinterpretation. Second, formal require- ments can be reasoned over, permitting desired properties of the specified software to be proved.

--- Chunk 77 ---
Tokens: 378
Type: sentence-based
Text:
Second, formal require- ments can be reasoned over, permitting desired properties of the specified software to be proved. This permits static validation that the software specified by the requirements does have the properties (e.g, absence of deadlock) that the customer, users and soft- ware engineer expect it to have. This topic is related to Formal Methods in the Software Engineering Models and Methods KA. 3.4. Addressing Conflict in Requirements When a project has more  and more diverse  stakeholders, conflicts among the require- ments are more likely. One particularly important aspect of requirements analysis is identifying and managing such conflicts (e.g, 6, c17). Once conflicting requirements have been identified, the engineer may con- sider two different approaches to managing that conflict (and possibly other approaches as well) and determine the most appropriate course of action. One approach is to negotiate a resolution among the conflicting stakeholders. In most cases, it is unwise for the software engineer to make a unilateral decision, so it becomes necessary to consult with the stakeholders to reach a consensus resolution. It is often also important, for contractual reasons, that such decisions be traceable back to the customer. A specific example is project scope management  namely, balancing whats desired in the stated software product requirements with what can be accomplished given the project require- ments of cost, schedule, staffing and other project-level constraints.

--- Chunk 78 ---
Tokens: 386
Type: sentence-based
Text:
A specific example is project scope management  namely, balancing whats desired in the stated software product requirements with what can be accomplished given the project require- ments of cost, schedule, staffing and other project-level constraints. There are many useful sources for information on negotiation and conflict resolution 25. Another approach is to apply product family development (e.g, 20). This involves sepa- rating requirements into two categories. The first category contains the invariant require- ments. These are requirements that all stake- holders agree on. The second category contains the variant requirements, where conflict exists. The software engineer can focus on under- standing the range of variations needed to satisfy all stakeholders. The software can be designed using design to invariants to accom- modate the invariant requirements and design for change to incorporate customization points to configure an instance of the system to best fit relevant stakeholders. In a simple example, some users of a weather application require temperatures displayed in degrees Celsius while others require degrees Fahrenheit. 4. Requirements Specification 1, c10-14, c20-26 2, s4.4, c5 Requirements specification concerns recording the requirements so they can be both remem- bered and communicated. Requirements specification might be the most contentious topic in this KA. Debate centers on ques- tions such as:  should requirements be written down at all? if requirements are written down, what form should they take?

--- Chunk 79 ---
Tokens: 392
Type: sentence-based
Text:
if requirements are written down, what form should they take? if requirements are written down, should they also be maintained over time? There are no standard answers to these questions; the answer to each can depend on factors such as the following:  the software engineers familiarity with the business domain;  precedent for this kind of software;  degree of risk (e.g, probability, severity) of incorrect requirements;  staff turnover anticipated during the ser- vice life of the software;  geographic distribution of the develop- ment team members;  stakeholder involvement over the course of the project;  whether the use of a third-party service, packaged solution or open source library is anticipated;  whether any design or construction will be outsourced; SOFTWARE REQUIREMENTS 1-11  the degree of requirements-based testing expected;  effort needed to use a candidate specifica- tion technique;  accuracy needed from the require- ments-based estimates;  extent of requirements tracing neces- sary, if any;  contractual impositions of requirements specification content and format. As stated in this KAs introduction, the whats and hows of software requirements work on a project should be determined by the nature of the software constructed, not by the life cycle under which it is constructed. Downstream maintainers should not be able to discern the life cycle used in earlier devel- opment from the form of those requirements alone. The chosen life cycles effect should be limited to the completeness of the require- ments at any point in the project.

--- Chunk 80 ---
Tokens: 387
Type: sentence-based
Text:
The chosen life cycles effect should be limited to the completeness of the require- ments at any point in the project. Under a waterfall life cycle, the requirements are expected to be completely specified at the end of the Requirements phase. Under an Agile life cycle, the requirements are expected to change, grow, or be eliminated continuously and not be complete until the projects end. Some organizations have a culture of docu- menting requirements; some do not. Dynamic startup projects are often driven by a strong product vision and limited resources; their teams might view requirements documen- tation as unnecessary overhead. But as these products evolve and mature, software engi- neers often recognize that they need to recover the requirements that motivated product fea- tures in order to assess the impact of proposed changes. Hence, requirements documentation and change management become important to long-term success. A projects approach to requirements in general, and to requirements specification in particular, may evolve over the service life of that software. The most basic recommendation for requirements documentation is to base deci- sions on an audience analysis. Who are the different consumers who will need informa- tion from a requirements specification? What information will they need? How can that information be packaged and presented so that each consumer can get the information they need with the least effort? There is a degree of overlap and dependency between requirements analysis and specifica- tion.

--- Chunk 81 ---
Tokens: 372
Type: sentence-based
Text:
There is a degree of overlap and dependency between requirements analysis and specifica- tion. Use of certain requirements specifica- tion techniques  particularly model-based requirements specifications  permit and encourage requirements analysis that can go beyond what has already been presented. Documented software requirements should be subject to the same configuration man- agement practices as the other deliverables of the software life cycle processes. (See the Configuration Management KA for a detailed discussion.) In addition, when practical, the individual requirements are also subject to configuration management and traceability, which is generally supported by a requirements management tool. (See Topic 8, Software Requirements Tools.) There are several general categories of requirements specification techniques, each of which is discussed below. The requirements specification for a given project may also use various techniques. ISOIECIEEE 29148 26, as well as 1, c10-14, 5, c4, 6, c16, and many others offer templates for require- ments documentation. 4.1. Unstructured Natural Language Requirements Specification 1, c11 2, s4.4.1 Natural language requirements specifications express requirements in common, ordinary lan- guage. Natural language requirements specifi- cations can be unstructured or structured. A typical unstructured natural language requirements specification is a collection of statements in natural language, such as, The system shall . . . .

--- Chunk 82 ---
Tokens: 377
Type: sentence-based
Text:
. For example, business rules are statements that define or constrain some aspect of the structure or the behavior of the business to be automated. A student cannot register in next semesters courses if there remain any unpaid tuition fees is an example of a business rule that serves as a requirement 1-12 SWEBOK  GUIDE V4.0 for a universitys course-registration software. Some projects can publish a user manual as a satisfactory requirements specification, although there are limits to how effective this can be. (See also 5, c4 26.) 4.2. Structured Natural Language Requirements Specification 1, c8 2, s4.4.2 Structured natural language requirements specifications impose constraints on how the requirements are expressed; the goal is to increase precision and conciseness. The simplest example might be the actor-action format. The actor is the entity responsible for carrying out the action, and action is what needs to happen. A trig- gering event might precede the actor, and the action might be followed by an optional condition or qualification. The statement When an order is shipped, the system shall create an Invoice unless the Order Terms are Prepaid uses actor-action format. The triggering event is When an order is shipped. The actor is the system. The action is create an Invoice. The condition qualification is except the Order Terms are Prepaid. Another example is a use case specifica- tion template, as shown in Figure 1.6. (See 11 for guidelines on writing good use case specifications.)

--- Chunk 83 ---
Tokens: 223
Type: sentence-based
Text:
(See 11 for guidelines on writing good use case specifications.) The user story format, As a user I want capability so that benefit as well as deci- sion tables are other examples. (See also 5, c4 6, c12, c16 7, c2-5.) 4.3. Acceptance Criteria-Based Requirements Specification This general approach includes two specific variants: acceptance test driven develop- ment (ATDD) and behavior driven develop- ment (BDD). ATDD 2, s3.2.3, s8.2 is a part of the larger test driven development (TDD) approach. (See the Software Testing KA.). The main idea of TDD is that test cases pre- cede construction. Therefore, no new produc- tion code is written and no existing code is modified unless at least one test case fails, either at the unit test level or at the acceptance test level. The ATDD process has three steps: 1. A unit of functionality (e.g, a user story) is selected for implementation. 2.

--- Chunk 84 ---
Tokens: 375
Type: sentence-based
Text:
2. One or more software engineers, one or more business domain experts, and pos- sibly one or more QAtest professionals meet  before any production design or Use case 66 Use case name: Reserve ight(s) Triggering event(s) Customer requests reservation(s) on ight(s) Parameters Passenger, itinerary, fare class, payment method(s) Requires Legal itinerary, fare class restrictions met Guarantees Seat(s) reserved for passenger on itinerary ight(s) Normal course Non-FF passenger, all domestic itinerary, Economy fare class, creditdebit card Alternative course(s) Is FF passenger: None, Silver, Gold, Platinum, Elite Itinerary: all international, mixed domestic  international Fare class: Basic economy, Premium Economy, Business, First Payment method: Voucher, FF miles Exceptions CD card declined, voucher doesnt exist, voucher expired, FF account doesnt exist, insucient miles in FF account Figure 1.6. Example of Structured Natural Language Specification for a Single Use Case SOFTWARE REQUIREMENTS 1-13 construction work is done  to agree on a set of test cases that must pass to show that the unit of functionality has been correctly implemented. 3. At least one of those acceptance test cases must fail on the existing software. The existence of at least one failing test case gives the software engineer(s) permis- sion to create or modify production code to pass all of the agreed-upon test cases. This step might require several iterations. The code may also be refactored during this step.

--- Chunk 85 ---
Tokens: 395
Type: sentence-based
Text:
The code may also be refactored during this step. When all acceptance test cases have passed, and presumably all unit and integration test cases as well, then the unit of functionality is deemed to have been completely and correctly implemented. The ATDD process returns to step 1, where a new unit of functionality is selected, and the cycle repeats. ATDD might seem to be a testing tech- nique rather than a requirements specifica- tion technique. On the other hand, a test case has the general form of When given input that looks like X, we expect the software to produce results that look like Y. The key is the underlined phrase, we expect the soft- ware to produce. If we simply modify that phrase to say, the software shall produce, as in When given input that looks like X, the software shall produce results that look like Y, what first looked like a test case now looks like a requirement. Technically, one acceptance test case can encompass more than one single requirement, but the gen- eral idea holds that the ATDD test cases are essentially precise, unambiguous statements of requirements. The BDD approach 19 is slightly more structured, and business domain experts typ- ically prefer it over ATDD because it is less technical in appearance. In BDD, the unit of functionality is described as a user story, in a form such as this: As a user I want capability so that benefit. This leads to the identification and specification of a set of scenarios in this form: Given some con- text and possibly more context, when stimulus then outcome and possibly more outcomes.

--- Chunk 86 ---
Tokens: 387
Type: sentence-based
Text:
This leads to the identification and specification of a set of scenarios in this form: Given some con- text and possibly more context, when stimulus then outcome and possibly more outcomes. If the story is As a bank customer, I want to withdraw cash from the automated teller machine (ATM) so that I can get money without going to the bank, one scenario could be that the account has a sufficient balance. This scenario could be detailed as Given the account balance is 500, and the customers bank card is valid, and the automated teller machine contains enough money in its cash box, when the Account Holder requests 100, then the ATM should dispense 100 and the account balance should be 400, and the cus- tomers bank card should be returned. Another scenario could be that the account has an insufficient balance and could be detailed as Given the account bal- ance is 50, and the customers bank card is valid, and the automated teller machine con- tains enough money in its cash box, when the Account Holder requests 100, then the ATM should not dispense any money, and the ATM should say there is an insufficient bal- ance, the balance should remain at 50, and the customers bank card should be returned. The goal of BDD is to have a comprehensive set of scenarios for each unit of functionality. In the withdrawing cash situation, additional scenarios for The Bank Customers bank card has been disabled and The ATM does not contain enough money in its cash box would be necessary. The acceptance test cases are obvious from the BDD scenarios.

--- Chunk 87 ---
Tokens: 397
Type: sentence-based
Text:
The acceptance test cases are obvious from the BDD scenarios. Acceptance criteria-based requirements specification directly addresses the require- ments ambiguity problem. Natural languages are inherently ambiguous, but test case lan- guage is not. In acceptance-based criteria requirements specification, the requirements are written using test case language, which is very precise. On the other hand, this does not inherently solve the incompleteness problem. However, combining ATDD or BDD with appropriate functional test coverage cri- teria, such as Domain Testing, Boundary Value Analysis and Pairwise Testing (see the Software Testing KA), can reduce the 1-14 SWEBOK  GUIDE V4.0 likelihood of requirements incompleteness. (See also 9, c1, c12.) 4.4. Model-Based Requirements Specification 1, c12 2, c5 4 Another approach to avoiding the inherent ambiguity of natural languages is to use mod- eling languages such as selected elements of the unified modeling language (UML) or systems modeling language (SysML). Much like the blueprints used in building construc- tion, these modeling languages can be used in a computing technology-free manner to precisely and concisely specify functional requirements 9, c1-2. This topic is closely related to the Software Engineering Models and Methods KA. Requirements models fall into two general categories: 1. Structural models for specifying poli- cies to be enforced: These are logical class models as described in, for example, 9, c8. They are also called conceptual data models, logical data models and enti- ty-relationship diagrams. 2.

--- Chunk 88 ---
Tokens: 365
Type: sentence-based
Text:
2. Behavioral models for specifying pro- cesses to be carried out: These models include use case modeling as described in 9, c7, interaction diagrams as described in 9, c9 and state modeling as described in 9, c10. Other examples are UML activity diagrams and data-flow mod- eling, as described in 1, c12-13, 8, 10 and 18. Model-based requirements specifica- tions vary in the degree of model formality. Consider the following: 1. Agile modeling (see, for example, 10) is the least formal. Agile models can be little more than rough sketches whose goal is to communicate important infor- mation rather than demonstrate proper use of modeling notations. In this type of modeling, the effect of the communi- cation is considered more important than the form of the communication. 2. Semiformal modeling, for example 9, c6-12, provides a definition of the mod- eling language semantics (9, Appendix L), but that definition has not been formally proved to be complete and consistent. 3. Formal modeling, for example, Z, the Vienna development method (VDM), specification and description language (SDL) and 5, c7 have very precisely defined semantics that allow specifica- tions to be mechanically analyzed for the presence or absence of specific properties to help avoid critical reasoning errors. The term correctness by construction has been used for development in this con- text. (See the Formal Methods section in the Software Engineering Models and Methods KA.)

--- Chunk 89 ---
Tokens: 273
Type: sentence-based
Text:
(See the Formal Methods section in the Software Engineering Models and Methods KA.) Generally, the more formal a requirements model is, the less ambiguous it is, so soft- ware engineers are less likely to misinterpret the requirements. More formal requirements models can also be:  more concise and compact;  easier to translate into code, possibly mechanically;  used as a basis for deriving acceptance test cases. One important message in 4 is that while formal modeling languages are stronger than semiformal and Agile modeling, formal nota- tions can burden both the model creator and human readers. Wings compromise is to use formally defined underpinnings (e.g, in Z) for surface syntaxes that are easier to read and write (e.g, UML statecharts). 4.5. Additional Attributes of Requirements 1, c27pp462-463 Over and above the basic requirements statements already described, documenting additional attributes for some or all require- ments can be useful. This supplemental detail can help software engineers better SOFTWARE REQUIREMENTS 1-15 interpret and manage the requirements 6, c16.

--- Chunk 90 ---
Tokens: 379
Type: sentence-based
Text:
This supplemental detail can help software engineers better SOFTWARE REQUIREMENTS 1-15 interpret and manage the requirements 6, c16. Possible additional attributes include the following:  tag to support requirements tracing;  description (additional details about the requirement);  rationale (why the requirement is important);  source (role or name of the stakeholder who imposed this requirement);  use case or relevant triggering event;  type (classification or category of the requirement  e.g, functional, quality of service);  dependencies;  conflicts;  acceptance criteria;  priority (see Requirements Prioritization later in this KA);  stability (see Requirements Stability and Volatility later in this KA);  whether the requirement is common or a variant for product family development (e.g, 20);  supporting materials;  the requirements change history. Gilbs Planguage (short for Planning Language) 7 recommends attributes such as scale, meter, minimum, target, outstanding, past, trend and record. 4.6. Incremental and Comprehensive Requirements Specification Projects that explicitly document require- ments take one of two approaches. One can be called incremental specification. In this approach, a version of the requirements speci- fication contains only the differences  addi- tions, modifications and deletions  from the previous version. An advantage of this approach is that it can produce a smaller volume of written specifications. The other approach can be called compre- hensive specification.

--- Chunk 91 ---
Tokens: 378
Type: sentence-based
Text:
The other approach can be called compre- hensive specification. In this approach, each versions requirements specification con- tains all requirements, not just changes from the previous version. An advantage of this approach is that a reader can understand all requirements in a single document instead of having to keep track of cumulative additions, modifications and deletions across a series of specifications. Some organizations combine these two approaches, producing intermediate releases (e.g, x.1, x.2 and x.3) that are specified incre- mentally and major releases (e.g, 1.0, 2.0 and 3.0) that are specified comprehensively. The reader never needs to go any further back than the requirements specifications for the last major release to obtain the complete set of specifications. 5. Requirements Validation 1, c17 2, s4.5 Requirements validation concerns gaining confidence that the requirements represent the stakeholders true needs as they are cur- rently understood (and possibly documented). Key questions include the following:  do these represent all requirements rele- vant at this time? are any stated requirements not represen- tative of stakeholder needs? are these requirements appropri- ately stated? are the requirements understandable, consistent and complete? does the requirements documentation conform to relevant standards? Three methods for requirements validation tend to be used: requirements reviews, sim- ulation and execution, and prototyping. (See also 5, c5 6, c17 9, c12.) 5.1.

--- Chunk 92 ---
Tokens: 397
Type: sentence-based
Text:
5.1. Requirements Reviews 1, c17pp332-342 2, c4p130 The most common way to validate is by reviewing or inspecting a requirements docu- ment. One or more reviewers are asked to look for errors, omissions, invalid assumptions, lack of clarity and deviation from accepted 1-16 SWEBOK  GUIDE V4.0 practice. Review from multiple perspectives is preferred:  clients, customers and users check that their wants and needs are completely and accurately represented;  other software engineers with expertise in requirements specification check that the document is clear and conforms to applicable standards;  software engineers who will do architec- ture, design or construction of the soft- ware that satisfies these requirements check that the document is sufficient to support their work. Providing checklists, quality criteria or a definition of done to the reviewers can guide them to focus on specific aspects of the requirements specification. (See Reviews and Audits in the Software Quality KA.) 5.2. Simulation and Execution Nontechnical stakeholders might not want to spend time reviewing a specification in detail. Some specifications can be subjected to sim- ulation or actual execution in place of or in addition to human review. To the extent that the requirements are formally specified (e.g, in a model-based specification), software engineers can hand interpret that specifica- tion and execute the specification. Given a sufficient set of demonstration scenarios, stakeholders can be convinced that the spec- ification defines their policies and processes completely and accurately.

--- Chunk 93 ---
Tokens: 386
Type: sentence-based
Text:
Given a sufficient set of demonstration scenarios, stakeholders can be convinced that the spec- ification defines their policies and processes completely and accurately. (See 9, c12.) 5.3. Prototyping 1, c17p342 2, c4p130 If the requirements specification is not in a form that allows direct simulation or exe- cution, an alternative is to have a software engineer build a prototype that concretely demonstrates some important dimension of an implementation. This demonstrates the software engineers interpretation of those requirements. Prototypes can help expose software engi- neers assumptions and, where needed, give useful feedback on why they are wrong. For example, a user interfaces dynamic behavior might be better understood through an ani- mated prototype than through textual description or graphical models. However, a danger of prototyping is that cosmetic issues or quality problems with the prototype can distract the reviewers attention from the core underlying functionality. Prototypes can also be costly to develop. However, if a prototype helps engineers avoid the waste caused by trying to satisfy erroneous requirements, its cost can be more easily justified. 6. Requirements Management Activities 1, c27-28 2, s4.6 Requirements development, as a whole, can be thought of as reaching an agreement on what software is to be constructed. (See Figure 1.3.) In contrast, requirements management can be thought of as maintaining that agree- ment over time. This topic examines require- ments management. (See also 5, c9.) 6.1.

--- Chunk 94 ---
Tokens: 284
Type: sentence-based
Text:
6.1. Requirements Scrubbing The goal of requirements scrubbing 22, c14, c32 is to find the smallest set of simply stated requirements that will meet stakeholder needs. Doing so will reduce the size and complexity of the solution, thus minimizing the effort, cost and schedule to deliver it. Requirements scrub- bing involves eliminating requirements that:  are out of scope;  would not yield an adequate return on investment;  are not that important. Another important part of the process is to simplify unnecessarily complicated requirements. In waterfall and other plan-based life cycles, requirements scrubbing can be coordi- nated with requirements reviews for valida- tion; scrubbing should occur just before the SOFTWARE REQUIREMENTS 1-17 validation review. In Agile life cycles, scrub- bing happens implicitly in iteration planning; only the highest-priority requirements are brought into a sprint (iteration). 6.2. Requirements Change Control 1, c28 2, s4.6 Change control is central to managing requirements. This topic is closely linked to the Software Configuration Management KA. (Refer to that chapter for more information.)

--- Chunk 95 ---
Tokens: 350
Type: sentence-based
Text:
(Refer to that chapter for more information.) Projects using waterfall or other plan-based life cycles should have an explicit require- ments change control process that includes:  a means to request changes to previously agreed-upon requirements;  an optional impact analysis stage to more thoroughly examine benefits and costs of a requested change;  a responsible person or group who decides to accept, reject, or defer each requested change;  a means to notify all affected stakeholders of that decision;  a means to track accepted changes to closure. All stakeholders must understand and agree that accepting a change means accepting its impact on schedule, resources andor com- mensurate change in scope elsewhere in the project. Ideally the change in scope should be objectively quantifiable, i.e, in terms of func- tional size units. In contrast, requirements change manage- ment happens implicitly in Agile life cycles. In these life cycles, any request to change pre- viously agreed-upon requirements becomes just another item on the product backlog. A request will only become accepted when it is prioritized highly enough to make it into an iteration (a sprint). (See also 5, c9 22, c17.) 6.3. Scope Matching Scope matching 22, c14 involves ensuring that the scope of requirements to architect, design and construct does not exceed any cost, schedule or staffing constraints on the project.

--- Chunk 96 ---
Tokens: 397
Type: sentence-based
Text:
Scope Matching Scope matching 22, c14 involves ensuring that the scope of requirements to architect, design and construct does not exceed any cost, schedule or staffing constraints on the project. When requirements scope exceeds the cost, schedule or staffing constraints, then either that scope must be reduced (pre- sumably by removing a sufficient number of the lowest-priority requirements), capacity must be increased (by extending the schedule or increasing the budget andor staffing), or some appropriate combination thereof must be negotiated. Where possible, scope matching should be quantitative instead of qualitative, i.e, in terms of functional size units. In waterfall and other plan-based life cycles, scope matching can be coordinated with requirements validation; the scope matching should occur just before the validation review. In Agile life cycles, as long as some variant of velocity-based sprint planning is done, then the only work allowed into a sprintiteration will be the work that can reasonably be expected to be completed during that sprintiteration. 7. Practical Considerations 7.1. Iterative Nature of the Requirements Process 2, s4.2 Requirements for typical software not only have wide breadth; they must also have significant depth. The tension created by simultaneous breadth-wise and depth-wise requirements in real-world projects often prompts teams to perform requirements activ- ities iteratively. At some points, elicitation and analysis favor expanding the breadth of requirements knowledge, while at other points, expanding the depth is called for.

--- Chunk 97 ---
Tokens: 398
Type: sentence-based
Text:
At some points, elicitation and analysis favor expanding the breadth of requirements knowledge, while at other points, expanding the depth is called for. In practice, it is highly unlikely that all requirements work can be done in a single pass through the sub- ject matter. (See also 6, c2, c9.) 7.2. Requirements Prioritization 1, c16 Prioritizing requirements is useful throughout a software project because it helps focus soft- ware engineers on delivering the most valuable functionality soonest. It also helps support intelligent trade-off decisions involving 1-18 SWEBOK  GUIDE V4.0 conflict resolution and scope matching. Prioritized requirements also help in mainte- nance beyond the initial development project itself. Defects raised against higher-priority requirements should probably be repaired before defects raised against lower-pri- ority ones. A variety of prioritization schemes are available. Answering a few key questions can help engineers choose the best approach. The first question is What factors are relevant in determining the priority of one requirement over another? The following factors might be relevant to a project:  value; desirability; client, customer and user satisfaction;  undesirability; client, customer and user dissatisfaction (Kano model, below);  cost to deliver;  cost to maintain over the softwares ser- vice life;  technical risk of implementation;  risk that users will not use it even if implemented. The Kano model, which underlies 6, c17, shows that considering only value, desir- ability or satisfaction can lead to erroneous priorities.

--- Chunk 98 ---
Tokens: 392
Type: sentence-based
Text:
The Kano model, which underlies 6, c17, shows that considering only value, desir- ability or satisfaction can lead to erroneous priorities. A better understanding of priorities comes from considering how unhappy stake- holders would be if that requirement were not satisfied. For example, consider a project to develop an email client. Two candidate requirements might relate to: 1. Having an effective spam filter 2. Handling attachments on emails Prioritization must weigh both the satis- faction users will experience from having cer- tain features and the dissatisfaction they will experience if they lack certain features. For example, users are more likely to be happy with an effective spam filter than with the ability to handle attachments, so the spam filter would be given a higher priority based on the satisfaction criterion. On the other hand, the inability to handle attachments would make many users extremely unhappy  much more so than not having an effective spam filter. When considering happiness, or satis- faction, from implementing features combined with unhappiness (or dissatisfaction) from not implementing certain features, developers would generally give handling attachments a higher priority than the effective spam filter. The second key question is How can we convert the set of relevant factors into an expression of priority? The formula Cost Priority  (Value  (1-Risk)) is just one example of an objective function to do so. The choice of measurement schemes for the relevant factors can impose constraints on the objective function.

--- Chunk 99 ---
Tokens: 383
Type: sentence-based
Text:
The choice of measurement schemes for the relevant factors can impose constraints on the objective function. (See Measurement Theory in Computing Foundations). Once the priority of the requirements has been determined, those priorities must be specified in a way that can be communicated to all stakeholders. Several ways to do this are possible, including the following:  enumerated scale (e.g, must have, should have, nice to have);  numerical scale (e.g, 1 . . . 10);  Lists that sort the requirements in decreasing priority order. Effective requirement prioritization focuses on finding groups of requirements with sim- ilar priorities rather than creating overly rig- orous measurement scales or debating small differences. 7.3. Requirements Tracing 1, c29 Requirements tracing can serve two poten- tially useful purposes. One is to serve as an accounting exercise that documents consis- tency between pairs of related project work products. An important question might be For each identified software requirement, are there identified design elements intended to satisfy it? If no identified design elements can be found, then either that requirement is not satisfied in that design or the design is SOFTWARE REQUIREMENTS 1-19 correct and one or more stated requirements can be deleted. Similarly, For each identified design element, are there identified require- ments that cause it to exist? If no identified requirements can be found, then either that design element is unnecessary or the stated requirements are incomplete.

--- Chunk 100 ---
Tokens: 398
Type: sentence-based
Text:
If no identified requirements can be found, then either that design element is unnecessary or the stated requirements are incomplete. The other purpose is to assist in impact analysis of a proposed requirement change. If a particular system requirement were to change, for example, that system requirement could be traced to its linked software require- ments. Not all linked software requirements would need to change. But each software requirement that would be affected could be traced to its linked design elements. Again, not all linked design elements would need to change. But each design element affected could be traced to the linked code. The affected software requirements, design ele- ments and code units could also be traced to their linked test cases for further impact anal- ysis. This helps establish a footprint for the volume of work needed to incorporate that change to the system requirement. Software requirements can be traced back to source documentation such as system requirements, standards documents and other relevant specifications. Software requirements can also be traced forward to design elements and requirements-based test cases. Finally, software requirements can also be traced for- ward to sections in a user manual describing the implemented functionality. (See also 23.) 7.4. Requirements Stability and Volatility 2, s4.6 Some requirements are very stable; they will probably never change over the softwares ser- vice life. Some requirements are less stable; they might change over the service life but might not change during the development project.

--- Chunk 101 ---
Tokens: 397
Type: sentence-based
Text:
Some requirements are less stable; they might change over the service life but might not change during the development project. For example, in a banking applica- tion, requirements for functions to calculate and credit interest to customers accounts are likely to be more stable than require- ments to support different tax-free accounts. The former reflects a banking domains fundamental feature (that accounts can earn interest). At the same time, the latter may be rendered obsolete by a change in govern- ment legislation. Finally, some requirements can be very unstable; they can change during the project  possibly more than once. It is useful to assess the likelihood that a require- ment will change in a given time. Identifying potentially volatile requirements helps the software engineer establish a design more tol- erant of change, (e.g, 20). (See also 9, c4.) 7.5. Measuring Requirements 1, c19 As a practical matter, it may be useful to have some concept of the volume of the require- ments for a particular software product. This number is useful in evaluating the size of a new development project or the size of a change in requirements and in estimating the cost of development or maintenance tasks (e.g, 9, c23), or simply for use as the denom- inator in other measurements. Functional size measurement (FSM) is a technique for evalu- ating the size of a body of functional require- ments. Story points can also be considered a measure of requirements size. Additional information on size measure- ment and standards can be found in the Software Engineering Process KA.

--- Chunk 102 ---
Tokens: 356
Type: sentence-based
Text:
Additional information on size measure- ment and standards can be found in the Software Engineering Process KA. Many quality indicators have been devel- oped that can be used to relate the quality of software requirements specification to other project variables such as cost, acceptance, performance, schedule and reproducibility. Quality indicators for individual software requirements and a requirements specifica- tion document as a whole can be derived from the desirable properties discussed in Section 3.1, Basic Requirements Analysis, earlier in this KA. 7.6. Requirements Process Quality and Improvement 1, c31 This topic concerns assessing the quality and improvement of the requirements process. Its purpose is to emphasize the key role of the 1-20 SWEBOK  GUIDE V4.0 requirements process in a software products cost and timeliness and in customer satisfac- tion. Furthermore, it helps align the require- ments process with quality standards and process improvement models for software and systems. Process quality and improvement are closely related to both the Software Quality KA and Software Engineering Process KA, comprising the following:  requirements process coverage by process improvement standards and models;  requirements process measures and benchmarking;  improvement planning and implementation;  securityCIA (confidentiality, integrity, and availability) improvementplanning and implementation. 8.

--- Chunk 103 ---
Tokens: 380
Type: sentence-based
Text:
8. Software Requirements Tools 1, c30 Tools that help software engineers deal with software requirements fall broadly into three categories: requirements management tools, requirements modeling tools and functional test case generation tools, as discussed below. 8.1. Requirements Management Tools 1, c30pp506-510 Requirements management tools support var- ious activities, including storing requirements attributes, tracing, document generation and change control. Indeed, tracing and change control might only be practical when sup- ported by a tool. Because requirements man- agement is fundamental to good requirements practice, many organizations have invested in tools. However, many more manage their requirements in more ad hoc and generally less satisfactory ways (e.g, spreadsheets). (See also 5, c8.) 8.2. Requirements Modeling Tools 1, c30p506 2, s12.3.3 At a minimum, a requirements modeling tools support visually creating, modifying and publishing model-based requirements speci- fications. Some tools extend that by also pro- viding static analysis (e.g, syntax correctness, completeness and consistency). Formal anal- ysis requires tool support to be practicable for anything other than trivial systems, and tools generally fall into two categories: theorem provers or model checkers. In neither case can proof be fully automated, and the com- petence in formal reasoning needed to use the tools restricts the wider formal analysis. Some tools also dynamically execute a specification (simulation). 8.3.

--- Chunk 104 ---
Tokens: 399
Type: sentence-based
Text:
8.3. Functional Test Case Generation Tools The more formally defined a requirements specification language is, the more likely it is that functional test cases can be at least partially derived mechanically. For example, converting BDD scenarios into test cases is not difficult. Another example involves state models. Positive test cases can be derived for each defined transition in that kind of model. Negative test cases can be derived from the state and event combinations that do not appear. (See Section 8.2, Testing Tools in the Testing KA, for more informa- tion.) A process for deriving test cases from UML requirements models can be found in 9, c12. In the most general case, such tools can only generate test case inputs. Determining an expected result is not always possible, additional business domain expertise might be necessary. SOFTWARE REQUIREMENTS 1-21 MATRIX OF TOPICS VS. REFERENCE MATERIAL Wiegers 2013 1 Sommerville 2018 2 Tockey 2005 3 Wing 1990 4 1. Software Requirements Fundamentals 1.1. Definition of a Software Requirement c1pp5-6 c4p102 1.2. Categories of Software Requirements c1pp7-12 s4.1 1.3. Software Product Requirements and Software Project Requirements c1pp14-15 1.4. Functional Requirements c1p9 s4.1.1 1.5. Nonfunctional Requirements c1pp10-11 s4.1.2 1.6. Technology Constraints 1.7. Quality of Service Constraints 1.8. Why Categorize Requirements This Way? 1.9. System Requirements and Software Requirements 1.10. Derived Requirements 1.11. Software Requirements Activities c1pp15-18 s4.2 2. Requirements Elicitation 2.1. Requirements Sources c6 s4.3 2.2.

--- Chunk 105 ---
Tokens: 350
Type: sentence-based
Text:
Requirements Sources c6 s4.3 2.2. Common Requirements Elicitation Techniques c7 s4.3 3. Requirements Analysis 3.1. Basic Requirements Analysis c8-9 3.2. Economics of Quality of Service Constraints c1-27 3.3. Formal Analysis s12.3.2-12.3.3 3.4. Addressing Conflict in Requirements 4. Requirements Specification 4.1. Unstructured Natural Language Requirements Specification c11 s4.4.1 4.2. Structured Natural Language Requirements Specification c8 s4.4.2 4.3. Acceptance Criteria-Based Requirements Specification s3.2.3, s8.2 4.4. Model-Based Requirements Specification c12 c5 pp8-11 4.5. Additional Attributes of Requirements c27pp462-463 4.6. Incremental and Comprehensive Requirements Specification 5. Requirements Validation 5.1. Requirements Reviews c17pp332-342 c4p130 5.2. Simulation and Execution 5.3. Prototyping c17p342 c4p130 1-22 SWEBOK  GUIDE V4.0 6. Requirements Management Activities 6.1. Requirements Scrubbing 6.2. Requirements Change Control c28 s4.6 6.3. Scope Matching 7. Practical Considerations 7.1. Iterative Nature of the Requirements Process s4.2 7.2. Requirements Prioritization c16 7.3. Requirements Tracing c29 7.4. Requirements Stability and Volatility s4.6 7.5. Measuring Requirements c19 7.6. Requirements Process Quality and Improvement c31 8. Software Requirements Tools 8.1. Requirements Management Tools c30pp506-510 8.2. Requirements Modeling Tools c30p506 s12.3.3 8.3.

--- Chunk 106 ---
Tokens: 371
Type: sentence-based
Text:
Requirements Modeling Tools c30p506 s12.3.3 8.3. Functional Test Case Generation Tools FURTHER READINGS IIBA, A Guide to the Business Analysis Body of Knowledge (BABOK Guide) v3 30 The BABOK Guide is the reference body of knowledge for the Business Analysis commu- nity and provides a comprehensive descrip- tion of that discipline. While broader than just requirements and just for software, a very large portion of the BABOK Guide content is relevant to software requirements. P. LaPlante, Requirements Engineering for Software and Systems 5. This book is one potential alternative to 1, offering a comprehensive discussion of soft- ware requirements. S. Robertson and J. Robertson, Mastering the Requirements Process: Getting Requirements Right 6. This book is another potential alternative to 1, offering a comprehensive discussion of software requirements. T. Gilb, Competitive Engineering: A Handbook for Systems Engineering, Requirements Engineering, and Software Engineering Using Planguage 7. This book presents a unique perspective on requirements, emphasizing requirements pre- cision and completeness along with a strong business value-driven motivation. K. Wiegers, Software Development Pearls: Lessons from Fifty Years of Software Experience 21. This book is a compendium of important but often unrecognized key success factors based on Dr. Wiegers extensive real-world experience. Chapter 2 is specific to software requirements. R. Fisher and W. Ury, Getting to Yes 25.

--- Chunk 107 ---
Tokens: 391
Type: sentence-based
Text:
R. Fisher and W. Ury, Getting to Yes 25. This book is a classic reference on principled negotiation and conflict resolution that serves as one good basis for addressing inevitable SOFTWARE REQUIREMENTS 1-23 conflict in software requirements when there are multiple stakeholders. N. Ahmad, Effects of Electronic Communication on the Elicitation of Tacit Knowledge in Interview Techniques for Small Software Developments 29. This doctoral thesis shows how using four different types of electronic communication tools to discuss interview agenda details with interviewees before conducting semi-struc- tured interviews for requirements elicita- tion improved elicitation of tacit (hidden) knowledge. REFERENCES 1 K. E. Wiegers and J. Beatty, Software Requirements, 3rd ed, Redmond, WA: Microsoft Press, 2013. 2 I. Sommerville, Software Engineering, 10th ed, New York: Addison-Wesley, 2018. 3 S. Tockey, Return on Software: Maximizing the Return on Your Software Investment, Boston, MA: Addison- Wesley, 2005. 4 J. M. Wing, A Specifiers Introduction to Formal Methods, Computer, vol. 23, no. 9, 1990, pp. 8, 10-23. 5 P. Laplante and M. Kassab, Requirements Engineering for Software and Systems, 4th ed, Boca Raton, FL: CRC Press, 2022. 6 S. Robertson and J. Robertson, Mastering the Requirements Process: Getting Requirements Right, Upper Saddle River, NJ: Addison- Wesley, 2013. 7 T. Gilb, Competitive Engineering: A Handbook for Systems Engineering, Requirements Engineering, and Software Engineering Using Planguage, Oxford, UK: Elsevier Butterworth- Heinemann, 2005.

--- Chunk 108 ---
Tokens: 384
Type: sentence-based
Text:
7 T. Gilb, Competitive Engineering: A Handbook for Systems Engineering, Requirements Engineering, and Software Engineering Using Planguage, Oxford, UK: Elsevier Butterworth- Heinemann, 2005. 8 E. Yourdon, Modern Structured Analysis, Englewood Cliffs, NJ: Prentice- Hall, 1989. 9 S. Tockey, How to Engineer Software, Hoboken, NJ: Wiley, 2019. 10 S. Ambler, Agile Modeling: Effective Practices for eXtreme Programming and the Unified Process, Hoboken, NJ: Wiley, 2002. 11 A. Cockburn, Writing Effective Use Cases, Upper Saddle River, NJ: Addison-Wesley, 2000. 12 L. Constantine and L. Lockwood, Software for Use, Reading, MA: Addison-Wesley, 2000. 13 J. Wood and D. Silver, Joint Application Development, New York, NY: Wiley, 1995. 14 E. Gottesdiener, Requirements by Collaboration, Boston, MA: Addison- Wesley, 2002. 15 J. Terninko, Step by Step QFD, 2nd ed, Boca Raton, FL: CRC Press, 1997. 16 G. Salvendy, Handbook of Human Factors, 4th ed, Hoboken, NJ: Wiley, 2012. 17 T. Brown and B. Katz, Change by Design: How Design Thinking Transforms Organizations and Inspires Innovation, Revised and updated ed, New York, NY: Harper Collins, 2019. 18 S. McMenamin and J. Palmer, Essential Systems Analysis, New York, NY: Yourdon Press, 1984. 19 J. Smart, BDD in Action: Behavior- Driven Development for the Whole 1-24 SWEBOK  GUIDE V4.0 Software Lifecycle, Shelter Island, NY: Manning Publications, 2015. 20 D. Weiss and C. Lai, Software Product- Line Engineering: A Family-Based Software Development Process, Reading, MA: Addison-Wesley, 1999.

--- Chunk 109 ---
Tokens: 396
Type: sentence-based
Text:
20 D. Weiss and C. Lai, Software Product- Line Engineering: A Family-Based Software Development Process, Reading, MA: Addison-Wesley, 1999. 21 K. Wiegers, Software Development Pearls: Lessons from Fifty Years of Software Experience, Boston, MA: Addison-Wesley Professional, 2021. 22 S. McConnell, Rapid Development, Redmond, WA: Microsoft Press, 1996. 23 O. Gotel and C. W. Finkelstein, An Analysis of the Requirements Traceability Problem, presented at the Proceedings of the 1st International Conference on Requirements Engineering, 1994. 24 INCOSE, Systems Engineering Handbook: A Guide for System Life Cycle Processes and Activities, 3.2.2 ed, San Diego, US: International Council on Systems Engineering, 2012. 25 R. Fisher and W. Ury, Getting to Yes, 3rd ed, New York, NY: Penguin, 2011. 26 ISOIECIEEE 29148 Systems and software engineering  Life cycle processes  Requirements engi- neering, International Standards Organization, 2018. 27 ISOIEC 25010: System and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  System and software quality models, International Standards Organization, 2011. 28 ISOIECIEEE, ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, 2nd ed. 2017. 29 N. Ahmad, Effects of Electronic Communication on the Elicitation of Tacit Knowledge in Interview Techniques for Small Software Developments, doctoral thesis, University of Huddersfield, 2021. 30 IIBA, A Guide to the Business Analysis Body of Knowledge (BABOK Guide) v3, International Institute of Business Analysis, Toronto, Ontario, Canada, 2015.

--- Chunk 110 ---
Tokens: 398
Type: sentence-based
Text:
30 IIBA, A Guide to the Business Analysis Body of Knowledge (BABOK Guide) v3, International Institute of Business Analysis, Toronto, Ontario, Canada, 2015. 2-1 CHAPTER 02 Software Architecture ACRONYMS AD Architecture Description ADL Architecture Description Language API Application Programming Interface ASR Architecturally Significant Requirement ATAM Architectural Tradeoff Analysis Method IDL Interface Description Language MVC Model View Controller QAW Quality AttributeWorkshop RA Reference Architecture REST Representational State Transfer SAAM Software Architecture Analysis Method UML Unified Modeling Language INTRODUCTION This chapter considers software architecture from several perspectives: concepts; repre- sentation and work products; context, process and methods; and analysis and evaluation. In contrast to the previous edition, this edi- tion creates a software architecture knowledge area (KA), separate from the Software Design KA, because of the significant interest and growth of the discipline since the 1990s. BREAKDOWN OF TOPICS FOR SOFTWARE ARCHITECTURE The breakdown of topics for the Software Architecture KA is shown in Figure 2.1. 1. Software Architecture Fundamentals 2c1-2, 38c2, 41c1-3, 29, 34 1.1. The Senses of Architecture 2c1, 29 Software engineering and related disciplines use many senses of architecture. First, architecture often refers to a discipline: the art and science of constructing things  in this case, software-intensive systems. The dis- cipline involves concepts, principles, processes and methods the community has discovered and adopted.

--- Chunk 111 ---
Tokens: 368
Type: sentence-based
Text:
The dis- cipline involves concepts, principles, processes and methods the community has discovered and adopted. Second, architecture refers to the various processes through which that discipline is realized. Software architecture is also consid- ered part of Software Design; generally con- sidered a multistage process, divided into the following stages:  Architectural design stage  High-level design stage  Detailed design stage Software design is the focus of Chapter 3. This chapter focuses on architecting and archi- tectural design. Third, architecture refers to the out- come of applying architectural design disci- pline and processes to devise architectures for software systems. Architectures as out- comes are expressed in architecture descrip- tions. This is discussed in topic Software Architecture Description. The concept of architecture has evolved, and many defi- nitions are in use today. One early defini- tion of architecture, from 1990, emphasized software structure: Architecture. The organizational struc- ture of a system or component. from: IEEE 2-2 SWEBOK  GUIDE V4.0 Std 610.121990, IEEE Glossary of Software Engineering Terminology This definition did not do justice to evolving thinking about architecture; e.g, this definition does not allow us to distinguish the detailed design of a module from its Makefile. Either example reflects an organizational structure of the software system or component but should not be considered architecture.

--- Chunk 112 ---
Tokens: 386
Type: sentence-based
Text:
Either example reflects an organizational structure of the software system or component but should not be considered architecture. Moreover, emphasis on the structure was often limited to the codes structure and failed to encompass all the structures of the software system: The software architecture of a system is the set of structures needed to reason about the system. These structures comprise software ele- ments, relations among them, and properties of both. 2 During the mid-1990s, however, software architecture emerged as a broader discipline involving a more generic study of software structures and architectures. Many software system structures are not directly reflected in the code structure. Both types of struc- ture have implications for the system as a whole: What behaviors is the system capable of? What interactions does it have with other systems? How are properties like safety and security handled? The recognition that soft- ware contains many different structures has prompted discussion of a number of inter- esting concepts about software architecture (and software design more generally) leading to current definitions such as: architecture (of a system). fundamental con- cepts or properties of a system in its environ- ment embodied in its elements, relationships, and in the principles of its design and evo- lution 23 Key ideas in that definition are the fol- lowing: (1) Architecture is about what is fundamental to a software system; not every element, interconnection, or interface is con- sidered fundamental.

--- Chunk 113 ---
Tokens: 377
Type: sentence-based
Text:
fundamental con- cepts or properties of a system in its environ- ment embodied in its elements, relationships, and in the principles of its design and evo- lution 23 Key ideas in that definition are the fol- lowing: (1) Architecture is about what is fundamental to a software system; not every element, interconnection, or interface is con- sidered fundamental. (2) Architecture con- siders a system in its environment. Much like building architecture, software architec- ture is outward-looking; it considers a sys- tems context beyond its boundaries including the people, organizations, software, hard- ware and other devices with which the system must interact. Software Architecture Te Senses of architecture Architecture Views and Viewpoints Architecture in Context Goodness in Architecture Reasoning about Architectures Architecture Reviews Architecture Metrics Architectural Design Architecture Methods and Tactics Architecture in the Large Architecture Styles and Patterns Architecture Description Languages and Architecture Framework Architecture as Signifcant Decisions Stakeholders and Concerns Uses of Architecture Software Architecture Description Software Architecture Fundamentals Software Architecture Process Software Architecture Evaluation Figure 2.1. Breakdown of Topics for the Software Architecture KA SOFTWARE ARCHITECTURE 2-3 1.2. Stakeholders and Concerns 2c3-14, 38c8-9, 41c3, 12, 23, 24 A software system has many stakeholders with varying roles and interests relative to that system.

--- Chunk 114 ---
Tokens: 390
Type: sentence-based
Text:
Stakeholders and Concerns 2c3-14, 38c8-9, 41c3, 12, 23, 24 A software system has many stakeholders with varying roles and interests relative to that system. These varying interests are termed con- cerns, following Dijkstras separation of concerns: Let me try to explain to you, what to my taste is characteristic for all intelligent thinking. It is, that one is willing to study in depth an aspect of ones subject matter in isolation for the sake of its own consistency, all the time knowing that one is occupying oneself only with one of the aspects. We know that a pro- gram must be correct and we can study it from that viewpoint only; we also know that it should be efficient and we can study its effi- ciency on another day, so to speak. In another mood we may ask ourselves whether, and if so: why, the program is desirable. But nothing is gained  on the contrary! by tackling these various aspects simultaneously. It is what I sometimes have called the separation of con- cerns, which, even if not perfectly possible, is yet the only available technique for effective ordering of ones thoughts, that I know of. This is what I mean by focusing ones attention upon some aspect: it does not mean ignoring the other aspects, it is just doing justice to the fact that from this aspects point of view, the other is irrelevant. It is being one- and multi- ple-track-minded simultaneously. 12 What is fundamental about a system varies according to stakeholders concerns and roles. The software structures, therefore, also vary with stakeholder roles and concerns.

--- Chunk 115 ---
Tokens: 378
Type: sentence-based
Text:
The software structures, therefore, also vary with stakeholder roles and concerns. (See also topic Design Methods in Software Design KA.) A software systems customer is most inter- ested in when the system will be ready and how much it will cost to build and operate. Users are most interested in what it does and how to use it. Designers and programmers building the system have their own concerns, such as whether an algorithm will meet the system requirements. Those responsible for ensuring the system is safe to operate have dif- ferent concerns. Concerns encompass a broad range of issues, possibly pertaining to any influence on a system in its environment, including devel- opmental, technological, business, opera- tional, organizational, political, economic, legal, regulatory, ecological and social influ- ences. Like software requirements, they may be classified as functional, non-functional or constraint. (See Software Requirements KA.) Concerns manifest in various familiar forms, including requirements, quality attri- butes or ilities, emergent properties (which may be either desired or prohibited) and var- ious kinds of constraints (as listed above). See Software Quality KA. Topic 2, Software Architecture Description, shows how concerns shape architecture and the work products describing those architectures. Example of concerns are depicted in Figure 2.2. Concerns are not static; concerns evolve over the life cycle of a system and as technolo- gies, policies and other influences evolve.

--- Chunk 116 ---
Tokens: 359
Type: sentence-based
Text:
Concerns are not static; concerns evolve over the life cycle of a system and as technolo- gies, policies and other influences evolve. For example, due to increased awareness of climate change, there is growing interest in concerns such as energy efficiency, and sus- tainability 24. Figure 2.2. Examples of Architectural Concerns affordability, agility, assurance, autonomy, availability, behavior, business goals and strategies, complexity, compliance with regu- lation, concurrency, control, cost, data acces- sibility, deployability, disposability, energy efficiency, evolvability, extensibility, feasi- bility, flexibility, functionality, information assurance, inter-process communication, interoperability, known limitations, main- tainability, modifiability, modularity, open- ness, performance, privacy, quality of service, reliability, resource utilization, reusability, safety, scalability, schedule, security, system modes, software structure, subsystem inte- gration, sustainability, system features, test- ability, usability, usage, user experience 2-4 SWEBOK  GUIDE V4.0 1.3. Uses of Architecture 2c24, 38c30, 23, 11, 28 A principal use of a software systems archi- tecture is to give those working with it a shared understanding of the system to guide its design and construction. An architec- ture also serves as a preliminary conception of the software system that provides a basis to analyze and evaluate alternatives.

--- Chunk 117 ---
Tokens: 382
Type: sentence-based
Text:
An architec- ture also serves as a preliminary conception of the software system that provides a basis to analyze and evaluate alternatives. A third common usage is to enable reverse engi- neering (or reverse architecting) by helping those working with it to understand an existing software system before undertaking maintenance, enhancement or modification. To support these uses, the architecture should be documented (see topic Software Architecture Description). Conways Law posits that organizations which design systems . . . are constrained to produce designs which are copies of the com- munication structures of these organiza- tions 11. Empirical studies have observed that the architectures of these systems often mirror the communications structures of those organizations 28. Depending on the software system and the organization, this can be a strength or a weakness. The archi- tecture can enhance communication within a large team or compromise it. Each part of the organization can base its planning, costing and scheduling activities upon its knowledge of the architecture. Creating a well-planned and documented architecture is one approach to increasing the applicability and reusability of software designs and components. The architecture forms the basis for design fam- ilies of programs or software product lines. This can be done by identifying commonali- ties among members of such families and by designing reusable and customizable com- ponents to account for the variability among family members. 2.

--- Chunk 118 ---
Tokens: 385
Type: sentence-based
Text:
2. Software Architecture Description 2c22, 38, 40c6, 41c6-7, 9,23,25 In topic 1, Software Architecture Fundamentals, a software architecture was defined as the fundamental concepts or properties of a soft- ware system in its environment. But each stakeholder can have a different notion of what is fundamental to that software system, given their perspective. Having a mental model of a systems architecture is perhaps fine for small systems and for individuals working alone. However, for large, complex systems developed and operated by teams, a tangible representation is invaluable, espe- cially as the conception of the system evolves, and as people join or leave the team. Having a concrete representation as a work product can also serve as a basis to analyze the architec- ture, organize its design and guide its imple- mentation. These work products are called architecture descriptions (ADs). ADs document an architecture for a soft- ware system. It is targeted to those stake- holders of the system who have concerns about the software system which are answered by the architecture. As noted in topic 1, Software Architecture Fundamentals, a primary audi- ence comprises the designers, engineers and programmers whose concerns pertain to con- structing the system. For these stakeholders, ADs serve as a blueprint to guide the con- struction of the software system. For others, the AD is a basis for their workfor example, testing and quality assurance, certification, deployment, operation, and maintenance and future evolution.

--- Chunk 119 ---
Tokens: 384
Type: sentence-based
Text:
For others, the AD is a basis for their workfor example, testing and quality assurance, certification, deployment, operation, and maintenance and future evolution. Historically, ADs used text and informal diagrams to convey the architecture. However, the diversity of stakeholder audi- ences and their different concerns have led to a diversity of representations of the architec- ture. Notations should be chosen based on the need, purpose and the utility of those choices (such as understandability, familiarity) for the stakeholders who need that information. Often, these representations are specialized based upon existing practices of the com- munities or disciplines involved to effectively address this variety of stakeholders and con- cerns (see Software Design KA and Software Engineering Models and Methods KA). These various representations are called archi- tecture views. SOFTWARE ARCHITECTURE 2-5 2.1. Architecture Views and Viewpoints 6c7, 38c3,c15-23, 40c6.2, 23 An architecture view represents one or more aspects of an architecture to address one or more concerns 38. Views address distinct concerns  for example, a logical view (depicts how the system will satisfy the functional requirements); a process view (depicts how the system will use concurrency); a physical view (depicts how the system is to be deployed and distributed) and a development view (depicts how the top-level design is broken down into implementation units, the dependencies among those units and how the implementa- tion is to be constructed).

--- Chunk 120 ---
Tokens: 302
Type: sentence-based
Text:
Views address distinct concerns  for example, a logical view (depicts how the system will satisfy the functional requirements); a process view (depicts how the system will use concurrency); a physical view (depicts how the system is to be deployed and distributed) and a development view (depicts how the top-level design is broken down into implementation units, the dependencies among those units and how the implementa- tion is to be constructed). Separating concerns by view allows interested stakeholders to focus on a few things at a time and offers a means of managing the architectures understandability and overall complexity. Architecture practice has evolved from the use of text and informal diagrams to the use of more rigorous representations. Each archi- tecture view depicts architectural elements of the system using well-defined conventions, notations and models 38. The conventions for each view are documented as an architec- ture viewpoint 23. Viewpoints guide the cre- ation, interpretation and uses of architecture views. Each viewpoint links stakeholder audi- ence concerns with a set of conventions. In model-based architecting, each view can be machine-checked against its viewpoint.

--- Chunk 121 ---
Tokens: 380
Type: sentence-based
Text:
In model-based architecting, each view can be machine-checked against its viewpoint. Common viewpoints include the module viewpoint, used to express a software systems implementation in terms of its modules and their organization 2; the component and connector viewpoint, used to express the soft- wares large-scale runtime organization and interactions 2; the logical viewpoint, used to express fundamental concepts of the soft- wares domain and capability 25; the sce- nariosuse cases viewpoint, used to express how users interact with the system 25; the information viewpoint, used to express a sys- tems key information elements and how they are accessed and stored 38; and the deploy- ment viewpoint, used to express how a system is configured and deployed for operation 38. Other documented viewpoints include view- points for availability, behavior, communi- cations, exception handling, performance, reliability, safety and security. Each viewpoint provides a vocabulary or language for talking about a set of concerns and the mechanisms for addressing them. The viewpoint language gives stakeholders a shared means of expression. Viewpoints need not be limited to one software system but are reusable by an organization or appli- cation community for many similar systems. When generic representations such as Unified Modeling Language (UML) are used, they can be specialized to the system, its domain or the organizations involved. (See section 2.3 Architecture Description Languages and Architecture Frameworks.)

--- Chunk 122 ---
Tokens: 394
Type: sentence-based
Text:
(See section 2.3 Architecture Description Languages and Architecture Frameworks.) Beyond specifying forms of representation, an architecture viewpoint can capture the ways of working within a discipline or com- munity of practice. For example, a software reliability viewpoint captures existing prac- tices from the software reliability community for identifying and analyzing reliability issues, formulating alternatives and synthesizing and representing solutions. Like engineering handbooks, general-purpose and special- ized viewpoints provide a means to document repeatable or reusable approaches to recurring software issues. Clements et al. have intro- duced viewtypes which establish a 3-way cat- egorization of viewpoints. These categories are module, component and connector, and allo- cation viewtypes 9. Architecture descriptions frequently use multiple architecture views to represent the diverse structures needed to address different stakeholders various concerns. There are two common approaches to the construction of views: the synthetic approach and the projective approach. In the synthetic approach, architects construct views of the system-of-interest and integrate these views within an architecture description using correspondence rules. In the projective approach, an architect derives each view through some routine, possibly mechanical, procedure of extraction from a single unified model (or uber model) 23. 2-6 SWEBOK  GUIDE V4.0 A consequence of introducing multiple views into an AD is a potential mismatch between the views. Are they consistent?

--- Chunk 123 ---
Tokens: 313
Type: sentence-based
Text:
Are they consistent? Are they describing the same system? This has been called the multiple views problem 39. The projective approach limits possible inconsis- tencies, since views are derived from a single (presumably consistent) model, but at the cost of expressiveness: the underlying model may not be capable of capturing arbitrary concerns. Under the synthetic approach, architects inte- grate views into a whole, using linkages or other forms of traceability to cross-refer- ence view elements to achieve consistency 23,25. Viewpoints often include rules for establishing consistency or other relationships among views. 2.2. Architecture Patterns, Styles and Reference Architectures 6c6,38c11, 40c6.3, 41c11, 7, 9, 10c2, 13, 17, 18, 19, 37 Inspired by its use in the long history of the architecture of buildings, an architectural style is a particular manner of construction yielding a software systems characteristic features. An architectural style often expresses a software systems large-scale organization. In contrast, an architectural pattern expresses a common solution to a recurring problem within the context of a software systemit need not apply to the whole system. Design patterns are discussed in section 4.4 of Software Design KA.

--- Chunk 124 ---
Tokens: 369
Type: sentence-based
Text:
Design patterns are discussed in section 4.4 of Software Design KA. Various architectural styles and patterns have been documented 7,39:  General structures (e.g, layered, call- and-return, pipes and filters, blackboard, services and microservices)  Distributed systems (e.g, client-server, n-tier, broker, publish-subscribe, point-to- point, representational state transfer (REST))  Method-driven (e.g, object-oriented, event-driven, data flow)  User-computer interaction (e.g, model- view-controller, presentation-abstraction- control)  Adaptive systems (e.g, microkernel, reflection and meta-level architectures)  Virtual machines (e.g, interpreters, rule- based, process control) Pattern catalogs (or systems of patterns) are used to express architectural styles and solu- tions through coordinated sets of patterns. Examples of pattern catalogs are 7, 19 for n-tier architectures, 13 for service-oriented architecture and 37 for microservice architec- tures. Pattern catalogs are not limited to archi- tecture styles and can be focused on addressing specific concerns, such as security 17. There is no strict dividing line between architectural styles and patterns. Both pat- terns and styles provide solutions to specific problems in given contexts. An architectural style expresses the global aspects of a system or subsystem by defining its major parts of that (sub)system and how they interact 7,38. An architectural style can be expressed as an architectural pattern 7.

--- Chunk 125 ---
Tokens: 397
Type: sentence-based
Text:
An architectural style can be expressed as an architectural pattern 7. Architectural pat- terns exist at varying scales and could apply once to a single element of a system or be applied repeatedly throughout a system. In relation to architecture viewpoints, which provide the languages for talking about various aspects of software systems, a uni- fying notion is that both patterns and styles are idioms in those languages for expressing partic- ular aspects of architectures (and designs, see section 4.4 Design Patterns in Software Design KA). An architectural pattern or style uses a vocabulary, drawn from the viewpoints lan- guage, in a specified way, to talk about view elements, including element and relation types and their instances, and constraints on com- bining them 23,39. In this way, viewpoints, patterns and styles are mechanisms for codi- fying recommended practices to facilitate reuse. A reference architecture (RA) is an architec- ture constraining or guiding other architec- tures. Documented as a reference architecture description, an RA provides a common basis for the development of architectures for indi- vidual systems, product lines or families of systems and application domains. Reference architectures capture commonalities to SOFTWARE ARCHITECTURE 2-7 promote ease of development, integration and interoperability and other kinds of stan- dardization. Reference architectures have been developed and used in many domains including automotive systems, healthcare, Internet of Things, cloud computing, avionics, manufacturing and telecommunications. 2.3.

--- Chunk 126 ---
Tokens: 365
Type: sentence-based
Text:
2.3. Architecture Description Languages and Architecture Frameworks 2c22, 41c6-7, 23,30 An architecture description language (ADL) is a domain-specific language for expressing software architectures. ADLs arose from module interconnection languages 36 for programming in the large. Some ADLs target a single application domain or architectural style (such as MetaH for avionics systems in an event-driven style), others are wide spec- trum to frame concerns across the enterprise (such as ArchiMate). UML has frequently been used as an ADL due to its widespread use in software design activities 41. ADLs often provide capabilities beyond descrip- tion to enable architecture analysis or code generation. An architecture framework captures the conventions, principles and practices for the description of architectures established within a specific domain of application andor com- munity of stakeholders 23. Frameworks codify recommended practices within a spe- cific domain and are implemented as an inter- locking set of viewpoints or ADLs. Examples are AUTOSAR for the automotive industry, OMGs Unified Architecture Framework (UAF) and ISO Reference Model for Open Distributed Processing. 2.4. Architecture as Significant Decisions 38c8, 40c6.1, 1, 23, 26 Architectural design is a creative process. During this activity, architects make many decisions that profoundly affect the archi- tecture, the downstream development pro- cess and the software system.

--- Chunk 127 ---
Tokens: 371
Type: sentence-based
Text:
During this activity, architects make many decisions that profoundly affect the archi- tecture, the downstream development pro- cess and the software system. Many factors affect decision-making, including prominent concerns of stakeholders for the software system, its requirements, and the available resources during development and throughout the life cycle. The impact on quality attributes and trade-offs among competing quality attri- butes are often the basis for design decisions. The architectural design activity creates a network of decisions as its outcome, with some decisions deriving from prior decisions. Decision analysis provides one approach to architecture evaluation. Decisions can be explicitly documented, along with an explana- tion of the rationale for each nontrivial deci- sion. Decision analysis provides one approach to architecture evaluation. (See topic 4, Software Architecture Evaluation.) Architecture rationale captures why an archi- tectural decision was made. This includes assumptions made before the decision, alter- natives considered, and trade-offs or criteria used to select an approach and reject others. Recording rejected decisions and the rea- sons for their rejection can also be useful. In the future, this could either prevent a soft- ware project from making a poor decision one rejected earlier for forgotten reasonsor allow the development to recognize that rel- evant conditions have changed and that they can revisit the decision.

--- Chunk 128 ---
Tokens: 358
Type: sentence-based
Text:
In the future, this could either prevent a soft- ware project from making a poor decision one rejected earlier for forgotten reasonsor allow the development to recognize that rel- evant conditions have changed and that they can revisit the decision. Architectural technical debt has been intro- duced to reflect that todays decisions for an architecture may have significant con- sequences later in the software systems life cycle. Decisions deferred can compromise its maintainability or the future evolvability, and that debt will have to be paidtyp- ically by others, not necessarily by those who caused the debt. Such debt has an eco- nomic impact on the systems future devel- opment and operations. For example, when a software project has limited time, it may develop an initial design with little concern for modularity for its first release. The lack of modularity can adversely affect the devel- opment time for subsequent releases, impact developers, and perhaps compromise future maintainability of the system. Additional functionality can be added later only by doing extensive refactoring which impacts future 2-8 SWEBOK  GUIDE V4.0 timelines and introduces additional defects. 26. Architectural technical debt can be ana- lyzed and managed, like other concerns, using models and viewpoints 27. 3. Software Architecture Process 38c7, 41c4, 14,42 This section outlines a general model of an architectural design process.

--- Chunk 129 ---
Tokens: 374
Type: sentence-based
Text:
Software Architecture Process 38c7, 41c4, 14,42 This section outlines a general model of an architectural design process. It is used to demonstrate how architectural design fits into the general context of software engineering processes (see Software Engineering Process KA) and as a framework for understanding the many architecture methods currently in use. It also recognizes that architectural design can take place in a variety of contexts. 3.1. Architecture in Context 41c2, 29 Architecture occurs in several contexts. In the traditional life cycle, there is an architec- tural design stage driven by software system requirements (see Software Requirements KA). Some requirements will be architectural drivers, influencing major decisions about the architecture, while other requirements are deferred to subsequent stages of the software process, such as design or construction. In product line or product family settings, a product linefamily architecture is devel- oped against a basic set of needs, requirements and other factors. That architecture will be the starting point for one or more product instances developed against specific product require- ments, building upon the product baseline. In agile approaches, there is not usually an architecture design stage. The only architec- ture description might be the code itself. In some agile practices, the software architecture is said to emerge from coding the system based on user stories through a rapid series of development cycles.

--- Chunk 130 ---
Tokens: 364
Type: sentence-based
Text:
In some agile practices, the software architecture is said to emerge from coding the system based on user stories through a rapid series of development cycles. Although this approach has had some success with user-centric information systems, it is difficult to ensure an adequate architecture emerges for other classes of applications, such as embedded and cyber-physical systems, when critical archi- tectural properties might not be articulated by any user stories. In enterprise and system-of-systems con- texts, as in product lines and families, the Figure 2.3. A general model of architectural design SOFTWARE ARCHITECTURE 2-9 overarching architecture (of the enterprise, system or product linefamily) provides pri- mary requirements and guidance on the form and constraints upon the software architec- ture. This baseline can be enforced through specifications, additional requirements, appli- cation programming interfaces (APIs) or con- formance suites. 3.1.1. Relation of Architecture to Design Design and architecture are often blurred. It has been said that architecture is the set of decisions that one cannot trust to designers. In fact, architecture emerged out of software design as the discipline matured, largely since the 1990s. There are various contrasts: design often focuses on an established set of require- ments, whereas architecture often must shape the requirements through negotiation with stakeholders and requirements analysis.

--- Chunk 131 ---
Tokens: 271
Type: sentence-based
Text:
There are various contrasts: design often focuses on an established set of require- ments, whereas architecture often must shape the requirements through negotiation with stakeholders and requirements analysis. In addition, architecture often must recognize and address a wider range of concerns that may or may not end up as requirements on the software system of interest. 3.2. Architectural Design 2c20, 20 Architectural design is the application of design principles and methods within a process to create and document a software architecture. There are many architecture methods for carrying out this activity. This section describes a general model of architec- tural design underlying various architecture methods based upon 20. Architectural design involves identifying a systems major components; their responsibil- ities, properties, and interfaces; and the rela- tionships and interactions among them and with the environment. In architectural design, fundamentals of the system are decided, but other aspects, such as the internal details of major components are deferred.

--- Chunk 132 ---
Tokens: 389
Type: sentence-based
Text:
In architectural design, fundamentals of the system are decided, but other aspects, such as the internal details of major components are deferred. Typical concerns in architectural design include the following:  Overall architecture styles and com- puting paradigms  Large-scale refinement of the system into key components  Communication and interaction among components  Allocation of concerns and design responsibilities to components  Component interfaces  Understanding and analysis of scaling and performance properties, resource consumption properties, and reliability properties  Large-scalesystem-wide approaches to dominating concerns (such as safety and security, where applicable) An overview of architectural design is pre- sented in Figure 2.3. Architectural design is iterative, com- prising three major activities: analysis, syn- thesis and evaluation. Often, all three major activities are performed concurrently at var- ious levels of granularity. 3.2.1. Architecture Analysis Architecture analysis gathers and formulates architecturally significant requirements (ASRs), defined as any requirement upon a software system which influences its architecture 31. Architecture analysis is based on identified concerns and on understanding the softwares context, including known requirements, stakeholder needs and the environments con- straints. ASRs reflect the design problems the architecture must solve. Often the com- bination of initial requirements and known constraints cannot be satisfied without conse- quences to cost, schedule, etc.

--- Chunk 133 ---
Tokens: 369
Type: sentence-based
Text:
Often the com- bination of initial requirements and known constraints cannot be satisfied without conse- quences to cost, schedule, etc. In such cases, negotiation is used to modify incoming needs, requirements and expectations to make solu- tions possible. Architecture analysis produces ASRs, initial system-wide decisions and any overarching system principles derived from the context (see Architecture in Context). 3.2.2. Architecture Synthesis Architecture synthesis develops candidate solutions in response to the outcomes of 2-10 SWEBOK  GUIDE V4.0 architecture analysis. Synthesis proceeds by working out detailed solutions to design prob- lems identified by ASRs, and makes trade- offs to accommodate interactions between those solutions. These outcomes feedback to architecture analysis resulting in elaborated ASRs, principles and decisions which then lead to further detailed solution elements. 3.2.3. Architecture Evaluation Architecture evaluation validates whether the chosen solutions satisfy ASRs and when and where rework is needed. Architecture evalua- tion methods are discussed in topic 4 Software Architecture Evaluation. 3.3. Architecture Practices, Methods, and Tactics 2c19-23, 38c9-14, 5, 8, 14, 15, 16, 21, 25, 35 There are a number of documented architec- ture methods (see Further Readings for a list). 3.4. Architecting in the Large 29 Architectural design denotes a specific stage of the life cycle, but is only one part of soft- ware architecting.

--- Chunk 134 ---
Tokens: 372
Type: sentence-based
Text:
Architecting in the Large 29 Architectural design denotes a specific stage of the life cycle, but is only one part of soft- ware architecting. Software architecting does not occur in a vacuum, as noted in section 3.1 Architecture in Context, but in an environment that often includes other architectures. For example, an application architecture should conform to an enterprise architecture; to play well in a system of systems, the architecture of each constituent system should conform to the system of systems architecture. In such cases, these relations need to be reflected as ASRs on the software being architected. Many software architecting activities and principles are not limited to software but equally apply to systems and enterprise architecting 29. Weinreich and Buchgeher have extended Hofmeister et al.s model used in section 3.2 Architectural Design to include these activities 42:  architecture implementation: overseeing implementation and certifying that imple- mentations conform to the architecture  architecture maintenance: managing and extending the architecture following its implementation  architecture management: managing an organizations portfolio of interrelated architectures  architecture knowledge management: extracting, maintaining, sharing and exploiting reusable architecture assets, including decisions, lessons learned, specifications and documentation across the organization 4. Software Architecture Evaluation 2c21, 38c14, 41c8, 10, 31, 33 4.1.

--- Chunk 135 ---
Tokens: 387
Type: sentence-based
Text:
Software Architecture Evaluation 2c21, 38c14, 41c8, 10, 31, 33 4.1. Goodness in Architecture 2c2, 3, 10, 31 Architecture analysis takes place throughout the process of creating and sustaining an architecture. Architecture evaluation is typ- ically undertaken by third parties at deter- mined milestones as a form of assessment. Given the multi-concern, multi-disci- plinary nature of software architecture, there are many aspects to what makes an architecture good. The Roman architect Vitruvius posited that all buildings should have the attributes of firmitas, utilitas and venustas (translated from Latin as strength, utility and beauty). Of a software system and its architecture, one can ask:  Is it robust over its lifetime and possible evolution? Is it fit for its intended use? Is it feasible and cost-effective to construct software systems using this architecture? Is it, if not beautiful, then at least clear and understandable to those who must construct, use and maintain the software? Each architecture concern may be a basis for evaluation. Evaluation is conducted against requirements (when available) or against need, expectations and norms (in other situations). A good architecture should address not only the distinct concerns of its stakeholders, but SOFTWARE ARCHITECTURE 2-11 also the consequences of their interactions. For example, a secure architecture may be excessively costly to build and verify; an easy- to-build architecture may not be maintainable over the systems lifetime if it cannot incorpo- rate new technologies.

--- Chunk 136 ---
Tokens: 397
Type: sentence-based
Text:
For example, a secure architecture may be excessively costly to build and verify; an easy- to-build architecture may not be maintainable over the systems lifetime if it cannot incorpo- rate new technologies. The Architecture Tradeoff Analysis Method (ATAM) 10 provides a methodical approach to evaluating software architectures based on quality attributes in a utility tree (provide illus- tration) and scenarios illustrating the quali- ties. Analysis of tradeoffs among competing quality requirements and their architectural approaches are the key to the architecture evaluation. Clements, et al. describe several methods for evaluation including ATAM, Software Architecture Analysis Method (SAAM), and Quality Attribute Workshops (QAW) 10. The SARA Report defines a general framework for software architecture evaluation 31. 4.2. Reasoning about Architectures 38c10, 3, 10, 31 Each architecture concern has a distinct basis for evaluation. Evaluation is most effective when it is based upon robust, existing archi- tecture descriptions. ADs can be queried, examined and analyzed. For example, eval- uation of functionality or behavior benefits from having an explicit architecture view or other representation of that aspect of the system to study. Specialized concerns such as reliability, safety and security often rely on specialized representations from the respec- tive discipline. Often architecture documentation is unfin- ished, incomplete, out of date or nonexistent. In such cases, the evaluation effort must rely on the knowledge of participants as a primary information source.

--- Chunk 137 ---
Tokens: 372
Type: sentence-based
Text:
In such cases, the evaluation effort must rely on the knowledge of participants as a primary information source. Use cases are frequently used to check an architectures completeness and consis- tency (see Software Engineering Models and Methods KA) by comparing the steps in the use case to the software architecture elements that would be involved in carrying out those steps 23. For a general framework for reasoning about various concerns, see Bass et al. 3. 4.3. Architecture Reviews 2c21, 1, 31 Architecture reviews are an effective approach to assess an architectures status and quality and identify risks by assessing one or more architecture concerns 1. Many reviews are informal or expertise-based, and some are more structured, organized around a checklist of topics to cover. Parnas and Weiss proposed an effective approach to conducting reviews, called active reviews 33, where instead of checklists, each evaluation item entails a specific activity by a reviewer to obtain the needed information. Many organizations have institution- alized architecture review practices. For example, an industry group developed a framework for defining, conducting and documenting architecture reviews and their outcomes 31. 4.4. Architecture Metrics 2c23 An architecture metric is a quantitative mea- sure of a characteristic of an architecture. Various architecture metrics have been defined. Many of these originated as design or code metrics that have been lifted to apply to architecture.

--- Chunk 138 ---
Tokens: 202
Type: sentence-based
Text:
Many of these originated as design or code metrics that have been lifted to apply to architecture. Metrics include component dependency, cyclicity and cyclomatic com- plexity, internal module complexity, module coupling and cohesion, levels of nesting, and compliance with the use of patterns, styles and (required) APIs. In continuous development paradigms (such as DevOps), other metrics have evolved that focus not on the architecture directly but on the responsiveness of the process, such as metrics for lead time for changes, deployment frequency, mean time to restore service, and change failure rateas indicative of the state of the architecture. 2-12 SWEBOK  GUIDE V4.0 MATRIX OF TOPICS VS. REFERENCE MATERIAL cX refers to chapter X Bass et al. 2 Budgen 6 Rozanski Woods 38 Sommerville 40 Taylor et al.

--- Chunk 139 ---
Tokens: 376
Type: sentence-based
Text:
2 Budgen 6 Rozanski Woods 38 Sommerville 40 Taylor et al. 41 See also Software Architecture Fundamentals c1-2 c2 c1-3 29,34 The senses of architecture c1 29 Stakeholders and Concerns c3-14 c8-9 c3 12,23,24 Uses of Architecture c24 c30 23,11,28 Software Architecture Description c22 all c6 c6-7 9,23,25 Architecture Views and Viewpoints c7 c3,c15-23 c6.2 23 Architectural Styles and Patterns c6 c11 c6.3 c11 7,9,10c2,13, 17,18,19,37 Architecture Description Languages and Architecture Frameworks c22 c6-7 23,30 Architecture as Significant Decisions c8 c6.1 1,23,26 Architecture Processes c7 c4 14,42 Architecture in Context c2 29 Architectural Design c20 20 Architecture Methods and Tactics c19-23 c9-14 5,8,14,15,16, 21,25,35 Architecting in the Large 29 Architecture Evaluation c21 c14 c8 10,31,33 Goodness in Architecture c2 3,10,31 Reasoning about Architectures c10 3,10,31 Architecture Reviews c21 1,31 Architecture Metrics c23 SOFTWARE ARCHITECTURE 2-13 FURTHER READINGS Perry and Wolf, Foundations for the study of software architecture 34 Perry and Wolfs Foundations circulated infor- mally for several years before its publication in 1992. It has indeed served as a foundation the evolution of the discipline of software archi- tecture, introducing a number of ideas that are fundamental to the field, including architec- ture as a discipline; distinguishing architecture and design; elements of software architectures; multiple views; architecture styles and types; and analogies with other fields.

--- Chunk 140 ---
Tokens: 391
Type: sentence-based
Text:
It has indeed served as a foundation the evolution of the discipline of software archi- tecture, introducing a number of ideas that are fundamental to the field, including architec- ture as a discipline; distinguishing architecture and design; elements of software architectures; multiple views; architecture styles and types; and analogies with other fields. Bass et al, Software Architecture in Practice 2 This book introduces concepts and recom- mended practices of software architecture, meaning how software is structured and how the softwares components interact. The book addresses several quality concerns in detail, including: availability, deployability, energy efficiency, modifiability, performance, test- ability and usability. The authors offer recom- mended practices focusing on architectural design, architecture description, architecture evaluation and managing architecture tech- nical debt. They also emphasize the impor- tance of the business context in which large software is designed. In doing so, they present software architecture in a real-world setting, reflecting both the opportunities and con- straints that organizations encounter. Kruchten, The 41 View Model of Architecture 25. This seminal paper organizes an approach to architecture description using five archi- tecture viewpoints. The first four are used to produce the logical view, the development view, the process view, and the physical view. These are integrated through selected use cases or scenarios to illustrate the architec- ture. Hence, the model results in 41 views.

--- Chunk 141 ---
Tokens: 368
Type: sentence-based
Text:
Hence, the model results in 41 views. The views are used to describe the software as envisioned by different stakeholderssuch as end-users, developers, and project managers. Rozanski and Woods, Software Systems Architecture 38 This is a handbook for the software sys- tems architect. It develops key concepts of stakeholder, concern, architecture descrip- tion, architecture viewpoint and architecture view, architecture patterns and styles, with examples. It provides an end-to-end archi- tecting process. The authors provide a cat- alog of ready-to-use, practical viewpoints for the architect to employ that are applicable to a wide range of systems. The book is filled with guidance for applying these concepts and methods. R.N. Taylor, N. Medvidovi, E. Dashofy, Software Architecture: Foundations, Theory, and Practice 41 This is a comprehensive textbook on many aspects of software architecture, including key ideas; software architecture in the con- text of software engineering; the design pro- cess; architecture modeling, analysis and visualization; and chapters on several con- cerns including implementation, deployment, adaptation, non-functional properties, trust and security. P. Clements et al. Documenting Software Architecture: Views and Beyond, 2nd edition 9. This book provides detailed guidance on cap- turing software architectures, using guidance and examples to express an architecture so that stakeholders can build, use, and main- tain that system.

--- Chunk 142 ---
Tokens: 377
Type: sentence-based
Text:
This book provides detailed guidance on cap- turing software architectures, using guidance and examples to express an architecture so that stakeholders can build, use, and main- tain that system. The book introduces a 3-way categorization of views and therefore viewpoints: into module, component and connector and allocation called viewtypes, providing numerous examples of each. Brown, Software Architecture for Developers 5 Brown provides an overview of software architecture topics from the perspective of a 2-14 SWEBOK  GUIDE V4.0 developer. He discusses common architec- ture drivers including architecture principles, quality concerns, constraints and functional requirements. He has an in-depth discussion of the role of the architect in a development setting and requisite knowledge and skills for architects. He focuses on the practical issues of architecture in the delivery process and on managing risk. An appendix provides a case study. Fairbanks, Just Enough Software Architecture: A risk-driven approach 16 Fairbanks offers a risk-driven approach to architecting within the context of develop- ment: do just enough software architecture to mitigate the identified risks where those risks could result from a small solution space, from extremely demanding quality require- ments or from possible high-risk failures. The risk-driven approach is harmonious with low-ceremony and agile approaches. Architecting, as argued by Fairbanks, is not just for architectsbut is relevant to all developers.

--- Chunk 143 ---
Tokens: 379
Type: sentence-based
Text:
Architecting, as argued by Fairbanks, is not just for architectsbut is relevant to all developers. Erder, Pureur and Woods, Continuous Architecture in Practice: Software Architecture in the Age of Agility and DevOps. 15 This book shows how classical thinking about software architecture has evolved in the present day in the contexts of agile, cloud-based and DevOps approaches to software development by providing prac- tical guidance on a range of quality and cross-cutting concerns including security, resilience, scalability and integration of emerging technologies. REFERENCES 1 M. Ali Babar, and I. Gorton, Software Architecture Review: The State of the Practice, IEEE Computer, July 2009. 2  L. Bass, P. Clements, and R. Kazman, Software Architecture in Practice, 4th edi- tion, 2021. 3 L. Bass, J. Ivers, M.H. Klein, and P. Merson, Reasoning Frameworks, CMUSEI-2005-TR-007, 2005. 4  F. Brooks, The Design of Design, Addison-Wesley, 2010. 5 S. Brown, Software Architecture for Developers, 2018, http:leanpub.com software-architecture-for-developers 6  D. Budgen, Software Design: Creating Solutions for Ill-Structured Problems, 3rd Edition, CRC Press, 2021. 7 F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, Pattern Oriented Software Architecture, John Wiley  Sons, 1996. 8 H. Cervantes, R Kazman, Designing Software Architectures: A Practical Approach, 2nd ed, Addison-Wesley, 2024. 9 P. Clements et al, Documenting Software Architecture: Views and Beyond, 2nd edi- tion Addison-Wesley, 2011.

--- Chunk 144 ---
Tokens: 392
Type: sentence-based
Text:
9 P. Clements et al, Documenting Software Architecture: Views and Beyond, 2nd edi- tion Addison-Wesley, 2011. 10 P. Clements, R. Kazman, M. Klein, Evaluating Software Architectures, Addison-Wesley, 2001 11 M.E. Conway, How Do Committees Invent? Datamation, 14(4), 28-31, 1968. 12 E.W. Dijkstra, On the role of scientific thought, 1974, available at http:www. cs.utexas.eduusersEWDtranscrip- tionsEWD04xxEWD447.html. 13 T. Earl, SOA Design Patterns, Prentice-Hall, 2009 14 P. Eeles, and P. Cripps, The Process of Software Architecting, Addison Wesley, 2010. SOFTWARE ARCHITECTURE 2-15 15 M. Erder, P. Pureur and E. Woods, Continuous Architecture in Practice: Software Architecture in the Age of Agility and DevOps, Addison-Wesley, 2021. 16 G. Fairbanks, Just Enough Software Architecture: A Risk-Driven Approach, Marshall  Brainerd, 2010. 17 E. Fernandez-Buglioni, Security Patterns in Practice: Designing Secure Architectures Using Software Patterns, Wiley, 2013. 18 R.T. Fielding and R.N. Taylor, Principled design of the modern web architecture, ACM Transactions on Internet Technology, 2(2), 115150, 2002. 19 M. Fowler, D. Rice, M. Foemmel, E. Hieatt, R. Mee and R. Stafford, Patterns of Enterprise Application Architecture, Addison-Wesley, 2003. 20 C. Hofmeister, P.B. Kruchten, R.L. Nord, H. Obbink, A. Ran, and P. America, A general model of soft- ware architecture design derived from five industrial approaches, The Journal of Systems and Software, 80, 106126, 2007. 21 C. Hofmeister, R.L. Nord, and D. Soni, Applied Software Architecture, Addison- Wesley, 2000.

--- Chunk 145 ---
Tokens: 398
Type: sentence-based
Text:
Nord, and D. Soni, Applied Software Architecture, Addison- Wesley, 2000. 22 ISOIECIEEE, ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, 2nd ed. 2017. 23 ISOIECIEEE 42010:2011, Systems and software engineering  Architecture description. 24 R. Kazman, S. Haziyev, A. Yakuba, and D.A. Tamburri, Managing Energy Consumption as an Architectural Quality Attribute, IEEE Software, 35(5), 102107, 2018 25 P.B. Kruchten, The 41 View Model of Architecture, IEEE Software 12(6), 1995. 26 P.B. Kruchten, R.L. Nord, and I. Ozkaya, Managing Technical Debt: Reducing Friction in Software Development. Addison-Wesley, 2019. 27 Z. Li, P. Liang and P. Avgeriou, Architecture viewpoints for documenting architectural technical debt. Software Quality Assurance, Elsevier, 2016. 28 Alan MacCormack, John Rusnak  Carliss Baldwin, Exploring the Duality between Product and Organizational Architectures: A Test of the Mirroring Hypothesis. Research Policy, 41:13091324, 2012 29  M.W. Maier and E. Rechtin, The Art of Systems Architecting, 3rd edition, CRC Press, 2021. 30 N. Medvidovi, D.S. Rosenblum, D.F. Redmiles and J.E. Robbins, Modeling software architectures in the Unified Modeling Language, ACM Transactions on Software Engineering and Methodology, 11(1), 257, 2002 31 H. Obbink et al, Report on Software Architecture Review and Assessment (SARA), version 1.0, available at https: philippe.kruchten.comarchitecture SARAv1.pdf, 2002. 32 D.L. Parnas, On the criteria to be used in decomposing systems into modules, Communications of the ACM 15(12), 1053-1058, 1972. 33 D.L. Parnas and D.M.

--- Chunk 146 ---
Tokens: 319
Type: sentence-based
Text:
Parnas and D.M. Weiss, Active Design Reviews: Principles and Practices, Proceedings of 8th International Conference on Software Engineering, 215-222, 1985. 34 D. Perry, A. Wolf, Foundations for the 2-16 SWEBOK  GUIDE V4.0 study of software architecture, ACM SIGSOFT Software Engineering Notes, 17(4), 4052, 1992 35 E. Poort, H. van Vliet, RCDA: Architecting as a Risk- and Cost Management Discipline, Journal of Systems and Software, https:www .cs.vu.nlhanspublicationsy2012 JSS-RCDA.pdf, 2012 36 R. Prieto-Diaz and J.M. Neighbors, Module Interconnection Languages, Journal of Systems and Software, 6(4), 307334, 1986. 37 C. Richardson, Microservices Patterns, Manning Publications, 2019 38 N. Rozanski and E. Woods, Software Systems Architecture: Working with Stakeholders Using Viewpoints and Perspectives, 2nd edition, Addison- Wesley, 2011. 39 M. Shaw and D. Garlan, Software Architecture: Perspectives on an Emerging Discipline, Prentice Hall, 1996. 40 I. Sommerville, Software Engineering, 10th edition, 2016. 41 R.N. Taylor, N. Medvidovi, E. Dashofy, Software Architecture: Foundations, Theory, and Practice, Wiley, 2009 42 R. Weinreich and G. Buchgeher, Towards supporting the software archi- tecture life cycle, The Journal of Systems and Software, 85, 546561, 2012.

--- Chunk 147 ---
Tokens: 386
Type: sentence-based
Text:
Taylor, N. Medvidovi, E. Dashofy, Software Architecture: Foundations, Theory, and Practice, Wiley, 2009 42 R. Weinreich and G. Buchgeher, Towards supporting the software archi- tecture life cycle, The Journal of Systems and Software, 85, 546561, 2012. 3-1 CHAPTER 03 Software Design ACRONYMS API Application Programming Interface AOD Aspect-Oriented Design CBD Component-Based Design CRC Class Responsibility Collaborator (Or Collaboration) DFD Data Flow Diagram DSL Domain-Specific Language ERD Entity Relationship Diagram FOSS Free And Open Source Software IDL Interface Description Language MBD Model-Based Design MDD Model-Driven Design OO Object-Oriented PDL Program Design Language SDD Software Design Description SoC Separation of Concerns UML Unified Modeling Language INTRODUCTION This chapter considers software design from several perspectivesfocusing on basic con- cepts, context and processes, software design qualities and strategies, and recording and evaluating designs. Design is used in distinct but closely related ways to refer to (1) the discipline (use of sci- entific principles, technical information, and imagination in the definition of a software system to perform prespecified functions with maximum economy and efficiency) 11; (2) the processes for performing within that discipline; (3) the result of applying that discipline; and (4) the stage in the life cycle of a software system during which those pro- cesses yield those results. A software design description (SDD) docu- ments the result of software design.

--- Chunk 148 ---
Tokens: 374
Type: sentence-based
Text:
A software design description (SDD) docu- ments the result of software design. It is a rep- resentation of software created to facilitate analysis, planning, implementation, and deci- sion-making. The software design description is used as a medium for communicating soft- ware design information and can be thought of as a blueprint or model of the system 11. The SDD, which may take many forms, encompasses the refinement of that software into components, the organization of those components, and the definition of interfaces among them and between the software and the outside worldto a level of detail that enables their construction. Software design, viewed as a life cycle activity, is the application of software engi- neering discipline in which software require- ments are analyzed to define the softwares external characteristics and internal structure as the basis for the softwares construction. Software design takes place in three stages:  architectural design of the software system  high-level or external-facing design of the system and its components  detailed or internal-facing design Architectural design is a part of architecting, discussed in the Software Architecture KA. BREAKDOWN OF TOPICS FOR SOFTWARE DESIGN The breakdown of topics for the Software Design KA is shown in Fig. 3.1. 3-2 SWEBOK  GUIDE V4.0 1. Software Design Fundamentals 34 The concepts, notions and terminology intro- duced here form a basis for understanding the role and scope of software design. 1.1.

--- Chunk 149 ---
Tokens: 374
Type: sentence-based
Text:
1.1. Design Thinking 3 c1, c2, c3 4 c1, c2 20 Design is all around us, in the things and organizations that have been created to meet a need or solve a problem. In a general sense, design can be viewed as a form of problem-solving. For example, the concept of a wicked problema problem with no definitive solutionis interesting in terms of understanding the limits of design. Many other notions and concepts help us understand design in its general sense: goals, constraints, alternatives, representations and solutions. (See also Design as a Problem-Solving Activity in Engineering Foundations KA.) Design thinking comprises two essentials: (1) understanding the need or problem and (2) devising a solution. Ross, Goodenough and Irvine offer an elaboration of design thinking appropriate to software: This process consists of five basic steps: (1) crys- tallize a purpose or objective; (2) formulate a concept for how the purpose can be achieved; (3) devise a mechanism that implements the con- ceptual structure; (4) introduce a notation for expressing the capabilities of the mechanism and invoking its use; (5) describe the usage of the notation in a specific problem context to invoke the mechanism so the purpose is achieved. 20 This is particularly appropriate because much of software design consists of cre- ating the necessary vocabulary to express a problem, express its solution and implement that solution. The steps emphasize the lin- guistic nature of software design problem solving.

--- Chunk 150 ---
Tokens: 150
Type: sentence-based
Text:
The steps emphasize the lin- guistic nature of software design problem solving. This is a recurring pattern we see throughout high-level design, detailed design and architecting (see Architecting in the Large in Software Architecture KA). Therefore, Software Design is a practical process of transforming a problem statement into a solu- tion statement. Software design shares com- monalities with other kinds of design. Design can be further understood via design theory 8. 1.2. Context of Software Design 4 c13, c14 21 c19, c20 Software design is an important part of the software development process.

--- Chunk 151 ---
Tokens: 380
Type: sentence-based
Text:
Context of Software Design 4 c13, c14 21 c19, c20 Software design is an important part of the software development process. To understand the role of software design is to see how it fits Software Design Software Design Fundamentals Design Tinking Context of Software Design Key Issues in Software Design Software Design Principles High-Level Design Detailed Design Concurrency Control and Event Handling Data Persistence Distribution of Components Errors and Exception Handling Integration and Interoperability Assurance, Security, Safety Variability Model-Based Design Structural Design Description Behavioral Design Description Design Patterns Specialized Domain-Specic Languages Design Rationale General Strategies Function-Oriented Data-Centered Object-Oriented User-Centered Component-Based Event-Driven Aspect-Oriented Constraint-Based Domain-Driven Design Other Methods Design Reviews and Audits Quality Attributes Quality Analysis and Evaluation Techniques Measures and Metrics Verication, Validation and Certication Software Design Processes Software Design Qualities Recording Software Design Software Design Strategies and Methods Software Design Analysis and Evaluations Figure 3.1. Breakdown of topics for the Software Design KA SOFTWARE DESIGN 3-3 into the software development life cycle (see Software Process KA). To understand that context, it is important to understand the major characteristics and roles of software requirements, software construction, software testing, and software maintenance.

--- Chunk 152 ---
Tokens: 397
Type: sentence-based
Text:
To understand that context, it is important to understand the major characteristics and roles of software requirements, software construction, software testing, and software maintenance. The con- text varies with many factors, including degree of formality and stage of the life cycle. Software design is the transformation of customer and other requirements, needs, and concerns into implementable design specifica- tions. Its contexts include the following:  Software Designs relationship with soft- ware requirements: The requirements establish a set of problems that the soft- ware design must solve. Software Designs relationship with soft- ware architecture: In cases where an architecture has been established, that architecture constrains the design by capturing fundamental aspects of the system: such as its major components and their interconnections, application pro- gramming interfaces (APIs), styles and patterns to be used, and architectural principles to be observed and enforced. Software Designs relationship with soft- ware construction: The software design must provide a guide to implementors on building the system. Software Designs relationship with soft- ware testing: Software design provides a foundation for an overall testing strategy and test cases that ensure that the design is properly implemented and operates as intended. 1.3. Key Issues in Software Design 2, 12 Many key issues must be dealt with when designing software. Some are quality con- cerns that all software must address (per- formance, security, reliability, usability, maintainability, etc.).

--- Chunk 153 ---
Tokens: 390
Type: sentence-based
Text:
Some are quality con- cerns that all software must address (per- formance, security, reliability, usability, maintainability, etc.). Another important issue is how to refine, organize, intercon- nect and package software components. These issues are so fundamental that all design approaches address them in one way or another. (See topic Stakeholders and Concerns in Software Architecture KA, sec- tion 1.4 Software Design Principles, and topic 5 Software Design Strategies and Methods.) In contrast, other issues deal with some aspect of softwares behavior that is not in the application domain, but which addresses some of the supporting domains 2. Such issues, which often crosscut the systems function- ality, are referred to as aspects, which tend not to be units of softwares functional decompo- sition, but rather to be properties that affect the performance or semantics of the compo- nents in systemic ways 12. 1.4. Software Design Principles 5, 10, 17, 20 A principle is a fundamental truth or proposi- tion that serves as the foundation for a system of belief or behavior or for a chain of rea- soning. Oxford English Dictionary Design principles provide direction or guid- ance for making decisions during design. Some principles originated during the early days of software engineering, others even pre- date the discipline, deriving from best prac- tices in engineering unrelated to software. (See Engineering Foundations KA.) Decision making can also be assisted by quantita- tive methods, such as discussed in Software Engineering Economics KA.

--- Chunk 154 ---
Tokens: 380
Type: sentence-based
Text:
Decision making can also be assisted by quantita- tive methods, such as discussed in Software Engineering Economics KA. Software design principles are key notions that provide the basis for many different software design concepts, approaches and methods. The principles listed below apply to any of the three stages of design. Many of these principles are interrelated. Whether alone or used in combination with other principles, they are reflected elsewhere in software design to produce many concepts and constructs found in design capture, strat- egies and methods. This is itself an application of the design thinking process above. Software design principles include the following:  Abstraction is a view of an object that focuses on the information relevant to a particular purpose and ignores the remainder of the information 11.The abstraction principle . . . helps to identify 3-4 SWEBOK  GUIDE V4.0 essential properties common to super- ficially different entities 20. (See also topic Abstraction in the Computing Foundations KA.) Separation of concerns (SoC). A design con- cern is an area of interest with respect to a software design 11 that is relevant to one or more of its stakeholders. By identifying and separating concerns, the designer can focus on each concern for the system in isolation about which Dijkstra said even if not perfectly possible, SoC is yet the only available technique for effective ordering of ones thoughts  5 (See also topic Stakeholders and Concerns in Software Architecture KA.)

--- Chunk 155 ---
Tokens: 340
Type: sentence-based
Text:
By identifying and separating concerns, the designer can focus on each concern for the system in isolation about which Dijkstra said even if not perfectly possible, SoC is yet the only available technique for effective ordering of ones thoughts  5 (See also topic Stakeholders and Concerns in Software Architecture KA.) Modularization (or refinement or decompo- sition) structures large software as com- prising smaller components or units. Each component is named and has well-de- fined interfaces for its interactions with other components. Smaller components are easier to understand and, therefore, to maintain. There are numerous modular- ization strategies. (See topic 5 Software Design Strategies and Methods.) Traditionally, the goal is to place distinct functionalities and responsibilities in dif- ferent components. David Parnas advo- cated that each module in a system should have a single responsibility 17. One way to think of modularization is as a special case of more general strategies, such as sep- aration of concerns or divide and conquer. (see topic Problem-Solving Techniques in Computing Foundations). Encapsulation (or information hiding) builds upon the principles of abstraction and modularization so that nonessential information is less accessible, allowing users of the module to focus on the essen- tial elements at the interface.

--- Chunk 156 ---
Tokens: 388
Type: sentence-based
Text:
Encapsulation (or information hiding) builds upon the principles of abstraction and modularization so that nonessential information is less accessible, allowing users of the module to focus on the essen- tial elements at the interface. Separation of interface and implementa- tion is an application of encapsulation that involves defining a component by specifying its public interfaces, which are known to and accessible to clients; isolating the use of a component from the details of how that component is built. (See Encapsulation (or information hiding) above.) Coupling is defined as a measure of the interdependence among modules in a computer program 11. Most design methods advocate that modules should be loosely or weakly coupled. Cohesion (or localization) is defined as a measure of the strength of association of the elements within a module 11. Cohesion highlights organizing a mod- ules constituents based on their relat- edness. Most design methods advocate that modules should maximize their cohesionlocality. Uniformity is a principle of consistency across software componentscommon solutions should be produced to address common or recurring problems. These include naming schemes, notations and syntax, interfaces that define access to services and mechanisms, and ordering of elements and parameters. This can be achieved through conventions such as rules, formats and styles. Completeness (or sufficiency) means ensuring that a software component captures the important characteristics of an abstrac- tion and leaves nothing out.

--- Chunk 157 ---
Tokens: 379
Type: sentence-based
Text:
Completeness (or sufficiency) means ensuring that a software component captures the important characteristics of an abstrac- tion and leaves nothing out. Completeness takes various forms, perhaps the most important of which is design completeness against requirements: a design should be sufficient for designers to demonstrate how requirements will be met and how subse- quent work will satisfy those requirements. Design should be complete with respect to the modes and states of the software. Verifiability means that information needed to verify the design against its requirements and other constraints is available. This is relevant for any software but is of particular importance for high-as- surance software, such as software where security, reliability or safety-critical con- cerns are present. An SDD should be sufficient as a basis for verifying a design. (See Software Testing KA and Software Quality KA.).) Other design principles. Recently, with the SOFTWARE DESIGN 3-5 increased appearance of autonomous sys- tems, the use of machine learning and artificial intelligence, and, generally, systems with widening social impacts, approaches to Ethically Aligned Design have been developed to address concerns including universal human values, polit- ical self-determination, and data agency and technical dependability 9. The gen- eral principles of Ethically Aligned Design are human rights, well-being, data agency, effectiveness, transparency, accountability, awareness of misuse, and competence. 2.

--- Chunk 158 ---
Tokens: 354
Type: sentence-based
Text:
2. Software Design Processes 4 c3 21 c2, c7 10 Software design is generally considered a mul- tistage process or activity. Software design can be divided into the following stages or phases. When necessary, we distinguish the phase from the general activity:  Architectural design stage  High-level design stage  Detailed design stage The architectural design stage addresses the fundamentals of the system as a whole and in relation to its environment (see Software Architecture KA). The high-level design stage is out- ward-facingdeveloping the top-level struc- ture and organization of the software, identifying its various components and how that software system and its components interact with the environment and its elements. The detailed design stage is inward- facingspecifying each component in suffi- cient detail to facilitate its construction and to meet its outside obligations, including how software components are further refined into modules and units. Each stage reflects the basic pattern out- lined in section 1.1 Design Thinking. Not all stages are found in every soft- ware process. However, when present, each stage creates an obligation upon the next stage regarding the software which is under development. Although software developers generally follow similar guidelines for what happens in each stage, there are no strict bound- aries between stages regarding what must be done and when.

--- Chunk 159 ---
Tokens: 357
Type: sentence-based
Text:
Although software developers generally follow similar guidelines for what happens in each stage, there are no strict bound- aries between stages regarding what must be done and when. For example, for many soft- ware systems, the choice of an algorithm to sort data will be deferred to programmers, within the constraints and guidance provided by the systems requirements, its architecture description or design specifications. However, for another software system, the existence of a suitable algorithm could be architecturally significant and must be determined early in the life cycle. Without that algorithm, there is no possibility of constructing the software to meet its requirements. Some rules of thumb for each stage include the following:  The architectural design stage defines a computational model, the major com- putational elements, and the important protocols and relationships among them. This stage develops strategies to address crosscutting concerns, such as perfor- mance, reliability, security and safety, and articulation of crosscutting deci- sions, including system-wide styles (e.g, a transactional n-tier style versus a pipes and filters style, together with the ratio- nale for such decisions). The high-level design stage includes identification of the primary computa- tional elements and significant relation- ships among them, with a focus on each major components existence, role and interfaces.

--- Chunk 160 ---
Tokens: 270
Type: sentence-based
Text:
The high-level design stage includes identification of the primary computa- tional elements and significant relation- ships among them, with a focus on each major components existence, role and interfaces. That definition should be suf- ficiently detailed to allow designers or programmers of client components to correctly and efficiently access each ser- vices capabilitieswithout having to read its code. The detailed design stage defines each modules internal structure, focusing on detailing and justifying choices of algo- rithms, data access and data representa- tion. The detailed design specifications should be sufficient to allow programmers 3-6 SWEBOK  GUIDE V4.0 to code each module during construction (see Software Construction KA). The code is a representation of the solution that is sufficiently detailed and complete that a compiler (or interpreter) can execute it. 2.1. High-Level Design 3 c5 4 c6 10 High-level design specifies the interaction of a systems major components with one another and with the environment, including users, devices and other systems.

--- Chunk 161 ---
Tokens: 398
Type: sentence-based
Text:
High-Level Design 3 c5 4 c6 10 High-level design specifies the interaction of a systems major components with one another and with the environment, including users, devices and other systems. High-level design addresses the following:  External events and messages to which the system must respond  Events and messages which the system must produce  Specification of the data formats and pro- tocols for events and messages  Specification of the ordering and timing relationships between input events and messages, and output events and messages  Tracing and analysis of end-to-end trans- actions and event threads  Data persistence (how data is stored and managed) High-level design is undertaken within the envelope established by the systems soft- ware architecture (if any). Each of the above may be guided or constrained by architecture directives. For example, event signaling and messaging will use the protocols and modes of interaction established by the architecture. Data formats and protocols will use data and communication standards specified by the architecture. Absent an explicit architecture design stage, some of these directives will be established by the software requirements or decided during high-level design. 2.2. Detailed Design 10 The detailed design stage proceeds within the constraints established by the high-level design. It specifies major system components internal characteristics, internal modules and their interconnections to other modules, services and processes they provide, computing proper- ties, algorithms, and data access rules and data structures.

--- Chunk 162 ---
Tokens: 384
Type: sentence-based
Text:
It specifies major system components internal characteristics, internal modules and their interconnections to other modules, services and processes they provide, computing proper- ties, algorithms, and data access rules and data structures. This includes the following:  Refinement of major system components into modules or program units, including opportunities for using off-the-shelf com- ponents and application frameworks  Allocation of design responsibilities to modules and program units  Interactions among modules  Scope and visibility among components, modules and program units  Component modes, component states and transitions among them  Data and control interdependencies  Data organization, packaging and implementation  User interfaces  Requisite algorithms and data structures 3. Software Design Qualities 4 c4 20 Software requirements and architecture direc- tives are intended to guide software toward certain characteristics or design qualities. Design qualities are an important subclass of concerns (see topic Stakeholders and Concerns in Software Architecture KA). One role of design principles (see section 1.4 Software Design Principles) is to help software achieve these qualities. Among the characteristics of interest to designers are the following: 3.1. Concurrency 21 c17 Design for concurrency concerns how software is refined into concurrent units such as pro- cesses, tasks, and threads and the consequences of those decisions with respect to efficiency, atomicity, synchronization and scheduling. 3.2.

--- Chunk 163 ---
Tokens: 384
Type: sentence-based
Text:
3.2. Control and Event Handling 21 c21 Event handling is concerned with how to organize control flow as well as how to handle reactive and temporal events through var- ious mechanisms including synchronization, implicit invocation and callbacks. SOFTWARE DESIGN 3-7 3.3. Data Persistence 21 c6, c16 Data persistence concerns the storage and management of data throughout the system. 3.4. Distribution of Components 21 c17 Distribution concerns how software com- ponents are distributed across hardware (including computers, networks and other devices) and how those components commu- nicate while meeting performance, reliability, scalability, availability, monitorability, busi- ness continuity and other expectations. 3.5. Errors and Exception Handling, Fault Tolerance 21 c11 This concern pertains to how to prevent, avoid, mitigate, tolerate and process errors and exceptional conditions. 3.6. Integration and Interoperability 4 c11, c14, c16 This issue arises at the enterprise or sys- tem-of-systems level or for any complex software when heterogeneous systems or applications need to interwork through exchanges of data or accessing one anothers services. Within a software system, the issue arises when components are designed using different frameworks, libraries or protocols. 3.7. Assurance, Security, and Safety 21 c10c14 High assurance spans a number of software qualities, including security and safety con- cerns, pertaining to whether the software behaves as intended in critical situations, such as in the face of hazards.

--- Chunk 164 ---
Tokens: 390
Type: sentence-based
Text:
Assurance, Security, and Safety 21 c10c14 High assurance spans a number of software qualities, including security and safety con- cerns, pertaining to whether the software behaves as intended in critical situations, such as in the face of hazards. Security becomes a key concern for distributed applications where components communicate using different pro- tocols and media. Design for security concerns how to prevent unauthorized disclosure, cre- ation, change, deletion, or denial of access to information and other resources in the face of attacks upon the system or violations of system policies to limit damage; provide continuity of service; and assist repair and recovery. Design for safety pertains to managing the softwares behavior in circumstances which might lead to harm to or loss of human life or damage to property or the environment. 3.8. Variability 6 Variability concerns permissible variations in a software system. It is a fundamental aspect of most software 6. It is the ability to create software system variants for different market segments or contexts of use. Interest in variability first arose in software product lines and system families, to accom- modate and manage deployment of multiple variants such as for different organizations or markets. (See appendix B 6, Standards for product line, methods and tools). It is also relevant to software ecosystems and con- text-aware software. (See also 3.5 Reuse in Construction, Software Construction KA.) Feature models are used to gather require- ments and dependencies into bundles.

--- Chunk 165 ---
Tokens: 370
Type: sentence-based
Text:
Feature models are used to gather require- ments and dependencies into bundles. (See Feature-Driven Development, under topic 4.1 Agile Methods in Software Engineering Models and Methods KA) 4. Recording Software Designs 4 c7, c8 1 The outcome of design processes is accumu- lated knowledge and work products recording that knowledge. Work products of software design capture (1) aspects of the problems to be solved, using the vocabulary of the domain; (2) a solution vocabulary for solving the design problems (see section 1.1 Design Thinking); (3) the major decisions that have been taken; and (4) explanations of the rationale for each nontrivial decision. Recording the rationale for important decisions enhances the software products long-term maintainability when modifications or enhancements are consid- ered (see section 4.6 Design Rationale). These work products, often termed design descrip- tions or design specifications, can take the form of texts, diagrams, models and prototypes 3-8 SWEBOK  GUIDE V4.0 that comprise the blueprints of the software to be implemented. A fundamental aspect of software design is communication about the design among designers, and to customers, implementers and other stakeholders. This is the case whether the software is developed using agile, tradi- tional or formal methods. The communication will vary depending upon the target audi- ence, the level of detail being communicated, and relevance to the concerns of the stake- holders.

--- Chunk 166 ---
Tokens: 394
Type: sentence-based
Text:
The communication will vary depending upon the target audi- ence, the level of detail being communicated, and relevance to the concerns of the stake- holders. For example, when using traditional or formal methods, the design often evolves through a progression of design descriptions, while in agile approaches the evolving design may be implicit in the minds of developers and only explicit as code. While the latter approach supports the agility of developers, other stakeholders, such as those concerned with requirements, certification, testing and quality assurance may need explicit design information to do their work. Therefore, projects should make conscious decisions about which design specifications are needed based upon stakeholder audience, subject and intended usage. Designers can analyze and evaluate these work products to determine whether the design can meet the requirements and con- straints on the software. Software design also examines and evaluates alternative solutions and trade-offs. In addition to using them as inputs and as the starting point for con- struction and testing, stakeholders can use the design work products to plan subsequent activities, such as system verification and validation. As design concepts evolve, so do their rep- resentations (see section 1.1 Design Thinking); part of the design process involves creating appropriate vocabularies for problems and solutions. An informal sketch may be most appropriate for the early stages. It is useful to distinguish in-process (working) spec- ifications from final design products.

--- Chunk 167 ---
Tokens: 388
Type: sentence-based
Text:
It is useful to distinguish in-process (working) spec- ifications from final design products. The former are produced by the design team for the design team; the latter may be produced for known stakeholders or even for an unknown future audience. Many notations exist to represent software design artifacts. Software design is often car- ried out using multiple types of notation. Two broad areas of concern are software struc- tures and software behaviors. Some are used to describe a designs structural organization, others to represent the softwares intended behavior. Below, they are categorized as nota- tions for structural and behavioral concerns (see section 4.2 Structural Design Descriptions and section 4.3 Behavioral Design Descriptions, respectively). Certain notations are used mostly during architectural design and others mainly during detailed design; some are useful throughout all stages of software design. Some notations are closely tied to the context of spe- cific design methods (see Software Design Strategies and Methods KA). The Unified Modeling Language (UML) is a widely used family of notations addressing both structural and behavioral concerns and is used in all design stages, from architectural through detailed design 1. 4.1. Model-Based Design 4 c7.3 21 c5.5 Over the history of software engineering, including architecture and design, there has been an evolution from document-based artifacts to model-based artifacts. Model- Based Design (MBD) is an approach to recording designs where models play an important role.

--- Chunk 168 ---
Tokens: 325
Type: sentence-based
Text:
Model- Based Design (MBD) is an approach to recording designs where models play an important role. This trend reflects the limitations of docu- ment-based artifacts and the increased capa- bilities of automated tools. Document-based artifacts use natural language and informal diagrams to convey designers intentions, which might introduce ambiguity and incompleteness. Even when documents use well-defined formats, relevant information might be spread across documents, making understandability and analysis difficult. With MBD, appropriate tooling can gather and organize relevant information for use by designers and other stakeholders in an acces- sible form. Modern tools have accelerated the trend from document to model-based artifacts. SOFTWARE DESIGN 3-9 Tooling enables animation or simulation of various software aspects, analyses of what-if scenarios and trade-offs, and rapid proto- typing. Tooling also facilitates continuous testing and integration approaches, enhanced and interactive traceability, and knowledge capture and management, which are ineffi- cient or even infeasible with document-based approaches. Model-driven development (MDD) is a development paradigm that uses models as the development process primary artifacts (see Software Engineering Models and Methods KA). 4.2.

--- Chunk 169 ---
Tokens: 363
Type: sentence-based
Text:
4.2. Structural Design Descriptions 4 c7, c10 7 c4 21 c5.3 The following types of notation, most of which are graphical, are used to represent the struc- tural aspects of a software designthat is, they are used to describe the major compo- nents and how they are interconnected (static view) and the allocation of responsibilities to components and modules:  Class and object diagrams are used to rep- resent a set of classes and objects and their interrelationships. Component diagrams are used to rep- resent a set of components (replaceable elements of a system that conform to and provide the realization of a set of interfaces) and their interconnections. Component models evolved from ear- lier module interconnection languages into the package systems of program- ming languages like Ada and Java and the sophisticated module systems of cur- rent functional language systems such as Haskell and Coq. Class responsibility collaborator cards (CRCs) are used to denote the names of components (classes), their responsibil- ities and the components they interact with to meet those responsibilities. Deployment diagrams are used to repre- sent a set of physical nodes and their inter- connections to model the physical aspects of software as deployed on hardware. Entity relationship diagrams (ERDs) are used to represent conceptual, logical and physical models of data as stored in infor- mation repositories or as a part of inter- face descriptions.

--- Chunk 170 ---
Tokens: 395
Type: sentence-based
Text:
Entity relationship diagrams (ERDs) are used to represent conceptual, logical and physical models of data as stored in infor- mation repositories or as a part of inter- face descriptions. Interface description languages (IDLs) are programming-like languages used to define the interfaces (names and types of exported operations) of software components. Structure charts are used to describe the calling structure of programs (that is, they show which modules call, and are called by, which other modules). 4.3. Behavioral Design Descriptions 4 c9, c10 7 c5 21 c5.4 The following notations and languages, some graphical and some textual, are used to describe the dynamic behavior of software systems and their components. Many of these notations are useful mostly, but not exclusively, during detailed design. Moreover, behavioral descrip- tions can include rationale for design decisions (see section 4.6 Design Rationale). Activity diagrams are used to show flow of a computation from activity to activity. They also can represent concurrent activ- ities, their inputs and outputs and oppor- tunities for concurrency. Interaction diagrams characterize the interaction among a group of objects. There are two major kinds of interaction diagrams: communication (or collabora- tion) diagrams and sequence diagrams. Communication diagrams show inter- actions among objects with an emphasis on their links and the messages they exchange on those links. Sequence dia- grams show interactions among objects, with an emphasis on the temporal ordering of messages passed among those objects.

--- Chunk 171 ---
Tokens: 395
Type: sentence-based
Text:
Sequence dia- grams show interactions among objects, with an emphasis on the temporal ordering of messages passed among those objects. Data flow diagrams (DFDs) are used to show data flow among computing ele- ments. A DFD provides a description based on modeling the flow of infor- mation around a network of operational 3-10 SWEBOK  GUIDE V4.0 elements, with each element making use of or modifying the information flowing into that element 4. DFDs have other uses, such as security analysis, as they identify possible paths for attack and dis- closure of confidential information. Decision tables and diagrams are used to represent complex combinations of con- ditions and actions. Flowcharts are used to represent the flow of control and the sequence of associ- ated actions. State (transition) diagrams and statecharts are used to show transitions from state to state and how a components behavior changes based on its current state and response to input events. Formal specification languages are predomi- nantly textual languages founded upon basic notions from mathematics (for example, type, set, sequence, logical proposition) to rigorously and abstractly define software component interfaces and behavior, often in terms of pre- and post-conditions, invariants, type checking, and computational models (see section Formal Methods in Software Engineering Models and Methods KA). Pseudocode and program design lan- guages (PDLs) are structured, program- ming language-like notations used to describe a procedures processing behavior, generally at the detailed design stage.

--- Chunk 172 ---
Tokens: 363
Type: sentence-based
Text:
Pseudocode and program design lan- guages (PDLs) are structured, program- ming language-like notations used to describe a procedures processing behavior, generally at the detailed design stage. The use of these languages is less common today but is still found in the documenta- tion of algorithms. 4.4. Design Patterns and Styles 3 c12 4 c15 7 c1, c2 21 7.2 Succinctly described, a pattern is a common solution to a common problem in a given context 7. Design patterns include the following:  Creational patterns (e.g, builder, factory, prototype, singleton)  Structural patterns (e.g, adapter, bridge, composite, decorator, facade, fly- weight, proxy)  Behavioral patterns (e.g, command, interpreter, iterator, mediator, memento, observer, peer-to-peer, publish-subscribe, state, strategy, template, visitor) Design patterns can be used to reflect idioms that have proven useful in solving particular design problems in the past, establish a solution vocabulary, and document and explain design decisions. They arise at all stages of design, including architectural design. Often architec- tural styles can be viewed as patterns in the large, describing common solutions to archi- tecture-level problems that pervade the soft- ware. (See also topic 2.2 Architecture Styles and Patterns, Software Architecture KA). 4.5. Specialized and Domain-Specific Languages 21 c15 Not every design representation falls easily into the structurebehavior dichotomy.

--- Chunk 173 ---
Tokens: 354
Type: sentence-based
Text:
Specialized and Domain-Specific Languages 21 c15 Not every design representation falls easily into the structurebehavior dichotomy. For example, user interface design mixes the structural layout of what a user might see with the behavioral logic of sequencing screens based upon user actions. Specialized concerns such as safety and reliability often have their own forms of representation that have evolved among specialists in those communities 21. A recent trend has been the maturing of domain-specific languages (DSLs) and widely available tools to develop them. In this approach, part of the design process is codifying concepts and constructs of a specific application domain to create a computer language for that domain so that representing the design using these constructs leads to an animated or exe- cutable implementation. DSLs blur the lines among modeling languages, design languages and programming languages in this approach. There are DSLs and supporting tools for domains such as simulation; real-time, reactive and distributed systems; game development; user interfaces; test development; and language processing tools. The growth of DSLs has been facilitated by increasingly powerful gram- mar-driven tools that, given a language defi- nition, can generate a graphical user interface, syntax checkers, code generators, compilers and linkers for the specialized language. SOFTWARE DESIGN 3-11 4.6.

--- Chunk 174 ---
Tokens: 372
Type: sentence-based
Text:
SOFTWARE DESIGN 3-11 4.6. Design Rationale 3 c16 4 c12 21 c6.1 A useful design outcome is insight into and explicit documentation of the major decisions taken, along with an explanation of the ratio- nale for each decision. Design rationale cap- tures why a design decision was made. This includes prior assumptions made, alternatives considered, and trade-offs and criteria ana- lyzed to select one approach and reject others. Although the reasons for decisions are likely to be obvious to the current design team, they can be less obvious to those who modify or main- tain the system after deployment. Recording the rationale enhances the software products long- term maintainability. Continuing to capture the rationale for changes during maintenance also contributes to the softwares viability. It can also be useful to capture rejected deci- sions and the reasons for rejection. Capturing these rationales can enable a team to revisit a previously rejected decision when assump- tions, requirements or constraints change. The importance of rationale is visible, for example, in free and open-source software (FOSS) projects, which often involve large, distributed teams of developers with frequent turnover. Design rationale may be captured as part of a software design description or as a com- panion artifact. Often rationale is captured in text, but other forms of representation can also be used, such as graphs that portray a design as an interconnected network of decisions. 5.

--- Chunk 175 ---
Tokens: 381
Type: sentence-based
Text:
5. Software Design Strategies and Methods 21 c3 Various strategies and methods exist to struc- ture and guide the design process; many of these evolved from programming styles or paradigms. In addition to embodying one or more general strategies, most design methods focus on making one or more design concepts (whether objects, methods or events) promi- nent as organizing themes for the software. These themes then guide the designers as to what to focus on first, how to proceed, and how to structure modules. 5.1. General Strategies 4 c13 Some often-cited examples of general strategies useful in the design process include divide-and- conquer and stepwise refinement strategies; top- down vs. bottom-up strategies; strategies using heuristics, patterns and pattern languages; and iterative and incremental approaches. 5.2. Function-Oriented (or Structured) Design 4 c9 This is one of the classical software design methods. It focuses on refinement (or decom- position) to identify major software func- tions, elaborating them in a top-down manner. Structured design often follows structured anal- ysis, producing DFDs and associated process descriptions. Various tools enable the automated translation of DFDs into high-level designs. 5.3. Data-Centered Design 4 c9 Data-centered design starts from the data structures a program manipulates rather than from the functions it performs. The software designer specifies the input and output data structures and then develops program units that transform inputs into outputs.

--- Chunk 176 ---
Tokens: 381
Type: sentence-based
Text:
The software designer specifies the input and output data structures and then develops program units that transform inputs into outputs. Various heuristics have been proposed to deal with spe- cial cases, such as cases where there is a mis- match between the input and output structures. 5.4. Object-Oriented Design 4 c10 Numerous software design methods based on objects have been proposed. The field has evolved from the early object-oriented design of the mid-1980s (where nouns depict objects; verbs depict methods; and adjec- tives depict attributes), where inheritance and polymorphism play key roles, to the field of component-based design (CBD), where metainformation can be defined and accessed (through reflection, for example). Although OODs roots stem from the concept of data abstraction, responsibility-driven design has been proposed as an alternative underlying principle of OOD. Often design strategies 3-12 SWEBOK  GUIDE V4.0 are provided with mnemonics such as SOLID (Single-responsibility, Openclosed, Liskov substitution, Interface segregation, and Dependency inversion) principles of class design and SOFA (Short, One thing, Few arguments and Abstraction level consistency) principles for method design. 5.5. User-Centered Design 3 c9 16 User-centered design is more than a design method; it is a multidisciplinary approach emphasizing a deep understanding of users and their needs as the basis for designing user experiences within the context of their orga- nization and the tasks to be accomplished.

--- Chunk 177 ---
Tokens: 381
Type: sentence-based
Text:
User-Centered Design 3 c9 16 User-centered design is more than a design method; it is a multidisciplinary approach emphasizing a deep understanding of users and their needs as the basis for designing user experiences within the context of their orga- nization and the tasks to be accomplished. It involves gathering user requirements, creating a user flow of tasks and decisions, creating prototypes or mockups representative of user interfaces, and evaluating the design solution against original requirements 16. 5.6. Component-Based Design (CBD) 4 c11, c16 21 c16 CBD decomposes a software system into one or more standalone components that com- municate only on well-defined interfaces and conform to a system-wide standard com- ponent model. A software component is an independent unit, having well-defined inter- faces and dependencies that can be composed and deployed independently. CBD addresses issues related to providing, developing and integrating such components to improve reuse. CBD often emphasizes common APIs for all components and specialized APIs for specific services or responsibilities. 5.7. Event-Driven Design 14, 15 Event-driven design is an approach where a system or component invokes its operations in reaction to events (indirect invocation) 15. Publishsubscribe messaging (broadcasting) is often used as means of transporting events via the network to all interested subscribers. Publishsubscribe keeps the producers and consumers decoupled using a message broker with channels called topics.

--- Chunk 178 ---
Tokens: 379
Type: sentence-based
Text:
Publishsubscribe keeps the producers and consumers decoupled using a message broker with channels called topics. This differs from Point-to-point messaging where senders and receivers need to know each other to deliver and receive a message. Different types of event processing exist, i.e. simple event pro- cessing, event stream processing and complex event processing. Message-based systems frequently incorporate identifiable senders and receivers within the design. Event- driven systems may not identify senders and receivers explicitlyinstead each module produces events while listening for any events they care about or need to respond to 14. Anonymous asynchronous message and event processing are good strategies for scal- able systems. 5.8. Aspect-Oriented Design (AOD) 12 AOD is a method by which software is con- structed using aspects to implement the cross- cutting concerns and extensions identified in software requirements 12. AOD evolved from object-oriented design and program- ming practices. Although it has yet to become a widespread design or programming para- digm, the aspect-oriented perspective is fre- quently used in application frameworks and software libraries where parameters of the framework or library can be configured with aspect declarations. 5.9. Constraint-Based Design 3 c11 Constraints role in the design process is to limit the size of a design space to exclude infea- sible or unacceptable alternatives. Constraints accelerate design because they force a few early decisions.

--- Chunk 179 ---
Tokens: 346
Type: sentence-based
Text:
Constraints accelerate design because they force a few early decisions. The constraints can reflect limits imposed on the hardware, software, data, operational procedures, interfaces or anything that affects the software. The constrained design space can then be explored with search or backtracking methods. Constraint-based design approaches are used in user interface design, gaming and other applications. In general, constraint satisfaction problems can be computationally intractable; however, var- ious kinds of constraint-based programming SOFTWARE DESIGN 3-13 can be used to approximate or solve con- straint problems. 5.10. Domain-Driven Design 14 Domain-driven design is a method in which the designer uses a domain-specific language shared with analysts and other stakeholders to describe the target software system. Through this shared language, objects, roles, events, and activities specified in the software require- ments can be expressed in the software design descriptions. (See the Requirements KA). 5.11. Other Methods 21 c18c21 Other approaches to design exist (see Software Engineering Models and Methods KA). For example, iterative and adaptive methods implement software increments and reduce the emphasis on rigorous software require- ments and design. Service-oriented methods builds distrib- uted software using web services executed on distributed computers.

--- Chunk 180 ---
Tokens: 400
Type: sentence-based
Text:
Service-oriented methods builds distrib- uted software using web services executed on distributed computers. Software systems are often constructed using services from different providers interconnect with standard proto- cols (e.g, HTTP, HTTPS, SOAP) designed to support service communication and service information exchange. 6. Software Design Quality Analysis and Evaluation 4 c7 21 c24 6.1. Design Reviews and Audits 4 c5.3 Design reviews are intended as compre- hensive examinations of a design to assess concerns such as status or degree of com- pletion, coverage of requirements, open or unresolved issues and potential problems. A design review can be undertaken at any stage of design. Design reviews can be conducted by the design team, by an independent third party or other stakeholder. A design audit is more narrowly focused on a set list of char- acteristics (e.g, a functional audit). (See also section 2.3 Reviews and Audits in Software Quality KA). 6.2. Quality Attributes 21 c24 Various attributes contribute to the quality of a software design, including various ilities (modularity, maintainability, portability, test- ability, usability) and nesses (correctness, robustness). Qualities are a major subset of concerns (see topic Stakeholders and Concerns in Software Architecture KA). Some qualities can be observed at runtime (e.g, performance, security, availability, functionality, usability); others cannot (e.g, modifiability, portability, reusability, testability); some (e.g, concep- tual integrity, correctness, completeness) are observable in the design of the software.

--- Chunk 181 ---
Tokens: 369
Type: sentence-based
Text:
Some qualities can be observed at runtime (e.g, performance, security, availability, functionality, usability); others cannot (e.g, modifiability, portability, reusability, testability); some (e.g, concep- tual integrity, correctness, completeness) are observable in the design of the software. 6.3. Quality Analysis and Evaluation Techniques 21 c24 Various tools and techniques can help in ana- lyzing and evaluating software design quality. (See also topic Software Quality Tools in Software Quality KA.) Software design reviews include informal and rigorous techniques to determine software qualities based on SDDs and other design artifacts for example, archi- tecture reviews, design reviews and inspections; scenario-based techniques; requirements tracing. Static analysis: formal or semiformal static (nonexecutable) analysis that can be used to evaluate a design (for example, fault- tree analysis or automated cross-checking). Design vulnerability analysis (for example, static analysis for security weaknesses) can be performed if security is a concern. Formal design analysis uses mathemat- ical models that allow designers to predict the behavior and validate the performance of the software instead of having to rely entirely on testing. Formal design anal- ysis can be used to detect residual speci- fication and design errors (perhaps caused by imprecision, ambiguity, and sometimes other kinds of mistakes). (See also Software Engineering Models and Methods KA.)

--- Chunk 182 ---
Tokens: 302
Type: sentence-based
Text:
(See also Software Engineering Models and Methods KA.) Simulation and prototyping: dynamic 3-14 SWEBOK  GUIDE V4.0 techniques to evaluate a design (for example, performance simulation or fea- sibility prototypes). 6.4. Measures and Metrics 4 c5, c17 21 c24.5 Measures can be used to assess or to quanti- tatively estimate various aspects of a software design; for example, size, structure, or quality. Most measures that have been proposed are based upon the approach used for producing the design (see topic 5 Software Design Strategies and Methods). These measures are classified in two broad categories:  Function-based (structured) design mea- sures: measures obtained by analyzing functional decomposition; generally rep- resented using a structure chart (or hierar- chical diagram) on which various measures can be calculated. Object-oriented design measures: the design structure is typically represented as a class diagram, on which various mea- sures can be computed. Measures on the properties of the internal content of each class can also be calculated. Object- oriented measures also consider the com- plexity of the code based on the lines of code per method or the number of mes- sages sent. 6.5.

--- Chunk 183 ---
Tokens: 342
Type: sentence-based
Text:
6.5. Verification, Validation, and Certification 21 c7, c8 Systematic analysis or evaluation of the design plays an important role in each of these three areas:  verification: to confirm that the design satisfies stated requirements;  validation: to establish that the design will allow the system to meet the expectations of its stakeholders, including customers, users, operators and maintainers;  certification: third-party attestation of conformity of design to its overall spec- ification and intended usage. (See also section 2.2 Verification and Validation in Software Quality KA.) MATRIX OF TOPICS VS. REFERENCE MATERIAL In table below, cX means chapter X 1. Software Design Fundamentals Brooks 3 Budgen 4 Gamma et al. 7 Sommerville 21 See also 1.1 Design Thinking c1, c2, c3 c1, c2 20 1.2 Context of Software Design c13, c14 c19, c20 1.3 Key Issues in Software Design 2, 12 1.4 Software Design Principles 5, 10, 17, 20 2. Software Design Processes c3 c2, c7 10 2.1 High-level Design c5 c6 10 2.2 Detailed Design 10 3. Software Design Qualities c4 20 3.1 Concurrency c17 3.2 Control and Handling of Events c21 3.3 Data Persistence c6, c16 SOFTWARE DESIGN 3-15 3.4 Distribution of Components c17 3.5 Errors and Exception Handling, Fault Tolerance c11 3.6 Integration and Interoperability c11, c14, c16 3.7 Assurance, Security and Safety c10c14 3.8 Variability 6 4.

--- Chunk 184 ---
Tokens: 384
Type: sentence-based
Text:
Software Design Qualities c4 20 3.1 Concurrency c17 3.2 Control and Handling of Events c21 3.3 Data Persistence c6, c16 SOFTWARE DESIGN 3-15 3.4 Distribution of Components c17 3.5 Errors and Exception Handling, Fault Tolerance c11 3.6 Integration and Interoperability c11, c14, c16 3.7 Assurance, Security and Safety c10c14 3.8 Variability 6 4. Recording Software Designs c7, c8 1 4.1 Model-based Design c7.3 c5.5 4.2 Structural Design Descriptions c7, c10 c4 c5.3 4.3 Behavioral Design Descriptions c9, c10 c5 c5.4 4.4 Design Patterns and Styles c12 c15 c1, c2 c7.2 7 4.5 Specialized and Domain- Specific Languages c15 4.6 Design Rationale c16 c12 c6.1 5. Software Design Strategies and Methods c3 5.1 General Strategies c13 5.2 Function-Oriented (or Structured) Design c9 5.3 Data-Centered Design c9 5.4 Object-Oriented Design c10 5.5 User-Centered Design c9 16 5.6 Component-Based Design (CBD) c11, c16 c16 5.7 Event-Driven Design 14, 15 5.8 Aspect-Oriented Design (AOD) 12 5.9 Constraint-Based Design c11 5.10 Domain-Driven Design 13 5.11 Other Methods c18c21 6. Software Design Quality Analysis and Evaluation c17 c24 6.1 Design Reviews and Audits c5.3 6.2 Quality Attributes c24 6.3 Quality Analysis and Evaluation Techniques c24 6.4 Measures and Metrics c5, c17 c24.5 6.5 Verification, Validation and Certification c7,c8 3-16 SWEBOK  GUIDE V4.0 FURTHER READINGS Brooks, The Design of Design 3 Brooks, one of the pioneers of software engi- neering, provides a collection of essays and case studies on all aspects of software design.

--- Chunk 185 ---
Tokens: 398
Type: sentence-based
Text:
Software Design Quality Analysis and Evaluation c17 c24 6.1 Design Reviews and Audits c5.3 6.2 Quality Attributes c24 6.3 Quality Analysis and Evaluation Techniques c24 6.4 Measures and Metrics c5, c17 c24.5 6.5 Verification, Validation and Certification c7,c8 3-16 SWEBOK  GUIDE V4.0 FURTHER READINGS Brooks, The Design of Design 3 Brooks, one of the pioneers of software engi- neering, provides a collection of essays and case studies on all aspects of software design. REFERENCES 1 G. Booch, J. Rumbaugh, and I. Jacobson, The Unified Modeling Language User Guide, 2nd edition, Addison- Wesley, 2005. 2 J. Bosch, Design and Use of Software Architectures: Adopting and Evolving a Product-Line Approach, ACM Press, 2000. 3 F. Brooks, The Design of Design, Addison-Wesley, 2010. 4 D. Budgen, Software Design: Creating Solutions for Ill-Structured Problems, 3rd Edition CRC Press, 2021. 5 E.W. Dijkstra, On the Role of Scientific Thought. 1974. http:www.cs.utexas .eduusersEWDtranscriptions EWD04xxEWD447.html. 6 M. Galster, D. Weyns, D. Tofan, B. Michalik, and P. Avgeriou, Variability in Software SystemsA Systematic Literature Review, IEEE Transactions on Software Engineering, 40(3), 2014. 7 E. Gamma et al, Design Patterns: Elements of Reusable Object-Oriented Software, 1st ed, Addison-Wesley, 1994. 8 S. Gregor and D. Jones, The Anatomy of a Design Theory, Association for Information Systems, 2007. 9 IEEE Std 7000-2021, IEEE Standard Model Process for Addressing Ethical Concerns during System Design. 10 ISOIECIEEE 12207, Systems and Software Engineering  Software Life Cycle Processes.

--- Chunk 186 ---
Tokens: 333
Type: sentence-based
Text:
10 ISOIECIEEE 12207, Systems and Software Engineering  Software Life Cycle Processes. 11 ISOIECIEEE, ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, 2nd ed. 2017. 12 G. Kiczales et al, Aspect-Oriented Programming, Proc. 11th European Conf. Object-Oriented Programming (ECOOP 97), Springer, 1997. 13 T. Kosar, S. Bohra, M. Mernik, Domain-Specific Languages: A Systematic Mapping Study, Information and Software Technology, 71, 77-91, 2016. 14 D. Luckham, The Power of Events: an Introduction to Complex Event Processing, Addison-Wesley, 2002. 15 G. Mhl, L. Fiege, and P. Pietzuch, Distributed Event-Based Systems, Spring- Verlag, 2006. 16 J. Nielsen, Usability Engineering, Morgan Kaufman, 1994. 17 D.L. Parnas, On the Criteria To Be Used In Decomposing Systems Into Modules, Communications of the ACM 15(12), 10531058, 1972. 18 D.L. Parnas and P.C. Clements, A Rational Design Process: How and Why to fake it, IEEE Transactions on Software Engineering 12(2), 251 257, 1986. 19 D.L. Parnas and D.M. Weiss, Active Design Reviews: Principles and Practices, Journal of Systems  Software 7, 259265, 1987 20 D.T. Ross, J.B. Goodenough, and A. Irvine, Software Engineering: SOFTWARE DESIGN 3-17 Process, Principles, and Goals, IEEE Computer, May 1975. 21 I. Sommerville, Software Engineering, 10th edition, Pearson, 2016.

--- Chunk 187 ---
Tokens: 398
Type: sentence-based
Text:
21 I. Sommerville, Software Engineering, 10th edition, Pearson, 2016. 4-1 CHAPTER 04 Software Construction ACRONYMS API Application Programming Interface ASIC Application-Specific Integrated Circuit BaaS Backend As A Service CI Continuous Integration COTS Commercial Off-The-Shelf CSS Cascading Style Sheets DSL Domain-Specific Language DSP Digital Signal Processor ESB Enterprise Service Bus FPGA Field Programmable Gate Array GPU Graphic Processing Unit GUI Graphical User Interface HTML5 Hypertext Markup Language Version 5 IDE Integrated Development Environment IEEE Institute Of Electrical And Electronics Engineers ISO International Organization For Standardization JEE Jakarta Enterprise Edition KA Knowledge Area MDA Model-Driven Architecture NPM Node Package Manager OMG Object Management Group PIM Platform Independent Model POSIX Portable Operating System Interface PSM Platform-Specific Model SDK Software Development Kit TDD Test-Driven Development UML Unified Modeling Language WYSIWYG What You See Is What You Get INTRODUCTION Software construction refers to the detailed cre- ation and maintenance of software through coding, verification, unit testing, integration testing and debugging. The software construction knowledge area (KA) is linked to all the other KAs, but it is most strongly linked to the Software Design and Software Testing KAs because the soft- ware construction process involves signifi- cant design and testing. The process uses the design output and provides an input to testing (design and testing in this case referring to the activities, not the KAs).

--- Chunk 188 ---
Tokens: 377
Type: sentence-based
Text:
The process uses the design output and provides an input to testing (design and testing in this case referring to the activities, not the KAs). Boundaries among design, construction and testing (if any) vary depending on the software life cycle processes used in a project. Although some detailed design might be performed before construction, much design work is performed during construction. Thus, the Software Construction KA is closely linked to the Software Design KA. Also, throughout construction, software engineers both unit-test and integration-test their work. Thus, the Software Construction KA is closely linked to the Software Testing KA as well. 4-2 SWEBOK  GUIDE V4.0 The Software Construction KA is also related to configuration management, quality, project management and computing, and thus to the relevant KAs. First, software construction typically pro- duces the highest number of configuration items that need to be managed in a software project (e.g, source files, documentation, test cases). Thus, the Software Construction KA is closely linked to the Software Configuration Management KA. Second, while quality is important in all the KAs, code is a software projects ultimate deliv- erable, and code is produced during construc- tion. Thus, the Software Quality KA is closely linked to the Software Construction KA. Third, while project management involves various software development tasks, soft- ware construction typically produces the most deliverables of a software project.

--- Chunk 189 ---
Tokens: 385
Type: sentence-based
Text:
Third, while project management involves various software development tasks, soft- ware construction typically produces the most deliverables of a software project. Thus, the Software Construction KA is closely linked to the Software Engineering Management KA. Fourth, since software construction requires knowledge of algorithms and coding practices, this KA is closely related to the Computing Foundations KA, which concerns the com- puter science foundations supporting software product design and construction. BREAKDOWN OF TOPICS FOR SOFTWARE COSTRUCTION The breakdown of topics for the Software Architecture KA is shown in Figure 4-1. 1. Software Construction Fundamentals Software construction fundamentals include the following:  Minimizing complexity  Anticipating and embracing change  Constructing for verification  Reusing assets  Applying standards in construction The first four concepts apply to design as well as to construction. The following sections define these concepts and describe how they apply to construction. 1.1. Minimizing Complexity 1, c2, c3, c7-9, c24, c27, c28, c3, 1, c32, c34 Most people have limited ability to hold complex structures and information in their working memories, especially over long periods. This greatly influences how people convey intent to computers and drives one of the key goals in software construction  to minimize complexity. The need to reduce complexity applies to essentially every aspect of software construction and is particularly critical to testing software constructions.

--- Chunk 190 ---
Tokens: 325
Type: sentence-based
Text:
The need to reduce complexity applies to essentially every aspect of software construction and is particularly critical to testing software constructions. Several types of complexity can affect software construction. Tools can be used to manage different aspects of the complexity of software components and their construc- tion. For example, cyclomatic complexity is a static analysis measure of how difficult code is to test and understand. The tool, developed by Thomas J. McCabe, Sr, in 1976, calculates the number of linearly independent paths through a programs source code. Ideally, there should be at least that number of test cases. Other examples are tools like Make, which can build an application, or integrated development environments (IDEs) for entering, editing and compiling code. These tools help manage the complexity of the construction process. In software construction, reduced com- plexity is achieved by creating simple and readable code rather than clever code. This is accomplished by using standards (see section 3.1.5, Standards in Construction), modular design (see section 3.1, Construction Design) and numerous other specific techniques (see section 3.3, Coding). Construction-focused quality techniques also support this (see sec- tion 3.6, Construction Quality). 1.2.

--- Chunk 191 ---
Tokens: 289
Type: sentence-based
Text:
1.2. Anticipating and Embracing Change 1-c3-c5, c24, c31, c32, c34, 2-c1, c3, c9, 3-c1 Most software changes over time, and anticipating change drives many aspects SOFTWARE CONSTRUCTION 4-3 of software construction; changes in the environments in which software oper- ates also affect software in diverse ways. Anticipating change helps software engi- neers build extensible software, enhancing a software product without disrupting the underlying structure. Anticipating change is supported by many specific techniques (see section 3.3, Coding). Moreover, todays business environments require many organizations to deliver and deploy software more frequently, faster and more reliably. Anticipating specific, nec- essary changes can be difficult, so soft- ware engineers should be careful to build flexibility and adaptability into the soft- ware to incorporate changes with less diffi- culty. These software teams should embrace change by adopting agile development, practicing DevOps, and by adopting con- tinuous delivery and deployment practices. Such practices align the software develop- ment process and management with an evo- lutionary environment.

--- Chunk 192 ---
Tokens: 373
Type: sentence-based
Text:
Such practices align the software develop- ment process and management with an evo- lutionary environment. Software Construction Software Construction Fundamentals Minimizing Complexity Anticipating and Embracing Change Construction for Verifcation Reusing Assets Applying Standards in Construction Construction in Life Cycle Models Construction Planning Construction Measurements Managing Dependencies Construction Design Construction Languages Coding Construction Testing Reuse in Construction Construction Quality Integration Cross-Platform Development and Migration API Design and Use Object-Oriented Runtime Issues Parameterization, Templates and Generics Assertions, Design by Contract and Defensive Programming Error Handling, Exception Handling and Fault Tolerance Executable Models State-Based and Table-Driven Construction Techniques Runtime Confguration and Internationalization Grammar-Based Input Processing Concurrency Primitives Middleware Construction Methods for Distribution and Cloud-Based Software Constructing Heterogeneous Systems Performance Analysis and Tuning Platform Standards Test-First Programming Feedback Loop for Construction Development Environments Visual Programming and Low-Code Zero-Code Platforms Unit Testing Tools Proofng, Performance Analysis and Slicing Tools Managing Construction Practical Considerations Construction Technologies Software Construction Tools Figure 4.1. Breakdown of Topics for the Software Construction KA 4-4 SWEBOK  GUIDE V4.0 1.3.

--- Chunk 193 ---
Tokens: 366
Type: sentence-based
Text:
Breakdown of Topics for the Software Construction KA 4-4 SWEBOK  GUIDE V4.0 1.3. Constructing for Verification 1-c8, c20-c23, c31, c34 Constructing for verification builds software in such a way that faults can be readily found by the software engineers writing the software as well as by the testers and users during inde- pendent testing and operational activities. Specific techniques that support constructing for verification include following coding standards to support code reviews and unit testing, organizing code to support automated testing, restricting the use of complex or dif- ficult-to-understand language structures, and recording software behaviors with logs. 1.4. Reusing Assets 2-c15 Reuse means using existing assets to solve dif- ferent problems. In software construction, typical assets that are reused include frame- works, libraries, modules, components, source code and commercial off-the-shelf (COTS) assets. Reuse has two closely related facets: construction for reuse and construction with reuse. The former means creating reusable software assets, whereas the latter means reusing soft- ware assets to construct a new solution. Reuse often transcends project boundaries, which means reused assets can be constructed in other projects or organizations. 1.5. Applying Standards in Construction 1-c4 Applying external or internal development standards during construction helps achieve a projects efficiency, quality and cost objec- tives.

--- Chunk 194 ---
Tokens: 389
Type: sentence-based
Text:
Applying Standards in Construction 1-c4 Applying external or internal development standards during construction helps achieve a projects efficiency, quality and cost objec- tives. Specifically, the choices of allowable programming language subsets and usage standards are important aids in achieving higher security. Standards that directly affect construction issues include the following:  Communication methods (e.g, standards for document formats and content)  Programming languages (e.g, standards for languages like Java and C)  Coding standards (e.g, standards for naming conventions, layout and indentation)  Exception handling policies (e.g, stan- dards for the information included in exceptions and the way how exceptions are handled after catching)  Platforms (e.g, interface standards for operating system calls)  Tools (e.g, diagrammatic standards for notations like UML - Unified Modeling Language) Use of external standards: Construction depends on external standards for construction languages, construction tools, technical inter- faces and interactions between the Software Construction KA and other KAs. Standards come from numerous sources, including hardware and software interface specifica- tions (e.g, OMG - Object Management Group) and international organizations (e.g, IEEE - the Institute of Electrical and Electronics Engineers, ISO - the International Organization for Standardization). Use of internal standards: Standards may also be created on an organizational basis at the corporate level or for use on specific projects.

--- Chunk 195 ---
Tokens: 381
Type: sentence-based
Text:
Use of internal standards: Standards may also be created on an organizational basis at the corporate level or for use on specific projects. These standards support coordinating group activities, minimizing complexity, anticipating change and constructing for verification. 2. Managing Construction 2.1. Construction in Life Cycle Models 1-c2, c3, c27, c29, 2-c3, c7, 3-c1 Numerous models have been created to develop software; some emphasize construc- tion more than others. Some models are more linear from the construction viewpoint, such as the water- fall and staged-delivery life cycle models. These models treat construction as an activity that occurs only after the completion of sig- nificant prerequisite work, including detailed requirements work, extensive design work and detailed planning. The more linear approaches emphasize the activities that precede con- struction (requirements and design) and create SOFTWARE CONSTRUCTION 4-5 more distinct separations between activities. In these models, constructions main emphasis might be coding. Other models, such as evolutionary proto- typing and agile development, are more iter- ative. These approaches treat construction as an activity that occurs concurrently with or overlaps other software development activi- ties (including requirements, design and plan- ning). These approaches mix design, coding and testing activities, and they often treat the combination of activities as construction (see the Software Engineering Management and Software Process KAs).

--- Chunk 196 ---
Tokens: 369
Type: sentence-based
Text:
These approaches mix design, coding and testing activities, and they often treat the combination of activities as construction (see the Software Engineering Management and Software Process KAs). The practices of continuous delivery and deployment further mix coding, testing, delivery and deployment activities. In these practices, software updates made during con- struction activities are continuously delivered and deployed into the production environ- ment. The whole process is fully automated by a deployment pipeline that consists of var- ious testing and deployment activities. Consequently, what is considered construc- tion depends on the life cycle model used. In general, software construction is mostly coding and debugging, but it also involves construction planning, detailed design, unit testing, integration testing and other activities. 2.2. Construction Planning 1-c3, c4, c21, c27-c29 The choice of construction method is a key aspect of the construction planning activity. This choice affects the extent to which con- struction prerequisites are performed, the order in which they are performed and the degree to which they should be completed before construction work begins. The approach to construction affects the project teams ability to reduce complexity, anticipate change and construct for verifica- tion. Each objective may also be addressed at the process, requirements and design levels, but the choice of construction method will influence them.

--- Chunk 197 ---
Tokens: 388
Type: sentence-based
Text:
Each objective may also be addressed at the process, requirements and design levels, but the choice of construction method will influence them. Construction planning also defines the order in which components are created and integrated, the integration strategy (for example, phased or incremental integration), the software quality management processes, the allocation of task assignments to specific software engineers, and other tasks, according to the chosen method. 2.3. Construction Measurement 1-c25, c28 Numerous construction activities and arti- facts can be measured, including code devel- oped, modified, reused, and destroyed; code complexity; code inspection statistics; fault-fix and fault-find rates; effort; and scheduling. These measurements can be useful for man- aging construction, ensuring quality during construction and improving the construc- tion process, among other uses (see the Software Engineering Process KA for more on measurement). 2.4. Managing Dependencies 2-c25 Software products often heavily rely on depen- dencies, including internal and external (com- mercial or open-source) dependencies, which allow developers to reuse common functional- ities instead of reinventing the wheel and sub- stantially improve developers productivity. In addition, package managers (e.g, Maven in Java and NPM in JavaScript) are widely used to automate the process of installing, upgrading, configuring and removing dependencies. The direct and indirect dependencies of software products constitute a dependency supply chain network.

--- Chunk 198 ---
Tokens: 378
Type: sentence-based
Text:
The direct and indirect dependencies of software products constitute a dependency supply chain network. Any dependency in the supply chain network can introduce poten- tial risk to software products and should be managed by developers or tools. Unnecessary dependencies should be avoided to improve build efficiency. License conflicts between dependencies and software products should be avoided to reduce legal risk. Propagation of dependencies defects or vulnerabilities into software products should be avoided to improve the quality of software products. Regulations and monitoring mechanisms should be devel- oped to prevent developers from introducing untrusted external dependencies. 4-6 SWEBOK  GUIDE V4.0 3. Practical Considerations Construction is an activity in which the soft- ware engineer often has to deal with some- times chaotic, changing and even conflicting real-world constraints. Because of real-world constraints, practical considerations drive construction more than some other KAs, and software engineering is perhaps most craft- like in the construction activities compared with other activities. 3.1. Construction Design 1-c3, c5, c24, 2-c7 Some projects allocate considerable design activity to construction, whereas others allo- cate design to a phase explicitly focused on design. Regardless of the exact allocation, some detailed design work occurs at the con- struction level, and that design work is dic- tated by constraints imposed by the real-world problem the software addresses.

--- Chunk 199 ---
Tokens: 374
Type: sentence-based
Text:
Regardless of the exact allocation, some detailed design work occurs at the con- struction level, and that design work is dic- tated by constraints imposed by the real-world problem the software addresses. Just as construction workers building a physical structure must make small modifi- cations for unanticipated gaps in the builders plans, software construction workers must make small or large modifications to flesh out software design details during construction. The details of the design activity at the construction level are essentially the same as described in the Software Design KA, but they are applied at a smaller scale to algo- rithms, data structures and interfaces. 3.2. Construction Languages 1-c4 Construction languages include all forms of communication by which a human can specify an executable solution to a problem. Consequently, construction languages and their implementations (e.g, compilers) can affect software quality attributes such as per- formance, reliability and portability. As a result, they can seriously contribute to secu- rity vulnerabilities. The simplest construction language is a configuration language, in which software engineers choose from a limited set of pre- defined options to create new or custom software installations. The text-based config- uration files used in both the Windows and Unix operating systems are examples of this, and some program generators menu-style selection lists constitute another example of a configuration language.

--- Chunk 200 ---
Tokens: 380
Type: sentence-based
Text:
The text-based config- uration files used in both the Windows and Unix operating systems are examples of this, and some program generators menu-style selection lists constitute another example of a configuration language. Toolkit languages are used to build appli- cations from elements in toolkits (integrated sets of application-specific reusable parts); they are more complex than configuration languages. Toolkit languages may be explic- itly defined as application programming lan- guages, or the applications might be implied by a toolkits set of interfaces. Scripting languages are commonly used application programming languages. In some scripting languages, scripts are called batch files or macros. Programming languages are the most flex- ible construction languages. They also contain the least amount of information about specific application areas and development processes. Therefore, they require the most training and skill to use effectively. The choice of program- ming language can greatly affect the like- lihood of vulnerabilities being introduced during coding (e.g, unsafe use of C and C library functions is questionable from a secu- rity viewpoint). Three general notations are used for pro- gramming languages:  Linguistic (e.g, CC, Java)  Formal (e.g, Event-B)  Visual (e.g, MATLAB) Linguistic notations are distinguished in particular by the use of textual strings to rep- resent complex software constructions. The combination of textual strings in patterns may have a sentence-like syntax.

--- Chunk 201 ---
Tokens: 369
Type: sentence-based
Text:
The combination of textual strings in patterns may have a sentence-like syntax. Properly used, each string should have a strong semantic connotation providing an immediate intui- tive understanding of what happens when the software construction is executed. Formal notations rely less on intuitive, everyday meanings of words and text strings and more on definitions backed by precise, unambiguous and formal (or mathematical) SOFTWARE CONSTRUCTION 4-7 definitions. Formal construction notations and methods are at the semantic base of most system programming notations, where accu- racy, time behavior and testability are more important than ease of mapping into natural language. Formal constructions also use pre- cisely defined ways of combining symbols that avoid the ambiguity of many natural language constructions. Visual notations rely much less on the textual notations of linguistic and formal construction and more on direct visual inter- pretation and placement of visual entities that represent the underlying software. Visual construction is somewhat limited by the dif- ficulty of making complex statements using only the arrangement of icons on a display. However, these icons can be powerful tools in cases where the primary programming task is to build and adjust a visual interface to a program, the detailed behavior of which has an underlying definition. Nowadays, domain-specific languages (DSLs) are widely used to build domain-spe- cific applications.

--- Chunk 202 ---
Tokens: 374
Type: sentence-based
Text:
Nowadays, domain-specific languages (DSLs) are widely used to build domain-spe- cific applications. Unlike a general-pur- pose programming language, such as CC or Java, a DSL is designed for the applica- tion construction of a particular domain. Therefore, a DSL usually can be defined based on a higher level of abstraction of the target domain and can be optimized for a specific class of problems. Furthermore, A DSL usually can be expressed by visual nota- tions defined by domain-specific concepts and rules. 3.3. Coding 1-c5-c19, c25-c26 The following considerations apply to the software construction coding activity:  Techniques for creating understandable source code, including naming conven- tions and source code layout  Use of classes, enumerated types, vari- ables, named constants and other sim- ilar entities  Use of control structures  Handling of error conditions  both anticipated and exceptional (e.g, input of bad data)  Prevention of code-level security breaches (e.g, buffer overflows or array index bounds)  Resource use through use of exclusion mechanisms and discipline in accessing serially reusable resources, including threads and database locks  Source code organization into state- ments, routines, classes, packages or other structures  Code documentation  Code tuning 3.4. Construction Testing 1-c22, c23, 2-c8 Construction involves two forms of testing, which are often performed by the software engineer who wrote the code: unit testing and integration testing.

--- Chunk 203 ---
Tokens: 384
Type: sentence-based
Text:
Construction Testing 1-c22, c23, 2-c8 Construction involves two forms of testing, which are often performed by the software engineer who wrote the code: unit testing and integration testing. Construction testing aims to reduce the gap between when faults are inserted into the code and when those faults are detected, thereby reducing the cost incurred to fix them. In some instances, test cases are written after the code has been written. In other instances, test cases might be created before code is written. Construction testing typically involves a subset of the various types of testing, described in the Software Testing KA. For instance, construction testing does not typically include system testing, alpha testing, beta testing, stress testing, configuration testing, usability testing, or other more specialized testing. Two standards have been published on construction testing: IEEE Standard 829- 1998, IEEE Standard for Software Test Documentation, and IEEE Standard 1008-1987, IEEE Standard for Software Unit Testing. See sections 2.1.1 and 2.1.2 in the Software Testing KA for more specialized refer- ence material. 3.5. Reuse in Construction 2-c15, c16 Reuse in construction includes both construc- tion for reuse and construction with reuse. 4-8 SWEBOK  GUIDE V4.0 Construction for reuse creates software with the potential to be reused in the future for the present project or for other projects with a broad-based, multisystem perspec- tive. Construction for reuse is usually based on variability analysis and design.

--- Chunk 204 ---
Tokens: 390
Type: sentence-based
Text:
Construction for reuse is usually based on variability analysis and design. To avoid the problem of code clones, developers should encapsulate reusable code fragments into well-structured libraries or components. The tasks related to software construc- tion for reuse during coding and testing are as follows:  Variability implementation with mech- anisms such as parameterization, condi- tional compilation and design patterns  Variability encapsulation to make the software assets easy to configure and customize  Testing the variability provided by the reusable software assets  Description and publication of reusable software assets Construction with reuse means creating new software by reusing existing software assets. The most popular reuse method is to reuse code from the libraries provided by the language, platform, tools or an organi- zational repository. Aside from these, many applications developed today use open-source libraries. In addition, reused and off-the- shelf software often have the same (or better) quality requirements as newly developed soft- ware (e.g, security level requirements). The tasks related to software construc- tion with reuse during coding and testing are as follows:  Selecting reusable units, databases, test procedures or test data  Evaluating code or test reusability  Integrating reusable software assets into the current software  Reporting reuse information on new code, test procedures or test data The forms of reusable software assets are not limited to software artifacts that must be locally integrated.

--- Chunk 205 ---
Tokens: 381
Type: sentence-based
Text:
The tasks related to software construc- tion with reuse during coding and testing are as follows:  Selecting reusable units, databases, test procedures or test data  Evaluating code or test reusability  Integrating reusable software assets into the current software  Reporting reuse information on new code, test procedures or test data The forms of reusable software assets are not limited to software artifacts that must be locally integrated. Nowadays, cloud services that provide various services through online interfaces such as RESTful application pro- gramming interfaces (APIs) are widely used in applications. In the new cloud service model BaaS (backend as a service), applications del- egate their backend implementations to cloud service providers  for example, utilities such as authentication, messaging and storage are usually provided by cloud providers. Reuse is best practiced systematically, according to a well-defined, repeatable pro- cess. Systematic reuse can enable signifi- cant software productivity, quality and cost improvements. Systematic reuse is supported by methodologies such as software product line engineering and various software frame- works and platforms. Widely used frameworks such as Spring provide reusable infrastruc- tures for enterprise applications so soft- ware teams can focus on application-specific business logic. Commercial platforms pro- vide various reusable frameworks, libraries, components and tools to support application development to build their ecosystems. 3.6.

--- Chunk 206 ---
Tokens: 386
Type: sentence-based
Text:
3.6. Construction Quality 1-c8, c20-c25, 2-c8, c24 In addition to faults occurring during require- ments and design activities, faults introduced during construction can cause serious quality problems (e.g, security vulnerabilities). These include not only faults in security function- ality but also faults elsewhere that allow bypassing of the security functionality or create other security weaknesses or violations. Numerous techniques exist to ensure the quality of code as it is constructed. The pri- mary techniques used to ensure construction quality are the following:  Unit testing and integration testing (see section 3.4, Construction Testing)  Test-first development (see section 6.1.2 in the Software Testing KA)  Use of assertions and defensive programming  Debugging SOFTWARE CONSTRUCTION 4-9  Inspections  Technical reviews, including securi- ty-oriented reviews (see section 2.3 in the Software Quality KA)  Static analysis (see section 2.2.1 of the Software Quality KA) The specific technique or techniques selected depend on the software constructed and on the skill set of the software engi- neers performing the construction activities. Programmers should know good practices and common vulnerabilities (e.g, from widely rec- ognized lists about common vulnerabilities). Automated static code analysis for security weaknesses is available for several common programming languages and can be used in security-critical projects. Construction quality activities are dif- ferentiated from other quality activities by their focus.

--- Chunk 207 ---
Tokens: 378
Type: sentence-based
Text:
Construction quality activities are dif- ferentiated from other quality activities by their focus. These activities focus on arti- facts that are closely related to code  such as detailed design  as opposed to other artifacts that are less directly connected to the code, such as requirements, high-level designs and plans. 3.7. Integration 1-c29, 2-c8, 3-c11 During construction, a key activity is inte- grating individually constructed routines, classes, components and subsystems into a single system. In addition, a particular soft- ware system may need to be integrated with other software or hardware systems. Concerns related to construction integra- tion include planning the sequence in which components are integrated, identifying what hardware is needed, creating scaffolding to support interim versions of the software, determining the degree of testing and quality work performed on components before they are integrated, and determining points in the project at which interim versions of the soft- ware are tested. Programs can be integrated by means of either the phased or the incremental approach. Phased integration, also called big bang integration, entails delaying the integration of component software parts until all parts intended for release in a version are complete. Incremental integration is thought to offer many advantages over the traditional phased integration (e.g, easier error loca- tion, improved progress monitoring, earlier product delivery and improved customer rela- tions).

--- Chunk 208 ---
Tokens: 386
Type: sentence-based
Text:
Incremental integration is thought to offer many advantages over the traditional phased integration (e.g, easier error loca- tion, improved progress monitoring, earlier product delivery and improved customer rela- tions). In incremental integration, the devel- opers write and test a program in small pieces and then combine the pieces one at a time. Additional test infrastructure, including, for example, stubs, drivers and mock objects, is usually needed to enable incremental integra- tion. In addition, by building and integrating one unit at a time (e.g, a class or compo- nent), the construction process can provide early feedback to developers and customers. Other advantages of incremental integration include easier error location, improved prog- ress monitoring and more fully tested units, among others. Nowadays, continuous integration (CI) has been widely adopted in practice. A software team using CI integrates its work frequently, leading to multiple integrations per day. CI is usually automated by a pipeline that builds and tests each integration to detect errors and provide fast feedback. 3.8. Cross-Platform Development and Migration 4-c Some applications, such as mobile applica- tions, heavily rely on specific platforms (e.g, Apple, Android), which usually include operating systems, development frameworks and APIs. To support multiple platforms, the developers need to develop and build an application separately for each target plat- form using the corresponding program lan- guage and software development kit (SDK).

--- Chunk 209 ---
Tokens: 391
Type: sentence-based
Text:
To support multiple platforms, the developers need to develop and build an application separately for each target plat- form using the corresponding program lan- guage and software development kit (SDK). However, multi-platform development in this way requires more time and cost and might cause different user experiences between dif- ferent implementations. Cross-platform development allows the developers to develop an application using a universal language and export it to various platforms. This usually can be done in two 4-10 SWEBOK  GUIDE V4.0 ways for mobile applications. One way is to generate native applications using specific tools that can compile the universal language into platform-specific formats. The other is to develop hybrid applications that combine web applications developed using languages like hypertext markup language version 5 (HTML5) and cascading style sheets (CSS) and native containers or wrappers for various operations systems. For applications that are not developed in this way, developers may consider migrating the applications from one platform to another. The migration usually involves translation of different programming languages and plat- form-specific APIs and can be partially auto- mated by tools. 4. Construction Technologies 4.1. API Design and Use 5-c7 An API is a set of signatures that are exported and available to the users of a library or a framework to write their applications. Besides signatures, an API should always include statements about the programs effects andor behaviors (i.e, its semantics).

--- Chunk 210 ---
Tokens: 375
Type: sentence-based
Text:
Besides signatures, an API should always include statements about the programs effects andor behaviors (i.e, its semantics). API design should make the API easy to learn and memorize, lead to readable code, be difficult to misuse, be easy to extend, be com- plete, and maintain backward compatibility. As the APIs usually outlast their implemen- tations for a widely used library or framework, an API should be straightforward and stable, to facilitate client application development and maintenance. API use involves selecting, learning, testing, integrating and possibly extending APIs provided by a library or framework (see section 3.5, Reuse in Construction). For online interfaces such as RESTful APIs, open standers such as OpenAPI play an important role. OpenAPI defines a stan- dard, language-agnostic interface to HTTP APIs and supports the automatic generation of server-side and client-side code, covering popular languages such as Java, JavaScript, Python, etc. At the same time, API-first approach has been widely used, which emphasizes designing and building the APIs of an application first. In practice, API-first approach is usually accomplished by using an API description language to establish a con- tract for how the API is supposed to behave. 4.2. Object-Oriented Runtime Issues 1-c6, c7 Object-oriented languages support run- time mechanisms, including polymorphism and reflection. These runtime mechanisms increase the flexibility and adaptability of object-oriented programs.

--- Chunk 211 ---
Tokens: 370
Type: sentence-based
Text:
These runtime mechanisms increase the flexibility and adaptability of object-oriented programs. Polymorphism is a languages ability to support general operations without knowing until runtime what kind of concrete objects the software will include. Because the pro- gram does not know the types of the objects in advance, the exact behavior is determined at runtime (called dynamic binding). Reflection is a programs ability to observe and modify its structure and behavior at run- time. For example, reflection allows inspection of classes, interfaces, fields and methods at runtime without knowing their names at com- pile time. It also allows instantiation of new objects at runtime and invocation of methods using parameterized class and method names. 4.3. Parameterization, Templates, and Generics 6-c1 Parameterized types, also known as generics (Ada, Java, Eiffel) and templates (C), enable a type or class definition without specifying all the other types used. The unspecified types are supplied as parameters at the point of use. Parameterized types provide a third way (besides class inheritance and object compo- sition) to compose behaviors in object-ori- ented software. 4.4. Assertions, Design by Contract, and Defensive Programming 1-c8, c9 An assertion is an executable predicate placed in a program  usually a routine or macro  that allows runtime checks of the program. SOFTWARE CONSTRUCTION 4-11 Assertions are especially useful in high-reli- ability programs.

--- Chunk 212 ---
Tokens: 393
Type: sentence-based
Text:
SOFTWARE CONSTRUCTION 4-11 Assertions are especially useful in high-reli- ability programs. They enable programmers to more quickly flush out mismatched interface assumptions, errors that creep in when code is modified, and other problems. Assertions are typically compiled into the code at develop- ment time and are later compiled out of the code so they dont degrade the performance. Design by contract is a development approach in which preconditions and postconditions are included for each routine. When precondi- tions and postconditions are used, each rou- tine or class is said to form a contract with the rest of the program. A contract precisely specifies the semantics of a routine and thus helps clarify its behavior. Design by contract is thought to improve the quality of software construction. Defensive programming means to protect a routine from being broken by invalid inputs. Common ways to handle invalid inputs include checking the values of all the input parameters and deciding how to handle bad inputs. Assertions are often used in defensive programming to check input values. 4.5. Error Handling, Exception Handling, and Fault Tolerance 1-c8, c9 How errors are handled affects softwares ability to meet requirements related to correct- ness, robustness and other nonfunctional attri- butes. Assertions are sometimes used to check for errors. Other error-handling techniques  such as returning a neutral value, substituting the next piece of valid data, logging a warning message, returning an error code or shutting down the software  are also used.

--- Chunk 213 ---
Tokens: 366
Type: sentence-based
Text:
Other error-handling techniques  such as returning a neutral value, substituting the next piece of valid data, logging a warning message, returning an error code or shutting down the software  are also used. Exceptions are used to detect and process errors or exceptional events. The basic struc- ture of an exception is as follows: A routine uses throw to throw a detected exception, and an exception-handling block will catch the exception in a try-catch block. The try- catch block may process the erroneous condi- tion or return control to the calling routine. Exception-handling policies should be care- fully designed following common principles, such as including in the exception message all information that led to the exception, avoiding empty catch blocks, knowing the exceptions the library code throws, perhaps building a centralized exception reporter, and standardizing the programs use of exceptions. Fault tolerance is a collection of techniques that increase software reliability by detecting errors and then recovering from them or con- taining their effects if recovery is not possible. The most common fault tolerance strate- gies include backing up and retrying, using auxiliary code and voting algorithms, and replacing an erroneous value with a phony value that will have a benign effect. 4.6. Executable Models 7 Executable models abstract away the details of specific programming languages and deci- sions about the softwares organization.

--- Chunk 214 ---
Tokens: 393
Type: sentence-based
Text:
Executable Models 7 Executable models abstract away the details of specific programming languages and deci- sions about the softwares organization. Different from traditional software models, a specification built in an executable mod- eling language like xUML (executable UML) can be deployed in various software environ- ments without change. Furthermore, an exe- cutable-model compiler (transformer) can turn an executable model into an implemen- tation using a set of decisions about the target hardware and software environment. Thus, constructing executable models is a way of constructing executable software. Executable models are one foundation supporting the model-driven architecture (MDA) initiative of the OMG. An executable model is a way to specify a platform-indepen- dent model (PIM); a PIM is a model of a solution to a problem that does not rely on any implementation technologies. Then a plat- form-specific model (PSM), which is a model that contains the details of the implementa- tion, can be produced by weaving together the PIM and the platform on which it relies. 4.7. State-Based and Table-Driven Construction Techniques 1-c18 State-based programming, or automata-based programming, is a programming technology 4-12 SWEBOK  GUIDE V4.0 that uses finite-state machines to describe program behaviors. A state machines transi- tion graphs are used in all stages of software development (specification, implementation, debugging and documentation). The main idea is to construct computer programs in the same way technological processes are auto- mated.

--- Chunk 215 ---
Tokens: 353
Type: sentence-based
Text:
The main idea is to construct computer programs in the same way technological processes are auto- mated. State-based programming is usually combined with object-oriented programming, forming a new composite approach called state-based, object-oriented programming. A table-driven method is a schema that uses tables to display information rather than convey information with logic state- ments (such as if and case). When used in appropriate circumstances, table-driven code is simpler than complicated logic and easier to modify. When using table-driven methods, the programmer addresses two issues: what information to store in the table or tables and how to efficiently access infor- mation in the table. 4.8. Runtime Configuration and Internationalization 1-c3, c10 To achieve more flexibility, a program is often constructed to support its variables late binding time. For example, runtime configu- ration binds variable values and program set- tings when the program is running, usually by updating and reading configuration files in a just-in-time mode. Internationalization is the technical activity of preparing a program, usually interactive software, to support multiple locales. The cor- responding activity, localization, modifies a program to support a specific local language. Interactive software may contain dozens or hundreds of prompts, status displays, help messages, error messages and so on.

--- Chunk 216 ---
Tokens: 373
Type: sentence-based
Text:
Interactive software may contain dozens or hundreds of prompts, status displays, help messages, error messages and so on. The design and construction processes should accommodate string and character set issues, including which character set is used, what kinds of strings are used, how to maintain the strings without changing the code and how to translate the strings into different languages with minimal impact on the processing code and the user interface. 4.9. Grammar-Based Input Processing 1, 8 Grammar-based input processing involves syntax analysis, or parsing, of the input token stream. It involves the creation of a data struc- ture (called a parse tree or syntax tree) repre- senting the input data. The inorder traversal of the parse tree usually gives the expres- sion just parsed. Next, the parser checks the symbol table for programmer-defined vari- ables that populate the tree. After building the parse tree, the program uses it as an input to the computational processes. 4.10. Concurrency Primitives 9-c6 A synchronization primitive is a programming abstraction provided by a programming lan- guage or the operating system that facilitates concurrency and synchronization. Well- known concurrency primitives include sema- phores, monitors and mutexes. A semaphore is a protected variable or abstract data type that provides a simple but useful abstraction for controlling access to a common resource by multiple processes or threads in a concurrent programming environment.

--- Chunk 217 ---
Tokens: 399
Type: sentence-based
Text:
A semaphore is a protected variable or abstract data type that provides a simple but useful abstraction for controlling access to a common resource by multiple processes or threads in a concurrent programming environment. A monitor is an abstract data type that pres- ents a set of programmer-defined operations executed with mutual exclusion. A monitor contains the declaration of shared variables and procedures or functions that operate on those variables. The monitor construct ensures that only one process at a time is active in the monitor. A mutex (mutual exclusion) is a synchro- nization primitive that grants exclusive access to a shared resource by only one process or thread at a time. 4.11. Middleware 5-c1, 8-c8 Middleware is a broad classification for soft- ware that provides services above the operating system layer yet below the application pro- gram layer. Middleware can provide runtime containers for software components to provide message passing, persistence and a transparent SOFTWARE CONSTRUCTION 4-13 location across a network. Middleware can be viewed as a connector between the com- ponents using the middleware. Modern mes- sage-oriented middleware usually provides an enterprise service bus (ESB) that supports ser- vice-oriented interaction and communication among multiple software applications. 4.12. Construction Methods for Distributed and Cloud-Based Software 2-c17, c18, 9-c2 A distributed system is a collection of physically separate, possibly heterogeneous computer systems networked to provide the users with access to the resources the system maintains.

--- Chunk 218 ---
Tokens: 371
Type: sentence-based
Text:
Construction Methods for Distributed and Cloud-Based Software 2-c17, c18, 9-c2 A distributed system is a collection of physically separate, possibly heterogeneous computer systems networked to provide the users with access to the resources the system maintains. The construction of distributed software is distinguished from traditional software con- struction by issues such as parallelism, com- munication and fault tolerance. Distributed programming typically falls into several basic architectural categories: client-server, three-tier architecture, n-tier architecture, distributed objects, loose cou- pling or tight coupling (see section 5.6 in the Computing Foundations KA and section 2.2 in the Software Architecture KA). Nowadays, more applications are migrated to the cloud. Cloud-based software often adopts microservice architecture and container-based deployment. In addition to traditional dis- tributed software issues, cloud-based soft- ware developers also need to consider cloud infrastructure issues such as use of an API gateway, service registration and discovery. Distributed systems based on n-tierser- vice-oriented architectures usually rely on ACID distributed transactions for the imple- mentation of transactions involving multiple distributed components. In contrast, cloud- based microservices cannot enforce distributed transactions consistency, and use some form of SAGA-based eventual consistency, initially intended for long-running transactions. 4.13.

--- Chunk 219 ---
Tokens: 369
Type: sentence-based
Text:
4.13. Constructing Heterogeneous Systems 8-c9 Heterogeneous systems consist of various special- ized computational units of different types, such as Graphic Processing Units (GPUs) and Digital Signal Processors (DSPs), micro- controllers and peripheral processors. These computational units are independently con- trolled and communicate with one another. Embedded systems are typically heteroge- neous systems. The design of heterogeneous systems may require combining several specifica- tion languages to design different system parts (hardwaresoftware codesign). The key issues include multilanguage validation, co-simulation and interfacing. During the hardwaresoftware code- sign, software and virtual hardware develop- ment proceed concurrently through stepwise decomposition. The hardware part is usually simulated in field programmable gate arrays (FPGAs) or application-specific integrated circuits (ASICs). The software part is trans- lated into a low-level programming language. 4.14. Performance Analysis and Tuning 1-c25, c26 Code efficiency  determined by architec- ture, detailed design decisions, and data struc- ture and algorithm selection  influences execution speed and size. Performance analysis investigates a programs behavior using infor- mation gathered as the program executes to identify possible hot spots in the program to be improved. Code tuning, which improves performance at the code level, modifies correct code to make it run more efficiently.

--- Chunk 220 ---
Tokens: 382
Type: sentence-based
Text:
Code tuning, which improves performance at the code level, modifies correct code to make it run more efficiently. Code tuning usually involves only small changes that affect a single class, a single routine or, more com- monly, a few lines of code. A rich set of code tuning techniques is available, including those for tuning logic expressions, loops, data trans- formations, expressions and routines. Using a low-level language is another common tech- nique for improving hot spots in a program. 4.15. Platform Standards 4-c, 8-c10, 9-c1 Platform standards enable programmers to develop portable applications that can be exe- cuted in compatible environments without 4-14 SWEBOK  GUIDE V4.0 changes. Platform standards usually involve standard services and APIs that compat- ible platform implementations must use. Typical examples of platform standards are Jakarta Enterprise Edition (JEE); the por- table operating system interface (POSIX) standard for operating systems, which rep- resents a set of standards implemented pri- marily for Unix-based operating systems; and HTML5, which defines the standards for developing web applications that can run on different environments (e.g, Apple iOS, Android). 4.16. Test-First Programming 1-c22, 2-c8 Test-first programming (also known as TDD - Test-Driven Development) is a popular devel- opment style in which test cases are written before any code. These test cases, when applied to the current code base, will fail. Code is then written that will allow the test cases to pass.

--- Chunk 221 ---
Tokens: 355
Type: sentence-based
Text:
Code is then written that will allow the test cases to pass. At that time, the new code and associated parts of the project can be refactored and opti- mized. Test-first programming can usually detect defects earlier and correct them more easily than traditional programming styles. Furthermore, writing test cases first forces programmers to think about requirements and design before coding, thus exposing require- ments and design problems sooner. 4.17. Feedback Loop for Construction 3-c3, c16 Early and continuous feedback for the construction activity is one of the most important advantages of agile development and DevOps. Agile development provides early feedback for construction through fre- quent iterations in the development process. DevOps provides even faster feedback from the operation, allowing the developers to learn how well their code performs in pro- duction environments. This fast feedback is achieved through techniques and practices in the DevOps pipeline, such as automated building and testing, canary release, and AB testing. 5. Software Construction Tools 5.1. Development Environments 1-c30 A development environment, or integrated development environment (IDE), provides comprehensive facilities to programmers for software construction by integrating a set of development tools. The programmers choice of development environment can affect soft- ware construction efficiency and quality.

--- Chunk 222 ---
Tokens: 359
Type: sentence-based
Text:
The programmers choice of development environment can affect soft- ware construction efficiency and quality. Besides basic code editing functions, modern IDEs often offer other features, like compilation and error detection within the editor, integration with source code control, buildtestdebugging tools, compressed or outline views of programs, automated code transforms, and support for refactoring. Nowadays, cloud-based development envi- ronments are available in public or private cloud services. These environments can pro- vide all the features of modern IDEs and even more (e.g, containerized building and deployment), powered by the cloud. Moreover, modern IDEs are often equipped with AI-assisted programming which is boosted by the recent advances in Large Language Models (LLMs). With the support a programmer can define a function in pseudo- code comments or outline its implementa- tion as a prompt for an LLM to generate or complete the code. The programmer lets the LLM complete many of the details, but still reviews the generated code and integrates it into their project. 5.2. Visual Programming and Low-CodeZero- Code Platforms 1-c30 Visual programming allows users to create pro- grams by manipulating visual program ele- ments graphically. As a visual programming tool, a GUI (graphical user interface) builder enables the developer to create and main- tain GUIs in a WYSIWYG (what you see is what you get) mode.

--- Chunk 223 ---
Tokens: 388
Type: sentence-based
Text:
As a visual programming tool, a GUI (graphical user interface) builder enables the developer to create and main- tain GUIs in a WYSIWYG (what you see is what you get) mode. A GUI builder usu- ally includes a visual editor that enables the developer to design forms and windows and manage the layout of the widgets with drag, SOFTWARE CONSTRUCTION 4-15 drop and parameter setting features. Some GUI builders can automatically generate the source code corresponding to the visual GUI design. Because GUI applications usually follow the event-driven style (in which events and event handling determine the program flow), GUI builder tools usually provide code generation assistants, which automate the most repetitive tasks required for event han- dling. The supporting code connects widgets with the outgoing and incoming events that trigger the functions providing the application logic. Some modern IDEs provide integrated GUI builders or GUI builder plug-ins. There are also many stand-alone GUI builders. Visual programming and other rapid appli- cation development tools have evolved into low-codezero-code platforms. These platforms allow developers to build complete applica- tions visually through a drag-and-drop inter- face and with minimal hand-coding. They are usually based on the principles of mod- el-driven design, visual programming and code generation. The difference between low- code development and zero-code development lies in hand-coding; the former requires a little hand-coding, whereas the latter requires practically none. 5.3.

--- Chunk 224 ---
Tokens: 382
Type: sentence-based
Text:
5.3. Unit Testing Tools 1-c22, 2-c8 Unit testing verifies the functioning of soft- ware modules in isolation from other sepa- rately testable software elements (for example, classes, routines, components). Unit testing is often automated. Developers can use unit testing tools and frameworks to extend and create an automated testing environment. For example, the developer can code criteria into the test with unit testing tools and frame- works to verify the units correctness under various data sets. Each test is implemented as an object, and a test runner runs the tests. Failed test cases will be automatically flagged and reported during the test execution. 5.4. Profiling, Performance Analysis, and Slicing Tools 1-c25, c26 Performance analysis tools are usually used to support code tuning. The most common per- formance analysis tools are profiling tools. An execution profiling tool monitors the code while it runs and records how often each statement is executed or how much time the program spends on each statement or exe- cution path. Profiling the code while it runs gives insight into how the program works, where the hot spots are and where the devel- opers should focus the code tuning efforts. Program slicing involves computing the set of program statements (i.e, the program slice) that might affect the values of specified vari- ables at some point of interest, which is called a slicing criterion. Program slicing can be used for locating error sources, program under- standing and optimization analysis.

--- Chunk 225 ---
Tokens: 392
Type: sentence-based
Text:
Program slicing can be used for locating error sources, program under- standing and optimization analysis. Program slicing tools compute program slices for var- ious programming languages using static or dynamic analysis methods. MATRIX OF TOPICS VS. REFERENCE MATERIAL McConnell, 2004 1 Sommerville, 2016 2 Kim et al, 2021 3 Heitktter et al, 2013 4 Clements et al, 2010 5 Gamma et al. 1994 6 Mellor and Balcer, 2002 7 Null and Lobur, 2006 8 Silberschatz et al, 2008 9 1. Software Construction Fundamentals 4-16 SWEBOK  GUIDE V4.0 1.1. Minimizing Complexity c2, c3, c7-c9, c24, c27, c28, c31, c32, c34 1.2. Anticipating and Embracing Change c3-c5, c24, c31, c32, c34 c1, c3, c9 c1 1.3. Constructing for Verification c8, c20-c23, c31, c34 1.4. Reuse c15 1.5. Standards in Construction c4 2. Managing Construction 2.1. Construction in Life Cycle Models c2, c3, c27, c29 c3, c7 c1 2.2. Construction Planning c3, c4, c21, c27-c29 2.3. Construction Measurement c25, c28 2.4. Managing Dependencies c25 3. Practical Considerations 3.1. Construction Design c3, c5, c24 c7 3.2. Construction Languages c4 3.3. Coding c5-c19, c25-c26 3.4. Construction Testing c22, c23 c8 3.5. Reuse in Construction c15, c16 3.6. Construction Quality c8, c20-c25 c8, c24 3.7. Integration c29 c8 c11 3.8. Cross-Platform Development and Migration c 4. Construction Technologies 4.1. API Design and Use c7 4.2. Object-Oriented Runtime Issues c6, c7 SOFTWARE CONSTRUCTION 4-17 4.3. Parameterization, Templates and Generics c1 4.4. Assertions, Design by Contract and Defensive Programming c8, c9 4.5.

--- Chunk 226 ---
Tokens: 363
Type: sentence-based
Text:
Assertions, Design by Contract and Defensive Programming c8, c9 4.5. Error Handling, Exception Handling and Fault Tolerance c3, c8 4.6. Executable Models 4.7. State-Based and Table-Driven Construction Techniques c18 4.8. Runtime Configuration and Internationalization c3, c10 4.9. Grammar-Based Input Processing c5 c8 4.10. Concurrency Primitives c6 4.11. Middleware c1 c8 4.12. Construction Methods for Distributed and Cloud-Based Software c17, c18 c2 4.13. Constructing Heterogeneous Systems c9 4.14. Performance Analysis and Tuning c25, c26 4.15. Platform Standards c c10 c1 4.16. Test-First Programming c22 c8 4.17. Feedback Loop for Construction c3, c16 5. Software Construction Tools 5.1. Development Environments c30 5.2. Visual Programming and Low-CodeZero- Code Platforms c30 5.3. Unit Testing Tools c22 c8 5.4. Profiling, Performance Analysis and Slicing Tools c25, c26 4-18 SWEBOK  GUIDE V4.0 FURTHER READINGS IEEE Std. 1517-1999: IEEE Standard for Information Technology--Software Life Cycle Processes--Reuse Processes, IEEE, 1999 8. This standard specifies the processes, activi- ties, and tasks to be applied during each phase of the software life cycle to enable a soft- ware product to be constructed from reusable assets. It covers the concept of reuse-based development and the processes of construc- tion for reuse and construction with reuse. ISOIEC 12207:2008: Information Technology--Software Life Cycle Processes, ISO IEC, 2008 9.

--- Chunk 227 ---
Tokens: 381
Type: sentence-based
Text:
ISOIEC 12207:2008: Information Technology--Software Life Cycle Processes, ISO IEC, 2008 9. This standard defines a series of software development processes, including software construction process, software integration process, and software reuse process. Martin Fowler, Kent Beck. Refactoring: Improving the Design of Existing Code (2nd Edition), Addison-Wesley Signature Series (Fowler). Robert C. Martin.Clean Code: A Handbook of Agile Software Craftsmanship, Pearson Education, Inc. REFERENCES 1 S. McConnell, Code Complete, 2nd edition, Redmond, WA: Microsoft Press, 2004. 2 I. Sommerville, Software Engineering, 10th edition, Addison-Wesley, 2016. 3 G. Kim et al, The DevOps Handbook: How to Create World-Class Agility, Reliability  Security in Technology Organizations, 2nd edition, IT Revolution, 2021. 4 H. Heitktter, S. Hanschke, and T.A. Majchrzak, Evaluating Cross-Platform Development Approaches for Mobile Applications, 2013, in Cordeiro, J, Krempels, K.H. (eds. ), Web Information Systems and Technologies. WEBIST 2012. Lecture Notes in Business Information Processing, vol. 140, Springer, Berlin, Heidelberg. 5 P. Clements et al, Documenting Software Architectures: Views and Beyond, 2nd edi- tion, Boston: Pearson Education, 2010. 6 E. Gamma et al, Design Patterns: Elements of Reusable Object-Oriented Software, 1st edition, Reading, MA: Addison-Wesley Professional, 1994. 7 S.J. Mellor and M.J. Balcer, Executable UML: A Foundation for Model-Driven Architecture, 1st edition, Boston: Addison-Wesley, 2002.

--- Chunk 228 ---
Tokens: 90
Type: sentence-based
Text:
Mellor and M.J. Balcer, Executable UML: A Foundation for Model-Driven Architecture, 1st edition, Boston: Addison-Wesley, 2002. 8 L. Null and J. Lobur, The Essentials of Computer Organization and Architecture, 2nd edition, Sudbury, MA: Jones and Bartlett Publishers, 2006. 9 A. Silberschatz et al, Operating System Concepts, 8th edition, Hoboken, NJ: Wiley, 2008.

--- Chunk 229 ---
Tokens: 393
Type: sentence-based
Text:
9 A. Silberschatz et al, Operating System Concepts, 8th edition, Hoboken, NJ: Wiley, 2008. 5-1 CHAPTER 05 Software Testing ACRONYMS AI Artificial Intelligence API Application Program Interface ARINC Aeronautical Radio Incorporated ATDD Acceptance Test-Driven Development CMMI Capability Maturity Model Integration CSS Cascading Style Sheets DICOM Digital Imaging and Communications in Medicine DL Deep Learning DU Definition and Use EBSE Evidence-Based Software Engineering ECS Ecosystem ETSI European Telecommunications Standards Institute FHIR Fast Healthcare Interoperability Resources GDPR General Data Protection Regulation GPS Global Positioning System GUI Graphical User Interface HIL Hardware-In-the-Loop HIPAA Health Insurance Portability and Accountability Act HL7 Health Level Seven IoT Internet of Things KPI Key Performance Indicator MCDC Modified Condition Decision Coverage ML Machine Learning MTTR Mean Time to Recovery OAT Orthogonal Array Testing ODC Orthogonal Defect Classification SoS System of Systems SPI Software Process Improvement SPICE Software Process Improvement and Capability Determination SUT System Under Test TDD Test-Driven Development TMMi Test Maturity Model integration UI User Interface UP Unified Process INTRODUCTION Software testing consists of the dynamic vali- dation that a system under test (SUT) provides expected behaviors on a finite set of test cases suitably selected from the usually infinite exe- cution domain. In the above statement, italicized words correspond to key issues in the Software Testing knowledge area (KA).

--- Chunk 230 ---
Tokens: 388
Type: sentence-based
Text:
In the above statement, italicized words correspond to key issues in the Software Testing knowledge area (KA). Those terms are discussed below. System Under Test: This term can refer to the tested object, which could be a pro- gram, a software product, an applica- tion, a service-oriented application (e.g, web services, microservices), middleware (HWSW), a services composition, a system, a System of Systems (SoS), or an Ecosystem (ECS). Test Case: A test case is the specification of all the entities that are essential for the execution, such as input values, execution 5-2 SWEBOK  GUIDE V4.0 and timing conditions, testing procedure, and the expected outcomes (e.g, pro- duced values, state changes, output mes- sages). Input values alone are not always sufficient to specify the test cases because the SUT might react to the same input with different behaviors, depending, for instance, on the SUT state or environ- mental conditions. A set of test cases is usually called a test suite. Dynamic: Dynamic validation requires executing the SUT on a test suite. Static techniques complement dynamic testing, and they are covered in the Software Quality KA.1  Finite: Even in a simple SUT, executing all the possible test cases (i.e, exhaus- tive testing) could require months or years. Consequently, in practice, testing targets a subset of all possible test cases determined by different criteria. Testing always implies a trade-off between lim- ited resources and schedules on the one hand and inherently unlimited test requirements on the other.

--- Chunk 231 ---
Tokens: 385
Type: sentence-based
Text:
Testing always implies a trade-off between lim- ited resources and schedules on the one hand and inherently unlimited test requirements on the other. Selected: Identifying the most suitable selection criteria under given conditions is a complex problem. Different tech- niques can be considered and combined to tackle that problem, such as risk anal- ysis, software requirements, cost reduc- tion, quality attributes satisfaction, prioritization, and fault detection. The many proposed test techniques differ in how the test suite is selected, and soft- ware engineers must be aware that dif- ferent selection criteria might yield vastly different degrees of effectiveness. Expected: For each executed test case, it must be possible, although it might not be easy, to decide whether the observed SUT outcomes match the expected ones. Indeed, the observed behavior may be checked against user needs (commonly referred to as testing for validation), against a specification (testing for verification), or, 1 It is worth noting that terminology is not uniform among different communities, and some use the term testing to refer to static techniques as well. perhaps, against the foreseen behavior from implicit requirements or expectations. (See Section 4.3, Acceptance Criteria- Based Requirements Specification, in the Software Requirements KA.) As reflected in this discussion, software testing is a pervasive and holistic activity involving all the steps of any process devel- opment life cycle (e.g, traditional or shift-left development).

--- Chunk 232 ---
Tokens: 400
Type: sentence-based
Text:
As reflected in this discussion, software testing is a pervasive and holistic activity involving all the steps of any process devel- opment life cycle (e.g, traditional or shift-left development). The remainder of this chapter presents the basics of software testing and its challenges, issues, and commonly accepted practices and solutions. BREAKDOWN OF TOPICS FOR SOFTWARE TESTING Figure 5.1 shows the breakdown of topics for the Software Testing KA. The Matrix of Topics vs. Reference Material provides a more detailed breakdown at the end of this KA. The first topic, Software Testing Fundamentals, covers the basic definitions in software testing, the basic terminology and key issues, and software testings relationship with other activities. The second topic, Test Levels, contains two (orthogonal) subtopics. The first subtopic, The Target of the Test, lists the levels into which the testing of large software is tradi- tionally subdivided, and the second subtopic, Objectives of Testing, discusses testing for specific conditions or properties. Not all types of testing apply to every software product, nor has every possible type been listed. The Target of the Test and Objectives of Testing together determine how the test suite is identified, both regarding its consistency (How much testing is enough for achieving the stated objective?) and its composition (Which test cases should be selected for achieving the stated objec- tive?). (However, usually, for achieving the stated objective remains implicit, and only the first part of the two questions above is SOFTWARE TESTING 5-3 posed.)

--- Chunk 233 ---
Tokens: 378
Type: sentence-based
Text:
(However, usually, for achieving the stated objective remains implicit, and only the first part of the two questions above is SOFTWARE TESTING 5-3 posed.) Criteria for addressing the first ques- tion are test adequacy criteria, whereas those used for addressing the second question are the test selection criteria. Several Test Techniques have been devel- oped in the past few decades, and new ones are still being proposed. Therefore, the third topic covers generally accepted and standard- ized techniques. Test-Related Measures are dealt with in the fourth topic, while the issues relative to the Test Process are covered in the fifth. Software Testing in the Development Processes and the Application Domains is described in the sixth topic, and Testing of and Testing Through Emerging Technologies are described in the seventh topic. Finally, Software Testing Tools are presented in topic eight. 1. Software Testing Fundamentals 1, c1, c2; 2, c8; 14, c7 This section provides an overview of the main testing issues and the relationship of testing to the other activities. Most of the testing terms used here are also defined. A more comprehensive overview of the testing and testing-related terminology can be found in the cited references. 1.1 Faults vs. Failures 1, c1s5; 2, c1; 14, c1s3 Many terms are used in the software engi- neering literature to describe a malfunction: notably fault (see, for comparison, defect in Section 3.2, Defect Characterization, in the Software Quality KA), failure and error.

--- Chunk 234 ---
Tokens: 223
Type: sentence-based
Text:
1.1 Faults vs. Failures 1, c1s5; 2, c1; 14, c1s3 Many terms are used in the software engi- neering literature to describe a malfunction: notably fault (see, for comparison, defect in Section 3.2, Defect Characterization, in the Software Quality KA), failure and error. It is essential to distinguish between the cause of a malfunction (for which the term fault is used here) and an undesired effect observed in the systems delivered service (a failure). Indeed, there might well be faults in the software that never manifest as failures. (See Theoretical and Practical Limitations of Testing in Section 1.2.8.) Thus, testing can reveal fail- ures, but the faults causing them are what can and must be removed. However, a failures cause cannot always be unequivocally iden- tified. No theoretical criteria exist to defin- itively determine, in general, the fault that caused an observed failure.

--- Chunk 235 ---
Tokens: 368
Type: sentence-based
Text:
No theoretical criteria exist to defin- itively determine, in general, the fault that caused an observed failure. The fault might have to be modified to remove the failure, but Software Testing Software Testing Fundamentals Software Testing in the Development Processes and the Application Domains Faults vs. Failures Key Issues Relationship of Testing to other Activities Te Target of the Test Objectives of Testing Specication- Based Techniques Structure- Based Test Techniques Experience-Based Techniques Fault-Based and Mutation Techniques Techniques Based on the Nature of the Application Selecting and Combining Techniques Techniques Based on Derived Knowledge Evaluation of the SUT Evaluation of the Test Performed Practical Considerations Test Sub- Processes and Activities Stang Testing Inside Software Development Process Testing in the Application Domains Test Levels Test Techniques Test-Related Measures Test Process Testing of and Testing Trough Emerging Technologies Testing of Emerging Technologies Testing Trough Emerging Technologies Software Testing Tools Testing Tool Support and Selection Categories of Tools Figure 5.1. Breakdown of Topics for the Software Testing KA 5-4 SWEBOK  GUIDE V4.0 other modifications might also work. To avoid ambiguity, we could refer to failure-causing inputs instead of faults  those sets of inputs that cause a failure to appear. 1.2. Key Issues This subsection provides an overview of the main testing issues. 1.2.1.

--- Chunk 236 ---
Tokens: 343
Type: sentence-based
Text:
1.2.1. Test Case Creation 1, c12s1, c12s3, 2, c8 Test case creation or generation creates the test suite useful for testing the SUT for specific purposes (e.g, adequacy, accuracy, or assess- ment). Because test case generation is among the most important and intensive software testing activities, it is usually supported by approaches, techniques, and tools to automate the process. 1.2.2. Test Selection and Adequacy Criteria 1, c1s14, c6s6, c12s7, 2, c8 A test selection criterion is a means of selecting test cases or determining that a test suite is sufficient for a specified purpose. Test case selection aims to reduce the car- dinality of the test suites while keeping the same effectiveness in terms of coverage or fault detection rate. Test adequacy criteria can be used to decide when sufficient testing is accomplished. 1.2.3 PrioritizationMinimization 4, part 2, part 3, c5 Suitable strategies for test case selection or prioritization can be adopted to improve testing efficacy. Test case prioritization aims to define a test execution order according to some criteria (e.g, coverage, fault detection rate, similarity, and risk), so those tests with a higher priority are executed before those with a lower priority. Test case minimization usu- ally aims to reduce a test suite by removing redundant test cases according to some crite- rion or purpose. 1.2.4.

--- Chunk 237 ---
Tokens: 394
Type: sentence-based
Text:
1.2.4. Purpose of Testing 1, c13s11, c11s4, 2, c8 Different well-defined purposes can guide testing activity; it is only by considering a specific purpose that a test suite can be gen- erated (selected), executed, and evaluated (see Section 2 for more details). 1.2.5. Assessment and Certification 4, part 1, c5; 2, c7, c25; 8 Testing needs to focus on specific (mandatory) prescriptions, such as requirements, laws, and standards. Test cases should be generated and executed to provide evidence useful for eval- uating andor certifying adherence to the selected prescriptions. Usually, assessment and certification of the test results include verifying that the test cases have been derived and gen- erated using baseline requirements, adopting a configuration control process, and using repeatable processes. 1.2.6. Testing for Quality Assurance Improvement 1, c16s2; 4, part 1, c5; 9 Testing has many aspects, including quality improvement and assurance. These charac- teristics involve planned and systematic sup- porting processes and activities leveraging confidence that the SUT fulfills established technical or quality requirements. Thus, quality improvement and assurance involve defining methods, tools, skills, and prac- tices to achieve the specific quality level and objectives. The list of the main quality char- acteristics that testing can measure or assess is reported in ISOIEC 25010:2011 9. (See also Section 1.3.2, Software Product Quality, in the Software Quality KA.) 1.2.7. The Oracle Problem 1, c1s9, c9s7 An important testing component is the oracle.

--- Chunk 238 ---
Tokens: 379
Type: sentence-based
Text:
The Oracle Problem 1, c1s9, c9s7 An important testing component is the oracle. Indeed, a test is meaningful only if it is possible to decide its observed outcome. SOFTWARE TESTING 5-5 An oracle can be any human or mechanical agent that decides whether the SUT behaved correctly in each test and according to the expected outcomes. Consequently, the oracle provides a pass or fail verdict. The oracle cannot always decide; in these cases, the test output is classified as inconclusive. There are many kinds of oracles  for example, unam- biguous requirements specifications, behav- ioral models, and code annotations. The automation of oracles can be difficult and expensive. 1.2.8. Theoretical and Practical Limitations 1, c2s7 Testing theory warns against ascribing unjus- tified confidence to a series of successful tests. Unfortunately, most established results of the testing theory are negative results in that they state what is not achieved as opposed to what is achieved. The most famous quo- tation on this point is the Dijkstra aphorism that program testing can be used to show the presence of bugs, but never to show their absence 3. The obvious reason for this is that complete testing is not feasible in real- istic software. 1.2.9. The Problem of Infeasible Paths 1, c4s7 Infeasible paths are control flow paths that cannot be exercised by any input data (i.e, test cases). Managing (i.e, identifying, solving or removing) the infeasible paths can help reduce the time and resources devoted to testing.

--- Chunk 239 ---
Tokens: 390
Type: sentence-based
Text:
Managing (i.e, identifying, solving or removing) the infeasible paths can help reduce the time and resources devoted to testing. They are a significant problem in path-based testing, particularly in the automated deri- vation of test cases to exercise control flow paths. Additionally, the detection of infeasible paths can also play a role in reducing security vulnerabilities. 1.2.10. Testability 1, c17s2 The term software testability has two related but different meanings. On the one hand, it refers to the ease with which a given test cov- erage criterion can be satisfied; on the other hand, it is defined as the likelihood, possibly measured statistically, that a test suite will expose a failure if the software is faulty. Both meanings are important. 1.2.11 Test Execution and Automation 4, part 1, c4 An important challenge of testing is to improve attainable automation, either by developing advanced techniques for generating the test inputs or, beyond test generation, by finding innovative sup- port procedures to (fully) automate the dif- ferent testing activities  for instance, to increase the number of test cases generated or executed. 1.2.12. Scalability 1, c8s7 Scalability is the softwares ability to increase and scale up on its nonfunctional require- ments, such as load, number of transactions, and volume of data. Scalability is also con- nected to the complexity of the platform and environment in which the program runs, such as distributed, wireless networks and virtual- ized environments, large-scale clusters, and mobile clouds.

--- Chunk 240 ---
Tokens: 363
Type: sentence-based
Text:
Scalability is also con- nected to the complexity of the platform and environment in which the program runs, such as distributed, wireless networks and virtual- ized environments, large-scale clusters, and mobile clouds. 1.2.13 Test Effectiveness 1 c1s1; 2 c8s1; 8 Evaluating the SUT, measuring a testing techniques efficacy, and judging whether testing can be stopped are important evi- dences for software testing, and they may require defining and selecting the proper test effectiveness measures. 1.2.14 Controllability, Replication, and Generalization 1 c12s12; 4, part 2, c7 Specific aspects of testing include the following: 5-6 SWEBOK  GUIDE V4.0  Controllability refers to the transition of testing activities from the laboratory (i.e, controlled conditions) to reality (i.e, uncontrolled conditions). Replication refers to the ability for dif- ferent people to perform the same testing activities. The purpose is to verify whether a given testing theory works, at least in the laboratory. The generalization of testing is connected to external validity  i.e, the extent to which the test approach can be applied to broader settings or target populations. The generalizability of the software testing can be important for managing the testing activities (in terms of cost and effort) and increasing confidence in the test results. 1.2.15. Offline vs. Online Testing 10, c3 The testing process can be executed in two settings: offline and online.

--- Chunk 241 ---
Tokens: 398
Type: sentence-based
Text:
Offline vs. Online Testing 10, c3 The testing process can be executed in two settings: offline and online. Usually, the SUT is validated in an environment without external interaction in offline testing, whereas the SUT interacts with the real application environment in online testing. The test cases are either manually or automatically derived in both cases, and the expected outcomes are used to assess the SUT. 1.3. Relationship of Testing to Other Activities Software testing is related to but different from static software quality management techniques, proofs of correctness, debugging, and program construction. However, it is informative to consider testing from the view- point of software quality analysts and certi- fiers. For further discussion, see the following:  Testing vs. Static Software Quality Management Techniques: See Section 2.2.1, Static Analysis Techniques, in the Software Quality KA. Testing vs. Quality Improvement Assurance: See Section 1.3.2, Software Product Quality, in the Software Quality KA. Testing vs. Correctness Proofs and Formal Verification: See the Software Engineering Models and Methods KA. Testing vs. Debugging: See Construction Testing in the Software Construction KA and Debugging Tools and Techniques in the Computing Foundations KA. Testing vs. Program Construction: See Construction Testing in the Software Construction KA. Testing vs. Security: See the new KA: Software Security. Testing vs. Effort Estimation: See the Software Engineering Management KA. Testing vs. Legal Issues: See the Software Engineering Professional Practice KA. 2.

--- Chunk 242 ---
Tokens: 393
Type: sentence-based
Text:
2. Test Levels 1, c1s13; 2, c8s1 Software testing is usually performed at dif- ferent levels throughout development and maintenance. Levels can be distinguished based on the object of testing, the target, or on the purpose or objective (of the test level). 2.1. The Target of the Test 1, c1s13, 2, c8s1 The target of the test can vary depending on the SUT, the conditions of the environ- ment, and the budgettime devoted to the testing activity. Four test stages can be distin- guished: unit, integration, system, and accep- tance. These four test stages do not imply any development process, nor is any one of them assumed to be more important than the other three. 2.1.1. Unit Testing 1, c3, 2, c8 Unit testing verifies the functioning in isola- tion of SUT elements that are separately test- able. Depending on the context, these could be the individual subprograms or components, a subsystem, or a composition of SUT com- ponents. Typically, but not always, the person who wrote the code conducts the unit testing. SOFTWARE TESTING 5-7 2.1.2. Integration Testing 1, c7, 2, c8 Integration testing verifies the interac- tions among SUT elements (for instance, components, modules, or subsystems). Integration strategies involve the incre- mental (and systematic) integration of the SUT elements considering either identified functional threads or architecture specifica- tions. Typical integration testing strategies are top-down, bottom-up, mixed (or sand- wiched), and the big bang. They focus on different perspectives of the level at which SUT elements are integrated.

--- Chunk 243 ---
Tokens: 399
Type: sentence-based
Text:
They focus on different perspectives of the level at which SUT elements are integrated. Integration testing is a continuous activity that can be performed at each development stage. It may target different aspects, such as interoperability (e.g, compatibility or con- figuration) of the SUT elements or with the external environment. External inter- faces to other applications, utilities, hard- ware devices or operating environments can also be considered. 2.1.3. System Testing 1, c8, 2, c8 System testing concerns testing the behavior of the SUT (according to the definition of Section 1). Effective unit and integration testing should have identified many SUT defects. In addition, system testing is usu- ally considered appropriate for assessing non-functional system requirements, such as security, privacy, speed, accuracy, and reli- ability. (See Functional and Non-Functional Requirements in the Software Requirements KA and Software Quality Requirements in the Software Quality KA.) 2.1.4. Acceptance Testing 1, c1s7, 2, c8s4 Acceptance testing targets the deployment of a SUT. Its main goal is to verify that the SUT satisfies the requirements and the end-users expectations. Generally, it is run by or with the end-users to perform those functions and tasks for which the software was built. For example, this testing activity could target usability testing or operational acceptance. Defining acceptance tests before imple- menting the corresponding functionality is a key activity of the acceptance test-driven development (ATDD). (See the Software Requirements KA, Section 4.3.) 2.2.

--- Chunk 244 ---
Tokens: 384
Type: sentence-based
Text:
2.2. Objectives of Testing 1, c1s7 Testing is conducted considering specific objectives, which are stated (more or less) explicitly and with varying degrees of preci- sion. Stating the testing objectives in precise, quantitative terms supports measurement and control of the test process. Testing can be aimed at verifying dif- ferent properties. For example, test cases can be designed to check that the functional specifications are correctly implemented, which is variously referred to in the liter- ature as conformance testing, correctness testing or functional testing. However, sev- eral other non-functional properties may be tested as well, including performance, reliability, and usability. (See Models and Quality Characteristics in the Software Quality KA.) Other important testing objectives include but are not limited to reliability measure- ments, identification of security and pri- vacy vulnerabilities, and usability evaluation; different approaches would be necessary depending on the objective. Note that, in general, the test objectives vary with the test target; different purposes are addressed at dif- ferent levels of testing. The subtopics listed below are those most cited in the literature. 2.2.1. Conformance Testing 1, c10s4 Conformance testing aims to verify that the SUT conforms to standards, rules, specifi- cations, requirements, design, processes, or practices. 5-8 SWEBOK  GUIDE V4.0 2.2.2 Compliance Testing 1, c12s3 Compliance testing aims to demonstrate the SUTs adherence to a law or regulation.

--- Chunk 245 ---
Tokens: 359
Type: sentence-based
Text:
5-8 SWEBOK  GUIDE V4.0 2.2.2 Compliance Testing 1, c12s3 Compliance testing aims to demonstrate the SUTs adherence to a law or regulation. Usually, compliance testing is forced by an external regulatory body. 2.2.3. Installation Testing 1, c12s2 Often, after system and acceptance testing is completed, and the SUT has been installed in the target environment, the SUT is verified. Installation testing can be viewed as system testing conducted in the operational environ- ment of hardware configurations and other operational constraints. Installation proce- dures may also be verified. 2.2.4. Alpha and Beta Testing 1, c13s7, c16s6, 2, c8s4 Before the SUT is released, it is sometimes given to a small, selected group of potential users for trial use (alpha testing) andor to a larger set of representative users (beta testing). These users report problems with the product. Alpha testing and beta testing are often uncontrolled and are not always referred to in a test plan. 2.2.5. Regression Testing 1, c8s11, c13s3; 4, part 1, c5 According to the definition reported in 5, regression testing is the selective retesting of a SUT to verify that modifications have not caused unintended effects and that the SUT still complies with its specified requirements. In practice, the approach is designed to show that the SUT still passes previously passed tests in a test suite (in fact, it is sometimes referred to as non-regression testing).

--- Chunk 246 ---
Tokens: 372
Type: sentence-based
Text:
In practice, the approach is designed to show that the SUT still passes previously passed tests in a test suite (in fact, it is sometimes referred to as non-regression testing). In some cases, a trade-off must be made between the assur- ance given by regression testing every time a change is made and the resources required to perform the regression tests. This can be quite time-consuming because of the many tests that might be executed. Regression testing can be conducted at each test level described in Section 2.1. It may involve functional and non-functional testing, such as reliability, accessibility, usability, maintainability, con- version, migration, and compatibility testing. Regression testing may involve selection (see Section 1.2.2) and minimization (see Section 1.2.3) of test cases, as well as the adoption of prioritization approaches (see Section 2.2.6) to existing test suites. Regression testing is a fundamental activity of Agile, DevOps, test-driven development (TDD), and Continuous Development. It is usually performed after integration testing and before deployment to production or operation. 2.2.6. Prioritization Testing 1, c12s7 Test case prioritization aims to schedule test cases to increase the rate and likelihood of fault detection, the coverage of code under test, and the SUTs reliability. Typically, pri- oritization testing relies on heuristics, and its performance might vary according to the SUT, the environment, and the available test cases.

--- Chunk 247 ---
Tokens: 368
Type: sentence-based
Text:
Typically, pri- oritization testing relies on heuristics, and its performance might vary according to the SUT, the environment, and the available test cases. Among the different prioritization proposals, similarity-based prioritization is one of the most commonly adopted. In this approach to prioritization, test cases are pri- oritized starting from those most dissimilar according to a predefined distance function. 2.2.7. Non-functional Testing 2, c8 Non-Functional testing targets the validation of non-functional aspects (such as perfor- mance, usability, or reliability), and it is per- formed at all test levels. At the state of the practice, there are hundreds of non-functional testing techniques that include but are not limited to the following:  Performance Testing 4, part 1: Performance testing verifies that the software meets the specified performance requirements and assesses performance SOFTWARE TESTING 5-9 characteristics (e.g, capacity and response time). Load Testing 4, part 1: Load testing focuses on validating the SUTs behavior under load pressure conditions to dis- cover problems (e.g, deadlocks, racing, buffer overflows and memory leaks) or reliability, stability, or robustness viola- tions. It aims to assess the rate at which different service requests are submitted to the SUT. Stress Testing 1, c8s8: Stress testing aims to push the SUT beyond its capa- bilities by generating a load greater than what the system is expected to handle.

--- Chunk 248 ---
Tokens: 396
Type: sentence-based
Text:
Stress Testing 1, c8s8: Stress testing aims to push the SUT beyond its capa- bilities by generating a load greater than what the system is expected to handle. Volume Testing 4, part 1: Volume testing targets the assessment of the SUTs internal storage limitations and its ability to exchange data and information. Failover Testing 1, c17s2; 2, c8: Failover testing validates the SUTs ability to manage heavy loads or unex- pected failure to continue typical opera- tions (e.g, by allocating extra resources). Failover testing is also connected with recoverability validation. Reliability Testing 1, c15; 2, c11: Reliability testing evaluates the SUTs reliability by identifying and correcting faults. Reliability testing observes the SUT in operation or exercises the SUT by using test cases according to statis- tical models (operational profiles) of the different users behaviors. Usually, reli- ability is assessed through reliability growth models. The continuous devel- opment processes (such as DevOps) are currently facilitating the adoption of reli- ability testing in the various iterations for improving final SUT quality. Compatibility Testing 4, part 1; 10, c3: Compatibility testing is used to verify whether the software can collaborate with different hardware and software facilities or with different versions or releases. Scalability Testing 1, c8s7; 2 c17: Scalability testing assesses the soft- wares ability to scale up non-functional requirements such as load, number of transactions, volume of data. It could integrate or extend load, elasticity and stress testing.

--- Chunk 249 ---
Tokens: 399
Type: sentence-based
Text:
It could integrate or extend load, elasticity and stress testing. Elasticity Testing 17: Elasticity testing assesses the ability of the SUT (such as cloud and distributed systems) to rap- idly expand or shrink compute, memory, and storage resources without compro- mising the capacity to meet peak utili- zation. Some elasticity testing objectives are to control behaviors, to identify the resources to be (un)allocated, and to coor- dinate events in parallel. Infrastructure Testing 8, annex H: Infrastructure testing tests and validates infrastructure components to reduce the chances of downtime and improve the performance of the IT infrastructure. Back-to-Back Testing 5: ISOIEC IEEE 24765 defines back-to-back testing as testing in which two or more vari- ants of a program are executed with the same inputs, the outputs are com- pared, and errors are analyzed in case of discrepancies. Recovery Testing 1, c14s2: Recovery testing is aimed at verifying software restart capabilities after a system crash or other disaster. 2.2.8. Security Testing 2, c13; 4, part 4, annex A Security testing focuses on validating that the SUT is protected from external attacks. More precisely, it verifies the confidenti- ality, integrity, and availability of the sys- tems and their data. Usually, security testing includes validation against misuse and abuse of the software or system (negative testing). (See Security Testing in the Software Security KA.) 2.2.9. Privacy Testing 2, c13, c14 Privacy testing is devoted to assessing the security and privacy of users personal data to prevent local attacks.

--- Chunk 250 ---
Tokens: 394
Type: sentence-based
Text:
Privacy Testing 2, c13, c14 Privacy testing is devoted to assessing the security and privacy of users personal data to prevent local attacks. It specifically 5-10 SWEBOK  GUIDE V4.0 assesses privacy and information-sharing policies, as well as the validation of decen- tralized management of users social profiles and data storage solutions. (See Legal Issue in the Software Engineering Professional Practice KA.) 2.2.10. Interface and Application Program Interface (API) Testing 2, c8s1; 14, c7s12; 4, part 5, c4, c7 Interface defects are common in complex sys- tems. Interface testing aims to verify whether the components interface provide the correct exchange of data and control information. Usually, the test cases are generated from the interface specification. A specific interface testing objective is to simulate the use of APIs by end-user applications. That involves gen- erating parameters of the API calls, setting conditions of the external environment, and defining internal data that affect the API. 2.2.11. Configuration Testing 1, c8s5 Where the SUT is built to serve different users, configuration testing verifies the software under specified configurations. 2.2.12. Usability and Human-Computer Interaction Testing 2 c8s4; 19, c6; 4, part 4, annex A The main task of usability and human-com- puter interaction testing is to evaluate how easy it is for end-users to learn to use the software. It might involve testing the soft- ware functions that support user tasks, the documentation that aids users, and the sys- tems ability to recover from user errors.

--- Chunk 251 ---
Tokens: 323
Type: sentence-based
Text:
It might involve testing the soft- ware functions that support user tasks, the documentation that aids users, and the sys- tems ability to recover from user errors. (See User-Centered Design in the Software Design KA.) 3. Test Techniques 1, c1s15; 4, part 4 Over the years, different testing techniques have been developed to increase the SUTs overall quality 4, part 4. These techniques attempt to propose systematic procedures and approaches for generating or selecting the most suitable test suites for detecting as many failures as possible. Testing techniques can be classified by considering different key aspects such as specification, structure, and experience 4, part 4. Additional classification sources can be the faults to be discovered, the predicted use, the models, the nature of the applica- tion, or the derived knowledge. For instance, model-based testing 7; 4, part 1 refers to all the testing techniques that use the concept of a model representing behavioral specifi- cation, the SUTs structure, or the available knowledge and experience. However, classi- fication overlapping is possible, and one cate- gory might deal with combining two or more techniques. Alternative classifications that rely on the degree of information about the SUT are available in the literature.

--- Chunk 252 ---
Tokens: 319
Type: sentence-based
Text:
Alternative classifications that rely on the degree of information about the SUT are available in the literature. Indeed, in the specification-based techniques, also known as black-box techniques, the gen- eration of test cases is based only on the SUTs inputoutput behavior, whereas in the structure-based, also called white-box (or glass-box or clear-box), techniques, the test cases are generated using the infor- mation about how the SUT has been designed or coded. As some testing techniques are used more than others, the remainder of the sec- tion presents the standard testing techniques and those commonly adopted at the state of the practice. 3.1. Specification-Based Techniques 1, c6s2; 4, part 4 The underlying idea of specification-based tech- niques (sometimes also called domain testing techniques) is to select a few test cases from the input domain that can detect specific cat- egories of faults (also called domain errors). These techniques check whether the SUT can manage inputs within a certain range and return the required output. SOFTWARE TESTING 5-11 3.1.1. Equivalence Partitioning 1, c9s4 Equivalence partitioning involves partitioning the input domain into a collection of subsets (or equivalence classes) based on a specified criterion or relation.

--- Chunk 253 ---
Tokens: 375
Type: sentence-based
Text:
Equivalence Partitioning 1, c9s4 Equivalence partitioning involves partitioning the input domain into a collection of subsets (or equivalence classes) based on a specified criterion or relation. This criterion or rela- tion may be different computational results, a relation based on control flow or data flow, or a distinction made between valid inputs that are accepted and processed by the SUT and invalid inputs, such as out-of-range values, that are not accepted and should generate an error message or initiate error processing. A representative test suite (sometimes con- taining only one test case) is usually taken from each equivalence class. 3.1.2. Bounday Value Analysis 1, c9s5; 4, part 4 Test cases are chosen on or near the bound- aries of the input domain of variables, with the underlying rationale that many faults tend to concentrate near the extreme values of inputs. An extension of this technique is robustness testing, wherein test cases are also chosen out- side the input domain of variables to test pro- gram robustness in processing unexpected or erroneous inputs. 3.1.3. Syntax Testing 1, c10s11, 2, c5; 4, part 4 The Syntax Testing techniques, also known as formal specification-based techniques, rely on the SUT specifications in a formal language. (See Formal Methods in the Software Engineering Models and Methods KA.) This representation permits automatic derivation of functional test cases and, at the same time, provides an oracle for checking test results. 3.1.4.

--- Chunk 254 ---
Tokens: 374
Type: sentence-based
Text:
3.1.4. Combinatorial Test Techniques 1, c9s3; 4, part 4 The Combinatorial Test Techniques system- atically derive the test cases that cover specific parameters of values or conditions. According to 4, part 4, the commonly used combina- torial test techniques are All combinations Testing, Pair-Wise Testing, Each Choice Testing, and Base Choice Testing. All combi- nations testing focuses on all the possible input combinations, whereas its subset, also called t-wise testing, considers every possible combi- nation of t input. In this case, more than one pair is derived (i.e, by including higher-level combinations). Pair-wise testing is a specific combinatorial testing technique where test cases are derived by combining values of every pair of an input set. These techniques are also known as orthogonal array testing (OAT). 3.1.5. Decision Table 1, c9s6; 1, c13s6; 4, part 4 Decision tables (or trees) represent logical rela- tionships between conditions (roughly, inputs) and actions (roughly, outputs). Usually, they are widely adopted for knowledge representa- tion (e.g, machine learning (ML)). Test cases are systematically derived by considering every possible combination of conditions and their corresponding resultant actions. A related technique is cause-effect graphing. Currently, shift-left development processes are taking advantage of this kind of testing technique because these techniques are useful for documenting the test results and factors that can affect them. 3.1.6.

--- Chunk 255 ---
Tokens: 333
Type: sentence-based
Text:
3.1.6. Cause-Effect Graphing 1, c1s6; 4, part 3, part 4 Cause-effect graphing techniques rely on log- ical networks that map a set of causes to a set of effects by systematically exploring the possible combinations of input conditions. They identify the effects and link the effects to their causes through model graphs. Cause- effect graphing techniques are used in testing because they allow specification analysis, the identification of the relevant input conditions or causes, the consequent transformations, and the output conditions. 5-12 SWEBOK  GUIDE V4.0 3.1.7. State Transition Testing 1, c10; 4, part 4 Techniques based on Finite-State Machines (State Transition Testing techniques in 4, part 4) focus on representing the SUT with a finite-state machine. In this case, the test suite is derived to cover the states and tran- sitions according to a specific coverage level. 3.1.8. Scenario-Based Testing 2, c8s3, c19s3; 4, part 4; 7 A model in this context is an abstract (formal) representation of the SUT or its software requirements. (See Modeling in the Software Engineering Models and Methods KA.) Scenario-based testing is used to validate require- ments, check their consistency, and generate test cases focused on the SUTs behavioral aspects. (See Types of Models in the Software Engineering Models and Methods KA.)

--- Chunk 256 ---
Tokens: 382
Type: sentence-based
Text:
(See Types of Models in the Software Engineering Models and Methods KA.) The key components of scenario-based testing are the notation used to represent the model of the software or its requirements, workflow models or similar models, the test strategy or algorithm used for test case generation, the supporting infrastructure for the test execution, and the evaluation of test results compared to expected results. Because of the complexity of the tech- niques, scenario-based testing approaches are often used with test automation harnesses. Among scenario-based testing, workflow models can also be used to graphically represent the sequence of activities performed by humans andor software applications. In this case, each sequence of actions constitutes one workflow (also called a scenario). Usually, it is important to ensure that both typical and alternate work- flows are also tested. For example, business process testing is part of this scenario-based technique. In this case, the special focus is on the roles in a workflow specification. 3.1.9. Random Testing 1, c9s7; 4, part 4 In this approach, test cases are generated purely at random. This testing falls under the heading of input domain testing because the input domain must be known to be able to pick random points within it. Random testing provides a relatively simple approach to test automation. Enhanced forms of random testing (such as adaptive random testing) have been proposed in which other input selection criteria direct the random input sampling.

--- Chunk 257 ---
Tokens: 399
Type: sentence-based
Text:
Enhanced forms of random testing (such as adaptive random testing) have been proposed in which other input selection criteria direct the random input sampling. Currently, under the name of fuzz testing, the random selection of invalid and unex- pected inputs and data is extensively used in cybersecurity to find hackable software bugs, coding errors, and security loopholes. (See also Sections 2.2.8 and 8.2.) 3.1.10. Evidence-Based 10, c6s2 Evidence-based software engineering (EBSE), which follows a rigorous research approach, is the best solution for a practical problem. EBSE includes the following phases:  Identifying the evidence and forming a question  Tracking down the best evidence to answer the question  Critically analyzing the evidence in light of the problem that the evidence should help solve. EBSE principles can also be applied to the testing process. For that purpose, the widely used approaches that allow iden- tifying and aggregating evidence are systematic mapping studies and system- atic reviews. 3.1.11. Forcing Exception 5 Test cases are specifically conceived for checking whether the SUT can manage a predefined set of exceptionserrors, such as data exception, operation exception, overflow exception, protection exception or underflow exception. Testing techniques usually focus on negative test scenarios (i.e, test cases that are able to force the generation of error messages). SOFTWARE TESTING 5-13 3.2. Structure-Based Test Techniques 4, part 4 Structure-Based Test Techniques (sometimes called code-based test techniques) focus on the code and its structure.

--- Chunk 258 ---
Tokens: 389
Type: sentence-based
Text:
Structure-Based Test Techniques 4, part 4 Structure-Based Test Techniques (sometimes called code-based test techniques) focus on the code and its structure. Structure-Based Test Techniques can be performed at dif- ferent levels (such as code development, code inspection, or unit testing) and can include static testing (such as code inspection, code walkthrough, and code review), dynamic testing (like statement coverage, branch cov- erage, and path coverage), or code complexity measurement (e.g, using techniques like cyc- lomatic complexity 12). 3.2.1. Control Flow Testing 1, c4; 4, part 4 Control flow testing covers all the statements, branches, decisions, branch conditions, mod- ified condition decision coverage (MCDC), blocks of statements, or specific combinations of statements in a SUT. The strongest of the control flow-based criteria is path testing, which aims to execute all entry-to-exit con- trol flow paths in a SUTs control flow graph. Because exhaustive path testing is generally not feasible because of loops, other less strin- gent criteria focus on coverage of paths that limit loop iterations, such as statement cov- erage, branch coverage, and conditiondecision testing. The adequacy of such tests is measured in percentages; for example, when all branches have been executed at least once by the tests, 100 branch coverage has been achieved. 3.2.2. Data Flow Testing 1, c5; 4, part 4 In data flow testing, the control flow graph is annotated with information about how the variables are defined, used, and killed (unde- fined).

--- Chunk 259 ---
Tokens: 399
Type: sentence-based
Text:
Data Flow Testing 1, c5; 4, part 4 In data flow testing, the control flow graph is annotated with information about how the variables are defined, used, and killed (unde- fined). Commonly adopted data flow testing techniques are All-Definitions Testing, All- C-Uses Testing, All-P-Uses Testing, All- Uses Testing and All-DU-Paths Testing. The strongest data flow testing criterion is the All- DU-Paths Testing, where all definition and use (DU) paths need to be covered 4, part 4. This is because it requires executing, for each variable, every control flow path segment from a definition of that variable to the use of that definition. However, weaker strategies such as all-definitions and all-uses are used to reduce the number of paths required. 3.2.3. Reference Models for Structure-Based Test Techniques 1, c4 Although not a technique, a SUTs control structure can be graphically represented using a flow graph to visualize structure-based test techniques. A flow graph is a directed graph, the nodes and arcs of which correspond to program elements. (See Graphs and Trees in the Mathematical Foundations KA.) For instance, nodes may represent statements or uninterrupted sequences of statements, and arcs may represent the transfer of control between nodes. 3.3. Experience-Based Techniques 4, part 1, part 4 The generation of the most suitable test suite may depend on different factors, such as human knowledge of the SUT and its context and the testers experience and intuition. In the fol- lowing section, the commonly adopted experi- ence-based techniques are briefly introduced. 3.3.1.

--- Chunk 260 ---
Tokens: 387
Type: sentence-based
Text:
3.3.1. Error Guessing 1, c9s8; 4, part 4 In error guessing, software engineers design test cases specifically to anticipate the most plausible faults in each SUT. Good sources of information are the history of faults discov- ered in earlier projects and the software engi- neers expertise. 3.3.2. Exploratory Testing 4, part 1 Exploratory testing is defined as simultaneous learning, test design and test execution. The 5-14 SWEBOK  GUIDE V4.0 test cases are not defined in advance but are dynamically designed, executed, and modi- fied according to the collected evidence and test results, such as observed product behavior, peculiarities of the SUT, the domain and the environment, the failure process, the types of possible faults and failures, and the risk asso- ciated with a particular product. Usually, the intuition, knowledge, and expertise of the personnel in charge of performing the explor- atory testing can affect the testing effective- ness. Exploratory testing is widely used in shift-left development (such as Agile). (See Section 5.4.2.) 3.3.3. Further Experience-Based Techniques 4, part 4; 13 At the state of the practice, experience-based techniques may include further approaches such as Ad Hoc-based, knowledge-based and ML-based testing techniques. Ad Hoc testing is a widely used technique in which test cases are derived by relying on the software engineers skill, intuition, and expe- rience with similar programs. It can be useful for identifying test cases that are not easily gen- erated by more formalized techniques.

--- Chunk 261 ---
Tokens: 346
Type: sentence-based
Text:
It can be useful for identifying test cases that are not easily gen- erated by more formalized techniques. Typical Ad Hoc methodologies are the following:  Monkey testing runs randomly generated test cases to simulate rundom activities and cause the program to stop. Pair (Buddy) testing involves two indi- viduals. One generates and runs the test cases; the other observes and analyzes the testing process. Pair testing allows for generating test cases with broader and better test coverage. Gamification aims to convert testing tasks to components of gameplay. By applying specific techniques (such as engaging practitioners or crowdsourcing complex testing tasks), gamification can substantially improve software testing practice and, consequently, SUT quality. Quick testing, in which a very small test suite is selected and executed to swiftly identify critical issues in the SUT. It aims to enhances the probability of detecting faults early in the development process. Smoke testing (also known as Build Verification Testing) ensures that the SUTs core functionalities behave prop- erly. It also guarantees that the SUT is operational before the planned testing begins. In addition, smoke testing pre- vents failures because of the test envi- ronment (e.g, because artifacts or packages are not properly built). Smoke testing is also considered a special case of quick testing.

--- Chunk 262 ---
Tokens: 375
Type: sentence-based
Text:
Smoke testing is also considered a special case of quick testing. Knowledge-based testing and ML-based testing exploit (formal or informal) knowl- edge about the SUT or derive it from obser- vations of SUT executions for defining its behavioral models (such as ontologies or decision tables) (see Section 3.6.1), rules, and non-functional properties. In addition, Knowledge-based testing and ML-based testing specify the testing needs and iden- tify test objectives for which test cases are generated. 3.4. Fault-Based and Mutation Techniques 1, c1s14, 1 c3s5; 5 With different degrees of formalization, fault- based testing techniques devise test cases spe- cifically to reveal likely or predefined fault categories. A fault model can be introduced that classifies the different faults to better focus the test case generation or selection. In this context, a variety of platforms and devel- opment processes (e.g, waterfall, spiral and Agile) consider the orthogonal defect clas- sification (ODC) a valid methodology for collecting semantic information about the different defects and reducing the time and effort of the root cause analysis. Mutation Testing was originally conceived as a technique to evaluate test suites (see Section 4.2, Evaluation of the Tests Performed) in which a mutant is a slightly modified ver- sion of the SUT (also called gold), differing from it by a small syntactic change. Every test case exercises both the gold version and SOFTWARE TESTING 5-15 all generated mutants.

--- Chunk 263 ---
Tokens: 396
Type: sentence-based
Text:
Every test case exercises both the gold version and SOFTWARE TESTING 5-15 all generated mutants. If a test case succeeds in identifying the difference between the gold version and a mutant, the latter is said to be killed. The underlying assumption of mutation testing, the coupling effect, is that more complex but real faults will be found by looking for simple syntactic faults. For the technique to be effective, many mutants must be automatically generated and executed systematically 6. Mutation testing is also a testing criterion in itself. Test cases are ran- domly generated until enough mutants have been killed, or tests are specifically designed to kill surviving mutants. In the latter case, mutation testing can also be categorized as a structure-based technique. Mutation testing has been used effectively for generating fuzz testing. A more recent application of the mutation process is metamorphic testing, a technique that has become increasingly pop- ular in addressing some ML systems testing challenges. In this case, the modifications (called also morph) are applied to the inputs so a relationship can connect the previous input (and its output) to the new morphed input (and its output). 3.5. Usage-Based Techniques 1, c15s5 Usage-based techniques usually rely on a usage model or profiles. In this case, the testing environment needs to represent the actual operational environment, and the sequence of test case execution should reproduce the SUT usage by the target stakeholder. Statistical sampling is used for simulating the execu- tion of many test cases.

--- Chunk 264 ---
Tokens: 374
Type: sentence-based
Text:
Statistical sampling is used for simulating the execu- tion of many test cases. Thus, sometimes, the term random testing is also associated with these techniques. Usage-based statistical testing is applied more during the acceptance testing stage. 3.5.1. Operational Profile 1, c15s5, 2, c11 Testing based on operational profiles aims at generating test cases that might estimate the reliability of the SUT or part of it. Therefore, the goal is to infer from the observed test results the future reliability of the software (when it is in use). Because the established reliability strictly depends on the operating profile, the main difficulty (and cost) in using this testing approach comes from the opera- tional profile derivation. Therefore, one pos- sible solution is to assign to the input the probabilities or profiles according to their fre- quency of occurrence in actual operation. 3.5.2. User Observation Heuristics 19, c5, c7; 4, part 4, annex A Specialized heuristics, also called usability inspection methods, are applied to systemat- ically observe system use under controlled conditions to determine how well people can use the system and its interfaces. Usability heuristics include cognitive walkthroughs, claims analysis, field observations, thinking aloud, and even indirect approaches such as user questionnaires and interviews. 3.6. Techniques Based on the Nature of the Application 2 c16, c17, c18, c20, c21; 14, c4s8; 8 The above techniques apply to all kinds of software.

--- Chunk 265 ---
Tokens: 370
Type: sentence-based
Text:
Techniques Based on the Nature of the Application 2 c16, c17, c18, c20, c21; 14, c4s8; 8 The above techniques apply to all kinds of software. Additional test derivation and exe- cution techniques are based on the nature of the software being tested. Examples are the following:  Object-oriented software  Component-based software  Web-based software  Concurrent programs  Protocol-based software  Communication systems  Real-time systems  Safety-critical systems  Service-oriented software  Open-source software  Embedded software  Cloud-based software  Blockchain-based software  Big data-based software  AIMLDL-based software 5-16 SWEBOK  GUIDE V4.0  Mobile apps  Security and privacy-preserving software In some cases, standards such as ISO IECIEEE 29119 4, part 4, part 5 pro- vide examples and support for specifying test cases, automating their execution, and main- taining the test suites, such as the case of the Keyword-Driven Testing 4, part 5. 3.7. Selecting and Combining Techniques 14, c7s12; 10; 4, part 5 Combining different testing techniques has always been a well-grounded means to assure the required level of SUT quality. Currently, especially in shift-left developments, method- ologies for adaptive combinations of testing techniques are part of the state of the prac- tice. The goal is to improve the effectiveness of testing processes by learning from experience and, at the same time, adapting the technique selection to the current testing session. 3.7.1.

--- Chunk 266 ---
Tokens: 395
Type: sentence-based
Text:
3.7.1. Combining Functional and Structural 1, c9; 4, part 5 Scenario-based and structure-based test techniques are often contrasted as functional vs. structural testing. These two approaches to test case selection are nowadays seen as complements, as they use different sources of information and have been shown to high- light different problems. Depending on the different organizational constraints, such as budgetary considerations, they could be combined. 3.7.2. Deterministic vs. Random 1, c9s6 Test cases can be selected in a determin- istic way, according to many techniques, or randomly drawn from some distribution of inputs, such as is usually done in reliability testing. Several analytical and empirical com- parisons have been conducted to analyze the conditions that make one approach more effective than the other. 3.8. Techniques Based on Derived Knowledge 2, c19, c20; 14, c7 Testing techniques can integrate evidence and knowledge from different research areas and contexts. For this, approaches and methodol- ogies are used to support testing activity and improve its effectiveness. Currently, innova- tive approaches include using digital twins or simulation methodologies and frameworks, exploiting ML and gamification facilities, and using (simulated) neuronal networks. 4. Test-Related Measures 2, c24s5; 14, c10; 4, part 4 Testing techniques are like tools that help in achieving specific test objectives. To evaluate whether a test objective is reached, well-de- fined measures are needed. Measurement is usually considered fundamental to quality analysis.

--- Chunk 267 ---
Tokens: 350
Type: sentence-based
Text:
Measurement is usually considered fundamental to quality analysis. Measurement may also be used to optimize test planning and execution. Test management can use several different process measures to monitor progress. (See Software Engineering Measurement in the Software Engineering Management KA for informa- tion on measurement programs. See Software Measurement in the Software Engineering Process KA for information on measures.) According to the definition in 4, part 4, testing techniques can be classified according to the degree of coverage they can achieve. Coverage may vary from 0 to 100, excluding possible infeasible tests (i.e, tests that cannot be executed). Thus, for each spec- ification-based, structure-based, and expe- rience-based test technique, the associated coverage measures and the procedure for evaluating that coverage must be determined. Examples of coverage measures could be the percentage of branches covered in the pro- gram flow graph or the percentage of func- tional requirements exercised among those listed in the specifications document. It is important to consider that moni- toring facilities can dynamically compute the ratio between covered elements, and the total number may also be considered. Additionally, SOFTWARE TESTING 5-17 especially in the case of structure-based testing techniques, appropriate instrumenta- tion of the SUT may also be necessary.

--- Chunk 268 ---
Tokens: 322
Type: sentence-based
Text:
Additionally, SOFTWARE TESTING 5-17 especially in the case of structure-based testing techniques, appropriate instrumenta- tion of the SUT may also be necessary. However, the proposed set of testing mea- sures can also be classified from different viewpoints  from the point of view of those providing and allowing an evaluation of the SUT based on the observed test outputs and of those that evaluate the thoroughness or effectiveness of the executed test suites. 4.1. Evaluation of the SUT 2, c24s5 Usually, indicators (i.e, measurable infor- mation) can be used to determine whether a SUT is performing as expected and achieving its expected outcomes. The indicators, some- times known as key performance indica- tors (KPIs), are strongly connected with the adopted evaluation measures, methods, data analysis and reporting. 4.1.1. SUT Measurements That Aid in Planning and Designing Tests 14, c10; 10, c6; 4, part 1, part 4 All the testing measures proposed in 4, part 4 can be used for planning and guiding testing activities. Additionally, in the shift- left development process, specific measures, such as deployment frequency, lead time, mean time to recovery (MTTR), and change failure rate, are also commonly adopted to plan and manage the testing activities and results. 4.1.2.

--- Chunk 269 ---
Tokens: 393
Type: sentence-based
Text:
4.1.2. Fault Types, Classification and Statistics 1 c13s4, c13s5, c13s6 The testing literature is rich in classifica- tions and taxonomies of faults that can be generic or specific to a context or quality attributes (such as the usability defect clas- sification, the taxonomy of HWSW security and privacy vulnerabilities and attacks, and the classification of cybersecurity risks). To make testing more effective, it is important to know which types of faults may be found in the SUT and the relative frequency with which these faults have occurred in the past. This information can be useful in making quality predictions and in process improve- ment (See Characterization in the Software Quality KA). 4.1.3. Fault Density 1, c13s4; 14, c10s1 Traditionally, a SUT can be evaluated by counting discovered faults as the ratio between the number of faults found and the SUT size. Because of the semantics-based definition of faults, additional measurements can be considered, such as fault depth (the minimal number of fault removals needed to make a SUT correct) and fault multiplicity (the number of atomic changes needed to repair a single fault). 4.1.4. Life Test, Reliability Evaluation 1, c15, 2, c11; 14, c1s3 A statistical estimate of software reliability, which can be obtained by observing reli- ability achieved, can be used to evaluate a SUT and decide whether testing can be stopped or the SUT is mature enough to be a candidate for the next shift-left develop- ment release. Reliability evaluation is taking a pivotal role in the Cloud (and fog) con- texts 18.

--- Chunk 270 ---
Tokens: 386
Type: sentence-based
Text:
Reliability evaluation is taking a pivotal role in the Cloud (and fog) con- texts 18. On the one hand, validation and veri- fication proposals are focusing on main- taining the high level of reliability and availability required by the cloud (fog) ser- vices. On the other, testing activities are exploiting the computational power of the cloud (fog) environment to speed up the reliability evaluation and drastically reduce its costs. 4.1.5. Reliability Growth Models 1, c15, 2 c11s5 Reliability growth models predict reli- ability based on observed failures. They assume, in general, that when the faults 5-18 SWEBOK  GUIDE V4.0 that caused the observed failures have been fixed (although some models also accept imperfect fixes), the products reliability will increase. There are many published reliability growth models. Notably, these models are divided into failure-count and time-between-failure models. 4.2. Evaluation of the Tests Performed 4, part 4, c6 The behavior of SUT is generally verified by executing test suites, which are pivotal in finding defects. Therefore, from both the researchers and practitioners perspectives, a fundamental part of software testing is com- paring test suites. Usually, evaluating the test suites means comparing techniques for test case generation that produce the test cases. Different criteria are used for that purpose, such as coverage criteria or mutation anal- ysis criteria. 4.2.1. Fault Injection 1, c2s5 In fault injection, some faults are artificially introduced into the SUT before testing.

--- Chunk 271 ---
Tokens: 365
Type: sentence-based
Text:
Fault Injection 1, c2s5 In fault injection, some faults are artificially introduced into the SUT before testing. When a test suite is executed, some of these injected faults are revealed, as are, possibly, some faults that were already there. In theory, depending on which and how many artificial faults are discovered, the testing effectiveness can be evaluated, and the remaining number of genuine faults can be estimated. In prac- tice, statisticians question the distribution and representativeness of injected faults rel- ative to genuine faults and the small sample size on which any extrapolations are based. Some also argue that this technique should be used with great care because inserting faults into the SUT incurs the obvious risk of leaving them there. 4.2.2. Mutation Score 1, c3s5; 6 In mutation testing, the test suite effective- ness measure is calculated as the ratio of killed mutants to the number of generated mutants. The higher the test suite effectiveness value, the better, since it indicates a stronger ability to discover the most real injected faults. 4.2.3. Comparison and Relative Effectiveness of Different Techniques 1, c1s7; 5; 9 Relative effectiveness compares different testing techniques against a specific property, such as the number of tests needed to find the first failure, the ratio of the number of faults found through testing to all the faults found during and after testing, and how much reli- ability was improved.

--- Chunk 272 ---
Tokens: 396
Type: sentence-based
Text:
Comparison and Relative Effectiveness of Different Techniques 1, c1s7; 5; 9 Relative effectiveness compares different testing techniques against a specific property, such as the number of tests needed to find the first failure, the ratio of the number of faults found through testing to all the faults found during and after testing, and how much reli- ability was improved. Several studies have already been conducted to compare dif- ferent techniques analytically and empirically according to each notion of property (or effec- tiveness) defined. 5. Test Process 4, part 1, part 2, part 3; 2 c8 Testing concepts, strategies, techniques and measures need to be integrated into a defined and controlled test planning process to test output evaluation. The test process supports testing and provides guidelines to those respon- sible for different testing activities to ensure the test objectives are met cost-effectively. As described in 4, part 2, the test pro- cess is a multi-layered process activity that includes the test specification at the organi- zational, management and dynamic levels. The organizational test process defines the steps for creating and maintaining test speci- fications, such as organizational test policies, strategies, processes, procedures, and other assets 4, part 2. The test management process defines the steps necessary for management: planning, monitoring and control, and completion. Finally, the dynamic test process speci- fies the steps for design and implementation, environment setup and maintenance, execu- tion, and test incident reporting.

--- Chunk 273 ---
Tokens: 389
Type: sentence-based
Text:
Finally, the dynamic test process speci- fies the steps for design and implementation, environment setup and maintenance, execu- tion, and test incident reporting. In the remainder of this section, some practical considerations about the test process SOFTWARE TESTING 5-19 specification, management, and execution, as well as a summary of the test sub-processes and activities included in the organizational, management and dynamic levels as in 4, part 2, are provided. 5.1. Practical Considerations 4, part 1 Testing processes should allow the automation of different testing phases and should rely on the controllability, traceability, replicability, and riskcost estimation of the performed activities. In the remainder of this section, commonly applied test steps are described, compatible with and applicable to all life cycle models. (See Software Life Cycles in the Software Engineering Process KA.) 5.1.1. AttitudesEgoless Programming 1, c16; 2, c3 An important element of successful testing is a collaborative attitude toward testing and quality assurance (QA) activities. Managers have a key role in fostering a favorable recep- tion toward failure discovery and correction during software development and mainte- nance. For instance, in shift-left change in development, such as Agile, communication and collaboration among testers and devel- opers are considered vital for achieving suc- cessful testing results. 5.1.2. Test Guides and Organizational Process 1, c12s1, 2 c8; 4, part 2, part 3; 14, c7s3 Various aims can guide the testing phases.

--- Chunk 274 ---
Tokens: 389
Type: sentence-based
Text:
Test Guides and Organizational Process 1, c12s1, 2 c8; 4, part 2, part 3; 14, c7s3 Various aims can guide the testing phases. For example, risk-based testing uses the product risks to prioritize and focus the test strategy, and scenario-based testing defines test cases based on specified software scenarios and backlog lists. Usually, the organization of the test process includes defining test policies (i.e, specifying the purpose, goals, and overall scope of testing) and test strategies (i.e, spec- ifying the guidelines about how testing will be carried out). For instance, in shift-left developments, a test strategy should include at least the following data: the purposes (e.g, defined through user stories), the objectives (e.g, a test suite), the scope (the SUT), and the environment and methods (e.g, how, and where the test suite is run). 5.1.3. Test Management and Dynamic Test Processes 1, c12; 4, part 2, part 3, 14, c7s3 Test activities conducted at different levels (see Section 2, Test Levels) should be organized  with people, tools, policies, and measures  into a well-defined process integral to the life cycle. Test process management includes different subprocesses such as planning, mon- itoring, control, and completion, whereas the Dynamic test process includes test design and implementation, test environment set-up and maintenance, test execution, and test incident reporting. 5.1.4. Test Documentation 1, c8s12; 14, c7s8; 4, part 3 According to 4, part 3, documentation is integral to the formalization of the test pro- cess.

--- Chunk 275 ---
Tokens: 386
Type: sentence-based
Text:
Test Documentation 1, c8s12; 14, c7s8; 4, part 3 According to 4, part 3, documentation is integral to the formalization of the test pro- cess. Test documents can be classified into three hierarchical categories: organizational test documentation, test management docu- mentation and dynamic test documentation. Organizational test documentation includes the information necessary for documenting the test policy and the organizational test strategies. Test management documentation includes the test plan, test status report and test completion report. Finally, dynamic test documentation includes the following docu- ments: test specification (test design specifica- tion, test case specification and test procedure specification), test data requirements, test environment requirements, test data readiness report, test environment readiness report, and test execution documentation (such as actual results, test results, test execution log and incident report). Test documentation should be produced and continuously updated with the same 5-20 SWEBOK  GUIDE V4.0 quality as other software engineering doc- umentation. Test documentation should also be under the control of software con- figuration management. (See the Software Configuration Management KA.) 5.1.5. Test Team 1, c16; 2 c23s5; 4, part 2, part 3 Formalizing the testing process may also involve formalizing the testing teams orga- nization. Considerations of cost, schedule, maturity levels of the involved organizations and criticality of the application can guide the decision.

--- Chunk 276 ---
Tokens: 398
Type: sentence-based
Text:
Considerations of cost, schedule, maturity levels of the involved organizations and criticality of the application can guide the decision. The testing team can be composed of members involved (or not) in the SUT devel- opment (i.e, having or not having an unbi- ased, independent perspective) or internal (or external) personnel. Nowadays, shift-left development does not strongly distinguish among testing team members because the test suite is defined and updated according to the SUT development and delivered code. 5.1.6. Test Process Measures 1, c18s3, 14, c10; 4, part 1, part 2, part 3 Managers use several measures for the resources spent on testing, as well as for the relative fault-finding effectiveness of the var- ious test phases, to control and improve the testing process, as well as to provide informa- tion for managing process risks. Therefore, monitor and control testing must define required data and information and state how to obtain them. The test measures may cover the number of specified, executed, passed, and failed test cases, among other elements. These measures can also be combined with specific process metrics such as residual risk, cumulative defects open and closed, test case progress, and defect detection percentage. Evaluation of test phase reports can be com- bined with root-cause analysis to evaluate test process effectiveness in finding faults as early as possible. Such an evaluation can be associated with risk analysis. Moreover, the resources deemed worth spending on testing should be commensurate with the applica- tions use and criticality.

--- Chunk 277 ---
Tokens: 394
Type: sentence-based
Text:
Moreover, the resources deemed worth spending on testing should be commensurate with the applica- tions use and criticality. Different techniques have different costs and yield different confi- dence levels in product reliability. 5.1.7. Test Monitoring and Control 4, part 1, part 2 Monitoring and Control comprise an important sub-process of the test management process as in 4, part 2, useful for collecting data and information required during test management and assessment. Usually, monitoring and con- trol activities are executed in parallel with the test execution, and sometimes, data col- lected might prompt revision of overall pro- cess planning. Monitoring assures that testing process activities comply with a specific test plan to trace the requirements satisfaction and mitigate the identified risks satisfactorily. During test monitoring and control, specific documentation (test reports) can regularly be produced to help assess and document the test activity. 5.1.8. Test Completion 14, c7s11; 4, part 3 A decision must be made about how much testing is enough and when a test stage can be completed. Therefore, the purpose of Test Completion, a sub-process of the test manage- ment process as in 4, part 2, is to ensure that test requirements are satisfied and verified, test reports are completed, and test results are communicated to relevant stakeholders. Thoroughness measures, such as achieved code coverage or functional coverage, and estimates of fault density or operational reliability, pro- vide useful support but are not sufficient in themselves.

--- Chunk 278 ---
Tokens: 388
Type: sentence-based
Text:
Thoroughness measures, such as achieved code coverage or functional coverage, and estimates of fault density or operational reliability, pro- vide useful support but are not sufficient in themselves. The decision also involves consid- erations about the costs and risks incurred by possible remaining failures, as opposed to the costs incurred by continuing to test (See Test Selection and Adequacy Criteria in Section 1.2, Key Issues.) As for the other activities, in this stage, specific documentation is produced (e.g, test completion report) and communi- cated to the relevant stakeholders. SOFTWARE TESTING 5-21 5.1.9. Test Reusability 14, c3; 9 It is necessary to add complexity and time for test planning and design to achieve reus- ability of the testing artifacts, such as the test case or execution environment, which is desired when test development is costly, time-consuming, and complex. Test reusability collects and classifies the testing knowledge (test cases and test results) to make this information searchable and usable for creating new tests or re-executing an existing one. Suitable knowledge-based repositories should be configured and man- aged to test reusability so changes to soft- ware requirements or design can be reflected in changes to the tests. Currently, the reusability of test cases is pivotal in feature-based or product-line devel- opment and regression testing. Test reus- ability also relates to maintainability because reusability can reduce the cost and effort involved and improve a tests effectiveness. 5.2.

--- Chunk 279 ---
Tokens: 386
Type: sentence-based
Text:
5.2. Test Sub-Processes and Activities 1, c1s12; 1, c12s9; 4, part 2 In the remainder of this section, the main testing activities and sub-processes are briefly introduced. 5.2.1. Test Planning Process 1, c12s1, c12s8; 11; 4, part 2 Like all other aspects of project manage- ment, testing activities must be planned. According to 4, part 2, key aspects of test planning include identification and coor- dination of personnel, identification of the test objective and completion criteria, definition of test facilities and equipment, creation and maintenance of all test-re- lated documentation, and risk planning and management for possible undesirable out- comes. These activities can be organized at three different levels: (1) process manage- ment (i.e, identification of test policies, strategies, processes, and procedures), (2) organizational management (i.e, definition of the test phase, test type and test objective), and (3) design and implementation (i.e, defi- nition of the test environment, the test execu- tion process and monitoring, the completion process, and reporting). 5.2.2. Test Design and Implementation 1, c12s1, c12s3; 11 Generation of test cases is based on the level of testing to be performed and the chosen testing techniques. According to the dynamic test process, as described in 4, part 2, preconditions of the test case gener- ation are the identification of test objectives and the selection of the appropriate testing demonstration techniques. Test generation focuses on implementing and executing test cases.

--- Chunk 280 ---
Tokens: 395
Type: sentence-based
Text:
Test generation focuses on implementing and executing test cases. It often relates to tooling (i.e, using specific software, also called a test cases gen- erator). This software accepts inputs (such as source code, test criteria, specifications, or data structure definitions) and uses them to generate the test suites. Sometimes, a test case generator can determine expected results by using a specific oracle facility. This contributes to the full test automation of the overall testing process. 5.2.3. Test Environment Set-up and Maintenance 1, c12s6; 2 c8s1; 14 c13s2; 4, part 2; 11 According to the dynamic test process, as described in 4, part 2, test environment development and setup involve identifying the testing infrastructure. This includes selecting or developing the facilities, hardware, soft- ware, firmware, and procedures to conduct the testing activity. The testing environment can be simulated, controlled, and executed in vitro or in vivo. Developing the test envi- ronment also involves setting up monitoring and logging facilities useful for documenting the testing activities and assessing the result obtained. The testing environment should be compatible with the other software engi- neering tools used. 5-22 SWEBOK  GUIDE V4.0 5.2.4. Controlled Experiments and Test Execution 1, c12s7, 14 c4s7, 14 c5s6; 4, part 2 Execution of tests should embody a basic principle of scientific controlled experimenta- tion  everything done during testing should be performed and documented specifically and clearly enough that another person could replicate the results.

--- Chunk 281 ---
Tokens: 385
Type: sentence-based
Text:
Controlled Experiments and Test Execution 1, c12s7, 14 c4s7, 14 c5s6; 4, part 2 Execution of tests should embody a basic principle of scientific controlled experimenta- tion  everything done during testing should be performed and documented specifically and clearly enough that another person could replicate the results. Hence, testing should be performed following documented proce- dures using a clearly defined version of the SUT. Especially during acceptance testing, controlled experiments like AB testing can also be performed to statistically evaluate user preferences between different versions of the SUT. 5.2.5. Test Incident Reporting 1, c13s4, c13s9, c13s11; 2, c8s3; 14, c7s8; 4, part 3; 12 According to the dynamic test process, as described in 4, part 2, testing incidents and reporting focus on the well-defined test data collection process (i.e, identifying when a test was conducted, who performed the test, what software configuration was used, and other relevant identification infor- mation). This process and the collected evi- dence can be leveraged for accountability purposes. Test reporting can involve suitable audit systems to identify unexpected or incor- rect test results and record them in a problem reporting system. These data form the basis for later debugging and fixing the problems observed as failures during testing. Also, anomalies not classified as faults could be documented if they later become more serious than first thought. Test reports are also inputs to the change management request process.

--- Chunk 282 ---
Tokens: 337
Type: sentence-based
Text:
Test reports are also inputs to the change management request process. (See Software Configuration Control in the Software Configuration Management KA.) Hence, the Test Incident Reporting pro- cess focuses on identifying the relevant stakeholders incidents that could be used to determine what aspects of software testing and other processes need improvement and how effective previous approaches have been. Part of the incident reporting is also eval- uating test results to determine whether the testing has been successful. In most cases, successful means that the software per- formed as expected and did not have any major unexpected outcomes. Not all unex- pected outcomes are necessarily faults; some- times they are determined to be simply noise. Before a fault can be removed, an analysis and debugging effort is needed to isolate, identify, and describe it. When test results are particu- larly important, a formal review board may be convened to evaluate them. 5.3. Staffing 1, c16; 4, part 3 According to 4, part 3, staffing includes defining roles, activities, and responsibilities, specifying hiring needs, and defining training needs. Staffing affects project risk because the teams expertise might undermine the ability to discover faults, to address changing require- ments, to meet deadlines, and increasereduce maintenance costs.

--- Chunk 283 ---
Tokens: 371
Type: sentence-based
Text:
Staffing affects project risk because the teams expertise might undermine the ability to discover faults, to address changing require- ments, to meet deadlines, and increasereduce maintenance costs. The roles, activities and responsibilities definition establishes the following roles and responsibilities: the activity leader and sup- porting personnel, the test-related roles and their corresponding responsibilities, and the person responsible for providing the test item(s). Depending on the development lifecycle adopted, typical testing roles include but are not limited to scrum mastertest lead, QA test analyst, test designer, test securityperfor- mance engineer and consultant, test environ- ment expert, test executor and test automation consultant or architect. Hiring needs require the identification of specific requirements for which additional testing personnel are needed to complete the testing process (as well as when that personnel is needed and the desired skills). Depending on the business needs, staffing could take different forms, from internal transfers to external hires or even consultants andor out- sourced resources. Finally, the training needs specification includes the definition of the required skill SOFTWARE TESTING 5-23 level. It also includes the specification of the training activities (such as classroom training, self-paced training, computer-based training, or mentoring) useful for providing the neces- sary skills to the selected staff. 6.

--- Chunk 284 ---
Tokens: 400
Type: sentence-based
Text:
6. Software Testing in the Development Processes and the Application Domains 2, c8, c15; 14, c4s8, c7 Whatever development process is adopted, testing remains a fundamental activity. However, specific testing activities or termi- nologies could be used in some cases, such as the adopted development life cycle andor the application domain 6.1. Testing Inside Software Development Processes 2, c8; 14, c7 In the remainder of this section, peculiarities of testing inside the different development processes are provided. 6.1.1. Testing in Traditional Processes 1 c18; 14, c7 There are a variety of traditional processes, essentially based on the SUT development principles, that can be adopted within the organization. Sequential, V, spiral model and iterative are just some of the processes com- monly applied. (Software Life Cycles in the Software Engineering Process KA provides a detailed description of each.) However, in all these processes, testing is just one per- ceived activity; it is sometimes performed at the end of the process, with a tangible risk of SUT development failure in case of devi- ation of the end-user needs or assessment issues. During recent years, to evaluate and control the overall quality of the SUT, initia- tives such as test maturity model integration (TMMi) and software process improvement (SPI) have been established. As a result, dif- ferent existing frameworks have been updated or improved for the purpose, such as soft- ware process improvement and capability determination (SPICE), capability maturity model integration (CMMI), and unified pro- cess (UP).

--- Chunk 285 ---
Tokens: 379
Type: sentence-based
Text:
As a result, dif- ferent existing frameworks have been updated or improved for the purpose, such as soft- ware process improvement and capability determination (SPICE), capability maturity model integration (CMMI), and unified pro- cess (UP). For instance, CMMI is one of the most referenced models; it can guide key SUT stakeholders in gaining control of their devel- opment and maintenance processes. It is, in fact, a well-defined set of best practices in software testing that improves SUT quality by increasing customer satisfaction. Presented in the early 2000s, the UP model can be seen as a predecessor of the shift-left movement. UP encourages testing early by offering several mechanisms to integrate testing more closely with the software devel- opment effort, making testing a distinct disci- pline. Furthermore, UP promotes an iterative development approach for continuously ver- ifying quality. It also enables use cases and risk to drive SUT development and allows strategic change management. Indeed, UP groups the SUT increments and SUT itera- tions into four phases: inception, elaboration, construction, and transition. Nowadays, UP can be considered both Iterative and Agile  Iterative because all the core activities are repeated throughout the SUT development project, and Agile because the defined phases of the chosen lifecycle can be repeated until the SUT meets require- ments (both functional and non-functional), achieves the defined objectives, and guaran- tees the target quality. 6.1.2.

--- Chunk 286 ---
Tokens: 364
Type: sentence-based
Text:
6.1.2. Testing in Line with Shift-Left Movement 2, c3, c8s2; 4, part 1; 10, c3, c5 The shift-left testing movement promotes the adoption of testing in the early stages of soft- ware development to detect and remove faults as early as possible to increase overall SUT quality and reduce the cost and risks of testing activities. Currently, different develop- ment life cycles, such as Agile, DevOps and TDD, belong to the shift-left movement. (See Agile Methods in the Software Engineering Process KA.) In shift-left-based development, different testing aspects should be considered: 5-24 SWEBOK  GUIDE V4.0 A. The internal code quality: Regression, prioritization, security, and privacy could be the primary objectives of the internal code quality (Section 2.2). Usually, unit testing and integration testing are the targeted levels (Section 2.1), whereas structure-based is the main testing tech- nique (Section 3.2). B. Business needs: Compliance and confor- mance, usability, security, and privacy are just a subset of the possible objectives of the business needs aspect (Section 2.2). Concerning this aspect, testing focuses more on the system and acceptance test levels and on end-user expectations, as well as usage-based (Section 3.5) and sce- nario-based techniques (Section 3.1.8). C. Perceived quality: Alpha, beta, instal- lation, usability, security, and privacy could be the primary objectives of the internal perceived quality (Section 2.2).

--- Chunk 287 ---
Tokens: 399
Type: sentence-based
Text:
C. Perceived quality: Alpha, beta, instal- lation, usability, security, and privacy could be the primary objectives of the internal perceived quality (Section 2.2). Perceived quality usually focuses on the acceptance test level and is achieved by applying techniques based on soft- ware engineerings intuition and experi- ence (Section 3.3) and usage-based and fault-based techniques, such as mutation testing (Section 3.4). D. Quality assurance: Performance installa- tions, security, and privacy conformance and compliance are some main objectives of quality assurance (Section 2.2). This aspect may involve all testing levels, and the selec- tion of the testing technique depends on the objective and the level chosen. Here, some examples of testing inside the different shift-left movements implementa- tion are provided:  In Agile process development, testing activities involve all stakeholders (such as customers and team personnel) and target the identification of where improvements could be made in future interactions. Managing the risk of regression defects, meeting changing requirements, and managing their impact on test artifacts are also objectives of the Agile testing process. Typically, test automation is used to manage the regression risk, and explor- atory testing may be used to manage a lack of detailed requirements. In TDD, the test cases mainly target the software requirements specifications and acceptance, and they are generated in advance of the code being written. The tests are based on the user stories and implemented using automated com- ponent testing tools.

--- Chunk 288 ---
Tokens: 398
Type: sentence-based
Text:
The tests are based on the user stories and implemented using automated com- ponent testing tools. Indeed, TDD is a practice that requires defining and main- taining unit tests and can help clarify the user needs and software requirements specifications. In testing automated builds and contin- uous integration (for instance, DevOps), the SUT is continuously developed, inte- grated, delivered and monitored. In this process, regression testing is continuously performed to timely identify and cor- rect development and integration issues. Additionally, quick testing techniques, such as smoke testing, are commonly used during continuous integration to guarantee that the SUT is testable before it is released to the operational stage. 6.2. Testing in the Application Domains 2, c15; 14, c4s8 Usually, an application domain is strictly con- nected to a certain reality. Therefore, testing approaches could be tailored to the needs of the domain and customized to the adopted technologies. Below, we provide an overview of dif- ferent aspects and solutions for software testing applied within several domain-spe- cific environments:  Automotive domain testing: Due to the complexity of automotive systems, this testing involves aspects of almost every software component and its interaction with hardware. Security testing, simula- tion testing, reliabilitylife cycle testing, integrated systems testing, data acquisi- tion and signal analysis testing, quality SOFTWARE TESTING 5-25 testing and inspection, and stressstrain testing are just some of the various testing performed in this domain.

--- Chunk 289 ---
Tokens: 387
Type: sentence-based
Text:
Security testing, simula- tion testing, reliabilitylife cycle testing, integrated systems testing, data acquisi- tion and signal analysis testing, quality SOFTWARE TESTING 5-25 testing and inspection, and stressstrain testing are just some of the various testing performed in this domain. Several sup- porting standards are currently available to guide and manage automotive testing according to the peculiarity, the compo- nent, or the quality aspect that should be assessed. Autosar2 and Automotive SPICE3 are examples. Internet of things (IoT) domain testing: This testing involves application develop- ment, device management, system man- agement, heterogeneity management, data management, and tools for anal- ysis, deployment, monitoring, visualiza- tion and research. Additionally, security, privacy, communications and usercom- ponent interaction should be considered in the quality assessment. For example, guidelines and specific conformance test suites for cybersecurity assessment of the IoT SUT are detailed in the European Telecommunications Standards Institute (ETSI) standards.4  Legal domain testing: One of the most important aspects in the legal domain is the management of highly sensitive users; therefore, security, privacy and trust are the most common areas of focus for testing. Additionally, because of the copious data collected and exchanged, performance testing of the data reposi- tory, testing to show accurate commu- nication and integration testing, as well as consistency and compliance testing, should also be done.

--- Chunk 290 ---
Tokens: 379
Type: sentence-based
Text:
Additionally, because of the copious data collected and exchanged, performance testing of the data reposi- tory, testing to show accurate commu- nication and integration testing, as well as consistency and compliance testing, should also be done. Finally, because the legal domain is characterized by specific nomenclature and jargon, involving legal domain experts in test case generation is common practice to ensure a focus on desired characteristics and quality. 2 https:www.autosar.org 3 https:www.automotivespice.com 4 https:www.etsi.org 5 https:www.w3.org201307webmobile-ig-charter.html 6 www.astm.org. 7 https:www.hl7.org 8 http:fhir.org  Mobile domain testing: This testing is usually for usability, functional, con- figuration and consistency assessment. Mobile-specific aspects such as screen resolution, global positioning system (GPS), operating systems, and device manufacturers should also be consid- ered during testing activity. Finally, the type of mobile applications (native or web apps) and their interactions need to be tested. For example, the W3C Web and Mobile Interest Group5 provides facil- ities, guidelines and ad hoc test suites useful for developing and testing web- based content, applications and services. Avionics domain testing6: Usually, avi- onics systems include several indepen- dent or loosely coupled components and commercial off-the-shelf products. Those forces testing to include very general processes and approaches applicable at both the system and the process levels.

--- Chunk 291 ---
Tokens: 374
Type: sentence-based
Text:
Those forces testing to include very general processes and approaches applicable at both the system and the process levels. Functional and non-functional, integra- tion, communication operational, stress, safety, and security testing are exam- ples of possible approaches. As in other domains, supporting standards such as Aeronautical Radio Incorporated (ARINC) Standards and ASTM F3153-15 can be used for reference. Healthcare domain testing: Healthcare domain testing should ensure quality in areas such as secure and reliable data exchange, stable performance, privacy, and safety. Interoperability, usability, per- formance and compliance with industry regulations, as well as security and safety standards (such as the Health Level Seven (HL7),7 Fast Healthcare Interoperability Resources (FHIR),8 Digital Imaging and Communications in Medicine 5-26 SWEBOK  GUIDE V4.0 (DICOM),9 Health Insurance Portability and Accountability Act (HIPAA),10 and the General Data Protection Regulation (GDPR)11) should also be considered. Embedded domain testing: Because soft- ware and hardware are tightly coupled in embedded systems, testing activity should assess functional and non-func- tional attributes of both software and hardware. Graphical user interface (GUI) testing: GUI testing involves assessing the UI (user interface) (i.e, the elements of the user objects that we can see). Thus, GUI testing targets the design pattern, images, alignment, spellings, and the overall look and feel of the UI.

--- Chunk 292 ---
Tokens: 391
Type: sentence-based
Text:
Thus, GUI testing targets the design pattern, images, alignment, spellings, and the overall look and feel of the UI. Testing approaches based on finite-state machines, goal- driven approaches, approaches based on abstractions and model-based approaches can be considered. Gaming: Gaming applications and soft- ware are currently a very active sector of software production, causing increased demand for new approaches and ways to ensure their quality and security. Among the specific testing techniques, playtesting is one of the most adopted. In this case, real gamers repeat quality control methods at many points of the game execution or design process. GUI testing, functionality testing, secu- rity testing, console testing, compliance testing and performance testing can also be considered. Real-time domain testing: Real-time testing usually focuses on assessing timing constraints and deterministic behavior. Usually, unit, integration and system testing approaches can be adopted. Communication, interaction and behav- ioral testing can also be performed. Service oriented architecture (SOA) testing: This testing focuses mainly on correctly implementing business 9 https:www.dicomstandard.org 10 https:www.hhs.govhipaa. 11 https:eur-lex.europa.eulegal-contentENTXTPDF?uriCELEX:32016R0679. processes and involves unit and integra- tion testing approaches. Structure-based, specification-based and security testing can be applied. The testing activity might vary according to the environment, orga- nization and set of requirements that should be satisfied.

--- Chunk 293 ---
Tokens: 391
Type: sentence-based
Text:
The testing activity might vary according to the environment, orga- nization and set of requirements that should be satisfied. Finance domain testing: This testing covers a wide range of aspects, from man- aging financial requirements to assessing financial applications and software pro- grams. As in other domains, domain-spe- cific knowledge (such as that held by, for example, banks, credit unions, insurance companies, credit card companies, con- sumer finance businesses, investment funds and stock brokerages) could be necessary to apply the testing process effectively and efficiently. Customer satisfaction, usability, security, privacy, third-party component and apps integrations, real-time issues, and performance are some of the most important challenges in this domain. 7. Testing of and Testing Through Emerging Technologies In recent decades, software development was driven by emerging trends such as the wide- spread diffusion of mobile technology, cloud infrastructures adoption, big data analysis and the software as a service paradigm, which highlighted new constraints and challenges for testing. 7.1. Testing of Emerging Technologies  Testing artificial intelligence (AI), ML deep learning (DL) 13: AI, ML and DL are successfully being applied in practice. Sooner or later, most business applications will have some form of AI, ML or DL. Because of their peculiarities, testing such applications is challenging and might be very expensive. AI, ML or SOFTWARE TESTING 5-27 DL testing refers to any activity designed to reveal AI, ML or DL bugs.

--- Chunk 294 ---
Tokens: 369
Type: sentence-based
Text:
AI, ML or SOFTWARE TESTING 5-27 DL testing refers to any activity designed to reveal AI, ML or DL bugs. o Three main aspects should be consid- ered in defining bugs and testing in this scenario: the required conditions (correctness, robustness, security, and privacy); the AI, ML or DL items (e.g, a bug might exist in the data, the learning program, or the frame- work used); and the involved testing activities (test case generation, test oracle identification and definition, and test case adequacy criteria). o In all these applications, a prototype model is first generated based on his- torical data. Then, offline testing, such as cross-validation, is con- ducted to verify that the generated model satisfies the required condi- tions. Usually, after deployment, the model is used for prediction purposes by generating new data. Finally, the generated data is analyzed through online testing to evaluate how the model interacts with user behaviors. Testing blockchain 15: The commonly used testing techniques for validating blockchains and related applications such as smart contracts are stress testing, pen- etration testing and property testing. However, depending on the specific situa- tion, different aspects should be considered during the testing of a blockchain-based SUT, such as the following:  Platform type: The level of validation depends on the type of platform used for implementation  public or private. The latter requires a much greater testing effort.

--- Chunk 295 ---
Tokens: 357
Type: sentence-based
Text:
The latter requires a much greater testing effort. Connection with other applications: Integration testing should be performed to check consistency when the blockchain works with various applications. Performance: Performance testing should be conducted when performance issues are a concern. Specific strategies to handle many transactions should be conceived to guarantee a satisfactory performance level. Qualitative and quantitative met- rics, such as average transaction valida- tion latency and security, should also be considered. Testing the cloud 1, c10s10, 2, c18: Testing the cloud validates the quality of applications and infrastructures deployed in the cloud by considering both func- tional and non-functional properties. The focus is to identify problems posed by systems residing in the cloud. Therefore, testing activities use techniques to val- idate cloud-based services perfor- mance, scalability, elasticity and security. Moreover, testing should also focus on compatibility and interoperability among heterogeneous cloud resources when dif- ferent deployment models are used (e.g, private, public or hybrid). Testing concurrent and distributed appli- cations 1, c10s10, 2, c17: One main aspect of testing dynamic, complex, dis- tributed or concurrent applications is dealing with multiple operating systems and updates, multiple browser platforms and versions, different types of hardware, and many users.

--- Chunk 296 ---
Tokens: 395
Type: sentence-based
Text:
Testing concurrent and distributed appli- cations 1, c10s10, 2, c17: One main aspect of testing dynamic, complex, dis- tributed or concurrent applications is dealing with multiple operating systems and updates, multiple browser platforms and versions, different types of hardware, and many users. For such testing, its dif- ficult to use testing approaches based on the classical hierarchy between compo- nents or systems; instead, solutions based on inputoutput, dependency threads, or dynamic relations often work better. Additionally, the possibility of continuous integration and deployment of the dif- ferent components forces the testing pro- cess to include approaches for managing continuous test operation, injection, mon- itoring and reporting according to the time, bandwidth usage, throughput, and adaptability constraints. Finally, there is still the need for solutions that allow the reusability of testing knowledge, archi- tectures, and code to make the testing activity more effective and less expensive. 7.2. Testing Through Emerging Technologies  Testing through ML 13: AI, ML or DL techniques are successfully used to reduce 5-28 SWEBOK  GUIDE V4.0 the effort involved in several activities in software engineering (such as behavior extraction, testing or bug fixing). These techniques aid both researchers and practitioners in adopting and identi- fying appropriate methods for their desired applications. There is a growing interest in adopting ML techniques in software testing because most software testing issues are being formulated as ML learning problems.

--- Chunk 297 ---
Tokens: 386
Type: sentence-based
Text:
There is a growing interest in adopting ML techniques in software testing because most software testing issues are being formulated as ML learning problems. Indeed, AI, ML or DL is intensively used in almost all software, such as test case design, the oracle problem, test case evaluation, test case prioritization and refinement, and mutation testing automation. Indeed, they can reduce maintenance efforts and improve the overall SUT quality because of their ability to analyze large amounts of data for classifying, triaging and prioritizing bugs more efficiently. From a DevOps perspective, AI, ML and DL solutions can be used in SUT automation authoring and execution phases of test cases, as well as in the post-execution test analysis that identi- fies trends, patterns and impact on SUT testing activity. Testing through blockchain 15: Testing becomes complicated when dif- ferent teams, domain experts and users need to work together in collaborative, large-scale systems and complex soft- ware systems to achieve a common goal. This is mainly because of the time con- straint, data sharing policies, acceptance criteria and trusted coordination among the teams involved in the testing process. Blockchain technologies can be exploited to improve software testing efficiency and avoid using centralized authority to manage different testing activities. This can help ensure distributed data man- agement, tamper resistance, auditability, and automatic requirement compli- ance to improve the quality of software testing and development.

--- Chunk 298 ---
Tokens: 395
Type: sentence-based
Text:
This can help ensure distributed data man- agement, tamper resistance, auditability, and automatic requirement compli- ance to improve the quality of software testing and development. Blockchain- based approaches for trusted test case repository management and to support test-based software and security testing are also considered. Testing through the cloud 17: Testing through the cloud refers to SUT testing performed by leveraging scalable cloud technologies. Usually, the cloud is used for testing purposes wherever large-scale simulations and elastic resources are nec- essary. Indeed, this can affect cost reduc- tion, development, and maintenance of the testing infrastructure (scaffolding), and online validation of systems, such as ML-based SUT. A particular situation is the testing of the cloud through the cloud itself. This is an example of the inter- section between testing of and testing through emerging technologies. The applications and infrastructures deployed in the cloud can be tested, exploiting the clouds bandwidth. Testing through simulation 1, c3s9: Simulation is an important technology for testing activity because it represents a valid means for evaluating SUT execu- tion under critical situations or disasters or assessing specific behaviors or recov- ering activities. The complexity of the testing approach might vary according to the complexity of the simulation system adopted and might involve closed-loop testing; assessing the devices, communi- cations, and interface; and use of real-time data (e.g, voltage, current and breaker status).

--- Chunk 299 ---
Tokens: 351
Type: sentence-based
Text:
The complexity of the testing approach might vary according to the complexity of the simulation system adopted and might involve closed-loop testing; assessing the devices, communi- cations, and interface; and use of real-time data (e.g, voltage, current and breaker status). Simulation testing can be applied to each development level and might involve mathematical, formal represen- tation of the real system, environment, network conditions and control devices. Simulation testing is currently adopted in many application domains. Especially in the automotive and embedded domain, among the different proposals, one of the emerging solutions for simulation testing is hardware-in-the-loop (HIL) simula- tion testing. In this case, real signals sent to the SUT to simulate reality and to test and design the iteration are continuously performed while the real-world system is being used. SOFTWARE TESTING 5-29  Testing through crowdsourcing 16: Crowdsourced testing (also known as crowdtesting) is an emerging approach for involving users and experts in the testing activity. Thus, crowdsourcing uses repre- sent the dispersed, temporary workforce of multiple individual testers. Testing through crowdsourcing is mainly used for testing mobile applications because it ensures technology diversity and custom- er-centric validation. However, crowd- testing is not a substitute for in-house SUT validation.

--- Chunk 300 ---
Tokens: 360
Type: sentence-based
Text:
However, crowd- testing is not a substitute for in-house SUT validation. It represents a valid means of detecting failures and issues because it involves many individuals (tes- ters) in different locations, who are using different technologies in different condi- tions and who have different skills and knowledge. 8. Software Testing Tools 1, c12s11, 14, c7 Several testing tools focus on the SUT pecu- liarities and needs. This section describes the main issues and challenges concerning testing tools and provides an overview of their cur- rently identified categories. 8.1. Testing Tool Support and Selection 1, c12s11, 14, c7 Testing involves many labor-intensive tasks since it involves running numerous pro- gram executions and handling a considerable amount of information. Appropriate tools can alleviate the burden of tedious clerical operations and make them less error-prone. Sophisticated tools can support test design and generation, making them more effective. Guidance to managers and testers on selecting testing tools that will be most useful to their organization and processes is an important topic, as tool selection greatly affects testing efficiency and effectiveness. Tool selection depends on diverse factors, such as development choices, evaluation objectives and execution facilities. In general, there might not be a unique tool to satisfy spe- cific needs, so a suite of selected tools could be appropriate. 8.2.

--- Chunk 301 ---
Tokens: 385
Type: sentence-based
Text:
8.2. Categories of Tools 1, c1, c3, c4, c7, c8, c9, c12 Several classifications of testing tools mainly describe their functionalities, such as the following:  Test harnesses (drivers, stubs) 1, c3s9 provide a controlled environment in which tests can be launched and the test outputs can be logged. Drivers and stubs are provided to execute parts of a SUT to simulate calling and called modules. Test generators 1, c12s11 assist in gen- erating test cases. That generation can be random, path-based, model-based or a mix thereof. Capturereplay tools 1, c12s11 automat- ically re-execute or replay previously exe- cuted tests that have recorded inputs and outputs (e.g, screens). Oraclefile comparatorsassertion checking tools 1, c9s7 assist in deciding whether a test outcome is successful. Coverage analyzers and instrumenters 1, c4 work together. Coverage analyzers assess which and how many entities of the program flow graph have been exer- cised among all those required by the selected test coverage criterion. The anal- ysis can be done through SUT instru- menters that insert recording probes into the code. Tracers 1, c1s7 record the history of a programs execution paths. Regression testing tools 1, c12s16 support the re-execution of a test suite after a sec- tion of software has been modified. They can also help select a test subset according to the change made. Reliability evaluation tools 1, c8 support test results analysis and graphical visual- ization to assess reliability-related mea- sures according to selected models.

--- Chunk 302 ---
Tokens: 382
Type: sentence-based
Text:
Reliability evaluation tools 1, c8 support test results analysis and graphical visual- ization to assess reliability-related mea- sures according to selected models. Injection-based tools 1, c3, c7s7 focus on 5-30 SWEBOK  GUIDE V4.0 introducing or reproducing specific prob- lems to confirm that the SUT behaves suitably under the corresponding con- dition. That can involve managing some input or triggering of events. Usually, two categories of injection-based tools are considered: attack injection and fault injection. Simulation-based tools 1, c3s9 verify and validate selected properties. Usually, they exploit specific models to enable the auto- mated execution of scenarios to assess whether the SUT operates as expected or to predict how the SUT would respond to defined inputs. Typical simulation-based tools are classified into tools for verifi- cation, tools for collaboration, tools for optimization, tools for testing automated systems and tools for evaluating software concepts. Security testing tools 1, c8s3, c12s11 focus on specific security vulnerabilities. Among these are tools for attack injec- tion, penetration testing and fuzz testing. Test management tools 1, c12s11 include all the supporting tools that assure effi- cient and effective test management and data collection. Cross-browser testing tools 1, c8s3 enable the tester to quickly build and run user interface test cases across desktop, mobile and web applications to check whether the SUT looks and works as expected on every device and browser.

--- Chunk 303 ---
Tokens: 376
Type: sentence-based
Text:
Cross-browser testing tools 1, c8s3 enable the tester to quickly build and run user interface test cases across desktop, mobile and web applications to check whether the SUT looks and works as expected on every device and browser. Load testing tools 1, c3 collect valuable data and evidence for SUT performance evaluations. Defect tracking tools 1, c3 help keep track of detected faults during the SUT development projects. These tools behave as tracking systems and usually allow end users to enter fault reports directly. Mobile testing tools 1, c8s3 support the implementation and testing of mobile apps by allowing several repeated UI tests over the application platform, develop- ment on real mobile devices or emulators, testing of the mobile apps on real-time implementations and collection of data for specific QA measures. API testing tools 1, c7s2 check whether the applications meet functionality, per- formance, reliability, and security expec- tations throughout the automation of specific API tests. CSS validator tools 1, c7s2 validate cas- cading style sheets (CSS) code and dis- cover errors, issues and warnings that can be fixed. The CSS Validation Service, provided by W3C for free, is one of the most used validators in practice that helps both web designers and web developers check CSS. Web application testing tools 1, c8s3, also referred to as web testing tools, support validating the functionality and the per- formance of web-based SUTs before their deployment into production.

--- Chunk 304 ---
Tokens: 397
Type: sentence-based
Text:
Web application testing tools 1, c8s3, also referred to as web testing tools, support validating the functionality and the per- formance of web-based SUTs before their deployment into production. These tools provide relevant insight and data for dif- ferent stakeholders, such as developers, servers, and infrastructure administra- tors. From a DevOps perspective, these tools address issues, or bugs before SUTs are available to end users. SOFTWARE TESTING 5-31 MATRIX OF TOPICS VS. REFERENCE MATERIAL 1 2 14 19 1. Software Testing Fundamentals c1, c2 c8 c7 1.1. Faults vs. Failures c1s5 c1 c1s3 1.2. Key Issues 1.2.1. Test Case Creation c12s1, c12s3 c8 1.2.2. Test Selection and Adequacy Criteria c1s14, c6s6, c12s7 c8 1.2.3. PrioritizationMinimization 1.2.4. Purpose of Testing c13s11, c11s4 c8 1.2.5. Assessment and Certification c7, c25 1.2.6. Testing for Quality ImprovementAssurance c16s2 1.2.7. The Oracle Problem c1s9, c9s7 1.2.8. Theoretical and Practical Limitations c2s7 1.2.9. The Problem of Infeasible Paths c4s7 1.2.10. Testability c17s2 1.2.11. Test Execution and Automation 1.2.12. Scalability c8s7 1.2.13. Test Effectiveness c1s1 c8s1 1.2.14. Controllability, Replication and Generalization c12s12 1.2.15. Offline vs. Online Testing 1.3. Relationship of Testing to Other Activities 2. Test Levels c1s13 c8s1 2.1. The Target of the Test c1s13 c8s1 2.1.1. Unit Testing c3 c8 2.1.2. Integration Testing c7 c8 2.1.3. System Testing c8 c8 2.1.4. Acceptance Testing c1s7 c8s4 2.2. Objectives of Testing c1s7 2.2.1. Conformance Testing c10s4 2.2.2. Compliance Testing c12s3 2.2.3.

--- Chunk 305 ---
Tokens: 397
Type: sentence-based
Text:
Compliance Testing c12s3 2.2.3. Installation Testing c12s2 2.2.4. Alpha and Beta Testing c13s7, c16s6 c8s4 2.2.5. Regression Testing c8s11, c13s3 2.2.6. Prioritization Testing c12s7 2.2.7. Non-functional testing c8s7, c8s8, c14s2, c15, c17s2 c8, c 11, c17 5-32 SWEBOK  GUIDE V4.0 2.2.8. Security Testing c13 2.2.9. Privacy Testing c13, c14 2.2.10. Interface and API Testing c8s1 c7s12 2.2.11. Configuration Testing c8s5 2.2.12. Usability and Human-Computer Interaction Testing c8s4 c6 3. Test Techniques c1s15 3.1. Specification-Based Techniques c6s2 3.1.1. Equivalence Partitioning c9s4 3.1.2. Boundary Value Analysis c9s5 3.1.3. Syntax Testing c10s11 c5 3.1.4. Combinatorial Test Techniques c9s3 3.1.5. Decision Table c9s6, c13s6 3.1.6. Cause-Effect Graphing c1s6 3.1.7. State Transition Testing c10 3.1.8. Scenario Testing c8s3.2, c19s3.1 3.1.9. Random Testing c9s7 3.1.10. Evidence-Based 3.1.11. Forcing Exception 3.2. Structure-Based Test Techniques 3.2.1. Control Flow Testing c4 3.2.2. Data Flow Testing c5 3.2.3. Reference Models for Structure-Based Test Techniques c4 3.3. Experience-Based Techniques 3.3.1. Error Guessing c9s8 3.3.2. Exploratory Testing 3.3.3. Further Experience-Based Techniques 3.4. Fault-Based and Mutation Techniques c1s14, c3s5 3.5. Usage-Based Techniques c15s5 3.5.1. Operational Profile c15s5 c11 3.5.2. User Observation Heuristics c5, c7 3.6. Techniques Based on the Nature of the Application c16, c17, c18, c20, c21 c4s8 3.7. Selecting and Combining Techniques c7s12 3.7.1. Combining Functional and Structural c9 3.7.2. Deterministic vs. Random c9s6 3.8.

--- Chunk 306 ---
Tokens: 394
Type: sentence-based
Text:
Deterministic vs. Random c9s6 3.8. Techniques Based on Derived Knowledge c19, c20 c7 4. Test-Related Measures c24s5 c10 4.1. Evaluation of the SUT c24s5 SOFTWARE TESTING 5-33 4.1.1. SUT Measurements That Aid in Planning and Designing Tests c10 4.1.2. Fault Types, Classification and Statistics c13s4, c13s5, c13s6 4.1.3. Fault Density c13s4 c10s1 4.1.4. Life Test, Reliability Evaluation c15 c11 c1s3 4.1.5. Reliability Growth Models c15 c11s5 4.2. Evaluation of the Tests Performed 4.2.1. Fault Injection c2s5 4.2.2. Mutation Score c3s5 4.2.3. Comparison and Relative Effectiveness of Different Techniques c1s7 5. Test Process c8 5.1. Practical Considerations 5.1.1. AttitudesEgoless Programming c16 c3 5.1.2. Test Guides and Organizational Process c12s1 c8 c7s3 5.1.3. Test Management and Dynamic Test Processes c12 c7s3 5.1.4. Test Documentation c8s12 c7s8 5.1.5. Test Team c16 c23s5 5.1.6. Test Process Measures c18s3 c10 5.1.7. Test Monitoring and Control 5.1.8. Test Completion c7s11 5.1.9. Test Reusability c3 5.2. Test Sub-Processes and Activities c12s9, c1s12 5.2.1. Test Planning Process c12s1, c12s8 5.2.2. Test Design and Implementation c12s1, c12s3 5.2.3. Test Environment Set-up and Maintenance c12s6 c8s1 c13s2 5.2.4. Controlled Experiments and Test Execution c12s7 c4s7, c5s6 5.2.5. Test Incident Reporting c13s4, c13s9, c13s11 c8s3 c7s8 5.3. Staffing c16 6. Software Testing in the Development Processes and the Application Domains c8, c15 c4s8, c7 6.1. Testing Inside Software Development Processes c8 c7 6.1.1. Testing in Traditional Processes c18 c7 6.1.2.

--- Chunk 307 ---
Tokens: 386
Type: sentence-based
Text:
Testing in Traditional Processes c18 c7 6.1.2. Testing in Line with Shift- Left Movement c3, c8s2 5-34 SWEBOK  GUIDE V4.0 6.2. Testing in the Application Domains c15 c4s8 7. Testing of and Testing Through Emerging Technologies 7.1. Testing of Emerging Technologies c10s10 c17, c18 7.2. Testing Through Emerging Technologies c3s9 8. Software Testing Tools c12s11 c7 8.1. Testing Tool Support and Selection c12s11 c7 8.2. Categories of Tools c1, c3, c4, c7, c8, c9, c12 REFERENCES 1 S. Naik and P. Tripathy, Software Testing and Quality Assurance: Theory and Practice, ed: Wiley, 2008, p. 648. 2 I. Sommerville, Software Engineering, 10th ed, Addison-Wesley, 2016. 3 E.W. Dijkstra, Notes on Structured Programming, Technological University, Eindhoven, 1970. 4 ISOIECIEEE 29119  System and software engineering  Software testing, ed. 2021. 5 ISOIECIEEE, ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, 2nd ed. 2017. 6 M. Papadakis, M. Kintis, J. Zhang, Y. Jia, Y. Le Traon, and M. Harman, Chapter Six  Mutation Testing Advances: An Analysis and Survey, Adv. Comput. 112, 2019: 275-378. 7 M. Utting, B. Legeard, F. Bouquet, E. Fourneret, F. Peureux, and A. Vernotte, Recent advances in model-based testing, Advances in Computers, 101, 2016, pp. 53-120. 8 IEEE Std 1012-2016, IEEE Standard for System, Software, and Hardware Verification, and Validation, ed. 2016. 9 ISOIEC 25010:2011, Systems and software engineering  Systems and Software Quality Requirements and Evaluation (SQuaRE)  System and Software Quality Models, ed. 2011.

--- Chunk 308 ---
Tokens: 326
Type: sentence-based
Text:
2011. 10 ISOIECIEEE 32675:2022 Information technology  DevOps  Building reliable and secure systems including application build, package and deployment. 11 Software Engineering Competency Model (SWECOM), v1.0, 2014. 12 ISOIEC 20246:2017, Software and systems engineering  Work product reviews, ed, 2017, 42p 13 V. Riccio, G. Jahangirova, A. Stocco, et al, Testing machine learning based systems: A systematic mapping, Empir Software Eng, 25, 2020, pp. 5193-5254. 14 C.Y. Laporte, and A. April, Software Quality Assurance, IEEE Computer Society Press, 1st ed, 2018. 15 S. Demi, R. Colomo-Palacios, and M. Snchez-Gordn, Software Engineering Applications Enabled by SOFTWARE TESTING 5-35 Blockchain Technology: A Systematic Mapping Study, Applied Sciences, 11(7), 2021, pp. 2960. 16 K. Mao, L. Capra, M. Harman, and Y. Jia. A survey of the use of crowd- sourcing in software engineering, Journal of Systems and Software, 126, 2017, pp. 57-84. 17 A. Bertolino, G.D. Angelis, M. Gallego, B. Garca, F. Gortzar, F. Lonetti, and E. Marchetti, A system- atic review on cloud testing, ACM Computing Surveys (CSUR), 52(5), 2019, pp. 1-42. 18 R. Achary and P. Raj, Cloud Reliability Engineering: Technologies and Tools, CRC Press, 2021. 19 J. Nielsen, Usability Engineering, 1st ed, Boston: Morgan Kaufmann, 1993.

--- Chunk 309 ---
Tokens: 379
Type: sentence-based
Text:
19 J. Nielsen, Usability Engineering, 1st ed, Boston: Morgan Kaufmann, 1993. 6-1 CHAPTER 06 Software Engineering Operations ACRONYMS API Application Programming Interface ATDD Acceptance Test Driven Development CD Continuous Delivery CI Continuous Integration CPU Central Processing Unit CONOPS Concepts of Operations DBMS Database Management System IaC Infrastructure as-Code IaaS Infrastructure as a Service IT Information technology ITIL IT Infrastructure Library KA Knowledge Area KPI Key Performance indicator MR Modification request MVP Minimum Viable Product PaaS Platform as a Service PR Problem Report QA Quality Assurance SaaS Software as a Service SLAs Service-Level Agreements SRE Site Reliability Engineering TDD Test Driven Development INTRODUCTION Software engineering operations refers to the set of activities and tasks necessary to deploy, operate and support a software application or system while preserving its integrity and stability. These activities include the deploy- ment and configuration of the software in the targeted operational environments and the monitoring and management of the applica- tion while it is in use (until it is retired). Once the application is operational, software engi- neering operations must manage any defects that are uncovered, any changes made to the system software environment and hard- ware equipment over time, and any new user requirements that surface. Software engineering operations is an inte- gral part of system and software life cycle processes 3.

--- Chunk 310 ---
Tokens: 390
Type: sentence-based
Text:
Software engineering operations is an inte- gral part of system and software life cycle processes 3. The Software Engineering Operations Knowledge Area (KA) is related to all other aspects of software engineering. Therefore, this KA description is linked to all other software engineering KAs of the SWEBOK Guide, particularly the Software Construction KA, which discusses preparing the software for deployment, including inte- grating, building, packaging and testing. Specialized software and information tech- nology (IT) operations engineers have tradi- tionally provided and managed IT operations services. Best practices in software engi- neering operations were initially published by the IT infrastructure library (ITIL) and were quickly accepted by the industry. These practices were summarized and published in the Institute of Electrical and Electronics Engineers 20000 standard 1. Historically, operations and computing cen- ters were often located in organizational silos separate from software development activities. Progressive organizations now co-locate soft- ware development, software maintenance and some software engineering operations activ- ities (often provided as a service and often coined DevOps). Benefits of this approach are the elimination of the organizational silos that separated these software activities and the 6-2 SWEBOK  GUIDE V4.0 sharing of common processes and tools. The rising popularity and growing acceptance of DevOps practices 2 and related standards 4, including an ever-evolving set of tools, reflect this trend.

--- Chunk 311 ---
Tokens: 315
Type: sentence-based
Text:
The rising popularity and growing acceptance of DevOps practices 2 and related standards 4, including an ever-evolving set of tools, reflect this trend. DevOps aims at automating and continuously evolving software engi- neering activities to ensure high-quality soft- ware and to satisfy users who demand quicker turnaround from software engineers. In this context, the role of software engi- neers involved in software engineering oper- ations has significantly evolved over the past decade with the emergence of practices like infrastructure as code (IaC), Platform- as-Code (PaC), Agile infrastructure, soft- ware-defined architecturessystems, and the availability of infrastructure as a ser- vice (IaaS) and platform as a service (PaaS) solutions. Tasks traditionally performed by IT infrastructure engineers are increasingly automated and made available as a service, enabling application developers to perform software engineering operations tasks inde- pendently as part of their daily project activ- ities. For example, application developers in many organizations can now directly use IaaS and PaaS to deploy applications in produc- tion environments and to monitor different aspects of those applications without directly involving operations engineers.

--- Chunk 312 ---
Tokens: 373
Type: sentence-based
Text:
For example, application developers in many organizations can now directly use IaaS and PaaS to deploy applications in produc- tion environments and to monitor different aspects of those applications without directly involving operations engineers. Having end-to-end resources and desired state configuration managed like code, using practices such as IaC and PaC, provides value in the form of 1) improved repeatability, 2) consistencystandardization, 3) known secu- rity policies , 4) self-documentation (transpar- ency), 5) single source of truth, 6) configuration control, and 7) scalability. From an engi- neering perspective, the important point is that nearly anything that impacts a software product directly or indirectly should be con- sidered for representation as code. To perform software engineering operations tasks, some organizations use the the concept of Platform Engineering and Site Reliability Engineering (SRE) 6 to increase produc- tivity and software quality. The role of platform engineering is to build and manage self-service platform capabilities that can be used by soft- ware engineers to develop, deploy, and operate software applications. On the other hand, the role of SRE is to monitor, automate, and improve software operations with respect to non-functional aspects, including availability, performance, latency, and security. SRE is also responsible for change management, emer- gency response, capacity planning, and overall efficiency of software systems.

--- Chunk 313 ---
Tokens: 359
Type: sentence-based
Text:
SRE is also responsible for change management, emer- gency response, capacity planning, and overall efficiency of software systems. Although many organizations still use conventional IT operations management Software Engineering Operations Software Engineering Operations Fundamentals Software Engineering Operations Planning Software Engineering Operations Delivery Software Engineering Operations Control Software Engineering Operations Tools Defnition of Software Engineering Operations Software Engineering Operations Processes Software Installation Scripting and Automating Efective Testing and Troubleshooting Performance, Reliability and Load Balancing Operations Plan and Supplier Management Development and Operational Environment Software Availability, Continuity and Service Levels Software Capacity Management Software and Data Safety, Security, Integrity, Protection and Controls DeploymentRelease Engineering Rollback and Data Migration Change Management Problem Management Incident Management Monitor, Measure Track and Review Operations Support Operations Service Reporting Incident and Problem Prevention Operational Risk Management Automated Software Engineering Operations Software Engineering Operations for Very Small Entities Containers and Incident Visualization Deployment Automated Tests Monitoring and Telemetry Practical Considerations Figure 6.1. Breakdown of Topics for the Software Engineering Operations KA.

--- Chunk 314 ---
Tokens: 376
Type: sentence-based
Text:
Breakdown of Topics for the Software Engineering Operations KA. SOFTWARE ENGINEERING OPERATIONS 6-3 processes, this KA focuses mainly on the role of software engineers in operations in the emerging contexts of DevOps, IaC, PaC, and Agile infrastructure practices. In this context, we identify two main soft- ware engineering roles related to operations: Operations engineer, who is responsible for developing operations services made available as a service and accessible through an appli- cation programming interface (API), and software engineer, who can use the resulting operations services (available as a service) to independently deploy and manage applica- tions without directly involving IT operations specialists. BREAKDOWN OF TOPICS FOR SOFTWARE ENGINEERING OPERATIONS The breakdown of topics for the Software Engineering Operations KA is shown in Figure 6.1. 1. Software Engineering Operations Fundamentals This first section introduces the concepts and terminology that form an underlying basis for understanding the role and scope of software engineering operations. 1.1. Definition of Software Engineering Operations 1, c3s3.33, c6s6.4.12 In this Guide, the term software engineering operations refers to the knowledge, skills, pro- cesses and tools used by software engineers or their organization to ensure that a software product, including IT infrastructure, system software, and application software, operates well during development, maintenance and in real conditions of operations.

--- Chunk 315 ---
Tokens: 176
Type: sentence-based
Text:
Definition of Software Engineering Operations 1, c3s3.33, c6s6.4.12 In this Guide, the term software engineering operations refers to the knowledge, skills, pro- cesses and tools used by software engineers or their organization to ensure that a software product, including IT infrastructure, system software, and application software, operates well during development, maintenance and in real conditions of operations. In ISOIECIEEE 12207 3, an operator is defined as an individual or organization that performs the operations of a system. The SWEBOK Guide modifies that definition for the term operations engineer, which refers to a software engineer who executes software engineering operations processes.

--- Chunk 316 ---
Tokens: 317
Type: sentence-based
Text:
The SWEBOK Guide modifies that definition for the term operations engineer, which refers to a software engineer who executes software engineering operations processes. In this role, an operations engineer works closely with soft- ware engineers to develop and offer operations services such as the following:  Provisioning, deploying and config- uring, and supporting containers and vir- tual servers,  Designing and offering on-demand ser- vices (e.g, environment on demand, ver- sioning, continuous integration (CI) and testing, deployment, and surveillance) for use by software engineering,  Monitoring and troubleshooting system and application software incidents by running diagnostics, documenting prob- lems and resolutions, prioritizing prob- lems, and assessing impact of issues,  Performing, automating and imple- menting appropriate processes for security, data protection and failover procedures,  Overseeing capacity, storage plan- ning and database management system (DBMS) performance,  Providing documentation and technical specifications to IT staff for planning and implementing new or upgraded IT infra- structure and system software. ISOIECIEEE 20000-1 describes the need to develop and enhance the profes- sional competencies of operations engineers.

--- Chunk 317 ---
Tokens: 380
Type: sentence-based
Text:
ISOIECIEEE 20000-1 describes the need to develop and enhance the profes- sional competencies of operations engineers. To achieve this goal, software organizations should address the following:  Staff recruitment: To validate job appli- cants qualificationscompetencies, including their professional certifications, and to identify their strengths, weak- nesses and potential capabilities against the operations engineer job description, core technologies and computer languages mastered and overall experience,  Resource planning: To staff new or expanded engineering operations services, plan the use of new technology, plan the assignment of service management staff 6-4 SWEBOK  GUIDE V4.0 to development project teams, develop succession planning and other staffing gaps created by staff turnover,  Resource training and development: To identify training and development requirements and create a training and development plan that meets them; also, to provide timely, effective delivery of operations services. Operations engineers should be trained in the relevant aspects of service management (e.g, via training courses, self-study, mentoring and on-the-job training), and their teamwork and leadership skills should be developed. A chronological training record should be maintained for each individual, with descriptions of the training provided. 1.2. Software Engineering Operations Processes 2, s13, c6s6.4.12 ISOIECIEEE 20000-1 is the reference stan- dard that presents an overview of operations pro- cesses.

--- Chunk 318 ---
Tokens: 343
Type: sentence-based
Text:
Software Engineering Operations Processes 2, s13, c6s6.4.12 ISOIECIEEE 20000-1 is the reference stan- dard that presents an overview of operations pro- cesses. It specifies requirements for the design, transition, delivery and improvement of opera- tions services. The ISOIECIEEE 20000-1 describes five main operations process groups: service delivery processes, release processes, control processes, resolution processes and rela- tionship processes. These operations processes are further categorized as technical processes in ISOIECIEEE 12207 3. Operations pro- cesses, from the perspective of a software engi- neer, contain the activities and tasks necessary to deploy, configure, operate and support an existing software system or product while pre- serving its integrity. This international standard describes four main operations process activi- ties: 1) prepare for the operation: that requires to define an operation strategy; 2) perform the operation: which consist of operating and mon- itoring; 3) manage the results of operation: where anomalies are recorded and addressed; and finally 4) support the customer: which means to give assistance and consultation to any user of the operations services. Finally, ISOIECIEEE 32675 4 intro- duces a number of software engineering operations activities using an Agile and a minimum viable product (MVP) perspec- tive.

--- Chunk 319 ---
Tokens: 330
Type: sentence-based
Text:
Finally, ISOIECIEEE 32675 4 intro- duces a number of software engineering operations activities using an Agile and a minimum viable product (MVP) perspec- tive. This standard recognizes the influence of DevOps as a set of principles and practices that enable better communication and collab- oration between relevant stakeholders for the  Operations Plan and Supplier Management  Development and Operational Environment  Software CM, Build, Package and Deployment  Software Availability, Continuity and Service Levels  Software Capacity Management  Software Backup, Disaster Recovery and Failover  Software and Data Safety, Security, Integrity, Protection and Controls  Operational Testing, Verication and Acceptance  DevelopmentRelease Engineering  Rollback and Data Migration  Problem Resolution  Incident and Change Management  Monitor, Measure, Track and Review  Service Support and Operations Service Desk  Service Reporting Operations Planning Processes Operations Delivery Processes Operations Control Processes Figure 6.2. Software Engineering Operations Processes and Activities SOFTWARE ENGINEERING OPERATIONS 6-5 purpose of specifying, developing, continu- ously improving, and operating software and system products and services. These processes and activities are the responsibility of opera- tions engineers.

--- Chunk 320 ---
Tokens: 383
Type: sentence-based
Text:
These processes and activities are the responsibility of opera- tions engineers. For the purpose of the SWEBOK Guide, engineering operations activities can be grouped into three main operations processes (see Figure 6.2) that each contain a number of operations activities, which are described in the following sections of this chapter:  Operations Planning (section 2),  Operations Delivery (section 3),  Operations Control (section 4). Each software engineering operations pro- cess includes activities performed during the pre delivery and post delivery stages of a soft- ware project. Software engineering opera- tions planning activities occur during the pre delivery stage. These activities are covered in this chapter. 1.3. Software Installation 1, c3, c6s22, c3s3.1 Before a software application or update can be made available to the users (i.e. released in production), the operations engineer must install the software as part of its deployment. To install the software, the engineer might have to uninstall previous versions, configure the software for its target destination, and create the necessary directories, registry files and environment variables on the target des- tination. This is often done using a scripting language. The installation of the software to the appropriate locations is typically done electronically, but in the case of embedded systems, it might require the use of a phys- ical medium. Once the software is installed, a verification step is conducted to ensure that the operation succeeded. 1.4.

--- Chunk 321 ---
Tokens: 368
Type: sentence-based
Text:
1.4. Scripting and Automating 2, c9 As part of software engineering operations, repetitive tasks are automated to reduce delays, increase quality, and ensure a con- sistent and stable operational environment. This is typically achieved using scripting languages, which are basic programming languages. Automating operations enables a quicker reaction in case of a failure and, therefore, results in less downtime and fewer severe incidents, as alerts are sent immedi- ately. Automating such tasks is also a good way to ensure standardization of operations in an organization. It also constitutes the basis for the development of operations made avail- able as a service. Refer to section 6 for further discussion on operations tools. 1.5. Effective Testing and Troubleshooting 2, c3 Software engineering operations is respon- sible for ensuring the stability of the system. For this purpose, software must be thor- oughly tested before it is released (deployed in production and made available to users). Because manual testing is inefficient, error- prone and non-scalable, testing must be auto- mated as much as possible throughout the entire software process. Also, because the time available for testing is limited, regres- sion testing and test coverage strategies (the selective retesting of a software application, or component, to verify that the software to be deployed will not cause unintended effects) play an important role in software engineering operations.

--- Chunk 322 ---
Tokens: 352
Type: sentence-based
Text:
Also, because the time available for testing is limited, regres- sion testing and test coverage strategies (the selective retesting of a software application, or component, to verify that the software to be deployed will not cause unintended effects) play an important role in software engineering operations. When errors are found (in production after the software is released or during internal testing phases), software engineers and soft- ware operations engineers need to troubleshoot hardware and software incidents by running diagnostics, documenting problems and res- olutions, prioritizing problems, and assessing the impact of the issues. The cost  in both time and money  of repeating full testing on a major piece of software is significant. To ensure that the requested problem reports (PRs) are valid, the operations engineer should replicate and verify problems by running the appropriate tests. Testing certain aspects of the software in production can be particularly 6-6 SWEBOK  GUIDE V4.0 challenging. For example, when software per- forms critical functions, bringing it off-line to test might be difficult. Generally, testing the software in the production system context is challenging (sometimes impossible) and could require the use of testing techniques such as canary testing and dark launches. The Software Testing KA provides additional information and references on testing. 1.6.

--- Chunk 323 ---
Tokens: 329
Type: sentence-based
Text:
1.6. Performance, Reliability and Load Balancing 1, c6s6.2 Software operations engineers plan for per- formance, reliability and load balancing early in software projects to ensure they meet the project requirements. (See section 1.2 to 1.7 of the Software Requirements KA). A cur- rent trend is for software engineers to design and use infrastructureoperations services to adjust dynamically (e.g. scalability) the infra- structure according to the demand. Using DevOps practices enables operations engi- neers to anticipate these needs early and pro- vide infrastructure services that software engineers can use and test during the devel- opment stages of a project. 2. Software Engineering Operations Planning This topic introduces some of the generally accepted techniques used in software engi- neering operations planning. Operations engineers must deal with a number of key issues to ensure software operates effectively. Operations engineers should document their software engineering operations steps and tools, using any type, form or medium suit- able for the purpose (e.g, Wikis, documents, and more). The following topics are typically considered suitable as evidence of well docu- mented operations:  Policies and plans,  Service documentation,  Procedures,  Processes, and  Process control records. 2.1.

--- Chunk 324 ---
Tokens: 386
Type: sentence-based
Text:
2.1. Operations Plan and Supplier Management 1, c4s4.13, c6s6.1 Software engineering operations planning should comprise part of the process of trans- lating project requirements and the needs of the developers and maintainers into services, and it should provide a road map for directing progress. This process often involves the prod- ucts and services of suppliers that must be well coordinated to ensure quality service. ISOIECIEEE 20000-1 describes planning activities, as well as ISOIECIEEE 12207, which lists the activities operations engineers considers from human, technical and system perspectives. 2.1.1. Operations Plan 1, c4s4.13,c6s6.4.12.3a Whereas software development typically lasts from some months to a few years, the operations phase usually lasts many years. Therefore, estimating resources is a key ele- ment of operations planning. Software engi- neering operations planning should begin with the decision to develop a new software product and should consider its maintenance and operations requirements early. A concept document should be developed, followed by an operations and maintenance plan 1,c7s2, and both should address the following:  Scope of the operations and software maintenance,  Adaptation of the software engineering operations process and tools,  Identification of the software engineering operations organization,  Estimate of software engineering opera- tions and maintenance costs. The next planning step suggest to develop a software engineering operations plan, or concept of operations (CONOPS).

--- Chunk 325 ---
Tokens: 209
Type: sentence-based
Text:
The next planning step suggest to develop a software engineering operations plan, or concept of operations (CONOPS). This plan should be prepared during software develop- ment and should specify how users will request software modifications and report problems or issues when the software will be operational. SOFTWARE ENGINEERING OPERATIONS 6-7 Software engineering operations planning is addressed in ISOIECIEEE 12207 3 and ISOIECIEEE 32675 4. The standards pro- vide guidelines for planning, implementing, maintaining, automating and supporting pro- duction software. Finally, at the highest plan- ning level, the operations organization must conduct business planning activities (e.g, bud- getary, financial and human resources), just as all the other divisions of the organization (refer to the Software Engineering Management KA).

--- Chunk 326 ---
Tokens: 395
Type: sentence-based
Text:
Finally, at the highest plan- ning level, the operations organization must conduct business planning activities (e.g, bud- getary, financial and human resources), just as all the other divisions of the organization (refer to the Software Engineering Management KA). ISOIECIEEE 20000-1 recommends that the operations plan address issues associ- ated with a number of planning perspectives, including the following:  The roles and responsibilities for imple- menting, operating and maintaining the new or changed service,  Activities to be performed by customers and suppliers,  Changes to the existing service manage- ment framework and services,  Communication to the relevant parties,  New or changed contracts and agreements to align with changes in business needs,  Staffing and recruitment requirements,  Skills and training requirements (e.g, users, technical support),  Processes, measures, methods and tools to be used in connection with the new or changed service,  Capacity management,  Financial management,  Budgets and timescales,  Service acceptance criteria, and  The expected outcomes from operating the new service, expressed in measur- able terms. This plan ensures that an operational strategy is defined, conditions for correct oper- ations are identified and evaluated, the soft- ware is tested at scale to operate in its intended environment, and surveillance is provided to ensure responsiveness and availability of the software by ensuring constant support. At the individual request level (e.g, problem report (PR) or modification request (MR)) need planning.

--- Chunk 327 ---
Tokens: 362
Type: sentence-based
Text:
At the individual request level (e.g, problem report (PR) or modification request (MR)) need planning. Once individual requests are received and validated, the release or version planning activity requires that operations engineers perform the following tasks:  Identify the target availability dates of individual requests,  Agree on the content of subsequent releases or versions,  Identify potential conflicts and develop alternatives,  Assess the risk of a given release and develop a rollback and data migration plan (see section 3.3) in case problems arise,  Inform all stakeholders. 2.1.2. Supplier Management 1, c7s33, c6s6.1 Supplier management ensures that the orga- nizations suppliers and their performance are managed appropriately to support the seam- less provision of quality products and services. ISOIECIEEE 12207 lists the activities that the operations engineer will perform to estab- lish an agreement to acquire suppliers products andor services. From an operations engineers perspective, the nature of the relationship with suppliers and the approach should be determined by the nature of the products and services needed in a project. Managing sup- pliers of services related to operational soft- ware includes managing out-sourced services and cloud services, like IaaS and PaaS. 2.2. Development and Operational Environments 2, c9 The overall software process requires the use of different environments at different stages.

--- Chunk 328 ---
Tokens: 345
Type: sentence-based
Text:
Development and Operational Environments 2, c9 The overall software process requires the use of different environments at different stages. These are typically defined as the development environment, the testing or quality assurance (QA) environment, the preproduction envi- ronment, and the production environment. To build quality into the product and reduce the risks associated with the release of soft- ware in the production environment (whether the release is associated with new function- ality or software defects), engineers must 6-8 SWEBOK  GUIDE V4.0 ensure that the different environments are all coherent and synchronized with the produc- tion environment. For this reason, DevOps recommends that the creation of all the different environments be automated and built from a single code repository. In mature DevOps organizations, the creation of the different environments is completely automated and made available as a service. Also, all environments need to be built from the same code source (single source of truth) to ensure that all the environments are synchronized with the production envi- ronment in which the software is released. This leads to the concept of infrastructure as code (IaC). 2.3. Software Availability, Continuity, and Service Levels 1, c6s6.3 Service availability and continuity must be managed to ensure that customer commitments are met.

--- Chunk 329 ---
Tokens: 378
Type: sentence-based
Text:
Software Availability, Continuity, and Service Levels 1, c6s6.3 Service availability and continuity must be managed to ensure that customer commitments are met. Because service availability and conti- nuity are defined as nonfunctional requirements early in a project (see the Software Quality KA), operations engineers will ensure that the proper infrastructure is planned, designed, implemented and tested. Software availability is measured and recorded, and unplanned nonavailability is investigated and appropriate actions taken. Service reports produce avail- ability and continuity indicators of operations services against service-level targets. The service-level management process moni- tors the agreed software level of service, including workload characteristics, performance and availability trend information and customer satisfaction analysis. Defining, agreeing to and documenting service-level agreements (SLAs) can help clarify the full range of operations services obligations provided. The Software Maintenance KA provides additional infor- mation and references about SLAs. 2.4. Software Capacity Management 1, c6s6.5 ISOIECIEEE 20000-1 describes the need to ensure that the software product has the capacity, at all times, to meet current and future agreed-upon demands created by the customers business needs. The current and expected business requirements for services should be understood in terms of what the business needs in order to deliver its prod- ucts or services to its customers.

--- Chunk 330 ---
Tokens: 348
Type: sentence-based
Text:
The current and expected business requirements for services should be understood in terms of what the business needs in order to deliver its prod- ucts or services to its customers. Business pre- dictions and workload estimates should be translated into specific requirements and doc- umented. The reaction to variations in work- load or environment should be predictable; data on current and previous components, as well as resource utilization at an appropriate level, should be captured and analyzed to sup- port the process. Capacity management is the focal point for all performance and capacity issues. The process should directly support the develop- ment of new and changed services by sizing and modeling these services. A capacity plan documenting the actual performance of the infrastructure and the expected requirements should be produced at a suitable frequency (at least annually), considering the rate of change in services and service volumes, informa- tion in the change management reports, and changing customer business requirements. The capacity plan should document costed options for meeting business requirements and recommend solutions to ensure achieve- ment of the agreed-upon service-level targets as defined in the SLA. The technical infra- structure and its current and projected capac- ities should be well understood to ensure optimal software operations. 2.5.

--- Chunk 331 ---
Tokens: 381
Type: sentence-based
Text:
2.5. Software Backup, Disaster Recovery, and Failover 1, c6s6.3.4 ISOIECIEEE 20000-1 also proposes that the following should be quickly available following a major service failure or disaster to ensure continuity planning and testing: backups of data, documents and software, and any equipment or staff necessary for ser- vice restoration. Backup and data recovery are important activities; successful recovery is especially vital. The need for successful recovery should influence which backup and SOFTWARE ENGINEERING OPERATIONS 6-9 recovery methods are used (full or incre- mental), how frequently restore points are established, where they are stored, and how long they are retained. Preparedness and regular test of backup, disaster recovery, and failover should be con- stantly rehearsed as changes to the produc- tion environment are made. This is another essential activity that is triggered when outage assessments are done. Testing disaster recovery requires stopping the service, identifying the checkpoint state and triggering the failover process. Software engineers should under- stand that failure is inevitable and that auto- mated failover daemons can reduce recovery time drastically. To achieve this, software applications should include failure-handling logic; this must be planned during develop- ment. DevOps can help organizations that want to reduce failovers and disasters by auto- mating and launching tests as often as possible to ensure readiness in case of a failure or cata- strophic event. 2.6.

--- Chunk 332 ---
Tokens: 372
Type: sentence-based
Text:
2.6. Software and Data Safety, Security, Integrity, Protection, and Controls 1, c6.s6.6 The need to manage information secu- rity effectively within all service activities is described in ISOIECIEEE 20000-1. This is done by conducting a software risk assess- ment on the security and availability of infor- mation. Operations engineers should strive to enforce the following controls: a. Senior management should define their information security policy, communi- cate it to staff and customers, and act to ensure its effective implementation, b. Information security management roles and responsibilities should be defined and allocated to post holders, c. A representative of the management team should be assigned the role of monitoring and maintaining the effectiveness of the information security policy, d. Staff with significant security roles should receive information security training, e. All staff should be made aware of the information security policy, f. Expert help on risk assessment and con- trol implementation should be available, g. Changes should not compromise the effective operation of controls, and  Information security incidents should be reported following incident manage- ment procedures, and a response should be initiated. In line with the evolution of DevOps, DevSecOps is promoting the integration of security early and throughout the soft- ware process, which includes the integra- tion of different security mechanisms and tools at the operations level.

--- Chunk 333 ---
Tokens: 380
Type: sentence-based
Text:
In line with the evolution of DevOps, DevSecOps is promoting the integration of security early and throughout the soft- ware process, which includes the integra- tion of different security mechanisms and tools at the operations level. The goal is to automate the detection and correction of security issues as early as possible in the overall process. 3. Software Engineering Operations Delivery This topic introduces some of the gener- ally accepted processes used during software engineering operations delivery (ISOIEC IEEE 20000-1): SLA, service reporting, service continuity, availability management, budgeting and accounting for IT services, capacity management, and information secu- rity management. 3.1. Operational Testing, Verification, and Acceptance 2,c10 3, c6s6.3.5.3d Software engineers plan and execute soft- ware verification as early as possible, using test-driven development (TDD) and accep- tance test-driven development (ATDD) techniques and tools that ensure that opera- tional testing is ongoing during the develop- ment of the software, not only at the end of a project. DevOps plays an important role in developing and automating software testing services and integrating different tools to boost software productivity and quality. (See TDD and ATDD in the Software Testing KA.) 6-10 SWEBOK  GUIDE V4.0 3.2. DeploymentRelease Engineering 2,c123,c6s6.3.5.3d A software operations engineers main responsibility relates to the deployment and release of software to ensure its continued performance.

--- Chunk 334 ---
Tokens: 334
Type: sentence-based
Text:
DeploymentRelease Engineering 2,c123,c6s6.3.5.3d A software operations engineers main responsibility relates to the deployment and release of software to ensure its continued performance. As defined in 2, deploy- ment is the installation of a specified ver- sion of software to a given environment (e.g, deploying code into an integration test envi- ronment or deploying code in production), whereas release is when we make a feature (or set of features) available to all our cus- tomers or a segment of customers (e.g, we enable the feature to be used by 5 of our customer base). Release processes include all the activities related to release management. ISOIECIEEE 12207 3 lists release con- trol activities and explains the need to iden- tify and record release requests, identify the software system elements in a release fol- lowed by approval, and track the releases in their specified environments. DevOps advocates integrating develop- ment and operations in the same team to improve software engineering operations efficiency. In traditional software processes, when an application is ready for deployment, it is transferred from a development team to an operations team that is responsible for deployment, which is mostly done manually. This results in processes that are inefficient from both a time and a quality perspective.

--- Chunk 335 ---
Tokens: 368
Type: sentence-based
Text:
This results in processes that are inefficient from both a time and a quality perspective. To improve the efficiency of the deployment process, DevOps calls for automating the different deployment steps, including pack- aging the code, generating configuration files, restarting the servers, configuring the servers and databases, installing the soft- ware on the different servers, launching the execution of the application, and executing smoke testing. Different release engineering strate- gies can be used to reduce the risks asso- ciated with software releases. These strategies can be grouped into two main cat- egories: environment-based release strate- gies and application-based release strategies. Environment-based release strategies use a staging environment to support the release of a new version of an application. In other words, the basic strategy involves deploying the new version of the application to a staging environment. Application-based release strat- egies are based on the use of toggles (e.g, fea- ture toggles) that make it possible to enable or disable specific sections of the code (e.g, a feature) using configuration parameters. Deployment and release are supported by automation techniques and tools. The canary release testing technique is a partial and time-limited deployment of a change in a service and an evaluation of that change. This evaluation helps the operations engi- neer decide whether to proceed with a complete deployment.

--- Chunk 336 ---
Tokens: 382
Type: sentence-based
Text:
This evaluation helps the operations engi- neer decide whether to proceed with a complete deployment. Similarly, tools that manage the installation of new software typ- ically observe the newly started server for a while, ensuring that the server doesnt crash or otherwise misbehave. The same tech- nique is useful for observing recent changes; if they do not pass the validation period, they can be automatically rolled back. The Software Configuration Management KA provides more information about the release processes. Once the application platform is deployed in the targeted production envi- ronment, the decision to make it available to the users (release it) becomes a busi- ness decision. 3.3. Rollback and Data Migration 2, c123, c6s6.4.10.3 Rollback and data migration are terms used to describe the process of returning software and its database to a state where they work prop- erly. Software engineers ensure that when a new version of the software and its data- bases have been modified and deployed to production, they can easily and quickly be rolled back in case the new version is causing defects or product degradation in production. This means a planned and rehearsed rollback is done before a new version of the software is deployed in production. DevOps processes automate this process to make it faster; in fact, the automated surveillance can trigger SOFTWARE ENGINEERING OPERATIONS 6-11 rollback and data migration to a previous state so quickly that the end user doesnt notice that there was a problem.

--- Chunk 337 ---
Tokens: 376
Type: sentence-based
Text:
DevOps processes automate this process to make it faster; in fact, the automated surveillance can trigger SOFTWARE ENGINEERING OPERATIONS 6-11 rollback and data migration to a previous state so quickly that the end user doesnt notice that there was a problem. Both release strategy categories (described in section 3.2)  envi- ronment-based release and application-based release  can be used to support rollback. 3.4. Change Management 1, c9s9.2 This operations process ensures that all changes are assessed, approved, implemented and reviewed in a controlled manner. All change requests are recorded and classified (e.g, emergency, urgent, major and minor). This process assesses the risk of a change and the need for a rollback strategy in case of failure. Large systems might require that a change schedule be planned with the product manager and end users. Whereas in traditional software delivery processes (or software life cycle models), all changes are delivered as part of new soft- ware releases (containing multiple changes related to different aspects of the application or system) issued at fixed time intervals (e.g, every three months), DevOps aims to deliver small units of change (a single new function- ality or service, or defect fix, rather than a new version of an application containing mul- tiple changes) on demand and independently from each other. For this purpose, software applications (or services) must be archi- tected to enable small, independent software deployments. 3.5.

--- Chunk 338 ---
Tokens: 358
Type: sentence-based
Text:
3.5. Problem Management 1, c8s8.3 The objective of this operations process is to minimize disruption to the business through the identification and analysis of the cause of software and system incidents and prob- lems. This approach may require the involve- ment of a multidisciplinary team, whose software engineers and operations engineers investigate, for example, recurring produc- tion problems that might have an underlying cause in software infrastructure and system components. This might require monitoring, logging and profiling the software and its infrastructure behavior. 4. Software Engineering Operations Control This topic introduces some generally accepted techniques used in software engineering operations control. 4.1. Incident Management 1, c8s8.2 Incident management is the process of recording, prioritizing and assessing the busi- ness impact, resolution, escalation and closure of software incidents. The modern DevOps approach automates software surveillance using alerts and logs to prevent minor incidents from becoming major incidents. When an inci- dent occurs, proper analysis andor post mor- tems must be conducted to find the source of the incident and appropriate solutions must be implemented to prevent similar incidents to happen again in the future. 4.2. Monitor, Measure, Track, and Review 2, c14-15 Software engineering operations activi- ties monitor capacity, continuity and avail- ability.

--- Chunk 339 ---
Tokens: 370
Type: sentence-based
Text:
Monitor, Measure, Track, and Review 2, c14-15 Software engineering operations activi- ties monitor capacity, continuity and avail- ability. In a DevOps mindset, hope should not be a strategy; instead, engineers should be informed about system quality and operational health with evidence, such as the following key performance indicators (KPI), which are available to stakeholders in real time:  Production systems monitoring and product telemetry,  Actionable verification and valida- tion results before and after release to production,  End-user activity and resource use,  Impact analysis results,  Inter- and intra-related dependencies required for system operation,  Configuration changes unrelated to approved deployment tasks, and  Security and resilience performance capability. 6-12 SWEBOK  GUIDE V4.0 4.3. Operations Support 1, c6, c14s5 ISOIECIEEE 12207 3, ISOIEC IEEE 20000-1 1 and ISOIECIEEE 32675 4 identify the primary software engineering operations activities that sup- port the operations processes  activi- ties that operate the software product in its intended environment  and the primary activities that provide support to the cus- tomers of the software products. Operations support activities are initiated at the plan- ning stage of the project and are then exe- cuted, which often requires techniques and tools to proactively monitor the product and services and react quickly to events and incidents. Support activities are often described in SLAs. 4.4.

--- Chunk 340 ---
Tokens: 388
Type: sentence-based
Text:
4.4. Operations Service Reporting 1,c6s6.2 Service reporting aims to produce agreed- upon, timely, reliable and accurate informa- tion for decision-making. Each service report helps demonstrate how an operations ser- vice has performed and whether it has met some stated and agreed-upon end-user objec- tive. Typical service reports address perfor- mance against service-level targets, as well as security breaches, the volume of transac- tions and resource use, incidents and failures, trend information, and satisfaction analysis. Operations engineers need to establish auto- mated systems and tools for measurement to do the following:  Determine whether measures are already available or additional instrumentation for collection, analysis and reporting is needed,  Select or develop a framework and tools to allow coordination of measurement col- lection for analysis, reporting and control. 5. Practical Considerations This topic introduces practical considerations for software engineering operations. 5.1. Incident and Problem Prevention 2, c7 The overall operations process needs to be automated as much as possible to prevent inci- dents and problems, and automated testing needs to be integrated throughout the process. Also, product telemetry should be imple- mented with proper analytics techniques to detect problems as early as possible to prevent incidents. For this purpose, data collected at all layers of the product stack (including application layer, operating system layer and infrastructure layer) must be collected and analyzed.

--- Chunk 341 ---
Tokens: 312
Type: sentence-based
Text:
For this purpose, data collected at all layers of the product stack (including application layer, operating system layer and infrastructure layer) must be collected and analyzed. Using product telemetry not only allows engineers to detect potential issues but also provides the foundation for identifying the source of the problem. 5.2. Operational Risk Management 3, c6s6.4.12.3c4 Operations engineers must manage a number of risks. IEEE 2675 4 defines continuous risk management as a continuous process that can be automated to monitor operations con- stantly for risks that can affect software avail- ability, scalability and security. Operations engineers can take measures to automate the alerts. To decide what events will trigger an alert, they need to talk with product owners and software engineers to establish an agreed-upon level of risk tolerance. Other perspectives are to choose the deployment process that is appropriate for the risk profile of a given service and the risks of exposing private data. 5.3. Automating Software Engineering Operations 2, c8 Automation has taken an important place in recent years in modern operations. Software engineers achieve the best results when cou- pling applications and operations automation.

--- Chunk 342 ---
Tokens: 388
Type: sentence-based
Text:
Software engineers achieve the best results when cou- pling applications and operations automation. Although automation primarily focuses on managing the life cycle of a system or infra- structure (e.g, user account creation, envi- ronments and server provisioning, runtime SOFTWARE ENGINEERING OPERATIONS 6-13 config changes), it can also be useful in other use cases where services can be developed to help software engineers deploy, test and debug during development. Trends in oper- ations automation aim to reduce complexity, accelerate provisioning of infrastructure, offer operations services scripts to developers, define applications, automate deployment and test workflows. 5.4. Software Engineering Operations for Small Organizations Very small organizations (organizations of up to 25 people) have difficulty applying stan- dards developed by and for large organiza- tions, as their requirements can overwhelm the capabilities of small organizations. This is where the ISOIEC 29110 series of stan- dards is useful, as it provides standards and guidelines adapted to very small organizations to ensure the quality of their software engi- neering operations 7. Software engineers should be aware that operations processes can be adapted to small organizations and that the ISOIEC CD 29110-5-5 is currently under development for this purpose. 6. Software Engineering Operations Tools 1, c5s5g2, c12 This topic encompasses tools that are par- ticularly important in software engineering operations for maximizing the efficient use of personnel.

--- Chunk 343 ---
Tokens: 363
Type: sentence-based
Text:
Software Engineering Operations Tools 1, c5s5g2, c12 This topic encompasses tools that are par- ticularly important in software engineering operations for maximizing the efficient use of personnel. Automating development, maintenance and operations-related tasks saves engineering resources and improves quality and turnaround. When imple- mented appropriately, such automated tasks are generally faster, easier and more reliable than they would be if they were attempted manually by software engineers and oper- ations engineers. DevOps supports such automation for integrating, building, pack- aging, configuring, and deploying reliable and secure systems. It combines devel- opment, maintenance, and operations resources and procedures to perform CI, delivery, testing and deployment. Continuous delivery (CD) is a software engineering practice that uses automated tools to provide frequent releases of new sys- tems (including software) to staging or var- ious test environments. CD continuously assembles the latest code and configuration from the head into release candidates. Continuous testing is a software testing practice that involves testing the software at every stage of the software development life cycle. Continuous testing aims to evaluate the quality of software at every step of the CD process by testing early and often. Continuous testing involves various stakeholders, such as developers, DevOps personnel, and QA and end-users.

--- Chunk 344 ---
Tokens: 366
Type: sentence-based
Text:
Continuous testing involves various stakeholders, such as developers, DevOps personnel, and QA and end-users. Continuous deployment (aka CD) is an auto- mated process of deploying changes to pro- duction by verifying intended features and validations to reduce risk. Jez Humble and David Farley 8 pointed out that the biggest risk to any software effort is that you end up building something that isnt useful. The ear- lier and more frequently you get working soft- ware in front of real users, the quicker you get feedback to find out how valuable it really is. 6.1. Containers and Virtualization Different containervirtualization technol- ogies and management tools (also called orchestrators) are available to operations engineers to improve the scalability of appli- cations and standardize software deployment across multiple computer and server suppliers. 4, c6,s6.4.12 Operations engineers use their knowledge of the size and complexity of each project to identify the best tool for flexibility, security and monitoring. 6.2. Deployment 2, c12 Different technologies and tools can be used to manage software deployments in different environments. 4, c5s5.1 Also, different tools are usually combined to cover the different phases and aspects of software deployment, ranging from the specification of deployment and configuration using descriptor files to the 6-14 SWEBOK  GUIDE V4.0 automated deployment and management of production environment resources. 6.3.

--- Chunk 345 ---
Tokens: 400
Type: sentence-based
Text:
6.3. Automated Test 2, c10 To enable fast and constant feedback to the developers, testing must be automated as much as possible throughout the entire soft- ware delivery process, including throughout development and operations. For this pur- pose, a testing strategy covering the different types of test (unit test, integration test, system test, user acceptance test) must be defined, and tools to support and automate the different testing phases must be selected. The automa- tion of testing is critical to provide continuous feedback to software engineers developing code and thereby to improve software quality. 6.4. Monitoring and Telemetry 2, c14-15 Monitoring and telemetry are key aspects of software engineering operations. They collect data at all layers of the software system (including application, operating system and server) and extract information that can be used to analyze and monitor different aspects of the system to detect issues and follow the evolution of various properties. James Turnbull 9 describes a general monitoring framework architecture used by engineering operations in many technology organizations. Implementing monitoring solutions requires combining different techniques and tools to collect data at different layers. This includes logs at the application level, execution traces at the operating system level and resource use information (like CPU and memory use) at the server level. Then, based on the col- lected data, different analytics techniques (e.g, statistical analysis and machine learning techniques) can be used to extract relevant information.

--- Chunk 346 ---
Tokens: 400
Type: sentence-based
Text:
Then, based on the col- lected data, different analytics techniques (e.g, statistical analysis and machine learning techniques) can be used to extract relevant information. Finally, dashboards can be used to visualize the extracted information; dif- ferent dashboards can be developed to display relevant information to different stakeholders. MATRIX OF TOPICS VS. REFERENCE MATERIAL ISO 20000-1 1 The DevOps Handbook 2 ISO 12207 3 1. Software Engineering Operations Fundamentals 1.1. Definition of Software Engineering Operations c3s3.3 c6s6.4.12 1.2. Software Engineering Operations Processes s1 c6 s6.4.12 1.3. Software Installation c3, c6s2 c3s3.1 1.4. Scripting and Automating c9 1.5. Effective Testing and Troubleshooting c3 1.6. Performance, Reliability and Load Balancing c6s6.2 2. Software Engineering Operations Planning 2.1. Operations Plan and Supplier Management c4s4.1 c6s6.1 2.2. Development and Operational Environments c9 SOFTWARE ENGINEERING OPERATIONS 6-15 2.3. Software Availability, Continuity and Service Levels c6s6.3 2.4. Software Capacity Management c6s6.5 2.5. Software Backup, Disaster Recovery and Failover c6s6.3.4 2.6. Software and Data Safety, Security, Integrity, Protection and Controls c6s6.6 3. Software Engineering Operations Delivery 3.1. Operational Testing, Verification and Acceptance c10 c6s6.3.5.3d 3.2. DeploymentRelease Engineering c12 3.3. Rollback and Data Migration 3.4. Change Management c9s9.2 3.5. Problem Management c8s8.3 4. Software Engineering Operations Control 4.1. Incident Management c8s8.2 4.2. Monitor, Measure, Track and Review c14-15 4.3.

--- Chunk 347 ---
Tokens: 395
Type: sentence-based
Text:
Monitor, Measure, Track and Review c14-15 4.3. Operations Support c6, c14s5 4.4. Operations Service Reporting c6s6.2 5. Practical Considerations 5.1. Incident and Problem Prevention c7 5.2. Operational Risk Management c6s6.4.12.3c4 5.3. Automating Software Engineering Operations c8 5.4. Software Engineering Operations for Small Organizations 6. Software Engineering Operations Tools c5s5g c12 6.1. Containers and Virtualization 6.2. Deployment c12 6.3. Automated Test c10 6.4. Monitoring and Telemetry c14-15 REFERENCES 1 IEEE standard, ISOIECIEEE 20000- 1:2013, Information technology  Service management  Part 1: Service management systems requirements, ed. IEEE, 2013. 2 G. Kim, J. Humble, J. Debois, J. Willis, and N. Forsgren, The DevOps 6-16 SWEBOK  GUIDE V4.0 Handbook: How to create world-class agility, reliability and security in tech- nology organizations, 2nd ed, IT Revolution Press, 2021. 3 IEEE standard, ISOIECIEEE 12207:2017, Systems and software engineering  Software Life Cycle Processes, ed. IEEE, 2017. 4 IEEE standard, ISOIECIEEE 32675:2022, Information Technology  DevOps: Building Reliable and Secure Systems Including Application Build, Package and Deployment, ed. IEEE, 2022. 5 ISOIECIEEE, ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, 2nd ed. 2017 6 B. Beyer, C. Jones, J. Petoff, and N.R. Murphy, Site Reliability Engineering  How Google Runs Production Systems, OReilly Media, 2016. 7 ISOIEC CD 29110-5-5:2023, Systems and software engineering  Lifecycle profiles for Very Small Entities (VSEs), Part 5-5: AgileDevOps guidelines.

--- Chunk 348 ---
Tokens: 380
Type: sentence-based
Text:
7 ISOIEC CD 29110-5-5:2023, Systems and software engineering  Lifecycle profiles for Very Small Entities (VSEs), Part 5-5: AgileDevOps guidelines. 8 J. Humble and D. Farley. Continuous delivery: reliable software releases through build, test, and deployment automation. Pearson Education, 2010. 9 J. Turnbull, The Art of Monitoring. James Turnbull, 2014. 7-1 CHAPTER 07 Software Maintenance ACRONYMS API Application Programming Interface CI Continuous Integration IEC The International Electrotechnical Commission IEEE The Institute of Electrical and Electronics Engineers ISO International Organization for Standardization KA Knowledge Area LOC Lines of Code MR Modification Request PR Problem Report SCM Software Configuration Management SEE Software Engineering Environment SLA Service-Level Agreement SLI Service-Level Indicators SLO Service-Level Objectives SQA Software Quality Assurance VV Verification and Validation XaaS Anything as a Service INTRODUCTION Successful software development efforts result in the delivery of a software product that satisfies user requirements. As those requirements and other factors change, the software product must evolve: Once the soft- ware is in operation, defects are uncovered, operating environments change, and new user requirements surface. The maintenance phase of the life cycle begins after a warranty period or after post-implementation support delivery, but maintenance activities occur much earlier. Software maintenance is an integral part of a software life cycle.

--- Chunk 349 ---
Tokens: 390
Type: sentence-based
Text:
Software maintenance is an integral part of a software life cycle. However, it has not received the same degree of attention as the other software engineering activities. Historically, software development has had a much higher profile than software mainte- nance. This is now changing as organizations strive to optimize their software engineering investment by ensuring continuous develop- ment, maintenance and operation, progres- sively eliminating the organizational silos among these areas. The growing acceptance of DevOps practices and tools have drawn further attention to the need to continuously evolve software while ensuring its smooth operation to satisfy users, who are demanding quicker turnaround from software engineers than in the past. In this SWEBOK Guide, software main- tenance is defined as the totality of activi- ties required to provide cost-effective support for software in operation. Activities to sup- port software operation and maintenance are performed during the pre delivery stage and during the post delivery stage. Pre delivery activities include planning for post delivery operations, maintainability and determining the logistics support needed for the tran- sition from development to maintenance. Postdelivery activities include software sur- veillance, modification, training, and oper- ating or interfacing with a help desk. The Software Maintenance knowledge area (KA) is related to all other aspects of software engineering. Therefore, this KA description is linked to all other software engineering KAs in the Guide.

--- Chunk 350 ---
Tokens: 390
Type: sentence-based
Text:
Therefore, this KA description is linked to all other software engineering KAs in the Guide. 7-2 SWEBOK  GUIDE V4.0 BREAKDOWN OF TOPICS FOR SOFTWARE MAINTENANCE The breakdown of topics for the Software Maintenance KA is shown in Figure 7.1. 1. Software Maintenance Fundamentals This section introduces the concepts and ter- minology that form a basis for understanding the role and scope of software maintenance. Among these concepts are the different cat- egories of software maintenance. Learning about these categories is critical to under- standing what this knowledge area encom- passes and why it is so important. 1.1. Definitions and Terminology 1, s3.12, c1s1.2, c2s2,2 The purpose of software maintenance is defined in the international standard for soft- ware maintenance: ISOIECIEEE 14764 1. In the context of software engineering, software maintenance is essentially one of many technical processes. The objective of software maintenance is to modify existing software while preserving its integrity. The international standard also emphasizes the importance of performing some maintenance activities before final delivery of the software (pre delivery activities). Software mainte- nance shares knowledge and tools with soft- ware development and software operation and also has its own processes and techniques. 1.2. Nature of Software Maintenance 2, c1s1.3 Software maintenance sustains the soft- ware product throughout its life cycle (from development through operations). The soft- ware is monitored for capacity, continuity and availability.

--- Chunk 351 ---
Tokens: 388
Type: sentence-based
Text:
The soft- ware is monitored for capacity, continuity and availability. Modification requests (MRs) and incidents or problems reports (PRs) are logged and tracked, the impact of proposed changes is determined, code and other software artifacts are modified, testing is conducted, and a new version of the soft- ware product is released into operation. Also, training and daily ongoing support are provided to users. A software maintainer is defined as a role or an organization that performs software maintenance activities. Software Maintenance Denitions and Terminology Technical Issues Management Issuess Software Maintenance Cost Software Maintenance Measurements Nature of Software Maintenance Need of Software Maintenance Categories of Software Maintenance Evolution of Software Key Issues in Software Maintenance Software Maintenance Fundamentals Software Maintenance Processes Software Maintenance Processes Program Comprehension Software Reengineering Reverse Engineering CICD, Testing and Deployment Software Maintenance Activities and Tasks Software Maintenance Techniques Software Maintenance Tools Figure 7.1. Breakdown of Topics for the Software Maintenance KA SOFTWARE MAINTENANCE 7-3 In this KA, the term sometimes refers to individuals who perform those activities, to contrast their role with the software devel- opers role. Maintainers can learn from the developers and operators knowledge of the software. Early contact with the developers and early involvement by the maintainers can reduce the overall maintenance costs and efforts.

--- Chunk 352 ---
Tokens: 385
Type: sentence-based
Text:
Early contact with the developers and early involvement by the maintainers can reduce the overall maintenance costs and efforts. An additional challenge is created when main- tainers join the project after the initial devel- opers have left or are no longer available. Maintainers must understand and use soft- ware artifacts from development (e.g, code, tests or documentation), support them imme- diately, and progressively evolve and maintain them over time. 1.3. Need for Software Maintenance 2, c1s1.5 Software maintenance is needed to ensure that the software continues to satisfy user require- ments throughout its life span. Maintenance is necessary regardless of the type of software life cycle model used to develop it (e.g, water- fall or Agile). Software products change as a result of both corrective and non-corrective actions. Software maintenance is typically performed to do the following:  Correct faults and latent defects  Improve the design or performance of operational software  Implement enhancements  Help users understand the softwares functionality  Adapt to changes in interfaced systems or infrastructure  Prevent security threats  Remediate technical obsolescence of system or software elements  Retire the software 1.4. Majority of Maintenance Costs 2, c4s4.3, c5s5.2 It is generally accepted that the relative cost of error fixing increases in later phases of the software life cycle. Maintenance also uses a significant portion of the total finan- cial resources attributed throughout the life of a software.

--- Chunk 353 ---
Tokens: 378
Type: sentence-based
Text:
Maintenance also uses a significant portion of the total finan- cial resources attributed throughout the life of a software. A common perception of soft- ware maintenance is that it merely fixes faults. However, studies and surveys over the years have indicated that most software mainte- nance  over 80  is used for enhancing and adapting the software 3. Grouping enhancements and corrections together in management reports contributes to a mis- conception that corrections cost more than they really do. Understanding the categories of software maintenance helps us understand the structure of software maintenance costs  that is, where most of that spending goes 7. Also, understanding the factors that affect the maintainability of software can help orga- nizations contain costs. Environmental fac- tors that affect software maintenance costs include the following:  Operating environment (hardware and software). Organizational environment (poli- cies, competition, process, product and personnel). 1.5. Evolution of Software 2, c3s3.5 Software maintenance as an activity that supports the evolution of software was first addressed in the late 1960s. Research, by Lehman and others 8, over a period of twenty years led to the formulation of eight laws of software evolution:  Continuing Change  Software must be continually adapted, or it becomes pro- gressively less satisfactory. Increasing Complexity  As software evolves, its complexity increases unless work is done to maintain or reduce that complexity.

--- Chunk 354 ---
Tokens: 364
Type: sentence-based
Text:
Increasing Complexity  As software evolves, its complexity increases unless work is done to maintain or reduce that complexity. Self-Regulation  The program evolu- tion process is self regulating with close to normal distribution of measures of product and process attributes. 7-4 SWEBOK  GUIDE V4.0  Invariant Work Rate  The average effective global activity rate in an evolving software package is invariant over the products lifetime. Conservation of Familiarity  As soft- ware evolves, all associated with it (e.g, developers, sales personnel and users) must maintain mastery of its content and behavior to achieve satisfactory evolution. Excessive growth diminishes that mas- tery. Hence, average incremental growth remains invariant as the system evolves. Continuing Growth  Functional con- tent of a program must be continually increased to maintain user satisfaction over its lifetime. Declining Quality  The quality of soft- ware will appear to be declining unless it is rigorously maintained and adapted to changes in the operational environment. Feedback System  Software evolution processes constitute multilevel, multi- loop, multi-agent feedback systems and must be treated as such to achieve sig- nificant improvement over any rea- sonable base. Key findings of Lehmans research include a proposal that maintenance is evolutionary development and that maintenance decisions are aided by an understanding of what hap- pens to software over time.

--- Chunk 355 ---
Tokens: 396
Type: sentence-based
Text:
Key findings of Lehmans research include a proposal that maintenance is evolutionary development and that maintenance decisions are aided by an understanding of what hap- pens to software over time. Another way to think of maintenance is as continued devel- opment that accommodates extra inputs (or constraints)  in other words, large software programs are never complete and continue to evolve. As they evolve, they grow more complex unless action is taken to reduce that complexity. 1.6. Categories of Software Maintenance 1, s3.1.82, c1s1.8, c3s3.3 Five categories (types) of software mainte- nance have been standardized to classify a maintenance request: corrective, preventive, adaptive, additive and perfective. ISOIEC IEEE 14764 1, regroups these maintenance categories as either corrections or enhance- ments, as shown in Figure 7.2. ISOIECIEEE 14764 1 also defines a sixth category  emergency maintenance:  Corrective maintenance: Reactive modi- fication (or repairs) of a software product performed after delivery to correct dis- covered problems. Preventive maintenance: Modification of a software product after delivery to cor- rect latent faults in the software product before they occur in the live system. Adaptive maintenance: Modification of a software product performed after delivery to keep a software product usable in an evolving environment. Adaptive mainte- nance provides enhancements necessary to accommodate changes in the environ- ment in which a software product operates (e.g, an upgrade to the operating system results in changes to the applications).

--- Chunk 356 ---
Tokens: 396
Type: sentence-based
Text:
Adaptive mainte- nance provides enhancements necessary to accommodate changes in the environ- ment in which a software product operates (e.g, an upgrade to the operating system results in changes to the applications). Additive maintenance: Modification of a software product performed after delivery to add functionality or features to enhance the usage of the product. Modication Request Correction Corrective Preventive Adaptive Additive Perfective Enhancement Figure 7.2. Software Maintenance Categories SOFTWARE MAINTENANCE 7-5 Additive maintenance differs from per- fective maintenance in that a) it provides additional new functions or features to improve software usability, performance, maintainability or other software quality attributes, and b) it adds functionality or features with relatively large additions or changes for improving software attri- butes after delivery. Perfective maintenance: Modification of a software product after delivery to pro- vide enhancements for users, improve- ment of program documentation, and recoding to improve software perfor- mance, maintainability, or other software attributes. Emergency maintenance: Unscheduled modification performed to temporarily keep a system operational, pending cor- rective maintenance. 2. Key Issues in Software Maintenance A number of key issues must be dealt with to ensure the effective maintenance of software. Software maintenance provides unique tech- nical and management challenges for soft- ware engineers (e.g,the challenge of finding a fault in large complex software developed by someone else.)

--- Chunk 357 ---
Tokens: 400
Type: sentence-based
Text:
Software maintenance provides unique tech- nical and management challenges for soft- ware engineers (e.g,the challenge of finding a fault in large complex software developed by someone else.) Similarly, in an Agile setting, maintainers and developers are constantly striving to make sure that clients see the value at the end of each iteration so maintenance activities have to compete with the development of new fea- tures for client approval; Planning for a future release, which often includes coding the next release while sending out emergency patches for the current release, also creates a challenge in balancing maintenance and development work. The following section presents tech- nical and management issues related to soft- ware maintenance. They are grouped under the following topics:  Technical issues. Management issues. Software maintenance costs. Software maintenance measurement. 2.1. Technical Issues 2.1.1 Limited Understanding 2, c6s6.9 Limited understanding describes a software engineers initial comprehension of software someone else developed. This is reflected in how quickly a software engineer can under- stand where to change or correct the soft- ware. Research suggests a significant portion of total maintenance effort is devoted to understanding the software to be modified. Consequently, the topic of software compre- hension is of great interest to software engi- neers. A number of comprehension factors have been identified: 1) domain knowledge; 2) programming practices (e.g, implementation issues); 3) documentation; and 4) organisation and presentation issues.

--- Chunk 358 ---
Tokens: 388
Type: sentence-based
Text:
A number of comprehension factors have been identified: 1) domain knowledge; 2) programming practices (e.g, implementation issues); 3) documentation; and 4) organisation and presentation issues. Comprehension is more difficult in text-oriented representation (e.g, in source code), where it is often difficult to trace the evolution of software through its releases or versions if changes are not docu- mented and the developers are not available to explain them. Thus, software engineers may initially have a limited understanding of the software, and much work must be done to remedy this. Various techniques can help engineers understand existing software, such as visualization and reverse engineering using tool-based graphical representations of the code. 2.1.2 Testing 1, s6.22, c9, c13s13.4.4 Test planning and activities occur during MRs and PRs processing. The cost of repeating full testing on a major piece of software is signifi- cant, in both time and effort. To ensure a soft- ware modification is validated, the maintainer should replicate or verify changes by planning and executing the appropriate tests  for example, regression testing is important in maintenance. Regression testing is the selec- tive retesting of software or a component to verify that the modifications have not caused unintended effects. Another challenge is 7-6 SWEBOK  GUIDE V4.0 finding the time to conduct as much testing as possible. Coordinating tests can be chal- lenging for maintenance team members who are simultaneously working on different prob- lems.

--- Chunk 359 ---
Tokens: 358
Type: sentence-based
Text:
Coordinating tests can be chal- lenging for maintenance team members who are simultaneously working on different prob- lems. Bringing software offline to test it can be difficult if the software performs critical functions. The Software Testing KA pro- vides additional information and references on software testing and its subtopic on regres- sion testing. 2.1.3 Impact Analysis 1, s5.1.62, c13s13.3 Impact analysis assesses the detailed effects of proposed changes on existing software. Software engineers should strive to con- duct the analysis as cost-effectively as pos- sible. Maintainers need detailed knowledge of the softwares structure and content. They use that knowledge to perform the impact analysis, which identifies all systems and software products that would be affected by a software change request and develops an estimate of the resources needed to accom- plish the change. The analysis also deter- mines the risks involved in making the change. The change request (originating from an MR or a PR), must first be analyzed and translated into software terms. Impact analysis is performed after a change request enters the software configuration man- agement (SCM) process. ISOIECIEEE 14764 1 states that the impact analysis tasks do the following:  Develop an identification scheme for MRsPRs. Develop a scheme for categorizing and prioritizing MRsPRs. Determine the procedures for an operator to submit an MRPR.

--- Chunk 360 ---
Tokens: 361
Type: sentence-based
Text:
Determine the procedures for an operator to submit an MRPR. Identify the information needs and issues that must be tracked and reported to the users and identify the measures that pro- vide feedback on those information needs and issues. Determine how temporary work-arounds will be provided to the operators. Track the work-around(s) through to removal. Determine what follow-up feedback will be provided to the users. Software maintainers often use the severity of a PR as a guide when deciding how and when to fix the problem. The maintainer con- ducts an impact analysis that identifies the affected components, develops several poten- tial solutions, and, finally, recommends a course of action. Impact analyses of proposed maintenance changes often consider various factors such as the maintenance category, the size of the mod- ification, the cost involved, the testing needed to make the modification, and any impacts on performance, safety and security. Designing software with maintainability in mind greatly facilitates impact analysis. More information can be found in the Software Configuration Management KA. 2.1.4 Maintainability 1, s8.82, c12s12.5.5 ISOIECIEEE 14764 1 defines main- tainability as the capability of the software product to be modified. Modifications can include corrections, improvements or adap- tation of the software to changes in environ- ment, as well as changes in requirements and functional specifications.

--- Chunk 361 ---
Tokens: 392
Type: sentence-based
Text:
Modifications can include corrections, improvements or adap- tation of the software to changes in environ- ment, as well as changes in requirements and functional specifications. As an important software quality char- acteristic, maintainability should be speci- fied, reviewed and controlled during software development activities in order to reduce maintenance costs. When these activities are carried out successfully, the softwares main- tainability will benefit. Maintainability is often difficult to achieve because it is often not a primary focus during software development. The developers are typically more focused on other activities and might not pay enough attention to maintainability requirements. This can result in bad architecturing, missing software documentation or test environments, which is a leading cause of difficulties in pro- gram comprehension and subsequent impact SOFTWARE MAINTENANCE 7-7 analysis during maintenance. The presence of systematic and mature software development processes, techniques and tools helps enhance the maintainability of software. The Software Quality KA provides additional information and references on software maintainability. Compromised software maintainability typically increases the burden on software engineers who maintain the software in the future; in other words, it creates technical debt. Technical debt often accumulates when the need to quickly address corrective, emer- gency, and additive maintenance tasks, con- strained by limited time and understanding of the software, leads to compromises.

--- Chunk 362 ---
Tokens: 384
Type: sentence-based
Text:
Technical debt often accumulates when the need to quickly address corrective, emer- gency, and additive maintenance tasks, con- strained by limited time and understanding of the software, leads to compromises. These immediate but potentially under-considered solutions, often not peer-reviewed, contribute to the accumulation of technical debt. This practice generally creates a technical debt that will take additional time and effort to address during maintenance. Specifically, software engineers must investigate three areas in depth when addressing technical debt: 1. Code quality versus relevance: Not all technical debt is urgent. 2. Alignment with organizational objec- tives: The software architecture should reflect the organizations goals. 3. Process loss: Ensure complementary skills of software engineers involved. 2.2. Management Issues 2.2.1. Alignment with Organizational Objectives 1, s9.1.82, c2s2.3.1.2, c3s3.4 This section describes how to optimizse soft- ware maintenance activities and economics to be aligned with organizational objectives and the priorities of the business, customers and users. In many organizations, initial software development is project-based, with a defined time scale and budget. The main goal is to deliver a product that meets user needs on time and within budget. In contrast, soft- ware maintenance aims to extend the life of software and keep it operational for as long as possible. In addition, it may be driven by the need to meet user demand for software updates and enhancements.

--- Chunk 363 ---
Tokens: 383
Type: sentence-based
Text:
In addition, it may be driven by the need to meet user demand for software updates and enhancements. In both cases, the economics of software maintenance is not as visible as those of soft- ware development. At the organizational level, it may be seen as an activity that con- sumes significant resources with no clear, quantifiable benefit for the organization. As a consequence, adding new features is often given higher priority than other maintenance activities (such as refactoring, security or per- formance improvement) to meet the goals and objectives of software customers, as well as with constraints such as time and budget. However, such organizational objectives and constraints must be balanced with software maintainability and engineering standards to avoid code decay and technical debt. Applying product management approaches to the management of software development and maintenance can help organizations:  Understand the total cost of operational software over its full life cycle. Compare the costs and benefits of devel- oping new software versus enhancing existing software. Resolve staffing and skills issues, as the same team can be responsible for mainte- nance and development. Focus more on maintainability require- ments from the start, as the same team has responsibility for both development and maintenance. 2.2.2. Staffing 1, s6.4.13.3c 2, c2s2.3.1.5, c10s10.4 Although maintenance work is sometimes perceived as less engaging, this view overlooks the critical importance of software main- tainers.

--- Chunk 364 ---
Tokens: 370
Type: sentence-based
Text:
Staffing 1, s6.4.13.3c 2, c2s2.3.1.5, c10s10.4 Although maintenance work is sometimes perceived as less engaging, this view overlooks the critical importance of software main- tainers. Given that maintenance constitutes a significant portion of software lifecycle activi- ties, recognizing and valuing the contribution of maintainers is essential to boosting morale, performance, and reducing staff turnover. 7-8 SWEBOK  GUIDE V4.0 Organizations need to design development and maintenance teams and roles carefully and provide professional development oppor- tunities for their staff. 2.2.3. Process 1, s62, c5 The software life cycle process is a set of activities, methods, practices and transforma- tions that people use to develop and maintain software and its associated products. At the process level, software maintenance activ- ities share much in common with software development (e.g, SCM is a crucial activity in both). Maintenance also requires several activities not found in software development. (Refer to section 3.2.) 2.2.4. Supplier Management 1, s6.1.2, s8.3, s8.8.2 Supplier management ensures that the orga- nizations suppliers and their performance are managed appropriately to support the seam- less provision of quality products and services when maintenance is contracted to suppliers. The nature of the organizations relation- ship with suppliers and its approach to sup- plier management should be determined by the nature of these products and services.

--- Chunk 365 ---
Tokens: 383
Type: sentence-based
Text:
The nature of the organizations relation- ship with suppliers and its approach to sup- plier management should be determined by the nature of these products and services. Contractors can be hired to conduct main- tenance tasks and outsourcing or offshoring software maintenance is a major industry. Outsourcing maintenance means substituting internal capability with an external suppliers capability. Approaches to contracting mainte- nance include the following:  Single source or partnership: A single sup- plier provides all services, or an external service integrator manages the organiza- tions relationship with all suppliers. Multi-sourcing: Products and services are provided by more than one inde- pendent supplier. These are combined into a single (software-enabled) service. Multi-sourcing in software services is increasingly common, enabled by the growth of anything as a service (XaaS), application programming interfaces (APIs), and data sources. Many organizations outsource entire port- folios of software. Typically, these portfolios include software that is not mission-critical, as organizations do not want to lose control of the software used in their core business. One major challenge for outsourcers is determining the scope of the maintenance services required, the terms of a service-level agreement (SLA), and the contractual details. Outsourcers need to invest in good communication infrastruc- ture and an efficient help desk staffed with people who can communicate effectively with customers and users 3.

--- Chunk 366 ---
Tokens: 399
Type: sentence-based
Text:
Outsourcers need to invest in good communication infrastruc- ture and an efficient help desk staffed with people who can communicate effectively with customers and users 3. Outsourcing requires a significant initial investment and the setup and review of software maintenance processes that require automation. 2.2.5. Organizational Aspects of Maintenance 1, s9.1.82, c10 Organizational aspects of maintenance include determining which teams will be responsible for software maintenance. When using Agile life cycle models, the developer also conducts maintenance tasks, acting as both developer and maintainer. Other organi- zations prefer that the team that develops the software does not necessarily maintain it once it is operational. In deciding where the soft- ware maintenance function will be located, software engineering organizations must con- sider each alternatives advantages and disad- vantages. There are a number of disadvantages to having the developer also maintain the software after it has been put into production, such as the risk that new development will be disrupted when the developers need to attend to failures and the potential loss of knowledge when developers leave the organization, since fewer individuals are familiar with the soft- ware; this could also lead to lower-quality doc- umentation, as fewer individuals are involved. However, having a separate maintenance function also has its challenges, as many soft- ware engineers do not like limiting their work to maintenance and may be more likely to SOFTWARE MAINTENANCE 7-9 leave for more interesting work.

--- Chunk 367 ---
Tokens: 388
Type: sentence-based
Text:
However, having a separate maintenance function also has its challenges, as many soft- ware engineers do not like limiting their work to maintenance and may be more likely to SOFTWARE MAINTENANCE 7-9 leave for more interesting work. In addition, a handoff process must be put in place between developers and maintainers, which sometimes leads to friction between teams 3. The introduction of product manage- ment processes has encouraged a single-team approach, particularly for developing and maintaining software that needs to respond rapidly to changes in customer and user needs. Because there are many pros and cons to each option, the decision should be made on a case- by-case basis. What is important is that the organization delegates the maintenance tasks to an experienced group or person and keeps quality documentation on maintenance tasks and all changes made to the software, regard- less of the organizations structure. 2.3. Software Maintenance Costs Software engineers must understand the dif- ferent categories of software maintenance described in 1.6. Presenting costs trends by categories of Maintenance can show cus- tomers where maintenance effort is spent for each system supported 7. The data about maintenance effort by category can be also used to accurately estimate the cost of software maintenance. Cost estimation is an important aspect of planning software maintenance. 2.3.1. Technical Debt Cost Estimation 1, s6.1.7, s8.8.3.62, c12.12.5 Technical debt generally makes code more expensive to maintain than it has to be.

--- Chunk 368 ---
Tokens: 374
Type: sentence-based
Text:
Technical Debt Cost Estimation 1, s6.1.7, s8.8.3.62, c12.12.5 Technical debt generally makes code more expensive to maintain than it has to be. Technical debt represents the effort required to fix problems that remain in the code when an application is initially released by the devel- opment team. Several techniques and indica- tors can help engineers measure technical debt, including, size, complexity and the number of engineering flaws and violations of good archi- tectural design and coding practices in the source code. ISOIECIEEE 14764 provides suggestions for improving maintainability, including: ensuring legibility, pursuing struc- tured code, reducing code complexity, provide accurate code comments, using identation and white space, eliminating language weaknesses and compiler dependent constructs, facilitate error-tracing, ensure traceability of code to design, conduct inspections and code reviews. A software product needs to evolve, by adding new features and capabilities, and its codebase must remain maintainable, easily understood, and easy to further evolve. A common barrier to addressing technical debt  or, indeed, of implementing any potential enhancement  is the uncertain reward for doing so. Thats why its so important for organizations to determine the following:  The quality of their current software. The current cost of their technical debt. The potential savings from investing in quality enhancement. The impact of current quality issues on their business.

--- Chunk 369 ---
Tokens: 394
Type: sentence-based
Text:
The impact of current quality issues on their business. Furthermore, technical debt is only one factor of several contributing to excess unplanned work; team or process issues may also need to be understood and addressed. Modern tooling can help detect such issues, which means tech- nical debt should not be handled in isolation but through an examination of its root causes. 2.3.2. Maintenance Cost Estimation 1, s6.2.2, s9.1.4, s9.1.9-10 2, c12s12.5.6 An estimate of software maintenance costs should be prepared early in the software plan- ning process 1, c6s1.4. The costs should be a function of the scope of maintenance activi- ties. ISOIECIEEE 14764 1, c7s2.4 iden- tified various factors that should be included, such as the following:  Travel to user locations. Training for maintainers as well as users. Cost and annual maintenance for the software engineering environment (SEE) and software testing. Personnel costs (e.g, salaries, benefits). Other resource costs, such as consumables. Software license maintenance costs. 7-10 SWEBOK  GUIDE V4.0  Product changes, program management. Field service engineers. Renting facilities for maintenance. Moreover, as the maintenance and devel- opment efforts progress, the estimates should be amended. Historical measurement data should be used as inputs to estimate main- tenance costs. Additionally, cost estimates are also required during impact analysis of individual MR or PR. The cost estimating method (e.g, parametric model, comparison to analog systems, use of empirical and his- torical data) should be described.

--- Chunk 370 ---
Tokens: 399
Type: sentence-based
Text:
The cost estimating method (e.g, parametric model, comparison to analog systems, use of empirical and his- torical data) should be described. Estimates of individual MRs or PRs typically include the estimated effort associated with executing a change, resource estimates and an estimated timeline for implementing the change. 2.4. Software Maintenance Measurement 1, s6.1.72, c12 Measurable software maintenance artifacts include maintenance processes, resources and products 2, c12s12.3.1. Measures include size, complexity, quality, understandability, maintainability and effort. One useful measure is the amount of effort (in terms of resources) expended for corrective, preventive, adaptive, additive and perfective maintenance. Complexity and technical debt measures of software can also be obtained using avail- able tools. These measures constitute a good starting point for the measurement of soft- ware quality. Maintainers should determine which measures are appropriate for a spe- cific organization based on that organiza- tions needs. Software measurement programs are discussed in the Software Engineering Management KA. The software quality model described in the Software Quality KA describes software product and process measures specific to soft- ware maintenance. Measurable characteristics of maintainability include the following:  Modularity measures the degree to which a system or software is composed of com- ponents that are independent, such that a change to one component has minimal impact on other components. Reusability measures how well a compo- nent can be reused.

--- Chunk 371 ---
Tokens: 396
Type: sentence-based
Text:
Reusability measures how well a compo- nent can be reused. Analyzability measures the effort or resources the maintainer must expend either to diagnose deficiencies or causes of failure or to identify components to be modified. Modifiability measures the maintain- ers effort associated with implementing a specified modification without intro- ducing defects or degrading existing product quality. Testability measures the effort main- tainers and users expend to test the mod- ified software. Supportability measures the ease with which support can be provided for the software, encompassing the availability and accessibility of documentation, tools, and assistance for addressing issues, facilitating effective maintenance and troubleshooting. Other measures that software maintainers use include the following:  Reliability: The degree to which a system or software performs specific functions under specified conditions for a spec- ified period, including the following characteristics: o Maturity: How well a system or soft- ware can meet the need for reliability. o Availability: Whether a system or soft- ware is operational and accessible. o Fault tolerance: How well a system or software operates despite hardware or software faults. o Recoverability: How well a system or software can recover data during an interruption or failure. Size of the software (e.g, functional size, LOC). Number of maintenance requests, by time period. SOFTWARE MAINTENANCE 7-11  Effort per maintenance request. Software characteristics (e.g, platform, hardware, programming language, frameworks).

--- Chunk 372 ---
Tokens: 388
Type: sentence-based
Text:
Software characteristics (e.g, platform, hardware, programming language, frameworks). Maintenance measures may be collected, analyzed and trended by category to facil- itate improvement and to provide insight into where maintenance costs are expended. The degree of software maintenance effort expended for different applications, listed by category, is valuable business informa- tion for users and their organizations. It can also enable the organization to make an internal comparison of software maintenance profiles 7. 3. Software Maintenance Processes In addition to standard software engineering processes and activities described in ISO IECIEEE 14764 1, a number of activities are unique to maintainers (refer to section 3.2). 3.1. Software Maintenance Processes 1, s5.22, c5 Maintenance processes provide needed activ- ities and detailed inputs and outputs to those activities, as described in ISOIECIEEE 14764 1. Maintenance is one of the technical life cycle processes presented in ISOIEC IEEE 12207 10. Figure 7.3 shows how main- tenance processes connect to other software engineering processes, which interact to sup- port operational software. The software main- tenance processes includes the following:  Prepare for maintenance. Perform maintenance. Perform logistics support. Manage results of maintenance and logistics. Recently, Agile methodologies, which pro- mote lightweight processes, have also been adapted to maintenance. This requirement has emerged from the ever-increasing demand for fast turnaround of maintenance services.

--- Chunk 373 ---
Tokens: 370
Type: sentence-based
Text:
This requirement has emerged from the ever-increasing demand for fast turnaround of maintenance services. Improvement to the software maintenance processes is supported by software mainte- nance maturity models 3. 3.2. Software Maintenance Activities and Tasks 1, s6.12, c6, c7 The maintenance process contains the activi- ties and tasks necessary to operate and modify an existing software system while preserving its integrity. These activities and tasks are the responsibility of the operator and the main- tainer. As already noted, many maintenance activities are similar to those of software development. Maintainers perform anal- ysis, design, coding, testing and documenta- tion. They must track requirements in their activities  just as in development  and update documentation as baselines change. Software Maintenance Process Prepare for Maintenance Perform Logistic Support Manage Results of Maintenance and Logistics Disposal Transition Operation Development Perform Maintenance Figure 7.3. Software Maintenance Processes (ISOIECIEEE 14764) 1 7-12 SWEBOK  GUIDE V4.0 ISOIECIEEE 14764 recommends that when a maintainer uses a development pro- cess, the process must be tailored to meet spe- cific needs. However, there are a number of processes, activities and practices that are specialized to software maintenance:  Program understanding: This comprises the activities needed to obtain a general knowledge of what a software product does and how the parts work together.

--- Chunk 374 ---
Tokens: 391
Type: sentence-based
Text:
However, there are a number of processes, activities and practices that are specialized to software maintenance:  Program understanding: This comprises the activities needed to obtain a general knowledge of what a software product does and how the parts work together. Transition: This is a controlled and coor- dinated sequence of activities during which software is transferred progres- sively from the developer to the opera- tions and maintenance team. MR acceptancerejection: Modifications requesting work greater than the agreed size, level of effort, or level of complexity may be rejected by maintainers and rerouted to a developer. Maintenance help desk: The help desk is an end-user and maintenance-coordi- nated support function that triggers the assessment, prioritization and costing of MRs and incidents. Impact analysis: The impact analysis identifies areas impacted by a poten- tial change. Maintenance service-level indicators (SLIs), service-level objectives (SLOs), SLAs, and maintenance software and hardware licenses and contracts: These are contractual agreements that describe the services and quality objectives of third parties. 3.2.1. Supporting and Monitoring Activities s6.4.13.3d5, s6.1.82, c3s3.4 Maintainers may also perform ongoing sup- port activities, such as documentation, SCM, verification and validation (VV), problem resolution, software quality assurance (SQA), reviews, vulnerability assessments, and audits. Another important management of mainte- nance results activity is that of monitoring customer satisfaction. 3.2.2.

--- Chunk 375 ---
Tokens: 396
Type: sentence-based
Text:
3.2.2. Planning Activities 1, s6.1.3, s8.7.22, c10 An important activity for software main- tenance is planning, and this process must address the issues associated with a number of planning perspectives, including the following:  Business planning (organizational level)  Maintenance planning (transition level). Releaseversion planning (software level). MR planning (at individual request level). At the individual request level, planning is carried out during the impact analysis. (See section 2.1.3, Impact Analysis.) The release version planning activity requires that the maintainer do the following:  Collect the dates of availability of indi- vidual requests. Agree with users on the content of sub- sequent releasesversions. Identify potential conflicts and develop alternatives. Assess the risk of a given release and develop a back-out plan in case problems arise  Inform all stakeholders. Whereas software development projects have a typical duration of months to a few years, the maintenance phase usually lasts until the software is retired by the disposal process. Estimating resources is a key element of main- tenance planning. Software maintenance plan- ning should begin with the decision to develop a new software product and should consider quality objectives. A concept document should be developed, followed by a maintenance plan, and these should address the following:  Scope of software maintenance. Adaptation of the software maintenance processes and tools. Identification of the software mainte- nance organization. Estimate of software maintenance costs.

--- Chunk 376 ---
Tokens: 375
Type: sentence-based
Text:
Estimate of software maintenance costs. SOFTWARE MAINTENANCE 7-13 A software maintenance plan should be prepared during software development and should specify how users will request mod- ifications and report problems or issues. Software maintenance planning is addressed in ISOIECIEEE 14764 1. Finally, at the highest level of management, the maintenance organization must conduct software mainte- nance business planning activities (e.g, com- munications, budgetary, financial and human resources activities). 2, c10 3.2.3. Configuration Management 1, s6.1.3c, s6.4.13.3d42, c11s11.3 ISOIECIEEE 14764 1 describes SCM as an enabling system or service to support the maintenance process. SCM procedures should provide for the verification, valida- tion and audit of each step required to iden- tify, authorize, implement and release the software product and its IT assets under- going change. It is not sufficient to track MRs or PRs only. Any change made to the software product and its underlying infrastructure must be controlled. This control is established by implementing and enforcing an approved SCM process. The SCM KA discusses SCM in more detail as well as the process by which change requests are submitted, evaluated and approved. SCM for software maintenance differs from SCM for software development in the number of small changes that must be controlled in the operational environment. The SCM process is implemented by devel- oping and following an SCM plan and oper- ating procedures.

--- Chunk 377 ---
Tokens: 396
Type: sentence-based
Text:
The SCM process is implemented by devel- oping and following an SCM plan and oper- ating procedures. Maintainers participate in configuration control boards to determine the content of the next release or version in production. 3.2.4. Software Quality 1, s6.1.6, s8.7.22, c13s13.4 It is not sufficient to simply hope that soft- ware maintenance will produce higher quality software. Maintainers should have an effec- tive quality program. They must implement processes to support the continuous improve- ment of software maintenance processes. The activities and techniques for SQA, VV, reviews, and audits must be selected in con- cert with all the other processes to achieve the desired level of quality. It is also recom- mended that both software operations and maintenance adapt and use the output of the software development process, its techniques and deliverables (e.g, test tools and documen- tation), and test results. More details about software quality can be found in the Software Quality KA. 4. Software Maintenance Techniques This topic introduces generally accepted tech- niques used in software maintenance. 4.1. Program Comprehension 2, c6, c14s14.5 Maintainers spend considerable time reading and understanding programs in order to implement changes. Code browsers are key tools for program comprehension and are used to organize and present source code. Clear and concise documentation also aids program comprehension. 4.2. Software Reengineering 2, c7 Software reengineering refers to the examina- tion and alteration of software to reconstitute it in a new form.

--- Chunk 378 ---
Tokens: 394
Type: sentence-based
Text:
Software Reengineering 2, c7 Software reengineering refers to the examina- tion and alteration of software to reconstitute it in a new form. It includes the subsequent implementation of the new form. It is often undertaken not to improve maintainability but to replace aging legacy software. Refactoring is a reengineering technique that aims to reorganize a program without changing its behavior. Refactoring seeks to improve the internal structure and the main- tainability of software. Refactoring tech- niques can be used during maintenance activities to reduce the technical debt of the codebase before and after code changes. In the context of Agile software develop- ment, the incremental nature of continuous 7-14 SWEBOK  GUIDE V4.0 integration (CI) often requires the code to be continuously refactored to augment its quality and reliability. Hence, continuous refactoring supports the volatile software life cycle by providing better ways to reduce and manage the growing complexity of soft- ware systems while improving developer productivity. 4.3. Reverse Engineering 2, c7, c14s14.5 Reverse engineering is the process of ana- lyzing software to identify the softwares components and their interrelationships and creating representations of the soft- ware in another form or at higher levels of abstraction. Reverse engineering is passive; it does not change the software or result in new software. Reverse engineering efforts typically produce graphical representations of different software artifacts, such as call graphs and control flow graphs from source code.

--- Chunk 379 ---
Tokens: 382
Type: sentence-based
Text:
Reverse engineering efforts typically produce graphical representations of different software artifacts, such as call graphs and control flow graphs from source code. Types of reverse engineering include the following:  Re-documentation. Design recovery. Data reverse engineering  recovering logical schemata from physical databases. Tools are key for reverse engineering and related tasks such as re-documentation and design recovery. Software visualization is a common reverse engineering technique that helps maintainers explore, analyze and understand the structure of software systems as well as their evolution. Software visual- ization comprises visually encoding and ana- lyzing software systems, including software maintenance practices, evolution, structure and software runtime behavior using infor- mation visualization, computer graphics and human-computer interaction. Generally, software visualization tools are accompanied by various quality assurance features, such as quality metrics calculation, technical debt estimation, and bad design and coding prac- tices (code smells) detection. 4.4. Continuous Integration, Delivery, Testing and Deployment 1, s6.4.13.3 Note 1 Automating development, operation and maintenance-related tasks saves engineering resources. When implemented appropriately, such automated tasks are generally faster, easier and more reliable than they would be if per- formed manually. ISO14764 states that auto- mation includes distribution and installation of software.1, s6.4.13.3 Note 1.

--- Chunk 380 ---
Tokens: 379
Type: sentence-based
Text:
ISO14764 states that auto- mation includes distribution and installation of software.1, s6.4.13.3 Note 1. DevOps supports such automation while building, packaging and deploying reliable and secure systems. DevOps combines development, operations, and main- tenance resources and procedures to perform CI, delivery, testing and deployment. 9 CI is a software engineering practice that continually merges artifacts, including source code updates from all members of a team, into a shared mainline for evolving and testing the developed system. With CI, the members of a team can integrate their changes frequently, and each integration can be verified by an automated build (including testing) to detect integration errors as quickly as possible. The fundamental goal of CI is to automatically catch problematic changes as early as pos- sible. CI helps guarantee the working state of a software system at various points from build to release, thereby improving confidence and quality in software products and improving productivity in teams. Specifically, CI auto- mates the build and release processes with continuous build, continuous delivery, contin- uous testing and continuous deployment. 6, c23, c24. Continuous delivery is a software engi- neering practice that enables frequent releases of new systems (including software) to staging or various test environments through the use of automated tools. Continuous delivery con- tinuously assembles the latest code and config- uration to create release candidates.

--- Chunk 381 ---
Tokens: 333
Type: sentence-based
Text:
Continuous delivery con- tinuously assembles the latest code and config- uration to create release candidates. Continuous testing is a software testing prac- tice that involves testing the software at every stage of the software development life cycle. The goal of continuous testing is to evaluate the quality of software at every step of the continuous delivery process by testing early SOFTWARE MAINTENANCE 7-15 and often. Continuous testing involves var- ious stakeholders such as developers, main- tainers, DevOps, SQA, and operational systems teams. Continuous deployment is an automated pro- cess of deploying changes to production by verifying intended features and validations to reduce risk. As Martin Fowler, in the book Continuous Delivery, pointed out, The biggest risk to any software effort is that you end up building something that isnt useful. The ear- lier and more frequently you get working soft- ware in front of real users, the quicker you get feedback to find out how valuable it really is. 4.5. Visualizing Maintenance Maintaining a clear understanding of soft- ware systems evolving structures and depen- dencies presents a challenge. Visualization is a valuable supporter in software maintenance management, offering a visual representation of the softwares components and helping it make informed decisions.

--- Chunk 382 ---
Tokens: 394
Type: sentence-based
Text:
Visualization is a valuable supporter in software maintenance management, offering a visual representation of the softwares components and helping it make informed decisions. With the increasing size and complexity of software systems, visual representations can support software mainte- nance by enabling dependency analysis, tracing a software evolution history, visualizing soft- ware runtime dynamics, and providing com- plementary documentation. Visualization represents an active research area that syner- gizes computational capabilities with human pattern detection abilities. It produces visual representations designed to enhance the main- tenance teams cognitive performance when faced with complex data analysis. 5. Software Maintenance Tools 1, c6s42, c14 This topic encompasses tools that are par- ticularly important in software maintenance where existing software is being modified. Maintenance tools are interrelated with development and operations tools. Together, they are part of the SEE. The following are examples of maintenance tools:  Configuration management, code ver- sioning and code review tools,  software testing tools,  Software quality assessment tools (to assess technical debt and code quality). Program slicers, which select only the parts of a program affected by a change. Static analyzers, which allow gen- eral viewing and summaries of pro- gram content. Dynamic analyzers, which allow the maintainer to trace the execution path of a program. Data flow analyzers, which allow the maintainer to track all possible data flows of a program.

--- Chunk 383 ---
Tokens: 398
Type: sentence-based
Text:
Data flow analyzers, which allow the maintainer to track all possible data flows of a program. Cross-referencers, which generate indexes of program components. Dependency analyzers, which help main- tainers analyze and understand the inter- relationships among components of a program. Remote Access tools, enabling main- tainers to diagnose and modify user sys- tems remotely, crucial for real-time issue resolution and seamless modifications across environments. Reverse engineering tools support the pro- cess by working backward from an existing product to create artifacts such as specifica- tion and design descriptions, which can then be transformed to generate a new product from an old one. Maintainers also use soft- ware tests, SCM, software documentation and software measurement tools. 7-16 SWEBOK  GUIDE V4.0 MATRIX OF TOPICS VS. REFERENCE MATERIAL ISOIECIEEE 14764 2022 1 Grubb and Takang 2003 2 1. Software Maintenance Fundamentals 1.1. Definitions and Terminology s3.1 c1s1.2, c2s2.2 1.2. Nature of Software Maintenance c1s1.3 1.3. Need for Software Maintenance c1s1.5 1.4. Majority of Maintenance Costs c4s4.3, c5s5.2 1.5. Evolution of Software c3s3.5 1.6. Categories of Software Maintenance s3.1.8 c1s1.8, c3s3.3 2. Key Issues in Software Maintenance 2.1. Technical Issues 2.1.1. Limited Understanding c6s6.9 2.1.2. Testing s6.2 c9, c13s13.4.4 2.1.3. Impact Analysis s5.1.6 c13s13.3 2.1.4. Maintainability s8.8 c12s12.5.5 2.2. Management Issues 2.2.1. Alignment with Organizational Objectives s9.1.8 c2s2.3.1.2, c3s3.4 2.2.2. Staffing s6.4.13.3c c2s2.3.1.5, c10s10.4 2.2.3.

--- Chunk 384 ---
Tokens: 368
Type: sentence-based
Text:
Staffing s6.4.13.3c c2s2.3.1.5, c10s10.4 2.2.3. Process s6 c5 2.2.4. Supplier Management s6.1.2, s8.3, s8.8.2 2.2.5. Organizational Aspects of Maintenance s9.1.8 c10 2.3. Maintenance Costs 2.3.1. Technical Debt Cost Estimation s6.1.7, s8.8.3.6 c12s12.5 2.3.2. Maintenance Costs Estimation s6.2.2, s9.1.4, s9.1.9-10 c12s12.5.6 2.4. Software Maintenance Measurement s6.1.7 c12 3. Software Maintenance Process 3.1. Software Maintenance Processes s5.2 c5 3.2. Software Maintenance Activities and Tasks s6.1 c6, c7 3.2.1. Supporting and Monitoring Activities s6.4.13.3d5, s6.1.8 c3s3.4 3.2.2. Planning Activities s6.1.3, s8.7.2 c10 3.2.3. Software Configuration Management s6.1.3c, s6.4.13.3d4 c11s11.3 3.2.4. Software Quality s6.1.6, s8.7.2 c13s13.4 4. Software Maintenance Techniques 4.1. Program Comprehension c6,c14s14.5 4.2. Software Reengineering c7 4.3. Reverse Engineering c7, c14s14.5 SOFTWARE MAINTENANCE 7-17 4.4. Continuous Integration, Delivery, Testing and Deployment s6.4.13.3 Note 1 4.5. Visualizing Maintenance 5. Software Maintenance Tools s4 c14 FURTHER READINGS A. April and A. Abran, Software Maintenance Management: Evaluation and Continuous Improvement 3. This book explores the domain of contin- uous software maintenance processes. It provides road maps for improving soft- ware maintenance processes in organiza- tions. It describes software maintenance practices organized by maturity levels, which allow for benchmarking and con- tinuous improvement.

--- Chunk 385 ---
Tokens: 387
Type: sentence-based
Text:
It describes software maintenance practices organized by maturity levels, which allow for benchmarking and con- tinuous improvement. Goals for each key practice area are provided, and the pro- cess model presented is fully aligned with the architecture and framework of inter- national standards ISO12207, ISO14764 and ISO15504, as well as models such as ITIL and CoBIT. IEEE std 2675-2021, IEEE Standard for DevOps: Building Reliable and Secure Systems Including Application Build, Package and Deployment 5. Technical principles and processes to build, package, and deploy systems and applica- tions in a reliable and secure way are speci- fied. Establishing effective compliance and information technology (IT) controls is the focus. DevOps principles presented include mission first, customer focus, shift-left, con- tinuous everything, and systems thinking. How stakeholders, including developers and operations staff, can collaborate and commu- nicate effectively is described. The process outcomes and activities herein are aligned with the process model specified in ISO IECIEEE 12207:2017 and ISOIECIEEE 15288:2015. REFERENCES 1 IEEE standard, ISOIECIEEE 14764 IEEE Std. 14764:2022, Software Engineering  Software Life Cycle Processes  Maintenance, third ed: 2022 01, 39p. 2 P. Grubb and A.A. Takang, Software Maintenance: Concepts and Practice, 2nd ed. River Edge, NJ: World Scientific Publishing, 2003. 3 A. April and A. Abran, Software Maintenance Management: Evaluation and Continuous Improvement. Wiley- IEEE Computer Society Press, 2008.

--- Chunk 386 ---
Tokens: 291
Type: sentence-based
Text:
Wiley- IEEE Computer Society Press, 2008. 4 C. Seybold and R. Keller, Aligning Software Maintenance to the Offshore Reality, 12th European Conference on Software Maintenance and Reengineering. April 1-4, 2008, Athens, Greece, DOI:10.1109 CSMR.2008.4493298. 5 IEEE standard, IEEE Std. 2675- 2021, IEEE Standard for DevOps: Building Reliable and Secure Systems Including Application Build, Package and Deployment, ed: IEEE. 2021. 6 W. Titus, T. Manshreck, and H. Wright. Software engineering at Google: Lessons learned from programming over time. OReilly Media, 2020. 7 A. Abran and H. Nguyenkim, Measurement of the maintenance pro- cess from a demand-based perspec- tive, Journal of Software Maintenance: 7-18 SWEBOK  GUIDE V4.0 Research and Practice, Vol. 5 Issue 2: 63-90, 1993. 8 Laws of software evolution revisited. European workshop on software process technology. Berlin, Heidelberg: Springer Berlin Heidelberg, 1996 9 J. Humble and D. Fairley, Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation, Addison-Wesley, 2010. 10 ISOIECIEEE 12207:2017 Systems and software engineering  Software life cycle processes, 2017.

--- Chunk 387 ---
Tokens: 370
Type: sentence-based
Text:
10 ISOIECIEEE 12207:2017 Systems and software engineering  Software life cycle processes, 2017. 8-1 CHAPTER 08 Software Configuration Management ACRONYMS CCB Configuration Control Board CI Configuration Item CM Configuration Management FCA Functional Configuration Audit PCA Physical Configuration Audit QA Quality Assurance SCCB Software Configuration Control Board SCI Software Configuration Item SCM Software Configuration Management SCMP Software Configuration Management Plan SCR Software Change Request SCSA Software Configuration Status Accounting CMMI Software Engineering Institutes Capability Maturity Model Integration SLCP Software Life Cycle Process SQA Software Quality Assurance VV Verification And Validation KA Knowledge Area MBX Model Based Experience SBOM Software Bill Of Materials CR Change Request VDD Version Description Document CMDB Configuration Management Database INTRODUCTION Software configuration management (SCM) is formally defined as the process of applying configuration management CM throughout the software life cycle to ensure the com- pleteness and correctness of CIs configura- tion items, with CM defined as a discipline applying technical and administrative direc- tion and surveillance to identify and document the functional and physical characteristics of a configuration item, control changes to those characteristics, record and report change pro- cessing and implementation status, and verify compliance with specified requirements 1.

--- Chunk 388 ---
Tokens: 397
Type: sentence-based
Text:
8-1 CHAPTER 08 Software Configuration Management ACRONYMS CCB Configuration Control Board CI Configuration Item CM Configuration Management FCA Functional Configuration Audit PCA Physical Configuration Audit QA Quality Assurance SCCB Software Configuration Control Board SCI Software Configuration Item SCM Software Configuration Management SCMP Software Configuration Management Plan SCR Software Change Request SCSA Software Configuration Status Accounting CMMI Software Engineering Institutes Capability Maturity Model Integration SLCP Software Life Cycle Process SQA Software Quality Assurance VV Verification And Validation KA Knowledge Area MBX Model Based Experience SBOM Software Bill Of Materials CR Change Request VDD Version Description Document CMDB Configuration Management Database INTRODUCTION Software configuration management (SCM) is formally defined as the process of applying configuration management CM throughout the software life cycle to ensure the com- pleteness and correctness of CIs configura- tion items, with CM defined as a discipline applying technical and administrative direc- tion and surveillance to identify and document the functional and physical characteristics of a configuration item, control changes to those characteristics, record and report change pro- cessing and implementation status, and verify compliance with specified requirements 1. SCM is a software life cycle process (SLCP) that supports project management, devel- opment and maintenance activities, quality assurance (QA) activities, and the customers and users of the end product.

--- Chunk 389 ---
Tokens: 397
Type: sentence-based
Text:
SCM is a software life cycle process (SLCP) that supports project management, devel- opment and maintenance activities, quality assurance (QA) activities, and the customers and users of the end product. The concepts of CM apply to all items controlled, although some differences exist between implementing hardware CM and implementing software CM. CM applies equally to iterative and incremental software development methodology. SCM is closely related to software quality assurance (SQA). As defined in the Software Quality knowledge area (KA), SQA processes ensure that the software products and pro- cesses in the project life cycle conform to their specified requirements by requiring software engineers to plan, enact and perform a set of activities that demonstrate that those specifica- tions are built into the software. SCM activi- ties support these SQA goals through software configuration activities (presented later in this chapter). The configuration audit activity can be described as a review of CIs and is closely related to the reviews defined in the quality plan. The SCM activities should operationalize SCM process management and planning, soft- ware configuration identification, software con- figuration change control, software configuration 8-2 SWEBOK  GUIDE V4.0 status accounting (SCSA), software configura- tion auditing, and software release management and delivery. This operationalization: 1. Determines what is expected to be under control during project development 2. Identifies and records who developed what CI as well as when and where it is allocated 3.

--- Chunk 390 ---
Tokens: 375
Type: sentence-based
Text:
Identifies and records who developed what CI as well as when and where it is allocated 3. Allows controlled changes 4. Tracks CIs relationships to show how changes that affect one CI might affect other CIs 5. Keeps CI versions under control 6. Ensures that the quality of the CIs delivered meets the requirements for intended use The SCM KA is related to all other KAs because SCMs object is the artifact produced and used throughout the software engi- neering process. BREAKDOWN OF TOPICS FOR SOFTWARE CONFIGURATION MANAGEMENT Figure 8.1 shows the breakdown of topics for the SCM KA. 1. Management of the SCM Process 2, c6, c7 SCM controls the evolution and integrity of a product by identifying its elements (known as CIs); managing and controlling change; and verifying, recording and reporting on configuration information. From the soft- ware engineers perspective, SCM facilitates development and change implementation activities. Successful SCM implementation requires careful planning and management, which requires a strong understanding of the organizational context for, and the con- straints placed on, the design and imple- mentation of the SCM process. The SCM plan can be developed once for the organi- zation and then adjusted as needed for indi- vidual projects. 1.1 Organizational Context for SCM 2, c6, ann. D 3, Introduction 4, c25 To plan an SCM process for a project, it is necessary to understand the organizational context and the relationships among orga- nizational elements.

--- Chunk 391 ---
Tokens: 398
Type: sentence-based
Text:
D 3, Introduction 4, c25 To plan an SCM process for a project, it is necessary to understand the organizational context and the relationships among orga- nizational elements. SCM interacts not just Software Conguration Management Organizational Context for SCM Constraints and Guidance for the SCM Process Planning for SCM Identifying Items to be Controlled Requesting, Evaluating and Approving Software Changes Software Conguration Status Information Software Conguration Status Reporting Software Functional Conguration Audit Software Physical Conguration Audit In-process Audits of a Software Baseline Software Building Software Release Management Implementing Software Changes Deviations and Waivers Software Conguration Control Board Software Change Request Process Software Change Request Forms Denition Conguration Item Identiers and Attributes Baselines Identication Baseline Attributes Relationships Scheme Denition Software Libraries Software Conguration Software Conguration Item SCM Organization and Responsibilities SCM Resources and Schedules Tool Selection and Implementation Vendor Subcontractor Control Interface Control SCM Plan Surveillance of Software Conguration Management SCM Measures and Measurement In-Process Audits of SCM Management of the SCM Process Software Conguration Identication Software Conguration Change Control Software Conguration Status Accounting Software Conguration Auditing Software Release Management and Delivery Software Conguration Management Tools Figure 8.1. Breakdown of Topics for the Software Configuration Management KA.

--- Chunk 392 ---
Tokens: 384
Type: sentence-based
Text:
Breakdown of Topics for the Software Configuration Management KA. SOFTWARE CONFIGURATION MANAGEMENT 8-3 with the particular project but also with sev- eral other areas of the organization. The organizational elements responsible for software engineering supporting pro- cesses might be structured in various ways. The overall responsibility for SCM often rests with a distinct part of the organization or with a designated individual. However, responsibility for certain SCM tasks might be assigned to other parts of the organization (such as the development division). Software is frequently developed as part of a larger system containing hardware and firmware elements. In this case, SCM activ- ities take place in parallel with hardware and firmware CM activities and must be con- sistent with system-level CM. Note that firmware contains hardware and software; therefore, both hardware and software CM concepts apply. SCM might interface with an organiza- tions QA activity on issues such as records management and nonconforming items. Regarding the former, project records subject to provisions of the organizations QA pro- gram might also be under SCM control. The QA team is usually responsible for managing nonconforming items. However, SCM might assist with tracking and reporting on software configuration items (SCIs) in this category. Perhaps the closest relationship is with the software development and maintenance organizations. It is within this context that many of the software configuration control tasks are conducted.

--- Chunk 393 ---
Tokens: 392
Type: sentence-based
Text:
It is within this context that many of the software configuration control tasks are conducted. Frequently, the same tools support development, maintenance, and SCM purposes. 1.2 Constraints and Guidance for the SCM Process 2, c6, ann. D, ann. E 3, c2, c5 5, c19s2.2 Constraints affecting, and guidance for, the SCM process come from many sources. Policies and procedures set forth at corporate or other organizational levels might influence or prescribe the design and implementation of the SCM process for a project. In addition, the contract between the acquirer and the supplier might contain provisions affecting the SCM process (e.g, certain configura- tion audits might be required, or the contract might specify that certain items be placed under CM). When the software to be devel- oped could affect public safety, external regu- latory bodies may impose constraints. Finally, the SLCP chosen for a software project and the level of formalism selected for imple- mentation will also affect SLCP design and implementation. Software engineers can also find guid- ance for designing and implementing an SCM process in best practice, as reflected in the software engineering standards issued by the various standards organizations. (See Appendix B for more information about these standards.) 1.3 Planning for SCM 2, c6, ann. D, ann. E 3, c23 4, c25 SCM process planning for a project should be consistent with the organizational context, applicable constraints, commonly accepted guidance and the nature of the project (e.g, size, safety criticality and security).

--- Chunk 394 ---
Tokens: 400
Type: sentence-based
Text:
E 3, c23 4, c25 SCM process planning for a project should be consistent with the organizational context, applicable constraints, commonly accepted guidance and the nature of the project (e.g, size, safety criticality and security). The major activities covered in the plan are software con- figuration identification, software configura- tion control, SCSA, software configuration auditing, and software release management and delivery. In addition, issues such as orga- nization and responsibilities, resources and schedules, tool selection and implementa- tion, vendor and subcontractor control, and interface control are typically considered. The planning activitys results are recorded in an SCM plan (SCMP), which is subject to SQA review and audit. Branching and merging strategies should be carefully planned and communicated because they affect many SCM activities. SCM defines a branch as a set of evolving source file versions 1. Merging consists of combining different changes to the same file 1. This typically occurs when more than one person changes a CI. There are many 8-4 SWEBOK  GUIDE V4.0 branching and merging strategies in common use. (See the Further Readings section for additional discussion.) The software development life cycle model chosen (see Software Life Cycle Models in the Software Engineering Process KA) also affects SCM activities, and SCM planning should consider this. For instance, many soft- ware development approaches use continuous integration, which is characterized by fre- quent build-test-deploy cycles. Clearly, SCM activities must be planned accordingly.

--- Chunk 395 ---
Tokens: 395
Type: sentence-based
Text:
Clearly, SCM activities must be planned accordingly. 1.3.1 SCM Organization and Responsibilities 2, ann. Ds5-6 3, c10-11 4, c25 Organizational roles must be clearly identi- fied to prevent confusion about who will per- form specific SCM activities or tasks. These responsibilities must also be assigned to orga- nizational entities; this can be made clear by the responsible individuals title or by des- ignating the organizational division or sec- tion in addition to the individual responsible within that section. The overall authority and reporting channels for SCM should also be identified, although this might be accom- plished at the project management or the QA planning stage. 1.3.2 SCM Resources and Schedules 2, ann. Ds8 3, c23 Planning for SCM identifies the resources  including staff and tools  involved in carrying out SCM activities and tasks. It also identifies the necessary sequences of SCM tasks and establishes each tasks place in the project schedule and its position rela- tive to milestones established at the project management planning stage. Any training requirements for implementing the plans and training new staff members are also specified. 1.3.3 Tool Selection and Implementation 3, c26s2, c26s6 As in any area of software engineering, the selection and implementation of SCM tools should be carefully planned. The following questions should be considered:  Organization: What motivates tool acqui- sition from an organizational perspective? Tools: Can we use commercial tools, or do we need to develop our own tools spe- cifically for this project?

--- Chunk 396 ---
Tokens: 372
Type: sentence-based
Text:
Tools: Can we use commercial tools, or do we need to develop our own tools spe- cifically for this project? Environment: What constraints are imposed by the organization and its tech- nical context? Legacy: How will projects use (or not use) the new tools? Financing: Who will pay for the tools acquisition, maintenance, training and customization? Scope: How will the new tools be deployed  for instance, through the entire orga- nization or only on specific projects? Ownership: Who is responsible for intro- ducing new tools? Future: What is the plan for the tools use in the future? Change: How adaptable are the tools? Branching and merging: Are the tools capabilities compatible with planned branching and merging strategies? Integration: Do the various SCM tools integrate among themselves? Do they integrate with other tools in use in the organization? Migration: Can the repository maintained by the version control tool be ported to another version control tool while main- taining the complete history of the CIs it contains? SCM requires a set of tools instead of a single tool. Such tool sets are sometimes called workbenches. As part of the tool selec- tion planning effort, the team must determine whether the SCM workbench will be open (tools from different suppliers will be used in different SCM process activities) or integrated (elements of the workbench are designed to work together). Organization size and the type of projects involved may also affect tool selection.

--- Chunk 397 ---
Tokens: 378
Type: sentence-based
Text:
Organization size and the type of projects involved may also affect tool selection. (See SCM Tools, section 7 of this document) SOFTWARE CONFIGURATION MANAGEMENT 8-5 1.3.4 VendorSubcontractor Control 2, c13 3, c13s9-c14s2 A software project might acquire or use pur- chased software products, such as compilers or other tools. SCM planning considers whether and how these items will be managed with configuration control (e.g, integrated into the project libraries) and how changes or updates will be evaluated and managed. Similar considerations apply to subcon- tracted software. When a project uses subcon- tracted software, both the SCM requirements to be imposed on the subcontractors SCM process and the means for monitoring compli- ance need to be established. The latter includes determining what SCM information must be available for effective compliance monitoring. 1.3.5 Interface Control 2, c12 3, c23s4 When a software item interfaces with another software or with a hardware item, a change to either item can affect the other. Planning for the SCM process considers how the inter- facing items will be identified and how changes to the items will be managed and communi- cated. The SCM role may be part of a larger, system-level process for interface specification and control involving interface specifications, interface control plans and interface control documents. In this case, SCM planning for interface control takes place within the con- text of the system-level process. 1.4 SCM Plan 2, ann.

--- Chunk 398 ---
Tokens: 393
Type: sentence-based
Text:
1.4 SCM Plan 2, ann. D 3, c23 The results of SCM planning for a given project are recorded in an SCMP, a living document that serves as a reference for the SCM process. The SCMP is maintained (updated and approved) as necessary during the software life cycle. For teams to implement an SCMP, theyll typically need to develop a number of more detailed, subordinate pro- cedures to define how specific requirements will be met during day-to-day activities (e.g, which branching strategies will be used, how frequently builds will occur, how often auto- mated tests of all kinds will be run). Guidance on creating and maintaining an SCMP, based on the information produced by the planning activity, is available from a number of sources, such as 2. This refer- ence provides requirements for information to be contained in an SCMP. An SCMP should include the following sections:  Introduction (purpose, scope, terms used)  SCM Management (organization, respon- sibilities, authorities, applicable policies, directives, procedures)  SCM Activities (configuration identifi- cation, configuration control, etc.) SCM Schedules (coordination with other project activities)  SCM Resources (tools, physical resources and human resources)  SCMP Maintenance 1.5 Monitoring of Software Configuration Management 3, c11s3 After the SCM process has been imple- mented, some surveillance may be necessary to ensure that the SCMP provisions are prop- erly carried out. The plan is likely to include specific SQA requirements to ensure com- pliance with specified SCM processes and procedures.

--- Chunk 399 ---
Tokens: 359
Type: sentence-based
Text:
The plan is likely to include specific SQA requirements to ensure com- pliance with specified SCM processes and procedures. The person responsible for SCM ensures that those with the assigned respon- sibility perform the defined SCM tasks cor- rectly. As part of a compliance auditing activity, the SQA authority might also per- form this surveillance. Using integrated SCM tools with pro- cess control capability can make the surveil- lance task easier. Some tools facilitate process compliance while providing flexibility for the software engineer to adapt procedures. Other tools enforce a specific process, leaving the software engineer with less flexibility. Surveillance requirements and the level of flexibility provided to the software engineer are important considerations in tool selection. 8-6 SWEBOK  GUIDE V4.0 1.5.1 SCM Measures and Measurement 3, c9s2, c25s2-s3 SCM measures can be designed to provide specific information on the evolving product, but they can also provide insight into how well the SCM process functions and iden- tify opportunities for process improvement. SCM process measurements enable teams to monitor the effectiveness of SCM activities on an ongoing basis. These measurements are useful in characterizing the current state of the process and providing a basis for comparison over time. Measurement anal- ysis may produce insights that lead to pro- cess changes and corresponding updates to the SCMP.

--- Chunk 400 ---
Tokens: 400
Type: sentence-based
Text:
Measurement anal- ysis may produce insights that lead to pro- cess changes and corresponding updates to the SCMP. Software libraries and the various SCM tool capabilities enable teams to extract useful information about SCM process characteris- tics (as well as project and management infor- mation). For example, information about the time required to accomplish various types of changes would be useful in evaluating criteria for determining what levels of authority are optimal for authorizing certain changes and in estimating the resources needed to make future changes. Care must be taken to keep the surveillance focused on the insights that can be gained from the measurements, not on the measurements themselves. Software process and product measurement is further discussed in the Software Engineering Process KA. Software measurement programs are described in the Software Engineering Management KA. 1.5.2 In-Process Audits of SCM 3, c1s1 Audits can be carried out during the software engineering process to investigate the status of specific configuration elements or to assess the SCM process implementation. In-process SCM auditing provides a more formal mech- anism for monitoring selected aspects of the process and may be coordinated with the SQA function. (See Software Configuration Auditing.) 2. Software Configuration Identification 2, c8 Software configuration identification identi- fies items to be controlled, establishes iden- tification schemes for the items and their versions, and establishes the tools and tech- niques to be used in acquiring and managing controlled items.

--- Chunk 401 ---
Tokens: 371
Type: sentence-based
Text:
Software Configuration Identification 2, c8 Software configuration identification identi- fies items to be controlled, establishes iden- tification schemes for the items and their versions, and establishes the tools and tech- niques to be used in acquiring and managing controlled items. These activities provide the basis for other SCM activities. 2.1 Identifying Items to Be Controlled 2, c8s2.2 A first step in controlling change is identi- fying the software items to be controlled. This involves understanding the software configu- ration within the context of the system con- figuration, selecting SCIs and developing a strategy for labeling software items. 2.1.1. Software Configuration Software configuration is the functional and physical characteristics of hardware or soft- ware as set forth in technical documentation or achieved in a product. It can be viewed as part of an overall system configuration. 2.1.2 Software Configuration Item 2, c8s2.1 3, c9 A CI is an item or aggregation of hardware, software or both, designed to be managed as a single entity. An SCI is a software entity that has been established as a CI 1. The SCM controls various items in addition to the code itself. Software items with potential to become SCIs include plans, specifications and design documentation, testing materials, software tools, source and executable code, code libraries, data and data dictionaries, and documentation for installation, maintenance, operations and software use.

--- Chunk 402 ---
Tokens: 399
Type: sentence-based
Text:
Software items with potential to become SCIs include plans, specifications and design documentation, testing materials, software tools, source and executable code, code libraries, data and data dictionaries, and documentation for installation, maintenance, operations and software use. Selecting SCIs is an important process in which a balance must be achieved between providing adequate visibility for project con- trol purposes and providing a manageable number of controlled items. SOFTWARE CONFIGURATION MANAGEMENT 8-7 2.2 Configuration Item Identifiers and Attributes 2, c8s2.3, c8s2.4 3, c9 Status accounting activity (explained later) gathers information about CIs while they are developed. The CIs scheme is defined in order to establish what information must be gathered and tracked for each CI. Unique identifiers and versions are tracked. An example scheme may include the following: CI name CI unique identifier CI description CI date(s) CI type CI owner The CIs unique Identifier can use sig- nificant or nonsignificant codification. An example of significant codification could be XX-YY, where XX is the iteration abbrevia- tion (in case of using an iterative development method) and YY is the CI abbreviation. 2.3 Baseline Identification 2, c8s2.5.4, c8s2.5.5, c8s2.5.6 A software baseline is a formally approved version of a CI (regardless of media type) that is formally designated and fixed at a specific time during the CIs life cycle. The term also refers to a particular version of an agreed- upon SCI. The baseline can be changed only through formal change control procedures.

--- Chunk 403 ---
Tokens: 346
Type: sentence-based
Text:
The baseline can be changed only through formal change control procedures. A baseline, with all approved changes to the baseline, represents the current approved con- figuration. A baseline consists of one or more related CIs. 2.4 Baseline Attributes 2, c8s2.5.4 Baseline attributes are used in the status accounting activity and specify information about the baseline established. Example baseline attributes may include the following: Baseline name Baseline unique identifier Baseline description Baseline date of creation Baseline CIs 2.5 Relationships Scheme Definition 3, c7s4 Relationships provide the connections required to create and sustain structure. The ability to communicate intent and manage the results are significantly enhanced when effec- tive relationships (structuring) are in place (e.g, model-based experience (MBX) plat- forms). Relationship information exchange and interoperability are needed to support the applicable relationship types. The status accounting activity is responsible for gathering information about relationships among CIs. Common types of relationships can be described according to the following schemes: Dependencies: CI-1 and CI-2 depend mutu- ally on each other. Example: CI-1 depends on C1-2, and vice versa, for instance a class model depends on a sequence diagram, because any change on any of both types of models, affect the other.

--- Chunk 404 ---
Tokens: 386
Type: sentence-based
Text:
Example: CI-1 depends on C1-2, and vice versa, for instance a class model depends on a sequence diagram, because any change on any of both types of models, affect the other. CI-1 Code CI-2 Code Date Derivation: One CI derives from another, typically in a sequential relationship, not because of a lack of resources to handle both CIs but because of a constraint that requires that, for instance, CI-1 is completed before CI-2 is developed. Example: CI-1 derives from CI-2. CI-1 Code CI-2 Code Date Succession: Software items evolve as a soft- ware project proceeds. A software item ver- sion is an identified instance of an item. It can be thought of as a state of an evolving item. This is what the succession relationship 8-8 SWEBOK  GUIDE V4.0 reflects, and it is reflexive in that each CI has this relationship with itself. The first succes- sion comes up the first time a CI is created. Each time it is changed, a new succession comes up, and tracking these successions is the way to track CI versions. Example: CI versions along a timeline. CI Code Current Version Next Version Date Variants are program versions resulting from engineered alternative options. This type of relationship is not as common as the type of relationships described above because it is more expensive to maintain. The decision on what relationships to track throughout the project is important because tracking some relationships can require extra work. On the other hand, tracking such rela- tionships can facilitate decisions on change requests (CRs) for a CI.

--- Chunk 405 ---
Tokens: 345
Type: sentence-based
Text:
On the other hand, tracking such rela- tionships can facilitate decisions on change requests (CRs) for a CI. Relationships between CIs can be tracked in a Software Bill of Materials (SBOM). An SBOM is a formal record containing the details and supply chain relationships of the CIs used in building software. CIs in an SBOM are frequently referred to as components. Components can be source code, libraries, modules and other artifacts; they can be open source or proprietary, free or paid; and the data can be widely available or access-restricted. A simple example of the relationships among three CIs in an SBOM, called CI-1, CI-2 and CI-3, is illustrated in Figure 8.2. 2.6 Software Libraries 2, c8s2.5 3, c1s3 A software library is a controlled collection of source code, scripts, object code, documen- tation and related artifacts. Requirements and test cases are stored in a repository and should be linked with the code baselines developed. Source code is stored in a version control system, which provides traceability and security for the baselines developed. Multiple development streams are supported in version control systems linked to the binary objects (e.g, object code) derived during the build process. These binary objects are typi- cally stored in a repository that should con- tain cryptographic hashes used to perform the physical configuration audit (PCA).

--- Chunk 406 ---
Tokens: 383
Type: sentence-based
Text:
These binary objects are typi- cally stored in a repository that should con- tain cryptographic hashes used to perform the physical configuration audit (PCA). Successions Records: According to the scheme dened for succession relationships, the next table gives the date when each CI was created (three rst rows), and the fourth row indicates a change made on the CI-1 on 10052021, where the current version was 1 and created new version is 2. Derivation Record: According to the scheme dened for derivation, CI-3 derives from CI-1 and this relationship came up the day CI-3 was created. Dependency Record: According to the scheme dened for dependencies CI-1 and CI-2 have a dependency relationship created the day CI-2 was developed. CI-1  1 10012021 CI-2  1 10042021 CI-3  1 10032021 CI-1 1 2 10052021 CI-1 CI-2 10042021 CI-3 CI-1 10032021 CI-1 CI-2 CI-3 succession succession succession dependency derivation Figure 8.2. Example of reported relationships SOFTWARE CONFIGURATION MANAGEMENT 8-9 The definitive media library contains the release baseline(s) of the artifacts that can be deployed to the test, stage and produc- tion systems. The release management process depends on these software libraries to manage the arti- facts deployed. In terms of access control and the backup facilities, security is a key aspect of library management. 3. Software Configuration Change Control 2, c9 3,c8 4, c25s3 5, c11.s3.3 Software configuration change control is con- cerned with changes required to CIs during the software life cycle.

--- Chunk 407 ---
Tokens: 362
Type: sentence-based
Text:
Software Configuration Change Control 2, c9 3,c8 4, c25s3 5, c11.s3.3 Software configuration change control is con- cerned with changes required to CIs during the software life cycle. It covers the pro- cess for determining what changes to make, the authority for approving certain changes, support for implementing those changes, and the concept of formal deviations from project requirements as well as waivers of them. Information derived from these activ- ities is useful in measuring change traffic and breakage, as well as aspects of rework. Given that change to CIs can follow spe- cific rules depending on the industrial sector, area, company, etc, it is very important to identify those rules in the context of the software project for which the SCM pro- cess is being developed and to adhere strictly to those rules. The rest of this section can be useful when no specific rules regarding change control exist in the company or the industrial sector where the software project under development is allocated. 3.1 Requesting, Evaluating, and Approving Software Changes 2, c9s2.4 3, c11s1 4, c25s3 The first step in managing changes to con- trolled items is determining what changes to make. The software change request (SCR) process (Figure 8.3) provides formal pro- cedures for submitting and recording CRs; evaluating the potential cost and impact of a proposed change; and accepting, modifying, deferring or rejecting the proposed change.

--- Chunk 408 ---
Tokens: 379
Type: sentence-based
Text:
The software change request (SCR) process (Figure 8.3) provides formal pro- cedures for submitting and recording CRs; evaluating the potential cost and impact of a proposed change; and accepting, modifying, deferring or rejecting the proposed change. A CR is a request to expand or reduce the project scope; modify policies, processes, plans or procedures; modify costs or budgets; modify implemented code; or revise schedules 1. Requests for changes to SCIs may be orig- inated by anyone at any point in the software life cycle and may include a suggested solution and requested priority. One source of a CR is the initiation of corrective action in response to problem reports. Regardless of the source, the type of change (e.g, defect or enhance- ment) is usually recorded on the SCR. Emergency Path usually also exists Changes can be implemented with change process performed afterward Incomplete Complete Approved Rejected Inform Requester Assign to Software Engineer Schedule, Design, Test, Complete Change CCB Review Preliminary Investigation Need for Change Change identifed for controlled item SCR Generated or Upgraded SCR Evaluated Figure 8.3. Flow of a Change Control Process 8-10 SWEBOK  GUIDE V4.0 Recording of the SCR enables the software engineers to track defects and collect change activity measurements by change type. Once an SCR is received, a technical evaluation (also known as an impact analysis) is per- formed to determine the extent of the modifi- cations necessary should the CR be accepted.

--- Chunk 409 ---
Tokens: 390
Type: sentence-based
Text:
Once an SCR is received, a technical evaluation (also known as an impact analysis) is per- formed to determine the extent of the modifi- cations necessary should the CR be accepted. A good understanding of the relationships among software (and, possibly, hardware) items is important for this task. The infor- mation recorded about the CIs relationships could be useful for making decisions affecting any CI, given the potential impact on other CIs. Finally, an established authority  com- mensurate with the affected baseline, the SCI involved and the nature of the change  will evaluate the CRs technical and managerial aspects and accept, modify, reject or defer the proposed change. 3.1.1 Software Configuration Control Board 2, c9s2.2 3, c11s1 4, c25s3 The authority for accepting or rejecting pro- posed changes rests with an entity known as a configuration control board (CCB). In smaller projects, this authority may reside with the leader or an assigned individual rather than a multi-person board. There can be multiple levels of change authority depending on a variety of criteria  such as the criticality of the item involved, the nature of the change (e.g, impact on budget and schedule), or where the project is in the life cycle. The com- position of the CCBs used for a system varies depending on these criteria (but an SCM rep- resentative is always present). All stakeholders appropriate to the CCB level are represented. When a CCBs scope of authority is limited to software, the board is known as a Software Configuration Control Board (SCCB).

--- Chunk 410 ---
Tokens: 380
Type: sentence-based
Text:
When a CCBs scope of authority is limited to software, the board is known as a Software Configuration Control Board (SCCB). The CCBs activities are subject to software quality audits or reviews. 3.1.2 Software Change Request Process 3, c1s4, c8s4 4, c25s3 An effective SCR process requires the use of supporting tools and procedures for originating CRs, enforcing the change process flow, capturing CCB decisions and reporting change process information. Linking this tool capability with the problem-reporting system can facilitate the problem resolution tracking and how quickly solutions are developed. 3.1.3 Software Change Request Forms Definition 2, c9s2.3, c9s2.5 3, c8s4 4, c25s3 A CR application must include the following:  A CR form, which must describe the request and give the rationale for it  A change certification form (necessary if the CR is granted) These forms can be managed through the corresponding supporting tool, but humans are responsible for designing the forms. 3.2 Implementing Software Changes 4, c25s3 Approved SCRs are implemented using the defined software procedures per the applicable schedule requirements. Because a number of approved SCRs might be implemented simul- taneously, a means for tracking which SCRs are incorporated into particular software ver- sions and baselines must be provided. At the end of the change process, completed changes may undergo configuration audits and soft- ware quality verification, which includes ensuring that only approved changes have been made.

--- Chunk 411 ---
Tokens: 338
Type: sentence-based
Text:
At the end of the change process, completed changes may undergo configuration audits and soft- ware quality verification, which includes ensuring that only approved changes have been made. The SCR process typically docu- ments the changes SCM and other approval information. Changes may be supported by source code version control tools. These tools allow a team of software engineers, or a single software engineer, to track and document changes to the source code. These tools provide a single repository for storing the source code, so they can prevent more than one software engineer from editing the same module at the same time, and they record all changes made to the SOFTWARE CONFIGURATION MANAGEMENT 8-11 source code. Software engineers check mod- ules out of the repository, make changes, doc- ument the changes, and then save the edited modules in the repository. If needed, changes can also be discarded, restoring a previous baseline. More powerful tools can support parallel development and geographically dis- tributed environments. These tools may mani- fest as separate, specialized applications under an independent SCM groups control. They may also appear as an integrated part of the software engineering environment. Finally, they may be as elementary as a rudimentary change control system that is provided with an operating system.

--- Chunk 412 ---
Tokens: 368
Type: sentence-based
Text:
Finally, they may be as elementary as a rudimentary change control system that is provided with an operating system. 3.3 Deviations and Waivers 1, c3 The constraints imposed on a software engi- neering effort or the specifications produced during the development activities might con- tain provisions that those working on the project find cannot be satisfied at the desig- nated point in the life cycle. A deviation is a written authorization granted before the manufacture of an item to depart from a par- ticular performance or design requirement for a specific number of units or a specific period of time. A waiver is a written authorization to allow a CI or other designated item in response to an issue found during production or after the project is submitted for inspection to depart from specified requirements when the CI or project is nevertheless considered suitable for use, either as it is or after rework via an approved method. In these cases, a formal process is used to gain approval for deviations from or waivers of the provisions. 4. Software Configuration Status Accounting 2, c10 3, c9 5, c11s3.4 SCSA is an activity of CM consisting of recording and reporting information needed to manage a configuration effectively regarding CIs, baselines and relationships among CIs. This activity must be done by following the logical schemes defined in the activity config- uration identification for CIs, baselines and relationships for gathering information.

--- Chunk 413 ---
Tokens: 377
Type: sentence-based
Text:
This activity must be done by following the logical schemes defined in the activity config- uration identification for CIs, baselines and relationships for gathering information. 4.1 Software Configuration Status Information 2, c10s2.1 The SCSA activity designs and operates a system for capturing, verifying, validating and reporting necessary information as the life cycle proceeds. As in any information system, the configuration status information to be managed for the evolving configurations must be identified, collected and maintained. In addition, the information itself should be secured where relevant. SCSA information and measurements are needed to support the SCM process and to meet the configuration status reporting needs of management, soft- ware engineering, security, performance and other related activities. The types of information available include but are not limited to the following:  Ongoing and approved configuration identification  Current implementation status of changes  Impacted CIs and related systems  Deviations and waivers  Verification and validation (VV) activities Automated tools support SCSA as tasks are performed, and reporting is available in a user-friendly format. 4.2 Software Configuration Status Reporting 2, c10s2.4 3, c1s5, c9s1 Reported information can be used by var- ious organizational and project elements  including the development team, operations, security, the maintenance team, project man- agement, software quality activities teams and others.

--- Chunk 414 ---
Tokens: 333
Type: sentence-based
Text:
4.2 Software Configuration Status Reporting 2, c10s2.4 3, c1s5, c9s1 Reported information can be used by var- ious organizational and project elements  including the development team, operations, security, the maintenance team, project man- agement, software quality activities teams and others. Reporting can take many forms: automated reports, ad hoc queries to answer specific questions, and regular production of predesigned reports, including those devel- oped to meet security, legal or regulatory 8-12 SWEBOK  GUIDE V4.0 requirements. In other words, information produced by the SCSA activity throughout the life cycle can be used to satisfy QA and security and to provide evidence of compli- ance with regulations, governance require- ments, etc. In addition to reporting the configura- tions current status, the information obtained by the SCSA can serve as a basis for various measurements. Modern SCM includes a wider scope of information, including but not limited to the following:  Indicators of integrity (e.g, MAC (Message Authentication Code) SHA1 (Secure Hash Algorithm), MD5 (Message Digest))  Indicators of security status (e.g, gover- nance risk and compliance)  Evidence of VV activities (e.g, require- ments completion)  Baseline status  The number of CRs per SCI  The average time needed to implement a CR 5.

--- Chunk 415 ---
Tokens: 392
Type: sentence-based
Text:
Modern SCM includes a wider scope of information, including but not limited to the following:  Indicators of integrity (e.g, MAC (Message Authentication Code) SHA1 (Secure Hash Algorithm), MD5 (Message Digest))  Indicators of security status (e.g, gover- nance risk and compliance)  Evidence of VV activities (e.g, require- ments completion)  Baseline status  The number of CRs per SCI  The average time needed to implement a CR 5. Software Configuration Auditing 2, c11 5, c11s3.5 A software audit is an independent examina- tion of a work product or set of work prod- ucts to assess technical, security, legal and regulatory compliance with specifications, standards, contractual agreements or other criteria 1. Audits are conducted according to a well-defined process comprising various auditor roles and responsibilities. Because of this complexity, each audit must be care- fully planned. An audit can require a number of individuals to perform various tasks over a fairly short time. Tools to support the plan- ning and conduct of an audit can greatly facil- itate the process. Software configuration auditing deter- mines the extent to which an item satis- fies requirements for functional and physical characteristics. Informal audits can be con- ducted at key points in the life cycle. Two types of formal audits might be required by the governing contract (e.g, a contract cov- ering critical software): the functional config- uration audit (FCA) and the PCA. Successful completion of these audits can be a prerequi- site for establishing the product baseline.

--- Chunk 416 ---
Tokens: 397
Type: sentence-based
Text:
Successful completion of these audits can be a prerequi- site for establishing the product baseline. 5.1 Software Functional Configuration Audit 2, c11s2.1 The software FCA ensures that the audited software item is consistent with its governing specifications. The software VV activities output (see Verification and Validation in the Software Quality KA) is a key input to this audit. 5.2 Software Physical Configuration Audit 2, c11s2.2 The software PCA ensures that the design and reference documentation are consistent with the as-built software product. 5.3 In-Process Audits of a Software Baseline 2, c11s2.3 Audits can be carried out during the develop- ment process to investigate the status of specific configuration elements. In-process audits can be applied to all baseline items to ensure that performance is consistent with specifications or that evolving documentation continues to be consistent with the developing baseline item. This task applies to every single CI to be approved as part of a baseline. The audit consists of reviewing the CI to determine whether it satisfies requirements. How to con- duct the review and the expected result must be described in the quality plan or if there is no quality plan, defined for the software con- figuration auditing activity. Continuous reviews of CIs identified in the configuration identification activities help verify conformance to governance and regula- tory requirements. Configuration auditing reviews take place throughout project development, whenever a CI must be reviewed. SOFTWARE CONFIGURATION MANAGEMENT 8-13 6.

--- Chunk 417 ---
Tokens: 386
Type: sentence-based
Text:
SOFTWARE CONFIGURATION MANAGEMENT 8-13 6. Software Release Management and Delivery 2, c14 3, c8s2 4, c25s4 In this context, release refers to distrib- uting software and related artifacts outside the development activity, including internal releases and distribution to customers. When different versions of a software item are avail- able for delivery (such as versions for different platforms or versions with varying capabili- ties), re-creating specific versions and pack- aging the correct materials for version delivery are frequently necessary. The software library is a key element in accomplishing release and delivery tasks. 6.1 Software Building 4, c25s2 Software building constructs the correct ver- sions of SCIs, using the appropriate config- uration data, into a software package for delivery to a customer or other recipient such as a team performing testing. For systems with hardware or firmware, the executable program is delivered to the system-building activity. Build instructions help ensure that the proper build steps are taken in the cor- rect sequence. In addition to building soft- ware for new releases, SCM must usually be able to reproduce previous releases for recovery, testing, maintenance or additional release purposes. Software is built using supporting tools, such as compilers. For example, if it is nec- essary to rebuild an exact copy of a previously built SCI, supporting tools and associated build instructions must be under SCM con- trol to ensure the availability of the correct versions of the tools.

--- Chunk 418 ---
Tokens: 389
Type: sentence-based
Text:
For example, if it is nec- essary to rebuild an exact copy of a previously built SCI, supporting tools and associated build instructions must be under SCM con- trol to ensure the availability of the correct versions of the tools. Tool capability is useful for selecting the correct versions of software items for a target environment and automating the process of building the software from the selected version and configuration data. This tool capability is necessary for projects with parallel or distributed development envi- ronments. Most software engineering envi- ronments provide this capability. However, these tools vary in complexity; some require the software engineer to learn a special- ized scripting language, while others use a more graphics-oriented approach that hides much of the complexity of an intelligent build facility. The build process and products are often subject to software quality verification. Outputs of the build process might be needed for future reference. They may become records of quality, security, or compliance with orga- nizational or regulatory requirements. The SBOM listing the artifacts included in the build is an important CM output. In continuous integration, software building is performed automatically when changes to CIs are committed to a source control repository. Tools running on a local or cloud-based server monitor the projects source control system and initiate a pipeline of steps to be undertaken every time a change is committed to a particular branch or area of the source code repository.

--- Chunk 419 ---
Tokens: 374
Type: sentence-based
Text:
Tools running on a local or cloud-based server monitor the projects source control system and initiate a pipeline of steps to be undertaken every time a change is committed to a particular branch or area of the source code repository. The tool is configured to retrieve a fresh copy of the complete source code for the project and execute the necessary commands to compile and link the code. This configuration is often combined with steps to validate coding standards via automated static analysis, execute unit tests and determine code coverage metrics, or extract documenta- tion from the source code. The resulting arti- facts are then deployed through the Release Management process. 6.2 Software Release Management 4, c25s2 Software release management encompasses the identification, packaging and delivery of the elements of a product (e.g, an execut- able program, documentation, release notes, or configuration data). Given that product changes can occur continually, one concern for release management is determining when to issue a release. The severity of the prob- lems addressed by the release and measure- ments of the fault densities of prior releases affect this decision. The packaging task iden- tifies which product items are to be delivered 8-14 SWEBOK  GUIDE V4.0 and then selects the correct variants of those items, given the products intended applica- tion. The information documenting the phys- ical contents of a release is known as a version description document (VDD).

--- Chunk 420 ---
Tokens: 399
Type: sentence-based
Text:
The information documenting the phys- ical contents of a release is known as a version description document (VDD). The release notes describe new capabilities, known prob- lems and platform requirements necessary for proper product operation. The package to be released also contains installation or upgrade instructions. The latter can be complicated because some users might have versions that are several releases old. In some cases, release management might be necessary to track the products distribution to various customers or target systems (e.g, when the supplier was required to notify a customer of newly reported problems). Finally, a mechanism to help ensure the released items integrity can be implemented (e.g, by including a digital signature). A tool capability is needed for supporting these release management functions. For example, a connection with the tool capa- bility supporting the CR process is useful to map release contents to the SCRs that have been received. This tool capability might also maintain information on various target plat- forms and customer environments. In continuous delivery, a pipeline is estab- lished to build software continuously, as described in the previous section. The resulting artifacts from the build process include exe- cutable code and libraries, which can then be combined into an installation package and deployed into an environment for verification or production use. 7. Software Configuration Management Tools 3, c26s1 Many tools can assist with CM at many levels. The scope of these tools varies depending on who uses the tools.

--- Chunk 421 ---
Tokens: 393
Type: sentence-based
Text:
The scope of these tools varies depending on who uses the tools. CM is most effective when integrated with other processes and by exten- sion with other existing tools. The selection of CM tool can be made depending on the scope that the tool is going to have. Overview of tools:  The configuration management system (CMS) provides enabling technology and logic to facilitate CM activities. Version control stores the source code, configuration files and related artifacts. Build automation (pipeline) is established to enable continuous delivery. A repository stores binaries that are cre- ated during the build process to extract the latest build artifacts and redeploy them as required  used in the release verification process. Configuration management database (CMDB) or similar persistence store. Change control tools. Releasedeployment tools. The CMS supports the unique identifica- tion of artifacts. Both individual artifacts and collections are specified in CM systems and related repositories. Structuring creates a log- ical relationship between artifacts. Validation and release establish the artifacts integ- rity, as part of the release management pro- cess. Baselines are identified where stability is intended. For example, interface management is identified and controlled, making it part of the baseline process. Change management, including variants and nonconformances, is reviewed and approved, and its imple- mentation is planned. Verification and audit activities are performed as part of the identi- fication, change and release management pro- cess.

--- Chunk 422 ---
Tokens: 398
Type: sentence-based
Text:
Verification and audit activities are performed as part of the identi- fication, change and release management pro- cess. Status and performance accounting are recorded as events occur and are made avail- able through the CMS. Individual support tools are typically suffi- cient for small organizations or development groups that do not issue variants of their soft- ware products or face other complex SCM requirements. The following are examples of these tools:  Version control tools: These tools track, document and store individual CIs such as source code and external documentation. Build handling tools: In their simplest form, such tools compile and link an exe- cutable version of the software. More SOFTWARE CONFIGURATION MANAGEMENT 8-15 advanced building tools extract the latest version from the version control soft- ware, perform quality checks, run regres- sion tests, and produce various forms of reports, among other tasks. Change control tools: These tools pri- marily support the control of CRs and event notifications (e.g, CR status changes, milestones reached). Project-related support tools mainly sup- port workspace management for develop- ment teams and integrators. In addition, they can support distributed development environments. Such tools are appropriate for medium-to-large organizations that use vari- ants of their software products and parallel development and do not have certification requirements. Companywide-process support tools can automate portions of a companywide pro- cess, providing support for workflow man- agement, roles and responsibilities.

--- Chunk 423 ---
Tokens: 400
Type: sentence-based
Text:
Companywide-process support tools can automate portions of a companywide pro- cess, providing support for workflow man- agement, roles and responsibilities. They can handle many items, large volumes of data, and numerous life cycles. In addition, such tools add to project-related support by supporting a more formal development process, including certification requirements. MATRIX OF TOPICS VS. REFERENCE MATERIAL Topic IEEE 828-2012 2 Hass 2003 3 Sommerville 2016 4 1. Management of the SCM Process c6, c7 1.1. Organizational Context for SCM c6, ann.D Introduction c25 1.2. Constraints and Guidance for the SCM Process c6, ann.D, ann.E c2,c5 1.3. Planning for SCM c6, ann.D, ann.E c23 c25 1.3.1. SCM Organization and Responsibilities ann.Ds5-6 c10-11 c25 1.3.2. SCM Resources and Schedules ann.Ds8 c23 1.3.3. Tool Selection and Implementation c26s2, s6 1.3.4. VendorSubcontractor Control c13 c13s9-c14s2 1.3.5. Interface Control c12 c23s4 1.4. SCM Plan ann.D c23 1.5. Surveillance of Software Configuration Management c11s3 1.5.1. SCM Measures and Measurement c9s2; c25s2-s3 1.5.2. In-Process Audits of SCM c1s1 2. Software Configuration Identification c8 2.1. Identifying Items to Be Controlled c8s2.2 c1s2 2.1.1. Software Configuration 8-16 SWEBOK  GUIDE V4.0 2.1.2. Software Configuration Item c8s2.1 c9 2.2. Configuration Item Identifiers and Attributes c8s2.3 c8s2.4 c9 2.3. Baseline Identification c8s2.5.4 c8s2.5.5 c8s2.5.6 2.4. Baseline Attributes c8s2.5.4 2.5. Relationships Scheme Definition c7s4 2.6. Software Libraries c8s2.5 c1s3 3. Software Configuration Change Control c9 c8 c25s3 3.1.

--- Chunk 424 ---
Tokens: 366
Type: sentence-based
Text:
Software Configuration Change Control c9 c8 c25s3 3.1. Requesting, Evaluating and Approving Software Changes c9s2.4 c11s1 c25s3 3.1.1. Software Configuration Control Board c9s2.2 c11s1 c25s3 3.1.2. Software Change Request Process c1s4, c8s4 c25s3 3.1.3. Software Change Request Forms Definition c9s2.3 c9s2.5 c8s4 c25s3 3.2. Implementing Software Changes c25s3 3.3. Deviations and Waivers 4. Software Configuration Status Accounting c10 c9 4.1. Software Configuration Status Information c10s2.1 4.2. Software Configuration Status Reporting c10s2.4 c1s5; c9s1 5. Software Configuration Auditing c11 5.1. Software Functional Configuration Audit c11s2.1 5.2. Software Physical Configuration Audit c11s2.2 5.3. In-Process Audits of a Software Baseline c11s2.3 6. Software Release Management and Delivery c14 c8s2 c25s4 6.1. Software Building c25s2 6.2. Software Release Management c25s2 7. Software Configuration Management Tools c26s1 FURTHER READINGS S.P. Berczuk and B. Appleton, Software Configuration Management Patterns: Effective Teamwork, Practical Integration 6. This book expresses useful SCM practices and strategies as patterns. The patterns can be implemented using various tools, but they are expressed in a tool-agnostic fashion. CMMI for Development, Version 2.0 - 2.1, pp. 6680 7. This model presents a collection of best prac- tices to help software development organi- zations improve their processes. At maturity level 2, it suggests CM activities.

--- Chunk 425 ---
Tokens: 297
Type: sentence-based
Text:
At maturity level 2, it suggests CM activities. B. Aiello and L. A. Sachs, Configuration man- agement best practices: Practical methods that SOFTWARE CONFIGURATION MANAGEMENT 8-17 work in the real world (1st edition), 2011 8. This book presents the seven types of change control (Chapter 4, Section 3). REFERENCES 1 ISOIECIEEE, ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, 2nd ed. 2017. 2 IEEE. IEEE Standard 828- 2012, Standard for Configuration Management in Systems and Software Engineering, 2012. 3 A.M.J. Hass. Configuration Management Principles and Practices, 1st ed. Boston: Addison-Wesley, 2003. 4 I. Sommerville, Software Engineering, 10th ed. Global ed. Pearson, 2016. 5 J.W. Moore, The Road Map to Software Engineering: A Standards-Based Guide, 1st ed. Hoboken, NJ: Wiley-IEEE Computer Society Press, 2006. 6 S.P. Berczuk and B. Appleton, Software Configuration Management Patterns: Effective Teamwork, Practical Integration: Addison-Wesley Professional, 2003. 7 CMMI for development, Version 2.0, CMMI Institute, 2018. 8 B. Aiello and L.A. Sachs, Configuration management best practices: Practical methods that work in the real world (1st edition), 2011.

--- Chunk 426 ---
Tokens: 340
Type: sentence-based
Text:
8 B. Aiello and L.A. Sachs, Configuration management best practices: Practical methods that work in the real world (1st edition), 2011. 9-1 CHAPTER 09 Software Engineering Management ACRONYMS PMBOK Guide Guide to the Project Management Body of Knowledge SDLC Software development life cycle SEM Software engineering management SQA Software quality assurance SWX Software Extension to the PMBOK Guide WBS Work breakdown structure PSM Practical Software and Systems Measurement MBSE Model-Based System Engineering INTRODUCTION Software engineering management (SEM) can be defined as a collection of work activi- ties involved with planning, estimating, mea- suring, controlling, coordinating, leading and managing risk factors for a software project to help ensure that software products and soft- ware engineering services are delivered effi- ciently, effectively and to the stakeholders benefit 3. Although project management and measurement management are often seen as separate areas, and each possesses many unique attributes, the close relationship between the two has led to their combined treatment in this knowledge area (KA). In one sense, it should be possible to manage a software engineering project in the same way other complex endeavors are man- aged, using models, technical processes and problem-solving styles as other engineering projects do.

--- Chunk 427 ---
Tokens: 397
Type: sentence-based
Text:
In one sense, it should be possible to manage a software engineering project in the same way other complex endeavors are man- aged, using models, technical processes and problem-solving styles as other engineering projects do. However, software engineers use different process models, technical processes, and problem-solving styles than other engi- neers, making these choices based on their education and experience and on the differ- ences between physical and software attri- butes. Software system elements are logical constructions expressed in algorithmic form, while physical system elements are realized in mechanical, electrical, chemical, biological and other physical media. Software is intan- gible because it has no physical properties and is malleable because of the relative ease with which code can be modified. Obtaining the desired effect by modifying software code might not be easy, but code modifications, per se, are straightforward compared with the modification of physical elements that have already been constructed 12. As software and software-embedded sys- tems become bigger, more complex, and more intertwined, software engineering manage- ment and engineering roles are evolving in response 10, because skilled individuals must actively develop and maintain these sys- tems. Consider the following: hardware is different from software (and not all software is the same). Hardware can be developed, procured, and maintained in a linear fashion. Software is an enduring capability that must be supported and continuously improved throughout its life cycle 13.

--- Chunk 428 ---
Tokens: 389
Type: sentence-based
Text:
Software is an enduring capability that must be supported and continuously improved throughout its life cycle 13. Furthermore, the malleable nature of software allows iter- ation among and interleaving of the develop- ment phases (to a much greater degree than is possible when developing physical artifacts). Software is made by people and for people, so digital talent matters. Software projects are increasingly important, and their ongoing success largely depends on people with the right skills, knowledge and abilities. This fact 9-2 SWEBOK  GUIDE V4.0 is essentially actual and necessary but not suf- ficient. Other human factors may affect the projects success. During the software devel- opment lifecycle, it is impossible to separate the human factors from the technical ones. Therefore, people management activities, such as team and teamwork, leadership, com- munication, and coordination activities, are important to project success. Software reuse can be a key factor in main- taining and improving productivity and competitiveness. Factors such as cultural differences and diverse attitudes may affect the develop- ment team. A significant number of software projects failed due to social issues. A high quality developer can produce inappro- priate or poor quality products that require rework if presented with poor requirements or communication. Other issues can complicate effective man- agement of software projects and software life cycle processes, including the following:  Clients often do not know what is needed or what is feasible.

--- Chunk 429 ---
Tokens: 394
Type: sentence-based
Text:
Other issues can complicate effective man- agement of software projects and software life cycle processes, including the following:  Clients often do not know what is needed or what is feasible. Increased understanding and changing conditions will likely generate new or changed software requirements. Clients often do not appreciate the com- plexities inherent in software engi- neering, particularly regarding the impact of changing requirements. As a result of changing requirements and software malleability, software is often built iteratively rather than as a linear sequence of phases. Software is nominally an enduring capa- bility that must be supported and contin- uously improved throughout its lifecycle. Software construction differs from hard- ware implementation in that design is usually part of software construction, whereas in hardware-oriented systems, design precedes hardware implementa- tion to get it right prior to procurement or fabrication of hardware 12. Software engineering necessarily incorpo- rates creativity and discipline. Maintaining an appropriate balance between the two is sometimes difficult 5. The development of software capabilities often involves a high degree of novelty and complexity. Typically, the underlying technology has a high rate of change. Computer software has become a key component of most modern systems. Software has been elevated to a highly prominent role because of its flexibility and relatively low replication cost com- pared with hardware. A significant number of software projects failed due to human issues.

--- Chunk 430 ---
Tokens: 386
Type: sentence-based
Text:
A significant number of software projects failed due to human issues. Physical mea- surement units such as the length and weight measures are challenging to apply to the software. This difficulty impacts how to plan, monitor, and control soft- ware development projects. Software rework to remove faults and respond to change. Speed and cycle time are important met- rics for managing software. Software capabilities are often delivered at increasing speed to satisfy business and mission needs 13. SEM activities occur on three levels: orga- nizational and infrastructure management, project management, and management of the measurement program. The last two are cov- ered in detail in this KA description. This fact does not diminish the importance of organiza- tional and infrastructure management issues but rather points out that software organiza- tional engineering managers should be con- versant with the project management and software measurement knowledge described in this KA. They should also possess some target domain knowledge. Likewise, it also helps for managers of complex projects and programs where software is part of the system architecture to know what issues software engineering processes (versus other types of engineering processes) introduce into project management and project measurement. Other aspects of organizational man- agement affect software engineering  for SOFTWARE ENGINEERING MANAGEMENT 9-3 example, organizational policies and proce- dures that provide the framework for software engineering projects.

--- Chunk 431 ---
Tokens: 348
Type: sentence-based
Text:
Other aspects of organizational man- agement affect software engineering  for SOFTWARE ENGINEERING MANAGEMENT 9-3 example, organizational policies and proce- dures that provide the framework for software engineering projects. These policies and pro- cedures might need to be adjusted for effec- tive software development and maintenance requirements. In addition, several policies specific to software engineering might need to be in place or established for the effective management of software engineering at the organizational level. For example, policies are usually necessary to establish specific organi- zation-wide processes or procedures for soft- ware engineering tasks such as software design, software construction, estimating, monitoring and reporting. Such policies are important for effective long-term management of software engineering projects across an organization (e.g, one such policy could establish a con- sistent basis for analyzing past project perfor- mance and implementing improvements). Another important aspect of organiza- tional management is the use of personnel management policies and procedures for hiring, training and mentoring  not only for a projects success, but also for the orga- nizations long-term success. Given the pro- jected scarcity of skilled software engineers, it is important to provide an environment that attracts and retains good talent.

--- Chunk 432 ---
Tokens: 393
Type: sentence-based
Text:
Given the pro- jected scarcity of skilled software engineers, it is important to provide an environment that attracts and retains good talent. Software engineering personnel can present unique training or personnel management chal- lenges (e.g, maintaining currency in a context where the underlying technology undergoes rapid and continuous change) as part of career development. Communication management is also often mentioned as an overlooked but important aspect of success in a field where a pre- cise understanding of user needs, software requirements and software designs is nec- essary. Furthermore, portfolio manage- ment is desirable, which provides an overall view of software under development in var- ious projects and programs (integrated proj- ects) of planned software, and of software already in use in an organization. Also, soft- ware reuse can be a key factor in maintaining and improving productivity and competitive- ness. Effective reuse requires a strategic vision that reflects the advantages and disadvantages of reuse. Software engineers should have a sound understanding of the aspects of management that are unique to software projects, and they should also have some knowledge of the more general aspects of management discussed in this KA (even in the first few years after graduation). Certain attributes of organizational cul- ture and behavior, as well as management of functional areas of the enterprise outside the immediate software engineering realm, can influence an organizations software engi- neering processes, albeit indirectly.

--- Chunk 433 ---
Tokens: 353
Type: sentence-based
Text:
Certain attributes of organizational cul- ture and behavior, as well as management of functional areas of the enterprise outside the immediate software engineering realm, can influence an organizations software engi- neering processes, albeit indirectly. Software projects are often targeted at changing the way people work  but culture change is dif- ficult, complicated and unlikely to succeed without a significant effort. For this reason, leadership is an important attribute for pro- gram managers, as they often need to lead the charge for digital transformation. They might need to galvanize their teams and other stakeholders to bring their very best to every project pursuing major change. Extensive information concerning project management can be found in the Guide to the Project Management Body of Knowledge (PMBOK Guide fifth edition) and the Software Extension to the PMBOK Guide (SWX) 1, 2. Each of these guides includes 10 project management KAs: project integration man- agement, project scope management, project timeschedule management, project cost man- agement, project quality management, project resourcehuman management, project com- munications management, project risk man- agement, project procurement management and project stakeholder management. Each KA has direct relevance to this SEM KA. Additional information is also provided in this KAs references and list of Further Readings.

--- Chunk 434 ---
Tokens: 384
Type: sentence-based
Text:
Additional information is also provided in this KAs references and list of Further Readings. This SEM KA discusses the software project management processes shown as the first five topics in Figure 9-1 (Initiation and Scope Definition, Software Project Planning, Software Project Enactment, Review and Evaluation, Closure), as well as Software Engineering Measurement (the sixth topic 9-4 SWEBOK  GUIDE V4.0 shown in the figure) and Software Engineering Management Tools (the seventh topic). Unfortunately, a common perception of the software industry is that software prod- ucts often are delivered late, are over budget, are of poor quality and have incomplete functionality. Measurement-informed man- agement  a basic principle of any true engi- neering discipline (see Measurement in the Engineering Foundations KA)  can help improve perception and reality. In essence, management without measurement (qualita- tive and quantitative) suggests a lack of disci- pline, and measurement without management suggests a lack of purpose or context. To be effective, software engineers must use both measurement and management. The following working definitions are adopted here:  Management is a system of processes and controls required to achieve the strategic objectives set by the organization. Measurement refers to the assignment of values and labels to software engi- neering work products, processes and resources, plus the models derived from them, whether these models are devel- oped using statistical or other techniques 3, c7, c8.

--- Chunk 435 ---
Tokens: 338
Type: sentence-based
Text:
Measurement refers to the assignment of values and labels to software engi- neering work products, processes and resources, plus the models derived from them, whether these models are devel- oped using statistical or other techniques 3, c7, c8. The software engineering project manage- ment sections in this KA use the Software Engineering Measurement section extensively. This KA is closely related to others in the SWEBOK Guide; reading the following KA descriptions will be particularly helpful in understanding this one:  The Engineering Foundations KA describes some general measurement concepts that directly apply to the Software Engineering Measurement section of this KA. In addi- tion, the concepts and techniques pre- sented in the Statistical Analysis section of the Engineering Foundations KA apply directly to many topics in this KA. The Software Requirements KA describes activities that should be performed during the projects Initiation and Scope Definition phase. The Software Configuration Management KA deals with the identification, control, status accounting and auditing of soft- ware configurations, along with software release management and delivery and software configuration management tools. The Software Engineering Process KA describes software life cycle models and the relationships between processes and work products.

--- Chunk 436 ---
Tokens: 384
Type: sentence-based
Text:
The Software Engineering Process KA describes software life cycle models and the relationships between processes and work products. Software Engineering Management Initiation and Scope Denition Software Engineering Measurement Determination and Negotiation of Requirements Feasibility Analysis Process for the Review and Revision of Requirements Process Planning Determine Deliverables Eort, Schedule, and Cost Estimation Implementation of Plans Software Acquisition and Supplier Contract Management Implementation of Measurement Process Monitor Process Control Process Reporting Determine Satisfaction of Requirements Reviewing and Evaluating Performance Determine Closure Closure Activities Establish and Sustain Measurement Commitment Plan the Measurement Process Perform the Measurement Process Evaluate Measurement Software Project Planning Software Project Enactment Software Review and Evaluation Closure Software Engineering Management Tools Figure 9.1. Breakdown of Topics for the Software Engineering Management KA SOFTWARE ENGINEERING MANAGEMENT 9-5  The Software Quality KA emphasizes quality as a management goal and as an aim of many software engineering activities. The Software Engineering Economics KA discusses how to make software-re- lated decisions in a business context. BREAKDOWN OF TOPICS FOR SOFTWARE ENGINEERING MANAGEMENT Because most software development life cycle (SDLC) models require similar activities that may be executed in different ways, the topic breakdown, shown in Figure 9-1, is activi- ty-based.

--- Chunk 437 ---
Tokens: 391
Type: sentence-based
Text:
BREAKDOWN OF TOPICS FOR SOFTWARE ENGINEERING MANAGEMENT Because most software development life cycle (SDLC) models require similar activities that may be executed in different ways, the topic breakdown, shown in Figure 9-1, is activi- ty-based. The top-level elements shown in the figure are activities that are usually per- formed when a software development project is being managed, regardless of which SDLC model is being used (see Software Life Cycle Models in the Software Engineering Process KA). This breakdown does not recommend a specific life cycle model. However, it is important to note the choice of the SDLC can have a impact on program activities to accommodate changing requirements. Delivery speed, continuous adaptation and frequent modular upgrades to deliver new capabilities are often key business differenti- ators and project management imperative 11, 13. These imperatives should be balanced with risk management activities. Several software life cycle process models have been and are being developed to shorten development cycles in response to changing business needs, specifically, changing soft- ware requirements. Most of these pro- cesses involve Agile SDLC approaches 14. The Agile approach assumes that teams can develop high-quality, adaptive software using continuous design improvement prin- ciples and testing based on rapid feedback and change. In comparison, the traditional approach assumes that software-intensive sys- tems are fully specifiable and predictable and can be built through meticulous and exten- sive planning.

--- Chunk 438 ---
Tokens: 378
Type: sentence-based
Text:
In comparison, the traditional approach assumes that software-intensive sys- tems are fully specifiable and predictable and can be built through meticulous and exten- sive planning. The management style asso- ciated with the Agile approach emphasizes leadership and collaboration at the team level, whereas the management style of the highly predictive approach is more formal (top- down). Many Agile approaches integrate dif- ferent management approaches. For example, DevSecOps is a culture and an Agile approach to modern software delivery that aligns development (Dev), secu- rity (Sec) and operations (Ops) groups into an integrated team focused on continuous, incre- mental delivery of capabilities. The main char- acteristic of DevSecOps is that this approach automates, continuously monitors and applies security at all phases of the software life cycle: plan, develop, build, test, release, deliver, deploy, operate and monitor. In DevSec Ops, testing and security are shifted to the left through automated unit, functional, inte- gration and security testing. This is a key DevSecOps differentiator; securityquality assurance (QA) and other nonfunctional and functional capabilities are tested and built simultaneously 11, 14. Whereas Dev SecOps encompasses the culture and pro- cesses that enable rapid, continual delivery of cyber-resilient systems, complex soft- ware-embedded systems can have additional demands that must also be integrated into the DevSecOps culture and processes, such as safety.

--- Chunk 439 ---
Tokens: 356
Type: sentence-based
Text:
Whereas Dev SecOps encompasses the culture and pro- cesses that enable rapid, continual delivery of cyber-resilient systems, complex soft- ware-embedded systems can have additional demands that must also be integrated into the DevSecOps culture and processes, such as safety. Elevating these demands to be on par with DevSecOps highlights the impor- tance of incorporating quality into all program aspects. The complexity of the end-to-end DevSecOps tools and of using emerging tech- nologies such as artificial intelligence (AI) and machine learning (ML) to leverage those tools adds another dimension 15. For example, Agile and DevOps approaches are reasonably well-established, but in case of AI-based soft- ware, new SLDCs maybe required to manage the complexity brought by AI to the software. It is important to understand the differ- ence between phases and activities and why an activities breakdown is used. The Project Management Institute (PMI) describes a phase this way: The completion and approval of one or more deliverables characterizes a project phase. A deliverable is a measurable, verifiable work product such as a specification, 9-6 SWEBOK  GUIDE V4.0 feasibility study report, detailed design docu- ment or working prototype. Some deliverables correspond to part of the project management process, whereas others are the end products or components of the end products for which the project was conceived.

--- Chunk 440 ---
Tokens: 398
Type: sentence-based
Text:
Some deliverables correspond to part of the project management process, whereas others are the end products or components of the end products for which the project was conceived. The deliverables, and hence the phases, are part of a generally sequential process designed to ensure proper control of the project and to attain the desired product or service, which is the projects objec- tive. From a project management perspective, phases help accomplish project objectives and maintain control over the project. The activity-based breakdown in Figure 9-1 shows what happens but does not imply when, how or how many times each activity occurs. The seven topics are the following:  Initiation and Scope Definition, which deals with the decision to embark on a software engineering project  Software Project Planning, which addresses the activities undertaken to pre- pare for a successful software engineering project from the management perspective  Software Project Enactment, which deals with generally accepted SEM activities that occur during a software engineering projects execution  Review and Evaluation, which deals with ensuring that technical, schedule, cost and quality engineering activities are satisfactory  Closure, which addresses the activities accomplished to complete a project  Software Engineering Measurement, which deals with the effective develop- ment and implementation of measure- ment programs in software engineering organizations  Software Engineering Management Tools, which describes the selection and use of tools for managing a software engineering project 1.

--- Chunk 441 ---
Tokens: 393
Type: sentence-based
Text:
The seven topics are the following:  Initiation and Scope Definition, which deals with the decision to embark on a software engineering project  Software Project Planning, which addresses the activities undertaken to pre- pare for a successful software engineering project from the management perspective  Software Project Enactment, which deals with generally accepted SEM activities that occur during a software engineering projects execution  Review and Evaluation, which deals with ensuring that technical, schedule, cost and quality engineering activities are satisfactory  Closure, which addresses the activities accomplished to complete a project  Software Engineering Measurement, which deals with the effective develop- ment and implementation of measure- ment programs in software engineering organizations  Software Engineering Management Tools, which describes the selection and use of tools for managing a software engineering project 1. Initiation and Scope Definition Project initiation focuses on reviewing the software requirements and determining the need, scope, feasibility, and authorization for a software project Once project feasibility has been established, the remaining tasks in this section are specifying the software require- ments and selecting the processes for require- ments revision and review. 1.1. Determination and Negotiation of Requirements 3, c3 Determining and negotiating the project requirements are the overarching goals of the tasks undertaken during this phase (see the Software Architecture KA and Software Requirements KA).

--- Chunk 442 ---
Tokens: 365
Type: sentence-based
Text:
Determination and Negotiation of Requirements 3, c3 Determining and negotiating the project requirements are the overarching goals of the tasks undertaken during this phase (see the Software Architecture KA and Software Requirements KA). Activities should include software requirements review (e.g, elicita- tion, analysis, specification, and validation). Methods and techniques should be selected and applied considering the various stake- holder perspectives. Requirements provide the basis for all that follows on a software project and are captured in a Project Charter or other high-level project initiation document. 1.2. Feasibility Analysis 4, c5 The purpose of the feasibility analysis is to develop a clear description of project objec- tives and to evaluate alternative approaches to determine whether the proposed project solu- tion is the best approach, given the constraints of technology, resources, finances and changes to ethical, environmental, and socio-technical considerations. An initial project and product scope statement, project deliverables, project duration constraints, and an estimation of resources needed should be prepared. Resources (which can be internal or external to the organization) include infrastructure, support, and people with the necessary core competencies. The feasibility analysis often requires estimations of effort and cost based on appropriate methods. (See Section 2.3, Effort, Schedule and Cost Estimation.)

--- Chunk 443 ---
Tokens: 400
Type: sentence-based
Text:
(See Section 2.3, Effort, Schedule and Cost Estimation.) An initial work breakdown structure (WBS) and context diagram may be devel- oped during the projects Initiation and Scope Definition phase activities. Breaking work into smaller tasks is a common productivity SOFTWARE ENGINEERING MANAGEMENT 9-7 technique that makes the work more man- ageable and approachable. As the project tool that uses this technique, WBS is an important project management document. While a WBS can be used to organize cost and schedule tracking, the WBS does not itself include cost and schedule baselines. Schedules are developed as part of the next activity, project planning (section 2). An engineering context diagram defines the boundary between the system (or a part of the system) and its environment, showing the entities interacting with it. This document is important in defining management and technical interfaces and trade-offs that must be considered 1. While engineers are devel- oping the WBS, they should consider all con- figuration items as tasks to have under control. 1.3. Process for the Review and Revision of Requirements 3, c3 Given the inevitability of change, stake- holders should agree on how requirements and scope will be reviewed and revised (e.g, change management and trade-off proce- dures, iterative cycle retrospectives). (See the Requirements KA.) This indicates that scope and requirements will not be set in stone but can and should be revisited at predetermined points as the project unfolds (for example, at the time when backlog pri- orities are created or at milestone reviews).

--- Chunk 444 ---
Tokens: 383
Type: sentence-based
Text:
This indicates that scope and requirements will not be set in stone but can and should be revisited at predetermined points as the project unfolds (for example, at the time when backlog pri- orities are created or at milestone reviews). If changes are accepted, then forward or backward traceability analysis and risk anal- ysis should be used to ascertain the impact of those changes. For example, backward traceability may link the test script to its associated requirement and design. This link helps monitor the status of require- ments satisfaction and helps make deci- sions to stop testing. It also helps in making tradeoffs regarding requirements and design. (See Section 2.5, Risk Management, and Software Configuration Control in the Software Configuration Management KA.) A managed-change approach can also form the basis for evaluating success during closure of an incremental cycle or an entire project, based on changes that occurred along the way. (See Topic 5, Closure). 2. Software Project Planning A key step in software project planning should be selecting an appropriate SDLC model and, perhaps, tailoring it based on project scope, software requirements and a risk assess- ment. The SWX 2 states that project life cycles occupy a continuum from predictive to adaptive. Factors that characterize the posi- tions of software project life cycles within the continuum include (but are not limited to) the various ways requirements and plans are handled, how risk and cost are managed, and key stakeholder involvement.

--- Chunk 445 ---
Tokens: 396
Type: sentence-based
Text:
Factors that characterize the posi- tions of software project life cycles within the continuum include (but are not limited to) the various ways requirements and plans are handled, how risk and cost are managed, and key stakeholder involvement. Highly pre- dictive software project life cycles emphasize requirements specification and detailed plan- ning during the projects initiation and plan- ning phases. Detailed plans based on a known architecture, requirements and constraints are used to reduce risk and cost. Milestones are planned, versus continuous key stakeholder involvement. Highly adaptive software project life cycles, on the other hand, are character- ized by progressive requirements specification based on short iterative development cycles. Risk and cost are reduced by progressive evo- lution of initial plans, and key stakeholders are continuously involved 2. Other factors to consider include the nature of the application domain, func- tional and technical complexity, and software quality requirements. (See Software Quality Requirements in the Software Quality KA.) In all SDLCs, risk assessment should be an element of initial project planning, and the risk profile of the project should be dis- cussed and accepted by all relevant stake- holders. Software quality management processes (see Software Quality Management Processes in the Software Quality KA) should be planned along with project plan- ning. This planning should establish proce- dures and responsibilities for software quality assurance (SQA), verification and valida- tion, reviews, and audits.

--- Chunk 446 ---
Tokens: 397
Type: sentence-based
Text:
This planning should establish proce- dures and responsibilities for software quality assurance (SQA), verification and valida- tion, reviews, and audits. (See the Software Quality KA.) Processes and responsibilities 9-8 SWEBOK  GUIDE V4.0 for ongoing review and revision of the project plan and related plans should also be clearly stated and agreed upon. 2.1. Process Planning 3, c3, c4, c5, 5, c1 SDLC models span a continuum from pre- dictive to adaptive. (See Software Life Cycle Models in the Software Engineering Process KA.) Predictive SDLCs are characterized by the development of detailed software archi- tecture and software requirements, detailed project planning, and minimal planning for iteration among development phases. Adaptive SDLCs are designed to accommo- date emergent software requirements and iterative adjustment of plans. A highly pre- dictive SDLC executes the first five pro- cesses listed in Figure 9-1 in a linear sequence with revisions to earlier phases only as nec- essary. Adaptive SDLCs are characterized by iterative development cycles. SDLCs in the midrange of the SDLC continuum pro- duce increments of functionality on either a preplanned schedule (on the predictive side of the continuum) or as the products of fre- quently updated development cycles (on the adaptive side of the continuum). Well-known SDLCs include the water- fall, incremental and spiral models, plus var- ious Agile software development approaches 2, 11 3, c2. Relevant methods (see the Software Engineering Models and Methods KA) and tools should be selected as part of planning.

--- Chunk 447 ---
Tokens: 384
Type: sentence-based
Text:
Relevant methods (see the Software Engineering Models and Methods KA) and tools should be selected as part of planning. Automated tools that will be used throughout the project should also be planned for and acquired. Tools might include those for project scheduling, software requirements, software design, software construction, soft- ware maintenance, software configuration management, software engineering process and software quality, among others. Many of these tools should be selected based primarily on the technical considerations discussed in other KAs, but some of those concerns are closely related to the management consider- ations discussed in this chapter. 2.2. Determine Deliverables 3, c4, c5, c6 Each project activitys work product(s) (e.g, software architecture design documents, inspection reports, tested software) should be identified and characterized. Opportunities to reuse software components from previous proj- ects or to use off-the-shelf software products should be evaluated. Software procurement and use of third parties to develop delivera- bles should be planned and suppliers selected. (See Section 3.2, Software Acquisition and Supplier Contract Management.) 2.3. Effort, Schedule, and Cost Estimation The topic of estimation in general is addressed in the Software Engineering Economics KA. Questions like What is estimation? and Why do we estimate? are addressed there. This section addresses management-specific estimation topics. Estimating costs for software projects is an error-prone process.

--- Chunk 448 ---
Tokens: 364
Type: sentence-based
Text:
Estimating costs for software projects is an error-prone process. The effort required for any given software project depends almost entirely on human elements: individuals experience and capabilities, team members interactions, and the culture of the software development environment. Dynamic environmental factors, such as rapid technology evolution, changing and emergent requirements, and the intangible nature of the product, also significantly affect cost management. Estimating costs when this much variability exists is difficult even when significant historical data exists. Software project managers should use multiple estima- tion approaches and then reconcile the differ- ences among the estimates 3, 10, 11. When data is available, the estimated range of effort required for a project, or parts of a project, can be determined using a calibrated estimation model based on historical size and effort data. It is best to also use bottom-up estimation techniques based on estimates from those who will accomplish the work and historical data based on similar projects 2. Task dependencies can be established, and potential opportunities for completing tasks SOFTWARE ENGINEERING MANAGEMENT 9-9 concurrently and sequentially can be identi- fied and documented, using a Gantt chart, for example. In predictive SDLC projects, the expected schedule of tasks, with projected start times, durations and end times, is typ- ically produced during planning.

--- Chunk 449 ---
Tokens: 386
Type: sentence-based
Text:
In predictive SDLC projects, the expected schedule of tasks, with projected start times, durations and end times, is typ- ically produced during planning. In adaptive SDLC projects, an overall estimate of effort and schedule is typically developed from the initial understanding of the requirements, or, alternatively, constraints on overall effort and schedule may be specified and used to deter- mine an initial estimate of the number of iter- ative cycles and estimates of effort and other resources allocated to each cycle. Resource requirements (for example, people and tools needed) can usually be translated into cost estimates. The estima- tion of effort, schedule and cost is an itera- tive activity that should be negotiated and revised among affected stakeholders until consensus is reached on resources and time available for project completion. Program managers often use a model that links four association role types: responsible, account- able, consulted, and informed (i.e, RACI) to facilitate this process. Responsible roles pro- duce deliverables; accountable roles check the deliverables; consulted roles advise on tasks; and informed roles are kept informed throughout these processes. Project managers should constantly monitor stakeholder require- ments and changes as they evolve to analyze their impact on the project cost and schedule. This is usually more important in Agile soft- ware development projects, where stakeholder requirements are dynamic because changes might occur rapidly as the project progresses. 2.4.

--- Chunk 450 ---
Tokens: 366
Type: sentence-based
Text:
2.4. Resource Allocation 3, c5, c10, c11 Equipment, facilities and people should be allocated to the identified tasks, including allocating responsibilities for completing var- ious project elements and the overall project. A matrix that shows who is responsible for, accountable for, consulted about and informed about each task can be used. Resource allo- cation is based on and constrained by the availability of resources and their optimal use, and by issues relating to personnel (e.g, productivity of individuals and teams, team dynamics, and team structures). 2.5. Risk Management 3, c9 5, c5 Risk and uncertainty are related but distinct concepts. Uncertainty results from a lack of information. Risk is effect of uncertainty on objectives that has negative (threats) or positive (opportunities) consequences on objectives. Risk management entails identifying risk factors, analyzing probability and potential impact of each risk factor, prioritizing risk factors, and developing risk mitigation strat- egies to reduce the probability of a negative event and to minimize the negative impact if a risk factor becomes a problem. Risk man- agement data can be used to represent the project risk profile; this data is often part of a risk register. A risk register is a document used as a risk management tool. It can be used to fulfill regulatory compliance, serving as a repository for all risks identified and for addi- tional information about each risk 2.

--- Chunk 451 ---
Tokens: 365
Type: sentence-based
Text:
It can be used to fulfill regulatory compliance, serving as a repository for all risks identified and for addi- tional information about each risk 2. Risk assessment methods (e.g, expert judgment, historical data, decision trees and process simulations) can sometimes be used to iden- tify and evaluate risk factors. Project abandonment conditions can also be determined with all relevant stakeholders. Software-unique aspects of risk, such as soft- ware engineers tendency to add unneeded features or the risks related to softwares intangible nature, can influence risk man- agement for software projects. Particular attention should be paid to managing risks related to software quality requirements such as safety or security 11. (See the Software Quality KA.) Risk management should be done not only at the beginning of a project, but also at periodic intervals throughout the project life cycle. 2.6. Quality Management 3, c4 4, c2 According to the PMBOK Guide, Project quality management includes the performing 9-10 SWEBOK  GUIDE V4.0 organizations processes and activities that determine quality policies, objectives and responsibilities so the project will satisfy the needs for which it was undertaken. This section discusses additional considerations for managing software project quality 1. Software quality requirements for a soft- ware project and the associated work prod- ucts should be identified, perhaps both quantitatively and qualitatively.

--- Chunk 452 ---
Tokens: 346
Type: sentence-based
Text:
Software quality requirements for a soft- ware project and the associated work prod- ucts should be identified, perhaps both quantitatively and qualitatively. Quality attributes of software include but are not limited to safety, security, reliability, avail- ability, performance, ease of use and ease of modification. SWX Section 1.9 lists quality attributes that are important for software users (e.g, efficiency, safety, security, reli- ability, availability) and quality attributes that are important to software developers and maintainers (e.g, maintainability is important to those who provide sustain- ment services) 1. ISOIEC 25000 series of standards provides extensive lists of software quality attributes that align with different stakeholder needs 2. This align- ment is consistent with ISOIECIEEE 15939 and practical software and systems measurement (PSM) 2, 9.11. Large portions of system functionality are shifting from hardware to software to capitalize on the increased flexibility and speed of component delivery that soft- ware can provide. However, with these benefits come other challenges  for example, the need for increased man- agement of software quality require- ments (e.g, cybersecurity) throughout the SDLC 11. Thresholds for acceptable quality measurements should be set for each software quality requirement based on stakeholder needs and expectations.

--- Chunk 453 ---
Tokens: 394
Type: sentence-based
Text:
Thresholds for acceptable quality measurements should be set for each software quality requirement based on stakeholder needs and expectations. Procedures concerned with ongoing SQA and quality improvement throughout the development process and with veri- fying and validating the deliverable soft- ware product should also be specified during quality planning (e.g, technical reviews and inspections or demonstra- tions of completed functionality). (See the Software Quality KA.) 2.7. Plan Management 3, c4 Except for older predictive programs, doc- umenting and managing formal plans are becoming less emphasized in managing most software projects. (e.g, documentation plans are rarely used, especially when Model-Based Systems Engineering (MBSE) is used for product data). The said, where they are used, plans should be developed and managed for software projects when change is expected. The magnitude of the planning effort and the plans content should be determined partly by the risk of not developing the plan. The management of the project plan should itself be planned. Plans and processes selected for software development should be systemat- ically monitored, reviewed, reported and, when appropriate, revised. Plans associated with supporting processes (e.g, documenta- tion, software configuration management, and problem resolution) also should be man- aged. Reporting, monitoring and controlling a project should fit within the selected SDLC and the realities of the project. Plans should account for the various artifacts that will be used to manage the project.

--- Chunk 454 ---
Tokens: 385
Type: sentence-based
Text:
Plans should account for the various artifacts that will be used to manage the project. Project managers of predictive life cycle software projects put substantial effort into up-front development of the project plan and integration of subsidiary plans developed by support personnel from other organiza- tional units (e.g, estimation specialists in the Project Management Office (PMO)). In other types of programs (e.g, adap- tive programs) where formal plans are not usually used, the emphasis should be on selecting and retaining project information useful in project control and future projects, and establishing strategy, policies, and pro- cedures. For example, in adaptive programs, managers will usually spend less effort up front on developing detailed scope, cost and schedule plans. But significant effort is typ- ically spent defining monitor and control processes, such as requirements traceability, to ensure coordination among the project members or teams as the emerging plans are implemented 2. SOFTWARE ENGINEERING MANAGEMENT 9-11 3. Software Project Execution During software project enactment (also known as project execution), plans are imple- mented, and the processes embodied in the plans are enacted. Throughout, there should be a focus on adherence to the selected SDLC processes, with an overriding expectation that adherence will satisfy stakeholder require- ments and achieve the projects objectives. Fundamental to enactment are the ongoing management activities of monitoring, con- trolling and reporting. 3.1.

--- Chunk 455 ---
Tokens: 331
Type: sentence-based
Text:
3.1. Implementation of Plans 4, c2 Project activities should follow the project plan and supporting plans. Project activities use resources (personnel, technology and funding) and generate work products (software design, software code and software test cases). 3.2. Software Acquisition and Supplier Contract Management 3, c3, c4 Software acquisition and supplier contract management concern issues involved in con- tracting with customers of the software development organization who acquire the deliverable work products and with suppliers who supply products or services to the soft- ware engineering organization. Software acquisition is common practice in software development projects, with inte- grated development environments (IDEs) and package libraries allowing software engineers to acquire third-party libraries with minimal steps, facilitating the assess- ment of risk, legality and suitability. However, software is no longer exclusively acquired as a shrink-wrapped product via a complex supply chain process and pur- chasing route. The ease of acquiring soft- ware has resulted in a common attack surface and led to security vulnerabilities. Organizations should consider introducing technical or procedural controls to minimize risk potentially exposed by unfiltered access to external library repositories.

--- Chunk 456 ---
Tokens: 268
Type: sentence-based
Text:
Organizations should consider introducing technical or procedural controls to minimize risk potentially exposed by unfiltered access to external library repositories. The different software acquisition classes include commercial off-the-shelf (COTS) software  an existing product acquired as is from another software vendor, with appli- cable license terms; software developed exclu- sively for the organization by another party  typically contracted and sometimes a cus- tomization of COTS software; open source software  nominally free, although the orga- nization may purchase enhanced support or maintenance and must review the license for restrictions on use; customer loaned software  typically to provide simulation or integra- tion with another system element; software as a service (SaaS)  which might include soft- ware the organization rents to fulfill a partic- ular need (for example, a cloud-based hosting, source control or development environment). Software projects typically use different acquisition approaches to obtain the necessary software components.

--- Chunk 457 ---
Tokens: 399
Type: sentence-based
Text:
Software projects typically use different acquisition approaches to obtain the necessary software components. However, regardless of how the software components are obtained, the following activities should be performed: verifying that each component is complete, correct and consistent concerning the archi- tectural design and software requirements for that component; integrating the components; verifying that the integrated components are correct, complete and consistent concerning the architectural design and the software requirements; and validating that the inte- grated components will satisfy their intended purpose when used in their intended oper- ating environment. Different acquisition approaches (for obtaining software components) require dif- ferent approaches to managing the project. For example, custom development requires detailed planning for the numbers and skills of the software developers, organizing the development team(s), allocating requirements to the teams, specifying project metrics to be collected, monitoring progress, and applying corrective actions when actual progress does not agree with planned progress. Licensing components involves evaluating candidate components; selecting appropriate compo- nents; and negotiating terms, conditions, and delivery dates for the selected components. 9-12 SWEBOK  GUIDE V4.0 This might involve selecting appropriate contracts, such as fixed price, time-and-mate- rials, cost plus fixed fee, and cost-plus incentive fee. Agreements with customers and suppliers typically specify the scope of work and the deliverables.

--- Chunk 458 ---
Tokens: 375
Type: sentence-based
Text:
Agreements with customers and suppliers typically specify the scope of work and the deliverables. The agreements can also include special clauses, such as clauses establishing penalties for late delivery or no delivery, and intellectual property agreements that specify what the suppliers are providing and what the acquirer is paying for, plus what will be delivered to and owned by the acquirer. For software developed by suppliers (both those internal to and those external to the software development organization), agreements com- monly establish software quality requirements. In software contracting with suppliers, data set acquisition is usually important. It includes the process of obtaining specific datasets from external vendors or partners as part of a software development project or service agreement. This can occur in various scenarios, such as: date licensing agreements, data provisioning, custom data acquisition and data integration services. After the agreement has been put in place, executing the project in compliance with the terms of the agreement should be man- aged. (See Chapter 12, Software Extension to the PMBOK Guide (SWX), Software Procurement Management, for more infor- mation on this topic 2.) 3.3. Implementation of Measurement Process 3, c7 The measurement process should be enacted during the software project to ensure that relevant and useful data is collected. (See Sections 6.2, Plan the Measurement Process, and 6.3, Perform the Measurement Process.) 3.4.

--- Chunk 459 ---
Tokens: 353
Type: sentence-based
Text:
3.4. Monitor Process 3, c8 Adherence to the scope, project plan and related plans should be assessed continually and at predetermined intervals. Outputs and completion criteria for each task should also be assessed. Deliverables should be evaluated for their required characteristics (for example, via inspections or by demonstrating working functionality). Effort expenditure, schedule adherence, costs to date, and resource use should be analyzed. The project risk pro- file (see Section 2.5, Risk Management) should be revisited, and adherence to soft- ware quality requirements should be evalu- ated (see Software Quality Requirements in the Software Quality KA). Measurement data should be analyzed. (See Statistical Analysis in the Engineering Foundations KA.) Variance analysis should be conducted to determine deviation of actual from expected outcomes and values. This anal- ysis might examine cost overruns, schedule slippage or other measures. Outlier identifica- tion and analysis of quality and other measure- ment data should be performed (e.g, defect analysis). (See Software Quality Measurement in the Software Quality KA.) Risk exposures should be recalculated. (See Section 2.5, Risk Management.) These activities can enable problem detection and exception identification based on thresholds that have been exceeded. Outcomes should be reported as necessary or when thresholds have been exceeded.

--- Chunk 460 ---
Tokens: 371
Type: sentence-based
Text:
Outcomes should be reported as necessary or when thresholds have been exceeded. For example, the timely identification, mitigation, and resolution of software security vulnerabil- ities and weaknesses that exceed expectations can affect the systems security posture 11. 3.5. Control Process 3, c7, c8 Project monitoring activities provide the basis for making decisions. Where appropriate, and when the probability and impact of risk fac- tors are understood, changes can be made to the project. This may take the form of cor- rective action (e.g, retesting certain software components). It might involve incorporating additional actions (e.g, deciding to use pro- totyping to assist in software requirements validation; see Prototyping in the Software Requirements KA). It might also entail revising the project plan and other project documents (e.g, the software requirements specification) to accommodate unanticipated events and their implications. SOFTWARE ENGINEERING MANAGEMENT 9-13 In some instances, the control process might lead to abandonment of the project. In all cases, the software development team should adhere to software configuration con- trol and software configuration management procedures. (See the Software Configuration Management KA.) Decisions should be doc- umented and communicated to all relevant parties, plans should be revisited and revised when necessary, and relevant data should be recorded. (See Section 6.3, Perform the Measurement Process.) 3.6.

--- Chunk 461 ---
Tokens: 385
Type: sentence-based
Text:
3.6. Reporting 3, c11 Progress to date should be reported at spec- ified and agreed-upon times both within the organization (e.g, to a project steering com- mittee) and to external stakeholders (e.g, cli- ents or users). Reports should focus on the information needs of the target audience as opposed to the detailed status reporting within the project team. 4. Software Review and Evaluation At prespecified times and as needed, overall progress toward the stated objectives and satisfaction of stakeholder (user and cus- tomer) requirements should be evaluated. Similarly, assessments of the effectiveness of the software process, the personnel involved, and the tools and methods used should also be undertaken regularly and as circum- stances demand. 4.1. Determining Satisfaction of Requirements 4, c8 Achieving stakeholder satisfaction is a prin- cipal goal of the software engineering man- ager. Progress toward this goal should be assessed periodically. Progress should be assessed upon achieving a major project milestone (e.g, completing software design architecture or completing a software tech- nical review) or upon completion of an iter- ative development cycle that results in a product increment. Variances from software requirements should be identified, and appro- priate actions should be taken. As in the control process activity above (see Section 3.5, Control Process), software con- figuration control and software configuration management procedures should be followed (see the Software Configuration Management KA).

--- Chunk 462 ---
Tokens: 388
Type: sentence-based
Text:
As in the control process activity above (see Section 3.5, Control Process), software con- figuration control and software configuration management procedures should be followed (see the Software Configuration Management KA). Decisions should be documented and communicated to all relevant parties; plans should be revisited and revised as neces- sary; and relevant data should be recorded (see Section 6.3, Perform the Measurement Process). 4.2. Reviewing and Evaluating Performance 3, c8, c10 Periodic performance reviews for project per- sonnel can provide insight into the likelihood of adherence to plans and processes and pos- sible areas of difficulty (e.g, team member conflicts). The various project methods, tools and techniques should be evaluated for effec- tiveness and appropriateness. The projects process should also be systematically and periodically assessed for relevance, utility and efficacy. Where appropriate, project changes should be made and managed. 5. Closure An entire project, a major project phase or an iterative development cycle reaches clo- sure when all the plans and processes have been enacted and completed. The criteria for project, phase or iteration success should then be evaluated. Once closure has been estab- lished, archival, retrospective and process improvement activities can be performed. 5.1. Determining Closure 1, s3.7, s4.6 Closure occurs when the specified tasks for a project, a phase or an iteration have been completed and satisfactory achievement of the completion criteria has been confirmed.

--- Chunk 463 ---
Tokens: 378
Type: sentence-based
Text:
Determining Closure 1, s3.7, s4.6 Closure occurs when the specified tasks for a project, a phase or an iteration have been completed and satisfactory achievement of the completion criteria has been confirmed. Software requirements can be confirmed as satisfied or not, and the degree of achieving the objectives can be determined. Closure 9-14 SWEBOK  GUIDE V4.0 processes should involve relevant stake- holders and document relevant stakeholders acceptance; any known problems should be documented. 5.2. Closure Activities 2, s3.7, s4.8 After closure has been confirmed, project materials should be archived in accordance with stakeholder agreed-upon rules for archival methods, location and duration  possibly including destruction of sensitive information, software and the medium on which copies are resident. For example, these rules could require that during closure, all data is removed and destroyed from any devices that contain relevant information before physical disposal of the devices (e.g, the hard drives of personal computers, servers, main- frames, personal digital assistants (PDAs), routers, firewalls, switches, tapes, diskettes, CDs, DVDs, cell phones, printers, universal serial bus (USB) data storage devices). The organizations measurement database should be updated with relevant project data. A project, phase or iteration retrospective analysis should be undertaken so that issues, problems, risks and opportunities encoun- tered can be analyzed. (See Topic 4, Review and Evaluation.)

--- Chunk 464 ---
Tokens: 398
Type: sentence-based
Text:
(See Topic 4, Review and Evaluation.) Lessons learned should be drawn from the project and fed into organiza- tional learning and improvement endeavors. 6. Software Engineering Measurement The importance of software engineering mea- surement for good management and engi- neering practices is widely acknowledged. (See Measurement in the Engineering Foundations KA.) Effective software engi- neering measurement has become one of the cornerstones of organizational maturity. Measurement can be applied to organiza- tions, projects, processes and work products. This section focuses on applying measure- ment at the levels of projects, processes and work products. 1 These two chapters can be downloaded free of charge from http:www.psmsc.comPSMBook.asp. This section follows ISOIECIEEE 15939 standard 6, which describes a pro- cess to define the activities and tasks neces- sary to implement a software measurement process. The standard also includes a mea- surement information model. This model in the PSM Continuous Iterative Development Measurement Framework report is also elab- orated for SDLC approaches 9. 6.1. Establish and Sustain Measurement Commitment 7, c1, c21  Establish measurement requirements. Each measurement endeavor should be guided by organizational objectives and driven by a set of measurement require- ments established by the organization and the project (e.g, an organizational objective might be first to market). Establish the scope of measurement. The project team should establish the organizational unit to which each mea- surement requirement is to be applied.

--- Chunk 465 ---
Tokens: 375
Type: sentence-based
Text:
The project team should establish the organizational unit to which each mea- surement requirement is to be applied. This might be a functional area, a single project, a single site or an entire enterprise. The temporal scope of the measurement effort should also be con- sidered because the time series of some measurements might be required (e.g, to calibrate estimation models). (See Section 2.3, Effort, Schedule and Cost Estimation.) Establish the teams commitment to measurement. The commitment should be formally established, communicated and supported by resources. Commit measurement resources. An organizations commitment to mea- surement is an essential factor for suc- cess, as evidenced by the assignment of resources for implementing the mea- surement process. Assigning resources includes allocation of responsibility for the various tasks of the measurement process (such as analyst and librarian). Adequate funding, training, tools and SOFTWARE ENGINEERING MANAGEMENT 9-15 support to conduct the process should also be allocated. 6.2. Plan the Measurement Process 7, c1, c21  Characterize the organizational unit. The organizational unit provides the context for measurement, so the organizational context should be explicit, including the organizations constraints on the mea- surement process. The characterization can be stated in terms of organizational processes, application domains, tech- nology, organizational interfaces and organizational structure. Identify information needs.

--- Chunk 466 ---
Tokens: 374
Type: sentence-based
Text:
Identify information needs. Information needs are based on the organizational units goals, constraints, risks, and prob- lems and may be derived from business, organizational, regulatory andor product objectives. Stakeholders should identify, prioritize, document, communicate and review these needs. Select measures. Select candidate mea- sures, with clear links to the information needs. Select measures based on the pri- orities of the information needs and other criteria such as cost of collection; degree of process disruption during collection; ease of obtaining accurate, consistent data; and ease of analysis and reporting. Internal quality characteristics (see Models and Quality Characteristics in the Software Quality KA) are often not contained in the contractually binding software requirements. Therefore, con- sider measuring the softwares internal quality to provide an early indicator of potential issues that might affect external stakeholders. Define data collection, analysis and reporting procedures. This encompasses collection procedures and schedules, storage, verification, analysis, reporting and data configuration management. Select criteria for evaluating the infor- mation products. The organizational units technical and business objectives influence evaluation criteria. Information products include those associated with the product produced and those associ- ated with the processes used to manage and measure the project. Provide resources for measurement tasks.

--- Chunk 467 ---
Tokens: 374
Type: sentence-based
Text:
Provide resources for measurement tasks. The appropriate stakeholders should review and approve the measurement plan to include all data collection pro- cedures; storage, analysis, and reporting procedures; evaluation criteria; sched- ules; and responsibilities. Criteria for reviewing these artifacts should be estab- lished at the organizational unit level or higher and should be used as the basis for these reviews. Such criteria should con- sider experience, resource availability and potential disruptions to projects when changes from current practices are pro- posed. Approval demonstrates commit- ment to the measurement process. o Identify resources to be made avail- able for implementing the planned and approved measurement tasks. Resource availability may be staged in cases where changes are piloted before widespread deployment. Consider the resources necessary for successful deployment of new procedures or measures. o Acquire and deploy supporting tech- nologies. This includes evaluating available supporting technologies, selecting the most appropriate tech- nologies, acquiring those technologies and deploying those technologies. 6.3. Perform the Measurement Process 7, c1, c2 Integrate measurement procedures with rel- evant software processes. The measurement procedures, such as data collection, should be integrated into the software processes they measure. This might involve changing current software processes to accommodate data col- lection or generation activities.

--- Chunk 468 ---
Tokens: 396
Type: sentence-based
Text:
This might involve changing current software processes to accommodate data col- lection or generation activities. It might also involve analyzing current software processes to minimize additional effort and evaluating 9-16 SWEBOK  GUIDE V4.0 the effect on employees to ensure acceptance of the measurement procedures. Consider morale issues and other human factors. In addition, communicate the measurement pro- cedures to those providing the data. Training and support might also be needed. Data anal- ysis and reporting procedures are typically integrated similarly into organizational and project processes. Collect data. Measurement data should be collected and analyzed. Data should be col- lected, verified and stored. Collection can sometimes be automated by using SEM tools (see Topic 7, Software Engineering Management Tools) to analyze data and develop reports. Data may be aggregated, transformed or recorded as part of the analysis, using a degree of rigor appropriate to the nature of the data and the information needs. This analysis typically produces graphs, numbers or other indicators that inform conclusions and recommendations to present to stakeholders. (See Statistical Analysis in the Engineering Foundations KA.) The results and conclusions are reviewed using the organizations formal or informal process. Data providers and mea- surement users should participate in reviewing the data to ensure it is meaningful and accurate and can result in reasonable actions. Communicate results. Document and communicate information products to users and stakeholders. 6.4.

--- Chunk 469 ---
Tokens: 373
Type: sentence-based
Text:
6.4. Evaluate Measurement 7, c1, c2 Evaluate information products and the mea- surement process against specified evalua- tion criteria, and determine the strengths and weaknesses of the information products or process. An internal process or an external audit can be used to perform the evaluation, including feedback from measurement users. Record lessons learned in an appropriate database. Identify potential improvements. Such improvements might be changes in the format of indicators, changes in units measured or reclassification of measurement categories. Determine potential improvements costs and benefits, and report appropriate improve- ment actions. Communicate proposed improvements to the measurement process owner and stake- holders for review and approval. Also, com- municate the lack of potential improvements if the analysis fails to identify any. 7. Software Engineering Management Tools 3, c5, c6, c7 SEM tools are often used to provide visibility and control of SEM processes. Some tools are automated, whereas others are manually imple- mented. In addition, there has been a recent trend toward using integrated suites of software engineering tools throughout a project to plan, collect and record, monitor and control, and report project and product information. Tools can be divided into the following categories: Project planning and tracking tools. Project planning and tracking tools can be used to estimate project effort and cost and to prepare project schedules.

--- Chunk 470 ---
Tokens: 400
Type: sentence-based
Text:
Project planning and tracking tools can be used to estimate project effort and cost and to prepare project schedules. For example, some proj- ects use automated estimation tools that use a software products estimated size and other characteristics as input and then estimate the required total effort, schedule and cost. Planning tools also include automated sched- uling tools that analyze the WBS tasks, their estimated durations, their precedence rela- tionships and the resources assigned to each task to produce a Gantt chart. Tracking tools can be used to track project milestones, regularly scheduled project status meetings, scheduled iteration cycles, product demonstrations and action items. Risk management tools. Risk management tools (see Section 2.5, Risk Management) can be used to track risk identification, anal- ysis and monitoring. These tools include sim- ulation or decision trees to analyze the effect of costs versus payoffs and subjective esti- mates of the probabilities of risk events. For example, Monte Carlo simulation tools can be used to produce probability distributions of effort, schedule and risk by algorithmi- cally combining multiple input probability distributions. SOFTWARE ENGINEERING MANAGEMENT 9-17 Communication tools. Communication tools can help provide timely and consistent infor- mation to relevant stakeholders involved in a project. Examples of such tools are email notifications and broadcasts to team mem- bers and stakeholders; regular communica- tions of meeting minutes; and charts showing progress, backlogs, and maintenance request resolutions.

--- Chunk 471 ---
Tokens: 400
Type: sentence-based
Text:
Examples of such tools are email notifications and broadcasts to team mem- bers and stakeholders; regular communica- tions of meeting minutes; and charts showing progress, backlogs, and maintenance request resolutions. Measurement tools. Measurement tools sup- port activities related to the software mea- surement program. (See Topic 6, Software Engineering Measurement.) There are few completely automated tools in this cate- gory. Measurement tools to gather, analyze and report project measurement data may be based on spreadsheets developed by project team members or organizational employees. MATRIX OF TOPICS VS. REFERENCE MATERIAL Fairley 2009 3 Sommerville 2011 4 Boehm and Turner 2003 5 McGarry et al. 2001 7 1. Initiation and Scope Definition 1.1. Determination and Negotiation of Requirements c3 1.2. Feasibility Analysis c4 1.3. Process for the Review and Revision of Requirements c3 2. Software Project Planning 2.1. Process Planning c2, c3, c4, c5 c1 2.2. Determine Deliverables c4, c5, c6 2.3. Effort, Schedule and Cost Estimation c6 2.4. Resource Allocation c5, c10, c11 2.5. Risk Management c9 c5 2.6. Quality Management c4 c24 2.7. Plan Management c4 3. Software Project Enactment 3.1. Implementation of Plans c2 3.2. Software Acquisition and Supplier Contract Management c3, c4 3.3. Implementation of Measurement Process c7 3.4. Monitor Process c8 3.5. Control Process c7, c8 3.6. Reporting c11 4. Review and Evaluation 4.1. Determining Satisfaction of Requirements 9-18 SWEBOK  GUIDE V4.0 4.2. Reviewing and Evaluating Performance c8, c10 5. Closure 5.1. Determining Closure 5.2.

--- Chunk 472 ---
Tokens: 380
Type: sentence-based
Text:
Determining Closure 5.2. Closure Activities 6. Software Engineering Measurement 6.1. Establish and Sustain Measurement Commitment c1, c2 6.2. Plan the Measurement Process c1, c2 6.3. Perform the Measurement Process c1, c2 6.4. Evaluate Measurement c1, c2 7. Software Engineering Management Tools c5, c6, c7 FURTHER READINGS A Guide to the Project Management Body of Knowledge (PMBOK Guide) 1. The PMBOK Guide provides guidelines for managing individual projects and defines project management-related concepts. It also describes the project management life cycle and its related processes, and the project life cycle. It is a globally recognized guide for the project management profession. Software Extension to the Project Management Body of Knowledge (PMBOK) Guide 2. SWX provides adaptations of and extensions to the generic practices of project manage- ment documented in the PMBOK Guide for managing software projects. The primary con- tribution of this extension to the PMBOK Guide is a description of processes for man- aging adaptive life cycle software projects. IEEE Standard Adoption of ISOIEC 15939 6. This international standard identifies a pro- cess that supports defining suitable measures to address specific information needs. It iden- tifies the activities and tasks necessary to suc- cessfully identify, define, select, apply and improve measurement within an overall project or organizational measurement structure. J. McDonald, Managing the Development of Software Intensive Systems, Wiley, 2010 8.

--- Chunk 473 ---
Tokens: 374
Type: sentence-based
Text:
J. McDonald, Managing the Development of Software Intensive Systems, Wiley, 2010 8. This textbook introduces project management for beginning software and hardware devel- opers, plus unique advanced material for expe- rienced project managers. Case studies are included for planning and managing verifica- tion and validation for large software projects and complex software and hardware systems, as well as inspection results and testing met- rics to monitor project status. REFERENCES 1 Project Management Institute, A Guide to the Project Management Body of Knowledge (PMBOK Guide), 6th ed, Newton Square, PA: Project Management Institute, 2017. SOFTWARE ENGINEERING MANAGEMENT 9-19 2 Software Extension to the Project Management Body of Knowledge (PMBOK Guide), Fifth Edition, Project Management Institute, 2013. 3 R. E. Fairley, Managing and Leading Software Projects. Hoboken, NJ: Wiley IEEE Computer Society Press, 2009. 4 I. Sommerville, Software Engineering, 10th ed, New York: Addison- Wesley, 2015. 5 B. Boehm and R. Turner, Balancing Agility and Discipline: A Guide for the Perplexed. Boston: Addison- Wesley, 2003. 6 IEEE, IEEE Standard Adoption of ISO IEC 15939: 2007 Systems and Software Engineering Measurement Process, ed: IEEE, 2017. 7 J. McGarry et al, Practical Software Measurement: Objective Information for Decision Makers, Addison-Wesley Professional, 2001. 8 J. McDonald, Managing the Development of Software-Intensive Systems. Hoboken, NJ: John Wiley and Sons, Inc, 2010.

--- Chunk 474 ---
Tokens: 292
Type: sentence-based
Text:
Hoboken, NJ: John Wiley and Sons, Inc, 2010. 9 Practical Software and Systems Measurement Continuous Iterative Development Measurement Framework Parts 1-3: Concepts, Definitions, Principles, and Measures, Version 2.1, 15 April 2021. 10 S. Sheard, M. Bouyaud, M. Osaisai, J. Siviy, and K. Nidiffer, Book Club Guides a Working Group to Create INCOSE System-Software Interface Products, INSIGHT, Volume 24, Issue 2, 2021. 11 K. Nidiffer, C. Woody, and T.A. Chick, Program Managers Guidebook for Software Assurance, Special Report, CMUSEI-2018-SR-025, Software Solutions and CERT Divisions, Software Engineering Institute Carnegie Mellon University, August 2018. 12 R.E. Fairley, Systems Engineering of Software-Enabled Systems, ISBN 978-1- 119-53501-0, 2019. 13 Defense Innovation Board, Software Is Never Done: Refactoring the Acquisition Code for Competitive Advantage Defense, v3.3, March 12, 2019. 14 DevOps: Building Reliable and Secure Systems Including Application Build, Package, and Deployment, IEEE Standard, 2675-2021, 2021. 15 M. Chemuturi and T. Cagley, Mastering Software Project Management: Best Practices, Tools and Techniques, J. Ross Publishing, July 2010.

--- Chunk 475 ---
Tokens: 388
Type: sentence-based
Text:
15 M. Chemuturi and T. Cagley, Mastering Software Project Management: Best Practices, Tools and Techniques, J. Ross Publishing, July 2010. 10-1 CHAPTER 10 Software Engineering Process ACRONYMS BPMN Business Process Modeling Notation CASE Computer-Aided Software Engineering CMM Capability Maturity Model CMMI Capability Maturity Model Integration GQM Goal-Question-Metric IDEF0 Integration Definition KA Knowledge Area PDCA Plan-Do-Check-Act SLCM Software Life Cycle Model SLCP Software Life Cycle Process UML Unified Modeling Language INTRODUCTION TO THE KA This chapter considers the software engi- neering process from several perspectives: concepts, life cycles, and software engi- neering process assessment. The software engineering community has been very active concerning the standardization of many of the aspects of the software engi- neering process. BREAKDOWN OF TOPICS FOR THE SOFTWARE ENGINEERING PROCESS KA The topic breakdown for the Software Engineering Process KA is shown in Figure 10.1. 1. Software Engineering Process Fundamentals 1.1 Introduction 1,c5,13 Software engineering processes involve work activities software engineers conduct to build and operate software. When the discipline of software engineering emerged, scientists, engineers and technicians had to look at existing disciplines to understand the scope of the software engineering process. An engi- neering process consists of a set of interrelated activities that transform one or more inputs into outputs while consuming resources to accomplish the transformation.

--- Chunk 476 ---
Tokens: 399
Type: sentence-based
Text:
An engi- neering process consists of a set of interrelated activities that transform one or more inputs into outputs while consuming resources to accomplish the transformation. As part of engineering, software engineering uses pro- cesses similar to those of other types of engi- neering. As engineers create devices or other products, they progress through various steps, expending significant design effort, relying on a vast trove of knowledge as they do so, at the time that they gain knowledge, i.e. learn, about the process they are performing and the product they are creating. Beginning in the 1960s and continuing in the 1970s, engineering design and manufac- turing provided a baseline  a foundation  for what would later become a new discipline. In those years, it was agreed that the process of building software would be decomposed into processes that could include design and manufacturing, and later, operations. Some of the processes needed to construct software systems fit into the design class, and others fit into the manufacturing class. Today, the soft- ware engineering community is still learning and, therefore, still improving the soft- ware engineering process. Currently, a wide consensus exists concerning that building 10-2 SWEBOK  GUIDE V4.0 software systems requires lots of design and learning effort focused on the product under construction, and on the process. As it will be discussed below, no ideal process, or set of processes exists: software processes must be selected, adapted, and applied as appropriate for each project and each organizational con- text.

--- Chunk 477 ---
Tokens: 354
Type: sentence-based
Text:
As it will be discussed below, no ideal process, or set of processes exists: software processes must be selected, adapted, and applied as appropriate for each project and each organizational con- text. It is essential that the software engi- neering process management is supported by empirical measurement. The concept of a project emerges as an endeavor with defined start and finish cri- teria undertaken to create a product or service in accordance with specified resources and requirements 1 or a temporary endeavor undertaken to create a unique product, ser- vice, or result 13. It is a concept of the man- agement discipline linked to clear objectives and bound by a limited time frame, as dis- cussed in knowledge area (KA) 9, Software Engineering Management. Software engi- neering processes are usually performed in the context of projects. Many of the processes of the more con- ventional engineering disciplines (e.g, elec- trical or chemical) include design and manufacturing, where manufacturing pro- duces multiple units of a system (e.g, a chem- ical reactor). This is not the case for software systems, though manufacturing is useful to describe the need to build the many software units that comprise a software system. In electrical or chemical engineering, the oper- ation of the engineering systems transforms (raw) materials, energy and physical entities into other forms of material or energy.

--- Chunk 478 ---
Tokens: 352
Type: sentence-based
Text:
In electrical or chemical engineering, the oper- ation of the engineering systems transforms (raw) materials, energy and physical entities into other forms of material or energy. For the software engineering discipline, an analogy for this operation could be the execution of a software unit (the output from a software engineering set of processes) that transforms one kind of data into another. In the rest of the section, the term process will denote work activities, not the execution of software. The Software Engineering Process KA is closely related to most of the SWEBOK Software Engineering Process Software Engineering Process Fundamentals Introduction Software Engineering Process Denition Life Cycle Denition, Process Cathegories and Terminology Rationale for Life Cycles Te Concepts of Process Models and Life Cycle Models Some Paradigm for Development Life Cycle Models Development Life Cycle Models and Teir Engineering Dimension Te Management of SLCPs Software Engineering Process Management Software Life Cycle Adaptation Practical Considerations Software Process Infrastructure, Tools, Methods Software Engineering Process Monitoring and the Relation to the Software Product Overview of Sotware Process Assesment and Improvement Global-Question-Metric (GQM) Framework-Based-Method Process Assesment and Improvement in Agile Life Cycles Software Process Assesment and Improvement Figure 10.1.

--- Chunk 479 ---
Tokens: 316
Type: sentence-based
Text:
The Software Engineering Process KA is closely related to most of the SWEBOK Software Engineering Process Software Engineering Process Fundamentals Introduction Software Engineering Process Denition Life Cycle Denition, Process Cathegories and Terminology Rationale for Life Cycles Te Concepts of Process Models and Life Cycle Models Some Paradigm for Development Life Cycle Models Development Life Cycle Models and Teir Engineering Dimension Te Management of SLCPs Software Engineering Process Management Software Life Cycle Adaptation Practical Considerations Software Process Infrastructure, Tools, Methods Software Engineering Process Monitoring and the Relation to the Software Product Overview of Sotware Process Assesment and Improvement Global-Question-Metric (GQM) Framework-Based-Method Process Assesment and Improvement in Agile Life Cycles Software Process Assesment and Improvement Figure 10.1. Breakdown of Topics for the Software Engineering Process KA SOFTWARE ENGINEERING PROCESS 10-3 KAs and the Software Engineering Management, Software Engineering Models and Methods, Software Quality, Software Architecture, and Software Testing KAs. The Measurement and Root Cause Analysis sec- tions in the Engineering Foundations KA is also closely related.

--- Chunk 480 ---
Tokens: 363
Type: sentence-based
Text:
The Measurement and Root Cause Analysis sec- tions in the Engineering Foundations KA is also closely related. 1.2 Software Engineering Process Definition 1,c52 71420 A process is a set of interrelated or interacting activities that transforms inputs into outputs, where activity is a set of cohesive tasks of a pro- cess, and a task is a required, recommended, or permissible action, intended to contribute to the achievement of one or more outcomes of a process 1. According to 2, a process is a predetermined course of events defined by its purpose or by its effect, achieved under given conditions. A third definition, following 7, is a system of activities, which use resources to transform inputs into outputs. And a fourth one is a set of interrelated or interacting activ- ities which transforms inputs into outputs to deliver an intended result 20. That is, the description of a process includes required inputs, transforming activities, and the outputs gener- ated. These definitions address any processes that are applied to the software part of software systems. Software systems also include hard- ware, and they also involve people and manual procedures. The output of one process can be an input to another process. Processes may include controls (e.g. directives and constraints) and enabling mechanisms (e.g. tools, technolo- gies or resources such as workforce and infra- structure) associated with the processes 14. 2. Life Cycles1 2.1.

--- Chunk 481 ---
Tokens: 395
Type: sentence-based
Text:
Life Cycles1 2.1. Life Cycle Definition, Process Categories, and Terminology 1,c5-63,c28,c1-313 A life cycle, according to 1, is the evolution of a system, product, service, project or other 1 Lifecycle, life-cycle and life cycle are different spellings. Merriam-Webster prefers the spelling life cycle. human-made entity from conception through retirement. In software engineering, life cycles help convey information about software systems, the systems for which software is of primary importance to the stakeholders 1. The concept of life cycles was put in place because simply identifying and defining the processes required to produce software did not adequately describe all the complexity of software systems. It was also necessary to define life cycles, which include a number of processes and constraints 8. In software engineering, development refers to a crucial stage of a system, product, ser- vice or project life cycle: that of building (or changing) a software system according to the stakeholders needs. From a production industrial management perspective, software systems are referred to as products. In this context, the term software product development lifecycle makes sense. Product life cycle can be defined as the series of phases that represent the evolution of a product, from concept through delivery, growth, maturity, to retirement 13. This definition is not specific to software sys- tems but applies to all products more gener- ally. Likewise, the life cycle concept, which is linked to the product concept, is not specific to software engineering.

--- Chunk 482 ---
Tokens: 300
Type: sentence-based
Text:
Likewise, the life cycle concept, which is linked to the product concept, is not specific to software engineering. Software systems contain software units that are an atomic-level software component of the software architecture that can be sub- jected to stand-alone testing. (See the Testing KA.) The life cycle of a software system (and keep in mind that software engineering uses an interdisciplinary approach) comprises all the processes, activities and tasks from the ideation of the software system to the retire- ment of the system, including production, operation and evolution, as well as acquisi- tion, when needed, and supply. Likewise, we can look at the life cycle of an element of a software system (a software unit). A soft- ware system life cycle will consider both the business and the technical needs of the stake- holders and the systems ability to produce, 10-4 SWEBOK  GUIDE V4.0 as the outcome of the different software life cycle processes (SLCPs) performed by a team, a product that meets the stakeholders needs, with the required quality level for its users and for all the different stakeholders. The following paragraphs enumerate the process categories, as enumerated in 1.

--- Chunk 483 ---
Tokens: 394
Type: sentence-based
Text:
The following paragraphs enumerate the process categories, as enumerated in 1. These process categories reflect the multiple perspectives involved in producing a soft- ware system: (1) technical processes including engineering practices to build, make, evolve, operate and retire software products; (2) technical management processes that cover planning and control, as well as configura- tion management, risk management, infor- mation management and quality assurance; (3) organizational project-enabling processes that support life cycle model and infrastruc- ture management, portfolio management, and human resources, knowledge and quality management; and finally (4) agreement pro- cesses, which are essential to support collec- tive decision-making, as well as acquisition and supply processes. A breakdown of these processes is as follows: 1. Technical processes a) Business or mission analysis process b) Stakeholder needs and requirements definition process c) Systemsoftware requirements defini- tion process d) Architecture definition process e) Design definition process f) System analysis process g) Implementation process h) Integration process i) Verification process j) Transition process k) Validation process l) Operation process m) Maintenance process n) Disposal process 2. Technical management processes a) Project planning process b) Project assessment and control process c) Decision management process d) Risk management process e) Configuration management process f) Information management process g) Measurement process h) Quality assurance process 3.

--- Chunk 484 ---
Tokens: 392
Type: sentence-based
Text:
Technical management processes a) Project planning process b) Project assessment and control process c) Decision management process d) Risk management process e) Configuration management process f) Information management process g) Measurement process h) Quality assurance process 3. Organizational project-enabling processes a) Life cycle model management process b) Infrastructure management process c) Portfolio management process d) Human resource management process e) Quality management process f) Knowledge management process 4. Agreement processes a) Acquisition process b) Supply processes 2.2. Rationale for Life Cycles 8,c2-312 Creating, operating and retiring software products require a number of processes, with their activities and tasks, and a number of constraints. As noted above, software systems involve people and manual procedures, as well as software and hardware. Defining software processes, following 12, requires specifying inputs and outputs. Inputs from processes are, very often, outputs from other processes. Therefore, life cycle processes are interre- lated processes; that is, each individual pro- cess (its inputs and outputs) may depend on other processes. The interrelated nature of the processes involved make the overall software engineering process highly complex. The specification of life cycles is a pow- erful tool for implementing an engineering approach to the creation, operation and retirement of software systems. A life cycle should be defined following engineering prin- ciples that guide engineering as a discipline 8.

--- Chunk 485 ---
Tokens: 387
Type: sentence-based
Text:
A life cycle should be defined following engineering prin- ciples that guide engineering as a discipline 8. The specification of a life cycle includes the specification of every process and the associated constraints. The process specifica- tion should be useful to humans so that they can communicate with one another using this specification. The specification should be easy to understand and correct because life cycle specifications are the basis for technical and SOFTWARE ENGINEERING PROCESS 10-5 engineering management, including coordina- tion and agreement, measurement, assessment and improvement, and quality management. 2.3. The Concepts of Process Models and Life Cycle Models 3,c210,c2c2 Section 2.1 provides a number of software life cycle definitions. In reference 2, a new defi- nition introduces the concept of a standard as a commonly accepted guiding document, stating that a project-specific sequence of activities  is created by mapping the activities of a stan- dard onto a selected software life cycle model (SLCM). That is, a life cycle is created in con- formance with the life cycle model. Examples of well-known life cycle models for product development are, among others, the waterfall model, the V-model, the incre- mental model, the spiral model and the Agile model 2,3, 10. 2.4. Some Paradigms for Development Life Cycle Models 3,c2-38,c2-3 9,c110,c121112 Each software system has its own features reflecting the stakeholders needs, both busi- ness and technical. A suitable life cycle will consider all these needs.

--- Chunk 486 ---
Tokens: 385
Type: sentence-based
Text:
A suitable life cycle will consider all these needs. As explained in Section 2.3, a software life cycle will be defined in conformance with (partially or fully conforming to) an SLCM. Some authors use the term development to refer to SLCM, e.g. iterative development instead of itera- tive (software) life cycle model. Types of life cycles are described below. Predictive life cycles are a form of project life cycle in which the project scope, time, and cost are determined in the early phase of the life cycle 13. Predictive life cycles assume that the set of requirements that will be implemented is a closed set that will not undergo substantive change unless a force majeure occurs. An iterative life cycle is a project life cycle where the project scope is generally deter- mined early in the project life cycle, but time and cost estimates are routinely mod- ified as the project team understanding of the product increases. Iterations develop the product through a series of repeated cycles, while increments successively add to the func- tionality of the product 3, 8, 13. The itera- tions duration is defined for each project. The method chosen (see KA 11) would prescribe the role and size of iterations. In an evolutionary life cycle, a product or service changes over its lifetime. It may happen because requirements and customer needs change, but it also may happen because requirements are introduced into the product in successive steps and not as a complete and atomic set 3, 8. Successive steps is a syn- onym for iterations.

--- Chunk 487 ---
Tokens: 398
Type: sentence-based
Text:
Successive steps is a syn- onym for iterations. An incremental life cycle is an adaptive project life cycle in which the deliverable is produced through a series of iterations that successively add functionality within a prede- termined time frame. The deliverable contains the necessary and sufficient capability to be considered complete only after the final itera- tion 3, 8, 13. Incremental life cycles are not always predictive, but they can be. Incremental development is a software development tech- nique in which requirements definition, design, implementation, and testing occur in an overlapping, iterative (rather than sequen- tial) manner, resulting in incremental com- pletion of the overall software product 2. Continuous development refers to software engineering practices that allow for frequent releases of new systems (including soft- ware) to staging or various test environments through the use of automated tools 8, 9, 11. A life cycle can enforce a rule that the requirements specifications cannot be changed once the requirements process has been finalized and the customer has agreed to the specifications. This happens, for example, in predictive life cycles. On the other hand, when the life cycle does not preclude changes in the requirements specifications, even after the customer has agreed to them and signed off on them, and in practice, allows them to change at any point upon negotiation of interested parts, then the life cycle is said to be open to change. Being open to change is one of the claims of Agile development 9, 10. 10-6 SWEBOK  GUIDE V4.0 2.5.

--- Chunk 488 ---
Tokens: 398
Type: sentence-based
Text:
10-6 SWEBOK  GUIDE V4.0 2.5. Development Life Cycle Models and Their Engineering Dimension 3,c28,c2-3 9,c110,c12 11 16 17 18 19252627 Several life cycle models have become well known with the development of software engineering since its inception. One model, which became popular early in the history of the discipline, is the waterfall model 3, that falls into the category of predictive, described previously. The waterfall model approach for product development uses a number of phases, including requirements, preliminary design, detailed design, coding and testing. It imple- ments a very strict process, in which one phase cannot be started until the previous one is fin- ished. The waterfall model was useful because it introduced a systematization in the develop- ment of software systems and, therefore, what could be referred to as an engineering approach to software product development. Many vari- ants or extensions, such as the V-model 3, with many different names and nuances, have been introduced in the history of software engineering. The waterfall model was an early attempt to address the so-called software crisis 3. The waterfall model is document-driven. Reference 2 defines the waterfall model as the model of the software development pro- cess in which the constituent activities, typ- ically a concept phase, requirements phase, design phase, implementation phase, test phase, and installation and checkout phase, are performed in that order, possibly with overlap but with little or no iteration. The waterfall model is clearly an example of a predictive life cycle.

--- Chunk 489 ---
Tokens: 375
Type: sentence-based
Text:
The waterfall model is clearly an example of a predictive life cycle. Some other para- digms, such as the incremental life cycle, also attempted to address the software crisis. In this model (see Section 2.4), different phases occur in an overlapping rather than sequential manner. An incremental life cycle can also be a predictive life cycle. This would mean that the requirements are defined and closed before any other development phase is started. The spiral model, introduced by Boehm, is evolu- tionary and risk-driven, as opposed to docu- ment- or code-driven 3. Reference 2 defines the spiral model as a model of the software development process in which the constit- uent activities, typically requirements anal- ysis, preliminary and detailed design, coding, integration, and testing, are performed itera- tively until the software is complete. Another popular model is rapid prototyping, a type of prototyping in which emphasis is placed on developing prototypes early in the devel- opment process to permit early feedback and analysis in support of the development process 2. The unified process, also known as unified software development process, is an iterative and incremental software development pro- cess framework 25. From the unified process, the rational unified process (RUP) is docu- mented in 26, and the OpenUP, managed by the Eclipse Foundation 27. The Agile Manifesto 16 effected a disrup- tion in the software engineering community by creating an abrupt change of mindset.

--- Chunk 490 ---
Tokens: 395
Type: sentence-based
Text:
The Agile Manifesto 16 effected a disrup- tion in the software engineering community by creating an abrupt change of mindset. The difference was that Agile Manifesto signato- ries claimed that the process should be open to change  requirements could be modified at any stage of the development process if users needs changed. Communication and mutual trust between teamcustomer were essential. Signatories claimed that team communication, often face-to-face, and communication with the customer were key. Nevertheless, the Agile Manifesto does not say that documents (e.g. to define requirements) are not needed, docu- ments are needed 9, 10. Signatories also advo- cated for small software incremental deliveries, as opposed to projects that applied the waterfall model with a single software delivery at the end of the project after months or years of working. Agile makes a clear distinction between, on the one side, values and principles (e.g, always delivering value to the customer or a commit- ment to technical excellence) and, on the other, practices (peer programming, sprint planning or retrospective). The Agile mindset 10 is dif- ferent from the predictive mindset. The Agile mindset is based on a number of values and principles (e.g, the importance of communi- cation, being open to change or commitment to technical excellence and always delivering value to the customer); this focus differentiates SOFTWARE ENGINEERING PROCESS 10-7 Agile from the predictive mindset, which is more focused on committing to the implemen- tation of the requirements specifications.

--- Chunk 491 ---
Tokens: 399
Type: sentence-based
Text:
The Agile mindset is based on a number of values and principles (e.g, the importance of communi- cation, being open to change or commitment to technical excellence and always delivering value to the customer); this focus differentiates SOFTWARE ENGINEERING PROCESS 10-7 Agile from the predictive mindset, which is more focused on committing to the implemen- tation of the requirements specifications. Agile helps address complexity 8, 10. Several misconceptions arose around Agile, and some still remain. One is that Agile is a method in itself, which it is not. Another is that Agile is faster than waterfall because you need not produce any document. A third one is that Agile has a limited or unstructured set of methodspractices; a chart that enumer- ates several commonly used Agile methods and practices can be found, for example, in 18. Several Agile methods became popular, like Extreme Programming for product devel- opment, Scrum for project management and others. Even considering the ever rising pop- ularity of the Agile life cycle model to address complex projects, scaling up Agile for large projects and portfolios is still challenging. The perception today is that the Agile Manifesto meant a significant disruption; nevertheless, it is already 20 years old, and some authors think that some of its principles might need be updated, informed by the experience devel- opers have obtained in the past 20 years 17. The application of Agile practices has tran- scended the software engineering process, and the terms business agility and Agile organiza- tions are now very common 19.

--- Chunk 492 ---
Tokens: 340
Type: sentence-based
Text:
The application of Agile practices has tran- scended the software engineering process, and the terms business agility and Agile organiza- tions are now very common 19. From a soft- ware engineering point of view, Agile created an opportunity for the industry to achieve a reengineering and a better alignment of soft- ware engineering processes and business stra- tegic processes in organizations. The use of an Agile approach by business processes is a common scenario; this is reflected in the prin- ciples of DevOps 11, for example, explained later in this section, and process assessment and improvement in Section 3. The need to provide more frequent releases, the fact that users needs and technological life cycles change more frequently, together with the required alignment of the organizations strategic plans with the organizations IT opera- tions, has led to the creation of DevOps, defined as a set of principles and practices which enable better communication and collaboration between relevant stakeholders for the purpose of specifying, developing, and operating software and systems products and services, and con- tinuous improvements in all aspects of the life cycle 11. The ability to provide more releases more frequently, once adequate process manage- ment has been defined, has become an advan- tage that makes companies more competitive.

--- Chunk 493 ---
Tokens: 399
Type: sentence-based
Text:
The ability to provide more releases more frequently, once adequate process manage- ment has been defined, has become an advan- tage that makes companies more competitive. In the history of software engineering, there has been a lot of controversy over soft- ware life cycle models  for example, as seen in debate over the merits of the water- fall model versus the Agile model of software development (See Section 2). This contro- versy should be understood from a historical perspective; new approaches have been dis- ruptive or considered disruptive, and there has been a lack of empirical measures to sup- port evidence-based discussions about soft- ware engineering. This situation has been changing slowly but steadily. Using empirical measures as the basis for making decisions is an essential element of software engineering 4, 8. See also KA 9, Software Engineering Management, and KA 12, Software Quality. 2.6. The Management of SLCPs 14 The life cycle for any software system contains a number of stages. According to 14, these stages are the following: 1. Concept: At this stage, stakeholders needs will be identified, concepts will be explored, and solutions will be proposed. 2. Development: At this stage, require- ments representing the users needs will be refined, solutions will be created, sys- tems built, and all undergo the needed verification and validation processes. 3. Production: This stage will have a dif- ferent scope depending on the character- istics of the software system under focus. Generally speaking, it will include the production and testing of the system. 4.

--- Chunk 494 ---
Tokens: 395
Type: sentence-based
Text:
4. Utilization: At this stage, the system operates to satisfy users needs. 5. Support: At this stage, developers pro- vide the required actions to achieve a sat- isfactory operation. 10-8 SWEBOK  GUIDE V4.0 6. Retirement: At this stage, the team fol- lows established procedures to dispose of the system. The stages are not supposed to be sequen- tial, by any means. Actually, the specifica- tion of the life cycle for a software system will include the transitions between these stages. It should be clear that these stages have been identified for a general life cycle. Specific life cycles will have specific stages, meaningful to a particular projects stakeholders; these stages will fit into these general stages. 2.7. Software Engineering Process Management 1,c52 Process management is defined as direction, control, and coordination of work performed to develop a product or perform a service 2. Several management levels govern the software engineering process, as explained in reference 1, see also KA 9, Software Engineering Management. The lowest level is the technical processes; the second is the tech- nical management level, which will include project management processes. The third level is the (executive) management level, focused on organizational enabling processes, such as knowledge management, life cycle model management, or portfolio management. 2.8. Software Life Cycle Adaptation 5 14 2329 Each software system has its differential char- acteristics. These differential characteristics, together with the stakeholders needs, lead to specific life cycles.

--- Chunk 495 ---
Tokens: 389
Type: sentence-based
Text:
These differential characteristics, together with the stakeholders needs, lead to specific life cycles. This adaptation will include identifying all the relevant characteristics, selecting the appropriate standards or docu- ments internal to an organization, selecting a development strategylife cycle model, stages, and processes, and documenting the decisions and rationale. The adaptation will not require keeping the names provided in Section 2, or including them all 5, 14, 23. The ISO IEC 29110 series, Systems and Software Engineering Standards and Guides for Very Small Entities (VSEs) 29, is an example of a series derived from ISOIECIEEE 12207. 2.9. Practical Considerations 8,c2-3 Defining a life cycle process includes the spec- ification of the four categories presented in Section 2. This means addressing technical processes (definition of the processes that will be required), organizational processes (this includes human resources, among other pro- cesses), technical management processes (how processes are related, how they are monitored and managed), and agreement processes. The discipline of software engineering has been evolving since its conception for several reasons. The community has never stopped learning, while the complexity of the prod- ucts has been ever-increasing. Defining a software life cycle for the development of a product requires considering the characteris- tics of the product (e.g, stakeholders needs, product size or complexity) and others external to the product, such as the stakeholders char- acteristics.

--- Chunk 496 ---
Tokens: 378
Type: sentence-based
Text:
Defining a software life cycle for the development of a product requires considering the characteris- tics of the product (e.g, stakeholders needs, product size or complexity) and others external to the product, such as the stakeholders char- acteristics. Something that the community has learned is that estimations and measurements are essential. Wrong or uncertain estimations in the context of a life cycle will lead to failure. Accurate estimations are not easy to produce. 8 A current trend in software engineering is a focus on continuous delivery, supported by realistic process and product estimations and measurements. A helpful lesson engi- neers have learned is that working with large processes without producing any delivera- bles along the way increases uncertainty. (See DevOps in Section 2.5.) The Agile mindset has contributed to this and has helped engi- neers recognize the importance of communi- cation in the process. 8 When a project process is defined in confor- mity with a life cycle, it is important to make sure that it will be possible to have metrics measure definitions that will result in realistic process (and product) estimations and mea- surements throughout project definition and execution, and to define the level of precision and uncertainty; project process (and product) measurements should always provide accurate SOFTWARE ENGINEERING PROCESS 10-9 information about what is happening (the status of the process and the product) while the life cycle process is executed.

--- Chunk 497 ---
Tokens: 363
Type: sentence-based
Text:
8 When a project process is defined in confor- mity with a life cycle, it is important to make sure that it will be possible to have metrics measure definitions that will result in realistic process (and product) estimations and mea- surements throughout project definition and execution, and to define the level of precision and uncertainty; project process (and product) measurements should always provide accurate SOFTWARE ENGINEERING PROCESS 10-9 information about what is happening (the status of the process and the product) while the life cycle process is executed. If we are uncer- tain about the accuracy of estimations and measurements, the project might not be suc- cessful. In this case, a reflection should take place on the overall approach. Historically, a lot of polemics have grown about the pre- dictive life cycle versus the Agile life cycle. In software engineering, discussions should always be supported by realistic process and product estimations and measurements, which can accurately reduce the level of uncertainty. 2.10. Software Process Infrastructure, Tools, Methods 3,c28,c2-32 Several notations have been used for defining software processes, including natural language, specifying textual lists of constituent activi- ties and tasks, data-flow diagrams, state charts, integration definition (IDEF0), Petri nets, and unified modeling language (UML) activity dia- grams, and business process modeling notation (BPMN) 2, 3.

--- Chunk 498 ---
Tokens: 361
Type: sentence-based
Text:
Software Process Infrastructure, Tools, Methods 3,c28,c2-32 Several notations have been used for defining software processes, including natural language, specifying textual lists of constituent activi- ties and tasks, data-flow diagrams, state charts, integration definition (IDEF0), Petri nets, and unified modeling language (UML) activity dia- grams, and business process modeling notation (BPMN) 2, 3. Software process infrastructure includes tools to support the definition of these processes (e.g, a BPMN toolkit) but mainly to support all specific processes (testing or con- figuration management). Process definitions will often include methods and formalism (e.g, Rational Unified Process or extreme program- ming) 3. Tools will, ideally, have to support these methods and, as important, be integrated with them. Therefore, it is not enough that a tool supports testing. Once a code unit has been successfully tested, for example, this becomes useful information that should be recorded so that the rest of the team can be aware of this fact. This means that the configuration man- agement tool and the testing tool will have to be integrated 3, 8. The term software engineering environment, representing a set of integrated tools, is sometimes used. The term CASE (com- puter-aided software engineering) was popular in the 1980s and 1990s. Somehow, the power tools of the 1980s and 1990s were oversold as a cure for the software crisis.

--- Chunk 499 ---
Tokens: 397
Type: sentence-based
Text:
Somehow, the power tools of the 1980s and 1990s were oversold as a cure for the software crisis. In any case, today, the automation of some processes (e.g, config- uration management, or at least version control; testing; ticket management) is seen as essential for the implementation of successful life cycles. You can also read KA 11, Software Engineering Models and Methods. 2.11. Software Engineering Process Monitoring and its Relationship with the Software Product 1,c5-63,c24c4-10 8c2-3 Developers must monitor the software engi- neering process execution, assess whether the process objectives are met, and assess risks. This process monitoring is part of software engineering process assessment (see Section 3) and part of the Software Engineering Management KA 1, 3, 4, 8. Empirical methods support process assess- ment and improvement as well as product assessment and improvement. The goal of pro- cess execution is to obtain products that meet stakeholders needs. While this area is focused on the software engineering process, process monitoring requires assessing both process and product, using a joint, more holistic approach. 3. Software Process Assessment and Improvement 3.1. Overview of Software Process Assessment and Improvement 4,c41524 The idea that any executed process can be improved was present in the classic Shewhart- Deming plan-do-check-act (PDCA) par- adigm 15, 24, which was already being discussed and applied in the 1950s, and its foundations can be found centuries earlier. For the software engineering process, several approaches have been developed.

--- Chunk 500 ---
Tokens: 352
Type: sentence-based
Text:
For the software engineering process, several approaches have been developed. The PDCA paradigm is an opportunity to meet a widely recognized need  the need for empirical evidence to make decisions. Such decisions include choosing a life cycle, deciding how to assess a process or deciding how to improve a process, among others. Getting empirical evidence across the execu- tion of a software engineering process is essen- tial for the success of the process execution. 4 10-10 SWEBOK  GUIDE V4.0 3.2. Goal-Question-Metric (GQM) 21 The GQM approach 21 is based on Basilis Quality Improvement Paradigm. Both are based on setting goals that can be measured, changing something, and then evaluating the effect of the change. When the evaluation is positive, an improvement has occurred. 3.3 Framework-Based Methods 4,c4-10622 Some assessment methods are based on frame- works that use a process reference model and an assessment reference model  for example, CMM (capability maturity model), CMMI 4, 22, and the ISOIEC 33000 4, 6 series, also known as SPICE. The ISOIEC 33000 framework includes a process reference framework and a pro- cess assessment model. The ISOIEC 33000 framework revises the ISOIEC 15504 series of International Standards, providing a framework for the assessment of (1) the pro- cess quality characteristics, one of which is process capability, together with (2) organi- zational maturity.

--- Chunk 501 ---
Tokens: 385
Type: sentence-based
Text:
The ISOIEC 33000 framework revises the ISOIEC 15504 series of International Standards, providing a framework for the assessment of (1) the pro- cess quality characteristics, one of which is process capability, together with (2) organi- zational maturity. This framework covers pro- cesses for the development, maintenance and use of systems across the information tech- nology domain, as well as processes for the design, transition, delivery and improvement of services. The concept of seeking continuous improvement underlies the assessment. This series has developed several groups of standards addressing, as well as core elements, basic requirements for performing process assessments, process models and the process measurement framework; guidance on how to perform assessments; measurement frame- works for the assessment of process capability and organizational maturity; process refer- ence models for special cases such as safety or high maturity; process assessment models for SLCPs, system life cycle process IT service management, safety and high maturity; and organizational maturity models. The process reference model is defined as a model comprising definitions of processes in a domain of application described in terms of process purpose and outcomes, together with an architecture describing the relationships between the processes. The process assess- ment model is defined as a model suitable for the purpose of assessing a specified process quality characteristic, based on one or more process reference models. 6 3.4.

--- Chunk 502 ---
Tokens: 362
Type: sentence-based
Text:
6 3.4. Process assessment and improvement in Agile 9,c1128 Agile methods (e.g, the scrum project man- agement method) introduce what they call retrospectives at the end of each iteration. The objective of the retrospective is to analyze what went well and what did not go well, to understand why, and to set a number of actions for learning and improvement. In the end, the team is in a continuous learning loop 9. This practice, with different names and scopes was not new in software engineering 28. MATRIX OF TOPICS VS. REFERENCE MATERIAL ISOIECI EEE 12207 1 Sommerville 3 Laporte et al. 4 Farley 8 Shore et al 9 PMI 10 Others 1. Software Engineering Process Fundamentals 1.1 Introduction c5 13 1.2 Software Engineering Process Definition c5 2 71420 SOFTWARE ENGINEERING PROCESS 10-11 2. Life Cycles 2.1 Life cycle definition, process categories and terminology c5-6 c2 c1-3 13 2.2 Rationale for life cycles c2-3 12 2.3 The concept of process models and life cycles models c2 c2 2 2.4 Some paradigms for development life cycle models c2-3 c2-3 c1 c1 2 11 13 2.5 Development life cycle models and their engineering dimension c2 c2-3 c1 c1 2 11 16 17 18 19 25 26 27 2.6 The management of SLCPs 14 2.7 Software engineering process management c5 2 2.8 Software life cycle adaptation 5 14 23 29 2.9 Practical considerations 2.10 Software process infrastructure, tools, methods c2 c2-3 2 2.11 Software engineering process monitoring c5-6 c2 c4-10 c2-3 3.

--- Chunk 503 ---
Tokens: 396
Type: sentence-based
Text:
Life Cycles 2.1 Life cycle definition, process categories and terminology c5-6 c2 c1-3 13 2.2 Rationale for life cycles c2-3 12 2.3 The concept of process models and life cycles models c2 c2 2 2.4 Some paradigms for development life cycle models c2-3 c2-3 c1 c1 2 11 13 2.5 Development life cycle models and their engineering dimension c2 c2-3 c1 c1 2 11 16 17 18 19 25 26 27 2.6 The management of SLCPs 14 2.7 Software engineering process management c5 2 2.8 Software life cycle adaptation 5 14 23 29 2.9 Practical considerations 2.10 Software process infrastructure, tools, methods c2 c2-3 2 2.11 Software engineering process monitoring c5-6 c2 c4-10 c2-3 3. Software Process Assessment and Improvement c4-10 3.1 Overview of software process assessment and improvement c4 15 24 3.2 Goal-question metric (GQM) 21 3.3 Framework-based methods c4-10 6 22 3.4 Process Assessment and improvement in Agile c11 28 REFERENCES 1 ISOIECIEEE 12207:2017 Systems and software engineering  Software life cycle processes. 2 ISOIECIEEE, ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, 2nd ed. 2017. 3 I. Sommerville, Software Engineering. 10th ed. 2016. 4 C. Y. Laporte and A. April, Software Quality Assurance, IEEE Computer Society Press, 1st ed, 2018. 5 Project Management Institute, Software Extension to the PMBOK Guide  Fifth Edition, 2013. 6 ISOIEC 33001:2015 Information technology  Process assessment  Concepts and terminology. 7 ISOIEC 25000:2014 Systems and software engineering  Systems and software product quality requirements and evaluation (SQuaRE)  Guide to SQuaRE.

--- Chunk 504 ---
Tokens: 395
Type: sentence-based
Text:
7 ISOIEC 25000:2014 Systems and software engineering  Systems and software product quality requirements and evaluation (SQuaRE)  Guide to SQuaRE. 8 D. Farley, Modern Software Engineering: Doing What Works to Build Better 10-12 SWEBOK  GUIDE V4.0 Software Faster. Addison-Wesley Professional, December 2021. 9 J. Shore and S. Warden, The Art of Agile Development, OReilly Media, 2nd ed. October 2021. 10 Project Management Institute, Agile Practice Guide. Project Management Institute and Agile Alliance. September 2017. 11 ISOIECIEEE Std 32675:2022 Information technology  DevOps  Building reliable and secure systems including application build, package and deployment. 12 ISOIECIEEE 24774:2021 Systems and software engineering  Life cycle management  Specification for pro- cess description. 13 Project Management Institute, A Guide to the Project Management Body of Knowledge (PMBOK Guide)  Sixth Edition. 14 ISOIECIEEE 24748-1:2018(E) Systems and software engineering  Life cycle management  Part 1: Guidelines for life cycle management. 15 W.A. Shewhart and W.E. Deming, Statistical Method from the Viewpoint of Quality Control. Dover, New York, 1986. 16 The Agile Manifesto. https: agilemanifesto.org. Accessed March 5, 2022. 17 S. McConnell, More Effective Agile: A Roadmap for Software Leaders, 2019. 18 Subway Map to Agile Practices. Agile Alliance. https:www.agilealliance.org agile101subway-map-to-agile -practices. Accessed March 5, 2022. 19 J. Eckstein and J. Buck, Company-wide Agility with Beyond Budgeting, Open Space  Sociocracy: Survive  Thrive on Disruption, 2021.

--- Chunk 505 ---
Tokens: 257
Type: sentence-based
Text:
19 J. Eckstein and J. Buck, Company-wide Agility with Beyond Budgeting, Open Space  Sociocracy: Survive  Thrive on Disruption, 2021. 20 ISOIEC TR 29110-5-3:2018 Systems and software engineering  Lifecycle profiles for very small entities (VSEs)  Part 5-3: Service delivery guidelines. 21 N. Fenton and J. Bieman, Software Metrics, 3rd ed. CRC Press, 2014. 22 CMMI Institute  CMMI V2.0. https:cmmiinstitute.comcmmi. Accessed 5 March 2022. 23 ISOIECIEEE 24748-3:2020. Part 3: Guidelines for the application of ISO IECIEEE 12207 (software life cycle processes). 24 D.R. Kiran, Total Quality manage- ment. Elsevier, 2017. 25 J. Rumbaugh, G. Booch, I. Jacobson. The Unified Software Development Process, 1999 26 P. Kruchten. The Rational Unified Process: An Introduction. 3rd Ed. 2004 27 The Eclipse Foundation https:www. eclipse.orgorgfoundation Accessed 25 April 2024. 28 T. Dingsyr, Postmortem reviews: pur- pose and approaches in software engi- neering, Information and Software Technology, Volume 47, Issue 5, 2005, Pages 293-303.

--- Chunk 506 ---
Tokens: 365
Type: sentence-based
Text:
28 T. Dingsyr, Postmortem reviews: pur- pose and approaches in software engi- neering, Information and Software Technology, Volume 47, Issue 5, 2005, Pages 293-303. 29 ISOIEC TR 29110-1:2016 Systems and software engineering Lifecycle pro- files for Very Small Entities (VSEs) Part 1: Overview 11-1 CHAPTER 11 Software Engineering Models and Methods ACRONYMS 3GL 3rd Generation Language BNF Backus-Naur Form FDD Feature-Driven Development IDE Integrated Development Environment PBI Product Backlog Item RAD Rapid Application Development UML Unified Modeling Language XP eXtreme Programming INTRODUCTION Software engineering models and methods impose structure on software engineering to make it systematic, repeatable and ultimately more success-oriented. Models provide an approach to problem-solving, a notation and procedures for model construction and anal- ysis. Methods provide an approach to the sys- tematic specification, design, construction, testing and verification of the end-item soft- ware and associated work products. Software engineering models and methods vary widely in scope  from addressing a single software life cycle phase to covering the complete software life cycle. This knowledge area (KA) focuses on models and methods that encompass multiple software life cycle phases regardless of the type of life cycle pro- cess models such as iterative models and agile ones, since other KAs cover methods specific to single life cycle phases.

--- Chunk 507 ---
Tokens: 377
Type: sentence-based
Text:
This knowledge area (KA) focuses on models and methods that encompass multiple software life cycle phases regardless of the type of life cycle pro- cess models such as iterative models and agile ones, since other KAs cover methods specific to single life cycle phases. BREAKDOWN OF TOPICS FOR SOFTWARE ENGINEERING MODELS AND METHODS This chapter on software engineering models and methods is divided into four main topic areas: 1. Modeling discusses the general practice of modeling and presents topics in modeling principles, properties and expression of models, modeling syntax, semantics, and pragmatics, as well as preconditions, postconditions, and invariants. 2. Types of Models briefly discusses models and aggregation of submodels and pro- vides general characteristics of model types commonly found in the software engineering practice. 3. Analysis of Models presents common anal- ysis techniques used in modeling to verify completeness, consistency, correctness, traceability and interaction. 4. Software Engineering Methods presents a summary of commonly used software engineering methods. The discussion guides the reader through a summary of heuristic methods, formal methods, pro- totyping and Agile methods. The breakdown of topics for the Software Engineering Models and Methods KA is shown in Figure 11.1. 1. Modeling Modeling of software is becoming a pervasive technique to help software engineers under- stand, engineer and communicate aspects of the software to appropriate stakeholders.

--- Chunk 508 ---
Tokens: 381
Type: sentence-based
Text:
Modeling Modeling of software is becoming a pervasive technique to help software engineers under- stand, engineer and communicate aspects of the software to appropriate stakeholders. 11-2 SWEBOK  GUIDE V4.0 Stakeholders are those people or parties with a stated or implied interest in the software (e.g, users, buyers, suppliers, architects, certifying authorities, evaluators, developers, software engineers). Although there are many modeling lan- guages, notations, techniques and tools in the literature and in practice, some general, unifying concepts apply to them all. The fol- lowing sections provide background on these general concepts. 1.1. Modeling Principles 1, c2s2, c5s1, c5s2, 2, c2s2, 3, c5s0 Modeling provides the software engineer with an organized and systematic approach for representing significant aspects of the software under study, facilitating deci- sion-making about the software or elements, and communicating those significant deci- sions to others in the stakeholder commu- nities. Three general principles guide such modeling activities:  Model the essentials: Good models do not usually represent every aspect or fea- ture of the software under every possible condition. Modeling typically involves only those aspects or features that pose specific questions, abstracting away any nonessential information. This approach keeps models manageable and useful. Provide perspective: Modeling provides views of the software under study using defined rules for expressing the model within each view.

--- Chunk 509 ---
Tokens: 385
Type: sentence-based
Text:
Provide perspective: Modeling provides views of the software under study using defined rules for expressing the model within each view. This perspective-driven approach provides dimensionality to the model (e.g, providing a structural view, a behavioral view, a temporal view, an organizational view andor other views if relevant). Organizing information into views focuses the software modeling efforts on specific concerns relevant to that view using the appropriate notation, vocabulary, methods and tools. Enable effective communications: Modeling uses the application domain vocabulary of the software, a modeling language and semantic expression (in other words, meaning within context). When used rigorously and systematically, mod- eling results in a reporting approach that facilitates effective communica- tion of software information to project stakeholders. Software Engineering Models and Methods Modeling Types of Models Analysis of Models Software Engineering Methods Modeling Principles Properties and Expression of Models Syntax, Semantics and Pragmatics Preconditions, Postconditions and Invariants Behavioral Modeling Structure Modeling Analyzing for Completeness Analyzing for Consistency Analyzing for Correctness Analyzing for Traceability Analyzing for Interaction Heuristic Methods Formal Methods Prototyping Methods Agile Methods Figure 11.1. Breakdown of Topics for the Software Engineering Models and Methods KA SOFTWARE ENGINEERING MODELS AND METHODS 11-3 A model is an abstraction or simplification of a system.

--- Chunk 510 ---
Tokens: 280
Type: sentence-based
Text:
Breakdown of Topics for the Software Engineering Models and Methods KA SOFTWARE ENGINEERING MODELS AND METHODS 11-3 A model is an abstraction or simplification of a system. A consequence of using abstrac- tion is that, because no single abstraction completely describes a software component, the software model comprises an aggregation of abstractions, which, when taken together, describe selected aspects, perspectives or views  only those that are needed to make informed decisions and respond to the reasons for creating the model in the first place. This simplification points to assumptions about the context within which the model is placed that should also be captured in the model. Then, when the model is reused, these assumptions can be validated first to establish the rele- vancy of the reused model within its new use and context. 1.2. Properties and Expression of Models 1, c5s2, c5s3, 3, c4s1.1p7, c4s6p3, c5s0p3 Properties of models are those distinguishing features of a particular model that charac- terize its completeness, consistency and cor- rectness within the chosen modeling notation and tooling.

--- Chunk 511 ---
Tokens: 369
Type: sentence-based
Text:
Properties and Expression of Models 1, c5s2, c5s3, 3, c4s1.1p7, c4s6p3, c5s0p3 Properties of models are those distinguishing features of a particular model that charac- terize its completeness, consistency and cor- rectness within the chosen modeling notation and tooling. Properties of models include the following:  Completeness  the degree to which all requirements have been implemented and verified within the model  Consistency  the degree to which the model contains no conflicting require- ments, assertions, constraints, functions or component descriptions  Correctness  the degree to which the model satisfies its requirements and design specifications and is free of defects Models are constructed to represent objects needed for target domains and their behaviors to answer specific questions about how the software is expected to operate. Interrogating the models  through exploration, simula- tion or review  might expose areas of uncer- tainty within the model and the software to which the model refers. These uncertain- ties or unanswered questions regarding the requirements, design andor implementation can then be handled appropriately. The primary expression element of a model is an entity. An entity may represent concrete artifacts (e.g, processors, sensors or robots) or abstract artifacts (e.g, software modules or communication protocols). Model entities are connected to other entities using relations (lines or textual operators on target entities).

--- Chunk 512 ---
Tokens: 370
Type: sentence-based
Text:
Model entities are connected to other entities using relations (lines or textual operators on target entities). Expression of model entities may be accom- plished using textual or graphical modeling languages; both modeling language types con- nect model entities through specific language constructs. The meaning of an entity may be represented by its shape, its textual attri- butes or both. Generally, textual information adheres to language-specific syntactic struc- ture. The precise meanings related to the mod- eling of context, structure or behavior using these entities and relations are dependent on the modeling language used, the design rigor applied to the modeling effort, the specific view being constructed and the entity to which the specific notation element may be attached. Multiple views of the model may be required to capture the needed semantics of the software. When using automation-supported models, models may be checked for completeness and consistency. The usefulness of these checks depends greatly on the level of semantic and syntactic rigor applied to the modeling effort and on explicit tool support. Correctness can be checked through model simulation, execu- tion or review. 1.3. Syntax, Semantics, and Pragmatics 2, c2s2.2.2p6, 3, c5s0 Models can be surprisingly deceptive. The fact that a model is an abstraction with missing information can give people the illusion that they completely understand the software after studying a single model.

--- Chunk 513 ---
Tokens: 342
Type: sentence-based
Text:
The fact that a model is an abstraction with missing information can give people the illusion that they completely understand the software after studying a single model. A complete model (complete being relative to the modeling effort) may be a union of multiple submodels and any special function models. Examination of and decision-making regarding a single model within this collection of submodels may be problematic. 11-4 SWEBOK  GUIDE V4.0 Understanding the precise meanings of modeling constructs can also be difficult. Syntactic and semantic rules define modeling languages. For textual languages, syntax is defined using a notation grammar that defines valid language constructs (e.g, Backus-Naur form (BNF)). For graphical languages, syntax is defined using graphical models called meta- models. As with BNF, metamodels define a graphical modeling languages valid syntac- tical constructs. In addition, the metamodel defines how these constructs can be composed to produce valid models. Semantics for modeling languages specify the meaning attached to the entities and relations captured within the model. For example, a simple diagram of two boxes con- nected by a line is open to various interpre- tations. Knowing that the diagram on which the boxes are placed and connected is an object diagram or an activity diagram can assist in interpreting this model.

--- Chunk 514 ---
Tokens: 343
Type: sentence-based
Text:
Knowing that the diagram on which the boxes are placed and connected is an object diagram or an activity diagram can assist in interpreting this model. As a practical matter, the semantics of a specific software model are usually fairly clear due to the models use of a modeling language, the way that modeling language expresses entities and relations within that model, the experience and skill of the mod- elers, and the context within which the mod- eling has been undertaken and represented. Meaning is communicated through the model even in the presence of incomplete informa- tion through abstraction. Pragmatics explains how meaning is embodied in the model and its context and how it is communicated effec- tively to other software engineers. However, there are still instances where caution is needed regarding modeling and semantics. For example, any model parts imported from another model or library must be examined for semantic assumptions that conflict with the new modeling environ- ment; these conflicts might not be obvious. The model should be checked for documented assumptions. Although the imported mod- eling syntax might be the same, it might mean something quite different in the new environ- ment, which is a different context. Also, con- sider that as software matures and changes are made, semantic discord can be intro- duced, leading to errors.

--- Chunk 515 ---
Tokens: 383
Type: sentence-based
Text:
Also, con- sider that as software matures and changes are made, semantic discord can be intro- duced, leading to errors. With many soft- ware engineers working on part of a model over time, and with tool updates and perhaps new requirements, there are opportunities for portions of the model to represent something different from the original authors intent and initial model context. 1.4. Preconditions, Postconditions, and Invariants 2, c4s4, 4, c10s4p2, c10s5p2p4 When modeling functions or methods, the software engineer typically starts with assumptions about the softwares state before, during and after the function or method exe- cutes. These assumptions are essential to the correct operation of the function or method and are grouped, for discussion, as a set of preconditions, postconditions and invariants. Preconditions are conditions that must be satisfied before execution of the function or method. If these preconditions do not hold before execution of the function or method, the function or method might produce erroneous results. Postconditions are conditions guaranteed to be true after the function or method has executed successfully. Typically, the postconditions represent how the soft- wares state has changed, how parameters passed to the function or method have changed, how data values have changed, or how the return value has been affected. Invariants are conditions within the oper- ational environment that persist (in other words, do not change) before and after execution of the function or method.

--- Chunk 516 ---
Tokens: 356
Type: sentence-based
Text:
Invariants are conditions within the oper- ational environment that persist (in other words, do not change) before and after execution of the function or method. These invariants are relevant and neces- sary to the software and to the correct operation of the function or method. 2. Types of Models A typical model consists of an aggregation of submodels. Each submodel is a partial description and is created for a specific pur- pose. A submodel may comprise one or more SOFTWARE ENGINEERING MODELS AND METHODS 11-5 diagrams. The collection of submodels may use multiple modeling languages or a single modeling language. The unified modeling language (UML) recognizes a rich collec- tion of modeling diagrams. These diagrams, along with the modeling language constructs, are used in two common model types: struc- tural models and behavioral models. (See Section 1.1.) Depending on modeling lan- guages, there can be other types of models. For instance, the systems modeling language (SysML) provides two other types of models: requirements models and parametric models. 2.1. Structural Modeling 1, c7s2.2, c7s2.5, c7s3.1, c7s3.2, 3, c5s3, c8s1, 4, c4, 17 Structural models illustrate the softwares physical or logical composition of software from its various component parts. Structural modeling establishes the defined boundary between the software being implemented or modeled and the environment in which it is to operate.

--- Chunk 517 ---
Tokens: 386
Type: sentence-based
Text:
Structural modeling establishes the defined boundary between the software being implemented or modeled and the environment in which it is to operate. Some common structural constructs used in structural modeling are composition, decomposition, generalization, and special- ization of entities; identification of relevant relations and cardinality between entities; and the definition of process or functional inter- faces. Structure diagrams provided by the UML for structural modeling include class, component, object, deployment, and pack- aging diagrams. Information modeling is a kind of struc- tural modeling and focuses on data and other information. An information model is an abstract representation that identifies and defines a set of concepts, properties, relations and constraints on data entities. The semantic or conceptual information model is often used to provide some formalism and context to the software as viewed from the problem perspec- tive, without concern for how this model is mapped to the implementation of the software. The semantic or conceptual information model is an abstraction and, as such, includes only the concepts, properties, relations and constraints needed to conceptualize a real-world view of the information. Subsequent transformations of the semantic or conceptual information model become logical and then physical data models as implemented in the software. 2.2. Behavioral Modeling 1, c7s2.1, c7s2.3, c7s2.4, 2, c9s2, 3, c5s4, 8, c1s5.4 Behavioral models identify and define soft- ware functions.

--- Chunk 518 ---
Tokens: 369
Type: sentence-based
Text:
Behavioral Modeling 1, c7s2.1, c7s2.3, c7s2.4, 2, c9s2, 3, c5s4, 8, c1s5.4 Behavioral models identify and define soft- ware functions. Behavioral models generally take three basic forms: state machines, con- trol-flow models and data-flow models. State machines provide a model that represents the software as a collection of defined states, events and transitions. The software tran- sitions from one state to the next through a guarded or unguarded triggering event that occurs in the modeled environment. Control- flow models depict how a sequence of events causes processes to be activated or deacti- vated. Data-flow models represent data-flow behavior as a sequence of steps where data moves through processes toward data stores or data sinks. These models are described in the way of event-triggered, time concepts (i.e, logical, physical, discrete, continuous, relative, or absolute time), or combinations thereof. Behavioral diagrams provided by the UML for behavioral modeling include use case, activity, state machine, and interaction (sequence, communication, timing, and inter- action overview) diagrams. 3. Analysis of Models The development of models allows the soft- ware engineer to study, reason about and understand software structure, function, operational use and assembly considerations. Analysis of constructed models is needed to ensure that the models are complete, con- sistent and correct enough to serve their intended purpose for the stakeholders.

--- Chunk 519 ---
Tokens: 386
Type: sentence-based
Text:
Analysis of constructed models is needed to ensure that the models are complete, con- sistent and correct enough to serve their intended purpose for the stakeholders. The following sections briefly describe the analysis techniques generally used to ensure that the software engineer and other relevant stakeholders gain appropriate value from the development and use of models. 11-6 SWEBOK  GUIDE V4.0 3.1. Analyzing for Completeness 3, c4s1.1p7, c4s6, 5, pp8-11 To ensure software fully meets the needs of the stakeholders, completeness  from the requirements elicitation process to code imple- mentation  is critical. Completeness is the degree to which all specified requirements have been implemented and verified. Engineers can check models for completeness with a modeling tool that uses structural analysis and state- space reachability analysis (which ensure some set of correct inputs reach all paths in the state models). Models may also be checked manually for completeness by using inspections or other review techniques. (See the Software Quality KA.) Errors and warnings generated by these analysis tools and found by inspection or review indicate that corrective actions are probably needed to ensure model completeness. 3.2. Analyzing for Consistency 3, c4s1.1p7, c4s6, 5, pp8-11 Consistency is the degree to which models contain no conflicting requirements, asser- tions, constraints, functions or component descriptions. Typically, consistency checking is accomplished with the modeling tool using an automated analysis function.

--- Chunk 520 ---
Tokens: 317
Type: sentence-based
Text:
Typically, consistency checking is accomplished with the modeling tool using an automated analysis function. Models may also be checked manually for consistency using inspections or other review techniques. (See the Software Quality KA.) As with com- pleteness, errors and warnings generated by these analysis tools and found by inspection or review indicate the need for corrective action. 3.3. Analyzing for Correctness 5, pp8-11 Correctness is the degree to which a model satisfies its software requirements and soft- ware design specifications, is free of defects, and ultimately meets the stakeholders needs. Analyzing for correctness includes verifying the models syntactic correctness (that is, cor- rect use of the modeling language grammar and constructs) and semantic correctness (that is, use of the modeling language constructs to correctly represent the meaning of that which is being modeled). To analyze a model for syn- tactic and semantic correctness, one analyzes it  either automatically (e.g, using the modeling tool to check for model syntactic correctness) or manually (using inspections or other review techniques)  searching for possible defects and then removing or repairing the confirmed defects before the software is released for use. 3.4.

--- Chunk 521 ---
Tokens: 351
Type: sentence-based
Text:
3.4. Analyzing for Traceability 3, c4s7.1, c4s7.2 Developing software typically involves using, creating and modifying many work products such as planning documents, process specifica- tions, software requirements, diagrams, designs and pseudo-code, handwritten and tool-gen- erated code, manual and automated test cases and reports, and files and data. These work products may share various dependency rela- tionships (e.g, uses, implements and tests). As software is developed, managed, maintained or extended, these traceability relationships must be mapped and controlled to demonstrate the software requirements consistency with the software model (see Requirements Tracing in the Software Requirements KA) and the many work products. Use of traceability typically improves the management of software work products and software process quality and assures stakeholders that all requirements are satisfied. Traceability enables change analysis once the software is developed and released because relationships to software work prod- ucts can easily be traversed to assess change impact. Modeling tools typically help automat- ically or manually specify and manage trace- ability links among requirements, design, code andor test entities that might be represented in the models and other software work products. (For more information on traceability, see the Software Configuration Management KA.) 3.5.

--- Chunk 522 ---
Tokens: 337
Type: sentence-based
Text:
3.5. Analyzing for Interaction 2, c10, c11, 3, c29s1.1, c29s5, 4, c5 Interaction analysis focuses on the communica- tions or control-flow relations between entities used to accomplish a specific task or function SOFTWARE ENGINEERING MODELS AND METHODS 11-7 within the software model. This analysis examines the dynamic behavior of the inter- actions among the software models different parts, including other software layers (such as the operating system, middleware and appli- cations). Examining interactions between the computer software application and the user interface software might also be important for some software applications. Some soft- ware modeling environments provide simula- tion facilities to study aspects of the dynamic behavior of modeled software. Stepping through the simulation allows the software engineer to review the interaction design and verify that the softwares different parts work together to provide the intended functions. 4. Software Engineering Methods Software engineering methods provide an organized and systematic approach to devel- oping software for a target computer. There are numerous methods from which to choose, and the software engineer needs to choose an appropriate method or methods for the soft- ware development task at hand. This choice can dramatically affect the success of the project.

--- Chunk 523 ---
Tokens: 381
Type: sentence-based
Text:
This choice can dramatically affect the success of the project. When software engineers, working with people who have the right skill sets and the right tools, use these software engineering methods, they can visualize the softwares details and ultimately transform the represen- tation into a working set of code and data. Selected software engineering methods are discussed below. The topic areas are orga- nized into discussions of Heuristic Methods, Formal Methods, Prototyping Methods and Agile Methods. 4.1. Heuristic Methods 1, c13, c15, c16, 3, c2s2.2, c7s1, c5, 8, pp.xiii-xvii 9, c2s2, 11, c1, 12, c1s1, 19, pp.220-242 Heuristic methods are experience-based soft- ware engineering methods that are fairly widely practiced in the software industry. This topic area contains five broad discussion categories: structured analysis and design methods, data modeling methods, object-oriented analysis and design methods, aspect-oriented develop- ment methods, and model-driven and mod- el-based development methods. Structured analysis and design methods: These methods develop the software model primarily from a functional or behavioral viewpoint. It starts from a high-level view of the software (including data and control elements). It then pro- gressively decomposes or refines the model components through increasingly detailed designs. The detailed designs eventually converge to specific software details or specifications that must be coded (by hand, automatically generated or both), built, tested and verified.

--- Chunk 524 ---
Tokens: 365
Type: sentence-based
Text:
The detailed designs eventually converge to specific software details or specifications that must be coded (by hand, automatically generated or both), built, tested and verified. Data modeling methods: The data model is constructed from the viewpoint of the data or information used. Data tables and relationships define the data models. This data modeling method is used primarily to define and analyze data requirements supporting database designs or data repositories typically found in business software, where data is actively managed as a business systems resource or asset. Object-oriented analysis and design methods: The object-oriented model is represented as a collection of objects that encapsulate data and relationships and interact with other objects through methods. Objects may be real-world items or virtual items. These methods build models using diagrams to constitute selected views of the software. Progressive refinement of the models leads to a detailed design. The detailed design is then either evolved through succes- sive iterations or transformed (using some mechanism) into the implementation view of the model, where the code and pack- aging for eventual software product release and deployment are expressed. Popular object-oriented approaches include Unified Process (UP) and specific implementa- tions of UP, such as Rational Unified Process (RUP). (See Software Design KA, Model-Based Requirements and Software Requirements KA.)

--- Chunk 525 ---
Tokens: 385
Type: sentence-based
Text:
(See Software Design KA, Model-Based Requirements and Software Requirements KA.) 11-8 SWEBOK  GUIDE V4.0  Aspect-Oriented Development Methods: The aspect-oriented approach aims to separate crosscutting concerns from non-crosscut- ting ones in the system and keeps them encapsulated throughout the entire life cycle to solve their scattering and tangling problem. Aspect is the unit of modularity to encapsulate crosscutting concerns. At the software level, there is a weaver that is in charge of joining the portions of functionality (advices) encapsulated in the incumbencies at certain points of base behavior (join points), according to well-defined predicates (pointcuts). Model-Driven and Model-Based Development Methods: Model-Driven Development (MDD) is an approach using models as primary artifacts of the development process. In MDD, usu- ally the implementation or other models are (semi)automatically transformed from the models. Model-Based Development (MBD) uses models to analyze the system, where models are not necessarily the pri- mary artifacts. Some literature refers to MBD as the acronym for Model-Based Design. Model-Based Design is a mod- el-centric approach to developing con- trol, signal processing, communications, and other dynamic systems, focusing on executable specification and simula- tion. See Software Design KA. Model- Driven Requirements and Model-Based Requirements apply the same mentality to specification of software requirements, see the Software Requirements KA for more information on this topic.

--- Chunk 526 ---
Tokens: 399
Type: sentence-based
Text:
Model- Driven Requirements and Model-Based Requirements apply the same mentality to specification of software requirements, see the Software Requirements KA for more information on this topic. MDDMBD is a prerequisite to Model-Based Architecture, see the Software Architecture KA. Sometimes, test cases are generated from models, see the Software Testing KA. 4.2. Formal Methods 1, c18, 3, c27, 5, pp8-24, 10, pp.xi-xiv Formal methods are software engineering methods that apply rigorous, mathemati- cally based notation and language to specify, develop and verify the software. Through use of a specification language, the software model can be systematically checked for con- sistency (or lack of ambiguity), complete- ness, and correctness, either automatically or semiautomatically. This topic is related to the Formal Analysis section in the Software Requirements KA. This section addresses specification lan- guages, program refinement and derivation, formal verification, logical inference, and lightweight formal methods. Specification languages: Specification lan- guages provide the mathematical basis for a formal method. Specification lan- guages are formal, higher-level computer languages (not a classic 3rd-generation language (3GL) programming language) used during the software specification, requirements analysis andor design stages to describe specific inputoutput behavior. Specification languages are not directly executable languages. Instead, they typ- ically comprise a notation and syntax, semantics for the use of the notation, and a set of allowed relations for objects.

--- Chunk 527 ---
Tokens: 377
Type: sentence-based
Text:
Instead, they typ- ically comprise a notation and syntax, semantics for the use of the notation, and a set of allowed relations for objects. Program refinement and derivation: Program refinement creates a lower-level (or more detailed) specification using a series of transformations. Through suc- cessive transformations, the software engineer derives an executable represen- tation of a program. Specifications may be refined, adding details until the model can be formulated in a 3GL program- ming language or in an executable por- tion of the chosen specification language. This specification refinement is made possible by defining specifications with precise semantic properties. For example, the specifications must set out not only the relationships between entities but also the exact runtime meanings of those relationships and operations. Formal verification: Model checking is a formal verification method. It typically involves performing a state-space explo- ration or reachability analysis to demon- strate that the represented software design SOFTWARE ENGINEERING MODELS AND METHODS 11-9 has or preserves certain model properties of interest. An example of model checking is an analysis that verifies correct program behavior under all possible interleaving of event or message arrivals. Formal verifica- tion requires a rigorously specified model of the software and its operational envi- ronment. This model often takes the form of a finite-state machine or other formally defined automaton.

--- Chunk 528 ---
Tokens: 389
Type: sentence-based
Text:
This model often takes the form of a finite-state machine or other formally defined automaton. Logical inference: Logical inference is a method of designing software that spec- ifies preconditions and postconditions around each significant design block. Using mathematical logic, it develops the proof that those preconditions and post- conditions must hold under all inputs. This allows the software engineer to pre- dict software behavior without having to execute the software. Some inte- grated development environments (IDEs) include ways to represent these proofs and the design or code. Lightweight Formal Methods: Lightweight formal methods are lightweight approaches that balance practical usability and rigorous verification. For instance, Alloy takes from formal specifi- cation the idea of a precise and expressive notation based on a tiny core of simple and robust concepts, but it replaces conven- tional analysis based on theorem proving with a fully automatic analysis that gives immediate feedback. Unlike theorem proving, this analysis is not complete: it examines only a finite space of cases. 4.3. Prototyping Methods 1, c12s2, 3, c2s3.1, 6, c7s3p5 Software prototyping is an activity that gen- erally creates incomplete or minimally func- tional versions of a software application, usually for trying out specific new features; soliciting feedback on software requirements or user interfaces; further exploring software requirements, software design, or imple- mentation options; or gaining some other useful insight into the software.

--- Chunk 529 ---
Tokens: 363
Type: sentence-based
Text:
Prototyping Methods 1, c12s2, 3, c2s3.1, 6, c7s3p5 Software prototyping is an activity that gen- erally creates incomplete or minimally func- tional versions of a software application, usually for trying out specific new features; soliciting feedback on software requirements or user interfaces; further exploring software requirements, software design, or imple- mentation options; or gaining some other useful insight into the software. The software engineer selects a prototyping method to first understand the least understood soft- ware aspects or components. This approach contrasts with other software engineering methods that usually begin development with the best-understood portions first. Typically, the prototype does not become the final soft- ware product without extensive development rework or refactoring. This section briefly discusses prototyping styles, targets and evaluation techniques. Prototyping style: Prototyping styles describe the various approaches to devel- oping prototypes. A prototype can be developed as throwaway code or a paper product, as an evolution of a working design, or as an executable specification. Different prototyping life cycle processes are typically used for each style. The style chosen is based on the type of results the project needs, the quality of the results needed and the results urgency. Prototyping target: The prototyping target is the specific product served by the pro- totyping effort.

--- Chunk 530 ---
Tokens: 390
Type: sentence-based
Text:
Prototyping target: The prototyping target is the specific product served by the pro- totyping effort. Examples of prototyping targets are a requirements specification, an architectural design element or com- ponent, an algorithm, and a human-ma- chine user interface. Prototyping evaluation techniques: The software engineer or other project stake- holders may use or evaluate the prototype in many ways, driven primarily by the underlying reasons that led to prototype development. Prototypes may be evalu- ated or tested against the implemented software or target requirements (e.g, a requirements prototype). The prototype might also serve as a model for future software development (e.g, as in a user interface specification). 4.4. Agile Methods 3, c3, 6, c7s3p7, 7, c6, App. A, 13, 14, 15, 16, 18 Agile methods were developed in the 1990s to reduce the apparent large overhead associated 11-10 SWEBOK  GUIDE V4.0 with heavyweight, plan-based methods used in large-scale software development projects. Agile methods are considered lightweight because of their short, iterative development cycles, self-organizing teams, simpler designs, code refactoring, test-driven development, frequent customer involvement and emphasis on creating a demonstrable working product with each development cycle. Agile methods can be seen as an application of the Deming improvement cycle of Plan-Do-Check-Act (PDCA) to software engineering. For example, EVO, which is one of the earliest agile methods, is known as a practical way to implement the PDCA cycle incrementally.

--- Chunk 531 ---
Tokens: 383
Type: sentence-based
Text:
For example, EVO, which is one of the earliest agile methods, is known as a practical way to implement the PDCA cycle incrementally. Many Agile methods are available in the lit- erature. Some more popular approaches, dis- cussed here briefly, include rapid application development (RAD), eXtreme programming (XP), Scrum, feature-driven development (FDD), and Lean software development. RAD: RAD methods are used primarily in data-intensive, business systems appli- cation development. RAD is enabled by special-purpose database develop- ment tools used by software engineers to quickly develop, test and deploy new or modified business applications. XP: This approach uses stories or sce- narios for requirements, develops tests first, has direct customer involvement on the team (typically defining acceptance tests), uses pair programming, and pro- vides continuous code refactoring and integration. Stories are decomposed into tasks, prioritized, estimated, developed and tested. Each software increment is tested with automated and manual tests. An increment may be released frequently, such as every couple of weeks. Scrum: This Agile approach is more project management-friendly than the others. The Scrum master manages the activities within the project increment. Each increment is called a sprint and lasts no more than 30 days. The product owner determines which items go into the product backlog and developed a product backlog item (PBI) list. The tasks from this list are identified, defined, priori- tized and estimated.

--- Chunk 532 ---
Tokens: 392
Type: sentence-based
Text:
The tasks from this list are identified, defined, priori- tized and estimated. A working version of the software is tested and released in each increment. Daily Scrum meetings ensure work is managed according to the plan. FDD: This is a model-driven, short, iter- ative software development approach using a five-phase process: (1) develop a product model to scope the breadth of the domain, (2) create the list of needs or features, (3) build the feature develop- ment plan, (4) develop designs for itera- tion-specific features, and (5) code, test, and then integrate the features. FDD is similar to an incremental software devel- opment approach. It is similar to XP, except that code ownership is assigned to individuals rather than to the team. In addition, FDD emphasizes an overall architectural approach to the software, which promotes building features cor- rectly the first time rather than rely on continual refactoring. Lean: This is an application of lean man- ufacturing principles adapted from the Toyota Production System to software development. The approach adopts the strategy of making a Minimum Viable Product, in which a team releases the simplest version of its product. The team learns feedback from users and iterates based on the feedback. The concept of Lean is to optimize the entire develop- ment process, rather than optimizing the individual development process. By over- looking the entire value flow, including design, manufacturing, sales, and ser- vice delivery, this approach optimizes the flow to quickly deliver the service to users.

--- Chunk 533 ---
Tokens: 392
Type: sentence-based
Text:
By over- looking the entire value flow, including design, manufacturing, sales, and ser- vice delivery, this approach optimizes the flow to quickly deliver the service to users. Kanban is also lightweight process that applies many of the Lean. However, they are some fundamental differences because Kanban supports managing workflow and visualization. There are many more variations of Agile methods in the literature and in practice. There will always be a place for heavyweight, SOFTWARE ENGINEERING MODELS AND METHODS 11-11 plan-based software engineering methods as well as places where Agile methods shine. In addition, new methods are arising from com- binations of Agile and plan-based methods: Practitioners are defining these new methods to balance features from heavyweight and lightweight methods based primarily on organizational business needs. These busi- ness needs, as typically identified by project stakeholders, should and do drive the choice of software engineering method. Large-scale and enterprise agile approaches reflect recent efforts to manage many agile teams and apply agile principles and practices across the enterprise while keeping promises of agile development methodologies (see agile models in Software Engineering Process KA). Agile methodology leads to shorter release cycles. Then, Release engineering contributes lightweight release cycle. Release engineering is a sub-discipline in software engineering concerned with the compilation, assembly, and delivery of source code into finished prod- ucts or other software components.

--- Chunk 534 ---
Tokens: 393
Type: sentence-based
Text:
Release engineering is a sub-discipline in software engineering concerned with the compilation, assembly, and delivery of source code into finished prod- ucts or other software components. The trend cycle in Agile would be Integration, Building, and Testing that Release Engineering focuses on. DevOps is often conflated with agile and continuous deployment approaches of software development. To avoid conflating, release management acts as a method for filling the collaboration gap between devel- opment and operations. Release managers need to monitor the development process and the promotion schedule for each release. The key to managing software releases in DevOps that keeps pace with deployment schedules is through automated management tools such as a continuous integration (CI) system. MATRIX OF TOPICS VS. REFERENCE MATERIAL Budgen 2021 1 Mellor and Balcer 2002 2 Sommerville 2011 3 Page-Jones 1999 4 Wing 1990 5 Brookshear 2008 6Brookshear, 2008, Computer Science: An Overview Boehm and Turner 2003 7 1. Modeling 1.1. Modeling Principles c3s3, c3s5, c4s2, c7s1, c7s2 c2s2 c5s0 1.2. Properties and Expression of Models c7s2, c7s3 c4s1.1p7, c4s6p3, c5s0p3 1.3. Syntax, Semantics and Pragmatics c2s2.2.2p6 c5s0 1.4. Preconditions, Postconditions and Invariants c4s4 c10s4p2, c10s5p2p4 11-12 SWEBOK  GUIDE V4.0 2. Types of Models 2.1. Structural Modeling c9s5, c10s5 c8s1, c5s3 c4 2.2. Behavioral Modeling c9s3, c10s6 c9s2 c5s4 3. Analysis of Models 3.1. Analyzing for Completeness c4s1.1p7, c4s6 pp8-11 3.2. Analyzing for Consistency c4s1.1p7, c4s6 pp8-11 3.3.

--- Chunk 535 ---
Tokens: 386
Type: sentence-based
Text:
Analyzing for Consistency c4s1.1p7, c4s6 pp8-11 3.3. Analyzing for Correctness pp8-11 3.4. Traceability c4s7.1, c4s7.2 3.5. Interaction Analysis c10, c11 c29s1.1, c29s5 c5 4. Software Engineering Methods 4.1. Heuristic Methods c13 c2s2.2, c7s1, c5s4.1 4.2. Formal Methods c18s2 c27 pp8-24 4.3. Prototyping Methods c14s1, c14s2, c14s3 c2s3.1 c7s3p5 4.4. Agile Methods c14s5, c14s6 c3 c7s3p7 c6, app. A REFERENCES 1 D Budgen, Software Design: Creating Solutions for Ill-Structured Problems, 3rd Edition, CRC Press, 2021. 2 S.J. Mellor and M.J. Balcer, Executable UML: A Foundation for Model-Driven Architecture, 1st ed. Boston: Addison- Wesley, 2002. 3 I. Sommerville, Software Engineering, 9th ed. New York: Addison-Wesley, 2011. 4 M. Page-Jones, Fundamentals of Object- Oriented Design in UML, 1st ed. Reading, MA: Addison-Wesley, 1999. 5 J.M. Wing, A Specifiers Introduction to Formal Methods, Computer, vol. 23, pp. 8, 10-23, 1990. 6 J.G. Brookshear, Computer Science: An Overview, 10th ed. Boston: Addison- Wesley, 2008. 7 B. Boehm and R. Turner, Balancing Agility and Discipline: A Guide for the Perplexed. Boston: Addison- Wesley, 2003. 8 B. Selic and S. Gerard, Modeling and Analysis of Real-Time and Embedded SOFTWARE ENGINEERING MODELS AND METHODS 11-13 Systems with UML and MARTE: Developing Cyber-Physical Systems, Morgan Kaufmann, 2013. 9 M. Brambilla, J. Cabot, and M. Wimmer, Model-Driven Software Engineering in Practice, Morgan  Claypool Publishers, 2017. 10 D. Jackson, Software Abstractions, revised edition, The MIT Press, 2016.

--- Chunk 536 ---
Tokens: 309
Type: sentence-based
Text:
10 D. Jackson, Software Abstractions, revised edition, The MIT Press, 2016. 11 R. Aarenstrup, Managing Model- Based Design, CreateSpace Independent Publishing Platform, 2015. 12 C. Larman, Applying UML and Patterns: An Introduction to Object- oriented Analysis and Design and Iterative Development, Germany: Prentice Hall PTR, 2005. 13 M. Poppendieck and T. Poppendieck, Lean Software Development: An Agile Toolkit, Addison-Wesley Professional, 2003. 14 T. Ohno, Toyota Production System: Beyond Large-Scale Production, Taylor  Francis Distribution, 2021 15 D.J. Anderson, Kanban: Successful Evolutionary Change for Your Technology Business, Blue Hole Press; Blue Book ed. edition, 2010. 16 J. Goodpasture, Project management the agile way: Making it work in the enter- prise, J. Ross Publishing, 2010. 17 ISOIEC 19505-1:2012, Information technology  Object Management Group Unified Modeling Language (OMG UML)  Part 1: Infrastructure. 18 ISOIECIEEE 32675:2022, Information technology  DevOps  Building reliable and secure systems including application build, package and deployment. 19 G. Kiczales, J. Lamping, A. Mendhekar, C. Maeda, C. Lopes, J. M. Loingtier, and J. Irwin, Aspect-oriented pro- gramming, ECOOP97, LNCS, Vol. 1241, 1997.

--- Chunk 537 ---
Tokens: 370
Type: sentence-based
Text:
1241, 1997. 12-1 CHAPTER 12 Software Quality ACRONYMS CICD Continuous Integration Continuous Delivery CoSQ Cost of Software Quality COTS Commercial Off-The-Shelf FMEA Failure Mode and Effects Analysis FTA Fault Tree Analysis IVV Independent Verification and Validation PDCA Plan-Do-Check-Act PSP Personal Software Process QFD Quality Function Deployment RCA Root Cause Analysis SCM Software Configuration Management SQA Software Quality Assurance SQAP Software Quality Assurance Plan SQC Software Quality Control SQM Software Quality Management VV Verification and Validation INTRODUCTION What is software quality, and why is it so important that it is included in many knowl- edge areas (KAs) of the SWEBOK Guide? One reason is that the term software quality is over- loaded. Software quality may refer to the desir- able characteristics of software products, to the extent to which a particular software product has those characteristics (software product quality), and to the processes, tools and tech- niques used to achieve those characteristics (software process quality). Over the years, authors and organizations have defined the term quality differently. Phil Crosby defined quality as conformance to requirements 2. Watts Humphrey referred to it as achieving excellent levels of fitness for use 3. Meanwhile, IBM coined the phrase market-driven quality, where the customer is the final arbiter 4. Finally, fitness for purpose is also a term that refers to software qualit.

--- Chunk 538 ---
Tokens: 369
Type: sentence-based
Text:
Finally, fitness for purpose is also a term that refers to software qualit. Fitness for purpose is the suitability of a product, system, or service for use by the intended users, for the intended use, in the intended situations, and intended environmental conditions. More recently, software (product) quality has been defined as the capability of a soft- ware product to satisfy stated and implied needs under specified conditions 4 and as the degree to which a software product meets established requirements; however, quality depends upon the degree to which those established requirements accurately represent stakeholder needs, wants, and expectations 6. Both definitions embrace the premise of conformance to requirements. Neither refers to different types of requirements (require- ments categorized according to functionality, reliability, performance, dependability, or any other characteristic). Significantly, however, these definitions emphasize that quality is an important characteristic of requirements. These definitions also illustrate another reason for the recurring discussions about soft- ware quality throughout the SWEBOK Guide  the often-unclear distinction between software quality and software quality require- ments (the -ilities is a common shorthand for these terms). Software quality require- ments (Quality of Service Constraints in the Software Requirements KA) are attributes of (or constraints on) functional requirements (what the system does).

--- Chunk 539 ---
Tokens: 400
Type: sentence-based
Text:
Software quality require- ments (Quality of Service Constraints in the Software Requirements KA) are attributes of (or constraints on) functional requirements (what the system does). Software requirements 12-2 SWEBOK  GUIDE V4.0 may also specify resource use, a communi- cation protocol, or many other characteris- tics (Technology Constraints in the Software Requirements KA). This KA attempts to clarify requirements by using software quality in the broadest sense from the definitions above and by using software quality require- ments as constraints on functional require- ments. Software product quality is achieved by conforming to all requirements regard- less of specified characteristics or grouping or naming of requirements. Software quality is also discussed in many other SWEBOK Guide Knowledge Areas because it is a basic concept of a software engi- neering effort. The primary goal for all engineered products is to deliver maximum stakeholder value while balancing the constraints of develop- ment, maintenance, and operational cost, some- times characterized as fitness for use. Stakeholder value is expressed in requirements. For software products, stakeholders could value price (what they pay for the product), lead time (how fast they get the product), and software quality. (See the Software Requirements KA for a broader discussion of this.) The software process quality aspect, which is implied by the above, must be made explicit. The quality of a software process can be also observed in process characteristics such as efficiency, effectiveness, usability, and learnability.

--- Chunk 540 ---
Tokens: 311
Type: sentence-based
Text:
The quality of a software process can be also observed in process characteristics such as efficiency, effectiveness, usability, and learnability. Defects in that process will likely show up as defects in the resulting software product, as well. Finally, the Agile and DevOps move- ments aim at improving the software pro- cess and product quality through compliance by promoting quick iteration feedback loops and eliminating organizational silos by col- locating users and software engineers. Other practices like pair programming and the auto- mation of development, testing, and oper- ations services also bring value, improve efficiency, and can detect defects early. (Refer to the Process KA for Agile life cycles and the Software Operations KA for more informa- tion on DevOps processes.) This KA provides an overview of practices, tools, and techniques for understanding soft- ware quality and planning and appraising the state of software quality during develop- ment, maintenance and operation, from both a software product perspective and a software process perspective. Cited references provide additional details. BREAKDOWN OF TOPICS FOR SOFTWARE QUALITY The breakdown of topics for the Software Quality KA is presented in Figure 12.1.

--- Chunk 541 ---
Tokens: 375
Type: sentence-based
Text:
BREAKDOWN OF TOPICS FOR SOFTWARE QUALITY The breakdown of topics for the Software Quality KA is presented in Figure 12.1. Software Quality Software Quality Fundamentals Software Quality Management Process Software Quality Assurance Process Software Quality Tools Software Engineering Culture and Ethics Value and Cost of Quality Standards, Models and Certications Software Dependability and Integrity Levels Software Quality Improvement Plan Quality Management Evaluate Quality Management Perform corrective and Preventive Action Prepare for Quality Assurance Perform Process Assurance Perform Product Assurance Figure 12.1. Breakdown of Topics for Software Quality SOFTWARE QUALITY 12-3 1. Software Quality Fundamentals Agreeing on what constitutes software quality for all stakeholders and communicating that agreement to software engineers requires that the many aspects of quality be formally defined and communicated. The main chal- lenges the software engineer faces to ensure quality include the following:  Difficulty in clearly defining requirements;  Maintaining effective communication with the clientuser;  Deviations from specifications;  Architecture and design errors;  Coding errors;  Noncompliance with current processes procedures;  Inadequate work product reviews and tests;  Documentation errors. Software quality is defined as confor- mance to established requirements; the capa- bility of a software product to satisfy stated and implied needs when under specified con- ditions 6.

--- Chunk 542 ---
Tokens: 392
Type: sentence-based
Text:
Software quality is defined as confor- mance to established requirements; the capa- bility of a software product to satisfy stated and implied needs when under specified con- ditions 6. It is further defined by the degree to which a software product meets established requirements; however, quality depends upon the degree to which those established require- ments accurately represent stakeholder needs, wants, and expectations 6. Quality often means the absence of defects. The word defect is overloaded with too many meanings, as engineers and others use the word to refer to all different types of anomalies. However, different engineering cultures and standards often understand defect and other terms as having more specific meanings. To avoid confusion, software engineers should use the meaning provided by their standards 14:  Error: A human action that produces an incorrect result. Also called human error;  Defect: (synonym of a fault) An imper- fection or deficiency in a work product where that work product does not meet its requirements or specifications and needs to be either repaired or replaced. A defect is inserted when a person developing the software makes an error. It hides in the software until (and if) it is discovered;  Failure: The termination of the ability of a system to perform a required function or its inability to perform within previ- ously specified limits; an externally visible deviation from the systems specification event in which a system or system compo- nent does not perform a required function within specified limits.

--- Chunk 543 ---
Tokens: 368
Type: sentence-based
Text:
It hides in the software until (and if) it is discovered;  Failure: The termination of the ability of a system to perform a required function or its inability to perform within previ- ously specified limits; an externally visible deviation from the systems specification event in which a system or system compo- nent does not perform a required function within specified limits. A failure is pro- duced when the software executes a defect. A software engineer should understand software quality concepts, characteristics, and values and their application to the many devel- opment, maintenance, and operation activi- ties. An important concept is that the software requirements are expected to define the required software quality attributes. Furthermore, soft- ware requirements influence the measurement methods and acceptance criteria for assessing how the software and related work products achieve the desired quality levels. Another important concept is that software quality should be planned early and assessed at many milestones during the software life cycle. Finally, how to adapt software quality assur- ance (SQA) activities to accommodate different life cycles, for example Agile software develop- ment is presented in detail in the Institute of Electrical and Electronics Engineers (IEEE) Standard 730:2014 6. 1.1. Software Engineering Culture and Ethics 1, c1s1.6; c2s3 5 An organizations culture affects how soft- ware engineers influence software quality.

--- Chunk 544 ---
Tokens: 383
Type: sentence-based
Text:
Software Engineering Culture and Ethics 1, c1s1.6; c2s3 5 An organizations culture affects how soft- ware engineers influence software quality. As Iberle explains 19, software engineering practices vary depending on the business model (e.g, custom, mass-market, commer- cial, firmware) and the industry where the software engineers work. Software engineers are expected to share a commitment to soft- ware quality in the context of their industry and as part of their culture. A healthy soft- ware engineering culture includes many char- acteristics, such as the understanding that trade-offs among cost, schedule and quality 12-4 SWEBOK  GUIDE V4.0 are a basic tenet of any products engineering. A strong software engineering ethic assumes that engineers accurately report information, conditions and outcomes related to quality. Ethics also play a significant role in soft- ware quality in the professional culture of engineering, and in the attitudes of software engineers. The IEEE Computer Society and the Association for Computing Machinery (ACM) have developed a code of ethics and professional practice. (See Codes of Ethics and Professional Conduct in the Software Engineering Professional Practice KA.) 1.2. Value and Costs of Quality 1, c2s2.2 One major factor driving resistance to imple- menting SQA is its perceived high cost. However, not implementing basic SQA activ- ities can be costly as well. Software engineers should inform their administration of the risks they take when they are not fully committed to quality.

--- Chunk 545 ---
Tokens: 372
Type: sentence-based
Text:
Software engineers should inform their administration of the risks they take when they are not fully committed to quality. This can be done by explaining the cost of software quality concepts to management. Cost of software quality (CoSQ ) is defined as the sum of the following project costs:  Implementation cost of planning and construction activities (e.g, planning, designing, development);  Prevention cost of activities (process improvement, tools, training);  Appraisal costs activities for defect detec- tion (e.g, reviews, audits, testing);  Nonconformance and rework costs (internal failure cost and external failure cost). The CoSQ can be broken down into two top-level categories: conformance cost and non- conformance cost. Conformance cost is the total of all investments in error and defect detec- tion (appraisal) and prevention activities. Appraisal costs arise from project activities that are intended to find errors and defects. These include testing (as detailed in the Software Testing KA) and reviews and audits (as detailed later in this KA). Appraisal costs extend to subcontracted software suppliers, if any. Prevention costs include investments in software process improvement (SPI) efforts, quality infrastructure, quality tools, work product templates and training. These costs might not be specific to a project; they often span the larger organization. Nonconformance cost is the total of all spending dealing with errors and defects that have been detected.

--- Chunk 546 ---
Tokens: 374
Type: sentence-based
Text:
Nonconformance cost is the total of all spending dealing with errors and defects that have been detected. Pre-delivery costs are those incurred to repair errors and defects found during appraisal activities and discov- ered before the software product is delivered to the customer. Post-Delivery costs include those incurred responding to software fail- ures discovered after delivery to the customer. External costs include the rework needed to repair and test an updated release. External costs include rework and repair of the unin- tended and uncompensated side effects or consequences of defects. However, the finan- cial impact on the customer who encounters a failure is just as important. For example, the customers lost productivity, lost data, and potential loss of reputation in the market- place must be acknowledged and accounted for. Beyond the impact on the customer, low- quality software can also impact the public and the environment. Software engineers should seek the optimal CoSQ  the minimal total cost for a specified quality level. 1.3. Standards, Models, and Certifications 1, c4 7, c24s24.2 Sound use of software engineering software standards and software process assessment and improvement improves software quality. One of the key general software engineering standards is ISOIECIEEE 12207:2017, which describes the software life cycle pro- cesses. Foremost, software engineers should know the key software engineering stan- dards that apply to their specific industry.

--- Chunk 547 ---
Tokens: 312
Type: sentence-based
Text:
Foremost, software engineers should know the key software engineering stan- dards that apply to their specific industry. As Iberle discussed 19, the practices software engineers use vary greatly depending on the industry, business model and organizational culture where they work. For example, IEEE 1228:1994 Standard for Software Safety Plans and IEEE 1633:2016 Recommended Practice SOFTWARE QUALITY 12-5 on Software Reliability target industries where safety and reliability are important. The Plan-Do-Check-Act (PDCA) para- digms differ from standards in that it often proposes best practices for software engi- neers from a specific perspective. (Refer to the Software Engineering Process KA for more information about the PDCA paradigm for software.) Other industry best practices models such as the Control Objectives for Information and Related Technologies (COBIT) for informa- tion technology governance 27, the Project Management Body of Knowledge (PMBOK) for project management 25, the Business Analysis Body of Knowledge (BABOK) 28, the Capability Maturity Model Integration (CMMI) 29 and The Open Group Architecture Framework (TOGAF) propose software related practices that can improve the quality of software processes and products 30.

--- Chunk 548 ---
Tokens: 363
Type: sentence-based
Text:
Other industry best practices models such as the Control Objectives for Information and Related Technologies (COBIT) for informa- tion technology governance 27, the Project Management Body of Knowledge (PMBOK) for project management 25, the Business Analysis Body of Knowledge (BABOK) 28, the Capability Maturity Model Integration (CMMI) 29 and The Open Group Architecture Framework (TOGAF) propose software related practices that can improve the quality of software processes and products 30. Software organizations can also consider the possible advantages of obtaining registrations or certifications (e.g, ISO 9001 for quality 10, ISO 27001 for security 31, (e.g, ISO 9001 for quality 10, ISO 27001 for security 31 and ISO 20000 for operations 32), and software engineers can also obtain Scrum and Scaled Agile Framework (SAFe) certifica- tions for Agile processes 22. The use of these models and certifications have been shown to augment stakeholders confidence that the software engineers knowledge and skills are up to date and recognized internationally. 1.4. Software Dependability and Integrity Levels 1, c4s4.8, c7s7.3.3 11 Software-intensive and safety-critical sys- tems are those in which a system failure could harm human life, other living things, physical structures, or the environment. The software in these systems is considered safety-critical and requires the use of systematic methods and tools to ensure its high level of quality.

--- Chunk 549 ---
Tokens: 393
Type: sentence-based
Text:
The software in these systems is considered safety-critical and requires the use of systematic methods and tools to ensure its high level of quality. A growing number of industries are using increasing numbers of safety-critical soft- ware, including transportation systems, chem- ical and nuclear plants, and medical devices. Software failure in these systems could have catastrophic effects. Engineers use industry standards, such as software considerations in airborne systems and equipment certification DO-178C 8 and railway applications EN 50128 18, and emerging processes, tools, and techniques to develop safety-critical soft- ware more safely. These standards, tools and techniques reduce the risk of injecting faults into the software and thus improve software availability, reliability, and maintainability. Software engineers and their managers must understand the threats and issues and develop the skills needed to anticipate and prevent accidents before they occur 15. Safety-critical software can be catego- rized as direct or indirect. Direct software is embedded in a safety-critical system, such as an aircrafts flight control computer. Indirect software includes software applications used to develop safety-critical software. Indirect software is included in software engineering environments and software test environments. Three complementary techniques for reducing failure risk are avoidance, detec- tion and removal, and damage limitation. These techniques impact software functional requirements, performance requirements and development processes.

--- Chunk 550 ---
Tokens: 359
Type: sentence-based
Text:
These techniques impact software functional requirements, performance requirements and development processes. Increasing risk implies increasing SQA and more rigorous review techniques such as inspections 16. Higher risk levels might necessitate more thorough inspec- tions of requirements, design, and code, or the use of more formal verification and valida- tion techniques. Another technique for man- aging and controlling software risk is building assurance cases. An assurance case is a reasoned, auditable artifact created to support the con- tention that its claim or claims are satisfied. It contains the following relationships: one or more claims about properties, arguments that logically link the evidence and any assump- tions to the claims, and a body of evidence and assumptions supporting these arguments 9. 1.4.1. Dependability 7, c10 In cases where system failure may have severe consequences, overall dependability (e.g, 12-6 SWEBOK  GUIDE V4.0 hardware, software, and human or oper- ational dependability) is the main quality requirement, aside from basic software func- tionality, for the following reasons: System failures affect many people; users often reject systems that are unreliable, unsafe, or inse- cure; system failure costs could be important; and undependable systems might cause infor- mation loss. Many standards address dif- ferent perspectives of dependability, such as reliability and availability.

--- Chunk 551 ---
Tokens: 397
Type: sentence-based
Text:
Many standards address dif- ferent perspectives of dependability, such as reliability and availability. System and soft- ware dependability regroups several related quality characteristics: availability, reliability, maintainability and supportability, safety and security 21. When developing dependable software, engineers can apply tools and tech- niques to reduce the risk of injecting faults into the intermediate deliverables or the final soft- ware product. They can use static, dynamic, or formal methods for verification and validation (VV), and testing processes, as well as other specialized techniques, methods, and tools to identify defects that affect dependability as early as possible in the software life cycle 7, c10.5. Additionally, they may have to incor- porate specific mechanisms into the software to guard against external attacks and to tol- erate faults during its operation. 1.4.2. Integrity Levels of Software 1, c4s4.8, c7s7.3.2 11 Defining integrity levels is a method of risk management. An integrity level is a value rep- resenting project-unique characteristics (e.g, complexity, criticality, risk, safety level, secu- rity level, desired performance, and reliability) that define the importance of the system, software, or hardware to the user 11. The characteristics used to determine software integrity level vary depending on the intended application and use of the system. The soft- ware is a part of the system, and its integrity level is determined as a part of that system. The assigned software integrity levels might change as the software evolves.

--- Chunk 552 ---
Tokens: 380
Type: sentence-based
Text:
The assigned software integrity levels might change as the software evolves. Design, coding, procedural and technology features implemented in the system or software can raise or lower the assigned software integrity levels. The software integrity levels estab- lished for a project result from agreements among the acquirer, supplier, developer, and independent assurance authorities. A software integrity level scheme is used to determine soft- ware integrity levels 11. Software engineers should know that in certain safety-critical industries, such as avionics, railways, nuclear power, medical devices and many others, industry-specific guidance can require a certain level of inde- pendence for software quality activities and can assign minimum VV techniques to be used by integrity level (example of such techniques are: usability analysis, algorithm analysis, boundary value analysis, data flow analysis, walk-through review 1126). 2. Software Quality Management Process Software quality management (SQM) is concerned with coordinating activities to direct and control an organization with regard to software quality 6. The purpose of the Quality Management process is to assure that products, services, and implementations of the quality management process meet orga- nizational and project quality objectives and achieve customer satisfaction. Software engineers can learn about the SQM process in the many software engi- neering standards, models, and certifications available and used widely in the industry.

--- Chunk 553 ---
Tokens: 397
Type: sentence-based
Text:
Software engineers can learn about the SQM process in the many software engi- neering standards, models, and certifications available and used widely in the industry. An important concept of SQM is the design and upkeeping of a Quality Management System (QMS). As proposed by ISO90003 26 which interprets ISO9001 concepts for the software industry. QMS defines processes, process owners, requirements for the processes, measurements of the processes and their outputs, and feed- back channels throughout the whole software life cycle. A QMS comprises many key activ- ities: SQA, VV, reviews and audits, soft- ware configuration management (SCM), and requires policies, procedures, and processes to ensure that everyone involved understands what is expected in terms of software pro- cess and product quality. For a QMS to be SOFTWARE QUALITY 12-7 effective, management support is impera- tive. Management support implies that proj- ects are trained to the QMS requirement and have enough resources to achieve the quality goal defined for it. Management sponsorship should be solicited frequently during soft- ware project review to ensure software quality activities are executed and nonconformities addressed. For a software project, software quality processes consist of tasks and techniques to indicate how software plans (e.g, software management, development, quality manage- ment or configuration management plans) are implemented and how well the intermediate and final products meet their specified require- ments. Results from these tasks are assem- bled in reports for management.

--- Chunk 554 ---
Tokens: 363
Type: sentence-based
Text:
Results from these tasks are assem- bled in reports for management. SQM process management is tasked with ensuring that the report results are accurate and acted upon. Risk management can also play an important role in delivering quality software. Incorporating disciplined risk analysis and management techniques into the software life cycle processes can help improve product quality. (See the Software Engineering Management KA for related material on risk management.) 2.1. Software Quality Improvement 1, s9.9 and c9 2 3 Software quality improvement (SQI) is done using many different approaches within the software industry, including software process improvement (SPI), Six Sigma, Lean, and Kaizen just to name a few. For example, the SPI activities seek to improve process effec- tiveness, efficiency, and other characteristics to improve software quality. For example, although SPI could be included in any of the first three categories, many organizations organize SPI into a separate category that might span many projects. Software product quality can be improved using Lean principles as well as an iterative process of continual improvement, which includes management control, coordination of activities, and feedback from many concurrent processes: (1) the process of improving the software life cycle processes; (2) the pro- cess of faultdefect categorization, detection, removal, and prevention; and (3) a personal improvement process.

--- Chunk 555 ---
Tokens: 347
Type: sentence-based
Text:
Software product quality can be improved using Lean principles as well as an iterative process of continual improvement, which includes management control, coordination of activities, and feedback from many concurrent processes: (1) the process of improving the software life cycle processes; (2) the pro- cess of faultdefect categorization, detection, removal, and prevention; and (3) a personal improvement process. The theory and concepts behind quality improvement  such as building quality through the prevention and early detection of defects, continual improvement, and stake- holder focus  are also pertinent to software engineering. These concepts are based on the work of experts in quality who have stated that a products quality is directly linked to the quality of the process used to create it. Improvement models such as the Plan-Do- Check-Act (PDCA) improvement cycle, evo- lutionary delivery, Kaizen, and techniques like quality function deployment (QFD) offer ways to specify quality objectives and deter- mine whether they are met. Finally, since software engineering is a complex process, it cannot be reduced to a cookbook of procedures. To complement the process and tools improvement movement, Humphrey proposed the personal software process (PSP) for software engineers to also assess their skills and knowledge constantly and continually improve them as well. 2.2.

--- Chunk 556 ---
Tokens: 360
Type: sentence-based
Text:
2.2. Plan Quality Management 1, c13 Software quality planning includes determining which quality standards and models are to be used, defining specific quality goals, estimating the effort to be used to achieve each goal; and deciding at what milestone the software quality activity should take place. In some cases, soft- ware quality planning also includes defining the software quality processes to be used. First, the software organization must commit to quality by establishing their quality management system (QMS) which includes quality management policies, objectives, and procedures. This requires that the respon- sibility and authority for implementing the QMS are assigned and that they are indepen- dent of current project management teams. An approved organizational policy, about software quality, helps in guiding projects 12-8 SWEBOK  GUIDE V4.0 and products development decisions as well as behavior of personnel. Software engineers should promote the use of graphically repre- sented processes and procedures that imple- ment the quality policy and explain the roles, activities to be executed and the expected results of key software engineering activi- ties. Consequently, for a QMS to be used in improvement its processes should be doc- umented with its user in mind and iden- tify where quality controls are to be verified. Finally, procedures explain in detail what steps are taken to execute a specific activity. 2.3.

--- Chunk 557 ---
Tokens: 331
Type: sentence-based
Text:
2.3. Evaluate Quality Management Once the QMS is in place, the ISOIEC Technical Specification TS 33061:2021 23 Standard defines a process assessment model for software life cycle processes using five pro- cess capabilities levels (from level 0: incomplete to level 5: optimizing process). Additionally, software engineers can assess the maturity of their QMS activities in their software projects using the IEEE 730:2014 Standard guidance 6. Management sponsorship supports pro- cess and product evaluations. The evaluation findings feed into an improvement program for identifying detailed actions and improve- ment projects to be addressed in a feasible time frame. Periodically, the software engi- neers will gather and analyze quality assur- ance evaluation results. This can be achieved by looking at quality measures and defect characterization produced by the projects. 2.3.1. Software Quality Measurement 1, c10 7, c24s24.5 Software quality measurements are used to support decision-making. With the increasing sophistication of software, quality questions go beyond whether the software works to how well it achieves measurable quality goals. Quantifying some attribute of software can help engineers evaluate its quality or the quality of its process. (Process measurement is described in detail in the Process KA.)

--- Chunk 558 ---
Tokens: 321
Type: sentence-based
Text:
(Process measurement is described in detail in the Process KA.) Software quality measurement helps engi- neers make determinations about soft- ware quality (because models of software product quality include measures to deter- mine the degree to which the software product achieves quality goals); managerial questions about effort, cost, and schedule; when to stop testing and release a product (see Test-Related Measures in the Software Testing KA); and the efficacy of process improvement efforts. The CoSQ assurance activities are an issue frequently raised in deciding how a project or a software development and maintenance organization should be organized. Often, generic models of cost are used; these models are based on when a defect is found and how much effort it takes to fix the defect rela- tive to finding the defect earlier in develop- ment. Software quality measurement data collected internally may offer a better picture of cost within the project or organization. Although the software quality measurement data may be useful by itself (e.g, the number of defective requirements or the proportion of defective requirements), mathematical and graphical techniques can help project stakeholders interpret the measures. (See the Engineering Mathematical Foundations KA.)

--- Chunk 559 ---
Tokens: 343
Type: sentence-based
Text:
(See the Engineering Mathematical Foundations KA.) These techniques include the following:  Descriptive statistics-based analysis (e.g, Pareto analysis, run charts, scatter plots, normal distribution);  Statistical tests (e.g, the binomial test, chi-squared test);  Trend analysis (e.g, control charts; see The Quality Toolbox in Further Readings);  Prediction (e.g, reliability models). Descriptive statistics-based techniques and tests often provide a snapshot of the more troublesome areas of the software product under examination. The resulting charts and graphs are visualization aids decision-makers can use to focus resources and conduct process improvements where they seem most needed. Results from trend analysis may indicate that a schedule is slipping or that certain classes of faults may become more likely unless some SOFTWARE QUALITY 12-9 corrective action is taken in development. The predictive techniques help estimate testing effort and schedule and predict failures. (More discussion on measurement in general appears in the Software Engineering Process and Software Engineering Management KAs. More specific information on testing mea- surement is presented in the Software Testing KA.) Software quality measurement also includes measuring defect occurrences and applying statistical methods to understand what types of defects occur most frequently.

--- Chunk 560 ---
Tokens: 386
Type: sentence-based
Text:
Software quality measurement also includes measuring defect occurrences and applying statistical methods to understand what types of defects occur most frequently. Three widely used software quality measure- ments are error density (number of errors per unit size of documentssoftware), defect den- sity (number of defects found divided by the size of the software), and failure rate (mean time to failure). Reliability models are built from failure data collected during software testing or from software in service and thus can be used to estimate the probability of future failures and assist in decisions about when to stop testing. This information can be used in SPI to determine methods to pre- vent, reduce or eliminate defect recurrence. The information also helps engineers under- stand trends, how well detection and contain- ment techniques are working, and how well the development and maintenance processes are progressing. They can use these measure- ment methods to develop defect profiles for a specific application domain. Then, for the next software project within that organi- zation, the profiles can be used to guide the SQM processes  that is, to focus effort on where problems are most likely to occur. Similarly, benchmarks, or defect counts typ- ical of that domain, may help engineers deter- mine when the product is ready for delivery. (Discussion about using measurement data to improve development and maintenance pro- cesses appears in the Software Engineering Management and Software Engineering Process KAs.) 2.4.

--- Chunk 561 ---
Tokens: 365
Type: sentence-based
Text:
2.4. Perform Corrective and Preventive Actions It is important that when quality manage- ment objectives are not met, corrective actions be documented and submitted so that the QMS be improved to prevent problem from reoccurring in future software projects. This requires that project participants have a way of reporting software engineering process and tools problems to an independent orga- nization that will document and monitor the progress of the corrective actions and inform the relevant stakeholders. 2.4.1. Defect Characterization 1, c1s3 To help in the elimination of the cause or causes of an existing nonconformity or unde- sirable situation to prevent recurrence, soft- ware engineers can use software quality control (SQC) techniques to find errors, defects, and failures in their processes and products. When tracking errors, defects and failures, the software engineer is interested in the number and types of incidents. Numbers alone, without classification, might be insuf- ficient to help in identifying the underlying causes and thus to prevent them in the future. Therefore, software engineers should establish a meaningful defect classification taxonomy to describe and categorize such anomalies. One probable action resulting from peer reviews and testing findings is to remove these errors and defects early from the work product under examination. Other SQM activities attempt to eliminate their causes (e.g, root cause analysis (RCA)).

--- Chunk 562 ---
Tokens: 373
Type: sentence-based
Text:
Other SQM activities attempt to eliminate their causes (e.g, root cause analysis (RCA)). RCA activities include analyzing and sum- marizing the findings to find root causes and using measurement techniques to improve the software engineering processes, techniques and tools. (Process improvement is pri- marily discussed in the Software Engineering Process KA. RCA is further discussed in the Engineering Foundations KA.) Data on errors and defects found during SQA and control techniques may be lost unless they are recorded. For some techniques (e.g, peer reviews and inspections), software engineers are present to record such data and to address issues and make decisions. In addi- tion, when automated tools are used (see Topic 4, Software Quality Tools), the tool output 12-10 SWEBOK  GUIDE V4.0 may provide defect trends reports that can be provided to the organizations management. 3. Software Quality Assurance Process 3.1. Prepare for Quality Assurance 1, c1s1.5, c4s4.6 6 Software quality assurance (SQA) is defined as a set of activities that define and assess the adequacy of software processes to provide evi- dence that establishes confidence that the soft- ware processes are appropriate for and produce software products of suitable quality for their intended purposes. To correct a common misunderstanding, SQA is not only testing of a software. A key attribute of SQA, in critical systems, is the objectivity of the SQA function concerning the quality of a software product.

--- Chunk 563 ---
Tokens: 375
Type: sentence-based
Text:
A key attribute of SQA, in critical systems, is the objectivity of the SQA function concerning the quality of a software product. In this case, the SQA function might also be organizationally independent of the project; that is, free from technical, managerial, and financial pressures 6. SQA has two aspects: product assurance and process assurance, which are introduced in Section 2.3. The software quality plan (in some industry sectors, it is termed the software quality assurance plan (SQAP)) defines the activities and tasks used to ensure that software devel- oped for a specific product satisfies the proj- ects established requirements and user needs within project cost and schedule constraints and is commensurate with project risks. The SQAP first ensures that quality targets are clearly defined and understood. The SQAPs quality activities and tasks are specified, along with their costs, resource requirements, objectives, and schedule in relation to related objectives, in the software engineering management, software develop- ment and software maintenance plans. The SQAP identifies documents, standards, prac- tices, and conventions governing the project and how these items are checked and mon- itored to ensure adequacy and compliance. The SQAP also identifies measures; statistical techniques; procedures for problem reporting and corrective action; resources such as tools, techniques, and methodologies; security for physical media; training; and SQA reporting and documentation.

--- Chunk 564 ---
Tokens: 369
Type: sentence-based
Text:
The SQAP also identifies measures; statistical techniques; procedures for problem reporting and corrective action; resources such as tools, techniques, and methodologies; security for physical media; training; and SQA reporting and documentation. Moreover, the SQAP addresses the SQA activities of any other type of activity described in the software plans  such as procurement of supplier software for the project, commercial off-the-shelf (COTS) software installation and service after soft- ware delivery. It can also contain acceptance criteria and reporting and management activ- ities that are critical to software quality. The SQA plan should not conflict with the soft- ware configuration management plan or any other relevant project plannning artifact. More over they should be considered com- plimentary activities (for process SQAP the SCM Process Audit and the Testing activities for SCM Functional Audit). Software quality encompasses several per- spectives: the software process quality, the software end-product quality and the soft- ware work products (also called intermediary products) quality. The next sections cover each perspective of software quality knowledge a software engineer must have. 3.2. Perform Process Assurance 1, c3s3.2s3.3, c4s4.6.1.3, c8, c9 7, c25 Crosby 2 and Humphrey 3 have demon- strated that software quality management (SQM) and software engineering process quality have a direct effect on the quality of the final software product.

--- Chunk 565 ---
Tokens: 375
Type: sentence-based
Text:
Perform Process Assurance 1, c3s3.2s3.3, c4s4.6.1.3, c8, c9 7, c25 Crosby 2 and Humphrey 3 have demon- strated that software quality management (SQM) and software engineering process quality have a direct effect on the quality of the final software product. (Models and criteria that evaluate and improve the capabilities of software organizations are primarily project organization and management considerations and, as such, are covered in the Software Engineering Management and Software Engineering Process KAs.) International Organization for Standardization (ISO) 9001 10 proposes another process quality perspec- tive, where a management system that over- sees the processes actors, activities, controls, input, and outputs ensures the quality of out- puts (e.g, work products and final product). A management system is defined as a set of inter- related or interacting elements of an organi- zation to establish policies and objectives, and processes to achieve those objectives SOFTWARE QUALITY 12-11 10. This perspective requires software engi- neering organizations to take the time to describe their policies, processes, and proce- dures with enough detail that software engi- neer roles and responsibilities are clear during life cycle activities (as detailed in the Software Engineering Process KA). SQA activities, listed in the IEEE 730:2014 Standard 6, describe the many quality assur- ance activities that should be conducted early in a software projects life cycle to ensure quality.

--- Chunk 566 ---
Tokens: 383
Type: sentence-based
Text:
SQA activities, listed in the IEEE 730:2014 Standard 6, describe the many quality assur- ance activities that should be conducted early in a software projects life cycle to ensure quality. Software engineers should be aware of the need to plan and execute SQA activ- ities at certain project milestones and keep records of their execution. These activities consist of document and code reviews as well as verification and validation (VV) activi- ties, including testing (as detailed in Section 3.4 of this KA), which evaluate the output of a processs compliance with its requirements and specifications. Finally, software configuration man- agement (SCM) is an important activity to ensure the quality of work products and soft- ware. Configuration management is defined as the discipline applying technical and admin- istrative direction and surveillance to:  identify and document the functional and physical characteristics of a config- uration item;  control changes to those characteristics;  record and report change processing and implementation status;  verify compliance with specified requirements. Software engineers should identify which work products and software artifacts require configuration management. In addition, they should be familiar with source code ver- sioning processes, which involve keeping track of baselined and incremental versions of the software and ensuring that changes dif- ferent developers make do not interfere with one another, and they should know how to operate the version control tool kit.

--- Chunk 567 ---
Tokens: 360
Type: sentence-based
Text:
In addition, they should be familiar with source code ver- sioning processes, which involve keeping track of baselined and incremental versions of the software and ensuring that changes dif- ferent developers make do not interfere with one another, and they should know how to operate the version control tool kit. (Refer to the Software Configuration Management KA for more information about this process.) 3.3. Perform Product Assurance 1, s3.2s3.3 7, c4, s4.6.1.2 First, the software engineer must determine the real purpose of the software to be designed and constructed. Stakeholder requirements are paramount here. They include quality require- ments (called Quality of Service Constraints in the Software Requirements KA) and func- tional requirements. Thus, software engineers are responsible for eliciting quality require- ments that might not be explicit at the outset and for understanding their importance and the difficulty in defining them, measuring them, and establishing them for final accep- tance. Software engineers should understand how to define quality requirements as well as their quality targets to ensure they can effec- tively be measured at the acceptance stage of the project. During the project planning, software engineers must keep these quality requirements in mind. They must also antici- pate potential additional development costs if attributes such as safety, security and depend- ability are important.

--- Chunk 568 ---
Tokens: 385
Type: sentence-based
Text:
They must also antici- pate potential additional development costs if attributes such as safety, security and depend- ability are important. An international standard on what con- stitutes a software products many measur- able quality characteristics was reached and is described in ISOIEC 25010:2011 4. This standard proposes several software product quality models, consisting of characteristics and sub-characteristics, for software product quality and software quality in use. Another is IEEE 982.1:2005 Standard Dictionary of Measures to Produce Reliable Software. These software characteristics are commonly called product quality requirements, which are nonfunctional software requirements 7, c4,s4.6.1.2. Software engineers should know the many software characteristics that can be planned, implemented, and measured during software construction (e.g, functional suit- ability, performance efficiency, compatibility, usability, reliability, security, maintainability, and portability). Software engineers should also know that certain quality characteris- tics have conflicting impacts. For example, trying to augment the security characteristic by encrypting data might adversely affect the 12-12 SWEBOK  GUIDE V4.0 performance characteristic. This international standard also proposes a general data quality model that focuses on data quality as part of a computer system and defines quality char- acteristics for target data used by humans and systems. Another software product quality perspec- tive is the quality of work products.

--- Chunk 569 ---
Tokens: 388
Type: sentence-based
Text:
Another software product quality perspec- tive is the quality of work products. The term work product means any artifact resulting from a process used to create the final software product. Work products include systemsub- system specifications, software requirements specifications for a systems software compo- nents, software design descriptions, source code, software test documentation and test reports. Sound engineering practice requires that intermediate work products relevant to quality be evaluated using work product reviews and inspections (discussed later in this chapter) throughout the software engineering process. 3.4. VV and Testing 1, c7 11 Verification ensures that the product is built correctly in that the output products of a life cycle phase meet the specifications imposed on them in previous phases. Verification is defined as the process of evaluating a system or component to determine whether the prod- ucts of a given development phase satisfy the conditions imposed at the start of that phase 11. Alternatively, validation ensures that the right product is built  the product fulfills its specific intended purpose. It is defined as the process of evaluating a system or component during or at the end of the development pro- cess to determine whether it satisfies specified requirements. The purpose of VV is to help the devel- opment organization build quality into the software throughout the development life cycle. VV includes software testing tasks. Software testing is a necessary activity to ensure product quality.

--- Chunk 570 ---
Tokens: 400
Type: sentence-based
Text:
Software testing is a necessary activity to ensure product quality. However, in most cases, software testing is insufficient to establish confidence that the software fits its intended use. VV tasks listed in IEEE Standard 1012:2016 11 objectively assess products and processes throughout the life cycle. This assessment demonstrates whether the requirements are correct, complete, accu- rate, consistent, and testable. The verifica- tion process and the validation process should begin early in development or maintenance. This prevents defects late in the life cycle, which would incur rework and significantly increase costs. Software engineers should identify the product integrity level and ensure the minimum VV tasks are assigned for key product features concerning both the products immediate predecessor and the planned spec- ifications. Optional VV tasks are also listed and can improve software product quality. Keeping a record of the traceability among software work products can help augment the quality of the VV activities. Traceability is defined as the ability to trace the history, application or location of an object 14. Early planning of VV activities ensures that each resource, role, and responsibility is clearly assigned. The resulting VV plan documents the various resources and their roles and SQA activities, as well as the techniques and tools to be used. Software engineers should choose and apply the proper VV task depending on the soft- ware integrity level. (Refer to Section 1.4.2) VV can also be executed by an indepen- dent organization for very critical software.

--- Chunk 571 ---
Tokens: 354
Type: sentence-based
Text:
(Refer to Section 1.4.2) VV can also be executed by an indepen- dent organization for very critical software. Independent verification and validation (IVV) are defined as VV performed by an organization that is technically, mana- gerially, and financially independent of the development organization 11. Software VV tasks can be sorted into static, dynamic and formal tasks 20. Dynamic techniques involve executing the software; static techniques involve analyzing documents and source code but not executing the software; formal techniques use mathe- matics and formal specification languages. It should be noted that there are no strong boundaries between Static analysis tech- niques, Dynamic analysis techniques and Formal analysis techniques. For example, static and dynamic analysis techniques usu- ally have a strong formal background such as data-flow analysis or model checking. SOFTWARE QUALITY 12-13 3.4.1. Static Analysis Techniques Static analysis techniques directly ana- lyze a work products content and structure (including requirements, interface specifica- tions, designs, and models) without executing the software. The only way to detect non-ex- ecutable code is through static analysis as no dynamic test can verify that. Static techniques can be executed manually or with the help of a tool. Tools and techniques for statically exam- ining software work can help software engi- neers in this task.

--- Chunk 572 ---
Tokens: 393
Type: sentence-based
Text:
Tools and techniques for statically exam- ining software work can help software engi- neers in this task. For example, code reading, peer review of a work product, and static anal- ysis of source code control flow are considered static techniques because they do not involve executing the software code. We will see, in section 3.4.5 that review and audit processes are consideredstatic anal- ysis activities, meaning that no software or models are executed. Instead, they examine software engineering artifacts (also called intermediary or work products) concerning standards established by the organization or project for those artifacts. 3.4.2. Dynamic Analysis Techniques Dynamic analysis techniques involve exe- cuting or simulating the software code, looking for errors and defects. Different dynamic techniques are performed throughout soft- ware development, maintenance, and opera- tion. Generally, these are testing techniques, but simulation, model analysis and model checking are considered dynamic analysis techniques. (See the Software Engineering Models and Methods KA.) In addition, black box testing is considered a dynamic analysis technique, as the software engineer analyzes the output received following the entry of inputs. (See the Software Testing KA.) 3.4.3. Formal Analysis Techniques 7, c10s10.5 Formal analysis techniques (also called formal methods) are mathematical approaches to software development where you define a formal model of the software. You may then formally analyze this model to search for errors and inconsistencies 7, c10s10.5.

--- Chunk 573 ---
Tokens: 374
Type: sentence-based
Text:
You may then formally analyze this model to search for errors and inconsistencies 7, c10s10.5. Sometimes, the software requirements may be written using a more formal specification language known as formal methods. They are notably used to verify software requirements and designs. They have mostly been used to verify crucial parts of critical systems, such as specific security and safety requirements. (See also Formal Methods in the Software Engineering Models and Methods KA.) Different groups may perform testing during software development, including groups independent of the development team. The Software Testing KA is devoted entirely to this subject. 3.4.4. Software Quality Control and Testing 1, c7s7.10 Testing is considered an important product quality control activity part of a soft- ware development projects VV processes. Quality Control is a set of activities that measure, evaluate and report on the quality of software project artifacts throughout the project life cycle 25. Software testing is an important quality control activity to ensure software quality. Software testing is one of many verification activities that confirm that software development output meets input requirements. IEEE 730:2014 6 lists the many testing and retesting activities software engineers should plan, execute, and record. It also recommends that testing completion cri- teria be set. Software engineers should plan the testing activities, including levels, tech- niques, measures, and tools.

--- Chunk 574 ---
Tokens: 389
Type: sentence-based
Text:
Software engineers should plan the testing activities, including levels, tech- niques, measures, and tools. Software quality engineering team, for critical systems, should particularly be involved in qualifying software products prior to its delivery (i) either for fur- ther integration or (ii) for operations in target computing environment; as an independent test and evaluation activity, without involving development team members in the process. (Refer to the Testing KA for details about the knowledge software engineers should have about software testing.) 12-14 SWEBOK  GUIDE V4.0 3.4.5. Technical Reviews and Audits 1, c5, c6 23, s4, s5 We have seen SQC techniques for assessing the quality of the software in section 2.4.1. For the other artefacts, product quality con- trol is assessed using reviews and inspections of these work products. These SQC activities are planned and executed during develop- ment, maintenance, and operations activities 17. Peer reviews are defined as the review of work products performed by peers during development of the work products to identify defects for removal 14. For example, during software development, a code review (often done by using a pull request techniquetool) occurs when a peer reviews the code, often at the software developers request, before it can be merged into a project. Reviews are valuable because they can iden- tify issues early in development or even before a component is designed. Fixing a defect in a component that has been coded is much more expensive than catching it beforehand.

--- Chunk 575 ---
Tokens: 376
Type: sentence-based
Text:
Fixing a defect in a component that has been coded is much more expensive than catching it beforehand. Different types of work product reviews (e.g, formal, and informal) are distinguished by pur- pose, level of independence, tools and tech- niques used, roles involved, and by the subject of the activity. Reviews play important roles in software quality, in SCM, and in the sharing of knowledge among colleagues. However, these different roles share a single purpose  to ensure the quality of the delivered products. Reviews should be part of the software engi- neering culture and should be planned, exe- cuted, and documented during the software life cycle. In Agile life cycles, pair programming invites continuous reviews. Different review types for work products are described in the ISOIEC 20246:2017 Standard 12:  Ad hoc reviews  unstructured reviews where each reviewer is expected to find as many defects as possible of any type;  Checklist-based reviews  system- atic reviews identifying issues based on checklists;  Scenario-based reviews  reviews where reviewers are provided with structured guidelines on how to read through the work product under review;  Perspective-based reviews  reviews where reviewers take on different stake- holder viewpoints and review the work product from that stakeholders view- point; and  Role-based reviews  reviews in which the reviewer evaluates the work product from the perspective of various stake- holder roles, which might differ from their daily role.

--- Chunk 576 ---
Tokens: 311
Type: sentence-based
Text:
Different review types for work products are described in the ISOIEC 20246:2017 Standard 12:  Ad hoc reviews  unstructured reviews where each reviewer is expected to find as many defects as possible of any type;  Checklist-based reviews  system- atic reviews identifying issues based on checklists;  Scenario-based reviews  reviews where reviewers are provided with structured guidelines on how to read through the work product under review;  Perspective-based reviews  reviews where reviewers take on different stake- holder viewpoints and review the work product from that stakeholders view- point; and  Role-based reviews  reviews in which the reviewer evaluates the work product from the perspective of various stake- holder roles, which might differ from their daily role. Audits are more formal activities that are often mandated to be performed by third parties to ensure independence. In mature organizations, technical reviews and audits are fully integrated with the overall project plans. Therefore, technical reviews and audits should be planned, approved, and conducted. Although a project audit often addresses the whole projects current state, technical reviews can also be more focused and address a spe- cific project phase 24.

--- Chunk 577 ---
Tokens: 386
Type: sentence-based
Text:
Although a project audit often addresses the whole projects current state, technical reviews can also be more focused and address a spe- cific project phase 24. System requirements reviews help ensure that the level of under- standing of top-level system requirements is adequate to support further requirements anal- ysis and design activities and that the system can proceed into initial system design with acceptable risk; System functional or pre- liminary design reviews help ensure that the system under review can proceed into prelimi- nary or detailed design with acceptable risk and that all system requirements and functional performance requirements derived from the approved preliminary system specification are defined and consistent with the project budget, program schedule, risk, and other program and system constraints; Preliminary design reviews help ensure that the preliminary design for the system under review is sufficiently mature and ready to proceed into detailed design and can meet the stated performance requirements within program budget, schedule, risk and other program and system constraints; Test readiness reviews assess test objectives, test methods and procedures, test scope, safety, readiness for the project test and evaluation, and whether test resources have been properly SOFTWARE QUALITY 12-15 identified and obtained; Production readi- ness reviews ascertain that the system design is ready for production and that the project has accomplished adequate production planning for entering production. 4.

--- Chunk 578 ---
Tokens: 358
Type: sentence-based
Text:
4. Software Quality Tools 1, c3s3.2.3, c7s7.8.1, c7s7.11 Software tools improve software quality. Simple tools can be forms and checklists (e.g, a requirements traceability matrix or a code review checklist). But automated tools can also be of great help to improve software efficiency and quality. Examples of automated tools are tools that allow code versioningbranching (e.g, Git) and pull requests for code review. DevOps tools in servicesscripts like on-demand envi- ronments, continuous integrationcontinuous delivery (CICD), code quality assessment, and automated testing are important contributors to software quality. (See the Software Operations KA discussion about tools.) These tools are known as static and dynamic analysis tools. Static analysis tools input source code, perform syntactical and semantic anal- ysis without executing the code, and present results to users. There is a large variety in the depth, thoroughness and scope of static anal- ysis tools that can be applied to artifacts, including models, and source code. (See the Software Construction, Software Testing, and Software Maintenance KAs for descrip- tions of dynamic analysis tools.) Categories of static analysis tools include the following:  Tools that facilitate and partially auto- mate reviews and inspections of docu- ments and code. These tools can route work to different participants to partially automate and control the review process.

--- Chunk 579 ---
Tokens: 400
Type: sentence-based
Text:
These tools can route work to different participants to partially automate and control the review process. In addition, they allow users to enter defects found during inspections and reviews for later removal;  Tools that help organizations perform software safety hazard analysis. These tools provide, for example, automated sup- port for failure mode and effects analysis (FMEA) and fault tree analysis (FTA);  Tools that support tracking of software problems. These tools enable entry of anomalies discovered during software testing and subsequent analysis, disposi- tion, and resolution. Some tools include support for workflow and for tracking problem resolution status; and  Tools that analyze data captured from software engineering environments and software test environments and pro- duce visual displays of quantified data in graphs, charts, and tables. These tools sometimes include the functionality to perform statistical analysis on data sets (to discern trends and make forecasts). Some of these tools provide defect injec- tion and removal rates, defect densities, yields, and distribution of defect injection and removal for each life cycle phase. MATRIX OF TOPICS VS. REFERENCE MATERIAL Topic Laporte and April 2018 1 Sommerville 2016 7 IEEE Software Code of Ethics 5 Wiegers 2013 13 1. Software Quality Fundamentals 1.1. Software Engineering Culture and Ethics Ch. 1s1.6, Ch. 2s3 X 1.2. Value and Cost of Quality Ch. 2s2.2 12-16 SWEBOK  GUIDE V4.0 1.3. Standards, Models and Certifications Ch. 4 Ch. 24s24.2 1.4. Software Dependability and Integrity Levels Ch. 4s4.8 Ch. 7s7.2-7.3 Ch.

--- Chunk 580 ---
Tokens: 358
Type: sentence-based
Text:
7s7.2-7.3 Ch. 10 2. Software Quality Management Process 2.1. Software Quality Improvement Ch. 9s9.9 2.2. Plan Quality Management 2.3. Evaluate Quality Management Ch. 10 Ch. 24s24.5 2.4. Perform Corrective and Preventive Actions Ch. 1,s3 3. Software Quality Assurance Process 3.1. Prepare for Quality Assurance Ch. 1s1.5, Ch. 4s4.6 Ch. 14 3.2. Perform Process Assurance Ch. 3s3.2-s3.3 Ch. 8, Ch. 9, Ch. 4s4.6.1.3 Ch. 25 3.3. Perform Product Assurance Ch. 3s3.2-3.3 Ch. 7, Ch. 5, Ch. 4s4.6.1.2 Ch. 4s4.1.2 3.4. Verification  Validation and Tests Ch. 5, Ch. 6, Ch. 7 Ch. 10s10.5 4. Software Quality Tools Ch. 3s3.2.3, Ch. 7s7.8.1, Ch. 7s7.11 X FURTHER READINGS IEEE 730-2014, IEEE Standard for Software Quality Assurance Processes, 2014 6. Requirements for initiating, planning, con- trolling, and executing the Software Quality Assurance processes of a software develop- ment or maintenance project are established in this standard. IEEE Std 1012-2016, IEEE Standard for System, Software, and Hardware Verification and Validation, 2016 11. Verification and validation (VV) pro- cesses are used to determine whether the development products of a given activity conform to that activitys requirements and whether the product satisfies its intended use and user needs. VV life cycle process requirements are specified for different integ- rity levels. ISOIEC Std 20246-2017, Software and Systems Engineering  Work Product Reviews, 2017 12.

--- Chunk 581 ---
Tokens: 386
Type: sentence-based
Text:
ISOIEC Std 20246-2017, Software and Systems Engineering  Work Product Reviews, 2017 12. This international standard establishes a generic framework for work product reviews that can be referenced and used by all orga- nizations involved in the management, devel- opment, testing and maintenance of systems and software. SOFTWARE QUALITY 12-17 N. Leveson, Safeware: System Safety and Computers 15. This book describes the importance of soft- ware safety practices and how these practices can be incorporated into software develop- ment projects. T. Gilb and D. Graham, Software Inspection 16. This book introduces measurement and sta- tistical sampling for reviews and defects. It presents techniques that produce quanti- fied results for reducing defects, improving productivity, tracking projects and creating documentation. K. E. Wiegers, Peer Reviews in Software: A Practical Guide 17. This book provides clear, succinct expla- nations of different peer review methods distinguished by level of formality and effec- tiveness. It provides pragmatic guidance for implementing the methods and for deter- mining which methods are appropriate for given circumstances. REFERENCES 1 C.Y. Laporte and A. April, Software Quality Assurance, IEEE Press, 2018. 2 P.B. Crosby, Quality Is Free, McGraw- Hill, 1979. 3 W. Humphrey, Managing the Software Process, Addison-Wesley, 1989. 4 ISOIEC, ISOIEC 25010:2011 Systems and Software Engineering  Systems and Software Quality Requirements and Evaluation (SQuaRE)  Systems and Software Quality Models, ed, 2011.

--- Chunk 582 ---
Tokens: 392
Type: sentence-based
Text:
4 ISOIEC, ISOIEC 25010:2011 Systems and Software Engineering  Systems and Software Quality Requirements and Evaluation (SQuaRE)  Systems and Software Quality Models, ed, 2011. 5 IEEE CSACM Joint Task Force on Software Engineering Ethics and Professional Practices, Software Engineering Code of Ethics and Professional Practice https:www .computer.orgeducationcode-of -ethics. 6 IEEE, IEEE 730 Standard for Software Quality Assurance Processes, ed, IEEE, 2014. 7 I. Sommerville, Software Engineering, 10th ed, New York: Addison- Wesley, 2016. 8 RTCA, DO-178C, Software Considerations in Airborne Systems and Equipment Certification, ed, 5 January 2012. Also known as ED-12C in EUROCAE. 9 ISOIEC, ISOIEC 15026-1:2019 Systems and Software Engineering  Systems and Software Assurance  Part 1: Concepts and Vocabulary, ed, ISOIEC, 2019. 10 ISO 9001:2015 Quality Management Systems  Requirements, ed, ISO, 2015. 11 IEEE, IEEE Std. 1012:2016, Standard for System and Software Verification and Validation, IEEE, 2016. 12 ISOIEC 20246:2017, Software and systems engineering  Work product reviews, ed, 2017. 13 K.E. Wiegers, Software Requirements, 3rd ed, Redmond, WA: Microsoft Press, 2013. 14 ISOIECIEEE, ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, 2nd ed. 2017. 15 N. Leveson, Safeware: System Safety 12-18 SWEBOK  GUIDE V4.0 and Computers, Addison-Wesley Professional, 1995. 16 T. Gilb and D. Graham, Software Inspection, Addison-Wesley Professional, 1993. 17 K. Wiegers, Peer Reviews in Software: A Practical Guide, Addison-Wesley Professional, 2001.

--- Chunk 583 ---
Tokens: 372
Type: sentence-based
Text:
17 K. Wiegers, Peer Reviews in Software: A Practical Guide, Addison-Wesley Professional, 2001. 18 BS EN 50128:2011A2:2020, Standard for Railway Applications  Communications, Signaling and Processing Systems  Software for Railway Control and Protection Systems, British-Adopted European Standard, 10 August 2020. 19 K. Iberle, They dont care about quality, proceedings of STAR East, Orlando, United States, 2013, available at https:kiberle.compublications. 20 D. Wallace, L. M. Ippolito, and B.B. Cuthill, Reference Information for the Software Verification and Validation Process, National Institute of Standards and Technology (NIST), U.D. Department of Commerce, Special Publication 500-234, 1996. 21 IEC 60300-1:2014, Dependability Management  Part 1: Guidance for Management and Application, version 3, 25 September 2014. 22 D. Leffingwell, Safe 4.5 Reference Guide: Scaled Agile Framework For Lean Enterprises, 2nd ed, New-York, Addison-Wesley, 2018. 23 ISOIEC TS 33061:2021, Information technology  Process assessment  Process Assessment Model for Software Life Cycle Processes, 2021-04. 24 IEEE Std 15288.2:2014, IEEE Standard for Technical Reviews and Audits on Defense Programs. 25 A guide to the Project management Body of Knowledge, 7th edition, PMI, 2021, 368p. 26 ISOIECIEEE 90003:2018, Guidelines for the application of ISO 9001:2015 to computer soft- ware, 2018-11. 27 COBIT, Control Objectives for Information Technology, version 2019, ISACA and the IT Governance Institute.

--- Chunk 584 ---
Tokens: 369
Type: sentence-based
Text:
27 COBIT, Control Objectives for Information Technology, version 2019, ISACA and the IT Governance Institute. 28 BABOK, A guide to the Business Analysis Body of Knowledge, version 3, International Institute of Business Analysis, 04-2015. 29 CMMI, Capability Maturity Model Integration, version 10, ISACA, 2023. 30 TOGAF, Open Group Architecture Framework, version 10, 04-2022. 31 ISOIEC 27001:2022, Information security, cybersecurity, and pri- vacy protection Information security management systems  Requirements, 10-2022. 13-1 CHAPTER 13 Software Security ACRONYMS CC Common Criteria SDLC Secure Development Life Cycle INTRODUCTION Security has become a significant issue in soft- ware development because of potential misuse and increasing malicious activity targeting computer systems. In addition to the usual correctness and reliability concerns, software developers must pay attention to the security of the software they develop. Secure software development builds security by following a set of established andor recommended rules and practices. Secure software mainte- nance complements secure software develop- ment by ensuring that no security problems are introduced during software maintenance and that identified vulnerabilities, which are errors that attackers can exploit, can be han- dled during the software life cycle. Security vulnerabilities are not only introduced at the development, but also by third party compo- nents such as libraries, COTS, or OS.

--- Chunk 585 ---
Tokens: 369
Type: sentence-based
Text:
Security vulnerabilities are not only introduced at the development, but also by third party compo- nents such as libraries, COTS, or OS. BREAKDOWN OF TOPICS FOR SOFTWARE SECURITY The breakdown of topics for the Software Security knowledge area (KA) is shown in Figure 13.1. 1. Software Security Fundamentals 37, 9 A generally accepted belief about software security is that it is much better to design security into software than to patch it in after the software is developed. To design secu- rity into software, one must consider every development life cycle stage. Secure software development involves software requirements security, software design security, software construction security and software testing security. In addition, security must be consid- ered during software maintenance, as secu- rity faults and loopholes can be and often are introduced during maintenance. 1.1. Software Security 10 Security is a product quality characteristic representing the degree to which a product or system protects information and data so that persons or other products or systems have data access appropriate to their types and levels of authorization 10. (For more information about product quality, refer to the Software Quality KA.) 1.2. Information Security 11 Information security preserves confidenti- ality, integrity and availability of informa- tion. Other properties, such as authenticity, accountability, non-repudiation and reliability can also be involved 11.

--- Chunk 586 ---
Tokens: 355
Type: sentence-based
Text:
Other properties, such as authenticity, accountability, non-repudiation and reliability can also be involved 11. Confidentiality is the property of ensuring that information is not disclosed to unauthorized individuals, entities or processes. Integrity is the property of accuracy and completeness. Availability is the property of being accessible and usable on demand by an authorized entity. Software engineers should define the secu- rity properties of their software and maintain them throughout the software development life cycle. 13-2 SWEBOK  GUIDE V4.0 1.3. Cybersecurity 1238 Cybersecurity is safeguarding of people, society, organizations and nations from cyber risks. Safeguarding means to keep cyber risk at a tolerable level. Generally, cybersecurity addresses secu- rity issues in cyberspace, including the following:  Social engineering attacks  Hacking  The proliferation of malicious soft- ware (malware)  Spyware  Other potentially unwanted software 12 Software engineers should consider the mitigation of such threats as part of software development. 2. Security Management and Organization 1, c713 Security governance and management are most effective when they are systematic; in other words, when they are woven into the culture and fabric of organizational behaviors and actions. Project managers need to elevate software security from a stand-alone tech- nical concern to an enterprise issue 1. 2.1.

--- Chunk 587 ---
Tokens: 255
Type: sentence-based
Text:
2.1. Capability Maturity Model 3, c2214 Many organizations practice security engi- neering in the development of computer pro- grams, including operating systems, functions that manage and enforce security, packaged software products, middleware, and applica- tions. Therefore, a diverse array of individuals must know how to apply appropriate methods and practices, including product developers, service providers, system integrators, system administrators and even security specialists. Systems Security Engineering  Capability Maturity Model (SSE-CMM), which helps measure the process capability of an organi- zation that performs risk assessments 14, can be an important tool. 2.2. Information Security Management System 15 International Organization of Standardization International Electrotechnical Commission (ISOIEC) 27001:2022 specifies the require- ments for establishing, implementing, main- taining and continually improving an information security management system (ISMS) within the organizational context 15.

--- Chunk 588 ---
Tokens: 362
Type: sentence-based
Text:
Information Security Management System 15 International Organization of Standardization International Electrotechnical Commission (ISOIEC) 27001:2022 specifies the require- ments for establishing, implementing, main- taining and continually improving an information security management system (ISMS) within the organizational context 15. ISMS is a documented plan for man- aging the technology-related security of an Software Security Software Security Fundamentals Software Security Engineering and Process Software Engineering for Software Systems Domain Specic Software Security Software Security Information Security Cybersecurity Security Engineering and Development Lifecycle Common Criteria for Information Technology Security Evaluation Security Requirements Security Design Security Patterns Construction for Security Security Testing Vulnerability Management Software Security Tools Security Vulnerability Checking Tools Penetration Testing Tools Security for Container and Cloud Security for IoT Software Security for Machine Learning-Based Application Security Management and Organization Capability Maturity Model Information Security Management System Agile Practice for Software Security Figure 13.1. The Breakdown of Topics for the Software Security KA SOFTWARE SECURITY 13-3 organization. This includes documenting risks and taking measures to address them, aiming to protect the organizations data and prevent security breaches 15.

--- Chunk 589 ---
Tokens: 360
Type: sentence-based
Text:
This includes documenting risks and taking measures to address them, aiming to protect the organizations data and prevent security breaches 15. Organization should use it to continually conduct risk assess- ments to identify security risks and vulnera- bilities and implement protective measures by deploying an IT team to monitor these risks. An ISMS can thus also raise new or changed existing software security requirements. In addition, software security requirements are derived from laws, regulations and obligations for compliance. 2.3. Agile Practice for Software Security 4,c15,c16 Agile teams need to understand and adopt security practices and take more responsibility for their systems security. Security profes- sionals must learn to accept change, work faster and more iteratively, and think about security risks and how to manage risks in incremental terms. Finally, and most important, secu- rity needs to become an enabler instead of a blocker. The keys to a successful Agile security program are the involvement of the security team and developers, enablement, automation, and agility to keep up with Agile teams 4. 3. Software Security Engineering and Processes 3.1. Security Engineering and Secure Development Life Cycle (SDLC) 1, c11636 Software is only as secure as its development process. Security must be built into software engineering to ensure software security. The SDLC concept is one trend that aims to do this.

--- Chunk 590 ---
Tokens: 396
Type: sentence-based
Text:
The SDLC concept is one trend that aims to do this. SDLC uses a classical spiral model that views security holistically from the perspective of the software life cycle and ensures that secu- rity is inherent in software design and develop- ment, not an afterthought later in production. The SDLC process is claimed to reduce soft- ware maintenance costs and increase software reliability against security-related faults. Recently, DevSecOps (meaning the integra- tion of development, security and operations) has emerged. Beyond SDLC, DevSecOps includes an approach to culture, automation and platform design to make the software life cycle as Agile and responsible as Agile devel- opment and continuous integration (CI). 3.2. Common Criteria for Information Technology Security Evaluation 3, c22, c253435 Security evaluation establishes confidence in the security functionality of IT products and the assurance measures applied to them. The evaluation results may help consumers deter- mine whether IT products meet their secu- rity needs or standards conformity. ISO IEC 15408:2022, named Common Criteria (CC) for Information Technology Security Evaluation, is useful as a guide for developing, evaluating andor procuring IT products with security functionality 34. CC addresses the protection of assets from unauthorized disclosure, modification or loss of use. The categories of protection relating to these three types of security failure are commonly called confidentiality, integrity and availability, respectively. 4. Security Engineering for Software Systems 1,c1,c33,c1,c3 4.1.

--- Chunk 591 ---
Tokens: 398
Type: sentence-based
Text:
Security Engineering for Software Systems 1,c1,c33,c1,c3 4.1. Security Requirements 1,c32,c23,c20,c3018 Security requirements engineering includes elicitation, specification, and prioritization. It considers threats, as illustrated by misuse and abuse cases, threat actors, security risk assess- ments, selection and application of speci- fication methods, prioritization methods, inspections, and revisions. Selection of life- cycle models may impact the order of activities, and software product revision implies a need to revisit security requirements. Traceability of security requirements throughout the development process is important, and secu- rity teams may include specialist in security 13-4 SWEBOK  GUIDE V4.0 requirements. Numerous methods and tools exist in support of security requirements engineering. 4.2. Security Design 1,c42,c53,c20,c3117,40 Security design concerns how to prevent unauthorized disclosure, creation, change, deletion or denial of access to informa- tion and other resources. It also concerns how to tolerate security-related attacks or violations by limiting damage, continuing service, speeding repair and recovery, and failing and recovering securely. Access con- trol is a fundamental concept of security. Most controls build on cryptographic algo- rithms and cryptographic material like keys. It is important to carefully select these and how crypto material is created, distributed and managed. Software design security deals with the design of software modules that fit together to meet the security objectives specified in the security requirements.

--- Chunk 592 ---
Tokens: 347
Type: sentence-based
Text:
Software design security deals with the design of software modules that fit together to meet the security objectives specified in the security requirements. To meet secu- rity requirements, developers conduct threat modeling, illustrating how a system is being attacked to specify a security design for the mitigation. This step clarifies the details of security considerations and develops the spe- cific steps for implementation. Factors con- sidered may include frameworks and access modes that set up the overall security mon- itoringenforcement strategies, as well as the individual policy enforcement mechanisms. 4.3. Security Patterns 1,c419, 20, 21 A security pattern describes a particular recur- ring security problem that arises in a specific context and presents a well-proven generic solution 21. 4.4. Construction for Security 1,c53,c20,c3122, 23, 24 Software construction security concerns how to write programming code for specific sit- uations to address security considerations. The term software construction security can mean different things to different people. It can mean the way a specific function is coded so that the code itself is secure, or it can mean the coding of security into software. Unfortunately, most people entangle the two meanings without distinction. One reason for such confusion is that it is unclear how to ensure a specific coding is secure.

--- Chunk 593 ---
Tokens: 399
Type: sentence-based
Text:
One reason for such confusion is that it is unclear how to ensure a specific coding is secure. For example, in the C programming language, the expres- sions i1 (shift the binary representation of is value to the left by one bit) and 2 (mul- tiply the value of variable i by constant 2) mean the same thing semantically, but do they have the same security ramifications? The answer could be different for different combinations of ISAs and compilers. Because of this lack of understanding, software con- struction security  in its current state  mostly refers to the second aspect mentioned above: the coding of security into software. Coding of security into the software can be achieved by following recommended rules. A few such rules follow:  Structure the process so that all sec- tions requiring extra privileges are mod- ules. The modules should be as small as possible and perform only the tasks that require those privileges. Ensure that any assumptions in the pro- gram are validated. If this is not possible, document them for the installers and maintainers so they know the assump- tions attackers will try to invalidate. Ensure that the program does not share objects in memory with any other program. Check every functions error status. Do not recover unless neither the errors cause nor its effects affect any secu- rity considerations. The program should restore the state of the software to the state it had before the process began and then terminate. Although there are no bulletproof ways to achieve secure software development, some general guidelines exist that can be helpful.

--- Chunk 594 ---
Tokens: 345
Type: sentence-based
Text:
Although there are no bulletproof ways to achieve secure software development, some general guidelines exist that can be helpful. SOFTWARE SECURITY 13-5 These guidelines span every phase of the soft- ware development life cycle. The Computer Emergency Response Team (CERT) pub- lishes reputable guidelines, and the following are its top 10 software security practices (the details can be found in 22): 1. Validate input. 2. Heed compiler warnings. 3. Architect and design for security policies. 4. Keep it simple. 5. Default deny. 6. Adhere to the principle of least privilege. 7. Sanitize data sent to other software. 8. Practice defense in depth. 9. Use effective quality assurance techniques. 10. Adopt a software construction secu- rity standard. 4.5. Security Testing 1,c52,c73,c24,c3126, 27 Security testing ensures that the implemented software meets the security requirements. It also verifies that the software implementation contains none of the known vulnerabilities. Whereas general software testing methods can handle the former, the latter requires security-specific testing methods. (For more information about testing, please refer to the Software Testing KA.) There are two general approaches to security-specific testing. The first approach includes detecting vulnerabilities through static analysis, which can be conducted on the source code or compiled binaries.

--- Chunk 595 ---
Tokens: 383
Type: sentence-based
Text:
The first approach includes detecting vulnerabilities through static analysis, which can be conducted on the source code or compiled binaries. A static analysis on the source code can be used to detect programming language or implemen- tation-specific vulnerabilities, while static analysis on compiled binaries can be used to detect vulnerabilities that are not apparent in the source code due to compiler optimi- zations or hidden in the compiled third- party components. Static analysis can be automated using tools, however while auto- mation can play a significant role, the exper- tise of security professionals are required to properly operate and configure the tools, and verify the results. The other approach to detect vulnera- bilities is through dynamic testing, typi- cally using techniques such as vulnerability assessment or penetration testing (also known as the ethical hacking test), to detect vulnerabilities in software behavior. Like static analysis, there are tools that can auto- mate dynamic testing, such as web appli- cation scanners and fuzzing tools. Security experts skilled in the application domain should be engaged to perform these tests, and such tests should always be conducted within legal boundaries and with proper authorization. The latter aspects are cru- cial to differentiate such tests from illegal hacking activities. 4.6. Vulnerability Management 1,c53,c2428,29, 30 Using sound coding practices can help sub- stantially reduce software defects commonly introduced during implementation 1.

--- Chunk 596 ---
Tokens: 362
Type: sentence-based
Text:
Vulnerability Management 1,c53,c2428,29, 30 Using sound coding practices can help sub- stantially reduce software defects commonly introduced during implementation 1. Such common security defects are categorized and shared with databases: the Common Vulnerabilities and Exposures (CVE) 28, Common Weakness Enumeration (CWE) 29, and Common Attack Pattern Enumeration and Classification (CAPEC) 30; Common Vulnerability Scoring System (CVSS) 41 expresses characteristics and severity of soft- ware vulnerabilities. Programmers can refer to these databases for security implementation, and some tools are available to check common vulnerabilities in codes. Security maintenance encompasses the task to mitigate effects of vul- nerabilities in a system and third party com- ponents which the system uses. The task often comes with a vulnerability disclosure pro- cess that allows to report the identification of vulnerabilities. 5. Software Security Tools 5.1. Security Vulnerability Checking Tools 1,c625 Security vulnerability checking tools, such as source code analyzers and binary analysis 13-6 SWEBOK  GUIDE V4.0 tools, can be used to identify potential secu- rity vulnerabilities and issues. Source code analyzers scrutinize code to detect secu- rity vulnerabilities, such as injection flaws, buffer overflows, and insecure library use. They are useful at finding vulnerabilities that can be identified through code pat- terns and logical flaws.

--- Chunk 597 ---
Tokens: 391
Type: sentence-based
Text:
They are useful at finding vulnerabilities that can be identified through code pat- terns and logical flaws. Binary analysis tools, on the other hand, examine compiled code, including third-party libraries, for vulnerabilities that might not be apparent in the source code or that arise from the compilation process. While these tools sig- nificantly aid in detecting vulnerabilities, they cannot find all vulnerabilities. For example, they might not capture vulner- abilities that manifest in hard-to-produce software states or that crop up in unusual circumstances 1. 5.2. Penetration Testing Tools 2,c4 Penetration testing tools can be used to eval- uate a systems security in its operational environment. These tools perform controlled attacks on the system to uncover vulnerabili- ties and security weaknesses, using techniques such as fuzzing 2, where malformed, mali- cious, or random data is submitted to the sys- tems various entry points to detect faults. The use of penetration testing tools to expose vul- nerabilities provide insights into how an actual attacker could exploit the system. 6. Domain-Specific Software Security 6.1. Security for Container and Cloud 31 Cloud infrastructure and services are often inexpensive and easy to provision, which can quickly lead to having many assets strewn all over the world and forgotten. These forgotten assets are like a ticking time bomb, waiting to explode into a security incident 31. One important difference with cloud envi- ronments is that physical assets and protection are generally not a concern.

--- Chunk 598 ---
Tokens: 380
Type: sentence-based
Text:
One important difference with cloud envi- ronments is that physical assets and protection are generally not a concern. Developers can gleefully outsource asset tags, anti-tailgating, slab-to-slab barriers, placement of data center windows, cameras, and other physical secu- rity and physical asset tracking controls 31. 6.2. Security for IoT Software 32,33 As part of todays IoT (internet of things), systems are interconnected with many other devices, especially back-end systems suffering from all the well-known secu- rity flaws inherent in todays business IT. Attackers gaining access to business IT plat- forms, for instance, by exploiting browser vulnerabilities, will likely also gain access to weakly protected IoT industrial devices. This can cause severe damage, including safety incidents. Hence, the introduction of a massive number of end points from the consumer or industrial environment cre- ates fertile ground for the exploitation of weak links. Hardening these end points, securing device-to-device communications, and ensuring device and information cred- ibility in what until now have been closed, homogeneous systems present new chal- lenges. Comprehensive risk and threat anal- ysis methods, as well as management tools for IoT platforms, are required 33. 6.3. Security for Machine Learning-Based Application 39,c8 Although machine learning techniques are widely used in many systems, machine learning presents a specific vulnerability. Attackers can change the decisions of machine learning models.

--- Chunk 599 ---
Tokens: 363
Type: sentence-based
Text:
Attackers can change the decisions of machine learning models. There are two kinds of attacks: model poisoning, which attacks training data, and evasion, which attacks inputs to trained models 39. SOFTWARE SECURITY 13-7 MATRIX OF TOPICS VS. REFERENCE MATERIAL Topic Allen et al. 2008 1 McGraw 2006 2 Bishop 2019 3 Bell 2017 4 1. Software Security Fundamentals 1.1. Software Security 1.2. Information Security 1.3. Cybersecurity Ch. 23 2. Security Management and Organization Ch. 7 2.1. Capability Maturity Model Ch. 22 2.2. Information Security Management System 2.3. Agile Practice for Software Security Ch. 15, Ch. 16 3. Software Security Engineering and Processes Ch. 9 3.1. Security Engineering and Secure Development Life Cycle Ch. 1 Ch. 4 3.2. Common Criteria for Information Technology Security Evaluation Ch. 22, Ch. 25 4. Security Engineering for Software Systems Ch. 1, Ch. 15, Ch. 1, Ch. 3 4.1. Security Requirements Ch. 3 Ch. 2 Ch. 20, Ch. 31 Ch. 5, Ch. 8 4.2. Security Design Ch. 4 Ch. 5 Ch. 20, Ch. 31 Ch. 8 4.3. Security Patterns Ch. 4 4.4. Construction for Security Ch. 5 Ch. 20, Ch. 31 4.5. Security Testing Ch. 5 Ch. 24, Ch. 31 Ch. 10, Ch. 11 4.6. Vulnerability Management Ch. 24 Ch. 6 5. Software Security Tools 5.1. Security Vulnerability Checking Tools Ch. 6 Ch. 6 5.2. Penetration Testing Tools Ch. 4 Ch. 31 Ch. 11, Ch. 12 6. Domain-Specific Software Security 6.1. Security for Container and Cloud 6.2. Security for IoT Software 6.3.

--- Chunk 600 ---
Tokens: 374
Type: sentence-based
Text:
Security for IoT Software 6.3. Security for Machine Learning-Based Application 13-8 SWEBOK  GUIDE V4.0 FURTHER READINGS J. Viega, Building Secure Software: How to Avoid Security Problems the Right Way, Addison-Wesley, 2011. This book introduces the definition of Software Security and the activities to develop and maintain secure software. It includes not only the software development process but also the related activities such as auditing and the monitoring of service. L. Kohnfelder, Designing Secure Software: A Guide for Developers, No Starch Press, 2021. This book describes security activities in the software design and implementation phases, including secure programming and web secu- rity. It also introduces best practices for secure software development. C.W. Axelrod, Engineering Safe and Secure Software Systems, Artech House Publishers, 2012. This book describes engineering activities to make software systems safe and secure from a risk management viewpoint. It introduces risk assessment and mitigation methods for secu- rity and safety. REFERENCES 1 J.H. Allen, S.J. Barnum, R.J. Ellison, G. McGraw, and N.R. Mead, Software Security Engineering: A Guide for Project Managers, Addison-Wesley Professional, 2008. 2 G. McGraw, Software Security: Building Security In, Addison-Wesley Professional, 2006. 3 M. Bishop, Computer Security, 2nd Edition, Addison-Wesley Professional, 2019. 4 L. Bell, M. Brunton-Spall, R. Smith, and J. Bird, Agile Application Security, OReilly, 2017.

--- Chunk 601 ---
Tokens: 384
Type: sentence-based
Text:
4 L. Bell, M. Brunton-Spall, R. Smith, and J. Bird, Agile Application Security, OReilly, 2017. 5 T. Hsiang-Chih Hsu, Hands-On Security in DevOps: Ensure continuous security, deployment, and delivery with DevSecOps, Packt Publishing, 2018. 6 T. Hsiang-Chih Hsu, Practical Security Automation and Testing: Tools and techniques for automated security scan- ning and testing in DevSecOps, Packt Publishing, 2019. 7 G. Wilson, DevSecOps: A leaders guide to producing secure software without com- promising flow, feedback and continuous improvement, Rethink Press, 2020. 8 L. Rice, Container Security: Fundamental Technology Concepts That Protect Containerized Applications, OReilly  Associates Inc, 2020. 9 ISOIECJTC1 SC27 Standards: Trustworthiness, Cryptography, Data security, Cryptography, Security eval- uation and testing, Security control, Identity management and privacy technologies. 10 ISOIEC 25010:2023 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Product quality model. 11 ISOIEC 27000:2018 Information technology  Security techniques  Information security management sys- tems  Overview and vocabulary. 12 ISOIEC 27032:2012 Information technology  Security techniques  Guidelines for cybersecurity. 13 ISOIEC 19770-1:2017 Information technology  IT asset management SOFTWARE SECURITY 13-9  Part 1: IT asset management sys- tems  Requirements. 14 ISOIEC 21827:2008 Information technology  Security techniques  Systems Security Engineering  Capability Maturity Model (SSE-CMM).

--- Chunk 602 ---
Tokens: 377
Type: sentence-based
Text:
14 ISOIEC 21827:2008 Information technology  Security techniques  Systems Security Engineering  Capability Maturity Model (SSE-CMM). 15 ISOIEC 27001:2022 Information Security, Cybersecurity And Privacy Protection  Information Security Management Systems  Requirements. 16 M. Howard and S. Lipner, The Security Development Lifecycle, Microsoft Press, 2006. 17 F. Swiderski and W. Snyder, Threat Modeling: Design for Security, Wiley, 2014. 18 D. Firesmith, Security use cases, Journal of Object Technology, Vol. 2, No. 1, pp. 53-64, 2003. 19 E. Fernandez-Buglioni, Security Patterns in Practice: Designing Secure Architectures Using Software Patterns, Wiley, 2013. 20 C. Nagappan, R. Lai, and R. Steel, Core Security Patterns: Best Practices and Strategies for J2EE, Web Services, and Identity Management, Prentice Hall, 2005. 21 M. Schumacher, E. Fernandez- Buglioni, D. Hybertson, F. Buschmann, and P. Sommerlad, Security Patterns: Integrating Security and Systems Engineering, Wiley, 2006. 22 R.C. Seacord, The CERT C Secure Coding Standard, Addison-Wesley Professional, 2008. 23 R.C. Seacord, Secure Coding in C and C, Addison-Wesley Professional, 2013. 24 D. Long, F. Mohindra, D. Seacord, R.C. Sutherland, and D.F. Svoboda, The CERT Oracle Secure Coding Standard for Java, 2011. 25 J. Erickson, Hacking: The Art of Exploitation, 2nd Edition, No Starch Press, 2008. 26 K. Scarfone, M. Souppaya, A. Cody, and A. Orebaugh, Technical Guide to Information Security Testing and Assessment, NIST SP800-115, 2008.

--- Chunk 603 ---
Tokens: 390
Type: sentence-based
Text:
26 K. Scarfone, M. Souppaya, A. Cody, and A. Orebaugh, Technical Guide to Information Security Testing and Assessment, NIST SP800-115, 2008. 27 PCI Security Standards Council, PCI DSS: Payment Card Industry Data Security Standard, Version 3.2, 2017. 28 MITRE, Common Vulnerabilities and Exposures (CVE), https:cve.mitre.org. 29 MITRE, Common Weakness Enumeration (CWE), https:cwe. mitre.org. 30 MITRE, Common Attack Pattern Enumeration and Classification (CAPEC), https:capec.mitre.org. 31 C. Dotson, Practical Cloud Security, OReilly, 2019. 32 Internet of Things Security Best Practices, IEEE, 2017, https: internetinitiative.ieee.orgresources reports-presentations-publications. 33 IoT 2020: Smart and secure IoT plat- form, IEC, 2016, https:www.iec.ch basecampiot-2020-smart-and-secure -iot-platform. 34 ISOIEC 15408-1:2022 Information security, cybersecurity and privacy pro- tection  Evaluation criteria for IT security  Part 1: Introduction and general model. 35 ISOIEC 18045:2008 Information technology  Security techniques 13-10 SWEBOK  GUIDE V4.0  Methodology for IT security evaluation. 36 DoD Enterprise DevSecOps, https: software.af.mildsopdocuments. 37 C. Easttom, Computer Security Fundamentals, 4th Edition, Pearson IT Certification, 2019. 38 Y. Diogenes and E. Ozkaya, Cybersecurity  Attack and Defense Strategies, Second Edition, Packt Publishing, 2019. 39 C. Chio and D. Freeman, Machine Learning and Security: Protecting Systems with Data and Algorithms, OReilly, 2018. 40 I. Sommerville, Software Engineering, 10th ed, Addison-Wesley, 2016.

--- Chunk 604 ---
Tokens: 387
Type: sentence-based
Text:
40 I. Sommerville, Software Engineering, 10th ed, Addison-Wesley, 2016. 41 FIRST, CVSS v4.0 Specification Document, https:www.first.orgcvss specification-document. 14-1 CHAPTER 14 Software Engineering Professional Practice ACRONYMS ACM Association for Computing Machinery CCPA The California Consumer Privacy Act EEA European Economic Area ENAEE European Network for Accreditation of Engineering Education EU European Union GDPR The General Data Protection Regulation IEA International Engineering Alliance IEC International Electrotechnical Commission IEEE CS IEEE Computer Society IFIP International Federation for Information Processing IP Intellectual Property ISO International Organization for Standardization NDA Nondisclosure Agreement UIUX User InterfaceUser Experience WIPO World Intellectual Property Organization WTO World Trade Organization INTRODUCTION The Software Engineering Professional Practice knowledge area (KA) is concerned with the knowledge, skills, and attitudes soft- ware engineers must possess to practice soft- ware engineering in a professional, responsible and ethical manner. Because of the widespread applications of software products in social and personal life, software product quality can profoundly affect personal well-being and societal harmony. Software engineers must handle unique engineering problems to pro- duce software with known characteristics and reliability. This requirement calls for software engineers who possess the proper knowledge, skills, training, and experience in professional practice.

--- Chunk 605 ---
Tokens: 368
Type: sentence-based
Text:
This requirement calls for software engineers who possess the proper knowledge, skills, training, and experience in professional practice. Professional practice refers to a way of con- ducting services to achieve certain standards or criteria in both the process of performing a ser- vice and the end product resulting from the ser- vice. These standards and criteria can include both technical and non-technical aspects. The concept of professional practice is espe- cially applicable to professions with a generally accepted body of knowledge; code of ethics and professional conduct with penalties for viola- tions; accepted processes for accreditation, cer- tification, qualification, and licensing; and professional societies to provide and administer all these. Admission to these professional soci- eties is often predicated on a prescribed combi- nation of education and experience. A software engineer maintains professional practice by performing all work following generally accepted practices, standards, and guidelines set forth by the applicable pro- fessional society, such as the Association for Computing Machinery (ACM), Institute for Electrical and Electronics Engineers (IEEE), or International Federation for Information Processing (IFIP), IEEE Computer Society (IEEE CS), International Organization for StandardizationInternational Electrotechnical Commission (ISOIEC), and ISOIEC IEEE provide internationally accepted soft- ware engineering standards.

--- Chunk 606 ---
Tokens: 398
Type: sentence-based
Text:
A software engineer maintains professional practice by performing all work following generally accepted practices, standards, and guidelines set forth by the applicable pro- fessional society, such as the Association for Computing Machinery (ACM), Institute for Electrical and Electronics Engineers (IEEE), or International Federation for Information Processing (IFIP), IEEE Computer Society (IEEE CS), International Organization for StandardizationInternational Electrotechnical Commission (ISOIEC), and ISOIEC IEEE provide internationally accepted soft- ware engineering standards. All of these 14-2 SWEBOK  GUIDE V4.0 standards and guidelines comprise the foun- dation of the professional practice of software engineering. BREAKDOWN OF TOPICS FOR SOFTWARE ENGINEERING PROFESSIONAL PRACTICE The Software Engineering Professional Practice KAs breakdown of topics is shown in Figure 14.1. The subareas presented in this KA are pro- fessionalism, group dynamics and psychology, and communication skills. 1. Professionalism A software engineer displays professionalism notably by adhering to a code of ethics and professional conduct and to standards and practices established by the engineers profes- sional community. One or more professional societies often represent a professional community, and this is the case for the engineering community. Those societies publish codes of ethics and professional conduct as well as criteria for admittance to the community. Those criteria form the basis for accreditation and licensing activities and may determine engineering competence or negligence.

--- Chunk 607 ---
Tokens: 212
Type: sentence-based
Text:
Those criteria form the basis for accreditation and licensing activities and may determine engineering competence or negligence. As software is used more widely and deeply in society, stakeholders requirements have likewise become wider and deeper. And as software has become socially vital, software engineers have worked to base the user inter- faceuser experience (UIUX) on socially inclusive concepts. 1.1. Accreditation, Certification and Qualification, and Licensing 1, cls4-s5, cls10 2 4, c12s10 6 7 8 9 1.1.1. Accreditation Accreditation certifies an organizations com- petency, authority, or credibility. Accredited schools or programs have shown that they adhere to particular standards and maintain certain qualities. In many countries, the basic means by which engineers acquire knowledge is by completing an accredited course of study.

--- Chunk 608 ---
Tokens: 395
Type: sentence-based
Text:
In many countries, the basic means by which engineers acquire knowledge is by completing an accredited course of study. Often, the accreditation process is indepen- dent of the government and is performed by Software Engineering Professional Practice Professionalism Group Dynamics and Psychology Communication Skills Accreditation Certication and Qualication, and Licensing Code of Ethics and Professional Conduct Nature and Role of Professional Societies Nature and Role of Software Engineering Standards Economic Impact of Software Employment Contracts Legal Issues Documentation Trade-o Analysis Dynamics of Working in TeamsGroups Individual Cognition Dealing with Problem Complexity Interacting with Stakeholders Dealing with Uncertainty and Ambiguity Dealing with Equity, Diversity and Inclusivity Reading, Understanding, and Summarizing Writing Team and Group Communication Presentation Skills Figure 14.1. Breakdown of Topics for the Software Engineering Professional Practice KA SOFTWARE ENGINEERING PROFESSIONAL PRACTICE 14-3 private membership associations. There are two major global accreditation organizations. One is the International Engineering Alliance (IEA), of which the Washington Accord is a constituent. The other is the European Network for Accreditation of Engineering Education (ENAEE), which administers EUR-ACE, the label awarded to engineering degree programs at the bachelors and masters levels, listed by the European Commission. Although the accreditation process might differ for each country and jurisdiction, the gen- eral meaning is the same.

--- Chunk 609 ---
Tokens: 372
Type: sentence-based
Text:
Although the accreditation process might differ for each country and jurisdiction, the gen- eral meaning is the same. Accreditation of an institutions course of study means the accred- itation body recognizes an educational institu- tion as maintaining standards that qualify the graduates for admission to higher or more spe- cialized institutions or professional practice. 1.1.2. Certification and Qualification ISOIEC 24773-1 Software and Systems Engineering  Certification of Software and Systems Engineering Professionals  Part 1: General Requirements define certification and qualification 8 defines certification and qualification. ISOIEC 24773-4 Software and Systems Engineering  Certification of Software and Systems Engineering Professionals  Part 4: Software engineering 9 elaborates requirements and recommen- dations for certification schemes based on ISOIEC 24773-1, which are specific to the domain of software engineering. Certification contains recertification. Qualification is sim- ilar to certification but does not require re-qualification. Certification refers to the confirmation of a persons particular char- acteristics. A common type of certification is professional certification, which certifies a person as being able to complete an activity in a certain discipline at a stated level of compe- tency. Professional certification can verify the holders ability to meet professional standards and to apply professional judgment in solving or addressing problems.

--- Chunk 610 ---
Tokens: 375
Type: sentence-based
Text:
Professional certification can verify the holders ability to meet professional standards and to apply professional judgment in solving or addressing problems. Professional certifi- cation can also verify prescribed knowledge, mastery of best practices and proven method- ologies, and professional experience. An engineer usually obtains certifica- tion by passing an examination in addition to meeting other experience-based criteria. Nongovernmental organizations, such as pro- fessional societies, often administer these examinations. In software engineering, certi- fication testifies to ones capability as a soft- ware engineer. The qualification and certification programs are designed to confirm a software engineers knowledge of standard software engineering practices and to advance the engineers career. A lack of qualification or certification does not exclude the individual from working as a software engineer. Qualification or certifi- cation in software engineering is voluntary. Most software engineers are not qualified or certified under any program 1.1.3. Licensing Licensing authorizes a person to perform cer- tain activities and take responsibility for resultant engineering products. The noun license refers to both that authorization and the document recording that authorization. Governmental authorities or statutory bodies usually issue licenses. Obtaining a license to practice requires an individual to meet a certain standard at a cer- tain ability to practice or operate.

--- Chunk 611 ---
Tokens: 393
Type: sentence-based
Text:
Obtaining a license to practice requires an individual to meet a certain standard at a cer- tain ability to practice or operate. Sometimes an entry-level requirement sets the minimum skills and capabilities to practice, and as the profes- sional moves through their career, the required skills and capabilities change and evolve. Engineers are licensed to protect the public from unqualified individuals. In some coun- tries, no one can practice as a professional engineer unless licensed; further, no company may offer engineering services unless at least one licensed engineer is employed there. 1.2. Codes of Ethics and Professional Conduct 1, cls7-cls9, c10s2, Appendix 3, c8 4, cls2 5, c3310 11 13 Codes of ethics and professional conduct describe the values and behavior that an engineers professional practice and decisions 14-4 SWEBOK  GUIDE V4.0 should embody. The professional community establishes a code of ethics and professional conduct. This code exists in the context of societal norms and local laws and is adjusted to agree with those norms and laws as needed. A code of ethics and professional conduct can offer guidance in the face of conflicting imperatives. More than one such code serves the professional engineering community. For example, in 1999, IEEE CS and ACM launched a joint Software Engineering Ethics and Professional Practices Task Force to publish a code of ethics. In 2018, ACM published its ACM Code of Ethics and Professional Conduct, and in 2020, IEEE published a revision of its Code of Ethics which was originally approved in 1912.

--- Chunk 612 ---
Tokens: 400
Type: sentence-based
Text:
In 2018, ACM published its ACM Code of Ethics and Professional Conduct, and in 2020, IEEE published a revision of its Code of Ethics which was originally approved in 1912. Then, in 2021, IFIP published its Code of Ethics and Professional Conduct, adapted from ACMs Code of Ethics and Professional Conduct. Once established, codes of ethics and pro- fessional conduct are enforced by the profes- sion, as represented by professional societies or by a statutory body. Violations may be acts of commission, such as concealing inadequate work, disclosing confidential information, falsifying information, or misrepresenting abilities. They may also occur through omis- sion, including failure to disclose risks or pro- vide important information, failure to give proper credit or acknowledge references, and failure to represent client interests. Violations of a code of ethics and professional conduct may result in penalties and possible expulsion from professional status. Software engineers shall commit them- selves to making the analysis, specification, design, development, testing, and mainte- nance of software a beneficial and respected profession. Following their commitment to the health, safety, and welfare of the public, software engineers shall adhere to the ten principles according to IEEE Code of Ethics adopted by the IEEE Board of Directions, June 2020. Since the code of ethics and professional conduct may be introduced, modified, or replaced at any time, individual software engineers are responsible for continuing their studies to stay current in their professional practice. 1.3.

--- Chunk 613 ---
Tokens: 364
Type: sentence-based
Text:
1.3. Nature and Role of Professional Societies 1, c2s3 4, c1s2 5, c35s1 Professional societies comprise a mix of practitioners and academics. These societies define, advance, and regulate their corre- sponding professions. Professional societies help establish professional standards as well as codes of ethics and professional conduct. They also engage in related activities, which include the following:  Establishing and promulgating a body of generally accepted knowledge  Providing the basis for licensing, certi- fying, and accrediting  Dispensing disciplinary actions  Advancing the profession through confer- ences, training, publications, and standards Participation in professional societies assists individual engineers in maintaining and sharpening their professional knowledge and relevancy and in expanding and main- taining their professional network. 1.4. Nature and Role of Software Engineering Standards 1, c10s2 2 4 5, c32s6 Software engineering standards cover a remarkable variety of topics. They provide guidelines for the practice of software engi- neering and for processes to be used during the development, maintenance, and sup- port of software. By establishing a common body of knowledge and experience, soft- ware engineering standards establish a basis on which further guidelines may be devel- oped. Appendix B of this Guide presents IEEE, ISOIEC, and ISOIECIEEE soft- ware engineering standards that support this Guides KAs.

--- Chunk 614 ---
Tokens: 362
Type: sentence-based
Text:
Appendix B of this Guide presents IEEE, ISOIEC, and ISOIECIEEE soft- ware engineering standards that support this Guides KAs. Standards are valuable sources of infor- mation about requirements and other SOFTWARE ENGINEERING PROFESSIONAL PRACTICE 14-5 guidance that can support software engi- neers in everyday activities. Adherence to standards promotes discipline by enumer- ating minimal characteristics of products and practices. That discipline helps mitigate sub- conscious assumptions or overconfidence in a design. For these reasons, organizations per- forming software engineering activities often include conformance to standards as part of their organizational policies. 1.5. Economic Impact of Software 3, c1s1, c10s8 4, c1s1 13 The software has economic effects at the individual, business, and societal levels. For example, software success may be deter- mined by a products suitability for a recog- nized problem and by its effectiveness when applied to that problem. At the individual level, an engineers continuing employment may depend on their ability and willingness to interpret and execute tasks in meeting cus- tomers or employers needs and expectations. The customers or the employers financial sit- uation may be positively or negatively affected by software purchases. At the business level, software properly applied to a problem can eliminate months of work and translate to elevated profits or more effective organizations.

--- Chunk 615 ---
Tokens: 355
Type: sentence-based
Text:
At the business level, software properly applied to a problem can eliminate months of work and translate to elevated profits or more effective organizations. Organizations that acquire or provide successful software may become a boon to the society in which they operate by providing both employment and improved services. However, the softwares development or acquisition costs can be con- siderable, like those of any major acquisition. At the societal level, direct impacts of soft- ware success or failure include the avoidance or experience of accidents, interruptions, and loss of service. Indirect impacts include the success or failure of the organization that acquired or produced the software, increased or decreased societal productivity, harmo- nious or disruptive social order, and even the saving or loss of property or life. In addition, as digitalization progresses, easier and faster access to the information needed may bring higher social value. 1.6. Employment Contracts 1, c6, c7 10 11 12 Software engineering services may be pro- vided under a variety of client-engineer rela- tionships. For example, the work may be done through a company-to-customer supplier arrangement, an engineer-to-customer con- sultancy arrangement, a direct-hire, or even through volunteering. In these situations, the customer and supplier agree that a product or service will be provided in return for some con- sideration.

--- Chunk 616 ---
Tokens: 328
Type: sentence-based
Text:
In these situations, the customer and supplier agree that a product or service will be provided in return for some con- sideration. Here, we are most concerned with engineer-to-customer arrangements and their attendant agreements or contracts, whether they are of the direct-hire or consultant variety, and the issues they typically address. A common concern in software engineering contracts is confidentiality. Employers derive commercial advantage from intellectual prop- erty (IP), so they strive to protect that prop- erty from disclosure. Therefore, software engineers are often required to sign nondis- closure agreements (NDA) or IP agreements as a precondition to working. These agree- ments typically apply to information the software engineer could gain only through association with the customer. The terms of these agreements may extend past the associ- ations termination. Another concern is IP ownership. Rights to software engineering assets  products, innovations, inventions, discoveries, and ideas  may reside with the employer or customer, under explicit contract terms or relevant laws, if those assets are obtained during the software engineers relationship with that employer or customer. Contracts differ in the ownership of assets created using non-employer-owned equipment or information.

--- Chunk 617 ---
Tokens: 387
Type: sentence-based
Text:
Contracts differ in the ownership of assets created using non-employer-owned equipment or information. Finally, contracts can also specify, among other elements:  The location at which work is performed  Standards to which that work will be held  The system configuration used for development  Limitations of the software engineers and employers liability 14-6 SWEBOK  GUIDE V4.0  A communication matrix andor esca- lation plan  Administrative details such as rates, fre- quency of compensation, working hours, and working conditions 1.7. Legal Issues 1, c6, c11 2 3, c5s3c5s4 4, c12s3, c13s2 Legal issues surrounding software engi- neering professional practice include mat- ters related to standards, trademarks, patents, copyrights, trade secrets, professional lia- bility, legal requirements, trade compliance, cybercrime, and data privacy. It is there- fore beneficial to know these issues and their applicability. In addition, legal issues are jurisdictionally based, so software engi- neers must consult attorneys who specialize in the type and jurisdiction of any identified legal issues. 1.7.1. Standards Adherence to standards provides a defense from legal action or allegations of malpractice. 1.7.2. Trademarks A trademark relates to any word, name, symbol, or device used in business transactions. It is used to indicate the source or origin of the goods. Trademark protection protects names, logos, images, and packaging. However, if a name, image, or other trademarked asset becomes a generic term, trademark protection is nullified.

--- Chunk 618 ---
Tokens: 383
Type: sentence-based
Text:
However, if a name, image, or other trademarked asset becomes a generic term, trademark protection is nullified. The World Intellectual Property Organization (WIPO) is the authority that frames the rules and regulations on trademarks. WIPO is the United Nations agency dedicated to protecting the use of IP as a means of stimulating innovation and creativity. 1.7.3. Patents Patents protect an inventors right to manu- facture and sell an idea. A patent consists of exclusive rights granted by a sovereign gov- ernment to an individual, group of individ- uals, or organization for a limited period. Patents are an old form of idea-ownership protection and date to the 15th century. Application for a patent entail keeping and producing careful records of the process that led to the invention. In addition, patent attor- neys help write patent disclosure claims in a manner most likely to protect the software engineers rights. Note that if inventions are made during a software engineering contract, ownership may belong to the employer or cus- tomer or be jointly held rather than belong to the software engineer. Rules vary concerning what is and what is not patentable. In many countries, soft- ware code is not patentable, but software algorithms may be. Existing and filed patent applications can be found at WIPO. 1.7.4. Copyrights Most governments give exclusive rights of an original work to its creator, usually for a lim- ited time, enacted as copyright. Copyrights protect the way an idea is presented  not the idea itself.

--- Chunk 619 ---
Tokens: 354
Type: sentence-based
Text:
Copyrights protect the way an idea is presented  not the idea itself. For example, they may pro- tect the particular wording of an account of a historical event, whereas the event itself is not protected. Copyrights are long-term and renewable. As a form of IP, they date to the 17th century. 1.7.5. Trade Secrets In many countries, an intellectual asset such as a formula, algorithm, process, design, method, pattern, instrument, or compilation of informa- tion may be considered a trade secret, provided the asset is not generally known and may pro- vide a business with some economic advan- tage. The trade secret designation provides legal protection if the asset is stolen. This pro- tection is not subject to a time limit. However, if another party derives or discovers the same asset legally, then the asset is no longer pro- tected and the other party will also possess all rights to use it. SOFTWARE ENGINEERING PROFESSIONAL PRACTICE 14-7 1.7.6. Professional Liability It is common for software engineers to be concerned with professional liability mat- ters. As engineers provide services to a client or employer, it is crucial that they adhere to standards and generally accepted practices to protect themselves against allegations of or proceedings related to malpractice, negli- gence, or incompetence. For engineers (including software engi- neers), professional liability is related to product liability.

--- Chunk 620 ---
Tokens: 360
Type: sentence-based
Text:
For engineers (including software engi- neers), professional liability is related to product liability. Under the laws and rules of their juris- diction, engineers may be held accountable for failing to fully and conscientiously follow rec- ommended practice; this is known as negligence. They may also be subject to laws governing strict liability and implied or express warranty, where, by selling the product, the engineer is held to warrant that the product is both suit- able and safe for use. In some countries (e.g, in the US), privity (a doctrine under which one can sue only the person selling the product) is no longer a defense against liability actions. Legal suits for liability can be brought under tort law in the US, allowing anyone who is harmed to recover their loss even if no guaran- tees were made. Because it is difficult to mea- sure the suitability or safety of software, failure to take due care can be used to prove negligence on the part of software engineers. Engineers can defend themselves against such an allega- tion by showing that they followed standards and generally accepted practices in developing the product to be ready to consult with attor- neys regarding the standard of care in any rel- evant jurisdiction to manage risks associated with product liability or professional liability. 1.7.7. Legal Requirements Software engineers must operate within local, national and international legal frameworks.

--- Chunk 621 ---
Tokens: 397
Type: sentence-based
Text:
Legal Requirements Software engineers must operate within local, national and international legal frameworks. Therefore, software engineers must know the legal requirements for the following:  Registration and licensing, including examination, education, experience, and training requirements  Contractual agreements  Noncontractual legalities, such as those governing liability Basic information on the international legal framework can be accessed from the World Trade Organization (WTO). 1.7.8. Trade Compliance All software professionals must be aware of legal restrictions on the import, export, or re-export of goods, services, and technology in the jurisdictions in which they work. Such rules often concern export controls and classi- fication; transfer of goods; acquisition of nec- essary governmental licenses for foreign use of hardware and software; services and tech- nology by sanctioned nations, enterprises, or individual entities; and import restrictions and duties. Trade experts should be consulted for detailed compliance guidance. 1.7.9. Cybercrime Cybercrime refers to any crime that involves a computer, computer software, computer net- works, or embedded software controlling a system. The computer or software may have been used in the commission of a crime or have been the target of the crime. This cat- egory of crime includes fraud, unauthorized access, spam, obscene or offensive content, threats, harassment, theft of sensitive per- sonal data or trade secrets, and use of one computer to damage or infiltrate other com- puters and automated system controls.

--- Chunk 622 ---
Tokens: 373
Type: sentence-based
Text:
This cat- egory of crime includes fraud, unauthorized access, spam, obscene or offensive content, threats, harassment, theft of sensitive per- sonal data or trade secrets, and use of one computer to damage or infiltrate other com- puters and automated system controls. Computer and software users commit fraud by altering electronic data to facilitate illegal activity. Forms of unauthorized access include hacking, eavesdropping, and using computer systems in a way that is concealed from their owners. Many countries have laws that specifically cover cybercrimes, but many do not have effective statutes, making cyber- crime difficult to prosecute in some cases. The software engineer has a professional obligation to consider the threat of cyber- crime and to consider how the software 14-8 SWEBOK  GUIDE V4.0 systems security will protect the software and user information from accidental or malicious access, use, modification, destruc- tion, or disclosure. Dark patterns are deceptive UIUX inter- actions designed to mislead or trick users into making them do something they may not want to do. These patterns do not have the users interests in mind and aim for exploit- ability rather than usability. Creating dark patterns is not good ethical practice. Software engineers should be responsible for their actions and be transparent with users instead of manipulating them. 1.7.10. Data Privacy Software engineers should know that data privacy is a key legal requirement in many countries.

--- Chunk 623 ---
Tokens: 281
Type: sentence-based
Text:
Data Privacy Software engineers should know that data privacy is a key legal requirement in many countries. The General Data Protection Regulation (GDPR), adopted on 14 April 2016, and enforceable since 25 May 2018, regulates data protection and privacy in the European Union (EU) and the European Economic Area (EEA). It also addresses the transfer of personal data outside the EU and EEA areas. The GDPRs primary aim is to enhance individuals control and rights over their data and to simplify the regulatory envi- ronment for international business. The regulation became a model for many national laws outside the EU, including the UK, Chile, Japan, Brazil, South Korea, Argentina, and Kenya. The California Consumer Privacy Act (CCPA), adopted on 28 June 2018, has many similarities with the GDPR. 1.8. Documentation 1, c10s5.8 3, c1s5 4 5, c32 Providing clear, thorough, and accurate documentation is the responsibility of each software engineer. The adequacy of documen- tation is judged according to different criteria, based on stakeholder needs. Good documen- tation complies with accepted standards and guidelines.

--- Chunk 624 ---
Tokens: 373
Type: sentence-based
Text:
Good documen- tation complies with accepted standards and guidelines. In particular, software engineers should document the following:  Relevant facts  Significant risks and trade-offs  Warnings of undesirable or dangerous consequences from the use or misuse of the software  Relevant information pertaining to attri- bute, license type, and sourcing Software engineers should avoid:  Certifying or approving unacceptable products  Disclosing confidential information  Falsifying facts or data In addition, software engineers and their managers should provide the following doc- umentation for other elements of the software development organization to use:  Software requirements specifications, soft- ware design documents, details on the soft- ware engineering tools used, software test specifications and results, and details about the adopted software engineering methods  Problems encountered during the devel- opment process For external stakeholders (customers, users, others), software documentation should pro- vide the following:  Information needed to determine whether the software is likely to meet customer and user needs  Description of safe and unsafe use of the software  Explanation of how to protect sensitive information created by or stored using the software  Clear identification of warnings and crit- ical procedures Software use may include installation, oper- ation, administration, and performance of other functions by various groups of users and support personnel.

--- Chunk 625 ---
Tokens: 439
Type: sentence-based
Text:
In particular, software engineers should document the following:  Relevant facts  Significant risks and trade-offs  Warnings of undesirable or dangerous consequences from the use or misuse of the software  Relevant information pertaining to attri- bute, license type, and sourcing Software engineers should avoid:  Certifying or approving unacceptable products  Disclosing confidential information  Falsifying facts or data In addition, software engineers and their managers should provide the following doc- umentation for other elements of the software development organization to use:  Software requirements specifications, soft- ware design documents, details on the soft- ware engineering tools used, software test specifications and results, and details about the adopted software engineering methods  Problems encountered during the devel- opment process For external stakeholders (customers, users, others), software documentation should pro- vide the following:  Information needed to determine whether the software is likely to meet customer and user needs  Description of safe and unsafe use of the software  Explanation of how to protect sensitive information created by or stored using the software  Clear identification of warnings and crit- ical procedures Software use may include installation, oper- ation, administration, and performance of other functions by various groups of users and support personnel. If the customer will acquire ownership of the software source code or the right to modify the code, the software engineer SOFTWARE ENGINEERING PROFESSIONAL PRACTICE 14-9 should provide documentation of the func- tional specifications, the software design, the test suite, and the necessary operating environ- ment for the software.

--- Chunk 626 ---
Tokens: 394
Type: sentence-based
Text:
If the customer will acquire ownership of the software source code or the right to modify the code, the software engineer SOFTWARE ENGINEERING PROFESSIONAL PRACTICE 14-9 should provide documentation of the func- tional specifications, the software design, the test suite, and the necessary operating environ- ment for the software. Documents should be kept for at least as long as the software prod- ucts life cycle or the time required by relevant organizational or regulatory requirements. 1.9. Trade-Off Analysis 3, c1s2, c10 4, c7s2, c13s4 13, c9s5.10 A software engineer often has to choose between alternative problem solutions. The outcome of these choices is determined by the software engineers professional evaluation of each alternatives risks, costs, and benefits in cooperation with stakeholders. The software engineers evaluation is called trade-off analysis. Trade-off analysis notably identifies competing and complementary software requirements to prioritize the final requirements defining the software to be constructed. (See Requirements Negotiation in the Software Requirements KA and Determination and Negotiation of Requirements in the Software Engineering Management KA.) When an ongoing software development project is late or over budget, a trade-off anal- ysis is often conducted to decide which soft- ware requirements can be relaxed or dropped given the effects thereof. The first step in a trade-off analysis is establishing design goals (see Engineering Design in the Engineering Foundations KA) and setting the relative importance of those goals.

--- Chunk 627 ---
Tokens: 360
Type: sentence-based
Text:
The first step in a trade-off analysis is establishing design goals (see Engineering Design in the Engineering Foundations KA) and setting the relative importance of those goals. This permits the identification of the solution that most nearly meets those goals; this means that the way the goals are stated is critically important. Design goals may include minimizing monetary cost and maximizing reliability, performance, or other criteria on various dimensions. However, it is difficult to formu- late a trade-off analysis of cost against risk, especially where primary production and secondary risk-based costs must be weighed against each other. A software engineer must ethically con- duct a trade-off analysis  notably by being objective and impartial when selecting cri- teria for comparing alternative problem solu- tions and assigning weights or importance to these criteria. In addition, any conflict of interest must be disclosed upfront. 2. Group Dynamics and Psychology Engineering work is often conducted in teams. A software engineer should interact cooperatively and constructively with others to first determine and then meet needs and expectations. Knowledge of group dynamics and psychology is an asset when interacting with customers, coworkers, suppliers, and subordinates to solve software engineering problems. 2.1. Dynamics of Working in TeamsGroups 3, c1s6 14, c1s3.5, c10 Software engineers must work with others.

--- Chunk 628 ---
Tokens: 390
Type: sentence-based
Text:
Dynamics of Working in TeamsGroups 3, c1s6 14, c1s3.5, c10 Software engineers must work with others. On the one hand, they work internally in engi- neering teams; on the other hand, they work with customers, members of the public, reg- ulators, and other stakeholders. Performing teams  those who demonstrate a consistent quality of work and progress toward goals  are cohesive and possess a cooperative, honest and focused atmosphere. Individual and team goals are aligned so the members natu- rally commit to and feel ownership of shared outcomes. Team members facilitate this atmosphere by being intellectually honest, using group thinking, admitting ignorance, and acknowl- edging mistakes. They share responsibility, rewards, and workload fairly. They commu- nicate clearly and directly to one another and in documents and source code so information is accessible to everyone. Peer reviews about work products are framed in a constructive and nonpersonal way. (See Reviews and Audits in the Software Quality KA.) This allows all the members to pursue a continuous improve- ment and growth cycle without personal risk. Members of cohesive teams demonstrate respect for one another and their leader. One point to emphasize is that software 14-10 SWEBOK  GUIDE V4.0 engineers must be able to work in multidisci- plinary environments and varied application domains. Because software is everywhere, from phones to cars, it affects peoples lives far beyond the more traditional concept of software made for information management in a business environment. 2.2.

--- Chunk 629 ---
Tokens: 386
Type: sentence-based
Text:
2.2. Individual Cognition 3, c1s6.5 5, c33 Engineers want to solve problems. Every engineer strives to solve problems effectively and efficiently. However, the limits and pro- cesses of individual cognition affect prob- lem-solving. Individual cognition plays a prominent role in problem-solving in soft- ware engineering, in part because of the highly abstract nature of software itself. An individuals (in particular, a software engineers) ability to decompose a problem and creatively develop a solution can be inhib- ited by the following:  The need for more knowledge  Subconscious assumptions  The volume of data  Fear of failure or the consequence of failure  Culture, either of the application domain or the organization  Lack of ability to express the problem  Perceived working atmosphere  The individuals emotional status The effects of these inhibiting factors can be reduced by cultivating good prob- lem-solving habits that minimize the impact of misleading assumptions. The ability to focus is crucial, as is intellectual humility. Both allow a software engineer to suspend personal considerations and consult with others freely, which is especially important when working in teams. Engineers use basic methods to facili- tate problem-solving. (See Problem-Solving Techniques in the Computing Foundations KA.) Breaking down problems and solving them one piece at a time reduces cognitive overload. By taking advantage of professional curiosity and pursuing continuous professional development, engineers gain skills and knowl- edge.

--- Chunk 630 ---
Tokens: 400
Type: sentence-based
Text:
By taking advantage of professional curiosity and pursuing continuous professional development, engineers gain skills and knowl- edge. Reading, networking, and experimenting with new tools, techniques and methods are all valid means of professional development. 2.3. Dealing with Problem Complexity 3, c3s2 4, c1s1, c20s1-s5 5, c33 Many, if not most, software engineering prob- lems are too complex and difficult to address as a whole or to be tackled by individual soft- ware engineers. When such circumstances arise, engineers typically use teamwork and problem decomposition. (See Problem- Solving Techniques in the Computing Foundations KA.) Teams work together to deal with large, complex problems by sharing burdens and drawing on one anothers knowledge and cre- ativity. When software engineers work in teams, individual engineers different views and abilities complement one another and help build a solution otherwise difficult to come by. Some teamwork examples in soft- ware engineering are pair programming (see Agile Methods in the Software Engineering Models and Methods KA) and code review (see Reviews and Audits in the Software Quality KA). 2.4. Interacting with Stakeholders 4 The success of a software engineering endeavor depends on positive interactions with stake- holders. Stakeholders should provide support, information, and feedback at all stages of the software life cycle. For example, during the early stages, it is critical to identify all stake- holders and discover how the product will affect them to properly capture a sufficient definition of stakeholder requirements.

--- Chunk 631 ---
Tokens: 399
Type: sentence-based
Text:
For example, during the early stages, it is critical to identify all stake- holders and discover how the product will affect them to properly capture a sufficient definition of stakeholder requirements. In Agile software development, the involve- ment of stakeholders is even more essential than in other types of development. First, during development, stakeholders may pro- vide feedback on specifications or early ver- sions of the software, changes of priority, and clarification of detailed or new software SOFTWARE ENGINEERING PROFESSIONAL PRACTICE 14-11 requirements. Last, during software mainte- nance and until the end of product life, stake- holders can provide feedback on evolving or new requirements and problem reports so the software can be extended and improved. Clearly, regular stakeholder involvement will lead to a better application. It is vital to main- tain open and productive communication with stakeholders during the software prod- ucts life cycle. 2.5. Dealing with Uncertainty and Ambiguity 4, c4s1, c4s4, c11s5, c24s5 14, c9s4 As with engineers in other fields, software engineers must often deal with and resolve uncertainty and ambiguities while providing services and developing products. The soft- ware engineer must reduce or eliminate any lack of clarity that is an obstacle to per- forming work. Often, uncertainty reflects a lack of knowl- edge. If that is the case, investigating the issue by reading formal sources such as text- books and professional journals, interviewing stakeholders, or consulting with teammates and peers can likely solve the problem.

--- Chunk 632 ---
Tokens: 357
Type: sentence-based
Text:
If that is the case, investigating the issue by reading formal sources such as text- books and professional journals, interviewing stakeholders, or consulting with teammates and peers can likely solve the problem. When uncertainty or ambiguity cannot be overcome easily, software engineers or organi- zations may regard it as a project risk. When this is the case, work estimates or pricing are adjusted to mitigate the anticipated cost of addressing it. (See Risk Management in the Software Engineering Management KA.) 2.6. Dealing with Equity, Diversity, and Inclusivity 4 14, c10s7 The equity, diversity, and inclusivity environ- ment can affect a groups dynamics. This is especially true when the group is geograph- ically separated or communication is infre- quent because such separation elevates the importance of each contact. Intercultural communication is even more difficult if the difference in time zones makes oral commu- nication less frequent. Multicultural environments are preva- lent in software engineering, perhaps more than in other engineering fields, because of the strong trend of international outsourcing and the easy shipment of software compo- nents instantaneously around the globe. For example, it is common for a software project to be divided into pieces across national and cultural borders. It is also common for a soft- ware project team to consist of people from diverse cultural backgrounds.

--- Chunk 633 ---
Tokens: 371
Type: sentence-based
Text:
It is also common for a soft- ware project team to consist of people from diverse cultural backgrounds. For a software project to succeed, team members must embrace tolerance of dif- ferent cultural and social norms, acknowl- edging that not all societies have the same social expectations. The support of leader- ship and management can facilitate tolerance and understanding. More frequent commu- nication, including face-to-face meetings, can help mitigate geographical and cultural divisions, promote cohesiveness, and raise productivity. Also, communicating with teammates in their native language could be beneficial. In the software industry, gender bias is still prevalent. Implementing broader recruiting strategies, specific and measur- able performance evaluation criteria, and transparent procedures for assigning com- pensation can reduce gender inequality in the software industry. These trends can con- tribute to building a diverse environment for all software engineers, regardless of their gender. 3. Communication Skills A software engineer must communicate well, both orally and in reading and writing. To meet software requirements and deadlines, engineers must establish clear communica- tion with customers, supervisors, coworkers, and suppliers. Optimal problem-solving is made possible through the ability to inves- tigate, comprehend and summarize infor- mation. Customer product acceptance and safe product use depend on relevant training and documentation.

--- Chunk 634 ---
Tokens: 350
Type: sentence-based
Text:
Customer product acceptance and safe product use depend on relevant training and documentation. The software engineers career success is affected by consistently pro- viding oral and written communication effec- tively and on time. 14-12 SWEBOK  GUIDE V4.0 3.1. Reading, Understanding, and Summarizing 4, c4s5 5, c33s3 Software engineers must be able to read and understand technical material. Technical mate- rial includes reference books, manuals, research papers, online sources and program source code. Reading is not only a primary way of improving skills but also a way of gathering information for completing engineering goals. A software engineer sifts through accumu- lated information, focusing on the pieces that will be most helpful. Customers may request that a software engineer summarize the results of such information-gathering for them, sim- plifying or explaining it so that they can make the final choice among competing solutions. Reading and comprehending source code are also components of information-gathering and problem-solving. For example, when engineers modify, extend or rewrite software, they must understand both its implementa- tion, directly derived from the presented code, and its design, which must often be inferred. 3.2. Writing 3, c1s5 4, c4s2-s3 Software engineers can produce written products requested by customers or required by generally accepted practice.

--- Chunk 635 ---
Tokens: 399
Type: sentence-based
Text:
Writing 3, c1s5 4, c4s2-s3 Software engineers can produce written products requested by customers or required by generally accepted practice. These written products may include source code, software project plans, software requirement docu- ments, risk analyses, software design doc- uments, software test plans, user manuals, technical reports and evaluations, justifica- tions, diagrams and charts, and so forth. Clear, concise writing is important because writing is often the primary method of com- munication among relevant parties. In all cases, written software engineering products must be accessible, understandable, and rele- vant to their intended audience. 3.3. Team and Group Communication 3, c1s6.8 4, c22s3 5, c27s1 14, c10s4 Effective communication among team and group members is essential to a collaborative software engineering effort. Stakeholders must be consulted; decisions must be made, and plans must be generated. The greater the number of team and group members, the greater the need to communicate. However, the number of communication paths grows quadratically with the addition of each team member. Furthermore, team members are unlikely to communicate with anyone perceived to be removed from them by more than two degrees (levels). This problem can be more serious when software engi- neering endeavors or organizations are spread across national and continental borders. Some communication can be accom- plished in writing. Software documentation is a common substitute for direct interaction. Email is another, but although it is useful, it is not always enough.

--- Chunk 636 ---
Tokens: 381
Type: sentence-based
Text:
Email is another, but although it is useful, it is not always enough. Also, if one receives too many messages, it becomes difficult to identify the important information. Increasingly, orga- nizations are using enterprise collaboration tools to share information. In addition, elec- tronic information stores, accessible to all team members for organizational policies, stan- dards, common engineering procedures, and project-specific information, can be beneficial. Some software engineering teams focus on face-to-face interaction and promote such interaction through office space arrange- ments. Although private offices improve indi- vidual productivity, other arrangements, such as co-locating team members in physical or virtual spaces and providing communal work areas, can boost collaborative efforts. 3.4. Presentation Skills 3, c1s5 4, c22 14, c10s7c10s8 Software engineers rely on their presenta- tion skills during software life cycle pro- cesses. For example, software engineers may walk customers and teammates through software requirements during the phase and conduct formal requirements reviews. (See Requirement Reviews in the Software Requirements KA.) During and after soft- ware design, software construction, and soft- ware maintenance, software engineers lead SOFTWARE ENGINEERING PROFESSIONAL PRACTICE 14-13 reviews, product walkthroughs (see Review and Audits in the Software Quality KA), and training. These require the ability to present technical information to groups and solicit ideas or feedback.

--- Chunk 637 ---
Tokens: 392
Type: sentence-based
Text:
These require the ability to present technical information to groups and solicit ideas or feedback. Therefore, the software engineers ability to convey concepts effectively in a presentation influences product acceptance, management, and customer support. It also influences the ability of stakeholders to comprehend and assist in the product effort. This knowledge needs to be archived in slides, knowledge write-ups, technical white papers, and other material used for knowledge creation. MATRIX OF TOPICS VS. REFERENCE MATERIAL 1. Professionalism Bott et al. 2000 1 Voland, 2003 3 Sommerville, 2016 4 McConnel, 2004 5 Tockey, 2004 13 Fairley, 2009 14 1.1. Accreditation, Certification and Qualification, and Licensing c1s5, c1s10 c12s10 1.2. Codes of Ethics and Professional Conduct c1s7-s9, c10s2, App c1s2 1.3. Nature and Role of Professional Societies c2s3 c1s2 c35s1 1.4. Nature and Role of Software Engineering Standards c10s2,  c32s6 1.5. Economic Impact of Software c1s1, c10s8 c1s1  1.6. Employment Contracts c6, c7  1.7. Legal Issues c6, c11 c5s3- s4, c12s3, c13s2 1.8. Documentation c10s5 c1s5  c32 1.9. Trade-Off Analysis c1s2, c10 c7s2, c13s4 c9s5-10 2. Group Dynamics and Psychology 2.1. Dynamics of Working in TeamsGroups c1s6 c1s3-5, c10 2.2. Individual Cognition c1s6 c33 2.3. Dealing with Problem Complexity c3s2 c1s1, c20s1-s5 2.4. Interacting with Stakeholders  2.5. Dealing with Uncertainty and Ambiguity c4s1,c4s4, c11s5c24s5 c9s4 14-14 SWEBOK  GUIDE V4.0 2.6. Dealing with Equity, Diversity, and Inclusivity  c10s7 3. Communication Skills 3.1.

--- Chunk 638 ---
Tokens: 382
Type: sentence-based
Text:
Communication Skills 3.1. Reading, Understanding, and Summarizing c4s5 c33s3 3.2. Writing c1s5 c4s2-s3 3.3. Team and Group Communication c1s6 c22s3 c27s1 c10s4 3.4. Presentation Skills c1s5 c22 c10s7-s8 FURTHER READINGS G.M. Weinberg, The Psychology of Computer Programming 15. This was the first major book to address pro- gramming as an individual and team effort; it has become a classic in the field. Kinney and Lange, P.A, Intellectual Property Law for Business Lawyers 16. This book covers IP laws in the US. It not only talks about what the IP law is; it also explains why it looks the way it does. REFERENCES 1 F. Bott et al, Professional Issues in Software Engineering, 3rd ed, Taylor  Francis, 2000. 2 Appendix B of this Guide. 3 G. Voland, Engineering by Design, 2nd ed, Prentice-Hall, 2003. 4 I. Sommerville, Software Engineering, 10th ed, Addison-Wesley, 2016. 5 S. McConnell, Code Complete, 2nd ed, Microsoft Press, 2004. 6 25 Years Washington Accord, IEC, 2014. 7 EUR-ACE, 2017. 8 ISOIEC 24773-1, Software and Systems Engineering  Certification of Software and System Engineering Professionals  Part 1: General Requirements. 9 ISOIEC 24773-4 Software and Systems Engineering  Certification of Software and Systems Engineering Professionals  Part 4: Software engineering. 10 ACM Code of Ethics and Professional Conduct, 2018. 11 IEEE Code of Ethics, 2020. 12 IFIP Code of Ethics and Professional Conduct, 2021. 13 S. Tockey, Return on Software: Maximizing the Return on Your Software Investment, Addison-Wesley, 2004.

--- Chunk 639 ---
Tokens: 398
Type: sentence-based
Text:
13 S. Tockey, Return on Software: Maximizing the Return on Your Software Investment, Addison-Wesley, 2004. 14 R. E. Fairley, Managing and Leading Software Projects, Wiley-IEEE Computer Society Press, 2009. 15 G. M. Weinberg, The Psychology of Computer Programming: Silver Anniversary Edition, Dorset House, 1998. 16 Kinney and Lange, P.A, Intellectual Property Law for Business Lawyers, Thomson West, 2013. 15-1 CHAPTER 15 Software Engineering Economics ACRONYMS IRR Internal Rate of Return MARR Minimum Acceptable Rate of Return SDLC Software Development Life Cycle SPLC Software Product Life Cycle ROI Return on Investment SEI Software Engineering Institute TCO Total Cost of Ownership INTRODUCTION Software is ubiquitous and has become essen- tial for many organizations. It serves organiza- tions in the following ways:  as a lever to reach an organizations busi- ness or strategic goals;  as a catalyst of organizational know-how to improve value. Both aspects lead directly to critical soft- ware engineering demands:  increased productivity;  reduced rework  reduced development time  shorter maintenance turnaround  long-term sustainability;  innovation;  competitiveness;  alignment with organizational goals. Software engineering economics helps soft- ware engineers work in ways that satisfy these critical demands. The Introduction to SWEBOK Guide explains that engineering economics is a key element of all recognized engineering dis- ciplines. Economics is the science of choice, not the science of money. Engineering eco- nomics is the applied microeconomics branch of economics.

--- Chunk 640 ---
Tokens: 373
Type: sentence-based
Text:
Engineering eco- nomics is the applied microeconomics branch of economics. It asks the fundamental ques- tion, Is it in the best interest of this enterprise to invest its limited resources in this technical endeavor, or would the same investment pro- duce a higher return elsewhere? Paraphrasing the definition in 1, engineering is finding the balance between what is technically feasible and what is economically acceptable. Software engineering must be value-based. Neutral  or worse, negative  value from an organizations investment in software is not sustainable. Software engineering economics aligns software technical decisions with the organizations business goals. The organization will at least include the organization where the software engineer is employed. However, when the software engi- neer is involved in work for any third party, such as through an external digital transfor- mation contract or other works for hire situ- ation, the business goals of that third party are also relevant. In all types of organizations  for-profit, nonprofit and government  a value-based approach translates into long-term sustainability. In for-profit organizations this means achieving a tangible return on the software investment. In nonprofit organizations, this means achieving the maximum benefit for the least cost. Software technical decisions, like an orga- nizations decision to use a preexisting library or to develop its own, may appear easy from a purely technical perspective.

--- Chunk 641 ---
Tokens: 384
Type: sentence-based
Text:
Software technical decisions, like an orga- nizations decision to use a preexisting library or to develop its own, may appear easy from a purely technical perspective. However, they can have serious implications for the business via- bility of a software project as well as the product itself. Most software practitioners wonder 15-2 SWEBOK  GUIDE V4.0 whether such concerns apply to them. But eco- nomic decision-making is fundamental to engi- neering. Someone who cannot make decisions from both a technical and an economic per- spective cannot be considered a true engineer. Software engineering economics applies to decisions across the entire software product life cycle (SPLC), from the pre-project deci- sion to develop the software to end-of-life decisions for existing software. It also applies to decisions at all levels of technical detail. For example, all following questions involve an economic perspective:  can a client organization benefit from a digital transformation? does a project proposal (a tender) align with a clients business goals? should certain software functionality be bought or built? should certain requirements be included in scope or not? what is the most efficient, cost-effective architecture and design? what is an optimal load-balancing strategy for a cloud-based deployment that provides adequate response time to clients without incurring unnecessary operational cost? how much risk-based testing is enough? is it better to refactor, redevelop or just live with code that has high technical debt?

--- Chunk 642 ---
Tokens: 263
Type: sentence-based
Text:
is it better to refactor, redevelop or just live with code that has high technical debt? is it better to focus maintenance on adding new functionality or on fixing known defects? would the value of early delivery of par- tial functionality gained by using an Agile process outweigh the overhead of rework and continuous testing inherent in iterative approaches? The Software Engineering Economics knowledge area (KA) is directly or indirectly related to all other KAs in this Guide. This KA also takes the position that the more traditional, purely financial view of engineering economics needs to be broadened 2. Value does not always derive from money alone; value can also derive from unquanti- fiables like corporate citizenship, employee well-being, environmental friendliness, cus- tomer loyalty and so on. Therefore, software engineering decisions must also consider rel- evant unquantifiable criteria. BREAKDOWN OF TOPICS FOR SOFTWARE ENGINEERING ECONOMICS The breakdown of topics for the Software Engineering Economics KA is shown in Figure 15.1.

--- Chunk 643 ---
Tokens: 449
Type: sentence-based
Text:
BREAKDOWN OF TOPICS FOR SOFTWARE ENGINEERING ECONOMICS The breakdown of topics for the Software Engineering Economics KA is shown in Figure 15.1. Software Engineering Economics Proposals Cash Flow Time-Value of Money Equivalence Bases for Comparison Alternatives Intangible Assets Business Model Process Overview Understand the Real Problem Identify all Reasonable Technically- Feasible Solutions Dene the Selection Criteria Evaluate each Alternative against the Selection Criteria Select the Preferred Alternative Monitor the Performance of the Selected Alternative Minimum Acceptable Rate of Return Economic Life Planning Horizon Replacement Decisions Retirement Decisions Advanced For-Prot Decision Considerations Benet-Cost Analysis Cost- Eectiveness Analysis Break-Even Analysis Optimization Analysis Compensatory Techniques Non- Compensatory Techniques Identify Processes and Dene Business Goals Identify Intangible Assets linked with Business Goals Identify Software Products that Support Intangible Assets Dene and Measure Indicators Intangible Asset Characterization Link Specic Intangible Assets with the Business Model Decision Making Accounting Cost and Costing Finance Controlling Eciency and Eectiveness Productivity Product or Service Project Program Portfolio Product Lifecycle Project Lifecycle Price and Pricing Prioritization Software Engineering Economics Fundamentals Te Engineering Decision-Making Process For-Prot Decision-Making Nonprot Decision-Making Present Economy Decision-Making Multiple- Attribute Decision-Making Identifying and Characterizing Intangible Assets Estimation Practical Considerations Related Concepts Expert Judgment Analogy Decomposition Parametric Multiple Estimates Business Case Multiple- Currency Analysis Systems Tinking Figure 15.1.

--- Chunk 644 ---
Tokens: 437
Type: sentence-based
Text:
Software Engineering Economics Proposals Cash Flow Time-Value of Money Equivalence Bases for Comparison Alternatives Intangible Assets Business Model Process Overview Understand the Real Problem Identify all Reasonable Technically- Feasible Solutions Dene the Selection Criteria Evaluate each Alternative against the Selection Criteria Select the Preferred Alternative Monitor the Performance of the Selected Alternative Minimum Acceptable Rate of Return Economic Life Planning Horizon Replacement Decisions Retirement Decisions Advanced For-Prot Decision Considerations Benet-Cost Analysis Cost- Eectiveness Analysis Break-Even Analysis Optimization Analysis Compensatory Techniques Non- Compensatory Techniques Identify Processes and Dene Business Goals Identify Intangible Assets linked with Business Goals Identify Software Products that Support Intangible Assets Dene and Measure Indicators Intangible Asset Characterization Link Specic Intangible Assets with the Business Model Decision Making Accounting Cost and Costing Finance Controlling Eciency and Eectiveness Productivity Product or Service Project Program Portfolio Product Lifecycle Project Lifecycle Price and Pricing Prioritization Software Engineering Economics Fundamentals Te Engineering Decision-Making Process For-Prot Decision-Making Nonprot Decision-Making Present Economy Decision-Making Multiple- Attribute Decision-Making Identifying and Characterizing Intangible Assets Estimation Practical Considerations Related Concepts Expert Judgment Analogy Decomposition Parametric Multiple Estimates Business Case Multiple- Currency Analysis Systems Tinking Figure 15.1. Breakdown of Topics for the Software Engineering Economics KA SOFTWARE ENGINEERING ECONOMICS 15-3 1.

--- Chunk 645 ---
Tokens: 393
Type: sentence-based
Text:
Breakdown of Topics for the Software Engineering Economics KA SOFTWARE ENGINEERING ECONOMICS 15-3 1. Software Engineering Economics Fundamentals 1.1. Proposals 3, c3pp23-24 Software engineering decisions begin with the concept of a proposal  a single, separate course of action to be considered (e.g, carrying out a particular software development project or not). Another proposal could be to enhance an existing software component; another might be to redevelop that same software from scratch. In deciding what algorithm to use in implementing a certain function, each candidate considered is a proposal. Every pro- posal represents a binary unit of choice  the software engineer either carries out that pro- posal or chooses not to. Software engineering economics aims to identify the proposals best aligned with the organizations goals. 1.2. Cash Flow 3, c3pp24-32 Engineers must evaluate a proposal from a financial perspective to make a meaningful decision about it. The concepts of cash flow instance and cash flow stream describe the financial perspective of proposals. A cash flow instance is a specific amount of money flowing into or out of the organization at a specific time as a direct result of carrying out a proposal. For example, in a proposal to develop and launch product X, the payment for new computers, if needed, would be an example of an outgoing cash flow instance. Money would need to be spent to carry out that proposal. The sales income from product X in the 11th month after market launch would be an example of an incoming cash flow instance.

--- Chunk 646 ---
Tokens: 378
Type: sentence-based
Text:
The sales income from product X in the 11th month after market launch would be an example of an incoming cash flow instance. Money would come in because of carrying out the proposal. A cash flow stream is the set of cash flow instances over time caused by carrying out that proposal. The cash flow stream is that proposals complete financial view. How much money goes out? When does it go out? How much money comes in? When does it come in? If the cash flow stream for Proposal A is more desirable than the cash flow stream for Proposal B, then  all other things being equal  the organization is financially better off carrying out Proposal A than Proposal B. Thus, the cash flow stream is an important element of engineering decision-making. A cash flow diagram is a picture of a cash flow stream. The cash flow diagram quickly sum- marizes the financial view of a proposal. Figure 15.2 shows an example cash flow diagram. The cash flow stream is shown in two dimen- sions. Time runs from left to right and amounts of money run up and down. The horizontal axis is divided into units representing years, months, weeks, etc, as appropriate for the pro- posal. Each net cash flow instance is drawn at a left-to-right position relative to its timing. The amount of the cash flow instance is shown as an upward or downward arrow. Upward arrows indicate that money is coming in (income), whereas downward arrows indicate that money is spent (expense). The arrows length is usually proportional to the net amount. 1.3.

--- Chunk 647 ---
Tokens: 389
Type: sentence-based
Text:
1.3. Time-Value of Money 3, c5-6 One of the most fundamental concepts in economics  and therefore, in business deci- sions  is that money has time-value: Its value changes over time. A specific amount of money right now almost always has a value 0 1 2 3 4 2900 5 6 7 -10,000 -850 8150 650 5900 3650 1400 Figure 15.2. A Cash Flow Diagram 15-4 SWEBOK  GUIDE V4.0 different from the same amount at some other time. This concept has been around since the earliest recorded human history and is com- monly expressed as interest. 1.4. Equivalence 3, c7 Due to the time-value of money, two or more cash flows are equivalent only when they equal the same amount of money at the same time. Therefore, comparing cash flows makes sense only when they are expressed in the same time frame. Then, lack of equivalence between the two cash flows can be determined accurately and can serve as the basis for choice. The pro- posal with the highest value in the same time frame is the most financially desirable. 1.5. Bases for Comparison 3, c8 A basis for comparison is a shared frame of ref- erence for comparing two or more cash flow streams. It uses equivalence to meaningfully compare two or more proposals. Several bases for comparison exist, including the following:  present worth;  future worth;  annual equivalent;  internal rate of return (IRR);  discounted payback period. 1.6. Alternatives 3, c9 Often, an organization could carry out more than one proposal if it wanted to. But there might be important relationships between proposals that need to be considered.

--- Chunk 648 ---
Tokens: 384
Type: sentence-based
Text:
But there might be important relationships between proposals that need to be considered. Maybe Proposal Y can only be carried out if Proposal X is also carried out. Or maybe Proposal P cannot be carried out if Proposal Q is car- ried out, nor could Q be carried out if P were. Decisions are easier when there are mutually exclusive paths  A, or B, or C, or another project, and no others. This topic explains how to turn any set of proposals, with their inter- relationships, into a set of mutually exclu- sive alternatives. The cash flow stream for any alternative is the sum of the cash flow streams for all the proposals it contains. The choice can then be made among these alternatives. One special case is known as the do-nothing alternative. Sometimes the best course of action is not to carry out any of the proposals being considered. The do-nothing alterna- tive represents that case. It doesnt mean do nothing at all; it means do something else, something thats not in this set of choices. The do-nothing alternative should be consid- ered in most, but not all, situations. 1.7. Intangible Assets Intangible assets, also known as knowl- edge assets, are any knowledge that lies in the non-visible side of an organization but affects that organizations financial perfor- mance. According to International Valuation Standards (IVS) 210  20.1, an intangible asset is a non-monetary asset that manifests itself by its economic properties. It does not have physical substance but grants rights and economic benefits to its owner 4.

--- Chunk 649 ---
Tokens: 382
Type: sentence-based
Text:
It does not have physical substance but grants rights and economic benefits to its owner 4. This can include, but is not limited to, pol- icies, procedures, tools and specifications, as well as organizational culture, experience and know-how. Knowing the organizations intangible assets helps the software engineer better understand how proposals may affect or be affected by orga- nizational realities. Otherwise, hidden risks and opportunities that could influence pro- posals success or failure might not be exposed. The skills needed to consider intangible assets are the following:  intangible assets identification and valuation Skills Framework for the Information Age (SFIA), category Strategy and Architecture, subcategory Business strategy and planning;  knowledge management SFIA, category Strategy and Architecture, subcategory Business strategy and planning. Identifying and characterizing intan- gible assets are discussed in more detail later in this KA. SOFTWARE ENGINEERING ECONOMICS 15-5 1.8. Business Model Peter Drucker, a founder of modern manage- ment, defines a good business model as one that answers these questions 5:  Who is the customer? What does the customer value? How do we make money? What is the underlying economic logic that explains how we can deliver value to customers at an appropriate cost? Understanding the organizations business model  as well as its intangible assets  helps the software engineer better understand how proposals may affect or be affected by orga- nizational realities.

--- Chunk 650 ---
Tokens: 392
Type: sentence-based
Text:
Understanding the organizations business model  as well as its intangible assets  helps the software engineer better understand how proposals may affect or be affected by orga- nizational realities. Analyzing the business model can help the software engineer iden- tify hidden risks and opportunities that could influence a proposals success or failure 6. 2. The Engineering Decision-Making Process 2.1. Process Overview 3, c4pp35-36 Figure 15.3 provides an overview of the engi- neering decision-making process. The process is shown as stepwise and sequen- tial; however, it can be more fluid in practice. Steps can be done iteratively, can overlap and can even occur in different sequences. Just be sure not to skip any step or execute it poorly. When the consequences of a wrong deci- sion are significant, such as a gono-go deci- sion for a large project, more time, effort and care should be spent in this process. All steps should be completed thoroughly and carefully. ISO 12207 7 and ISO 15288 8 recommend two additional early activities, which can be important in high-consequence decisions:  define the decision management strategy  this strategy might specify roles, responsibilities, procedures and tools;  identify relevant stakeholders, which might include appropriate subject matter experts. When the consequences of a wrong deci- sion are small, such as the consequences of selecting a minor algorithm or data structure, less time, effort and care can be spent, but the same general process is followed. Each step is discussed in more detail below. 2.2.

--- Chunk 651 ---
Tokens: 379
Type: sentence-based
Text:
2.2. Understand the Real Problem 3, c4pp37-39 The best solution to a problem can come only from thoroughly understanding the real problem to be solved. This steps key aspects include the use of an interrogative technique such as the 5 Whys technique and a con- sideration of the broader context surrounding the problem. The Empathize stage in Design Thinking 9 (to consider intangible assets) and looking closely at the organizations Identify all reasonable technically feasible solutions Evaluate each alternative against the selection criteria Defne the selection criteria Understand the real problem Select the preferred alternative Monitor the performance of the selected alternative Figure 15.3. The Engineering Decision-Making Process 15-6 SWEBOK  GUIDE V4.0 business model are examples of considering that broader context. 2.3. Identify All Reasonable Technically Feasible Solutions 3, c4pp40-41 The goal of engineering decision-making is to find the best solution. However, the best solution must first be identified as a candidate before it can be selected as the best. If the best solution is not among the set of solutions being considered, it cannot be selected. The importance of creative thinking in this step cannot be overstated when the consequences of a wrong decision are high. For some potential solutions, or candidates, prototyping is a useful way to verify technical feasibility. Peer review can also help verify technical feasibility and possibly spur the identification of even more candidates.

--- Chunk 652 ---
Tokens: 379
Type: sentence-based
Text:
Peer review can also help verify technical feasibility and possibly spur the identification of even more candidates. On the one hand, adding candidates increases the probability that the best one is in the set. On the other hand, each adds cost to the decision-making process. Software engi- neers must use their best judgment in deciding when they have enough candidates. These candidates are the proposals as defined in the Fundamentals topic, Section 1. 2.4. Define the Selection Criteria 3, c4pp39-40, c26pp441-442 Engineering decisions almost always consider the financial perspective. However, other decision criteria can also be relevant; when this is the case, the decision is a multiple-at- tribute decision. For example, an environmen- tally conscious organization may choose a less economical solution if it is more eco-friendly. In many cases, the greater the consequences of a wrong decision, the more selection cri- teria need to be considered. As much as possible, each criterion should be expressed objectively. Ideally, those objec- tive terms will be expressed as a monetary value  but not necessarily. What is the value of a clean river? It might not make sense to value a river by multiplying the price per kilogram of fish by an estimate of the number of fish in the river. Decision criteria that cant be expressed objectively are called unquantifiables, irre- ducibles or intangibles. Defining the decision criteria can be a sub- jective task. Too many criteria could make the analysis unwieldy.

--- Chunk 653 ---
Tokens: 396
Type: sentence-based
Text:
Too many criteria could make the analysis unwieldy. On the other hand, too few criteria might not differentiate well between proposals and could thus lead to a suboptimal choice. The potential for a better decision provided by including more criteria must be balanced against the extra effort required to analyze the criteria. To the extent that money is a selection crite- rion, the context of the decision will constrain the decision-maker to a for-profit, nonprofit or present economy decision analysis, as explained in topics 3, 4 and 5, later in this KA. 2.5. Evaluate Each Alternative Against the Selection Criteria 3, c4pp41-42 Each alternative is evaluated against each selection criterion. When a selection crite- rion involves money, each alternative must be judged from the same viewpoint. Use the same basis for comparison (present worth, future worth, IRR, etc, in for-profit deci- sions; benefit-cost ratio or cost-effectiveness in nonprofit decisions, etc. ), the same planning horizon, and consider the same kinds of costs and incomes. An example decision might be buying and adapting an off-the-shelf software product versus building a custom application from scratch. Considering costs for a longer time frame for one proposal than for the other will make the one using the shorter time frame seem like the better choice even though it might not be better over the same time frame. 2.6. Select the Preferred Alternative 3, c4p42, c26pp447-458 If the only selection criterion is money, the alternative with the highest present worth, future worth, etc, will be chosen.

--- Chunk 654 ---
Tokens: 391
Type: sentence-based
Text:
Select the Preferred Alternative 3, c4p42, c26pp447-458 If the only selection criterion is money, the alternative with the highest present worth, future worth, etc, will be chosen. When there are multiple criteria, a variety of tech- niques can be used to evaluate the criteria together. Multiple-attribute decision-making is detailed later in this KA. SOFTWARE ENGINEERING ECONOMICS 15-7 Engineering decisions are based on esti- mates (discussed later in this KA). The accu- racy of an estimate is limited in theory and in practice, and the degree of inaccuracy depends on the specifics of the situation 3, c21pp344- 356. If the degree of inaccuracy is high enough, that inaccuracy could change the resulting decision. The following techniques 3, c23 can help engineers address these situations:  consider ranges of estimates;  perform a sensitivity analysis;  delay final decisions. In addition, two categories of techniques address multiple potential outcomes from a decision:  decision-making-under-risk techniques 3, c24 are used when probabilities can be assigned to the different potential outcomes. Specific techniques include expected value decision-making, expec- tation variance and decision-making, Monte Carlo analysis, decision trees, and the expected value of perfect information;  decision-making-under-uncertainty tech- niques 3, c25 are used when probabil- ities cannot be assigned to the different potential outcomes. Specific techniques include the Laplace Rule, the Maximin Rule, the Maximax Rule, the Hurwicz Rule and the Minimax Regret Rule.

--- Chunk 655 ---
Tokens: 395
Type: sentence-based
Text:
Specific techniques include the Laplace Rule, the Maximin Rule, the Maximax Rule, the Hurwicz Rule and the Minimax Regret Rule. High-consequence decisions may benefit from formally recording the selected alterna- tive and the justification for why that alterna- tive was selected. 2.7. Monitor the Performance of the Selected Alternative 3, c4pp42-43 Because estimation is a fundamental element of engineering decision-making, the quality of the decision depends on the quality of the esti- mates. Bad estimates can easily lead to bad deci- sions. The software engineer needs to close the loop on estimates by comparing them to the actual outcomes. Otherwise, no one will ever know if the estimates were good 3, c21pp356- 358. This also helps improve estimation over time. Understanding what drives differences between estimates and actual outcomes helps engineers refine estimation techniques to pro- duce more accurate estimates in the future. 3. For-Profit Decision-Making For-profit decision techniques apply when the organizations goal is profit  which is the case in most companies. Figure 15.4 shows the process for identi- fying the financially best alternative out of a set of proposals. Arranging alternatives in order of increasing initial investment and then selecting strictly better candidates means that, all other considerations being equal, the alternative with the smaller initial investment will be chosen. The Is the next candidate strictly better? decision is made in terms of the appropriate basis for com- parison: present worth, future worth, IRR, etc. 3.1.

--- Chunk 656 ---
Tokens: 370
Type: sentence-based
Text:
3.1. Minimum Acceptable Rate of Return 3, c10pp141-143 The minimum acceptable rate of return (MARR) is the lowest IRR the organization would consider a good investment. Generally, it would not be wise to invest in an activity with a return of 10 when another activity returns 20. The MARR is a statement that the organization is confident it can achieve at least that rate of return. The MARR rep- resents the organizations opportunity cost for investments. By investing in some alter- native, the organization explicitly decides not to invest that same money somewhere else. If the organization is already confident it can achieve a known rate of return, alternatives should be chosen only if their rate of return is at least that high. A simple way to account for that opportunity cost is to use the MARR as the interest rate in the basis for comparison. 3.2. Economic Life 3, c11pp160-164 When an organization invests in a partic- ular alternative, money is tied up in that 15-8 SWEBOK  GUIDE V4.0 alternative  so-called frozen assets. The eco- nomic impact of frozen assets typically starts high and decreases over time. On the other hand, operating and maintenance costs tend to start low and increase over time. An alter- natives total cost is the sum of those two costs. At first, frozen asset costs dominate; later, operating and maintenance costs dom- inate. At some point, the sum of the two costs is minimized; this is the economic life or min- imum cost lifetime. 3.3.

--- Chunk 657 ---
Tokens: 395
Type: sentence-based
Text:
3.3. Planning Horizon 3, c11 To properly compare a proposal with a four- year life to a proposal with a six-year life, the economic effects of either cutting the six-year proposal by two years or investing the profits from the four-year proposal for another two years need to be addressed. The planning horizon, sometimes known as the study period, is the consistent time frame over which all proposals in the same decision are considered. Aspects such as economic life and the time frame over which reasonable estimates can be made need to be factored into establishing a planning horizon. Once the planning horizon is established, several techniques are available for putting proposals with different life spans into that planning horizon. 3.4. Replacement Decisions 3, c12pp171-178 8, c9 A replacement decision happens when an organization already has a particular asset and is considering replacing it with a different asset (e.g, deciding between maintaining and sup- porting legacy software or redeveloping it from the ground up). Replacement decisions use the same for-profit decision process, but there are two additional important considerations: sunk cost and salvage value. Replacement does not necessarily need to involve an entire asset. To the extent that an asset can be replaced in smaller increments, the decision-maker can consider incremental replacement options among the various economic alternatives. Start Stop Is the next candidate strictly better than the current best? Compare the next candidate to the current best Are there more alternatives to compare?

--- Chunk 658 ---
Tokens: 391
Type: sentence-based
Text:
Compare the next candidate to the current best Are there more alternatives to compare? Arrange the alternatives in order of increasing initial investment Assume the frst alternative is the current best Make that next candidate the new current best Te current best is the best overall Yes Yes No No Figure 15.4. The For-Profit Decision-Making Process SOFTWARE ENGINEERING ECONOMICS 15-9 3.5. Retirement Decisions 3, c12pp178-181 8, c9 Retirement decisions are about getting out of an activity altogether, such as when a soft- ware company considers not selling a software product anymore or a hardware manufacturer considers not building and selling a partic- ular computer model any longer. Retirement decisions can be preplanned or happen spon- taneously (e.g, when performance targets are not achieved). Retirement decisions can be influenced by lock-in factors such as tech- nology dependency and high exit costs. 3.6. Advanced For-Profit Decision Considerations 3, c13-17 The above concepts and techniques are often sufficient to make a good for-profit decision. However, particularly when the consequences of a wrong decision are high, additional con- siderations may need to be factored into the decision analysis, including the following:  inflation or deflation;  depreciation;  income taxes. 4. Nonprofit Decision-Making The for-profit decision techniques dont apply when the organizations goal isnt profit  which is the case in government and non- profit organizations. These organizations have a different goal, so different decision techniques are needed.

--- Chunk 659 ---
Tokens: 400
Type: sentence-based
Text:
These organizations have a different goal, so different decision techniques are needed. The two techniques are benefit-cost analysis and cost-effective- ness analysis (discussed below). 4.1. Benefit-Cost Analysis 3, c18pp303-311 Benefit-cost analysis is one of the most widely used methods for evaluating pro- posals in nonprofit organizations. A propos- als financial benefits are divided by its costs. Any proposal with a benefit-cost ratio of less than 1.0 can usually be rejected without further analysis because it would cost more than it would benefit the organization. Additional considerations are necessary when two or more proposals are considered at the same time. 4.2. Cost-Effectiveness Analysis 3, c18pp311-314 Cost-effectiveness analysis shares much of the philosophy and methodology of bene- fit-cost analysis. There are two versions of cost-effectiveness analysis. The fixed-cost version seeks to maximize benefit given a fixed upper bound on cost. The fixed-effec- tiveness version seeks to minimize the cost to achieve a fixed goal. 5. Present Economy Decision-Making This subset of engineering decision-making is called present economy because it does not involve the time-value of money (future economy). The two forms of present economy decisions are presented below. 5.1. Break-Even Analysis 3, c19 Given functions describing the costs of two or more proposals, break-even analysis helps engineers choose between them by identi- fying points where those cost functions are equal. Below a break-even point, one pro- posal is preferred, and above that point, the other is preferred.

--- Chunk 660 ---
Tokens: 394
Type: sentence-based
Text:
Below a break-even point, one pro- posal is preferred, and above that point, the other is preferred. For example, consider a choice between two cloud service providers. One provider has a lower fixed cost per month with a higher incremental fee for use, whereas the other has a higher fixed monthly cost with a lower incremental fee for use. Break-even analysis identifies the use level where the costs are the same. The organi- zations expected use level can be compared to the break-even point to identify the low- er-cost provider. 5.2. Optimization Analysis 3, c20 Optimization analysis studies one or more cost functions over a range of values to find the 15-10 SWEBOK  GUIDE V4.0 point where overall cost is lowest. Softwares classic space-time trade-off is an example of optimization; an algorithm that runs faster often uses more memory. Optimization bal- ances the value of faster run time against the cost of the additional memory. 6. Multiple-Attribute Decision-Making 3, c26 Most topics presented in this KA so far have discussed decisions based on a single cri- terion  money. The alternative with the best present worth, the best incremental IRR, the best incremental benefit-cost ratio, etc, is the one selected. Aside from tech- nical feasibility, money is usually the most important decision criterion, but its cer- tainly not always the only one. Often, other criteria, other attributes, need to be con- sidered that cant be cast in terms of money. Multiple-attribute decision-making tech- niques allow nonmonetary criteria to be fac- tored into the decision.

--- Chunk 661 ---
Tokens: 376
Type: sentence-based
Text:
Multiple-attribute decision-making tech- niques allow nonmonetary criteria to be fac- tored into the decision. A variety of techniques can be used to address multiple criteria, including nonmon- etary criteria. These techniques fall into two categories. 6.1. Compensatory Techniques 3, c26pp449-458 Also called single-dimensioned techniques, the techniques in this category collapse all criteria into a single figure of merit. This category is called compensatory because, for any given alternative, a lower score in one criterion can be compensated by  traded off against  a higher score in other criteria. Compensatory techniques include nondimensional scaling, additive weighting and analytic hierarchy process (AHP). Gilbs Impact Estimation 11 and the Software Engineering Institutes (SEI) Architectural Tradeoff Analysis Method (ATAM) 12 are examples of compensa- tory multiple-attribute decision-making techniques focused on identifying the best software design. 6.2. Non-Compensatory Techniques 3, c26pp447-449 Also called fully dimensioned techniques, the techniques in this category do not allow trade- offs among the criteria. Each criterion is treated as a separate entity in the selection pro- cess. Non-compensatory techniques include dominance, satisficing and lexicography. 7. Identifying and Characterizing Intangible Assets The intangible side of an organization is the valuable knowledge residing within it. This includes employees knowledge about pro- cesses, structures, procedures, etc.

--- Chunk 662 ---
Tokens: 394
Type: sentence-based
Text:
This includes employees knowledge about pro- cesses, structures, procedures, etc. (tacit, or implicit, knowledge), as well as institutional knowledge recorded in various organizational resources (explicit knowledge). These assets are usually hidden, the way most of an iceberg is underwater. The intangible assets must be explicitly considered in many decisions, par- ticularly when the consequences of a wrong decision are high for the client, no matter if the client is internal or external to the orga- nization for which the software project is being done. If these assets are not adequately consid- ered, software engineers risk developing a software solution that does not fit the client organization. Only when the intangible assets are explicitly considered will the risk of a poorly fitting software solution be min- imized. The Strategic Intangible Process Assets Characterization (SIPAC) method 13 has been used to good effect to accom- plish this. SIPAC steps are outlined in the following subsections. 7.1. Identify Processes and Define Business Goals Start by understanding the organizations business processes and business goals. If the organization has well-documented processes, these should be used; otherwise, a deliberate survey will be necessary. Business goals can include, but are not lim- ited to, the following: SOFTWARE ENGINEERING ECONOMICS 15-11 1. maintaining growth and continuity of the organization; 2. meeting financial objectives; 3. meeting responsibility to employees; 4. meeting responsibility to society; 5. managing market position. 7.2.

--- Chunk 663 ---
Tokens: 378
Type: sentence-based
Text:
7.2. Identify Intangible Assets Linked with Business Goals The next step is to comprehensively iden- tify the intangible assets. Common examples are policies, documented business processes, checklists, lessons learned, templates, stan- dards, procedures, plans and training mate- rials. Organizations develop or acquire these assets to meet their business goals. The assets represent investments that provide business value. One effective approach to identifying an organizations intangible assets is to start with a taxonomy such as described in the fol- lowing reference 14. The goal is to identify as many intangible assets as possible that serve as a lever to achieve the business goals iden- tified in the previous step. In practice, this can be an iterative process where reviewing the already-identified assets reveals the exis- tence of others. A practical way to do it is by focusing iteratively on the 11 generic intan- gible assets (GIAs) described in 6. Possible GIAs represent all potential parts of any business that can be involved in a dig- ital transformation. Focusing on one or more of them allows the software engineer to better understand and frame the projects impact. Focusing iteratively on the 11 GIAs, the soft- ware engineer will select the type of GIA to be considered and, with this, elicit the specific intangible assets associated with each GIA. In addition to identifying specific intan- gible assets, a qualitative relative importance must be added to each one as it is identified.

--- Chunk 664 ---
Tokens: 370
Type: sentence-based
Text:
In addition to identifying specific intan- gible assets, a qualitative relative importance must be added to each one as it is identified. The importance is a value between 1 and 5 (1 for lower importance and 5 for higher impor- tance), depending on how well the asset sup- ports achieving the business objectives. The intangible assets with the highest importance are likely the most suitable target for the client organization. 7.3. Identify Software Products That Support Intangible Assets Software products that support specific intan- gible assets will be part of the digital transfor- mation proposal to be presented to the client to help them decide what digital transforma- tion to implement. To identify products related to specific intangible assets, the software engineer can choose from the following:  discovering them all at a single time by using the methodology of Osterwalder 13, which promotes innovation by gen- erating a value map with the stakeholders emerging needs, mapping the products to the specific intangible assets;  listing them if they are known and then mapping them to specific intangible assets;  iteratively working with the individual intangible assets by (1) selecting a spe- cific intangible asset and (2) identifying the products, continuing until all specific intangible assets have been analyzed. A single product can support more than one specific intangible asset, and each specific intan- gible asset can be supported by many products. 7.4.

--- Chunk 665 ---
Tokens: 367
Type: sentence-based
Text:
7.4. Define and Measure Indicators This step defines and measures the indica- tors that will be used to characterize how the intangible assets (through the software prod- ucts that support those intangible assets) help meet business goals through describing, imple- menting or improving the identified products. Quality indicators assess specific intangible asset characteristics or features. Impact indi- cators assess how much the specific intangible assets contribute to processes or business goals. Indicators must be normalized and stan- dardized to operate correctly. 7.5. Intangible Asset Characterization Based on the information gathered, the soft- ware engineer determines the value of the 15-12 SWEBOK  GUIDE V4.0 identified specific intangible assets based on their quality and impact. Specific intangible assets may be characterized in terms of their impact on business goals and their quality as organizational assets. There are three important characteriza- tion cases:  case 1: specific intangible assets with both impact and quality indicators (Warning, Replaceable, Evolving or Stable);  case 2: specific intangible assets with only quality indicators (Acceptable Quality or Unacceptable Quality);  case 3: specific intangible assets with only impact indicators (Acceptable Impact or Unacceptable Impact). The three characterization cases are shown in Figure 15.5. The quadrants represent the states constituting different levels of char- acterization.

--- Chunk 666 ---
Tokens: 368
Type: sentence-based
Text:
The quadrants represent the states constituting different levels of char- acterization. The lines separating the quad- rants are thresholds of impact and quality that define the point at which the impact or quality of a specific intangible asset may be considered acceptable or not for each organization. These thresholds are established for every client organization and specify what level of orga- nizational performance, quality, and impact they will demand from their knowledge intangible assets. Thresholds are used to deter- mine when quality andor impact are accept- able or unacceptable. Lets look at an example of how to interpret Qval and Ival (both Qval and Ival will be explained in the following sections). Assuming, for example, that we are analyzing the status of an intangible asset with both quality and impact indicators, and that Qval is below the quality threshold and Ival is below the impact threshold. In these cir- cumstances we would say that the status of the intangible asset is warning as can be seen in Figure 15.5. The characterization uses information from standardized-normalized indicators to assess the identified intangible assets. This assess- ment generates a descriptive value that will determine the assets general state of health from a quantitative perspective. Quality quantitative assessment The quality valuation considers only the indicators of the type quality of an intan- gible asset and calculates a general valua- tion of it.

--- Chunk 667 ---
Tokens: 322
Type: sentence-based
Text:
Quality quantitative assessment The quality valuation considers only the indicators of the type quality of an intan- gible asset and calculates a general valua- tion of it. To evaluate the subset of quality indicators, given a set of q quality indica- tors for an intangible asset n, the valua- tion of the quality is given according to Equation 1. Q  q i1 X n n i q  Val Equation 1. Quality Assessment for a Knowledge Asset Where X n i is each of the q normalized indica- tors of quality that the intangible asset n has. Above, Qval is the average of the normal- ized values of the quality indicators of a cor- responding specific intangible asset. Impact quantitative assessment An intangible assets impact valuation is an assessment that considers only the normal- ized indicators that are classified as impact indicators. To evaluate the subset of impact indicators, given a set of p normalized impact indicators for an intangible asset n, the valua- tion is given as stated in Equation 2: I n Val   p i  1Z n i p Equation 2. Impact Assessment for a Specific Intangible Asset Where Zn i is each of the p normalized indica- tors of impact that the knowledge asset n has. Where Ival is the average of the normal- ized values of the impact indicators of a corre- sponding knowledge asset.

--- Chunk 668 ---
Tokens: 376
Type: sentence-based
Text:
Where Ival is the average of the normal- ized values of the impact indicators of a corre- sponding knowledge asset. Linear value calculation Finally, the linear value of an intangible asset characterization is given by the impact and SOFTWARE ENGINEERING ECONOMICS 15-13 quality valuations (Qval and Ival), following these rules, assuming that both quality and impact are equally important, so KAval (the valuation of the intangible asset) is given by: If Qval Ival, then KAval  Qval  Ival If Qval Ival, then KAval  Qval 2 Ival, then If Qval KAval  Ival This linear value represents an intangible assets general state based on the state of its indicators. It uses the algebraic mean of the standardized and normalized indicators to represent the assets general state on a scale -1, 1 and based on the corresponding inter- pretation thresholds. If no threshold is explic- itly mentioned, the linear value is interpreted as follows, if the value is 0, then the intan- gible asset is on the target, if the value is 1, it means that the intangible asset is 100 over the target and if the value is -1 then the intan- gible asset is -100 under the target. 7.6. Link Specific Intangible Assets with the Business Model Visualizing the client business model, enriched with the intangible assets status allocated into that model, gives organiza- tional leadership a clear understanding of the important relationships among proposed soft- ware solutions, intangible assets, the business model and the business goals.

--- Chunk 669 ---
Tokens: 372
Type: sentence-based
Text:
Link Specific Intangible Assets with the Business Model Visualizing the client business model, enriched with the intangible assets status allocated into that model, gives organiza- tional leadership a clear understanding of the important relationships among proposed soft- ware solutions, intangible assets, the business model and the business goals. The software engineer can clearly show which proposed solution generates the most value for the busi- ness. An example is shown in 6. 7.7. Decision-Making The next step in the decision-making process is to prioritize and choose the software prod- ucts that interest the client organization most. There is no simple rule; several criteria must be considered:  the intangible assets impact on business goals (defined in previous steps);  the characterization reached (defined in previous steps);  the impact of intangibles assets status on the competitors of the organization under improvement;  the intangible assets impact on the busi- ness model;  cost to implement the products;  time to implement the products;  complexity of the products. All criteria must be considered to decide what software products should be developed for the client organization, making this a multiple-attribute decision. (See 6, Multiple- Attribute Decision-Making.) Upon considering all relevant criteria, the organization can see the risks of imple- menting a software solution to automate pro- cesses that are either not very valuable or not in good shape.

--- Chunk 670 ---
Tokens: 400
Type: sentence-based
Text:
Upon considering all relevant criteria, the organization can see the risks of imple- menting a software solution to automate pro- cesses that are either not very valuable or not in good shape. Instead, the software engi- neer can offer, in a transparent way, proposals that better satisfy the organizations busi- ness needs. This approach can be useful whenever an engineering decision needs to be made, but it is particularly critical in the pre-project stage when there is a need to present the client organization with proposals that are best for business value. 8. Estimation 3, c21-26 An estimate analytically predicts some quan- tity, like a projects size, cost or schedule. Many other quantities are also estimated in software engineering, such as the average number of active client sessions a cloud ser- vice needs to support, the number of times a function will be called during execution of a section of code, or the number of delivered defects in a software product. Software engineers do not estimate purely for the sake of estimating. Software engi- neers estimate to make decisions when critical quantities are unknown. For example, a deci- sion to buy a functionality or build it within 15-14 SWEBOK  GUIDE V4.0 the organization would certainly be based on the cost of building it. But the actual cost of building it cannot be precisely known until the organization does build it. Key informa- tion needed to make engineering decisions is usually not known when those decisions need to be made. Instead, decisions are based on estimates. Behind every estimate is one or more decisions.

--- Chunk 671 ---
Tokens: 370
Type: sentence-based
Text:
Behind every estimate is one or more decisions. Given that estimates are predictions, there is a nonzero probability that the actual out- come will differ from the estimate. All esti- mates are inherently uncertain. Sometimes, the uncertainty is large, and sometimes it is small. But it is always there. Fortunately, esti- mates need not be perfect; they need only to be good enough to lead the decision-maker to make the right decision. The Software Engineering Code of Ethics and Professional Practice 16 states, 3.09. Ensure realistic quantitative estimates of cost, scheduling, personnel, quality and outcomes on any project on which they work or propose to work and provide an uncertainty assess- ment of these estimates (underlining added for emphasis). (See 3, c21pp358-361.) Estimation is covered extensively in 17, 18 and 3. Several general techniques exist, and each is overviewed here. All specific esti- mation techniques use one or a combination of these general techniques. 8.1. Expert Judgment 3, c22pp367-369 In expert judgment estimation, the estimate is based purely on the estimators professional opinion. It is the simplest technique and is always available, and it is particularly useful when the other techniques arent available. The downside is that this technique produces the least accurate estimates. Multiple expert judg- ment estimates can be fed into group estimation processes like Wide Band Delphi and Planning Poker to produce more accurate estimates.

--- Chunk 672 ---
Tokens: 393
Type: sentence-based
Text:
Multiple expert judg- ment estimates can be fed into group estimation processes like Wide Band Delphi and Planning Poker to produce more accurate estimates. Case 2: Only Quality Indicators Acceptable Quality Unacceptable Quality Warning Evolving Unacceptable Impact Acceptable Impact Case 3: Only Impact Indicators Replaceable Stable Quality Treshold Case 1: Quality and Impact Indicators Impact Treshold Figure 15.5. Extended Characterization of Specific Intangible Assets SOFTWARE ENGINEERING ECONOMICS 15-15 8.2. Analogy 3, c22pp369-371 Estimation by analogy assumes that if the thing estimated is similar to something already known, then the estimate for the new thing can be based on the actual result for the similar thing, with allowances for rel- evant differences. The steps in estimation by analogy are as follows: 1. Understand the thing to be estimated. 2. Find a suitable analogy for which actual results are known. 3. List differences between the thing being estimated and the analogy that could sig- nificantly affect the outcome. 4. Estimate the magnitude of each identi- fied difference. 5. Build the estimate from the analogys actual result and adjustments for the identified differences. Estimation by analogy produces more accurate results than expert judgment, and it is still relatively quick and easy. On the other hand, an appropriate analogy for which accu- rate results are known must be available for this approach to work. 8.3. Decomposition 3, c22pp371-374 Sometimes called bottom-up estimation, the steps in estimation by decomposition are: 1.

--- Chunk 673 ---
Tokens: 395
Type: sentence-based
Text:
Decomposition 3, c22pp371-374 Sometimes called bottom-up estimation, the steps in estimation by decomposition are: 1. Break the thing to be estimated into suc- cessively smaller pieces until the smallest pieces can be reasonably estimated. 2. Estimate those smallest pieces. 3. Add up the estimates for the smallest pieces to build the estimate for the whole. 4. If the estimates for the smallest pieces dont include allowances for significant cross-cut- ting factors, then find a way to address those factors. For example, when estimating a software project from its design, the esti- mates for the design elements may not include allowances for requirements work, integration work, testing work and user documentation work. Estimation by decomposition assumes that overestimates of lowest-level pieces will cancel out corresponding underestimates of other pieces and lead to a more accurate esti- mate of the whole. The primary disadvantages are the following:  it can be a lot more work than any other technique;  if the bottom-level estimates are biased either high or low, the canceling effect doesnt happen. 8.4. Parametric 3, c22pp374-377 Also called estimation by statistical methods, parametric estimation takes advantage of a known, mathematical relationship between the thing being estimated and one or more observable factors about that thing, like cal- culating the cost to build a building as a func- tion of its floor space. The estimation model is an equation: First, count the observable fac- tors, and then plug them into the equation to get the resulting estimate.

--- Chunk 674 ---
Tokens: 359
Type: sentence-based
Text:
The estimation model is an equation: First, count the observable fac- tors, and then plug them into the equation to get the resulting estimate. Parametric estimates are typically the most accurate, the most defendable and the easiest to use, provided the equation has been devel- oped and validated. The disadvantage is that developing and validating such an equation requires an adequate base of accurate histor- ical data along with some nontrivial mathe- matics and statistics. 8.5. Multiple Estimates 3, c22pp377-379 When the consequences of a wrong decision are small, it can be acceptable to base the deci- sion on a single estimate from a single estimator using a single estimation technique. However, when the consequences of a wrong decision are significant, investing extra effort in developing more than one estimate can be worthwhile. To use this approach, engineers estimate the same thing using different techniques, pos- sibly by different estimators. Then, they look for convergence or divergence among those multiple estimates. Convergence suggests 15-16 SWEBOK  GUIDE V4.0 the individual estimates are probably accu- rate, and any of them could be used to make the decision. Divergence suggests that one or more important factors might have been over- looked. Finding the factors that caused the divergence and reestimating to produce con- verging results often lead to a better estimate and thus a better decision. 9.

--- Chunk 675 ---
Tokens: 393
Type: sentence-based
Text:
9. Practical Considerations 9.1. Business Case The business case is the consolidated, doc- umented information summarizing and explaining a recommended business decision from different perspectives (cost, benefit, risk and so on) for a decision-maker and other rel- evant stakeholders. Its used to assess a prod- ucts potential value, which can be used as a basis for an investment decision. 9.2. Multiple-Currency Analysis When a decision analysis involves cross- border finances, currency exchange rate varia- tions may need to be considered. This is often done using historical data. 9.3. Systems Thinking The ecosystem in which software engineers develop their professional life is complex. To understand the whole picture around a client organization and form a holistic view of the scenarios they analyze, software engineers can use systems thinking methodologies. This approach helps the software engineer create a complete set of possible scenarios in which the software to be provided could be useful and, with this information, explain to the client how the software solution can be a value pro- vider for the organization. Sources for system thinking methodologies are Understanding Systems Systems Innovation 19 and Business Dynamics: Systems Thinking and Modeling for a Complex World 20. A way to connect systems thinking methodologies with the development of a business model to understand the pillars of the client organiza- tion can be reached here 21. 10. Related Concepts This topic includes concepts the software engineer may want to bear in mind. 10.1.

--- Chunk 676 ---
Tokens: 393
Type: sentence-based
Text:
10.1. Accounting 3, c15pp234-245 Accounting is part of finance. It allows people whose money is used to run an organization to know the results of their investment: Did they get the profit they were expecting? In for- profit organizations, this relates to the tangible return on investment (ROI), while in nonprofit and governmental organizations, as well as for- profit organizations, it translates into sustain- ably staying in business. Accountings primary role is to measure the organizations actual financial performance and to communicate financial information about a business entity to stakeholders, such as shareholders, finan- cial auditors and investors. Communication generally takes the form of financial state- ments showing the economic resources to be controlled. The right information  relevant and reliable to the user  must be presented. Information and its timing are partially gov- erned by risk management and governance policies. Accounting systems are also a rich source of historical data for estimating. Software engineers must be conscious of the softwares importance as a driver of busi- ness accounts in the digital era. 10.2. Cost and Costing 3, c15pp245-259 A cost is the money used to produce some- thing and, hence, is no longer available for use. In economics, a cost is an alternative that is given up as a result of a decision. Sunk cost refers to unrecoverable expenses that have occurred, which can cause emotional hurdles looking forward. From a traditional economics viewpoint, sunk costs should not be considered in decision-making.

--- Chunk 677 ---
Tokens: 394
Type: sentence-based
Text:
From a traditional economics viewpoint, sunk costs should not be considered in decision-making. Opportunity cost is the cost of an alternative that must be forgone to pursue another alternative. SOFTWARE ENGINEERING ECONOMICS 15-17 Costing is part of finance and product management. It is the process of determining the cost based on expenses (e.g, production, software engineering, distribution, rework) and on the target cost to be competitive and successful in a market. The target cost can be below the actual estimated cost. The plan- ning and controlling of these costs (called cost management) is important and should always be included in costing. An important concept in costing is the total cost of ownership (TCO). This holds true especially for software because there are many not-so-obvious costs related to SPLC activities after initial product development. TCO for a software product is defined as the total cost for acquiring that product, acti- vating it and keeping it running. These costs can be grouped as direct and indirect costs. TCO is an accounting method that is crucial in making sound economic decisions. 10.3. Finance Finance is the branch of economics concerned with allocating, managing, acquiring and investing resources. Finance is an element of every organization, including software engi- neering organizations. The field of finance deals with the concepts of time, money, and risk, and how they are interrelated. It also deals with how money is spent and budgeted. Corporate finance is con- cerned with funding an organizations activ- ities.

--- Chunk 678 ---
Tokens: 363
Type: sentence-based
Text:
Corporate finance is con- cerned with funding an organizations activ- ities. Generally, this involves balancing risk and profitability while attempting to maxi- mize an organizations wealth and the value of its stock. This applies primarily to for-profit organizations but also to nonprofit organiza- tions. The latter needs finances to ensure sus- tainability, if not to make a tangible profit. To do this, an organization must:  identify organizational goals, time hori- zons, risk factors, tax considerations and financial constraints;  identify and implement the appropriate business strategy, such as which port- folio and investment decisions to take, how to manage cash flow and where to get the funding;  measure financial performance, such as cash flow and ROI, and take corrective actions in case of deviation from objec- tives and strategy. Provided that many organizations use software development or acquisition to stay competitive, the software engineer must be conscious of the importance of software to business finances. 10.4. Controlling Controlling is the element of finance and accounting that involves measuring and correcting performance. It ensures that an organizations objectives and plans are accom- plished. Controlling cost is a specialized branch of controlling used to detect variances of actual costs from planned costs. In software engineering, this concept is referred to as processes and products con- trol and evolution.

--- Chunk 679 ---
Tokens: 392
Type: sentence-based
Text:
In software engineering, this concept is referred to as processes and products con- trol and evolution. While the organization is seen as an entity with its own goals, and control of the organizational goals is seen as separate, software engineers must consider control of the organization part of their job by ensuring alignment of their software with business goals. 10.5. Efficiency and Effectiveness 10, c22pp422-23 Economic efficiency of a process, activity or task is the ratio of resources consumed to resources expected to be consumed. Efficiency means doing things right. An efficient behavior, like an effective behavior, delivers results and minimizes effort. Factors affecting efficiency in software engineering include product com- plexity, quality requirements, time pressure, process capability, team distribution, inter- ruptions, feature churn, tools and program- ming language. Effectiveness is about having impact. It is the relationship between achieved objectives and defined objectives. Effectiveness means 15-18 SWEBOK  GUIDE V4.0 doing the right things. Effectiveness looks only at whether defined objectives are reached  not at how they are reached. 10.6. Productivity 10, c23pp689 Productivity is the ratio of output to input from an economic perspective. Output is the value delivered. Input covers all resources (e.g, effort) spent to generate the output. Productivity combines efficiency and effec- tiveness from a value-oriented perspective. Maximizing productivity is about generating the highest value with the lowest resource consumption.

--- Chunk 680 ---
Tokens: 372
Type: sentence-based
Text:
Maximizing productivity is about generating the highest value with the lowest resource consumption. The Guide to the Project Management Body of Knowledge 23 defines rework as action taken to bring a defective or noncon- forming component into compliance with requirements or specifications. It is worth noting that most software organizations are unaware that the single largest resource con- sumer is, in fact, rework. In many software projects the cost of rework is higher than the cost of all other project activities com- bined. The most effective way to increase productivity can be to simply reduce rework. Reducing software project rework involves proactive quality improvement actions (see Chapter 12, Software Quality KA) that either a) identify defects earlier so those defects can be fixed at lower resource cost, b) reduce the degree of defect cost growth (e.g, intention- ally simpler code is easier to modify than complex code so actively managing and con- trolling code complexity reduces the cost of defect repair), and c) prevent defects in the first place by, for example, using appropriate templates and checklists in development and maintenance. 10.7. Product or Service A product is a tangible economic good (or output) created in a process that transforms product factors (or inputs) into an output. A service is an intangible resource, like con- sulting. When sold, a product or service is a deliverable that creates both a value and an experience for its consumers.

--- Chunk 681 ---
Tokens: 383
Type: sentence-based
Text:
When sold, a product or service is a deliverable that creates both a value and an experience for its consumers. A product or service can be a combination of systems, solu- tions and materials delivered internally (e.g, an in-house IT solution) or externally (e.g, a software application), either as is or as a com- ponent for another product (e.g, embedded software). 10.8. Project 22, c2s2.4 A project is a temporary endeavor undertaken to create a unique product, service, or result 24. In software engineering, different project types are distinguished (e.g, product development, outsourced services, software maintenance, service creation, and so on). During its life cycle, a software product may require many projects. For example, during the product conception phase, a project might be conducted to determine customer need and market requirements; during maintenance, a project might be conducted to produce the next version of a product. 10.9. Program A program is a group of related projects, sub- programs, and program activities managed in a coordinated way to obtain benefits not available from managing them individually 24. Programs are often used to identify and manage different deliveries to a single cus- tomer or market over a time horizon of sev- eral years. 10.10. Portfolio Portfolios are projects, programs, sub-portfo- lios, and operations managed as a group to achieve strategic objectives 24. Portfolios are used to group and then manage simul- taneously all assets within a business line or organization.

--- Chunk 682 ---
Tokens: 383
Type: sentence-based
Text:
Portfolios are used to group and then manage simul- taneously all assets within a business line or organization. Having an entire portfolio to consider helps ensure that the broader impacts of decisions are considered, such as the decision to allocate resources to a specific project, which means that the same resources will not be available for the other projects in the portfolio. SOFTWARE ENGINEERING ECONOMICS 15-19 10.11. Product Life Cycle An SPLC includes all activities needed to define, build, operate, maintain and retire a software product or service and its variants. The SPLC activities of operate, main- tain and retire occur in a much longer time frame than initial software develop- ment (the software development life cycle (SDLC)). (See Software Life Cycle Models in the Software Engineering Process KA.) Also, the operate-maintain-retire activi- ties of an SPLC consume more total effort and other resources than the SDLC activi- ties. (See Majority of Maintenance Costs in the Software Maintenance KA.) The value contributed by a software product or associ- ated services can be objectively determined during the operate and maintain time frame. Software engineering economics should be concerned with all SPLC activ- ities, including activities that take place after the initial product release. 10.12. Project Life Cycle Project life cycle activities typically involve five process groups: Initiating, Planning, Executing, Monitoring and controlling, and Closing 23. (See the Software Engineering Management KA.)

--- Chunk 683 ---
Tokens: 376
Type: sentence-based
Text:
(See the Software Engineering Management KA.) The activ- ities within a software project life cycle are often interleaved, overlapped and iter- ated in various ways 20, c2 25. (See the Software Engineering Process KA.) For instance, Agile product development within an SPLC involves multiple itera- tions that produce increments of deliver- able software. An SPLC should include risk management and synchronization with different suppliers (if any) while pro- viding auditable decision-making informa- tion (e.g, to comply with product liability needs or governance regulations). The soft- ware project life cycle and the SPLC are interrelated; an SPLC may include sev- eral SDLCs. 10.13. Price and Pricing 10, c23s23.1 A price is what is paid in exchange for a good or service. Price is a fundamental aspect of finan- cial modeling and is one of the four Ps of the marketing mix. The other three Ps are product, promotion and place. Price is the only reve- nue-generating element among the four Ps; the rest are costs. Pricing is an element of finance and mar- keting. It determines what a company will receive in exchange for its products. Pricing factors include manufacturing cost, market placement, competition, market condition and product quality. Pricing applies prices to prod- ucts and services based on factors such as fixed amount, quantity break, promotion or sales campaign, specific vendor quote, shipment or invoice date, combination of multiple orders, service offerings, and many others.

--- Chunk 684 ---
Tokens: 400
Type: sentence-based
Text:
Pricing applies prices to prod- ucts and services based on factors such as fixed amount, quantity break, promotion or sales campaign, specific vendor quote, shipment or invoice date, combination of multiple orders, service offerings, and many others. The con- sumers needs can be converted into demand only if the consumer has the willingness and capacity to buy the product. Thus, pricing is crucial in marketing. Pricing is initially done during the project initiation phase and is a part of the go decision-making process. 10.14. Prioritization Prioritization involves ranking alternatives based on common criteria to deliver the best value. For example, in software engineering projects, software requirements are often pri- oritized to deliver the most value to the client within the constraints of schedule, budget, resources, and technology, or to allow the team to build the product in increments, where the first increments provide the highest value to the customer. (See Requirements Prioritization in the Software Requirements KA and Software Life Cycle Models in the Software Engineering Process KA.) Prioritizing alter- natives is at least implicit in the discussion in 2.6, Select the Preferred Alternative, but is explicit when a compensatory technique is used, as described in 7.6, Multiple-Attribute Decision-Making. 15-20 SWEBOK  GUIDE V4.0 MATRIX OF TOPICS VS. REFERENCE MATERIAL Tockey 2005 3 Sommerville 2016 10 Fairley 2009 22 1. Software Engineering Economics Fundamentals 1.1. Proposals c3pp23-24 1.2. Cash Flow c3pp24-32 1.3. Time-Value of Money c5-6 1.4. Equivalence c7 1.5.

--- Chunk 685 ---
Tokens: 397
Type: sentence-based
Text:
Equivalence c7 1.5. Bases for Comparison c8 1.6. Alternatives c9 1.7. Intangible Assets 1.8. Business Model 2. The Engineering Decision- Making Process 2.1. Process Overview c4pp35-36 2.2. Understand the Real Problem c4pp37-39 2.3. Identify All Reasonable Technically Feasible Solutions c4pp40-41 2.4. Define the Selection Criteria c4pp39-40, c26pp441-442 2.5. Evaluate Each Alternative Against the Selection Criteria c4pp41-42 2.6. Select the Preferred Alternative c4p42, c26pp447-458 2.7. Monitor the Performance of the Selected Alternative c4pp42-43 3. For-Profit Decision-Making 3.1. Minimum Acceptable Rate of Return c10pp141-143 3.2. Economic Life c11pp160-164 3.3. Planning Horizon c11 3.4. Replacement Decisions c12pp171-178 c9 3.5. Retirement Decisions c12pp178-181 c9 3.6. Advanced For-Profit Decision Considerations c13-17 4. Nonprofit Decision-Making 4.1. Benefit-Cost Analysis c18pp303-311 4.2. Cost-Effectiveness Analysis c18pp311-314 5. Present Economy Decision-Making SOFTWARE ENGINEERING ECONOMICS 15-21 5.1. Break-Even Analysis c19 5.2. Optimization Analysis c20 6. Multiple-Attribute Decision-Making 6.1. Compensatory Techniques c26pp449-458 6.2. Non-Compensatory Techniques c26pp447-449 7. Identifying and Characterizing Intangible Assets 7.1. Identify Processes and Define Business Goals 7.2. Identify Intangible Assets Linked with Business Goals 7.3. Identify Software Products That Support Intangible Assets 7.4. Define and Measure Indicators 7.5. Intangible Asset Characterization 7.6. Link Specific Intangible Assets with the Business Model 7.7. Decision-Making 8.

--- Chunk 686 ---
Tokens: 395
Type: sentence-based
Text:
Decision-Making 8. Estimation 8.1. Expert Judgment c22pp367-369 8.2. Analogy c22pp369-371 8.3. Decomposition c22pp371-374 8.4. Parametric c22pp374-377 8.5. Multiple Estimates c22pp377-379 9. Practical Considerations 9.1. Business Case 9.2. Multiple-Currency Analysis 9.3. Systems Thinking 10. Related Concepts 10.1. Accounting c15pp234-245 10.2. Cost and Costing c15pp245-259 10.3. Finance 10.4. Controlling 10.5. Efficiency and Effectiveness c22pp422-23 10.6. Productivity c23pp689 10.7. Product or Service 10.8. Project c2s2.4 15-22 SWEBOK  GUIDE V4.0 10.9. Program 10.10. Portfolio 10.11. Product Life Cycle 10.12. Project Life Cycle 10.13. Price and Pricing c23s23.1 10.14. Prioritization FURTHER READINGS Project Management Institute, A Guide to the Project Management Body of Knowledge (PMBOK Guide) 24. The PMBOK Guide provides guidelines for managing individual projects and defines project management-related concepts. It also describes the project management life cycle and its related processes, as well as the project life cycle. It is a globally rec- ognized guide for the project management profession. Project Management Institute and IEEE Computer Society, Software Extension to the Guide to the Project Management Body of Knowledge (SWX) 25. SWX provides adaptations and extensions to the generic practices of project management documented in the PMBOK Guide for man- aging software projects. The primary con- tribution of this extension to the PMBOK Guide is its description of processes that are applicable to managing adaptive life cycle software projects. B.W.

--- Chunk 687 ---
Tokens: 398
Type: sentence-based
Text:
B.W. Boehm, Software Engineering Economics 26. This book is classic reading on software engi- neering economics. It provides an overview of business thinking in software engineering. Although the examples and figures are dated, it is still worth reading. C. Ebert and R. Dumke, Software Measurement 27. This book provides an overview of quantita- tive methods in software engineering, starting with measurement theory and proceeding to performance management and business decision-making. D.J. Reifer, Making the Software Business Case: Improvement by the Numbers 28. This book is classic reading on making a busi- ness case in software and IT industries. Many useful examples illustrate how the business case is formulated and quantified. REFERENCES 1 E. DeGarmo et al, Engineering Economy, 9th ed, Englewood Cliffs, NJ: Prentice Hall, 1993. 2 P. Rodriguez, C. Urquhart, and E. Mendes. A Theory of Value for Value- based Feature Selection in Software Engineering, IEEE Transactions on Software Engineering, 1, 2020. 3 S. Tockey, Return on Software: Maximizing the Return on Your Software Investment, Boston, MA: Addison- Wesley, 2005. 4 International Valuation Standards (IVS), SOFTWARE ENGINEERING ECONOMICS 15-23 2019, Norwich: Page Bros, ISBN: 978-0-9931513-3-3-0. 5 K. Voigt, O. Buliga, and K. Michl, Business Model Pioneers: How Innovators Successfully Implement New Business Models, 2017. 6 M.-I. Sanchez-Segura, G.-L. Dugarte- Pea, A. Amescua-Seco, and F. Medina-Domnguez, Exploring How The Intangible Side of an Organization Impacts its Business Model, Kybernetes, Vol. 50 No. 10, pp.

--- Chunk 688 ---
Tokens: 392
Type: sentence-based
Text:
10, pp. 2790-2822. 2021. https:doi.org 10.1108K-05-2020-0302. 7 ISOIECIEEE International Standard  Systems And Software Engineering  Software Life Cycle Processes  Part 2: Relation and Mapping Between ISOIECIEEE 12207:2017 and ISOIEC 12207:2008. IEEE, 2020, pp. 1-278, doi: 10.1109 IEEESTD.2020.9238529. 8 ISOIECIEEE 15288 First edi- tion 2015-05-15: ISOIECIEEE International Standard  Systems and Software Engineering  System Life Cycle Processes, IEEE. 9 T. Brown and B. Katz, Change by Design: How Design Thinking Transforms Organizations and Inspires Innovation, Revised and updated ed, New York, NY: Harper Collins, 2019. 10 I. Sommerville, Software Engineering, 10th ed, New York: Addison- Wesley, 2016. 11 T. Gilb, Competitive Engineering: A Handbook for Systems Engineering, Requirements Engineering, and Software Engineering Using Planguage, Oxford, UK: Elsevier Butterworth- Heinemann, 2005. 12 R. Kazman, M. Klein, and P. Clements, ATAMSM: Method for Architecture Evaluation, CMUSEI- 2000-TR-004, Software Engineering Institute, August 2000. 13 M.I. Sanchez-Segura, A. Ruiz- Robles, F. Medina-Domnguez, and G.L. Dugarte-Pea. Strategic Characterization of Process Assets Based on Asset Quality and Business Impact, Industrial Management and Data Systems, 117(8), 1720-1734. https:doi. org10.1108IMDS-10-2016-0422, 2017. 14 M.I. Sanchez-Segura, A. Ruiz Robles, F. Medina-Domnguez. Uncovering Hidden Process Assets: A Case Study. Information Systems Frontiers, https: www.springerprofessional.deen uncovering-hidden-process-assets-a -case-study11724394, 2016.

--- Chunk 689 ---
Tokens: 396
Type: sentence-based
Text:
Information Systems Frontiers, https: www.springerprofessional.deen uncovering-hidden-process-assets-a -case-study11724394, 2016. 15 A. Osterwalder, Y. Pigneur, G. Bernarda, A. Smith, and T. Papadakos, Value Proposition Design, Wiley, 2015. 16 D. Gotterbarn, K. Miller, and S. Rogerson, Software Engineering Code of Ethics, Commun. ACM 40, 11, 110-118, doi: 10.1145265684.265699, 1997. 17 S. McConnell, Software Estimation Demystifying the Black Art, 1st ed, Microsoft Press, 2009. 18 R.D. Stutzke, Estimating Software- Intensive Systems Projects, Products, and Processes, 1st ed, Addison-Wesley, 2005. 19 M. Ben-Eli, Understanding Systems. Systems Innovation, http:bit.ly2X- Nlh3D, 2019. 20 J. Sterman, Business Dynamics: Systems Thinking and Modeling for a Complex World, McGraw-Hill, 2000. 15-24 SWEBOK  GUIDE V4.0 21 S. Pereira, G. Medina, et al, System Thinking and Business Model Canvas for Collaborative Business Models Design, IFIP Advances in Information and Communication Technology, Vol. 488, pp. 461-468, 2016. 22 R.E. Fairley, Managing and Leading Software Projects, Wiley-IEEE Computer Society Press, 2009. 23 Project Management Institute, A Guide to the Project Management Body of Knowledge (PMBOK Guide), 7th ed, Newton Square, PA: Project Management Institute, 2021. 24 Project Management Institute, Inc, PMI Lexicon of Project Management Term, 2012. 25 Project Management Institute and IEEE Computer Society, Software Extension to the PMBOK Guide Fifth Edition, ed: Project Management Institute, 2013. 26 B.W. Boehm, Software Engineering Economics, Prentice-Hall, 1981.

--- Chunk 690 ---
Tokens: 56
Type: sentence-based
Text:
Boehm, Software Engineering Economics, Prentice-Hall, 1981. 27 C. Ebert and R. Dumke, Software Measurement, Springer, 2007. 28 D.J. Reifer, Making the Software Business Case: Improvement by the Numbers, Addison-Wesley, 2002.

--- Chunk 691 ---
Tokens: 482
Type: sentence-based
Text:
Reifer, Making the Software Business Case: Improvement by the Numbers, Addison-Wesley, 2002. 16-1 CHAPTER 16 Computing Foundations ACRONYMS ADT Abstract Data Type AI Artificial Intelligence ANSI American National Standards Institute AVL Tree Adelson-Velskii and Landis Tree BCNF Boyce-Codd Normal Form BST Binary Search Tree CASE Common Application Service Element CDRAM Cache DRAM CERT Computer Engineering Response Team CISC Complex Instruction Set Computer CRUD Create, Read, Update, Delete CUDA Compute Unified Device Architecture DAG Directed Acyclic Graph DAL Database Access Language DAS Direct Access Storage DBCS Double Byte Character Set DCL Data Control Language DDL Data Definition Language DDR SDRAM Double Data Rate SDRAM DKNF DomainKey Normal Form DMA Direct Memory Access DML Data Manipulation Language EDW Enterprise Data Warehouse FCFS First Come, First Served FIFO First In, First Out FPU Floating Point Unit HCI Human-Computer Interface HMPP Hybrid Multicore Parallel Programming HTTP Hyper Text Transfer Protocol IPC Inter-Process Communication ISA Instruction Set Architecture MIMD Multiple Instruction, Multiple Data Stream MISD Multiple Instruction, Single Data Stream MISRA Motor Industry Software Reliability Association ML Machine Learning NAS Network Access Storage OSI Open Systems Interconnection PDU Protocol Data Unit RDBMS Relational DBMS RDM Runtime Database Manager RDRAM Rambus DRAM RISC Reduced Instruction Set Computer RTOS Real Time Operating System SAN Storage Area Network SASE Specific Application Service Element SDRAM Synchronous DRAM SEI Software Engineering Institute SIMD Single Instruction, Multiple Data Stream SISD Single Instruction, Single Data Stream SQL Structured Query Language SRTF Shortest Remaining Time First 16-2 SWEBOK  GUIDE V4.0 INTRODUCTION Software engineers must understand and inter- nalize the differences between their role and that of a computer programmer.

--- Chunk 692 ---
Tokens: 518
Type: sentence-based
Text:
16-1 CHAPTER 16 Computing Foundations ACRONYMS ADT Abstract Data Type AI Artificial Intelligence ANSI American National Standards Institute AVL Tree Adelson-Velskii and Landis Tree BCNF Boyce-Codd Normal Form BST Binary Search Tree CASE Common Application Service Element CDRAM Cache DRAM CERT Computer Engineering Response Team CISC Complex Instruction Set Computer CRUD Create, Read, Update, Delete CUDA Compute Unified Device Architecture DAG Directed Acyclic Graph DAL Database Access Language DAS Direct Access Storage DBCS Double Byte Character Set DCL Data Control Language DDL Data Definition Language DDR SDRAM Double Data Rate SDRAM DKNF DomainKey Normal Form DMA Direct Memory Access DML Data Manipulation Language EDW Enterprise Data Warehouse FCFS First Come, First Served FIFO First In, First Out FPU Floating Point Unit HCI Human-Computer Interface HMPP Hybrid Multicore Parallel Programming HTTP Hyper Text Transfer Protocol IPC Inter-Process Communication ISA Instruction Set Architecture MIMD Multiple Instruction, Multiple Data Stream MISD Multiple Instruction, Single Data Stream MISRA Motor Industry Software Reliability Association ML Machine Learning NAS Network Access Storage OSI Open Systems Interconnection PDU Protocol Data Unit RDBMS Relational DBMS RDM Runtime Database Manager RDRAM Rambus DRAM RISC Reduced Instruction Set Computer RTOS Real Time Operating System SAN Storage Area Network SASE Specific Application Service Element SDRAM Synchronous DRAM SEI Software Engineering Institute SIMD Single Instruction, Multiple Data Stream SISD Single Instruction, Single Data Stream SQL Structured Query Language SRTF Shortest Remaining Time First 16-2 SWEBOK  GUIDE V4.0 INTRODUCTION Software engineers must understand and inter- nalize the differences between their role and that of a computer programmer. A typical pro- grammer converts a given algorithm into a set of computer instructions, compiles the code, creates links with relevant libraries, binds, loads the program into the desired system, executes the program, and generates output.

--- Chunk 693 ---
Tokens: 385
Type: sentence-based
Text:
A typical pro- grammer converts a given algorithm into a set of computer instructions, compiles the code, creates links with relevant libraries, binds, loads the program into the desired system, executes the program, and generates output. On the other hand, a software engineer studies the requirements, architects and designs major system blocks, and identifies optimal algorithms, communication mechanisms, per- formance criteria, test and acceptance plans, maintenance methodologies, engineering pro- cesses and methods appropriate to the applica- tions and so on. The key purpose of the Software Engineering Body of Knowledge (SWEBOK) Guide is to identify the areas of knowledge that professional software engineers must know, according to practicing subject matter experts worldwide. Software engineers are expected to have deep and broad knowledge of various con- cepts of computer science and be able to apply them. These concepts form the foundations of computing. BREAKDOWN OF TOPICS FOR COMPUTING FOUNDATIONS The breakdown of topics for the Computing Foundations knowledge area (KA) is shown in Figure 16.1. 1. Basic Concepts of a System or Solution 6, C10 The problem to be solved has to be analyzed in greater detail for functional requirements, user interactions, performance requirements, device interfaces, security, vulnerability, durability and upgradability. A system is an integrated set of subsystems, modules and components that perform specific functions independently. Delineating the problem and solution is critical.

--- Chunk 694 ---
Tokens: 97
Type: sentence-based
Text:
Delineating the problem and solution is critical. An engineered system ensures the subsys- tems are designed to be:  Modular: Each subsystem (module) is uniform (similar size). Cohesive: Each subsystem performs one specific task. Ideally, systems should be highly cohesive. Coupled: Each subsystem functions inde- pendently, as much as possible. Ideally, systems should be loosely coupled.

--- Chunk 695 ---
Tokens: 417
Type: sentence-based
Text:
Ideally, systems should be loosely coupled. Computing Foundations Basic Concepts of a System or Solution Computer Architecture Types of Computer Architecture Microarchitecture or Computer Organization Memory Unit InputOutput Devices Control Unit Types of Data Structures Operations on Data Structures Algorithms and Attributes of Algorithms Algorithm Complexity Measurement of Complexity Designing Algorithms Sorting Techniques Searching Techniques Hashing Programming Language Types Programming Syntax, Semantics, Type Systems Subprograms and Coroutines Object-Oriented Programming Distributed Programming and Parallel Programming Debugging Standards and Guidelines Processor Management Memory Management Device Management Information Management Network Management Schema Data Models and Storage Models Database Management Systems Relational Database Management Systems and Normalization Structured Query Language Data Mining and Data Warehousing Database Backup and Recovery Types of Computer Networks Layered Architectures of Networks Open Systems Interconnection Model Encapsulation and Decapsulation Application Layer Protocols Design Techniques for Reliable and Efcient Networks Internet Protocol Suite Wireless and Mobile Networks Security and Vulnerabilities Computer Architecture and Organization Data Structures and Algorithms Programming Fundamentals and Languages Operating Systems Database Management Computer Networks and Communications Human Factors: User and Developer User Human Factors Developer Human Factors Articial Intelligence and Machine Learning Reasoning Learning Models Perception and Problem-Solving Natural Language Processing Figure 16.1.

--- Chunk 696 ---
Tokens: 454
Type: sentence-based
Text:
Computing Foundations Basic Concepts of a System or Solution Computer Architecture Types of Computer Architecture Microarchitecture or Computer Organization Memory Unit InputOutput Devices Control Unit Types of Data Structures Operations on Data Structures Algorithms and Attributes of Algorithms Algorithm Complexity Measurement of Complexity Designing Algorithms Sorting Techniques Searching Techniques Hashing Programming Language Types Programming Syntax, Semantics, Type Systems Subprograms and Coroutines Object-Oriented Programming Distributed Programming and Parallel Programming Debugging Standards and Guidelines Processor Management Memory Management Device Management Information Management Network Management Schema Data Models and Storage Models Database Management Systems Relational Database Management Systems and Normalization Structured Query Language Data Mining and Data Warehousing Database Backup and Recovery Types of Computer Networks Layered Architectures of Networks Open Systems Interconnection Model Encapsulation and Decapsulation Application Layer Protocols Design Techniques for Reliable and Efcient Networks Internet Protocol Suite Wireless and Mobile Networks Security and Vulnerabilities Computer Architecture and Organization Data Structures and Algorithms Programming Fundamentals and Languages Operating Systems Database Management Computer Networks and Communications Human Factors: User and Developer User Human Factors Developer Human Factors Articial Intelligence and Machine Learning Reasoning Learning Models Perception and Problem-Solving Natural Language Processing Figure 16.1. Breakdown of Topics for the Computing Foundations KA COMPUTING FOUNDATIONS 16-3 The subsystems may further be broken down into modules and sub-modules that also exhibit these characteristics.

--- Chunk 697 ---
Tokens: 392
Type: sentence-based
Text:
Breakdown of Topics for the Computing Foundations KA COMPUTING FOUNDATIONS 16-3 The subsystems may further be broken down into modules and sub-modules that also exhibit these characteristics. The system may include both software and hardware subsystems. The hardware must be designed to support the software subsys- tems and satisfy all user requirements, espe- cially user interfaces (inputoutput (IO)) and performance. This section focuses on designing and building engineered software subsystems. The applications may require systems that are manual or fully or semiautomated; real- time, online or offline; distributed or single- location, and so on. The software subsystems architects have to consider appropriate technology, tools, data structure, operating system, database (if required), user interfaces, programming lan- guages, and algorithms for computing solu- tions optimally among others. Software requirements, architecture, design, construction, testing, methods and models, quality assurance, and security are discussed in detail in other chapters as independent KAs. The Computing Foundations KA focuses on explaining the key computer science con- cepts a software engineer has to know well to architect, design, construct, deploy and main- tain useful, high-quality software subsystems. 2. Computer Architecture and Organization 6, C6 Computer architecture refers to the com- ponents of a computer system designed for specific purposes. Computer organization explains how the units within the system con- nect and interact to achieve those purposes.

--- Chunk 698 ---
Tokens: 350
Type: sentence-based
Text:
Computer organization explains how the units within the system con- nect and interact to achieve those purposes. System architects must analyze the appli- cation for which the computer system is to be designed or developed; identify the crit- ical components, including IO devices required (along with throughput), types and quantum of memory, processing power, and coprocessors required; and choose or design appropriate computer architecture and orga- nization. Contingencies should be built in for the resources required. This content area discusses various com- puter architectures and organizations a system or software architect needs to know. 2.1. Computer Architecture 8, C1.1 Architecture describes what the computer or system does, and its components, such as memory, data storage devices, graphics, and the computers or processors computing power. A computing system typically has memory, IO devices and a central processing unit (CPU). These components are connected through physical signal lines called a bus. Typically, three types of buses are used for specific purposes:  Address bus, which addresses or accesses a specific memory location or IO device. Data bus, which stores (writes) or retrieves (reads) data to and from the memory location. Control bus, which provides control sig- nals from the CPU to IO devices (read or write, enable or disable, interrupt, status, reset, etc.).

--- Chunk 699 ---
Tokens: 384
Type: sentence-based
Text:
Control bus, which provides control sig- nals from the CPU to IO devices (read or write, enable or disable, interrupt, status, reset, etc.). Software engineers are expected to know the details of the functioning and timing of different types of buses  first-gener- ation, second-generation and third-gen- eration buses; internal and external buses; serial and parallel buses; simplex, full-duplex and half-duplex buses; Mil-Std-1553Bbus, Wishbone buses, etc. 2.2. Types of Computer Architectures 8, C4.14, C5 2.2.1. Von Neumann Architecture 8, C1.9 John von Neumann designed a computer system architecture with five essential com- ponents as shown in Figure 16.2:  Arithmetic logic unit (ALU) that per- forms arithmetic and logic computation. Memory where the program and data are loaded and executed (program and data reside in the same memory space). 16-4 SWEBOK  GUIDE V4.0  Input devices (e.g, keyboard, mouse, serial port, hard disk) that allow the user to provide inputs and control commands. Output devices (e.g, monitor, printer) that transmit or communicate the com- puted results. The control unit synchronizes all devices, memory and ALU. 2.2.2. Harvard Architecture 20 The Harvard architecture provides separate memory blocks for code (program or instruc- tions) and data. As the code and data memory blocks are different, the contents of address 0000 in the code block and the contents of address 0000 in the data block are different. The CPU reads instructions from the code addresses and reads data from the data addresses.

--- Chunk 700 ---
Tokens: 383
Type: sentence-based
Text:
The CPU reads instructions from the code addresses and reads data from the data addresses. The system design and implementation in the original Harvard architecture were rela- tively complex. The modified Harvard architec- ture provides one memory block but partitions it into code and data sections. Data memory sections are readwrite capable, and code memory sections are read-only (thus protects code from getting corrupted at runtime). IO operations can be performed simultaneously. 2.2.3. Instruction Set Architecture 8, C4.8.3 An instruction set architecture (ISA) is an abstract model of how a CPU executes the instruction sets defined for the system. An ISA defines registers (address, data, flags), data types, instructions specific to the computer or system, memory (internal and external) addressing schemes, and IO handling models. A reduced instruction set computer (RISC) architecture and a complex instruction set computer (CISC) architecture are the two primary types of ISAs. In RISC, the instructions perform single tasks such as reading from memory or IO, performing arithmetic or logical computa- tion, and storing data into memory or IO. The computer system is simple but requires more instructions to execute a task. It requires fewer clock cycles per instruction, and instruc- tion sizes tend to be fixed. As the instruction set is small (fewer instructions), it is easier to build a compiler, and the program can be rel- atively large. RISC architectures are typically designed for general-purpose processors.

--- Chunk 701 ---
Tokens: 388
Type: sentence-based
Text:
RISC architectures are typically designed for general-purpose processors. The instructions are relatively more pow- erful in CISC and can perform multiple tasks such as reading data from memory  per- forming arithmetic operation  storing the result in memory. Here, fewer instructions are required to perform a task, but the instruc- tions take more clock cycles to complete. Instruction sizes vary widely depending on operations with registers, memory and IO. Programs are relatively small. CISCs are typ- ically designed for specific purposes such as digital signal processing (DSP) and graphics. Memory Input Devices ALU Output Devices Control Unit Figure 16.2. Computer Architecture COMPUTING FOUNDATIONS 16-5 2.2.4. Flynns Architecture or Taxonomy 8, C9.3 The computing architectures described above consider a single computer at a time. Michael J. Flynn proposed concurrent computer archi- tectures, where multiple instruction streams and multiple data streams are used in the system. Software engineers need to know the different types of Flynns architecture, with examples, including the following:  Single instruction, single data stream (SISD) architecture. Single instruction, multiple data stream (SIMD) architecture. Multiple instruction, single data stream (MISD) architecture. Multiple instruction, multiple data stream (MIMD) architecture. Variants of these architectures include array processing, parallel processing, and asso- ciate processing; processing single program multiple data streams, and multiple program multiple data streams.

--- Chunk 702 ---
Tokens: 378
Type: sentence-based
Text:
Variants of these architectures include array processing, parallel processing, and asso- ciate processing; processing single program multiple data streams, and multiple program multiple data streams. Software engineers are expected to know the differences among these architectures, along with case studies, so that they can choose the right architecture to solve the problem at hand. 2.2.5. System Architecture 6, C6 System architecture is the overall system design, considering hardware architec- ture, software architecture, modules, inter- faces, data management, and communication among modules. Distributed computing has become affordable with the development of efficient, high-end, high-performance servers, storage, network devices, software, and tools. Several reference designs or architectures are available for any given application. Typical system architectures include the following:  Integrated system architecture: Computing, IO, data and networking are tightly coupled and available in one box. This architecture is typically used in solutions designed for specific applications. Distributed system architecture: Computing and storage are located in separate but networked boxes. This archi- tecture supports scaling, provides cen- tralized or isolated data storage, and shares computation load. Pooled system architecture: Several com- puting, storage and network resources are available in pools and provided depending on demand. This architecture provides for efficient use of shared resources.

--- Chunk 703 ---
Tokens: 386
Type: sentence-based
Text:
This architecture provides for efficient use of shared resources. Converged system architecture: As the name implies, this is the convergence of distributed and pooled architectures. This architecture supports agility and scalability. Software engineers are also expected to know and be able to apply various other architectures, including .NET Framework architecture, Unix architecture, and virtual machine architecture. 2.3. Microarchitecture or Computer Organization 8, C4 Microarchitecture or computer organization explains how the ISA of a computer is imple- mented and how different components in the system function and interact with one another to produce the desired outcome. System architects and engineers must know the various components used in the system along with how they function. Some of these components are discussed below. 2.3.1. Arithmetic Logic Unit 8, C1.2 The ALU performs all arithmetic computa- tions and logical operations. The CPU typ- ically has an ALU, processor, memory, and control unit. High-end CPUs may also have other functionality-specific processing units, such as a floating-point unit (FPU), to per- form computations involving floating point or real numbers (fractions). ALUs have registers 16-6 SWEBOK  GUIDE V4.0 that are high-speed memory and internal to the ALU. The ALU executes the processor instruction sets. All operations are typically carried out on the registers. Various schemes may be implemented to improve the performance of the ALU, including pipeline processing and parallel processing.

--- Chunk 704 ---
Tokens: 387
Type: sentence-based
Text:
Various schemes may be implemented to improve the performance of the ALU, including pipeline processing and parallel processing. The latest CPUs provide multiple cores and multiple threads that help achieve maximum throughput. Software engineers are expected to know the differences between multiple cores and multiple threads, along with specific cases illustrating the best use of these. Specific-purpose coprocessors and asso- ciate processors are used with main processors to support faster processing. 2.3.2. Memory Unit 8, C6 Memory units are used to store data or infor- mation, which is accessed by the CPU. The total amount of memory a computer can have is derived from the maximum number of address lines supported by the CPU. Different types of memory used in the system include read-only memory (ROM), and read-write memory or random access memory (RAM). Software engineers working on perfor- mance-critical applications are expected to know the differences among various types of memory, including static RAM (SRAM), dynamic RAM (DRAM), asynchronous DRAM (ADRAM), synchronous DRAM (SDRAM), double-data-rate SDRAM (DDR SDRAM), rambus DRAM (RDRAM), and cache DRAM (CDRAM), along with pros, cons and use cases of each. 2.3.3. InputOutput Devices 8, C7 As the names imply, input devices are those that provide inputs to the computer system, and output devices are those that deliver com- puter systems output to the user. While some devices are input only (keyboard, mouse, microphone, etc.) or output only (printer, monitor, speakers, etc.

--- Chunk 705 ---
Tokens: 398
Type: sentence-based
Text:
or output only (printer, monitor, speakers, etc. ), a few devices serve as both input and output devices (e.g, touch screens, hard disks, USB drives). Software engineers are expected to under- stand the interface of the IO devices with the system, whether they are memory-mapped IO or IO-mapped IO devices, and device drivers required for the users or applications to interact with the devices through the operating system. 2.3.4. Control Unit 8, C4.2 The control unit synchronizes multiple com- ponents in the computer system. Typically, control units are part of the CPU. They inter- pret instructions and coordinate data move- ment among different components (memory, IO devices and ALU). Control units are also used to enable or disable components or devices and reset devices. Software engineers are expected to be aware of the different types of control units, including hardware control units and micro programmable control units (single-level and two-level control stores), along with the bene- fits and challenges of each. 3. Data Structures and Algorithms 8, C2 18, C10 Part V Data structures are fundamental to computer science and software engineering. Every pro- gram uses data  receives input (data), per- forms specific functions on the data and produces output. Data structures is about rep- resenting different types of data effectively, performing various operations on the data pro- ficiently, and storing and retrieving data effi- ciently. Software engineers must internalize data structures, the selection of data structures, and operations on them specific to applications.

--- Chunk 706 ---
Tokens: 359
Type: sentence-based
Text:
Software engineers must internalize data structures, the selection of data structures, and operations on them specific to applications. In this chapter, different types of data structures and various operations on them are discussed. 3.1. Types of Data Structures 18, C10, 5, C2.1 - 2.6 Data type is an attribute of data. Various data types are identified and defined based on dif- ferent characteristics of data, the need for grouping data items and various operations COMPUTING FOUNDATIONS 16-7 performed on data. Data structures are grouped primarily based on the physical and logical ordering of data items. Primarily, data is grouped into three types: basic, composite or compound, and abstract. Basic or primitive data types include char- acter, integer, float or real, Boolean, and pointer data. Compound data types are made of multiple basic or primitive, or even multiple compound data types. Some of the compound data types include sets, graphs, records and partitions. An abstract data type (ADT) is defined by its behavior (semantics) from the users per- spective, specifically from the point of pos- sible values and operations. Composite or compound data types are further grouped under linear, and hierarchical or nonlinear data types. Linear data types include one-dimensional and multidimensional arrays, strings, linked lists (singly linked lists, doubly linked lists, circular lists), stacks, queues, and hash tables.

--- Chunk 707 ---
Tokens: 381
Type: sentence-based
Text:
Linear data types include one-dimensional and multidimensional arrays, strings, linked lists (singly linked lists, doubly linked lists, circular lists), stacks, queues, and hash tables. Hierarchical or nonlinear data types include trees, binary trees, n-array trees, B trees, B trees, weighted balanced trees, red- black trees, heaps, binary heaps and graphs. In the current era of free text queries or natural language processing, software engi- neers may need to understand strings and var- ious operations on strings, and to be able to analyze skip lists. Software engineers must understand the nuances of various types of data and their sizes in memory (short integer, integer, long integer, long long integer, signed and unsigned integer, float, double, long double, double byte character set (DBCS), Boolean, etc. ), along with how various data types are represented and stored in memory and how various operations are performed on them. Sets, graphs, and trees are discussed in more detail in the Mathematical Foundations KA. 3.2. Operations on Data Structures 5, C2.1 - 2.6 Basic operations performed on data structures include create, read, update and delete (CRUD). Compound data types also require various ways of traversing data sets to identify specific data items before performing the operation. It is important to ensure that any insertion or deletion of items in a data set or database does not alter the data set or database in a way that violates any policy under which the data- base was designed and built.

--- Chunk 708 ---
Tokens: 399
Type: sentence-based
Text:
It is important to ensure that any insertion or deletion of items in a data set or database does not alter the data set or database in a way that violates any policy under which the data- base was designed and built. Additional operations performed on data structures include sorting the data items in a specific order, searching and locating a data item, and merging two or more data sets into one set without disturbing the policy on which the data set is built. Searching and sorting algorithms are discussed in the next section. Different data structures are created to suit specific applications, such as stacks, queues, trees, and graphs. Software engineers are encouraged to learn the traversals through non- linear data structures, which include different tree parsers (pre-order, in-order, and post-order tree traversals), CRUD operations on trees, tree balancing, binary search trees (BSTs), AVL trees, and red-black trees, and to learn tree search algorithms (depth first, breadth first, shortest paths, etc.). Some of these are dis- cussed in the Mathematical Foundations KA. 3.3. Algorithms and Attributes of Algorithms 18, C26, C27 All software implements logic to perform the required function. That logic or algorithm to perform a specific task has to be designed or chosen with consideration for system per- formance, security, portability, maintain- ability, scalability and simplicity, among other concerns. The complexity of an algorithm is deter- mined by measuring the computational resources (computing power and space) con- sumed by that algorithm for a given set of data.

--- Chunk 709 ---
Tokens: 382
Type: sentence-based
Text:
The complexity of an algorithm is deter- mined by measuring the computational resources (computing power and space) con- sumed by that algorithm for a given set of data. A thorough understanding of data struc- tures is vital for analyzing and designing good algorithms. Refer to the Data Structures and Organization content area for more details. The attributes of algorithms are many and include functionality, correctness, robustness, 16-8 SWEBOK  GUIDE V4.0 modularity, maintainability, programmer- friendliness (ease of integration into the project and ease of use), user-friendliness (i.e, how easily it is understood by people), need for pro- grammer time, simplicity, and extensibility. A commonly emphasized attribute of algo- rithms is performance or efficiency. The parameters that matter for an algo- rithms resource consumption include, but are not limited to: 1. Hardware. 2. Software. 3. Algorithm selection and design for a spe- cific problem. 4. Effective implementation. 3.4. Algorithm Complexity 5, S1, S3, S4, S5, S6, S7, S11, S12 The complexity of an algorithm is a mea- sure of the resources it consumes (computing power or memory) for a specific problem and given data set. Choosing the right data structures and operations on data structures and ensuring optimal implementation of the algorithm also effect the algorithms complexity. 3.5. Measurement of Complexity 5, S1.1, S3, S4, S5, S6, S11.1, S12.1 Often, the complexity of an algorithm is denoted by the resources consumed in the worst-case scenario.

--- Chunk 710 ---
Tokens: 398
Type: sentence-based
Text:
Measurement of Complexity 5, S1.1, S3, S4, S5, S6, S11.1, S12.1 Often, the complexity of an algorithm is denoted by the resources consumed in the worst-case scenario. The complexity of algo- rithms is typically measured by asymptotic notations for best-case, worst-case and aver- age-case scenarios in terms of resource con- sumption for a given data set. Popular asymptotic notations for algo- rithms are listed in Table 16.1. Learning the computation of the listed notations for different sets of input data (e.g, sorted, unsorted, and sorted in reverse order) is important. The complexity of an algorithm can be con- stant, linear, quadratic, cubic, exponential or logarithmic. These complexities are described in Table 16.2. Typically, constants are not considered when computing the efficiency of an algorithm. 3.6. Designing Algorithms 18, Part IV, Part VI The software engineer must consider the specific applications purpose and the per- formance requirements in order to select an appropriate algorithm. In addition, the soft- ware engineer must consider linear pro- gramming versus parallel programming and single- versus multi-threading. The efficiency of an algorithm is measured by the resources it consumes, primarily com- puting time and memory. A software engineer has to know a few standard algorithms and relevant concepts, including the following: Asymptotic Notations Description Big O Big O notation provides the upper bound of operations (worst-case scenario) for a function f(n). little-o Little o notations are used to depict scenarios where the upper bound is not tight.

--- Chunk 711 ---
Tokens: 392
Type: sentence-based
Text:
little-o Little o notations are used to depict scenarios where the upper bound is not tight. Big Omega () Big  notations are used to depict lower bounds (best-case scenarios) for a function f(n). little-omega () Little omega () notations are used to depict loosely bound best-case scenarios of an algorithm. Theta () Theta notation bounds the function from above and below (provides average-case complexity of an algorithm). Table 16.1. Asymptotic Notations of Algorithms COMPUTING FOUNDATIONS 16-9  Common types of algorithms: Brute force algorithm, Recursive algorithm, Divide  Conquer algorithm, Dynamic programming algorithms, Greedy algorithm, Backtracking algorithms, Randomized algorithms. Randomized approximation algorithms, randomized rounding, approximation algorithms, P and NP complexity class algorithms, Cooks theorem, reductions and completeness algorithms. Multiple comparison operations per- formed simultaneously in a network model of computation. Popular sorting network algorithms include comparison networks, zero-one principle, merging network and bitonic sorter. Optimized algorithms for performing several operations on a matrix, such as matrix multiplication, transposition, matrix inversion, median, and finding determinants. Cryptographic complexity and algo- rithms: secret key (symmetric) encryp- tion algorithms, public key (asymmetric) encryption algorithms and hash functions. One-way functions, class UP, space com- plexity, deterministic and nondeterministic space complexity classes, the reachability method, and Savitchs theorem.

--- Chunk 712 ---
Tokens: 391
Type: sentence-based
Text:
One-way functions, class UP, space com- plexity, deterministic and nondeterministic space complexity classes, the reachability method, and Savitchs theorem. Graph representations, graph algorithms, breadth-first and depth-first search, topological sort, minimum spanning tree, Kruskal and Prim algorithms, and single-source shortest paths (Bellman- Ford and Dijkstra algorithms). Complexity of randomized computa- tion, interactive proofs, complexity of counting, Boolean circuit complexity. Of particular importance in many soft- ware systems are algorithms for sorting and searching, these are discussed in more detail. 3.7. Sorting Techniques 18, C6-C9 Sorting is the process of arranging data items in a specific order. Popular sorting algorithms include Linear sort, Bubble sort, Quick sort, Merge sort, Radix sort, Heap sort, Bucket sort, Pigeonhole sort, Bitonic sort, Tree sort, Cartesian Tree sort, 3-Way Quick sort,3-Way Merge sort, and Sorting Singly  Doubly linked lists. Each sorting algorithm has its benefits and shortfalls. Selection of an appropriate algo- rithm depends on the size of input data, the type of data (linear or nonlinear), and the type of data set (completely unsorted, partially sorted, etc.). The algorithms are implemented in both iterative and recursive methods. Complexity Notation Description Constant O(1) Regardless of the data size, the algorithm takes a constant number of steps to perform the operation. Linear O(n) The number of operations is linearly proportional (steps are a constant multiple of the data set size n).

--- Chunk 713 ---
Tokens: 395
Type: sentence-based
Text:
Linear O(n) The number of operations is linearly proportional (steps are a constant multiple of the data set size n). Quadratic O(n2) The algorithm takes the order of n2 steps for performing the operation on the data set of size n. Cubic O(n3) The algorithm takes the order of n3 steps for performing the operation on a data set size of n. Exponential O(nk) O(2n) O(n!) The algorithm has an order of exponential dependability for performing the operation on a data set of size n. Logarithmic O(log (n)) O(Nlog (n)) The algorithm takes the order of log (n) steps (base of log is typically 2). Table 16.2. List of Algorithmic Complexities 16-10 SWEBOK  GUIDE V4.0 Typically, iterative methods are better than recursive methods for CPU performance and memory. However, recursion provides easy methods for solving specific problems, such as tree operations. If adequate computing power and memory are available, the difference between recursive and iterative implementa- tion methods is negligible. In the case of applications where certain sorting algorithms work best, software engi- neers should learn and accommodate any preconditions and complexities (demand on memory and computing power) involved in using them. 3.8. Searching Techniques 5, C6 Searching is a process of finding specific data items or records in a set of data items or a database. Search algorithms are primarily catego- rized into sequential search (data set is tra- versed sequentially until the end of the data set) and interval search (the search moves effi- ciently through a sorted list, balanced tree, etc.

--- Chunk 714 ---
Tokens: 344
Type: sentence-based
Text:
Search algorithms are primarily catego- rized into sequential search (data set is tra- versed sequentially until the end of the data set) and interval search (the search moves effi- ciently through a sorted list, balanced tree, etc. ), based on how data sets are organized. Depending on the type of the data item and the size of the data set, various search techniques are used to find the desired data item. Popular search algorithms include linear, binary, jump, interpolation, exponen- tial, Fibonacci, sub-list (search a linked list in another list), logarithmic, tree and hashing. 3.9. Hashing 18, C11.2 Hashing is one of the very important and popular technique in which data of arbitrary size (key values) are converted into values of fixed size called hash values, which index into a hash table so the data records can be located easily. The function used for that pur- pose is called a hash function, and the values returned are called hash values, hash codes, digests, or hash keys. Different properties of hash functions, such as uniformity, efficiency, universality, applica- bility, deterministic, defined or variable range, data normalization, testing, and measurement, must be understood and considered when designing or choosing a hash function. Various types of hash functions are designed for different types of key values, applica- tions, and database sizes.

--- Chunk 715 ---
Tokens: 359
Type: sentence-based
Text:
Various types of hash functions are designed for different types of key values, applica- tions, and database sizes. Hash function types include trivial hash function, division method, mid-square method, digit folding method, multiplicative hashing, double hashing, open and closed hashing, rehashing, extendible hashing, and cryptographic and noncryptographic hash functions. Software engineers are expected to learn, implement and be able to compare different types of hashing algorithms, various collision resolution techniques, linear probing, qua- dratic probing, separate chaining, and open addressing. 4. Programming Fundamentals and Languages 4, C6 Computer programs are sequential steps or instructions that work on provided inputs and generate desired or specific outputs. Software engineers must carefully consider various aspects before selecting a program- ming language to solve a specific problem. 4.1. Programming Language Types 8, C8.4.4 Depending on the hardware, operating system, and application various types of programming languages are developed and used. Basic types of programming languages include microprogramming, machine lan- guages, assembly programming and high- level programming. Microprogramming is executed within the microcontroller or microprocessor chips to execute the assembly language instructions. Assembly language programs use the mne- monic specified by the microcontroller or microprocessor.

--- Chunk 716 ---
Tokens: 391
Type: sentence-based
Text:
Assembly language programs use the mne- monic specified by the microcontroller or microprocessor. Typically, the microcon- trollers or microprocessors are designed to address specific applications (DSP processors, graphics chips, IO controllers, mathematical coprocessors, generic processors, etc.). High-level languages enable programs to be written in instructions similar to English, COMPUTING FOUNDATIONS 16-11 which makes it easy for the developer and maintainer to write and maintain the pro- grams. Various types of high-level program- ming languages include the following:  Functional programming languages. Procedural programming languages. Object-oriented programming languages  Scripting languages. Logic programming languages. A programming language can support more than one programming paradigms Software engineers need to study multiple program- ming languages to choose the right one for a specific application. Many programming languages, such as C, C and Java, use compilers to build execut- ables, whereas other programming languages, such as JavaScript, Ruby and Python, use interpreters. 4.2. Programming Syntax, Semantics, Type Systems 8, C8.4.4 The syntax of a programming language is its grammar  the various constructs the pro- gramming language uses. A compiler or inter- preter checks the syntax of all declarations, statements (algorithmic statements, condi- tional or logical statements, control statements, loops, special language-specific statements, micros, etc. ), and functions or procedures, and creates notifications of any errors.

--- Chunk 717 ---
Tokens: 389
Type: sentence-based
Text:
), and functions or procedures, and creates notifications of any errors. Semantics refers to the meaning or inter- pretation of the statement. The meaning could vary at runtime, depending on runtime values. A type system assigns a type to a data item or to constructs of a program, such as variables, expressions and functions. In static typing, the type is fixed; it is defined during program creation and checked at compilation time. Languages such as C, C and Java support static typing. In dynamic typing, the type of a variable can change at runtime depending on the context and hence is checked at runtime. Dynamic typing languages include Python, Perl, PHP and Ruby. Dynamic typing is also called polymorphic typing. Software engineers are expected to know how high-level programming languages are translated into machine languages, to be familiar with the various types of compilers, and to know the differences among compilers, interpreters, cross-compilers, assemblers and cross-assemblers. Software engineers are encouraged to learn about compiler phases, including preprocessing, lexical analysis, syntax analysis, intermediate code generation, optimization, code generator, linkers, loaders and debuggers. Tokens, grammars, syntax trees, parse trees and weights to various operators (prece- dence) in arithmetic and logical equations are important to analyze and understand. 4.3. Subprograms and Coroutines 4, C6.3 Subprograms or functions are programs or building blocks that perform specific (part) functions in the scope of a complete project.

--- Chunk 718 ---
Tokens: 388
Type: sentence-based
Text:
Subprograms and Coroutines 4, C6.3 Subprograms or functions are programs or building blocks that perform specific (part) functions in the scope of a complete project. Subprograms provide for breaking the larger program into smaller modules. The modules are typically sections of code that are used multiple times in multiple places. The subpro- grams reduce memory space, improve read- ability and maintainability of the program, and execute parts of the program with dif- ferent values at different places and times. The subprograms have an entry point and typically have multiple input parameters on which the subprogram acts and produces output. The scope of input parameters is local to the subprogram. Subprograms that return value by their name (which can be used as a variable in a statement) are called functions, and subprograms designed not to return any value are called procedures. By default, the scope of subprogram parameters is dynamic and local to the sub- program. However, if the subprograms have to remember their history or previous values, they have to be declared static or as specified in the chosen programming language. Different programming languages sup- port one or more types of parameters passing, including pass-by-value, pass-by-ref- erence, pass-by-name, pass-by-result and 16-12 SWEBOK  GUIDE V4.0 pass-by-result-value. Software engineers should know the differences among these types and use them appropriately. Many high-end languages support the nesting of subroutines and recursions, where a subroutine calls itself.

--- Chunk 719 ---
Tokens: 396
Type: sentence-based
Text:
Many high-end languages support the nesting of subroutines and recursions, where a subroutine calls itself. Different types of recur- sions include cyclic or direct recursion (subrou- tine calls itself) and acyclic or indirect recursion (subroutine A calls subroutine B, which in turn calls subroutine A). It is important to establish the exit criteria in recursive subprograms. Software engineers are encouraged to understand, using case studies, how the sub- program return address and parameters are stored in memory (runtime stack), how they are used in the subprogram and for returning to the called subprogram, and the scope of variables (global and local). A subprogram with multiple entry points, where the previous exit point is remembered for resumption at a later point, is called a Coroutine. A Coroutine call is typically called a resume call. The first resume call enters the subroutine from the beginning, and sub- sequent resume calls enter the subroutine at the point where it was exited last. High-end languages that support Coroutines include C20, C, Java, JavaScript, Kotlin, Perl, .NET Framework, Python, Ruby and many assembly languages. Software engineers are encouraged to understand specific applications where corou- tines are useful and to use the coroutines. It is an interesting exercise to implement corou- tines in C, as C does not support corou- tines natively. Figure 16.3 depicts the functioning or con- trol flow of coroutines. 4.4. Object-Oriented Programming 4, C6.5 As the name suggests, object-oriented pro- gramming languages are based on objects.

--- Chunk 720 ---
Tokens: 384
Type: sentence-based
Text:
Object-Oriented Programming 4, C6.5 As the name suggests, object-oriented pro- gramming languages are based on objects. The objects typically have both data and functions that operate on that data. The data of an object is typically called the objects attributes or properties, and the code or func- tions that work on the attributes are called operations externally (by the client or user) and called methods internally (referring to how the operation is implemented by the developer). A Class is a programmer-defined proto- type that defines the attributes and methods. Objects are actual instances of a Class. There could be multiple Objects of a Class with varied characteristics. For example, a Class can be defined by the characteristics and operations of a vehicle, whereas objects are instances of the class vehicle such as car, bus or truck. The objects interact with one another using the methods or operations. Important characteristics of object-ori- ented programming (OOP) are Abstraction, Encapsulation, Inheritance and Polymorphism. Abstraction is a property that exposes only required or relevant information and func- tionality to the user, hiding the details and nonessentials. Thus, the implementation is hidden from the user of the superclass. One of the key benefits of encapsulation is the ability to hide or protect data from unau- thorized users. The software engineer can give different levels of protection to data and methods by declaring them private (local to class) or public (available to other classes).

--- Chunk 721 ---
Tokens: 389
Type: sentence-based
Text:
The software engineer can give different levels of protection to data and methods by declaring them private (local to class) or public (available to other classes). This also protects data from corruption, either intentional or accidental. Subroutine S1 Subroutine S2 Subroutine S3 Resume S1 Resume S3 Resume S3 Resume S2 Resume S2 Resume S1 Figure 16.3. Example of Coroutine COMPUTING FOUNDATIONS 16-13 Inheritance is an important feature of OOP, where a subclass or derived class inherits the properties of a superclass or base class. Primary inheritance modes include public, protected and private modes. Polymorphism is another key feature of OOP. Polymorphism is a provision of pro- viding a single interface to entities of dif- ferent types. For example, shape could be a base class with draw as a method, and objects could be a circle, triangle or rect- angle. The implementation of method draw, though the name is the same, differs for a circle, triangle and rectangle. Polymorphism has two types:  Static or compile-time polymorphism: The methods (functions) or operators are overloaded and resolved during compile time. Example: The methods, though they have the same name, will have dif- ferent types or numbers of parameters. Dynamic or runtime polymorphism: The overloaded method to be executed is resolved at runtime. Example: When both base class and derived class have the same method, the base class method is said to be overridden. Popular OOP languages include C, C, Cobol 2002, Java, Python, Lisp, Perl, Object Pascal, Ruby and Smalltalk.

--- Chunk 722 ---
Tokens: 343
Type: sentence-based
Text:
Popular OOP languages include C, C, Cobol 2002, Java, Python, Lisp, Perl, Object Pascal, Ruby and Smalltalk. Its important to recognize that using OOP requires a different mindset than using traditional, procedural, or structured pro- gramming does. 4.5. Distributed Programming and Parallel Programming 4, C6.6 In a distributed computer system, multiple parts of the software are run on multiple com- puters, connected through computer networks, to achieve a common goal. Writing such pro- grams is called distributed programming. Parallel programming is a type of com- puting in which different parts of the program are run in parallel to achieve the same objec- tive or goal. Table 16.3 compares distributed and parallel programming. High Performance Computing (HPC) aims to speed-up the exe- cution of software, both distributed program- ming and parallel programming are ways to do this and is increasingly used together in hybrid software. 4.6. Debugging 6, C2.2.2 Programs, when written, are expected to function properly and generate the expected output. However, programmers often face three types of errors  syntax errors, runtime errors, and logical errors  at different stages of software development. Syntax errors are deviations from the stan- dard format specified by programming lan- guages. These are explicitly identified by compilers and are easy to fix.

--- Chunk 723 ---
Tokens: 380
Type: sentence-based
Text:
These are explicitly identified by compilers and are easy to fix. Runtime errors surface when a program runs into an unexpected condition or situation such as dividing by zero, memory overflow, or addressing a wrong or unauthorized memory location or device, or when a program tries to perform an illegitimate or unauthorized oper- ation or tries to access a library, for example. The programs must be thoroughly tested for various types of inputs (valid data sets, invalid data sets and boundary value data sets) and conditions to identify these errors. Once iden- tified, runtime errors are easy to fix. Logical errors are slipups in implementing the logic to achieve the desired output. These errors must be traced and resolved with various data for each functionality. Several sophisti- cated high-end debuggers help trace each vari- able or data item and support setting various types of break points. 4.7. Standards and Guidelines 3, C28.5, C31.5 As the computing system or application becomes bigger and complex, more program- mers are involved. Their individual program- ming styles affect the project schedules and make system integration difficult, so systems become defect-prone, and maintenance and enhancement become challenging. 16-14 SWEBOK  GUIDE V4.0 An estimated 82 of vulnerabilities are caused by clashes between program- ming styles. Hence, quality-conscious companies often have defined tools, standards and guidelines, which set rules and recommendations for their programmers and testers to follow.

--- Chunk 724 ---
Tokens: 374
Type: sentence-based
Text:
Hence, quality-conscious companies often have defined tools, standards and guidelines, which set rules and recommendations for their programmers and testers to follow. When software teams follow appro- priate coding standards, they create read- able, cleaner, portable, reusable, modular,  https:www.ptsecurity.comww-enanalyticsweb-vulnerabilities-2020 easily maintainable, less defect-prone soft- ware code, and project schedules become more predictable. The following practices can help organizations implement such standards successfully:  Carefully choose the coding standards and guidelines that suit the application or system being developed. Consider open standards created by Parameters Distributed Programming Parallel Programming Functionality A task is shared and executed by mul- tiple computers that are networked. Two or more processors on a computer share and execute the task in parallel. Computers Multiple computers in different loca- tions but networked. Two computer with one or more processors or cores. Memory Each computer has its own memory. Computers can have shared or distributed memory. Communication Computers communicate through networks. Processes communicate through a bus or inter-process communication (IPC) methods. Benefits Failure of one computer does not affect the functioning of the task, as it is transferred to another computer. Provides scalability and reliability for end users. As multiple processes run in parallel, generally the performance increases.

--- Chunk 725 ---
Tokens: 380
Type: sentence-based
Text:
As multiple processes run in parallel, generally the performance increases. Failure of one processor does not affect the performance of other processors or cores Disadvantages Having multiple systems could become expensive; the cost must be weighed against customers need for application uptime. Network delays could affect the overall functioning of the task. Designing an efficient distributed computing system is relatively difficult. Using multiple processors or cores could be expensive. Dependency of one process on another process could introduce latency. Example Applications Telephone and cellular networks, internet, World Wide Web networks, distributed database management systems, network file systems, grid computing, cloud computing. 2D and 3D simulations and rendering in computer graphics, scientific computing. Example Programming Languages, libraries engines, framaworks Golang, Elixir, Scala, Fortran, C and C. Apache Hadoop, Apache Spark, Apache Flink, Apache Beam, CUDA, OpenCL, OpenHMPP, MPP, OpenMP for C, C and Fortran. Table 16.3. Comparison of Distributed and Parallel Programming COMPUTING FOUNDATIONS 16-15 community participation, such as Software Engineering Institute (SEI) Computer Emergency Response Team (CERT), as well as closed standards created by working groups such as the Motor Industry Software Reliability Association (MISRA). Educate programmers to follow adopted standards and guidelines. Use tools and periodic reviews to ensure adopted standards and guidelines are followed.

--- Chunk 726 ---
Tokens: 365
Type: sentence-based
Text:
Use tools and periodic reviews to ensure adopted standards and guidelines are followed. Review and revise standards and guide- lines from time to time, learning from project execution. SC 22 is a subcommittee of the Joint Technical Committee ISOIEC JTC 1 of the International Organization for Standardization (ISO) and the International Electrotechnical Commission (IEC) for defining standards for programming languages, their environments and system software interfaces (ISOIEC JTC 1SC 22). Software engineers are recom- mended to refer these standards as well. 5. Operating Systems 19 An operating system (OS) is software that manages the computers hardware and pro- vides a platform for software applications. Software engineers need a good general understanding of OSs and OS objectives, ser- vices, and functions. Different types of OSs have been designed over time to support various types of systems or applications, including batch processing, multiprogramming, time-sharing, and dual-mode operation  for protecting IO, memory, CPU, kernels and micro-kernels. To choose an appropriate OS, software engineers have to analyze different types of operating systems, such as single-user, sin- gle-tasking, multiuser, multitasking and multi-threading OSs; real-time OS (RTOS); network OS; and distributed OS. For small systems, an operating system may not be required. It is important to study examples of each type and compare their benefits and limitations.

--- Chunk 727 ---
Tokens: 358
Type: sentence-based
Text:
It is important to study examples of each type and compare their benefits and limitations. Software engineers need to understand operating systems basic structure, system architecture types, design approaches, the architecture of distributed OS and issues in distributed OS. An operating system typically has four major components: processor management, memory management, device management and information management. 5.1. Processor Management 19, C2, C8 Software engineers must understand the concepts of processor, process and address space. They must understand booting, pro- cesses, cores, threads, user and kernel threads, fork and exec, synchronization, and hardware support for locking. They should compare and contrast various CPU scheduling concepts, scheduling algorithms, algorithm evalua- tions, multiple processor scheduling and real- time scheduling, concurrent programming, deadlocks, critical regions, conditional crit- ical regions, and monitors. Communication among different pro- cesses is important in multitasking, mul- tiuser OSs. A software engineer must have a deep understanding of inter-process commu- nication (IPC), and types of IPCs, including messages, pipes, shared memory, semaphores, modularization and process synchronization. Various types of locks are used to ensure proper synchronization of data among pro- cesses, including semaphores, binary sema- phores, counting semaphores and mutex locks.

--- Chunk 728 ---
Tokens: 361
Type: sentence-based
Text:
Various types of locks are used to ensure proper synchronization of data among pro- cesses, including semaphores, binary sema- phores, counting semaphores and mutex locks. Deep understanding of common challenges of IPCs, deadlocks, deadlock scenarios, and deadlock characterization; prevention, avoid- ance, detection and recovery of deadlocks; and precedence graphs is critical and to be internalized with the help of case studies. Software engineers are required to study, with examples, concurrent languages, pro- cesses and scheduling, job and process con- cepts, and various types of scheduling: CPU-IO interleaving, non-preemption, con- text switching, and scheduling algorithms (first come, first served (FCFS), shortest job first (SJF), shortest remaining time first 16-16 SWEBOK  GUIDE V4.0 (SRTF), priority scheduling, round robin and combined schemes). 5.2. Memory Management 19, C3 A software engineer needs a very good under- standing of how memory is managed in the system and of the different types of memory and relevant concepts  physical memory, virtual memory, secondary memory, memory hierarchy, linking and memory allocation. Engineers must understand memory frag- mentation (both external fragmentation, internal fragmentation), and various memory management concepts, including units, paging, page tables, segmentation, paged segmentation, virtual memory management, demand paging, page replacement, thrashing and swapping.

--- Chunk 729 ---
Tokens: 375
Type: sentence-based
Text:
Engineers must understand memory frag- mentation (both external fragmentation, internal fragmentation), and various memory management concepts, including units, paging, page tables, segmentation, paged segmentation, virtual memory management, demand paging, page replacement, thrashing and swapping. Memory is allocated to processes in dif- ferent ways  for example, through contig- uous allocation, noncontiguous allocation, dynamic partitioned memory allocation, stat- ic-swapping and overlays. An understanding of logical addresses, partitions, static versus dynamic memory allocation, free space management, and defragmentation of memory blocks is also important. As the physical memory available is always limited, various memory page replacement strategies are designed and implemented. These strategies include first-in-first-out (FIFO), not-recently-used (NRU), least recently used (LRU), most recently used (MRU), least fre- quently used (LFU), most frequently used (MFU), longest distance first (LDF), second chance, and aging among others. 5.3. Device Management 19, C5 A software engineer must have good knowl- edge of different types of IO devices  mem- ory-mapped and IO-mapped devices, block and character devices, and buffering devices. Engineers should compare and contrast polled, interrupt-driven and direct memory access (DMA) IO devices, and blocking versus non-blocking IO devices. Device drivers are software programs that provide an interface between hardware and applications.

--- Chunk 730 ---
Tokens: 147
Type: sentence-based
Text:
Device drivers are software programs that provide an interface between hardware and applications. Software engineers should understand device drivers, the various types of device drivers, device driver tables, device driver functions, and interfaces for various types of hardware devices, as well as hard- ware and software interrupts and interfaces by interrupts and polling. Software engineers should also understand that issues with caching, scheduling, spooling and performance can arise for shared devices in multiuser, multitasking OSs and device a mechanism for resolving them. 5.4.

--- Chunk 731 ---
Tokens: 340
Type: sentence-based
Text:
5.4. Information Management 19, C4 Software engineers need to understand the following:  The concept of a process, a system pro- grammers view of processes, an operating systems view of processes, and operating system services for process management  File system management, storage manage- ment, file attributes, directory structure, file system structure, mass storage struc- ture, IO systems, protection and security  User and operating system views of the file system and various types of file systems  simple file system, symbolic file system, logical file system and physical file system Engineers should be familiar with various operations including access control lists (ACLs), access matrix, access control, access control ver- ification, capabilities allocation strategy, IO initiators, device strategy, device handlers, disk scheduling, disk space management, existence and concurrency control, schemes and com- bined schemes, authentication schemes, direc- tory namespace, hierarchies, directed acyclic graph (DAGs), hard and soft links. 5.5. Network Management 4, C4.1 Network management is the process of administering and managing various types of networks. This content area includes network COMPUTING FOUNDATIONS 16-17 management concepts, distributed objects, distributed file systems, and network archi- tecture, design, issues and resolutions.

--- Chunk 732 ---
Tokens: 393
Type: sentence-based
Text:
This content area includes network COMPUTING FOUNDATIONS 16-17 management concepts, distributed objects, distributed file systems, and network archi- tecture, design, issues and resolutions. A network manager will need detailed knowledge of physical and logical time, as well as internal and external synchroniza- tion protocols in network management such as Cristians algorithm, Berkeleys algorithm, the Network Time Protocol, Lamports log- ical clock, Vector clocks, Casual ordering of messages, and global state. Other important topics include distrib- uted computation, termination detection, distributed mutual exclusion and election, simple and multicast-based mutual exclusion algorithms; Centralized, Ring based, Ricart Agrawalas algorithm, Maekawas algorithm, Election algorithms, Bullys algorithm and multicast communication. In addition, software engineers should understand important principles include hard- ware security, external security, operational security, password protection, access control, security kernels, and the layered approach. 6. Database Management A database is a collection of related data ele- ments, collected specifically for use by one or more applications and stored in an organized format for easy and quick access, using one or more key values. The data items or elements are stored in one or more databases or files, and the relationship among them is estab- lished using a database schema. Basic operations performed on the database include creating the database and its elements (table, index, views, functions, procedures, etc.

--- Chunk 733 ---
Tokens: 364
Type: sentence-based
Text:
Basic operations performed on the database include creating the database and its elements (table, index, views, functions, procedures, etc. ), deleting or dropping items from the database, modifying contents and structure of the database, and data retrieval, comment, and rename actions. Different types of databases include rela- tional databases, not only structured query language (NoSQL) databases, columnar data- bases, object-oriented databases, key-value databases, document databases, hierarchical databases, graph databases, time series data- bases, and network databases. Understanding what type of database works best for specific applications and analyzing the definition, structure, specific pros and cons of each type of database; what along with examples helps software engineers choose the right type of database for a given application. When selecting a database, software engi- neer should evaluate data models, storage models, types of databases, key values, graphs, column family, volume of data, consistent data access time, and the number of users or appli- cations accessing the database (traffic), etc. The learners and users of the database system need to create two roles (database user and database architect), review several case studies of increasing complexity, create multiple data- bases, and analyze the information. This process significantly helps one to understand and inter- nalize the database design and management. 6.1.

--- Chunk 734 ---
Tokens: 369
Type: sentence-based
Text:
6.1. Schema 22, C2.1.4 A database schema is a structure or record of data items, defined in one or more database tables, and the relationships between them. The schema may also contain formulae to check the integrity of data items, relationships, indexes, functions or procedures and views. While a physical schema explains how the database is designed at physical level (files), the logical schema describes how different data items are defined in one or more tables and interconnected. Different types of schemata used in the industry include star, snowflake and fact con- stellation schemata. Different types of keys used in schemata include Primary Key, Secondary  Alternate Key, Foreign Key, Composite Key, Surrogate Key and Candidate Key. Parameters that influence the definition and use of schemata include overlap preserva- tion, extended overlap preservation, normal- ization and minimality. 6.2. Data Models and Storage Models 22, C2.3 A data model specifies the logical aspects of data structure in a data store, and a storage 16-18 SWEBOK  GUIDE V4.0 model specifies the physical aspects of data structure in a data store. It is difficult to achieve both data consistency and high avail- ability in a database. The two primary data models used to dis- tinguish databases are the following:  The ACID (atomicity, consistency, isola- tion, durability) model provides for high data consistency. ACID-compliant data- bases are ideal for a finance-intensive application.

--- Chunk 735 ---
Tokens: 352
Type: sentence-based
Text:
ACID-compliant data- bases are ideal for a finance-intensive application. The BASE (basically available, soft state, eventual consistency) model provides flexible methods to process data, which suits NoSQL database types. Types of storage models include the following: i. DAS (direct access storage): Storage devices are physically or directly con- nected to the computer that pro- cesses the data. ii. NAS (network access storage): Data is stored in a network and accessed by mul- tiple computers or applications. iii. SAN (storage area network): Data is stored in multiple servers and efficiently provided to users through a computer network. 6.3. Database Management Systems 22, C1.3 Database management systems (DBMSs) are software systems that provide the necessary tools for maintaining data optimally, retrieving stored information effectively, protecting and securing stored data, and managing access for users of different levels of authority. Typical DBMSs include:  A database engine: This is the core of a DBMS. The database engine manages efficient storing and retrieving of data. Users with privileges can access the data- base engine. A database manager: This program or set of programs performs all DBMS func- tionality in a database (creating, purging, backing up, retrieving, maintaining, cloning and deleting data). It is also responsible for maintaining the DBMS with patches and updates.

--- Chunk 736 ---
Tokens: 353
Type: sentence-based
Text:
It is also responsible for maintaining the DBMS with patches and updates. A runtime database manager (RDM): The RDM checks for user authentica- tion and privileges before any operation is performed, provides access to a con- text-based database, provides concurrent access to the database by multiple users, and ensures data integrity. Database languages: These help in storing, retrieving, modifying and retrieving data, controlling user access (privileges), speci- fying schemata and views, and performing various operations. Popular database lan- guages include data definition language (DDL), database access language (DAL), data manipulation language (DML), Transaction Control Language (TCL), and data control languages (DCL),  A query processor: This basic and key com- ponent of DBMS provides an effective, rich and English-like interface for users to access the database and perform var- ious functions or operations. Reporting: Reporting applies specified fil- ters, extracts requested data and records from one or more database tables, and presents information as specified. Several free and open-source database management systems are available. 6.4. Relational Database Management Systems and Normalization 22, C4 Conventional file system-based databases suffered from data redundancy, data incon- sistency, data access challenges, unautho- rized access, lack of concurrent access, among other issues.

--- Chunk 737 ---
Tokens: 376
Type: sentence-based
Text:
Relational Database Management Systems and Normalization 22, C4 Conventional file system-based databases suffered from data redundancy, data incon- sistency, data access challenges, unautho- rized access, lack of concurrent access, among other issues. A relational database management system (RDBMS) stores data in tables and, unlike in a DBMS, its data tables relate to one another, multiple data items can be accessed simulta- neously, a large amount of data is handled, multiple users can access data concurrently, data redundancy is significantly reduced, and COMPUTING FOUNDATIONS 16-19 multiple levels of data security are supported. Computer science engineers must under- stand the difference between the various types of RDBMS, such as Objective RDBMS, Object Oriented RDBMS, be familiar with examples, and know the applications they suit best. Database normalization is the process of organizing data in a database and removing data redundancy and data inconsistency from the tables. Normalization might increase the number of tables and increase the query time. If this occurs, then  depending on the application and the requirement  de-nor- malization is applied, where data redundancy is added for quicker data access. Different types of database normalizations are the following: i. First normal form (1 NF): Removes dupli- cation or redundancy. Each table cell has a single value (creates more entries and tables). Each row has unique values. Related data is identified with a unique key. ii.

--- Chunk 738 ---
Tokens: 374
Type: sentence-based
Text:
ii. Second normal form (2 NF): The table should be in 1 NF; no partial dependency (creates separate tables with records refer- enced by multiple records or tables). iii. Third normal form (3 NF): The table should be in 2 NF. Transitive dependen- cies are removed. iv. Boyce-Codd normal form (BCNF3.5 NF): The table should be in 3 NF, and X should be the super-key for any (X-Y). v. Fourth normal form (4 NF): The table should be in 3.5 NF and should not have a multivalued dependency. vi. Fifth normal form (5 NF): The table should be in 4 NF and cannot be split into any more tables without losing data. vii. Sixth normal form or domainkey normal form (6 NFDKNF): The table should be in 5 NF, and every join dependency is trivial. Most databases are typically normalized until 3 NF or BCNF. An alternative normal form, DKNF, is defined where insertion and deletion of anomalies is avoided (see 13). Database engineers are encouraged to understand normalization forms with examples and case studies and to understand the challenges one would face if the database were not normalized. Although normaliza- tion is essential and provides various benefits, it also increases the number of tables and pro- cessing time. 6.5. Structured Query Language 22, C6, C7, C8 Structured query language (SQL) is a stan- dard and popular database language for cre- ating, updating, and deleting databases and for retrieving information from databases. SQL is an inevitable part of most database management systems.

--- Chunk 739 ---
Tokens: 384
Type: sentence-based
Text:
SQL is an inevitable part of most database management systems. Typical SQL syntax has several language constructs or elements, including clauses, expressions, predicates, queries and statements. All operations on a database, including cre- ating, updating, deleting and viewing tables; performing different normalizations; purging data; and searching through the database based on various combinations of parameters or filters, can be performed using SQL. Most databases support SQL (except NoSQL databases), and the SQL syntax and library of functions supported vary across database providers (much like programming languages  though different languages sup- port similar features, the syntaxes vary). Database engineers also have to decide whether to use staticembedded SQL, dynamic SQL or a combination of the two, after weighing the pros and cons of each option for the particular application. They should also know the differences between simple and complex views and use them appropriately. SQL is standardized and adopted by the American National Standards Institute (ANSI) and ISO. The standards are revised from time to time; the first SQL standard was SQL-86, issued in 1986, and the most recent is SQL:2019. 6.6. Data Mining and Data Warehousing 22, C34 Databases are designed to store transactions and retrieve them efficiently. 16-20 SWEBOK  GUIDE V4.0 Data warehousing extracts data from mul- tiple databases efficiently and stores it in a common database so data mining can be per- formed effectively on the compiled data.

--- Chunk 740 ---
Tokens: 387
Type: sentence-based
Text:
16-20 SWEBOK  GUIDE V4.0 Data warehousing extracts data from mul- tiple databases efficiently and stores it in a common database so data mining can be per- formed effectively on the compiled data. Data warehouses are typically huge, as they store historical data records. Data mining extracts requested informa- tion from the data warehouse, applying var- ious filters and conditions. Data mining applies pattern recognition algorithms to huge data sets to generate required reports. The different types of warehouses include enterprise data warehouse (EDW), operational data store (ODS), and data mart (DM). Many efficient tools are available to create data warehouses and mine data from them. Database engineers must know different data mining techniques, including associa- tion, clustering, classification, sequential pat- terns and prediction, and know how to apply them for various uses and industries, such as health care, fraud detection, customer rela- tionship management, finance and banking, anomaly detection, prediction, neural net- works, statistics, and data visualization. 6.7. Database Backup and Recovery 22, C22 Database systems are prone to failures, and data can be corrupted. It is crucial to prevent data corruption and  if it does occur  to recognize it immediately and recover the data. Updating the database for transactions must be carried out carefully (with commits at specific checkpoints), and must incorporate techniques such as undoing, deferred updates, immediate updates, caching or buffering, and shadow paging.

--- Chunk 741 ---
Tokens: 397
Type: sentence-based
Text:
Updating the database for transactions must be carried out carefully (with commits at specific checkpoints), and must incorporate techniques such as undoing, deferred updates, immediate updates, caching or buffering, and shadow paging. Databases must be backed up periodi- cally to ensure data safety. Backup techniques include Full database backup, Differential backup and Transaction log backup. 7. Computer Networks and Communications 4, C4.1, 24, C1 A computer network is a group of devices that are connected for sharing information. The connected devices (nodes on the network) can be located near one another, on the same premises, or somewhere else. Networking is required for certain benefits, including cer- tain modes of communication and infor- mation sharing; the ability to share devices such as printers, routers and video cameras; global information and data storing; security and policy enforcement; remote monitoring; shared business models; and web browsing. As we are in the internet era, computer net- working is a critical element in computing, and the practitioners of computer science engineering have to study computer networks and commu- nication concepts, including examples and case studies. Many computing paradigms (distrib- uted computing, grid computing, cloud com- puting, etc.) are based on networking principles. It is important for software engineers to understand the following:  Different types of computer networks. Layered architectures of networks. Open systems interconnect (OSI) layers  Encapsulation and decapsulation. Application layer protocols.

--- Chunk 742 ---
Tokens: 384
Type: sentence-based
Text:
Application layer protocols. Design techniques for reliable and effi- cient networking. Internet and packet delivery. Wireless and mobile networks. Security and vulnerabilities. 7.1. Types of Computer Networks 4, C4.1, 24, C1.2.1 Different types of computer networks are designed and used based on the need, such as the following: 1. Personal area network (PAN)  home network. 2. Local area network (LAN). 3. Wireless local area network (WLAN). 4. Wide area network (WAN). 5. Campus area network (CAN). 6. Metropolitan area network (MAN). 7. Storage area network (SAN). 8. System-area network (SAN). 9. Enterprise private network (EPN). 10. Virtual private network (VPN). COMPUTING FOUNDATIONS 16-21 It is important to understand each of the above network type as well as examples, ben- efits, limitations and available solutions to cir- cumvent challenges. 7.2. Layered Architectures of Networks 24, C1.5 A communication system includes hardware and software, and these components have become complex to meet complicated use scenarios and user demands. To support the implementation and maintenance of such sys- tems, ISO has developed a layered approach, where every layer has specific functionality for processing data and transferring it from one node to another. Each layer is independent in its function- ality and provides services from the lower layer to the upper layer without providing details of how each layers service is imple- mented. Each layer (n) on a machine com- municates with the same layer (n) on the peer machine.

--- Chunk 743 ---
Tokens: 365
Type: sentence-based
Text:
Each layer (n) on a machine com- municates with the same layer (n) on the peer machine. Rules used in a conversation are called layer-n protocol (see Figure 16.4). The basic elements of the layered approach are service, protocol and interface. Service: The set of actions a layer provides to the adjacent higher layer is the service. Protocol: The set of rules a layer uses to exchange information with the peer entity is called the protocol. The rules are primarily for managing both the contents and order of the messages used. Interface: The interface provides a medium for transferring the message from one layer to another layer. Software engineers are expected to under- stand the essential functionalities required, various modes in which the data or information is communicated from one layer to the other, and data packet formation and interpretation at peer levels. A useful exercise is to take exam- ples of different protocols and analyze them. 7.3. Open Systems Interconnection Model 24, C1.5 The Open Systems Interconnection (OSI) Model was defined by the ISO. It serves as a reference model for information exchange between applications on two systems or com- puters through a physical medium. Layer 5 (Application Layer) Layer 5 (Application Layer) Layer 4 Layer 4 Layer 3 Layer 3 Layer 2 Layer 2 Layer 1 (Physical Layer) Layer 1 (Physical Layer) Layer 5 Protocol Layer 4 Protocol Layer 3 Protocol Layer 2 Protocol Layer 1 Protocol Figure 16.4.

--- Chunk 744 ---
Tokens: 365
Type: sentence-based
Text:
Layer 5 (Application Layer) Layer 5 (Application Layer) Layer 4 Layer 4 Layer 3 Layer 3 Layer 2 Layer 2 Layer 1 (Physical Layer) Layer 1 (Physical Layer) Layer 5 Protocol Layer 4 Protocol Layer 3 Protocol Layer 2 Protocol Layer 1 Protocol Figure 16.4. Pictorial Representation of Layered Networking 16-22 SWEBOK  GUIDE V4.0 OSI proposes seven (7) layers, and each layer is assigned a specific task. Each layer independently processes the data it receives from the upper or lower layer and passes it to the lower or upper layer, as appropriate. Engineers must understand each OSI layer, its functionality protocol, the input and output of each layer in each direction (from lower layer to upper layer and vice versa). Engineers should analyze whether all seven layers are required for all proto- cols and what is necessary to optimize for performance. 1. Physical Layer (Layer 1). 2. Data Link Layer (Layer 2). 3. Network Layer (Layer 3). 4. Transport Layer (Layer 4). 5. Session Layer (Layer 5). 6. Presentation Layer (Layer 6). 7. Application Layer (Layer 7). Engineers must understand the nuances of each layer, with examples. 7.4. Encapsulation and Decapsulation 24, C1.5.2 Each layer, while sending data from the upper layer to the lower layer, inserts additional information at the beginning (header) and optionally at the end of the data packet received from the upper layer, treating the packet received from the upper layer as data. This is encapsulation.

--- Chunk 745 ---
Tokens: 376
Type: sentence-based
Text:
This is encapsulation. The protocol data unit (PDU), which is the data packet containing additional informa- tion from all layers, is sent to the receiving system. At the receiving end, each layer extracts its header from the PDU, deciphers the information to treat the data appropri- ately, and sends the remaining PDU to the upper layer. Learning about cross-layer optimization, the principles to which it must adhere, and its applications is important. Engineers should analyze the PDU structures of each layer of OSI, the Internet protocol suite and the asyn- chronous transfer mode (ATM). 7.5. Application Layer Protocols 24, C2 The application layer, being the top most layer, provides services and interfaces to interact with users application. There are two types of appli- cation layers in the OSI model: common appli- cation service element (CASE) and specific application service element (SASE). Example applications include file transfer (FTP, TFTP, NFS), remote login (Telnet, Zoho Assist, Anydesk, TeamViewer, etc), e-mail (SMTP) networking support (DNS), network manage- ment (SNMP, DHCP), devices (LPD), etc. Software engineers practicing in a net- working domain need to understand CASE and SASE application services, including example applications in each category. 7.6. Design Techniques for Reliable and Efficient Network 24, C1.5 Todays information technology-based busi- nesses need around-the-clock, reliable, effi- cient and scalable networks and high-speed internet availability.

--- Chunk 746 ---
Tokens: 393
Type: sentence-based
Text:
Design Techniques for Reliable and Efficient Network 24, C1.5 Todays information technology-based busi- nesses need around-the-clock, reliable, effi- cient and scalable networks and high-speed internet availability. Catering to varied busi- ness needs, the networks and their manage- ment has become complex as well. It is critical to identify network require- ments (both business goals and technical solu- tions) along with a road map (scalability). The fundamental design goals should include reli- ability, security, availability and manageability. Engineers should expect threats and intrusions at multiple levels and design security at mul- tiple levels. Systems must be set up to monitor the networks for both proper functioning and malfunctioning; identify faults, vulnerabilities and hacks quickly; and fix them. Engineers must understand and learn the nuances of designing a network while using appropriate firewalls, LANVLANs, subnets, quality of service (QoS), Demilitarized Zone (DMZ), Spanning Tree (especially for hier- archical network), port or network interface controller (NIC) channel, security (both poll security and physical security), wireless access points, and wireless access controllers. Even when the design and implementation are well planned and executed, one has to be COMPUTING FOUNDATIONS 16-23 constantly vigilant for attacks and continuously upgrade to better systems, devices and tools. 7.7. Internet Protocol Suite 24, C3 Data is transmitted in packets from one com- puter to another, either in the same network or in a different one.

--- Chunk 747 ---
Tokens: 391
Type: sentence-based
Text:
Internet Protocol Suite 24, C3 Data is transmitted in packets from one com- puter to another, either in the same network or in a different one. The Internet Protocol suite, or TCPIP, defines data communi- cation between two computers connected via the internet. The top three layers of the OSI model (Application, Presentation and Session layers) are merged into the applica- tion layer, and the network layer is revised specifically for internet functioning. Internet Protocol is the fulcrum of todays internet or network layer. Multiple variations of Internet Protocols are designed and used for different purposes. The protocols include TCPIP (Transmission Control ProtocolInternet Protocol), UDPIP (User Datagram protocol  Internet Protocol), SMTP (Simple Mail Transfer Protocol), PPP (Point to Point Protocol), FTP File Transfer Protocol, SFTP (Secure FTP), HTTP (Hyper Text Transfer Protocol), HTTPS (HTTP Secure), Telnet (Terminal Network), PoP3 (Post office Protocol 3), VOIP (Voice over Internet Protocol), SLIP (Serial Line Internet Protocol). It is important to know the differences between these along with use cases (applications where each type is used or where it works best). Mobile Internet Protocol is a communi- cations protocol that conforms to an IETF (Internet Engineering Task Force) standard and allows users to move their mobile devices (laptops, mobile phones, etc.) seamlessly from one network to the other without changing the IP address. Internet Protocol Version 4 (IPV4) uses a 32-bit IP address, whereas IPV6 uses 128-bit IP addresses.

--- Chunk 748 ---
Tokens: 363
Type: sentence-based
Text:
Internet Protocol Version 4 (IPV4) uses a 32-bit IP address, whereas IPV6 uses 128-bit IP addresses. Private IP addresses are translated into public IP addresses using either NAT (net- work address translation) or PAT (port address translation). Both use IPV4, but PAT uses port numbers. Different technologies used to communicate between IPV4 and IPV6 devices include dual-stack routers, tunneling and NAT protocol translators. Professional computer network architects and programmers need to understand IPV6 addressing, routing, transitioning to IPV6 from IPV4, dual-dress stacks, tunneling and NAT64. 7.8. Wireless and Mobile Networks c24, C7 Wireless networks provide the ability for devices to connect and communicate without the hassle of wires and cables. They also pro- vide flexibility and ease of using the devices. Different wireless technologies are used for different applications:  Wireless personal area networks (WPAN). Wireless local area networks (WLAN) . Wireless wide area networks (WWAN). A mobile or cellular network is a radio network spread over a specific area of land (called a cell). The cells are served by base sta- tions, which are fixed-location transceivers. To avoid interference and ensure guaran- teed bandwidth, the adjacent cells use a dif- ferent set of frequencies. These cells, when connected, provide wide area radio coverage. The cell patterns take different shapes, but squares, circles and hexagons are typical.

--- Chunk 749 ---
Tokens: 398
Type: sentence-based
Text:
The cell patterns take different shapes, but squares, circles and hexagons are typical. Different methods of data transmission are used between channels, such as frequency division multiple access (FDMA), time divi- sion multiple access (TDMA), code division multiple access (CDMA), space division mul- tiple access (SDMA), etc. Wireless technology has evolved over sev- eral generations. Software Engineers are encouraged to learn the differences among 1G, 2G, 3G, 4G and 5G technologies, along with the core network, access system, frequency, bandwidth and technologies used in each. 7.9. Security and Vulnerabilities 24, C9 Although wireless technology provides the ease of connecting seamlessly to the network, it is also prone to attacks unless the network is secured. Risks to unsecured wireless networks 16-24 SWEBOK  GUIDE V4.0 include Piggybacking, Wardriving, Evil Twins attacks, Wireless sniffing, Unauthorized com- puter access, Shoulder sniffing and Theft of mobile devices. Communication over the internet via mobile device is highly vulnerable to cyber- attacks. In addition to wardriving, mentioned above, typical wireless and mobile device attacks include SMiShing, War driving, WEP attacks, WPA attacks, Bluejacking, Reply attacks, Blue snarfing, RF Jamming, etc. Many precautionary measures must be implemented and strictly followed to reduce such risks. These measures include changing default passwords, changing passwords fre- quently, restricting access to authorized users, encrypting data in the system and on the network, and installing multiple levels of firewalls.

--- Chunk 750 ---
Tokens: 384
Type: sentence-based
Text:
These measures include changing default passwords, changing passwords fre- quently, restricting access to authorized users, encrypting data in the system and on the network, and installing multiple levels of firewalls. In addition, users must protect and hide (not publicize) service set identifier (SSID), use effective antivirus software, and update and upgrade it regularly; use a virtual private networks (VPN), use file-sharing or system-sharing access with care, and disable access after use; and update or upgrade the access point or access controller, gateway and other devices with security patches when they become available. 8. User and Developer Human Factors The thought processes and behaviors of soft- ware developers typically differ from that of software users. This content area identifies salient parameters that matter for end users as well as the perspective of the developers. Human-computer interface (HCI) focuses on designing and developing computer technology for users to interact with com- puting systems. User satisfaction is measured in terms of user experience (UX). An ideal interface would facilitate interaction that is as natural as the interaction between two human beings. 8.1. User Human Factors 3, C8 Users expect software to be robust; to have an intuitive graphical user interface (GUI) that guides the user through minimal, intelligent, easy-to-follow steps to achieve the end result; to be secure; and to provide fast, consistent responses. The interface should help users use the system easily.

--- Chunk 751 ---
Tokens: 391
Type: sentence-based
Text:
The interface should help users use the system easily. The interface should be self-ex- planatory and enable self-learning. The mes- sages, whether communicating results or errors, should be clear and complete. The system should be able to regain its original state if there are errors. The system should allow users to interrupt during the processing and undo the operation, wherever possible. The software engineer needs to identify the profile of users the system; systems func- tionality, input and output interfaces users use (keyboard, touch pad, audio, video, etc.) to interact with the system, the systems fault tolerance, the systems performance parame- ters. among others. Typically, user interface development goes through several iterations, starting with a proto- type. The user interface devices must be robust. 8.2. Developer Human Factors 3, C31 - C32 The software lives much longer than the time taken to develop. Invariably, the software engineers who maintain the code are different from those who develop. Hence, the code has to be written with more care and for use by other programmer  software engineer. Meaningful and comprehensive docu- mentation is crucial at all stages of software lifecycle. Defining and adopting apt coding stan- dard for the project, and ensuring every team member implements the same in spirit is key for developing clean code that lives longer with minimal maintenance. Programming style is another key ingre- dient of a good code. Code has to be legible, should be like reading a good poem and easily comprehendible.

--- Chunk 752 ---
Tokens: 383
Type: sentence-based
Text:
Code has to be legible, should be like reading a good poem and easily comprehendible. Using meaningful, consis- tent and detailed comments is essential to ensure code readability. Other traits of a good software pro- grammer include being a team player, enjoy COMPUTING FOUNDATIONS 16-25 solving puzzles creatively, be agile, be struc- tured  modular among others. Good coding standards include defining naming conventions for various types of vari- ables, functionsprocedures, comment struc- turestyles, indentation styles, structuring the code into paragraphs (of related functions), etc. Code is read many more times than it is written. Consider whether write-time conve- nience is a false economy  Steve McConnell Clean code always looks like it was written by someone who cares  Robert (Uncle Bob) Martin 9. Artificial Intelligence and Machine Learning 17 Intelligence is the ability to acquire and cor- relate information and knowledge to make a correct decision for a specific task. Artificial intelligence (AI) enables computer systems to become intelligent, like human beings. Machine learning (ML) enables computer sys- tems to learn from experiences and to use the knowledge gained to make smart decisions  to become artificially intelligent. Deep learning uses artificial neural network models for learning and making predictions. Everyone expects all systems they use to be smart, reliable, consistent, secure and fault-tolerant  and to get better every day. AI and ML work toward enabling systems to accomplish all this.

--- Chunk 753 ---
Tokens: 378
Type: sentence-based
Text:
AI and ML work toward enabling systems to accomplish all this. An ideal AI system would be one that a human could not identify it as a computer; humans would not be able to distinguish the computer from a human being. Several tools have been developed and are available for creating AI systems. Using proven tools helps engineers build a stable system faster. 9.1. Reasoning Reasoning means analyzing sets of informa- tion available for a given situation and deter- mining the cause of the situation. Reaching this conclusion is an important ability of AI, as the conclusion informs AIs decision about what to do next. Different types of reasoning used in AI include the following: Deductive Reasoning is a standard and stra- tegic approach to mapping available facts, information and knowledge to arrive at a con- clusion. In this approach, available facts and information are considered to be authentic. For example, if the premises are All girls are beautiful and Michu is a girl, then the con- clusion is Michu is beautiful. Inductive Reasoning is about introducing a hypothesis and creating generalizations from the available facts and premises. Unlike deduc- tive reasoning, in inductive reasoning, even if the premises are certain, the conclusion would be probable, depending on whether the induc- tive argument is strong or weak. For example, check the location of all engineers working on a project and if they are from Bengaluru, India state All employees working on the gaming project are from Bengaluru.

--- Chunk 754 ---
Tokens: 396
Type: sentence-based
Text:
For example, check the location of all engineers working on a project and if they are from Bengaluru, India state All employees working on the gaming project are from Bengaluru. Abductive Reasoning starts with an incom- plete set of data or information and proceeds to derive the most likely conclusion from the latest data. For example, a doctor analyzes the latest lab reports of a patient to predict the course of the disease. Common Sense Reasoning makes inferences about situations based on similar past expe- riences. For example, if a motorcycle skids while driving on a wet road, that informa- tion is remembered and considered during future rides. Monotonic Reasoning occurs when the con- clusion remains permanent or constant after it is reached. For example, The Himalayas are one of the tallest mountain ranges. Non-Monotonic Reasoning (NMR) occurs when the inference changes values or direc- tion based on new knowledge or information. NMR is based on assumptions and deals with 16-26 SWEBOK  GUIDE V4.0 incomplete or not-known facts. For example, the rule is Birds fly. But a few birds do not fly including penguins. Software engineers are encouraged to learn other reasoning methods, such as metalevel reasoning, procedural numeric reasoning, and formal reasoning, as well. 9.2. Learning We learn from our observations, experiments and experiences. Enabling computers to learn and to remember what theyve learned for future use is critical for building AI sys- tems. An AI system learns when observations and outcomes of experiments (signals) are fed back into the system.

--- Chunk 755 ---
Tokens: 331
Type: sentence-based
Text:
An AI system learns when observations and outcomes of experiments (signals) are fed back into the system. Different types of learning include the following: Supervised Learning, the computer system trains by receiving labeled (i.e, training) data. Subsequently, when any input is provided, the system compares it with the data it was trained on and generates output. Naturally, the more training data, the better the out- come. Supervised learning uses multiple learning techniques, including the classifica- tion technique and the regression technique. Supervised learning may not be able to handle complex tasks. Unsupervised Learning, labeled or training data is not provided to the system. The system has to figure out common patterns from the input given and make inferences. The data is analyzed in real time. Semi-supervised Learning, the system is trained with partly labeled and partly unla- beled data. This type of learning has been shown to be effective. Reinforcement Learning is based on inter- actions with the environment. In this type of learning, the system receives feedback (an error message or a reward) and learns from that feedback. No data is provided to the system (neither labeled nor unlabeled). Various algorithms are produced in reinforced learning. This is a trial-and-error method for learning.

--- Chunk 756 ---
Tokens: 375
Type: sentence-based
Text:
This is a trial-and-error method for learning. Software engineers working on AI are expected to know various other learning techniques as well, including dimension- ality reduction learning, self-learning, feature learning, sparse learning, anomaly detection and robot learning, along with the key differ- ences between the methods and the applica- tions where each method works well. 9.3. Models AI models are inference engines or tools (algorithms) that can arrive at the best deci- sions based on relevant data. Different models are created to enable effi- cient ML, with or without training data. Models used in ML include the following: Linear Regression model is based on super- vised learning, where the relationship between input and output variables is determined and used. This model is commonly used in health care and banking applications. Logistic Regression model is a statistical model primarily used for classifying dependent variables from given independent variables. Artificial Neural Networks are inspired by biological neural networks in a brain. The sys- tems are designed to learn naturally from the inputs without specific rules. Decision Tree model is used where past deci- sions are used to arrive at a decision. The name tree is used because the data is stored in the form of a tree. Nave Bayes model works on the assumption that the presence of a feature does not depend on the presence of any other feature. Spam filtering is one of the applications that suits this model.

--- Chunk 757 ---
Tokens: 398
Type: sentence-based
Text:
Spam filtering is one of the applications that suits this model. Support Vector Machine (SVM), is a super- vised ML algorithm used to analyze a limited quantum of data. SVM is typically faster than COMPUTING FOUNDATIONS 16-27 artificial neural networks because it works with limited data. Random Forest model uses multiple decision trees for making a final decision. The random forest model is useful for solving both regres- sion and classification problems. AI models are key to making the most appropriate decisions. As different models suit specific applications or domains, software engineers are encouraged to learn many other AI models as well, such as Linear Discriminant Analysis, Learning Vector Quantization, K-nearest Neighbors (KNN), etc. 9.4. Perception and Problem-Solving Solving a problem efficiently and quickly is the goal of AI. Problem-solving predomi- nantly comprises understanding user com- mands and executing them, as humans do. Depending on the application and problem to be solved, AI systems use the relevant knowl- edge base and predicate logic to identify the most appropriate solution. AI systems dealing with the external world, obtain environmental data through sensors (cameras; microphones; temperature, pres- sure and light sensors, etc. ), analyzes the data using its knowledge base or inference engine, and acts upon it. Based on capabilities and functionality, AI systems are categorized into multiple types. Type I AI systems are designed to do specific tasks with intelligence. Examples include Chess games, speech and image rec- ognition, among others.

--- Chunk 758 ---
Tokens: 378
Type: sentence-based
Text:
Examples include Chess games, speech and image rec- ognition, among others. Type II AI systems analyze the current sit- uation or environment and do not normally refer to previous decisions made in a similar situation to arrive at an appropriate action. Reactive systems or reactive machines typically make decisions and execute commands at that instance, referring to the existing knowledge base. A good example is a self-driving cars. Type III, or self-aware, AI systems have consciousness and are mindful. These systems adopt the mind theory and predict the mood of the other person or entity based on the persons action or type of action. For example, if the driver in the vehicle behind the system honks, then the AI system might conclude that the driver is angry or unhappy. Social and ethical behavior is part of conscious systems. 9.5. Natural Language Processing Natural language processing (NLP) is a crucial part of AI systems, enabling users to interact with the AI systems in a way that is similar to how they interact with other humans. AI sys- tems understand human languages and exe- cute commands delivered in those languages. AI systems that work on voice commands need to understand not only the human language, but also the slang or pronunciation of the user. 9.6. AI and Software Engineering Software engineering and AI are mutually related to each other in basically two ways: AI applications in software engineering (i.e, AI for SE) and software engineering for AI sys- tems (i.e, SE for AI).

--- Chunk 759 ---
Tokens: 384
Type: sentence-based
Text:
AI and Software Engineering Software engineering and AI are mutually related to each other in basically two ways: AI applications in software engineering (i.e, AI for SE) and software engineering for AI sys- tems (i.e, SE for AI). AI for SE aims to establish efficient ways of building high-quality software systems by replicating human developers behavior. It ranges over almost all development stages, from resolving ambiguous requirements to predicting maintainability, particularly well applied in software quality assurance and analytics, such as defect prediction, test case generation, vulnerability analysis, and pro- cess assessment 15. Although human-cen- tric software engineering activities benefit, engineers should be aware of limitations and challenges inherent to the nature of AI and ML, especially the uncertain and stochastic behavior and the necessity of sufficiently labeled and structured datasets 15. The development of AI systems is different from traditional software systems since the rules and system behavior of AI systems are inferred from training data rather than written down as program code 16. Thus, there is a need for particular support of SE for AI, such as interdisciplinary collaborative teams of data scientists and software engineers, software 16-28 SWEBOK  GUIDE V4.0 evolution focusing on large and changing datasets, and ethics and equity requirements engineering 16. Recommended software engineering practices for AI are often formal- ized as patterns, such as ML software design patterns 17.

--- Chunk 760 ---
Tokens: 352
Type: sentence-based
Text:
Recommended software engineering practices for AI are often formal- ized as patterns, such as ML software design patterns 17. MATRIX OF TOPICS VS. REFERENCE MATERIAL Topics Tanenbaum, Bos 19 CLRS 18 H.Washizaki 17 Horowitz et al. 2007 5 S McConnell 3 Sommerville 2011 6 L. Null and J. Lobur 8 Articles and Journals J.G. Brookshear 4 Thomas Connolly, Carolyn Begg 22 Kurose  Ross 24 1. Basic Concept of a System or Solution C10 2. Computer Architecture and Organization 2.1 Computer Architecture C1.1 2.2 Types of Computer Architecture C4.14, C5 2.2.1 Von Neumann Architecture C1.9 2.2.2 Harward Architecture 20 2.2.3 Instruction Set Architecture C4.8.3 2.2.4 Flynns Architecture or Taxonomy C9.3 2.2.5 System Architecture C6 C6 2.3 Micro Architecture or Computer Organization C4 2.3.1 Arithmetic Logic Unit C1.2 2.3.2 Memory Unit C6 2.3.3 Input  Output Unit C7 COMPUTING FOUNDATIONS 16-29 2.3.4 Control Unit C4.2 3. Data Structures and Algorithms c10, Part V C2 3.1 Types of Data Structures c10 S2.1-2.6 3.2 Operations on Data Structures S2.1-2.6 3.3 Algorithms and Attributes of Algorithms c26, c27 3.4 Algorithm Complexity s1.11.3, s3.33.6, s4.14.8, s5.15.7, s6.16.3, 7.6, s11.1, s12.1 3.5 Measurement of Complexity s1.1s3.3 3.6, s4.14.8, s5.15.7, s6.16.3, s7.17.6, s11.1, s12.1 3.6 Designing Algorithms Part IV, Part VII 3.7 Sorting Techniques c6, c7, c8, c9 3.8 Searching Techniques C6 3.9 Hashing c11.2 4.

--- Chunk 761 ---
Tokens: 328
Type: sentence-based
Text:
Data Structures and Algorithms c10, Part V C2 3.1 Types of Data Structures c10 S2.1-2.6 3.2 Operations on Data Structures S2.1-2.6 3.3 Algorithms and Attributes of Algorithms c26, c27 3.4 Algorithm Complexity s1.11.3, s3.33.6, s4.14.8, s5.15.7, s6.16.3, 7.6, s11.1, s12.1 3.5 Measurement of Complexity s1.1s3.3 3.6, s4.14.8, s5.15.7, s6.16.3, s7.17.6, s11.1, s12.1 3.6 Designing Algorithms Part IV, Part VII 3.7 Sorting Techniques c6, c7, c8, c9 3.8 Searching Techniques C6 3.9 Hashing c11.2 4. Programming Fundamentals and Languages C6 4.1 Programming Language Types C8.4.4 4.2 Programming Syntax, Semantics, Type Systems C8.4.4 4.3 Subprograms and Coroutines C6.3 16-30 SWEBOK  GUIDE V4.0 4.4 Object- Oriented Programming C6.5 4.5 Distributed Programming and Parallel Programming C6.6 4.6 Debugging C2.2.2 4.7 Standards and Guidelines C28.5, C31.5 5. Operating Systems 5.1 Processor Management c2, c8 5.2 Memory Management c3 5.3 Device Management c5 5.4 Information Management c4 5.5 Network Management C4.1 6. Database Management 6.1 Schema C2.1.4 6.2 Data Models and Storage Models C2.3 6.3 Database Management Systems C1.3 6.4 Relational Database Management Systems and Normalization C4 6.5 Structured Query Language C6, C7, C8 6.6 Data Mining and Data Warehousing C34 6.7 Database Backup and Recovery C22 7.

--- Chunk 762 ---
Tokens: 386
Type: sentence-based
Text:
Database Management 6.1 Schema C2.1.4 6.2 Data Models and Storage Models C2.3 6.3 Database Management Systems C1.3 6.4 Relational Database Management Systems and Normalization C4 6.5 Structured Query Language C6, C7, C8 6.6 Data Mining and Data Warehousing C34 6.7 Database Backup and Recovery C22 7. Computer Networks and Communications C4.1 C1 7.1 Types of Computer Networks C4.1 C1.2.1 COMPUTING FOUNDATIONS 16-31 7.2 Layered Architecture of Networks C1.5 7.3 Open Systems Interconnection Model C1.5 7.4 Encapsulation and Decapsulation C1.5.2 7.5 Application Layer Protocols C2 7.6 Design Techniques for Reliable and Efficient Network C1.5 7.7 Internet Protocol Suite C3 7.8 Wireless and Mobile Networks C7 7.9 Security and Vulnerabilities C8 8. User and Developer Human Factors 8.1 User Human Factors c8 8.2. Developer Human Factors c31- c32 9. Artificial Intelligence and Machine Learning C1 9.1 Reasoning 9.2 Learning 9.3 Models 9.4 Perception and Problem-Solving 9.5 Natural Language Processing 9.6 AI and Software Engineering 16-32 SWEBOK  GUIDE V4.0 REFERENCES 1 Joint Task Force on Computing Curricula, IEEE Computer Society and Association for Computing Machinery, Software Engineering 2014: Curriculum Guidelines for Undergraduate Degree Programs in Software Engineering, 2014; http:sites.computer.orgccse SE2004Volume.pdf. 2 G. Voland, Engineering by Design, 2nd ed, Prentice Hall, 2003. 3 S. McConnell, Code Complete, 2nd ed, Microsoft Press, 2004. 4 J.G. Brookshear, Computer Science: An Overview, 12th ed, Addison- Wesley, 2017.

--- Chunk 763 ---
Tokens: 365
Type: sentence-based
Text:
Brookshear, Computer Science: An Overview, 12th ed, Addison- Wesley, 2017. 5 E. Horowitz et al, Computer Algorithms, 2nd ed, Silicon Press, 2007. 6 I. Sommerville, Software Engineering, 9th ed, Addison-Wesley, 2011. 7 ISOIECIEEE, ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, 2nd ed. 2017. 8 L. Null and J. Lobur, The Essentials of Computer Organization and Architecture, 5th ed, Jones and Bartlett Publishers, 2018. 9 J. Nielsen, Usability Engineering, Morgan Kaufmann, 1994. 10 ISO 9241-420:2011 Ergonomics of Human-System Interaction, ISO, 2011. 11 M. Bishop, Computer Security: Art and Science, 2nd ed, Addison-Wesley, 2018. 12 R.C. Seacord, The CERT C Secure Coding Standard, Addison-Wesley Professional, 2016. 13 R. Fagin, A Normal Form for Relational Databases that is based on Domains and Keys, ACM Transactions on Database Systems, Vol. 6, No. 3, ACM, September 1981 14 I. Goodfellow, Y. Bengio, A. Courville, Deep Learning (Adaptive Computation and Machine Learning series) Illustrated Edition, 2018. 15 S. Shafiq, A. Mashkoor, C. Mayr- Dorn, A. Egyed, A Literature Review of Using Machine Learning in Software Development Life Cycle Stages, IEEE Access, Volume 9, IEEE, October 2021. 16 S. Martnez-Fernndez, J. Bogner, X. Franch, M. Oriol, J. Siebert, A. Trendowicz, A. M. Vollmer, Software Engineering for AI-Based Systems: A Survey, ACM Transactions on Software Engineering and Methodology, Vol. 31, No. 2, ACM, April 2022.

--- Chunk 764 ---
Tokens: 395
Type: sentence-based
Text:
2, ACM, April 2022. 17 H. Washizaki, F. Khomh, Y. G. Gueheneuc, H. Takeuchi, N. Natori, T. Doi, S. Okuda, Software Engineering Design Patterns for Machine Learning Applications, Computer, Vol. 55, No. 3, IEEE Computer Society, March 2022. 18 Thomas H Cormen, Charles E Leiserson, Ronald L Rivest, Clifford Stein, Introduction to Algorithms, Fourth Edition, 2022. 19 Andrew W Tanenbaum, Herbert Bos, Modern Operating Systems, 4e, 2016. 20 https:ieeexplore.ieee.orgdocument 9779481 21 Neal Ford, Mark Richards, Pramod Sadalage and Zhamak Dehgh, Software Architecture: The Hard Parts, O Reilly, First Edition  2021 COMPUTING FOUNDATIONS 16-33 22 Thomas Connolly, Carolyn Begg, Database Systems - A Practical Approach to Design, Implementation and Management, 6th Edition  Pearson 23 Michael J. Hernandez, Database Design For Mere Mortals, 4th Edition, Addison-Wesley 24 James F Kurose, Keith W Ross, Computer Networking - A Top-Down Approach, 7th Edition, Pearson 17-1 CHAPTER 17 Mathematical Foundations ACRONYMS BST Binary Search Tree CFG Context-Free Grammar CSG Context-Sensitive Grammar FSM Finite-State Machine GCD Greatest Common Divisor IH Induction Hypothesis LHS Left-Hand Side PSG Phrase Structure Grammar RHS Right-Hand Side INTRODUCTION Software engineers can write code only for something that follows well-understood, unambiguous logic. The Mathematical Foundations Knowledge Area (KA) helps software engineers comprehend this logic, which they translate into source code. The mathematics in this KA differs greatly from typical arithmetic, which deals with num- bers.

--- Chunk 765 ---
Tokens: 380
Type: sentence-based
Text:
The mathematics in this KA differs greatly from typical arithmetic, which deals with num- bers. This KA focuses on logic and reasoning, which are the essence of the mathematics a software engineer must address. Mathematics, in a sense, is the study of formal systems. The word formal is associated with preciseness, so there can be no ambig- uous or erroneous interpretation of the facts. Mathematics is therefore the study of all cer- tain truths about any concept. This concept can be about numbers, symbols, images, sounds or video  almost anything. In short, numbers and numeric equations arent the only subjects of preciseness. On the contrary, a software engineer must have a precise abstraction on complex, diverse application domains. The Mathematical Foundations KA covers basic techniques to identify a set of rules for reasoning in the context of the system under study. Anything you can deduce following these rules is an absolute certainty within the context of that system. This KA defines and discusses techniques that can represent and take forward a software engineers rea- soning and judgment in a precise (and there- fore mathematical) manner. The language and methods of logic discussed allow software engineers to describe mathematical proofs to infer conclusively the absolute truth of cer- tain concepts beyond just numbers. This KAs objective is to help software engineers develop the skill to identify and describe such logic and verify that the logic in the code is con- sistent with abstractions.

--- Chunk 766 ---
Tokens: 395
Type: sentence-based
Text:
This KAs objective is to help software engineers develop the skill to identify and describe such logic and verify that the logic in the code is con- sistent with abstractions. The emphasis is on helping software engineers understand the basic concepts rather than on developing their arithmetic abilities. BREAKDOWN OF TOPICS FOR MATHEMATICAL FOUNDATIONS The breakdown of topics for the Mathematical Foundations KA is shown in Figure 17.1. 1. Basic Logic 1, c1 1.1. Propositional Logic A proposition is a statement that is either true or false, but not both. Consider declar- ative sentences for which it is meaningful to assign either of the two status values: true 17-2 SWEBOK  GUIDE V4.0 or false. The following are some examples of propositions:  The sun is a star. Elephants are mammals. 2  3  5. However, a  3  b is not a proposition, as it is neither true nor false. Whether it is true depends on the values of the variables a and b. The Law of Excluded Middle: For every proposition p, either p is true, or p is false. The Law of Contradiction: For every propo- sition p, it is not the case that p is both true and false. Propositional logic is the area of logic that deals with propositions. A truth table displays the relationships between the truth values of propositions. A Boolean variable is a variable whose value is either true or false. Computer bit operations correspond to logical operations of Boolean variables. The basic logical operators include negation (not,  p), conjunction (and, p  q), disjunc- tion (or, p  q), exclusion (p  q), and impli- cation (p  q).

--- Chunk 767 ---
Tokens: 393
Type: sentence-based
Text:
The basic logical operators include negation (not,  p), conjunction (and, p  q), disjunc- tion (or, p  q), exclusion (p  q), and impli- cation (p  q). Compound propositions may be formed using various logical operators. A compound proposition that is always true is a tautology. A compound proposition that is always false is a contradiction. A com- pound proposition that is neither a tautology nor a contradiction is a contingency. Compound propositions that always have the same truth value are called logically equiv- alent (denoted by ). Some common logical equivalences are the following:  Identity laws: p  T  p p  F  p  Domination laws: p  T  T p  F  F  Idempotent laws: p  p  p p  p  p  Double negation law:  ( p)  p  Commutative laws: p  q  q  p p  q  q  p  Associative laws: (p  q)  r  p  (q  r) (p  q)  r  p  (q  r)  Distributive laws: p  (q  r)  (p  q)  (p  r) p  (q  r)  (p  q)  (p  r) Mathematical Foundations Basic Logic Set, Relation, Function Finite-State Machine Number Teory Propositional Logic Predicate Logic Set Operations Properties at Set Relations and Funtions Types of Numbers Divisibility Prime Number Greatest Common Divisor Discrete Probability Algebraic Structures Group Ring Proof Techniques Direct Proof Proof by Contradiction Proof by Induction Proof by Example Graph and Tree Graph Tree Grammar Language Recognition Basics of Counting Numerical Precision, Accuracy and Error Calculus Figure 17.1. Breakdown of Topics for the Mathematical Foundations KA MATHEMATICAL FOUNDATIONS 17-3  De Morgans laws:  (p  q)   p   q  (p  q)   p   q 1.2.

--- Chunk 768 ---
Tokens: 374
Type: sentence-based
Text:
Breakdown of Topics for the Mathematical Foundations KA MATHEMATICAL FOUNDATIONS 17-3  De Morgans laws:  (p  q)   p   q  (p  q)   p   q 1.2. Predicate Logic A predicate is a verb phrase template that describes a property of objects or a relation- ship among objects represented by the vari- ables. For example, in the sentence The flower is Red, the template is Red is a predicate. It describes a property of the flower. The same predicate may be used in other sentences. Predicates are often given a name (e.g, Red or simply R) that can represent the predicate (in this case, Red or R can represent the predicate is red). Assuming R is the name for the predicate is red, sentences that assert an object is the color red can be represented as R(x), where x rep- resents an arbitrary object. R(x) reads as x is red. Quantifiers allow statements about entire collections of objects so that enumerating each object by name is not necessary. The universal quantifier x asserts that a sentence is true for all values of variable x (e.g, x Tiger(x)  Mammal(x) means all tigers are mammals). The existential quantifier x asserts that a sentence is true for at least one value of variable x (e.g, x Tiger(x)  Man- eater(x) means there exists at least one tiger that is a man-eater). Thus, while universal quantification uses implication, existential quantification natu- rally uses conjunction. A variable x introduced into a logical expression by a quantifier is bound to the closest enclosing quantifier.

--- Chunk 769 ---
Tokens: 394
Type: sentence-based
Text:
A variable x introduced into a logical expression by a quantifier is bound to the closest enclosing quantifier. Similarly, in a block-structured programming language, a variable in a logical expression refers to the closest quantifier within whose scope it appears. For example, in x (Cat(x)  x (Black(x))), x in Black(x) is universally quan- tified. Therefore, the expression implies that cats exist and everything is black. A variable is a free variable if it is not bound to a quantifier. Propositional logic falls short in repre- senting many assertions used in mathematics, computer science and, therefore, software engineering. It also fails to compare equiva- lence and other relationships between prop- ositions. For example, the assertion a is greater than 1 is not a proposition because one cannot infer whether it is true or false without knowing the value of a. Thus, propo- sitional logic cannot deal with such sentences. However, such assertions appear quite often in mathematics, and we want to infer infor- mation from those assertions. Also, prop- ositional logic cannot capture the pattern involved in the following two logical equiva- lences: Not all men are smokers and Some men dont smoke. Each of these two propositions is treated independently in propositional logic. There is no mechanism in propositional logic to determine whether the two are equivalent. Hence, propositional logic treats each equiva- lent proposition individually rather than apply a general formula that covers all equivalences collectively. Predicate logic addresses these issues.

--- Chunk 770 ---
Tokens: 384
Type: sentence-based
Text:
Predicate logic addresses these issues. In a sense, predicate logic (also known as first- order logic or predicate calculus) extends propositional logic to formulas involving terms and predicates. 2. Proof Techniques 1, c1 A proof is an argument that rigorously estab- lishes the truth of a statement. Proofs can themselves be represented formally as discrete structures. Statements used in a proof include axioms and postulates that are essentially the under- lying assumptions about mathematical struc- tures, the hypotheses of the theorem to be proved and previously proved theorems. A theorem is a statement that can be shown to be true. A lemma is a simple theorem used in proving other theorems. A corollary is a proposition that can be established directly from a theorem that has been proved. 17-4 SWEBOK  GUIDE V4.0  A conjecture is a statement whose truth value is unknown. When a conjectures proof is found, that conjecture becomes a theorem. Many times, conjectures are shown to be false and, hence, are not theorems. 2.1. Direct Proof Direct proof is a technique to establish that the implication p  q is true by showing that q must be true when p is true. For example, to show that if n is odd, then n2  1 is even, suppose n is odd for some integer k  i.e, n  2k  1:  n2  (2k  1)2  4k2  4k  1 As the first two terms of the Right-Hand Side (RHS) are even numbers irrespective of the value of k, the Left-Hand Side (LHS) (n2) is an odd number. Therefore, n2  1 is even. Direct proof can also be called Proof by Deduction. 2.2.

--- Chunk 771 ---
Tokens: 358
Type: sentence-based
Text:
2.2. Proof by Contradiction A proposition p is true by contradiction if proved based on the truth of the implica- tion  p  q, where q is a contradiction. For example, to show that the sum of 2x  1 and 2y  1 is even, assume that the sum of 2x  1 and 2y  1 is odd. In other words, 2(x  y), which is a multiple of 2, is odd. This is a con- tradiction. Hence, the sum of 2x  1 and 2y  1 is even. An inference rule is a pattern establishing that if a set of premises are all true, then it can be deduced that a certain conclusion statement is true. The reference rules of addi- tion, simplification and conjunction need to be studied. A closely related approach, Proof by Contrapositive, takes the opposite approach by assuming the conclusion is false and proving that the hypothesis is also false. If it can be shown that  q   p is true, then p  q must also be true. 2.3. Proof by Induction Proof by induction is done in two parts. First, the proposition is established to be true for a base case  typically for the posi- tive integer 1. Then, in the second part, it is established that if the proposition holds for an arbitrary positive integer k, then it must also hold for the next greater integer, k  1. In other words, proof by induction is based on the rule of inference that tells us that the truth of an infinite sequence of propositions P(n), n  1, ,  is established if first P(1) is true, and, second k  2, , n if P(k)  P(k  1).

--- Chunk 772 ---
Tokens: 398
Type: sentence-based
Text:
In other words, proof by induction is based on the rule of inference that tells us that the truth of an infinite sequence of propositions P(n), n  1, ,  is established if first P(1) is true, and, second k  2, , n if P(k)  P(k  1). For a proof by induction, it is not assumed that P(k) is true for all positive integers k. Proving a theorem or proposition only requires us to establish that if it is assumed P(k) is true for any arbitrary positive integer k, then P(k  1) is also true. An in-depth dis- cussion of the correctness of induction as a valid proof technique is beyond the scope of this KA. The following proposition is proved using induction: Proposition: The sum of the first n positive odd integers P(n) is n2. Basis Step: The proposition is true for n  1 as P(1)  12  1. The basis step is complete. Inductive Step: The induction hypothesis (IH) is that the proposition is true for n  k, k being an arbitrary positive integer k.  1  3  5    (2k  1)  k2 Now, its to be shown that P(k)  P(k  1). P(k  1)  1  3  5    (2k  1)  (2k  1)  P(k)  (2k  1)  k2  (2k  1) using IH  k2  2k  1  (k  1)2 Thus, it is shown that if the proposition is true for n  k, then it is also true for n  k  1. The basis step together with the inductive step of the proof show that P(1) is true and the conditional statement P(k)  P(k  1) is true for all positive integers k. Hence, the proposi- tion is proved. MATHEMATICAL FOUNDATIONS 17-5 2.4. Proof by Example Proof by example is only valid when the core of the proof is there exists and one needs only to show that at least one valid instance does exist.

--- Chunk 773 ---
Tokens: 377
Type: sentence-based
Text:
Proof by Example Proof by example is only valid when the core of the proof is there exists and one needs only to show that at least one valid instance does exist. More generally, however, proof by example has often been called Inappropriate Generalization where validity is assumed to be illustrated through one or a few examples rather than a full proof. Showing only one or a few specific examples where p  q is not suf- ficient to prove that for all cases p  q. 3. Set, Relation, Function 1, c2 Set. A set is a collection of objects called ele- ments. A set can be represented by listing its elements between braces (e.g, S  1, 2, 3). The symbol  is used to express that an ele- ment belongs to a set or is a member of the set. Its negation is represented by  (e.g, 1  S, but 4  S). In a more compact representation of a set using set builder notation, x  P(x) is the set of all x such that P(x) for any proposition P(x) over any universe of discourse. Examples of important sets include the following:    0, 1, 2, 3,   the set of nonnega- tive integers.   , -3, -2, -1, 0, 1, 2, 3,   the set of integers. Finite and Infinite Set. A set with a finite number of elements is called a finite set. Conversely, any set that does not have a finite number of elements in it is an infinite set. For example, the set of all natural numbers is an infinite set. Cardinality. The cardinality of a finite set S is the number of elements in S. This is repre- sented as S (e.g, if S  1, 2, 3, then S  3). Universal Set.

--- Chunk 774 ---
Tokens: 388
Type: sentence-based
Text:
Universal Set. In general, S  x  U  p(x), where U is the universe of discourse in which the predicate P(x) must be interpreted. The universe of discourse for a given pred- icate is often referred to as the universal set. Alternatively, one may define a universal set as the set of all elements. Set Equality. Two sets are equal if and only if they have the same elements  i.e, X  Y  p (p  X  p  Y). Subset. X is a subset of set Y, or X is con- tained in Y, if all elements of X are included in Y. This is denoted by X  Y. In other words, X  Y if and only if p(p  X  p  Y) If X  1, 2, 3 and Y  1, 2, 3, 4, 5, then X  Y. If X is not a subset of Y, it is denoted as X Y. Proper Subset. X is a proper subset of Y (denoted by X  Y) if X is a subset of Y but not equal to Y  i.e, there is some element in Y that is not in X. In other words, X  Y if (X  Y)  (X  Y). If X  1, 2, 3, Y  1, 2, 3, 4, and Z  1, 2, 3, then X  Y, but X is not a proper subset of Z. Sets X and Z are equal sets. If X is not a proper subset of Y, it is denoted as X  Y. Superset. If X is a subset of Y, then Y is called a superset of X. This is denoted by Y  X  i.e, Y  X if and only if X  Y. If X  1, 2, 3 and Y  1, 2, 3, 4, 5, then Y  X. Empty Set. A set with no elements is called an empty set. An empty set, denoted by , is also referred to as a null or void set. Power Set. The set of all subsets of a set X U X Figure 17.2. Venn Diagram for Set X U X  Y X Y Figure 17.3. Intersection of Sets X and Y 17-6 SWEBOK  GUIDE V4.0 is called the power set of X. It is represented as (X).

--- Chunk 775 ---
Tokens: 398
Type: sentence-based
Text:
It is represented as (X). If X  a, b, c, then (X)  , a, b, c, a, b, a, c, b, c, a, b, c. If X  n, then  (X)  2n. Venn Diagrams. Venn diagrams are graphic representations of sets as enclosed areas in the plane. For example, in Figure 17.2, the rect- angle represents the universal set, and the shaded region represents a set X. 3.1. Set Operations Intersection. The intersection of two sets, X and Y, denoted by X  Y, is the set of common elements in both X and Y. In other words, X  Y  p  (p  X)  (p  Y). For example, 1, 2, 3  3, 4, 6  3. If X  Y  , then the two sets X and Y are said to be disjoint. A Venn diagram for set intersection is shown in Figure 17.3. The common portion of the two sets represents the set intersection. Union. The union of two sets, X and Y, denoted by X  Y, is the set of all elements in X, in Y or in both. In other words, X  Y  p  (p  X)  (p  Y). For example, 1, 2, 3  3, 4, 6  1, 2, 3, 4, 6. It may be noted that X  Y  X  Y  X  Y. A Venn diagram illustrating the union of two sets is represented by the shaded region in Figure 17.4. Complement Set. The set of elements in the universal set that do not belong to a given set X is called its complement set X. In other words, X p  (p  U)  (p  X). The shaded portion of the Venn diagram in Figure 17.5 represents the complement set of X. Set Difference or Relative Complement. The set of elements that belong to set X but not to set Y builds the set difference of Y from X. This is represented by X  Y. In other words, X  Y  p  (p  X)  (p  Y). For example, 1, 2, 3  3, 4, 6  1, 2. It may be proved that X  Y  X  Y.

--- Chunk 776 ---
Tokens: 400
Type: sentence-based
Text:
It may be proved that X  Y  X  Y. Set difference X  Y is illustrated by the shaded region in Figure 17.6 using a Venn diagram. Cartesian Product. An ordinary pair p, q is a set with two elements. In a set, the order of the elements is irrelevant, so p, q  q, p. In an ordered pair (p, q), the order of occur- rences of the elements is relevant. Thus, (p, q)  (q, p) unless p  q. In general, (p, q)  (s, t) if and only if p  s and q  t. Given two sets, X and Y, their Cartesian product X  Y is the set of all ordered pairs (p, q) such that p  X and q  Y. In other words, X  Y  (p, q)  (p  X)  (q  Y). For example, a, b  1, 2  (a, 1), (a, 2), (b, 1), (b, 2). 3.2. Properties of Sets Some of the important properties and laws of sets are mentioned below: U X  Y X Y Figure 17.4. Union of Sets X and Y U X  Y X Y Figure 17.6. Venn Diagram for X  Y U X Figure 17.5. Venn Diagram for Complement Set of X MATHEMATICAL FOUNDATIONS 17-7  Associative Laws:  X  (Y  Z)  (X  Y)  Z  X  (Y  Z)  (X  Y)  Z  Commutative Laws:  X  Y  Y  X X  Y  Y  X  Distributive Laws:  X  (Y  Z)  (X  Y)  (X  Z)  X  (Y  Z)  (X  Y)  (X  Z)  Identity Laws:  X    X X  U  X  Complement Laws:  X  X  U X  X    Idempotent Laws:  X  X  X X  X  X  Bound Laws:  X  U  U X      Absorption Laws:  X  (X  Y)  X X  (X  Y)  X  De Morgans Laws:  (X  Y)  X  Y (X  Y)  X  Y 3.3. Relation and Function A relation is an association between two sets of information. Consider a set of residents of a city and their phone numbers. The pairing of names with corresponding phone numbers is a rela- tion. This pairing is ordered for the entire rela- tion.

--- Chunk 777 ---
Tokens: 397
Type: sentence-based
Text:
This pairing is ordered for the entire rela- tion. For each pair, either the name comes first, followed by the phone number, or the reverse. The set from which the first element is drawn is called the domain set, and the other set is called the range set. The domain is what you start with, and the range is what you end with. A function is a well-behaved relation. A relation R(X, Y) is well-behaved if every ele- ment of the domain set X corresponds to a single element of the range set Y. Consider domain set X as a set of people and range set Y as their phone numbers. If a person may have more than one phone number, then this relation is not a function. However, if we draw a relation between the names of resi- dents and their dates of birth with the name set as domain, then this becomes a well-be- haved relation and hence a function. This means that while all functions are relations, not all relations are functions. In the case of a function given an x, there is one and exactly one y for each ordered pair (x, y). For example, consider the following two relations: A: (3, 9), (5, 8), (7, 6), (3, 9), (6, 3) B: (5, 8), (7, 8), (3, 8), (6, 8) Are these functions as well? In relation A, the domain is all x-values  i.e, 3, 5, 6, 7  and the range is all y-values  i.e, 9, 6, 3, 8, 9. Relation A is not a function, as there are two different range values, 9 and 9, for the same x-value, 3. In relation B, the domain is the same as for A  i.e, 3, 5, 6, 7. However, the range is a single element  8. This qualifies as a function even if all x-values are mapped to the same y-value.

--- Chunk 778 ---
Tokens: 380
Type: sentence-based
Text:
This qualifies as a function even if all x-values are mapped to the same y-value. Here, each x-value is distinct, so the relation is well-behaved and is therefore a function. Therefore, Relation B may be rep- resented by the equation y  8. Whether a relation may be characterized as a function can be verified using the vertical line test presented below: Given the graph of a relation, if one can draw a vertical line that crosses the graph in more than one place, then that relation is not a function. Y L1 L2 X Figure 17.7. Vertical Line Test for Function 17-8 SWEBOK  GUIDE V4.0 In Figure 17.7, both lines L1 and L2 cut the graph for the relation three times. This signi- fies that for each of these x-values (with L1 representing one x-value and L2 representing another), there are three different y-values. Thus, the relation is not a function. Of course, either L1 or L2 alone would be enough to prove that the relation is not a function. 4. Graph and Tree 1, c10, c11 4.1. Graph In a graph G  (V, E), V is the set of vertices (nodes) and E is the set of edges. Edges are also called arcs or links. F is a function that maps the set of edges E to a set of ordered or unordered pairs of ele- ments V. In Figure 17.8, G  (V, E) where V  A, B, C, E  e1, e2, e3, and F  (e1, (A, C)), (e2, (C, B)), (e3, (B, A)). The simple graph in Figure 17.8 consists of a set of vertices or nodes and a set of edges connecting unordered pairs. The edges in simple graphs are undirected. Such graphs are also called undirected graphs.

--- Chunk 779 ---
Tokens: 397
Type: sentence-based
Text:
Such graphs are also called undirected graphs. In Figure 17.8, (e1, (A, C)) may be replaced by (e1, (C, A)), as the pair between vertices A and C is unordered. This is true for the other two edges as well. In a multigraph, more than one edge may connect the same two vertices. Two or more connecting edges between the same pair of vertices may reflect multiple associations between the same two vertices. Such edges are called parallel or multiple edges. In Figure 17.9, the edges e3 and e4 both connect A and B. Figure 17.9 is a multigraph where edges e3 and e4 are multiple edges. In a pseudograph, edges connecting a node to itself are allowed. Such edges are called loops. In Figure 17.10, the edge e4 both starts and ends at B. Figure 17.10 is a pseudograph in which e4 is a loop. A directed graph G  (V, E) consists of a set of vertices V and a set of edges E that are ordered pairs of elements of V. A directed graph may contain loops. In Figure 17.11, G  (V, E) is a directed graph where V  A, B, C, A B C e2 e1 e3 Figure 17.8. Example of a Graph A B C e2 e4 e1 e3 Figure 17.9. Example of a Multigraph A B C e2 e4 e1 e3 Figure 17.10. Example of a Pseudograph A B C e2 e1 e3 Figure 17.11. Example of a Directed Graph A B C e2 93 e1 76 15 e3 Figure 17.12. Example of a Weighted Graph MATHEMATICAL FOUNDATIONS 17-9 E  e1, e2, e3, and F  (e1, (A, C)), (e2, (B, C)), (e3, (B, A)). In weighted graph G  (V, E), each edge has a weight associated with it. The weight of an edge typically represents the numeric value associated with the relationship between the corresponding two vertices.

--- Chunk 780 ---
Tokens: 392
Type: sentence-based
Text:
The weight of an edge typically represents the numeric value associated with the relationship between the corresponding two vertices. In Figure 17.12, the weights for the edges e1, e2 and e3 are taken to be 76, 93 and 15, respectively. If the vertices A, B and C represent three cities in a state, the weights could be, for example, the distances in kilometers between these cities. Let G  (V, E) be an undirected graph with edge set E. Then, for an edge e  E where e  u, v, the following expressions are often used:  u, v are said to be adjacent, neighbors, or connected. Edge e is incident with vertices u and v.  Edge e connects u and v.  Vertices u and v are endpoints for edge e. If vertex v  V, the set of vertices in the undirected graph G  (V, E), then:  The degree of v, deg(v), is its number of incident edges, except that any self-loops are counted twice. A vertex with degree 0 is called an iso- lated vertex. A vertex of degree 1 is called a pen- dant vertex. Let G  (V, E) be a directed graph. If e(u, v) is an edge of G, then the following expres- sions can be used to describe the graph:  u is adjacent to v, and v is adjacent from u.  e comes from u and goes to v.  e connects u to v, or e goes from u to v.  The initial vertex of e is u. The terminal vertex of e is v. If vertex v is in the set of vertices for the directed graph G  (V, E), then:  In-degree of v, deg(v), is the number of edges going to v, i.e, for which v is the terminal vertex. Out-degree of v, deg(v), is the number of edges coming from v, i.e, for which v is the initial vertex.

--- Chunk 781 ---
Tokens: 394
Type: sentence-based
Text:
Out-degree of v, deg(v), is the number of edges coming from v, i.e, for which v is the initial vertex. Degree of v, deg(v)  deg(v)  deg(v), is the sum of vs in-degree and out-degree. A loop at a vertex contributes 1 to both the in-degree and the out-degree of this vertex. According to the definitions above, the degree of a node is unchanged whether we consider its edges to be directed or undirected. In an undirected graph, a path of length n from u to v is a sequence of n adjacent edges from vertex u to vertex v.  A path is a circuit if u  v.  A path traverses the vertices along it. A path is simple if it contains no edge more than once. A cycle on n vertices Cn for any n  3 is a simple graph where V  v1, v2, , vn and E  v1, v2, v2, v3, , vn1, vn, vn, v1. For example, Figure 17.13 illustrates two cycles of lengths 3 and 4. An adjacency list is a table with one row per vertex, listing its adjacent vertices. The Figure 17.13. Example of Cycles C3 and C4 A B C e2 e1 e3 A B D C e1 e3 e4 e2 Figure 17.14. Adjacency List for the Graph in Figure 17.10 Vertex Adjacent Nodes A B, C B A, B, C C A, B 17-10 SWEBOK  GUIDE V4.0 adjacency list for a directed graph maintains a listing of the terminal nodes for each vertex. Figure 17.14 illustrates the adjacency lists for the pseudograph in Figure 17.10 and the directed graph in Figure 17.11. As the out-de- gree of vertex C in Figure 17.11 is 0, there is no entry against C in the adjacency list. Different representations for a graph  e.g, adjacency matrix, incidence matrix and adjacency lists  need to be studied. 4.2.

--- Chunk 782 ---
Tokens: 390
Type: sentence-based
Text:
4.2. Tree A tree T(N, E) is a hierarchical data struc- ture of n  N nodes with a specially desig- nated root node R while the remaining n  1 nodes form subtrees under the root node R. The number of edges E in a tree are always equal to N  1. The subtree at node X is the subgraph of the tree consisting of node X, its descendants and all edges incident to those descendants. As an alternative to this recursive definition, a tree may be defined as a connected undirected graph with no simple circuits. However, a tree is strictly hierarchical, whereas a graph is flat. In a tree, an ordered pair is built between two nodes as parent and child. Each child node in a tree is associ- ated with only one parent node, whereas this restriction is meaningless for a graph, where no parent-child association exists. An undirected graph is a tree if and only if there is a unique simple path between any two of its vertices. Figure 17.15 presents a tree T(N, E) with a set of nodes N  A, B, C, D, E, F, G, H, I, J, K. The edge set E is (A, B), (A, C), (A, D), (B, E), (B, F), (B, G), (C, H), (C, I), (D, J), (D, K). The parent of a non-root node v is the unique node u with a directed edge from u to v. Each node in the tree has a unique parent node except for the trees root node. While root nodes can serve as parent nodes, they have no parent nodes themselves. In Figure 17.15, root node A is the parent node for nodes B, C and D. Similarly, B is the parent of E, F and G, and so on. The root node A has no parent. A node that has children is called an internal node.

--- Chunk 783 ---
Tokens: 388
Type: sentence-based
Text:
A node that has children is called an internal node. For example, in Figure 17.15, node A and node B are examples of internal nodes. The degree of a node in a tree is the same as its number of children. For example, in Figure 17.15, root node A and its child B are both of degree 3. Nodes C and D have degree 2. A nodes distance from the root node in number of hops is called its level. Nodes in a tree are at different levels. The root node is at level 0. Alternately, a node Xs level is the unique paths length from the trees root to node X. Root node A is at level 0 in Figure 17.15. Nodes B, C and D are at level 1. The remaining nodes in Figure 17.15 are at level 2. A trees height is the maximum of the levels of tree nodes. For example, in Figure 17.15, the trees height is 2. A node is called a leaf if it has no chil- dren, and the degree of a leaf node is 0. For example, in Figure 17.15, nodes E through K are leaf nodes with degree 0. The ancestors or predecessors of a non-root node X are all the nodes in the path from the root to node X. For example, in Figure 17.15, nodes A and D form the set of ancestors for J. A node Xs successors or descendants are all the nodes that have X as their ancestor. For a tree with n nodes, all remaining n  1 nodes are successors of the root node. In Figure 17.15, node B has successors in E, F, and G. If node X is an ancestor of node Y, then node Y is a successor of X. Two or more nodes sharing the same parent node are called sibling nodes. For example, in Figure 17.15, nodes E and G are siblings.

--- Chunk 784 ---
Tokens: 396
Type: sentence-based
Text:
For example, in Figure 17.15, nodes E and G are siblings. However, nodes E and J, though at the same level, are not sibling nodes. A B C D E F G H I J K Figure 17.15. Example of a Tree MATHEMATICAL FOUNDATIONS 17-11 Two sibling nodes are at the same level, but two nodes at the same level are not necessarily siblings. A tree is called an ordered tree if the rela- tive position of occurrences of children nodes is significant. For example, a family tree is an ordered tree if, as a rule, the name of an elder sibling always appears before (on the left of) the younger sibling. In an unordered tree, the relative position of occurrences between the siblings has no significance and may be altered arbitrarily. A binary tree is formed with 0 or more nodes where there is a root node R and all the remaining nodes form a pair of ordered sub- trees under the root node. In a binary tree, no internal node can have more than two children. In addition to this criterion for the degree of internal nodes, a binary tree is always ordered. If the positions of the left and right subtrees for any node in the tree are swapped, then a new tree is created. In Figure 17.16, the two binary trees are different, as the positions of occurrences of As children differ in the two trees. According to 1, a binary tree is called a full binary tree if every internal node has exactly two children. For example, the binary tree in Figure 17.17 is a full binary tree, as both internal nodes A and B are of degree 2. A full binary tree that meets the definition above is also called a strictly binary tree.

--- Chunk 785 ---
Tokens: 400
Type: sentence-based
Text:
A full binary tree that meets the definition above is also called a strictly binary tree. Both binary trees in Figure 17.18 are com- plete binary trees. The tree in Figure 17.18(a) is a complete and full binary tree. A complete binary tree has all its levels filled, except pos- sibly the last one. If a complete binary trees last level is not full, nodes occur from the left- most positions available. Interestingly, following the definitions above, the tree in Figure 17.18(b) is a complete but not full binary tree, as node B has only one child in D. On the contrary, the tree in Figure 17.17 is a full but not complete binary tree, as Bs children occur in the tree, whereas the children of C do not appear in the last level. A binary tree of height H is balanced if all leaf nodes occur at levels H or H  1. All three binary trees in Figures 17.17 and 17.18 are balanced binary trees. There are at most 2H leaves in a binary tree of height H. In other words, if a binary tree with L leaves is full and balanced, then its height is H log2L. This is true for the two trees in Figures 17.17 and 17.18(a), as both trees are full and balanced. However, the tree in Figure 17.18(b) is not a full binary tree. A binary search tree (BST) is a special kind of binary tree in which each node contains a distinct key value, and the key value of each node in the tree is less than every key value in its right subtree and greater than every key value in its left subtree. A traversal algorithm is a procedure for sys- tematically visiting every node of a binary tree. Tree traversals may be defined recursively.

--- Chunk 786 ---
Tokens: 398
Type: sentence-based
Text:
Tree traversals may be defined recursively. A B C A C B Figure 17.16. Examples of Binary Trees A C B D E Figure 17.17. Example of a Full Binary Tree A A (a) (b) C B C B D E D G F Figure 17.18. Example of Complete Binary Trees 17-12 SWEBOK  GUIDE V4.0 If T is a binary tree with root R and the remaining nodes form an ordered pair of non- null left subtree TL and nonnull right subtree TR below R, then the preorder traversal func- tion PreOrder(T) is defined as: PreOrder(T)  R, PreOrder(TL), PreOrder(TR)  eqn. 1 The recursive process of finding the pre- order traversal of the subtrees continues until the subtrees are found to be Null. Here, commas have been used as delimiters for improved readability. The postorder and in-order may be similarly defined using eqn. 2 and eqn. 3, respectively. PostOrder(T)  PostOrder(TL), PostOrder(TR), R  eqn. 2 InOrder(T)  InOrder(TL), R, InOrder(TR)  eqn. 3 The tree in Figure 17.19 is a binary search tree (BST). The pre-order, post-order and in-order traversal outputs for this BST are given below in their respective orders: Preorder output: 9, 5, 2, 1, 4, 7, 6, 8, 13, 11, 10, 15 Postorder output: 1, 4, 2, 6, 8, 7, 5, 10, 11, 15, 13, 9 In-order output: 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15 5. Finite-State Machine 1, c13 A computer system may be abstracted as a mapping from state to state, driven by inputs. In other words, a system may be considered a transition function T: S  I  S  O, where S is the set of states and I and O are the input and output functions. If the state set S is finite, the system is called a finite-state machine (FSM).

--- Chunk 787 ---
Tokens: 364
Type: sentence-based
Text:
If the state set S is finite, the system is called a finite-state machine (FSM). Alternatively, a finite state machine (FSM) is a mathematical abstraction com- posed of a finite number of states and transi- tions between those states. For example, if the domain S  I is reasonably small, then one can specify T explicitly, using diagrams similar to a flow graph to illustrate how logic flows for different inputs. However, this is practical only for machines with a very small informa- tion capacity. An FSM has a finite internal memory, an input feature that reads symbols one at a time in a sequence, and an output feature. The operation of an FSM begins from a start state, goes through transitions depending on the input to different states, and can end in any valid state. However, only a few of the states mark a successful flow of operation. These are called accept states. The information capacity of an FSM is C  log S. Thus, if we represent a machine having an information capacity of C bits as an FSM, then its state transition graph will have S  2C nodes. An FSM is formally defined as M  (S, I, O, f, g, s0). 9 1 4 6 8 10 5 13 15 11 7 2 Figure 17.19. A Binary Search Tree 1, 2 1, 2 0, 2 0, 3 0, 3 1, 3 S S S Figure 17.20. Example of an FSM MATHEMATICAL FOUNDATIONS 17-13 S is the state set. I is the set of input symbols. O is the set of output symbols. f is the state transition function. g is the output function. s0 is the initial state.

--- Chunk 788 ---
Tokens: 361
Type: sentence-based
Text:
s0 is the initial state. Given an input x  I on state Sk, the FSM transitions to state Sh, following state transi- tion function f, and produces an output y  O, using the output function g. Figure 17.20 illustrates an FSM with S0 as the start state and S1 as the final state. Here, S  S0, S1, S2; I  0, 1; O  2, 3; f(S0, 0)  S2; f(S0, 1)  S1; f(S1, 0)  S2; f(S1, 1)  S2; f(S2, 0)  S2; f(S2, 1)  S0; g(S0, 0)  3; g(S0, 1)  2; g(S1, 0)  3; g(S1, 1)  2; g(S2, 0)  2; g(S2, 1)  3. The state transition and output values for dif- ferent inputs on different states may instead be represented using a state table. The state table for the FSM in Figure 17.20 is shown in Figure 17.21. Each pair against an input symbol rep- resents the new state and the output symbol. Figures 17.21(a) and 17.21(b) are alternative representations of the FSM in Figure 17.20. 6. Grammar 1, c13 The grammar of a natural language defines whether a combination of words makes a valid sentence. Unlike natural languages, a formal language is specified by a well-defined set of rules for syntaxes. The valid sentences of a formal language can be described by a grammar with the help of these rules, called production rules. A formal language is a set of finite-length words or strings over some finite alphabet, and a grammar specifies the rules for forming those words or strings. The entire set of words that are valid for a grammar constitutes the language for the grammar.

--- Chunk 789 ---
Tokens: 369
Type: sentence-based
Text:
The entire set of words that are valid for a grammar constitutes the language for the grammar. Thus, the grammar G is any compact, precise mathematical defi- nition of a language L as opposed to a raw listing of all legal sentences or examples of those sentences in that language. A grammar implies an algorithm that can generate all legal sentences of the language. There are different types of grammars. A phrase structure grammar (PSG) or Type-0 grammar G  (V, T, S, P) is a 4-tuple in which:  V is the vocabulary  i.e, the set of words. T  V is a set of words called terminals. S  N is a special word called the start symbol. P is the set of production rules for substi- tuting one sentence fragment for another. There exists another set, N  V  T, of words called nonterminals. The nonterminals repre- sent concepts such as noun. Production rules are applied on strings containing nonterminals until no more nonterminal symbols are present in the string. The start symbol S is a nonterminal. The language generated by a formal grammar G, denoted by L(G), is the set of all strings over the set of alphabets V that can be generated, starting with the start symbol, by applying production rules until all the nonter- minal symbols are replaced in the string. For example, let G  (S, A, a, b, a, b, S, S  aA, S  b, A  aa). Here, the set of terminals is N  S, A, where S is the start symbol. The three production rules for the grammar are given as P1: S  aA; P2: S  b; P3: A  aa.

--- Chunk 790 ---
Tokens: 393
Type: sentence-based
Text:
The three production rules for the grammar are given as P1: S  aA; P2: S  b; P3: A  aa. Applying the production rules in all pos- sible ways, the following words may be gener- ated from the start symbol: Current State Input Input Input Current State (a) (b) Output f State Trans g 0 1 3 2 3 2 0 1 0 1 S, S, 3 2 S, S, 2 3 S, S, S S S S S S S 3 2 S S 2 3 S S S Figure 17.21. Tabular Representation of an FSM 17-14 SWEBOK  GUIDE V4.0 S  aA (using P1 on start symbol)  aaa (using P3) S  b (using P2 on start symbol) Nothing else can be derived from G. Thus, the language of the grammar G consists of only two words: L(G)  aaa, b. 6.1. Language Recognition Formal grammars can be classified according to the types of productions they allow. The Chomsky hierarchy (introduced by Noam Chomsky in 1956) describes such a classifi- cation scheme. From Figure 17.22, we can infer the fol- lowing about different grammars: 1. Every regular grammar is a context-free grammar (CFG). 2. Every CFG is a context-sensitive grammar (CSG). 3. Every CSG is a phrase structure grammar (PSG). Context-Sensitive Grammar (CSG): All fragments in the RHS are either longer than the corresponding fragments in the LHS or empty; in other words, if b  a, then b  a or a  . A formal language is context-sensi- tive if a CSG generates it. Context-Free Grammar (CFG): All frag- ments in the LHS are of length 1; in other words, if A  a, then A  1 for all A  N. The term context-free derives from the fact that A can always be replaced by a, regardless of the context in which it occurs.

--- Chunk 791 ---
Tokens: 383
Type: sentence-based
Text:
Context-Free Grammar (CFG): All frag- ments in the LHS are of length 1; in other words, if A  a, then A  1 for all A  N. The term context-free derives from the fact that A can always be replaced by a, regardless of the context in which it occurs. A formal language is context-free if a CFG generates it. Context-free languages are the theoret- ical basis for the syntax of most programming languages. Regular Grammar: All fragments in the RHS are either single terminals or a pair built by a terminal and a nonterminal; if A  a, then either a  T, a  cD, or a  Dc for c  T, D  N. If a  cD, the grammar is called a right linear grammar. On the other hand, if a  Dc, the grammar is called a left linear grammar. Both the right linear and left linear grammars are regular or Type-3 grammars. The language L(G) generated by a regular grammar G is called a regular language. A regular expression A is a string (or pat- tern) formed from the following pieces of information: a  , the set of alphabets, , 0, and the operations OR (), PRODUCT (), and CONCATENATION (). The language of G, L(G) is equal to all those strings that match G, L(G)  x  x matches G. For any a  , L(a)  a; L()  ; L(0)  0.  functions as an or, L(A  B)  L(A)  L(B). creates a product structure, L(AB)  L(A)  L(B). denotes concatenation, L(A)  x1x2  xn  xi  L(A) and n  0. For example, the regular expression (ab) matches the set of strings: , ab, abab, ababab, abababab, . The regular expression (aa) matches the set of strings on one letter a with even length.

--- Chunk 792 ---
Tokens: 393
Type: sentence-based
Text:
The regular expression (aa) matches the set of strings on one letter a with even length. The regular expression (aaa)  (aaaaa) matches the set of strings of length equal to a multiple of 3 or 5. 7. Number Theory 1, c4 Number theory is one of the oldest branches of pure mathematics and one of the largest. It concerns questions about numbers, usu- ally meaning whole numbers, and fractional Type 0: PSG Type 1: CSG Type 2: CFG Type 3: Regular Grammar Figure 17.22. Chomsky Hierarchy of Grammars MATHEMATICAL FOUNDATIONS 17-15 or rational numbers. The different types of numbers include integer, real number, natural number, complex number and rational number. 7.1. Types of Numbers Natural Numbers: This group of numbers starts at 1 and continues with 2, 3, 4, 5 and so on. Zero is not in this group. There are no negative or fractional numbers in the group of natural numbers. The common mathematical symbol for the set of all natural numbers is N. Whole Numbers: This group has all natural numbers plus the number 0. Unfortunately, not everyone accepts the above definitions of natural and whole num- bers. There seems to be no general agreement about whether to include 0 in the set of nat- ural numbers. Many mathematicians consider that, in Europe, the sequence of natural num- bers traditionally started with 1 (0 was not even considered a number by the Greeks). In the 19th century, set theoreticians and other mathematicians started the convention of including 0 in the set of natural numbers. Integers: This group includes all the whole numbers and their negatives.

--- Chunk 793 ---
Tokens: 399
Type: sentence-based
Text:
Integers: This group includes all the whole numbers and their negatives. The common mathematical symbol for the set of all integers is Z  i.e, Z  , 3, 2, 1, 0, 1, 2, 3, . Rational Numbers: These numbers can be expressed as a ratio of two integers. The common symbol for the set of all rational numbers is Q. Rational numbers may be classified into three types based on how the decimals act: (1) decimals do not exist (e.g, 15); or (2) deci- mals do exist, and they terminate (e.g, 15.6); (3) decimals do exist, and they repeat with a pattern, as in 1.666. (which is 53). Irrational Numbers: These numbers cannot be expressed as an integer divided by an integer. These numbers have decimals that never terminate and never repeat with a pat- tern (e.g, PI or 2). Real Numbers: This group comprises all rational and irrational numbers. The numbers algebra uses are real numbers. The common mathematical symbol for the set of all real numbers is R. Imaginary Numbers: These are all based on the imaginary number i. This imaginary number is equal to the square root of 1. Any real number multiple of i is an imaginary number (e.g, i, 5i, 3.2i, 2.6i). Complex Numbers: A complex number is a combination of a real number and an imaginary number in the form a  bi. The real part is a, and b is called the imaginary part. The common mathematical symbol for the set of all complex numbers is C. For example, 2  3i, 3  5i, 7.3  0i, and 0  5i are complex numbers, but the latter two are equivalent to real numbers. 7.3  0i is the same as the real number 7.3. Similarly, 0  5i is same as the imaginary number 5i.

--- Chunk 794 ---
Tokens: 376
Type: sentence-based
Text:
Similarly, 0  5i is same as the imaginary number 5i. All real numbers are complex numbers with 0 for the imaginary part, and all imaginary numbers are complex numbers with 0 for the real part. 7.2. Divisibility Elementary number theory involves divisi- bility among integers. Let a, b  Z with a  0. The expression ab says that a divides b if c  Z, and the expression b  ac means that there is an integer c such that c times a equals b. For example, 312 is true, but 37 is false. If a divides b, then we say that a is a factor of b or a is a divisor of b, and b is a multiple of a. b is even if and only if 2b. Let a, d  Z with d  1. Then a mod d denotes the remainder r from the division algorithm with dividend a and divisor d, i.e, the remainder when a is divided by d. We can compute (a mod d) by a  d ad, where ad represents the floor of the real number. Let Z  n  Z  n  0 and a, b  Z, m  Z. Then a is congruent to b modulo m, written as a  b (mod m), if and only if m  a  b. Alternately, a is congruent to b modulo m if and only if (a  b) mod m  0. 7.3. Prime Number An integer p  1 is prime if and only if it is not the product of any two integers greater than 17-16 SWEBOK  GUIDE V4.0 1; i.e, p is prime if p  1    a, b  N: a  1, b  1, a  b  p. The only positive factors of a prime p are 1 and p itself. The numbers 2, 13, 29, 61, etc, are prime numbers. Nonprime integers greater than 1 are called composite numbers. A composite number may be composed by mul- tiplying two integers greater than 1.

--- Chunk 795 ---
Tokens: 379
Type: sentence-based
Text:
A composite number may be composed by mul- tiplying two integers greater than 1. There are many interesting applications of prime numbers; among them is the pub- lic-key cryptography scheme, which involves the exchange of public keys containing the product pq of two random large primes p and q (a private key) that must be kept secret by a given party. 7.4. Greatest Common Divisor The greatest common divisor gcd(a, b) of inte- gers a, b is the greatest integer d that is a divisor both of a and of b  i.e, d  gcd (a, b) for max (d: da  db). For example, gcd(24, 36)  12. Integers a and b are called relatively prime or coprime if and only if their GCD is 1. For example, neither 35 nor 6 is prime, but they are coprime, as these two numbers have no common factors greater than 1, so their GCD is 1. A set of integers X  i1, i2,  is relatively prime if all possible pairs ih, ik, h  k drawn from the set X are relatively prime. 8. Basics of Counting 1, c6 The sum rule states that if a task t1 can be done in n1 ways and a second task t2 can be done in n2 ways, and if these tasks cannot be done at the same time, then there are n1  n2 ways to do either task. If A and B are disjoint sets, then A  BA  B. In general if A1, A2, , An are disjoint sets, then A1  A2    An  A1  A2    An. If 200 athletes do sprint events and 30 ath- letes participate in the long jump event, then how many ways are there to pick one athlete who is either a sprinter or a long jumper? Using the sum rule, the answer would be 200  30  230.

--- Chunk 796 ---
Tokens: 383
Type: sentence-based
Text:
Using the sum rule, the answer would be 200  30  230. The product rule states that if a task t1 can be done in n1 ways and a second task t2 can be done in n2 ways after the first task has been done, then there are n1  n2 ways to perform the procedure. If A and B are disjoint sets, then A  B  A  B. In general, if A1, A2, , An are disjoint sets, then A1  A2    An  A1  A2  . An. If 200 athletes do sprint events and 30 ath- letes participate in the long jump event, then how many ways are there to pick two ath- letes so that one is a sprinter and the other is a long jumper? Using the product rule, the answer would be 200  30  6,000. The principle of inclusion-exclusion states that if a task t1 can be done in n1 ways and a second task t2 can be done in n2 ways at the same time with t1, then to find the total number of ways the two tasks can be done, one must subtract the number of ways to do both tasks from n1  n2. If A and B are not disjoint, A  B  A  B  A  B. In other words, the principle of inclu- sion-exclusion aims to ensure that the objects in the intersection of two sets are not counted more than once. Recursion is the general term for defining an object in terms of itself. There are recur- sive algorithms, recursively defined functions, relations, sets, etc. A recursive function is a function that calls itself. For example, we can define f(n)  3  f(n  1) for all n  N and n  0 and f(0)  5. An algorithm is recursive if it solves a problem by reducing it to an instance of the same problem with a smaller input.

--- Chunk 797 ---
Tokens: 383
Type: sentence-based
Text:
An algorithm is recursive if it solves a problem by reducing it to an instance of the same problem with a smaller input. MATHEMATICAL FOUNDATIONS 17-17 A phenomenon is said to be random if indi- vidual outcomes are uncertain but the long- term pattern of many individual outcomes is predictable. The probability of any outcome for a random phenomenon is the proportion of times the outcome would occur in a very long series of repetitions. The probability P(A) of any event A satis- fies 0  P(A)  1. Any probability is a number between 0 and 1. If S is the sample space in a probability model, then P(S)  1. All pos- sible outcomes together must have a proba- bility of 1. Two events are disjoint if they have no out- comes in common and so can never occur together. If A and B are two disjoint events, P(A or B)  P(A)  P(B). This is known as the addition rule for disjoint events. If two events have no outcomes in common, the probability that one or the other occurs is the sum of their individual probabilities. Permutation is an arrangement of objects in which the order matters without repeti- tion. For example, one can choose r objects in a particular order from a total of n objects by using nPr ways, where npr  n! (n  r). Various notations, such as nPr and P(n, r), are used to represent the number of permutations of a set of n objects taken r at a time. Combination is a selection of objects in which the order does not matter without rep- etition. This is different from a permutation because the order does not matter.

--- Chunk 798 ---
Tokens: 392
Type: sentence-based
Text:
This is different from a permutation because the order does not matter. If only the order is changed (and not the members), no new combination is formed. One can choose r objects in any order from a total of n objects using nCr ways, where nCr  n! r! (n  r). 9. Discrete Probability 1, c7 Probability is the mathematical description of randomness. Basic definitions of probability and randomness are provided in the previous section. Here, we start with the concepts behind probability distribution and discrete probability. A probability model is a mathemat- ical description of a random phenomenon consisting of two parts: a sample space S and a way of assigning probabilities to events. The sample space defines the set of all possible outcomes, whereas an event is a subset of a sample space representing a possible outcome or a set of outcomes. A random variable is a function or rule that assigns a number to each outcome. Basically, it is a symbol that represents the outcome of an experiment. For example, X could be the number of heads when the experiment is flip- ping a coin n times. Similarly, S could be the speed of a passing car as measured on a radar detector. The values for a random variable could be discrete or continuous, depending on the experiment. A discrete random variable can hold all possible values (i.e, can represent all possible outcomes) without missing any, although it might take an infinite amount of time. A continuous random variable is used to measure an uncountable number of values even when an infinite amount of time is given.

--- Chunk 799 ---
Tokens: 390
Type: sentence-based
Text:
A continuous random variable is used to measure an uncountable number of values even when an infinite amount of time is given. For example, if random variable X rep- resents an outcome that is a real number between 1 and 100, then X may have an infinite number of values. Therefore, one can never list all possible outcomes for X, even if an infinite amount of time is allowed. Here, X is a continuous random variable. On the other hand, for the same interval of 1 to 100, another random variable Y can be used to list all integer values in the range. Here, Y is a dis- crete random variable. An uppercase letter, say X, will represent the name of the random variable. Its lowercase counterpart, x, will represent the value of the random variable. The probability that the random variable X will equal x is: P(X  x) or, more simply, P(x). A Probability Distribution (Density) Function (PDF) is a table, formula or graph that describes the values of a random vari- able and the probabilities associated with these values. Probabilities associated with 17-18 SWEBOK  GUIDE V4.0 discrete random variables have the following properties:  0  P(x)  1 for all x  P(x)  1 A discrete probability distribution can be rep- resented as a discrete random variable. The mean  of a probability distribution model is the sum of the product terms for individual events and their outcome probability. In other words, for the possible outcomes x1, x2, , xn in a sample space S if pk is the probability of outcome xk, the mean of this probability would be   x1p1  x2p2    xnpn.

--- Chunk 800 ---
Tokens: 391
Type: sentence-based
Text:
In other words, for the possible outcomes x1, x2, , xn in a sample space S if pk is the probability of outcome xk, the mean of this probability would be   x1p1  x2p2    xnpn. The mean of the probability density for the distribution in Figure 17.23 would be the following: 1  (16)  2  (16)  3  (16)  4  (16)  5  (16)  6  (16)  21  (16)  3.5 Here, the sample space refers to the set of all possible outcomes. The variance 2 of a discrete probability model is 2  (x1  )2p1  (x2  )2p2    (xk  )2pk. The standard deviation, , is the square root of the variance. For the probability distribution in Figure 17.23, the variation 2 would be the following: 2  (1  3.5)2  (16)  (2  3.5)2  (16)  (3  3.5)2  (16)  (4 - 3.5)2  (16)  (5  3.5)2  (16)  (6  3.5)2  (16)  (6.25  2.25  0.25  0.5  2.25  6.25)  (16)  17.5  (16)  2.90  standard deviation s  1.70 These numbers aim to derive the average value from repeated experiments. This is based on the most important principle in probability  i.e, the average value from repeated exper- iments is likely to be close to the expected value of one experiment. Moreover, the average value is more likely to be closer to the expected value of any one experiment as the number of experiments increases. 10. Numerical Precision, Accuracy, and Error 2, c1 The main goal of numerical analysis is to develop efficient algorithms for computing precise numerical values of functions, as well as finding solutions to algebraic and differen- tial equations, optimization problems, etc. Digital computers can store finite num- bers only.

--- Chunk 801 ---
Tokens: 376
Type: sentence-based
Text:
Digital computers can store finite num- bers only. A digital computer cannot repre- sent any infinitely large number  be it an integer, rational number, or any real or com- plex number see section 7, Number Theory. The mathematics of approximation is critical for working with numbers in the finite range a computer can handle. Each number in a computer is assigned a location (e.g, an address or register) and con- sists of a quantity of binary digits, or bits. A k-bit location can store any of N  2k different numbers. A 32-bit location can store any of N  232  4.3  109 different numbers, while a 64-bit location can store any of N  264  1.84  1019 different numbers. The question is how to distribute those numbers for max- imum efficiency and accuracy in practical computations. One choice is to distribute the numbers evenly, leading to fixed-point arithmetic. In this system, the first bit represents the sign, and the remaining bits represent magnitude. The decimal point  more appropriately, the binary point (the transition between whole and fractional values)  can be anywhere. Integer numbers are represented by placing the binary point immediately to the right of the least significant bit, and integer num- bers between 2k11 and 2k1 can be stored. Placing the binary point to the left of the least X 1 2 3 4 5 6 P(x) 16 16 16 16 16 16 Figure 17.23. A Discrete Probability Function for a Rolling Die MATHEMATICAL FOUNDATIONS 17-19 significant bit allows non-integer values to be represented.

--- Chunk 802 ---
Tokens: 365
Type: sentence-based
Text:
A Discrete Probability Function for a Rolling Die MATHEMATICAL FOUNDATIONS 17-19 significant bit allows non-integer values to be represented. Another choice is to space the numbers closely together, say with a uniform gap of 2n, and thereby distribute the total N num- bers uniformly over the interval 2n1N  x  2n1N. Real numbers lying between the gaps are represented by either rounding (meaning the closest exact representative) or chopping (meaning the exact representative immediately below  or above, if negative  the number). Numbers outside the range must be rep- resented by the largest (or largest negative) number that can be represented. This becomes a symbol for overflow, which occurs when a com- putation produces a value outside the range. When processing speed is a significant bot- tleneck, fixed-point representations can be an attractive and faster alternative to the more cumbersome floating-point arithmetic most commonly used in practice. Accuracy and precision are important terms in numerical analysis. Accuracy is the closeness with which a mea- sured or computed value agrees with the true value. Precision, on the other hand, is the close- ness with which two or more measured or computed values for the same thing agree. In other words, precision is the closeness with which a number represents an exact value. Let x be a real number, and let x be an approximation. The absolute error in the approx- imation x  x is defined as  x  x .

--- Chunk 803 ---
Tokens: 388
Type: sentence-based
Text:
The absolute error in the approx- imation x  x is defined as  x  x . The relative error is defined as the ratio of the absolute error to the size of x  i.e, x  x   x   which assumes x  0; otherwise, relative error is not defined. For example, 1,000,000 is an approx- imation of 1,000,001 with an absolute error of 1 and a relative error of 106, whereas 10 is an approximation of 11 with an absolute error of 1 and a relative error of 0.1. Typically, relative error is more intuitive and the preferred deter- miner of the size of the error. The present con- vention is that errors are always  0 and are  0 if and only if the approximation is exact. An approximation x has k significant dec- imal digits if its relative error is  5  10 k1. This means that the first k digits of x following its first nonzero digit are the same as those of x. Significant digits are the digits of a number that are known to be correct. In a measure- ment, one uncertain digit is included. For example, measurement of length with a ruler of 15.5 mm with 0.5 mm maximum allow- able error has two significant digits, whereas a measurement of the same length using a cal- iper and recorded as 15.47 mm with 0.01 mm maximum allowable error has three sig- nificant digits. 11. Algebraic Structures This section introduces a few representa- tions used in higher algebra. An algebraic structure consists of one or two sets closed under some operations and satisfying several axioms, including none. For example, group, monoid, ring and lattice are examples of alge- braic structures.

--- Chunk 804 ---
Tokens: 388
Type: sentence-based
Text:
For example, group, monoid, ring and lattice are examples of alge- braic structures. Group, monoid and ring are defined in this section. 11.1. Group A set S closed under a binary operation  forms a group if the binary operation satisfies the following four criteria:  Associative: a, b, c  S, the equation (a  b)  c  a  (b  c) holds. Identity: There exists an identity element I  S such that for all a  S, I  a  a  I  a.  Inverse: Every element a  S has an inverse a  S with respect to the binary operation, i.e, a  a  I; for example, the set of integers Z with respect to the addition operation is a group. The iden- tity element of the set is 0 for the addi- tion operation. In x  Z, the inverse of x would be x, which is also included in Z.  Closure property: a, b  S, the result of the operation a  b  S. A group that is commutative i.e, a  b  b  a is known as a commutative or Abelian group. The set of natural numbers N (with the operation of addition) is not a group because 17-20 SWEBOK  GUIDE V4.0 there is no inverse for any x  0 in the set of natural numbers. (The third criterion, the inverse criterion, is violated.) However, the set of natural numbers has some structure. Sets with an associative operation (the first criterion) are called semigroups; if they also have an identity element (the second criterion), they are called monoids. The set of natural numbers under addition is an example of a monoid, a structure that is not quite a group because it is missing the requirement that every element have an inverse under the operation.

--- Chunk 805 ---
Tokens: 361
Type: sentence-based
Text:
The set of natural numbers under addition is an example of a monoid, a structure that is not quite a group because it is missing the requirement that every element have an inverse under the operation. A monoid is a set S that is closed under a single associative binary operation  and has an identity element I  S such that for all a  S, I  a  a  I  a. A monoid must contain at least one element. The set of natural numbers N forms a commutative monoid under addi- tion with identity element 0. The same set of natural numbers N also forms a monoid under multiplication with identity element 1. The set of positive integers P forms a commuta- tive monoid under multiplication with iden- tity element 1. It may be noted that, unlike those in a group, elements of a monoid need not have inverses. A monoid can also be considered a semigroup with an identity element. A subgroup is a group H contained within a bigger group, G, such that the identity ele- ment of G is contained in H, and whenever h1 and h2 are contained in H, so are h1  h2 and h1 1. Thus, the elements of H, equipped with the group operation on G restricted to H, form a group. Given any subset S of a group G, the sub- group generated by S consists of products of elements of S and their inverses. It is the smallest subgroup of G containing S. For example, let G be the Abelian group whose elements are G  0, 2, 4, 6, 1, 3, 5, 7 and whose group operation is addition modulo 8.

--- Chunk 806 ---
Tokens: 385
Type: sentence-based
Text:
It is the smallest subgroup of G containing S. For example, let G be the Abelian group whose elements are G  0, 2, 4, 6, 1, 3, 5, 7 and whose group operation is addition modulo 8. This group has a pair of nontrivial subgroups: J  0, 4 and H  0, 2, 4, 6, where J is also a subgroup of H. In group theory, a cyclic group is a group that can be generated by a single element, in the sense that the group has an element a (called the generator of the group) such that, when this element is written multiplicatively, every element of the group is a power of a. A group G is cyclic if G  an for any integer n. Since any group generated by an element in a group is a subgroup of that group, showing that the only subgroup of a group G that con- tains a is G itself suffices to show that G is cyclic. For example, the group G  0, 2, 4, 6, 1, 3, 5, 7, with respect to addition modulo 8 operation, is cyclic. The subgroups J  0, 4 and H  0, 2, 4, 6 are also cyclic. 11.2. Ring If we take an Abelian group and define a second operation on it, a new structure is found that is different from just a group. If this second operation is associative and is dis- tributive over the first, then we have a ring. A ring is a triple of the form (S, , ), where (S, ) is an Abelian group, (S, ) is a semigroup and  is distributive over ; i.e,  a, b, c  S, the equation a  (b  c)  (a  b)  (a  c) holds. Further, if  is commutative, then the ring is said to be commutative. If there is an identity element for the  operation, then the ring is said to have an identity.

--- Chunk 807 ---
Tokens: 356
Type: sentence-based
Text:
If there is an identity element for the  operation, then the ring is said to have an identity. As an example, (Z, , ), i.e, the set of integers Z with the usual addition and mul- tiplication operations, is a ring. As (Z, ) is commutative, this ring is a commutative or Abelian ring. The ring has 1 as its iden- tity element. Note that the second operation may not have an identity element, nor do we need to find an inverse for every element with respect to this second operation. As for what distrib- utive means, intuitively, it is what we do in elementary mathematics when we perform the following operation: a  (b  c)  (a  b)  (a  c). A field is a ring for which the elements of the set, excluding 0, form an Abelian group with the second operation. A simple example of a field is the field of rational numbers (R, , ) with the usual addition and multiplica- tion operations. The numbers are of the form ab  R, where a, b are integers and b  0. The MATHEMATICAL FOUNDATIONS 17-21 additive inverse of such a fraction is simply ab, and the multiplicative inverse is ba, pro- vided that a  0. 12. Engineering Calculus Calculus is a branch of mathematics that deals with study of continuous transition, deriva- tives and integrals of functions using methods originally based on the summation of infin- itesimal differences. Engineering Calculus focuses on learning analytical geometry and vectors for engineering applications.

--- Chunk 808 ---
Tokens: 354
Type: sentence-based
Text:
Engineering Calculus focuses on learning analytical geometry and vectors for engineering applications. Engineering Calculus includes the learning of the following:  Limits  Continuity  Differentiation  Integration  Transcendental functions  Vector calculus Limits are the building blocks of Calculus. For a function f(x), the limit of the function at a point a is the value the function achieves at a point a. L  lim x-a f(x) A function is said to be Continuous on the interval a, b if it is continuous at each point in the interval. Lim f(x)  f (a) x-a The two major elements of calculus are differ- ential calculus and integral calculus. Differential calculus analyzes the rate of change of one quantity in rela- tion to the rate of change of another. Geometrically, it is the slope of the line tangent to the graph of the function. The rate of change of x with respect to y is expressed as dxdy. Integral calculus analyzes such concepts as the area or volume enclosed by a function. A transcendental function, in contrast to an algebraic function, is an analytic function that does not satisfy a polynomial equation. Vector calculus deals with the differentia- tion and integration of vector fields in the three-dimensional Euclidean space. Software engineers are encouraged to learn Engineering Calculus with case studies. These concepts are required for analysing and extrapolating data. 13. New Advancements 13.1.

--- Chunk 809 ---
Tokens: 378
Type: sentence-based
Text:
New Advancements 13.1. Computational Neurosciences Computational Neurosciences is a branch of Neurosciences that uses mathematical models, computer simulations and brain abstraction to understand and analyze cognitive abilities of the nervous systems. This enables the learning of control theory, cybernetics, quantitative psychology, machine learning, artificial intel- ligence, creative  imagination and connec- tionism among others. The central assumption of computational neuroscience is that the brain computes. What does that mean? Generally speaking, a com- puter is a dynamic system whose state vari- ables encode information about the external world. In short, computation equals coding plus dynamics. Some neuroscientists study the way that information is encoded in neural activity and other dynamic variables of the brain. Others try to characterize how these dynamic variables evolve over time. The study of neural dynamics can be further subdivided into two separate strands. One tradition, exemplified by the work of Hodgkin and Huxley, focuses on the biophysics of single neurons. The other focuses on the dynamics of networks, concerning itself with phenomena that emerge from the inter- actions between neurons. Therefore computa- tional neuroscience can be divided into three sub-specialties: neural coding, biophysics of neurons, and neural networks. 13.2. Genomics The in-silico analysis of nucleotide sequences 17-22 SWEBOK  GUIDE V4.0 of chromosome(s) from a given organism is called genome.

--- Chunk 810 ---
Tokens: 393
Type: sentence-based
Text:
Genomics The in-silico analysis of nucleotide sequences 17-22 SWEBOK  GUIDE V4.0 of chromosome(s) from a given organism is called genome. The genome is the genetic material of living organisms, containing hereditary characteristics. It is constituted by DNA. Genomic studies aim to understand how genes and genetic information are orga- nized within the genome and how this orga- nization determines their function. Genomics deals with structure, func- tion, mapping, evolution and editing of genomes, including sequencing and anal- ysis of genomes. Significant research works are being under- taken in the areas of preventive and thera- peutic healthcare, especially in the area of detection, analysis and repair of genetic dis- orders. These include genome data security, genome data sharing, efficiency in genome data analysis among others. Genomics encompasses a variety of tech- niques and approaches, including DNA sequencing, bioinformatic analysis, study of genetic variation, computational modeling, and much more. The advancement of DNA sequencing technologies and bioinformatic analysis has significantly propelled progress in genomics, enabling detailed study of genomes across various organisms. Due to the large amount of data repre- sented by nucleotide sequences obtained from genome sequencing, informatics is required to handle these data. And the development of specific software for the field relies heavily on Software Engineering. MATRIX OF TOPICS VS. REFERENCE MATERIAL Rosen 2018 1 Cheney and Kincaid 2020 2 1. Basic Logic c1 2. Proof Techniques c1 3.

--- Chunk 811 ---
Tokens: 389
Type: sentence-based
Text:
Proof Techniques c1 3. Set, Relation, Function c2 4. Graph and Tree c10, c11 5. Finite State Machine c13 6. Grammar c13 7. Number Theory c4 8. Basics of Counting c6 9. Discrete Probability c7 10. Numerical Precision, Accuracy and Error c2 11. Algebraic Structures 12. Calculus REFERENCES 1 K. Rosen, Discrete Mathematics and Its Applications, 8th ed, McGraw-Hill, 2018. 2 E.W. Cheney and D.R. Kincaid, Numerical Mathematics and Computing, 7th ed, Addison Wesley, 2020. 18-1 CHAPTER 18 Engineering Foundations ACRONYMS CAD Computer-Aided Design CMMI Capability Maturity Model Integration PDF Probability Density Function PMF Probability Mass Function RCA Root Cause Analysis SDLC Software Development Life Cycle INTRODUCTION The Institute of Electrical and Electronics Engineers (IEEE) defines engineering as the application of a systematic, disciplined, quanti- fiable approach to structures, machines, prod- ucts, systems or processes 1. As the theory and the practice of software engineering mature, it is increasingly apparent that software engineering as a discipline is based on skills and knowledge that are common to all engineering disciplines. This knowledge area (KA) explores engineering foundations pertinent to other engineering dis- ciplines that also apply to software engineering. The focus is on covering topics that support other KAs while minimizing duplication of content covered elsewhere in this Guide. BREAKDOWN OF TOPICS FOR ENGINEERING FOUNDATIONS The breakdown of topics for the Engineering Foundations KA is shown in Figure 18.1. 1.

--- Chunk 812 ---
Tokens: 379
Type: sentence-based
Text:
1. The Engineering Process 2, c4 The engineering process, which is common to all engineering disciplines, is discussed more fully in the Software Engineering Economics KA. (Refer to that chapter for more informa- tion.) A brief, high-level summary is included here. Figure 18.2 shows the process flow. The engineering process is necessarily iter- ative; knowledge gained at any point may be relevant to earlier steps, triggering iteration. These steps are briefly defined below:  Understand the real problem  Engineering begins when a need is recog- nized and no existing solution meets that need. However, the problem that needs to be solved is not always the problem engineers are asked to solve. Use root cause analysis techniques (discussed later in this KA) to discover the underlying problem needing a solution. Define the selection criteria  Engineering decisions must consider various factors; for example, they must consider financial criteria, as discussed in the Software Engineering Economics KA. Be sure to identify all relevant selec- tion criteria. Identify all reasonable, technically fea- sible solutions  The best solution is rarely the first solution that comes to mind. Therefore, consider multiple tech- nically feasible solutions to ensure that the optimal solution is among the set considered. Evaluate each solution against the selec- tion criteria  Determine how well each technically feasible solution satisfies the need while meeting the various criteria (for example, financial criteria).

--- Chunk 813 ---
Tokens: 384
Type: sentence-based
Text:
Evaluate each solution against the selec- tion criteria  Determine how well each technically feasible solution satisfies the need while meeting the various criteria (for example, financial criteria). Select the preferred option  Identify which technically feasible solution best satisfies the selection criteria. 18-2 SWEBOK  GUIDE V4.0  Monitor the performance of the selected solution  The engineering process nec- essarily depends on estimates, and those estimates can be wrong. Therefore, it is essential to evaluate the selected alterna- tives real-world performance and, if nec- essary (and possible), decide whether one of the other alternatives might be better. Much of the rest of this KA elabo- rates on details of this higher-level engi- neering process. 2. Engineering Design 3, c1s2-s4 A products design will affect or even deter- mine its life cycle costs. This is true for man- ufactured products as well as for software. Software design is guided by the features to be implemented and the quality attributes to be achieved. In the software engineering con- text, design has a particular meaning; while there are commonalities between engineering design as discussed in this section and soft- ware engineering design as discussed in the Software Architecture KA and the Software Design KA, there are also many differences. For example, the scope of engineering design is generally viewed as much broader than that of software design. Many disciplines involve solving problems for which there is a single correct solution.

--- Chunk 814 ---
Tokens: 336
Type: sentence-based
Text:
Many disciplines involve solving problems for which there is a single correct solution. In engineering, most problems have many solutions, and the focus is on finding a fea- sible solution (among many alternatives) that best meets the needs presented, economi- cally. In business, where the goal may be to foster innovation in the marketplace, product definitions may derive from a business case. Whichever is the origin, possible solutions are often constrained by explicitly imposed limitations such as cost, available resources, and the state of discipline or domain knowl- edge. In engineering problems, implicit con- straints (such as the physical properties of materials or the laws of physics) sometimes restrict the set of feasible solutions for a given problem. 2.1. Engineering Design in Engineering Education Various engineering education accreditation bodies, including the Canadian Engineering Accreditation Board and the Accreditation Board for Engineering and Technology (ABET), place great value on engineering design, as evidenced by their high expecta- tions in this area. The Canadian Engineering Accreditation Board requires specified levels of engineering design experience and coursework for engi- neering students and certain qualifications for the faculty members who teach such course- work or supervise design projects.

--- Chunk 815 ---
Tokens: 398
Type: sentence-based
Text:
The Canadian Engineering Accreditation Board requires specified levels of engineering design experience and coursework for engi- neering students and certain qualifications for the faculty members who teach such course- work or supervise design projects. The organi- zations accreditation criteria state: Engineering Foundations Te Engineering Process Engineering Design Abstraction and Encapsulation Empirical Methods and Experimental Techniques Statistical Analysis Modeling, Simulation, and Prototyping Engineering Design in Engineering Education Design as a Problem- Solving Activity Designed Experiment Observational Study Retrospective Study Levels of Abstraction Encapsulation Hierarchy Alternate Abstractions Unit of Analysis (Sampling Units), Population, and Sample Correlation and Regression Measurement Levels (Scales) of Measurement Implications of Measurement Teory on Programming Languages Direct and Derived Measures Reliability and Validity Assessing Reliability Goal-Question- Metric Paradigm: Why Measure? Root Cause Analysis Root Cause Analysis Techniques Root Cause- Based Improvement Industry 4.0 and Software Engineering Standards Modeling Simulation Prototyping Figure 18.1. Breakdown of Topics for the Engineering Foundations KA ENGINEERING FOUNDATIONS 18-3 Design: An ability to design solutions for com- plex, open-ended engineering problems and to design systems, components or processes that meet specified needs with appropriate atten- tion to health and safety risks, applicable stan- dards, and economic, environmental, cultural, and societal considerations 4, p7.

--- Chunk 816 ---
Tokens: 388
Type: sentence-based
Text:
Breakdown of Topics for the Engineering Foundations KA ENGINEERING FOUNDATIONS 18-3 Design: An ability to design solutions for com- plex, open-ended engineering problems and to design systems, components or processes that meet specified needs with appropriate atten- tion to health and safety risks, applicable stan- dards, and economic, environmental, cultural, and societal considerations 4, p7. Similarly, ABET defines engineering design as follows:  a process of devising a system, component, or process to meet desired needs and specifica- tions within constraints. It is an iterative, cre- ative, decision-making process in which the basic sciences, mathematics, and engineering sciences are applied to convert resources into solutions 5, p7. Thus, engineering design is vital to the training and education of all engineers. The rest of this section focuses on various aspects of engineering design. 2.2. Design as a Problem-Solving Activity 3, c1s4, c2s1, c3s3 6, c5s1 Engineering design is primarily a prob- lem-solving activity. Finding a solution is particularly challenging because design prob- lems tend to be open-ended and vaguely defined, and there are usually several ways to solve the same problem. Design is generally considered a wicked problem  a term coined by Horst Rittel in the 1960s when design methods were a subject of intense interest. Rittel sought an alternative to the linear, step- by-step process many designers and design theorists were exploring and argued that most problems addressed by designers are wicked problems.

--- Chunk 817 ---
Tokens: 379
Type: sentence-based
Text:
Rittel sought an alternative to the linear, step- by-step process many designers and design theorists were exploring and argued that most problems addressed by designers are wicked problems. As explained by McConnell, a wicked problem presents a paradox: One can define it only by solving it, or by solving part of it. However, that solution is not the final solution; a wicked problem must be solved once to define it clearly and solved again to create a solution that works. This has been an important insight for software designers for decades 6, c5s1. 3. Abstraction and Encapsulation 6, c5s2-4 Abstraction is an indispensable technique associated with problem-solving. It refers to both the process and the result of generaliza- tion, where one reduces the information about a concept, problem or observable phenomenon in order to focus on the big picture. One of the most important skills in any engineering undertaking is the ability to frame the levels of abstraction appropriately. According to Voland, Through abstrac- tion, we view the problem and its possible solution paths from a higher level of con- ceptual understanding. As a result, we may become better prepared to recognize possible relationships between different aspects of the Dene the selection criteria Identify all reasonable technically feasible solutions Select the preferred alternative Monitor the performance of the selected alternative Evaluate each alternative against the selection criteria Understand the real problem Figure 18.2.

--- Chunk 818 ---
Tokens: 399
Type: sentence-based
Text:
As a result, we may become better prepared to recognize possible relationships between different aspects of the Dene the selection criteria Identify all reasonable technically feasible solutions Select the preferred alternative Monitor the performance of the selected alternative Evaluate each alternative against the selection criteria Understand the real problem Figure 18.2. The Engineering Process 18-4 SWEBOK  GUIDE V4.0 problem and thereby generate more creative design solutions 2. This is true in computer science in general (such as hardware vs. soft- ware) and in software engineering in partic- ular (e.g, data structure vs. data flow). Dijkstra states, The purpose of abstracting is not to be vague, but to create a new semantic level in which one can be absolutely precise 7. 3.1. Levels of Abstraction When abstracting, we concentrate on one level of the big picture at a time, confident that we can connect effectively with levels above and below. Although we focus on one level, abstraction does not mean knowing nothing about the neighboring levels. Abstraction levels do not necessarily correspond to discrete com- ponents in reality or in the problem domain, but to well-defined standard interfaces such as application programming interfaces (APIs). Standard interfaces offer advantages such as portability, easier softwarehardware integra- tion and wider usage. 3.2. Encapsulation Encapsulation is a mechanism used to imple- ment abstraction. When we are working with one level of abstraction, the information con- cerning the levels below and above that level is encapsulated.

--- Chunk 819 ---
Tokens: 373
Type: sentence-based
Text:
When we are working with one level of abstraction, the information con- cerning the levels below and above that level is encapsulated. This can be information about the concept, problem, or observable phenom- enon or the permissible operations on these entities. Encapsulation usually means hiding underlying details about the level above the interface provided by the abstraction. For example, hiding information about an object is useful because we dont need to know the details of how the object is represented or how the operations on the object are implemented. 3.3. Hierarchy When we use abstraction in our problem formulation and solution, we might use dif- ferent abstractions at different times  in other words, we work on different levels of abstraction as the situation requires. Usually, these different levels of abstraction are orga- nized in a hierarchy. There are many ways to structure a particular hierarchy, and the cri- teria used in determining the specific content of each layer vary depending on the individ- uals performing the work. Sometimes, a hierarchy of abstraction is sequential, meaning that each layer has one and only one predecessor (lower) layer and one and only one successor (upper) layer  except the upmost layer (which has no suc- cessor) and the bottommost layer (which has no predecessor). Sometimes, however, the hierarchy is organized in a tree structure, which means each layer can have more than one predecessor layer but only one successor layer.

--- Chunk 820 ---
Tokens: 381
Type: sentence-based
Text:
Sometimes, however, the hierarchy is organized in a tree structure, which means each layer can have more than one predecessor layer but only one successor layer. Occasionally, a hierarchy can have a many-to-many structure, in which each layer has multiple predecessors and successors. A hierarchy never contains a loop. A hierarchy often forms naturally in task decomposition. Often, task analysis can be decomposed hierarchically, starting with the organizations larger tasks and goals and breaking each into smaller subtasks that can again be subdivided. This continuous division of tasks into smaller ones produces a hierar- chical structure of tasks and subtasks. 3.4. Alternate Abstractions Sometimes, multiple alternate abstractions for the same problem are useful to keep dif- ferent perspectives in mind. For example, we can have a class diagram, a state chart and a sequence diagram for the same software at the same level of abstraction. These alter- nate abstractions do not form a hierarchy but complement each other, helping to illuminate the problem and its solution. Though benefi- cial, keeping alternate abstractions in sync is sometimes difficult. 4. Empirical Methods and Experimental Techniques 8, c1 The engineering process involves pro- posing solutions or models of solutions and ENGINEERING FOUNDATIONS 18-5 conducting experiments or tests to study those proposed solutions or models. Thus, engineers must understand how to create an experiment and analyze the results to evaluate proposed solutions.

--- Chunk 821 ---
Tokens: 391
Type: sentence-based
Text:
Thus, engineers must understand how to create an experiment and analyze the results to evaluate proposed solutions. Empirical methods and experi- mental techniques help the engineer describe and understand variability in their observa- tions, identify the sources of that variability, and make decisions. Three types of empirical studies commonly used in engineering efforts are designed experiments, observational studies and ret- rospective studies. Brief descriptions of the commonly used methods are given below. 4.1. Designed Experiment A designed or controlled experiment tests a hypothesis by manipulating one or more inde- pendent variables to measure their effect on one or more dependent variables. A precon- dition for conducting this experiment is the existence of a clear hypothesis. Therefore, engineers need to understand how to formu- late clear hypotheses. Designed experiments allow engineers to determine precisely how the variables are related and, specifically, whether a cause-ef- fect relationship exists between them. Each combination of values of the independent vari- ables is a treatment. The simplest experiments have just two treatments, representing two levels of a single independent variable (e.g, using a tool vs. not using a tool). More com- plex experimental designs arise when more than two levels, more than one independent variable, or any dependent variables are used. 4.2. Observational Study An observational or case study is an empirical inquiry that makes observations of processes or phenomena within a real-world context.

--- Chunk 822 ---
Tokens: 391
Type: sentence-based
Text:
Observational Study An observational or case study is an empirical inquiry that makes observations of processes or phenomena within a real-world context. While an experiment deliberately ignores con- text, an observational or case study includes context. A case study is most useful when it focuses on how and why questions, on when the behavior of those involved cannot be manipu- lated, and on when contextual conditions are relevant and the boundaries between the phe- nomena and context are unclear. 4.3. Retrospective Study Retrospective studies involve the analysis of historical data, and thus are also known as historical studies. This type of study uses data (regarding some phenomenon) archived over time. This archived data is then analyzed to find relationships between variables, to pre- dict future events or to identify trends. One limitation is that the quality of the analysis depends on the quality of the archived data, and historical data may be incomplete, incon- sistently measured or incorrect. 5. Statistical Analysis 8, c9s1, c2s1 9, c11s3 Engineers must understand how product and process characteristics vary. Engineers often encounter situations where the relationship between different variables must be studied. Most studies use samples, but the results need to be understood with respect to the full pop- ulation. Therefore, engineers must understand statistical techniques for collecting and inter- preting reliable data (sampling and analysis) to arrive at results that can be generalized. These techniques are discussed below. 5.1.

--- Chunk 823 ---
Tokens: 380
Type: sentence-based
Text:
5.1. Unit of Analysis (Sampling Units), Population, and Sample Unit of analysis. In any empirical study, the researchers must make observations based on chosen units called the units of anal- ysis or sampling units. These units must be clearly identified and be appropriate for the analysis. For example, in a study of the per- ceived usability of a software product, the user or the software function might be the unit of analysis. Population. The set of all respondents or items (possible sampling units) forms the population. For example, for a study of the perceived usability of a software product, the set of all possible users forms the population. 18-6 SWEBOK  GUIDE V4.0 In defining the population, care must be taken to differentiate the study and target populations. The population being studied and the population for which the results are generalized will differ if the study involves a sample. For example, when the study popu- lation consists only of past observations but generalizations are required for the future, the study population and the target popula- tion are not the same. Sample. A sample is a subset of the pop- ulation. The most crucial issue in selecting a sample is its representativeness, including size. The samples must be drawn in a way that ensures draws are independent, and the rules of drawing samples must be predefined so the probability of selecting a particular sampling unit is known beforehand. This method of selecting samples is called probability sampling. Random variable.

--- Chunk 824 ---
Tokens: 389
Type: sentence-based
Text:
Random variable. In statistical termi- nology, the process of making observations or measurements on the sampling units is referred to as conducting the experiment. For example, if the experiment is to toss a coin 10 times and count the number of times the coin lands on heads, every 10 tosses of the coin is a sampling unit and the number of heads for a given sample is the observation or out- come for the experiment. The outcome of an experiment is obtained in terms of real num- bers and defines the random variable being studied. The attribute of the items being mea- sured at the outcome of the experiment rep- resents the random variable being studied; the observation obtained from a particular sam- pling unit is a particular realization of the random variable. In the example of the coin toss, the random variable is the number of heads observed for each experiment. The set of possible values of a random vari- able may be finite or infinite but countable (e.g, the set of all integers or the set of all odd numbers). In such a case, the random variable is called a discrete random variable. In other cases, the random variable under consider- ation may take values on a continuous scale and is called a continuous random variable. Event. A subset of possible values of a random variable is called an event. Suppose X denotes some random variable; then, for example, we may define different events such as X  x or X  x and so on. Distribution of a random variable. A random variables range and pattern of variation are given by its distribution.

--- Chunk 825 ---
Tokens: 386
Type: sentence-based
Text:
A random variables range and pattern of variation are given by its distribution. When the distribu- tion of a random variable is known, it is pos- sible to compute the probability of any event. Some distributions occur commonly and are used to model many random variables occur- ring in practice in the context of engineering. A few of the more commonly occurring dis- tributions are described below:  Binomial distribution is used to model random variables that count the number of successes in n trials carried out inde- pendently of each other, where each trial results in success or failure. We assume that the chance of a successful trial remains constant 8, c3s5. Poisson distribution is used to model the count of occurrences of some event over time or space 8, c3s8. Normal distribution is used to model con- tinuous or discrete random variables by taking a very large number of values 8, c4s5. Concept of parameters. Parameters charac- terize a statistical distribution. For example, the proportion of successes in any given trial is the only parameter characterizing a binomial distribution. Similarly, the Poisson distribu- tion is characterized by a rate of occurrence. A normal distribution is characterized by two parameters: its mean and standard deviation. Once the values of the parameters are known, the distribution of the random vari- able is revealed and the chance (probability) of any event can be computed. The proba- bilities for a discrete random variable can be computed through the probability mass func- tion (PMF).

--- Chunk 826 ---
Tokens: 359
Type: sentence-based
Text:
The proba- bilities for a discrete random variable can be computed through the probability mass func- tion (PMF). The PMF is defined at discrete points and gives the point mass  i.e, the probability that the random variable takes that particular value. Likewise, for a contin- uous random variable, we have the probability density function (PDF). The PDF needs to be ENGINEERING FOUNDATIONS 18-7 integrated over a range to obtain the proba- bility that the continuous random variable lies between certain values. Thus, if the PMF or PDF is known, the chances of the random variable taking a certain set of values may be computed theoretically. Concept of estimation 8, c7s1, c7s3. The true values of the parameters of a distribution are usually unknown and need to be estimated from the sample observations. The estimates are functions of the sample values and are called statistics. For example, the sample mean is a statistic and may be used to estimate the population mean. Similarly, the rate of occur- rence of defects estimated from the sample (rate of defects per line of code) is a statistic and serves as the estimate of the population rate of defects per line of code. The statistic used to estimate a population parameter is often referred to as the estimator of the parameter. The results of the estimators themselves are random. If we take a different sample, we will likely get a different population param- eter estimate.

--- Chunk 827 ---
Tokens: 387
Type: sentence-based
Text:
If we take a different sample, we will likely get a different population param- eter estimate. In the theory of estimation, we need to understand different properties of estimators  particularly, how much the estimates can vary across samples and how to choose between different ways to obtain the estimates. For example, if we wish to estimate the mean of a population, we might use as our estimator a sample mean, a sample median, a sample mode or the midrange of the sample. Each of these estimators has different statis- tical properties that might impact the stan- dard error of the estimate. Types of estimates 8, c7s3, c8s1. There are two types of estimates: point estimates and interval estimates. When we use the value of a statistic to estimate a population parameter, we get a point estimate. As the name indi- cates, a point estimate gives a point value of the parameter estimated. Although point estimates are often used, they leave room for many questions. For instance, they do not tell us anything about the possible error size or the estimates statistical properties. Thus, we might need to supple- ment a point estimate with information about the sample size and the estimates variance. Alternatively, we might use an interval esti- mate. An interval estimate is a random interval whose lower and upper limits are functions of the sample observations and the sample size. The limits are computed based on assumptions regarding the sampling distribution of the point estimate on which the limits are based. Properties of estimators.

--- Chunk 828 ---
Tokens: 399
Type: sentence-based
Text:
Properties of estimators. Various statistical properties of estimators are used to deter- mine the appropriateness of an estimator in a given situation. The most important proper- ties are efficiency, consistency with respect to the population, and lack of bias. Tests of hypotheses 8, c9s1. A hypothesis is a statement about the possible values of a parameter. For example, suppose someone claims that a new method of software devel- opment reduces the occurrence of defects. The hypothesis is that the rate of occurrence of defects has been reduced. When we test the hypothesis, we decide  based on sample observations  whether it should be accepted or rejected. To test hypotheses, the null and alterna- tive hypotheses are formed. The null hypoth- esis is the hypothesis of no change, denoted as H0. The alternative hypothesis is written as H1. The alternative hypothesis may be one-sided or two-sided. For example, if we have the null hypothesis that the population mean is not less than some given value, the alternative hypoth- esis would be that it is less than that value, and we would have a one-sided test. However, if we have the null hypothesis that the popula- tion mean is equal to some given value, the alternative hypothesis would be that it is not equal, and we would have a two-sided test (because the true value could be either less than or greater than the given value). The first step in testing a hypothesis is to compute a statistic. In addition, a region is defined such that if the computed value of the statistic falls within that region, the null hypothesis is rejected.

--- Chunk 829 ---
Tokens: 351
Type: sentence-based
Text:
In addition, a region is defined such that if the computed value of the statistic falls within that region, the null hypothesis is rejected. This region is called the critical region (also known as the confidence interval). In tests of hypotheses, we need to accept or reject the null hypothesis based on the evidence obtained. In general, the alter- native hypothesis is the hypothesis of interest. 18-8 SWEBOK  GUIDE V4.0 If the computed value of the statistic does not fall inside the critical region, then we cannot reject the null hypothesis. This indicates that there is insufficient evidence to believe that the alternative hypothesis is true. As the decision is based on sample obser- vations, errors are possible; the types of such errors are summarized in the following table. Nature Statistical decision Accept H0 Reject H0 H0 is true OK Type I error (probability  ) H0 is false Type II error (probability  ) OK In testing hypotheses, we aim to maximize the power of the test (the value of 1  ) while ensuring that the probability of a type I error (the value of ) is maintained within a partic- ular value  typically 5. Also note that construction of a test of a hypothesis includes identifying statistic(s) to estimate the parameter(s) and defining a crit- ical region such that if the computed value of the statistic falls within the critical region, the null hypothesis is rejected. 5.2.

--- Chunk 830 ---
Tokens: 379
Type: sentence-based
Text:
5.2. Correlation and Regression 8, c11s2, c11s8 A major objective of many statistical investi- gations is to establish relationships that make it possible to predict one or more variables in terms of others. Although it is desirable to predict a quantity exactly in terms of another quantity, that is seldom possible, and, in many cases, we must be satisfied with estimating the average or expected values. The relationship between two variables is studied using correlation and regression. Both these concepts are explained briefly below. Correlation. The degree of the linear rela- tionship between two variables is measured using the correlation coefficient. Computing the correlation coefficient is appropriate for two variables that measure two different attributes of the same entity. The correlation coefficient takes a value between 1 and 1. The values 1 and 1 indicate a situation where the asso- ciation between the variables is perfect (i.e, given the value of one variable, the other can be estimated with no error). A positive cor- relation coefficient indicates a positive rela- tionship (i.e, if one variable increases, so does the other). On the other hand, when the vari- ables are negatively correlated, an increase of one leads to a decrease in the other. Always remember that correlation does not imply causation. Thus, if two variables are correlated, we cannot conclude that one causes the other. Regression. The correlation analysis only measures the degree of relationship between two variables.

--- Chunk 831 ---
Tokens: 367
Type: sentence-based
Text:
The correlation analysis only measures the degree of relationship between two variables. The analysis to find the strength of the relationship between two variables is called regression analysis. This analysis uses the coefficient of determination  a value between 0 and 1. The closer the coefficient is to 1, the stronger the relationship between the variables. A value of 1 indicates a perfect relationship. 6. Modeling, Simulation, and Prototyping 3, c6 10, c13s3 11, c5 Modeling is part of the abstraction process used to represent aspects of a system. Simulation uses a model of the system to conduct designed experiments to better understand the system, its behavior and relationships among subsys- tems, as well as to analyze aspects of the design. Modeling and simulation can be used to con- struct theories or hypotheses about the systems behavior. Engineers then use those theories to make predictions about the system. Prototyping is another abstraction process where a partial representation (that captures aspects of interest) of the product or system is built. A prototype may be an initial version of the system that lacks the full functionality of the final version. 6.1. Modeling A model is always an abstraction of some real or imagined artifact. Engineers use models in many ways as part of their problem-solving activities. Some models are physical, such as ENGINEERING FOUNDATIONS 18-9 a made-to-scale miniature construction of a bridge or building.

--- Chunk 832 ---
Tokens: 380
Type: sentence-based
Text:
Some models are physical, such as ENGINEERING FOUNDATIONS 18-9 a made-to-scale miniature construction of a bridge or building. Other models are non- physical representations, such as a comput- er-aided design (CAD) drawing of a cog or a mathematical model for a process. Models help engineers understand aspects of a problem. They can also help engineers deter- mine what they know and what they dont know about the problem. There are three types of models: iconic, ana- logic and symbolic. An iconic model is a visually equivalent but incomplete two-dimensional or three-dimensional representation (e.g, maps, globes or built-to-scale models of structures such as bridges or highways). An iconic model resembles the artifact modeled. In contrast, an analogic model is a function- ally equivalent but incomplete representation. The model behaves like the physical artifact even though it may not physically resemble it. Examples of analogic models include a minia- ture airplane for wind tunnel testing or a com- puter simulation of a manufacturing process. Finally, a symbolic model uses a higher level of abstraction, modeling the process or system with symbols such as equations. The engineers can use the symbols to understand, describe, and predict the properties or behavior of the final system or product. An example is the equation F  ma. 6.2. Simulation All simulation models are depictions of reality. A central issue in simulation is how to abstract data and create an appropriate simpli- fication of reality.

--- Chunk 833 ---
Tokens: 395
Type: sentence-based
Text:
A central issue in simulation is how to abstract data and create an appropriate simpli- fication of reality. Developing this abstraction is vital, as misspecification of the abstraction would invalidate the results of the simulation exercise. Simulation can be used for a variety of testing purposes. Simulation is classified based on the type of system under study; simulation can be either continuous or discrete. In software engineering, the emphasis is primarily on discrete simula- tion. Discrete simulations may model event scheduling or process interaction. The main components in such a model include entities, activities and events, resources, the state of the system, a simulation clock, and a random number generator. The simulation generates output that must be analyzed. An important problem in the development of a discrete simulation is that of initializa- tion. Before a simulation can be run, the ini- tial values of all the state variables must be provided. As the simulation designer may not know what initial values are appropriate for the state variables, these values might be chosen somewhat arbitrarily. For instance, it might be decided that a queue should be initialized as empty and idle. This choice for an initial con- dition can have a significant but unrecognized impact on the simulation outcome. 6.3. Prototyping Constructing a prototype of a system is another abstraction process. In this case, an initial version of the system is constructed, often while the system is designed, which helps the designers determine the feasibility of their design.

--- Chunk 834 ---
Tokens: 360
Type: sentence-based
Text:
In this case, an initial version of the system is constructed, often while the system is designed, which helps the designers determine the feasibility of their design. A prototype has many uses, including elic- iting requirements, designing and refining a user interface, and validating functional requirements. The objectives and purposes for building the prototype will guide its con- struction and determine the level of abstrac- tion used. The role of prototyping is somewhat dif- ferent for physical systems and software. With physical systems, the prototype might be the first fully functional version of a system, or it might be a model of the system. In soft- ware engineering, prototypes are also abstract models of part of the software. However, they are usually not constructed with all the archi- tectural, performance and other quality char- acteristics expected in the finished product. In either case, prototype construction must have a clear purpose and be planned, mon- itored and controlled  it is a technique to study a specific problem within a limited con- text 12, c2s8. In conclusion, modeling, simulation and prototyping are powerful techniques for studying the behavior of a system from a 18-10 SWEBOK  GUIDE V4.0 given perspective. All can be used to perform designed experiments to study various aspects of the system. However, these are abstrac- tions and, as such, may not model all attri- butes of interest. 7.

--- Chunk 835 ---
Tokens: 400
Type: sentence-based
Text:
7. Measurement 2, pp442-447 3, c4s4 12, c7s5 13, c3s1-2 Knowing what to measure, how to measure it, what can be done with measurements and even why to measure is critical in engineering endeavors. Everyone involved in an engi- neering project must understand the measure- ment methods, the measurement results and how those results can and should be used. Measurements can be physical, environ- mental, economic, operational or another sort of measurement that is meaningful to the project. This section explores the theory of measurement and how it is fundamental to engineering. Measurement starts as an abstract concept and progresses to a defini- tion of the measurement method and then to the actual application of that method to obtain a measurement result. Each step must be understood, communicated and properly performed to yield usable data. In traditional engineering, direct measures are often used. In software engineering, a combination of both direct and derived measures (defined in 7.3 below) is necessary 13, p273. The theory of measurement states that measurement is an attempt to describe an underlying empirical system. Measurement methods specify activities that assign a value or symbol to an attribute of an entity. Attributes must then be defined in terms of the operations used to identify and mea- sure them (the measurement methods). In this approach, a measurement method is defined as a precisely specified operation that yields a symbol (called the measurement result) as part of the measurement of an attribute. To be useful, the measurement method must be well defined.

--- Chunk 836 ---
Tokens: 382
Type: sentence-based
Text:
To be useful, the measurement method must be well defined. Arbitrariness or vagueness in the method leads to ambiguity in the mea- surement results. In some cases  particularly in the physical world  the attributes we wish to measure are easy to grasp; however, in an artificial world like software engineering, defining attributes might not be that simple. For example, the attributes of height, weight, distance, etc, are easily and uniformly understood (though they may not be very easy to measure in all circum- stances). In contrast, attributes such as software size and complexity require clear definitions. Operational definitions. The definition of attributes, to start with, is often rather abstract. Such definitions do not facilitate measure- ments. For example, we might define a circle as a line forming a closed loop such that the distance between any point on this line and a fixed interior point called the center is con- stant. We might further say that the fixed distance from the center to any point on the closed loop is the circles radius. Though the concept has been defined, no means of mea- suring the radius has been proposed. The oper- ational definition specifies the exact steps or method used to carry out a specific measure- ment. This can also be called the measurement method; sometimes, a measurement procedure might be required to be even more precise. The importance of operational definitions can hardly be overstated. Take the case of the apparently simple measurement of a per- sons height.

--- Chunk 837 ---
Tokens: 375
Type: sentence-based
Text:
Take the case of the apparently simple measurement of a per- sons height. Unless we specify various factors for example, the time the height is mea- sured (because the height of individuals varies throughout the day), how the variability cre- ated by hair is handled, whether the measure- ment is taken when the person is wearing shoes or not, the accuracy expected (to the nearest inch, 12 inch, centimeter, etc.) then even this simple measurement will produce sub- stantial variation. Therefore, engineers must appreciate the need to define measurements from an operational perspective. 7.1. Levels (Scales) of Measurement 2, pp442-447 12, c7s5 13, c3s2 Once the operational definitions have been determined, actual measurements can be taken. Measurement may be carried out in ENGINEERING FOUNDATIONS 18-11 four different scale types: nominal, ordinal, interval, and ratio. Brief descriptions of each are given below: Nominal scale: This is the lowest level of measurement and represents the most unre- stricted assignment of symbols, which are only labels. Nominal scales involve classifi- cation where measured entities are put into one of the mutually exclusive and collectively exhaustive categories (classes). Examples of nominal scales are the following:  Job titles in an organization  Automobile styles (sedan, coupe, hatch- back, minivan, etc.) Software development life cycle (SDLC) models (waterfall, iterative, Agile, etc.) In nominal scales, no relationship among symbols may be inferred.

--- Chunk 838 ---
Tokens: 390
Type: sentence-based
Text:
In nominal scales, no relationship among symbols may be inferred. The only valid types of manipulation of measures in a nominal scale are the following:  Determining whether two entities have the same or different symbol (e.g, Is your job title the same as or different from my job title?) Counting the number of entities having the same symbol (e.g, How many employees have the job title Software Engineer Level 2 in this organization?) Statistical analyses may be carried out to understand how entities belonging to dif- ferent classes perform with respect to some other variable. Ordinal scale: Ordinal scales extend nominal scales by requiring a strict ordering relationship among the symbols. Ordinal scales are neces- sarily transitive (if A  B and B  C, then A  C). The following are examples of ordinal scales:  Finish order in a race (1st, 2nd, 3rd)  Probabilities expressed using terms (remote, unlikely, even, probable, almost certain)  Severities expressed using terms (neg- ligible, marginal, serious, critical, catastrophic)  Level of agreement expressed using terms (strongly agree, somewhat agree, neutral, somewhat disagree, strongly disagree)  Capability Maturity Model Integration (CMMI) staged maturity levels All manipulations of values on nom- inal scales are valid on ordinal scales, while ordinal scales also support more-than and less-than comparisons. For example:  Did you finish that race before, tied with or after me? Is Event X the same, more or less prob- able than Event Y? Is Event X the same, more or less severe than Event Y?

--- Chunk 839 ---
Tokens: 387
Type: sentence-based
Text:
Is Event X the same, more or less severe than Event Y? Is the CMMI staged maturity level of Organization A the same, higher or lower than that of Organization B? When an ordinal scale uses numbers as symbols  like the CMMI staged maturity levels 1, 2, 3, 4 and 5  those numbers cannot be manipulated arithmetically. We cannot say that the difference between CMMI staged maturity level 5 and level 4 (5  4) compares in any meaningful way to the difference between level 3 and level 2 (3  2). Neither can we say that CMMI staged maturity level 4 is twice as good as level 2. Ordinal scales that use numbers as symbols are commonly misused in exactly this way  for example, to present mean and standard deviation (e.g, The average software organization worldwide has a CMMI staged maturity level of 1.763.). Such misuse can easily lead to erroneous conclusions 13, p274. (We can compute the median on an ordinal scale, as this only involves counting.) Using nonnumerical symbols, such as initial, repeat- able, defined, managed, and optimizing (for CMMI staged maturity levels), is preferred because it helps prevent such mistreatment. Properly chosen labels also better communi- cate the meaning of each label. Interval scale: Interval scales extend ordinal scales by requiring that the difference between any pair of adjacent values is constant. The following are examples of interval scales: 18-12 SWEBOK  GUIDE V4.0  Temperatures expressed in degrees Celsius and Fahrenheit: The difference between 9C and 8C is the same as that between 26C and 27C.

--- Chunk 840 ---
Tokens: 373
Type: sentence-based
Text:
The following are examples of interval scales: 18-12 SWEBOK  GUIDE V4.0  Temperatures expressed in degrees Celsius and Fahrenheit: The difference between 9C and 8C is the same as that between 26C and 27C. The differ- ence between 9F and 8F is the same as the difference between 26F and 27F. Calendar dates: The difference between any two consecutive dates is always one day: 24 hours. Shoe sizes in North America: The differ- ence between size 3 and size 4 is the same as the difference between a size 10 and size 11  one-third of an inch, or 8.467 mm. All manipulations of values on ordinal scales are valid on interval scales, while interval scales also support addition and sub- traction. For example:  The difference between 9C and 0C is the same as that between 0C and 9C. The difference between 50F and 0F is the same as that between 25F and 75F. The length of time between May 6 and May 9 is the same as that between November 8 and November 11. Interval scales support most statistical analyses, like mean, standard deviation, cor- relation and regression. Any manipulation involving multiplication or division of values, on the other hand, is meaningless because 0 on an interval scale, if it even exists, does not rep- resent the absence of the measured quantity. A 0 point on an interval scale is arbitrary with respect to the attribute measured. Consider that 0 (both C and F) do not represent the absence of heat (absolute zero), and a North American size 0 shoe has non-zero length.

--- Chunk 841 ---
Tokens: 370
Type: sentence-based
Text:
Consider that 0 (both C and F) do not represent the absence of heat (absolute zero), and a North American size 0 shoe has non-zero length. Therefore, 30C cannot be interpreted as twice as hot as 15C, nor is a North American size 9 shoe three times longer than a size 3 shoe. Ratio scale: Ratio scales extend ordinal scales by requiring the 0 point to represent the absence of the measured attribute. The following are examples of ratio scales:  Temperature in degrees Kelvin (K)  Shoe sizes in the Mondopoint system (commonly used for athletic shoes, ski boots, skates and ballet shoes); a size 270105 shoe fits a foot 270 mm long and 105 mm wide  Count of decision constructs (e.g, if(), for(), while(), in a given source code file)  Money Ratio scales support all arithmetic and sta- tistical manipulations. Values in one ratio scale can often be trivially transformed into corresponding values in another ratio scale that measures the same attribute by using a multiplication factor. Distances in inches can be trivially transformed into centimeters, weights in kilograms can be trivially trans- formed into pounds, speed in knots can be trivially transformed into kilometers per hour, and so on. An additional measurement scale, the abso- lute scale, is a ratio scale with uniqueness of measure (no transformation is possible). The number of software engineers working on a project is an absolute scale because there are no other meaningful measures for numbers of people. 7.2.

--- Chunk 842 ---
Tokens: 393
Type: sentence-based
Text:
7.2. Implications of Measurement Theory for Programming Languages Common programming languages support a set of built-in data types, often including the following:  Whole number types over varying ranges: int, integer, byte, short, long, etc. Floating-point numbers over varying ranges with varying precision: real, float, double, etc. Single characters: char  Ordered sequences of characters: string Many languages, although not all, also support type-safe enumeration (e.g, Javas enum). Unfortunately, these languages offer no support for measurement theory. They do not prevent, nor even warn programmers about, inappropriate manipulations. The whole and ENGINEERING FOUNDATIONS 18-13 floating-point number data types in pro- gramming languages operate as ratio scales and support the full range of manipulations: comparison, addition, subtraction, multi- plication, division and so on. But consider CMMI staged maturity level expressed as a number. In measurement theory terms, as shown above, it is an ordinal scale, so addi- tion, subtraction, multiplication and division are inappropriate. If any programmer rep- resents a CMMI staged maturity level using a whole number data type, nothing pre- vents the programmer from inappropriately adding, subtracting, multiplying or dividing that number. The same can be said for characters, strings and enumerations. Programming languages implement them as ordinal scales; how- ever, they might only be intended for repre- senting nominal-scale values. More-than and less-than comparisons are allowed even when inappropriate.

--- Chunk 843 ---
Tokens: 269
Type: sentence-based
Text:
More-than and less-than comparisons are allowed even when inappropriate. The string minivan appears alphabetically before the string sedan, but drawing any conclusion other than the mere alphabetical ordering of arbitrary text strings as a result of that fact is inappropriate. Common programming languages allow programmers to easily write code that is inap- propriate according to measurement theory. As long as programming languages allow it, programmers can and will  intention- ally or unintentionally  misuse measure- ment scale types. A more sensible solution would be data-type semantics that explicitly enforce measurement theory. For example, a language could explicitly support nom- inal scales, as shown in Figure 18.3 Sample A. That language could then prevent, or at least warn programmers against, more-than or less-than comparisons as shown in Figure 18.3 Sample B. If more-than or less-than comparisons are needed, the language supports declaration of an ordinal type as shown in Figure 18.3 Sample C. Figure 18.3 Sample D would not trigger any error or warning.

--- Chunk 844 ---
Tokens: 390
Type: sentence-based
Text:
If more-than or less-than comparisons are needed, the language supports declaration of an ordinal type as shown in Figure 18.3 Sample C. Figure 18.3 Sample D would not trigger any error or warning. Similarly, an interval scale could be supported, as shown in Figure 18.3 Sample E. A ratio scale could be supported, as shown in Figure 18.3 Sample F. Common programming languages have no problem with the code shown in Figure 18.3 Sample G. On the other hand, a measurement theoryaware programming language would be expected to generate a compiler error or warning with the code shown in Figure 18.3 Sample H. Future programming languages should enforce measurement theory and not allow developers to manipulate measurements inap- propriately. But until languages support mea- surement theory, software engineers need to at least understand it and be on the lookout for inappropriate manipulations in, for example, code reviews. 7.3. Direct and Derived Measures 13, c7s5 Measures may be either direct or derived (sometimes called indirect measures). An example of a direct measure is a count of how many times an event occurred, such as the number of defects found in a software product. A derived measure combines direct measures in a way that is consistent with the measure- ment methods used for those measures. For example, calculating the average hours spent to repair per defect is a derived measure. In both cases, the measurement method deter- mines how to perform the measurement. The scale types of those measures constrain how they can be manipulated.

--- Chunk 845 ---
Tokens: 400
Type: sentence-based
Text:
The scale types of those measures constrain how they can be manipulated. When different scale types are involved:  The scale type of the result of the manip- ulation can be no higher than the scale type of the most primitive measure- ment scale involved (e.g, a manipula- tion involving an interval scale and a ratio scale can only be done as if both are interval scales and can yield no better than an interval scale result). Investment is required to make the more primitive scale type compatible with any higher scale type (e.g, effort is required to bring the interval scale up to a ratio scale so the result can also be ratio-scaled). 18-14 SWEBOK  GUIDE V4.0 7.4. Reliability and Validity 13, c3s4-5 A basic question to ask when considering any measurement method is whether the proposed measurement method is truly measuring the concept with good quality. Reliability and validity are the two most useful criteria for addressing this question. The reliability of a measurement method is the extent to which the application of the method yields consistent results. Reliability refers to the consistency of the values obtained when the same item is measured several times. When the results agree with each other, the measurement method is said to be reliable. Reliability usually depends on the operational definition. It can be quantified by using the variation index, which is computed as the ratio between the standard deviation and the mean. The smaller the index, the more reliable the measurement results. Validity refers to whether the measurement method measures what we intend to measure.

--- Chunk 846 ---
Tokens: 399
Type: sentence-based
Text:
Validity refers to whether the measurement method measures what we intend to measure. The validity of a measurement method may be consid- ered from three different perspectives: construct validity, criteria validity and content validity. 7.5. Assessing Reliability 13, c3s5 Methods for assessing reliability include the test-retest method, the alternative form Nominal enum automobile_style  sedan, coupe, hatchback, minivan, suv, sports_car; Sample A if( thisCarStyle  sedan ) then   this is not allowed Sample B ordinal enum CMMI_staged_level  initial, repeatable, defined, managed, optimizing; Sample C if( anOrgsCMMILevel  repeatable ) then  Sample D interval AirTemperatureCelsius from -120.0 to 180.0; AirTemperatureCelsius yesterdaysHighTemp; AirTemperatureCelsius todaysHighTemp; if( todaysHighTemp  yesterdaysHighTemp )     allowed if( todaysHighTemp  yesterdaysHighTemp  2.0 )     not Sample E ratio TemperatureKelvin from 0.00 to 1000.00; TemperatureKelvin previousReading; TemperatureKelvin thisReading; if( thisReading  previousReading  2. ) allowed Sample F double priceOfBook; double highTemperature; highTemperature  priceOfBook;  makes no sense but is allowed Sample G ratio Money from -10000.00 to 10000.00; ratio TemperatureKelvin from 0.00 to 1000.00; Money priceOfBook; TemperatureKelvin highTemperature; double highTemperature; highTemperature  priceOfBook;  not allowed Sample H Figure 18.3. Code Samples for Measurement Theory ENGINEERING FOUNDATIONS 18-15 method, the split-halves method and the internal consistency method. The easiest of these is the test-retest method.

--- Chunk 847 ---
Tokens: 331
Type: sentence-based
Text:
The easiest of these is the test-retest method. In this method, we apply the measurement method twice to the same subjects. The correlation coefficient between the first and second set of measure- ment results gives us the reliability of the mea- surement method. 7.6. Goal-Question-Metric Paradigm: Why Measure? The final concern to discuss here regarding measurement is the importance of under- standing why we measure in the first place. The Goal-Question-Metric paradigm can be summarized with the simple observation that a measurement should be made to sup- port decision-making. Some measurements support decisions in code. Other measure- ments support decisions made by people outside of code (e.g, process improvement measures). The critical point is that some decision should be made as a result of the measurement. Many real-world software organizations fall victim to a measurement for the merely curious syndrome, where metrics are gathered simply because they are easy to measure and interesting to look at when plotted in graphs. Those measurements are not used to support any decision and are a waste of time and energy. They should be avoided. 8. Standards 3, c9s3.2 Moore states that a standard can be the following: a. An object or measure of comparison that defines or represents the magnitude of a unit b.

--- Chunk 848 ---
Tokens: 383
Type: sentence-based
Text:
An object or measure of comparison that defines or represents the magnitude of a unit b. A characterization that establishes allow- able tolerances for categories of items c. A degree or level of required excellence or attainment Standards are definitional in nature, estab- lished either to further understanding and interaction or to acknowledge observed (or desired) norms of exhibited characteristics or behavior 14, p8. Standards provide requirements, speci- fications or guidelines that engineers must observe so that products, processes and mate- rials are of acceptable quality. The quali- ties various standards dictate relate to safety, reliability or other product characteristics. Standards are considered critical to engineers, who are expected to be familiar with and use the appropriate standards for their spe- cific discipline. Compliance with or conformance to a standard allows an organization to assure the public that the organizations products meet the requirements contained in that standard. Thus, standards divide organizations or their products into those that conform to the stan- dard and those that do not. For a standard to be useful, conformance must add real or per- ceived value to the product, process or effort. Apart from supporting organizational goals, standards also serve several other pur- poses, such as protecting buyers, protecting businesses, and better defining the methods and procedures used in software engineering. Standards also provide users with common terminology and expectations.

--- Chunk 849 ---
Tokens: 397
Type: sentence-based
Text:
Standards also provide users with common terminology and expectations. There are many internationally recognized standards-making organizations, including the International Telecommunication Union (ITU), the International Electrotechnical Commission (IEC), IEEE, and the International Organization for Standardization (ISO). In addition, regional and governmentally recognized organizations generate standards for their region or country. For example, in the United States, more than 300 organizations develop standards. These include organiza- tions such as the American National Standards Institute (ANSI), ASTM International (for- merly known as American Society for Testing and Materials), SAE International (formerly the Society of Automotive Engineers), and Underwriters Laboratories, Inc. (UL), as well as the US government. (For more information on standards used in software engineering, see Appendix B.) 18-16 SWEBOK  GUIDE V4.0 There is a set of commonly used principles behind standards. Standards makers attempt to reach consensus for their decisions. This approach fosters an openness within the com- munity of interest so that once a standard is set, there is a good chance that it will be widely accepted. Most standards organizations have well-defined processes for their efforts and adhere to them carefully. Engineers must be aware of the existing standards and keep abreast of any changes to those standards over time. In many engineering endeavors, under- standing the applicable standards is critical, and the law may even require that spe- cific standards be followed.

--- Chunk 850 ---
Tokens: 385
Type: sentence-based
Text:
In many engineering endeavors, under- standing the applicable standards is critical, and the law may even require that spe- cific standards be followed. In these cases, the standards often represent the minimal requirements that must be met and thus are an element of the constraints imposed on the design effort. Therefore, the engineer must review all current standards related to a given endeavor and determine which must be met. The design must then incor- porate all constraints imposed by the appli- cable standard. 9. Root Cause Analysis 3, c9s3-5 13, c5, c3s7, c9s8 Root cause analysis (RCA) is a class of prob- lem-solving methods for identifying under- lying causes of undesirable outcomes. RCA methods identify why and how an undesirable outcome happened, allowing organizations to take effective action to prevent recurrence. Instead of merely addressing immediately obvious symptoms, the organization can solve problems by eliminating root causes. RCA can play several important roles in software projects, including the following: 1. Identifying the real problem to be solved by an engineering effort 2. Exposing the underlying drivers of risk, thus supporting project risk assessments 3. Revealing opportunities and actions for software process improvement 4. Discovering sources of recurring defects (defect causal analysis) 9.1. Root Cause Analysis Techniques Several RCA techniques exist, including the following:  Change analysis compares situations resulting in undesirable outcomes with similar situations that went well.

--- Chunk 851 ---
Tokens: 398
Type: sentence-based
Text:
Root Cause Analysis Techniques Several RCA techniques exist, including the following:  Change analysis compares situations resulting in undesirable outcomes with similar situations that went well. The assumption is that the root cause will be found in the area of difference. The 5-whys technique (see, for example, 2, c4) starts with an undesirable out- come and uses repeated Why? ques- tion-answer cycles to isolate the root cause. Cause-and-effect diagrams, sometimes called Ishikawa diagrams 15 or fishbone charts, break down, in successive levels of detail, causes that potentially contrib- uted to an undesirable outcome. Causes are often grouped into major categories such as people, processes, tools, mate- rials, measurements and environment. The diagram takes the form of a tree of potential causes that can all result in that undesirable outcome. Fault tree analysis (FTA) is a more formal approach to cause-and-effect diagram- ming that focuses on andor relationships between causes and effects. In some cases, any one of multiple causes can drive the effect (an or relationship); in other cases, a combination of multiple causes is required to drive the effect (an and relationship). Cause-and-effect diagrams do not distin- guish between and relationships and or relationships; fault tree analysis does. Failure modes and effects analysis (FMEA) forward-chains, starting with elements that can fail and cascade into undesirable effects. This approach contrasts with the backward-chaining techniques above, which start from an undesirable outcome and work backward toward causes.

--- Chunk 852 ---
Tokens: 389
Type: sentence-based
Text:
This approach contrasts with the backward-chaining techniques above, which start from an undesirable outcome and work backward toward causes. A cause map 16 is a structured map of cause-effect relationships that includes an undesirable outcome along with (1) chaining backward to driving causes and (2) chaining forward to effects on orga- nizational goals. Cause maps require ENGINEERING FOUNDATIONS 18-17 evidence of the occurrence of causes and the causality of effects and are thus more rigorous than cause-and-effect diagrams, FTA, and FMEA. A current reality tree 17 is a cause-ef- fect tree bound by the rules of logic (Categories of Legitimate Reservation). Human performance evaluation posits that human performance depends on (1) input detection, (2) input understanding, (3) action selection and (4) action execu- tion. An undesirable outcome that results from human performance can be identi- fied from a comprehensive list of poten- tial drivers, including cognitive overload, cognitive underload (boredom), memory lapse, tunnel vision or lack of a bigger picture, complacency, and fatigue. Additional techniques can be found in the DOE-NE-STD-1004-92 Root Cause Analysis Guidance Document. 9.2. Root CauseBased Improvement RCA is often an element in a greater pro- cess improvement effort. Why just identify a root cause if nothing will be done about it? Why go through the effort of identifying the root cause of low-importance problems? An example of a systematic process for a larger improvement effort incorporating RCA is given below: 1.

--- Chunk 853 ---
Tokens: 377
Type: sentence-based
Text:
An example of a systematic process for a larger improvement effort incorporating RCA is given below: 1. Select the problem to solve: Techniques such as Pareto analysis (the 8020 Rule), frequency-severity prioritization (problems that happen most frequently and consume the most resources to rec- tify are the best candidates), and statis- tical process control are used to identify a high-priority, undesirable outcome to address. This step needs to clearly define the problem and its significance. 2. Gather evidence about that problem and its cause(s): Consider information surrounding the selected undesirable outcome, including statements or testi- mony, relevant processes or standards, specifications, reports, historical trends, experiments, or tests. 3. Identify the root cause using one or more RCA techniques presented in 9.1. Root Cause Analysis Techniques. 4. Select corrective action(s) that (1) prevent recurrence, (2) are within the organiza- tions ability to control, (3) meet organi- zational goals and objectives, and (4) do not cause other problems. More than one candidate corrective action should be con- sidered, and the potential actions should eliminate the cause, reduce the probability of the cause occurring or disconnect the cause from the effect. Selected correc- tive actions should generate the greatest amount of control for the least cost. 5. Implement the selected corrective action(s). 6. Observe the selected corrective action(s) to ensure efficiency and effectiveness. 10.

--- Chunk 854 ---
Tokens: 383
Type: sentence-based
Text:
10. Industry 4.0 and Software Engineering The manufacturing industry has always been continuously changing. Industry 4.0 is set to change the manufacturing segment signifi- cantly, primarily focusing on custom manu- facturing supported by artificial intelligence (AI). This offers potential benefits for cost, quality and efficiency. Industry 4.0s emphasis on digitization and AI calls for building bespoke hardware and software and inte- grating these with other standard systems. This is supported by Continuous Software Engineering (CSE), which has been addressing continuous manufacturing prac- tices such as continuous planning, continuous architectingdesigning, continuous devel- opment, continuous integration, continuous deployments and continuous reviewrevision. Software is a key component in the Industry 4.0 revolution, and engineering the software is crucial to building robust and intelligent sys- tems. The engineering for one product affects others, as more devices connect with other devices, mostly wirelessly, to provide data and receive commands and data for further functioning. 18-18 SWEBOK  GUIDE V4.0 Many technologies are used in Industry 4.0, including the Internet of Things (IoT), Big data analytics, AI and machine learning, cybersecurity, cloud computing and Apps for multiple platforms among others. Software plays a key role in the implementation of all these. Continuous Systems and Software Engineering for Industry 4.0 (CSSE I4.0) proposes how software engineering could be applied in Industry 4.0.

--- Chunk 855 ---
Tokens: 384
Type: sentence-based
Text:
Continuous Systems and Software Engineering for Industry 4.0 (CSSE I4.0) proposes how software engineering could be applied in Industry 4.0. Quantum com- puting enables complex computations to be performed faster and more cost-effectively. The size and cost of devices that host the soft- ware are decreasing significantly, easing the adoption of Industry 4.0. The software will be increasingly self-learning and proactive, developing the ability to predict users wants. MATRIX OF TOPICS VS. REFERENCE MATERIAL Tockey 2004 2 Voland 2003 3 McConnell 2004 6 Montgomery and Runger 2018 8 Null and Lobur 2018 9 Cheney and Kincaid 2007 10 Sommerville 2018 11 Fairley 2009 12 Kan 2002 13 1. The Engineering Process c4 2. Engineering Design c1s2-4 2.1. Engineering Design in Engineering Education 2.2. Design as a Problem- Solving Activity c1s4, c2s1, c3s3 c5s1 3. Abstraction and Encapsulation c5s2-4 3.1. Levels of Abstraction 3.2. Encapsulation 3.3. Hierarchy 3.4. Alternate Abstractions 4. Empirical Methods and Experimental Techniques c1 4.1. Designed Experiment 4.2. Observational Study 4.3. Retrospective Study 5. Statistical Analysis c9s1, c2s1 c11s3 ENGINEERING FOUNDATIONS 18-19 5.1. Unit of Analysis (Sampling Units), Population and Sample c3s5, c3s8, c4s5, c7s1, c7s3, c8s1, c9s1 5.2. Correlation and Regression c11s2, c11s8 6. Modeling, Simulation and Prototyping c6 c13s3 c5 6.1. Modeling 6.2. Simulation 6.3. Prototyping c2s8 7. Measurement pp 442- 447 c4s4 c7s5 c3s1-2 7.1. Levels (Scales) of Measurement p442- 447 c7s5 c3s2 7.2.

--- Chunk 856 ---
Tokens: 387
Type: sentence-based
Text:
Levels (Scales) of Measurement p442- 447 c7s5 c3s2 7.2. Implications of Measurement Theory for Programming Languages 7.3. Direct and Derived Measures c7s5 7.4. Reliability and Validity c3s4-5 7.5. Assessing Reliability c3s5 7.6. Goal-Question- Metric Paradigm: Why Measure? 8. Standards c9s3.2 9. Root Cause Analysis c9s3-5 c5, c3s7, c9s8 9.1. Root Cause Analysis Techniques c4 9.2. Root Cause-Based Improvement 10. Industry 4.0 and Software Engineering FURTHER READINGS A. Abran, Software Metrics and Software Metrology. 18 This book provides very good information on the proper use of the terms measure, measure- ment method and measurement outcome. It pro- vides strong support material for the entire section on measurement. 18-20 SWEBOK  GUIDE V4.0 W.G. Vincenti, What Engineers Know and How They Know It. 19 This book introduces engineering foundations through case studies showing many foun- dational concepts in real-world engineering applications. REFERENCES 1 ISOIECIEEE, ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, 2nd ed. 2017 2 S. Tockey, Return on Software: Maximizing the Return on Your Software Investment, 1st ed. Boston: Addison-Wesley, 2004. 3 G. Voland, Engineering by Design, 2nd ed. Upper Saddle River, NJ: Prentice Hall, 2003. 4 2021 Accreditation Criteria and Procedures, Canadian Engineering Accreditation Board, Engineers Canada, 2021. 5 E.A. Commission, Criteria for Accrediting Engineering Programs, 2022-2023, ABET, 2021. 6 S. McConnell, Code Complete, 2nd ed. Redmond, WA: Microsoft Press, 2004.

--- Chunk 857 ---
Tokens: 337
Type: sentence-based
Text:
Redmond, WA: Microsoft Press, 2004. 7 Edsger W. Dijkstra, The Humble Programmer, Communications of the ACM, vol. 15, issue 10, October 1972. 8 D.C. Montgomery and G.C. Runger, Applied Statistics and Probability for Engineers, 7th ed. Hoboken, NJ: Wiley, 2018. 9 L. Null and J. Lobur, The Essentials of Computer Organization and Architecture, 5th ed. Sudbury, MA: Jones and Bartlett Publishers, 2018. 10 E.W. Cheney and D.R. Kincaid, Numerical Mathematics and Computing, 6th ed. Belmont, CA: BrooksCole, 2007. 11 I. Sommerville, Software Engineering, 10th ed. New York: Addison- Wesley, 2018. 12 R.E. Fairley, Managing and Leading Software Projects. Hoboken, NJ: Wiley- IEEE Computer Society Press, 2009. 13 S.H. Kan, Metrics and Models in Software Quality Engineering, 2nd ed. Boston: Addison-Wesley, 2002. 14 J.W. Moore, The Road Map to Software Engineering: A Standards-Based Guide, 1st ed. Hoboken, NJ: Wiley-IEEE Computer Society Press, 2006. 15 K. Ishikawa, Introduction to Quality Control, Productivity Press, 1990. 16 D. Gano, Apollo Root Cause Analysis, 3rd ed, Apollonian Publications, 2007. 17 E. Goldratt, Its Not Luck, North River Press, 1994. 18 A. Abran, Software Metrics and Software Metrology: Wiley-IEEE Computer Society Press, 2010. 19 W.G. Vincenti, What Engineers Know and How They Know It. Johns Hopkins University Press, 1993.

--- Chunk 858 ---
Tokens: 350
Type: sentence-based
Text:
Johns Hopkins University Press, 1993. 20 Elisa Yumi Nakagawa, Pablo Oliveira Antonio, Frank Schnicke, Thomas Kuhn, Peter Liggesmeyer, Continuous Systems and Software Engineering for Industry 4.0: A disruptive view, Elsevier, Volume 135, July 2021, 106562 (https: www.sciencedirect.comscience articleabspiiS0950584921000458.) A-1 KNOWLEDGE AREA DESCRIPTION SPECIFICATIONS Appendix A INTRODUCTION This appendix presents the specifications pro- vided to the knowledge area (KA) editors regarding the KA Descriptions of the Guide to the Software Engineering Body of Knowledge, Version 4 (SWEBOK Guide, V4). This enables readers, reviewers and users to clearly under- stand what specifications were used in devel- oping this version of the SWEBOK Guide. This appendix begins by situating the SWEBOK Guide as a foundational document for the IEEE Computer Societys suite of soft- ware engineering products and more widely within the software engineering commu- nity. The appendix then describes the role of the baseline and change control. Criteria and requirements are defined for the breakdowns of topics, for the rationale underlying these breakdowns and the succinct description of topics, and for reference materials. Important input documents are also identified, and their role within the project is explained. Finally, non-content issues such as submission format and style guidelines are discussed.

--- Chunk 859 ---
Tokens: 328
Type: sentence-based
Text:
Finally, non-content issues such as submission format and style guidelines are discussed. THE SWEBOK GUIDE IS A FOUNDATIONAL DOCUMENT FOR THE IEEE COMPUTER SOCIETY SUITE OF SOFTWARE ENGINEERING PRODUCTS The SWEBOK Guide is an IEEE Computer Society flagship and structural document for the IEEE Computer Societys suite of software engineering products. The SWEBOK Guide is also more widely recognized as a foundational document throughout the software engineering community, notably through the official recognition of the 2004 and 2014 versions as ISOIEC Technical Report 19759:2005 and 19759:2015, respectively. The list of KAs and the breakdown of topics within each are described and detailed in this SWEBOK Guides introduction. Consequently, the SWEBOK Guide is foundational to other initiatives within the IEEE Computer Society, as follows:  The list of KAs and the breakdown of topics within each are also adopted by the software engineering certifica- tion and associated professional devel- opment products offered by the IEEE Computer Society. (See www.computer .orgcertification.) The list of KAs and the breakdown of topics are also foundational to the soft- ware engineering curriculum guide- lines developed or endorsed by the IEEE Computer Society. (See www.computer. orgportalwebeducationCurricula.)

--- Chunk 860 ---
Tokens: 396
Type: sentence-based
Text:
orgportalwebeducationCurricula.) The Consolidated Reference List (see Appendix C)  meaning the list of Recommended References (to the level of section number) that accompanies the breakdown of topics within each KA  is also adopted by the software engi- neering certification and associated pro- fessional development products offered by the IEEE Computer Society. BASELINE AND CHANGE CONTROL Due to the structural nature of the SWEBOK Guide and its adoption by other products, a baseline was developed at the outset of the project by a SWEBOK Steering Group. The baseline comprises the list of KAs, including A-2 SWEBOK  GUIDE V4.0 new ones, and the breakdown of topics for each KA from the previous version. Furthermore, a SWEBOK KA editors team has been put in place for the development of this version to handle all major change requests to this baseline coming from the KA editors, arising during the review process or otherwise. Change requests must be approved both by the SWEBOK Guide editors and by the team before being implemented. The team is composed of members of the initia- tives listed above and acts under the authority of the Engineering Discipline Committee of the IEEE Computer Society Professional and Educational Activities Board (PEAB). CRITERIA AND REQUIREMENTS FOR THE BREAKDOWN OF TOPICS WITHIN A KNOWLEDGE AREA  KA editors are instructed to refine the baseline breakdown of topics to reflect the recent development in the target area for KAs that continue to exist from the previous version. The breakdown of topics is expected to be reasonable, not perfect.

--- Chunk 861 ---
Tokens: 390
Type: sentence-based
Text:
The breakdown of topics is expected to be reasonable, not perfect. The breakdown of topics within a KA must decompose the subset of the SWEBOK that is generally recognized. (See below for a more detailed discussion of this point.) The breakdown of topics within a KA must not presume specific application domains, business needs, sizes of organi- zations, organizational structures, man- agement philosophies, software life cycle models, software technologies or soft- ware development methods. The breakdown of topics must, as much as possible, be compatible with the var- ious schools of thought within software engineering. The breakdown of topics within a KA must be compatible with the breakdown of software engineering generally found in industry and in the software engi- neering literature and standards. The breakdown of topics is expected to be as inclusive as possible. The SWEBOK Guide adopts the position that even though the following themes are common across all KAs, they are also an integral part of all KAs and, there- fore, must be incorporated into the pro- posed breakdown of topics of each KA. These common themes are measurement, quality (in general) and security. The breakdown of topics should be at most two or three levels deep. Even though no upper or lower limit is imposed on the number of topics within each KA, a rea- sonable and manageable number of topics is expected to be included in each KA. Emphasis should also be put on the selection of the topics themselves rather than on their organization in an appropriate hierarchy.

--- Chunk 862 ---
Tokens: 372
Type: sentence-based
Text:
Emphasis should also be put on the selection of the topics themselves rather than on their organization in an appropriate hierarchy. Topic names must be significant enough to be meaningful even when cited outside the SWEBOK Guide. The Description of a KA will include a chart (in tree form) describing the knowl- edge breakdown. This chart will typically be the first figure in the respective KA. CRITERIA AND REQUIREMENTS FOR DESCRIBING TOPICS Topics need only be sufficiently described so readers can select the appropriate refer- ence material according to their needs. Topic descriptions must not be prescriptive. CRITERIA AND REQUIREMENTS FOR REFERENCE MATERIAL  KA editors are instructed to use the ref- erences (to the level of section number) allocated to their KA by the Consolidated Reference List as their Recommended References. There are three categories of refer- ence material:  Recommended References. The set of Recommended References (to the level APPENDIX A A-3 of section number) is collectively known as the Consolidated Reference List. Further Readings. Additional references cited in the KA Description (e.g, the source of a quo- tation or reference material in sup- port of a rationale behind a particular argument). The SWEBOK Guide is intended by defi- nition to be selective in its choice of topics and associated reference material. The list of reference material should be clearly viewed as an informed and reasonable selection rather than as a definitive list.

--- Chunk 863 ---
Tokens: 391
Type: sentence-based
Text:
The list of reference material should be clearly viewed as an informed and reasonable selection rather than as a definitive list. Reference material can be book chap- ters, refereed journal papers, refereed conference papers, refereed technical or industrial reports, or any other type of recognized artifact. References to another KA, subarea or topic are also permitted. Reference material must be generally available and must not be confidential in nature. Reference material must be in English. Criteria and requirements for rec- ommended reference material or Consolidated Reference List:  Collectively, the list of Recommended References should be: i. Complete  covering the entire scope of the SWEBOK Guide ii. Sufficient  providing enough information to describe generally accepted knowledge iii. Consistent  not providing con- tradictory knowledge or con- flicting practices iv. Credible  recognized as providing expert treatment v. Current  treating the subject in a manner that is commensurate with current, generally accepted knowledge vi. Succinct  as short as possible (both in the number of reference items and in total page count) without failing other objectives  Recommended reference material must be identified for each topic. Each recommended reference item may, of course, cover multiple topics. Rarely, a topic may be self-descriptive and not cite a reference material item (e.g, a topic that is a definition or a topic for which the description itself without any cited reference material is sufficient for the objectives of the SWEBOK Guide).

--- Chunk 864 ---
Tokens: 350
Type: sentence-based
Text:
Rarely, a topic may be self-descriptive and not cite a reference material item (e.g, a topic that is a definition or a topic for which the description itself without any cited reference material is sufficient for the objectives of the SWEBOK Guide). Each reference to the recommended reference material should be as precise as possible, identifying what specific chapter or section is relevant. A matrix of reference material (to the level of section number) versus topics must be provided. The latest versions or editions should be used as the Recommended References if there are multiple versions or editions. A reasonable amount of recommended reference material must be identified for each KA. The following guidelines should be used in determining how much is reasonable: i. If the recommended reference materials are written in a coherent manner, follow the proposed break- down of topics, and use a consistent style (e.g, list a new book based on the proposed KA description), an average page number target across all KAs would be 750. However, this target may not be attainable when selecting existing reference mate- rial due to differences in style and to overlap and redundancy among the selected reference materials. i. In other words, the target for the number of pages for the entire col- lection of Recommended References in the SWEBOK Guide is in the range of 10,000 to 15,000 pages. i.

--- Chunk 865 ---
Tokens: 367
Type: sentence-based
Text:
i. Another way of viewing this is that the amount of recommended refer- ence material would be reasonable if it consisted of the study material for this KA for a software engineering licensing exam that a graduate would pass after completing four years of work experience. A-4 SWEBOK  GUIDE V4.0  Additional reference material can be included by the KA editor in a Further Reading list:  These materials must be related to the topics in the breakdown rather than, for example, to more advanced topics. The list must be annotated (one para- graph per reference) to explain why each reference was included. Further Reading could include alternative viewpoints on a KA or a seminal treatment of a KA. A general guideline to be followed is 10 or fewer further readings per KA. There is no matrix of the reference materials listed in Further Reading and the breakdown of topics. Criteria and requirements regarding additional references cited in the KA Description:  The SWEBOK Guide is not a research document, and its readership will be varied. Therefore, a delicate balance must be maintained between ensuring a high level of readability within the document and maintaining its tech- nical excellence. Additional reference material should, therefore, be brought in by the KA editor only if it is nec- essary to the discussion. For example, the reference material might iden- tify the source of a quotation or offer support for the rationale behind an important argument.

--- Chunk 866 ---
Tokens: 385
Type: sentence-based
Text:
For example, the reference material might iden- tify the source of a quotation or offer support for the rationale behind an important argument. COMMON STRUCTURE KA Descriptions should use the following structure:  Acronyms  Introduction  Breakdown of Topics of the KA (including a figure describing the breakdown)  Matrix of Topics vs. Reference Material  List of Further Reading  References WHAT DO WE MEAN BY GENERALLY RECOGNIZED KNOWLEDGE? The Software Engineering Body of Knowledge is an all-inclusive term that describes the sum of knowledge within the profession of software engineering. However, the SWEBOK Guide seeks to identify and describe that subset of the body of knowledge that is generally recognized or, in other words, the core body of knowledge. To better illustrate what generally recognized knowledge is relative to other types of knowl- edge, Figure A.1 proposes a three-category schema for classifying knowledge. The Project Management Institute, in its Guide to the Project Management Body of Knowledge, defines generally recognized knowledge for project management as: that subset of the project management body of knowledge generally recognized as good prac- tice. Generally recognized means the knowl- edge and practices described are applicable to most projects most of the time, and there is con- sensus about their value and usefulness. Good practice means there is general agreement that the application of these skills, tools, and tech- niques can enhance the chances of success over a wide range of projects.

--- Chunk 867 ---
Tokens: 385
Type: sentence-based
Text:
Good practice means there is general agreement that the application of these skills, tools, and tech- niques can enhance the chances of success over a wide range of projects. Good practice does not mean that the knowledge described should always be applied uniformly to all projects; the organization andor project management team is responsible for determining what is appro- priate for any given project 1. Specialized Practices Used Only for Certain Types of Software Generally Recognized Established traditional practices recommended by many organizations Advanced and Research Innovative practices tested and used only by some organizations and concepts still being developed and tested in research organizations Figure A.1. Categories of Knowledge APPENDIX A A-5 Generally accepted knowledge could also be viewed as knowledge to be included in the study material of a software engineering licensing exam (in the US) that a graduate would take after completing four years of work experience. These two definitions should be seen as complementary. KA editors are also expected to be some- what forward-looking in their interpretation by taking into consideration not only what is generally recognized today but also what they expect will be generally recognized in a three- to five-year time frame. LENGTH OF KA DESCRIPTION KA Descriptions are to be roughly 10 to 20 pages using the formatting template for papers published in conference proceedings of the IEEE Computer Society. This includes text, references, appendixes, tables, etc.

--- Chunk 868 ---
Tokens: 369
Type: sentence-based
Text:
This includes text, references, appendixes, tables, etc. This, of course, does not include the reference mate- rials themselves. IMPORTANT RELATED DOCUMENTS Graduate Software Engineering 2009 (GSwE2009): Curriculum Guidelines for Graduate Degree Programs in Software Engineering, 2009 2. This document provides guidelines and rec- ommendations for defining the curricula of a professional masters-level program in soft- ware engineering. The SWEBOK Guide is identified as a primary reference in devel- oping the body of knowledge underlying these guidelines. This document has been officially endorsed by the IEEE Computer Society and sponsored by the Association for Computing Machinery. ISOIECIEEE 12207-2017 Standard for Systems and Software Engineering  Software Life Cycle Processes, ISOIEC IEEE, 2017 3. This standard is considered the key standard regarding the definition of life cycle pro- cesses and has been adopted by the two main standardization bodies in software engi- neering: ISOIEC JTC1SC7 and the IEEE Computer Society Software and Systems Engineering Standards Committees. It also has been designated a pivotal standard by the Software and Systems Engineering Standards Committee (S2ESC) of the IEEE. Even though we do not intend the SWEBOK Guide to be fully 12207-conformant, this stan- dard remains a key input to the SWEBOK Guide, and special care will be taken throughout the SWEBOK Guide regarding the compatibility of the Guide with the 12207 standard.

--- Chunk 869 ---
Tokens: 387
Type: sentence-based
Text:
Even though we do not intend the SWEBOK Guide to be fully 12207-conformant, this stan- dard remains a key input to the SWEBOK Guide, and special care will be taken throughout the SWEBOK Guide regarding the compatibility of the Guide with the 12207 standard. Software Engineering 2014: Curriculum Guidelines for Undergraduate Degree Programs in Software Engineering, IEEE Computer Society and Association for Computing Machinery, 2015; https:www. acm.orgbinariescontentassetseducation se2014.pdf 4. This document describes curriculum guidelines for an undergraduate degree in software engi- neering. The SWEBOK Guide is identified as one of the primary sources in developing the body of knowledge underlying these guidelines. ISOIECIEEE 24765:2017 Software and Systems Engineering  Vocabulary, ISO IECIEEE, 2017; https:www.computer. orgsevocab 5. The hierarchy of references for terminology is Merriam-Websters Collegiate Dictionary (11th ed.) 6, ISOIECIEEE 24765 5 and newly proposed definitions, if required. Software Professional Certification Program, IEEE Computer Society; https:www. computer.orgeducationcertifications 7. Information on the certification and associated professional development products developed and offered by the IEEE Computer Society for professionals in the field of software engineering A-6 SWEBOK  GUIDE V4.0 can be found on this website. The SWEBOK Guide is foundational to these products. OTHER DETAILED GUIDELINES When referencing the Guide to the Software Engineering Body of Knowledge, use the title SWEBOK Guide.

--- Chunk 870 ---
Tokens: 377
Type: sentence-based
Text:
OTHER DETAILED GUIDELINES When referencing the Guide to the Software Engineering Body of Knowledge, use the title SWEBOK Guide. For the purpose of simplicity, avoid foot- notes, and try to include their content in the main text. Use explicit references to standards, as opposed to simply inserting numbers refer- encing items in the bibliography. We believe this approach allows the reader to be better exposed to the source and scope of a standard. The text accompanying figures and tables should be self-explanatory or have enough related text. This ensures that the reader knows what the figures and tables mean. To make sure that some information in the SWEBOK Guide does not become rap- idly obsolete and in order to reflect its generic nature, please avoid directly naming tools and products. Instead, try to name their functions. EDITING Editors of the SWEBOK Guide, as well as profes- sional copy editors, will edit KA Descriptions. Editing includes copy editing (grammar, punc- tuation and capitalization), style editing (con- formance to the Computer Society style guide), and content editing (flow, meaning, clarity, directness and organization). The final editing will be a collaborative process in which the edi- tors of the SWEBOK Guide and the KA editors will work together to achieve a concise, well- worded and useful KA Description. RELEASE OF COPYRIGHT All intellectual property rights associated with the SWEBOK Guide will remain with the IEEE. KA editors must sign a copyright release form.

--- Chunk 871 ---
Tokens: 350
Type: sentence-based
Text:
KA editors must sign a copyright release form. It is also understood that the SWEBOK Guide will continue to be available free of charge in the public domain in at least one format, pro- vided by the IEEE Computer Society through web technology or by other means. (For more information, see www.computer. orgcopyright.htm.) REFERENCES 1 Project Management Institute, A Guide to the Project Management Body of Knowledge (PMBOK Guide), 7th ed, Project Management Institute, 2021. 2 Integrated Software and Systems Engineering Curriculum (iSSEc) Project, Graduate Software Engineering 2009 (GSwE2009): Curriculum Guidelines for Graduate Degree Programs in Software Engineering, Stevens Institute of Technology, 2009; https:dl.acm.org doibook10.11452593248. 3 ISOIECIEEE 12207-2017 Systems and Software Engineering  Software Life Cycle Processes, 2017. 4 Joint Task Force on Computing Curricula, IEEE Computer Society and Association for Computing Machinery, Software Engineering 2014: Curriculum Guidelines for Undergraduate Degree Programs in Software Engineering, 2015; https:www.acm.orgbinaries contentassetseducationse2014.pdf. 5 ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, 2nd ed. 2017. 6 Merriam-Websters Collegiate Dictionary, 11th ed, 2003. 7 IEEE Computer Society, Certification and Training for Software Professionals, 2013; https:www.computer.org educationcertifications.

--- Chunk 872 ---
Tokens: 391
Type: sentence-based
Text:
7 IEEE Computer Society, Certification and Training for Software Professionals, 2013; https:www.computer.org educationcertifications. B-1 IEEE AND ISOIEC STANDARDS Appendix B ACRONYMS EIC International Electrotechnical Commission ISO International Organization for Standardization JTC Joint Technical Committee MSS Management System Standard S2ESC Systems and Software Engineering Standards Committee SC Subcommittee SUPPORTING THE SOFTWARE ENGINEERING BODY OF KNOWLEDGE (SWEBOK) 1. Overview The purpose of this appendix is to describe the relationship between IEEE software engi- neering standards and the SWEBOK and to introduce the more prominent international software engineering standards most directly related to the SWEBOK knowledge areas (KA). A summary list of some useful stan- dards for software engineering, including all those referenced in this document, is in B.9. 1.1 The SWEBOK and standards The SWEBOK and other bodies of knowl- edge are closely related to standards for soft- ware engineering, and standards are cited as resources in knowledge areas (KA) in the SWEBOK. Standards for software engi- neering extend and apply the generally accepted body of knowledge that is collected in the SWEBOK. Conversely, standards also define and organize the systematic knowledge that is then reflected in collected bodies of knowl- edge. However, the SWEBOK has a different purpose from most software engineering stan- dards. The SWEBOK summarizes gener- ally accepted concepts and experience-based information about how software engineering is practiced.

--- Chunk 873 ---
Tokens: 373
Type: sentence-based
Text:
The SWEBOK summarizes gener- ally accepted concepts and experience-based information about how software engineering is practiced. This knowledge summary can be applied in various ways: to define a curric- ulum for educating software engineers, or for employers or certification bodies determine if a person has the knowledge and accepts the ethical values needed to practice software engineering or to be certified. In contrast, a standard is a document, established by consensus and approved by a recognized body, that provides, for common and repeated use, rules, guidelines or charac- teristics for activities or their results, aimed at the achievement of the optimum degree of order in a given context (ISOIEC TR 29110-1:2016). In standards, the Rules, guidelines, or characteristics are expressed differently:  requirements in normative standards, (stated using shall or the imperative),  recommended practices (stated using should)  other guidance on possible approaches (stated using may) Standards allow for global interoperability for accepted concepts, processes, people, and products. The existence of standards takes a very large (possibly infinite) trade space of alter- natives and normalizes that space, supporting mutual understanding between acquirers and suppliers. In that respect, software engineering standards counter the tendency of competing B-2 SWEBOK  GUIDE V4.0 organizations to develop unique, proprietary products that do not interoperate outside their own suite.

--- Chunk 874 ---
Tokens: 385
Type: sentence-based
Text:
In that respect, software engineering standards counter the tendency of competing B-2 SWEBOK  GUIDE V4.0 organizations to develop unique, proprietary products that do not interoperate outside their own suite. When standards are open, so that organizations of all sizes can meet their requirements, demand for trustworthy prod- ucts and services increases to the benefit of many suppliers and acquirers. Standards are voluntary; an individual or organization can choose to conform to their requirements and follow their recommenda- tions. When the standard is incorporated in contracts or other agreements, laws, and reg- ulations, then compliance with the standard becomes mandatory. 1.2 Types of Standards Standards can be characterized by what part of software engineering they standardize: concepts and terms, processes, products, people, or assessment of capabilities. Some software engineering standards simply present concepts (characteristics) and define terms, perhaps even establishing a schema of knowledge about a software engineering topic. An example of this type of standard is ISOIECIEEE 24765 Systems and software engineering: Vocabulary, which is freely avail- able online at www.computer.orgsevocab.1 However, most software engineering standards describe one or more of the software engi- neering processes and give requirements and recommendations about how to perform that process. The primary process standard in soft- ware engineering is ISOIECIEEE 12207, Systems and software engineering: Software life cycle processes.

--- Chunk 875 ---
Tokens: 382
Type: sentence-based
Text:
The primary process standard in soft- ware engineering is ISOIECIEEE 12207, Systems and software engineering: Software life cycle processes. There is even a standard for how to describe a process: ISOIECIEEE 24774, Systems and software engineering Life cycle management Specification for process descrip- tion. It describes the purpose, outcomes, activ- ities, tasks, and possibly the inputs, outputs, and other features of a process. Process stan- dards should not be confused with procedures or instructions; they do not offer detailed rec- ipes or step-by-step instructions for doing soft- ware engineering. 1 http:pascal.computer.orgsev_displayindex.action. A few software engineering standards have standardized descriptions of products of soft- ware engineering, such as models or informa- tion products like a project management plan (ISOIECIEEE 16326). Another notable standard for information products is ISO IECIEEE 15289, Systems and software engi- neeringContents of life cycle information items (documentation). Initially, most software engi- neering standards were standards for a prom- inent information product, a plan. These allowed customers (acquirers of software) to understand and compare what their suppliers would produce (a product). A standard for a plan describes what will be produced or deliv- ered, what methods and techniques will be used, and what activities will be performed. In recent years, most of the standards for plans have been revised to become standards for software engineering processes.

--- Chunk 876 ---
Tokens: 399
Type: sentence-based
Text:
In recent years, most of the standards for plans have been revised to become standards for software engineering processes. Besides standards for concepts, processes, and products, there are also standards for peo- ples skills, knowledge, or abilities, and stan- dards for certification schemes and bodies of knowledge in software engineering. An example is ISOIEC 24773-1:2019, Software and systems engineering  Certification of soft- ware and systems engineering professionals  Part 1: General requirements. Reviews and assessments can be standardized for soft- ware engineers, organizations, processes, and work products. 1.3 Sources of Software Engineering Standards Although there are thousands of pages in hun- dreds of systems and software engineering standards, guides, textbooks and handbooks, there are only two international organizations accredited to produce systems and software engineering standards: ISOIEC JTC 1SC 7 and IEEE. Both have produced software engi- neering standards for over thirty-five years. Both are committed to produce standards using doc- umented, consensus-based processes with open participation. ISOIEC JTC 1 (International Organization for Standardization  International APPENDIX B B-3 Electrotechnical Commission Joint Technical Committee)  SC 7 (Subcommittee), Software and Systems Engineering, produces standards through its membership of national standards bodies. JTC 1SC 7 has a portfolio of over two hundred standards. The IEEE Computer Society Systems and Software Standards Committee (S2ESC) produces standards in working groups of individual experts.

--- Chunk 877 ---
Tokens: 386
Type: sentence-based
Text:
The IEEE Computer Society Systems and Software Standards Committee (S2ESC) produces standards in working groups of individual experts. It main- tains about fifty standards, of which about 80 have been approved as ISOIECIEEE joint standards. These are IEEE standards adopted by ISOIEC JTC 1SC 7, or stan- dards that are jointly developed and main- tained with ISOIEC JTC 1 and designated as ISOIECIEEE. The aim of these jointly developed standards is to have a coordinated collection of consistent standards for interna- tional use. For the ISOIECIEEE standards described in this appendix, the IEEE version and the ISOIEC version are substantively identical. The respective versions may have different front and back matter but the tech- nical content is exactly the same. Standards can be purchased from the IEEE, ISO, and IEC websites, from national standards organizations, and from commer- cial resellers. Academic institutions and soft- ware engineering organizations can purchase or subscribe to collections of standards for use by their staffs. A few standards are freely available, generally those that provide intro- ductions to concepts or terminology. In both IEEE and ISOIEC JTC 1, stan- dards for systems engineering are maintained by the same committee as those for software engineering. Most of the standards apply to both, especially when software is considered as a system or as the major component of a system of interest. So, instead of making fine distinc- tions, this appendix covers both as applicable to software engineering.

--- Chunk 878 ---
Tokens: 379
Type: sentence-based
Text:
So, instead of making fine distinc- tions, this appendix covers both as applicable to software engineering. It does not mention older, now stabilized standards dealing with the foundations of computing or computing languages and basic programming, mathemat- ical, or engineering concepts. ISO and IEEE have their own numbering systems for their standards. When an IEEE standard is adopted by ISOIEC JTC 1, it is typically renumbered to a 5-digit number, e.g, IEEE 1062 becomes ISOIECIEEE 41062. ISO standards have long, taxonom- ical titles with three and four levels of classi- fication. The first level shows the general area (e.g. systems and software engineering); the second level is the main title of the standard, and the third level provides even more detail, especially for multi-part standards. To avoid cumbersome repetition, this appendix often uses a shortened title of the standard or simply cites it by number. The full title is given in the list in B.9. All of these software engineering standards are copyright protected, and IEEE standard numbers are trademarked. 2. The software engineering standards landscape Figure B.1 presents an overview of the most prominent software engineering standards, mainly from the perspective of how other standards relate to the major software engi- neering life cycle process standard, ISOIEC IEEE 12207, software engineering processes. It is closely related to the SWEBOK in that both present information related to many of the same software life cycle processes.

--- Chunk 879 ---
Tokens: 375
Type: sentence-based
Text:
It is closely related to the SWEBOK in that both present information related to many of the same software life cycle processes. Also in the upper portion of Figure B.1 are the foundational standards, such as the spe- cialized vocabulary for systems and soft- ware engineering (SEVOCAB, ISOIEC IEEE 24765) and a specification for how to describe processes (ISOIECIEEE 24774). There are standards for how to plan for and manage software engineering (ISOIEC IEEE 24748-5) and how to conduct rigorous reviews and audits, appropriate for critical software like aerospace and defense systems (ISOIECIEEE 24748-8). Using the life cycle process model of 12207 as described in the following section, there are many more specialized standards covering individual processes and modern approaches to the processes, such as ISOIECIEEE 32675, DevOps, as well as IEEE 1012, Verification and validation, and ISOIECIEEE 29119, software testing (in multiple parts). The life cycle processes in 12207 generally focus on a B-4 SWEBOK  GUIDE V4.0 single system of interest (SOI) but more spe- cialized series focus on processes and tools for product line engineering, and for systems of systems (SoS). The System of Systems stan- dards, ISOIECIEEE 21839, 21840, and 21841, explain how to use systems engineering processes when the system of interest (SOI) is a constituent part of a system of systems. The life cycle process standards are intended to be compatible with other well-known stan- dards for management systems.

--- Chunk 880 ---
Tokens: 340
Type: sentence-based
Text:
The life cycle process standards are intended to be compatible with other well-known stan- dards for management systems. According to ISO, a management system is the way in which an organization manages the interre- lated parts of its business in order to achieve its objectives. Management system standards (MSS) have a consistent structure and frame- work of requirements, but each MSS covers a specific aspect of managing and delivering engineering products and services. MSS typically come in multiple parts with var- ious guides for different aspects of their sys- tems. Well-known MSS related to software engineering include ISO 9000 for quality management, ISOIEC 20000 for service management, the ISOIEC 27000 series for information security management, the ISO IEC 19770 series for managing IT assets like hardware and software, and the ISOIEC 30105 series for business process outsourcing operations. 3. Life cycle process standards ISOIECIEEE 12207, Software life cycle processes, and ISOIECIEEE 15288, System life cycle processes, are intentionally harmonized for use together. As stated in ISOIECIEEE 15288:2023, there is a con- tinuum of human-made systems from those that use little or no software to those in which software is the primary interest. When soft- ware is the predominant system or element of interest, ISOIECIEEE 12207 should be used.

--- Chunk 881 ---
Tokens: 394
Type: sentence-based
Text:
When soft- ware is the predominant system or element of interest, ISOIECIEEE 12207 should be used. Both standards have identical life cycle models (the same four process groups, as shown in Figure B.2) and the same processes, The processes have the same names, purposes, and process outcomes (there are minor vari- ations in a couple of process names) in both standards. Process activities and tasks differ between these two foundational standards, as some aspects of engineering for software sys- tems are different from systems in general. Conformance to ISOIECIEEE 12207 or IEEE Guide to SW Engineering Body of Knowledge (SWEBOK) ISOIECIEEE 24765 Vocabulary (SEVOCAB) Product Lines Process Description ISOIECIEEE 24774 DevOps Process View ISOIECIEEE 32675 ISOIECIEEE 24748-4 SE Plans ISOIECIEEE 24748-8 Reviews and Audits Management Systems Information Mgmt: ISOIECIEEE 15289 Individual Processes Verication Validation IEEE 1012 Software Testing ISOIECIEEE 29119 ISO 9001 Quality ISOIEC 20000 Service ISOIEC 27000 Security ISOIEC 19770 IT Asset Mgmt. Systems of systems (SoS) ISOIECIEEE 21839, 21840, 21841 Life Cycle Processes ISOIECIEEE 12207 Figure B.1. Software Engineering Standards Landscape APPENDIX B B-5 15288 can be shown either by demonstrating that all the outcomes of the process have been achieved, or that all the required activities and tasks of a process have been performed. The life cycle processes are presented in the context of their use on projects, supported by an organization that provides continuous services applicable across multiple projects.

--- Chunk 882 ---
Tokens: 387
Type: sentence-based
Text:
The life cycle processes are presented in the context of their use on projects, supported by an organization that provides continuous services applicable across multiple projects. However, the processes can be applied in very small entities which are essentially orga- nized as a single team, as well as on large pro- grams and continuing efforts that do not have a defined end point like a project. IEEE Std 12207 establishes a common framework for software life cycle processes, with well-defined terminology that can be ref- erenced by the software industry. ISOIEC 12207 applies to the acquisition of systems and software products and services and to the supply, development, operation, maintenance, and disposal of software systems and the soft- ware portion of a system, whether performed internally or externally to an organization. Those aspects of system definition and enabling systems (infrastructure) needed to provide the context for software products and services are included. Selected sets of these processes can be applied throughout the life cycle for man- aging and performing the stages of a systems life cycle. This is accomplished through the involvement of all interested parties, with the goal of achieving customer satisfaction. Table B.1 aligns the software life cycle processes of ISOIECIEEE 12207 to the SWEBOK KA and identifies related stan- dards that offer more detailed requirements and guidance for individual processes. The SWEBOK KA do not directly cover all of the process groups and processes in ISO IECIEEE 12207.

--- Chunk 883 ---
Tokens: 382
Type: sentence-based
Text:
The SWEBOK KA do not directly cover all of the process groups and processes in ISO IECIEEE 12207. The Agreement processes (acquisition and supply) are not included, nor many of the processes in the Organizational Project-enabling process group, and not all of the Technical Management or Technical process group processes. SWEBOK KA are selected to cover the essential knowledge areas applied by individual software engineers working on projects or ongoing efforts, rather than those generally handled at higher levels in the organization or on a more general level. This version of the SWEBOK has added the software security KA, which for historical reasons has been standardized separately from the systems and software engineering stan- dards committees. Security is not identified as a technical process in ISOIECIEEE 12207. An extensive suite of security standards based on the ISOIEC 27001 MSS are developed in ISOIEC JTC 1 SC 27, Information security, cybersecurity, and privacy protection. Table B.1 also identifies standards that are intended to identify process-related functions where software tools and methods should be applied, or to apply the processes to product line engineering (see B.6). 4. Extensions and specialized applications of ISOIECIEEE 12207 Numerous useful standards supplement the requirements of ISOIECIEEE 12207 to handle more rigorous or specialized situa- tions, or to provide more extended guidance on its concepts and processes. Many of these standards are parts of the ISOIECIEEE 24748 family.

--- Chunk 884 ---
Tokens: 109
Type: sentence-based
Text:
Many of these standards are parts of the ISOIECIEEE 24748 family. 4.1, Explanations of concepts and several processes ISOIECIEEE 24748-1, -2 and -3 are overall guides to the life cycle processes and invaluable for understanding and applying systems and software engineering concepts. Technical Management Technical Organizational Project-enabling Agreement Figure B.2. Process groups of ISOIEC IEEE 12207 B-6 SWEBOK  GUIDE V4.0 TABLE B.1.

--- Chunk 885 ---
Tokens: 392
Type: sentence-based
Text:
Process groups of ISOIEC IEEE 12207 B-6 SWEBOK  GUIDE V4.0 TABLE B.1. RELATED SOFTWARE ENGINEERING STANDARDS AND KA BY ISOIECIEEE 12207 PROCESS GROUP AND PROCESS 12207 Clause Number Short title SWEBOK KA Related standard (ISOIEC IEEE unless otherwise shown) Product line or tool standard (ISOIEC) Agreement 6.1.1 Acquisition 41062, 26512 6,1,2 Supply 41062 Organizational process enabling 6.2.1 Life cycle model management Yes 24748-1, 24748-2, 24748-3, 33020 6.2.2 Infrastructure management 26550 6.2.3 Portfolio management 33001 26556 6.2.4 Human Resources management Yes, Professional practice 24773 6.2.5 Quality management Yes, Quality Assurance IEEE 730, 25000, 90003 6.2.6 Knowledge management Technical management 6.3.1 Project planning Yes 16326, 24748-4, 24748-5 26555 6.3.2 Project assessment, control Yes 16326, 24748-4, 24748-5, 24748-7, 26511, 20246 23396, 23531, 26555, 33001, 33002 6.3.3 Decision management 6.3.4 Risk Management 16085, 15026 (all parts) 6.3.5 Configuration Management Yes IEEE 828, 16350, 19770 (all parts) 26559, 26560, 26561 6.3.6 Information management 15289, 26511, 26531, 23026, 82079-1 6.3.7 Measurement Yes 15939, 14143, 32430, 19761, 20926, 25020, 25021, 25022, 25023, 25024, 29881, 33003 6.3.8 Quality Assurance Yes IEEE 730, IEEE 982.1, 25010, 25012 APPENDIX B B-7 ISOIECIEEE 24748-1, Guidelines for life cycle management, is much more than a guide to performing the life cycle man- agement process. It applies to both software and systems engineering processes, with fur- ther explanations of system and process con- cepts.

--- Chunk 886 ---
Tokens: 205
Type: sentence-based
Text:
It applies to both software and systems engineering processes, with fur- ther explanations of system and process con- cepts. Instead of describing processes, which are usually applied repeatedly throughout the life cycle, it includes a detailed descrip- tion of life cycle stages, covering their pur- pose and outcomes. There are several models of life cycle stages, and in ISOIECIEEE 24748-1 the model that is analyzed in detail includes the following stages: concept, devel- opment, production, utilization, support, and retirement. Since software engineers rarely Technical 6.4.1 Business or Mission Analysis 26561 6.4.2 Stakeholder needs  requirements Yes 25030 6.4.3 Systems requirements definition Yes 29148 26551 6.4.4 Architecture definition Yes 42010, 42020 26442, 26552 6.4.5 Design definition Yes 24748- 7000.

--- Chunk 887 ---
Tokens: 379
Type: sentence-based
Text:
Since software engineers rarely Technical 6.4.1 Business or Mission Analysis 26561 6.4.2 Stakeholder needs  requirements Yes 25030 6.4.3 Systems requirements definition Yes 29148 26551 6.4.4 Architecture definition Yes 42010, 42020 26442, 26552 6.4.5 Design definition Yes 24748- 7000. 26514 26557, 26580 6.4.6 System analysis Yes, Models and Methods ISOIEC 24641 20246, 26558 6.4.7 Implementation Yes, Construction 26553 6.4.8 Integration Yes, Construction 24748-6 6.4.9 Verification Yes, Testing IEEE 1012, 25021,25040, 25041, 25045, 25062, 26513, 29119-1, 29119-2, 29119-3, 33063, 42030 23643,26554, 30130 6.4.10 Transition 26562 6.4.11 Validation Yes, Testing IEEE 1012 6.4.12 Operation Yes 32675 23531 6.4.13 Maintenance Yes 14764 6.4.14 Disposal Software security Yes ISOIEC 27000 family, 15026 (Parts 1 to 4) Software Engineering computing foundations Yes Numerous historic standards Software Engineering Mathematical foundations Yes Numerous his- toric standards Software engineering Foundations Yes Numerous historic standards B-8 SWEBOK  GUIDE V4.0 focus on production as a stage of interest, an alternate model for software life cycle stages is more useful: concept, development, opera- tions and maintenance, and retirement. Life cycle models are characterized by their devel- opment approach: sequential, incremental, or evolutionary. The life cycle models are com- pared in a risk-based approach. ISOIECIEEE 24748-2 is the overall guide to applying the systems engineering pro- cesses in ISOIECIEEE 15288.

--- Chunk 888 ---
Tokens: 374
Type: sentence-based
Text:
ISOIECIEEE 24748-2 is the overall guide to applying the systems engineering pro- cesses in ISOIECIEEE 15288. However, it does not offer line-by-line expansions of each process, activity, and task, but presents an overall strategy for transitioning to use of standardized life cycle processes. There is yet more explanation of systems concepts, a pre- sentation of organizational concepts, some discussion of conformance or adaptation (tai- loring), of standard processes, and an intro- duction to model-based systems and software engineering (MBSSE). ISOIECIEEE 24748-3, guidelines for the application of software life cycle pro- cesses, also offers commentary on concepts of software systems, organizations and projects, processes, life cycle states, and life cycle pro- cess models for software systems. It includes guidance for each of the processes in ISO IECIEEE 12207, including further anal- ysis of process purposes; outcomes and out- puts; activities, tasks, and approaches; closely related processes; and related standards. ISOIECIEEE 32675 DevOps, (IEEE 2675) has the informative subtitle of Building Reliable and Secure Systems, Including Application Build, Package, and Deployment. It defines DevOps as a set of principles and practices which enable better communication and collaboration between relevant stakeholders for the purpose of spec- ifying, developing, and operating software and systems products and services, and con- tinuous improvements in all aspects of the life cycle.

--- Chunk 889 ---
Tokens: 392
Type: sentence-based
Text:
It defines DevOps as a set of principles and practices which enable better communication and collaboration between relevant stakeholders for the purpose of spec- ifying, developing, and operating software and systems products and services, and con- tinuous improvements in all aspects of the life cycle. It expounds on the principles of DevOps, including business or mission first, customer focus, left shift and continuous everything, and systems thinking. (Left- shift is defined as  prioritizing the involve- ment of relevant stakeholders in applying quality activities, security, privacy, perfor- mance, verification, and validation earlier in the life cycle.) IEEE 2675 emphasizes the leadership commitment needed for successful application of DevOps. It reviews many of the life cycle processes in ISOIECIEEE 12207 to analyze how they are transformed by DevOps, and discusses the use of DevOps with agile methods. In earlier versions, both ISOIECIEEE 24748-4 and 24748-5 covered what to include in a management plan (Systems Engineering Management Plan or Software Engineering Management Plan), respectively. That mate- rial is still there, but now they also include guidance for systems engineers and software engineers, respectively, on the management planning and control processes, with brief presentations of related processes. 4.2 More specialized extensions Although standards are well established for specialized areas of health and safety, secu- rity, and environmental concerns, standards relating ethical values to software systems are relatively new.

--- Chunk 890 ---
Tokens: 348
Type: sentence-based
Text:
4.2 More specialized extensions Although standards are well established for specialized areas of health and safety, secu- rity, and environmental concerns, standards relating ethical values to software systems are relatively new. The potential for software systems to cause harm through biased deci- sions, violations of privacy, or lack of social responsibility led to the development of ISO IECIEEE 24748-7000 (IEEE 7000). IEEE 7000 presents a model process for incorpo- rating ethical values into systems design. Engineers, their managers, and other stake- holders benefit from well-defined processes for considering ethical issues along with the usual concerns of system performance and functionality early in the system life cycle. The standard requires consideration of values relevant to the culture where the system is to be deployed. It is applicable with any life cycle model or development methodology. The processes in this stan- dard are intended to be performed concur- rently with those in ISOIECIEEE 12207 (Table B.3) Earlier versions of ISOIECIEEE 12207 were considered by some to be overly pre- scriptive in terms of required documentation, APPENDIX B B-9 reviews, and task sequences. The current ver- sion is intended to be used by any size or type of organization, having a more strategic, agile, approach to the processes, with reduced documentation and review requirements.

--- Chunk 891 ---
Tokens: 381
Type: sentence-based
Text:
The current ver- sion is intended to be used by any size or type of organization, having a more strategic, agile, approach to the processes, with reduced documentation and review requirements. However, for highly complex and critical sys- tems, a more rigorous and structured set of processes, reviews, and audits was developed in coordination with the US Department of Defense and has been specified in ISO IECIEEE 24748-7:2019 Systems and soft- ware engineering  Life cycle management  Part 7: Application of systems engineering on defense programs and ISOIECIEEE 24748- 8:2019 Systems and software engineering  Life cycle management  Part 8: Technical reviews and audits on defense programs. For more gen- eral use, ISOIEC 20246 outlines processes and characteristics for work product reviews throughout the life cycle, covering both soft- ware and information products. ISOIECIEEE 24748-9 is an application of system and software life cycle processes in epidemic prevention and control systems. More generally, it shows ways of doing sys- tems and software engineering with lim- ited infrastructure and staff support, such as insufficient infrastructure protection, short delivery cycles, frequent iterative upgrades, and special requirements such as accuracy, disaster tolerance, degradation capability, safety, user capacity and stress testing, and rapid demand capture. 4.3 SoS standards Three standards explore how the systems and software engineering concepts and processes can be applied to systems of systems (SoS).

--- Chunk 892 ---
Tokens: 309
Type: sentence-based
Text:
4.3 SoS standards Three standards explore how the systems and software engineering concepts and processes can be applied to systems of systems (SoS). ISOIECIEEE 21839 describes how systems that are constituents of SoS are affected at each stage in their life cycle. ISOIECIEEE 21940 takes the opposite view, exploring con- cepts of an SoS and how ISOIECIEEE 15288 can be applied to SoS. ISOIECIEEE 21841 is a brief taxonomy that identifies four types of SoS: directed, acknowledged, collab- orative and virtual. 5. Single Process Standards ISOIECIEEE 12207 applies to all types of software engineering with a variety of life cycle models, techniques, and methods. Its process descriptions do not go into detail about how the process should be performed or which techniques are considered best practice. To that end, there are numerous more specialized standards with additional requirements and guidelines applicable to most of the software engineering processes. Table B.1 correlates each process in ISO IECIEEE 12207 to the related SWEBOK KAs, more specialized standards and guid- ance, and related standards for applying the process to product lines, tools, and methods. Table B.2 shows standards referenced in each knowledge area. 6.

--- Chunk 893 ---
Tokens: 373
Type: sentence-based
Text:
6. Standards for product line, methods, and tools A product line is a  set of products or ser- vices sharing explicitly defined and managed common and variable features and relying on the same domain architecture to meet the common and variable needs of specific markets (ISOIEC 26550:2015) Product line engineering raises different consider- ations, especially for ongoing configuration and release management, maintenance, and operations, from the basic approach of ISO IECIEEE 12207, which applies software engineering from the perspective of a project within an organization. Standards in the ISOIEC 26550 to 26569 series also cover capabilities of tools related to various software engineering processes and management tasks. Because software devel- opment and operations tool capabilities are continually being expanded and more tightly integrated to support the DevOps pipeline, the individual standards in this series are not closely aligned with current commer- cial product suites or open-source libraries. However, the tool standards do suggest useful features to seek in support of the software lifecycle. B-10 SWEBOK  GUIDE V4.0 7. Process assessment standards Process assessment is a long-standing method of confirming the capabilities, quality, and maturity of software engineering pro- cesses, and encouraging process improve- ment. Process audits look for evidence of performance of activities and achievement of outcomes (artifacts like work products and information items).

--- Chunk 894 ---
Tokens: 86
Type: sentence-based
Text:
Process audits look for evidence of performance of activities and achievement of outcomes (artifacts like work products and information items). The assumption is that a repeatable process with organizational sup- port performed by competent practitioners is more likely to produce acceptable soft- ware products and services. The ISOIEC TABLE B.2.

--- Chunk 895 ---
Tokens: 380
Type: sentence-based
Text:
The ISOIEC TABLE B.2. STANDARDS CITED BY KNOWLEDGE AREA KA Number Knowledge Area Cited standards (ISOIECIEEE unless otherwise designated) Introduction 24765, 12207 1 Software Requirements 24765, 12207, ISOIEC 25010, 29148 2 Software Architecture 24765, 12207, 42010 3 Software Design 12207, 24748-7000, 24765 4 Software Construction 5 Software Testing IEEE 1012, ISOIEC 20246, 24765, ISOIEC 25010, 29119 (multiple parts), 32675 6 Software Operations 12207, ISOIEC 20000, 24765, 32675 7 Software Maintenance 12207, 14764, 15288, 32675 8 Software Configuration Management IEEE 828, 24765, 12207 9 Software Engineering Management 12207, 32675 10 Software Engineering Process 12207, 24748-1, 24748-3, 24765, 24774, ISOIEC 25000, 29110, 33001, 32675 11 Software Engineering Models and Methods 12 Software Quality IEEE 730, IEEE 982.1, IEEE 1012, IEEE 1228, IEEE 1633, ISO 9001, 12207, 15026-1, 15288, 20000, 20246, 24765, 25010, 27001, 33061, 90003, IEC 60300 13 Software Security ISOIEC 15408-1, ISOIEC 18045, ISOIEC 19770-1, ISOIEC 21827, 25010, ISOIEC 27000, ISOIEC 27001, ISOIEC 27032 14 Software Engineering Professional Practice ISOIEC 24773-1, ISOIEC 24773-4 15 Software Engineering Economics 12207, 15288 16 Computing Foundations 12207, 24765 17 Mathematical Foundations 18 Engineering Foundations 24765 APPENDIX B B-11 33000 family of standards currently includes over twenty active standards related to pro- cess assessment. The overall architecture and content of the ISOIEC 330xx family is described in ISOIEC 33001.

--- Chunk 896 ---
Tokens: 351
Type: sentence-based
Text:
The overall architecture and content of the ISOIEC 330xx family is described in ISOIEC 33001. A process assessment is conducted according to a doc- umented assessment process, which identifies the rating method for process attributes and how to determine process ratings. ISOIEC 33061 is the standard for process assessment which is aligned with ISOIECIEEE 12207 software engineering processes, treated as a process reference model. 8. Professional Skills and Knowledge Standards The ISOIEC 24773 series contains require- ments specifically related to certifications for software and systems engineering profes- sionals. It is useful to industry organizations seeking to compare various certifications for professionals in systems andor software engi- neering; to individual professionals seeking to obtain certification; and to employers who may choose to recognize such certifications. These standards are intended for international use, and do not replace national or regional licensing or registration requirements for engineers. ISOIEC 24773-1 is an overview of certification concepts, and requirements for the certification processes and certification schemes applicable to software and systems engineering. ISOIEC 24773-4 provides spe- cific requirements for certification bodies in software engineering. It specifies this IEEE SWEBOK as the reference body of knowl- edge in software engineering. 9.

--- Chunk 897 ---
Tokens: 370
Type: sentence-based
Text:
9. Selected Software Engineering Standards This is not an exhaustive list of standards related to software engineering or spon- sored by the IEEE Systems and Software Engineering Standards Committee (S2ESC) or ISOIEC JTC 1SC7, Software and sys- tems engineering. Those listed are considered more authoritative, relevant, and helpful for SWEBOK users. The standards described in this appendix are continually being revised or replaced by newer standards. Users of standards should look for the most recent version and for newer titles relating to emerging topics in software engineering, such as digital engineering or standards related to artificial intelligence (AI). IEEE 730-2014 IEEE Standard for Software Quality Assurance Processes  IEEE 828-2012 IEEE Standard for Configuration Management in Systems TABLE B.3. ALIGNMENT OF ETHICAL VALUE PROCESSES IN ISOIECIEEE 24748-7000 (IEEE 7000) AND SOFTWARE ENGINEERING PROCESSES IN ISO IECIEEE 12207 IEEE Std 7000 process clause ISOIECIEEE 12207:2017 and ISOIECIEEE 15288:2023 process clause 7. Concept of Operations (ConOps) and Context Exploration 6.4.1 Business or mission analysis 8. Ethical Values Elicitation and Prioritization 6.4.1 Business or mission analysis, 6.4.2 Stakeholder needs and requirements definition 9. Ethical Requirements Definition 6.4.2 Stakeholder needs and requirements definition, 6.4.3 System requirements definition 10. Ethical Risk-Based Design 6.4.4 Architecture definition, 6.4.5 Design definition 11.

--- Chunk 898 ---
Tokens: 3332
Type: sentence-based
Text:
Ethical Risk-Based Design 6.4.4 Architecture definition, 6.4.5 Design definition 11. Transparency Management 6.3.6 Information management B-12 SWEBOK  GUIDE V4.0 and Software Engineering  IEEE 982.1-2005 IEEE Standard Dictionary of Measures of the Software Aspects of Dependability  IEEE 1012-2016 IEEE Standard for System, Software, and Hardware Verification and Validation  IEEE 1228-1994 (R2002) IEEE Standard for Software Safety Plans  IEEE 1633-2016 IEEE Recommended Practice on Software Reliability  ISO 9000:2015 Quality management systems  Fundamentals and vocabulary  ISO 9001:2015 Quality management systems  Requirements  ISOIECIEEE 12207:2017 Systems and software engineering: Software engineering processes  ISOIEC 14143 Information technolo- gy--Software measurement--Functional size measurement (multiple parts)  ISOIECIEEE 14764-2021 Software Engineering - Software Life Cycle Processes - Maintenance  ISOIECIEEE 15026-1-2019 Systems and Software EngineeringSystems and Software Assurance Part 1: Concepts and Vocabulary  ISOIECIEEE 15026- 2:2021 Systems and Software EngineeringSystems and Software AssurancePart 2: Assurance Case  ISOIEC 15026-3: 2023 Systems and Software EngineeringSystems and Software AssurancePart 3: System Integrity Levels  ISOIECIEEE 15026-4:2021, Systems and Software EngineeringSystems and Software AssurancePart 4: Assurance in the Life Cycle  ISOIECIEEE 15288:2023 Standard for Systems and Software Engineering System Life Cycle Processes  ISOIECIEEE 15289:2019 Systems and Software Engineering Content of Life-Cycle Information Products (Documentation)  ISOIEC 15408-1:2022 Information security, cybersecurity and privacy protection  Evaluation criteria for IT security  Part 1: Introduction and general model  ISOIECIEEE 15939:2017 Systems and Software Engineering Measurement Process  ISOIECIEEE 16085:2021 Systems and Software EngineeringSoftware Life Cycle Processes Risk Management  ISOIECIEEE 16326:2019 Systems and Software EngineeringLife Cycle ProcessesProject Management  ISOIEC 16350:2015 Information tech- nology  Systems and software engi- neering  Application management  ISOIEC 18045:2022 Information secu- rity, cybersecurity and privacy protection  Evaluation criteria for IT security  Methodology for IT security evaluation  ISOIEC 19761:2011 Software EngineeringCOSMIC: A Functional Size Measurement Method  ISOIEC 19770-1:2017 Information technology  IT asset management  Part 1: IT asset management systems  Requirements  ISOIEC 19770-2:2015 Information technology  IT asset management  Part 2: Software identification tag  ISOIEC 19770-3:2016 Information technology  IT asset management  Part 3: Entitlement schema  ISOIEC 19770-4:2017 Information technology  IT asset management  Part 4: Resource utilization measurement  ISOIEC 19770-5:2015 Information technology  IT asset management  Part 5: Overview and vocabulary  ISOIEC 19770-8:2020 Information technology  IT asset management  Part 8: Guidelines for mapping of industry practices tofrom the ISOIEC 19770 family of standards  ISOIEC 19770-11:2021 Information technology  IT asset management  Part 11: Requirements for bodies pro- viding audit and certification of IT asset management systems  ISOIEC 20000-1:2018 Information APPENDIX B B-13 TechnologyService Management Part 1: Service management system requirements  ISOIEC 20246:2017 Software and sys- tems engineering -- Work product reviews  ISOIEC 20741:2017 Systems and soft- ware engineering  Guideline for the evaluation and selection of software engi- neering tools  ISOIEC 20926:2009 Software and Systems EngineeringSoftware MeasurementIFPUG Functional Size Measurement Method SW Requirements  ISOIEC 20968:2002 Software EngineeringMk II Function Point AnalysisCounting Practices Manual SW Requirements  ISOIEC 21827:2008 Information tech- nology  Security techniques  systems security engineering  capability matu- rity model (SSE-CMM)  ISOIECIEEE 21839:2019 Systems and software engineering  system of systems (SoS) considerations in life cycle stages of a system  ISOIECIEEE 21840:2019 Systems and software engineering  Guidelines for the utilization of ISOIECIEEE 15288 in the context of system of systems (SoS)  ISOIECIEEE 21841:2019 Systems and software engineering  Taxonomy of systems of systems  ISOIECIEEE 23026:2023 Systems and software engineering  Engineering and management of websites for systems, software, and services information  ISOIEC 23396:2020 Systems and soft- ware engineering  Capabilities of review tools  ISOIEC 23531:2020 Systems and soft- ware engineering  Capabilities of issue management tools  ISOIEC 24570:2018 Software engi- neering -- NESMA functional size measurement method --Definitions and counting guidelines for the application of function point analysis  ISOIECIEEE 24641:2023 Systems and Software engineering  Methods and tools for model-based systems and software engineering  ISOIECIEEE 24748-1:2024 Systems and software engineering  Life cycle management  Part 1: Guidelines for life cycle management  ISOIECIEEE 24748-2:2024 Systems and software engineering  Life cycle management  Part 2: Guidelines for the application of ISOIECIEEE 15288 (system life cycle processes)  ISOIECIEEE 24748-3:2020 Systems and software engineering  Life cycle management  Part 3: Guidelines for the application of ISOIECIEEE 12207 (software life cycle processes)  ISOIECIEEE 24748-4:2016 Systems and software engineering  Life cycle management  Part 4: Systems engi- neering planning  ISOIECIEEE 24748-5:2017 Systems and software engineering  Life cycle management  Part 5: Software devel- opment planning  ISOIECIEEE 24748-6:2023, Systems and Software Engineering  Life Cycle Management  Part 6: Systems and Software Integration  ISOIECIEEE 24748-7:2019 Systems and software engineering  Life cycle management  Part 7: Application of systems engineering on defense programs  ISOIECIEEE 24748-8:2019 Systems and software engineering  Life cycle management  Part 8: Technical reviews and audits on defense programs  ISOIECIEEE 24748-9:2023 Systems and software engineering, prevention and control systems  ISOIECIEEE 24748-7000:2022 (IEEE 7000:2021) Model Process for Addressing Ethical Concerns during System Design  ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, available at www.computer.orgsevocab  ISOIEC 24773-1:2019 Software and B-14 SWEBOK  GUIDE V4.0 systems engineering  Certification of software and systems engineering profes- sionals  Part 1: General requirements  ISOIEC 24773-4:2023 Software and systems engineering  Certification of software and systems engineering profes- sionals  Part 4: Software engineering  ISOIECIEEE 24774:2021 Systems and software engineering  Life cycle management  Specification for process description  ISOIEC 25000:2014 Systems and soft- ware engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Guide to SQuaRE  ISOIEC 25001:2014 Systems and soft- ware engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  planning and management  ISOIEC 25010:2023 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  System and software quality models  ISOIEC 25012:2008 Software engi- neering  Software product Quality Requirements and Evaluation (SQuaRE)  Data quality model  ISOIEC 25020:2019 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Quality mea- surement framework  ISOIEC 25021:2012 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Quality mea- sure elements  ISOIEC 25022:2016 Systems and software engineering  Systems and software quality requirements and eval- uation (SQuaRE)  Measurement of quality in use  ISOIEC 25023:2016 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Measurement of system and software product quality  ISOIEC 25024:2015 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Measurement of data quality  ISOIEC 25030:2019 Systems and software engineering  Systems and software quality requirements and eval- uation (SQuaRE)  Quality require- ments framework  ISOIEC 25040:2011 Systems and soft- ware engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Evaluation process  ISOIEC 25041:2012 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Evaluation guide for developers, acquirers and inde- pendent evaluators  ISOIEC 25045:2010 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Evaluation module for recoverability  ISOIEC 25051:2014 Software engi- neering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Requirements for quality of Ready to Use Software Product (RUSP) and instructions for testing  ISOIEC 25062 Software Product Quality Requirements and Evaluation (SQuaRE)Common Industry Format (CIF) for Usability  ISOIEC 26442:2019 Software and sys- tems engineering--Tools and methods for product line architecture design  ISOIECIEEE 26511:2018 Systems and software engineering  Requirements for managers of information for users of systems, software, and services  ISOIECIEEE 26512:2018 Systems and software engineering  Requirements for acquirers and suppliers of informa- tion for users  ISOIECIEEE 26513:2017 Systems and software engineering  Requirements for testers and reviewers of informa- tion for users APPENDIX B B-15  ISOIEC 26514:2021 Systems and Software Engineering--Design and development of information for users  ISOIECIEEE 26515:2018 Systems and software engineering  Developing infor- mation for users in an agile environment  ISOIECIEEE 26531:2023 Systems and software engineering  Content management for product life-cycle, user and service management documentation  ISOIEC 26550:2015 Software and sys- tems engineering  Reference model for product line engineering and management  ISOIEC 26551:2016 Software and sys- tems engineering  Tools and methods for product line requirements engineering  ISOIEC 26552:2019 Software and sys- tems engineering  Tools and methods for product line architecture design  ISOIEC 26553:2018 Information tech- nology  Software and systems engi- neering  Tools and methods for product line realization  ISOIEC 26554:2018 Information tech- nology  Software and systems engi- neering  Tools and methods for product line testing  ISOIEC 26555:2015 Software and sys- tems engineering  Tools and methods for product line technical management  ISOIEC 26556:2018 Information tech- nology  Software and systems engi- neering  Tools and methods for product line organizational management  ISOIEC 26557:2016 Software and sys- tems engineering  Methods and tools for variability mechanisms in software and systems product line  ISOIEC 26558:2017 Software and sys- tems engineering  Methods and tools for variability modelling in software and systems product line  ISOIEC 26559:2017 Software and sys- tems engineering  Methods and tools for variability traceability in software and systems product line  ISOIEC 26560:2019 Software and sys- tems engineering  Tools and methods for product line product management  ISOIEC 26561:2019 Software and sys- tems engineering  Methods and tools for product line technical probe  ISOIEC 26562:2019 Software and sys- tems engineering  Methods and tools for product line transition management  ISOIEC 26580:2021 Software and sys- tems engineering  Methods and tools for the feature-based approach to software and systems product line engineering  ISOIEC 27000:2018 Information technology  Security techniques  Information security management sys- tems  Overview and vocabulary  ISOIEC 27001:2022 Information secu- rity, cybersecurity and privacy protection  Information security management systems  Requirements  ISOIEC 27032:2012 Information technology  Security techniques  Guidelines for cybersecurity  ISOIEC TR 29110-1:2016 Systems and software engineering  Lifecycle pro- files for Very Small Entities (VSEs)  Part 1: Overview  ISOIEC 29110-2-1:2015 Software engineering  Lifecycle profiles for Very Small Entities (VSEs)  Part 2-1: Framework and taxonomy  ISOIEC TR 29110-5-3:2018 Systems and software engineering  Lifecycle profiles for Very Small Entities (VSEs)  Part 5-3: Service delivery guidelines  ISOIECIEEE 29119-1: 2022 Software and systems engineering --Software testing --Part 1: Concepts and definitions  ISOIECIEEE 29119-2: 2021 Software and systems engineering --Software testing --Part 2: Test processes  ISOIECIEEE 29119-3: 2021 Software and systems engineering -- Software testing --Part 3: Test documentation  ISOIECIEEE 29119-4 Software and systems engineering--Software testing-- Part 4: Test techniques  ISOIECIEEE 29119-5: 2016 Software and systems engineering -- Software testing -- Part 5: Keyword-Driven Testing  ISOIEC TR 29119-6:2021 Software B-16 SWEBOK  GUIDE V4.0 and systems engineering  Software testing  Part 6: Guidelines for the use of ISOIECIEEE 29119 (all parts) in agile projects  ISOIEC TR 29119-11:2020 Software and systems engineering  Software testing  Part 11: Guidelines on the testing of AI-based systems  ISOIECIEEE 29148:2018.

--- Chunk 899 ---
Tokens: 3771
Type: sentence-based
Text:
Transparency Management 6.3.6 Information management B-12 SWEBOK  GUIDE V4.0 and Software Engineering  IEEE 982.1-2005 IEEE Standard Dictionary of Measures of the Software Aspects of Dependability  IEEE 1012-2016 IEEE Standard for System, Software, and Hardware Verification and Validation  IEEE 1228-1994 (R2002) IEEE Standard for Software Safety Plans  IEEE 1633-2016 IEEE Recommended Practice on Software Reliability  ISO 9000:2015 Quality management systems  Fundamentals and vocabulary  ISO 9001:2015 Quality management systems  Requirements  ISOIECIEEE 12207:2017 Systems and software engineering: Software engineering processes  ISOIEC 14143 Information technolo- gy--Software measurement--Functional size measurement (multiple parts)  ISOIECIEEE 14764-2021 Software Engineering - Software Life Cycle Processes - Maintenance  ISOIECIEEE 15026-1-2019 Systems and Software EngineeringSystems and Software Assurance Part 1: Concepts and Vocabulary  ISOIECIEEE 15026- 2:2021 Systems and Software EngineeringSystems and Software AssurancePart 2: Assurance Case  ISOIEC 15026-3: 2023 Systems and Software EngineeringSystems and Software AssurancePart 3: System Integrity Levels  ISOIECIEEE 15026-4:2021, Systems and Software EngineeringSystems and Software AssurancePart 4: Assurance in the Life Cycle  ISOIECIEEE 15288:2023 Standard for Systems and Software Engineering System Life Cycle Processes  ISOIECIEEE 15289:2019 Systems and Software Engineering Content of Life-Cycle Information Products (Documentation)  ISOIEC 15408-1:2022 Information security, cybersecurity and privacy protection  Evaluation criteria for IT security  Part 1: Introduction and general model  ISOIECIEEE 15939:2017 Systems and Software Engineering Measurement Process  ISOIECIEEE 16085:2021 Systems and Software EngineeringSoftware Life Cycle Processes Risk Management  ISOIECIEEE 16326:2019 Systems and Software EngineeringLife Cycle ProcessesProject Management  ISOIEC 16350:2015 Information tech- nology  Systems and software engi- neering  Application management  ISOIEC 18045:2022 Information secu- rity, cybersecurity and privacy protection  Evaluation criteria for IT security  Methodology for IT security evaluation  ISOIEC 19761:2011 Software EngineeringCOSMIC: A Functional Size Measurement Method  ISOIEC 19770-1:2017 Information technology  IT asset management  Part 1: IT asset management systems  Requirements  ISOIEC 19770-2:2015 Information technology  IT asset management  Part 2: Software identification tag  ISOIEC 19770-3:2016 Information technology  IT asset management  Part 3: Entitlement schema  ISOIEC 19770-4:2017 Information technology  IT asset management  Part 4: Resource utilization measurement  ISOIEC 19770-5:2015 Information technology  IT asset management  Part 5: Overview and vocabulary  ISOIEC 19770-8:2020 Information technology  IT asset management  Part 8: Guidelines for mapping of industry practices tofrom the ISOIEC 19770 family of standards  ISOIEC 19770-11:2021 Information technology  IT asset management  Part 11: Requirements for bodies pro- viding audit and certification of IT asset management systems  ISOIEC 20000-1:2018 Information APPENDIX B B-13 TechnologyService Management Part 1: Service management system requirements  ISOIEC 20246:2017 Software and sys- tems engineering -- Work product reviews  ISOIEC 20741:2017 Systems and soft- ware engineering  Guideline for the evaluation and selection of software engi- neering tools  ISOIEC 20926:2009 Software and Systems EngineeringSoftware MeasurementIFPUG Functional Size Measurement Method SW Requirements  ISOIEC 20968:2002 Software EngineeringMk II Function Point AnalysisCounting Practices Manual SW Requirements  ISOIEC 21827:2008 Information tech- nology  Security techniques  systems security engineering  capability matu- rity model (SSE-CMM)  ISOIECIEEE 21839:2019 Systems and software engineering  system of systems (SoS) considerations in life cycle stages of a system  ISOIECIEEE 21840:2019 Systems and software engineering  Guidelines for the utilization of ISOIECIEEE 15288 in the context of system of systems (SoS)  ISOIECIEEE 21841:2019 Systems and software engineering  Taxonomy of systems of systems  ISOIECIEEE 23026:2023 Systems and software engineering  Engineering and management of websites for systems, software, and services information  ISOIEC 23396:2020 Systems and soft- ware engineering  Capabilities of review tools  ISOIEC 23531:2020 Systems and soft- ware engineering  Capabilities of issue management tools  ISOIEC 24570:2018 Software engi- neering -- NESMA functional size measurement method --Definitions and counting guidelines for the application of function point analysis  ISOIECIEEE 24641:2023 Systems and Software engineering  Methods and tools for model-based systems and software engineering  ISOIECIEEE 24748-1:2024 Systems and software engineering  Life cycle management  Part 1: Guidelines for life cycle management  ISOIECIEEE 24748-2:2024 Systems and software engineering  Life cycle management  Part 2: Guidelines for the application of ISOIECIEEE 15288 (system life cycle processes)  ISOIECIEEE 24748-3:2020 Systems and software engineering  Life cycle management  Part 3: Guidelines for the application of ISOIECIEEE 12207 (software life cycle processes)  ISOIECIEEE 24748-4:2016 Systems and software engineering  Life cycle management  Part 4: Systems engi- neering planning  ISOIECIEEE 24748-5:2017 Systems and software engineering  Life cycle management  Part 5: Software devel- opment planning  ISOIECIEEE 24748-6:2023, Systems and Software Engineering  Life Cycle Management  Part 6: Systems and Software Integration  ISOIECIEEE 24748-7:2019 Systems and software engineering  Life cycle management  Part 7: Application of systems engineering on defense programs  ISOIECIEEE 24748-8:2019 Systems and software engineering  Life cycle management  Part 8: Technical reviews and audits on defense programs  ISOIECIEEE 24748-9:2023 Systems and software engineering, prevention and control systems  ISOIECIEEE 24748-7000:2022 (IEEE 7000:2021) Model Process for Addressing Ethical Concerns during System Design  ISOIECIEEE 24765:2017 Systems and Software Engineering  Vocabulary, available at www.computer.orgsevocab  ISOIEC 24773-1:2019 Software and B-14 SWEBOK  GUIDE V4.0 systems engineering  Certification of software and systems engineering profes- sionals  Part 1: General requirements  ISOIEC 24773-4:2023 Software and systems engineering  Certification of software and systems engineering profes- sionals  Part 4: Software engineering  ISOIECIEEE 24774:2021 Systems and software engineering  Life cycle management  Specification for process description  ISOIEC 25000:2014 Systems and soft- ware engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Guide to SQuaRE  ISOIEC 25001:2014 Systems and soft- ware engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  planning and management  ISOIEC 25010:2023 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  System and software quality models  ISOIEC 25012:2008 Software engi- neering  Software product Quality Requirements and Evaluation (SQuaRE)  Data quality model  ISOIEC 25020:2019 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Quality mea- surement framework  ISOIEC 25021:2012 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Quality mea- sure elements  ISOIEC 25022:2016 Systems and software engineering  Systems and software quality requirements and eval- uation (SQuaRE)  Measurement of quality in use  ISOIEC 25023:2016 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Measurement of system and software product quality  ISOIEC 25024:2015 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Measurement of data quality  ISOIEC 25030:2019 Systems and software engineering  Systems and software quality requirements and eval- uation (SQuaRE)  Quality require- ments framework  ISOIEC 25040:2011 Systems and soft- ware engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Evaluation process  ISOIEC 25041:2012 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Evaluation guide for developers, acquirers and inde- pendent evaluators  ISOIEC 25045:2010 Systems and software engineering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Evaluation module for recoverability  ISOIEC 25051:2014 Software engi- neering  Systems and software Quality Requirements and Evaluation (SQuaRE)  Requirements for quality of Ready to Use Software Product (RUSP) and instructions for testing  ISOIEC 25062 Software Product Quality Requirements and Evaluation (SQuaRE)Common Industry Format (CIF) for Usability  ISOIEC 26442:2019 Software and sys- tems engineering--Tools and methods for product line architecture design  ISOIECIEEE 26511:2018 Systems and software engineering  Requirements for managers of information for users of systems, software, and services  ISOIECIEEE 26512:2018 Systems and software engineering  Requirements for acquirers and suppliers of informa- tion for users  ISOIECIEEE 26513:2017 Systems and software engineering  Requirements for testers and reviewers of informa- tion for users APPENDIX B B-15  ISOIEC 26514:2021 Systems and Software Engineering--Design and development of information for users  ISOIECIEEE 26515:2018 Systems and software engineering  Developing infor- mation for users in an agile environment  ISOIECIEEE 26531:2023 Systems and software engineering  Content management for product life-cycle, user and service management documentation  ISOIEC 26550:2015 Software and sys- tems engineering  Reference model for product line engineering and management  ISOIEC 26551:2016 Software and sys- tems engineering  Tools and methods for product line requirements engineering  ISOIEC 26552:2019 Software and sys- tems engineering  Tools and methods for product line architecture design  ISOIEC 26553:2018 Information tech- nology  Software and systems engi- neering  Tools and methods for product line realization  ISOIEC 26554:2018 Information tech- nology  Software and systems engi- neering  Tools and methods for product line testing  ISOIEC 26555:2015 Software and sys- tems engineering  Tools and methods for product line technical management  ISOIEC 26556:2018 Information tech- nology  Software and systems engi- neering  Tools and methods for product line organizational management  ISOIEC 26557:2016 Software and sys- tems engineering  Methods and tools for variability mechanisms in software and systems product line  ISOIEC 26558:2017 Software and sys- tems engineering  Methods and tools for variability modelling in software and systems product line  ISOIEC 26559:2017 Software and sys- tems engineering  Methods and tools for variability traceability in software and systems product line  ISOIEC 26560:2019 Software and sys- tems engineering  Tools and methods for product line product management  ISOIEC 26561:2019 Software and sys- tems engineering  Methods and tools for product line technical probe  ISOIEC 26562:2019 Software and sys- tems engineering  Methods and tools for product line transition management  ISOIEC 26580:2021 Software and sys- tems engineering  Methods and tools for the feature-based approach to software and systems product line engineering  ISOIEC 27000:2018 Information technology  Security techniques  Information security management sys- tems  Overview and vocabulary  ISOIEC 27001:2022 Information secu- rity, cybersecurity and privacy protection  Information security management systems  Requirements  ISOIEC 27032:2012 Information technology  Security techniques  Guidelines for cybersecurity  ISOIEC TR 29110-1:2016 Systems and software engineering  Lifecycle pro- files for Very Small Entities (VSEs)  Part 1: Overview  ISOIEC 29110-2-1:2015 Software engineering  Lifecycle profiles for Very Small Entities (VSEs)  Part 2-1: Framework and taxonomy  ISOIEC TR 29110-5-3:2018 Systems and software engineering  Lifecycle profiles for Very Small Entities (VSEs)  Part 5-3: Service delivery guidelines  ISOIECIEEE 29119-1: 2022 Software and systems engineering --Software testing --Part 1: Concepts and definitions  ISOIECIEEE 29119-2: 2021 Software and systems engineering --Software testing --Part 2: Test processes  ISOIECIEEE 29119-3: 2021 Software and systems engineering -- Software testing --Part 3: Test documentation  ISOIECIEEE 29119-4 Software and systems engineering--Software testing-- Part 4: Test techniques  ISOIECIEEE 29119-5: 2016 Software and systems engineering -- Software testing -- Part 5: Keyword-Driven Testing  ISOIEC TR 29119-6:2021 Software B-16 SWEBOK  GUIDE V4.0 and systems engineering  Software testing  Part 6: Guidelines for the use of ISOIECIEEE 29119 (all parts) in agile projects  ISOIEC TR 29119-11:2020 Software and systems engineering  Software testing  Part 11: Guidelines on the testing of AI-based systems  ISOIECIEEE 29148:2018. Systems and Software EngineeringLife Cycle ProcessesRequirements Engineering SW Requirements  ISOIEC 30130:2016 Software engi- neering  Capabilities of software testing tools  ISOIEC 33001:2015 Information technology  Process assessment  Concepts and terminology  ISOIEC 33002:2015 Information technology  Process assessment  Requirements for performing process assessment  ISOIEC 33003:2015 Information technology  Process assessment  Requirements for process measurement frameworks  ISOIEC 33004:2015 Information technology  Process assessment  Requirements for process reference, pro- cess assessment and maturity models  ISOIEC TR 33014:2013 Information technology  Process assessment  Guide for process improvement  ISOIEC 33020:2019 Information tech- nology  Process assessment  Process measurement framework for assessment of process capability  ISOIEC TS 33061:2021 Information technology  Process assessment  Process assessment model for software life cycle processes  ISOIEC 33063:2015 Information tech- nology  Process assessment  Process assessment model for software testing  ISOIECIEEE 32430 Software engi- neering  Standard for software non-functional size measurements  ISOIECIEEE 32675:2021 (IEEE 2675:2021) DevOps: Building Reliable and Secure Systems Including Application Build, Package, and Deployment  ISOIEC 38500:2008 Corporate gover- nance of information technology  ISOIECIEEE 41062:2023 Software engineering  Recommended practice for software acquisition  ISOIECIEEE 42010:2022 Software, systems and enterprise  Architecture description  ISOIECIEEE 42020:2019: Software, systems and enterprise  Architec- ture processes  ISOIECIEEE 42030: 2019 Software, systems, and enterprise  Architecture evaluation framework  IEC 60300-1:2014 Dependability man- agement - Part 1: Guidance for manage- ment and application.

--- Chunk 900 ---
Tokens: 580
Type: sentence-based
Text:
Systems and Software EngineeringLife Cycle ProcessesRequirements Engineering SW Requirements  ISOIEC 30130:2016 Software engi- neering  Capabilities of software testing tools  ISOIEC 33001:2015 Information technology  Process assessment  Concepts and terminology  ISOIEC 33002:2015 Information technology  Process assessment  Requirements for performing process assessment  ISOIEC 33003:2015 Information technology  Process assessment  Requirements for process measurement frameworks  ISOIEC 33004:2015 Information technology  Process assessment  Requirements for process reference, pro- cess assessment and maturity models  ISOIEC TR 33014:2013 Information technology  Process assessment  Guide for process improvement  ISOIEC 33020:2019 Information tech- nology  Process assessment  Process measurement framework for assessment of process capability  ISOIEC TS 33061:2021 Information technology  Process assessment  Process assessment model for software life cycle processes  ISOIEC 33063:2015 Information tech- nology  Process assessment  Process assessment model for software testing  ISOIECIEEE 32430 Software engi- neering  Standard for software non-functional size measurements  ISOIECIEEE 32675:2021 (IEEE 2675:2021) DevOps: Building Reliable and Secure Systems Including Application Build, Package, and Deployment  ISOIEC 38500:2008 Corporate gover- nance of information technology  ISOIECIEEE 41062:2023 Software engineering  Recommended practice for software acquisition  ISOIECIEEE 42010:2022 Software, systems and enterprise  Architecture description  ISOIECIEEE 42020:2019: Software, systems and enterprise  Architec- ture processes  ISOIECIEEE 42030: 2019 Software, systems, and enterprise  Architecture evaluation framework  IEC 60300-1:2014 Dependability man- agement - Part 1: Guidance for manage- ment and application. IECIEEE 82079-1 2019 Preparation0 of Information for Use (Instructions for Use) of Products - Part 1: Principles and General Requirements  ISOIECIEEE 90003:2018 Software engineering  Guidelines for the application of ISO 9001:2015 to com- puter software C-1 CONSOLIDATED REFERENCE LIST Appendix C The Consolidated Reference List identi- fies all recommended reference materials (to the level of section number) that accom- pany the breakdown of topics within each knowledge area (KA).

--- Chunk 901 ---
Tokens: 393
Type: sentence-based
Text:
IECIEEE 82079-1 2019 Preparation0 of Information for Use (Instructions for Use) of Products - Part 1: Principles and General Requirements  ISOIECIEEE 90003:2018 Software engineering  Guidelines for the application of ISO 9001:2015 to com- puter software C-1 CONSOLIDATED REFERENCE LIST Appendix C The Consolidated Reference List identi- fies all recommended reference materials (to the level of section number) that accom- pany the breakdown of topics within each knowledge area (KA). This Consolidated Reference List is adopted by the software engineering certification and associated pro- fessional development products offered by the IEEE Computer Society. KA Editors used the references allocated to their KA by the Consolidated Reference List as their Recommended References. Collectively this Consolidated Reference List is  Complete: Covering the entire scope of the SWEBOK Guide. Sufficient: Providing enough informa- tion to describe generally accepted knowledge. Consistent: Not providing contradictory knowledge nor conflicting practices. Credible: Recognized as providing expert treatment. Current: Treating the subject in a manner that is commensurate with currently gen- erally accepted knowledge. Succinct: As short as possible (both in number of reference items and in total page count) without failing other objectives. In total, there are 37 reference mate- rials below. J.H. Allen et al, Software Security Engineering: A Guide for Project Managers, Addison-Wesley, 2008. M. Bishop, Computer Security: Art and Science, 2nd Edition, Addison- Wesley, 2018.

--- Chunk 902 ---
Tokens: 389
Type: sentence-based
Text:
M. Bishop, Computer Security: Art and Science, 2nd Edition, Addison- Wesley, 2018. B. Boehm and R. Turner, Balancing Agility and Discipline: A Guide for the Perplexed, Addison-Wesley, 2003. F. Bott et al, Professional Issues in Software Engineering, 3rd ed, Taylor  Francis, 2000. J.G. Brookshear, Computer Science: An Overview, 12th ed, Addison- Wesley, 2017. D. Budgen, Software Design, 3rd ed, CRC Press, 2021. E.W. Cheney and D.R. Kincaid, Numerical Mathematics and Computing, 6th ed, BrooksCole, 2007. P. Clements et al, Documenting Software Architectures: Views and Beyond, 2nd ed, Pearson Education, 2010. R.E. Fairley, Managing and Leading Software Projects, Wiley-IEEE Computer Society Press, 2009. C.Y Laporte, A.April, Software Quality Assurance, IEEE Computer Society Press, 1st ed, 2018. E. Gamma et al, Design Patterns: Elements of Reusable Object-Oriented Software, 1st ed, Addison-Wesley Professional, 1994. P. Grubb and A.A. Takang, Software Maintenance: Concepts and Practice, 2nd ed, World Scientific Publishing, 2003. A.M.J. Hass, Configuration Management Principles and Practices, 1st ed, Addison- Wesley, 2003. S.H. Kan, Metrics and Models in Software Quality Engineering, 2nd ed, Addison-Wesley, 2002. S. McConnell, Code Complete, 2nd ed, Microsoft Press, 2004. J. McGarry et al, Practical Software Measurement: Objective Information C-2 SWEBOK  GUIDE V4.0 for Decision Makers, Addison-Wesley Professional, 2001. S.J. Mellor and M.J. Balcer, Executable UML: A Foundation for Model- Driven Architecture, 1st ed, Addison- Wesley, 2002.

--- Chunk 903 ---
Tokens: 392
Type: sentence-based
Text:
Mellor and M.J. Balcer, Executable UML: A Foundation for Model- Driven Architecture, 1st ed, Addison- Wesley, 2002. S. Naik and P. Tripathy, Software Testing and Quality Assurance: Theory and Practice, Wiley-Spektrum, 2008. J. Nielsen, Usability Engineering, 1st ed, Morgan Kaufmann, 1993. L. Null and J. Lobur, The Essentials of Computer Organization and Architecture, 2nd ed, Jones and Bartlett Publishers, 2006. M. Page-Jones, Fundamentals of Object- Oriented Design in UML, 1st ed, Addison-Wesley, 1999. A. Silberschatz, P.B. Galvin, and G. Gagne, Operating System Concepts, 8th ed, Wiley, 2008. I. Sommerville, Software Engineering, 10th ed, Addison-Wesley, 2016. S. Tockey, Return on Software: Maximizing the Return on Your Software Investment, 1st ed, Addison- Wesley, 2004. G. Voland, Engineering by Design, 2nd ed, Prentice Hall, 2003. K.E. Wiegers, Software Requirements, 3rd ed, Microsoft Press, 2013. J.M. Wing, A Specifiers Introduction to Formal Methods, Computer, vol. 23, no. 9, 1990, pp. 8, 1023. G. Kim, J. Humble, P. Debois, J. Willis and J. Allspaw, The DevOps handbook: How to create world-class agility, reli- ability,  security in technology organi- zations, 2nd ed, IT Revolution, 2021. G. Booch, J. Rumbaugh and I. Jacobson, The Unified Modeling Language User Guide, 2nd edition, Addison- Wesley, 2005. N. Rozanski and E. Woods, Software Systems Architecture: Working with Stakeholders Using Viewpoints and Perspectives, 2nd edition, Addison- Wesley, 2011. D. Farley, Modern Software Engineering: Doing What Works to Build Better Software Faster.

--- Chunk 904 ---
Tokens: 369
Type: sentence-based
Text:
D. Farley, Modern Software Engineering: Doing What Works to Build Better Software Faster. Addison-Wesley Professional, 2022. J. Shore and S. Warden, The Art of Agile Development, OReilly Media, 2nd Edition, 2021. Project Management Institute and Agile Alliance, Agile Practice Guide, Project Management Institute, 2017. D. C. Montgomery and G. C. Runger, Applied Statistics and Probability for Engineers, 7th ed. Hoboken, NJ: Wiley, 2018. K. Rosen, Discrete Mathematics and its Applications, 8th ed, McGraw- Hill, 2018. E.W. Cheney and D.R. Kincaid, Numerical Mathematics and Computing, 7th ed, Addison Wesley, 2020. L. Null and J. Lobur, The Essentials of Computer Organization and Architecture, 5th ed. Sudbury, MA: Jones and Bartlett Publishers, 2018. The Guide to the Software Engineering Body of Knowledge (SWEBOK Guide), published by the IEEE Computer Society, represents the current state of generally accepted knowledge and promotes a consistent view of software engineering worldwide. Guide Version 4 reflects changes since the publication of Guide V3 in 2014, including modern development practices, new techniques, and the advancement of standards, such as areas and descriptions related to agile and DevOps, architecture, operations, security, and AI. IEEE Computer Society is the largest computer science and technology community dedicated to engaging engineers, scientists, academia, and industry professionals from across the globe, driving continued advancements.
