{"text": "Software Design Basics \nSoftware design is a process to transform user requirements into \nsome suitable form, which helps the programmer in software \ncoding and implementation. \nFor assessing user requirements, an SRS (Software Requirement \nSpecification) document is created whereas for coding and \nimplementation, there is a need of more specific and detailed \nrequirements in software terms. The output of this process can \ndirectly be used into implementation in programming languages. \nSoftware design is the first step in SDLC (Software Design Life \nCycle), which moves the concentration from problem domain to \nsolution domain. It tries to specify how to fulfill the requirements \nmentioned in SRS. \nSoftware Design Levels \nSoftware design yields three levels of results: \n\uf0b7 Architectural Design - The architectural design is the \nhighest abstract version of the system. It identifies the \nsoftware as a system with many components interacting \nwith each other. At this level, the designers get the idea of \nproposed solution domain. \n\uf0b7 High-level Design- The high-level design breaks the \u2018single \nentity-multiple component\u2019 concept of architectural design \ninto less-abstracted view of sub-systems and modules and \ndepicts their interaction with each other. High-level design \nfocuses on how the system along with all of its components \ncan be implemented in forms of modules. It recognizes \nmodular structure of each sub-system and their relation and \ninteraction among each other. \n", "page": 1, "type": "text", "section": "Page 1"}
{"text": "\uf0b7 Detailed \nDesign- Detailed \ndesign \ndeals \nwith \nthe \nimplementation part of what is seen as a system and its sub-\nsystems in the previous two designs. It is more detailed \ntowards modules and their implementations. It defines \nlogical structure of each module and their interfaces to \ncommunicate with other modules. \nModularization \nModularization is a technique to divide a software system into \nmultiple discrete and independent modules, which are expected \nto be capable of carrying out task(s) independently. These \nmodules may work as basic constructs for the entire software. \nDesigners tend to design modules such that they can be executed \nand/or compiled separately and independently. \nModular design unintentionally follows the rules of \u2018divide and \nconquer\u2019 problem-solving strategy this is because there are many \nother benefits attached with the modular design of a software. \nAdvantage of modularization: \n\uf0b7 Smaller components are easier to maintain \n\uf0b7 Program can be divided based on functional aspects \n\uf0b7 Desired level of abstraction can be brought in the program \n\uf0b7 Components with high cohesion can be re-used again \n\uf0b7 Concurrent execution can be made possible \n\uf0b7 Desired from security aspect \nConcurrency \nBack in time, all software are meant to be executed sequentially. \nBy sequential execution we mean that the coded instruction will \n", "page": 2, "type": "text", "section": "Page 2"}
{"text": "be executed one after another implying only one portion of \nprogram being activated at any given time. Say, a software has \nmultiple modules, then only one of all the modules can be found \nactive at any time of execution. \nIn software design, concurrency is implemented by splitting the \nsoftware into multiple independent units of execution, like \nmodules and executing them in parallel. In other words, \nconcurrency provides capability to the software to execute more \nthan one part of code in parallel to each other. \nIt is necessary for the programmers and designers to recognize \nthose modules, which can be made parallel execution. \nExample \nThe spell check feature in word processor is a module of software, \nwhich runs alongside the word processor itself. \nCoupling and Cohesion \nWhen a software program is modularized, its tasks are divided \ninto several modules based on some characteristics. As we know, \nmodules are set of instructions put together in order to achieve \nsome tasks. They are though, considered as single entity but may \nrefer to each other to work together. There are measures by \nwhich the quality of a design of modules and their interaction \namong them can be measured. These measures are called \ncoupling and cohesion. \nCohesion \nCohesion is a measure that defines the degree of intra-\ndependability within elements of a module. The greater the \ncohesion, the better is the program design. \nThere are seven types of cohesion, namely \u2013 \n", "page": 3, "type": "text", "section": "Page 3"}
{"text": "\uf0b7 Co-incidental cohesion - It is unplanned and random \ncohesion, which might be the result of breaking the program \ninto smaller modules for the sake of modularization. \nBecause it is unplanned, it may serve confusion to the \nprogrammers and is generally not-accepted. \n\uf0b7 Logical cohesion - When logically categorized elements are \nput together into a module, it is called logical cohesion. \n\uf0b7 Temporal Cohesion - When elements of module are \norganized such that they are processed at a similar point in \ntime, it is called temporal cohesion. \n\uf0b7 Procedural cohesion - When elements of module are \ngrouped together, which are executed sequentially in order \nto perform a task, it is called procedural cohesion. \n\uf0b7 Communicational cohesion - When elements of module \nare grouped together, which are executed sequentially and \nwork \non \nsame \ndata \n(information), \nit \nis \ncalled \ncommunicational cohesion. \n\uf0b7 Sequential cohesion - When elements of module are \ngrouped because the output of one element serves as input \nto another and so on, it is called sequential cohesion. \n\uf0b7 Functional cohesion - It is considered to be the highest \ndegree of cohesion, and it is highly expected. Elements of \nmodule in functional cohesion are grouped because they all \ncontribute to a single well-defined function. It can also be \nreused. \nCoupling \nCoupling is a measure that defines the level of inter-dependability \namong modules of a program. It tells at what level the modules \n", "page": 4, "type": "text", "section": "Page 4"}
{"text": "interfere and interact with each other. The lower the coupling, the \nbetter the program. \nThere are five levels of coupling, namely - \n\uf0b7 Content coupling - When a module can directly access or \nmodify or refer to the content of another module, it is called \ncontent level coupling. \n\uf0b7 Common coupling- When multiple modules have read and \nwrite access to some global data, it is called common or \nglobal coupling. \n\uf0b7 Control coupling- Two modules are called control-coupled \nif one of them decides the function of the other module or \nchanges its flow of execution. \n\uf0b7 Stamp coupling- When multiple modules share common \ndata structure and work on different part of it, it is called \nstamp coupling. \n\uf0b7 Data coupling- Data coupling is when two modules interact \nwith each other by means of passing data (as parameter). If a \nmodule passes data structure as parameter, then the \nreceiving module should use all its components. \nIdeally, no coupling is considered to be the best. \nDesign Verification \nThe output of software design process is design documentation, \npseudo codes, detailed logic diagrams, process diagrams, and \ndetailed \ndescription \nof \nall \nfunctional \nor \nnon-functional \nrequirements. \nThe next phase, which is the implementation of software, depends \non all outputs mentioned above. \n", "page": 5, "type": "text", "section": "Page 5"}
{"text": "It is then becomes necessary to verify the output before \nproceeding to the next phase. The early any mistake is detected, \nthe better it is or it might not be detected until testing of the \nproduct. If the outputs of design phase are in formal notation \nform, then their associated tools for verification should be used \notherwise a thorough design review can be used for verification \nand validation. \nBy structured verification approach, reviewers can detect defects \nthat might be caused by overlooking some conditions. A good \ndesign review is important for good software design, accuracy \nand quality. \nSoftware Design Strategies \nSoftware design is a process to conceptualize the software \nrequirements into software implementation. Software design \ntakes the user requirements as challenges and tries to find \noptimum solution. While the software is being conceptualized, a \nplan is chalked out to find the best possible design for \nimplementing the intended solution. \nThere are multiple variants of software design. Let us study them \nbriefly: \nStructured Design \nStructured design is a conceptualization of problem into several \nwell-organized elements of solution. It is basically concerned with \nthe solution design. Benefit of structured design is, it gives better \nunderstanding of how the problem is being solved. Structured \ndesign also makes it simpler for designer to concentrate on the \nproblem more accurately. \nStructured design is mostly based on \u2018divide and conquer\u2019 \nstrategy where a problem is broken into several small problems \n", "page": 6, "type": "text", "section": "Page 6"}
{"text": "and each small problem is individually solved until the whole \nproblem is solved. \nThe small pieces of problem are solved by means of solution \nmodules. Structured design emphasis that these modules be well \norganized in order to achieve precise solution. \nThese modules are arranged in hierarchy. They communicate \nwith each other. A good structured design always follows some \nrules for communication among multiple modules, namely - \nCohesion - grouping of all functionally related elements. \nCoupling - communication between different modules. \nA good structured design has high cohesion and low coupling \narrangements. \nFunction Oriented Design \nIn function-oriented design, the system is comprised of many \nsmaller sub-systems known as functions. These functions are \ncapable of performing significant task in the system. The system is \nconsidered as top view of all functions. \nFunction oriented design inherits some properties of structured \ndesign where divide and conquer methodology is used. \nThis design mechanism divides the whole system into smaller \nfunctions, which provides means of abstraction by concealing the \ninformation and their operation.. These functional modules can \nshare information among themselves by means of information \npassing and using information available globally. \nAnother characteristic of functions is that when a program calls a \nfunction, the function changes the state of the program, which \nsometimes is not acceptable by other modules. Function oriented \n", "page": 7, "type": "text", "section": "Page 7"}
{"text": "design works well where the system state does not matter and \nprogram/functions work on input rather than on a state. \nDesign Process \n\uf0b7 The whole system is seen as how data flows in the system by \nmeans of data flow diagram. \n\uf0b7 DFD depicts how functions changes data and state of entire \nsystem. \n\uf0b7 The entire system is logically broken down into smaller \nunits known as functions on the basis of their operation in \nthe system. \n\uf0b7 Each function is then described at large. \nObject Oriented Design \nObject oriented design works around the entities and their \ncharacteristics instead of functions involved in the software \nsystem. This design strategy focuses on entities and its \ncharacteristics. The whole concept of software solution revolves \naround the engaged entities. \nLet us see the important concepts of Object Oriented Design: \n\uf0b7 Objects - All entities involved in the solution design are \nknown as objects. For example, person, banks, company and \ncustomers are treated as objects. Every entity has some \nattributes associated to it and has some methods to perform \non the attributes. \n\uf0b7 Classes - A class is a generalized description of an object. An \nobject is an instance of a class. Class defines all the \nattributes, which an object can have and methods, which \ndefines the functionality of the object. \n", "page": 8, "type": "text", "section": "Page 8"}
{"text": "In the solution design, attributes are stored as variables and \nfunctionalities are defined by means of methods or procedures. \n\uf0b7 Encapsulation - In OOD, the attributes (data variables) and \nmethods (operation on the data) are bundled together is \ncalled encapsulation. Encapsulation not only bundles \nimportant information of an object together, but also \nrestricts access of the data and methods from the outside \nworld. This is called information hiding. \n\uf0b7 Inheritance - OOD allows similar classes to stack up in \nhierarchical manner where the lower or sub-classes can \nimport, implement and re-use allowed variables and \nmethods from their immediate super classes. This property \nof OOD is known as inheritance. This makes it easier to \ndefine specific class and to create generalized classes from \nspecific ones. \n\uf0b7 Polymorphism - OOD languages provide a mechanism \nwhere methods performing similar tasks but vary in \narguments, can be assigned same name. This is called \npolymorphism, which allows a single interface performing \ntasks for different types. Depending upon how the function \nis invoked, respective portion of the code gets executed. \nDesign Process \nSoftware design process can be perceived as series of well-\ndefined steps. Though it varies according to design approach \n(function oriented or object oriented, yet It may have the \nfollowing steps involved: \n\uf0b7 A solution design is created from requirement or previous \nused system and/or system sequence diagram. \n", "page": 9, "type": "text", "section": "Page 9"}
{"text": "\uf0b7 Objects are identified and grouped into classes on behalf of \nsimilarity in attribute characteristics. \n\uf0b7 Class hierarchy and relation among them is defined. \n\uf0b7 Application framework is defined. \nSoftware Design Approaches \nHere are two generic approaches for software designing: \nTop Down Design \nWe know that a system is composed of more than one sub-\nsystems and it contains a number of components. Further, these \nsub-systems and components may have their on set of sub-system \nand components and creates hierarchical structure in the system. \nTop-down design takes the whole software system as one entity \nand then decomposes it to achieve more than one sub-system or \ncomponent based on some characteristics. Each sub-system or \ncomponent is then treated as a system and decomposed further. \nThis process keeps on running until the lowest level of system in \nthe top-down hierarchy is achieved. \nTop-down design starts with a generalized model of system and \nkeeps on defining the more specific part of it. When all \ncomponents are composed the whole system comes into \nexistence. \nTop-down design is more suitable when the software solution \nneeds to be designed from scratch and specific details are \nunknown. \nBottom-up Design \nThe bottom up design model starts with most specific and basic \ncomponents. It proceeds with composing higher level of \n", "page": 10, "type": "text", "section": "Page 10"}
{"text": "components by using basic or lower level components. It keeps \ncreating higher level components until the desired system is not \nevolved as one single component. With each higher level, the \namount of abstraction is increased. \nBottom-up strategy is more suitable when a system needs to be \ncreated from some existing system, where the basic primitives \ncan be used in the newer system. \nBoth, top-down and bottom-up approaches are not practical \nindividually. Instead, a good combination of both is used. \nSoftware Implementation \nStructured Programming \nIn the process of coding, the lines of code keep multiplying, thus, \nsize of the software increases. Gradually, it becomes next to \nimpossible to remember the flow of program. If one forgets how \nsoftware and its underlying programs, files, procedures are \nconstructed it then becomes very difficult to share, debug and \nmodify the program. The solution to this is structured \nprogramming. It encourages the developer to use subroutines and \nloops instead of using simple jumps in the code, thereby bringing \nclarity in the code and improving its efficiency Structured \nprogramming also helps programmer to reduce coding time and \norganize code properly. \nStructured programming states how the program shall be coded. \nStructured programming uses three main concepts: \n\uf0b7 Top-down analysis - A software is always made to perform \nsome rational work. This rational work is known as problem \nin the software parlance. Thus it is very important that we \nunderstand how to solve the problem. Under top-down \nanalysis, the problem is broken down into small pieces \n", "page": 11, "type": "text", "section": "Page 11"}
{"text": "where each one has some significance. Each problem is \nindividually solved and steps are clearly stated about how to \nsolve the problem. \n\uf0b7 Modular Programming - While programming, the code is \nbroken down into smaller group of instructions. These \ngroups are known as modules, subprograms or subroutines. \nModular programming based on the understanding of top-\ndown analysis. It discourages jumps using \u2018goto\u2019 statements \nin the program, which often makes the program flow non-\ntraceable. Jumps are prohibited and modular format is \nencouraged in structured programming. \n\uf0b7 Structured Coding - In reference with top-down analysis, \nstructured coding sub-divides the modules into further \nsmaller units of code in the order of their execution. \nStructured programming uses control structure, which \ncontrols the flow of the program, whereas structured coding \nuses control structure to organize its instructions in \ndefinable patterns. \nFunctional Programming \nFunctional programming is style of programming language, which \nuses the concepts of mathematical functions. A function in \nmathematics should always produce the same result on receiving \nthe same argument. In procedural languages, the flow of the \nprogram runs through procedures, i.e. the control of program is \ntransferred to the called procedure. While control flow is \ntransferring from one procedure to another, the program changes \nits state. \nIn procedural programming, it is possible for a procedure to \nproduce different results when it is called with the same \nargument, as the program itself can be in different state while \n", "page": 12, "type": "text", "section": "Page 12"}
{"text": "calling it. This is a property as well as a drawback of procedural \nprogramming, in which the sequence or timing of the procedure \nexecution becomes important. \nFunctional programming provides means of computation as \nmathematical functions, which produces results irrespective of \nprogram state. This makes it possible to predict the behavior of \nthe program. \nFunctional programming uses the following concepts: \n\uf0b7 First class and High-order functions - These functions \nhave capability to accept another function as argument or \nthey return other functions as results. \n\uf0b7 Pure functions - These functions do not include destructive \nupdates, that is, they do not affect any I/O or memory and if \nthey are not in use, they can easily be removed without \nhampering the rest of the program. \n\uf0b7 Recursion - Recursion is a programming technique where a \nfunction calls itself and repeats the program code in it unless \nsome pre-defined condition matches. Recursion is the way of \ncreating loops in functional programming. \n\uf0b7 Strict evaluation - It is a method of evaluating the \nexpression passed to a function as an argument. Functional \nprogramming has two types of evaluation methods, strict \n(eager) or non-strict (lazy). Strict evaluation always \nevaluates the expression before invoking the function. Non-\nstrict evaluation does not evaluate the expression unless it is \nneeded. \n\uf0b7 \u03bb-calculus - Most functional programming languages use \u03bb-\ncalculus as their type systems. \u03bb-expressions are executed by \nevaluating them as they occur. \n", "page": 13, "type": "text", "section": "Page 13"}
{"text": "Common Lisp, Scala, Haskell, Erlang and F# are some examples of \nfunctional programming languages. \nProgramming style \nProgramming style is set of coding rules followed by all the \nprogrammers to write the code. When multiple programmers \nwork on the same software project, they frequently need to work \nwith the program code written by some other developer. This \nbecomes tedious or at times impossible, if all developers do not \nfollow some standard programming style to code the program. \nAn appropriate programming style includes using function and \nvariable names relevant to the intended task, using well-placed \nindentation, commenting code for the convenience of reader and \noverall presentation of code. This makes the program code \nreadable and understandable by all, which in turn makes \ndebugging and error solving easier. Also, proper coding style \nhelps ease the documentation and updation. \nCoding Guidelines \nPractice of coding style varies with organizations, operating \nsystems and language of coding itself. \nThe following coding elements may be defined under coding \nguidelines of an organization: \n\uf0b7 Naming conventions - This section defines how to name \nfunctions, variables, constants and global variables. \n\uf0b7 Indenting - This is the space left at the beginning of line, \nusually 2-8 whitespace or single tab. \n\uf0b7 Whitespace - It is generally omitted at the end of line. \n", "page": 14, "type": "text", "section": "Page 14"}
{"text": "\uf0b7 Operators - Defines the rules of writing mathematical, \nassignment and logical operators. For example, assignment \noperator \u2018=\u2019 should have space before and after it, as in \u201cx = \n2\u201d. \n\uf0b7 Control Structures - The rules of writing if-then-else, case-\nswitch, while-until and for control flow statements solely \nand in nested fashion. \n\uf0b7 Line length and wrapping - Defines how many characters \nshould be there in one line, mostly a line is 80 characters \nlong. Wrapping defines how a line should be wrapped, if is \ntoo long. \n\uf0b7 Functions - This defines how functions should be declared \nand invoked, with and without parameters. \n\uf0b7 Variables - This mentions how variables of different data \ntypes are declared and defined. \n\uf0b7 Comments - This is one of the important coding \ncomponents, as the comments included in the code describe \nwhat the code actually does and all other associated \ndescriptions. \nThis \nsection \nalso \nhelps \ncreating \nhelp \ndocumentations for other developers. \nSoftware Documentation \nSoftware documentation is an important part of software process. \nA well written document provides a great tool and means of \ninformation repository necessary to know about software \nprocess. Software documentation also provides information about \nhow to use the product. \nA well-maintained documentation should involve the following \ndocuments: \n", "page": 15, "type": "text", "section": "Page 15"}
{"text": "\uf0b7 Requirement documentation - This documentation works \nas key tool for software designer, developer and the test \nteam to carry out their respective tasks. This document \ncontains all the functional, non-functional and behavioral \ndescription of the intended software. \nSource of this document can be previously stored data about the \nsoftware, already running software at the client\u2019s end, client\u2019s \ninterview, questionnaires and research. Generally it is stored in \nthe form of spreadsheet or word processing document with the \nhigh-end software management team. \nThis documentation works as foundation for the software to be \ndeveloped and is majorly used in verification and validation \nphases. Most test-cases are built directly from requirement \ndocumentation. \n\uf0b7 Software Design documentation - These documentations \ncontain all the necessary information, which are needed to \nbuild the software. It contains: (a) High-level software \narchitecture, (b) Software \ndesign \ndetails, (c) Data \nflow \ndiagrams, (d) Database design \nThese documents work as repository for developers to implement \nthe software. Though these documents do not give any details on \nhow to code the program, they give all necessary information that \nis required for coding and implementation. \n\uf0b7 Technical documentation - These documentations are \nmaintained by the developers and actual coders. These \ndocuments, as a whole, represent information about the \ncode. While writing the code, the programmers also mention \nobjective of the code, who wrote it, where will it be required, \nwhat it does and how it does, what other resources the code \nuses, etc. \n", "page": 16, "type": "text", "section": "Page 16"}
{"text": "The technical documentation increases the understanding \nbetween various programmers working on the same code. It \nenhances re-use capability of the code. It makes debugging easy \nand traceable. \nThere are various automated tools available and some comes with \nthe programming language itself. For example java comes JavaDoc \ntool to generate technical documentation of code. \n\uf0b7 User documentation - This documentation is different from \nall the above explained. All previous documentations are \nmaintained to provide information about the software and \nits development process. But user documentation explains \nhow the software product should work and how it should be \nused to get the desired results. \nThese documentations may include, software installation \nprocedures, how-to guides, user-guides, uninstallation method \nand special references to get more information like license \nupdation etc. \nSoftware Implementation Challenges \nThere are some challenges faced by the development team while \nimplementing the software. Some of them are mentioned below: \n\uf0b7 Code-reuse - \nProgramming \ninterfaces \nof \npresent-day \nlanguages are very sophisticated and are equipped huge \nlibrary functions. Still, to bring the cost down of end product, \nthe organization management prefers to re-use the code, \nwhich was created earlier for some other software. There \nare huge issues faced by programmers for compatibility \nchecks and deciding how much code to re-use. \n\uf0b7 Version Management - Every time a new software is issued \nto the customer, developers have to maintain version and \n", "page": 17, "type": "text", "section": "Page 17"}
{"text": "configuration related documentation. This documentation \nneeds to be highly accurate and available on time. \n\uf0b7 Target-Host - The software program, which is being \ndeveloped in the organization, needs to be designed for host \nmachines at the customers end. But at times, it is impossible \nto design a software that works on the target machines. \n \nDesign-notations \nSoftware Design Strategies \nSoftware analysis and design includes all activities, which help the \ntransformation of requirement specification into implementation. \nRequirement specifications specify all functional and non-\nfunctional expectations from the software. These requirement \nspecifications come in the shape of human readable and \nunderstandable documents, to which a computer has nothing to \ndo. \nSoftware analysis and design is the intermediate stage, which \nhelps human-readable requirements to be transformed into \nactual code. \nLet us see few analysis and design tools used by software \ndesigners: \nData Flow Diagram \nData flow diagram is graphical representation of flow of data in an \ninformation system. It is capable of depicting incoming data flow, \noutgoing data flow and stored data. The DFD does not mention \nanything about how data flows through the system. \n", "page": 18, "type": "text", "section": "Page 18"}
{"text": "There is a prominent difference between DFD and Flowchart. The \nflowchart depicts flow of control in program modules. DFDs \ndepict flow of data in the system at various levels. DFD does not \ncontain any control or branch elements. \nTypes of DFD \nData Flow Diagrams are either Logical or Physical. \n\uf0b7 Logical DFD - This type of DFD concentrates on the system \nprocess, and flow of data in the system.For example in a \nBanking software system, how data is moved between \ndifferent entities. \n\uf0b7 Physical DFD - This type of DFD shows how the data flow is \nactually implemented in the system. It is more specific and \nclose to the implementation. \nDFD Components \nDFD can represent Source, destination, storage and flow of data \nusing the following set of components - \n \n\uf0b7 Entities - Entities are source and destination of information \ndata. Entities are represented by a rectangles with their \nrespective names. \n\uf0b7 Process - Activities and action taken on the data are \nrepresented by Circle or Round-edged rectangles. \n\uf0b7 Data Storage - There are two variants of data storage - it \ncan either be represented as a rectangle with absence of \n", "page": 19, "type": "text", "section": "Page 19"}
{"text": "both smaller sides or as an open-sided rectangle with only \none side missing. \n\uf0b7 Data Flow - Movement of data is shown by pointed arrows. \nData movement is shown from the base of arrow as its \nsource towards head of the arrow as destination. \nLevels of DFD \n\uf0b7 Level 0 - Highest abstraction level DFD is known as Level 0 \nDFD, which depicts the entire information system as one \ndiagram concealing all the underlying details. Level 0 DFDs \nare also known as context level DFDs. \n \n\uf0b7 Level 1 - The Level 0 DFD is broken down into more specific, \nLevel 1 DFD. Level 1 DFD depicts basic modules in the \nsystem and flow of data among various modules. Level 1 \nDFD also mentions basic processes and sources of \ninformation. \n", "page": 20, "type": "text", "section": "Page 20"}
{"text": " \n\uf0b7 Level 2 - At this level, DFD shows how data flows inside the \nmodules mentioned in Level 1. \nHigher level DFDs can be transformed into more specific lower \nlevel DFDs with deeper level of understanding unless the desired \nlevel of specification is achieved. \nStructure Charts \nStructure chart is a chart derived from Data Flow Diagram. It \nrepresents the system in more detail than DFD. It breaks down \nthe entire system into lowest functional modules, describes \nfunctions and sub-functions of each module of the system to a \ngreater detail than DFD. \nStructure chart represents hierarchical structure of modules. At \neach layer a specific task is performed. \nHere are the symbols used in construction of structure charts - \n", "page": 21, "type": "text", "section": "Page 21"}
{"text": "\uf0b7 Module - It represents process or subroutine or task. A \ncontrol module branches to more than one sub-module. \nLibrary Modules are re-usable and inviolable from any \nmodule.\n \n\uf0b7 Condition - It is represented by small diamond at the base \nof module. It depicts that control module can select any of \nsub-routine based on some condition.\n \n\uf0b7 Jump - An arrow is shown pointing inside the module to \ndepict that the control will jump in the middle of the sub- \nmodule. \n \n", "page": 22, "type": "text", "section": "Page 22"}
{"text": "\uf0b7 Loop - A curved arrow represents loop in the module. All \nsub-modules covered by loop repeat execution of module.\n \n\uf0b7 Data flow - A directed arrow with empty circle at the end \nrepresents data flow. \n \nControl flow - A directed arrow with filled circle at the end \nrepresents control flow. \n \n \n \n \n", "page": 23, "type": "text", "section": "Page 23"}
{"text": "HIPO Diagram \nHIPO (Hierarchical Input Process Output) diagram is a \ncombination of two organized method to analyze the system and \nprovide the means of documentation. HIPO model was developed \nby IBM in year 1970. \nHIPO diagram represents the hierarchy of modules in the \nsoftware system. Analyst uses HIPO diagram in order to obtain \nhigh-level view of system functions. It decomposes functions into \nsub-functions in a hierarchical manner. It depicts the functions \nperformed by system. \nHIPO diagrams are good for documentation purpose. Their \ngraphical representation makes it easier for designers and \nmanagers to get the pictorial idea of the system structure. \n \nIn contrast to IPO (Input Process Output) diagram, which depicts \nthe flow of control and data in a module, HIPO does not provide \nany information about data flow or control flow. \n", "page": 24, "type": "text", "section": "Page 24"}
{"text": " \nExample \nBoth parts of HIPO diagram, Hierarchical presentation and IPO \nChart are used for structure design of software program as well as \ndocumentation of the same. \nStructured English \nMost programmers are unaware of the large picture of software \nso they only rely on what their managers tell them to do. It is the \nresponsibility of higher software management to provide \naccurate information to the programmers to develop accurate yet \nfast code. \nOther forms of methods, which use graphs or diagrams, may are \nsometimes interpreted differently by different people. \nHence, analysts and designers of the software come up with tools \nsuch as Structured English. It is nothing but the description of \nwhat is required to code and how to code it. Structured English \nhelps the programmer to write error-free code. \nOther form of methods, which use graphs or diagrams, may are \nsometimes interpreted differently by different people. Here, both \nStructured English and Pseudo-Code tries to mitigate that \nunderstanding gap. \n", "page": 25, "type": "text", "section": "Page 25"}
{"text": "Structured English is the It uses plain English words in structured \nprogramming paradigm. It is not the ultimate code but a kind of \ndescription what is required to code and how to code it. The \nfollowing are some tokens of structured programming. \nIF-THEN-ELSE,   \nDO-WHILE-UNTIL \nAnalyst uses the same variable and data name, which are stored \nin Data Dictionary, making it much simpler to write and \nunderstand the code. \nExample \nWe take the same example of Customer Authentication in the \nonline shopping environment. This procedure to authenticate \ncustomer can be written in Structured English as: \nEnter Customer_Name \nSEEK Customer_Name in Customer_Name_DB file \nIF Customer_Name found THEN \n   Call procedure USER_PASSWORD_AUTHENTICATE() \nELSE \n   PRINT error message \n   Call procedure NEW_CUSTOMER_REQUEST() \nENDIF \nThe code written in Structured English is more like day-to-day \nspoken English. It can not be implemented directly as a code of \nsoftware. Structured English is independent of programming \nlanguage. \n", "page": 26, "type": "text", "section": "Page 26"}
{"text": "Pseudo-Code \nPseudo code is written more close to programming language. It \nmay be considered as augmented programming language, full of \ncomments and descriptions. \nPseudo code avoids variable declaration but they are written \nusing some actual programming language\u2019s constructs, like C, \nFortran, Pascal etc. \nPseudo code contains more programming details than Structured \nEnglish. It provides a method to perform the task, as if a computer \nis executing the code. \nExample \nProgram to print Fibonacci up to n numbers. \nvoid function Fibonacci \nGet value of n; \nSet value of a to 1; \nSet value of b to 1; \nInitialize I to 0 \nfor (i=0; i< n; i++) \n{ \n   if a greater than b  \n   { \n      Increase b by a; \n      Print b; \n   }  \n", "page": 27, "type": "text", "section": "Page 27"}
{"text": "   else if b greater than a \n   { \n      increase a by b; \n      print a; \n   } \n} \nDecision Tables \nA Decision table represents conditions and the respective actions \nto be taken to address them, in a structured tabular format. \nIt is a powerful tool to debug and prevent errors. It helps group \nsimilar information into a single table and then by combining \ntables it delivers easy and convenient decision-making. \nCreating Decision Table \nTo create the decision table, the developer must follow basic four \nsteps: \n\uf0b7 Identify all possible conditions to be addressed \n\uf0b7 Determine actions for all identified conditions \n\uf0b7 Create Maximum possible rules \n\uf0b7 Define action for each rule \nDecision Tables should be verified by end-users and can lately be \nsimplified by eliminating duplicate rules and actions. \nExample \nLet us take a simple example of day-to-day problem with our \nInternet connectivity. We begin by identifying all problems that \n", "page": 28, "type": "text", "section": "Page 28"}
{"text": "can arise while starting the internet and their respective possible \nsolutions. \nWe list all possible problems under column conditions and the \nprospective actions under column Actions. \n \nConditions/Actions \nRules \nConditions \nShows Connected \nN N N N Y Y Y Y \nPing is Working \nN N Y Y N N Y Y \nOpens Website \nY N Y N Y N Y N \nActions \nCheck network cable \nX \n \n \n \n \n \n \n \nCheck internet router \nX \n \n \n \nX X X \n \nRestart Web Browser \n \n \n \n \n \n \nX \n \nContact Service provider \n \nX X X X X X \n \nDo no action \n \n \n \n \n \n \n \n \nTable : Decision Table \u2013 In-house Internet Troubleshooting \nEntity-Relationship Model \nEntity-Relationship model is a type of database model based on \nthe notion of real world entities and relationship among them. We \ncan map real world scenario onto ER database model. ER Model \ncreates a set of entities with their attributes, a set of constraints \nand relation among them. \nER Model is best used for the conceptual design of database. ER \nModel can be represented as follows : \n", "page": 29, "type": "text", "section": "Page 29"}
{"text": " \n\uf0b7 Entity - An entity in ER Model is a real world being, which \nhas some properties called attributes. Every attribute is \ndefined by its corresponding set of values, called domain. \nFor example, consider a school database. Here, a student is an \nentity. Student has various attributes like name, id, age and class \netc. \n\uf0b7 Relationship - The logical association among entities is \ncalled relationship. Relationships are mapped with entities \nin various ways. Mapping cardinalities define the number of \nassociations between two entities. \nMapping cardinalities: \no one to one \no one to many \no many to one \no many to many \nData Dictionary \nData dictionary is the centralized collection of information about \ndata. It stores meaning and origin of data, its relationship with \nother data, data format for usage etc. Data dictionary has rigorous \ndefinitions of all names in order to facilitate user and software \ndesigners. \n", "page": 30, "type": "text", "section": "Page 30"}
{"text": "Data dictionary is often referenced as meta-data (data about data) \nrepository. It is created along with DFD (Data Flow Diagram) \nmodel of software program and is expected to be updated \nwhenever DFD is changed or updated. \nRequirement of Data Dictionary \nThe data is referenced via data dictionary while designing and \nimplementing software. Data dictionary removes any chances of \nambiguity. It helps keeping work of programmers and designers \nsynchronized while using same object reference everywhere in \nthe program. \nData dictionary provides a way of documentation for the \ncomplete database system in one place. Validation of DFD is \ncarried out using data dictionary. \nContents \nData dictionary should contain information about the following \n\uf0b7 Data Flow \n\uf0b7 Data Structure \n\uf0b7 Data Elements \n\uf0b7 Data Stores \n\uf0b7 Data Processing \nData Flow is described by means of DFDs as studied earlier and \nrepresented in algebraic form as described. \n= \nComposed of \n{} \nRepetition \n", "page": 31, "type": "text", "section": "Page 31"}
{"text": "() \nOptional \n+ \nAnd \n[ / ] \nOr \nExample \nAddress = House No + (Street / Area) + City + State \nCourse ID = Course Number + Course Name + Course Level + \nCourse Grades \nData Elements \nData elements consist of Name and descriptions of Data and \nControl Items, Internal or External data stores etc. with the \nfollowing details: \n\uf0b7 Primary Name \n\uf0b7 Secondary Name (Alias) \n\uf0b7 Use-case (How and where to use) \n\uf0b7 Content Description (Notation etc. ) \n\uf0b7 Supplementary Information (preset values, constraints etc.) \nData Store \nIt stores the information from where the data enters into the \nsystem and exists out of the system. The Data Store may include - \n\uf0b7 Files \no Internal to software. \no External to software but on the same machine. \n", "page": 32, "type": "text", "section": "Page 32"}
{"text": "o External to software and system, located on different \nmachine. \n\uf0b7 Tables \no Naming convention \no Indexing property \nData Processing \nThere are two types of Data Processing: \n\uf0b7 Logical: As user sees it \n\uf0b7 Physical: As software sees it \n \n \n \n \n \n \n \n \n \n \n \n \n \n", "page": 33, "type": "text", "section": "Page 33"}
{"text": "Principles of Software Design & Concepts in Software \nEngineering \nOnce the requirements document for the software to be \ndeveloped is available, the software design phase begins. While \nthe requirement specification activity deals entirely with the \nproblem domain, design is the first phase of transforming the \nproblem into a solution. In the design phase, the customer and \nbusiness requirements and technical considerations all come \ntogether to formulate a product or a system. \nThe design process comprises a set of principles, concepts and \npractices, which allow a software engineer to model the system or \nproduct that is to be built. This model, known as design model, is \nassessed for quality and reviewed before a code is generated and \ntests are conducted. The design model provides details about \nsoftware data structures, architecture, interfaces and components \nwhich are required to implement the system. This chapter \ndiscusses the design elements that are required to develop a \nsoftware design model. It also discusses the design patterns and \nvarious software design notations used to represent a software \ndesign. \nBasic of Software Design \nSoftware design is a phase in software engineering, in which a \nblueprint is developed to serve as a base for constructing the \nsoftware system. IEEE defines software design as 'both a process \nof defining, the architecture, components, interfaces, and other \ncharacteristics of a system or component and the result of that \nprocess.' \nIn the design phase, many critical and strategic decisions are \nmade to achieve the desired functionality and quality of the \nsystem. These decisions are taken into account to successfully \n", "page": 34, "type": "text", "section": "Page 34"}
{"text": "develop the software and carry out its maintenance in a way that \nthe quality of the end product is improved. \nPrinciples of Software Design \nDeveloping design is a cumbersome process as most expansive \nerrors are often introduced in this phase. Moreover, if these \nerrors get unnoticed till later phases, it becomes more difficult to \ncorrect them. Therefore, a number of principles are followed \nwhile designing the software. These principles act as a framework \nfor the designers to follow a good design practice. \n \nSome of the commonly followed design principles are as \nfollowing.  \n1. Software design should correspond to the analysis \nmodel: Often a design element corresponds to many \nrequirements, therefore, we must know how the design \nmodel satisfies all the requirements represented by the \nanalysis model. \n2. Choose \nthe \nright \nprogramming \nparadigm: A \nprogramming paradigm describes the structure of the \nsoftware system. Depending on the nature and type of \n", "page": 35, "type": "text", "section": "Page 35"}
{"text": "application, different programming paradigms such as \nprocedure \noriented, \nobject-oriented, \nand \nprototyping \nparadigms can be used. The paradigm should be chosen \nkeeping constraints in mind such as time, availability of \nresources and nature of user's requirements. \n3. Software \ndesign \nshould \nbe \nuniform \nand \nintegrated: Software design is considered uniform and \nintegrated, if the interfaces are properly defined among the \ndesign components. For this, rules, format, and styles are \nestablished before the design team starts designing the \nsoftware. \n4. Software design should be flexible: Software design \nshould be flexible enough to adapt changes easily. To \nachieve the flexibility, the basic design concepts such as \nabstraction, refinement, and modularity should be applied \neffectively. \n5. Software design should ensure minimal conceptual \n(semantic) errors: The design team must ensure that major \nconceptual errors of design such as ambiguousness and \ninconsistency are addressed in advance before dealing with \nthe syntactical errors present in the design model. \n6. Software design should be structured to degrade \ngently: Software should be designed to handle unusual \nchanges and circumstances, and if the need arises for \ntermination, it must do so in a proper manner so that \nfunctionality of the software is not affected. \n7. Software design should represent correspondence \nbetween the software and real-world problem: The \nsoftware design should be structured in such away that it \nalways relates with the real-world problem. \n", "page": 36, "type": "text", "section": "Page 36"}
{"text": "8. Software reuse: Software engineers believe on the phrase: \n'do not reinvent the wheel'. Therefore, software components \nshould be designed in such a way that they can be effectively \nreused to increase the productivity. \n9. Designing for testability: A common practice that has been \nfollowed is to keep the testing phase separate from the \ndesign and implementation phases. That is, first the software \nis developed (designed and implemented) and then handed \nover to the testers who subsequently determine whether the \nsoftware is fit for distribution and subsequent use by the \ncustomer. However, it has become apparent that the process \nof separating testing is seriously flawed, as if any type of \ndesign \nor \nimplementation \nerrors \nare \nfound \nafter \nimplementation, then the entire or a substantial part of the \nsoftware requires to be redone. Thus, the test engineers \nshould be involved from the initial stages. For example, they \nshould be involved with analysts to prepare tests for \ndetermining whether the user requirements are being met. \n10. \nPrototyping: Prototyping should be used when the \nrequirements are not completely defined in the beginning. \nThe user interacts with the developer to expand and refine \nthe requirements as the development proceeds. Using \nprototyping, a quick 'mock-up' of the system can be \ndeveloped. This mock-up can be used as a effective means to \ngive the users a feel of what the system will look like and \ndemonstrate functions that will be included in the developed \nsystem. Prototyping also helps in reducing risks of designing \nsoftware that is not in accordance with the customer's \nrequirements. \nNote that design principles are often constrained by the existing \nhardware configuration, the implementation language, the \n", "page": 37, "type": "text", "section": "Page 37"}
{"text": "existing file and data structures, and the existing organizational \npractices. Also, the evolution of each software design should be \nmeticulously designed for future evaluations, references and \nmaintenance. \nSoftware Design Concepts  \nEvery software process is characterized by basic concepts along \nwith certain practices or methods. Methods represent the manner \nthrough which the concepts are applied. As new technology \nreplaces older technology, many changes occur in the methods \nthat are used to apply the concepts for the development of \nsoftware. However, the fundamental concepts underlining the \nsoftware design process remain the same, some of which are \ndescribed here. \nAbstraction \nAbstraction refers to a powerful design tool, which allows \nsoftware designers to consider components at an abstract level, \nwhile \nneglecting \nthe \nimplementation \ndetails \nof \nthe \ncomponents. IEEE defines abstraction as 'a view of a problem that \nextracts the essential information relevant to a particular purpose \nand ignores the remainder of the information.' The concept of \nabstraction can be used in two ways: as a process and as an entity. \nAs a process, it refers to a mechanism of hiding irrelevant details \nand representing only the essential features of an item so that one \ncan focus on important things at a time. As an entity, it refers to a \nmodel or view of an item. \nEach step in the software process is accomplished through \nvarious levels of abstraction. At the highest level, an outline of the \nsolution to the problem is presented whereas at the lower levels, \nthe solution to the problem is presented in detail. For example, in \nthe requirements analysis phase, a solution to the problem is \n", "page": 38, "type": "text", "section": "Page 38"}
{"text": "presented using the language of problem environment and as we \nproceed through the software process, the abstraction level \nreduces and at the lowest level, source code of the software is \nproduced. \nThere are three commonly used abstraction mechanisms in \nsoftware design, namely, functional abstraction, data abstraction \nand control abstraction. All these mechanisms allow us to control \nthe complexity of the design process by proceeding from the \nabstract design model to concrete design model in a systematic \nmanner. \n1. Functional \nabstraction: This \ninvolves \nthe \nuse \nof \nparameterized subprograms. Functional abstraction can be \ngeneralized as collections of subprograms referred to as \n'groups'. Within these groups there exist routines which may \nbe visible or hidden. Visible routines can be used within the \ncontaining groups as well as within other groups, whereas \nhidden routines are hidden from other groups and can be \nused within the containing group only. \n2. Data abstraction: This involves specifying data that \ndescribes \na \ndata \nobject. \nFor \nexample, \nthe \ndata \nobject window encompasses a set of attributes (window \ntype, window dimension) that describe the window object \nclearly. In this abstraction mechanism, representation and \nmanipulation details are ignored. \n3. Control abstraction: This states the desired effect, without \nstating the exact mechanism of control. For example, if and \nwhile statements in programming languages (like C and \nC++) are abstractions of machine code implementations, \nwhich involve conditional instructions. In the architectural \ndesign \nlevel, \nthis \nabstraction \nmechanism \npermits \n", "page": 39, "type": "text", "section": "Page 39"}
{"text": "specifications of sequential subprogram and exception \nhandlers without the concern for exact details of \nimplementation. \nArchitecture \nSoftware architecture refers to the structure of the system, which \nis composed of various components of a program/ system, the \nattributes (properties) of those components and the relationship \namongst them. The software architecture enables the software \nengineers to analyze the software design efficiently. In addition, it \nalso helps them in decision-making and handling risks. The \nsoftware architecture does the following. \n\uf0b7 Provides an insight to all the interested stakeholders that \nenable them to communicate with each other \n\uf0b7 Highlights early design decisions, which have great impact \non the software engineering activities (like coding and \ntesting) that follow the design phase \n\uf0b7 Creates intellectual models of how the system is organized \ninto components and how these components interact with \neach other. \nCurrently, software architecture is represented in an informal and \nunplanned manner. Though the architectural concepts are often \nrepresented in the infrastructure (for supporting particular \narchitectural styles) and the initial stages of a system \nconfiguration, the lack of an explicit independent characterization \nof architecture restricts the advantages of this design concept in \nthe present scenario. \nNote that software architecture comprises two elements of design \nmodel, namely, data design and architectural design. \n", "page": 40, "type": "text", "section": "Page 40"}
{"text": "Patterns \nA pattern provides a description of the solution to a recurring \ndesign problem of some specific domain in such a way that the \nsolution can be used again and again. The objective of each \npattern is to provide an insight to a designer who can determine \nthe following. \n1. Whether the pattern can be reused \n2. Whether the pattern is applicable to the current project \n3. Whether the pattern can be used to develop a similar but \nfunctionally or structurally different design pattern. \nTypes of Design Patterns  \nSoftware engineer can use the design pattern during the entire \nsoftware design process. When the analysis model is developed, \nthe designer can examine the problem description at different \nlevels of abstraction to determine whether it complies with one or \nmore of the following types of design patterns. \n1. Architectural patterns: These patterns are high-level \nstrategies that refer to the overall structure and organization \nof a software system. That is, they define the elements of a \nsoftware system such as subsystems, components, classes, \netc. In addition, they also indicate the relationship between \nthe elements along with the rules and guidelines for \nspecifying these relationships. Note that architectural \npatterns are often considered equivalent to software \narchitecture. \n2. Design \npatterns: These \npatterns \nare \nmedium-level \nstrategies that are used to solve design problems. They \nprovide a means for the refinement of the elements (as \n", "page": 41, "type": "text", "section": "Page 41"}
{"text": "defined by architectural pattern) of a software system or the \nrelationship among them. Specific design elements such as \nrelationship among components or mechanisms that affect \ncomponent-to-component interaction are addressed by \ndesign patterns. Note that design patterns are often \nconsidered equivalent to software components. \n3. Idioms: These patterns are low-level patterns, which are \nprogramming-language \nspecific. \nThey \ndescribe \nthe \nimplementation of a software component, the method used \nfor interaction among software components, etc., in a \nspecific programming language. Note that idioms are often \ntermed as coding patterns. \nModularity \nModularity is achieved by dividing the software into uniquely \nnamed and addressable components,which are also known \nas modules. A complex system (large program) is partitioned into \na set of discrete modules in such a way that each module can be \ndeveloped independent of other modules. After developing the \nmodules, they are integrated together to meet the software \nrequirements. Note that larger the number of modules a system is \ndivided into, greater will be the effort required to integrate the \nmodules. \n", "page": 42, "type": "text", "section": "Page 42"}
{"text": " \nModularizing a design helps to plan the development in a more \neffective manner, accommodate changes easily, conduct testing \nand \ndebugging \neffectively \nand \nefficiently, \nand \nconduct \nmaintenance work without adversely affecting the functioning of \nthe software. \nInformation Hiding \nModules should be specified and designed in such a way that the \ndata structures and processing details of one module are not \naccessible to other modules. They pass only that much \ninformation to each other, which is required to accomplish the \nsoftware functions. The way of hiding unnecessary details is \nreferred to as information hiding. IEEE defines information \nhiding as 'the technique of encapsulating software design \ndecisions in modules in such a way that the module's interfaces \nreveal as little as possible about the module's inner workings; \nthus each module is a 'black box' to the other modules in the \nsystem. \n", "page": 43, "type": "text", "section": "Page 43"}
{"text": " \nInformation hiding is of immense use when modifications are \nrequired during the testing and maintenance phase. Some of the \nadvantages associated with information hiding are listed below. \n1. Leads to low coupling \n2. Emphasizes communication through controlled interfaces \n3. Decreases the probability of adverse effects \n4. Restricts the effects of changes in one component on others \n5. Results in higher quality software. \nStepwise Refinement \nStepwise refinement is a top-down design strategy used for \ndecomposing a system from a high level of abstraction into a \nmore detailed level (lower level) of abstraction. At the highest \nlevel of abstraction, function or information is defined \nconceptually without providing any information about the \ninternal workings of the function or internal structure of the data. \nAs we proceed towards the lower levels of abstraction, more and \nmore details are available. \n", "page": 44, "type": "text", "section": "Page 44"}
{"text": "Software designers start the stepwise refinement process by \ncreating a sequence of compositions for the system being \ndesigned. Each composition is more detailed than the previous \none and contains more components and interactions. The earlier \ncompositions represent the significant interactions within the \nsystem, while the later compositions show in detail how these \ninteractions are achieved. \nTo have a clear understanding of the concept, let us consider an \nexample \nof \nstepwise \nrefinement. \nEvery computer program \ncomprises input, process, and output. \n1. INPUT \n\uf0b7 Get user's name (string) through a prompt. \n\uf0b7 Get user's grade (integer from 0 to 100) through a prompt \nand validate. \n2. PROCESS \n3. OUTPUT \nThis is the first step in refinement. The input phase can be refined \nfurther as given here. \n1. INPUT \no Get user's name through a prompt. \no Get user's grade through a prompt. \no While (invalid grade) \nAsk again: \n2. PROCESS \n3. OUTPUT \n", "page": 45, "type": "text", "section": "Page 45"}
{"text": "Note: Stepwise refinement can also be performed for PROCESS \nand OUTPUT phase. \nRefactoring \nRefactoring is an important design activity that reduces the \ncomplexity of module design keeping its behaviour or function \nunchanged. Refactoring can be defined as a process of modifying a \nsoftware system to improve the internal structure of design \nwithout changing its external behavior. During the refactoring \nprocess, the existing design is checked for any type of flaws like \nredundancy, poorly constructed algorithms and data structures, \netc., in order to improve the design. For example, a design model \nmight yield a component which exhibits low cohesion (like a \ncomponent performs four functions that have a limited \nrelationship with one another). Software designers may decide to \nrefactor the component into four different components, each \nexhibiting high cohesion. This leads to easier integration, testing, \nand maintenance of the software components. \nStructural Partitioning  \nWhen the architectural style of a design follows a hierarchical \nnature, the structure of the program can be partitioned either \nhorizontally or vertically. In horizontal partitioning, the control \nmodules are used to communicate between functions and execute \nthe functions. Structural partitioning provides the following \nbenefits. \n\uf0b7 The testing and maintenance of software becomes easier. \n\uf0b7 The negative impacts spread slowly. \n\uf0b7 The software can be extended easily. \n", "page": 46, "type": "text", "section": "Page 46"}
{"text": "Besides these advantages, horizontal partitioning has some \ndisadvantage also. It requires to pass more data across the \nmodule interface, which makes the control flow of the problem \nmore complex. This usually happens in cases where data moves \nrapidly from one function to another. \n \nIn vertical partitioning, the functionality is distributed among \nthe modules--in a top-down manner. The modules at the top level \ncalled control modules perform the decision-making and do \nlittle processing whereas the modules at the low level \ncalled worker modules perform all input, computation and \noutput tasks. \nConcurrency \nComputer has limited resources and they must be utilized \nefficiently as much as possible. To utilize these resources \nefficiently, multiple tasks must be executed concurrently. This \nrequirement makes concurrency one of the major concepts of \nsoftware design. Every system must be designed to allow multiple \nprocesses to execute concurrently, whenever possible. For \nexample, if the current process is waiting for some event to occur, \nthe system must execute some other process in the mean time. \nHowever, concurrent execution of multiple processes sometimes \nmay result in undesirable situations such as an inconsistent state, \n", "page": 47, "type": "text", "section": "Page 47"}
{"text": "deadlock, etc. For example, consider two processes A and B and a \ndata item Q1 with the value '200'. Further, suppose A and B are \nbeing executed concurrently and firstly A reads the value of Q1 \n(which is '200') to add '100' to it. However, before A updates es \nthe value of Q1, B reads the value ofQ1 (which is still '200') to add \n'50' to it. In this situation, whether A or B first updates the value \nof Q1, the value of would definitely be wrong resulting in an \ninconsistent state of the system. This is because the actions of A \nand B are not synchronized with each other. Thus, the system \nmust control the concurrent execution and synchronize the \nactions of concurrent processes. \nOne way to achieve synchronization is mutual exclusion, which \nensures that two concurrent processes do not interfere with the \nactions of each other. To ensure this, mutual exclusion may use \nlocking technique. In this technique, the processes need to lock \nthe data item to be read or updated. The data item locked by some \nprocess cannot be accessed by other processes until it is \nunlocked. It implies that the process, that needs to access the data \nitem locked by some other process, has to wait. \nDeveloping a Design Model  \nTo develop a complete specification of design (design model), \nfour design models are needed. These models are listed below. \n1. Data design: This specifies the data structures for \nimplementing the software by converting data objects and \ntheir relationships identified during the analysis phase. \nVarious studies suggest that design engineering should \nbegin with data design, since this design lays the foundation \nfor all other design models. \n2. Architectural \ndesign: This \nspecifies \nthe \nrelationship \nbetween the structural elements of the software, design \n", "page": 48, "type": "text", "section": "Page 48"}
{"text": "patterns, architectural styles, and the factors affecting the \nways in which architecture can be implemented. \n3. Component-level \ndesign: This \nprovides \nthe \ndetailed \ndescription of how structural elements of software will \nactually be implemented. \n4. Interface \ndesign: This \ndepicts \nhow \nthe \nsoftware \ncommunicates with the system that interoperates with it \nand with the end-users. \n \n \nDifferentiate Between Top Down and Bottom UP Approaches \nIn top down strategy we start by testing the top of the hierarchy \nand we incrementally add modules that it calls and then test the \nnew combined system. This approach of testing requires stubs to \nbe written. A stub is a dummy routine that simulates a module. \n", "page": 49, "type": "text", "section": "Page 49"}
{"text": "In the top-down approach, a module cannot be tested in isolation \nbecause they invoke some other modules. To allow the modules \nto be tested before their subordinates have been coded, stubs \nsimulate the behavior of the subordinates.  \nThe bottom-up approach starts from the bottom of the hierarchy. \nFirst the modules at the very bottom, which have no subordinates, \nare tested. Then these modules are combined with higher-level \nmodules for testing. At any stage of testing all the subordinate \nmodules exist and have been tested earlier. \nTo perform bottom-up testing, drivers are needed to set up the \nappropriate environment and invoke the module. It is the job of \nthe driver to invoke the module under testing with the different \nset of test cases. \n \n \n", "page": 50, "type": "text", "section": "Page 50"}
