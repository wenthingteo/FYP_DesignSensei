{"text": "Software Design Principles and Guidelines\nDouglas C. Schmidt\nd.schmidt@vanderbilt.edu\nVanderbilt University, St. Louis\nwww.cs.wustl.edu/\u0018schmidt/\nMay 25, 2003\nDesign Principles\nDesign Principles and Guidelines Overview\nNETWORK\nSTUBS\nOS  KERNEL\nNETWORK\nINTERFACE\nMESSAGE-PASSING\nMIDDLEWARE\n       HOME\nMIDDLEWARE SERVICES\n(SECURITY,\n EVENT NOTIFICATION, TRANSACTIONS, PERSISTENCE, LOAD BALANCING,\nFAULT\n TOLERANCE, A/V STREAMING,\n DYNAMIC RESOURCE MANAGEMENT, SCHEDULING,\nNAMING,\n TRADING,\n LOGGING,\n ETC...)\nCALL\nBACKS\nCONTAINER\noperation()\nMIDDLEWARE\nINTERFACE\nOBJECT\n ADAPTER\nCLIENT\nOS  KERNEL\nNETWORK\nINTERFACE\nCOMPONENT\nEXECUTOR\nSKELETONS\nNETWORK\nPROTOCOLS\nNETWORK\nPROTOCOLS\n\u000f Design Principles\n\u2013 Important design concepts\n\u2013 Useful design principles\n\u000f Development Methodologies\n\u2013 Traditional approaches\n\u2013 Agile programming\n\u000f Design Guidelines\n\u2013 Motivation\n\u2013 Common Design Mistakes\n\u2013 Design Rules\n1\nDesign Principles\nMotivation: Goals of the Design Phase (1/2)\nEVENT\nSERVER\nSUPER\nVISOR\nCCM\nStream\nACE\nRUN-TIME\nTELECOM\nSWITCHES\nSession  Router\nModule\nEvent  Filter\nModule\nSwitch  Adapter\nModule\nEvent  Analyzer\nModule\nSUPER\nVISOR\nSUPER\nVISOR\nMIB\n\u000f Decompose system into\ncomponents\n\u2013 i.e., identify the software\narchitecture\n\u000f Determine relationships\nbetween components\n\u2013 e.g., identify component\ndependencies\n\u000f Determine intercomponent\ncommunication mechanisms\n\u2013 e.g., globals, function calls,\nshared memory, IPC/RPC\n2\nDesign Principles\nMotivation: Goals of the Design Phase (2/2)\nUPSTREAM\nDOWNSTREAM\nopen()=0\nclose()=0\nput()=0\nsvc()=0\nSTREAM\nHead\nSTREAM\nTail\n\u000f Specify component interfaces\n\u2013 Interfaces should be well-de\ufb01ned\n\u0003 Facilitates component testing\nand team communication\n\u000f Describe component functionality\n\u2013 e.g., informally or formally\n\u000f Identify opportunities for systematic\nreuse\n\u2013 Both top-down and bottom-up\n3\n", "page": 1, "type": "text", "section": "Page 1"}
{"text": "Design Principles\nMacro Steps in the Design Process\n\u000f In the design process the orientation moves from\n\u2013 Customer to developer\n\u2013 What to how\n\u000f Macro steps include:\n1. Preliminary Design\n\u2013 External design describes the real-world model\n\u2013 Architectural design decomposes the requirement speci\ufb01cation\ninto software subsystems\n2. Detailed Design\n\u2013 Specify each subsystem\n\u2013 Further decomposed subsystems, if necessary\n4\nDesign Principles\nMicro Steps in the Design Process\n\u000f Given a requirements spec, design is an\niterative decision process with the following\ngeneral steps:\n1. List the hard decisions and decisions likely to\nchange\n2. Design a component speci\ufb01cation to hide\neach such decision\n\u2013 Make decisions that apply to whole program\nfamily \ufb01rst\n\u2013 Modularize most likely changes \ufb01rst\n\u2013 Then modularize remaining dif\ufb01cult\ndecisions and decisions likely to change\n\u2013 Design the uses hierarchy as you do this\n(include reuse decisions)\n3. Treat each higher-level component as a\nspeci\ufb01cation and apply above process to each\n4. Continue re\ufb01ning until all design decisions\nare:\n\u2013 hidden in a component\n\u2013 contain easily comprehensible components\n\u2013 provide individual, independent, low-level\nimplementation assignments\n5\nDesign Principles\nExample: Designing a Web Server\nWWW\nWWW\nSERVER\nSERVER\n2: index.html\n2: index.html\n1: GET ~schmidt\n1: GET ~schmidt\nHTTP/1.0\nHTTP/1.0\nCOMMUNICATION  PROTOCOL\nCOMMUNICATION  PROTOCOL\n(\n(E\nE.\n.G\nG.,\n., HTTP\n HTTP)\n)\nGUI\nGUI\nHTML\nHTML\nPARSER\nPARSER\nREQUESTER\nREQUESTER\nGRAPHICS\nGRAPHICS\nADAPTER\nADAPTER\nNETWORK\nOS  KERNEL\nOS  I/O  SUBSYSTEM\nNETWORK  ADAPTERS\nOS  KERNEL\nOS  I/O  SUBSYSTEM\nNETWORK  ADAPTERS\nDISPATCHER\nPROTOCOL\nHANDLERS\nWWW\nCLIENT\nCLIENT\nwww.cs.wustl.edu/\u02dcjxh/\nresearch/\n\u000f Web server design\ndecisions\n\u2013 Portability issues\n\u2013 I/O demuxing and\nconcurrency\n\u2013 HTTP protocol\nprocessing\n\u2013 File access\n\u000f Web server\ncomponents\n\u2013 Event dispatcher\n\u2013 Protocol handler\n\u2013 Cached virtual\n\ufb01lesystem\n6\nDesign Principles\nKey Design Concepts and Principles\nKey design concepts and design\nprinciples include:\n1. Decomposition\n2. Abstraction and information hiding\n3. Component modularity\n4. Extensibility\n5. Virtual machine architectures\n6. Hierarchical relationships\n7. Program families and subsets\nMain goal of these\nconcepts and principles is\nto:\n\u000f Manage software\nsystem complexity\n\u000f Improve software quality\nfactors\n\u000f Facilitate systematic\nreuse\n\u000f Resolve common design\nchallenges\n7\n", "page": 2, "type": "text", "section": "Page 2"}
{"text": "Design Principles\nChallenge 1: Determining the Web Server Architecture\n\u000f Context: A large and complex production web server\n\u000f Problems:\n\u2013 Designing the web server as a large monolithic entity is tedious\nand error-prone\n\u2013 Web server developers must work concurrently to improve\nproductivity\n\u2013 Portability and resuability are important quality factors\n8\nDesign Principles\nSolution: Decomposition\n\u000f Decomposition handles complexity by splitting large problems into\nsmaller problems\n\u000f This \u201cdivide and conquer\u201d concept is common to all life-cycle\nprocesses and design techniques\n\u000f Basic methodology:\n1. Select a piece of the problem (initially, the whole problem)\n2. Determine the components in this piece using a design paradigm,\ne.g., functional, structured, object-oriented, generic, etc.\n3. Describe the components interactions\n4. Repeat steps 1 through 3 until some termination criteria is met\n\u2013 e.g., customer is satis\ufb01ed, run out of time/money, etc. ;-)\n9\nDesign Principles\nDecomposition Example: Web Server Framework\nPipes and filters\nComponent  configurator\nComponent  configurator\n~\n/home/...\nProtocol\nhandler\nProtocol\nfilter\nProtocol pipeline\nframework\nConcurrency\nstrategy\nframework\nTilde\nexpander\nCached virtual\nfilesystem\nI/O strategy\nframework\nAdapter\nActive object\nStrategy\nState\nAcceptor\nAsynchronous completion token\nMemento\nReactor/Proactor\nStrategy\nSingleton\nState\nEvent dispatcher\n\u000f Features\n\u2013 High-performance\n\u2013 Flexible concurrency,\ndemuxing, and caching\nmechanisms\n\u2013 Uses frameworks based\non ACE\nwww.cs.wustl.edu/\u0018schmidt/PDF/JAWS.pdf\n10\nDesign Principles\nObject-Oriented Decomposition Principles\n1. Don\u2019t design components to correspond to execution steps\n\u000f Since design decisions usually transcend execution time\n2. Decompose so as to limit the effect of any one design decision on\nthe rest of the system\n\u000f Anything that permeates the system will be expensive to change\n3. Components should be speci\ufb01ed by all information needed to use\nthe component\n\u000f and nothing more!\n11\n", "page": 3, "type": "text", "section": "Page 3"}
{"text": "Design Principles\nChallenge 2: Implementing a Flexible Web Server\n\u000f Context: The requirements that a production web server must meet\nwill change over time, e.g.:\n\u2013 New platforms\n\u2013 New compilers\n\u2013 New functionality\n\u2013 New performance goals\n\u000f Problems:\n\u2013 If the web server is \u201chard coded\u201d using low-level system calls it will\nbe hard to port\n\u2013 If web server developers write software that\u2019s tightly coupled with\ninternal implementation details the software will be hard to evolve\n12\nDesign Principles\nSolution: Abstraction\nIMPLEMENTATION\nIMPLEMENTATION\nESSENTIAL\nCHARACTERISTICS\nUNESSENTIAL\nDETAILS\nINTERFACE\nINTERFACE\n\u000f Abstraction manages complexity\nby emphasizing essential\ncharacteristics and suppressing\nimplementation details\n\u000f Allows postponement of certain\ndesign decisions that occur at\nvarious levels of analysis, e.g.,\n\u2013 Representational and\nalgorithmic considerations\n\u2013 Architectural and structural\nconsiderations\n\u2013 External environment and\nplatform considerations\n13\nDesign Principles\nCommon Types of Abstraction\n1. Procedural abstraction\n\u000f e.g., closed subroutines\n2. Data abstraction\n\u000f e.g., ADT classes and component models\n3. Control abstraction\n\u000f e.g., loops, iterators, frameworks, and multitasking\nACE\nStreams\nACE Reactor\nEVENT\nLOOP\nEVENT\nLOOP\nAPPLICATION-\nSPECIFIC EVENT HANDLER\nFUNCTIONALITY\nCALL\nBACKS\nLOCAL\nINVOCATIONS\nIPC\nCLASSES\nADT\nCLASSES\nACE Task\nEVENT\nLOOP\nCALLBACKS\nCALLBACKS\n14\nDesign Principles\nInformation Hiding\n\u000f Information hiding is an important means of achieving abstraction\n\u2013 i.e., design decisions that are subject to change should be hidden\nbehind abstract interfaces\n\u000f Application software should communicate only through well-de\ufb01ned\ninterfaces\n\u000f Each interface should be speci\ufb01ed by as little information as possible\n\u000f If internal details change, clients should be minimally affected\n\u2013 May not even require recompilation and relinking...\n15\n", "page": 4, "type": "text", "section": "Page 4"}
{"text": "Design Principles\nTypical Information to be Hidden\n\u000f Data representations\n\u2013 i.e., using abstract\ndata types\n\u000f Algorithms\n\u2013 e.g., sorting or\nsearching techniques\n\u000f Input and Output\nFormats\n\u2013 Machine\ndependencies, e.g.,\nbyte-ordering,\ncharacter codes\n\u000f Lower-level interfaces\n\u2013 e.g., ordering of low-level operations,\ni.e., process sequence\n\u000f Separating policy and mechanism\n\u2013 Multiple policies can be implemented\nby same mechanisms\n\u0003 e.g., OS scheduling and virtual\nmemory paging\n\u2013 Same policy can be implemented by\nmultiple mechanisms\n\u0003 e.g., reliable communication\nservice can be provided by multiple\nprotocols\n16\nDesign Principles\nInformation Hiding Example: Message Queueing\nMessage\nBlock\nMessage\nQueue\nhead_\ntail_\nSYNCH\nSTRATEGY\nMessage\nBlock\nnext()\nprev()\ncont()\nMessage\nBlock\nnext()\nprev()\ncont()\nMessage\nBlock\nnext()\nprev()\ncont()\nData_Block\nData_Block\nData_Block\nData_Block\nnext()\nprev()\ncont()\n\u000f A Message_Queue is a list of\nACE_Message_Blocks\n\u2013 Ef\ufb01ciently handles\narbitrarily-large message\npayloads\n\u000f Design encapsulates and\nparameterizes various aspects\n\u2013 e.g., synchronization, memory\nallocators, and reference\ncounting can be added\ntransparently\n17\nDesign Principles\nThe ACE_Message_Block Class\n# base_ : char *\n# refcnt_ : int\nACE_Data_Block\nACE_Message_Block\n+ init (size : size_t) : int\n+ msg_type (type : ACE_Message_Type)\n+ msg_type () : ACE_Message_Type\n+ msg_priority (prio : u_long)\n+ msg_priority () : u_long\n+ clone () : ACE_Message_Block *\n+ duplicate () : ACE_Message_Block *\n+ release () : ACE_Message_Block *\n+ set_flags (flags : u_long) : u_long\n+ clr_flags (flags : u_long) : u_long\n+ copy (buf : const char *,n : size_t) : int\n+ rd_ptr (n : size_t)\n+ rd_ptr () : char *\n+ wr_ptr (n : size_t)\n+ wr_ptr () : char *\n+ length () : size_t\n+ total_length () : size_t\n+ size () : size_t\n# rd_ptr_ : size_t\n# wr_ptr_ : size_t\n# cont_ : ACE_Message_Block *\n# next_ : ACE_Message_Block *\n# prev_ : ACE_Message_Block *\n# data_block_ : ACE_Data_Block *\n*        1\nClass characteristics\n\u000f Hide messaging implementations from clients\nACE_Message\n_Block\ncont()\ndata_block()\nwr_ptr()\nrd_ptr()\nPAYLOAD\nACE_Data\n_Block\nACE_Message\n_Block\ncont()\ndata_block()\nwr_ptr()\nrd_ptr()\nACE_Data_Block\nACE_Message\n_Block\ncont()\ndata_block()\nrd_ptr()\nwr_ptr()\nreference_count() = 2\n(1) SIMPLE MESSAGE STRUCTURE\n(2) COMPOSITE MESSAGE STRUCTURE\n18\nDesign Principles\nThe ACE_Message_Queue Class\n+ ACE_Message_Queue (high_water_mark : size_t = DEFAULT_HWM,\n                     low_water_mark : size_t = DEFAULT_LWM,\n                     notify : ACE_Notification_Strategy * = 0)\n+ open (high_water_mark : size_t = DEFAULT_HWM,\n        low_water_mark : size_t = DEFAULT_LWM,\n        notify : ACE_Notification_Strategy * = 0) : int\n+ flush () : int\n+ notification_strategy (s : ACE_Notification_Strategy *) : void\n+ is_empty () : int\n+ is_full () : int\n+ enqueue_tail (item : ACE_Message_Block *,\n                timeout : ACE_Time_Value * = 0) : int\n+ enqueue_head (item : ACE_Message_Block *,\n                timeout : ACE_Time_Value * = 0) : int\n+ enqueue_prio (item : ACE_Message_Block *,\n                timeout : ACE_Time_Value * = 0) : int\n+ dequeue_head (item : ACE_Message_Block *&,\n                timeout : ACE_Time_Value * = 0) : int\n+ dequeue_tail (item : ACE_Message_Block *&,\n                timeout : ACE_Time_Value * = 0) : int\n+ high_water_mark (new_hwm : size_t) : void\n+ high_water_mark (void) : size_t\n+ low_water_mark (new_lwm : size_t) : void\n+ low_water_mark (void) : size_t\n+ close () : int\n+ deactivate () : int\n+ activate () : int\n+ pulse () : int\n+ state () : int\n# head_ : ACE_Message_Block *\n# tail_ : ACE_Message_Block *\n# high_water_mark_ : size_t\n# low_water_mark_ : size_t\nACE_Message_Queue\nSYNCH_STRATEGY\nClass characteristics\n\u000f Note how the synchronization aspect can be\nstrategized!\n19\n", "page": 5, "type": "text", "section": "Page 5"}
{"text": "Design Principles\nChallenge 3: Determining the Units of Web Server\nDecomposition\n\u000f Context: A production web server that uses abstraction and\ninformation hiding\n\u000f Problems:\n\u2013 Need to determine the appropriate units of decomposition, which\nshould\n\u0003 Possess well-speci\ufb01ed abstract interfaces and\n\u0003 Have high cohesion and low coupling\n20\nDesign Principles\nSolution: Component Modularity\nNAMING\nTRADING\nLOCKING\nEVENT\nLOOP\nAPPLICATION-\nSPECIFIC\nGLUE CODE\nLOGGING\nTIME\n\u000f A modular system is one that\u2019s structured\ninto identi\ufb01able abstractions called\ncomponents\n\u2013 A software entity that represents an\nabstraction\n\u2013 A \u201cwork\u201d assignment for developers\n\u2013 A unit of code that\n\u0003 has one or more names\n\u0003 has identi\ufb01able boundaries\n\u0003 can be (re-)used by other components\n\u0003 encapsulates data\n\u0003 hides unnecessary details\n\u0003 can be separately compiled\n21\nDesign Principles\nDesigning Component Interfaces\n\u000f A component interface consists of\nseveral types of ports:\n\u2013 Exports\n\u0003 Services provided to other\ncomponents, e.g., facets and\nevent sources\n\u2013 Imports\n\u0003 Services requested from\nother components, e.g.,\nreceptacles and event sinks\n\u2013 Access Control\n\u0003 Not all clients are equal, e.g.,\nprotected/private/public\nCALL\nBACKS\nCONTAINER\nCOMPONENT\nEXECUTOR\n       HOME\nFACETS\nRECEPTACLES\nEVENT SINK\nEVENT SOURCE\n\u000f De\ufb01ne components that\nprovide multiple interfaces\nand implementations\n\u000f Anticipate change\n22\nDesign Principles\nComponent Modularity Example: Stream Processing\nNETWORK  INTERFA\nCE\nOR  PSEUDO-DEVICES\nSTREAM\nTail\nMultiplexor\nAPPLICATION\nStream\nSTREAM\nHead\nAPPLICATION\nStream\nUPSTREAM\nDOWNSTREAM\nMESSAGE\nWRITE\nTASK\nREAD\nTASK\nMODULE\nopen()=0\nclose()=0\nput()=0\nsvc()=0\n\u000f A Stream allows \ufb02exible\ncon\ufb01guration of layered\nprocessing modules\n\u000f A Stream component contains\na stack of Module components\n\u000f Each Module contains two\nTask components\n\u2013 i.e., read and write Tasks\n\u000f Each Task contains a\nMessage Queue component\nand a Thread Manager\ncomponent\n23\n", "page": 6, "type": "text", "section": "Page 6"}
{"text": "Design Principles\nBene\ufb01ts of Component Modularity\nModularity facilitates software\nquality factors, e.g.,:\n\u000f Extensibility\n! well-de\ufb01ned,\nabstract interfaces\n\u000f Reusability\n! low-coupling,\nhigh-cohesion\n\u000f Compatibility\n! design\n\u201cbridging\u201d interfaces\n\u000f Portability\n! hide machine\ndependencies\nModularity is important for\ngood designs since it:\n\u000f Enhances for separation of\nconcerns\n\u000f Enables developers to\nreduce overall system\ncomplexity via decentralized\nsoftware architectures\n\u000f Increases scalability by\nsupporting independent and\nconcurrent development by\nmultiple personnel\n24\nDesign Principles\nCriteria for Evaluating Modular Designs\nComponent decomposability\n\u000f Are larger components\ndecomposed into smaller\ncomponents?\nComponent composability\n\u000f Are larger components\ncomposed from existing\nsmaller components?\nComponent understandability\n\u000f Are components separately\nunderstandable?\nComponent continuity\n\u000f Do small changes to the\nspeci\ufb01cation affect a\nlocalized and limited number\nof components?\nComponent protection\n\u000f Are the effects of run-time\nabnormalities con\ufb01ned to a\nsmall number of related\ncomponents?\n25\nDesign Principles\nPrinciples for Ensuring Modular Designs\nLanguage support for components\n\u000f Components should correspond to\nsyntactic units in the language\nFew interfaces\n\u000f Every component should\ncommunicate with as few others as\npossible\nSmall interfaces (weak coupling)\n\u000f If any two components communicate\nat all, they should exchange as little\ninformation as possible\nExplicit Interfaces\n\u000f Whenever two\ncomponents A and B\ncommunicate, this must\nbe obvious from the text\nof A or B or both\nInformation Hiding\n\u000f All information about a\ncomponent should be\nprivate unless it\u2019s\nspeci\ufb01cally declared\npublic\n26\nDesign Principles\nChallenge 4: \u201cFuture Proo\ufb01ng\u201d the Web Server\n\u000f Context: A production web server whose requirements will change\nover time\n\u000f Problems:\n\u2013 Certain design aspects seem constant until they are examined in\nthe overall structure of an application\n\u2013 Developers must be able to easily refactor the web server to\naccount for new sources of variation\n27\n", "page": 7, "type": "text", "section": "Page 7"}
{"text": "Design Principles\nSolution: Extensibility\n\u000f Extensible software is important to support successions of quick\nupdates and additions to address new requirements and take\nadvantage of emerging opportunities/markets\n\u000f Extensible components must be both open and closed, i.e., the\n\u201copen/closed\u201d principle:\n\u2013 Open component\n! still available for extension\n\u0003 This is necessary since the requirements and speci\ufb01cations are\nrarely completely understood from the system\u2019s inception\n\u2013 Closed component\n! available for use by other components\n\u0003 This is necessary since code sharing becomes unmanageable\nwhen reopening a component triggers many changes\n28\nDesign Principles\nExtensibility Example: Active Object Tasks\nEvent\nHandler\nhandle_input()\nhandle_output()\nhandle_exception()\nhandle_signal()\nhandle_timeout ()\nhandle_close()\nget_handle()=0\nShared\nObject\ninit()=0\nfini ()=0\ninfo()=0\nSvc\nHandler\nService\nObject\nA\nAPPLICATION-\nSPECIFIC\nAPPLICATION-\nINDEPENDENT\nMessage\nQueue\nSYNCH_STRATEGY\nPEER_STREAM\nsuspend()=0\nresume()=0\nSYNCH\nSTRATEGY\nA\nA\nTask\nopen()=0\nclose()=0\nput()=0\nsvc()=0\nSYNCH\nSTRATEGY\nA\n\u000f Features\n\u2013 Tasks can register with a\nReactor\n\u2013 They can be dynamically\nlinked\n\u2013 They can queue data\n\u2013 They can run as \u201cactive\nobjects\u201d\n\u000f JAWS uses inheritance and\ndynamic binding to produce\ntask components that are\nboth open and closed\n29\nDesign Principles\nChallenge 5: Separating Concerns for Layered\nSystems\n\u000f Context: A production web server whose requirements will change\nover time\n\u000f Problems:\n\u2013 To enhance reuse and \ufb02exibility, it is often necessary to\ndecompose a web server into smaller, more manageable units\nthat are layered in order to\n\u0003 Enhance reuse, e.g., multiple higher-layer services can share\nlower-layer services\n\u0003 Transparently and incrementally enhancement functionality\n\u0003 Improve performance by allowing the selective omission of\nunnecessary service functionality\n\u0003 Improve implementations, testing, and maintenance\n30\nDesign Principles\nSolution: Virtual Machine Architectures\n\u000f A virtual machine provides an extended\n\u201csoftware instruction set\u201d\n\u2013 Extensions provide additional data types and\nassociated \u201csoftware instructions\u201d\n\u2013 Modeled after hardware instruction set\nprimitives that work on a limited set of data\ntypes\n\u000f A virtual machine layer provides a set of\noperations that are useful in developing a family\nof similar systems\nAPPLICATION\nPRESENTATION\nSESSION\nTRANSPORT\nNETWORK\nDATA  LINK\nPHYSICAL\nAPPLICATION\nPRESENTATION\nSESSION\nTRANSPORT\nNETWORK\nDATA  LINK\nPHYSICAL\nAPPLICATION\nPRESENTATION\nSESSION\nTRANSPORT\nNETWORK\nDATA  LINK\nPHYSICAL\nAPPLICATION\nPRESENTATION\nSESSION\nTRANSPORT\nNETWORK\nDATA  LINK\nPHYSICAL\nNETWORK\nDATA  LINK\nPHYSICAL\nNETWORK\nDATA  LINK\nPHYSICAL\nNETWORK\nDATA  LINK\nPHYSICAL\nNETWORK\nDATA  LINK\nPHYSICAL\nH\nHOST  \nOST  A\nA\nH\nHOST  \nOST  B\nB\nG\nGATEWAY  \nATEWAY  A\nA\nG\nGATEWAY  \nATEWAY  B\nB\nVIRTUAL\nLINK\nPHYSICAL\nLINK\n31\n", "page": 8, "type": "text", "section": "Page 8"}
{"text": "Design Principles\nVirtual Machine Layers for the ACE Toolkit\nPROCESSES/\nTHREADS\nDYNAMIC\nLINKING\nSHARED\nMEMORY\nSELECT/\nIO COMP\nFILE SYS\nAPIS\nWIN32 NAMED\nPIPES & UNIX\nSTREAM PIPES\nUNIX\nFIFOS\nC\nAPIS\nSOCKETS/\nTLI\nCOMMUNICATION\nSUBSYSTEM\nVIRTUAL MEMORY & FILE\nSUBSYSTEM\nGENERAL OPERATING SYSTEM SERVICES\nPROCESS/THREAD\nSUBSYSTEM\nFRAMEWORK\nLAYER\nACCEPTOR\nCONNECTOR\nNETWORKED\nSERVICE\nCOMPONENTS\nLAYER\nNAME\nSERVER\nTOKEN\nSERVER\nLOGGING\nSERVER\nGATEWAY\nSERVER\nSOCK SAP/\nTLI SAP\nFIFO\nSAP\nLOG\nMSG\nSERVICE\nHANDLER\nTIME\nSERVER\nC++\nWRAPPER\nFACADE\nLAYER\nSPIPE\nSAP\nCORBA\nHANDLER\nFILE\nSAP\nSHARED\nMALLOC\nTHE ACE ORB\n(TAO)\nJAWS ADAPTIVE\nWEB SERVER\nSTANDARDS-BASED MIDDLEWARE\nREACTOR/\nPROACTOR\nPROCESS/\nTHREAD\nMANAGERS\nSTREAMS\nSERVICE\nCONFIG-\nURATOR\nSYNCH\nWRAPPERS\nMEM\nMAP\nOS ADAPTATION LAYER\nwww.cs.wustl.edu/\n\u0018schmidt/ACE.html\n32\nDesign Principles\nOther Examples of Virtual Machines\nComputer architectures\n\u000f e.g., compiler\n! assembler\n! obj code\n!\nmicrocode\n! gates, transistors, signals, etc.\nOperating systems\n\u000f e.g., Linux\nHardware Machine\nSoftware Virtual Machine\ninstruction set\nset of system calls\nrestartable instructions\nrestartable system calls\ninterrupts/traps\nsignals\ninterrupt/trap handlers\nsignal handlers\nblocking interrupts\nmasking signals\ninterrupt stack\nsignal stack\nJava Virtual Machine (JVM)\n\u000f Abstracts away from details of the underlying OS\n33\nDesign Principles\nChallenge 6: Separating Concerns for Hierarchical\nSystems\n\u000f Context: A production web server whose requirements will change\nover time\n\u000f Problems:\n\u2013 Developers need to program components at different levels of\nabstraction independently\n\u2013 Changes to one set of components should be isolated as much\nas possible from other components\n\u2013 Need to be able to \u201cvisualize\u201d the structure of the web server\ndesign\n34\nDesign Principles\nSolution: Hierarchical Relationships\n\u000f Hierarchies reduce component interactions by restricting the\ntopology of relationships\n\u000f A relation de\ufb01nes a hierarchy if it partitions units into levels (note\nconnection to virtual machine architectures)\n\u2013 Level 0 is the set of all units that use no other units\n\u2013 Level\ni is the set of all units that use at least one unit at level\n<\ni\nand no unit at level\n\u0015\ni.\n\u000f Hierarchies form the basis of architectures and designs\n\u2013 Facilitates independent development\n\u2013 Isolates rami\ufb01cations of change\n\u2013 Allows rapid prototyping\n35\n", "page": 9, "type": "text", "section": "Page 9"}
{"text": "Design Principles\nHierarchy Example: JAWS Architecture\nsvc_run\nREQUEST PROCESSING LAYER\n Options\ns\n HTTP\nHandler\n HTTP\nHandler\n HTTP\nHandler\n HTTP\nAcceptor\n Reactor\n HTTP\nProcessor\n Msg\nQueue\ns\nsvc_run\nsvc_run\nsvc_run\n QUEUEING\n LAYER\n I/O DEMUXING\n LAYER\n36\nDesign Principles\nDe\ufb01ning Hierarchies\n\u000f Relations that de\ufb01ne hierarchies include:\n\u2013 Uses\n\u2013 Is-Composed-Of\n\u2013 Is-A\n\u2013 Has-A\n\u000f The \ufb01rst two are general to all design methods,\nthe latter two are more particular to OO design\nand programming\nACE_IPC_SAP\nACE_Addr\nACE_SOCK_IO\nACE_SOCK\nACE_SOCK_Acceptor\nACE_INET_Addr\nACE_SOCK_Stream\nACE_SOCK_Connector\n37\nDesign Principles\nThe Uses Relation (1/3)\nClass X\nClass Y\n\u000f X Uses Y if the correct functioning of X depends on\nthe availability of a correct implementation of Y\n\u000f Note, uses is not necessarily the same as invokes:\n\u2013 Some invocations are not uses\n\u0003 e.g., error logging\n\u2013 Some uses don\u2019t involve invocations\n\u0003 e.g., message passing, interrupts, shared\nmemory access\n\u000f A uses relation does not necessarily yield a\nhierarchy (avoid cycles...)\n38\nDesign Principles\nThe Uses Relation (2/3)\n\u000f Allow X to use Y when:\n\u2013 X is simpler because it uses Y\n\u0003 e.g., Standard C++ library classes\n\u2013 Y is not substantially more complex because\nit is not allowed to use X\n\u2013 There is a useful subset containing Y and not\nX\n\u0003 i.e., allows sharing and reuse of Y\n\u2013 There is no conceivably useful subset\ncontaining X but not Y\n\u0003 i.e., Y is necessary for X to function\ncorrectly\n\u000f Uses relationships can exist between classes,\nframeworks, subsystems, etc.\nAcceptor-\nConnector\nReactor\nProactor\nService\nConfigurator\nStreams\nTask\n39\n", "page": 10, "type": "text", "section": "Page 10"}
{"text": "Design Principles\nThe Uses Relation (3/3)\n\u000f A hierarchy in the uses relation is essential for designing reusable\nsoftware systems\n\u000f However, certain software systems require controlled violation of a\nuses hierarchy\n\u2013 e.g., asynchronous communication protocols, OO callbacks in\nframeworks, signal handling, etc.\n\u2013 Upcalls are one way to control these non-hierarchical\ndependencies\n\u000f Rule of thumb:\n\u2013 Start with an invocation hierarchy and eliminate those invocations\n(i.e., \u201ccalls\u201d) that are not uses relationships\n40\nDesign Principles\nThe Is-Composed-Of Relation\n\u000f The is-composed-of relationship shows how the\nsystem is broken down in components\n\u000f X is-composed-of\nfx\ni\ng if X is a group of\ncomponents\nx\ni that share some common\npurpose\n\u000f The following diagram illustrates some of the\nis-composed-of relationships in JAWS\nHTTP\nHandler\nSock\nStream\nHTTP\nHandler\nSock\nStream\nHTTP\nHandler\nSock\nStream\nHTTP\nAcceptor\nSock\nAcceptor\nReactor\n41\nDesign Principles\nThe Is-Composed-Of Relation\n\u000f Many programming languages support the is-composed-of relation\nvia some higher-level component or record structuring technique\n\u000f However, the following are not equivalent:\n\u2013 level (virtual machine)\n\u2013 component (an entity that hides one or more \u201csecrets\u201d)\n\u2013 a subprogram (a code unit)\n\u000f Components and levels need not be identical, as a component may\nappear in several levels of a uses hierarchy\n42\nDesign Principles\nThe Is-A Relation\n\u000f This \u201cancestor/descendant\u201d relationship is\nassociated with object-oriented design and\nprogramming languages that possess\ninheritance and dynamic binding\n\u000f class X possesses Is-A relationship with class Y\nif instances of class X are specialization of class\nY.\n\u2013 e.g., an HTTP_1_0_Handler Is-A\nACE_Event_Handler that is specialized for\nprocessing HTTP 1.0 requests\nACE_Event_Handler\nhandle_input()\nget_handle()\nHTTP_1_0\nHandler\nHTTP_1_1\nHandler\n43\n", "page": 11, "type": "text", "section": "Page 11"}
{"text": "Design Principles\nThe Has-A Relation\n\u000f This \u201cclient\u201d relationship is associated with\nobject-oriented design and programming\nlanguages that possess classes and objects\n\u000f class X possesses a Has-A relationship with\nclass Y if instances of class X contain an\ninstance(s) of class Y.\n\u2013 e.g., the JAWS web server Has-A Reactor,\nHTTP_Acceptor, and CV_Filesytem\nJAWS\nWeb\nServer\nHTTP\nAcceptor\nReactor\nCV_Filesystem\n44\nDesign Principles\nChallenge 7: Enabling Expansion and Contraction of\nSoftware\n\u000f Context: A production web server whose requirements will change\nover time\n\u000f Problems:\n\u2013 It may be necessary to reduce the overall functionality of the\nserver to run in resource-constrained environments\n\u2013 To meet externally imposed schedules, it may be necessary to\nrelease the server without all the features enabled\n45\nDesign Principles\nSolution: Program Families and Subsets\n\u000f This principle should be applied to facilitate extension and\ncontraction of large-scale software systems, particularly reusable\nmiddleware infrastructure\n\u2013 e.g., JAWS, ACE, etc.\n\u000f Program families are natural way to detect and implement subsets\n\u2013 Minimize footprints for embedded systems\n\u2013 Promotes system reusability\n\u2013 Anticipates potential changes\n\u000f Heuristics for identifying subsets:\n\u2013 Analyze requirements to identify minimally useful subsets\n\u2013 Also identify minimal increments to subsets\n46\nDesign Principles\nExample of Program Families: JAWS\nand TAO\n(1) THE ACE ORB (TAO)\nNETWORK\nREAL-TIME ORB CORE\nACE components \nIOP\nIOP\nPLUGGABLE\nORB & XPORT\nPROTOCOLS\nPLUGGABLE\nORB & XPORT\nPROTOCOLS\nREAL-TIME I/O\nSUBSYSTEM\nHIGH-SPEED\nNETWORK INTERFACE\nOS KERNEL\nREAL-TIME I/O\nSUBSYSTEM\nHIGH-SPEED\nNETWORK INTERFACE\nOS KERNEL\nORB RUN-TIME\nSCHEDULER\nIDL\nSKELETON\nIDL\nSTUBS\noperation ()\nout args + return value\nOBJECT\n(SERVANT)\nin args\nREAL-TIME\nOBJECT\nADAPTER\nCLIENT\nOBJ\nREF\n(2) The JAWS Web Server Framework\nService Configurator\nStrategy\nStrategy\nSingleton\nState\nState\nAcceptor\nPipes and Filters\nActive Object\nAdapter\nService Configurator\nEvent Dispatcher\nConcurrency\nStrategy\nFramework\nProtocol\nHandler\nProtocol\nFilter\nTilde\nExpander\n/home/...\n~\nReactor/Proactor\nMemento\nI/O Strategy\nFramework\nCached Virtual\nFilesystem\nProtocol Pipeline\nFramework\nAsynchronous Completon Token\n\u000f TAO is a high-performance, real-time\nimplementation of the CORBA speci\ufb01cation\n\u000f JAWS is a high-performance, adaptive Web\nserver that implements the HTTP speci\ufb01cation\n\u000f JAWS and TAO were developed using the\nwrapper facades and frameworks provided by\nthe ACE toolkit\n47\n", "page": 12, "type": "text", "section": "Page 12"}
{"text": "Design Principles\nOther Examples of Program Families\nand Subsets\n\u000f Different services for different markets\n\u2013 e.g., different alphabets, different vertical\napplications, different I/O formats\n\u000f Different hardware or software platforms\n\u2013 e.g., compilers or OSs\n\u000f Different resource trade-offs\n\u2013 e.g., speed vs space\n\u000f Different internal resources\n\u2013 e.g., shared data structures and library\nroutines\n\u000f Different external events\n\u2013 e.g., UNIX I/O device interface\n\u000f Backward compatibility\n\u2013 e.g., sometimes it is important to retain bugs!\n48\nDesign Principles\nConventional Development Processes\n\u000f Waterfall Model\n\u2013 Specify, analyze, implement, test (in sequence)\n\u2013 Assumes that requirements can be speci\ufb01ed up front\n\u000f Spiral Model\n\u2013 Supports iterative development\n\u2013 Attempts to assess risks of changes\n\u000f Rapid Application Development\n\u2013 Build a prototype\n\u2013 Ship it :-)\n49\nDesign Principles\nAgile Processes\n\u000f Stresses customer satisfaction, and therefore, involvement\n\u2013 Provide what the customer wants, as quickly as possible\n\u2013 Provide only what the customer wants\n\u000f Encourages changes in requirements\n\u000f Relies on testing\n\u000f For example, eXtreme Programming practices\n\u2013 Planning, designing, coding, testing\n50\nDesign Principles\neXtreme Programming: Planning\nTechnology\nSpike\nSystem\nPrototype\nUser\nStory\nPlanning\nGame\nIteration\nCommitment\nSchedule\nChange in Requirements, Risk,\nor Developement Environment\nRisk Estimates\nTime\nRequirements\nbased on http://www.extremeprogramming.org/rules/planninggame.html\n\u000f Start with user stories\n\u2013 Written by customers, to\nspecify system\nrequirements\n\u2013 Minimal detail, typically\njust a few sentences on a\ncard\n\u2013 Expected development\ntime: 1 to 3 weeks each,\nroughly\n\u000f Planning game creates\ncommitment schedule for\nentire project\n\u000f Each iteration should take\n2-3 weeks\n51\n", "page": 13, "type": "text", "section": "Page 13"}
{"text": "Design Principles\neXtreme Programming: Designing\n\u000f Defer design decisions as long as possible\n\u000f Advantages:\n\u2013 Simpli\ufb01es current task (just build what is needed)\n\u2013 You don\u2019t need to maintain what you haven\u2019t built\n\u2013 Time is on your side: you\u2019re likely to learn something useful by the\ntime you need to decide\n\u2013 Tomorrow may never come: if a feature isn\u2019t needed now, it might\nnever be needed\n\u000f Disadvantages:\n\u2013 Future design decisions may require rework of existing\nimplementation\n\u2013 Ramp-up time will probably be longer later\n\u0003 Therefore, always try to keep designs as simple as possible\n52\nDesign Principles\neXtreme Programming: Coding\n\u000f Pair programming\n\u2013 Always code with a partner\n\u2013 Always test as you code\n\u000f Pair programming pays off by supporting good implementation,\nreducing mistakes, and exposing more than one programmer to the\ndesign/implementation\n\u000f If any de\ufb01ciencies in existing implementation are noticed, either \ufb01x\nthem or note that they need to be \ufb01xed\n53\nDesign Principles\neXtreme Programming: Testing\n\u000f Unit tests are written before code\n\u000f Code must pass both its unit test and all regression tests before\ncommitting\n\u000f In effect, the test suite de\ufb01nes the system requirements\n\u2013 Signi\ufb01cant difference from other development approaches\n\u2013 If a bug is found, a test for it must be added\n\u2013 If a feature isn\u2019t tested, it can be removed\n54\nDesign Principles\nAgile Processes: Information Sources\n\u000f Kent Beck, Extreme Programming Explained: Embrace Change,\nAddison-Wesley, ISBN 0201616416, 1999\n\u000f Kent Beck, \u201cExtreme Programming\u201d, C++ Report 11:5, May 1999,\npp. 26\u201329+\n\u000f John Vlissides, \u201cXP\u201d, interview with Kent Beck in the Pattern\nHatching Column, C++ Report 11:6, June 1999, pp. 44-52+\n\u000f Kent Beck, \u201cEmbracing Change with Extreme Programming\u201d, IEEE\nComputer 32:10, October 1999, pp. 70-77\n\u000f http://www.extremeprogramming.org/\n\u000f http://www.xprogramming.com/\n\u000f http://c2.com/cgi/wiki?ExtremeProgrammingRoadmap\n55\n", "page": 14, "type": "text", "section": "Page 14"}
{"text": "Design Principles\nDesign Guidelines: Motivation\n\u000f Design is the process of organizing structured solutions to tasks\nfrom a problem domain\n\u000f This process is carried out in many disciplines, in many ways\n\u2013 There are many similarities and commonalities among design\nprocesses\n\u2013 There are also many common design mistakes . . .\n\u000f The following pages provide a number of \u201cdesign rules.\u201d\n\u2013 Remember, these rules are simply suggestions on how to better\norganize your design process, not a recipe for success!\n56\nDesign Principles\nCommon Design Mistakes (1/2)\n\u000f Depth-\ufb01rst design\n\u2013 only partially satisfy the requirements\n\u2013 experience is best cure for this problem . . .\n\u000f Directly re\ufb01ning requirements speci\ufb01cation\n\u2013 leads to overly constrained, inef\ufb01cient designs\n\u000f Failure to consider potential changes\n\u2013 always design for extension and contraction\n\u000f Making the design too detailed\n\u2013 this overconstrains the implementation\n57\nDesign Principles\nCommon Design Mistakes (2/2)\n\u000f Ambiguously stated design\n\u2013 misinterpreted at implementation\n\u000f Undocumented design decisions\n\u2013 designers become essential to implementation\n\u000f Inconsistent design\n\u2013 results in a non-integratable system, because separately\ndeveloped modules don\u2019t \ufb01t together\n58\nDesign Principles\nRules of Design (1/8)\n\u000f Make sure that the problem is well-de\ufb01ned\n\u2013 All design criteria, requirements, and constraints, should be\nenumerated before a design is started\n\u2013 This may require a \u201cspiral model\u201d approach\n\u000f What comes before how\n\u2013 i.e., de\ufb01ne the service to be performed at every level of\nabstraction before deciding which structures should be used to\nrealize the services\n\u000f Separate orthogonal concerns\n\u2013 Do not connect what is independent\n\u2013 Important at many levels and phases . . .\n59\n", "page": 15, "type": "text", "section": "Page 15"}
{"text": "Design Principles\nRules of Design (2/8)\n\u000f Design external functionality before internal functionality.\n\u2013 First consider the solution as a black-box and decide how it\nshould interact with its environment\n\u2013 Then decide how the black-box can be internally organized. Likely\nit consists of smaller black-boxes that can be re\ufb01ned in a similar\nfashion\n\u000f Keep it simple.\n\u2013 Fancy designs are buggier than simple ones; they are harder to\nimplement, harder to verify, and often less ef\ufb01cient\n\u2013 Problems that appear complex are often just simple problems\nhuddled together\n\u2013 Our job as designers is to identify the simpler problems, separate\nthem, and then solve them individually\n60\nDesign Principles\nRules of Design (3/8)\n\u000f Work at multiple levels of abstraction\n\u2013 Good designers must be able to move between various levels of\nabstraction quickly and easily\n\u000f Design for extensibility\n\u2013 A good design is \u201copen-ended,\u201d i.e., easily extendible\n\u2013 A good design solves a class of problems rather than a single\ninstance\n\u2013 Do not introduce what is immaterial\n\u2013 Do not restrict what is irrelevant\n\u000f Use rapid prototyping when applicable\n\u2013 Before implementing a design, build a high-level prototype and\nverify that the design criteria are met\n61\nDesign Principles\nRules of Design (4/8)\n\u000f Details should depend upon abstractions\n\u2013 Abstractions should not depend upon details\n\u2013 Principle of Dependency Inversion\n\u000f The granule of reuse is the same as the granule of release\n\u2013 Only components that are released through a tracking system can\nbe effectively reused\n\u000f Classes within a released component should share common closure\n\u2013 That is, if one needs to be changed, they all are likely to need to\nbe changed\n\u2013 i.e., what affects one, affects all\n62\nDesign Principles\nRules of Design (5/8)\n\u000f Classes within a released component should be reused together\n\u2013 That is, it is impossible to separate the components from each\nother in order to reuse less than the total\n\u000f The dependency structure for released components must be a DAG\n\u2013 There can be no cycles\n\u000f Dependencies between released components must run in the\ndirection of stability\n\u2013 The dependee must be more stable than the depender\n\u000f The more stable a released component is, the more it must consist\nof abstract classes\n\u2013 A completely stable component should consist of nothing but\nabstract classes\n63\n", "page": 16, "type": "text", "section": "Page 16"}
{"text": "Design Principles\nRules of Design (6/8)\n\u000f Where possible, use proven patterns to solve design problems\n\u000f When crossing between two different paradigms, build an interface\nlayer that separates the two\n\u2013 Don\u2019t pollute one side with the paradigm of the other\n64\nDesign Principles\nRules of Design (7/8)\n\u000f Software entities (classes, modules, etc) should be open for\nextension, but closed for modi\ufb01cation\n\u2013 The Open/Closed principle \u2013 Bertrand Meyer\n\u000f Derived classes must usable through the base class interface\nwithout the need for the user to know the difference\n\u2013 The Liskov Substitution Principle\n65\nDesign Principles\nRules of Design (8/8)\n\u000f Make it work correctly, then make it work fast\n\u2013 Implement the design, measure its performance, and if\nnecessary, optimize it\n\u000f Maintain consistency between representations\n\u2013 e.g., check that the \ufb01nal optimized implementation is equivalent to\nthe high-level design that was veri\ufb01ed\n\u2013 Also important for documentation . . .\n\u000f Don\u2019t skip the preceding rules!\n\u2013 Clearly, this is the most frequently violated rule!!! ;-)\n66\nDesign Principles\nConcluding Remarks\n\u000f Good designs can generally be distilled into a few key principles:\n\u2013 Separate interface from implementation\n\u2013 Determine what is common and what is variable with an interface\nand an implementation\n\u2013 Allow substitution of variable implementations via a common\ninterface\n\u0003 i.e., the \u201copen/closed\u201d principle\n\u2013 Dividing commonality from variability should be goal-oriented\nrather than exhaustive\n\u000f Design is not simply the act of drawing a picture using a CASE tool\nor using graphical UML notation!!!\n\u2013 Design is a fundamentally creative activity\n67\n", "page": 17, "type": "text", "section": "Page 17"}
