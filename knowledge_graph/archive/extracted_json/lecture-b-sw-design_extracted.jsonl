{"text": "Cmp Sci 187:\nIntroduction to Software Design\nFollowing Chapter 1 of text\n(Koffmann and Wolfgang)\n", "page": 1, "type": "text", "section": "Page 1"}
{"text": "Chapter 1: Introduction to Software Design\n2\nOutline\n\u2022 The software challenge and the software life cycle\n\u2022 Activities of each phase of the software life cycle\n\u2022 Using top-down design and object-oriented design\n\u2022 Managing complexity:\n\u2022 Data abstraction\n\u2022 Procedural abstraction\n\u2022 Information hiding\n\u2022 Class diagrams document interactions between classes\n", "page": 2, "type": "text", "section": "Page 2"}
{"text": "Chapter 1: Introduction to Software Design\n3\nOutline (2)\n\u2022 Abstract data types:\n\u2022 Role in modeling\n\u2022 Implementing them with classes and interfaces\n\u2022 Use cases: tool to document interaction with a user\n\u2022 Software design process example:\n\u2022 Design and implementation of an array-based \ntelephone directory\n\u2022 Sequence diagrams: tool for documenting the interaction \nbetween multiple classes used in a program\n", "page": 3, "type": "text", "section": "Page 3"}
{"text": "Chapter 1: Introduction to Software Design\n4\nThe Software Challenge\n\u2022 Software is ...\n\u2022 Used for a long time\n\u2022 Updated and maintained\n\u2022 By people who did not write it\n\u2022 Initial specification may be incomplete\n\u2022 Specification clarified through extensive interaction \nbetween user(s) and system analyst(s)\n\u2022 Requirements specification needed at the beginning of \nany software project\n\u2022 Designers and users should both approve it!\n", "page": 4, "type": "text", "section": "Page 4"}
{"text": "Chapter 1: Introduction to Software Design\n5\nThings Change!\n\u2022 Users\u2019 needs and expectations change\n\u2022 Use reveals limitations and flaws\n\u2022 Desire for increased convenience, functionality\n\u2022 Desire for increased performance\n\u2022 Environment changes\n\u2022 Hardware, OS, software packages (\u201csoftware rot\u201d)\n\u2022 Need to interact with clients, parent org., etc.\n\u2022 Law and regulations change\n\u2022 Ways of doing business\n\u2022 Style, \u201ccool\u201d factor\n", "page": 5, "type": "text", "section": "Page 5"}
{"text": "Chapter 1: Introduction to Software Design\n6\nThe Software Life Cycle\n\u2022 Software goes through stages as it moves from initial \nconcept to finished product\n\u2022 The sequence of stages is called a life cycle\n\u2022 Must design and document software:\n\u2022 In an organized way for:\n\u2022 Understanding and ...\n\u2022 Maintenance (change) after the initial release\n\u2022 The maintainer is not necessarily the author!\n\u2022 ... and even authors forget\n\u2022 ... and no one can keep all details in mind at once\n", "page": 6, "type": "text", "section": "Page 6"}
{"text": "Chapter 1: Introduction to Software Design\n7\nSoftware Life Cycle Models:\nThe Waterfall Model\n\u2022 Simplest way to organizing activities in stages\n\u2022 Activities are:\n\u2022 Performed in sequence\n\u2022 Result of one flows (falls) into the next\n\u2022 The Waterfall Model is simple ... but unworkable\n\u2022 Fundamental flaw: Assumption that each stage can \nand must be completed before the next one occurs\n\u2022 Example: User may need to see finished product to \nexpress true requirements!\n", "page": 7, "type": "text", "section": "Page 7"}
{"text": "Chapter 1: Introduction to Software Design\n8\nWaterfall Model\n", "page": 8, "type": "text", "section": "Page 8"}
{"text": "Chapter 1: Introduction to Software Design\n9\nWaterfall Model (2)\n", "page": 9, "type": "text", "section": "Page 9"}
{"text": "Chapter 1: Introduction to Software Design\n10\nOther Software Life Cycle Models\n\u2022 Common theme among models: stages or cycles\n\u2022 Unified Model:\n\u2022 Cycles are called phases and iterations\n\u2022 Activities are called workflows\n\u2022 The four phases of the Unified Model:\n\u2022 Inception\n\u2022 Elaboration\n\u2022 Construction\n\u2022 Transition\n", "page": 10, "type": "text", "section": "Page 10"}
{"text": "Chapter 1: Introduction to Software Design\n11\nOther Software Life Cycle Models (2)\n", "page": 11, "type": "text", "section": "Page 11"}
{"text": "Chapter 1: Introduction to Software Design\n12\nSoftware Life Cycle Activities\nActivities essential for successful development:\n\u2022 Requirements specification\n\u2022 Architectural, component, & detailed designs\n\u2022 Implementation\n\u2022 Unit, integration, and acceptance testing\n\u2022 Installation and maintenance\n", "page": 12, "type": "text", "section": "Page 12"}
{"text": "Chapter 1: Introduction to Software Design\n13\nSoftware Life Cycle Activities Defined\n", "page": 13, "type": "text", "section": "Page 13"}
{"text": "Chapter 1: Introduction to Software Design\n14\nSoftware Life Cycle Activities (more)\n\u2022 Requirements Specification\n\u2022 System analyst works with users to clarify the detailed \nsystem requirements\n\u2022 Questions include format of input data, desired form \nof any output screens, and data validation\n\u2022 Analysis\n\u2022 Make sure you completely understand the problem\nbefore starting the design or program a solution\n\u2022 Evaluate different approaches to the design\n", "page": 14, "type": "text", "section": "Page 14"}
{"text": "Chapter 1: Introduction to Software Design\n15\nSoftware Life Cycle Activities (continued)\n\u2022 Design\n\u2022 Top-down: break system into smaller subsystems\n\u2022 Object-oriented: identify objects and their interactions\n\u2022 UML diagrams: tool to show interactions between:\n\u2022 Classes (inside the system)\n\u2022 Classes and external entities\n", "page": 15, "type": "text", "section": "Page 15"}
{"text": "Chapter 1: Introduction to Software Design\n16\nExample of Top-Down: Stepwise Refinement\n", "page": 16, "type": "text", "section": "Page 16"}
{"text": "Chapter 1: Introduction to Software Design\n17\nExample of Object-Oriented: Class Diagram\n", "page": 17, "type": "text", "section": "Page 17"}
{"text": "Chapter 1: Introduction to Software Design\n18\nUsing Abstraction to Manage Complexity\n\u2022 An abstraction is a model of a physical entity or activity\n\u2022 Models include relevant facts and details\n\u2022 Models exclude matters irrelevant to system/task\n\u2022 Abstraction helps programmers:\n\u2022 Complex issues handled in manageable pieces\n\u2022 Procedural abstraction: distinguishes ...\n\u2022 What to achieve (by a procedure) ...\n\u2022 From how to achieve it (implementation)\n\u2022 Data abstraction: distinguishes ...\n\u2022 Data objects for a problem and their operations ...\n\u2022 From their representation in memory\n", "page": 18, "type": "text", "section": "Page 18"}
{"text": "Chapter 1: Introduction to Software Design\n19\nUsing Abstraction to Manage Complexity (2)\n\u2022 If another class uses an object only through its methods, \nthe other class will not be affected if the data \nrepresentation changes\n\u2022 Information hiding: Concealing the details of a class \nimplementation from users of the class\n\u2022 Enforces the discipline of data abstraction\n", "page": 19, "type": "text", "section": "Page 19"}
{"text": "Chapter 1: Introduction to Software Design\n20\nAbstract Data Types, Interfaces, and\nPre- and Post-conditions\n\u2022 A major goal of software engineering: write reusable code\n\u2022 Abstract data type (ADT): data + methods\n\u2022 A Java interface is a way to specify an ADT\n\u2022 Names, parameters, return types of methods\n\u2022 No indication of how achieved (procedural abstraction)\n\u2022 No representation (data abstraction)\n\u2022 A class may implement an interface\n\u2022 Must provide bodies for all methods of the interface\n", "page": 20, "type": "text", "section": "Page 20"}
{"text": "Chapter 1: Introduction to Software Design\n21\nAbstract Data Types, Interfaces, and\nPre- and Postconditions (2)\n", "page": 21, "type": "text", "section": "Page 21"}
{"text": "Chapter 1: Introduction to Software Design\n22\nAbstract Data Types, Interfaces, and Pre-\nand Postconditions (continued)\n\u2022 You cannot instantiate (new) an interface\n\u2022 But you can:\n\u2022 Declare a variable that has an interface type\n\u2022 Use it to reference an actual object, whose class \nimplements the interface\n\u2022 A Java interface is a contract between\n\u2022 The interface designer and ...\n\u2022 The coder of a class that implements the interface\n\u2022 Precondition: any assumption/constraint on the method \ndata before the method begins execution\n\u2022 Postcondition: describes result of executing the method\n", "page": 22, "type": "text", "section": "Page 22"}
{"text": "Chapter 1: Introduction to Software Design\n23\nRequirements Analysis:\nUse Cases, and Sequence Diagrams\n\u2022 Analysis first step: study input and output requirements:\n\u2022 Make sure they are understood and make sense\n\u2022 Use case:\n\u2022 User actions and system responses for a sub-problem\n\u2022 In the order that they are likely to occur\n\u2022 Sequence diagram:\n\u2022 Shows objects involved across the horizontal axis\n\u2022 Shows time along the vertical axis\n\u2022 See page 26 for an example; shows:\n\u2022 User, PDApplication, PhoneDirectory, BufferedReader, \nPDUserInterface object + a number of method calls\n", "page": 23, "type": "text", "section": "Page 23"}
{"text": "Chapter 1: Introduction to Software Design\n24\nDesign of an Array-Based Phone Directory\n\u2022 Case study shows:\n\u2022 Design\n\u2022 Implementation\n\u2022 Testing of a software-based phone directory\n\u2022 In UML class diagrams:\n+ sign next to a method/attribute means it is public\n- sign next to a method/attribute means it is private\n", "page": 24, "type": "text", "section": "Page 24"}
{"text": "Chapter 1: Introduction to Software Design\n25\nDesign of Array-Based Phone Directory\nClasses/interfaces to design include:\n\u2022 PDUserInterface: interface; later we consider:\n\u2022 Console (command line) UI class\n\u2022 Graphical (JOptionPane) UI class\n\u2022 PDApplication: main / driving class\n\u2022 PhoneDirectory: interface\n\u2022 ArrayBasedPD: class implementing PhoneDirectory\n\u2022 DirectoryEntry: class, for one item in the directory\n", "page": 25, "type": "text", "section": "Page 25"}
{"text": "Chapter 1: Introduction to Software Design\n26\nDesign of Array-Based Phone Directory (2)\n", "page": 26, "type": "text", "section": "Page 26"}
{"text": "Chapter 1: Introduction to Software Design\n27\nDesign of Array-Based Phone Directory (3)\n", "page": 27, "type": "text", "section": "Page 27"}
{"text": "Chapter 1: Introduction to Software Design\n28\nDesign of DirectoryEntry\n\u2022 Simple class, similar to Person in Java review:\n\u2022 Two private fields, for name and number\n\u2022 Two-argument constructor\n\u2022 Get methods for both fields\n\u2022 Set method for number (only)\n", "page": 28, "type": "text", "section": "Page 28"}
{"text": "Chapter 1: Introduction to Software Design\n29\nDesign of Array-Based Phone Directory (4)\n", "page": 29, "type": "text", "section": "Page 29"}
{"text": "Chapter 1: Introduction to Software Design\n30\nThe PhoneDirectory Interface\n/**\n* The interface for the telephone directory.\n* @author Koffman & Wolfgang\n*/\npublic interface PhoneDirectory {\n...\n}\n\u2022 Shows syntax of an interface\n\u2022 Shows a javadoc comment and the @author tag\n", "page": 30, "type": "text", "section": "Page 30"}
{"text": "Chapter 1: Introduction to Software Design\n31\nPhoneDirectory.loadData\n/** Load the data file containing the\n*  directory, or establish a connection with\n*  the data source.\n*  @param sourceName The name of the file\n*    (data source) with the phone directory\n*    entries\n*/\nvoid loadData (String sourceName);\n\u2022 Shows syntax of method in an interface (note ;)\n\u2022 Shows a javadoc comment with the @param tag\n\u2022 Since returns void, no @return tag\n", "page": 31, "type": "text", "section": "Page 31"}
{"text": "Chapter 1: Introduction to Software Design\n32\nPhoneDirectory.lookupEntry\n/** Look up an entry.\n* @param name The name of the person\n*    to look up\n* @return The number, or null if name\n*    is not in the directory\n*/\nString lookupEntry (String name);\n\u2022 Shows a javadoc comment with the @return tag\n\u2022 I prefer a space before the ( in a declaration (not a call)\n", "page": 32, "type": "text", "section": "Page 32"}
{"text": "Chapter 1: Introduction to Software Design\n33\nPhoneDirectory.addOrChangeEntry\n/** Add an entry or change an existing entry.\n* @param name The name of the person being\n*    added or changed\n* @param number The new number to be assigned\n* @return The old number or, if a new entry,\n*    null\n*/\nString addOrChangeEntry (String name,\nString number);\n\u2022 Shows a javadoc comment with two @param tags\n", "page": 33, "type": "text", "section": "Page 33"}
{"text": "Chapter 1: Introduction to Software Design\n34\nPhoneDirectory.removeEntry\n/** Remove an entry from the directory.\n* @param name The name of the person to be\n*    removed\n* @return The current number. If not in\n*    directory, return null\n*/\nString removeEntry (String name);\n", "page": 34, "type": "text", "section": "Page 34"}
{"text": "Chapter 1: Introduction to Software Design\n35\nPhoneDirectory.save\n/** Method to save the directory.\n* pre:  The directory is loaded with data.\n* post: Contents of directory written back to\n*   the file in the form of name-number pairs\n*   on adjacent lines;\n*   modified is reset to false.\n*/\nvoid save ();\n\u2022 Illustrates pre/post conditions\n", "page": 35, "type": "text", "section": "Page 35"}
{"text": "Chapter 1: Introduction to Software Design\n36\nDesign of Array-Based Phone Directory (5)\n", "page": 36, "type": "text", "section": "Page 36"}
{"text": "Chapter 1: Introduction to Software Design\n37\nDesign of ArrayBasedPD.loadData\nInput: a file name; Effect: read initial directory from the file\n1. Create a BufferedReader for the input\n2. Read the first name\n3. while the name is not null\n4.\nRead the number\n5.\nAdd a new entry using method add\n6.\nRead the next name\n", "page": 37, "type": "text", "section": "Page 37"}
{"text": "Chapter 1: Introduction to Software Design\n38\nDesign of \nArrayBasedPD.addOrChangeEntry\nInput: name and number; Effect: change number of existing \nentry, or make new entry if there was none\n1. Call method find to see if the name is in the directory\n2.\nif the name is in the directory\n3.\nchange number with DirectoryEntry.setNumber\n4.\nReturn the previous value of the number\nelse\n5.\nAdd a new entry using method add\n6.\nReturn null\n", "page": 38, "type": "text", "section": "Page 38"}
{"text": "Chapter 1: Introduction to Software Design\n39\nDesign of Array-Based Phone Directory (6)\n\u2022 Remaining method designs proceed along the same \nlines\n\u2022 The class diagram changes, showing private fields and \nmethods added ....\n", "page": 39, "type": "text", "section": "Page 39"}
{"text": "Chapter 1: Introduction to Software Design\n40\nDesign of Array-Based Phone Directory (7)\n", "page": 40, "type": "text", "section": "Page 40"}
{"text": "Chapter 1: Introduction to Software Design\n41\nImplementing and Testing the Array-Based \nPhone Directory: ArrayBasedPD.java\nimport java.io.*;\n/** This is an implementation of the\n*  PhoneDirectory interface that uses an\n*  array to store the data.\n*  @author Koffman & Wolfgang\n*/\npublic class ArrayBasedPD\nimplements PhoneDirectory {\n...\n}   // note: import, javadoc, implements\n", "page": 41, "type": "text", "section": "Page 41"}
{"text": "Chapter 1: Introduction to Software Design\n42\nArrayBasedPD Data Fields (1)\n// Data Fields       (with javadoc comments)\n/** The initial capacity of the array */\nprivate static final int INITIAL_CAPACITY = 100;\n/** The current capacity of the array */\nprivate int capacity = INITIAL_CAPACITY;\n/** The current size of the array (number of\ndirectory entries) */\nprivate int size = 0;\n", "page": 42, "type": "text", "section": "Page 42"}
{"text": "Chapter 1: Introduction to Software Design\n43\nArrayBasedPD Data Fields (2)\n/** The array to contain the directory data */\nprivate DirectoryEntry[] theDirectory =\nnew DirectoryEntry[capacity];\n/** The name of the data file that contains the\ndirectory data */\nprivate String sourceName = null;\n/** Boolean flag indicates if the directory was\nmodified since it was loaded or saved. */\nprivate boolean modified = false;\n", "page": 43, "type": "text", "section": "Page 43"}
{"text": "Chapter 1: Introduction to Software Design\n44\nArrayBasedPD.loadData\npublic void loadData (String sourceName) {\n// Remember the source name.\nthis.sourceName = sourceName;\ntry {  ...\n} catch (FileNotFoundException ex) {\n// Do nothing \u2014 no data to load.\nreturn;\n} catch (IOException ex) {\nSystem.err.println(\u201cDirectory load failed.\");\nex.printStackTrace();\nSystem.exit(1);\n}\n}\n", "page": 44, "type": "text", "section": "Page 44"}
{"text": "Chapter 1: Introduction to Software Design\n45\nArrayBasedPD.loadData (2): Inside try\nBufferedReader in = new BufferedReader(\nnew FileReader(sourceName));\nwhile (true) {\nString name, number;\n// read name and number from succeeding lines\nif ((name   = in.readLine()) == null) break;\nif ((number = in.readLine()) == null) break;\n// insert entry (if got both name and number)\nadd(name, number);\n}\nin.close();   // should always close input\n\u2022 Slightly different loop approach from the text\n\u2022 Same assign-in-if-condition \u201chack\u201d\n", "page": 45, "type": "text", "section": "Page 45"}
{"text": "Chapter 1: Introduction to Software Design\n46\nArrayBasedPD.loadData (3): alternate\nboolean more = true;\nwhile (more) {\nmore = false;\nString name = in.readLine();\nif (name != null) {\nString number = in.readLine();\nif (number != null) {\nadd(name, number);\nmore = true;\n}\n}\n}\n\u2022 Nested if statements not as pleasant (what if 7 inputs?)\n\u2022 Control variables tend to be harder to understand/get right\n", "page": 46, "type": "text", "section": "Page 46"}
{"text": "Chapter 1: Introduction to Software Design\n47\nArrayBasedPD.addOrChangeEntry\npublic String addOrChangeEntry (String name,\nString number) {\nString oldNumber = null;\nint index = find(name);\nif (index > -1) {\noldNumber = theDirectory[index].getNumber();\ntheDirectory[index].setNumber(number);\n}\nelse {\nadd(name, number);\n}\nmodified = true;\nreturn oldNumber;\n}\n", "page": 47, "type": "text", "section": "Page 47"}
{"text": "Chapter 1: Introduction to Software Design\n48\nArrayBasedPD.save\npublic void save() {\nif (!modified) return; // save not needed\ntry {\n// Create PrintWriter for the file.\nPrintWriter out = new PrintWriter(\nnew FileWriter(sourceName));\n...\n} catch (Exception ex) {\nSystem.err.println(\u201cDirectory save failed\");\nex.printStackTrace();\nSystem.exit(1);\n}\n}\n", "page": 48, "type": "text", "section": "Page 48"}
{"text": "Chapter 1: Introduction to Software Design\n49\nArrayBasedPD.save (2)\n// Write each directory entry to the file.\nfor (int i = 0; i < size; i++) {\n// Write the name.\nout.println(theDirectory[i].getName());\n// Write the number.\nout.println(theDirectory[i].getNumber());\n}\n// Close the file.\nout.close();\nmodified = false;\n", "page": 49, "type": "text", "section": "Page 49"}
{"text": "Chapter 1: Introduction to Software Design\n50\nImplementing and Testing the Array-Based \nPhone Directory\n", "page": 50, "type": "text", "section": "Page 50"}
{"text": "Chapter 1: Introduction to Software Design\n51\nArrayBasedPD.find\nprivate int find (String name) {\nfor (int i = 0; i < size; i++) {\nif (theDirectory[i].getName().equals(name)) {\nreturn i;\n}\n}\nreturn -1; // Name not found.\n}\n", "page": 51, "type": "text", "section": "Page 51"}
{"text": "Chapter 1: Introduction to Software Design\n52\nArrayBasedPD.add\nprivate void add (String name, String number) {\nif (size >= capacity) {\nreallocate();\n}\ntheDirectory[size++] =\nnew DirectoryEntry(name, number);\n}\n\u2022 Differs from text in use of ++\n\u2022 Note that size means number of names stored,\n\u2022 while capacity means the number the array can hold\n", "page": 52, "type": "text", "section": "Page 52"}
{"text": "Chapter 1: Introduction to Software Design\n53\nArrayBasedPD.realloc\nprivate void reallocate () {\ncapacity *= 2;\nDirectoryEntry[] newDirectory =\nnew DirectoryEntry[capacity];\nSystem.arraycopy(theDirectory, 0,\nnewDirectory, 0,\ntheDirectory.length);\ntheDirectory = newDirectory;\n}\nArguments to arraycopy are:\n\u2022 fromDir, fromIndex\n\u2022 toDir, toIndex\n\u2022 number of elements to copy\n", "page": 53, "type": "text", "section": "Page 53"}
{"text": "Chapter 1: Introduction to Software Design\n54\nTesting ArrayBasedPD\n\u2022 Empty data file\n\u2022 Data file with only one name-number pair\n\u2022 Data file with odd number of lines\n\u2022 Data file with more pairs than initial array size\n\u2022 Retrieve names not in directory as well as ones that are\n\u2022 After a change, verify the new information\n\u2022 Check that after changes, the changes, plus all new \ninformation, are in the newly written file\n\u2022 Note: This code does not check for empty strings!\n", "page": 54, "type": "text", "section": "Page 54"}
{"text": "Chapter 1: Introduction to Software Design\n55\nImplementing PDUserInterface\n\u2022 Text offers two classes that implement the UI interface:\n\u2022 PDGUI: Uses JOptionPane for graphical UI\n\u2022 PDConsoleUI: Uses console stream I/O \n(System.in and System.out)\n\u2022 Text gives good recipes here that you can use as \nmodels\n\u2022 We will not cover them in detail here\n", "page": 55, "type": "text", "section": "Page 55"}
