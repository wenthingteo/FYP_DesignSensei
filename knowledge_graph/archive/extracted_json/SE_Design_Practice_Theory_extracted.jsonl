{"text": "Software\nEngineering\nDesign\nTheory and Practice\n", "page": 1, "type": "text", "section": "Page 1"}
{"text": "Titles in the \nAuerbach Series on Applied Software Engineering\nPhillip A. Laplante, Pennsylvania State University, Series Editor\nSoftware Engineering Design: Theory and Practice\nCarlos E. Otero  \n978-1-4398-5168-5\nEthics in IT Outsourcing\nTandy Gold \n978-1-4398-5062-6\nThe ScrumMaster Study Guide \nJames Schiel\n978-1-4398-5991-9\nAntipatterns: Managing Software Organizations and People,  \nSecond Edition\nColin J. Neill, Philip A. Laplante, and Joanna F\n. DeFranco\n978-1-4398-6186-8\nEnterprise-Scale Agile Software Development\nJames Schiel\n978-1-4398-0321-9\nRequirements Engineering for Software and Systems\nPhillip A. Laplante\n978-1-4200-6467-4 \nBuilding Software: A Practioner\u2019s Guide\nNikhilesh Krishnamurthy and Amitabh Saran\n978-0-8493-7303-9\nGlobal Software Development Handbook\nRaghvinder Sangwan, Matthew Bass, Neel Mullick, Daniel J. Paulish, \nand Juergen Kazmeier\n978-0-8493-9384-6\nSoftware Engineering Quality Practices\nRonald Kirk Kandt\n978-0-8493-4633-0\n", "page": 2, "type": "text", "section": "Page 2"}
{"text": "Software\nEngineering\nDesign\nTheory and Practice\nCarlos E. Otero\n", "page": 3, "type": "text", "section": "Page 3"}
{"text": "CRC Press\nTaylor & Francis Group\n6000 Broken Sound Parkway NW, Suite 300\nBoca Raton, FL 33487-2742\n\u00a9 2012 by Taylor & Francis Group, LLC\nCRC Press is an imprint of Taylor & Francis Group, an Informa business\nNo claim to original U.S. Government works\nVersion Date: 20120511\nInternational Standard Book Number-13: 978-1-4665-6586-9 (eBook - PDF)\nThis book contains information obtained from authentic and highly regarded sources. Reasonable efforts have been \nmade to publish reliable data and information, but the author and publisher cannot assume responsibility for the valid-\nity of all materials or the consequences of their use. The authors and publishers have attempted to trace the copyright \nholders of all material reproduced in this publication and apologize to copyright holders if permission to publish in this \nform has not been obtained. If any copyright material has not been acknowledged please write and let us know so we may \nrectify in any future reprint.\nExcept as permitted under U.S. Copyright Law, no part of this book may be reprinted, reproduced, transmitted, or uti-\nlized in any form by any electronic, mechanical, or other means, now known or hereafter invented, including photocopy-\ning, microfilming, and recording, or in any information storage or retrieval system, without written permission from the \npublishers.\nFor permission to photocopy or use material electronically from this work, please access www.copyright.com (http://\nwww.copyright.com/) or contact the Copyright Clearance Center, Inc. (CCC), 222 Rosewood Drive, Danvers, MA 01923, \n978-750-8400. CCC is a not-for-profit organization that provides licenses and registration for a variety of users. For \norganizations that have been granted a photocopy license by the CCC, a separate system of payment has been arranged.\nTrademark Notice: Product or corporate names may be trademarks or registered trademarks, and are used only for \nidentification and explanation without intent to infringe.\nVisit the Taylor & Francis Web site at\nhttp://www.taylorandfrancis.com\nand the CRC Press Web site at\nhttp://www.crcpress.com\n", "page": 4, "type": "text", "section": "Page 4"}
{"text": "Tis book is dedicated to my wife, Kelly, \nchildren\u00a0Allison, Amanda, Michael, and Ashley, \nand\u00a0parents\u00a0Angel L. Otero and Lydia E. Rivera.\n", "page": 5, "type": "text", "section": "Page 5"}
{"text": "vii\nContents\nPreface .......................................................................................................................... xvii\nAcknowledgments .........................................................................................................xix\nAbout the Author \n...........................................................................................................xxi\nChapter 1\t Introduction to Software Engineering Design \n...........................................1\nChapter Objectives .................................................................................................. 1\nConceptual Overview ............................................................................................. 1\nEngineering Design \n................................................................................................. 2\nEngineering Problem Solving \n................................................................................ 3\nInitial State \n........................................................................................................... 4\nOperational State ................................................................................................ 4\nTinking about the Problem ........................................................................ 5\nProblem Solution............................................................................................ 6\nGoal State ............................................................................................................. 6\nSofware Engineering Design ................................................................................ 9\nWhy Study Sofware Engineering Design? ........................................................ 10\nReasons for Studying Sofware Design in Product Development ............. 10\nReasons for Studying Sofware Design in Project Management ............... 11\nSofware Design Challenges \n................................................................................. 11\nDesign Challenge 1: Requirements Volatility ............................................... 12\nDesign Challenge 2: Process ........................................................................... 12\nDesign Challenge 3: Technology .................................................................... 12\nDesign Challenge 4: Ethical and Professional Practices ............................. 13\nDesign Challenge 5: Managing Design Infuences ...................................... 13\nStakeholders \n.................................................................................................. 14\nDevelopment Organization\u2019s Structure .................................................... 14\nContext of Sofware Design ................................................................................. 15\nSofware Design Process \n....................................................................................... 17\nSofware Architecture ...................................................................................... 18\nDetailed Design \n................................................................................................. 19\nInterface Design ........................................................................................... 19\nComponent Design \n......................................................................................20\nConstruction Design ........................................................................................20\nHuman\u2013Computer Interface Design \n............................................................. 21\nSofware Design Documentation ................................................................... 21\nSofware Design Management ........................................................................ 21\n", "page": 7, "type": "text", "section": "Page 7"}
{"text": "viii\u2002 \u2022\u2002 Contents\nRoles of the Sofware Designer ............................................................................ 22\nSystems Engineer .............................................................................................. 23\nSofware Architect ............................................................................................ 23\nComponent Designer ....................................................................................... 23\nSofware Design Fundamentals \n........................................................................... 24\nGeneral Sofware Design Principles .............................................................. 24\nModularization ............................................................................................ 25\nAbstraction ................................................................................................... 25\nEncapsulation ............................................................................................... 26\nCoupling \n........................................................................................................ 27\nCohesion \n........................................................................................................ 28\nSeparation of Interface and Implementation ........................................... 29\nCompleteness and Sufciency \n.................................................................... 30\nPractical Sofware Design Considerations \n.................................................... 30\nDesign for Minimizing Complexity \n.......................................................... 31\nDesign for Change ....................................................................................... 31\nSofware Design Strategies .............................................................................. 31\nStructured Design \n........................................................................................ 31\nObject-Oriented Design .............................................................................. 32\nChapter Summary ................................................................................................. 32\nReview Questions .................................................................................................. 33\nReferences ...............................................................................................................34\nChapter 2\t Software Design with Unified\u00a0Modeling Language ................................35\nChapter Objectives ................................................................................................ 35\nConceptual Overview ........................................................................................... 35\nWhat Is UML? \n........................................................................................................ 36\nWhy Study UML? .................................................................................................. 37\nTe UML\u2019s Fundamentals .................................................................................... 37\nStructural Modeling \n..............................................................................................40\nComponent Diagrams ..........................................................................................40\nLogical versus Physical Components \n.............................................................42\nClass Diagrams ...................................................................................................... 43\nClasses ................................................................................................................ 43\nName Compartment ...................................................................................44\nAttribute Compartment \n..............................................................................44\nOperation Compartment \n............................................................................ 45\nRelationships .....................................................................................................46\nDependency .................................................................................................. 47\nAssociation \n.................................................................................................... 47\nAggregation ..................................................................................................48\nComposition .................................................................................................48\n", "page": 8, "type": "text", "section": "Page 8"}
{"text": "Contents\u2002 \u2022\u2002 ix\nGeneralization .............................................................................................. 49\nRealization .................................................................................................... 50\nDeployment Diagrams \n.......................................................................................... 53\nBehavioral Modeling \n............................................................................................. 55\nUse Case Diagrams ............................................................................................... 55\nInteraction Diagrams \n............................................................................................ 57\nCommunication Diagrams ............................................................................. 58\nSequence Diagrams .......................................................................................... 59\nConcurrency in Interaction Diagrams .......................................................... 59\nChapter Summary ................................................................................................. 63\nReview Questions .................................................................................................. 63\nChapter Exercises ..................................................................................................64\nReferences ............................................................................................................... 65\nChapter 3\t Principles of Software Architecture \n..........................................................67\nChapter Objectives ................................................................................................ 67\nConceptual Overview ........................................................................................... 67\nWhat Is Sofware Architecture? ..........................................................................68\nWhy Study Sofware Architecture?..................................................................... 70\nKey Tasks in Architectural Design ..................................................................... 70\nIdentifying Stakeholders\u2019 Concerns \n............................................................... 71\nIdentifying Appropriate Architectural Views .............................................. 71\nIdentifying Architectural Styles and Patterns .............................................. 71\nIdentifying System Interfaces ......................................................................... 72\nIdentifying Impact of Architectural Decisions in Organization ............... 72\nImpact on Customer Base \n........................................................................... 73\nImpact on Budget and Schedule ................................................................ 73\nImpact from Resource Availability ............................................................74\nIdentifying the System\u2019s Major Components and Interfaces.......................74\nEvaluating and Validating the Architecture \n..................................................74\nIntroducing Policies for Design Synchronicity ............................................ 75\nProblem Solving in Sofware Architecture ........................................................ 76\nInputs \n.................................................................................................................. 77\nConstraints ........................................................................................................ 77\nOutputs............................................................................................................... 77\nSofware Architecture Process............................................................................. 78\nUnderstand and Evaluate Requirements \n............................................................ 79\nElicitation \n........................................................................................................... 79\nRequirement Sources \n................................................................................... 79\nElicitation Techniques ................................................................................. 81\nAnalysis .............................................................................................................. 82\n", "page": 9, "type": "text", "section": "Page 9"}
{"text": "x\u2002 \u2022\u2002 Contents\nSpecifcation and Validation ...........................................................................84\nSpecifc \n........................................................................................................... 85\nCorrect \n........................................................................................................... 86\nComplete ....................................................................................................... 86\nConsistent ..................................................................................................... 87\nAttainable \n...................................................................................................... 87\nVerifable ....................................................................................................... 88\nDesigning the Architecture \n.................................................................................. 88\nTe 4 + 1 View Model ...................................................................................... 89\nUser View ...................................................................................................... 89\nProcess View \n.................................................................................................90\nPhysical View \n................................................................................................90\nDevelopment View \n....................................................................................... 91\nLogical View ................................................................................................. 91\nComponents and Connectors ......................................................................... 92\nDesigning Logical Architectural Elements Using Data Flows \n................... 92\nDesigning Logical Architectural Elements Using Styles and Patterns ..... 93\nDesigning the Process Architecture .............................................................. 93\nProcesses ....................................................................................................... 93\nTreads .......................................................................................................... 94\nEvaluating the Architecture \n............................................................................... 103\nChapter Summary ............................................................................................... 104\nReview Questions ................................................................................................ 105\nChapter Exercises ................................................................................................ 106\nReferences ............................................................................................................. 106\nChapter 4\t Patterns and Styles in Software Architecture ........................................ 107\nChapter Objectives .............................................................................................. 107\nConceptual Overview ......................................................................................... 107\nArchitectural Styles and Patterns...................................................................... 108\nHistory of Architectural Styles and Patterns \n.............................................. 108\nArchitectural Pattern Classifcation ............................................................ 109\nData-Centered Systems \n........................................................................................111\nBlackboard Pattern ..........................................................................................111\nData Flow Systems \n................................................................................................116\nPipe and Filter Pattern ....................................................................................116\nDistributed Systems ............................................................................................120\nClient\u2013Server Pattern .....................................................................................120\nBroker Pattern ................................................................................................. 122\nInteractive Systems \n.............................................................................................. 127\nModel\u2013View\u2013Controller Pattern \n.................................................................. 127\n", "page": 10, "type": "text", "section": "Page 10"}
{"text": "Contents\u2002 \u2022\u2002 xi\nHierarchical Systems \n........................................................................................... 131\nMain Program and Subroutine \n..................................................................... 131\nLayered Pattern ............................................................................................... 133\nChapter Summary ............................................................................................... 136\nReview Questions ................................................................................................ 136\nChapter Exercises ................................................................................................ 137\nReferences ............................................................................................................. 137\nChapter 5\t Principles of Detailed Design \n.................................................................. 139\nChapter Objectives .............................................................................................. 139\nConceptual Overview ......................................................................................... 139\nWhat Is Detailed Design? \n................................................................................... 140\nKey Tasks in Detailed Design ............................................................................ 142\nDetailed Design Process ..................................................................................... 142\nUnderstanding the Architecture and Requirements \n...................................... 143\nCreating Detailed Designs ................................................................................. 144\nInterface Design .............................................................................................. 144\nExternal Interface Design ......................................................................... 144\nInternal Interface Design \n.......................................................................... 145\nGraphical User Interface Design ............................................................. 145\nDesigning Internal Structure of Components \n............................................ 145\nClasses ......................................................................................................... 146\nInterfaces, Types, Subtypes, Dynamic Binding, and Polymorphism ... 147\nObjects ......................................................................................................... 148\nDesign Principles for Internal Component Design ................................... 149\nOpen\u2013Closed Principle ............................................................................. 149\nLiskov Substitution Principle ................................................................... 156\nInterface Segregation Principle ................................................................ 157\nProgramming Styles in Detailed Design \n..................................................... 159\nFunction Names \n......................................................................................... 160\nVariable Names .......................................................................................... 162\nModeling Internal Behavior of Components \n.............................................. 164\nDesign Components Using Design Patterns .............................................. 166\nArchitectural versus Design Patterns ..................................................... 167\nClassifcation of Design Patterns ............................................................. 167\nDocumenting Design Patterns \n................................................................. 168\nDocument the Sofware Design ........................................................................ 169\nInterface Control Document \n......................................................................... 171\nSofware Version Document ......................................................................... 172\nMonitor and Control Implementation ............................................................. 173\nChapter Summary ............................................................................................... 173\nReview Questions .................................................................................................174\n", "page": 11, "type": "text", "section": "Page 11"}
{"text": "xii\u2002 \u2022\u2002 Contents\nChapter Exercises ................................................................................................ 175\nReferences ............................................................................................................. 175\nChapter 6\t Creational Design Patterns in Detailed Design ..................................... 177\nChapter Objectives .............................................................................................. 177\nConceptual Overview ......................................................................................... 177\nCreational Design Patterns ................................................................................ 178\nAbstract Factory .................................................................................................. 178\nProblem ............................................................................................................ 179\nStructure .......................................................................................................... 179\nImplementation \n................................................................................................181\nBenefts ............................................................................................................. 188\nFactory Method ................................................................................................... 188\nProblem ............................................................................................................ 189\nStructure .......................................................................................................... 189\nImplementation \n............................................................................................... 191\nBenefts ............................................................................................................. 192\nBuilder \n................................................................................................................... 193\nProblem ............................................................................................................ 195\nStructure .......................................................................................................... 195\nImplementation \n............................................................................................... 197\nBenefts ............................................................................................................. 197\nPrototype .............................................................................................................. 201\nProblem ............................................................................................................ 201\nStructure ..........................................................................................................204\nImplementation \n...............................................................................................205\nBenefts .............................................................................................................207\nSingleton ...............................................................................................................207\nProblem ............................................................................................................208\nStructure ..........................................................................................................208\nImplementation \n...............................................................................................209\nBenefts ..............................................................................................................211\nChapter Summary ................................................................................................211\nReview Questions .................................................................................................211\nChapter Exercises ................................................................................................ 212\nReference \n................................................................................................................214\nChapter 7\t Structural and Behavioral\u00a0Patterns in Detailed Design \n........................ 215\nChapter Objectives .............................................................................................. 215\nConceptual Overview ......................................................................................... 215\nStructural Design Patterns \n..................................................................................216\n", "page": 12, "type": "text", "section": "Page 12"}
{"text": "Contents\u2002 \u2022\u2002 xiii\nAdapter...................................................................................................................216\nProblem ............................................................................................................ 217\nStructure .......................................................................................................... 219\nImplementation \n............................................................................................... 219\nBenefts ............................................................................................................. 221\nComposite \n.............................................................................................................223\nProblem ............................................................................................................224\nStructure ..........................................................................................................225\nImplementation \n...............................................................................................227\nBenefts ............................................................................................................. 231\nFacade \n.................................................................................................................... 232\nProblem ............................................................................................................234\nStructure .......................................................................................................... 235\nImplementation \n............................................................................................... 237\nBenefts .............................................................................................................238\nBehavioral Design Patterns \n................................................................................238\nIterator \n...................................................................................................................238\nProblem ............................................................................................................ 239\nStructure .......................................................................................................... 241\nImplementation \n...............................................................................................245\nBenefts ............................................................................................................. 251\nObserver \n................................................................................................................ 252\nProblem ............................................................................................................ 252\nStructure .......................................................................................................... 252\nImplementation \n...............................................................................................254\nBenefts .............................................................................................................254\nChapter Summary ...............................................................................................256\nReview Questions ................................................................................................256\nChapter Exercises ................................................................................................ 257\nReference \n...............................................................................................................258\nChapter 8\t Principles of Construction Design \n.......................................................... 259\nChapter Objectives .............................................................................................. 259\nConceptual Overview ......................................................................................... 259\nWhat Is Construction Design? .......................................................................... 259\nWhy Study Construction Design? ....................................................................260\nBehavioral Construction Design \n....................................................................... 261\nFlow-Based Designs \n........................................................................................ 261\nState-Based Designs \n........................................................................................262\nTable-Based Designs \n.......................................................................................264\nLimited-Entry Decision Table ..................................................................266\nExtended-Entry Decision Table ...............................................................268\n", "page": 13, "type": "text", "section": "Page 13"}
{"text": "xiv\u2002 \u2022\u2002 Contents\nMixed-Entry Decision Table .................................................................... 270\nTable-Based Construction ........................................................................ 270\nProgramming Design Language .................................................................. 271\nSofware Construction Using Styles ................................................................. 274\nFormatting Conventions ............................................................................... 275\nIndentation ................................................................................................. 276\nBrace Placement ......................................................................................... 278\nNaming Conventions ..................................................................................... 279\nDocumentation Conventions \n........................................................................282\nDocumenting Files.....................................................................................282\nDocumenting Functions ...........................................................................282\nMinimizing Complexity in Construction Design ..........................................283\nQuality Evaluation of Construction Design \n....................................................284\nPeer Reviews ....................................................................................................285\nUnit Testing .....................................................................................................286\nCyclomatic Complexity .................................................................................286\nChapter Summary ...............................................................................................290\nReview Questions ................................................................................................290\nChapter Exercises ................................................................................................ 291\nReferences .............................................................................................................292\nChapter 9\t Human\u2013Computer Interface Design ...................................................... 293\nJacob Somervell\nChapter Objectives .............................................................................................. 293\nConceptual Overview ......................................................................................... 293\nWhat Is Human\u2013Computer Interface Design? ...............................................294\nWhy Study Human\u2013Computer Interface Design? .........................................294\nGeneral HCI Design Principles .........................................................................297\nHuman\u2013Computer Interface Design Methods ...............................................299\nGetting Started \n................................................................................................299\nFidelity in Prototypes \n.....................................................................................300\nMetaphors ........................................................................................................ 301\nGestalt Principles ............................................................................................303\nReusing Earlier Designs \n.................................................................................305\nEvaluation of HCI Quality .................................................................................305\nUsability Testing .............................................................................................305\nAnalytic Testing \n..............................................................................................306\nEmpirical Testing \n............................................................................................307\nChapter Summary ...............................................................................................309\nReview Questions ................................................................................................309\nChapter Exercises ................................................................................................309\nReferences ..............................................................................................................310\n", "page": 14, "type": "text", "section": "Page 14"}
{"text": "Contents\u2002 \u2022\u2002 xv\nChapter 10\tSoftware Design Management, Leadership, and Ethics ........................ 311\nLuis Daniel Otero\nChapter Objectives ...............................................................................................311\nConceptual Overview ..........................................................................................311\nWhat Is Sofware Design Management? .......................................................... 312\nWhy Study Design Management? ..................................................................... 312\nTe Concept of Quality ...................................................................................... 312\nDesign Management Framework ...................................................................... 313\nPlanning Design Eforts ......................................................................................314\nScoping ............................................................................................................. 315\nWork Breakdown Structure ..................................................................... 315\nBudgeting .....................................................................................................316\nOrganizing \n........................................................................................................317\nLinear Responsibility Chart ......................................................................318\nScheduling with Gantt Charts and Network Diagrams \n........................318\nProbability of Time to Completion ......................................................... 322\nEstablish Change Control Policy \n..................................................................324\nImplementation Phase ........................................................................................ 325\nEarned Value Management ........................................................................... 326\nTermination Stage ............................................................................................... 329\nLeading the Design Efort .................................................................................. 329\nPersonality Traits and Leadership \n................................................................ 329\nPersonality Dimensions ................................................................................. 329\nTraits of Efective Leaders ............................................................................. 330\nEthical Leadership .......................................................................................... 330\nPower .................................................................................................................331\nKey Leadership Skills .......................................................................................... 332\nCommunication Skills ................................................................................... 332\nNetworking Skills ........................................................................................... 333\nMotivation Skills \n............................................................................................. 333\nNegotiation Skills............................................................................................ 334\nEthics in Sofware Design .................................................................................. 335\nPublic and Product Principles ...................................................................... 335\nJudgment Principle ......................................................................................... 336\nManagement Principle ................................................................................... 336\nChapter Summary ............................................................................................... 336\nReview Questions ................................................................................................ 338\nChapter Exercises ................................................................................................ 339\nReferences .............................................................................................................340\n", "page": 15, "type": "text", "section": "Page 15"}
{"text": "xvii\nTis book is the result of an efort that I began in 2010 at the University of Virginia\u2019s \nCollege at Wise to create a course in sofware engineering design consistent with the 2004 \nIEEE/ACM curriculum guidelines for undergraduate programs in sofware engineering \n(SE). In a broad context, the recommended topics for undergraduate SE programs include \ndesign concepts, design strategies, architectural design, detailed design, human\u2013computer \ninterface design, and design evaluation. As a former industry practitioner, I learned frst-\nhand the diference between hearing or \u201clearning\u201d about these topics and developing the \nnecessary skills to apply them in a way that adds value to some development team, pro-\ngram, project, or business. With that in mind, I set out to compile material that I could \nuse (from previous industry experience) to help students become profcient in design-\ning sofware-intensive systems. Troughout the process, many of the original examples \nconsidered dry or hard to follow by students were replaced with new problem domains \n(e.g.,\u00a0 gaming\u00ad\n systems) that helped students assimilate the concepts better. Because of \nthe \u201chands-on\u201d approach required to master these concepts, the teaching style evolved \nto emphasize both theory and practice. Te theory portion was used to present accept-\nable general design principles or a body of design principles to explain successful sofware \n\u00ad\nsystems\u2019 designs. Te practice portion provided the avenue for transforming design theory \ninto skills that can be employed directly to real-life industrial settings. Te knowledge \nand experience gained from these eforts have been captured in this textbook, which can \nbe useful for both industry practitioners and students in sofware engineering, computer \n\u00ad\nscience, and information technology programs.\nINTRODUCTION\nTis book provides an introduction to the essential concepts employed by sofware engi-\nneers who design large-scale, sofware-intensive systems in a professional environment. \nIt\u00a0bridges the gap between industry and academia by providing students with a comprehen-\nsive view of sofware design using industry-proven concepts for designing \u00ad\ncomplex sofware \nsystems. Its unique blend of theory and practice provides both students and industry prac-\ntitioners with key concepts that are immediately relevant to today\u2019s sofware designers. Te \nbook contains examples, review questions, and chapter exercises carefully selected to bring \nreal-world problems into a classroom environment. More importantly, it\u00a0incorporates an \nefective learn-by-doing approach that allows students to transform design theory into the \nskills required to design complex sofware systems. Te book starts by providing a general \noverview of sofware design, including the fundamentals of sofware design, the importance \nof studying sofware design, and diferent practical concepts used for designing sofware.\nPreface\n", "page": 17, "type": "text", "section": "Page 17"}
{"text": "xviii\u2002 \u2022\u2002 Preface\nAs part of the introductory material, the sofware engineering process is covered briefy \nto provide the context in which sofware design takes place and a formal top-down design \nprocess is presented. Te top-down approach consists of several design phases and activi-\nties that occur at varied levels of detail/abstraction, including the sofware architecture, \ndetailed design, and construction design. As part of the top-down approach, detailed \ncoverage of applied architectural, creational, structural, and behavioral design patterns is \nprovided and a collection of standards and guidelines for structuring high-quality code \nis presented. Te book also provides techniques for evaluating sofware design quality at \ndiferent stages and much needed coverage of management and engineering leadership \nfor sofware designers. Tis provides sofware engineers with the necessary management, \n\u00ad\nethical, and leadership knowledge required to build products for the public domain. Te \nbook also provides coverage of the sofware design document and other forms of documen-\ntation important during the design of sofware systems. Collectively, the book comprehen-\nsively introduces students and practitioners to sofware engineering design and provides \nthe knowledge required to emerge and succeed as tomorrow\u2019s professional design leaders.\nUSE AS A TEXTBOOK\nTe textbook provides a comprehensive (sophomore-level) introduction to required con-\ncepts in sofware design. When used as textbook, instructors are encouraged to visit the \ntextbook website to download slides, the solutions manual, and other exercises developed \nas part of the ongoing efort to improve education in sofware engineering design. Te \nmaterial presented in the book\u2019s 10 chapters can be easily extended to 16 weeks, espe-\ncially when covering the topics of design patterns. A recommended approach includes \nconducting microdesign reviews, where students (or student groups) design, implement, \nand present\u00ad\n their work regularly, while other students evaluate, critique, and provide \npeer-review comments. Because of the nature of the topics covered, students are expected \nto meet the following prerequisites:\n\u2022\t Introduction to Programming (with object-oriented language)\n\u2022\t Data Structures and Algorithms\n\u2022\t Introduction to Sofware Engineering\nUltimately, the most important feature of sofware designs is their applicability to build \nsofware; therefore, the course should require students to implement a large portion of \nthe designs created as part of the course. A recommended approach (when possible) is to \nadopt a unifed modeling language (UML) modeling tool capable of forward and reverse \nengineering and use the textbook as a guide for creating and assigning design problems \ncentered around the topics discussed throughout the book, since they are essential to all \nsofware engineering students from ABET-accredited programs.\n", "page": 18, "type": "text", "section": "Page 18"}
{"text": "xix\nMany people have contributed to this efort in one way or another. First, I would like to \nthank Dr. Jacob Somervell from the University of Virginia\u2019s College at Wise, and Dr.\u00a0Luis \nDaniel Otero from Florida Institute of Technology for providing the material for Chapters \n9 and 10, respectively. Your work made the overall product complete, and many \u00ad\nstudents \nand practitioners will beneft from your contributions. I also thank Dr. Ira Weissberger \nfrom Harris Corporation for his contribution on the section on sofware design docu-\nmentation in Chapter 5 and Stefan Joe-Yen from Northrop Grumman Corporation for his \ncontribution to the architectural patterns chapter. I would also like to thank the reviewers \nand staf at Taylor & Francis\u2014in particular John Wyzalek\u2014for their help throughout this \nlong process. Finally, and most importantly, I thank my wife, Kelly, and children Allison, \nAmanda, Michael, and Ashley, for their sacrifces, patience, and support.\nAcknowledgments\n", "page": 19, "type": "text", "section": "Page 19"}
{"text": "xxi\nCarlos E. Otero, PhD, is assistant professor in the College of Technology and Innovation \nat the University of South Florida Polytechnic (USFP). Prior to joining USFP, Dr. Otero \nworked as assistant professor of sofware engineering in the Department of Mathematics \nand Computer Science at the University of Virginia\u2019s College at Wise, where he created \nthe sofware engineering design course for Virginia\u2019s frst and (at the time of writing) only \nABET-accredited BS in sofware engineering.\nPrior to his academic career, Dr. Otero spent 11 years in the private industry, where \nhe worked as design and development engineer in a wide variety of military computer \n\u00ad\nsystems, including satellite communications systems, command and control systems, \nwireless security systems, and unmanned aerial vehicle systems. Currently, he continues \nto consult with industry in the areas of requirements engineering, sofware systems design \nand development, quality assurance, and mobile systems engineering.\nDr. Otero received his BS in computer science, MS in sofware engineering, MS in \u00ad\nsystems \nengineering, and PhD in computer engineering from Florida Institute of Technology in \nMelbourne. He has published over 25 technical publications in \u00ad\nscientifc peer-reviewed \njournals and conferences proceedings. He is a senior member of the IEEE, a\u00a0science \u00ad\nadvisor \nfor the National Aeronautics and Space Administration (NASA) DEVELOP program, an \nactive professional member of the Association for Computing Machinery (ACM), and a \nmember of several journal editorial boards in technology and engineering.\nAbout the Author\n", "page": 21, "type": "text", "section": "Page 21"}
{"text": "1\n1\nIntroduction to Software \nEngineering Design\nCHAPTER OBJECTIVES\n\u2022\t Understand sofware design from the engineering perspective\n\u2022\t Understand the importance of sofware design in developing com-\nplex products\n\u2022\t Understand the issues that make sofware design challenging\n\u2022\t Understand the sofware design process and diferentiate between \nits activities\n\u2022\t Become familiar with sofware design principles, considerations, and \nstrategies\nCONCEPTUAL OVERVIEW\nSofware design is an indispensable phase of the sofware engineering pro-\ncess for creating and evaluating sofware models that guide the construc-\ntion efort for developing high-quality sofware systems on time and within \nbudget. Conceptually, design is the process of transforming functional and \nnonfunctional requirements into models that describe the technical solution \nbefore construction begins. To achieve this, the concept of sofware design, \nits activities, and tasks must be well understood so that a problem-solving \nframework for designing quality into sofware products can be established. \nIn today\u2019s modern sofware systems, there are numerous design principles, \nprocesses, strategies, and other factors afecting how designers execute the \nsofware design phase. When equipped with the proper design foundation \nknowledge, an understanding of the designer\u2019s roles and responsibilities \n", "page": 23, "type": "text", "section": "Page 23"}
{"text": "2\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\ncan be acquired, allowing designers to become efective in designing large-scale sofware \nsystems under a wide variety of challenging conditions. Tis chapter presents the funda-\nmental concepts of sofware engineering design, within context, and provides the motiva-\ntion for the rest of the book.\nENGINEERING DESIGN\nDesign is an integral part of every engineering discipline. Airplanes, bridges, buildings, \nelectronic devices, cars, and many other products of similar complexity are all designed. \nIn civil engineering, designs are used to specify detailed plans for developing physical and \nnaturally built environments, such as bridges, roads, canals, dams, and buildings. In elec-\ntrical engineering, designs are used to capture, evaluate, and specify the detailed qualita-\ntive and quantitative description of solutions for telecommunication systems, electrical \nsystems, and electronic devices. In mechanical engineering, designs are used for analyzing, \nevaluating, and specifying technical features required to construct machines and tools, \nsuch as industrial equipment, heating and cooling systems, aircrafs, robots, and medical \ndevices. In all other engineering disciplines, design provides a systematic approach for \ncreating products that meet their intended functions and users\u2019 expectations. Formally, \nDym\u00a0and Little (2008, p. 6) defne engineering design as\nA systematic, intelligent process in which designers generate, evaluate and specify designs for \ndevices, systems or processes whose form(s) and function(s) achieve clients\u2019 objectives and \nusers\u2019 needs while satisfying a specifed set of constraints.\nDesign is a lengthy and complex process requiring signifcant investments in time and \nefort. So why conduct design in engineering disciplines? Tere are many possible answers \nto this question, stemming from simple common sense to more complicated ones involv-\ning professional, ethical, social, and legal implications. From the commonsense perspec-\ntive, products of such complexity are hard to create, are costly to change, and, when built \ncarelessly or incorrectly, can signifcantly impact human life. When working toward the \ncreation of complex products, teams must organize in a disciplined manner, and a sys-\ntematic approach needs to be employed to carefully ensure that products are built to meet \ntheir specifcations. Consider the construction of a bridge that spans over a body of water \nand is required to support a particular weight, to maintain access to watercrafs navigating \nunderneath, to withstand expected wind speeds, and to provide other features such as side-\nwalks\u2014all while being bound by a schedule and budget. Te successful construction of such \na bridge is a nontrivial task and requires years of experience, formal education, and large \nteams collaborating together to achieve the construction goals. If constructed incorrectly\u00ad\n, \nreconstructing the bridge can skyrocket from its original construction cost; worse yet, \nif defects are undetected, the bridge could collapse, resulting in the catastrophic loss of \nhuman life. Similar to the construction of the bridge, teams engineering other products, \n", "page": 24, "type": "text", "section": "Page 24"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 3\nsuch as airplanes, watercrafs, medical devices, and safety-critical sofware \u00ad\nsystems, share \ncomparable challenges, and failure of these products can also result in \u00ad\ncatastrophic events. \nIn an engineering environment, before product construction begins, the design of prod-\nucts needs to be carefully and extensively planned, evaluated, verifed, and validated to \nensure the product\u2019s success. Tis is mainly achieved through design.\nENGINEERING PROBLEM SOLVING\nTroughout the design process, designers are constantly engaging in problem-solving activ-\nities that are fundamental to all modern engineering projects. In a broad sense, engineers \ncan be characterized as specialized problem solvers. Teir work requires them to identify, \nevaluate, and propose solutions to complex problems (in particular domains) under tight \nproject constraints. In some situations, engineers tackle problems that have never been \nsolved before, creating challenges to meet not only functional aspects of products but also \ntheir established schedule and budget. Before engaging in more concrete design topics, a \nformal discussion on problem solving is necessary to identify fundamental concepts that \nare well understood by successful designers; these serve as basis for establishing a holistic \nproblem solving framework that can be employed any time during design.\nTo become a good designer, engineers must be good problem solvers. Tis may require \nyears of experience solving problems in a particular domain. In many cases, experience \nallows engineers to reuse already proven solutions across separate but similar problems. \nIn other cases, where unsolved problems are encountered, designers are required to \n\u201cthink\u00a0out of the box\u201d and carefully craf a systematic approach for solving the problem in \nan acceptable manner, which may require problem classifcation, identifcation of the solu-\ntion approach and type of adequate solution, and identifying the overall strategy for reach-\ning its solution. In a general sense, problem solving during design occurs in three diferent \nstates (Plotnik and Kouyoumdjian 2010):\n\u2022\t Initial state\n\u2022\t Operation state\n\u2022\t Goal state\nTrough these states, designers employ several techniques and strategies to create a \nlandscape suitable for problem solving. Te initial state is where problems are formulated \nand interpreted. In some cases, achieving full understanding of the problem is a problem \nitself. Once problems are well understood, designers move to the operational state, where \nthinking about the problem occurs and viable solutions come to light. Once an appropri-\nate solution is identifed, evaluated, and validated, designers move to the goal state, where \na fnal solution to the problem is found, marking the end of the problem-solving process.\n", "page": 25, "type": "text", "section": "Page 25"}
{"text": "4\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\nInitial State\nDesign problems are not all the same; they vary in size, complexity, and, based on these \ncharacteristics, the amount of time and efort required for their solution. In some cases, it \nquickly becomes evident that certain problems are harder to solve than others. When this \ndetermination is made, the strategy for the solution approach is adjusted to account for \nthe additional complexity. Being able to diferentiate between types of problem is crucial \nin helping designers account for the amount of efort, time, and risk associated with the \nsolution approach. Terefore, an important problem-solving skill involves identifying and \nclassifying the type of problem encountered, which includes well-defned, ill-defned, and \nwicked problems, as presented in Table\u00a01.1 (Giachetti 2010).\nWell-defned problems have clear defned goals and their constraints are well under-\nstood. Tis makes scoping the problem, proposing a solution approach, and arriving at \nthe solution easier than with other types of problems, such as ill-defned and wicked \nproblems. Ill-defned problems are problems where the mere interpretation of the prob-\nlem is a problem itself; they are ambiguous with undefned goals and require more time \nand efort to clarify and interpret the problem to arrive at a solution. In some cases, with \nadditional efort, ill-defned problems can be transformed into well-defned problems. \nFinally, wicked problems are problems where no single problem formulation exists. Tere \nmay be many acceptable formulations of the problem and no defnite solutions, and solu-\ntions are not deemed correct or incorrect but good or bad (Giachetti 2010). In\u00a0many cases, \nwicked problems can lead to contradictive goals that need additional resolution before the \nproblem solving can occur. When contradictive goals are present, providing a solution \nto one part of the problem results in the inability of solving other parts of the problem. \nIn these types of problem, optimal solutions are hard to fnd, requiring additional strug-\ngle and collaborative brainstorming. Also, evaluation of alternative designs may require \nadvanced techniques to determine the best course of action, which tends to require more \ntime. In many cases, the solution to wicked problems is not known until afer the problem \nis solved.\nOperational State\nTe operational state of problem solving is where thinking about the problem solution \ntakes place. It requires employing multiple techniques for problem solving such as using \nmetaphors, decomposing problems into smaller, less complex problems (i.e., divide and \nconquer), reusing solutions (e.g., patterns), and so forth. In all of the techniques, designers \nTABLE\u00a01.1\nProblem Classifcation\nProblem\nDescription\nWell-defned\nProblem with clear goals and known constraints\nIll-defned\nProblem with undefned or ambiguous goals and unknown constraints\nWicked\nProblem with no defnite solution; not understood until afer the formulation of its solution\n", "page": 26, "type": "text", "section": "Page 26"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 5\nare expected to exhibit a \u201cthink outside the box\u201d mentality to be able to solve complex \nproblems. Tis requires shifing the mental model from a conventional approach to uncon-\nventional methodology where solutions to complex problems may arise from thinking in \nways that deviate from conventional wisdom. For example, consider the popular nine-dot \npuzzle illustrated in Figure\u00a01.1 (Kershaw and Ohlsson 2004).\nTe requirements for solving the nine-dot puzzle problem are as follows:\n\t\n1.\tDraw four straight lines to connect all dots.\n\t\n2.\tTe pencil cannot be lifed from the paper once the line-drawing process begins.\n\t\n3.\tNo lines can be retraced.\nBefore moving on, think about this problem and attempt to provide a solution. At frst, \nthis may seem difcult because of the tendency of fxing the mental process to operate on \nthe assumption that lines should begin and end on a dot. Tis functional fxedness limits \nthe ability to fnd solutions based on objects having a diferent function from their usual \nones (Plotnik and Kouyoumdjian 2010). In the case of the nine-dot puzzle, for some, func-\ntional fxedness makes it awkward or even impossible to propose solutions that involve lines \ngoing past the dots, which is what is required to solve this problem. To increase the chance \nof overcoming functional fxedness, problems need to be attempted several times and con-\nsidered from many diferent viewpoints and unusual angles (Plotnik and Kouyoumdjian). \nOvercoming functional fxedness is critical for designers attempting to provide solutions \nat the operational state of problem solving.\nThinking about the Problem\nDiferent types of thinking take place when fnding solutions to problems. For example, \nwhen learning about a problem for the frst time, problem solvers may begin by asking \nquestions, which allows them to think about many diferent alternative solutions; as the \nproblem-solving process moves forward, problem solvers can begin narrowing down the \npossibilities and think about the single best solution to the problem. Tese types of think-\ning are known as convergent thinking and divergent thinking (Table 1.2).\nBoth convergent and divergent thinking have signifcant roles in solving engineering \nproblems. In many cases, problem solvers begin using divergent thinking with diferent \nlevels of abstraction, and each level provides fner-grained solutions to the problem until \nconvergent thinking can be employed to solve it.\nFIGURE 1.1\nTe nine-dot puzzle.\n", "page": 27, "type": "text", "section": "Page 27"}
{"text": "6\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\nProblem Solution\nIn many cases, determining the type of solution required for a given problem can reduce \nwasted time and efort spent in attempting to fnd a single, optimal solution. In such cases, \ndesigners can elect to seek approximate solutions\u2014as opposed to optimal solutions\u2014that \nare appropriate and acceptable for meeting project constraints. Determining the type of \nsolution for a given problem can reduce time and budget required for building the system. \nTwo types of solutions are algorithms and heuristics, as presented in Table\u00a01.3.\nAlgorithms are step-by-step procedures for fnding the correct solution to given prob-\nlems. Algorithms do not normally involve subjective decisions or rely on intuition or \n\u00ad\ncreativity to fnd solutions (Brassard and Bratley 1995). For some types of problems, using \nalgorithms to fnd solutions can be unrealistic, especially in time-driven, practical engi-\nneering problems. In these cases, heuristics provide a realistic approach for fnding good \napproximations of the solution. In some cases, heuristics can lead to optimal solutions; in \nothers, they can lead to solutions that are far from optimal or no solution at all (Brassard \nand Bratley 1995). Algorithms and heuristics are both used heavily in the design of engi-\nneering systems and determining their appropriateness for solving particular problems is \nessential to meeting other project demands.\nGoal State\nTe goal state represents the fnal state of problem solving. It is where adequate solutions \nto given problems are determined. For many engineering problems, reaching the goal state \nis a nontrivial task that requires careful attention to all important aspects of the problem. \nTe concepts of initial, operational, and goal state can be fused together to create a holistic \nproblem-solving framework adequate to solving engineering problems at all stages of the \ndevelopment efort. Te approach consists of the following tasks:\n\u2022\t Interpret problem\n\u2022\t Evaluate constraints\n\u2022\t Collaborative brainstorming\nTABLE\u00a01.2\nTypes of Tinking\nType\nDescription\nConvergent thinking\nType of thinking that seeks to fnd one single solution to a problem\nDivergent thinking\nType of thinking that seeks to fnd multiple solutions to a problem\nTABLE\u00a01.3\nTypes of Problem Solution\nProblem\nDescription\nAlgorithm\nFixed set of rules that lead to the solution of a problem\nHeuristic\nRules of thumb (or procedure) that may or may not lead to the solution of a problem\n", "page": 28, "type": "text", "section": "Page 28"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 7\n\u2022\t Synthesize possibilities\n\u2022\t Evaluate solution\n\u2022\t Implement solution\nTe frst task of the problem-solving approach involves interpreting the problem. Tis \nis where problem information is received and processed; problem classifcation is identi-\nfed (e.g., well-defned, ill-defned) and activities are performed to formulate the problem. \nInterpreting the problem is a task performed during the initial state of problem solving. \nDuring the initial state, identifcation of stakeholders\u2014persons, groups, or organizations \nthat have direct or indirect stake in the problem and its solution\u2014is essential. Once the \nproblem is formulated, the evaluate constraints task is used to identify external problem con-\nstraints, which are negotiated, integrated, and used to set the bounds on the solution land-\nscape. Once the problem and constraints are well understood, collaborative \u00ad\nbrainstorming \ncan begin among problem solvers and stakeholders. During collaborative brainstorming, \nproblem solvers use mostly divergent thinking to come up with alternative solutions that \nmay bring to light new knowledge, which can trigger a transition back to the problem inter-\npretation task. Once a set of acceptable solutions is identifed, problem solvers synthesize \npossibilities to form the acceptable proposed solution to the problem. During this task, prob-\nlem solvers shif from divergent thinking to convergent thinking to propose the best-known \nsolution to the problem. Te solution is shared and evaluated by everyone involved in the \nproblem-solving process. Flaws in the solution may trigger a transition back to the collab-\norative brainstorming task; otherwise, implementation begins. Collaborative brainstorming, \nsynthesize possibilities, and evaluate solutions are all tasks performed as part of the opera-\ntional state of problem solving. During implementation, the proposed solution is executed \nuntil the problem is solved, which is a task performed during the goal state of problem solv-\ning. Together, these tasks are combined with other problem variables to provide a holistic \napproach to problem solving (Harrell, Ghosh, and Bowden 2004), as presented in Figure\u00a01.2.\nAs seen in the fgure, inputs are items that require processing during problem solving. \nInputs come from many diferent sources and are interpreted and formulated for particu-\nlar problems. Tey drive all activities by specifying the overarching need that promotes \nthe execution of the problem-solving tasks. Constraints are external properties that come \ninherent with any problem and limit the solution approach. Outputs are the expected \noutcome in problem solving. In many engineering projects, merely coming up with the \nsolution to a given problem is not enough, since the solution needs to be documented, \nformatted, decorated, specifed in graphical model format, or placed under confguration \nmanagement. Outputs coming out of the problem-solving process need to meet the appro-\npriate standards as defned by the developing organization. Te development organization \nmay also set standards for activities, controls, and resources, which all impact problem \nsolving. Tese variables are presented in Table\u00a01.4.\nActivities are internal tasks determined by the development organization that must be \nfollowed when solving problems. Tese are intended to help manage the problem-solving \napproach and may include review activities at diferent stages of problem solving, includ-\ning preliminary and detailed stages, status reports, and documentation, which all impact the \n", "page": 29, "type": "text", "section": "Page 29"}
{"text": "8\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\ntime required to solve the problem. Controls, on the other hand, are internal constraints set by \nthe development organization that limit the possible solutions so that they align well with the \norganizational goals and current practices. Tese controls can dictate when and where prob-\nlem solving takes place, selection of strategies, permitted tools, personnel allowed to engage in \nproblem solving, and measures for quality control. Finally, resources are the means by which \nactivities are performed, which include people, sofware, and hardware, and their availability, \nwhich all impact problem solving. Together, all of these variables mix together to defne the \nproblem-solving landscape, which must be considered when tackling engineering problems.\nSkill Development 1.1: Using the Holistic Approach in Problem Solving\nUse and document all the steps of the holistic problem-solving approach presented in \nFigure\u00a01.2 to solve the following problem. If possible, do this exercise as a team. Te \nproblem specifcation is as follows: there are six equal matches; connect each match to \nform four equilateral triangles. When done, explain how functional fxedness played a \nrole in preventing you from arriving at the solution to this problem. \nTABLE\u00a01.4\nProblem-Solving Process Variables\nPhase\nDescription\nActivities\nOne or more tasks identifed and required to solve the problem\nResources\nMeans by which activities are performed\nControls\nInternal properties of the organization that place bounds on the solution, or the solution process, \nfor the problem\nEvaluate\nConstraints \nSynthesize\nPossibilities\nInterpret\nProblem\nEvaluate \nInputs \nConstraints \nOutputs \nCollaborative\nBrainstorming\nImplement \nGeneric Design Problem \nResources \nActivities \nControls \nFIGURE 1.2\nHolistic approach to problem solving.\n", "page": 30, "type": "text", "section": "Page 30"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 9\nSOFTWARE ENGINEERING DESIGN\nIn the previous sections, design was introduced as a systematic and intelligent process for \ngenerating, evaluating, and specifying designs for devices, systems, or processes. To support \nthis process, the problem-solving skill was identifed as an essential ingredient for design-\ning complex products. Tese discussions provided a general perspective on the impor-\ntance of these concepts in the engineering profession. As in other engineering disciplines, \ndesign and problem-solving are crucial to the development of professional, large-scale, \nsofware systems. Sofware systems are highly complex, difcult to create, costly to change, \nand\u2014depending on the sofware product\u2014critical to human safety. Similarly to other \nengineering disciplines, designs in sofware engineering are used to identify, evaluate, and \nspecify the structural and behavioral characteristics of sofware systems that adhere to \nsome specifcation. Sofware designs provide blueprints that capture how sofware systems \nmeet their required functions and how they are shaped to meet their intended quality. \nFormally, sofware engineering design is defned as\n(1) Te process of identifying, evaluating, validating, and specifying the architectural, detailed, \nand construction models required to build sofware that meets its intended functional and non-\nfunctional requirements; and (2) the result of such process.\nTe term sofware design is used interchangeably in practice as a means to describe both \nthe process and product of sofware design. From a process perspective, sofware design is \nused to identify the phase, activities, tasks, and interrelationship between them required \nto model sofware\u2019s structure and behavior before construction begins. From a product \ndevelopment perspective, sofware design is used to identify the design artifacts that result \nfrom the identifed phase, activities, and tasks; therefore, these products by themselves, or \ncollectively, are referred to as sofware design. Design products vary according to several \nfactors, including design perspective, language, purpose, and their capabilities for evalu-\nation and analysis. For example, designs can be in architectural form, using architectural \nnotations targeted for specifc stakeholders. Tese types of design can be presented using \nblock diagrams, Unifed Modeling Language (UML) diagrams, or other descriptive form \nof black-box design documentation. In other cases, design can be in detailed form, where \na more white-box representation of the system is used to model structural and behavioral \naspects. Tese can include sofware models that contain class diagrams, object diagrams, \nsequence diagrams, or activity diagrams. Other design products include models that rep-\nresent interfaces, data, or user interface designs. Due to the many ways sofware design is \nused in practice, a common pitfall in sofware engineering projects is to associate design \nwith a particular type of design artifact, therefore neglecting other forms of design or the \nactivities required to create complete and correct sofware designs. Collectively, both pro-\ncess and products, including all variety of design products, are considered sofware design \nand are essential in most professional sofware projects.\n", "page": 31, "type": "text", "section": "Page 31"}
{"text": "10\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\nWHY STUDY SOFTWARE ENGINEERING DESIGN?\nOn February 25, 1991, a sofware error on the Patriot missile defense system operating \nduring operation Desert Storm caused it to fail to track and intercept an incoming Scud, \nwhich resulted in the death of 28 Americans (GAO, 1992). In 1996, a sofware error caused \nthe Ariane 501 satellite launch to fail catastrophically, resulting in a direct cost of approx-\nimately $370 million (Dowson 1997). Te sofware error that caused Ariane 501 to fail \ncould be attributed to its sofware design. Similarly, the literature is swamped with many \nexamples of disastrous results of sofware-based products. Te reason for many of these \ndisasters is that developing high-quality sofware on time and within budget is a daunting \ntask. From the outset, the landscape for sofware development projects is plagued with a \nvariety of challenges that increase complexity in sofware projects. Sofware design plays \nan integral part in managing the complexity and the challenges encountered in any sof-\nware development efort.\nDuring the sofware design phase, the system is decomposed to allow optimum develop-\nment of the sofware; requirements are mapped to conceptual models of the operational \nsofware; roles are assigned to sofware teams on the same or remote sites; well-known \ninterfaces for sofware components are created; quality attributes are addressed and \nincorporated into the design of the system; the user interface is created; the sofware\u2019s \ncapability is analyzed; function and variable names are identifed; design documentation \ngoals are established; and the foundation for the rest of the sofware engineering life cycle \nis established. Given its impact on the creation and management of sofware products, \n\u00ad\nmastering sofware design becomes essential to successfully engineer sofware products. \nTe reasons for studying sofware engineering design can be described using a product \ndevelopment perspective and a project management perspective.\nReasons for Studying Software Design in Product Development\nFrom the product development view, studying sofware design is important because \ndesigns form the foundation for all other sofware construction activities. Sofware designs \nallow sofware engineers to create models that represent the structure and behavior of \nthe sofware system. Trough these models, the main components and their interconnec-\ntion for the solution are identifed. Characteristics of quality code, such as modularization, \ncohesiveness, and coupling, are all born in the design phase. For complex tasks, abstrac-\ntions and encapsulation are used in sofware design as means to provide a systematic \napproach for problem solving. In addition, sofware designs are reusable; therefore, they \ncan be applied to diferent projects to provide ready-made solutions to common problems. \nSofware design also provides the means to evaluate and incorporate the quality attributes \nnecessary for sofware systems. Terefore, issues such as performance, usability, portabil-\nity, and security can all be addressed early on in the development project. Tese benefts \nare carried over to all other subsequent phases of the sofware development life cycle and \nhave direct impact on the implementation, testing, and maintenance phase.\n", "page": 32, "type": "text", "section": "Page 32"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 11\nReasons for Studying Software Design in Project Management\nManaging sofware projects characterized by changing requirements, tight schedules, cost \nconstraints, and high expectations for sofware quality is tough. Among these, require-\nment changes are common drivers for all other project characteristics. Tis means that, \nas requirements change, projects should expect some impact in their cost, schedule, and \nquality. In some cases, requirement changes can easily translate to extended schedules \nand increased cost; in others, where schedules are not extended, requirement changes \ntranslate to decreased sofware quality. Good sofware design can minimize (or counter) \nthe efects of requirements volatility in managing sofware projects. From the manage-\nment\u2019s point of view, sofware design is important because it helps accommodate changes \nto the requirements or system updates, therefore minimizing impact on schedule, cost, \nand quality. In\u00a0addition, good sofware design increases efciency in human resource \nallocation tasks. By decomposing the sofware into independent units, resources can be \nassigned to sofware components so that they can be built in parallel in the same or dif-\nferent construction sites, therefore having signifcant impact on sofware schedules and \ncost. By compartmentalizing the design, the efects of unwanted employment attrition \n(i.e.,\u00a0employees leaving the company) can also be minimized, since new employees need \nonly to take on the individual design component assigned to that employee. Good sof-\nware designs provide an efcient mapping of customer requirements to sofware solu-\ntions, therefore facilitating requirements tracing throughout the design. Having a strong \ngrasp on sofware design helps management abstract project tasks and acquire better \nappreciation of the work to be done. Overall, having a strong grasp in sofware design \nhelps management improve the project planning, organization, stafng, and tracking and \nprovide overall guidance for the project.\nSOFTWARE DESIGN CHALLENGES\nToday, the sofware design phase has evolved from an ad hoc and sometimes overlooked \nphase to an essential phase of the development life cycle. Furthermore, the increasing com-\nplexity of today\u2019s systems has created a set of particular challenges that makes it hard for sof-\nware engineers to meet the continuous customer demand for higher sofware quality. Tese \nchallenges have prompted sofware engineers to pay closer attention to the design process \nto better understand, apply, and promulgate well known design principles, processes, and \nprofessional practices to overcome these challenges. Some of the major challenges include \nrequirements volatility, design process, quality issues (e.g., performance, usability, secu-\nrity), distributed sofware development, efcient allocation of human resources to devel-\nopment tasks, limited budgets, unreasonable expectations and schedules, fast-changing \ntechnology, and accurate transformation from sofware requirement to a sofware product. \nA brief discussion of these challenges is presented next.\n", "page": 33, "type": "text", "section": "Page 33"}
{"text": "12\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\nDesign Challenge 1: Requirements Volatility\nA major reason for the complexity of sofware projects is the constant change of require-\nments. When designed properly, sofware can be modifed or extended easily; however, when \ndesigned poorly, modifying sofware can become overwhelming and lead to all sorts of com-\nplex problems. Unlike the development of computer hardware, bridges, houses, or mechanical \nparts, sofware\u2019s very own nature allows itself to change to provide diferent or new function-\nality to systems. Tis same trait that makes sofware so desirable is what makes it also so com-\nplex. Although much efort is put into the requirements phase to ensure that requirements are \ncomplete and consistent, that is rarely the case; leaving the sofware design phase as the most \ninfuential one when it comes to minimizing the efects of new or changing requirements. \nRequirements volatility is challenging because they impact future or current development \neforts. Tis forces designers to create designs that provide solutions to problems at a given \nstate while also anticipating changes and accommodating them with minimal efort. Tis \nrequires designers to have a strong understanding of the principles of sofware design and \ndevelop skills to manage complexity and change in sofware development.\nDesign Challenge 2: Process\nSofware engineering is a process-oriented feld. Sofware processes allow engineers to \norganize the steps required to develop sofware solutions with schedule and cost constraints. \nTerefore, at the core of every sofware development company, there should be a sound, \nwell-understood, and consistent process for sofware development. Processes can also be devel-\noped and customized for particular phases of the sofware engineering life cycle. In the design \nphase, sofware processes involve a broad set of activities and tasks that bridge the gap between \nrequirements and construction while adhering to a set of project-specifc (or company-specifc) \nconstraints. Tese activities include common ones, such as architectural and detailed design, \nas well as other supporting activities. Tese supporting activities include establishing a design \nreview process, defning design quality evaluation criteria, evaluating design reuse, estab-\nlishing design change management and version control procedures, adopting design tools, \nand allocating resources. In many cases, a company\u2019s design process is not well established, \nis poorly understood, or is approached with minimalistic expectations that ignore aspects \nthat are essential to executing a successful design phase. Focusing design eforts on creating \n\u00ad\nindependent sofware products, such as a simple class diagram or user interface, while ignoring \nother design activities may create complexities later on during system\u2019s test and maintenance. \nTe design process is challenging because essential design process activities are ofen over-\nlooked, done in an ad hoc manner, or simply not done at all. In many cases, a well-established \nand well carried out design process serves an indication of future project\u2019s success.\nDesign Challenge 3: Technology\nSofware is meant to be everywhere. From health-care systems and education to defense \nand everyday ubiquitous devices, sofware is required to operate on a massive and always \n", "page": 34, "type": "text", "section": "Page 34"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 13\nevolving technology landscape. Besides the operating environment, the technology for \ndesigning and implementing today\u2019s sofware systems continues to evolve to provide \nimproved capabilities. Examples of these include modeling languages and tools, program-\nming languages, development environments, design patterns, and design strategies. As \nnew technologies emerge, sofware engineers are required to assimilate and employ them \nall at the same time. In some cases, emerging technologies do not completely replace old \nones. Some sofware systems are required to interoperate with old legacy systems designed \nwith older design methodologies. Tis results in sofware designers employing diferent \ndesign methodologies and technologies, all on the same sofware system. In other cases, \ndesign models need to be derived from existing code, modifed, and made interopera-\nble with newer technologies. Tis technology-driven aspect of the design phase creates a \ndemand for capable sofware designers that can assimilate new technology quickly and \nefectively to succeed at designing sofware. Te technology aspect of sofware design is \nchallenging because it is fast and ever-changing; therefore, designers must keep abreast of \nthe latest advances and become profcient in the application of these advancements while \nmaintaining rooted in legacy technology.\nDesign Challenge 4: Ethical and Professional Practices\nDesigners create blueprints that drive the construction of the sofware. During this cre-\nation process, designers are required to determine how design decisions afect the environ-\nment and the people that use the sofware. In many cases, the sofware development process \nis traditionally carried out under tight schedule constraints. Inherently, all phases of the \ndevelopment life cycle sufer from this, including the design phase. Tis creates external \npressures that can lead designers to deviate from the normal design approach to meet these \ndemands, which can have catastrophic consequences. No matter how tight deadlines are, \nhow much animosity exists within the design team, or how much other external/personal \nfactors are brought into the design phase, sofware designers must exhibit strong ethical \nand professional practices to ensure that the systems they build are of highest quality and \nthat all design considerations are properly evaluated. In many cases, this requires design-\ners to exert strong leadership skills to infuence and negotiate with stakeholders, motivate \nthe design team, and lead the design process to accomplish the project\u2019s goals. Designers \nare also responsible for enforcing ethical guidelines during the design process; evaluating \nthe social impacts of their designs in the public domain or in safety-critical systems; and \nto follow the appropriate professional practices to ensure success in the overall system. Te \n\u00ad\nethical and professional practices aspect of sofware design are challenging because design-\ners are constantly faced with numerous pressures from stakeholders that infuence \u00ad\ndesigners\u2019 \n\u00ad\ndecisions, most of which have consequences of social, ethical, or professional nature.\nDesign Challenge 5: Managing Design Influences\nDesigns are shaped by many diferent infuences from stakeholders, the development orga-\nnization, and other factors. Tese infuences can have cyclical efects between the system \n", "page": 35, "type": "text", "section": "Page 35"}
{"text": "14\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\nand its external infuences, such that external factors afect the development of the system \nand the system afects its external factors (Bass, Clements, and Kazman 2003). Managing \nthese infuences is essential for maximizing the quality of systems and their related infu-\nence on future business opportunities. Of specifc importance are design infuences that \ncome from the system stakeholders and its developing organization.\nStakeholders\nDesigning sofware is a nondeterministic activity. If given the same task to diferent \ndesigners, diferent solutions will be proposed, each of them being perfectly acceptable \n(McConnell 2004). Now add to the mix the multitude of infuences that come from dif-\nferent stakeholders, and you can easily get a variety of design alternatives for meeting a \nvariety of stakeholders\u2019 concerns, all conficting with each other. Tis creates a challenge \nwhen trading of design alternatives that meet all stakeholders concerns. Making such \ndesign trade-ofs is difcult, especially on large-scale design eforts. Consider a project \nwith multiple customers, each with conficting goals afecting design decisions. In such \nprojects, creating a design that sacrifces some desired customer capability but provides \nother desired properties, such as quick time-to-market, reliability, or lower cost, can lead \nto the development of a high-quality system that maintains acceptable levels of satisfaction \namong stakeholders. Tis is an example of how stakeholders afect design decision, and the \ndesign, in turn, infuences the stakeholder goals (Bass et al. 2003). Managing \u00ad\nstakeholders\u2019 \ninfuences is challenging because it requires designers to exert a high-level of communica-\ntion, negotiation, and technical skills to ensure that design decisions are made to accom-\nmodate all concerns without negatively afecting the project.\nDevelopment Organization\u2019s Structure\nTe development organization\u2019s structure infuences the development of sofware prod-\nucts, in particular, the design of those products. As example, consider the case of distrib-\nuted sofware engineering. In today\u2019s global market, more and more cases of distributed \nsofware development are taking place. A wide variety of reasons exist for developing sof-\nware at diferent sites. Consider companies that have sites in multiple states, where various \nlevels of domain expertise are found at diferent sites. Or consider the case of sofware \nengineers resigning, creating a gap in the development team that is hard to fll with local \nresources. Finally, consider companies that simply want to reduce cost by hiring sofware \nengineers from diferent countries. Tese and many other reasons exist for having devel-\nopment across site boundaries. In each of these cases, the structure of the development\u2019s \norganization makes it complicated to, for example, coordinate design eforts, evaluate and \ndiscuss design alternatives, conduct peer reviews, and manage version control. In these \ncases, designers need to consider not only technical aspects of the design but also the dis-\ntribution of employees, organizational goals, resource availability, and so forth. Designs \nthat support integration of distributed expertise across sites can introduce capabilities for \nbuilding new sofware products that could not be engineered otherwise. Tis in turn can \n", "page": 36, "type": "text", "section": "Page 36"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 15\ninfuence the developing organization to target new areas of businesses, therefore allowing \nthe sofware design to infuence its business goals. Managing the infuences of the develop-\nment organization is challenging because it requires designers to span out of the technical \ndomain to have a keen interest on the organization as a whole.\nCONTEXT OF SOFTWARE DESIGN\nIn today\u2019s modern sofware systems, sofware design plays a key role in the development of \nsofware products; however, it is only one phase of the complete sofware engineering life \ncycle. To understand how design fts within the whole sofware engineering process, it is \nnecessary to provide the appropriate context so that clear distinctions can be made between \nthe diferent life cycle phases and an appreciation of the importance of sofware design \nactivities and tasks can be acquired. For this reason, an overview of sofware engineering \nand its life cycle is required. Sofware engineering is defned by the IEEE (1990, p. 67) as\n(1) Te application of a systematic, disciplined, quantifable approach to the development, \noperation, and maintenance of sofware; that is, the application of engineering to sofware. \n(2) Te study of approaches as in (1). \nTe fundamental sofware engineering life cycle phases include requirements, design, \nconstruction, test, and maintenance, as presented in Table\u00a01.5.\nTe requirements phase is where stakeholders are identifed and customer needs, wants, \nand the (ofen overlooked) nonfunctional requirements are determined (Laplante 2009). \nDuring this phase, requirements are analyzed in their raw form to address issues such as \nrequirements that don\u2019t make sense, contradict each other, or are incomplete, vague, or \njust wrong (Laplante 2009); requirements are classifed and prioritized; and the specifca-\ntion of the sofware system, which typically results in the production of a document, or \nits electronic equivalent is reviewed and validated (Abran, Moore, Bourque, and Dupuis \nTABLE\u00a01.5\nFundamental Sofware Engineering Phases\nPhase\nDescription\nRequirements\nInitial stage in the sofware development life cycle where requirements are elicited, analyzed, \nspecifed, and validated\nDesign\nTe requirement\u2019s specifcation is used to create the sofware design, which includes its \narchitecture and detailed design\nConstruction\nRelies on the requirements\u2019 specifcation, the sofware architecture, and detailed design to \nimplement the solution using a programming language; a great deal of design can also \noccur at this phase\nTest\nEnsures that the sofware behaves correctly and that it meets the specifed requirements\nMaintenance\nModifes sofware afer delivery to correct faults, improve performance, or adapt it for a \ndiferent environment\n", "page": 37, "type": "text", "section": "Page 37"}
{"text": "16\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\n2005). Once the requirements for the system are specifed, designing the system takes \nplace, which is the main topic of this book.\nTe construction phase begins once the design phase has been executed and all require-\nments can be traced to a section of the sofware design models. Te construction phase is \nwhere designs are implemented using the programming language of choice. In this phase, \ncode is generated according to a style guide. In addition, the code is unit tested, debugged, \nand peer-reviewed; programming errors are detected, tracked, and resolved; code is man-\naged by using change management and version control sofware; and, fnally, code is pre-\npared for delivery using a predefned set of conventions for formatting. Te construction \nphase is tightly related to the design phase and in some cases (typically on smaller projects) \nthe line dividing both phases can be hard to identify. Tere are several reasons for this, \nthe main one being that detailed designs can be directly translated to code; therefore, sof-\nware engineers tend to design and code at the same time. In other cases, where design and \nconstruction are clearly delineated by the process, it is common for some construction \ntasks, such as identifying appropriate class, function, and variable names, to be performed \nduring detailed design. Finally, because many discoveries made well into the construction \nphase give rise to functionality that requires design work, engineers must iterate back and \nforth between construction and design activities. Once all the design artifacts are imple-\nmented with programming and all assigned requirements can be validated through execu-\ntion of code during unit testing, the construction phase is complete.\nTe testing phase is typically the fnal step before the sofware goes out the door. Te\u00a0main \npurpose of the testing phase is to verify and validate the sofware to ensure that it meets \nthe predefned functions and level of quality defned in the sofware requirement\u2019s phase. \nFormally, the IEEE (1990, p. 76) defnes testing as\n(1) Te process of operating a system or component under specifed conditions, observing or \nrecording the results, and making an evaluation of some aspect of the system or component. \n(2) Te process of analyzing a sofware item to detect the diferences between existing and \nrequired conditions (that is, bugs) and to evaluate the features of the sofware item.\nTe sofware testing phase serves as a gateway between product development and product \nrelease. Terefore, verifcation and validation eforts need to be made to ensure that the sof-\nware meets the specifcation and the integrity of the sofware can be assured under normal \nand harsh conditions. It is important to note that no desired quality attribute can be verifed \nduring testing if it hasn\u2019t been designed into the product frst. Terefore, even though test-\ning is typically credited for ensuring product quality, design is fundamental in supporting a \nsuccessful testing phase. Once sofware is delivered, the maintenance phase begins to imple-\nment corrections, adaptations, or improvements to the sofware. Corrections are typically \nmade on a smaller scale to rectify faulty behavior or output of the sofware. Tese typically \ndo not require design work. However, for adaptations or improvements, design work may \nbe required to accommodate the changes. Together, all phases of the sofware engineering \nlife cycle work together to defne the functions that the sofware must provide, to transform \nthese functions into technical solutions, to implement those solutions, and to validate their \nimplementation and ensure the quality of the system throughout future versions.\n", "page": 38, "type": "text", "section": "Page 38"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 17\nSOFTWARE DESIGN PROCESS\nIn the previous section, the design phase was briefy mentioned as a means for determin-\ning its place within the sofware engineering process. However, as it will be seen, the design \nphase incorporates many activities and tasks conducted by diferent teams and typically \nmanaged by personnel other than designers. Tis requires a formal process to ensure that the \ndesign phase is conducted properly and that it addresses all the concerns identifed for the \nsofware system being built. Many processes exist to carry out phases, activities, and tasks \nthroughout the sofware engineering life cycle, including the unifed process (UP), Scrum, \nand the dynamic systems development method (DSDM) (Pressman 2010). What follows is \na discussion on the sofware design process in terms of the fundamental activities and tasks \nrequired to build sofware products. Tese activities and tasks are essential and typically built \ninto other formal processes such as the ones already mentioned. Te hope is that by plac-\ning more emphasis on the fundamental activities and tasks and less on particular process \napproaches readers can obtain a more concise and understandable coverage of the topic.\nIn today\u2019s professional sofware engineering landscape, sofware engineers are being \nasked to build larger and more complex sofware systems in the same or diferent sites. \nTerefore, both design processes and artifacts are increasing in complexity. Tis means that \nit is not enough to know how to model structural and behavioral aspects of the system in \nthe design phase, but it is also essential that sofware designers know about the particular \nprocess (e.g.,\u00a0UP, Scrum) required to manage, create, and control sofware design activities. \nSommerville (2010) defnes a sofware process as a set of activities that lead to the production \nof a sofware product. Similarly, a sofware design process is a set of activities and controls \nthat specify how resources work together for the production of sofware design artifacts. \nTe sofware engineering body of knowledge identifes two major activities for sofware \ndesign: sofware architecture and detailed design (Abran et al. 2005). Tese are the essential \nactivities for managing the complexity involved in developing large-scale sofware systems. \nHowever, numerous other important activities are required for supporting the creation of \narchitectural and detailed designs. Terefore, when planning and identifying an appropri-\nate sofware design process, the efort required for these activities needs to be considered. \nIn addition, because of the emphasis that some forms of design place on construction, the \ndetailed design activity process can be modifed to explicitly present the construction design \nactivity that addresses design issues encountered during the construction phase. With this \nin mind, a holistic approach to sofware design, which includes architecture, detailed and \nconstruction design, management, and documentation, is presented in Figure\u00a01.3.\nAs seen in the fgure, sofware architecture is the frst activity conducted in the design \nprocess. Architectural designs are elaborated through detailed designs, which are further \nelaborated through construction designs. All of these design activities need to be docu-\nmented, and the process for design and documentation needs to be managed. Figure\u00a01.3 \nalso presents a necessary diferentiation between the sofware design phase and the distri-\nbution of its activities throughout the sofware engineering life cycle. In some cases, the \narchitectural design activities can begin during the analysis activity of the requirements \n", "page": 39, "type": "text", "section": "Page 39"}
{"text": "18\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\nphase and span through the design phase; in others, it begins afer the requirements are \nspecifed and validated. In a similar fashion, the detailed design activity can start at the \nproject\u2019s design phase and span through the sofware construction phase. Tese scenarios \nare highly project dependent; therefore, following to a strict waterfall-like process for sof-\nware development is impractical for all but the simplest sofware applications.\nSoftware Architecture\nTe sofware architecture activity corresponds to a macrodesign approach for creating \n\u00ad\nmodels that depict the quality and function of the sofware system. It provides black-box \nmodels used to evaluate the system\u2019s projected capabilities as well as its expected quality, \nall from multiple perspectives. Terefore, architectural designs allow diferent \u00ad\nstakeholders, \nwith diferent backgrounds and expertise, to evaluate the design and ensure that the sofware \nSoftware Design \nManagement \nDocumentation \nDetailed Design:\nInterface Design\nComponent Design\nConstruction Design:\nFlow-Based Design\nTable-Based Design\nSoftware\nRequirements\nSoftware\nConstruction\nSoftware Architecture:\nArchitectural Views\nArchitectural Patterns\n\u2026\n\u2026\nH\nC\nI\nD\nE\nS\nI\nG\nN\n\u2026\nSoftware Design Process\nDesign Activities in Software\nEngineering Process\nSoftware\nRequirements\nArchitectural\nDesign\nArchitectural\n& Detailed\nDesign\nDetailed &\nConstruction\nDesign\nSoftware\nDesign\nSoftware\nConstruction\nFIGURE 1.3\nTe sofware design process and design activities during the SWE process.\n", "page": 40, "type": "text", "section": "Page 40"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 19\narchitecture is addressing their concerns. For example, from the systems engineering per-\nspective, architectural designs can provide information about the physical deployment of \nthe system, including subsystems located at diferent locations, the artifacts executing in \nthe subsystems, and how the system as a whole communicates. From the confguration \nmanagement perspective, architectural designs can provide information about the hier-\narchy of fles in the fle system and how these fles are interconnected to build and deploy \nthe sofware system. From the sofware engineering perspective, diferent architectural \ndesigns can help decompose the sofware and defne the major structural components of \nthe system, identify interfaces between the components, map the requirements to them, \nevaluate concurrency issues, and provide overall insight into the design solution. A major \nbeneft of architectural designs is their capacity to evaluate high-level concerns from stake-\nholders that deal mostly with nonfunctional requirements (e.g., performance, usability, \nsecurity). For these purposes, architectural designs serve as important communication, \nreasoning, and analysis tools that support the development and growth of the systems \n(Bass et al. 2003). Sofware architecture lays the foundation for all subsequent work in the \nsofware engineering life cycle.\nDetailed Design\nTe detailed design step begins afer the sofware architecture is specifed, reviewed, and \ndeemed sufciently complete for detailed design to begin. Te detailed design activity \nbuilds on the sofware architecture to provide white-box design elements of the \u00ad\nstructure \nand behavior of the sofware system and in many cases is the last major efort before \n\u00ad\nsofware construction begins. Detailed design is the activity that deals with refning the \nsofware architecture to reach a point where the sofware design, including architecture \nand detailed design, is deemed sufciently complete for construction to begin. Whereas the \nsofware architecture places a major emphasis on quality (nonfunctional requirements), \nthe detailed design activity places a major focus on addressing functional requirements of \nthe system. In object-oriented systems, the detailed design activity is where components \nare refned into one or more classes, interfaces are realized, relationships between classes \nare specifed, class functions and variable names are created, design patterns are identifed \nand applied, and, if applicable, design tools are confgured for code generation. Two major \ntasks of the detailed design activity are interface design and component design.\nInterface Design\nInterface design refers to the design activity that deals with specifcation of interfaces \nbetween components in the design (Sommerville 2010). Interface design can be focused \non specifying the interfaces used internally within sofware components or externally \nacross sofware components. In both cases, interfaces provide a standardized way for spec-\nifying how services are accessed and provided by sofware components. Interface design \nallows subsystems to be designed independently and in parallel; therefore, it is typically \none of the frst tasks performed as part of the detailed design. Other forms of interface \n", "page": 41, "type": "text", "section": "Page 41"}
{"text": "20\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\ndesign specify communication between systems, for example, custom binary or Extensible \nMarkup Language (XML) messaging specifcations used for communication between two \nor more subsystems through the network.\nComponent Design\nDuring architecture, the sofware system is decomposed into logical components that \nabstract required system functions. During detailed design, these logical components are \nrefned and their interactions are modeled to verify the validity of their structural compo-\nsition. Te execution of the detailed design activity requires a shif from the macrodesign \napproach to the microdesign approach to further decompose and refne system components \ninto one or more fne-grained elements, functions, and data variables required for support-\ning the internal structure and behavior of components that meet assigned roles during the \nsofware architecture activity. Component design refers to modeling the internal\u00a0structure\u00ad\n \nand behavior of components\u2014which includes the internal structure of both logical and \nphysical components\u2014identifed during the sofware architecture phase. During this \nactivity\u00ad\n, fne-grained components are derived from the architecture, and their internal \nstructure and behavior are designed. Components are not limited to object-oriented \n\u00ad\nsystems; therefore, component designs can be realized in many ways. In\u00a0object-oriented \nsystems, the internal structure of components is typically modeled using UML through \none or more diagrams, including class and sequence diagrams. When modeling the inter-\nnal structure of components, several design principles, heuristics, and patterns are used to \ncreate and evaluate component designs.\nConstruction Design\nTe idea of the detailed design activity is to get as close to the solution as possible without \nbeginning the construction phase. In many cases, in object-oriented systems, this amounts \nto identifying classes, their attributes and functions, and interrelationships with other \nclasses. Tese tasks are done while abstracting and deferring details of implementation to \nthe construction phase. In some cases, however, implementing complex sofware functions \nidentifed during the detailed design activity requires additional design work to ensure they \nwork properly and maintain the quality standards sought during the sofware architecture \nactivities. In these cases, construction design is necessary. Construction design is not a new \nconcept. Many other authors have proposed it as an important design activity. For example, \nMcConnell (2004) specifes fve levels of sofware design; one of them, being at the lowest \nlevel, deals with internal routine design. Similarly, Fox (2006) identifes a form of low-level \ndesign that flls the gap between detailed design and programming and deals with issues \nsuch as operation specifcation, including operation name, parameter types, and return \ntypes among others. Other authors, such as Meyers (2005), have highlighted the impor-\ntance of designing code at low levels, during construction. Construction design is the last \ndesign activity\u2014typically conducted during the construction phase\u2014required to support \nthe \u00ad\nsystem\u2019s quality attributes, such as performance, maintainability, and testability.\n", "page": 42, "type": "text", "section": "Page 42"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 21\nHuman\u2013Computer Interface Design\nTe human\u2013computer Interface (HCI) design activity is where general principles are applied \nto optimize the interface between humans and computers. Visual designs have a major role \non the success or failure of sofware systems. Systems that meet functional requirements \nbut that are not usable cannot succeed. Te HCI design activity can be executed in paral-\nlel to the sofware architecture or detailed design activities. In some cases, HCI design is \nconsidered an architectural task, while in others it is considered a detailed design task. \nRegardless of where HCI design fts within design processes adopted by specifc organiza-\ntions, it is a major design activitiy that requires careful attention. Te major concerns of \nthe HCI designs may include the evaluation and use of modes, navigation, visual designs, \nresponse time and feedback, and design modalities, such as forms and menu-driven. HCI \ndesigns directly infuence the quality of any system and are essential to understanding and \naddressing the factors that afect the overall usability of the system. Many design principles \nand evaluation techniques exist to succesfully design user interfaces.\nSoftware Design Documentation\nSimilar to the specifcation activity of the requirements phase, sofware design documen-\ntation, also known as sofware design description (SDD), plays a big role in professional, \nlarge-scale, or sofware-intensive systems. Its importance is specifed by the IEEE (1998, \np.\u00a0iii) as follows:\nSDDs play a pivotal role in the development and maintenance of sofware systems. During \nits lifetime, a given design description is used by project managers, quality assurance staf, \n\u00ad\nconfguration managers, sofware designers, programmers, testers, and maintainers. Each \nof these users has unique needs, both in terms of required design information and optimal \norganization of that information. Hence, a design description must contain all the design \n\u00ad\ninformation needed by those users.\nSDD should include the necessary information that properly captures the design of \nthe system. As part of this activity, other issues such as tools for generating design docu-\nments, validation, and confguration management must be addressed. Te sofware design \n\u00ad\ndocumentation activity typically begins at the design phase and continues throughout the \n\u00ad\nlifetime of the sofware system.\nSoftware Design Management\nManagement plays a big role in sofware engineering projects. Grifn (2010, p. 5) defnes \n\u00ad\nmanagement as\nA set of activities (including planning and decision making, organizing, leading, and con-\ntrolling) directed at an organization\u2019s resources (human, fnancial, physical, and informa-\ntion), with the aim of achieving organizational goals in an efcient and efective manner.\n", "page": 43, "type": "text", "section": "Page 43"}
{"text": "22\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\nIn the design phase, management refers to the set of activities required to efciently \u00ad\ncreate \nand implement quality design artifacts, within schedule and budget constraints. Tis defnition \nencompasses a broad set of activities that are particular to specifc organizations. However, at \nthe core of every organization\u2019s management activities, quality is a focal point. Te quality\u00ad\n of \nsofware designs can be assessed in various ways. From the management\u2019s perspective, quality \nof sofware designs can be evaluated in terms of cost and scheduling. From the engineering \npoint of view, quality in designs can be evaluated using a set of well-known design principles \nas well as modeling and evaluating the quality attributes that the sofware must exhibit, which \nare specifed via nonfunctional, quality requirements. From the confguration management\u2019s \nperspective, design quality can be achieved through change management processes that con-\ntrol how designs are created, modifed, and improved. In\u00a0large-scale sofware projects, sof-\nware design management is essential to plan, organize, staf, track, and lead the activities \nrequired to carry out successfully the sofware architecture and detailed design steps.\nROLES OF THE SOFTWARE DESIGNER\nFrom the discussions provided so far, it should be evident that designers are not all equal. \nIn many design eforts, designers have diferent roles, with diferent titles and responsibili-\nties that focus on specifc design problems of the sofware system. Tere are many factors \nin place that determine the designer\u2019s role, including an engineer\u2019s work preference, expe-\nrience, and capabilities. When studying sofware design, it is important to understand \nhow these roles difer, the type of work performed, and capabilities required to perform \nthe activities required of each role. In some cases, sofware designers are heavily involved \nin the requirements and construction phases; therefore, they must have expertise not \nonly in design but also in requirements engineering and sofware construction. In other \ncases, a clear organizational delineation exists, allowing designers to focus on their area \nof \u00ad\nexpertise. A\u00a0list of typical designer roles is presented in Table\u00a01.6 (Giachetti 2010).\nTABLE\u00a01.6\nTypical Roles in Sofware Design\nDesigner\nDescription\nEnterprise architect\nDesigns the enterprise\u2019s strategy, processes, information, and organizational \nstructure\nSofware architect\nDesigns sofware systems using a black-box modeling approach; concern is placed \non the external properties of sofware components that determine the system\u2019s \nquality and support the further design of functional requirements\nComponent designer\nFocuses on designing the internal structure of sofware components identifed \nduring the sofware architecture phase; has strong programming skills\nUser Interface designer\nDesigns the sofware\u2019s user interface; skilled in determining ways that increase \nusability of the system\nSystem engineer\nDesigns systems using a holistic approach, which include designing how sofware \nand hardware collaborate to achieve the system\u2019s goals\n", "page": 44, "type": "text", "section": "Page 44"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 23\nSystems Engineer\nTe systems engineer designs the overall development process of systems as a whole, \nincluding processes for development of both the sofware and hardware that are part of the \nsystem. As a specialization of system engineering, sofware systems engineers design sof-\nware at the system level; in many cases, the work performed by sofware systems engineers \nis similar to that of a sofware architect. Systems engineers work closely with customers to \nprovide a holistic view of systems, their interfaces, and the distribution of requirements \nto subsystems. Sofware systems engineers are typically experts in the problem domain, \nand, depending on the type of system (e.g., embedded, web), they also develop expertise \non other nonsofware-related parts, such as hardware, communications, and avionics. Tis \nis essential at all phases of the sofware development process, since they must be able to \ncommunicate with other engineering disciplines, such as electrical, mechanical, and civil. \nIn this role, designers have typically accumulated experience in other design roles, such as \nsofware architecture, component design, and in some cases construction. In addition to \ntechnical skills, systems engineers are required to have strong leadership skills to ensure \nthe successful system development.\nSoftware Architect\nTe sofware architect is in charge of designing the sofware architecture. Sofware architects \ncan be found under a wide variety of titles, such as sofware lead, senior sofware engineer, \nor principal sofware engineer. Regardless of the title, sofware architects have extensive \nexperience architecting systems that meet their intended requirements. Experience is typi-\ncally acquired while moving up through the ranks, from sofware programmer all the way \nup to sofware architect. Sofware architects have strong leadership skills and are required \nto be skilled in initiation, communication, and negotiation. Tey also need to have a keen \nunderstanding of the developing organization to determine ways sofware systems can \ninfuence the organizational business goals and increase new business ventures leveraged \nfrom existing architectures. Other skills benefcial to sofware architects include project \nmanagement skills.\nComponent Designer\nComponent designers are highly noticeable during detailed and construction designs, \nsince they are typically the ones constructing the sofware. Terefore, they have strong \nprogramming skills and a strong foundation in design principles. For object-oriented com-\nponent designers, strong object-oriented skills including knowledge of design patterns are \nessential. Component designers create both static and dynamic models of the sofware \nsystem at levels appropriate to drive \u00ad\nconstruction; these include (when applicable) UML \nclass diagrams and sequence diagrams. Tey have deep knowledge and understanding of \nthe sofware requirements assigned to them; they are knowledgeable about other tools that \nsupport the design and development efort, such as modeling tools, integrated development \n", "page": 45, "type": "text", "section": "Page 45"}
{"text": "24\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\nenvironments, forward and reverse \u00ad\nengineering, and confguration management. When \ndesigning at the component level, component designers have a full understanding of style \nguides for the project, since they dictate \u00ad\nnaming, spacing, and commenting conventions \nand other aspects that shape the structure of code. Component designers devise construc-\ntion designs as needed and are profcient at creating efective unit tests that verify the \nquality of their product developed. Finally, component designers need to be comfort-\nable scheduling and conducting peer reviews and accepting feedback and evaluating it \n\u00ad\nobjectively to improve their designs.\nSOFTWARE DESIGN FUNDAMENTALS\nWithin the design process, many principles, considerations, and strategies help designers \nexecute the sofware design process in an efective and consistent manner. For the most \npart, these help designers manage and simplify problems, consider the impacts of their \nproposed solutions, and establish a foundation for decision making during design. In this \ncontext, design principles refer to knowledge matter that has been found efective through-\nout the years in multiple projects on diferent domains. Design principles are applicable on \nmost design projects; therefore, their use is expected to help achieve high-quality designs. \nOn the other hand, design considerations are recommendations that help designers in the \ndesign process; they may or may not be followed. Finally, design strategies consist of tacti-\ncal approaches in which design principles and considerations can be employed to drive the \ndesign process. Tese concepts are further discussed in the next sections.\nGeneral Software Design Principles\nTroughout the history of sofware engineering, many design principles have emerged \nto become fundamental drivers for decision making during the sofware design process. \nTese design principles are used as a basis for reasoning and serve as justifcation for almost \nall design decisions. Tey also provide designers with a foundation from which other more \nsophisticated design methods can be applied (Pressman 2010). Tese principles are not \nspecifc to any particular design strategy (e.g., object oriented) or process, so they are fun-\ndamental to all sofware design eforts and can be applied during architectural, detailed, \nand construction designs. Te principles include (Abran et al. 2005):\n\u2022\t Modularization\n\u2022\t Abstraction\n\u2022\t Encapsulation\n\u2022\t Coupling and cohesion\n\u2022\t Separation of interface and implementation\n\u2022\t Sufciency and completeness\n", "page": 46, "type": "text", "section": "Page 46"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 25\nModularization\nModularization is one of the most important (and perhaps oversimplifed) design prin-\nciples in sofware design. Modularity allows sofware systems to be manageable at all levels \nof the development life cycle. Tat is, the work products of the requirements, design, con-\nstruction, and testing eforts can all be modularized to efciently carry out the operations. \nIn\u00a0the design phase, modularization is the principle that drives the continuous decompo-\nsition of the sofware system until fne-grained components are created. Modularization \nplays a key role during all design activities, including sofware architecture and detailed \nand construction design; when applied efectively, it provides a roadmap for sofware \ndevelopment starting from coarse-grained components that are further modularized into \nfne-grained components directly related to code. If applied properly, modularization can \nlead to designs that are easier to understand, resulting in systems that are easier to develop \nand \u00ad\nmaintain. Efcient modularization can be achieved by following and applying the \nprinciples of abstraction and encapsulation. With proper modularization, sofware systems \ncan be decomposed into modules that allow the system\u2019s complexity to be manageable and \nallow the system to be efciently built, maintained, and reused.\nAbstraction\nWhile the principle of modularization specifes what needs to be done, the principle of \nabstraction provides the guidance as to how it should be done. Modularizing systems in \nan ad hoc manner leads to designs that are incoherent, hard to understand, and hard to \nmaintain. To modularize intelligently, a thorough understanding of abstraction is required \n(Liskov and Guttag 2010). Abstraction is the principle that deals with creating conceptual \nentities required to facilitate problem solving by focusing on essential characteristics of \nentities\u2014in their active context\u2014while deferring unnecessary details. When abstraction \nis applied, the level of detail required to think about a problem is adjusted to productively \nmodularize a system; this allows for the creation of coherent entities that can be used to \nrepresent their possible variations in the problem\u2019s context and domain. Te principle of \nabstraction can be applied iteratively at multiple levels during the design phase. At the sof-\nware architecture level, abstraction helps during the identifcation of sofware components \nand their interfaces. At the detailed design phase, abstraction helps identify the entities, \nfunctions, and interfaces required to realize the component\u2019s provided services. At the \nconstruction level, abstraction helps in the further design of functions identifed during \ndetailed design. In all of these, abstraction is used to facilitate problem-solving by defer-\nring details to later stages. Te principle of abstraction can be classifed as (Pressman 2010):\n\u2022\t Procedural abstraction\n\u2022\t Data abstraction\nProcedural abstraction is a specifc type of abstraction that simplifes behavioral \n\u00ad\noperations containing a sequence of steps or other procedural abstractions. For example, \n", "page": 47, "type": "text", "section": "Page 47"}
{"text": "26\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\nconsider a client\u2013server application in which the client sends data to the server through \nthe Internet. In this case, the Send procedural abstraction can be used to denote a series \nof operations, for example, retrieving the server\u2019s information (e.g., Internet Protocol [IP] \naddress, port number), opening a connection, sending the message, and closing the con-\nnection. On the other hand, data abstraction is used to simplify the structural composition \nof data objects. Using the previous example, the Message data abstraction can be used to \nrepresent various messages with diferent attributes, such as the message\u2019s ID, content, and \nformat. Te defnition of all of these properties can be deferred to later stages. Abstraction \nis fundamental for managing complexity in all activities of the sofware design phase.\nSkill Development 1.2: The Abstraction Principle\nTe world is full of abstractions; without abstractions, communicating with our peers \nwould be much more difcult. As an exercise, look for the nearest rectangular object \nthat contains a knob and (maybe) a keyhole; if the object is blocking an entrance, \nchange the state of the object so that it no longer blocks the entrance. Summarize this \nscenario by coming up with two abstractions: one data and the other procedural to \nincrease communication with peers. When done, create a list of four other abstractions \nthat surround you, and provide an abstraction as well as the detailed object description \nthat would be required if the abstraction is not used. Ensure that there are two data \nabstractions and two procedural abstractions. \nEncapsulation\nIn previous sections, modularization is presented as principle for decomposing mono-\nlithic systems into manageable units. While abstraction provides the principle for guid-\ning the decomposition of the systems based on behavior and data, encapsulation provides \nthe principle for enhancing the efciency of the collaboration among modularized units. \nEncapsulation is the principle that deals with providing access to the services of concep-\ntual entities (e.g., modules, components) by exposing only the information that is essential \nto carry out such services while hiding details of how the services are carried out. While \nabstraction is employed to fnd conceptual entities, encapsulation enforces that abstracted \nentities communicate between each other using a \u201cneed to know only\u201d basis. When evalu-\nated this way, the abstraction design principle helps create the modules and the encapsula-\ntion design principle enforces efcient communication between them. Tese principles are \nall essential in achieving efcient modularization. Te relationship among modulariza-\ntion, abstraction, and encapsulation is presented in Figure\u00a01.4. As seen, afer the principle \nof abstraction is applied, the encapsulation principle is used to hide irrelevant details from \nthe abstraction. In Figure\u00a01.4, the shaded region corresponds to information that is irrel-\nevant to other modules, while the white region corresponds to access points that modules \ncan use to interoperate.\n", "page": 48, "type": "text", "section": "Page 48"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 27\nCoupling\nSimilar to abstraction and encapsulation, coupling and cohesion are design principles that lead \nto efcient module creation by emphasizing on the degree of dependency and belonging of \nmodules, respectively. Formally, the IEEE (1990, p. 22) defnes coupling as\nTe manner and degree of interdependence between sofware modules. \nLike all other design principles discussed so far, coupling can be applied during sofware \narchitecture, detailed design, and construction design to measure the degree of depen-\ndency of design units, such as an architectural subsystem, a class in a detailed design\u2019s \nclass diagram, or a function in code. In other words, the coupling principle can be used \nto determine how much an architectural subsystem depends on other architectural sub\u00ad\nsystems, how much a class depends on other classes, and how much a function depends on \nother functions. When measuring coupling, the number of dependencies between design \nunits does not tell the whole story, since the nature of the dependencies plays an impor-\ntant role in decision making. For example, design units can depend on well-defned and \nstable interfaces, common data structures, and internal structure of other design units. \nIt\u00a0is not hard to support the idea that dependencies on well-defned and stable interfaces \nare less troublesome than dependencies on the internal structure of other design units. \nTree common types of coupling are\n\u2022\t Content coupling\n\u2022\t Common coupling\n\u2022\t Data coupling\nContent coupling represents the most severe type of coupling, since it refers to modules that \nmodify and rely on the internal details of other modules. Common coupling refers to depen-\ndencies based on a common access area, such as a global variable (IEEE 1990). When this \noccurs, changes to the global data area causes changes in all dependent modules. Tis type \nof coupling results in lesser severity than content coupling; however, it shares many of the \nundesired efects as content coupling. Finally, data coupling refers to the type of dependency \nAbstraction\nModularization \nEncapsulation\nMonolithic\nSystem\nModularized\nSystem \nFIGURE 1.4\nTe modularization, abstraction, and encapsulation principles.\n", "page": 49, "type": "text", "section": "Page 49"}
{"text": "28\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\nin which design units communicate with each other only through a set of data parameters. \nUnlike content coupling, data coupling does not depend on the internals of other design \nunits, and unlike common coupling it provides more control over the form of dependency. \nWhen dependency between modules relies on data parameters that are globally inaccessible, \ndesign units are shielded from undesired changes to the data by other design units. In all \ncases, a high degree of coupling gives rise to negative side efects. For example, as coupling \nincreases, reusability and manageability of the design units decrease since errors or changes \nto the independent unit propagate to all dependent units. In\u00a0other cases, when coupling \nincreases, so does the complexity of managing and maintaining design units. Other types \nof coupling include control coupling, hybrid coupling\u00ad\n, and pathological\u00ad\n coupling (IEEE 1990).\nCohesion\nWhile coupling gives insight to a design unit\u2019s degree of dependency, cohesion provides \ninsight into its strengths. Te IEEE (1990, p. 17) defnes cohesion as\nTe manner and degree to which the tasks performed by a single sofware module are related \nto one another.\nCohesion measures how well design units are put together for achieving a particular \npurpose and can be classifed based on the measurement approach as\n\u2022\t Functional cohesion\n\u2022\t Procedural (or sequential) cohesion\n\u2022\t Temporal cohesion\n\u2022\t Communication cohesion\nFunctional cohesion measures a design unit\u2019s strength by the degree to which its tasks, \noperations, or subunits all contribute to perform a single function. When the function \nto be performed has a single logical meaning, functional cohesion can be seen as a form \nof logical cohesion. A highly functionally cohesive module is one whose internal details \nwork toward achieving the same function. Functional cohesion is the most typical type \nof cohesion. Procedural cohesion measures the strength of a design unit by the degree to \nwhich its tasks work procedurally (in steps) to achieve the unit\u2019s purpose. Terefore, func-\ntional and procedural cohesion are not mutually exclusive; that is, modules can exhibit \nboth high functional and procedural cohesion. Temporal cohesion measures strength by \nthe degree to which all tasks in a design unit are performed at specifc times. Consider \na design unit responsible for carrying out the initialization of a system. Tis unit may \nbe responsible for performing a power-on self-test that may include memory tests, fle \nsystem\u00ad\n checks, and communication checks. Tese are all diferent functions but need to be \n\u00ad\nexecuted at the same time during initialization; therefore, the unit is temporally cohesive. \nFinally, \u00ad\ncommunication cohesion measures a unit\u2019s strength by the degree to which its tasks \nproduce\u00ad\n or consume the same data.\n", "page": 50, "type": "text", "section": "Page 50"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 29\nCohesion provides an important principle that measures how much design units that are \ngrouped together actually belong together based on diferent criteria. Cohesion can also \nbe seen at diferent levels of the design process. During the sofware architecture activity, \nlogical and communication cohesive modules are typical, whereas, during the detailed \nand construction design activities, functional, procedural, and temporal cohesiveness are \nmore expected. In all cases, highly cohesive modules increase reusability. An example of \nthe cohesion and coupling principles is presented in Figure\u00a01.5. As seen in the top part \nof the fgure, Module 1 performs three unrelated diferent tasks (i.e., Task 1, Task\u00a02, and \nTask 3), each requiring three independent subtasks. For example, Task 1 requires three \ndiferent subtasks, denoted by the labels Task 1.1, Task 1.2, and Task 1.3. As seen, Module\u00a01 \nhas dependencies to nine diferent unrelated tasks, which can translate to a high degree \nof coupling and low degree of cohesion. Te bottom part of Figure\u00a01.5 shows how the \nsystem is decomposed into three more cohesive units, each with lower coupling than \nthe original approach. In this case, the system is transformed to a modular system with \nhigher \u00ad\ncohesiveness and lower coupling. With this transformation, Module 1 now has fve \ndependencies and stronger functional cohesion. Modules 2 and 3 have lower coupling than \nModule 1 (both in its original and improve form) and are highly cohesive.\nSeparation of Interface and Implementation\nTe principle of separation of interface and implementation deals with creating modules \nin such way that a stable interface is identifed and separated from its implementation. \nTis design principle should not be confused with encapsulation. During encapsulation, \nModule 1 \nTask 1.1 \nTask 1.2 \nTask 1.3 \nTask 2.1 \nTask 2.2 \nTask 2.3 \nTask 3.1 \nTask 3.2 \nTask 3.3 \nModule 2 \nModule 3  \nModule 1 \nTask 1.1 \nTask 1.2\nTask 1.3 \nTask 2.1 \nTask 2.2 \nTask 2.3\nTask 3.1 \nTask 3.2 \nTask 3.3 \nFIGURE 1.5\nExample of principles of coupling and cohesion.\n", "page": 51, "type": "text", "section": "Page 51"}
{"text": "30\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\ninterfaces are created to provide public access to services provided by the design unit while \nhiding unnecessary details, which include implementation. While encapsulation dictates \nhiding the details of implementation, the principle of separation dictates their separation, so \nthat diferent implementation of the same interface can be swapped to provide modifed or \nnew behavior. Figure\u00a01.6 presents these concepts.\nAs seen, the bottom design units have separated interfaces; therefore, varied implemen-\ntations can be employed without changes to a unit\u2019s interface and, subsequently, to depen-\ndent units. Tere are many benefts from this principle, including increased extensibility, \nreusability, and maintainability. Since implementation is compartmentalized, new capa-\nbilities can be added simply by including a new variation of the implementation without \nchanges to old implementations. Also, in this way specifc implementations can be reused.\nCompleteness and Sufficiency\nTe principles of completeness and sufciency deal with efcient module creation. \nCompleteness is a characteristic that measures how well design units provide the required \nservices to achieve their intent. For example, during the detailed design activity, a commu-\nnication class can be considered complete for a particular application if it provides services \nfor establishing and terminating connections, sending and receiving messages. Missing \nany of these services would render the class incomplete. On the other hand, sufciency \nmeasures how well design units are at providing only the services that are sufcient for \nachieving their intent. Consider the same communication class, which can include services \nfor logging statistics, visualization of network activity, or any other capability applicable \nto the communication task. Although these capabilities enhance the class\u2019 service list, the \nclass is considered sufcient by providing the required services of opening/terminating \nconnections, sending, and receiving messages. Tat is, these sets of services are sufcient \nto achieve the unit\u2019s required functions, nothing more and nothing less.\nPractical Software Design Considerations\nDesign principles are well-known throughout the sofware engineering community and \nare applied in one way or another in most projects. However, other considerations need to \nSegregation of Interface\nand Implementation\nEncapsulation\nFIGURE 1.6\nPrinciple of segregation of interface and implementation.\n", "page": 52, "type": "text", "section": "Page 52"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 31\nbe made to provide the appropriate context in which these principles can be successfully \napplied for developing high-quality sofware systems. Tese considerations are discussed \nin the next sections.\nDesign for Minimizing Complexity\nDesign is about minimizing complexity. Every decision that is made during the design phase \nmust take into account reducing complexity (McConnell 2004). In fact, the majority of design \nprinciples (e.g., modularization, abstraction, encapsulation) are meant to reduce complexity \nin one way or another. By doing this, details of the problem solution can be pushed further \ndown the process, where they can be appropriately handled. As another example, consider \nHCI design: it is all about reducing complexity for the user. Finally, code design is about \nreducing complexity for other developers maintaining the sofware. As rule of thumb, when \nfaced with competing design options, always choose the one that minimizes complexity.\nDesign for Change\nAs stated before, sofware will change; therefore, design with extension in mind. Tere are \nnumerous reasons for this; for example, customers who like the sofware may want to extend \nits functionalities. On the other hand, customers who are discontent with the \u00ad\nsofware may \nwant to replace or remove functionality. In other cases, hardware changes may trigger a \nsofware change; advances in communications may cause sofware to change; or, simply, \nnewer, better sofware technology becomes available triggering a change of \u00ad\nsofware that \nintroduces no new functionality but a more maintainable development technology that \nis supported by current practices. In any case, sofware will change; therefore, its very \nown nature requires sofware designers to plan for the future. A variety of \u00ad\ntechniques is \n\u00ad\navailable during the detailed design phase to achieve this.\nSoftware Design Strategies\nTroughout the years, a wide variety of strategies for designing sofware has been \u00ad\nproposed. \nSome of these include structured design, object-oriented design, aspect-oriented design, \ndata component-based design, and data structure-based design. Two popular strategies are \ndiscussed in the following sections.\nStructured Design\nIn a broad context, structured design refers to any disciplined functional design approach \nwhere sofware systems are decomposed into independent, single-purpose modules, using \nan iterative top-down approach. Te main focus of structured design is on the functions \nthat systems need to provide, the decomposition of these functions, and the creation of \nmodules that incorporate these functions. Structured design approaches are typically \nemployed afer structured analysis, where the main purpose is to derive a structure chart \n", "page": 53, "type": "text", "section": "Page 53"}
{"text": "32\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\n(i.e., sofware architecture) from data fow diagrams. Structured design introduced many \nbenefts; for instance, by decomposing the system into independent, single-purpose \nmodules\u00ad\n, programs were simpler to understand, manage, code, debug, and reuse (Stevens \n1981). However, structured design does not address the issues of data abstraction and infor-\nmation hiding and \u201cis largely inappropriate for use with object-based and object-oriented \nprogramming languages\u201d (Booch 1994, p. 22).\nObject-Oriented Design\nUnlike structured design, which focuses on functional decomposition of systems, \nobject-oriented design focuses on object decomposition. Formally, the IEEE (1990, p. 51) \ndefnes object-oriented design as\nA design strategy in which a system or component is expressed in terms of objects and \n\u00ad\nconnections between those objects.\nObjects provide numerous capabilities that make them desirable for efciently designing \nsofware systems. For example, objects are capable of maintaining state information and \nprovide services that can be used independently or relative to the object\u2019s state. Terefore, \nthey are naturally good building blocks for creating good abstractions. Object-oriented \ndesigns also provide capabilities for inheritance and polymorphism, which provide vari-\nous advantages when designing complex and large-scale sofware systems. Inheritance \nallows designers to create families of objects capable of reusing each other\u2019s interfaces or \ninterfaces with implementations. While inheritance allows objects to inherit interfaces \nand implementations, polymorphism allows objects to change the behavior of inherited \ninterfaces\u00ad\n. Numerous design methods based on objects have been proposed. Today, the UP \nprovides a popular framework for object-oriented sofware engineering using UML.\nCHAPTER SUMMARY\nDesigns in sofware engineering are used to identify, evaluate, and specify the structural \nand behavioral characteristics of sofware systems that adhere to some specifcation. \nSofware designs provide blueprints that capture how sofware systems meet their required \nfunctions and how they are shaped to meet their intended quality. Formally, sofware engi-\nneering design is defned as the process of identifying, evaluating, validating, and specify-\ning the architectural, detailed, and construction models required to build sofware that \nmeets its intended functional and nonfunctional requirements and the result of such a pro-\ncess. Te\u00a0term sofware design is used interchangeably in practice as means to describe \nboth the process and product of sofware design. Troughout the design process, designers \nare constantly engaging in problem-solving activities that are fundamental to all modern \nengineering projects; therefore, they can be characterized as specialized problem solvers. \n", "page": 54, "type": "text", "section": "Page 54"}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 33\nTo ensure that all problem considerations are incorporated when solving design problems, \na holistic\u00ad\n problem-solving approach must be adopted, including all relevant concerns. \nSofware design provides numerous advantages from both product development and pro-\ncess; however, many challenges must be considered and addressed before sofware designs \ncan lead to complete and sufcient sofware models. In today\u2019s modern sofware systems, \nnumerous design principles, processes, strategies, and other factors afect how designers \n\u00ad\nexecute the sofware design phase. When equipped with the proper design foundation \nknowledge, an understanding of the designer\u2019s roles and responsibilities can be acquired; \nallowing \u00ad\ndesigners to become efective in designing large-scale sofware systems under a \nwide variety of challenging conditions.\nREVIEW QUESTIONS\n\t\n1.\tWhat is sofware engineering design, and why is it important?\n\t\n2.\tWhat are the three states of problem solving? Describe each and explain how they \napply to design problems?\n\t\n3.\tWhat are two types of thinking employed during problem solving? Provide an \n\u00ad\nexample of how they are applied to design problems.\n\t\n4.\tWhat is the diference between well-defned, ill-defned, and wicked problems and \nhow these problems can afect sofware design?\n\t\n5.\tWhat is the diference between an algorithm and a heuristic? Give examples of how \nboth approaches can be applied during the design phase?\n\t\n6.\tWhat is the holistic approach to problem solving? Explain.\n\t\n7.\tHow does design fts within the sofware engineering life cycle? Explain.\n\t\n8.\tWhat are the major activities of the sofware design phase, and how do they difer \nfrom one another?\n\t\n9.\tList and explain the challenges faced in sofware design.\n\t 10.\tWhy is important to emphasize on documentation and management activities \n\u00ad\nduring design?\n\t 11.\tCompare and contrast the following: interface design, user interface design, and \n\u00ad\nconstruction design.\n\t 12.\tWhat are the diferent roles of sofware designers? How do they difer?\n\t 13.\tExplain the diference between procedural and data abstraction.\n\t 14.\tWhat is content coupling, and how does it difer from other forms of coupling?\n\t 15.\tExplain in detail the concept of cohesion.\n\t 16.\tWhat do completeness and sufciency mean?\n\t 17.\tWhat is the diference among the principles of modularization, abstraction, encapsu-\nlation, and separation of interface and implementation? Provide an example of each.\n\t 18.\tCompare and contrast the structured design strategy with the object-oriented design \nstrategy.\n", "page": 55, "type": "text", "section": "Page 55"}
{"text": "34\u2002 \u2022\u2002 Sofware Engineering Design\ufeff\nREFERENCES\nAbran, Alain, James W. Moore, Pierre Bourque, and Robert Dupuis. Guide to the Sofware Engineering Body of \nKnowledge\u20142004 Version\u2014SWEBOK. Los Alamitos, CA: IEEE Computer Society Press, 2005.\nBass, Len, Paul Clements, and Rick Kazman. Sofware Architecture in Practice, 2d ed. Boston: Addison-Wesley, \n2003.\nBooch, Grady. Object-Oriented Analysis and Design with Applications, 2d ed. Santa Clara, CA: Addison-Wesley, \n1994.\nBrassard, Gilles, and Paul Bratley. Fundamentals of Algorithmics. Upper Saddle River, NJ: Prentice Hall, 1995.\nDowson, Mark. \u201cTe Ariane 5 Sofware Failure.\n\u201d ACM SIGSOFT Sofware Engineering Notes, March 1997.\nDym, Clive L., and Patrick Little. Engineering Design: A Project-Based Introduction. Hoboken, NJ: Wiley, 2008.\nFox, Christopher. Introduction to Sofware Engineering Design: Processes, Principles, and Patterns with UML2. \nBoston: Addison Wesley, 2006.\nGiachetti, Ronald E. Design of Enterprise Systems: Teory, Architecture, and Methods. Boca Raton, FL; CRC\u00a0Press, \n2010.\nGrifn, Ricky W. Management, 10th ed. Mayfeld Hts, Ohio: South-Western College Pub, 2010.\nHarrell, C., Biman K. Ghosh, and Royce O. Bowden. Simulation Using Promodel. New York: McGraw-Hill, 2004.\nIEEE. \u201cIEEE Recommended Practice for Sofware Design Descriptions.\u201d 1998. http://ieeexplore.ieee.org/xpl/\nfreeabs_all.jsp?arnumber=741934.\nIEEE. \u201cIEEE Standard Glossary of Sofware Engineering Terminology.\u201d IEEE, 1990. http://ieeexplore.ieee.org/\nxpl/freeabs_all.jsp?arnumber=159342.\nIEEE/ACM. Sofware Engineering 2004. August 23, 2004. Available at: http://sites.computer.org/ccse/\nSE2004Volume.pdf (accessed September 22, 2010).\nKershaw, T. C., and S. Ohlsson. \u201cMultiple Causes of Difculty in Insight: Te Case of the Nine-Dot Problem.\u201d \nJournal of Experimental Psychology: Learning, Memory, and Cognition 30:3\u201315, 2004.\nLaplante, Phillip A. Requirements Engineering for Sofware and Systems. Boca Raton, FL: Auerbach Publications, \n2009.\nLiskov, Barbara, and John Guttag. Program Development in Java: Abstraction, Specifcation, and Object-Oriented \nDesign. Boston: Addison-Wesley, 2000.\nMcConnell, Steve. Code Complete, 2d ed. Redmond, WA: Microsof Press, 2004.\nMeyers, Scott. Efective C++: 55 Ways to Improve Your Programs and Designs, 3d ed. Boston: Addison-Wesley, \n2005.\nU.S. General Accounting Ofce. (GAO). Patriot Missile Defense: Sofware Problem Led to System Failure at \nDhahran, Saudi Arabia. Washington, DC: U.S. Government Accountability Ofce, 1992.\nPlotnik, Rod, and Haig Kouyoumdjian. Introduction to Psychology, 9th ed. Wadsworth Publishing, 2010.\nPressman, Roger S. Sofware Engineering: A Practitioner\u2019s Approach, 7th ed. Belmont, CA: McGraw-Hill, 2010.\nSommerville, Ian. Sofware Engineering, 9th ed. Boston: Addison Wesley, 2010.\nStevens, Wayne P. Using Structured Design: How to Make Programs Simple, Changeable, Flexible and Reusable. \nHoboken, NJ: John Wiley & Sons, 1981.\n", "page": 56, "type": "text", "section": "Page 56"}
{"text": "References\n1 Chapter 1 - Introduction to Software\nEngineering Design\nAbran, Alain, James W. Moore, Pierre Bourque, and Robert\nDupuis. Guide to the So\ufffdware Engineering Body of\nKnowledge\u20142004 Version\u2014SWEBOK. Los Alamitos, CA: IEEE\nComputer Society Press, 2005.\nBass, Len, Paul Clements, and Rick Kazman. So\ufffdware\nArchitecture in Practice, 2d ed. Boston: Addison-Wesley,\n2003.\nBooch, Grady. Object-Oriented Analysis and Design with\nApplications, 2d ed. Santa Clara, CA: Addison-Wesley,\n1994.\nBrassard, Gilles, and Paul Bratley. Fundamentals of\nAlgorithmics. Upper Saddle River, NJ: Prentice Hall, 1995.\nDowson, Mark. \u201c e Ariane 5 So\ufffdware Failure.\u201d ACM SIGSOFT\nSo\ufffdware Engineering Notes, March 1997.\nDym, Clive L., and Patrick Little. Engineering Design: A\nProject-Based Introduction. Hoboken, NJ: Wiley, 2008.\nFox, Christopher. Introduction to So\ufffdware Engineering\nDesign: Processes, Principles, and Patterns with UML2.\nBoston: Addison Wesley, 2006.\nGiachetti, Ronald E. Design of Enterprise Systems: \ufffdeory,\nArchitecture, and Methods. Boca Raton, FL; CRC Press,\n2010.\nGri\ufffdn, Ricky W. Management, 10th ed. May\u00a5eld Hts, Ohio:\nSouth-Western College Pub, 2010.\nHarrell, C., Biman K. Ghosh, and Royce O. Bowden.\nSimulation Using Promodel. New York: McGraw-Hill, 2004.\nIEEE. \u201cIEEE Recommended Practice for So\ufffdware Design\nDescriptions.\u201d 1998. http://ieeexplore.ieee.org/xpl/\nfreeabs_all.jsp?arnumber=741934.\nIEEE. \u201cIEEE Standard Glossary of So\ufffdware Engineering\nTerminology.\u201d IEEE, 1990. http://ieeexplore.ieee.org/\nxpl/freeabs_all.jsp?arnumber=159342.\nIEEE/ACM. So\ufffdware Engineering 2004. August 23, 2004.\n", "page": 57, "type": "text", "section": "Page 57"}
{"text": "Available at: http://sites.computer.org/ccse/\nSE2004Volume.pdf (accessed September 22, 2010).\nKershaw, T. C., and S. Ohlsson. \u201cMultiple Causes of\nDi\ufffdculty in Insight: e Case of the Nine-Dot Problem.\u201d\nJournal of Experimental Psychology: Learning, Memory, and\nCognition 30:3\u201315, 2004.\nLaplante, Phillip A. Requirements Engineering for So\ufffdware\nand Systems. Boca Raton, FL: Auerbach Publications, 2009.\nLiskov, Barbara, and John Guttag. Program Development in\nJava: Abstraction, Specication, and Object-Oriented\nDesign. Boston: Addison-Wesley, 2000.\nMcConnell, Steve. Code Complete, 2d ed. Redmond, WA:\nMicroso\ufffd Press, 2004.\nMeyers, Scott. E\ufffdective C++: 55 Ways to Improve Your\nPrograms and Designs, 3d ed. Boston: Addison-Wesley, 2005.\nU.S. General Accounting O\ufffdce. (GAO). Patriot Missile\nDefense: So\ufffdware Problem Led to System Failure at Dhahran,\nSaudi Arabia. Washington, DC: U.S. Government\nAccountability O\ufffdce, 1992.\nPlotnik, Rod, and Haig Kouyoumdjian. Introduction to\nPsychology, 9th ed. Wadsworth Publishing, 2010.\nPressman, Roger S. So\ufffdware Engineering: A Practitioner\u2019s\nApproach, 7th ed. Belmont, CA: McGraw-Hill, 2010.\nSommerville, Ian. So\ufffdware Engineering, 9th ed. Boston:\nAddison Wesley, 2010.\nStevens, Wayne P. Using Structured Design: How to Make\nPrograms Simple, Changeable, Flexible and Reusable.\nHoboken, NJ: John Wiley & Sons, 1981.\n", "page": 58, "type": "text", "section": "Page 58"}
{"text": "2 Chapter 2 - Software Design with\nUnified Modeling Language\nBooch, Grady, Robert A. Maksimchuk, Michael W. Engle, Bobbi\nJ. Young, Jim Conallen, and Kelli A. Houston.\nObject-Oriented Analysis and Design with Applications.\nUpper Saddle River, NJ: Addison-Wesley Professional, 2007.\nBooch, Grady, James Rumbaugh, and Ivar Jacobson. \ufffde Unied\nModeling Language User Guide. Santa Clara, CA:\nAddison-Wesley, 2005.\nQian, Kai, Xiang Fu, Lixin Tao, Chong-Wei Xu, and Jorge L.\nDiaz-Herrera. So\ufffdware Architecture and Design Illuminated.\nSudbury, MA: Jones & Barlett, 2009.\n\u201cUML 2.3 Superstructure.\u201d Vers. 2.3. Object Management\nGroup. May 2010. Available from: http://www.omg.org.\n", "page": 59, "type": "text", "section": "Page 59"}
{"text": "3 Chapter 3 - Principles of Software\nArchitecture\nAbran, Alain, James W. Moore, Pierre Bourque, and Robert\nDupuis. Guide to the So\ufffdware Engineering Body of\nKnowledge\u20142004 Version\u2014SWEBOK. Los Alamitos, CA: IEEE\nComputer Society Press, 2005.\nBass, Len, Paul Clements, and Rick Kazman. So\ufffdware\nArchitecture in Practice, 2d ed. Boston: Addison-Wesley,\n2003.\nBuschmann, Frank, Regine Meunier, Hans Rohnert, Peter\nSommerlad, and Michael Stal. Pattern-Oriented So\ufffdware\nArchitecture: A System of Patterns. West Sussex, UK: Wiley,\n1996.\nClements, Paul, Rick Kazman, and Mark Klein. Evaluating\nSo\ufffdware Architectures. Santa Clara, CA: Addison Wesley,\n2001.\nGorton, Ian. Essential So\ufffdware Architecture. Heidelberg,\nGermany: Springer, 2011.\nHofmeister, C., R. Nord, and D. Soni. Applied So\ufffdware\nArchitecture. Boston: Addison-Wesley, 2000.\nKruchten, Philippe. \u201cArchitectural Blueprints\u2014 e \u201c4+1\u201d View\nModel of So\ufffdware Architecture.\u201d IEEE So\ufffdware 12, no. 6\n(1995): 42\u201350.\nLaplante, Phillip A. Requirements Engineering for So\ufffdware\nand Systems. Boca Raton, FL: Auerbach Publications, 2009.\nPressman, Roger S. So\ufffdware Engineering: A Practitioner\u2019s\nApproach, 7th ed. Chicago: McGraw-Hill, 2010.\nTaylor, Richard N., Nenad Medvidovic, and Eric M. Dashofy.\nSo\ufffdware Architecture: Foundations, \ufffdeory, and Practice.\nHoboken, NJ: Wiley, 2009.\n", "page": 60, "type": "text", "section": "Page 60"}
{"text": "4 Chapter 4 - Patterns and Styles in\nSoftware Architecture\nAlexander, Christopher, Sara Ishikawa, Murray Silverstein,\nMax Jacobson, Ingrid Fiksdahl-King, and Shlomo Angel. A\nPattern Language: Towns, Buildings, Construction. New York:\nOxford University Press, 1977.\nBass, Len, Paul Clements, and Rick Kazman. So\ufffdware\nArchitecture in Practice, 2d ed. Boston: Addison-Wesley,\n2003.\nBuschmann, Frank, Regine Meunier, Hans Rohnert, Peter\nSommerlad, and Michael Stal. Pattern-Oriented So\ufffdware\nArchitecture: A System of Patterns. West Sussex, UK: Wiley,\n1996.\nClements, Paul, Rick Kazman, and Mark Klein. Evaluating\nSo\ufffdware Architectures. Santa Clara, CA: Addison Wesley,\n2001.\nPressman, Roger S. So\ufffdware Engineering: A Practitioner\u2019s\nApproach, 7th ed. Belmont, CA: McGraw-Hill, 2010.\nQian, Kai, Xiang Fu, Lixin Tao, Chong-Wei Xu, and Jorge L.\nDiaz-Herrera. So\ufffdware Architecture and Design Illuminated.\nSudbury, MA: Jones & Barlett, 2009.\nTaylor, Richard N., Nenad Medvidovic, and Eric M. Dashofy.\nSo\ufffdware Architecture: Foundations, \ufffdeory, and Practice.\nHoboken, NJ: Wiley, 2009.\n", "page": 61, "type": "text", "section": "Page 61"}
{"text": "5 Chapter 5 - Principles of Detailed\nDesign\nBooch, Grady, James Rumbaugh, and Ivar Jacobson. \ufffde Unied\nModeling Langauge User Guide, 2d ed. AddisonWesley\nProfessional, 2005.\nBuschmann, Frank, Regine Meunier, Hans Rohnert, Peter\nSommerlad, and Michael Stal. Pattern-Oriented So\ufffdware\nArchitecture: A System of Patterns. West Sussex, UK: Wiley,\n1996.\nClements, Paul, Felix Bachmann, Len Bass, David Garlan,\nJames Ivers, Reed Little, Robert Nord, and Judith Sta\u00a8ord.\nDocumenting So\ufffdware Architectures. Boston, MA: Addison\nWesley, 2002.\nClements, Paul, Rick Kazman, and Mark Klein. Evaluating\nSo\ufffdware Architectures. Addison Wesley, 2001.\nDouglas, Bruce P. Doing Hard Time: Developing Real-Time\nSystems with UML, Objects, Frameworks, and Patterns.\nAddison-Wesley Professional, 1999.\nDouglass, Bruce P. Real-Time Design Patterns: Robust\nScalable Architecture for Real-Time Systems. Addison-Wesley\nProfessional, 2002.\nGamma, Erich, Richard Helm, Ralph Johnson, and John\nVlissides. Design Patterns: Elements of Reusable\nObject-Oriented So\ufffdware. Boston: Addison-Wesley, 1995.\nIEEE. \u201cIEEE Standard for Information Technology-Systems\nDesign-So\ufffdware Design Descriptions.\u201d 2009.\nIEEE. \u201cIEEE Standard Glossary of So\ufffdware Engineering\nTerminology.\u201d IEEE, 1990, p. 34.\n176 \nLiskov, Barbara, and John Guttag. Program Development in\nJava: Abstraction, Specication, and Object-Oriented\nDesign. Boston: Addison-Wesley, 2000.\nMarin, Robert C. Agile So\ufffdware Development: Principles,\nPatterns, and Practices. Upper Saddle River, NJ: Prentice\nHall, 2003.\nMeyer, Bertrand. Object-Oriented So\ufffdware Construction, 2d\ned. Upper Saddle River, NJ: Prentice Hall, 1997.\n", "page": 62, "type": "text", "section": "Page 62"}
{"text": "Ortega-Arjona, Jorge L. Patterns for Parallel So\ufffdware\nDesign. West Sussex, UK: Wiley, 2010.\nPressman, Roger S. So\ufffdware Engineering: A Practitioner\u2019s\nApproach, 7th ed. Chicago: McGraw-Hill, 2010.\nSommerville, Ian. So\ufffdware Engineering, 9th ed. Boston:\nAddison Wesley, 2010.\nTichy, Walter. Making So\ufffdware: What Really Works, and Why\nWe Believe It. Sebastopol, CA: O\u2019Reilly Media, 2010.\n\u201cUML 2.3 Superstructure.\u201d Vers. 2.3. Object Management\nGroup. May 2010. Available at: http://www.omg.org\nVermeulen, Allan, Felix Bachmann, Len Bass, David Garlan,\nJames Ivers, Reed Little, Robert Nord, and Judith Sta\u00a8ord.\ne Elements of Java Styles. Cambridge, UK: Cambridge\nUniversity Press, 2000.\nVora, Pawan. Web Application Design Patterns. Burlington,\nMA: Morgan Kaufmann, 2009.\n", "page": 63, "type": "text", "section": "Page 63"}
{"text": "8 Chapter 8 - Principles of Construction\nDesign\nAbran, Alain, James W. Moore, Pierre Bourque, and Robert\nDupuis. Guide to the So\ufffdware Engineering Body of\nKnowledge\u20142004 Version\u2014SWEBOK. Los Angeles, CA: IEEE\nComputer Society Press, 2005.\nBaldwin, Kenneth, Andrew Gray, and Trevor Misfeldt. \ufffde\nElements of C# Style. Cambridge, UK: Cambridge University\nPress, 2006.\nBooch, Grady, James Rumbaugh, and Ivar Jacobson. \ufffde Unied\nModeling Language User Guide, 2d ed.\nBoston: Addison-Wesley, 2005.\nCheckstyle 5.3. October 19, 2010. Available from:\nhttp://checkstyle.sourceforge.net/index.html (accessed\nMarch 11, 2011).\nCollar, Emilio Jr. \u201cAn Investigation of Programming Code\nTextbase Readability Based on a Cognitive Readability\nModel.\u201d PhD thesis, University of Colorado at Boulder,\n2005.\nFox, Christopher. Introduction to So\ufffdware Engineering\nDesign: Processes, Principles, and Patterns with UML2.\nBoston: Addison Wesley, 2006.\nGalin, Daniel. So\ufffdware Quality Assurance: From \ufffdeory to\nImplementation. Harlow, UK: Pearson Addison Wesley, 2003.\nHurley, Richard B. Decision Tables in So\ufffdware Engineering.\nNew York: Van Nostrand Reinhold, 1982.\nIEEE. \u201cIEEE Standard for Information Technology-Systems\nDesign-So\ufffdware Design Descriptions.\u201d 2009, p. 175.\nJones, Capers. Applied So\ufffdware Measurement: Global Analysis\nof Productivity and Quality, 3d ed. New York: McGraw-Hill\nOsborne Media, 2008.\nMcCabe, omas J. \u201cA Complexity Measure.\u201d IEEE Transactions\non So\ufffdware Engineering SE-2, no. 4 (1976): 308\u2013320.\nMcConnell, Steve. Code Complete, 2d ed. Redmond, WA:\nMicroso\ufffd Press, 2004.\nMeyer, Bertrand. Object-Oriented So\ufffdware Construction, 2d\ned. Upper Saddle River, NJ: Prentice Hall, 1997.\n", "page": 64, "type": "text", "section": "Page 64"}
{"text": "Mills, Harlan D. Mathematical Foundations for Structured\nProgramming. Gaithersburg, MD: IBM Federal Systems\nDivision, IBM Corporation, 1972.\nMisfeldt, Trevor, Gregory Bumgardner, and Andrew Gray. \ufffde\nElements of C++ Style. Cambridge, UK: Cambridge University\nPress, 2004.\nPressman, Roger S. So\ufffdware Engineering: A Practitioner\u2019s\nApproach, 7th ed. Chicago: McGraw-Hill, 2010.\nVermeulen, Allan, Scott W. Ambler, Greg Bumgardner, Eldon\nMetz, Trevor Misfeldt, Jim Shur, and Patrick ompson. \ufffde\nElements of Java Style. Cambridge, UK: Cambridge University\nPress, 2000.\n", "page": 65, "type": "text", "section": "Page 65"}
{"text": "9 Chapter 9 - Human\u2013Computer Interface\nDesign\nCarroll, J. M. \ufffde Nurnberg Funnell: Designing Minimalist\nInstruction for Practical Computer Skill. Cambridge, MA:\nMIT Press, 1990.\nCarroll, J. M., and P. Aaronson. \u201cLearning by Doing with\nSimulated Intelligent Help.\u201d Communications of the\nAssociation for Computing Machinery, 1998: 1064\u20131079.\nHix, D., and H. R. Hartson. Developing User Interfaces:\nEnsuring Usability Through Product & Process. New York:\nJohn Wiley & Sons, 1993.\nIEEE. \u201cIEEE Standard Glossary of So\ufffdware Engineering\nTerminology.\u201d 1990. http://ieeexplore.ieee.org/xpl/\nfreeabs_all.jsp?arnumber=159342.\nLewis, C., P. Polson, C. Wharton, and J. Rieman. \u201cTesting a\nWalkthrough Methodology for eory-Based Design of\nWalk-Up-and-Use Interfaces.\u201d Chi \u201990 Proceedings, 1990,\n235\u2013242.\nMcCrickard, D. S., C. M. Chewar, and J. Somervell. \u201cDesign,\nScience, and Engineering Topics? Teaching HCI with a\nUni\u00a5ed Method.\u201d Technical Symposium on Computer Science\nEducation (SigCSE\u201904). Norfolk, VA, 2004, 31\u201335.\nNielsen, J., and R. L. Mack. Usability Inspection Methods.\nNew York: John Wiley & Sons, 1994.\nNielsen, J., and R. Molich. \u201cHeuristic Evaluation of User\nInterfaces.\u201d Proc. ACM CHI\u201990 Conference, Seattle, 1990,\n249\u2013256.\nRosson, M. B., and J. M. Carroll. Usability Engineering:\nScenario-Based Development of Human\u2013Computer Interaction.\nSan Franciso: Morgan Kaufmann, 2002.\nScriven, M. \ufffde Methodology of Evaluation in Perspectives of\nCurriculum Evaluation. Chicago, IL: Rand McNally, 1967.\nSomervell, J., and D. S. McCrickard. \u201cBetter Discount\nEvaluation: Illustrating How Critical Parameters Support\nHeuristic Creation.\u201d Interacting with Computers: Special\nIssue on Social Impact of Emerging Technologies 17, no. 5\n(September 2005): 592\u2013612.\nVirzi, R. A., J. L. Sokolov, and D. Karis. \u201cUsability\n", "page": 66, "type": "text", "section": "Page 66"}
{"text": "Problem Identi\u00a5cation Using both Low- and High-Fidelity\nPrototypes.\u201d Proceedings of ACM CHI \u201996, British Columbia,\nCanada, 1996, 236\u2013243.\n", "page": 67, "type": "text", "section": "Page 67"}
{"text": "10 Chapter 10 - Software Design\nManagement, Leadership, and Ethics\nFisher, R., and W. Ury. Getting to Yes, 2d ed. New York:\nPenguin Books, 1991.\nGri\ufffdn, Ricky W. Management, 10th ed. Mason, OH:\nSouth-Western Publications, 2010.\nIEEE Computer Society. \u201cSo\ufffdware Engineering Code of Ethics\nand Professional Practice.\u201d 2010. Available at\nJudge, T. A., R. Ilies, J. E. Bono, and M. W. Gerhardt.\n\u201cPersonality and Leadership: A Qualitative and Quantitative\nReview.\u201d Journal of Applied Psychology 87, no. 4 (2002):\n765\u2013768.\nLi, Mei Yan, and Ying Zong Liu. \u201cStudy on Line Managers\u2019\nCompetence-Based Abilities of Performance Management.\u201d\nApplied Mechanics and Materials 40\u201341 (2010): 820\u2013824.\nLussier, Robert, and Christopher Achua. Leadership: \ufffdeory,\nApplication, & Skill Development, 4th ed. Florence, KY:\nCengage Learning, 2010.\nMeredith, Jack, and Samuel Mantel. Project Management: A\nManagerial Approach, 7th ed. Hoboken, NJ: John Wiley &\nSons, 2009.\nNebus, J. \u201cBuilding Collegial Information Networks: A eory\nof Advice Network Generation.\u201d Academy of Management\nReview 31, no. 3 (2006): 615\u2013637.\nPelosi, Marilyn K., and eresa M. Sandifer. Elementary\nStatistics: From Discovery to Decision. Hoboken, NJ: John\nWiley & Sons, 2003.\nSimkin, Mark. \u201c e Importance of Good Communication Skills\non \u2018IS\u2019 Career Paths.\u201d Journal of Technical Writing and\nCommunication 26, no. 1 (1996): 69\u201378.\nVeiga, J. F. \u201cSpecial Topic Ethical Behavior in Management,\nBringing Ethics into the Mainstream: An Introduction to\nthe Special Topic.\u201d Academy of Management Executive 18, no.\n2 (2004): 37\u201338.\n", "page": 68, "type": "text", "section": "Page 68"}
