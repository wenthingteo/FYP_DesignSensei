{"text": "Praise for Head First Design Patterns: \u201cI received the book yesterday and started to read it on the way home\u2026and I couldn\u2019t stop. I took it to \nthe gym and I expect people saw me smiling a lot while I was exercising and reading. This is tr\u00e8s \u2018cool\u2019. It is fun, but they cover a lot of ground and they are right to the point. I\u2019m really impressed.\u201d\n\t\n   \u2014  Erich Gamma, IBM Distinguished Engineer\n\t\n         and coauthor of Design Patterns with the rest of the\n\t\n         Gang of Four\u2014Richard Helm, Ralph Johnson, and John Vlissides\n\u201cHead First Design Patterns manages to mix fun, belly-laughs, insight, technical depth, and great practical \nadvice in one entertaining and thought-provoking read. Whether you are new to Design Patterns or have \nbeen using them for years, you are sure to get something from visiting Objectville.\u201d\n\t\n   \u2014  Richard Helm, coauthor of Design Patterns with the rest of the \n                       Gang of Four\u2014Erich Gamma, Ralph Johnson, and John Vlissides\n \u201cI feel like a thousand pounds of books have just been lifted off of my head.\u201d\n\t\n   \u2014  Ward Cunningham, inventor of the Wiki \n\t\n         and founder of the Hillside Group\n\u201cThis book is close to perfect, because of the way it combines expertise and readability. It speaks with \nauthority and it reads beautifully. It\u2019s one of the very few software books I\u2019ve ever read that strikes me as \nindispensable. (I\u2019d put maybe 10 books in this category, at the outside. )\u201d\n\t\n   \u2014  David Gelernter, Professor of Computer Science,  Yale University, \n\t\n         and author of Mirror Worlds and Machine Beauty\n\u201cA Nose Dive into the realm of patterns, a land where complex things become simple, but where simple \nthings can also become complex. I can think of no better tour guides than Eric and Elisabeth.\u201d\n\t\n   \u2014  Miko Matsumura, Industry Analyst, The Middleware Company\n\t\n         Former Chief Java Evangelist, Sun Microsystems\n\u201cI laughed, I cried, it moved me.\u201d\n\t\n   \u2014  Daniel Steinberg, Editor-in-Chief, java.net\n\u201cMy first reaction was to roll on the floor laughing. After I picked myself up, I realized that not only is the \nbook technically accurate, it is the easiest-to-understand introduction to Design Patterns that I have seen.\u201d\n\t\n   \u2014  Dr. Timothy A. Budd, Associate Professor of Computer Science at \n\t\n        Oregon State University and author of more than a dozen books, \n\t\n        including C++ for Java Programmers\n\u201cJerry Rice runs patterns better than any receiver in the NFL, but Eric and Elisabeth have outrun him.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 3", "position": 3, "chunk_type": "semantic", "token_estimate": 399}
{"text": "Praise for Head First Design Patterns: I can think of no better tour guides than Eric and Elisabeth.\u201d\n\t\n   \u2014  Miko Matsumura, Industry Analyst, The Middleware Company\n\t\n         Former Chief Java Evangelist, Sun Microsystems\n\u201cI laughed, I cried, it moved me.\u201d\n\t\n   \u2014  Daniel Steinberg, Editor-in-Chief, java.net\n\u201cMy first reaction was to roll on the floor laughing. After I picked myself up, I realized that not only is the \nbook technically accurate, it is the easiest-to-understand introduction to Design Patterns that I have seen.\u201d\n\t\n   \u2014  Dr. Timothy A. Budd, Associate Professor of Computer Science at \n\t\n        Oregon State University and author of more than a dozen books, \n\t\n        including C++ for Java Programmers\n\u201cJerry Rice runs patterns better than any receiver in the NFL, but Eric and Elisabeth have outrun him. Seriously\u2026this is one of the funniest and smartest books on software design I\u2019ve ever read.\u201d\n\t\n   \u2014 Aaron LaBerge, SVP Technology & Product Development, ESPN", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 3", "position": 3, "chunk_type": "semantic", "token_estimate": 150}
{"text": "\u201cGreat code design is, first and foremost, great information design. A code designer is teaching a: computer how to do something, and it is no surprise that a great teacher of computers should turn out \nto be a great teacher of programmers. This book\u2019s admirable clarity, humor, and substantial doses of \nclever make it the sort of book that helps even non-programmers think well about problem-solving.\u201d\n\t\n   \u2014 Cory Doctorow, coeditor of Boing Boing \n\t\n        and author of Down and Out in the Magic Kingdom\n\t\n        and Someone Comes to Town, Someone Leaves Town\n\u201cThere\u2019s an old saying in the computer and videogame business\u2014well, it can\u2019t be that old because the \ndiscipline is not all that old\u2014and it goes something like this: Design is Life. What\u2019s particularly curious \nabout this phrase is that even today almost no one who works at the craft of creating electronic games \ncan agree on what it means to \u2018design\u2019 a game. Is the designer a software engineer? An art director? A \nstoryteller? An architect or a builder? A pitch person or a visionary? Can an individual indeed be in \npart all of these? And most importantly, who the %$!#&* cares? It has been said that the \u2018designed by\u2019 credit in interactive entertainment is akin to the \u2018directed by\u2019 \ncredit in filmmaking, which in fact allows it to share DNA with perhaps the single most controversial, \noverstated, and too often entirely lacking in humility credit grab ever propagated on commercial art. Good company, eh? Yet if Design is Life, then perhaps it is time we spent some quality cycles thinking \nabout what it is. Eric Freeman and Elisabeth Robson have intrepidly volunteered to look behind the code curtain for \nus in Head First Design Patterns. I\u2019m not sure either of them cares all that much about the PlayStation \nor Xbox, nor should they. Yet they do address the notion of design at a significantly honest level such \nthat anyone looking for ego reinforcement of his or her own brilliant auteurship is best advised not to \ngo digging here where truth is stunningly revealed. Sophists and circus barkers need not apply. Next-\ngeneration literati, please come equipped with a pencil.\u201d\n\t\n   \u2014  Ken Goldstein, Executive Vice President & Managing Director, \n                      Disney Online\n\n\u201cThis is a difficult blurb for me to write since Eric and Elisabeth were my students a long time ago, so \nI don\u2019t want to be seen to be too drooling, but this is the best book on Design Patterns available for \nstudents.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 4", "position": 4, "chunk_type": "semantic", "token_estimate": 415}
{"text": "\u201cGreat code design is, first and foremost, great information design. A code designer is teaching a: Sophists and circus barkers need not apply. Next-\ngeneration literati, please come equipped with a pencil.\u201d\n\t\n   \u2014  Ken Goldstein, Executive Vice President & Managing Director, \n                      Disney Online\n\n\u201cThis is a difficult blurb for me to write since Eric and Elisabeth were my students a long time ago, so \nI don\u2019t want to be seen to be too drooling, but this is the best book on Design Patterns available for \nstudents. As proof: I have used it ever since it was published, in both in my grad and undergrad courses, \nboth for software engineering and advanced programming. As soon as it came out I abandoned the \nGang of Four as well as all competitors!\u201d\n\t\n   \u2014  Gregory Rawlins, Indiana University\n\n\u201cThis book combines good humor, great examples, and in-depth knowledge of Design Patterns in \nsuch a way that makes learning fun. Being in the entertainment technology industry, I am intrigued \nby the Hollywood Principle and the home theater Facade Pattern, to name a few. The understanding \nof Design Patterns not only helps us create reusable and maintainable quality software, but also \nhelps sharpen our problem-solving skills across all problem domains. This book is a must-read for all \ncomputer professionals and students.\u201d\n\t\n   \u2014  Newton Lee, Founder and Editor-in-Chief, Association for Computing \n\t\n        Machinery\u2019s (ACM) Computers in Entertainment (acmcie.org)\nMore Praise for Head First Design Patterns", "domains": ["Design Patterns", "Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 4", "position": 4, "chunk_type": "semantic", "token_estimate": 237}
{"text": "Intro: Your brain on Design Patterns. Here you are trying to learn something, \nwhile here your brain is doing you a favor by making sure the learning doesn\u2019t stick. Your \nbrain\u2019s thinking, \u201cBetter leave room for more important things, like which wild animals to \navoid and whether naked snowboarding is a bad idea.\u201d  So how do you trick your brain into \nthinking that your life depends on knowing Design Patterns? Who is this book for? xxvi\nWe know what you\u2019re thinking. xxvii\nAnd we know what your brain is thinking. xxvii\nWe think of a \u201cHead First\u201d reader as a learner. xxviii\nMetacognition: thinking about thinking\t\t\n\t\n\t\nxxix\nHere\u2019s what WE did\t\n\t\n\t\n\t\n\t\nxxx\nHere\u2019s what YOU can do to bend your brain into submission\t\nxxxi\nRead Me\t\t\n\t\n\t\n\t\n\t\n\t\nxxxii\nTech Reviewers\t\n\t\n\t\n\t\n\t\n\t\nxxxiv\nAcknowledgments\t \t\n\t\n\t\n\t\n\t\nxxxv\nTable of Contents (summary)\n          Intro\t\nxxv\n1 \t\nWelcome to Design Patterns:  intro to Design Patterns\t\n1\n2\t\nKeeping your Objects in the Know:  the Observer Pattern\t\n37\n3\t\nDecorating Objects:  the Decorator Pattern\t\n79\n4\t\nBaking with OO Goodness:  the Factory Pattern\t\n109\n5\t\nOne-of-a-Kind Objects:  the Singleton Pattern\t\n169\n6\t\nEncapsulating Invocation:  the Command Pattern\t\n191\n7\t\nBeing Adaptive:  the Adapter and Facade Patterns\t\n237\n8\t\nEncapsulating Algorithms:  theTemplate Method Pattern\t\n277\n9\t\nWell-Managed Collections:  the Iterator and Composite Patterns\t\n317\n10\t\nThe State of Things:  the State Pattern\t\n381\n11\t\nControlling Object Access:  the Proxy Pattern\t\n425\n12\t\nPatterns of Patterns: compound patterns\t\n493\n13\t\nPatterns in the Real World: better living with patterns\t\n563\n14\t\nAppendix:  Leftover Patterns\t\n597\n\t\nTable of Contents (the real thing)\ntable of contents", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 12", "position": 12, "chunk_type": "semantic", "token_estimate": 263}
{"text": "1: Welcome to Design Patterns\nSomeone has already solved your problems. In this \nchapter, you\u2019ll learn why (and how) you can exploit the wisdom and lessons \nlearned by other developers who\u2019ve been down the same design problem road \nand survived the trip. Before we\u2019re done, we\u2019ll look at the use and benefits \nof design patterns, look at some key object-oriented (OO) design principles, \nand walk through an example of how one pattern works. The best way to use \npatterns is to load your brain with them and then recognize places in your \ndesigns and existing applications where you can apply them. Instead of code \nreuse, with patterns you get experience reuse. intro to Design Patterns\nYour BRAIN\nYour Code, now new \nand improved with \ndesign patterns! A Bunch of Patterns\nswim()\ndisplay()\nperformQuack()\nperformFly()\nsetFlyBehavior()\nsetQuackBehavior()\n// OTHER duck-like methods\u2026\nDuck\nFlyBehavior flyBehavior;\nQuackBehavior quackBehavior;\n<<interface>>\nFlyBehavior\nfly()\nfly() {\n  // implements duck flying\n}\nFlyWithWings\nfly() {\n  // do nothing - can\u2019t fly!\n} FlyNoWay\n<<interface>>\nQuackBehavior\nquack()\nquack) {\n  // implements duck quack\u00ad\ning\n}\nQuack\nquack() {\n  // rubber duckie squeak\n}\nSqueak\nquack() {\n  // do nothing - can\u2019t quack!\n} MuteQuack\ndisplay() {\n// looks like a decoy duck }\nDecoy Duck\ndisplay() {\n// looks like a mal\u00ad\nlard }\nMallard Duck\ndisplay() {\n// looks like a redhead \n}\nRedhead Duck\ndisplay() {\n// looks like a rubberduck }\nRubber Duck\nEncapsulated fly behavior\nEncapsulated quack behavior\nClient \nView\nController\nModel\nRequest", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 13", "position": 13, "chunk_type": "semantic", "token_estimate": 249}
{"text": "u: b\nj\ne\nc\nt\n \nOb\nj\ne\nc\nt\n8\nint\n \n \n \nD\no\ng\n \nO\nb\nj\ne\nc\nt\nM\no\nu\ns\ne\n \nO\nb\njec\nt\n \n \nC\na\nt\n \nO\nb\nj\ne\nct\n \n \nD\nu\nc\nk\n \nO\nb\njec\nt\nObservers\n8\n8\n8\n8\nAutomatic update/notification\nObject that \nholds state\nDependent Objects", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 13", "position": 13, "chunk_type": "semantic", "token_estimate": 60}
{"text": "Remember, knowing: concepts like abstraction, \ninheritance, and polymorphism do \nnot make you a good object oriented \ndesigner. A design guru thinks \nabout how to create flexible \ndesigns that are maintainable \nand that can cope with \nchange. It started with a simple SimUDuck app\t\t\n\t\n2\nBut now we need the ducks to FLY\t\n\t\n\t\n3\nBut something went horribly wrong\u2026\t \t\n\t\n4\nJoe thinks about inheritance\u2026\t\n\t\n\t\n5\nHow about an interface? 6\nWhat would you do if you were Joe? 7\nThe one constant in software development\t\n\t\n8\nZeroing in on the problem\u2026\t\t\n\t\n\t\n9\nSeparating what changes from what stays the same\t\n10\nDesigning the Duck Behaviors\t\n\t\n\t\n11\nImplementing the Duck Behaviors\t\n\t\n\t\n13\nIntegrating the Duck Behavior\t\n\t\n\t\n15\nTesting the Duck code\t\n\t\n\t\n\t\n18\nSetting behavior dynamically\t\t\n\t\n\t\n20\nThe Big Picture on encapsulated behaviors\t\n\t\n22\nHAS-A can be better than IS-A\t\n\t\n\t\n23\nSpeaking of Design Patterns\u2026\t\n\t\n\t\n24\nOverheard at the local diner\u2026\t\n\t\n\t\n26\nOverheard in the next cubicle\u2026\t\n\t\n\t\n27\nThe power of a shared pattern vocabulary\t\n\t\n28\nHow do I use Design Patterns? 29\nTools for your Design Toolbox\t\n\t\n\t\n32", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 13", "position": 13, "chunk_type": "semantic", "token_estimate": 176}
{"text": "The Weather Monitoring application overview: 39\nMeet the Observer Pattern\t\n\t\n\t\n\t\n\t\n44\nPublishers + Subscribers = Observer Pattern\t\n\t\n\t\n45\nThe Observer Pattern defined\t\n\t\n\t\n\t\n51\nThe Power of Loose Coupling\t\n\t\n\t\n\t\n54\nDesigning the Weather Station\t\n\t\n\t\n\t\n57\nImplementing the Weather Station\t\n\t\n\t\n\t\n58\nPower up the Weather Station\t\n\t\n\t\n\t\n61\nLooking for the Observer Pattern in the Wild\t\n\t\n\t\n65\nCoding the life-changing application\t\n\t\n\t\n\t\n66\nMeanwhile, back at Weather-O-Rama\t \t\n\t\n\t\n69\nTest Drive the new code\t\n\t\n\t\n\t\n\t\n71\nTools for your Design Toolbox\t\n\t\n\t\n\t\n72\nDesign Principle Challenge\t\n\t\n\t\n\t\n\t\n73\n2\nKeeping your Objects in the Know\nYou don\u2019t want to miss out when something \ninteresting happens, do you? We\u2019ve got a pattern that keeps your \nobjects in the know when something they care about happens. It\u2019s the Observer \nPattern. It is one of the most commonly used design patterns, and it\u2019s incredibly \nuseful. We\u2019re going to look at all kinds of interesting aspects of Observer, like its \none-to-many relationships and loose coupling. And, with those concepts in mind, \nhow can you help but be the life of the Patterns Party? the Observer Pattern\nS\nu\nb\nj\ne\nc\nt\n \nOb\nj\ne\nc\nt\n8\nint\n \n \n \nD\no\ng\n \nO\nb\nj\ne\nc\nt\nM\no\nu\ns\ne\n \nO\nb\njec\nt\n \n \nC\na\nt\n \nO\nb\nj\ne\nct\n \n \nD\nu\nc\nk\n \nO\nb\njec\nt\nObservers\n8\n8\n8\n8", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 14", "position": 14, "chunk_type": "semantic", "token_estimate": 227}
{"text": "Automatic update/notification: Object that \nholds state\nDependent Objects\nAbstraction\nEncapsulation\nPolymorphism\nInheritence\nOO Basics\nEncapsulate what varies. Favor Composition over \ninheritance. Program to interfaces, not \nimplementations. Strive for loosely coupled \ndesigns between objects that \ninteract. OO Principles\ntable of contents", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 14", "position": 14, "chunk_type": "semantic", "token_estimate": 40}
{"text": "3: Decorating Objects\nJust call this chapter \u201cDesign Eye for the Inheritance \nGuy.\u201d We\u2019ll re-examine the typical overuse of inheritance and you\u2019ll learn how \nto decorate your classes at runtime using a form of object composition. Why? Once you know the techniques of decorating, you\u2019ll be able to give your (or \nsomeone else\u2019s) objects new responsibilities without making any code changes \nto the underlying classes. the Decorator Pattern\nI used to think real men \nsubclassed everything. That was until \nI learned the power of extension \nat runtime, rather than at compile \ntime. Now look at me! Welcome to Starbuzz Coffee\t \t\n\t\n\t\n80\nThe Open-Closed Principle\t \t\n\t\n\t\n86\nMeet the Decorator Pattern\t \t\n\t\n\t\n88\nConstructing a drink order with Decorators\t\n\t\n89\nThe Decorator Pattern defined\t\n\t\n\t\n91\nDecorating our Beverages\t\n\t\n\t\n\t\n92\nWriting the Starbuzz code\t\n\t\n\t\n\t\n95\nCoding beverages\t \t\n\t\n\t\n\t\n96\nCoding condiments\t\t\n\t\n\t\n\t\n97\nServing some coffees\t\n\t\n\t\n\t\n98\nReal-World Decorators: Java I/O\t\n\t\n\t\n100\nDecorating the java.io classes\t\t\n\t\n\t\n101\nWriting your own Java I/O Decorator\t \t\n\t\n102\nTest out your new Java I/O Decorator\t \t\n\t\n103\nTools for your Design Toolbox\t\n\t\n\t\n105", "domains": ["Design Patterns", "Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 15", "position": 15, "chunk_type": "semantic", "token_estimate": 172}
{"text": "4: Baking with OO Goodness\nGet ready to bake some loosely coupled OO designs. There is more to making objects than just using the new operator. You\u2019ll \nlearn that instantiation is an activity that shouldn\u2019t always be done in public \nand can often lead to coupling problems. And we don\u2019t want that, do we? Find out how Factory Patterns can help save you from embarrassing \ndependencies. the Factory Pattern\n<<interface>>\nClams\n<<interface>>\nCheese\n<<interface>>\nSauce\n<<interface>>\nDough\ncreatePizza()\nNYPizzaStore\nThinCrustDough\nMarinaraSauce\nReggianoCheese\nFrozenClams\nThickCrustDough\nPlumTomatoSauce\nMozzarella Cheese\nFreshClams\nEach factory produces a different \nimplementation for the family of products. The abstract PizzaIngredientFactory \nis the interface that defines how to \nmake a family of related products- \neverything we need to make a pizza. The clients of the Abstract \nFactory are the two \ninstances of our PizzaStore, \nNYPizzaStore and \nChicagoStylePizzaSore. The job of the concrete \npizza factories is to \nmake pizza ingredients. Each factory knows \nhow to create the right \nobjects for their region. createDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\n<<interface>>\nPizzaIngredientFactory\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\nNYPizzaIngredientFactory\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\nChicagoPizzaIngredientFactory\nIdentifying the aspects that vary\t\n\t\n\t\n\t\n112\nEncapsulating object creation\t\t\n\t\n\t\n\t\n114\nBuilding a simple pizza factory\t\n\t\n\t\n\t\n115\nThe Simple Factory defined\t \t\n\t\n\t\n\t\n117\nA framework for the pizza store\t\n\t\n\t\n\t\n120\nAllowing the subclasses to decide\t\n\t\n\t\n\t\n121\nDeclaring a factory method\t \t\n\t\n\t\n\t\n125\nIt\u2019s finally time to meet the Factory Method Pattern\t\n\t\n131\nView Creators and Products in Parallel\t \t\n\t\n\t\n132\nFactory Method Pattern defined\t\n\t\n\t\n\t\n134\nLooking at object dependencies\t\n\t\n\t\n\t\n138\nThe Dependency Inversion Principle\t\n\t\n\t\n\t\n139\nApplying the Principle\t\n\t\n\t\n\t\n\t\n140\nFamilies of ingredients\u2026\t\n\t\n\t\n\t\n\t\n145\nBuilding the ingredient factories\t\n\t\n\t\n\t\n146\nReworking the pizzas\u2026\t\n\t\n\t\n\t\n\t\n149\nRevisiting our pizza stores\t\n\t\n\t\n\t\n\t\n152\nWhat have we done? 153\nAbstract Factory Pattern defined\t\n\t\n\t\n\t\n156\nFactory Method and Abstract Factory compared\t \t\n\t\n160\nTools for your Design Toolbox\t\n\t\n\t\n\t\n162\ntable of contents", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 16", "position": 16, "chunk_type": "semantic", "token_estimate": 303}
{"text": "5: One-of-a-Kind Objects\nOur next stop is the Singleton Pattern, our ticket to \ncreating one-of-a-kind objects for which there is only \none instance, ever. You might be happy to know that of all patterns, \nthe Singleton is the simplest in terms of its class diagram; in fact, the diagram \nholds just a single class! But don\u2019t get too comfortable; despite its simplicity \nfrom a class design perspective, it\u2019s going to require some deep object-oriented \nthinking in its implementation. So put on that thinking cap, and let\u2019s get going. the Singleton Pattern\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it. OO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically. Decorators provide a flexible \nalternative to subclassing for extending \nfunctionality. Abstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes. Factory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate. Factory Method lets \na class defer instantiation to the \nsubclasses. Singleton - Ensure a class only has \none instance and provide a global point \nof access to it. Dissecting the classic Singleton Pattern implementation\t\n\t\n173\nThe Chocolate Factory\t\n\t\n\t\n\t\n\t\n175\nSingleton Pattern defined\t\n\t\n\t\n\t\n\t\n177\nHouston, we have a problem\t \t\n\t\n\t\n\t\n178\nDealing with multithreading\t \t\n\t\n\t\n\t\n180\nCan we improve multithreading? 181\nMeanwhile, back at the Chocolate Factory\u2026\t\n\t\n\t\n183\nTools for your Design Toolbox\t\n\t\n\t\n\t\n186\nHershey, PA", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 17", "position": 17, "chunk_type": "semantic", "token_estimate": 270}
{"text": "6: Encapsulating Invocation\nIn this chapter, we take encapsulation to a whole new \nlevel: we\u2019re going to encapsulate method invocation. That\u2019s right\u2014by encapsulating method invocation, we can crystallize pieces \nof computation so that the object invoking the computation doesn\u2019t need to \nworry about how to do things, it just uses our crystallized method to get it \ndone. We can also do some wickedly smart things with these encapsulated \nmethod invocations, like save them away for logging or reuse them to \nimplement undo functionality in our code. the Command Pattern\nI\u2019ll have a Burger \nwith Cheese and a Malt \nShake\nBurger with Cheese\n  Malt Shake\ncreateOrder()\ntakeOrder()\nBurger with Cheese\n  Malt Shake\norderUp()\nmakeBurger(), makeShake()\noutput\nThe Order consists of an order \nslip and the customer\u2019s menu \nitems that are written on it. The customer knows \nwhat he wants and \ncreates an order. The Waitress takes the Order, and when she \ngets around to it, she calls its orderUp() \nmethod to begin the Order\u2019s preparation. The Order has all \nthe instructions \nneeded to prepare \nthe meal. The \nOrder directs the \nShort Order Cook \nwith methods like \nmakeBurger(). The Short Order \nCook follows the \ninstructions of \nthe Order and \nproduces the meal. Start Here\nHome Automation or Bust\t\n\t\n\t\n\t\n\t\n192\nTaking a look at the vendor classes\t\n\t\n\t\n\t\n194\nA brief introduction to the Command Pattern\t\n\t\n\t\n197\nFrom the Diner to the Command Pattern\t\n\t\n\t\n201\nOur first command object\t\n\t\n\t\n\t\n\t\n203\nUsing the command object\t\n\t\n\t\n\t\n\t\n204\nAssigning Commands to slots\t\t\n\t\n\t\n\t\n209\nImplementing the Remote Control\t\n\t\n\t\n\t\n210\nImplementing the Commands\t\n\t\n\t\n\t\n211\nPutting the Remote Control through its paces\t\n\t\n\t\n212\nTime to write that documentation\u2026\t\n\t\n\t\n\t\n215\nWhat are we doing? 217\nTime to QA that Undo button! 220\nUsing state to implement Undo\t\n\t\n\t\n\t\n221\nAdding Undo to the Ceiling Fan commands\t\n\t\n\t\n222\nEvery remote needs a Party Mode! 225\nUsing a macro command\t\n\t\n\t\n\t\n\t\n226\nMore uses of the Command Pattern: queuing requests\t\n\t\n229\nMore uses of the Command Pattern: logging requests\t\n\t\n230\nCommand Pattern in the Real World\t\n\t\n\t\n\t\n231\nTools for your Design Toolbox\t\n\t\n\t\n\t\n233\ntable of contents", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 18", "position": 18, "chunk_type": "semantic", "token_estimate": 341}
{"text": "7: Being Adaptive\nIn this chapter we\u2019re going to attempt such impossible \nfeats as putting a square peg in a round hole. Sound \nimpossible? Not when we have Design Patterns. Remember the Decorator \nPattern? We wrapped objects to give them new responsibilities. Now we\u2019re \ngoing to wrap some objects with a different purpose: to make their interfaces look \nlike something they\u2019re not. Why would we do that? So we can adapt a design \nexpecting one interface to a class that implements a different interface. That\u2019s not \nall; while we\u2019re at it, we\u2019re going to look at another pattern that wraps objects to \nsimplify their interface. the Adapter and Facade Patterns\nAdaptee\nClient\nAdapter\nrequest()\ntranslatedRequest()\nThe Client is implemented \nagainst the target interface\nThe Adapter implements the \ntarget interface and holds an \ninstance of the Adaptee\ntarget interface\nadaptee \ninterface\nTurkey was the \nadaptee interface\nBritish Wall Outlet\nAC Power Adapter\nStandard AC Plug\nAdapters all around us\t\n\t\n\t\n\t\n\t\n238\nObject-oriented adapters\t\n\t\n\t\n\t\n\t\n239\nIf it walks like a duck and quacks like a duck, then it must\n might be a duck turkey wrapped with a duck adapter\u2026\t\n\t\n240\nTest drive the adapter\t\n\t\n\t\n\t\n\t\n242\nThe Adapter Pattern explained\t\n\t\n\t\n\t\n243\nAdapter Pattern defined\t\n\t\n\t\n\t\n\t\n245\nObject and class adapters\t\n\t\n\t\n\t\n\t\n246\nReal-world adapters\t\n\t\n\t\n\t\n\t\n250\nAdapting an Enumeration to an Iterator\t\n\t\n\t\n251\nHome Sweet Home Theater\t \t\n\t\n\t\n\t\n257\nWatching a movie (the hard way)\t\n\t\n\t\n\t\n258\nLights, Camera, Facade! 260\nConstructing your home theater facade\t\t\n\t\n\t\n263\nImplementing the simplified interface\t \t\n\t\n\t\n264\nTime to watch a movie (the easy way)\t \t\n\t\n\t\n265\nFacade Pattern defined\t\n\t\n\t\n\t\n\t\n266\nThe Principle of Least Knowledge\t\n\t\n\t\n\t\n267\nHow NOT to Win Friends and Influence Objects\t\t\n\t\n268\nThe Facade Pattern and the Principle of Least Knowledge\t \t\n271\nTools for your Design Toolbox\t\n\t\n\t\n\t\n272", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 19", "position": 19, "chunk_type": "semantic", "token_estimate": 287}
{"text": "8: Encapsulating Algorithms\nWe\u2019ve encapsulated object creation, method invocation, \ncomplex interfaces, ducks, pizzas\u2026what could be next? We\u2019re going to get down to encapsulating pieces of algorithms so that subclasses \ncan hook themselves right into a computation anytime they want. We\u2019re even \ngoing to learn about a design principle inspired by Hollywood. Let\u2019s get started\u2026\nthe Template Method Pattern\n1\nBoil some water\n2\n3\n4\nSteep the tea bag in the water\nPour tea in a cup\nAdd lemon\n1\nBoil some water\n2\n3\n4\nBrew the coffee grinds\nPour coffee in a cup\nAdd sugar and milk\n2\n4\nSteep the teabag in the water\nAdd lemon\nT\nea subclass\nCoffee subclass\n2\n4\nBrew the coffee grinds\nAdd sugar and milk\n1\nBoil some water\n2\n3\n4\nBrew\nPour beverage in a cup\nAdd condiments\nCaffeine Beverage\nTea\nCoffee\nCaffeine Beverage knows \nand controls the steps of \nthe recipe, and performs \nsteps 1 and 3 itself, but \nrelies on T\nea or Coffee \nto do steps 2 and 4. We\u2019ve recognized that \nthe two recipes are \nessentially the same, \nalthough some of the \nsteps require different \nimplementations. So \nwe\u2019ve  generalized the \nrecipe and placed it in \nthe base class. generalize\nrelies on \nsubclass for \nsome steps\ngeneralize\nrelies on \nsubclass for \nsome steps\nIt\u2019s time for some more caffeine\t\n\t\n\t\n\t\n278\nWhipping up some coffee and tea classes (in Java)\t\t\n\t\n279\nLet\u2019s abstract that Coffee and Tea\t\n\t\n\t\n\t\n282\nTaking the design further\u2026\t \t\n\t\n\t\n\t\n283\nAbstracting prepareRecipe()\t \t\n\t\n\t\n\t\n284\nWhat have we done? 287\nMeet the Template Method \t \t\n\t\n\t\n\t\n288\nWhat did the Template Method get us? 290\nTemplate Method Pattern defined\t\n\t\n\t\n\t\n291\nHooked on Template Method\u2026\t\n\t\n\t\n\t\n294\nUsing the hook\t\n\t\n\t\n\t\n\t\n\t\n295\nThe Hollywood Principle and Template Method\t \t\n\t\n299\nTemplate Methods in the Wild\t\n\t\n\t\n\t\n301\nSorting with Template Method\t\n\t\n\t\n\t\n302\nWe\u2019ve got some ducks to sort\u2026\t\n\t\n\t\n\t\n303\nWhat is compareTo()? 303\nComparing Ducks and Ducks\t\n\t\n\t\n\t\n\t\n304\nLet\u2019s sort some Ducks\t\n\t\n\t\n\t\n\t\n305\nThe making of the sorting duck machine\t\n\t\n\t\n306\nSwingin\u2019 with Frames\t\n\t\n\t\n\t\n\t\n308\nCustom Lists with AbstractList\t\n\t\n\t\n\t\n309\nTools for your Design Toolbox\t\n\t\n\t\n\t\n313\ntable of contents", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 20", "position": 20, "chunk_type": "semantic", "token_estimate": 346}
{"text": "9: Well-Managed Collections\nThere are lots of ways to stuff objects into a collection. Put them into an Array, a Stack, a List, a hash map\u2014take your pick. Each has its \nown advantages and tradeoffs. But at some point your clients are going to want \nto iterate over those objects, and when they do, are you going to show them your \nimplementation? We certainly hope not! That just wouldn\u2019t be professional. Well, you \ndon\u2019t have to risk your career; in this chapter you\u2019re going to see how you can allow \nyour clients to iterate through your objects without ever getting a peek at how you \nstore your objects. You\u2019re also going to learn how to create some super collections of \nobjects that can leap over some impressive data structures in a single bound. And if \nthat\u2019s not enough, you\u2019re also going to learn a thing or two about object responsibility. the Iterator and Composite Patterns\nP\na\nn\nc\na\nk\ne\nH\nou\ns\ne\nM\ne\nn\nu\n \n \nD\ni\nn\ne\nr\nM\ne\nn\nu\n \n \n \nC\na\nf\ne\nM\ne\nn\nu\n1\n2\n3\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nPancake Menu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\nCaf\u00e9 Menu\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nDiner Menu\nAll Menus\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nDessert Menu\nArray\nArrayList\nBreaking News: Objectville Diner and Objectville Pancake House Merge\t\n318\nCheck out the Menu Items\t\n\t\n\t\n\t\n\t\n\t\n319\nImplementing the spec: our first attempt\t\n\t\n\t\n\t\n323\nCan we encapsulate the iteration?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 21", "position": 21, "chunk_type": "semantic", "token_estimate": 366}
{"text": "9: And if \nthat\u2019s not enough, you\u2019re also going to learn a thing or two about object responsibility. the Iterator and Composite Patterns\nP\na\nn\nc\na\nk\ne\nH\nou\ns\ne\nM\ne\nn\nu\n \n \nD\ni\nn\ne\nr\nM\ne\nn\nu\n \n \n \nC\na\nf\ne\nM\ne\nn\nu\n1\n2\n3\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nPancake Menu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\nCaf\u00e9 Menu\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nDiner Menu\nAll Menus\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nDessert Menu\nArray\nArrayList\nBreaking News: Objectville Diner and Objectville Pancake House Merge\t\n318\nCheck out the Menu Items\t\n\t\n\t\n\t\n\t\n\t\n319\nImplementing the spec: our first attempt\t\n\t\n\t\n\t\n323\nCan we encapsulate the iteration? 325\nMeet the Iterator Pattern\t\n\t\n\t\n\t\n\t\n\t\n327\nAdding an Iterator to DinerMenu\t\n\t\n\t\n\t\n\t\n328\nReworking the DinerMenu with Iterator\t\n\t\n\t\n\t\n329\nFixing up the Waitress code\t \t\n\t\n\t\n\t\n\t\n330\nTesting our code\t\n\t\n\t\n\t\n\t\n\t\n\t\n331\nReviewing our current design\u2026\t\n\t\n\t\n\t\n\t\n333\nCleaning things up with java.util.Iterator\t\n\t\n\t\n\t\n335\nIterator Pattern defined\t\n\t\n\t\n\t\n\t\n\t\n338\nThe Iterator Pattern Structure\t\n\t\n\t\n\t\n\t\n339\nThe Single Responsibility Principle\t\n\t\n\t\n\t\n\t\n340\nMeet Java\u2019s Iterable interface\t\t\n\t\n\t\n\t\n\t\n343\nJava\u2019s enhanced for loop\t\n\t\n\t\n\t\n\t\n\t\n344\nTaking a look at the Caf\u00e9 Menu\t\n\t\n\t\n\t\n\t\n347\nIterators and Collections\t\n\t\n\t\n\t\n\t\n\t\n353\nIs the Waitress ready for prime time? 355\nThe Composite Pattern defined\t\n\t\n\t\n\t\n\t\n360\nDesigning Menus with Composite\t\n\t\n\t\n\t\n\t\n363\nImplementing MenuComponent\t\n\t\n\t\n\t\n\t\n364\nImplementing the MenuItem\t\t\n\t\n\t\n\t\n\t\n365\nImplementing the Composite Menu\t\n\t\n\t\n\t\n\t\n366\nNow for the test drive\u2026\t\n\t\n\t\n\t\n\t\n\t\n369\nTools for your Design Toolbox\t\n\t\n\t\n\t\n\t\n376", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 21", "position": 21, "chunk_type": "semantic", "token_estimate": 351}
{"text": "10: The State of Things\nA little-known fact: the Strategy and State Patterns were \ntwins separated at birth. You\u2019d think they\u2019d live similar lives, but the Strategy \nPattern went on to create a wildly successful business around interchangeable algorithms, \nwhile State took the perhaps more noble path of helping objects to control their behavior \nby changing their internal state. As different as their paths became, however, underneath \nyou\u2019ll find almost precisely the same design. How can that be? As you\u2019ll see, Strategy \nand State have very different intents. First, let\u2019s dig in and see what the State Pattern is all \nabout, and then we\u2019ll return to explore their relationship at the end of the chapter. the State Pattern\nMighty Gumball, Inc.\nWhere the Gumball Machine \nis Never Half Empty\nHere\u2019s the way we think the gumball machine controller needs to \nwork. We\u2019re hoping you can implement this in Java for us! We may \nbe adding more behavior in the future, so you need to keep the \ndesign as flexible and maintainable as possible! - Mighty Gumball Engineers\nOut of \nGumballs\n   Has \nQuarter\n   No \nQuarter\nGumball \n  Sold\ninserts quarter\nejects quarter\nturns crank\ndispense \ngumball\ngumballs = 0\ngumballs > 0\nJava Breakers\t\n\t\n\t\n\t\n\t\n382\nState machines 101 \t\n\t\n\t\n\t\n384\nWriting the code\t\n\t\n\t\n\t\n\t\n386\nIn-house testing\t\n\t\n\t\n\t\n\t\n388\nYou knew it was coming\u2026a change request! 390\nThe messy STATE of things\u2026\t\n\t\n\t\n392\nThe new design\t\n\t\n\t\n\t\n\t\n394\nDefining the State interfaces and classes\t\n\t\n\t\n395\nReworking the Gumball Machine\t\n\t\n\t\n398\nNow, let\u2019s look at the complete GumballMachine class\u2026\t\n399\nImplementing more states\t\n\t\n\t\n\t\n400\nThe State Pattern defined\t\n\t\n\t\n\t\n406\nWe still need to finish the Gumball 1 in 10 game\t \t\n409\nFinishing the game\t\t\n\t\n\t\n\t\n410\nDemo for the CEO of Mighty Gumball, Inc.\t\n\t\n411\nSanity check\u2026\t\n\t\n\t\n\t\n\t\n413\nWe almost forgot! 416\nTools for your Design Toolbox\t\n\t\n\t\n419\ntable of contents", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 22", "position": 22, "chunk_type": "semantic", "token_estimate": 303}
{"text": "11: Controlling Object Access\nEver play good cop, bad cop? You\u2019re the good cop and you provide \nall your services in a nice and friendly manner, but you don\u2019t want everyone asking \nyou for services, so you have the bad cop control access to you. That\u2019s what proxies \ndo: control and manage access. As you\u2019re going to see, there are lots of ways in \nwhich proxies stand in for the objects they proxy. Proxies have been known to haul \nentire method calls over the internet for their proxied objects; they\u2019ve also been \nknown to patiently stand in for some pretty lazy objects. the Proxy Pattern\n<<interface>>\nSubject\nrequest()\nRealSubject\nrequest()\nProxy\nrequest()\n<<interface>>\nInvocationHandler\ninvoke()\nInvocationHandler\nThe proxy now consists of two \nclasses. invoke()\nCoding the Monitor\t\n\t\n\t\n\t\n427\nTesting the Monitor\t\n\t\n\t\n\t\n428\nRemote methods 101\t\n\t\n\t\n\t\n433\nGetting the GumballMachine ready to be a remote service\t 446\nRegistering with the RMI registry\u2026\t\n\t\n\t\n448\nThe Proxy Pattern defined\t\n\t\n\t\n\t\n455\nGet ready for the Virtual Proxy\t\n\t\n\t\n457\nDesigning the Album Cover Virtual Proxy\t\n\t\n459\nWriting the Image Proxy\t\n\t\n\t\n\t\n460\nUsing the Java API\u2019s Proxy to create a protection proxy\t\n469\nGeeky Matchmaking in Objectville\t\n\t\n\t\n470\nThe Person implementation\t \t\n\t\n\t\n471\nFive-minute drama: protecting subjects\t\t\n\t\n473\nBig Picture: creating a Dynamic Proxy for the Person\t\n474\nThe Proxy Zoo\t\n\t\n\t\n\t\n\t\n482\nTools for your Design Toolbox\t\n\t\n\t\n485\nThe code for the Album Cover Viewer\t \t\n\t\n489", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 23", "position": 23, "chunk_type": "semantic", "token_estimate": 229}
{"text": "12: Patterns of Patterns\nWho would have ever guessed that Patterns could work \ntogether? You\u2019ve already witnessed the acrimonious Fireside Chats (and \nyou haven\u2019t even seen the Pattern Death Match pages that the editor forced us to \nremove from the book), so who would have thought patterns can actually get along \nwell together? Well, believe it or not, some of the most powerful OO designs use \nseveral patterns together. Get ready to take your pattern skills to the next level; it\u2019s \ntime for compound patterns. compound patterns\nWorking together\t \t\n\t\n\t\n\t\n494\nDuck reunion\t\n\t\n\t\n\t\n\t\n495\nWhat did we do? 517\nA bird\u2019s duck\u2019s-eye view: the class diagram\t\n\t\n518\nThe King of Compound Patterns\t\n\t\n\t\n520\nMeet Model-View-Controller\t\t\n\t\n\t\n523\nA closer look\u2026\t\n\t\n\t\n\t\n\t\n524\nUnderstanding MVC as a set of Patterns\t\n\t\n526\nUsing MVC to control the beat\u2026\t\n\t\n\t\n528\nBuilding the pieces\t \t\n\t\n\t\n\t\n531\nNow let\u2019s have a look at the concrete BeatModel class\t\n532\nThe View\t\n\t\n\t\n\t\n\t\n\t\n533\nImplementing the View\t\n\t\n\t\n\t\n534\nNow for the Controller\t\n\t\n\t\n\t\n536\nPutting it all together\u2026\t\n\t\n\t\n\t\n538\nExploring Strategy\t \t\n\t\n\t\n\t\n539\nAdapting the Model\t\n\t\n\t\n\t\n540\nAnd now for a test run\u2026\t\n\t\n\t\n\t\n542\nTools for your Design Toolbox\t\n\t\n\t\n545\nB\ne\na\nt\nM\no\nd\ne\nl\nController\nsetBPM()\ngetBPM()\non()\noff()\nClick on the \nincrease beat \nbutton\u2026\nThe controller asks \nthe model to update \nits BPM by one. View is notified that the \nBPM changed. It calls \ngetBPM() on the model state. Because the BPM is 120, the \nview gets a beat notification \nevery 1/2 second. The beat is set at 119 BPM and you \nwould like to increase it to 120. \u2026which results in the \ncontroller being invoked. The view is updated \nto 120 BPM. You see the beatbar \npulse every 1/2 second. View\nView\ntable of contents", "domains": ["Architectural Patterns and Styles", "Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 24", "position": 24, "chunk_type": "semantic", "token_estimate": 288}
{"text": "14: Appendix: Leftover Patterns\nNot everyone can be the most popular. A lot has changed in the \nlast 25+ years. Since Design Patterns: Elements of Reusable Object-Oriented \nSoftware first came out, developers have applied these patterns thousands of \ntimes. The patterns we summarize in this appendix are full-fledged, card-carrying, \nofficial GoF patterns, but aren\u2019t used as often as the patterns we\u2019ve explored so \nfar. But these patterns are awesome in their own right, and if your situation calls for \nthem, you should apply them with your head held high. Our goal in this appendix is \nto give you a high-level idea of what these patterns are all about. i\nIndex\n\t\n617\t\nBridge\t\n\t\n\t\n\t\n\t\n598\nBuilder\t \t\n\t\n\t\n\t\n600\nChain of Responsibility\t\n\t\n\t\n602\nFlyweight\t\n\t\n\t\n\t\n\t\n604\nInterpreter\t\n\t\n\t\n\t\n606\nMediator\t\t\n\t\n\t\n\t\n608\nMemento\t\n\t\n\t\n\t\n\t\n610\nPrototype\t\n\t\n\t\n\t\n\t\n612\nVisitor\t\n\t\n\t\n\t\n\t\n614\nVisitor\n  Client / \nTraverser\ngetState()\ngetState()\ngetState()\ngetState()\ngetState()\ngetHealthRating()\ngetCalories()\ngetProtein()\ngetCarbs()\nAll these composite \nclasses have to do is add \na getState() method \n(and not worry about \nexposing themselves). The Client asks \nthe Visitor to get \ninformation from the \nComposite structure\u2026 \nNew methods can be \nadded to the Visitor \nwithout affecting the \nComposite. The Visitor needs to be able to call \ngetState() across classes, and this is \nwhere you can add new methods for \nthe client to use. The Traverser knows how to \nguide the Visitor through \nthe Composite structure. MenuItem\nMenu\nIngredient\nMenuItem\nIngredient\ntable of contents", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 26", "position": 26, "chunk_type": "semantic", "token_estimate": 231}
{"text": "how to use this book: xxvi \nintro\nWho is this book for? 1\nDo you know Java (you don\u2019t need to be a guru) or \nanother object-oriented language? 2\nDo you want to learn, understand, remember, and \napply design patterns, including the OO design \nprinciples upon which design patterns are based? this book is for you. Who should probably back away from this book? 1\nAre you completely new to object-oriented \nprogramming? 4\nthis book is not for you. Are you afraid to try something different? Would \nyou rather have a root canal than mix stripes \nwith plaid? Do you believe that a technical book \ncan\u2019t be serious if object-oriented concepts are \nanthropomorphized? If you can answer \u201cyes\u201d to all of these:\nIf you can answer \u201cyes\u201d to any one of these:\n2\nAre you a kick-butt object-oriented designer/\ndeveloper looking for a reference book? [Note from marketing: this book is \nfor anyone with a credit card.] 3\nDo you prefer stimulating dinner party conversation \nto dry, dull, academic lectures? 3\nAre you an architect looking for enterprise design \npatterns? All our examples are in \nJava, but you should be \nable to understand the \nmain concepts of the \nbook if you know another \nobject-oriented language.", "domains": ["Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 28", "position": 28, "chunk_type": "semantic", "token_estimate": 205}
{"text": "the intro: you are here\u0017 xxvii\n\u201cHow can this be a serious programming book?\u201d\n\u201cWhat\u2019s with all the graphics?\u201d\n\u201cCan I actually learn it this way?\u201d\nWe know what you\u2019re thinking. Your brain craves novelty. It\u2019s always searching, scanning, waiting for \nsomething unusual. It was built that way, and it helps you stay alive. Today, you\u2019re less likely to be a tiger snack. But your brain\u2019s still looking. You just never know. So what does your brain do with all the routine, ordinary, normal things \nyou encounter? Everything it can to stop them from interfering with the \nbrain\u2019s real job\u2014recording things that matter. It doesn\u2019t bother saving \nthe boring things; they never make it past the \u201cthis is obviously not \nimportant\u201d filter. How does your brain know what\u2019s important? Suppose you\u2019re out for a day \nhike and a tiger jumps in front of you, what happens inside your head and \nbody? Neurons fire. Emotions crank up. Chemicals surge. And that\u2019s how your brain knows... This must be important! Don\u2019t forget it! But imagine you\u2019re at home, or in a library. It\u2019s a safe, warm, tiger-\nfree zone. You\u2019re studying. Getting ready for an exam. Or trying to \nlearn some tough technical topic your boss thinks will take a week, \nten days at the most. Just one problem. Your brain\u2019s trying to do you a big favor. It\u2019s \ntrying to make sure that this obviously non-important content doesn\u2019t \nclutter up scarce resources. Resources that are better spent storing \nthe really big things. Like tigers. Like the danger of fire. Like how \nyou should never again snowboard in shorts. And there\u2019s no simple way to tell your brain, \u201cHey brain, thank \nyou very much, but no matter how dull this book is, and how little \nI\u2019m registering on the emotional Richter scale right now, I really do \nwant you to keep this stuff around.\u201d\nAnd we know what your brain is thinking. Your brain thinks \nTHIS is important. Your brain thinks \nTHIS isn\u2019t worth \nsaving. Great. Only \n642 more dull, \ndry, boring pages.", "domains": ["Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 29", "position": 29, "chunk_type": "semantic", "token_estimate": 341}
{"text": "the intro: For \nexample, studies show that putting words within the pictures they describe (as opposed to \nsomewhere else in the page, like a caption or in the body text) causes your brain to try to \nmakes sense of how the words and picture relate, and this causes more neurons to fire. More neurons firing = more chances for your brain to get that this is something worth \npaying attention to, and possibly recording. A conversational style helps because people tend to pay more attention when they \nperceive that they\u2019re in a conversation, since they\u2019re expected to follow along and hold up \ntheir end. The amazing thing is, your brain doesn\u2019t necessarily care that the \u201cconversation\u201d \nis between you and a book! On the other hand, if the writing style is formal and dry, your \nbrain perceives it the same way you experience being lectured to while sitting in a roomful \nof passive attendees. No need to stay awake. But pictures and conversational style are just the beginning. I wonder how I \ncan trick my brain \ninto remembering \nthis stuff...", "domains": ["Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 31", "position": 31, "chunk_type": "semantic", "token_estimate": 180}
{"text": "Automatic update/notification: Object that \nholds state\nDependent Objects\nPuzzles", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 32", "position": 32, "chunk_type": "semantic", "token_estimate": 9}
{"text": "the intro: you are here\u0017 xxxiii\nThe redundancy is intentional and important. One distinct difference in a Head First book is that we want you to really get it. And we want \nyou to finish the book remembering what you\u2019ve learned. Most reference books don\u2019t have \nretention and recall as a goal, but this book is about learning, so you\u2019ll see some of the same \nconcepts come up more than once. The code examples are as lean as possible. Our readers tell us that it\u2019s frustrating to wade through 200 lines of code looking for the two \nlines they need to understand. Most examples in this book are shown within the smallest \npossible context, so that the part you\u2019re trying to learn is clear and simple. Don\u2019t expect \nall of the code to be robust, or even complete\u2014the examples are written specifically for \nlearning, and aren\u2019t always fully functional. In some cases, we haven\u2019t included all of the import statements needed, but we assume that \nif you\u2019re a Java programmer, you know that ArrayList is in java.util, for example. If the \nimports were not part of the normal core JSE API, we mention it. We\u2019ve also placed all the \nsource code on the web so you can download it. You\u2019ll find it at \nhttp://wickedlysmart.com/head-first-design-patterns. Also, for the sake of focusing on the learning side of the code, we did not put our classes \ninto packages (in other words, they\u2019re all in the Java default package). We don\u2019t recommend \nthis in the real world, and when you download the code examples from this book, you\u2019ll find \nthat all classes are in packages. The Brain Power exercises don\u2019t have answers. For some of them, there is no right answer, and for others, part of the learning experience \nof the Brain Power activities is for you to decide if and when your answers are right. In \nsome of the Brain Power exercises, you will find hints to point you in the right direction.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 35", "position": 35, "chunk_type": "semantic", "token_estimate": 330}
{"text": "how to use this book: xxxvi \nintro\nVery Special Thanks\nA very special thanks to Erich Gamma, who went far beyond the call of duty in reviewing this book (he even \ntook a draft with him on vacation). Erich, your interest in this book inspired us, and your thorough technical review \nimproved it immeasurably. Thanks as well to the entire Gang of Four for their support and interest, and for \nmaking a special appearance in Objectville. We are also indebted to Ward Cunningham and the patterns \ncommunity who created the Portland Pattern Repository\u2014an indispensable resource for us in writing this book. A big thank you to Mike Loukides, Mike Hendrickson, and Meghan Blanchette. Mike L. was with \nus every step of the way. Mike, your insightful feedback helped shape the book, and your encouragement kept us \nmoving ahead. Mike H., thanks for your persistence over five years in trying to get us to write a patterns book; we \nfinally did it and we\u2019re glad we waited for Head First. It takes a village to write a technical book: Bill Pugh and Ken Arnold gave us expert advice on Singleton. Joshua Marinacci provided rockin\u2019 Swing tips and advice. John Brewer\u2019s \u201cWhy a Duck?\u201d paper inspired \nSimUDuck (and we\u2019re glad he likes ducks too). Dan Friedman inspired the Little Singleton example. Daniel \nSteinberg acted as our \u201ctechnical liason\u201d and our emotional support network. Thanks to Apple\u2019s James \nDempsey for allowing us to use his MVC song. And thank you to Richard Warburton, who made sure our \nJava 8 code updates were up to snuff for this updated edition of the book. Last, a personal thank you to the Javaranch review team for their top-notch reviews and warm support. There\u2019s more of you in this book than you know. Writing a Head First book is a wild ride with two amazing tour guides: Kathy Sierra and Bert Bates. With \nKathy and Bert you throw out all book writing convention and enter a world full of storytelling, learning theory, \ncognitive science, and pop culture, where the reader always rules. At O\u2019Reilly: \nFirst and foremost, Mary Treseler is the superpower who makes everything happen and we are eternally grateful \nto her for all she does for O\u2019Reilly, Head First, and the authors. Melissa Duffield and Michele Cronin \ncleared many paths that made this second edition happen. Rachel Monaghan did an amazing copy edit, giving a \nnew sparkle to our text.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 38", "position": 38, "chunk_type": "semantic", "token_estimate": 405}
{"text": "6\u2003 \u2003 Chapter 1: inheritance is not the answer\ndisplay() \nfly()\nquack()\nMallardDuck\ndisplay()\nfly()\nquack()\nRedheadDuck\ndisplay()\nquack()\nRubberDuck\nswim()\ndisplay()\n// OTHER duck-like methods... Duck\ndisplay()\nDecoyDuck\nfly()\nFlyable\nquack()\nQuackable\nHow about an interface? Joe realized that inheritance probably wasn\u2019t the \nanswer, because he just got a memo that says that \nthe executives now want to update the product every \nsix months (in ways they haven\u2019t yet decided on). Joe \nknows the spec will keep changing and he\u2019ll be forced \nto look at and possibly override fly() and quack() for \nevery new Duck subclass that\u2019s ever added to the \nprogram... forever. So, he needs a cleaner way to have only some (but not \nall) of the duck types fly or quack. What do YOU think about this design? I could take the fly() out of the Duck \nsuperclass, and make a Flyable() interface \nwith a fly() method. That way, only the ducks \nthat are supposed to fly will implement that \ninterface and have a fly() method...and I might \nas well make a Quackable, too, since not all \nducks can quack.", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 44", "position": 44, "chunk_type": "semantic", "token_estimate": 182}
{"text": "you are here 4\u2003 \u2003 9: intro to design patterns\nSo we know using inheritance hasn\u2019t worked out very well, since \nthe duck behavior keeps changing across the subclasses, and it\u2019s not \nappropriate for all subclasses to have those behaviors. The Flyable \nand Quackable interface sounded promising at first\u2014only ducks that \nreally do fly will be Flyable, etc.\u2014except Java interfaces typically have \nno implementation code, so no code reuse. In either case, whenever \nyou need to modify a behavior, you\u2019re often forced to track down and \nchange it in all the different subclasses where that behavior is defined, \nprobably introducing new bugs along the way! Luckily, there\u2019s a design principle for just this situation. Zeroing in on the problem... In other words, if you\u2019ve got some aspect of your code that is \nchanging, say with every new requirement, then you know you\u2019ve \ngot a behavior that needs to be pulled out and separated from all \nthe stuff that doesn\u2019t change. Here\u2019s another way to think about this principle: take the parts \nthat vary and encapsulate them, so that later you can \nalter or extend the parts that vary without affecting \nthose that don\u2019t. As simple as this concept is, it forms the basis for almost every \ndesign pattern. All patterns provide a way to let some part of  a \nsystem vary independently of  all other parts. Okay, time to pull the duck behavior out of the Duck classes! Take what varies and \n\u201cencapsulate\u201d it so it \nwon\u2019t affect the rest of \nyour code. The result? Fewer \nunintended consequences \nfrom code changes and \nmore f \nlexibility in your \nsystems! Design Principle\nIdentify the aspects of your \napplication that vary and separate \nthem from what stays the same. The first of many design \nprinciples. We\u2019ll spend more time \non these throughout the book.", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 47", "position": 47, "chunk_type": "semantic", "token_estimate": 300}
{"text": "you are here 4\u2003 \u2003 11: intro to design patterns\nSo how are we going to design the set of classes that \nimplement the fly and quack behaviors? We\u2019d like to keep things flexible; after all, it was the inflexibility in \nthe duck behaviors that got us into trouble in the first place. And we \nknow that we want to assign behaviors to the instances of Duck. For \nexample, we might want to instantiate a new MallardDuck instance \nand initialize it with a specific type of flying behavior. And while \nwe\u2019re there, why not make sure that we can change the behavior of a \nduck dynamically? In other words, we should include behavior setter \nmethods in the Duck classes so that we can change the MallardDuck\u2019s \nflying behavior at runtime. Given these goals, let\u2019s look at our second design principle:\nDesigning the Duck Behaviors\nDesign Principle\nProgram to an interface, not an \nimplementation. We\u2019ll use an interface to represent each behavior\u2014for instance, \nFlyBehavior and QuackBehavior\u2014and each implementation of a \nbehavior will implement one of those interfaces. So this time it won\u2019t be the Duck classes that will implement the \nflying and quacking interfaces. Instead, we\u2019ll make a set of classes \nwhose entire reason for living is to represent a behavior (for example, \n\u201csqueaking\u201d), and it\u2019s the behavior class, rather than the Duck class, \nthat will implement the behavior interface. This is in contrast to the way we were doing things before, where \na behavior came either from a concrete implementation in the \nsuperclass Duck, or by providing a specialized implementation in the \nsubclass itself. In both cases we were relying on an implementation. We \nwere locked into using that specific implementation and there was no \nroom for changing the behavior (other than writing more code). With our new design, the Duck subclasses will use a behavior \nrepresented by an interface (FlyBehavior and QuackBehavior), so that \nthe actual implementation of the behavior (in other words, the specific \nconcrete behavior coded in the class that implements the FlyBehavior \nor QuackBehavior) won\u2019t be locked into the Duck subclass. From now on, the Duck \nbehaviors will live in \na separate class\u2014a \nclass that implements \na particular behavior \ninterface. That way, the Duck \nclasses won\u2019t need \nto know any of the \nimplementation details \nfor their own behaviors. <<interface>>\nFlyBehavior\nfly()\nfly() {\n  // implements duck flying\n}\nFlyWithWings\nfly() {\n  // do nothing - can\u2019t fly!\n} FlyNoWay", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 49", "position": 49, "chunk_type": "semantic", "token_estimate": 402}
{"text": "12\u2003 \u2003 Chapter 1: program to an interface\nThe word interface is overloaded here. There\u2019s the concept of an \ninterface, but there\u2019s also the Java construct of an interface. You \ncan program to an interface without having to actually use a Java \ninterface. The point is to exploit polymorphism by programming \nto a supertype so that the actual runtime object isn\u2019t locked into \nthe code. And we could rephrase \u201cprogram to a supertype\u201d as \n\u201cthe declared type of the variables should be a supertype, usually \nan abstract class or interface, so that the objects assigned to \nthose variables can be of any concrete implementation of the \nsupertype, which means the class declaring them doesn\u2019t have to \nknow about the actual object types!\u201d\nThis is probably old news to you, but just to make sure we\u2019re \nall saying the same thing, here\u2019s a simple example of using a \npolymorphic type\u2014imagine an abstract class Animal, with two \nconcrete implementations, Dog and Cat. Programming to an implementation would be:\nBut programming to an interface/supertype would be:\n\nEven better, rather than hardcoding the instantiation of the \nsubtype (like new Dog()) into the code, assign the concrete \nimplementation object at runtime:\n\u201cProgram to an interface\u201d really means \n\u201cProgram to a supertype.\u201d\nmakeSound()\nAnimal\nmakeSound() {\n    bark();\n}\nbark() { // bark sound }\nDog\nmakeSound() {\n   meow();\n}\nmeow() { // meow sound }\nCat\nAbstract supertype (could \nbe an abstract class OR \ninterface). Concrete\nimplementations. Declaring the variable \u201cd\u201d as type \nDog (a concrete implementation \nof Animal) forces us to code to a \nconcrete implementation. We know it\u2019s a Dog, but \nwe can now use the animal \nreference polymorphically. We don\u2019t know WHAT the actual \nanimal subtype is...all we care about \nis that it knows how to respond to \nmakeSound(). Dog d = new Dog();\nd.bark();\nAnimal animal = new Dog();\nanimal.makeSound();\na = getAnimal();\na.makeSound(); \nI don\u2019t see why you \nhave to use an interface for \nFlyBehavior. You can do the \nsame thing with an abstract \nsuperclass. Isn\u2019t the whole point \nto use polymorphism?", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 50", "position": 50, "chunk_type": "semantic", "token_estimate": 340}
{"text": "you are here 4\u2003 \u2003 13: intro to design patterns\nFlyBehavior is an interface \nthat all flying classes implement. All new flying classes just need \nto implement the fly() method. Here\u2019s the implementation \nof flying for all ducks \nthat have wings. And here\u2019s the implementation \nfor all ducks that can\u2019t fly. Quacks that \nreally quack. Quacks that squeak. Quacks that make \nno sound at all. Same thing here for the quack \nbehavior; we have an interface \nthat just includes a quack() \nmethod that needs to be \nimplemented. <<interface>>\nFlyBehavior\nfly()\nfly() {\n  // implements duck flying\n}\nFlyWithWings\nfly() {\n  // do nothing - can\u2019t fly!\n} FlyNoWay\n<<interface>>\nQuackBehavior\nquack()\nquack() {\n  // implements duck quacking\n}\nQuack\nquack() {\n  // rubber duckie squeak\n}\nSqueak\nquack() {\n  // do nothing - can\u2019t quack!\n} MuteQuack\nImplementing the Duck Behaviors\nHere we have the two interfaces, FlyBehavior and QuackBehavior, along with \nthe corresponding classes that implement each concrete behavior:\nSo we get the benefit of \nREUSE without all the \nbaggage that comes along \nwith inheritance. With this design, other types of objects can \nreuse our fly and quack behaviors because \nthese behaviors are no longer hidden away \nin our Duck classes! And we can add new behaviors without \nmodifying any of our existing behavior \nclasses or touching any of the Duck classes \nthat use flying behaviors.", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 51", "position": 51, "chunk_type": "semantic", "token_estimate": 226}
{"text": "14\u2003 \u2003 Chapter 1: behavior in a class\nAnswers: \n1) Create a FlyRocketPowered \nclass that implements the \nFlyBehavior interface. 2) One example, a duck call (a \ndevice that makes duck sounds). Using our new design, what would you do if you needed \nto add rocket-powered flying to the SimUDuck app? 1\nCan you think of a class that might want to use the Quack \nbehavior that isn\u2019t a duck? 2\nQ: Do I always have to implement my \napplication first, see where things are \nchanging, and then go back to separate \nand encapsulate those things? A: Not always; often when you are \ndesigning an application, you anticipate \nthose areas that are going to vary and then \ngo ahead and build the flexibility to deal \nwith it into your code. You\u2019ll find that the \nprinciples and patterns can be applied at any \nstage of the development lifecycle. Q: Should we make Duck an interface \ntoo? A: Not in this case. As you\u2019ll see once \nwe\u2019ve got everything hooked together, we do \nbenefit by having Duck not be an interface, \nand having specific ducks, like MallardDuck, \ninherit common properties and methods. Now that we\u2019ve removed what varies from \nthe Duck inheritance, we get the benefits of \nthis structure without the problems. Q: It feels a little weird to have a class \nthat\u2019s just a behavior. Aren\u2019t classes \nsupposed to represent things? Aren\u2019t \nclasses supposed to have both state AND \nbehavior? A: In an OO system, yes, classes \nrepresent things that generally have both \nstate (instance variables) and methods. And in this case, the thing happens to be \na behavior. But even a behavior can still \nhave state and methods; a flying behavior \nmight have instance variables representing \nthe attributes for the flying (wing beats per \nminute, max altitude, speed, etc.) behavior.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 52", "position": 52, "chunk_type": "semantic", "token_estimate": 298}
{"text": "you are here 4\u2003 \u2003 15: intro to design patterns\nHere\u2019s the key: A Duck will now delegate its flying and \nquacking behaviors, instead of using quacking and \nflying methods defined in the Duck class (or subclass). Here\u2019s how:\npublic abstract class Duck {\n   QuackBehavior quackBehavior;\n   // more\n   public void performQuack() {\n     quackBehavior.quack();\n   }\n}\nIntegrating the Duck Behaviors\nFirst we\u2019ll add two instance variables of type FlyBehavior and \nQuackBehavior\u2014let\u2019s call them flyBehavior and quackBehavior. Each concrete duck \nobject will assign to those variables a specific behavior at runtime, like FlyWithWings for \nflying and Squeak for quacking. We\u2019ll also remove the fly() and quack() methods from the Duck class (and any subclasses) \nbecause we\u2019ve moved this behavior out into the FlyBehavior and QuackBehavior classes. We\u2019ll replace fly() and quack() in the Duck class with two similar methods, called \nperformFly() and performQuack(); you\u2019ll see how they work next. 1\n2\nThese methods replace \nfly() and quack(). Instance variables hold a reference \nto a specific behavior at runtime. Now we implement performQuack():\nperformQuack()\nswim()\ndisplay()\nperformFly()\n// OTHER duck-like methods... Duck\nFlyBehavior  flyBehavior\nQuackBehavior  quackBehavior\nDuck Behaviors\nQ\nu\na\nc\nk\ni\nn\ng\n \nB\ne\nh\navio\nr\ns\nF\nl\ny\ni\nn\ng\n \nB\ne\nh\na\nv\niors\nRather than handling the quack \nbehavior itself, the Duck object \ndelegates that behavior to the object \nreferenced by quackBehavior. Pretty simple, huh? To perform the quack, a Duck just asks the object that \nis referenced by quackBehavior to quack for it. In this part of the code we \ndon\u2019t care what kind of object the concrete Duck is, all we care about is \nthat it knows how to quack()! Each Duck has a reference to something that \nimplements the QuackBehavior interface. The behavior variables are \ndeclared as the behavior \nINTERFACE type.", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 53", "position": 53, "chunk_type": "semantic", "token_estimate": 301}
{"text": "you are here 4\u2003 \u2003 17: intro to design patterns\nGood catch, that\u2019s exactly what we\u2019re doing... \nfor now. Later in the book we\u2019ll have more patterns in \nour toolbox that can help us fix it. Still, notice that while we are setting the \nbehaviors to concrete classes (by instantiating \na behavior class like Quack or FlyWithWings \nand assigning it to our behavior reference \nvariable), we could easily change that at \nruntime. So, we still have a lot of flexibility here. That \nsaid, we\u2019re doing a poor job of initializing \nthe instance variables in a flexible way. But \nthink about it: since the quackBehavior \ninstance variable is an interface type, we \ncould (through the magic of polymorphism) \ndynamically assign a different QuackBehavior \nimplementation class at runtime. Take a moment and think about how you \nwould implement a duck so that its behavior \ncould change at runtime. (You\u2019ll see the code \nthat does this a few pages from now.) Wait a second, didn\u2019t you \nsay we should NOT program to an \nimplementation? But what are we doing in that \nconstructor? We\u2019re making a new instance of a \nconcrete Quack implementation class!", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 55", "position": 55, "chunk_type": "semantic", "token_estimate": 189}
{"text": "18\u2003 \u2003 Chapter 1: testing duck behaviors\nTesting the Duck code\nType and compile the Duck class below (Duck.java), and the \nMallardDuck class from two pages back (MallardDuck.java). 1\npublic abstract class Duck {\n   FlyBehavior flyBehavior;\n   QuackBehavior quackBehavior;\n   public Duck() { }\t\n\t\n \n   public abstract void display();\n   public void performFly() {\n      flyBehavior.fly();\n   }\n   public void performQuack() {\n      quackBehavior.quack();\n   } \n   public void swim() {\n      System.out.println(\"All ducks float, even decoys! \");\n   }\n}\nDeclare two reference \nvariables for the behavior \ninterface types. All duck \nsubclasses (in the same \npackage) inherit these. Delegate to the behavior class. Type and compile the FlyBehavior interface (FlyBehavior.java) \nand the two behavior implementation classes (FlyWithWings.java \nand FlyNoWay.java). 2\npublic interface FlyBehavior {\n   public void fly();\n}\npublic class FlyWithWings implements FlyBehavior { \n \n \n   public void fly() {\n\t\nSystem.out.println(\"I'm flying!! \");\n   }\n}\npublic class FlyNoWay implements FlyBehavior {\n   public void fly() {\n       System.out.println(\"I can't fly\");\n   }\n}\nThe interface that all flying \nbehavior classes implement. Flying behavior implementation \nfor ducks that DO fly... Flying behavior implementation \nfor ducks that do NOT fly (like \nrubber ducks and decoy ducks).", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 56", "position": 56, "chunk_type": "semantic", "token_estimate": 178}
{"text": "you are here 4\u2003 \u2003 19: intro to design patterns\nFile  Edit   Window  Help  Yadayadayada\n%java MiniDuckSimulator\nQuack\nI\u2019m flying!! public class MiniDuckSimulator {\n   public static void main(String[] args) {\n      Duck mallard = new MallardDuck();\n      mallard.performQuack();\n      mallard.performFly();\n   }\n}\n5\nRun the code! This calls the MallardDuck\u2019s inherited \nperformQuack() method, which then delegates to \nthe object\u2019s QuackBehavior (i.e., calls quack() on \nthe duck\u2019s inherited quackBehavior reference). Then we do the same thing with MallardDuck\u2019s \ninherited performFly() method. Type and compile the test class \n(MiniDuckSimulator.java). 4\nTesting the Duck code, continued... Type and compile the QuackBehavior interface \n(QuackBehavior.java) and the three behavior implementation \nclasses (Quack.java, MuteQuack.java, and Squeak.java). 3\npublic interface QuackBehavior {\n   public void quack();\n}\npublic class Quack implements QuackBehavior {\n   public void quack() {\n      System.out.println(\"Quack\");\n   }\n}\npublic class MuteQuack implements QuackBehavior {\n   public void quack() {\n\t\nSystem.out.println(\"<< Silence >>\");\n   }\n}\npublic class Squeak implements QuackBehavior {\n   public void quack() {\n\t\nSystem.out.println(\"Squeak\");\n   }\n}", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 57", "position": 57, "chunk_type": "semantic", "token_estimate": 156}
{"text": "22\u2003 \u2003 Chapter 1: the big picture\nBelow is the entire reworked class structure. We have everything you\u2019d expect: \nducks extending Duck, fly behaviors implementing FlyBehavior, and quack \nbehaviors implementing QuackBehavior. Notice also that we\u2019ve started to describe things a little differently. Instead \nof thinking of the duck behaviors as a set of  behaviors, we\u2019ll start thinking of \nthem as a family of  algorithms. Think about it: in the SimUDuck design, the \nalgorithms represent things a duck would do (different ways of quacking or \nflying), but we could just as easily use the same techniques for a set of classes \nthat implement the ways to compute state sales tax by different states. Pay careful attention to the relationships between the classes. In fact, grab \nyour pen and write the appropriate relationship (IS-A, HAS-A, and \nIMPLEMENTS) on each arrow in the class diagram. The Big Picture on encapsulated behaviors\nOkay, now that we\u2019ve done the deep dive on the \nduck simulator design, it\u2019s time to come back up \nfor air and take a look at the big picture. swim()\ndisplay()\nperformQuack()\nperformFly()\nsetFlyBehavior()\nsetQuackBehavior()\n// OTHER duck-like methods... Duck\nFlyBehavior flyBehavior\nQuackBehavior quackBehavior\n<<interface>>\nFlyBehavior\nfly()\nfly() {\n  // implements duck flying\n}\nFlyWithWings\nfly() {\n  // do nothing - can\u2019t fly!\n} FlyNoWay\n<<interface>>\nQuackBehavior\nquack()\nquack() {\n  // implements duck quacking\n}\nQuack\nquack() {\n  // rubber duckie squeak\n}\nSqueak\nquack() {\n  // do nothing - can\u2019t quack!\n} MuteQuack\ndisplay() {\n// looks like a decoy duck }\nDecoyDuck\ndisplay() {\n// looks like a mallard }\nMallardDuck\ndisplay() {\n// looks like a redhead }\nRedheadDuck\ndisplay() {\n// looks like a rubberduck }\nRubberDuck\nEncapsulated fly behavior\nEncapsulated quack behavior\nThink of each \nset of behaviors \nas a family of \nalgorithms. Client \nThese behaviors \n\u201calgorithms\u201d are \ninterchangeable. Client makes use of an \nencapsulated family of algorithms \nfor both flying and quacking. Make sure you do this.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 60", "position": 60, "chunk_type": "semantic", "token_estimate": 320}
{"text": "you are here 4\u2003 \u2003 23: intro to design patterns\nThe HAS-A relationship is an interesting one: each duck \nhas a FlyBehavior and a QuackBehavior to which it \ndelegates flying and quacking. When you put two classes together like this you\u2019re using \ncomposition. Instead of inheriting their behavior, the \nducks get their behavior by being composed with the right \nbehavior object. This is an important technique; in fact, it is the basis of our \nthird design principle:\nDesign Principle\nFavor composition over inheritance. As you\u2019ve seen, creating systems using composition gives you \na lot more flexibility. Not only does it let you encapsulate \na family of algorithms into their own set of classes, but it \nalso lets you change behavior at runtime as long as \nthe object you\u2019re composing with implements the correct \nbehavior interface. Composition is used in many design patterns and you\u2019ll see a \nlot more about its advantages and disadvantages throughout \nthe book. Guru and Student...\nGuru: Tell me what you \nhave learned of the \nObject-Oriented ways. Student: Guru, I have \nlearned that the promise of the object-\noriented way is reuse. Guru: Continue...\nStudent: Guru, through inheritance all \ngood things may be reused and so we \ncome to drastically cut development \ntime like we swiftly cut bamboo in the \nwoods. Guru: Is more time spent on code \nbefore or after development is \ncomplete? Student: The answer is after, \nGuru. We always spend more time \nmaintaining and changing software \nthan on initial development. Guru: So, should effort go into reuse \nabove maintainability and extensibility? Student: Guru, I believe that there is \ntruth in this. Guru: I can see that you still have \nmuch to learn. I would like for you to \ngo and meditate on inheritance further. As you\u2019ve seen, inheritance has its \nproblems, and there are other ways of \nachieving reuse. HAS-A can be better than IS-A\nA duck call is a device that hunters use to \nmimic the calls (quacks) of ducks. How \nwould you implement your own duck call \nthat does not inherit from the Duck class?", "domains": ["Design Principles", "Software Quality Attributes", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 61", "position": 61, "chunk_type": "semantic", "token_estimate": 342}
{"text": "24\u2003 \u2003 Chapter 1: the strategy pattern\nCongratulations on \nyour first pattern! You just applied your first design pattern\u2014the STRATEGY \nPattern. That\u2019s right, you used the Strategy Pattern to \nrework the SimUDuck app. Thanks to this pattern, the simulator is ready for any \nchanges those execs might cook up on their next \nbusiness trip to Maui. Now that we\u2019ve made you take the long road to learn it, \nhere\u2019s the formal definition of this pattern:\nThe Strategy Pattern defines a family of algorithms, \nencapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from \nclients that use it. Speaking of Design Patterns...\nUse THIS definition when you \nneed to impress friends and \ninfluence key executives.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 62", "position": 62, "chunk_type": "semantic", "token_estimate": 117}
{"text": "you are here 4\u2003 \u2003 25: intro to design patterns\nBelow you\u2019ll find a mess of classes and interfaces for an action adventure game. You\u2019ll \nfind classes for game characters along with classes for weapon behaviors the characters \ncan use in the game. Each character can make use of one weapon at a time, but can \nchange weapons at any time during the game. Your job is to sort it all out...\n(Answers are at the end of the chapter.) Character\nWeaponBehavior weapon\nsetWeapon(WeaponBehavior w) {\n    this.weapon = w;\n}\nfight()\nKnifeBehavior\nuseWeapon() { // implements \ncutting with a knife }\nQueen\nfight() { ... }\nKing\nfight() { ... }\nTroll\nfight() { ... }\nBowAndArrowBehavior\nuseWeapon() { // implements \nshooting an arrow with a bow }\nKnight\nfight() { ... }\n<<interface>>\nWeaponBehavior\nuseWeapon();\nAxeBehavior\nuseWeapon() { // implements \nchopping with an axe }\nSwordBehavior\nuseWeapon() { // implements \nswinging a sword }\n1. Arrange the classes. 2. Identify one abstract class, one interface, and eight classes. 3. Draw arrows between classes. a. Draw this kind of arrow for inheritance (\u201cextends\u201d). b. Draw this kind of arrow for interface (\u201cimplements\u201d). c. Draw this kind of arrow for HAS-A. 4. Put the method setWeapon() into the right class. 1\n2\n3\n4\nYour task:\n Design Puzzle", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 63", "position": 63, "chunk_type": "semantic", "token_estimate": 216}
{"text": "you are here 4\u2003 \u2003 27: intro to design patterns\nOverheard in the next cubicle...\nRick\nCan you think of other shared \nvocabularies that are used \nbeyond OO design and diner \ntalk? (Hint: how about auto \nmechanics, carpenters, gourmet \nchefs, and air traffic controllers?) What qualities are communicated \nalong with the lingo? Can you think of aspects of OO \ndesign that get communicated \nalong with pattern names? What \nqualities get communicated along \nwith the name \u201cStrategy Pattern\u201d? So I created this broadcast class. It keeps \ntrack of all the objects listening to it, and \nanytime a new piece of data comes along it sends \na  message to each listener. What\u2019s cool is that the \nlisteners can join the broadcast at any time or \nthey can even remove themselves. It is really \ndynamic and loosely coupled! Exactly. If you communicate \nin patterns, then other developers \nknow immediately and precisely the \ndesign you\u2019re describing. Just don\u2019t \nget Pattern Fever...you\u2019ll know you \nhave it when you start using patterns \nfor Hello World...\nRick, why didn\u2019t you \njust say you are using \nthe Observer Pattern?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 65", "position": 65, "chunk_type": "semantic", "token_estimate": 180}
{"text": "28\u2003 \u2003 Chapter 1: shared vocabulary\nShared pattern vocabularies are POWERFUL. When you communicate with another developer or your \nteam using patterns, you are communicating not just a \npattern name but a whole set of qualities, characteristics, \nand constraints that the pattern represents. Patterns allow you to say more with less. When you \nuse a pattern in a description, other developers quickly \nknow precisely the design you have in mind. Talking at the pattern level allows you to stay \u201cin \nthe design\u201d longer. Talking about software systems using \npatterns allows you to keep the discussion at the design \nlevel, without having to dive down to the nitty-gritty details \nof implementing objects and classes. Shared vocabularies can turbo-charge your \ndevelopment team. A team well versed in design \npatterns can move more quickly with less room for \nmisunderstanding. Shared vocabularies encourage more  junior \ndevelopers to get up to speed. Junior developers look \nup to experienced developers. When senior developers \nmake use of design patterns, junior developers also become \nmotivated to learn them. Build a community of pattern \nusers at your organization. The power of a shared pattern vocabulary\nWhen you communicate using patterns, you \nare doing more than just sharing LINGO. \u201cWe\u2019re using the Strategy Pattern to \nimplement the various behaviors of our \nducks.\u201d This tells you the duck behavior \nhas been encapsulated into its own set \nof classes that can be easily expanded \nand changed, even at runtime if needed. How many design meetings have you \nbeen in that quickly degrade into \nimplementation details? Think about starting a patterns \nstudy group at your organization. Maybe you can even get paid while \nyou\u2019re learning...\nAs your team begins to share \ndesign ideas and experience in \nterms of patterns, you will build \na community of pattern users.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 66", "position": 66, "chunk_type": "semantic", "token_estimate": 293}
{"text": "you are here 4\u2003 \u2003 29: intro to design patterns\nWe\u2019ve all used off-the-shelf libraries and frameworks. We take them, write some code against their APIs, \ncompile them into our programs, and benefit from a lot of code someone else has written. Think about \nthe Java APIs and all the functionality they give you: network, GUI, IO, etc. Libraries and frameworks go \na long way toward a development model where we can just pick and choose components and plug them \nright in. But...they don\u2019t help us structure our own applications in ways that are easier to understand, more \nmaintainable, and more flexible. That\u2019s where design patterns come in. Design patterns don\u2019t go directly into your code, they first go into your BRAIN. Once you\u2019ve loaded your \nbrain with a good working knowledge of patterns, you can then start to apply them to your new designs, \nand rework your old code when you find it\u2019s degrading into an inflexible mess. How do I use Design Patterns? Your BRAIN\nYour Code, now new \nand improved with \ndesign patterns! A Bunch of Patterns\nswim()\ndisplay()\nperformQuack()\nperformFly()\nsetFlyBehavior()\nsetQuackBehavior()\n// OTHER duck-like methods... Duck\nFlyBehavior flyBehavior;\nQuackBehavior quackBehavior;\n<<interface>>\nFlyBehavior\nfly()\nfly() {\n  // implements duck flying\n}\nFlyWithWings\nfly() {\n  // do nothing - can\u2019t fly!\n} FlyNoWay\n<<interface>>\nQuackBehavior\nquack()\nquack) {\n  // implements duck quacking\n}\nQuack\nquack() {\n  // rubber duckie squeak\n}\nSqueak\nquack() {\n  // do nothing - can\u2019t quack!\n} MuteQuack\ndisplay() {\n// looks like a decoy duck }\nDecoy Duck\ndisplay() {\n// looks like a mallard }\nMallard Duck\ndisplay() {\n// looks like a redhead }\nRedhead Duck\ndisplay() {\n// looks like a rubberduck }\nRubber Duck\nEncapsulated fly behavior\nEncapsulated quack behavior\nClient \nView\nController\nModel\nRequest", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 67", "position": 67, "chunk_type": "semantic", "token_estimate": 296}
{"text": "u: b\nj\ne\nc\nt\n \nOb\nj\ne\nc\nt\n8\nint\n \n \n \nD\no\ng\n \nO\nb\nj\ne\nc\nt\nM\no\nu\ns\ne\n \nO\nb\njec\nt\n \n \nC\na\nt\n \nO\nb\nj\ne\nct\n \n \nD\nu\nc\nk\n \nO\nb\njec\nt\nObservers\n8\n8\n8\n8\nAutomatic update/notification\nObject that \nholds state\nDependent Objects\nQ: If design patterns are so great, why \ncan\u2019t someone build a library of them so I \ndon\u2019t have to? A: Design patterns are higher level than \nlibraries. Design patterns tell us how to \nstructure classes and objects to solve certain \nproblems, and it is our job to adapt those \ndesigns to fit our particular application. Q: Aren\u2019t libraries and frameworks \nalso design patterns? A: Frameworks and libraries are not \ndesign patterns; they provide specific \nimplementations that we link into our \ncode. Sometimes, however, libraries and \nframeworks make use of design patterns in \ntheir implementations. That\u2019s great, because \nonce you understand design patterns, you\u2019ll \nmore quickly understand APIs that are \nstructured around design patterns. Q: So, there are no libraries of design \npatterns? A: No, but you will learn later about \npatterns catalogs with lists of patterns that \nyou can apply to your applications.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 67", "position": 67, "chunk_type": "semantic", "token_estimate": 204}
{"text": "30\u2003 \u2003 Chapter 1: why design patterns? Skeptical Developer\nFriendly Patterns Guru\nDeveloper:  Okay, hmm, but isn\u2019t this all just good object-oriented design; I \nmean as long as I follow encapsulation and I know about abstraction, inheritance, \nand polymorphism, do I really need to think about Design Patterns? Isn\u2019t it pretty \nstraightforward? Isn\u2019t this why I took all those OO courses? I think Design Patterns \nare useful for people who don\u2019t know good OO design. Guru:  Ah, this is one of the true misunderstandings of object-oriented \ndevelopment: that by knowing the OO basics we are automatically going to be good at \nbuilding flexible, reusable, and maintainable systems. Developer: No? Guru: No. As it turns out, constructing OO systems that have these properties is \nnot always obvious and has been discovered only through hard work. Developer: I think I\u2019m starting to get it. These, sometimes non-obvious, ways of \nconstructing object-oriented systems have been collected...\nGuru: ...yes, into a set of patterns called Design Patterns. Developer: So, by knowing patterns, I can skip the hard work and jump straight to \ndesigns that always work? Guru: Yes, to an extent, but remember, design is an art. There will always be \ntradeoffs. But, if you follow well-thought-out and time-tested design patterns, you\u2019ll \nbe way ahead. Developer: What do I do if I can\u2019t find a pattern? Patterns are nothing \nmore than using OO \ndesign principles...\nA common misconception, \nbut it\u2019s more subtle than that. You have much to learn...", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 68", "position": 68, "chunk_type": "semantic", "token_estimate": 244}
{"text": "you are here 4\u2003 \u2003 31: intro to design patterns\nGuru: There are some object-oriented principles that \nunderlie the patterns, and knowing these will help you \nto cope when you can\u2019t find a pattern that matches your \nproblem. Developer: Principles? You mean beyond abstraction, \nencapsulation, and...\nGuru: Yes, one of the secrets to creating maintainable \nOO systems is thinking about how they might change in the \nfuture, and these principles address those issues. Remember, knowing concepts \nlike abstraction, inheritance, and \npolymorphism does not make you a good \nobject-oriented designer. A design guru \nthinks about how to create flexible \ndesigns that are maintainable and can \ncope with change.", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 69", "position": 69, "chunk_type": "semantic", "token_estimate": 106}
{"text": "32\u2003 \u2003 Chapter 1: your design toolbox\nTools for your Design Toolbox\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies. Favor composition over \ninheritance. Program to interfaces, not \nimplementations. OO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it. OO Patterns\nWe assume you know the \nOO basics like abstraction, \nencapsulation, polymorphism, \nand inheritance. If you are a \nlittle rusty on these, pull out \nyour favorite object-oriented \nbook and review, then skim \nthis chapter again. We\u2019ll be taking a closer look at \nthese down the road and also \nadding a few more to the list. One down, many to go! Throughout the \nbook, think about \nhow patterns rely \non OO basics and \nprinciples. You\u2019ve nearly made it through the first chapter! You\u2019ve \nalready put a few tools in your OO toolbox; let\u2019s make a \nlist of them before we move on to Chapter 2. \u0083\nKnowing the OO basics \ndoes not make you a good \nOO designer. \u0083\nGood OO designs are \nreusable, extensible, and \nmaintainable. \u0083\nPatterns show you how to \nbuild systems with good \nOO design qualities. \u0083\nPatterns are proven \nobject-oriented \nexperience. \u0083\nPatterns don\u2019t give you \ncode, they give you \ngeneral solutions to \ndesign problems. You \napply them to your specific \napplication. \u0083\nPatterns aren\u2019t invented, \nthey are discovered. \u0083\nMost patterns and \nprinciples address issues \nof change in software. \u0083\nMost patterns allow some \npart of a system to vary \nindependently of all other \nparts. \u0083\nWe often try to take what \nvaries in a system and \nencapsulate it. \u0083\nPatterns provide a \nshared language that can \nmaximize the value of \nyour communication with \nother developers.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 70", "position": 70, "chunk_type": "semantic", "token_estimate": 288}
{"text": "34\u2003 \u2003 Chapter 1: design puzzle solution\n<<interface>> \nWeaponBehavior\nCharacter is the abstract class for all the other characters (King, Queen, \nKnight, and Troll), while WeaponBehavior is an interface that all weapon \nbehaviors implement. So all actual characters and weapons are concrete \nclasses. To switch weapons, each character calls the setWeapon() method, which \nis defined in the Character superclass. During a fight the useWeapon() \nmethod is called on the current weapon set for a given character to inflict \ngreat bodily damage on another character. Character\nWeaponBehavior weapon\nfight()\nsetWeapon(WeaponBehavior w) {\n    this.weapon = w;\n}\nKing\nfight() { ... }\nQueen\nfight() { ... }\nKnight\nfight() { ... }\nTroll\nfight() { ... }\nuseWeapon()\nBowAndArrowBehavior\nuseWeapon() { // implements \nshooting an arrow with a bow }\nAxeBehavior\nuseWeapon() { // implements \nchopping with an axe }\nSwordBehavior\nuseWeapon() { // implements \nswinging a sword }\nKnifeBehavior\nuseWeapon() { // implements \ncutting with a knife }\n Design Puzzle Solution\nNote that ANY object could \nimplement the WeaponBehavior \ninterface\u2014say, a paper clip, a tube of \ntoothpaste, or a mutated sea bass. Abstract\nA Character HAS-A \nWeaponBehavior.", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 72", "position": 72, "chunk_type": "semantic", "token_estimate": 185}
{"text": "Across: 1. Patterns can help us build ____ applications \n[FLEXIBLE] \n4. Strategies can be _______ [REUSED] \n7. Favor over inheritance [COMPOSITION] \n8. Development constant [CHANGE] \n9. Java IO, Networking, Sound  [APIS] \n10. Most patterns follow from OO _______ \n[PRINCIPLES] \n12. Design patterns are a shared _____ \n[VOCABULARY] \n14. High level libraries [FRAMEWORKS] \nDown\n2. Patterns go into your _______ [BRAIN] \n3. Duck that can't quack [DECOYDUCK] \n5. Rubberducks make a ________ [SQUEAK] \n6. _______ what varies [ENCAPSULATE] \n11. Grilled cheese with bacon [JACKBENNY] \n13. Rick was thrilled with this pattern [OBSERVER] \n16. Duck demo was located where [MAUI] \ncrossword solution", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 74", "position": 74, "chunk_type": "semantic", "token_estimate": 100}
{"text": "this is a new chapter\u2003 \u2003 37: You don\u2019t want to miss out when something interesting \nhappens, do you? We\u2019ve got a pattern that keeps your objects in the \nknow when something they care about happens. It\u2019s the Observer Pattern. It is \none of the most commonly used design patterns, and it\u2019s incredibly useful. We\u2019re \ngoing to look at all kinds of interesting aspects of Observer, like its one-to-many \nrelationships and loose coupling. And, with those concepts in mind, how can you \nhelp but be the life of the Patterns Party? Keeping your \n Objects in the Know\n2  the Observer Pattern\nHey Jerry, I\u2019m notifying \neveryone that the Patterns Group \nmeeting moved to Saturday night. We\u2019re going to be talking about the \nObserver Pattern. That pattern is \nthe best! It\u2019s the BEST, Jerry!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 75", "position": 75, "chunk_type": "semantic", "token_estimate": 132}
{"text": "you are here 4\u2003 \u2003 39: the observer pattern\nThe Weather Monitoring application overview\nLet\u2019s take a look at the Weather Monitoring application we need to deliver\u2014both \nwhat Weather-O-Rama is giving us, and what we\u2019re going to need to build or \nextend. The system has three components: the weather station (the physical device \nthat acquires the actual weather data), the WeatherData object (that tracks the data \ncoming from the Weather Station and updates the displays), and the display that \nshows users the current weather conditions:\nWeatherData \nobject\nWeather Station\nDisplay device\nTemperature \nsensor device\nHumidity \nsensor device\nPressure \nsensor device\npulls data\ndisplays\nCurrent \nConditions\nTemp: 72\u00b0\nHumidity: 60\nPressure:\nThe WeatherData object was written by Weather-O-Rama and knows how to talk \nto the physical Weather Station to get updated weather data. We\u2019ll need to adapt \nthe WeatherData object so that it knows how to update the display. Hopefully \nWeather-O-Rama has given us hints for how to do this in the source code. Remember, we\u2019re responsible for implementing three different display elements: \nCurrent Conditions (shows temperature, humidity, and pressure), Weather \nStatistics, and a simple Forecast. So, our job, if we choose to accept it, is to create an app \nthat uses the WeatherData object to update three displays \nfor current conditions, weather stats, and a forecast. The user can view one of three different \ndisplays: the current conditions, weather \nstats, or a forecast. What Weather-O-Rama \nis providing\nWhat we need to implement. We\u2019ll also need to integrate \nthe WeatherData object with \nthe display.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 77", "position": 77, "chunk_type": "semantic", "token_estimate": 252}
{"text": "you are here 4\u2003 \u2003 41: the observer pattern\n\t\n\u25cf\nWe know the WeatherData class has getter methods for \nthree measurement values: temperature, humidity, and \nbarometric pressure. \u25cf\nWe know the measurementsChanged() method is called \nanytime new weather measurement data is available. (Again, \nwe don\u2019t know or care how this method is called; we just \nknow that it is called.) \u25cf\nWe\u2019ll need to implement three display elements that use the \nweather data: a current conditions display, a statistics display, \nand a forecast display. These displays must be updated as \noften as the WeatherData has new measurements. \u25cf\nTo update the displays, we\u2019ll add code to the \nmeasurementsChanged() method. Our Goal\nWe know we need to implement a display and then have the WeatherData \nupdate that display each time it has new values, or, in other words, each time \nthe measurementsChanged() method is called. But how? Let\u2019s think through \nwhat we\u2019re trying to acheive:\nDisplay One\nCurrent \nConditions\nTemp: 72\u00b0\nHumidity: 60\nPressure:\nDisplay Two\nWeather\nStats\nAvg. temp: 62\u00b0\nMin. temp:  50\u00b0\nMax. temp: 78\u00b0\nDisplay Three\nForecast", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 79", "position": 79, "chunk_type": "semantic", "token_estimate": 178}
{"text": "42\u2003 \u2003 Chapter 2: first try with the weather station\npublic class WeatherData {\n    // instance variable declarations\n    public void measurementsChanged() {\n        float temp = getTemperature();\n        float humidity = getHumidity();\n        float pressure = getPressure();\n        currentConditionsDisplay.update(temp, humidity, pressure);\n        statisticsDisplay.update(temp, humidity, pressure);\n        forecastDisplay.update(temp, humidity, pressure);\n    }\n    // other WeatherData methods here\n}\n...by calling its update method \nand passing it the most recent \nmeasurements. First, we grab the most recent measurements by \ncalling the WeatherData\u2019s getter methods. We assign \neach value to an appropriately named variable. Taking a first, misguided implementation \nof the Weather Station\nHere\u2019s a first implementation possibility\u2014as we\u2019ve discussed, we\u2019re going to add our code to \nthe measurementsChanged() method in the WeatherData class:\n\u274f   A. We are coding to concrete \nimplementations, not interfaces. \u274f   B. For every new display we\u2019ll need to \nalter this code. \u274f   C.\t We have no way to add (or remove) \ndisplay elements at runtime. \u274f   D.\t The display elements don\u2019t implement a \ncommon interface. \u274f   E.\t We haven\u2019t encapsulated the part that \nchanges. \u274f   F.\t We are violating encapsulation of the \nWeatherData class. Next we\u2019re going to \nupdate each display...\nBased on our first implementation, which of the following apply? (Choose all that apply.) Here\u2019s the measurementsChanged() method. And here are our code additions...", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 80", "position": 80, "chunk_type": "semantic", "token_estimate": 209}
{"text": "you are here 4\u2003 \u2003 43: the observer pattern\nThink back to all those Chapter 1 concepts and principles\u2014which are we violating, and \nwhich are we not? Think in particular about the effects of change on this code. Let\u2019s work \nthrough our thinking as we look at the code:\nWhat\u2019s wrong with our implementation anyway? public void measurementsChanged() {\n    float temp = getTemperature();\n    float humidity = getHumidity();\n    float pressure = getPressure();\n    currentConditionsDisplay.update(temp, humidity, pressure);\n    statisticsDisplay.update(temp, humidity, pressure);\n    forecastDisplay.update(temp, humidity, pressure);\n}\nBy coding to concrete \nimplementations, we have no way \nto add or remove other display \nelements without making changes to \nthe code. Looks like an area of \nchange. We need to \nencapsulate this. At least we seem to be using a \ncommon interface to talk to the \ndisplay elements...they all have an \nupdate() method that takes the \ntemp, humidity, and pressure values. Good idea. Let\u2019s take a look at \nObserver, then come back and figure \nout how to apply it to the Weather \nMonitoring app. Umm, I know I\u2019m \nnew here, but given that we \nare in the Observer Pattern \nchapter, maybe we should \nstart using it? Let\u2019s take another look...\nWhat if we want to add or remove \ndisplays at runtime? This looks \nhardcoded.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 81", "position": 81, "chunk_type": "semantic", "token_estimate": 205}
{"text": "44\u2003 \u2003 Chapter 2: meet the observer pattern\nMeet the Observer Pattern\nYou know how newspaper or magazine \nsubscriptions work:\nA newspaper publisher goes into business and begins \npublishing newspapers. You subscribe to a particular publisher, and every time \nthere\u2019s a new edition it gets delivered to you. As long as \nyou remain a subscriber, you get new newspapers. You unsubscribe when you don\u2019t want papers anymore, \nand they stop being delivered. While the publisher remains in business, people, hotels, \nairlines, and other businesses constantly subscribe and \nunsubscribe to the newspaper. 1\n2\n3\n4\nNo way we want to \nmiss what\u2019s going on in \nObjectville. Of course we \nsubscribe.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 82", "position": 82, "chunk_type": "semantic", "token_estimate": 109}
{"text": "you are here 4\u2003 \u2003 45: the observer pattern\nObserver Objects\nThe observers have subscribed to \n(registered with) the Subject \nto receive updates when the \nSubject\u2019s data changes. The Subject object \nmanages some \nimportant data. S\nu\nb\nj\ne\nc\nt\n \nOb\nj\ne\nc\nt\n2\nint\n \n \n \nD\no\ng\n \nO\nb\nj\ne\nc\nt\nM\no\nu\ns\ne\n \nO\nb\njec\nt\n \n \nC\na\nt\n \nO\nb\nj\ne\nct\nIf you understand newspaper subscriptions, you pretty much \nunderstand the Observer Pattern, only we call the publisher the \nSUBJECT and the subscribers the OBSERVERS. Let\u2019s take a closer look:\n2\n2\n2\nWhen data in the Subject changes, \nthe observers are notified. New data values are \ncommunicated to the \nobservers in some form \nwhen they change. D\nu\nc\nk\n \nO\nb\njec\nt\nThis object isn\u2019t an \nobserver, so it doesn\u2019t \nget notified when the \nSubject\u2019s data changes. Publishers + Subscribers = Observer Pattern", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 83", "position": 83, "chunk_type": "semantic", "token_estimate": 159}
{"text": "46\u2003 \u2003 Chapter 2: a day in the life of the observer pattern\nA day in the life of the Observer Pattern\nA Duck object comes along \nand tells the Subject that \nhe wants to become an \nobserver. Duck really wants in on the \naction; those ints Subject is \nsending out whenever its state \nchanges look pretty interesting... Observers\nS\nu\nb\nj\ne\nc\nt\n \nOb\nj\ne\nc\nt\n2\nint\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n \n \nD\nu\nc\nk\n \nO\nb\njec\nt\nS\nu\nb\nj\ne\nc\nt\n \nO\nb\nj\ne\nc\nt\n2\nint\nObservers\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n  \nD\nu\nc\nk\n \nO\nb\nj\ne\nc\nt\nThe Duck object is now an \nofficial observer. Duck is psyched...he\u2019s on the \nlist and is waiting with great \nanticipation for the next \nnotification so he can get an int. S\nu\nb\nj\ne\nc\nt\n \nO\nb\nj\ne\nc\nt\n8\nint\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n  \nD\nu\nc\nk\n \nO\nb\nj\ne\nc\nt\nThe Subject gets a new \ndata value! Now Duck and all the rest of the \nobservers get a notification that \nthe Subject has changed. Observers\n8\n8\n8\n8\n\u201cregister/subscribe me\u201d", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 84", "position": 84, "chunk_type": "semantic", "token_estimate": 267}
{"text": "you are here 4\u2003 \u2003 47: the observer pattern\nThe Mouse object asks to be \nremoved as an observer. The Mouse object has been \ngetting ints for ages and is tired \nof it, so he decides it\u2019s time to \nstop being an observer. Mouse is outta here! The Subject acknowledges the \nMouse\u2019s request and removes him \nfrom the set of observers. S\nu\nb\nj\ne\nc\nt\n \nO\nb\nj\ne\nc\nt\n14\nint\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n  \nD\nu\nc\nk\n \nO\nb\nj\ne\nc\nt\nThe Subject has another \nnew int. All the observers get another \nnotification, except for the \nMouse who is no longer included. Don\u2019t tell anyone, but the Mouse \nsecretly misses those ints... \nmaybe he\u2019ll ask to be an observer \nagain some day. Observers\nS\nu\nb\nj\ne\nc\nt\n \nO\nb\nj\ne\nc\nt\n8\nint\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n  \nD\nu\nc\nk\n \nO\nb\nj\ne\nc\nt\nObservers\nS\nu\nb\nj\ne\nc\nt\n \nO\nb\nj\ne\nc\nt\n8\nint\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n  \nD\nu\nc\nk\n \nO\nb\nj\ne\nc\nt\nObservers\n14\n14\n14\n\u201cremove/unsubscribe me\u201d", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 85", "position": 85, "chunk_type": "semantic", "token_estimate": 259}
{"text": "you are here 4\u2003 \u2003 49: the observer pattern\n8\n6\nSubject\nSubject\n9\n7\nObserver\nObserver\nObserver\n5\nMeanwhile, for Lori and Jill life goes \non; if a Java job comes along, they\u2019ll get \nnotified. After all, they are observers. Jill lands her own job! Hey observers, there\u2019s \na Java opening down at \nJavaBeans-R-Us. Jump on \nit! Don\u2019t blow it! Bwahaha, money in \nthe bank, baby! Arghhh!!! Mark my \nwords, Jill, you\u2019ll never \nwork in this town again if I \nhave anything to do with it. You\u2019re off my call list!!! You can take me \noff your call list. I \nfound my own job! Thanks, I\u2019ll send my \nresume right over. This guy is a real jerk. Who needs him. I\u2019m \nlooking for my own job.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 87", "position": 87, "chunk_type": "semantic", "token_estimate": 126}
{"text": "50\u2003 \u2003 Chapter 2: more five-minute drama\nJill\u2019s loving life, and no longer an observer. She\u2019s also enjoying the nice fat signing \nbonus that she got because the company \ndidn\u2019t have to pay a headhunter. Two weeks later... But what has become of our dear Lori? We \nhear she\u2019s beating the headhunter at his own \ngame. She\u2019s not only still an observer, she\u2019s \ngot her own call list now, and she is notifying \nher own observers. Lori\u2019s a subject and an \nobserver all in one.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 88", "position": 88, "chunk_type": "semantic", "token_estimate": 84}
{"text": "you are here 4\u2003 \u2003 51: the observer pattern\nThe Observer Pattern defines a one-to-many \ndependency between objects so that when one \nobject changes state, all of its dependents are \nnotified and updated automatically. The Observer Pattern defined\nA newspaper subscription, with its publisher and subscribers, is a \ngood way to visualize the pattern. In the real world, however, you\u2019ll typically see the Observer \nPattern defined like this:\nThe subject and observers define the one-to-many relationship. We \nhave one subject, who notifies many observers when something in the subject \nchanges. The observers are dependent on the subject\u2014when the subject\u2019s \nstate changes, the observers are notified. As you\u2019ll discover, there are a few different ways to implement the \nObserver Pattern, but most revolve around a class design that includes \nSubject and Observer interfaces. The Observer Pattern \ndefines a one-to-many \nrelationship between a \nset of objects. When the state of one \nobject changes, all of its \ndependents are notified. Let\u2019s relate this definition to how we\u2019ve been thinking about the \npattern:\nS\nu\nb\nj\ne\nc\nt\n \nO\nb\nj\ne\nc\nt\n8\nint\n  \n \nD\no\ng\n \nO\nb\nj\nect\nM\no\nu\ns\ne\n \nO\nb\nj\nec\nt\n  \nC\na\nt\n \nO\nb\nj\ne\nct\n  \nD\nu\nc\nk\n \nO\nb\nj\ne\nc\nt\nObservers\n8\n8\n8\n8\nONE-TO-MANY RELATIONSHIP\nAutomatic update/notification\nObject that \nholds state\nDependent Objects", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 89", "position": 89, "chunk_type": "semantic", "token_estimate": 233}
{"text": "52\u2003 \u2003 Chapter 2: the observer pattern\n<<interface>>\nSubject\nregisterObserver()\nremoveObserver()\nnotifyObservers()\n<<interface>>\nObserver\nupdate()\nregisterObserver() {...}\nremoveObserver() {...}\nnotifyObservers() {...}\ngetState()\nsetState()\nConcreteSubject\nHere\u2019s the Subject interface. Objects \nuse this interface to register as \nobservers and also to remove themselves \nfrom being observers. All potential observers need \nto implement the Observer \ninterface. This interface has \njust one method, update(), \nthat is called when the \nSubject\u2019s state changes. Concrete observers can be \nany class that implements the \nObserver interface. Each observer \nregisters with a concrete subject \nto receive updates. A concrete subject always \nimplements the Subject \ninterface. In addition to \nthe register and remove \nmethods, the concrete subject  \nimplements a notifyObservers() \nmethod that is used to update \nall the current observers \nwhenever state changes. update()\n// other Observer specific \nmethods \nConcreteObserver\nThe Observer Pattern: the Class Diagram\nThe concrete subject may also \nhave methods for setting and \ngetting its state (more about \nthis later). observers\nsubject\nEach subject \ncan have many \nobservers. Q: What does this have to do with \none-to-many relationships? A: With the Observer Pattern, the Subject \nis the object that contains the state and \ncontrols it. So, there is ONE subject with \nstate. The observers, on the other hand, use \nthe state, even if they don\u2019t own it. There \nare many observers, and they rely on the \nSubject to tell them when its state changes. So there is a relationship between the ONE \nSubject to the MANY Observers. Q: How does dependence come into \nthis? A: Because the subject is the sole owner \nof that data, the observers are dependent on \nthe subject to update them when the data \nchanges. This leads to a cleaner OO design \nthan allowing many objects to control the \nsame data. Q: I\u2019ve also heard of a Publish-\nSubscribe Pattern. Is that just another \nname for the Observer Pattern? A: No, although they are related. The \nPublish-Subscribe pattern is a more complex \npattern that allows subscribers to express \ninterest in different types of messages \nand further separates publishers from \nsubscribers. It is often used in middleware \nsystems. Let\u2019s take a look at the structure of the Observer Pattern, complete with \nits Subject and Observer classes. Here\u2019s the class diagram:", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 90", "position": 90, "chunk_type": "semantic", "token_estimate": 366}
{"text": "you are here 4\u2003 \u2003 53: the observer pattern\nGuru and Student...\nGuru: Have we talked about loose coupling? Student: Guru, I do not recall such a discussion. Guru: Is a tightly woven basket stiff or flexible? Student: Stiff, Guru. Guru: And do stiff or flexible baskets tear or break less easily? Student: A flexible basket tends to break less easily. Guru: And in our software, might our designs break less easily if \nour objects are less tightly bound together? Student: Guru, I see the truth of it. But what does it mean for \nobjects to be less tightly bound? Guru: We like to call it, loosely coupled. Student: Ah! Guru: We say a object is tightly coupled to another object when it is \ntoo dependent on that object. Student: So a loosely coupled object can\u2019t depend on another \nobject? Guru: Think of nature; all living things depend on each other. Likewise, all objects depend on other objects. But a loosely coupled \nobject doesn\u2019t know or care too much about the details of another \nobject. Student: But Guru, that doesn\u2019t sound like a good quality. Surely \nnot knowing is worse than knowing. Guru: You are doing well in your studies, but you have much to \nlearn. By not knowing too much about other objects, we can create \ndesigns that can handle change better. Designs that have more \nflexibility, like the less tightly woven basket. Student: Of course, I am sure you are right. Could you give me an \nexample? Guru: That is enough for today.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 91", "position": 91, "chunk_type": "semantic", "token_estimate": 254}
{"text": "54\u2003 \u2003 Chapter 2: The Power of Loose Coupling\nDesign Principle\nStrive for loosely coupled designs \nbetween objects that interact. When two objects are loosely coupled, they can interact, but they typically have very little knowledge \nof each other. As we\u2019re going to see, loosely coupled designs often give us a lot of flexibility (more \non that in a bit). And, as it turns out, the Observer Pattern is a great example of loose coupling. Let\u2019s walk through all the ways the pattern achieves loose coupling:\nLoosely coupled designs allow us to build flexible OO \nsystems that can handle change because they minimize \nthe interdependency between objects. How many \ndifferent kinds \nof change can you \nidentify here? First, the only thing the subject knows about an observer is that it \nimplements a certain interface (the Observer interface). It doesn\u2019t need to \nknow the concrete class of the observer, what it does, or anything else about it. We can add new observers at any time. Because the only thing the subject depends \non is a list of objects that implement the Observer interface, we can add new observers \nwhenever we want. In fact, we can replace any observer at runtime with another observer \nand the subject will keep purring along. Likewise, we can remove observers at any time. We never need to modify the subject to add new types of observers. Let\u2019s say \nwe have a new concrete class come along that needs to be an observer. We don\u2019t need \nto make any changes to the subject to accommodate the new class type; all we have \nto do is implement the Observer interface in the new class and register as an observer. The subject doesn\u2019t care; it will deliver notifications to any object that implements the \nObserver interface. We can reuse subjects or observers independently of each other. If we have \nanother use for a subject or an observer, we can easily reuse them because the two aren\u2019t \ntightly coupled. Changes to either the subject or an observer will not affect the other. Because the two are loosely coupled, we are free to make changes to either, as long as the \nobjects still meet their obligations to implement the Subject or Observer interfaces. Look! We have a new \nDesign Principle! loose coupling", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 92", "position": 92, "chunk_type": "semantic", "token_estimate": 380}
{"text": "you are here 4\u2003 \u2003 55: the observer pattern\nBefore moving on, try sketching out the classes you\u2019ll need to \nimplement the Weather Station, including the WeatherData class \nand its display elements. Make sure your diagram shows how all \nthe pieces fit together and also how another developer might \nimplement her own display element. If you need a little help, read the next page; your teammates are \nalready talking about how to design the Weather Station.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 93", "position": 93, "chunk_type": "semantic", "token_estimate": 75}
{"text": "56\u2003 \u2003 Chapter 2: Cubicle conversation\nThe Observer Pattern defines a one-to-many dependency between objects so that when \none object changes state, all its dependents are notified and updated automatically. Back to the Weather Station project. Your teammates have already begun thinking \nthrough the problem...\nSue\nSo, how are we going \nto build this thing? Mary: Well, it helps to know we\u2019re using the Observer Pattern. Sue: Right...but how do we apply it? Mary: Hmm. Let\u2019s look at the definition again: \nMary: That actually makes some sense when you think about it. Our WeatherData class is the \n\u201cone,\u201d and our \u201cmany\u201d is the various display elements that use the weather measurements. Sue: That\u2019s right. The WeatherData class certainly has state...that\u2019s the temperature, \nhumidity, and barometric pressure, and those definitely change. Mary: Yup, and when those measurements change, we have to notify all the display elements \nso they can do whatever it is they are going to do with the measurements. Sue: Cool, now I think I see how the Observer Pattern can be applied to our Weather \nStation problem. Mary: There are still a few things to consider that I\u2019m not sure I understand yet. Sue: Like what? Mary: For one thing, how do we get the weather measurements to the display elements? Sue: Well, looking back at the picture of the Observer Pattern, if we make the WeatherData \nobject the subject, and the display elements the observers, then the displays will register \nthemselves with the WeatherData object in order to get the information they want, right? Mary: Yes...and once the Weather Station knows about a display element, then it can just \ncall a method to tell it about the measurements. Sue: We gotta remember that every display element can be different...so I think that\u2019s where \nhaving a common interface comes in. Even though every component has a different type, \nthey should all implement the same interface so that the WeatherData object will know how \nto send them the measurements. Mary: I see what you mean. So every display will have, say, an update() method that \nWeatherData will call. Sue: And update() is defined in a common interface that all the elements implement\u2026\nconversation about the weather station", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 94", "position": 94, "chunk_type": "semantic", "token_estimate": 367}
{"text": "you are here 4\u2003 \u2003 57: the observer pattern\nDesigning the Weather Station\n<<interface>>\nSubject\nregisterObserver()\nremoveObserver()\nnotifyObservers()\n<<interface>>\nObserver\nupdate()\nregisterObserver() \nremoveObserver() \nnotifyObservers()\ngetTemperature()\ngetHumidity()\ngetPressure()\nmeasurementsChanged()\nWeatherData\nupdate()\ndisplay() { // display current \nmeasurements }\nCurrentConditionsDisplay\nupdate() \ndisplay() { // display the aver\u00ad\nage, min and max measure\u00ad\nments }\nStatisticsDisplay\nupdate()\ndisplay() { // display the \nforecast }\nForecastDisplay\nHere\u2019s our Subject interface. This should look familiar. All our weather components \nimplement the Observer \ninterface. This gives the \nSubject a common interface to \ntalk to when it comes time to \nupdate the observers. This display element \nshows the current \nmeasurements from the \nWeatherData object. This one keeps track \nof the min/avg/max \nmeasurements and \ndisplays them. This display shows the weather \nforecast based on the barometer. WeatherData now \nimplements the Subject \ninterface. observers\nupdate()\ndisplay() { // display  \nsomething else based on \nmeasurements }\nThirdPartyDisplay\nDevelopers can \nimplement the \nObserver and \nDisplayElement \ninterfaces to \ncreate their own \ndisplay element. <<interface>>\nDisplayElement\ndisplay()\nLet\u2019s also create an interface \nfor all display elements \nto implement. The display \nelements just need to \nimplement a display() method. These three display elements should have a pointer to \nWeatherData labeled \u201csubject\u201d too, but boy would \nthis diagram start to look like spaghetti if they did. How does this diagram compare with yours? subject", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 95", "position": 95, "chunk_type": "semantic", "token_estimate": 218}
{"text": "58\u2003 \u2003 Chapter 2: Implementing the Weather Station\nAll right, we\u2019ve had some great thinking from Mary and Sue (from a few pages back) \nand we\u2019ve got a diagram that details the overall structure of our classes. So, let\u2019s get \nour implemention of the weather station underway. Let\u2019s start with the interfaces:\nBoth of these methods take an \nObserver as an argument\u2014that is, the \nObserver to be registered or removed. This method is called to notify all observers \nwhen the Subject\u2019s state has changed. The Observer interface \nis implemented by all \nobservers, so they all \nhave to implement the \nupdate() method. Here \nwe\u2019re following Mary and \nSue\u2019s lead and passing \nthe measurements to the \nobservers. These are the state values the Observers get from \nthe Subject when a weather measurement changes. The DisplayElement interface \njust includes one method, display(), \nthat we will call when the display \nelement needs to be displayed. Mary and Sue thought that passing the measurements directly to the observers was the \nmost straightforward method of updating state. Do you think this is wise? Hint: is this an area \nof the application that might change in the future? If it did change, would the change be well \nencapsulated, or would it require changes in many parts of the code? Can you think of other ways to approach the problem of passing the updated state to the \nobservers? Don\u2019t worry; we\u2019ll come back to this design decision after we finish the initial implementation. public interface Subject {\n    public void registerObserver(Observer o);\n    public void removeObserver(Observer o);\n    public void notifyObservers();\n}\npublic interface Observer {\n    public void update(float temp, float humidity, float pressure);\n}\npublic interface DisplayElement {\n    public void display();\n}\nimplementing the weather station", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 96", "position": 96, "chunk_type": "semantic", "token_estimate": 285}
{"text": "you are here 4\u2003 \u2003 59: the observer pattern\npublic class WeatherData implements Subject {\n    private List<Observer> observers;\n    private float temperature;\n    private float humidity;\n    private float pressure;\n    \n    public WeatherData() {\n        observers = new ArrayList<Observer>();\n    }\n    \n    public void registerObserver(Observer o) {\n        observers.add(o);\n    }\n    \n    public void removeObserver(Observer o) {\n        observers.remove(o);\n    }\n    \n    public void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(temperature, humidity, pressure);\n        }\n    }\n    \n    public void measurementsChanged() {\n        notifyObservers();\n    }\n    \n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n    \n    // other WeatherData methods here\n}\nImplementing the Subject interface \nin WeatherData\nWe notify the Observers when we \nget updated measurements from \nthe Weather Station. Remember our first attempt at implementing the WeatherData class at the \nbeginning of the chapter? You might want to refresh your memory. Now it\u2019s \ntime to go back and do things with the Observer Pattern in mind:\nWeatherData now implements \nthe Subject interface. When an observer registers, we \njust add it to the end of the list. Likewise, when an observer wants to \nun-register, we just take it off the list. Here\u2019s the fun part; this is where we \ntell all the observers about the state. Because they are all Observers, we \nknow they all implement update(), so we \nknow how to notify them. Okay, while we wanted to ship a nice little \nweather station with each book, the publisher \nwouldn\u2019t go for it. So, rather than reading \nactual weather data off a device, we\u2019re going \nto use this method to test our display elements. Or, for fun, you could write code to grab \nmeasurements off the web. We\u2019ve added an ArrayList to \nhold the Observers, and we \ncreate it in the constructor. Here we implement the Subject interface. REMEMBER: we don\u2019t provide \nimport and package statements \nin the code listings. Get the \ncomplete source code from \nhttps://wickedlysmart.com/\nhead-first-design-patterns", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 97", "position": 97, "chunk_type": "semantic", "token_estimate": 313}
{"text": "60\u2003 \u2003 Chapter 2: public class CurrentConditionsDisplay implements Observer, DisplayElement {\n    private float temperature;\n    private float humidity;\n    private WeatherData weatherData;\n    \n    public CurrentConditionsDisplay(WeatherData weatherData) {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n    \n    public void update(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        display();\n    }\n    \n    public void display() {\n        System.out.println(\"Current conditions: \" + temperature \n            + \"F degrees and \" + humidity + \"% humidity\");\n    }\n}\nNow, let\u2019s build those display elements\nThis display implements the Observer \ninterface so it can get changes from \nthe WeatherData object. When update() is called, we \nsave the temp and humidity \nand call display(). The display() method \njust prints out the most \nrecent temp and humidity. Now that we\u2019ve got our WeatherData class straightened out, it\u2019s time to build the \ndisplay elements. Weather-O-Rama ordered three: the current conditions display, the \nstatistics display, and the forecast display. Let\u2019s take a look at the current conditions \ndisplay; once you have a good feel for this display element, check out the statistics and \nforecast displays in the code directory. You\u2019ll see they are very similar. It also implements DisplayElement, \nbecause our API is going to \nrequire all display elements to \nimplement this interface. The constructor is passed the \nweatherData object (the Subject) \nand we use it to register the \ndisplay as an observer. Q: Is update() the best place to call display()? A: In this simple example it made sense to call display() when the \nvalues changed. However, you\u2019re right; there are much better ways to \ndesign the way the data gets displayed. We\u2019ll see this when we get to \nthe Model-View-Controller pattern. Q: Why did you store a reference to the WeatherData \nSubject? It doesn\u2019t look like you use it again after the \nconstructor. A: True, but in the future we may want to un-register ourselves as \nan observer and it would be handy to already have a reference to the \nsubject. build the display elements", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 98", "position": 98, "chunk_type": "semantic", "token_estimate": 320}
{"text": "you are here 4\u2003 \u2003 61: the observer pattern\npublic class WeatherStation {\n    public static void main(String[] args) {\n        WeatherData weatherData = new WeatherData();\n    \n        CurrentConditionsDisplay currentDisplay = \n            new CurrentConditionsDisplay(weatherData);\n        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);\n        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);\n        weatherData.setMeasurements(80, 65, 30.4f);\n        weatherData.setMeasurements(82, 70, 29.2f);\n        weatherData.setMeasurements(78, 90, 29.2f);\n    }\n}\nPower up the Weather Station\nFile  Edit   Window  Help  StormyWeather\n%java WeatherStation\nCurrent conditions: 80.0F degrees and 65.0% humidity\nAvg/Max/Min temperature = 80.0/80.0/80.0\nForecast: Improving weather on the way! Current conditions: 82.0F degrees and 70.0% humidity\nAvg/Max/Min temperature = 81.0/82.0/80.0\nForecast: Watch out for cooler, rainy weather\nCurrent conditions: 78.0F degrees and 90.0% humidity\nAvg/Max/Min temperature = 80.0/82.0/78.0\nForecast: More of the same\n%\nThe Weather Station is ready to go. All we need is some code to \nglue everything together. We\u2019ll be adding some more displays and \ngeneralizing things in a bit. For now, here\u2019s our first attempt:\nFirst, let\u2019s create a test harness. 1\nRun the code and let the Observer Pattern do its magic. 2\nFirst, create the  \nWeatherData object. Create the three \ndisplays and \npass them the \nWeatherData object. Simulate new weather \nmeasurements. If you don\u2019t \nwant to \ndownload the \ncode, you can \ncomment out \nthese two lines \nand run it.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 99", "position": 99, "chunk_type": "semantic", "token_estimate": 204}
{"text": "you are here 4\u2003 \u2003 63: the observer pattern\nTonight\u2019s talk: Subject and Observer spar over the right way \nto get state information to the Observer. Subject:\nI\u2019m glad we\u2019re finally getting a chance to chat in \nperson. Well, I do my job, don\u2019t I? I always tell you what\u2019s \ngoing on... Just because I don\u2019t really know who \nyou are doesn\u2019t mean I don\u2019t care. And besides, I \ndo know the most important thing about you\u2014you \nimplement the Observer interface. Oh yeah, like what? Well, excuuuse me. I have to send my state with my \nnotifications so all you lazy Observers will know \nwhat happened! Well...I guess that might work. I\u2019d have to open \nmyself up even more, though, to let all you \nObservers come in and get the state that you \nneed. That might be kind of dangerous. I can\u2019t \nlet you come in and just snoop around looking at \neverything I\u2019ve got. Observer:\n\n\nReally? I thought you didn\u2019t care much about us \nObservers. Yeah, but that\u2019s just a small part of who I am. Anyway, I know a lot more about you...\nWell, you\u2019re always passing your state around to us \nObservers so we can see what\u2019s going on inside you. Which gets a little annoying at times... Okay, wait just a minute here; first, we\u2019re not lazy, \nwe just have other stuff to do in between your oh-\nso-important notifications, Mr. Subject, and second, \nwhy don\u2019t you let us come to you for the state we \nwant rather than pushing it out to just everyone?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 101", "position": 101, "chunk_type": "semantic", "token_estimate": 258}
{"text": "64\u2003 \u2003 Chapter 2: Subject:\nYes, I could let you pull my state. But won\u2019t \nthat be less convenient for you? If you have to \ncome to me every time you want something, you \nmight have to make multiple method calls to get \nall the state you want. That\u2019s why I like push \nbetter...then you have everything you need in one \nnotification. Well, as I like to say, don\u2019t call us, we\u2019ll call you! But I\u2019ll give it some thought. You never know, hell could freeze over. Indeed. Observer:\nWhy don\u2019t you just write some public getter \nmethods that will let us pull out the state we need? Don\u2019t be so pushy! There are so many different \nkinds of us Observers, there\u2019s no way you can \nanticipate everything we need. Just let us come to \nyou to get the state we need. That way, if some of \nus only need a little bit of state, we aren\u2019t forced to \nget it all. It also makes things easier to modify later. Say, for example, you expand yourself and add \nsome more state. If you use pull, you don\u2019t have to \ngo around and change the update calls on every \nobserver; you just need to change yourself to allow \nmore getter methods to access our additional state. I won\u2019t hold my breath. I see, always the wise guy...\nfireside chat: subject and observer", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 102", "position": 102, "chunk_type": "semantic", "token_estimate": 230}
{"text": "you are here 4\u2003 \u2003 65: the observer pattern\nLooking for the Observer Pattern in the Wild\nThe Observer Pattern is one of the most common patterns in use, and you\u2019ll find plenty \nof examples of the pattern being used in many libraries and frameworks. If we look at the \nJava Development Kit (JDK), for instance, both the JavaBeans and Swing libraries make use \nof the Observer Pattern. The pattern\u2019s not limited to Java either; it\u2019s used in JavaScript\u2019s \nevents and in Cocoa and Swift\u2019s Key-Value Observing protocol, to name a couple of other \nexamples. One of the advantages of knowing design patterns is recognizing and quickly \nunderstanding the design motivation in your favorite libraries. Let\u2019s take a quick diversion \ninto the Swing library to see how Observer is used. Okay, our application is pretty simple. You\u2019ve got a button that says, \u201cShould I do \nit?\u201d and when you click on that button the listeners (observers) get to answer the \nquestion in any way they want. We\u2019re implementing two such listeners, called the \nAngelListener and the DevilListener. Here\u2019s how the application behaves:\nIf you\u2019re curious about \nthe Observer Pattern in \nJavaBeans, check out the \nPropertyChangeListener \ninterface. You probably already know that Swing is Java\u2019s GUI toolkit for user interfaces. One \nof the most basic components of that toolkit is the JButton class. If you look up \nJButton\u2019s superclass, AbstractButton, you\u2019ll find that it has a lot of add/remove \nlistener methods. These methods allow you to add and remove observers\u2014or, as \nthey are called in Swing, listeners\u2014to listen for various types of events that occur \non the Swing component. For instance, an ActionListener lets you \u201clisten in\u201d on \nany types of actions that might occur on a button, like a button press. You\u2019ll find \nvarious types of listeners all over the Swing API. The Swing library\n%java SwingObserverExample\nCome on, do it! Don\u2019t do it, you might regret it! %\nA little life-changing application\nAnd here\u2019s the output when \nwe click on the button. Here\u2019s our fancy interface. Angel answer\nDevil answer\nFile  Edit  Window  Help  HeMadeMeDoIt", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 103", "position": 103, "chunk_type": "semantic", "token_estimate": 345}
{"text": "66\u2003 \u2003 Chapter 2: public class SwingObserverExample {\n    JFrame frame;\n    public static void main(String[] args) {\n        SwingObserverExample example = new SwingObserverExample();\n        example.go();\n    }\n    public void go() {\n        frame = new JFrame();\n        JButton button = new JButton(\"Should I do it? \");\n        button.addActionListener(new AngelListener());\n        button.addActionListener(new DevilListener());\n        // Set frame properties here\n    }\n    class AngelListener implements ActionListener {\n        public void actionPerformed(ActionEvent event) {\n            System.out.println(\"Don't do it, you might regret it! \");\n        }\n    }\n    class DevilListener implements ActionListener {\n        public void actionPerformed(ActionEvent event) {\n            System.out.println(\"Come on, do it! \");\n        }\n    }\n}\nSimple Swing application that \njust creates a frame and \nthrows a button in it. Makes the devil and \nangel objects listeners \n(observers) of the button. Here are the class definitions for \nthe observers, defined as inner \nclasses (but they don\u2019t have to be). Rather than update(), the actionPerformed() \nmethod gets called when the state in the \nsubject (in this case the button) changes. This life-changing application requires very little code. All we need to do is \ncreate a JButton object, add it to a JFrame, and set up our listeners. We\u2019re \ngoing to use inner classes for the listeners, which is a common technique in \nSwing programming. If you aren\u2019t up on inner classes or Swing, you might \nwant to review the Swing chapter in your favorite Java reference guide. Coding the life-changing application\nCode to set up the frame goes here. use action listener observers", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 104", "position": 104, "chunk_type": "semantic", "token_estimate": 233}
{"text": "you are here 4\u2003 \u2003 67: the observer pattern\npublic class SwingObserverExample {\n    JFrame frame;\n    public static void main(String[] args) {\n        SwingObserverExample example = new SwingObserverExample();\n        example.go();\n    }\n    public void go() {\n        frame = new JFrame();\n        JButton button = new JButton(\"Should I do it? \");\n        button.addActionListener(event -> \n             System.out.println(\"Don't do it, you might regret it! \"));\n        button.addActionListener(event -> \n             System.out.println(\"Come on, do it! \"));\n        // Set frame properties here\n    }\n}\nThe updated code, using lambda expressions:\nWe\u2019ve replaced the AngelListener \nand DevilListener objects with \nlambda expressions that implement \nthe same functionality that we \nhad before. We\u2019ve removed the two ActionListener classes \n(DevilListener and AngelListener) completely. When you click the button, the \nfunction objects created by the \nlambda expressions are notified \nand the method they implement \nis run. Using lambda expressions makes \nthis code a lot more concise. Lambda expressions were added in Java \n8. If you aren\u2019t familiar with them, don\u2019t \nworry about it; you can continue using inner \nclasses for your Swing observers. For more on lambda expressions, check out the Java docs. How about taking your use of the Observer Pattern even further? By using a lambda expression \nrather than an inner class, you can skip the step of creating an ActionListener object. With a lambda \nexpression, we create a function object instead, and the function object is the observer. And, when you pass \nthat function object to addActionListener(), Java ensures its signature matches actionPerformed(), the \none method in the ActionListener interface. Later, when the button is clicked, the button object notifies its observers\u2014including the function \nobjects created by the lambda expressions\u2014that it\u2019s been clicked, and calls each listener\u2019s \nactionPerformed() method. Let\u2019s take a look at how you\u2019d use lambda expressions as observers to simplify our previous code:", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 105", "position": 105, "chunk_type": "semantic", "token_estimate": 288}
{"text": "68\u2003 \u2003 Chapter 2: I was thinking about the push/pull discussion \nwe had earlier. Would it generalize the code a \nbit more if we allowed the displays to pull their \ndata from the WeatherData object as needed? That might make it easier to add new displays in \nthe future. Q: I thought Java had Observer and Observable classes? A: Good catch. Java used to provide an Observable class (the \nSubject) and an Observer interface, which you could use to help \nintegrate the Observer Pattern in your code. The Observable class \nprovided methods to add, delete, and notify observers, so that you \ndidn\u2019t have to write that code. And the Observer interface provided \nan interface just like ours, with one update() method. These classes \nwere deprecated in Java 9. Folks find it easier to support the basic \nObserver Pattern in their own code, or want something more robust, \nso the Observer/Observable classes are being phased out. Q: Does Java offer other built-in support for Observer to \nreplace those classes? A: JavaBeans offers built-in support through \nPropertyChangeEvents that are generated when a Bean \nchanges a particular kind of property, and sends notifications \nto PropertyChangeListeners. There are also related publisher/\nsubscriber components in the Flow API for handling asynchronous \nstreams. Q: Should I expect notifications from a Subject to its \nObservers to arrive in a specific order? A: With Java\u2019s implementations of Observer, the JDK developers \nspecifically advise you to not depend on any specific notification \norder. That\u2019s a good idea. In our current Weather Station design, we are pushing all three pieces of data \nto the update() method in the displays, even if the displays don\u2019t need all these \nvalues. That\u2019s okay, but what if Weather-O-Rama adds another data value later, \nlike wind speed? Then we\u2019ll have to change all the update() methods in all the \ndisplays, even if most of them don\u2019t need or want the wind speed data. Now, whether we pull or push the data to the Observer is an implementation \ndetail, but in a lot of cases it makes sense to let Observers retrieve the data they \nneed rather than passing more and more data to them through the update() \nmethod. After all, over time, this is an area that may change and grow unwieldy.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 106", "position": 106, "chunk_type": "semantic", "token_estimate": 376}
{"text": "68\u2003 \u2003 Chapter 2: Now, whether we pull or push the data to the Observer is an implementation \ndetail, but in a lot of cases it makes sense to let Observers retrieve the data they \nneed rather than passing more and more data to them through the update() \nmethod. After all, over time, this is an area that may change and grow unwieldy. And, we know CEO Johnny Hurricane is going to want to expand the Weather \nStation and sell more displays, so let\u2019s take another pass at the design and see if \nwe can make it even easier to expand in the future. Updating the Weather Station code to allow Observers to pull the data they \nneed is a pretty straightforward exercise. All we need to do is make sure the \nSubject has getter methods for its data, and then change our Observers to use \nthem to pull the data that\u2019s appropriate for their needs. Let\u2019s do that. revisiting push and pull", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 106", "position": 106, "chunk_type": "semantic", "token_estimate": 162}
{"text": "you are here 4\u2003 \u2003 69: the observer pattern\nFor an Observer to receive notifications...\nFor the Subject to send notifications...\nWe\u2019ll modify the notifyObservers() method in WeatherData to call the method \nupdate() in the Observers with no arguments: \npublic void notifyObservers() {\n\t\nfor (Observer observer : observers) {\n\t\n\t\nobserver.update();\n\t\n}\n}\nThen we\u2019ll modify the Observer interface, changing the signature of the \nupdate() method so that it has no parameters: \npublic interface Observer {\n\t\npublic void update();\n}\n1\nAnd finally, we modify each concrete Observer to change the signature of its respective \nupdate() methds and get the weather data from the Subject using the WeatherData\u2019s \ngetter methods. Here\u2019s the new code for the CurrentConditionsDisplay class:\n2\npublic void update() {\n\t\nthis.temperature = weatherData.getTemperature();\n\t\nthis.humidity = weatherData.getHumidity();\n\t\ndisplay();\n}\n1\nMeanwhile, back at Weather-O-Rama\nThere\u2019s another way of handling the data in the Subject: we can rely on the \nObservers to pull it from the Subject as needed. Right now, when the Subject\u2019s data \nchanges, we push the new values for temperature, humidity, and pressure to the \nObservers, by passing that data in the call to update(). Let\u2019s set things up so that when an Observer is notified of a change, it calls getter \nmethods on the Subject to pull the values it needs. To switch to using pull, we need to make a few small changes to our existing code. Here we\u2019re using the \nSubject\u2019s getter methods \nthat were supplied with \nthe code in WeatherData \nfrom Weather-O-Rama.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 107", "position": 107, "chunk_type": "semantic", "token_estimate": 248}
{"text": "70\u2003 \u2003 Chapter 2: Code Magnets\nThe ForecastDisplay class is all scrambled up on the fridge. Can you \nreconstruct the code snippets to make it work? Some of the curly \nbraces fell on the floor and they were too small to pick up, so feel \nfree to add as many of those as you need! public void display() {\n    // display code here\n}\nweatherData.registerObserver(this);\npublic ForecastDisplay(WeatherData \nweatherData) {\ndisplay();\npublic class ForecastDisplay implements \n \n \n \n \nObserver, DisplayElement {\nlastPressure = currentPressure;\ncurrentPressure = weatherData.getPressure();\nprivate float currentPressure = 29.92f; \n \nprivate float lastPressure;\nthis.weatherData = weatherData;\npublic void update() {\nprivate WeatherData weatherData;\n}\ncode magnet exercise", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 108", "position": 108, "chunk_type": "semantic", "token_estimate": 104}
{"text": "you are here 4\u2003 \u2003 71: the observer pattern\nTest Drive the new code\nFile  Edit   Window  Help  TryThisAtHome\n%java WeatherStation\nCurrent conditions: 80.0F degrees and 65.0% humidity\nAvg/Max/Min temperature = 80.0/80.0/80.0\nForecast: Improving weather on the way! Current conditions: 82.0F degrees and 70.0% humidity\nAvg/Max/Min temperature = 81.0/82.0/80.0\nForecast: Watch out for cooler, rainy weather\nCurrent conditions: 78.0F degrees and 90.0% humidity\nAvg/Max/Min temperature = 80.0/82.0/78.0\nForecast: More of the same\n%\nOkay, you\u2019ve got one more display to update, the Avg/Min/Max display. Go ahead and \ndo that now! Just to be sure, let\u2019s run the new code...\nWeather-O-Rama, Inc.\n100 Main Street\nTornado Alley, OK 45021\nWow! Your design is fantastic. Not only did you quickly create all three \ndisplays that we asked for, you\u2019ve created a general design that \nallows anyone to create new display, and even allows users to add \nand remove displays at runtime! Ingenious! Until our next engagement, \nHere\u2019s what we got. Look! This just arrived!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 109", "position": 109, "chunk_type": "semantic", "token_estimate": 161}
{"text": "72\u2003 \u2003 Chapter 2: Tools for your Design Toolbox\nAbstraction\nEncapsulation\nPolymorphism\nInheritence\nOO Basics\nEncapsulate what varies. Favor composition over \ninheritance. Program to interfaces, not \nimplementations. Strive for loosely coupled \ndesigns between objects that \ninteract. OO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it. OO Patterns\nWelcome to the end of Chapter 2. You\u2019ve added a \nfew new things to your OO toolbox...\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nHere\u2019s your newest \nprinciple. Remember, \nloosely coupled designs are \nmuch more flexible and \nresilient to change. A new pattern for communicating state to a \nset of objects in a loosely coupled manner. We \nhaven\u2019t seen the last of the Observer Pattern\u2014\njust wait until we talk about MVC! \u0083\nThe Observer Pattern defines \na one-to-many relationship \nbetween objects. \u0083\nSubjects update Observers \nusing a common interface. \u0083\nObservers of any concrete type \ncan participate in the pattern \nas long as they implement the \nObserver interface. \u0083\nObservers are loosely coupled \nin that the Subject knows \nnothing about them, other \nthan that they implement the \nObserver interface. \u0083\nYou can push or pull data from \nthe Subject when using the \npattern (pull is considered more \n\u201ccorrect\u201d). \u0083\nSwing makes heavy use of the \nObserver Pattern, as do many \nGUI frameworks. \u0083\nYou\u2019ll also find the pattern in \nmany other places, including \nRxJava, JavaBeans, and RMI, \nas well as in other language \nframeworks, like Cocoa, Swift, \nand JavaScript events. \u0083\nThe Observer Pattern is related \nto the Publish/Subscribe Pattern, \nwhich is for more complex \nsituations with multiple Subjects \nand/or multiple message types. \u0083\nThe Observer Pattern is a \ncommonly used pattern, and \nwe\u2019ll see it again when we learn \nabout Model-View-Controller. design toolbox", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 110", "position": 110, "chunk_type": "semantic", "token_estimate": 315}
{"text": "you are here 4\u2003 \u2003 73: the observer pattern\nDesign Principle\nIdentify the aspects of your application that vary \nand separate them from what stays the same. Design Principle\nProgram to an interface, not an implementation. Design Principle\nFavor composition over inheritance. Design Principle Challenge\nFor each design principle, describe how the Observer \nPattern makes use of the principle. This is a hard one. Hint: think about how observers \nand subjects work together.", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 111", "position": 111, "chunk_type": "semantic", "token_estimate": 72}
{"text": "1. One Subject likes to talk to _______ observers.: 3. Subject initially wanted to _________ all the data to \nObserver. 6. CEO almost forgot the ________ index display. 8. CurrentConditionsDisplay implements this interface. 9. Java framework with lots of Observers. 11. A Subject is similar to a __________. 12. Observers like to be ___________ when something \nnew happens. 15. How to get yourself off the Observer list. 16. Lori was both an Observer and a _________. 18. Subject is an ______. 20. You want to keep your coupling ________. 21. Program to an __________ not an implementation. 22. Devil and Angel are _________ to the button.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 112", "position": 112, "chunk_type": "semantic", "token_estimate": 106}
{"text": "1. He didn\u2019t want any more ints, so he removed himself.: 2. Temperature, humidity, and __________. 4. Weather-O-Rama\u2019s CEO is named after this kind of \nstorm. 5. He says you should go for it. 7. The Subject doesn\u2019t have to know much about the \n_____. 10. The WeatherData class __________ the Subject \ninterface. 13. Don\u2019t count on this for notification. 14. Observers are______ on the Subject. 17. Implement this method to get notified. 19. Jill got one of her own. cross word\nUntitled Puzzle\nHeader Info 1\nHeader Info 2\netc...\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nAcross\n1. One Subject likes to talk to _____ \nObservers\n3. Subject initially wanted to ____ all the data \nto Observer\n6. CEO almost forgot the ____ index display\n8. CurrentConditionsDisplay implements this \ninterface\n9. Java framework with lots of Observers\n11. A Subject is similar to a _____\n12. Observers like to be _____ when something \nnew happens\n15. How to get yourself off the Observer list\n16. Ron was both an Observer and a ______\nDown\n1. He didn't want any more ints so he removed \nhimself\n2. Temperature, humidity, and _____\n4. Weather-O-Rama's CEO is named after this \nkind of storm\n5. He says you should go for it\n7. The Subject doesn't have to know much \nabout the _____\n10. The WeatherData class ______ the Subject \ninterface\n13. Don't count on this for notification\n14. Observers are _____ on the Subject\n17. Implement this method to get notified", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 112", "position": 112, "chunk_type": "semantic", "token_estimate": 265}
{"text": "you are here 4\u2003 \u2003 75: the observer pattern\nDesign Principle\nIdentify the aspects of your application that \nvary and separate them from what stays the \nsame. Design Principle\nProgram to an interface, not an implementation. Design Principle\nFavor composition over inheritance. The thing that varies in the Observer Pattern \nis the state of the Subject and the number and \ntypes of Observers. With this pattern, you can  \nvary the objects that are dependent on the state \nof the Subject, without having to change that \nSubject. That\u2019s called planning ahead! Both the Subject and Observers use interfaces. The Subject keeps track of objects implementing \nthe Observer interface, while the Observers \nregister with, and get notified by, the Subject \ninterface. As we\u2019ve seen, this keeps things nice and \nloosely coupled. The Observer Pattern uses composition to compose \nany number of Observers with their Subject. These relationships aren\u2019t set up by some kind \nof inheritance hierarchy. No, they are set up at \nruntime by composition! Design \nPrinciple \nChallenge \nSolution\n\u274f   A. We are coding to concrete \nimplementations, not interfaces. \u274f   B. For every new display element, \nwe need to alter code. \u274f   C.\tWe have no way to add display \nelements at runtime. \u274f   D.\tThe display elements don\u2019t implement \na common interface. \u274f   E.\tWe haven\u2019t encapsulated what changes. \u274f   F.\t We are violating encapsulation of the \nWeatherData class. Based on our first implementation, which of the \nfollowing apply? (Choose all that apply.)", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 113", "position": 113, "chunk_type": "semantic", "token_estimate": 241}
{"text": "76\u2003 \u2003 Chapter 2: exercise solution\nCode Magnets Solution\nThe ForecastDisplay class is all scrambled up on the fridge. Can you \nreconstruct the code snippets to make it work? Some of the curly \nbraces fell on the floor and they were too small to pick up, so feel \nfree to add as many of those as you need! Here\u2019s our solution. public void display() {\n    // display code here\n}\nweatherData.registerObserver(this);\ndisplay();\npublic class ForecastDisplay implements \n \n \n \n \nObserver, DisplayElement {\nlastPressure = currentPressure;\ncurrentPressure = weatherData.getPressure();\nprivate float currentPressure = 29.92f; \n \nprivate float lastPressure;\npublic void update() {\nprivate WeatherData weatherData;\n}\n}\n}\npublic ForecastDisplay(WeatherData \nweatherData) {\nthis.weatherData = weatherData;", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 114", "position": 114, "chunk_type": "semantic", "token_estimate": 109}
{"text": "you are here 4\u2003 \u2003 77: the observer pattern\nUntitled Puzzle\nHeader Info 1\nHeader Info 2\netc...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 115", "position": 115, "chunk_type": "semantic", "token_estimate": 17}
{"text": "Across: 1. One Subject likes to talk to _____ \nObservers [MANY] \n3. Subject initially wanted to ____ all the data \nto Observer [PUSH] \n6. CEO almost forgot the ____ index display \n[HEAT] \n8. CurrentConditionsDisplay implements this \ninterface [OBSERVER] \n9. Java framework with lots of Observers \n[SWING] \n11. A Subject is similar to a _____ \n[PUBLISHER]\nDown\n1. He didn't want any more ints so he removed \nhimself [MOUSE] \n2. Temperature, humidity, and _____ \n[PRESSURE] \n4. Weather-O-Rama's CEO is named after this \nkind of storm [HURRICANE] \n5. He says you should go for it \n[DEVILLISTENER] \n7. The Subject doesn't have to know much \nabout the _____ [OBSERVERS] \n10. The WeatherData class ______ the Subject \ninterface [IMPLEMENTS]\nDesign Patterns \nCrossword Solution", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 115", "position": 115, "chunk_type": "semantic", "token_estimate": 119}
{"text": "this is a new chapter\u2003 \u2003 79: Just call this chapter \u201cDesign Eye for the Inheritance Guy.\u201d \nWe\u2019ll re-examine the typical overuse of inheritance and you\u2019ll learn how to decorate \nyour classes at runtime using a form of object composition. Why? Once you know the \ntechniques of decorating, you\u2019ll be able to give your (or someone else\u2019s) objects new \nresponsibilities without making any code changes to the underlying classes. Decorating Objects          \n3  the Decorator Pattern\nI used to think real men \nsubclassed everything. That was \nuntil I learned the power of \nextension at runtime, rather than \nat compile time. Now look at me!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 117", "position": 117, "chunk_type": "semantic", "token_estimate": 102}
{"text": "you are here 4\u2003 \u2003 81: the decorator pattern\nBeverage\ndescription\ngetDescription()\ncost()\n// Other useful methods...\ncost()\nHouseBlendWithSteamedMilk\nandCaramel\ncost()\nHouseBlendWithMocha\ncost()\nHouseBlendWithWhipandMocha\ncost()\nHouseBlendWithSteamedMilk\nandSoy\ncost()\nHouseBlendWithSteamedMilk\ncost()\nHouseBlendWithSteamedMilk\nandMocha\ncost()\nHouseBlendWithSoy\ncost()\nHouseBlendWithWhip\ncost()\nHouseBlendWithSteamedMilk\nandWhip\ncost()\nHouseBlendWithSoyandMocha\ncost()\nHouseBlendWithWhipandSoy\ncost()\nDarkRoastWithSteamedMilk\nandCaramel\ncost()\nDarkRoastWithMocha\ncost()\nDarkRoastWithWhipandMocha\ncost()\nDarkRoastWithSteamedMilk\nandSoy\ncost()\nDarkRoastWithSteamedMilk\ncost()\nDarkRoastWithSteamedMilk\nandMocha\ncost()\nDarkRoastWithSoy\ncost()\nDarkRoastWithWhip\ncost()\nDarkRoastWithSteamedMilk\nandWhip\ncost()\nDarkRoastWithSoyandMocha\ncost()\nDarkRoastWithWhipandSoy\ncost()\nDecafWithSteamedMilk\nandCaramel\ncost()\nDecafWithMocha\ncost()\nDecafWithWhipandMocha\ncost()\nDecafWithSteamedMilk\nandSoy\ncost()\nDecafWithSteamedMilk\ncost()\nDecafWithSteamedMilk\nandMocha\ncost()\nDecafWithSoy\ncost()\nDecafWithWhip\ncost()\nDecafWithSteamedMilk\nandWhip\ncost()\nDecafWithSoyandMocha\ncost()\nDecafWithWhipandSoy\ncost()\nDarkRoastWithSoy\ncost()\nEspressoWithSteamedMilk\nandCaramel\ncost()\nEspressoWithMocha\ncost()\nEspressoWithWhipandMocha\ncost()\nEspressoWithSteamedMilk\nandSoy\ncost()\nEspressoWithSteamedMilk\ncost()\nEspressoWithSteamedMilk\nandMocha\ncost()\nDecafWithSoy\ncost()\nEspressoWhip\ncost()\nEspressoWithSteamedMilk\nandWhip\ncost()\nDecafWithSoyandMocha\ncost()\nEspressoWithWhipandSoy\nEach cost method computes the \ncost of the coffee along with the \nother condiments in the order. Whoa! Can you say \n\u201cclass explosion\u201d? In addition to your coffee, you can also ask for several \ncondiments like steamed milk, soy, and mocha (otherwise \nknown as chocolate), and have it all topped off with whipped \nmilk. Starbuzz charges a bit for each condiment, so they really \nneed to get them built into their order system. Here\u2019s their first attempt...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 119", "position": 119, "chunk_type": "semantic", "token_estimate": 199}
{"text": "you are here 4\u2003 \u2003 83: the decorator pattern\ncost()\nEspresso\ncost()\nDecaf\ncost()\nDarkRoast\ncost()\nHouseBlend\nNow let\u2019s add in the subclasses, one for \neach beverage on the menu:\nEach cost() method needs to compute \nthe cost of the beverage and then \nadd in the condiments by calling the \nsuperclass implementation of cost(). Beverage\ndescription\nmilk\nsoy\nmocha\nwhip\ngetDescription()\ncost()\nhasMilk()\nsetMilk()\nhasSoy()\nsetSoy()\nhasMocha()\nsetMocha()\nhasWhip()\nsetWhip()\n// Other useful methods.. The superclass cost() will calculate the \ncosts for all of the condiments, while \nthe overridden cost() in the subclasses \nwill extend that functionality to include \ncosts for that specific beverage type. Write the cost() methods for the following classes (pseudo-Java is okay):\npublic class Beverage {\n    public double cost() {\n    }\n}\npublic class DarkRoast extends Beverage {\n    public DarkRoast() {\n        description = \"Most Excellent Dark Roast\";\n    }\n    public double cost() {\n    }\n}", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 121", "position": 121, "chunk_type": "semantic", "token_estimate": 147}
{"text": "you are here 4\u2003 \u2003 85: the decorator pattern\nGuru and Student...\nGuru: It has been some time since our last meeting. Have you \nbeen deep in meditation on inheritance? Student: Yes, Guru. While inheritance is powerful, I have \nlearned that it doesn\u2019t always lead to the most flexible or \nmaintainable designs. Guru: Ah yes, you have made some progress. So, tell me, my student, how \nthen will you achieve reuse if not through inheritance? Student: Guru, I have learned there are ways of \u201cinheriting\u201d behavior at \nruntime through composition and delegation. Guru: Please, go on...\nStudent: When I inherit behavior by subclassing, that behavior is set statically \nat compile time. In addition, all subclasses must inherit the same behavior. If, \nhowever, I can extend an object\u2019s behavior through composition, then I can \ndo this dynamically at runtime. Guru: Very good; you are beginning to see the power of composition. Student: Yes, it is possible for me to add multiple new responsibilities to \nobjects through this technique, including responsibilities that were not even \nthought of by the designer of the superclass. And I don\u2019t have to touch their \ncode! Guru: What have you learned about the effect of composition on maintaining \nyour code? Student: Well, that is what I was getting at. By dynamically composing \nobjects, I can add new functionality by writing new code rather than altering \nexisting code. Because I\u2019m not changing existing code, the chances of \nintroducing bugs or causing unintended side effects in pre-existing code are \nmuch reduced. Guru: Very good. Enough for today. I would like for you to go and meditate \nfurther on this topic... Remember, code should be closed (to change) like the \nlotus flower in the evening, yet open (to extension) like the lotus flower in the \nmorning.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 123", "position": 123, "chunk_type": "semantic", "token_estimate": 295}
{"text": "86\u2003 \u2003 Chapter 3: the open-closed principle\nThe Open-Closed Principle\nDesign Principle\nClasses should be open \nfor extension, but closed for \nmodification. Come on in; we\u2019re \nopen. Feel free to extend our \nclasses with any new behavior you like. If your \nneeds or requirements change (and we know they \nwill), just go ahead and make your own extensions. Sorry, we\u2019re closed. That\u2019s right, we \nspent a lot of time getting this \ncode correct and bug free, so we can\u2019t let you \nalter the existing code. It must remain closed to \nmodification. If you don\u2019t like it, you can speak to \nthe manager. We're on to one of the most important design principles:\nOur goal is to allow classes to be easily extended to \nincorporate new behavior without modifying existing code. What do we get if we accomplish this? Designs that are \nresilient to change and flexible enough to take on new \nfunctionality to meet changing requirements.", "domains": ["Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 124", "position": 124, "chunk_type": "semantic", "token_estimate": 155}
{"text": "you are here 4\u2003 \u2003 87: the decorator pattern\nWhile it may seem like a contradiction, \nthere are techniques for allowing code to be \nextended without direct modification. Be careful when choosing the areas of code \nthat need to be extended; applying the \nOpen-Closed Principle EVERYWHERE is \nwasteful and unnecessary, and can lead to \ncomplex, hard-to-understand code. Q: Open for extension and closed \nfor modification? That sounds very \ncontradictory. How can a design be both? A: That\u2019s a very good question. It certainly \nsounds contradictory at first. After all, the less \nmodifiable something is, the harder it is to \nextend, right? As it turns out, though, there are some \nclever OO techniques for allowing systems \nto be extended, even if we can\u2019t change the \nunderlying code. Think about the Observer \nPattern (in Chapter 2)...by adding new \nObservers, we can extend the Subject at \nany time, without adding code to the Subject. You\u2019ll see quite a few more ways of extending \nbehavior with other OO design techniques. Q: Okay, I understand Observer, but \nhow do I generally design something to be \nextensible yet closed for modification? A: Many of the patterns give us time-tested \ndesigns that protect your code from being \nmodified by supplying a means of extension. In this chapter you\u2019ll see a good example of \nusing the Decorator Pattern to follow the Open-\nClosed Principle. Q: How can I make every part of my \ndesign follow the Open-Closed Principle? A: Usually, you can\u2019t. Making OO design \nflexible and open to extension without \nmodifying existing code takes time and effort. In \ngeneral, we don\u2019t have the luxury of tying down \nevery part of our designs (and it would probably \nbe wasteful). Following the Open-Closed \nPrinciple usually introduces new levels of \nabstraction, which adds complexity to our code. You want to concentrate on those areas that are \nmost likely to change in your designs and apply \nthe principles there. Q: How do I know which areas of change \nare more important? A: That is partly a matter of experience \nin designing OO systems and also a matter \nof knowing the domain you are working in. Looking at other examples will help you learn to \nidentify areas of change in your own designs.", "domains": ["Design Patterns", "Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 125", "position": 125, "chunk_type": "semantic", "token_estimate": 370}
{"text": "88\u2003 \u2003 Chapter 3: meet the decorator pattern\nMeet the Decorator Pattern\nOkay, we\u2019ve seen that representing our beverage and condiments with \ninheritance has not worked out very well\u2014we get class explosions and rigid \ndesigns, or we add functionality to the base class that isn\u2019t appropriate for \nsome of the subclasses. So, here\u2019s what we\u2019ll do instead: we\u2019ll start with a beverage and \u201cdecorate\u201d \nit with the condiments at runtime. For example, if the customer wants a \nDark Roast with Mocha and Whip, then we\u2019ll:\n1\n2\nStart with a DarkRoast object. Decorate it with a Mocha object. 3\nDecorate it with a Whip object. 4\nCall the cost() method and rely on delegation to \nadd up the condiment costs. Okay, but how do you \u201cdecorate\u201d an object, and how does delegation \ncome into this? A hint: think of decorator objects as \u201cwrappers.\u201d Let\u2019s see \nhow this works... Okay, enough of the \n\u201cObject-Oriented Design Club.\u201d We \nhave real  problems here! Remember us? Starbuzz Coffee? Do you think you could use \nsome of those design principles to actually \nhelp us?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 126", "position": 126, "chunk_type": "semantic", "token_estimate": 178}
{"text": "you are here 4\u2003 \u2003 89: the decorator pattern\nRemember that DarkRoast \ninherits from Beverage and has \na cost() method that computes \nthe cost of the drink. D\na\nr\nk\nR\no\na\ns\nt\ncost()\n  \n   \n \nM\noc\nh\na\ncost()\n  \nW\nh\ni\np\ncost()\n  \n   \n \nM\noc\nh\na\ncost()\n1\n2\nWe start with our DarkRoast object. The customer wants Mocha, so we create a Mocha \nobject and wrap it around the DarkRoast. 3\nThe customer also wants Whip, so we create a Whip \ndecorator and wrap Mocha with it. The Mocha object is a decorator. Its \ntype mirrors the object it is decorating\u2014\nin this case, a Beverage. (By \u201cmirror,\u201d \nwe mean it is the same type.) So, Mocha has a cost() method too, \nand through polymorphism we can treat \nany Beverage wrapped in Mocha as \na Beverage, too (because Mocha is a \nsubtype of Beverage). Whip is a decorator, so it also \nmirrors DarkRoast\u2019s type and \nincludes a cost() method. Constructing a drink order with Decorators\nSo, a DarkRoast wrapped in Mocha and Whip is still \na Beverage and we can do anything with it we can do \nwith a DarkRoast, including call its cost() method. D\na\nr\nk\nR\no\na\ns\nt\ncost()\n \n \n \nD\na\nr\nk\nR\no\na\ns\nt\ncost()", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 127", "position": 127, "chunk_type": "semantic", "token_estimate": 220}
{"text": "90\u2003 \u2003 Chapter 3: decorator characteristics\nFirst, we call cost() on the \noutermost decorator, Whip. W\nh\ni\np\n  \n   \n \nM\noc\nh\na\n  \n \nD\na\nr\nk\nR\no\na\nst\nNow it\u2019s time to compute the cost for the customer. We do this by \ncalling cost() on the outermost decorator, Whip, and Whip is going to \ndelegate computing the cost to the objects it decorates. And so on. Let\u2019s see how this works:\nWhip calls cost() on Mocha. Mocha adds its cost, 20 cents, \nto the result from DarkRoast, \nand returns the new total, $1.19. 4\n.99\n.20\n.10\n$1.29\nWhip adds its total, 10 cents, \nto the result from Mocha, and \nreturns the final result\u2014$1.29. 1\n2\n5\n6\nOkay, here\u2019s what we know about Decorators, so far...\n\t\n\u0083\nDecorators have the same supertype as the objects they decorate. \u0083\nYou can use one or more decorators to wrap an object. \u0083\nGiven that the decorator has the same supertype as the object it decorates, we can \npass around a decorated object in place of the original (wrapped) object. \u0083\nThe decorator adds its own behavior before and/or after delegating to the object it \ndecorates to do the rest of the job. \u0083\nObjects can be decorated at any time, so we can decorate objects dynamically at \nruntime with as many decorators as we like. Now let\u2019s see how this all really works by looking at the \nDecorator Pattern definition and writing some code. 3\nMocha calls cost() on \nDarkRoast. DarkRoast returns \nits cost, 99 cents. 4\n(You\u2019ll see how in \na few pages.) Key point! cost()\ncost()\ncost()", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 128", "position": 128, "chunk_type": "semantic", "token_estimate": 270}
{"text": "you are here 4\u2003 \u2003 91: the decorator pattern\nThe Decorator Pattern attaches additional \nresponsibilities to an object dynamically. Decorators provide a flexible alternative to \nsubclassing for extending functionality. The Decorator Pattern defined\nDecorators implement the \nsame interface or abstract \nclass as the component they \nare going to decorate. methodA()\nmethodB()\n// other methods\nConcreteComponent\ncomponent\nmethodA()\nmethodB()\n// other methods\nComponent\nThe ConcreteDecorator \ninherits (from the \nDecorator class) an instance \nvariable for the thing it \ndecorates (the Component \nthe Decorator wraps). Decorators can add new methods; however, new \nbehavior is typically added by doing computation \nbefore or after an existing method in the component. Each decorator HAS-A  \n(wraps) a component, which \nmeans the decorator has an \ninstance variable that holds a \nreference to a component. The ConcreteComponent  \nis the object we\u2019re going \nto dynamically add new \nbehavior to. It extends \nComponent. Let\u2019s first take a look at the Decorator Pattern description:\nWhile that describes the role of the Decorator Pattern, it doesn\u2019t give us a lot \nof insight into how we\u2019d apply the pattern to our own implementation. Let\u2019s \ntake a look at the class diagram, which is a little more revealing (on the next \npage we\u2019ll look at the same structure applied to the beverage problem). Each component can be used on its \nown or wrapped by a decorator. Decorators can extend the \nstate of the component. ConcreteDecoratorB\nmethodA()\nmethodB()\n// other methods\nObject newState\nConcreteDecoratorA\nmethodA()\nmethodB()\nnewBehavior()\n// other methods\nmethodA()\nmethodB()\n// other methods\nDecorator\nComponent wrappedObj", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 129", "position": 129, "chunk_type": "semantic", "token_estimate": 251}
{"text": "92\u2003 \u2003 Chapter 3: decorating beverages\nDecorating our Beverages\nLet\u2019s rework our Starbuzz beverages using the Decorator Pattern...\nBeverage beverage\nCondimentDecorator\ngetDescription()\ncost()\n// other useful methods\nBeverage\ndescription\ncost()\ngetDescription()\nMilk\ncost()\nHouseBlend\ncomponent\ncost()\nDarkRoast\ncost()\nDecaf\ncost()\nEspresso\nMocha\nThe four concrete \ncomponents, one per \ncoffee type. And here are our condiment decorators; notice \nthey need to implement not only cost() but also \ngetDescription(). We\u2019ll see why in a moment...\nBeverage acts as our \nabstract component class. Before going further, think about how you\u2019d implement the cost() \nmethod of the coffees and the condiments. Also think about how \nyou\u2019d implement the getDescription() method of the condiments. getDescription()\nSoy\nWhip\ncost()\ngetDescription()\ncost()\ngetDescription()\ncost()\ngetDescription()\nHere's the reference to \nthe Beverage that the \nDecorators will be wrapping.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 130", "position": 130, "chunk_type": "semantic", "token_estimate": 129}
{"text": "you are here 4\u2003 \u2003 93: the decorator pattern\nCubicle Conversation\nSome confusion over Inheritance versus Composition\nMary\nSue: What do you mean? Mary: Look at the class diagram. The CondimentDecorator is extending the Beverage class. That\u2019s inheritance, right? Sue: True. I think the point is that it\u2019s vital that the decorators have the same type as the objects \nthey are going to decorate. So here we\u2019re using inheritance to achieve the type matching, but we \naren\u2019t using inheritance to get behavior. Mary: Okay, I can see how decorators need the same \u201cinterface\u201d as the components they wrap \nbecause they need to stand in place of the component. But where does the behavior come in? Sue: When we compose a decorator with a component, we are adding new behavior. We are \nacquiring new behavior not by inheriting it from a superclass, but by composing objects together. Mary: Okay, so we\u2019re subclassing the abstract class Beverage in order to have the correct type, \nnot to inherit its behavior. The behavior comes in through the composition of decorators with the \nbase components as well as other decorators. Sue: That\u2019s right. Mary: Oh, I get it! And because we are using object composition, we get a whole lot more \nflexibility about how to mix and match condiments and beverages. Very slick. Sue: Yes, if we rely on inheritance, then our behavior can only be determined statically at \ncompile time. In other words, we get only whatever behavior the superclass gives us or that we \noverride. With composition, we can mix and match decorators any way we like...at runtime. Mary: I get it\u2014we can implement new decorators at any time to add new behavior. If we relied \non inheritance, we\u2019d have to go in and change existing code anytime we wanted new behavior. Sue: Exactly. Mary: I just have one more question: if all we need to inherit is the type of the component, how \ncome we didn\u2019t use an interface instead of an abstract class for the Beverage class? Sue: Well, remember, when we got this code, Starbuzz already had an abstract Beverage class. Traditionally the Decorator Pattern does specify an abstract component, but in Java, obviously, \nwe could use an interface. But we always try to avoid altering existing code, so don\u2019t \u201cfix\u201d it if the \nabstract class will work just fine. Okay, I\u2019m a little confused...I \nthought we weren\u2019t going to use \ninheritance in this pattern?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 131", "position": 131, "chunk_type": "semantic", "token_estimate": 404}
{"text": "94\u2003 \u2003 Chapter 3: decorator training\nNew barista training\nFirst, we call cost() on the \noutermost decorator, Whip. W\nh\ni\np\ncost()\n  \n   \n \nM\noc\nh\na\n  \n \nD\na\nr\nk\nR\no\na\nst\ncost()\ncost()\nWhip calls cost() on Mocha. Mocha adds its cost, 20 \ncents, to the result from \nDarkRoast, and returns \nthe new total, $1.19. .99\n.20\n.10\n$1.29\nWhip adds its total, 10 cents, \nto the result from Mocha, and \nreturns the final result\u2014$1.29. 1\n2\n5\n6\n3\nDarkRoast returns \nits cost, 99 cents. 4\nMocha calls cost() on \nDarkRoast. Make a picture for what happens when the order is for a \n\u201cdouble mocha soy latte with whip\u201d beverage. Use the menu to \nget the correct prices, and draw your picture using the same \nformat we used earlier (from a few pages back):\nStarbuzz Coffee\nCoffees\nHouse Blend \n \n \nDark Roast \nDecaf         \nEspresso\nCondiments\nSteamed Milk\nMocha\nSoy\nWhip\n .89\n .99\n1.05\n1.99\n .10\n .20\n .15\n .10\nDraw your picture here. This picture was for \na \u201cdark roast mocha \nwhip\u201d beverage. S\nt\na\nr\nb\nu\nz\nz\n \nC\no\nf\nf\ne\ne\n \nS\nt\na\nr\nb\nu\nz\nz\n \nC\no\nf\nf\ne\ne\nHINT: you can make a \n\u201cdouble mocha soy latte \nwith whip\u201d by combining \nHouseBlend, Soy, two shots \nof Mocha, and Whip! Okay, I need for you to \nmake me a double mocha \nsoy latte with whip.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 132", "position": 132, "chunk_type": "semantic", "token_estimate": 239}
{"text": "you are here 4\u2003 \u2003 95: the decorator pattern\npublic abstract class CondimentDecorator extends Beverage {\n    Beverage beverage;\n    public abstract String getDescription();\n}\npublic abstract class Beverage {\n    String description = \"Unknown Beverage\";\n  \n    public String getDescription() {\n        return description;\n    }\n \n    public abstract double cost();\n}\nWriting the Starbuzz code\nIt\u2019s time to whip this design into some real code. Let\u2019s start with the Beverage class, which doesn\u2019t \nneed to change from Starbuzz\u2019s original design. Let\u2019s take a look: \nBeverage is simple enough. Let\u2019s implement the abstract \nclass for the Condiments (the Decorator) as well:\nBeverage is an abstract \nclass with the two methods \ngetDescription() and cost(). getDescription is already \nimplemented for us, but we \nneed to implement cost() \nin the subclasses. First, we need to be \ninterchangeable with a Beverage, \nso we extend the Beverage class. We\u2019re also going to require \nthat the condiment \ndecorators all reimplement the \ngetDescription() method. Again, \nwe\u2019ll see why in a sec... Here's the Beverage that each \nDecorator will be wrapping. Notice we are using the \nBeverage supertype to refer to \nthe Beverage so the Decorator \ncan wrap any beverage.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 133", "position": 133, "chunk_type": "semantic", "token_estimate": 184}
{"text": "you are here 4\u2003 \u2003 97: the decorator pattern\npublic class Mocha extends CondimentDecorator {\n \n    public Mocha(Beverage beverage) {\n        this.beverage = beverage;\n    }\n \n    public String getDescription() {\n        return beverage.getDescription() + \", Mocha\";\n    }\n \n    public double cost() {\n        return beverage.cost() + .20;\n    }\n}\nCoding condiments\nIf you look back at the Decorator Pattern class diagram, you\u2019ll see \nwe\u2019ve now written our abstract component (Beverage), we have \nour concrete components (HouseBlend), and we have our abstract \ndecorator (CondimentDecorator). Now it\u2019s time to implement the \nconcrete decorators. Here\u2019s Mocha:\nMocha is a decorator, so we \nextend CondimentDecorator. We\u2019re going to instantiate Mocha with a \nreference to a Beverage. Remember, this class inherits the \nBeverage instance variable to hold the \nbeverage we are wrapping. We set this instance variable to the \nobject we are wrapping. Here, we\u2019re \npassing the beverage we\u2019re wrapping to \nthe decorator\u2019s constructor. Now we need to compute the cost of our beverage \nwith Mocha. First, we delegate the call to the \nobject we\u2019re decorating so that it can compute the \ncost; then, we add the cost of Mocha to the result. We want our description to include not \nonly the beverage-say \u201cDark Roast\u201d-\nbut also each item decorating the \nbeverage (for instance, \u201cDark Roast,  \nMocha\u201d). So we first delegate to the \nobject we are decorating to get its \ndescription, then append \u201c, Mocha\u201d to \nthat description. On the next page we\u2019ll actually instantiate the beverage and \nwrap it with all its condiments (decorators), but first... Remember, CondimentDecorator \nextends Beverage. Write and compile the code for the other Soy and Whip \ncondiments. You\u2019ll need them to finish and test the application.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 135", "position": 135, "chunk_type": "semantic", "token_estimate": 270}
{"text": "98\u2003 \u2003 Chapter 3: testing the beverages\npublic class StarbuzzCoffee {\n \n    public static void main(String args[]) {\n        Beverage beverage = new Espresso();\n        System.out.println(beverage.getDescription() \n                + \" $\" + beverage.cost());\n \n        Beverage beverage2 = new DarkRoast();\n        beverage2 = new Mocha(beverage2);\n        beverage2 = new Mocha(beverage2);\n        beverage2 = new Whip(beverage2);\n        System.out.println(beverage2.getDescription() \n                + \" $\" + beverage2.cost());\n \n        Beverage beverage3 = new HouseBlend();\n        beverage3 = new Soy(beverage3);\n        beverage3 = new Mocha(beverage3);\n        beverage3 = new Whip(beverage3);\n        System.out.println(beverage3.getDescription() \n                + \" $\" + beverage3.cost());\n    }\n}\nServing some coffees\nFile  Edit   Window  Help  CloudsInMyCoffee\n% java StarbuzzCoffee\nEspresso $1.99\nDark Roast Coffee, Mocha, Mocha, Whip $1.49\nHouse Blend Coffee, Soy, Mocha, Whip $1.34\n%\nCongratulations. It\u2019s time to sit back, order a few coffees, and marvel \nat the flexible design you created with the Decorator Pattern. Here\u2019s some test code to make orders:\nOrder up an espresso, no condiments, \nand print its description and cost. Make a DarkRoast object. Finally, give us a HouseBlend \nwith Soy, Mocha, and Whip. Now, let\u2019s get those orders in:\nWe\u2019re going to see a much better way of creating \ndecorated objects when we cover the Factory and \nBuilder Design Patterns. Please note that the \nBuilder Pattern is covered in the Appendix. File  Edit   Window  Help  CloudsInMyCoffee\nWrap it with a Mocha. Wrap it in a second Mocha. Wrap it in a Whip.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 136", "position": 136, "chunk_type": "semantic", "token_estimate": 217}
{"text": "you are here 4\u2003 \u2003 99: the decorator pattern\nOur friends at Starbuzz have introduced sizes to their menu. You can now order a \ncoffee in tall, grande, and venti sizes (translation: small, medium, and large). Starbuzz \nsaw this as an intrinsic part of the coffee class, so they\u2019ve added two methods to \nthe Beverage class: setSize() and getSize(). They\u2019d also like for the condiments to be \ncharged according to size, so for instance, Soy costs 10\u00a2, 15\u00a2, and 20\u00a2, respectively, for \ntall, grande, and venti coffees. The updated Beverage class is shown below. How would you alter the decorator classes to handle this change in requirements? Q: I\u2019m a little worried about code \nthat might test for a specific concrete \ncomponent\u2014say, HouseBlend\u2014and do \nsomething, like issue a discount. Once \nI\u2019ve wrapped the HouseBlend with \ndecorators, this isn\u2019t going to work \nanymore. A: That is exactly right. If you have code \nthat relies on the concrete component\u2019s \ntype, decorators will break that code. As \nlong as you only write code against the \nabstract component type, the use of \ndecorators will remain transparent to your \ncode. However, once you start writing code \nagainst concrete components, you\u2019ll want to \nrethink your application design and your use \nof decorators. Q: Wouldn\u2019t it be easy for some client \nof a beverage to end up with a decorator \nthat isn\u2019t the outermost decorator? Like \nif I had a DarkRoast with Mocha, Soy, \nand Whip, it would be easy to write code \nthat somehow ended up with a reference \nto Soy instead of Whip, which means it \nwould not include Whip in the order. A: You could certainly argue that you \nhave to manage more objects with the \nDecorator Pattern and so there is an \nincreased chance that coding errors will \nintroduce the kinds of problems you suggest. However, we typically create decorators \nby using other patterns like Factory and \nBuilder. Once we\u2019ve covered these patterns, \nyou\u2019ll see that the creation of the concrete \ncomponent with its decorator is \u201cwell \nencapsulated\u201d and doesn\u2019t lead to these \nkinds of problems. Q: Can decorators know about the \nother decorations in the chain? Say I \nwanted my getDescription() method to \nprint \u201cWhip, Double Mocha\u201d instead of \n\u201cMocha, Whip, Mocha.\u201d That would require \nthat my outermost decorator know all the \ndecorators it is wrapping. A: Decorators are meant to add behavior \nto the object they wrap.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 137", "position": 137, "chunk_type": "semantic", "token_estimate": 395}
{"text": "you are here 4\u2003 \u2003 99: Say I \nwanted my getDescription() method to \nprint \u201cWhip, Double Mocha\u201d instead of \n\u201cMocha, Whip, Mocha.\u201d That would require \nthat my outermost decorator know all the \ndecorators it is wrapping. A: Decorators are meant to add behavior \nto the object they wrap. When you need to \npeek at multiple layers into the decorator \nchain, you are starting to push the decorator \nbeyond its true intent. Nevertheless, \nsuch things are possible. Imagine a \nCondimentPrettyPrint decorator that parses \nthe final decription and can print \u201cMocha,  \nWhip, Mocha\u201d as \u201cWhip, Double Mocha.\u201d  \nNote that getDescription() could return an \nArrayList of descriptions to make this easier. public abstract class Beverage {\n\t\npublic enum Size { TALL, GRANDE, VENTI };\n\t\nSize size = Size.TALL;\n\t\nString description = \"Unknown Beverage\";\n  \t\npublic String getDescription() {\n\t\n\t\nreturn description;\n\t\n}\n\t\npublic void setSize(Size size) {\n\t\n\t\nthis.size = size;\n\t\n}\n\t\npublic Size getSize() {\n\t\n\t\nreturn this.size;\n\t\n}\n\t\npublic abstract double cost();\n}", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 137", "position": 137, "chunk_type": "semantic", "token_estimate": 157}
{"text": "100\u2003 \u2003 Chapter 3: decorators in java i/o\nFileInputStream is the component \nthat\u2019s being decorated. The \nJava I/O library supplies several \ncomponents, including FileInputStream, \nStringBufferInputStream, \nByteArrayInputStream, and a few \nothers. All of these give us a base \ncomponent from which to read bytes. Real-World Decorators: Java I/O\nThe large number of classes in the java.io package is...overwhelming. Don\u2019t feel alone \nif you said \u201cwhoa\u201d the first (and second and third) time you looked at this API. But now that you know the Decorator Pattern, the I/O classes should make more \nsense since the java.io package is largely based on Decorator. Here\u2019s a typical set of \nobjects that use decorators to add functionality to reading data from a file:\nZi\np\nI\nn\np\nu\nt\nS\nt\nr\ne\nam\nB\nu\nf\nf\ne\nr\ne\nd\nI\nn\npu\nt\nS\nt\nre\na\nm\nFi\nle\nIn\npu\nt\nS\nt\nr\ne\na\nm\nBufferedInputStream is \na concrete decorator. BufferedInputStream adds \nbuffering behavior to a \nFileInputStream: it buffers \ninput to improve performance. ZipInputStream is also a \nconcrete decorator. It \nadds the ability to read \nzip file entries as it reads \ndata from a zip file. A text file for reading.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 138", "position": 138, "chunk_type": "semantic", "token_estimate": 203}
{"text": "you are here 4\u2003 \u2003 101: the decorator pattern\nBufferedInputStream and ZipInputStream both extend FilterInputStream, which \nextends InputStream. InputStream acts as the abstract decorator class: \nFileInputStream\nByteArrayInputStream\nFilterInputStream\nStringBufferInputStream\nInputStream\nInflatorInputStream\nDataInputStream\nBufferedInputStream\nPushbackInputStream\nHere\u2019s our abstract component. FilterInputStream \nis an abstract \ndecorator. And finally, here are all our concrete decorators. You can see that this isn\u2019t so different from the Starbuzz design. You should \nnow be in a good position to look over the java.io API docs and compose \ndecorators on the various input streams. You\u2019ll see that the output streams have the same design. And you\u2019ve probably \nalready found that the Reader/Writer streams (for character-based data) \nclosely mirror the design of the streams classes (with a few differences and \ninconsistencies, but close enough to figure out what\u2019s going on). Java I/O also points out one of the downsides of the Decorator Pattern: \ndesigns using this pattern often result in a large number of small classes \nthat can be overwhelming to a developer trying to use the Decorator-based \nAPI. But now that you know how Decorator works, you can keep things in \nperspective and when you\u2019re using someone else\u2019s Decorator-heavy API, you \ncan work through how their classes are organized so that you can easily use \nwrapping to get the behavior you\u2019re after. Decorating the java.io classes\nThese InputStreams act as the concrete \ncomponents that we will wrap with \ndecorators. There are a few more we \ndidn\u2019t show, like ObjectInputStream. ZipInputStream", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 139", "position": 139, "chunk_type": "semantic", "token_estimate": 241}
{"text": "102\u2003 \u2003 Chapter 3: write your own i/o decorator\npublic class LowerCaseInputStream extends FilterInputStream {\n    public LowerCaseInputStream(InputStream in) {\n        super(in);\n    }\n \n    public int read() throws IOException {\n        int c = in.read();\n        return (c == -1 ? c : Character.toLowerCase((char)c));\n    }\n        \n    public int read(byte[] b, int offset, int len) throws IOException {\n        int result = in.read(b, offset, len);\n        for (int i = offset; i < offset+result; i++) {\n            b[i] = (byte)Character.toLowerCase((char)b[i]);\n        }\n        return result;\n    }\n}\nWriting your own Java I/O Decorator\nOkay, you know the Decorator Pattern, and you\u2019ve seen the \nI/O class diagram. You should be ready to write your own input \ndecorator. How about this: write a decorator that converts all uppercase \ncharacters to lowercase in the input stream. In other words, if \nwe read in \u201cI know the Decorator Pattern therefore I RULE!\u201d \nthen your decorator converts this to \u201ci know the decorator \npattern therefore i rule!\u201d\nFirst, extend the FilterInputStream, the \nabstract decorator for all InputStreams. Now we need to implement two \nread methods. They take a \nbyte (or an array of bytes) \nand convert each byte (that \nrepresents a character) to \nlowercase if it\u2019s an uppercase \ncharacter. Don\u2019t forget to import \njava.io... (not shown). REMEMBER: we don\u2019t provide import and package statements \nin the code listings. Get the complete source code from \nhttps://wickedlysmart.com/head-first-design-patterns. No problem. I \njust have to extend the \nFilterInputStream class and \noverride the read() methods.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 140", "position": 140, "chunk_type": "semantic", "token_estimate": 232}
{"text": "you are here 4\u2003 \u2003 103: the decorator pattern\npublic class InputTest {\n    public static void main(String[] args) throws IOException {\n        int c;\n        try {\n            InputStream in = \n                new LowerCaseInputStream(\n                    new BufferedInputStream(\n                        new FileInputStream(\"test.txt\")));\n            while((c = in.read()) >= 0) {\n                System.out.print((char)c);\n            }\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\nWrite some quick code to test the I/O decorator:\n% java InputTest\ni know the decorator pattern therefore i rule! %\nFile  Edit   Window  Help  DecoratorsRule\nGive it a spin:\nSet up the FileInputStream and decorate \nit, first with a BufferedInputStream \nand then our brand new \nLowerCaseInputStream filter. Just use the stream to read \ncharacters until the end of \nfile and print as we go. I know the Decorator Pattern therefore I RULE! test.txt file\nTest out your new Java I/O Decorator\nYou need to \nmake this file.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 141", "position": 141, "chunk_type": "semantic", "token_estimate": 139}
{"text": "104\u2003 \u2003 Chapter 3: decorator interview\nHead First: Welcome, Decorator Pattern. We\u2019ve heard that you\u2019ve been a bit down on \nyourself lately? Decorator: Yes, I know the world sees me as the glamorous design pattern, but you know, I\u2019ve \ngot my share of problems just like everyone. HeadFirst: Can you perhaps share some of your troubles with us? Decorator: Sure. Well, you know I\u2019ve got the power to add flexibility to designs, that much is \nfor sure, but I also have a dark side. You see, I can sometimes add a lot of small classes to a design, \nand this occasionally results in a design that\u2019s less than straightforward for others to understand. HeadFirst: Can you give us an example? Decorator: Take the Java I/O libraries. These are notoriously difficult for people to \nunderstand at first. But if they just saw the classes as a set of wrappers around an InputStream, \nlife would be much easier. HeadFirst: That doesn\u2019t sound so bad. You\u2019re still a great pattern, and improving this is just a \nmatter of public education, right? Decorator: There\u2019s more, I\u2019m afraid. I\u2019ve got typing problems: you see, people sometimes \ntake a piece of client code that relies on specific types and introduce decorators without \nthinking through everything. Now, one great thing about me is that you can usually insert decorators \ntransparently and the client never has to know it\u2019s dealing with a decorator. But like I said, some code is \ndependent on specific types and when you start introducing decorators, boom! Bad things \nhappen. HeadFirst: Well, I think everyone understands that you have to be careful when inserting \ndecorators. I don\u2019t think this is a reason to be too down on yourself. Decorator: I know, I try not to be. I also have the problem that introducing decorators can \nincrease the complexity of the code needed to instantiate the component. Once you\u2019ve got \ndecorators, you\u2019ve got to not only instantiate the component, but also wrap it with who knows \nhow many decorators. HeadFirst: I\u2019ll be interviewing the Factory and Builder patterns next week\u2014I hear they can \nbe very helpful with this? Decorator: That\u2019s true; I should talk to those guys more often. HeadFirst: Well, we all think you\u2019re a great pattern for creating flexible designs and staying \ntrue to the Open-Closed Principle, so keep your chin up and think positively! Decorator: I\u2019ll do my best, thank you.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 142", "position": 142, "chunk_type": "semantic", "token_estimate": 398}
{"text": "104\u2003 \u2003 Chapter 3: HeadFirst: Well, we all think you\u2019re a great pattern for creating flexible designs and staying \ntrue to the Open-Closed Principle, so keep your chin up and think positively! Decorator: I\u2019ll do my best, thank you. Patterns Exposed\nThis week\u2019s interview:\nConfessions of a Decorator", "domains": ["Design Patterns", "Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 142", "position": 142, "chunk_type": "semantic", "token_estimate": 47}
{"text": "you are here 4\u2003 \u2003 105: the decorator pattern\nTools for your Design Toolbox\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies. Favor composition over inheritance. Program to interfaces, not \nimplementations. Strive for loosely coupled designs \nbetween objects that interact. Classes should be open for \nextension but closed for \nmodification. OO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it. OO Patterns\nYou\u2019ve got another chapter under your belt and a new \nprinciple and pattern in the toolbox. Observer - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nWe now have the Open-\nClosed Principle to guide \nus. We\u2019re going to strive \nto design our system so \nthat the closed parts \nare isolated from our \nnew extensions. And here\u2019s our first pattern for creating designs \nthat satisfy the Open-Closed Principle. Or was it \nreally the first? Is there another pattern we\u2019ve \nused that follows this principle as well? Decorator - Attach additional \nresponsibilities to an object dynamically. Decorators provide a flexible \nalternative to subclassing for extending \nfunctionality. \u0083\nInheritance is one form of \nextension, but not necessarily the \nbest way to achieve flexibility in \nour designs. \u0083\nIn our designs we should allow \nbehavior to be extended without \nthe need to modify existing code. \u0083\nComposition and delegation \ncan often be used to add new \nbehaviors at runtime. \u0083\nThe Decorator Pattern provides \nan alternative to subclassing for \nextending behavior. \u0083\nThe Decorator Pattern involves \na set of decorator classes that \nare used to wrap concrete \ncomponents. \u0083\nDecorator classes mirror the type \nof the components they decorate. (In fact, they are the same type \nas the components they decorate, \neither through inheritance or \ninterface implementation.) \u0083\nDecorators change the behavior of \ntheir components by adding new \nfunctionality before and/or after (or \neven in place of) method calls to \nthe component. \u0083\nYou can wrap a component with \nany number of decorators. \u0083\nDecorators are typically \ntransparent to the client of the \ncomponent\u2014that is, unless \nthe client is relying on the \ncomponent\u2019s concrete type. \u0083\nDecorators can result in many \nsmall objects in our design, and \noveruse can be complex.", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 143", "position": 143, "chunk_type": "semantic", "token_estimate": 380}
{"text": "you are here 4\u2003 \u2003 107: the decorator pattern\nS\nt\na\nr\nb\nu\nz\nz\n \nC\no\nf\nf\ne\ne\n  \n   \n \nM\noc\nh\na\n  \n \nH\no\nu\ns\ne\nB\nl\nend\n  \n   \n \nM\noc\nh\na\n  \n  \nSo\ny\n  \nW\nh\ni\np\ncost()\ncost()\ncost()\ncost()\ncost()\n.89\n.15\n.20\n.20\n.10\n$1.54\nFirst, we call cost() on the \noutermost decorator, Whip. Whip calls cost() on Mocha. Last topping! Soy calls \ncost() on HouseBlend. Finally, the result returns to Whip\u2019s \ncost(), which adds .10, giving us a \nfinal cost of $1.54. 1\n2\n5\n10\n3 Mocha calls cost() on another Mocha. 4 Next, Mocha calls cost() on Soy. New barista training\n\u201cdouble mocha soy latte with whip\u201d \nHouseBlend\u2019s cost() method \nreturns .89 and pops off \nthe stack. 6\nSoy\u2019s cost() method adds .15 \nand returns the result, then \npops off the stack. 7\nThe second Mocha\u2019s cost() method \nadds .20 and returns the result, \nthen pops off the stack. 8\nThe first Mocha\u2019s cost() method adds \n.20 and returns the result, then pops \noff the stack. 9", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 145", "position": 145, "chunk_type": "semantic", "token_estimate": 180}
{"text": "108\u2003 \u2003 Chapter 3: exercise solutions\npublic class Soy extends CondimentDecorator {\n    public Soy(Beverage beverage) {\n        this.beverage = beverage;\n    }\n    public String getDescription() {\n        return beverage.getDescription() + \", Soy\";\n    }\n    public double cost() {\n        double cost = beverage.cost();\n        if (beverage.getSize() == Size.TALL) {\n            cost += .10;\n        } else if (beverage.getSize() == Size.GRANDE) {\n            cost += .15;\n        } else if (beverage.getSize() == Size.VENTI) {\n            cost += .20;\n        }\n        return cost;\n    }\n}\nOur friends at Starbuzz have introduced sizes to their menu. You can now order \na coffee in tall, grande, and venti sizes (translation: small, medium, and large). Starbuzz saw this as an intrinsic part of the coffee class, so they\u2019ve added two \nmethods to the Beverage class: setSize() and getSize(). They\u2019d also like for the \ncondiments to be charged according to size, so for instance, Soy costs 10\u00a2, 15\u00a2, \nand 20\u00a2, respectively, for tall, grande, and venti coffees. How would you alter the decorator classes to handle this change in \nrequirements? Here\u2019s our solution. Here we get the size (which \npropagates all the way to the \nconcrete beverage) and then \nadd the appropriate cost. public abstract class CondimentDecorator extends Beverage {\n    public Beverage beverage;\n    public abstract String getDescription();\n\t\n    public Size getSize() {\n        return beverage.getSize();\n    }\n}\nWe added a method, getSize(), for \nthe decorators that simply returns \nthe size of the beverage.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 146", "position": 146, "chunk_type": "semantic", "token_estimate": 222}
{"text": "this is a new chapter\u2003 \u2003 109: 4  the Factory Pattern\nGet ready to bake some loosely coupled OO designs. There is more \nto making objects than just using the new operator. You\u2019ll learn that instantiation is an \nactivity that shouldn\u2019t always be done in public and can often lead to coupling problems. And we don\u2019t want that, do we? Find out how Factory Patterns can help save you from \nembarrassing dependencies. Baking with OO Goodness", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 147", "position": 147, "chunk_type": "semantic", "token_estimate": 75}
{"text": "110\u2003 \u2003 Chapter 4: thinking about new\nYes, when you use the new operator you are certainly instantiating \na concrete class, so that\u2019s definitely an implementation and not an \ninterface. And you make a good observation: that tying your code to \na concrete class can make it more fragile and less flexible. Duck duck; \nif (picnic) {\n    duck = new MallardDuck();\n} else if (hunting) {\n    duck = new DecoyDuck();\n} else if (inBathTub) {\n    duck = new RubberDuck();\n}\nHere we\u2019ve got several concrete classes being instantiated, and the \ndecision of which to instantiate is made at runtime depending on \nsome set of conditions. When you see code like this, you know that when it comes time for \nchanges or extensions, you\u2019ll have to reopen this code and examine \nwhat needs to be added (or deleted). Often this kind of code ends \nup in several parts of the application, making maintenance and \nupdates more difficult and error-prone. Duck duck = new MallardDuck();\nWe want to use abstact types \nto keep code flexible. But we have to create an \ninstance of a concrete class! When we have a whole set of related concrete classes, often we end up \nwriting code like this:\nWe have a bunch of different \nduck classes, and we don\u2019t \nknow until runtime which one \nwe need to instantiate. When you see \u201cnew,\u201d think \u201cconcrete.\u201d\nOkay, it\u2019s been three chapters and you \nstill haven\u2019t answered my question about \nnew. We aren\u2019t supposed to program to an \nimplementation, but every time I use new, \nthat\u2019s exactly what I\u2019m doing, right?", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 148", "position": 148, "chunk_type": "semantic", "token_estimate": 261}
{"text": "you are here 4\u2003 \u2003 111: the factory pattern\nTechnically there\u2019s nothing wrong with the new operator. After all, it\u2019s a fundamental part of most modern object-\noriented languages. The real culprit is our old friend \nCHANGE and how change impacts our use of new. By coding to an interface, you know you can insulate yourself \nfrom many of the changes that might happen to a system \ndown the road. Why? If your code is written to an interface, \nthen it will work with any new classes implementing that \ninterface through polymorphism. However, when you have \ncode that makes use of lots of concrete classes, you\u2019re looking \nfor trouble because that code may have to be changed as new \nconcrete classes are added. So, in other words, your code will \nnot be \u201cclosed for modification.\u201d To extend your code with \nnew concrete types, you\u2019ll have to reopen it. So what can you do? It\u2019s times like these that you can fall back \non OO design principles to look for clues. Remember, our first \nprinciple deals with change and guides us to identify the aspects \nthat vary and separate them from what stays the same. Remember that designs \nshould be \u201copen for \nextension but closed \nfor modification.\u201d See \nChapter 3 for a review. What\u2019s wrong with \u201cnew\u201d? But you have to create an \nobject at some point, and Java \nonly gives us one way to create an \nobject, right? So what gives? How might you take all the parts of your application that instantiate \nconcrete classes and separate or encapsulate them from the rest of \nyour application?", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 149", "position": 149, "chunk_type": "semantic", "token_estimate": 265}
{"text": "112\u2003 \u2003 Chapter 4: identify what varies\nIdentifying the aspects that vary\nLet\u2019s say you have a pizza shop, and as a cutting-edge pizza store owner in \nObjectville you might end up writing some code like this:\nPizza orderPizza() {\n\t\nPizza pizza = new Pizza();\n\t\npizza.prepare();\n\t\npizza.bake();\t\n\t\npizza.cut();\n\t\npizza.box();\n\t\nreturn pizza;\n}\nFor flexibility, we really want this \nto be an abstract class or interface, \nbut unfortunately we can\u2019t directly \ninstantiate either of those. So then you\u2019d add some code that determines the appropriate type of pizza and \nthen goes about making the pizza:\nWe\u2019re now passing in \nthe type of pizza to \norderPizza. Based on the type of pizza, we \ninstantiate the correct concrete class \nand assign it to the pizza instance \nvariable. Note that each pizza here has \nto implement the Pizza interface. Once we have a Pizza, we prepare it \n(you know, roll the dough, put on the \nsauce, and add the toppings), then we \nbake it, cut it, and box it! Each Pizza subtype (CheesePizza, \nGreekPizza, etc.) knows how to prepare \nitself. Pizza orderPizza(String type) {\n\t\nPizza pizza;\n       if (type.equals(\"cheese\")) {\n           pizza = new CheesePizza();\n       } else if (type.equals(\"greek\") {\n           pizza = new GreekPizza();\n\t\n} else if (type.equals(\"pepperoni\") {\n           pizza = new PepperoniPizza();\n       } \n\t\npizza.prepare();\n\t\npizza.bake();\t\n\t\npizza.cut();\n\t\npizza.box();\n\t\nreturn pizza;\n}\nBut you need more than one type of pizza...", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 150", "position": 150, "chunk_type": "semantic", "token_estimate": 223}
{"text": "you are here 4\u2003 \u2003 113: the factory pattern\nPizza orderPizza(String type) {\n\t\nPizza pizza;\n       if (type.equals(\"cheese\")) {\n           pizza = new CheesePizza();\n       } else if (type.equals(\"greek\") {\n           pizza = new GreekPizza();\n\t\n} else if (type.equals(\"pepperoni\") {\n           pizza = new PepperoniPizza();\n\t\n} else if (type.equals(\"clam\") {\n           pizza = new ClamPizza();\n\t\n} else if (type.equals(\"veggie\") {\n           pizza = new VeggiePizza();\n       } \n\t\npizza.prepare();\n\t\npizza.bake();\t\n\t\npizza.cut();\n\t\npizza.box();\n\t\nreturn pizza;\n}\nYou realize that all of your competitors have added a couple of trendy pizzas to their \nmenus: the Clam Pizza and the Veggie Pizza. Obviously you need to keep up with the \ncompetition, so you\u2019ll add these items to your menu. And you haven\u2019t been selling many \nGreek pizzas lately, so you decide to take that off the menu:\nThis is what varies. As the pizza \nselection changes \nover time, you\u2019ll have \nto modify this code \nover and over. This is what we expect to \nstay the same. For the most \npart, preparing, cooking, and \npackaging a pizza has remained \nthe same for years and years. So, we don\u2019t expect this code \nto change, just the pizzas it \noperates on. This code is \nNOT closed for \nmodification. If the \nPizza Store changes \nits pizza offerings, we \nhave to open this code \nand modify it. Clearly, dealing with which concrete class is instantiated is really messing up our \norderPizza() method and preventing it from being closed for modification. But now that we \nknow what is varying and what isn\u2019t, it\u2019s probably time to encapsulate it. But the pressure is on to add more pizza types", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 151", "position": 151, "chunk_type": "semantic", "token_estimate": 259}
{"text": "114\u2003 \u2003 Chapter 4: encapsulate object creation\n       if (type.equals(\"cheese\")) {\n           pizza = new CheesePizza();\n\t\n} else if (type.equals(\"pepperoni\") {\n           pizza = new PepperoniPizza();\n\t\n} else if (type.equals(\"clam\") {\n           pizza = new ClamPizza();\n\t\n} else if (type.equals(\"veggie\") {\n           pizza = new VeggiePizza();\n       } \nSo now we know we\u2019d be better off moving the object \ncreation out of the orderPizza() method. But how? Well, what \nwe\u2019re going to do is take the creation code and move it out \ninto another object that is only going to be concerned with \ncreating pizzas. Pizza orderPizza(String type) {\n\t\nPizza pizza;\n\t\npizza.prepare();\n\t\npizza.bake();\t\n\t\npizza.cut();\n\t\npizza.box();\n\t\nreturn pizza;\n}\nFirst we pull the object \ncreation code out of the \norderPizza() method. Then we place that code in an object that \nis only going to worry about how to create \npizzas. If any other object needs a pizza \ncreated, this is the object to come to. We\u2019ve got a name for this new object: we \ncall it a Factory. Factories handle the details of object creation. Once we have \na SimplePizzaFactory, our orderPizza() method becomes a \nclient of that object. Anytime it needs a pizza, it asks the pizza \nfactory to make one. Gone are the days when the orderPizza() \nmethod needs to know about Greek versus Clam pizzas. Now \nthe orderPizza() method just cares that it gets a pizza that \nimplements the Pizza interface so that it can call prepare(), \nbake(), cut(), and box(). We\u2019ve still got a few details to fill in here; for instance, what does \nthe orderPizza() method replace its creation code with? Let\u2019s \nimplement a simple factory for the pizza store and find out...\nWhat\u2019s going to go here? S\ni\nm\np\nl\ne\nP\ni\nz\nza\nF\na\nc\nt\no\nr\ny\nEncapsulating object creation", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 152", "position": 152, "chunk_type": "semantic", "token_estimate": 295}
{"text": "you are here 4\u2003 \u2003 115: the factory pattern\npublic class SimplePizzaFactory {\n    public Pizza createPizza(String type) {\n        Pizza pizza = null;\n        if (type.equals(\"cheese\")) {\n            pizza = new CheesePizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new PepperoniPizza();\n        } else if (type.equals(\"clam\")) {\n            pizza = new ClamPizza();\n        } else if (type.equals(\"veggie\")) {\n            pizza = new VeggiePizza();\n        }\n        return pizza;\n    }\n}\nBuilding a simple pizza factory\nWe\u2019ll start with the factory itself. What we\u2019re going to do is define a class that \nencapsulates the object creation for all pizzas. Here it is...\nHere\u2019s the code we \nplucked out of the \norderPizza() method. First we define a \ncreatePizza() method in \nthe factory. This is the \nmethod all clients will use \nto instantiate new objects. Here\u2019s our new class, the SimplePizzaFactory. It \nhas one job in life: creating pizzas for its clients. This code is still parameterized by the type of the \npizza, just like our original orderPizza() method was. Q: What\u2019s the advantage of this? It looks like we\u2019re just \npushing the problem off to another object. A: One thing to remember is that the SimplePizzaFactory may \nhave many clients. We\u2019ve only seen the orderPizza() method; \nhowever, there may be a PizzaShopMenu class that uses the factory \nto get pizzas for their current description and price. We might also \nhave a HomeDelivery class that handles pizzas in a different way \nthan our PizzaShop class but is also a client of the factory. So, by encapsulating the pizza creating in one class, we now have \nonly one place to make modifications when the implementation \nchanges. And, don\u2019t forget, we\u2019re also just about to remove the concrete \ninstantiations from our client code. Q: I\u2019ve seen a similar design where a factory like this is \ndefined as a static method. What\u2019s the difference? A: Defining a simple factory as a static method is a common \ntechnique and is often called a static factory. Why use a static \nmethod? Because you don\u2019t need to instantiate an object to make \nuse of the create method. But it also has the disadvantage that you \ncan\u2019t subclass and change the behavior of the create method.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 153", "position": 153, "chunk_type": "semantic", "token_estimate": 356}
{"text": "116\u2003 \u2003 Chapter 4: simple factory\npublic class PizzaStore {\n    SimplePizzaFactory factory;\n \n    public PizzaStore(SimplePizzaFactory factory) { \n        this.factory = factory;\n    }\n \n    public Pizza orderPizza(String type) {\n        Pizza pizza;\n \n        pizza = factory.createPizza(type);\n \n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n        return pizza;\n    }\n    // other methods here\n}\nReworking the PizzaStore class \nPizzaStore gets the factory passed \nto it in the constructor. And the orderPizza() method uses the \nfactory to create its pizzas by simply \npassing on the type of the order. Notice that we\u2019ve replaced the new \noperator with a createPizza method \nin the factory object. No more \nconcrete instantiations here! Now it\u2019s time to fix up our client code. What we want to do is rely on the \nfactory to create the pizzas for us. Here are the changes:\nFirst we give PizzaStore a \nreference to a SimplePizzaFactory. We don\u2019t know about you, but we\u2019re thinking New York, Chicago, and California style pizza factories (let\u2019s \nnot forget New Haven, too). We know that object composition allows us to change behavior dynamically at runtime (among \nother things) because we can swap in and out implementations. How might we be able to use \nthat in the PizzaStore? What factory implementations might we be able to swap in and out?", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 154", "position": 154, "chunk_type": "semantic", "token_estimate": 202}
{"text": "you are here 4\u2003 \u2003 117: the factory pattern\nThe Simple Factory defined\nThe Simple Factory isn\u2019t actually a Design Pattern; it\u2019s more of a programming idiom. But it is commonly used, so we\u2019ll give it a Head First Pattern Honorable Mention. Some developers do mistake this idiom for the Factory Pattern, but the next time that \nhappens you can subtly show you know your stuff; just don\u2019t strut as you educate them \non the distinction. Just because Simple Factory isn\u2019t a REAL pattern doesn\u2019t mean we shouldn\u2019t check out \nhow it\u2019s put together. Let\u2019s take a look at the class diagram of our new Pizza Store:\nThink of Simple Factory as a warm-up. Next, we\u2019ll explore two heavy-duty patterns \nthat are both factories. But don\u2019t worry, there\u2019s more pizza to come! This is the factory where we create \npizzas; it should be the only part \nof our application that refers to \nconcrete Pizza classes. This is the client of the \nfactory. PizzaStore \nnow goes through the \nSimplePizzaFactory to get \ninstances of pizza. SimplePizzaFactory\ncreatePizza()\nPizza\nPizzaStore\norderPizza()\nClamPizza\nVeggiePizza\nCheesePizza\nPepperoniPizza\nprepare()\nbake()\ncut()\nbox()\nThese are our concrete products. Each \nproduct needs to implement the Pizza \ninterface* (which in this case means \n\u201cextend the abstract Pizza class\u201d) and \nbe concrete. As long as that\u2019s the case, \nit can be created by the factory and \nhanded back to the client. This is the product of \nthe factory: pizza! We\u2019ve defined Pizza \nas an abstract class \nwith some helpful \nimplementations that \ncan be overridden. The create method is \noften declared statically. *Just another reminder: in design patterns, the phrase \u201cimplement an interface\u201d does NOT always mean \n\u201cwrite a class that implements a Java interface, by using the \u2018implements' keyword in the class declaration.\u201d \nIn the general use of the phrase, a concrete class implementing a method from a supertype (which could be a \nabstract class OR interface) is still considered to be \u201cimplementing the interface\u201d of that supertype. Head First\nHonorable \nMention\nPattern \n \n \n \n \n \n \n \n \n \n \n \n \nHonorable \nMention", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 155", "position": 155, "chunk_type": "semantic", "token_estimate": 334}
{"text": "118\u2003 \u2003 Chapter 4: pizza franchise\nFranchising the pizza store\nYour Objectville Pizza Store has done so well that you\u2019ve trounced \nthe competition and now everyone wants a Pizza Store in their \nown neighborhood. As the franchiser, you want to ensure the \nquality of the franchise operations and so you want them to use \nyour time-tested code. But what about regional differences? Each franchise might want to \noffer different styles of pizzas (New York, Chicago, and California, \nto name a few), depending on where the franchise store is located \nand the tastes of the local pizza connoisseurs. P\ni\nz\nz\na\nSto\nr\ne\nYou want all the franchise pizza stores \nto leverage your PizzaStore code, so the \npizzas are prepared in the same way. One franchise wants a \nfactory that makes NY-style \npizzas: thin crust, tasty sauce, \nand just a little cheese. Another franchise \nwants a factory that \nmakes Chicago-style \npizzas; their customers \nlike pizzas with thick \ncrust, rich sauce, and \ntons of cheese. We\u2019ve seen one approach... If we take out SimplePizzaFactory and create three different \nfactories\u2014NYPizzaFactory, ChicagoPizzaFactory, and \nCaliforniaPizzaFactory\u2014then we can just compose the PizzaStore \nwith the appropriate factory and a franchise is good to go. That\u2019s \none approach. Let\u2019s see what that would look like...", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 156", "position": 156, "chunk_type": "semantic", "token_estimate": 209}
{"text": "you are here 4\u2003 \u2003 119: the factory pattern\nNYPizzaFactory nyFactory = new NYPizzaFactory();\nPizzaStore nyStore = new PizzaStore(nyFactory);\nnyStore.orderPizza(\"Veggie\");\nChicagoPizzaFactory chicagoFactory = new ChicagoPizzaFactory();\nPizzaStore chicagoStore = new PizzaStore(chicagoFactory);\nchicagoStore.orderPizza(\"Veggie\");\nHere we create a factory for \nmaking NY-style pizzas. Then we create a PizzaStore and pass \nit a reference to the NY factory. ...and when we make pizzas, we \nget NY-style pizzas. Likewise for the Chicago pizza stores: we \ncreate a factory for Chicago pizzas and \ncreate a store that is composed with a \nChicago factory. When we make pizzas, we \nget the Chicago-style ones. But you\u2019d like a little more quality control... So you test-marketed the SimpleFactory idea, and what you \nfound was that the franchises were using your factory to \ncreate pizzas, but starting to employ their own home-grown \nprocedures for the rest of the process: they\u2019d bake things \na little differently, they\u2019d forget to cut the pizza, and they\u2019d \nuse third-party boxes. Rethinking the problem a bit, you see that what you\u2019d really \nlike to do is create a framework that ties the store and the \npizza creation together, yet still allows things to remain \nflexible. In our early code, before the SimplePizzaFactory, we had \nthe pizza-making code tied to the PizzaStore, but it wasn\u2019t \nflexible. So, how can we have our pizza and eat it too? Not what you want in a good \nfranchise. You do NOT want to \nknow what he puts on his pizzas. I\u2019ve been making pizza \nfor years so I thought I\u2019d add \nmy own \u201cimprovements\u201d to the \nPizzaStore procedures...", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 157", "position": 157, "chunk_type": "semantic", "token_estimate": 258}
{"text": "120\u2003 \u2003 Chapter 4: let the subclasses decide\nThere is a way to localize all the pizza-making activities to the PizzaStore \nclass, and to give the franchises freedom to have their own regional style. What we\u2019re going to do is put the createPizza() method back into PizzaStore, \nbut this time as an abstract method, and then create a PizzaStore subclass \nfor each regional style. First, let\u2019s look at the changes to the PizzaStore:  \nA framework for the pizza store\npublic abstract class PizzaStore {\n\t\npublic Pizza orderPizza(String type) {\n\t\n\t\nPizza pizza;\n\t\n\t\npizza = createPizza(type);\n\t\n\t\npizza.prepare();\n\t\n\t\npizza.bake();\t\n\t\n\t\npizza.cut();\n\t\n\t\npizza.box();\n\t\n\t\nreturn pizza;\n\t\n}\n\n\t\nabstract Pizza createPizza(String type);\n}\nNow createPizza is back to being a \ncall to a method in the PizzaStore \nrather than on a factory object. All this looks just the same...\nNow we\u2019ve moved our factory \nobject to this method. Our \u201cfactory method\u201d is now \nabstract in PizzaStore. PizzaStore is now abstract (see why below). Now we\u2019ve got a store waiting for subclasses; we\u2019re going to have a \nsubclass for each regional type (NYPizzaStore, ChicagoPizzaStore, \nCaliforniaPizzaStore) and each subclass is going to make the decision about \nwhat makes up a pizza. Let\u2019s take a look at how this is going to work.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 158", "position": 158, "chunk_type": "semantic", "token_estimate": 202}
{"text": "you are here 4\u2003 \u2003 121: the factory pattern\npublic Pizza createPizza(type) {\n    if (type.equals(\"cheese\")) {\n        pizza = new NYStyleCheesePizza();\n    } else if (type.equals(\"pepperoni\") {\n        pizza = new NYStylePepperoniPizza();\n    } else if (type.equals(\"clam\") {\n        pizza = new NYStyleClamPizza();\n    } else if (type.equals(\"veggie\") {\n        pizza = new NYStyleVeggiePizza();\n    }\n}\ncreatePizza()\nChicagoStylePizzaStore\ncreatePizza()\nNYStylePizzaStore\npublic Pizza createPizza(type) {\n    if (type.equals(\"cheese\")) {\n        pizza = new ChicagoStyleCheesePizza();\n    } else if (type.equals(\"pepperoni\") {\n        pizza = new ChicagoStylePepperoniPizza();\n    } else if (type.equals(\"clam\") {\n        pizza = new ChicagoStyleClamPizza();\n    } else if (type.equals(\"veggie\") {\n        pizza = new ChicagoStyleVeggiePizza();\n    }\n}\nSimilarly, by using the \nChicago subclass, we get an \nimplementation of createPizza() \nwith Chicago ingredients. If a franchise wants NY-style \npizzas for its customers, it \nuses the NY subclass, which has \nits own createPizza() method, \ncreating NY-style pizzas. Each subclass provides an implementation \nof the createPizza() method, overriding \n \nthe abstract createPizza() method in \nPizza Store, while all subclasses make use \nof the orderPizza() method defined \nin Pizza Store. We could make the \norderPizza() method final if we really \nwanted to enforce this. createPizza()\norderPizza()\nPizzaStore\nAllowing the subclasses to decide\nRemember, the Pizza Store already has a well-honed order system in the orderPizza() \nmethod and you want to ensure that it\u2019s consistent across all franchises. What varies among the regional Pizza Stores is the style of pizzas they make\u2014New York \npizza has thin crust, Chicago pizza has thick, and so on\u2014and we are going to push all \nthese variations into the createPizza() method and make it responsible for creating the \nright kind of pizza. The way we do this is by letting each subclass of Pizza Store define \nwhat the createPizza() method looks like. So, we\u2019ll have a number of concrete subclasses \nof Pizza Store, each with its own pizza variations, all fitting within the Pizza Store \nframework and still making use of the well-tuned orderPizza() method. Remember: createPizza() is \nabstract in Pizza Store, so \nall pizza store subtypes MUST \nimplement the method.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 159", "position": 159, "chunk_type": "semantic", "token_estimate": 325}
{"text": "you are here 4\u2003 \u2003 123: the factory pattern\npublic class NYPizzaStore extends PizzaStore {\n    Pizza createPizza(String item) {\n        if (item.equals(\"cheese\")) {\n            return new NYStyleCheesePizza();\n        } else if (item.equals(\"veggie\")) {\n            return new NYStyleVeggiePizza();\n        } else if (item.equals(\"clam\")) {\n            return new NYStyleClamPizza();\n        } else if (item.equals(\"pepperoni\")) {\n            return new NYStylePepperoniPizza();\n        } else return null;\n    }\n}\nLet\u2019s make a Pizza Store\nThe NYPizzaStore extends \nPizzaStore, so it inherits the \norderPizza() method (among others). We\u2019ve got to implement \ncreatePizza(), since it is \nabstract in PizzaStore. Being a franchise has its benefits. You get all the PizzaStore \nfunctionality for free. All the regional stores need to do is subclass \nPizzaStore and supply a createPizza() method that implements \ntheir style of pizza. We\u2019ll take care of the big three pizza styles for \nthe franchisees. Here\u2019s the New York regional style:\nOnce we\u2019ve got our PizzaStore subclasses built, it will be time \nto see about ordering up a pizza or two. But before we do that, \nwhy don\u2019t you take a crack at building the Chicago-style and \nCalifornia-style pizza stores on the next page? Here\u2019s where we create our \nconcrete classes. For each type of \nPizza we create the NY style. * Note that the orderPizza() method in the \nsuperclass has no clue which Pizza we are creating; \nit just knows it can prepare, bake, cut, and box it! createPizza() returns a Pizza, and \nthe subclass is fully responsible for \nwhich concrete Pizza it instantiates.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 161", "position": 161, "chunk_type": "semantic", "token_estimate": 239}
{"text": "124\u2003 \u2003 Chapter 4: factory method\nWe\u2019ve knocked out the NYPizzaStore; just two more to go and we\u2019ll be ready to franchise! Write \nthe Chicago-style and California-style PizzaStore implementations here:", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 162", "position": 162, "chunk_type": "semantic", "token_estimate": 29}
{"text": "you are here 4\u2003 \u2003 125: the factory pattern\nWith just a couple of transformations to the PizzaStore class, we\u2019ve gone from \nhaving an object handle the instantiation of our concrete classes to a set of \nsubclasses that are now taking on that responsibility. Let\u2019s take a closer look: \nThe subclasses of \nPizzaStore handle object \ninstantiation for us in the \ncreatePizza() method. createPizza()\nNYStylePizzaStore\ncreatePizza()\nChicagoStylePizzaStore\nDeclaring a factory method\npublic abstract class PizzaStore {\n    public Pizza orderPizza(String type) {\n        Pizza pizza;\n        pizza = createPizza(type);\n        pizza.prepare();\n        pizza.bake();\t\n        pizza.cut();\n        pizza.box();\n        return pizza;\n    }\n    protected abstract Pizza createPizza(String type);\n\n    // other methods here\n}\nAll the responsibility for \ninstantiating Pizzas has \nbeen moved into a method \nthat acts as a factory. Code Up Close\nA factory method handles object creation and encapsulates it in a \nsubclass. This decouples the client code in the superclass from the \nobject creation code in the subclass. abstract Product factoryMethod(String type)\nA factory method \nis abstract so the \nsubclasses are counted \non to handle object \ncreation. A factory method may \nbe parameterized (or \nnot) to select among \nseveral variations of a \nproduct. A factory method isolates the client (the \ncode in the superclass, like orderPizza()) \nfrom knowing what kind of concrete \nProduct is actually created. A factory method returns \na Product that is typically \nused within methods \ndefined in the superclass.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 163", "position": 163, "chunk_type": "semantic", "token_estimate": 223}
{"text": "126\u2003 \u2003 Chapter 4: ordering a pizza\nI like NY-style pizza...you \nknow, thin, crispy crust with \na little cheese and really \ngood sauce. I like Chicago-style deep dish \npizza with thick crust and \ntons of cheese. Ethan needs to order \nhis pizza from a NY \npizza store. Joel needs to order his \npizza from a Chicago  \npizza store. Same pizza \nordering method, but \ndifferent kind of pizza! Joel\nEthan\nLet\u2019s see how it works: ordering pizzas with \nthe pizza factory method\n1\n2\nFirst, Joel and Ethan need an instance of a PizzaStore. Joel needs to instantiate a \nChicagoPizzaStore and Ethan needs a NYPizzaStore. With a PizzaStore in hand, both Ethan and Joel call the orderPizza() method and pass \nin the type of pizza they want (cheese, veggie, and so on). 4\nThe orderPizza() method has no idea what kind of pizza was created, but it knows it is \na pizza and it prepares, bakes, cuts, and boxes it for Ethan and Joel. 3\nTo create the pizzas, the createPizza() method is called, which is defined in the \ntwo subclasses NYPizzaStore and ChicagoPizzaStore. As we defined them, the \nNYPizzaStore instantiates a NY-style pizza, and the ChicagoPizzaStore instantiates a \nChicago-style pizza. In either case, the Pizza is returned to the orderPizza() method. So how do they order?", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 164", "position": 164, "chunk_type": "semantic", "token_estimate": 215}
{"text": "you are here 4\u2003 \u2003 127: the factory pattern\nLet\u2019s check out how these pizzas are \nreally made to order... Behind \nthe Scenes\n1\n2\nPizzaStore nyPizzaStore = new NYPizzaStore();\nLet\u2019s follow Ethan\u2019s order: first we need a NYPizzaStore:\nnyPizzaStore.orderPizza(\"cheese\");\nNow that we have a store, we can take an order:\n3\nThe orderPizza() method then calls the createPizza() \nmethod:\n4\nFinally, we have the unprepared pizza in hand and the \norderPizza() method finishes preparing it:\nPizza pizza  = createPizza(\"cheese\");\n \n  \n \n \nn\ny\nP\ni\nz\nz\naS\nt\no\nr\ne\nCreates a instance of \nNYPizzaStore. The orderPizza() method is called on \nthe nyPizzaStore instance (the method \ndefined inside PizzaStore runs). P\ni\nzza\ncreatePizza(\"cheese\")\nRemember, createPizza(), the factory \nmethod, is implemented in the subclass. In this \ncase it returns a NY-style cheese Pizza. pizza.prepare();\npizza.bake();\npizza.cut();\npizza.box();\nAll of these methods are \ndefined in the specific pizza \nreturned from the factory \nmethod createPizza(), defined \nin the NYPizzaStore. The orderPizza() method gets \nback a Pizza, without knowing \nexactly what concrete class it is.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 165", "position": 165, "chunk_type": "semantic", "token_estimate": 172}
{"text": "128\u2003 \u2003 Chapter 4: the pizza classes\npublic abstract class Pizza {\n    String name;\n    String dough;\n    String sauce;\n    List<String> toppings = new ArrayList<String>();\n \n    void prepare() {\n        System.out.println(\"Preparing \" + name);\n        System.out.println(\"Tossing dough...\");\n        System.out.println(\"Adding sauce...\");\n        System.out.println(\"Adding toppings: \");\n        for (String topping : toppings) {\n            System.out.println(\"   \" + topping);\n        }\n    }\n  \n    void bake() {\n        System.out.println(\"Bake for 25 minutes at 350\");\n    }\n \n    void cut() {\n        System.out.println(\"Cutting the pizza into diagonal slices\");\n    }\n  \n    void box() {\n        System.out.println(\"Place pizza in official PizzaStore box\");\n    }\n \n    public String getName() {\n        return name;\n    }\n}\nWe\u2019re just missing one thing: Pizzas! Our Pizza Store isn\u2019t going to be very popular \nwithout some pizzas, so let\u2019s implement them\nWe\u2019ll start with an abstract \nPizza class, and all the concrete \npizzas will derive from this. Each Pizza has a name, a type of dough, \na type of sauce, and a set of toppings. The abstract class provides \nsome basic defaults for \nbaking, cutting, and boxing. Preparation follows a \nnumber of steps in a \nparticular sequence. REMEMBER: we don\u2019t provide import and package statements in the \ncode listings. Get the complete source code from the wickedlysmart \nwebsite at https://wickedlysmart.com/head-first-design-patterns\n\nIf you lose this URL, you can always quickly find it in the Intro section.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 166", "position": 166, "chunk_type": "semantic", "token_estimate": 202}
{"text": "you are here 4\u2003 \u2003 129: the factory pattern\npublic class ChicagoStyleCheesePizza extends Pizza {\n    public ChicagoStyleCheesePizza() { \n        name = \"Chicago Style Deep Dish Cheese Pizza\";\n        dough = \"Extra Thick Crust Dough\";\n        sauce = \"Plum Tomato Sauce\";\n \n        toppings.add(\"Shredded Mozzarella Cheese\");\n    }\n \n    void cut() {\n        System.out.println(\"Cutting the pizza into square slices\");\n    }\n}\npublic class NYStyleCheesePizza extends Pizza {\n    public NYStyleCheesePizza() { \n        name = \"NY Style Sauce and Cheese Pizza\";\n        dough = \"Thin Crust Dough\";\n        sauce = \"Marinara Sauce\";\n \n        toppings.add(\"Grated Reggiano Cheese\");\n    }\n}\nNow we just need some concrete subclasses...how about defining \nNew York and Chicago-style cheese pizzas? The NY Pizza has its own \nmarinara-style sauce and thin crust. And one topping, Reggiano cheese! The Chicago-style deep \ndish pizza has lots of \nmozzarella cheese! The Chicago-style pizza also overrides the cut() \nmethod so that the pieces are cut into squares. The Chicago Pizza uses plum \ntomatoes as a sauce along \nwith extra-thick crust.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 167", "position": 167, "chunk_type": "semantic", "token_estimate": 152}
{"text": "you are here 4\u2003 \u2003 131: the factory pattern\ncreatePizza()\nChicagoPizzaStore\ncreatePizza()\nNYPizzaStore\nPizza\nNYStyleCheesePizza\nNYStyleVeggiePizza\nNYStyleClamPizza\nNYStylePepperoniPizza\nChicagoStyleVeggiePizza\nChicagoStyleClamPizza\nChicagoStylePepperoniPizza\nChicagoStyleCheesePizza\ncreatePizza()\norderPizza()\nPizzaStore\nIt\u2019s finally time to meet the Factory Method Pattern\nAll factory patterns encapsulate object creation. The Factory Method Pattern encapsulates object \ncreation by letting subclasses decide what objects to create. Let\u2019s check out these class diagrams to see \nwho the players are in this pattern:\nOften the creator contains code \nthat depends on an abstract product, \nwhich is produced by a subclass. The \ncreator never really knows which \nconcrete product was produced. Since each franchise gets its \nown subclass of PizzaStore, \nit\u2019s free to create its own \nstyle of pizza by implementing \ncreatePizza(). The createPizza() method \nis our factory method. It \nproduces products. This is our abstract \ncreator class. It defines \nan abstract factory \nmethod that the \nsubclasses implement to \nproduce products. These are the concrete \nproducts\u2009\u2014\u2009all the pizzas that \nare produced by our stores. Factories produce products, \nand in the PizzaStore, our \nproduct is a Pizza. The Creator classes\nThe Product classes\nClasses that produce \nproducts are called \nconcrete creators.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 169", "position": 169, "chunk_type": "semantic", "token_estimate": 187}
{"text": "132\u2003 \u2003 Chapter 4: creators and products\nView Creators and Products in Parallel\nFor every concrete Creator, there\u2019s typically a whole set of products that \nit creates. Chicago pizza creators create different types of Chicago-style \npizza, New York pizza creators create different types of New York\u2013style \npizza, and so on. In fact, we can view our sets of Creator classes and their \ncorresponding Product classes as parallel hierarchies. Let\u2019s look at the two parallel class hierarchies and see how they relate:\nPizza\nThe NYPizzaStore \nencapsulates all the \nknowledge about how to \nmake NY-style pizzas. The ChicagoPizzaStore \nencapsulates all the \nknowledge about how to \nmake Chicago-style pizzas. Notice how these \nclass hierarchies are \nparallel: both have \nabstract classes that \nare extended by \nconcrete classes, which \nknow about specific \nimplementations for \nNY and Chicago pizza. The factory method is the key to encapsulating this knowledge. createPizza()\nChicagoPizzaStore\ncreatePizza()\nNYPizzaStore\ncreatePizza()\norderPizza()\nPizzaStore\nNYStyleClamPizza\nChicagoStyleVeggiePizza\nChicagoStyleClamPizza\nChicagoStylePepperoniPizza\nChicagoStyleCheesePizza\nNYStylePepperoniPizza\nNYStyleCheesePizza\nNYStyleVeggiePizza\nThe Creator classes\nThe Product classes", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 170", "position": 170, "chunk_type": "semantic", "token_estimate": 163}
{"text": "you are here 4\u2003 \u2003 133: the factory pattern\nWe need another kind of pizza for those crazy Californians (crazy in a good way, \nof course). Draw another parallel set of classes that you\u2019d need to add a new \nCalifornia region to our PizzaStore. createPizza()\norderPizza()\nPizzaStore\nOkay, now write the five most bizarre things you can think of to put on a pizza. Then, you\u2019ll be ready to go into business making pizza in California! NYStyleCheesePizza\nNYStyleVeggiePizza\nNYStyleClamPizza\nNYStylePepperoniPizza\nChicagoStyleVeggiePizza\nChicagoStyleClamPizza\nChicagoStylePepperoniPizza\nChicagoStyleCheesePizza\ncreatePizza()\nChicagoPizzaStore\ncreatePizza()\nNYPizzaStore\nYour drawing here...\n Design Puzzle", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 171", "position": 171, "chunk_type": "semantic", "token_estimate": 92}
{"text": "134\u2003 \u2003 Chapter 4: factory method defined\nFactory Method Pattern defined\nThe Factory Method Pattern defines an interface \nfor creating an object, but lets subclasses decide which \nclass to instantiate. Factory Method lets a class defer \ninstantiation to subclasses. It\u2019s time to roll out the official definition of the Factory Method Pattern:\nAs with every factory, the Factory Method Pattern gives us a way to encapsulate the \ninstantiations of concrete types. Looking at the class diagram below, you can see that the \nabstract Creator class gives you an interface with a method for creating objects, also known \nas the \u201cfactory method.\u201d Any other methods implemented in the abstract Creator are \nwritten to operate on products produced by the factory method. Only subclasses actually \nimplement the factory method and create products. As in the official definition, you\u2019ll often hear developers say, \u201cthe Factory Method pattern \nlets subclasses decide which class to instantiate.\u201d Because the Creator class is written without \nknowledge of the actual products that will be created, we say \u201cdecide\u201d not because the \npattern allows subclasses themselves to decide, but rather, because the decision actually comes \ndown to which subclass is used to create the product. Product\nConcreteProduct\nfactoryMethod()\nanOperation()\nCreator\nfactoryMethod()\nConcreteCreator\nCreator is a class that contains \nthe implementations for all of the \nmethods to manipulate products, \nexcept for the factory method. ConcreteCreator \nimplements the \nfactoryMethod(), which is \nthe method that actually \nproduces products. All products must implement \nthe same interface so that the \nclasses that use the products \ncan refer to the interface, \nnot the concrete class. ConcreteCreator is responsible for creating \none or more concrete products. It is the \nonly class that has the knowledge of how \nto create these products. The abstract factoryMethod() \nis what all Creator subclasses \nmust implement. You could ask them what \n\u201cdecides\u201d means, but we \nbet you now understand \nthis better than they do!", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 172", "position": 172, "chunk_type": "semantic", "token_estimate": 312}
{"text": "you are here 4\u2003 \u2003 135: the factory pattern\nQ: What\u2019s the advantage of the Factory Method \nPattern when you only have one ConcreteCreator? A: The Factory Method Pattern is useful if you\u2019ve only \ngot one concrete creator because you are decoupling the \nimplementation of the product from its use. If you add \nadditional products or change a product\u2019s implementation, \nit will not affect your Creator (because the Creator is not \ntightly coupled to any ConcreteProduct). Q: Would it be correct to say that our NY and \nChicago stores are implemented using Simple \nFactory? They look just like it. A: They\u2019re similar, but used in different ways. Even \nthough the implementation of each concrete store looks \na lot like the SimplePizzaFactory, remember that the \nconcrete stores are extending a class that has defined \ncreatePizza() as an abstract method. It is up to each \nstore to define the behavior of the createPizza() method. In Simple Factory, the factory is another object that is \ncomposed with the PizzaStore. Q: Are the factory method and the Creator class \nalways abstract? A: No, you can define a default factory method to \nproduce some concrete product. Then you always \nhave a means of creating products even if there are no \nsubclasses of the Creator class. Q: Each store can make four different kinds of \npizzas based on the type passed in. Do all concrete \ncreators make multiple products, or do they \nsometimes just make one? A: We implemented what is known as the \nparameterized factory method. It can make more than one \nobject based on a parameter passed in, as you noticed. Often, however, a factory just produces one object and is \nnot parameterized. Both are valid forms of the pattern. Q: Your parameterized types don\u2019t seem \u201ctype-\nsafe.\u201d I\u2019m just passing in a String! What if I asked for a \n\u201cCalmPizza\u201d? A: You are certainly correct, and that would cause what \nwe call in the business a \u201cruntime error.\u201d There are several \nother more sophisticated techniques that can be used to \nmake parameters more \u201ctype safe\u201d\u2014in other words, to \nensure errors in parameters can be caught at compile time. For instance, you can create objects that represent the \nparameter types, use static constants, or use enums. Q: I\u2019m still a bit confused about the difference \nbetween Simple Factory and Factory Method. They \nlook very similar, except that in Factory Method, the \nclass that returns the pizza is a subclass.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 173", "position": 173, "chunk_type": "semantic", "token_estimate": 404}
{"text": "you are here 4\u2003 \u2003 135: Q: I\u2019m still a bit confused about the difference \nbetween Simple Factory and Factory Method. They \nlook very similar, except that in Factory Method, the \nclass that returns the pizza is a subclass. Can you \nexplain? A: You\u2019re right that the subclasses do look a lot like \nSimple Factory; however, think of Simple Factory as a \none-shot deal, while with Factory Method you are creating \na framework that lets the subclasses decide which \nimplementation will be used. For example, the orderPizza() \nmethod in the Factory Method Pattern provides a general \nframework for creating pizzas that relies on a factory \nmethod to actually create the concrete classes that go \ninto making a pizza. By subclassing the PizzaStore class, \nyou decide what concrete products go into making the \npizza that orderPizza() returns. Compare that with Simple \nFactory, which gives you a way to encapsulate object \ncreation, but doesn\u2019t give you the flexibility of Factory \nMethod because there is no way to vary the products \nyou\u2019re creating.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 173", "position": 173, "chunk_type": "semantic", "token_estimate": 169}
{"text": "136\u2003 \u2003 Chapter 4: master and student\nGuru and Student...\nGuru: Tell me about your training. Student: Guru, I have taken my study of \u201cencapsulate what \nvaries\u201d further. Guru: Go on...\nStudent: I have learned that one can encapsulate the code \nthat creates objects. When you have code that instantiates \nconcrete classes, this is an area of frequent change. I\u2019ve learned \na technique called \u201cfactories\u201d that allows you to encapsulate this \nbehavior of instantiation. Guru: And these \u201cfactories,\u201d of what benefit are they? Student: There are many. By placing all my creation code in one \nobject or method, I avoid duplication in my code and provide one \nplace to perform maintenance. That also means clients depend \nonly upon interfaces rather than the concrete classes required to \ninstantiate objects. As I have learned in my studies, this allows me \nto program to an interface, not an implementation, and that makes \nmy code more flexible and extensible in the future. Guru: Yes, your OO instincts are growing. Do you have any \nquestions for your guru today? Student: Guru, I know that by encapsulating object creation I am \ncoding to abstractions and decoupling my client code from actual \nimplementations. But my factory code must still use concrete \nclasses to instantiate real objects. Am I not pulling the wool over \nmy own eyes? Guru: Object creation is a reality of life; we must create objects or \nwe will never create a single Java application. But, with knowledge \nof this reality, we can design our code so that we have corralled \nthis creation code like the sheep whose wool you would pull \nover your eyes. Once corralled, we can protect and care for the \ncreation code. If we let our creation code run wild, then we will \nnever collect its \u201cwool.\u201d\nStudent: Guru, I see the truth in this. Guru:  As I knew you would. Now, please go and meditate on \nobject dependencies.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 174", "position": 174, "chunk_type": "semantic", "token_estimate": 317}
{"text": "you are here 4\u2003 \u2003 137: the factory pattern\npublic class DependentPizzaStore {\n \n    public Pizza createPizza(String style, String type) {\n        Pizza pizza = null;\n        if (style.equals(\"NY\")) {\n            if (type.equals(\"cheese\")) {\n                pizza = new NYStyleCheesePizza();\n            } else if (type.equals(\"veggie\")) {\n                pizza = new NYStyleVeggiePizza();\n            } else if (type.equals(\"clam\")) {\n                pizza = new NYStyleClamPizza();\n            } else if (type.equals(\"pepperoni\")) {\n                pizza = new NYStylePepperoniPizza();\n            }\n        } else if (style.equals(\"Chicago\")) {\n            if (type.equals(\"cheese\")) {\n                pizza = new ChicagoStyleCheesePizza();\n            } else if (type.equals(\"veggie\")) {\n                pizza = new ChicagoStyleVeggiePizza();\n            } else if (type.equals(\"clam\")) {\n                pizza = new ChicagoStyleClamPizza();\n            } else if (type.equals(\"pepperoni\")) {\n                pizza = new ChicagoStylePepperoniPizza();\n            }\n        } else {\n            System.out.println(\"Error: invalid type of pizza\");\n            return null;\n        }\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n        return pizza;\n    }\n}\nLet\u2019s pretend you\u2019ve never heard of an OO factory. Here\u2019s a \u201cvery dependent\u201d \nversion of PizzaStore that doesn\u2019t use a factory. We need you to make a count \nof the number of concrete pizza classes this class is dependent on. If you \nadded California-style pizzas to this PizzaStore, how many classes would it be \ndependent on then? You can write your \nanswers here:\nnumber\nnumber with \nCalifornia, too\nHandles all the \nNY-style pizzas\nHandles all the \nChicago-style pizzas", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 175", "position": 175, "chunk_type": "semantic", "token_estimate": 198}
{"text": "138\u2003 \u2003 Chapter 4: object dependencies\nLooking at object dependencies\nWhen you directly instantiate an object, you are depending on its \nconcrete class. Take a look at our very dependent PizzaStore one \npage back. It creates all the pizza objects right in the PizzaStore class \ninstead of delegating to a factory. If we draw a diagram representing that version of the PizzaStore \nand all the objects it depends on, here\u2019s what it looks like:\n \n \n \n \n \n \n \n \n \nP\ni\nz\nz\na\nS\nt\no\nr\ne\nIf the implementation of these \nclasses changes, then we may \nhave to modify in PizzaStore.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 176", "position": 176, "chunk_type": "semantic", "token_estimate": 98}
{"text": "you are here 4\u2003 \u2003 139: the factory pattern\nDesign Principle\nDepend upon abstractions. Do \nnot depend upon concrete classes. At first, this principle sounds a lot like \u201cProgram to an \ninterface, not an implementation,\u201d right? It is similar; \nhowever, the Dependency Inversion Principle makes an even \nstronger statement about abstraction. It suggests that our \nhigh-level components should not depend on our low-level \ncomponents; rather, they should both depend on abstractions. But what the heck does that mean? Well, let\u2019s start by looking again at the pizza store diagram \non the previous page. PizzaStore is our \u201chigh-level \ncomponent\u201d and the pizza implementations are our \u201clow-\nlevel components,\u201d and clearly PizzaStore is dependent on \nthe concrete pizza classes. Now, this principle tells us we should instead write our code \nso that we are depending on abstractions, not concrete \nclasses. That goes for both our high-level modules and our \nlow-level modules. But how do we do this? Let\u2019s think about how we\u2019d apply this \nprinciple to our very dependent PizzaStore implementation... It should be pretty clear that reducing dependencies to \nconcrete classes in our code is a \u201cgood thing.\u201d In fact, we\u2019ve \ngot an OO design principle that formalizes this notion; it even \nhas a big, formal name: Dependency Inversion Principle. Here\u2019s the general principle:\nThe Dependency Inversion Principle\nYet another phrase you can \nuse to impress the execs in \nthe room! Your raise will \nmore than offset the cost \nof this book, and you\u2019ll \ngain the admiration of \nyour fellow developers. A \u201chigh-level\u201d component is a class \nwith behavior defined in terms of \nother, \u201clow-level\u201d components. For example, PizzaStore is a \nhigh-level component because \nits behavior is defined in terms \nof pizzas\u2009\u2014\u2009it creates all the \ndifferent pizza objects, and \nprepares, bakes, cuts, and boxes \nthem, while the pizzas it uses are \nlow-level components.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 177", "position": 177, "chunk_type": "semantic", "token_estimate": 303}
{"text": "140\u2003 \u2003 Chapter 4: dependency inversion principle\nApplying the Principle\nNow, the main problem with the very dependent PizzaStore is that it depends \non every type of pizza because it actually instantiates concrete types in its \norderPizza() method. While we\u2019ve created an abstraction, Pizza, we\u2019re nevertheless creating concrete \nPizzas in this code, so we don\u2019t get a lot of leverage out of this abstraction. How can we get those instantiations out of the orderPizza() method? Well, as we \nknow, the Factory Method Pattern allows us to do just that. So, after we\u2019ve applied the Factory Method Pattern, our diagram looks like this:\n \n \n \n  \nP\ni\nz\nz\na\nSt\no\nr\ne\n \n \n \n  \n \n \n \nP\ni\nz\nza", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 178", "position": 178, "chunk_type": "semantic", "token_estimate": 114}
{"text": "t: y\nl\ne\nC\nh\ne\ne\ns\neP\ni\nzza\nCh\nic\na\ng\no\nS\nt\ny\nl\ne\nP\nep\np\ner\no\nn\ni\nP\nizza\nC\nhi\nc\na\ng\no\nS\nt\ny\nl\ne\nC\nh\ne\ne\ns\nePizza\nC\nhi\nc\na\ng\no\nS\nt\ny\nl\ne\nV\ne\ng\ng\ni\ne\nPizza\nC\nhi\nc\na\ng\no\nS\nt\ny\nl\ne\nC\nl\na\nm\nP\ni\nzza\nThe concrete pizza classes depend on \nthe Pizza abstraction too, because \nthey implement the Pizza interface \n(remember, we\u2019re using \u201cinterface\u201d \nin the general sense) in the Pizza \nabstract class. Pizza is an abstract \nclass...an abstraction. PizzaStore now depends only \non Pizza, the abstract class. After applying Factory Method, you\u2019ll notice that our high-level component, the \nPizzaStore, and our low-level components, the pizzas, both depend on Pizza, the \nabstraction. Factory Method is not the only technique for adhering to the Dependency \nInversion Principle, but it is one of the more powerful ones.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 178", "position": 178, "chunk_type": "semantic", "token_estimate": 175}
{"text": "you are here 4\u2003 \u2003 141: the factory pattern\nThe \u201cinversion\u201d in the name Dependency Inversion \nPrinciple is there because it inverts the way you typically \nmight think about your OO design. Look at the diagram \non the previous page. Notice that the low-level components \nnow depend on a higher-level abstraction. Likewise, the \nhigh-level component is also tied to the same abstraction. So, the top-to-bottom dependency chart we drew a couple \nof pages back has inverted itself, with both high-level and \nlow-level modules now depending on the abstraction. Let\u2019s also walk through the thinking behind the typical \ndesign process and see how introducing the principle can \ninvert the way we think about the design...\nWhere\u2019s the \u201cinversion\u201d in Dependency \nInversion Principle? Okay, I get \nthe dependency part, \nbut why is it called \ndependency inversion?", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 179", "position": 179, "chunk_type": "semantic", "token_estimate": 133}
{"text": "142\u2003 \u2003 Chapter 4: invert your thinking\nRight, you start at the top and follow things \ndown to the concrete classes. But, as you\u2019ve seen, \nyou don\u2019t want your pizza store to know about \nthe concrete pizza types, because then it\u2019ll be \ndependent on all those concrete classes! Now, let\u2019s \u201cinvert\u201d your thinking...instead of \nstarting at the top, start at the Pizzas and think \nabout what you can abstract. Right! You are thinking about the abstraction Pizza. So now, go back and think about the design of the \nPizza Store again. Close. But to do that you\u2019ll have to rely on a \nfactory to get those concrete classes out of \nyour Pizza Store. Once you\u2019ve done that, your \ndifferent concrete pizza types depend only on an \nabstraction, and so does your store. We\u2019ve taken \na design where the store depended on concrete \nclasses and inverted those dependencies (along \nwith your thinking). Okay, so you need to implement a Pizza Store. What\u2019s the first thought that pops into your head? Inverting your thinking...\nWell, a CheesePizza and a \nVeggiePizza and a ClamPizza are \nall just Pizzas, so they should \nshare a Pizza interface. Hmmm, Pizza Stores \nprepare, bake, and box pizzas. So, my store needs to be able to \nmake a bunch of different pizzas: \nCheesePizza, VeggiePizza, ClamPizza, \nand so on... Since I now have a Pizza \nabstraction, I can design my \nPizza Store and not worry about \nthe concrete pizza classes.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 180", "position": 180, "chunk_type": "semantic", "token_estimate": 240}
{"text": "you are here 4\u2003 \u2003 143: the factory pattern\nA few guidelines to help you follow \nthe Principle...\nYou\u2019re exactly right! Like many of our principles, this is a guideline \nyou should strive for, rather than a rule you should follow all the time. Clearly, every single Java program ever written violates these guidelines! But, if you internalize these guidelines and have them in the back of \nyour mind when you design, you\u2019ll know when you are violating the \nprinciple and you\u2019ll have a good reason for doing so. For instance, if you \nhave a class that isn\u2019t likely to change, and you know it, then it\u2019s not the \nend of the world if you instantiate a concrete class in your code. Think \nabout it; we instantiate String objects all the time without thinking twice. Does that violate the principle? Yes. Is that okay? Yes. Why? Because \nString is very unlikely to change. If, on the other hand, a class you write is likely to change, you have some \ngood techniques like Factory Method to encapsulate that change. The following guidelines can help you avoid OO designs that violate \nthe Dependency Inversion Principle:\n\t\n\u0083\nNo variable should hold a reference to a concrete class. \u0083\nNo class should derive from a concrete class. \u0083\nNo method should override an implemented method of any \nof its base classes. If you use new, you\u2019ll be holding a \nreference to a concrete class. Use \na factory to get around that! If you derive from a concrete class, you\u2019re \ndepending on a concrete class. Derive from an \nabstraction, like an interface or an abstract class. If you override an implemented method, \nthen your base class wasn\u2019t really an \nabstraction to start with. Those methods \nimplemented in the base class are meant to \nbe shared by all your subclasses. But wait, aren\u2019t these \nguidelines impossible to \nfollow? If I follow these, \nI\u2019ll never be able to write \na single program!", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 181", "position": 181, "chunk_type": "semantic", "token_estimate": 324}
{"text": "144\u2003 \u2003 Chapter 4: families of ingredients\nThe design for the Pizza Store is really shaping up: it\u2019s got a \nflexible framework and it does a good job of adhering to design \nprinciples. Now, the key to Objectville Pizza\u2019s success has always been fresh, \nquality ingredients, and what you\u2019ve discovered is that with the \nnew framework your franchises have been following your procedures, \nbut a few franchises have been substituting inferior ingredients in \ntheir pizzas to lower costs and increase their margins. You know \nyou\u2019ve got to do something, because in the long term this is going \nto hurt the Objectville brand! So how are you going to ensure each franchise is using quality ingredients? You\u2019re going to build a factory that produces them and ships them to your \nfranchises! Now there\u2019s only one problem with this plan: the franchises are located in \ndifferent regions and what is red sauce in New York is not red sauce in Chicago. So, you have one set of ingredients that needs to be shipped to New York and a \ndifferent set that needs to be shipped to Chicago. Let\u2019s take a closer look:\nEnsuring consistency in your ingredients\nCheese Pizza\n   Marinara Sauce, Reggiano, Garlic\nVeggie Pizza\n   Marinara Sauce, Reggiano, Mushrooms, \n   Onions, Red Peppers\nClam Pizza\n   Marinara Sauce, Reggiano, Fresh Clams\nPepperoni Pizza\n   Marinara Sauce, Reggiano, Mushrooms, \n   Onions, Red Peppers, Pepperoni\nNew York\nPizzaMenu\nCheese Pizza\n   Plum Tomato Sauce, Mozzarella, Parmesan,\n    Oregano\nVeggie Pizza\n   Plum Tomato Sauce, Mozzarella, Parmesan,\n   Eggplant, Spinach, Black Olives\nClam Pizza\n   Plum Tomato Sauce, Mozzarella, Parmesan, Clams\nPepperoni Pizza\n   Plum Tomato Sauce, Mozzarella, Parmesan,\n   Eggplant, Spinach, Black Olives, Pepperoni\nChicago\nPizzaMenu\nWe\u2019ve got the \nsame product \nfamilies (dough, \nsauce, cheese, \nveggies, meats) \nbut different \nimplementations \nbased on region. Meanwhile, back at the Pizza Store...\nDough\nSauce\nCheese\nVeggies\nPepperoni\nThat is, the baking, \nthe cutting, the \nboxing, and so on...", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 182", "position": 182, "chunk_type": "semantic", "token_estimate": 309}
{"text": "you are here 4\u2003 \u2003 145: the factory pattern\nFamilies of ingredients...\nNew York uses one set of ingredients and \nChicago another. Given the popularity of \nObjectville Pizza, it won\u2019t be long before \nyou also need to ship another set of regional \ningredients to California, and what\u2019s next? Austin? For this to work, you\u2019re going to have to figure \nout how to handle families of ingredients. ReggianoCheese\nThinCrustDough\nFreshClams\nFreshClams\nMarinaraSauce\nBruschettaSauce\nGoatCheese\nVeryThinCrustDough\nCalifornia\nFrozenClams\nPlumTomatoSauce\nMozzarellaCheese\nThickCrustDough\nNew York\nChicago\nAll Objectville\u2019s Pizzas are made from the same \ncomponents, but each region has a different \nimplementation of those components. In total, these three regions make up ingredient families, with \neach region implementing a complete family of ingredients. Each family consists of a type of dough, \na type of sauce, a type of cheese, and a \nseafood topping (along with a few more we \nhaven\u2019t shown, like veggies and spices).", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 183", "position": 183, "chunk_type": "semantic", "token_estimate": 150}
{"text": "146\u2003 \u2003 Chapter 4: ingredient factories\npublic interface PizzaIngredientFactory {\n \n    public Dough createDough();\n    public Sauce createSauce();\n    public Cheese createCheese();\n    public Veggies[] createVeggies();\n    public Pepperoni createPepperoni();\n    public Clams createClam();\n \n}\nBuilding the ingredient factories\nNow we\u2019re going to build a factory to create our ingredients; the \nfactory will be responsible for creating each ingredient in the \ningredient family. In other words, the factory will need to create \ndough, sauce, cheese, and so on... You\u2019ll see how we are going to \nhandle the regional differences shortly. Let\u2019s start by defining an interface for the factory that is going to \ncreate all our ingredients:\nFor each ingredient we define a \ncreate method in our interface. With that interface, here\u2019s what we\u2019re going to do:\nLots of new classes here, \none per ingredient. 1\n2\n3\nBuild a factory for each region. To do this, you\u2019ll create a subclass of \nPizzaIngredientFactory that implements each create method. Implement a set of ingredient classes to be used with the factory, like \nReggianoCheese, RedPeppers, and ThickCrustDough. These classes can be \nshared among regions where appropriate. Then we still need to hook all this up by working our new ingredient \nfactories into our old PizzaStore code.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 184", "position": 184, "chunk_type": "semantic", "token_estimate": 197}
{"text": "you are here 4\u2003 \u2003 147: the factory pattern\npublic class NYPizzaIngredientFactory implements PizzaIngredientFactory {\n \n    public Dough createDough() {\n        return new ThinCrustDough();\n    }\n \n    public Sauce createSauce() {\n        return new MarinaraSauce();\n    }\n \n    public Cheese createCheese() {\n        return new ReggianoCheese();\n    }\n \n    public Veggies[] createVeggies() {\n        Veggies veggies[] = { new Garlic(), new Onion(), new Mushroom(), new RedPepper() };\n        return veggies;\n    }\n \n    public Pepperoni createPepperoni() {\n        return new SlicedPepperoni();\n    }\n    public Clams createClam() {\n        return new FreshClams();\n    }\n}\nBuilding the New York ingredient factory\nOkay, here\u2019s the implementation for the New York ingredient factory. This \nfactory specializes in Marinara Sauce, Reggiano Cheese, Fresh Clams, etc. The NY ingredient factory \nimplements the interface for all \ningredient factories. For each ingredient in the \ningredient family, we create \nthe New York version. For veggies, we return an array of \nVeggies. Here we\u2019ve hardcoded the \nveggies. We could make this more \nsophisticated, but that doesn\u2019t really \nadd anything to learning the factory \npattern, so we\u2019ll keep it simple. The best sliced pepperoni. This is shared between New \nYork and Chicago. Make sure \nyou use it on the next page \nwhen you get to implement \nthe Chicago factory yourself. New York is on the coast; it \ngets fresh clams. Chicago has \nto settle for frozen.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 185", "position": 185, "chunk_type": "semantic", "token_estimate": 207}
{"text": "148\u2003 \u2003 Chapter 4: build a factory\nWrite the ChicagoPizzaIngredientFactory. You can reference \nthe classes below in your implementation:\nSlicedPepperoni\nEggPlant\nSpinach\nBlackOlives\nFrozenClams\nPlumTomatoSauce\nMozzarellaCheese\nThickCrustDough", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 186", "position": 186, "chunk_type": "semantic", "token_estimate": 26}
{"text": "you are here 4\u2003 \u2003 149: the factory pattern\npublic abstract class Pizza {\n    String name;\n    Dough dough;\n    Sauce sauce;\n    Veggies veggies[];\n    Cheese cheese;\n    Pepperoni pepperoni;\n    Clams clam;\n    abstract void prepare();\n    void bake() {\n        System.out.println(\"Bake for 25 minutes at 350\");\n    }\n    void cut() {\n        System.out.println(\"Cutting the pizza into diagonal slices\");\n    }\n    void box() {\n        System.out.println(\"Place pizza in official PizzaStore box\");\n    }\n    void setName(String name) {\n        this.name = name;\n    }\n    String getName() {\n        return name;\n    }\n    public String toString() {\n        // code to print pizza here\n    }\n}\nReworking the pizzas...\nWe\u2019ve got our factories all fired up and ready to produce quality ingredients; now we \njust need to rework our Pizzas so they only use factory-produced ingredients. We\u2019ll \nstart with our abstract Pizza class:\nEach pizza holds a set of ingredients \nthat are used in its preparation. Our other methods remain the same, with \nthe exception of the prepare method. We\u2019ve now made the prepare method abstract. This is where we are going to collect the \ningredients needed for the pizza, which of \ncourse will come from the ingredient factory.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 187", "position": 187, "chunk_type": "semantic", "token_estimate": 179}
{"text": "150\u2003 \u2003 Chapter 4: decoupling ingredients\npublic class CheesePizza extends Pizza {\n    PizzaIngredientFactory ingredientFactory;\n \n    public CheesePizza(PizzaIngredientFactory ingredientFactory) {\n        this.ingredientFactory = ingredientFactory;\n    }\n \n    void prepare() {\n        System.out.println(\"Preparing \" + name);\n        dough = ingredientFactory.createDough();\n        sauce = ingredientFactory.createSauce();\n        cheese = ingredientFactory.createCheese();\n    }\n}\nReworking the pizzas, continued...\nNow that you\u2019ve got an abstract Pizza class to work from, it\u2019s time to \ncreate the New York\u2013 and Chicago-style Pizzas\u2014only this time around, \nthey\u2019ll get their ingredients straight from the factory. The franchisees\u2019 days \nof skimping on ingredients are over! When we wrote the Factory Method code, we had a NYCheesePizza and \na ChicagoCheesePizza class. If you look at the two classes, the only thing \nthat differs is the use of regional ingredients. The pizzas are made just \nthe same (dough + sauce + cheese). The same goes for the other pizzas: \nVeggie, Clam, and so on. They all follow the same preparation steps; they \njust have different ingredients. So, what you\u2019ll see is that we really don\u2019t need two classes for each pizza; \nthe ingredient factory is going to handle the regional differences for us. Here\u2019s the CheesePizza:\nT\no make a pizza now, we \nneed a factory to provide \nthe ingredients. So each \nPizza class gets a factory \npassed into its constructor, \nand it\u2019s stored in an \ninstance variable. Here\u2019s where the magic happens! The prepare() method steps through creating \na cheese pizza, and each time it needs an \ningredient, it asks the factory to produce it.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 188", "position": 188, "chunk_type": "semantic", "token_estimate": 243}
{"text": "you are here 4\u2003 \u2003 151: the factory pattern\npublic class ClamPizza extends Pizza {\n    PizzaIngredientFactory ingredientFactory;\n \n    public ClamPizza(PizzaIngredientFactory ingredientFactory) {\n        this.ingredientFactory = ingredientFactory;\n    }\n \n    void prepare() {\n        System.out.println(\"Preparing \" + name);\n        dough = ingredientFactory.createDough();\n        sauce = ingredientFactory.createSauce();\n        cheese = ingredientFactory.createCheese();\n        clam = ingredientFactory.createClam();\n    }\n}\nCode Up Close\nThe Pizza code uses the factory it has been composed with to produce the ingredients used in the \npizza. The ingredients produced depend on which factory we\u2019re using. The Pizza class doesn\u2019t care; \nit knows how to make pizzas. Now, it\u2019s decoupled from the differences in regional ingredients and can \nbe easily reused when there are factories for the Austin, the Nashville, and beyond. sauce = ingredientFactory.createSauce();\nWe\u2019re setting the \nPizza instance \nvariable to refer to \nthe specific sauce \nused in this pizza. The createSauce() method returns the sauce \nthat is used in its region. If this is a NY \ningredient factory, then we get marinara sauce. This is our ingredient factory. The Pizza class doesn\u2019t care \nwhich factory is used, as long \nas it\u2019s an ingredient factory. Let\u2019s check out the ClamPizza as well:\nClamPizza also stashes \nan ingredient factory. T\no make a clam pizza, the prepare() \nmethod collects the right \ningredients from its local factory. If it\u2019s a New York factory, \nthe clams will be fresh; if it\u2019s \nChicago, they\u2019ll be frozen.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 189", "position": 189, "chunk_type": "semantic", "token_estimate": 223}
{"text": "152\u2003 \u2003 Chapter 4: use the right ingredient factory\npublic class NYPizzaStore extends PizzaStore {\n \n    protected Pizza createPizza(String item) {\n        Pizza pizza = null;\n        PizzaIngredientFactory ingredientFactory = \n            new NYPizzaIngredientFactory();\n \n        if (item.equals(\"cheese\")) {\n  \n            pizza = new CheesePizza(ingredientFactory);\n            pizza.setName(\"New York Style Cheese Pizza\");\n  \n        } else if (item.equals(\"veggie\")) {\n \n            pizza = new VeggiePizza(ingredientFactory);\n            pizza.setName(\"New York Style Veggie Pizza\");\n \n        } else if (item.equals(\"clam\")) {\n \n            pizza = new ClamPizza(ingredientFactory);\n            pizza.setName(\"New York Style Clam Pizza\");\n \n        } else if (item.equals(\"pepperoni\")) {\n            pizza = new PepperoniPizza(ingredientFactory);\n            pizza.setName(\"New York Style Pepperoni Pizza\");\n \n        } \n        return pizza;\n    }\n}\nRevisiting our pizza stores\nWe\u2019re almost there; we just need to make a quick trip to our franchise stores to make \nsure they are using the correct Pizzas. We also need to give them a reference to their \nlocal ingredient factories:\nThe NY Store is composed with \na NY pizza ingredient factory. This will be used to produce the \ningredients for all NY-style \npizzas. We now pass each pizza the \nfactory that should be used to \nproduce its ingredients. Look back one page and make \nsure you understand how the \npizza and the factory work \ntogether! For each type of Pizza, we \ninstantiate a new Pizza and \ngive it the factory it needs to \nget its ingredients. Compare this version of the createPizza() \nmethod to the one in the Factory Method \nimplementation earlier in the chapter.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 190", "position": 190, "chunk_type": "semantic", "token_estimate": 223}
{"text": "you are here 4\u2003 \u2003 153: the factory pattern\nWhat have we done? That was quite a series of code changes; \nwhat exactly did we do? We provided a means of creating a family \nof ingredients for pizzas by introducing \na new type of factory called an Abstract \nFactory. An Abstract Factory gives us an interface \nfor creating a family of products. By \nwriting code that uses this interface, we \ndecouple our code from the actual factory \nthat creates the products. That allows us \nto implement a variety of factories that \nproduce products meant for different \ncontexts\u2014such as different regions, \ndifferent operating systems, or different \nlook and feels. Because our code is decoupled from the \nactual products, we can substitute different \nfactories to get different behaviors \n(like getting marinara instead of plum \ntomatoes). An Abstract Factory provides an interface for \na family of products. What\u2019s a family? In our \ncase, it\u2019s all the things we need to make a pizza: \ndough, sauce, cheese, meats, and veggies. From the abstract factory, we \nderive one or more concrete \nfactories that produce the same \nproducts, but with different \nimplementations. ObjectvilleAbstract IngredientFactory\nNew York \nChicago\nDefines the \ninterface. We then write our code so that it uses the \nfactory to create products. By passing in \na variety of factories, we get a variety of \nimplementations of those products. But our \nclient code stays the same. P\ni\nz\nz\na\nSto\nr\ne\nProvides implementations \nfor products. Pizza made with \ningredients produced \nby concrete factory.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 191", "position": 191, "chunk_type": "semantic", "token_estimate": 250}
{"text": "you are here 4\u2003 \u2003 155: the factory pattern\nFrom here things change, because we \nare using an ingredient factory\nPizza pizza = new CheesePizza(nyIngredientFactory);\nWhen the createPizza() method is called, that\u2019s \nwhen our ingredient factory gets involved:\nNext we need to prepare the pizza. Once the \nprepare() method is called, the factory is asked to \nprepare ingredients:\nFinally, we have the prepared pizza in hand and the \norderPizza() method bakes, cuts, and boxes the pizza. Creates a instance \nof Pizza that is \ncomposed with the \nNew York ingredient \nfactory. P\ni\nzza\nprepare()\nn\ny\nI\nn\ng\nr\ne\nd\nien\nt\nF\nac\nt\no\nr\ny\nholds\nFor Ethan\u2019s pizza the New York \ningredient factory is used, and so \nwe get the NY ingredients. void prepare() {\n        dough = factory.createDough();\n        sauce = factory.createSauce();\n        cheese = factory.createCheese();\n    }\nThin crust\nMarinara\nReggiano\nThe ingredient factory is chosen and \ninstantiated in the PizzaStore and then \npassed into the constructor of each pizza. 4\n5\n6\nBehind \nthe Scenes", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 193", "position": 193, "chunk_type": "semantic", "token_estimate": 169}
{"text": "156\u2003 \u2003 Chapter 4: abstract factory defined\nAbstract Factory Pattern defined\nThe Abstract Factory Pattern provides an interface \nfor creating families of related or dependent objects \nwithout specifying their concrete classes. We\u2019re adding yet another factory pattern to our pattern family, one that lets us create families \nof products. Let\u2019s check out the official definition for this pattern:\nWe\u2019ve certainly seen that Abstract Factory allows a client to use an abstract interface to \ncreate a set of related products without knowing (or caring) about the concrete products that \nare actually produced. In this way, the client is decoupled from any of the specifics of the \nconcrete products. Let\u2019s look at the class diagram to see how this all holds together:\nCreateProductA()\nCreateProductB()\n<<interface>>\nAbstractFactory\nClient\nProductB1\n<<interface>>\nAbstractProductB\nProductA1\nProductB2\n<<interface>>\nAbstractProductA\nProductA2\nCreateProductA()\nCreateProductB()\nConcreteFactory2\nCreateProductA()\nCreateProductB()\nConcreteFactory1\nThe Client is written against the \nabstract factory and then composed \nat runtime with an actual factory. The concrete factories implement \nthe different product families. T\no \ncreate a product, the client uses \none of these factories, so it never \nhas to instantiate a product object. The Abstract Factory defines the \ninterface that all Concrete factories \nmust implement, which consists of a set \nof methods for producing products. This is the product \nfamily. Each concrete \nfactory can produce an \nentire set of products.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 194", "position": 194, "chunk_type": "semantic", "token_estimate": 221}
{"text": "you are here 4\u2003 \u2003 157: the factory pattern\n<<interface>>\nClams\n<<interface>>\nCheese\n<<interface>>\nSauce\n<<interface>>\nDough\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\nChicagoPizzaIngredientFactory\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\nNYPizzaIngredientFactory\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\n<<interface>>\nPizzaIngredientFactory\ncreatePizza()\nNYPizzaStore\nEach factory produces a different \nimplementation for the family of products. The abstract \nPizzaIngredientFactory is the \ninterface that defines how to \nmake a family of related products\u2014\neverything we need to make a pizza. The clients of the Abstract \nFactory are the two \ninstances of our PizzaStore, \nNYPizzaStore and \nChicagoStylePizzaStore. The job of the \nconcrete pizza \nfactories is to make \npizza ingredients. Each \nfactory knows how \nto create the right \nobjects for its region. That\u2019s a fairly complicated class \ndiagram; let\u2019s look at it all in terms \nof our PizzaStore:\nThickCrustDough\nThinCrustDough\nPlumTomatoSauce\nMarinaraSauce\nMozzarella Cheese\nReggianoCheese\nFreshClams\nFrozenClams", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 195", "position": 195, "chunk_type": "semantic", "token_estimate": 139}
{"text": "158\u2003 \u2003 Chapter 4: interview with factory patterns\nHeadFirst: Wow, an interview with two patterns at once! This is a first for us. Factory Method: Yeah, I\u2019m not so sure I like being lumped in with Abstract Factory, \nyou know. Just because we\u2019re both factory patterns doesn\u2019t mean we shouldn\u2019t get our own \ninterviews. HeadFirst: Don\u2019t be miffed, we wanted to interview you together so we could help clear up \nany confusion about who\u2019s who for the readers. You do have similarities, and I\u2019ve heard that \npeople sometimes get you confused. Abstract Factory: It\u2019s true, there have been times I\u2019ve been mistaken for Factory Method, \nand I know you\u2019ve had similar issues, Factory Method. We\u2019re both really good at decoupling \napplications from specific implementations; we just do it in different ways. So I can see why \npeople might sometimes get us confused. Factory Method: Well, it still ticks me off. After all, I use classes to create and you use objects; \nthat\u2019s totally different! This week\u2019s interview:\nFactory Method and Abstract Factory, on each other\nPatterns Exposed\nGood catch! Yes, often the methods of an Abstract Factory are \nimplemented as factory methods. It makes sense, right? The job of an \nAbstract Factory is to define an interface for creating a set of products. Each method in that interface is responsible for creating a concrete \nproduct, and we implement a subclass of the Abstract Factory to \nsupply those implementations. So, factory methods are a natural way to \nimplement your product methods in your abstract factories. Is that a factory method lurking inside the \nAbstract Factory? I noticed that each method in the \nAbstract Factory actually looks like \na factory method (createDough(), \ncreateSauce(), etc.). Each method is \ndeclared abstract and the subclasses \noverride it to create some object. Isn\u2019t \nthat a factory method?", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 196", "position": 196, "chunk_type": "semantic", "token_estimate": 300}
{"text": "you are here 4\u2003 \u2003 159: the factory pattern\nHeadFirst: Can you explain more about that, Factory \nMethod? Factory Method: Sure. Both Abstract Factory and \nI create objects\u2014that\u2019s our job. But I do it through \ninheritance...\nAbstract Factory: ...and I do it through object \ncomposition. Factory Method: Right. So that means, to create \nobjects using Factory Method, you need to extend a class \nand provide an implementation for a factory method. HeadFirst: And that factory method does what? Factory Method: It creates objects, of course! I mean, \nthe whole point of the Factory Method Pattern is that \nyou\u2019re using a subclass to do your creation for you. In that \nway, clients only need to know the abstract type they are \nusing; the subclass worries about the concrete type. So, in \nother words, I keep clients decoupled from the concrete \ntypes. Abstract Factory: And I do too, only I do it in a \ndifferent way. HeadFirst: Go on, Abstract Factory...you said \nsomething about object composition? Abstract Factory: I provide an abstract type for \ncreating a family of products. Subclasses of this type \ndefine how those products are produced. To use the \nfactory, you instantiate one and pass it into some code \nthat is written against the abstract type. So, like Factory \nMethod, my clients are decoupled from the actual \nconcrete products they use. HeadFirst: Oh, I see, so another advantage is that you \ngroup together a set of related products. Abstract Factory: That\u2019s right. HeadFirst: What happens if you need to extend that set \nof related products to, say, add another one? Doesn\u2019t that \nrequire changing your interface? Abstract Factory: That\u2019s true; my interface has to \nchange if new products are added, which I know people \ndon\u2019t like to do.... Factory Method: <snicker>\nAbstract Factory: What are you snickering at, Factory \nMethod? Factory Method:  Oh, come on, that\u2019s a big deal! Changing your interface means you have to go in and \nchange the interface of every subclass! That sounds like a \nlot of work. Abstract Factory: Yeah, but I need a big interface \nbecause I am used to creating entire families of products. You\u2019re only creating one product, so you don\u2019t really need \na big interface, you just need one method. HeadFirst: Abstract Factory, I heard that you often use \nfactory methods to implement your concrete factories? Abstract Factory: Yes, I\u2019ll admit it, my concrete \nfactories often implement a factory method to create \ntheir products.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 197", "position": 197, "chunk_type": "semantic", "token_estimate": 403}
{"text": "you are here 4\u2003 \u2003 159: HeadFirst: Abstract Factory, I heard that you often use \nfactory methods to implement your concrete factories? Abstract Factory: Yes, I\u2019ll admit it, my concrete \nfactories often implement a factory method to create \ntheir products. In my case, they are used purely to create \nproducts... Factory Method:  ...while in my case I usually \nimplement code in the abstract creator that makes use of \nthe concrete types the subclasses create. HeadFirst: It sounds like you both are good at what you \ndo. I\u2019m sure people like having a choice; after all, factories \nare so useful, they\u2019ll want to use them in all kinds of \ndifferent situations. You both encapsulate object creation \nto keep applications loosely coupled and less dependent \non implementations, which is really great, whether you\u2019re \nusing Factory Method or Abstract Factory. May I allow \nyou each a parting word? Abstract Factory: Thanks. Remember me, Abstract \nFactory, and use me whenever you have families of \nproducts you need to create and you want to make sure \nyour clients create products that belong together. Factory Method:  And I\u2019m Factory Method; use me to \ndecouple your client code from the concrete classes you \nneed to instantiate, or if you don\u2019t know ahead of time all \nthe concrete classes you are going to need. To use me, just \nsubclass me and implement my factory method!", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 197", "position": 197, "chunk_type": "semantic", "token_estimate": 226}
{"text": "160\u2003 \u2003 Chapter 4: patterns compared\ncreatePizza()\nChicagoPizzaStore\ncreatePizza()\nNYPizzaStore\ncreatePizza()\nPizzaStore\nNYStyleVeggiePizza\nNYStyleClamPizza\nNYStylePepperoniPizza\nNYStyleCheesePizza\nPizza\nChicagoStyleVeggiePizza\nChicagoStyleClamPizza\nChicagoStylePepperoniPizza\nChicagoStyleCheesePizza\nFactory Method and Abstract Factory compared\nNew York Store\nPizzaStore is implemented as a Factory \nMethod because we want to be able to \ncreate a product that varies by region. With the Factory Method, each region \ngets its own concrete factory that \nknows how to make pizzas that are \nappropriate for the area. Each subclass decides which \nconcrete class to instantiate. The Factory Method \nThis is the product of the \nPizzaStore. Clients only \nrely on this abstract type. Subclasses are \ninstantiated by the \nFactory Methods. New York\nChicago\nThe Factory Method \nThe NYPizzaStore subclass \ninstantiates only NY-style pizzas. The ChicagoPizzaStore \nsubclass instantiates only \nChicago-style pizzas. Chicago Store\nThe createPizza() method is parameterized by pizza \ntype, so we can return many types of pizza products. Provides an abstract \ninterface for \ncreating one product.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 198", "position": 198, "chunk_type": "semantic", "token_estimate": 152}
{"text": "you are here 4\u2003 \u2003 161: the factory pattern\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\n<<interface>>\nPizzaIngredientFactory\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\nNYPizzaIngredientFactory\ncreateDough()\ncreateSauce()\ncreateCheese()\ncreateVeggies()\ncreatePepperoni()\ncreateClam()\nChicagoPizzaIngredientFactory\nPizzaIngredientFactory is implemented as an \nAbstract Factory because we need to create \nfamilies of products (the ingredients). Each \nsubclass implements the ingredients using its \nown regional suppliers. FrozenClams\nFreshClams\n<<interface>>\nClams\n<<interface>>\nSauce\n<<interface>>\nDough\nReggianoCheese\nMozzarellaCheese\n<<interface>>\nCheese\nEach concrete subclass creates \na family of products. ThinCrustDough\nThickCrustDough\nMarinaraSauce\nPlumTomatoSauce\nChicago\nProvides an abstract \ninterface for creating a \nfamily of products. Methods to create \nproducts in an Abstract \nFactory are often \nimplemented with a \nFactory Method...\n...\u2009or the type of clams. New York\nEach ingredient \nrepresents a \nproduct that is \nproduced by a \nFactory Method \nin the Abstract \nFactory. ...for instance, the subclass \ndecides the type of dough... The product subclasses create parallel sets of product families. Here we have a New York ingredient family and a Chicago family.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 199", "position": 199, "chunk_type": "semantic", "token_estimate": 161}
{"text": "162\u2003 \u2003 Chapter 4: your design toolbox\nTools for your Design Toolbox\nIn this chapter, we added two more tools to your toolbox: \nFactory Method and Abstract Factory. Both patterns \nencapsulate object creation and allow you to decouple your \ncode from concrete types. Abstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies. Favor composition over inheritance. Program to interfaces, not \nimplementations. Strive for loosely coupled designs \nbetween objects that interact. Classes should be open for extension \nbut closed for modification. Depend on abstractions. Do not \ndepend on concrete classes. OO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it. OO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically. Decorators provide a flexible \nalternative to subclassing for extending \nfunctionality. Abstract Factory - Provides \nan interface for creating families of \nrelated or dependent objects without \nspecifying their concrete classes. Factory Method - Defines an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate. Factory Method lets \na class defer instantiation to the \nsubclasses. We have a new principle that \nguides us to keep things \nabstract whenever possible. Both of these new \npatterns encapsulate \nobject creation \nand lead to more \ndecoupled, flexible \ndesigns. \u0083\nAll factories encapsulate object \ncreation. \u0083\nSimple Factory, while not a \nbona fide design pattern, is a \nsimple way to decouple your \nclients from concrete classes. \u0083\nFactory Method relies on \ninheritance: object creation is \ndelegated to subclasses, which \nimplement the factory method \nto create objects. \u0083\nAbstract Factory relies on \nobject composition: object \ncreation is implemented in \nmethods exposed in the factory \ninterface. \u0083\nAll factory patterns promote \nloose coupling by reducing the \ndependency of your application \non concrete classes. \u0083\nThe intent of Factory Method \nis to allow a class to defer \ninstantiation to its subclasses. \u0083\nThe intent of Abstract Factory \nis to create families of related \nobjects without having to \ndepend on their concrete \nclasses. \u0083\nThe Dependency Inversion \nPrinciple guides us to avoid \ndependencies on concrete \ntypes and to strive for \nabstractions. \u0083\nFactories are a powerful \ntechnique for coding to \nabstractions, not concrete \nclasses.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 200", "position": 200, "chunk_type": "semantic", "token_estimate": 386}
{"text": "you are here 4\u2003 \u2003 163: the factory pattern\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nAcross\n1. In Factory Method, each franchise is a \n______________\n4. In Factory Method, who decides which class to \ninstantiate? 6. Role of PizzaStore in Factory Method Pattern\n7. All New York Style Pizzas use this kind of \ncheese\n8. In Abstract Factory, each ingredient factory is a \n_____________\n9. When you use new, you are programming to an \n___________\n11. createPizza() is a ______________ (two words)\n12. Joel likes this kind of pizza\n13. In Factory Method, the PizzaStore and the \nconcrete Pizzas all depend on this abstraction\n14. When a class instantiates an object from a \nconcrete class, it's __________ on that object\n15. All factory patterns allow us to __________ \nobject creation\nDown\n2. We used ______________  in Simple Factory \nand Abstract Factory and inheritance in Factory \nMethod\n3. Abstract Factory creates a ___________ of \nproducts\n5. Not a REAL factory pattern, but handy \nnonetheless\n10. Ethan likes this kind of pizza\nDesign Patterns Crossword\nIt\u2019s been a long chapter. Grab a slice of Pizza and relax while doing \nthis crossword; all of the solution words are from this chapter.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 201", "position": 201, "chunk_type": "semantic", "token_estimate": 206}
{"text": "1. In Factory Method, each franchise is a ________.: 4. In Factory Method, who decides which class to \ninstantiate? 6. Role of PizzaStore in the Factory Method Pattern. 7. All New York\u2013style pizzas use this kind of cheese. 8. In Abstract Factory, each ingredient factory is a \n_______. 9. When you use new, you are programming to an \n___________. 11. createPizza() is a ____________. 12. Joel likes this kind of pizza. 13. In Factory Method, the PizzaStore and the concrete \nPizzas all depend on this abstraction. 14. When a class instantiates an object from a concrete \nclass, it's ___________ on that object. 15. All factory patterns allow us to __________ object \ncreation.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 201", "position": 201, "chunk_type": "semantic", "token_estimate": 112}
{"text": "2.We used ___________ in Simple Factory and Abstract: Factory, and inheritance in Factory Method. 3. Abstract Factory creates a ___________ of products. 5. Not a REAL factory pattern, but handy nonetheless. 10. Ethan likes this kind of pizza.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 201", "position": 201, "chunk_type": "semantic", "token_estimate": 38}
{"text": "you are here 4\u2003 \u2003 165: the factory pattern\nWe need another kind of pizza for those crazy Californians (crazy in a good way, \nof course). Draw another parallel set of classes that you\u2019d need to add a new \nCalifornia region to our PizzaStore. createPizza()\norderPizza()\nPizzaStore\nOkay, now write the five silliest things you can think of to put on a pizza. Then, you\u2019ll be ready to go into business making pizza in California! createPizza()\nNYPizzaStore\ncreatePizza()\nChicagoPizzaStore\nNYStyleVeggiePizza\nNYStyleClamPizza\nNYStylePepperoniPizza\nNYStyleCheesePizza\nChicagoStyleVeggiePizza\nChicagoStyleClamPizza\nChicagoStylePepperoniPizza\nChicagoStyleCheesePizza\ncreatePizza()\nCaliforniaPizzaStore\nCaliforniaStyleVeggiePizza\nCaliforniaStyleClamPizza\nCaliforniaStylePepperoniPizza\nCaliforniaStyleCheesePizza\nHere\u2019s everything you need to \nadd a California pizza store, \nthe concrete pizza store class, \nand the California-style pizzas. Mashed potatoes with roasted garlic\nBBQ sauce\nArtichoke hearts\nM&M\u2019s\nPeanuts\nHere \nare our \nsuggestions...\n Design Puzzle Solution", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 203", "position": 203, "chunk_type": "semantic", "token_estimate": 129}
{"text": "166\u2003 \u2003 Chapter 4: exercise solutions\npublic class DependentPizzaStore {\n \n    public Pizza createPizza(String style, String type) {\n        Pizza pizza = null;\n        if (style.equals(\"NY\")) {\n            if (type.equals(\"cheese\")) {\n                pizza = new NYStyleCheesePizza();\n            } else if (type.equals(\"veggie\")) {\n                pizza = new NYStyleVeggiePizza();\n            } else if (type.equals(\"clam\")) {\n                pizza = new NYStyleClamPizza();\n            } else if (type.equals(\"pepperoni\")) {\n                pizza = new NYStylePepperoniPizza();\n            }\n        } else if (style.equals(\"Chicago\")) {\n            if (type.equals(\"cheese\")) {\n                pizza = new ChicagoStyleCheesePizza();\n            } else if (type.equals(\"veggie\")) {\n                pizza = new ChicagoStyleVeggiePizza();\n            } else if (type.equals(\"clam\")) {\n                pizza = new ChicagoStyleClamPizza();\n            } else if (type.equals(\"pepperoni\")) {\n                pizza = new ChicagoStylePepperoniPizza();\n            }\n        } else {\n            System.out.println(\"Error: invalid type of pizza\");\n            return null;\n        }\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n        return pizza;\n    }\n}\n8\n12\nYou can write your \nanswers here:\nnumber\nnumber with \nCalifornia too\nHandles all the \nNY-style pizzas\nHandles all the \nChicago-style pizzas\nLet\u2019s pretend you\u2019ve never heard of an OO factory. Here\u2019s a \u201cvery dependent\u201d \nversion of PizzaStore that doesn\u2019t use a factory. We need for you to make a \ncount of the number of concrete pizza classes this class is dependent on. If \nyou added California-style pizzas to PizzaStore, how many classes would it be \ndependent on then? Here\u2019s our solution.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 204", "position": 204, "chunk_type": "semantic", "token_estimate": 200}
{"text": "you are here 4\u2003 \u2003 167: the factory pattern\npublic class ChicagoPizzaIngredientFactory \n    implements PizzaIngredientFactory \n{\n    public Dough createDough() {\n        return new ThickCrustDough();\n    }\n    public Sauce createSauce() {\n        return new PlumTomatoSauce();\n    }\n    public Cheese createCheese() {\n        return new MozzarellaCheese();\n    }\n    public Veggies[] createVeggies() {\n        Veggies veggies[] = { new BlackOlives(), \n                              new Spinach(), \n                              new Eggplant() };\n        return veggies;\n    }\n    public Pepperoni createPepperoni() {\n        return new SlicedPepperoni();\n    }\n    public Clams createClam() {\n        return new FrozenClams();\n    }\n}\nGo ahead and write the ChicagoPizzaIngredientFactory; you can reference the \nclasses below in your implementation:\nSlicedPepperoni\nEggPlant\nSpinach\nBlackOlives\nFrozenClams\nPlumTomatoSauce\nMozzarellaCheese\nThickCrustDough", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 205", "position": 205, "chunk_type": "semantic", "token_estimate": 96}
{"text": "Across: 1. In Factory Method, each franchise is a \n______________ [CONCRETECREATOR] \n4. In Factory Method, who decides which class to \ninstantiate? [SUBCLASS] \n6. Role of PizzaStore in Factory Method Pattern \n[CREATOR] \n7. All New York Style Pizzas use this kind of \ncheese [REGGIANO] \n8. In Abstract Factory, each ingredient factory is a \n_____________ [CONCRETEFACTORY] \n9. When you use new, you are programming to an \n___________ [IMPLEMENTATION] \n11. createPizza() is a ______________ (two words) \nDown\n2. We used ______________  in Simple Factory \nand Abstract Factory and inheritance in Factory \nMethod [OBJECTCOMPOSITION] \n3. Abstract Factory creates a ___________ of \nproducts [FAMILY] \n5. Not a REAL factory pattern, but handy \nnonetheless [SIMPLEFACTORY] \n10. Ethan likes this kind of pizza [NYSTYLE] \nDesign Patterns Crossword Solution\nIt\u2019s been a long chapter. Grab a slice of Pizza and relax while doing this \ncrossword; all of the solution words are from this chapter. Here\u2019s the solution.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 206", "position": 206, "chunk_type": "semantic", "token_estimate": 149}
{"text": "this is a new chapter\u2003 \u2003 169: Our next stop is the Singleton Pattern, our ticket to creating one-\nof-a-kind objects for which there is only one instance, ever. You might \nbe happy to know that of all patterns, the Singleton is the simplest in terms of its class diagram; \nin fact, the diagram holds just a single class! But don\u2019t get too comfortable; despite its simplicity \nfrom a class design perspective, it\u2019s going to require some deep object-oriented thinking in its \nimplementation. So put on that thinking cap, and let\u2019s get going. 5  the Singleton Pattern\nOne-of-a-Kind Objects\nI tell ya she\u2019s ONE \nOF A KIND. Look at the \nlines, the curves, the body, \nthe headlights! You talkin\u2019 to me or the car? Oh, and when can I get my oven \nmitt back?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 207", "position": 207, "chunk_type": "semantic", "token_estimate": 133}
{"text": "170\u2003 \u2003 Chapter 5: one and only one\nDeveloper: What use is that? Guru: There are many objects we only need one of: thread pools, caches, dialog boxes, objects \nthat handle preferences and registry settings, objects used for logging, and objects that act as \ndevice drivers to devices like printers and graphics cards. In fact, for many of these types of \nobjects, if we were to instantiate more than one we\u2019d run into all sorts of problems like incorrect \nprogram behavior, overuse of resources, or inconsistent results. Developer: Okay, so maybe there are classes that should only be instantiated once, but do I \nneed a whole chapter for this? Can\u2019t I just do this by convention or by global variables? You know, \nlike in Java, I could do it with a static variable. Guru: In many ways, the Singleton Pattern is a convention for ensuring one and only one object \nis instantiated for a given class. If you\u2019ve got a better one, the world would like to hear about it; \nbut remember, like all patterns, the Singleton Pattern is a time-tested method for ensuring only \none object gets created. The Singleton Pattern also gives us a global point of access, just like a \nglobal variable, but without the downsides. Developer: What downsides? Guru: Well, here\u2019s one example: if you assign an object to a global variable, then that object \nmight be created when your application begins. Right? What if this object is resource intensive \nand your application never ends up using it? As you will see, with the Singleton Pattern, we can \ncreate our objects only when they are needed. Developer: This still doesn\u2019t seem like it should be so difficult. Guru: If you\u2019ve got a good handle on static class variables and methods as well as access \nmodifiers, it\u2019s not. But, in either case, it is interesting to see how a Singleton works, and, as \nsimple as it sounds, Singleton code is hard to get right. Just ask yourself: how do I prevent more \nthan one object from being instantiated? It\u2019s not so obvious, is it? That\u2019s one and ONLY \nONE object. What is this? An \nentire chapter about \nhow to instantiate just \nONE object?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 208", "position": 208, "chunk_type": "semantic", "token_estimate": 365}
{"text": "you are here 4\u2003 \u2003 171: the singleton pattern\nHow would you create a single object? new MyObject();\nAnd, what if another object wanted to create a \nMyObject? Could it call new on MyObject again? Yes, of course. So as long as we have a class, can we always \ninstantiate it one or more times? Yes. Well, only if it\u2019s a public class. And if not? Well, if it\u2019s not a public class, only classes in the \nsame package can instantiate it. But they can still \ninstantiate it more than once. Hmm, interesting. Did you know you could do this? No, I\u2019d never thought of it, but I guess it makes \nsense because it is a legal definition. public MyClass {\n   private MyClass() {}\n}\nWhat does it mean? I suppose it is a class that can\u2019t be instantiated \nbecause it has a private constructor. Well, is there ANY object that could use \nthe private constructor? Hmm, I think the code in MyClass is the only \ncode that could call it. But that doesn\u2019t make \nmuch sense. The Little Singleton\nA small Socratic exercise in the style of The Little Lisper", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 209", "position": 209, "chunk_type": "semantic", "token_estimate": 190}
{"text": "172\u2003 \u2003 Chapter 5: creating a singleton\nWhy not ? Because I\u2019d have to have an instance of the \nclass to call it, but I can\u2019t have an instance \nbecause no other class can instantiate it. It\u2019s \na chicken-and-egg problem: I can use the \nconstructor from an object of type MyClass, \nbut I can never instantiate that object because \nno other object can use \u201cnew MyClass()\u201d. Okay. It was just a thought. What does this mean? MyClass is a class with a static method. We can call \nthe static method like this:\nMyClass.getInstance();\npublic MyClass {\n   public static MyClass getInstance() {\n   }\n}\nWhy did you use MyClass instead of \nsome object name? Well, getInstance() is a static method; in other \nwords, it is a CLASS method. You need to use the \nclass name to reference a static method. Very interesting. What if we put things together? public MyClass {\n    private MyClass() {}\n    public static MyClass getInstance() {\n        return new MyClass();\n    }\n}\nWow, you sure can. Now can I instantiate a MyClass? So, now can you think of a second way to instantiate \nan object? MyClass.getInstance();\nCan you finish the code so that only ONE instance \nof MyClass is ever created? Yes, I think so...\n(You\u2019ll find the code on the next page.)", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 210", "position": 210, "chunk_type": "semantic", "token_estimate": 213}
{"text": "you are here 4\u2003 \u2003 173: the singleton pattern\npublic class Singleton {\n    private static Singleton uniqueInstance;\n \n    // other useful instance variables here\n \n    private Singleton() {}\n \n    public static Singleton getInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n \n    // other useful methods here\n}\nDissecting the classic Singleton \nPattern implementation\nWe have a static \nvariable to hold our \none instance of the \nclass Singleton. Our constructor is \ndeclared private; only \nSingleton can instantiate \nthis class! The getInstance() method \ngives us a way to instantiate \nthe class and also to return \nan instance of it. Of course, Singleton is a normal \nclass; it has other useful instance \nvariables and methods. if (uniqueInstance == null) {\n    uniqueInstance = new Singleton();\n}\nreturn uniqueInstance;\nIf uniqueInstance is null, then we \nhaven\u2019t created the instance yet...\n...and, if it doesn\u2019t exist, we \ninstantiate Singleton through \nits private constructor and \nassign it to uniqueInstance. Note \nthat if we never need the \ninstance, it never gets created; \nthis is lazy instantiation. By the time we hit this code, we \nhave an instance and we return it. If uniqueInstance wasn\u2019t null, \nthen it was previously created. We just fall through to the \nreturn statement. Code Up Close\nuniqueInstance holds our ONE \ninstance; remember, it is a \nstatic variable. Let\u2019s rename \nMyClass to Singleton. If you\u2019re just \nflipping through \nthe book, don\u2019t \nblindly type in this \ncode; you\u2019ll see it \nhas a few issues \nlater in the chapter.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 211", "position": 211, "chunk_type": "semantic", "token_estimate": 245}
{"text": "174\u2003 \u2003 Chapter 5: interview with singleton\nHeadFirst:  Today we are pleased to bring you an \ninterview with a Singleton object. Why don\u2019t you \nbegin by telling us a bit about yourself? Singleton: Well, I\u2019m totally unique; there is just one \nof me! HeadFirst: One? Singleton: Yes, one. I\u2019m based on the Singleton \nPattern, which ensures that at any time there is only \none instance of me. HeadFirst: Isn\u2019t that sort of a waste? Someone took \nthe time to develop a full-blown class and now all we \ncan get is one object out of it? Singleton: Not at all! There is power in ONE. Let\u2019s \nsay you have an object that contains registry settings. You don\u2019t want multiple copies of that object and its \nvalues running around\u2014that would lead to chaos. By using an object like me you can ensure that every \nobject in your application is making use of the same \nglobal resource. HeadFirst: Tell us more\u2026\nSingleton: Oh, I\u2019m good for all kinds of things. Being single sometimes has its advantages, you know. I\u2019m often used to manage pools of resources, like \nconnection or thread pools. HeadFirst: Still, only one of your kind? That sounds \nlonely. Singleton: Because there\u2019s only one of me, I do keep \nbusy, but it would be nice if more developers knew \nme\u2014many developers run into bugs because they have \nmultiple copies of objects floating around they\u2019re not \neven aware of. HeadFirst: So, if we may ask, how do you know \nthere is only one of you? Can\u2019t anyone with a new \noperator create a \u201cnew you\u201d? Singleton:  Nope! I\u2019m truly unique. HeadFirst: Well, do developers swear an oath not to \ninstantiate you more than once? Singleton: Of course not. The truth be told\u2026well, \nthis is getting kind of personal but\u2026I have no public \nconstructor. HeadFirst: NO PUBLIC CONSTRUCTOR! Oh, \nsorry, no public constructor? Singleton: That\u2019s right. My constructor is declared \nprivate. HeadFirst: How does that work? How do you EVER \nget instantiated? Singleton: You see, to get a hold of a Singleton \nobject, you don\u2019t instantiate one, you just ask for \nan instance. So my class has a static method called \ngetInstance(). Call that, and I\u2019ll show up at once, ready \nto work. In fact, I may already be helping other objects \nwhen you request me. HeadFirst: Well, Mr. Singleton, there seems to be a \nlot under your covers to make all this work.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 212", "position": 212, "chunk_type": "semantic", "token_estimate": 400}
{"text": "174\u2003 \u2003 Chapter 5: In fact, I may already be helping other objects \nwhen you request me. HeadFirst: Well, Mr. Singleton, there seems to be a \nlot under your covers to make all this work. Thanks \nfor revealing yourself and we hope to speak with you \nagain soon! Patterns Exposed\nThis week\u2019s interview:\nConfessions of a Singleton", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 212", "position": 212, "chunk_type": "semantic", "token_estimate": 56}
{"text": "you are here 4\u2003 \u2003 175: the singleton pattern\npublic class ChocolateBoiler {\n    private boolean empty;\n    private boolean boiled;\n  \n    private ChocolateBoiler() {\n        empty = true;\n        boiled = false;\n    }\n  \n    public void fill() {\n        if (isEmpty()) {\n            empty = false;\n            boiled = false;\n            // fill the boiler with a milk/chocolate mixture\n        }\n    }\n \n    public void drain() {\n        if (!isEmpty() && isBoiled()) {\n            // drain the boiled milk and chocolate\n            empty = true;\n        }\n    }\n \n    public void boil() {\n        if (!isEmpty() && !isBoiled()) {\n            // bring the contents to a boil\n            boiled = true;\n        }\n    }\n  \n    public boolean isEmpty() {\n        return empty;\n    }\n \n    public boolean isBoiled() {\n        return boiled;\n    }\n}\nThe Chocolate Factory\nEveryone knows that all modern chocolate factories have computer-controlled \nchocolate boilers. The job of the boiler is to take in chocolate and milk, bring them \nto a boil, and then pass them on to the next phase of making chocolate bars. Here\u2019s the controller class for Choc-O-Holic, Inc.\u2019s industrial strength Chocolate \nBoiler. Check out the code; you\u2019ll notice they\u2019ve tried to be very careful to ensure \nthat bad things don\u2019t happen, like draining 500 gallons of unboiled mixture, or \nfilling the boiler when it\u2019s already full, or boiling an empty boiler! This code is only started \nwhen the boiler is empty! T\no fill the boiler it must be \nempty, and, once it\u2019s full, we \nset the empty and boiled flags. T\no drain the boiler, it must be full \n(non-empty) and also boiled. Once it is \ndrained, we set empty back to true. T\no boil the mixture, the boiler \nhas to be full and not already \nboiled. Once it\u2019s boiled, we set \nthe boiled flag to true. public", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 213", "position": 213, "chunk_type": "semantic", "token_estimate": 281}
{"text": "176\u2003 \u2003 Chapter 5: chocolate boiler singleton\npublic class ChocolateBoiler {\n    private boolean empty;\n    private boolean boiled;\n             ChocolateBoiler() {\n        empty = true;\n        boiled = false;\n    }\n    \n    public void fill() {\n        if (isEmpty()) {\n           empty = false;\n           boiled = false;\n           // fill the boiler with a milk/chocolate mixture\n        }\n    }\n    // rest of ChocolateBoiler code...\n}\nChoc-O-Holic has done a decent job of ensuring bad things don\u2019t happen, \ndon\u2019t you think? Then again, you probably suspect that if two ChocolateBoiler \ninstances get loose, some very bad things can happen. How might things go wrong if more than one instance of ChocolateBoiler is \ncreated in an application? Can you help Choc-O-Holic improve their ChocolateBoiler class \nby turning it into a Singleton?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 214", "position": 214, "chunk_type": "semantic", "token_estimate": 118}
{"text": "you are here 4\u2003 \u2003 177: the singleton pattern\nSingleton\nstatic uniqueInstance\n// Other useful Singleton data...\nstatic getInstance()\n// Other useful Singleton methods... The Singleton Pattern ensures a class has only one \ninstance, and provides a global point of access to it. Singleton Pattern defined\nNow that you\u2019ve got the classic implementation of Singleton \nin your head, it\u2019s time to sit back, enjoy a bar of chocolate, \nand check out the finer points of the Singleton Pattern. Let\u2019s start with the concise definition of the pattern:\nNo big surprises there. But let\u2019s break it down a bit more:\n\u0083\t What\u2019s really going on here? We\u2019re taking a class and letting it manage a single \ninstance of itself. We\u2019re also preventing any other class from creating a new \ninstance on its own. To get an instance, you\u2019ve got to go through the class itself. \u0083\t We\u2019re also providing a global access point to the instance: whenever you need \nan instance, just query the class and it will hand you back the single instance. As you\u2019ve seen, we can implement this so that the Singleton is created in a lazy \nmanner, which is especially important for resource-intensive objects. Okay, let\u2019s check out the class diagram:\nThe getInstance() method is static, \nwhich means it\u2019s a class method, so you \ncan conveniently access this method \nfrom anywhere in your code using \nSingleton.getInstance(). That\u2019s just as \neasy as accessing a global variable, but \nwe get benefits like lazy instantiation \nfrom the Singleton. The uniqueInstance \nclass variable holds our \none and only instance \nof Singleton. A class implementing the Singleton \nPattern is more than a Singleton; it \nis a general-purpose class with its \nown set of data and methods.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 215", "position": 215, "chunk_type": "semantic", "token_estimate": 283}
{"text": "178\u2003 \u2003 Chapter 5: threads are a problem\nHouston, we have a problem...\nHershey, PA\nIt looks like the Chocolate Boiler has let us down; despite \nthe fact we improved the code using the classic Singleton \nPattern, somehow the Chocolate Boiler\u2019s fill() method was \nable to start filling the boiler even though a batch of milk \nand chocolate was already boiling! That\u2019s 500 gallons of \nspilled milk (and chocolate)! What happened!? Could the addition of threads have caused \nthis? Isn\u2019t it the case that once we\u2019ve set the \nuniqueInstance variable to the sole instance \nof ChocolateBoiler, all calls to getInstance() \nshould return the same instance? Right? We don\u2019t know what happened! The new Singleton \ncode was running fine. The only thing we can think \nof is that we just added some optimizations to \nthe Chocolate Boiler Controller that makes use of \nmultiple threads.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 216", "position": 216, "chunk_type": "semantic", "token_estimate": 142}
{"text": "you are here 4\u2003 \u2003 179: the singleton pattern\nWe have two threads, each executing this code. Your job is to play the JVM \nand determine whether there is a case in which two threads might get a hold \nof different boiler objects. Hint: \nyou really just need to look at the \nsequence of operations in the \ngetInstance() method and \nthe value of uniqueInstance \nto see how they might \noverlap. Use the code \nmagnets to help you study how the \ncode might interleave to create two boiler objects. BE the JVM\nif (uniqueInstance == null) {\n}\nThread\nOne\nThread\nTwo\nuniqueInstance = \n    new ChocolateBoiler();\nreturn uniqueInstance;\npublic static ChocolateBoiler\n\t\ngetInstance() {\n}\nChocolateBoiler boiler = \n        ChocolateBoiler.getInstance();\nboiler.fill();\nboiler.boil();\nboiler.drain();\nValue of \nuniqueInstance\nMake sure you check your answer on \npage 188 before continuing!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 217", "position": 217, "chunk_type": "semantic", "token_estimate": 133}
{"text": "180\u2003 \u2003 Chapter 5: multithreading and singleton\npublic class Singleton {\n    private static Singleton uniqueInstance;\n \n    // other useful instance variables here\n \n    private Singleton() {}\n \n    public static synchronized Singleton getInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n \n    // other useful methods here\n}\nDealing with multithreading\nOur multithreading woes are almost trivially fixed by making \ngetInstance() a synchronized method:\nBy adding the synchronized keyword to \ngetInstance(), we force every thread to \nwait its turn before it can enter the \nmethod. That is, no two threads may \nenter the method at the same time. Good point, and it\u2019s actually a little worse than you make \nout: the only time synchronization is relevant is the first time \nthrough this method. In other words, once we\u2019ve set the \nuniqueInstance variable to an instance of Singleton, we have \nno further need to synchronize this method. After the first time \nthrough, synchronization is totally unneeded overhead! I agree this fixes the \nproblem. But synchronization \nis expensive; is this an issue?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 218", "position": 218, "chunk_type": "semantic", "token_estimate": 170}
{"text": "you are here 4\u2003 \u2003 181: the singleton pattern\npublic class Singleton {\n    private static Singleton uniqueInstance = new Singleton();\n \n    private Singleton() {}\n \n    public static Singleton getInstance() {\n        return uniqueInstance;\n    }\n}\nUsing this approach, we rely on the JVM to create the unique instance of the Singleton \nwhen the class is loaded. The JVM guarantees that the instance will be created before \nany thread accesses the static uniqueInstance variable. Can we improve multithreading? For most Java applications, we obviously need to ensure that the Singleton works in the \npresence of multiple threads. But it\u2019s expensive to synchronize the getInstance() method,  \nso what do we do? Well, we have a few options...\n1. Do nothing if the performance of getInstance() isn\u2019t critical \nto your application. That\u2019s right; if calling the getInstance() method isn\u2019t causing substantial overhead for your \napplication, forget about it. Synchronizing getInstance() is straightforward and effective. Just keep in mind that synchronizing a method can decrease performance by a factor \nof 100, so if a high-traffic part of your code begins using getInstance(), you may have to \nreconsider. 2. Move to an eagerly created instance rather than a lazily \ncreated one. If your application always creates and uses an instance of the Singleton, or the overhead \nof creation and runtime aspects of the Singleton isn\u2019t onerous, you may want to create \nyour Singleton eagerly, like this:\nGo ahead and create an \ninstance of Singleton \nin a static initializer. This code is guaranteed \nto be thread safe! We\u2019ve already got an \ninstance, so just return it.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 219", "position": 219, "chunk_type": "semantic", "token_estimate": 256}
{"text": "182\u2003 \u2003 Chapter 5: double-checked locking\npublic class Singleton {\n    private volatile static Singleton uniqueInstance;\n \n    private Singleton() {}\n \n    public static Singleton getInstance() {\n        if (uniqueInstance == null) {\n            synchronized (Singleton.class) {\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\nCheck for an instance and \nif there isn\u2019t one, enter a \nsynchronized block. Once in the block, check again and \nif it\u2019s still null, create an instance. Note we only synchronize \nthe first time through! The volatile keyword ensures that multiple threads \nhandle the uniqueInstance variable correctly when it \nis being initialized to the Singleton instance. If performance is an issue in your use of the getInstance() method, then this method of \nimplementing the Singleton can drastically reduce the overhead. 3. Use  \u201c\ndouble-checked locking\u201d to reduce the use of \nsynchronization in getInstance(). With double-checked locking, we first check to see if an instance is created, and if not, THEN \nwe synchronize. This way, we only synchronize the first time through, just what we want. Let\u2019s check out the code:\n\t\n       Double-checked locking doesn\u2019t work in \nJava 1.4 or earlier! If for some reason you\u2019re using an old version \nof Java, unfortunately, in Java version 1.4 and \nearlier, many JVMs contain implementations of \nthe volatile keyword that allow improper synchronization for \ndouble-checked locking. If you must use a JVM earlier than Java \n5, consider other methods of implementing your Singleton.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 220", "position": 220, "chunk_type": "semantic", "token_estimate": 235}
{"text": "you are here 4\u2003 \u2003 183: the singleton pattern\nMeanwhile, back at the Chocolate Factory... While we\u2019ve been off diagnosing the multithreading problems, the chocolate boiler \nhas been cleaned up and is ready to go. But first, we have to fix the multithreading \nproblems. We have a few solutions at hand, each with different tradeoffs, so which \nsolution are we going to employ? At this point, the Chocolate Factory is a happy customer and Choc-O-Holic was glad to \nhave some expertise applied to their boiler code. No matter which multithreading solution \nyou applied, the boiler should be in good shape with no more mishaps. Congratulations\u2014\nnot only have you managed to escape 500 lbs of hot chocolate in this chapter, but you\u2019ve \nalso been through all the potential problems of the Singleton Pattern. Congratulations! For each solution, describe its applicability to the \nproblem of fixing the Chocolate Boiler code:\nSynchronize the getInstance() method:\nUse eager instantiation:\nDouble-checked locking:", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 221", "position": 221, "chunk_type": "semantic", "token_estimate": 157}
{"text": "184\u2003 \u2003 Chapter 5: q&a about singleton\nQ: For such a simple pattern \nconsisting of only one class, Singleton \nsure seems to have some problems. A: Well, we warned you up front! But \ndon\u2019t let the problems discourage you; while \nimplementing Singletons correctly can be \ntricky, after reading this chapter you\u2019re now \nwell informed on the techniques for creating \nSingletons and should use them wherever \nyou need to control the number of instances \nyou\u2019re creating. Q: Can\u2019t I just create a class in which \nall methods and variables are defined as \nstatic? Wouldn\u2019t that be the same as a \nSingleton? A: Yes, if your class is self-contained and \ndoesn\u2019t depend on complex initialization. However, because of the way static \ninitializations are handled in Java, this can \nget very messy, especially if multiple classes \nare involved. Often this scenario can result \nin subtle, hard-to-find bugs involving order \nof initialization. Unless there is a compelling \nneed to implement your \u201csingleton\u201d this way, \nit\u2019s far better to stay in the object world. Q: What about class loaders? I \nheard there\u2019s a chance that two class \nloaders could each end up with their own \ninstance of Singleton. A: Yes, that is true as each class loader \ndefines a namespace. If you have two or \nmore class loaders, you can load the same \nclass multiple times (once in each class \nloader). Now, if that class happens to be a \nSingleton, then since we have more than \none version of the class, we also have more \nthan one instance of Singleton. So, if you are \nusing multiple class loaders and Singletons, \nbe careful. One way around this problem is \nto specify the class loader yourself. Q: And reflection, and serialization/\ndeserialization? A: Yes, reflection and serialization/\ndeserialization can also present problems \nwith Singletons. If you\u2019re an advanced Java \nuser using reflection, serialization, and \ndeserialization, you\u2019ll need to keep that in mind. Q: Earlier we talked about the loose \ncoupling principle. Isn\u2019t a Singleton \nviolating this? After all, every object in \nour code that depends on the Singleton \nis going to be tightly coupled to that very \nspecific object. A: Yes, and in fact this is a common \ncriticism of the Singleton Pattern.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 222", "position": 222, "chunk_type": "semantic", "token_estimate": 365}
{"text": "184\u2003 \u2003 Chapter 5: After all, every object in \nour code that depends on the Singleton \nis going to be tightly coupled to that very \nspecific object. A: Yes, and in fact this is a common \ncriticism of the Singleton Pattern. The \nloose coupling principle says to \u201cstrive for \nloosely coupled designs between objects \nthat interact.\u201d It\u2019s easy for Singletons to \nviolate this principle: if you make a change \nto the Singleton, you\u2019ll likely have to make a \nchange to every object connected to it. Q: I\u2019ve always been taught that a class \nshould do one thing and one thing only. For a class to do two things is considered \nbad OO design. Isn\u2019t a Singleton violating \nthis too? A: You would be referring to the Single \nResponsibility Principle, and yes, you are \ncorrect: the Singleton is responsible not only \nfor managing its one instance (and providing \nglobal access), but also for whatever \nits main role is in your application. So, \ncertainly you could argue it is taking on two \nresponsibilities. Nevertheless, it isn\u2019t hard to \nsee that there is utility in a class managing \nits own instance; it certainly makes the \noverall design simpler. In addition, many \ndevelopers are familiar with the Singleton \nPattern as it is in wide use. That said, some \ndevelopers do feel the need to abstract out \nthe Singleton functionality. Q: I wanted to subclass my Singleton \ncode, but I ran into problems. Is it okay to \nsubclass a Singleton? A: One problem with subclassing a \nSingleton is that the constructor is private. You can\u2019t extend a class with a private \nconstructor. So, the first thing you\u2019ll have \nto do is change your constructor so that it\u2019s \npublic or protected. But then, it\u2019s not really a \nSingleton anymore, because other classes \ncan instantiate it. If you do change your constructor, there\u2019s \nanother issue. The implementation of \nSingleton is based on a static variable, so \nif you do a straightforward subclass, all of \nyour derived classes will share the same \ninstance variable. This is probably not what \nyou had in mind. So, for subclassing to work, \nimplementing a registry of sorts is required \nin the base class. But what are you really gaining from \nsubclassing a Singleton? Like most patterns, \nSingleton is not necessarily meant to be a \nsolution that can fit into a library. In addition, \nthe Singleton code is trivial to add to any \nexisting class.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 222", "position": 222, "chunk_type": "semantic", "token_estimate": 401}
{"text": "184\u2003 \u2003 Chapter 5: Like most patterns, \nSingleton is not necessarily meant to be a \nsolution that can fit into a library. In addition, \nthe Singleton code is trivial to add to any \nexisting class. Last, if you are using a large \nnumber of Singletons in your application, \nyou should take a hard look at your design. Singletons are meant to be used sparingly. Q: I still don\u2019t totally understand \nwhy global variables are worse than a \nSingleton. A: In Java, global variables are basically \nstatic references to objects. There are a \ncouple of disadvantages to using global \nvariables in this manner. We\u2019ve already \nmentioned one: the issue of lazy versus \neager instantiation. But we need to keep \nin mind the intent of the pattern: to ensure \nonly one instance of a class exists and to \nprovide global access. A global variable can \nprovide the latter, but not the former. Global \nvariables also tend to encourage developers \nto pollute the namespace with lots of global \nreferences to small objects. Singletons don\u2019t \nencourage this in the same way, but can be \nabused nonetheless.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 222", "position": 222, "chunk_type": "semantic", "token_estimate": 181}
{"text": "you are here 4\u2003 \u2003 185: the singleton pattern\nI just realized...I think we can \nsolve a lot of the problems with \nSingleton by using an enum. Is \nthat right? Ah, good idea! Many of the problems we\u2019ve discussed\u2014worrying about \nsynchronization, class loading issues, reflection, and serialization/\ndeserialization issues\u2014can all be solved by using an enum to create \nyour Singleton. Here\u2019s how you\u2019d do that:\npublic enum Singleton {\n    UNIQUE_INSTANCE;\n    // more useful fields here\n}\npublic class SingletonClient {\n\t\npublic static void main(String[] args) {\n\t\n\t\nSingleton singleton = Singleton.UNIQUE_INSTANCE;\n\t\n\t\n// use the singleton here\n\t\n}\n}\nYep, that\u2019s all there is to it. Simplest Singleton ever, right? Now, you \nmight be asking, why did we go through all that earlier with creating \na Singleton class with a getInstance() method and then synchronizing, \nand so on? We did that so you really, truly understand how Singleton \nworks. Now that you know, you can go off and use enum whenever \nyou need a Singleton, and still be able to ace that Java interview if \nthe question pops up: \u201cHow do you implement a Singleton without \nusing enum?\u201d \nCan you rework Choc-O-Holic to use an enum? Give it a try. And back in the old days, \nwhen we had to walk to \nschool, uphill, in the snow, in \nboth directions, Java didn\u2019t \nhave enums.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 223", "position": 223, "chunk_type": "semantic", "token_estimate": 221}
{"text": "186\u2003 \u2003 Chapter 5: your design toolbox\nTools for your Design Toolbox\nYou\u2019ve now added another pattern to your toolbox. Singleton gives you another method of creating \nobjects\u2014in this case, unique objects. Abstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies. Favor composition over inheritance. Program to interfaces, not \nimplementations. Strive for loosely coupled designs \nbetween objects that interact. Classes should be open for extension \nbut closed for modification. Depend on abstractions. Do not \ndepend on concrete classes. OO Principles\nAs you\u2019ve seen, despite its apparent simplicity, there are a lot of details \ninvolved in Singleton\u2019s implementation. After reading this chapter, \nthough, you\u2019re ready to go out and use Singleton in the wild. Strategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it. OO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically. Decorators provide a flexible \nalternative to subclassing for extending \nfunctionality. Abstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes. Factory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate. Factory Method lets \na class defer instantiation to the \nsubclasses. Singleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it. When you need to ensure you \nonly have one instance of a class \nrunning around your application, \nturn to the Singleton. \u0083\nThe Singleton Pattern \nensures you have at most \none instance of a class in \nyour application. \u0083\nThe Singleton Pattern also \nprovides a global access \npoint to that instance. \u0083\nJava\u2019s implementation \nof the Singleton Pattern \nmakes use of a private \nconstructor, a static \nmethod combined with a \nstatic variable. \u0083\nExamine your performance \nand resource constraints \nand carefully choose an \nappropriate Singleton \nimplementation for  \nmultithreaded applications \n(and we should \nconsider all applications \nmultithreaded!). \u0083\nBeware of the double-\nchecked locking \nimplementation; it isn\u2019t \nthread safe in versions \nbefore Java 5. \u0083\nBe careful if you are using \nmultiple class loaders; this \ncould defeat the Singleton \nimplementation and result \nin multiple instances. \u0083\nYou can use Java\u2019s enums \nto simplify your Singleton \nimplementation.", "domains": ["Design Patterns", "Design Principles", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 224", "position": 224, "chunk_type": "semantic", "token_estimate": 391}
{"text": "you are here 4\u2003 \u2003 187: the singleton pattern\nDesign Patterns Crossword\nSit back, open that case of chocolate that you were sent for solving the \nmultithreading problem, and have some downtime working on this \nlittle crossword puzzle; all of the solution words are from this chapter.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 225", "position": 225, "chunk_type": "semantic", "token_estimate": 46}
{"text": "3. Company that produces boilers.: 6. An incorrect implementation caused this to overflow. 7. The Singleton Pattern has one. 10. To totally defeat the new constructor, we have to \ndeclare the constructor __________. 12. The classic implementation doesn\u2019t handle this. 13. Singleton provides a single instance and __________ \n(three words). 14. An easy way to create Singletons in Java. 15. The Singleton was embarrassed it had no public \n__________. 16. A Singleton is a class that manages an instance of \n________.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 225", "position": 225, "chunk_type": "semantic", "token_estimate": 81}
{"text": "1. Added to chocolate in the boiler.: 2. Flawed multithreading approach if not using Java 5 or \nlater (two words). 3. It was \u201cone of a kind.\u201d\n4. Multiple __________ can cause problems (two words). 5. If you don\u2019t need to worry about lazy instantiation, you \ncan create your instance __________. 8. One advantage over global variables: ________ \ncreation. 9. Chocolate capital of the USA. 11. Singleton ensures only one of these exists. 1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nAcross\n3. Company that produces boilers\n6. An incorrect implementation caused this to \noverflow\n7. The Singleton Pattern has one\n10. To totally defeat the new constructor, we \nhave to declare the constructor ________\n12. The classic implementation doesn't handle \nthis\n13. Singleton provides a single instance and \n(three words)\n14. An easy way to create Singletons in Java\n15. The Singleton was embarassed it had no \npublic ____________\n16. A Singleton is a class that manages an \nDown\n1. Added to chocolate in the boiler\n2. Flawed multithreading approach if not using \nJava 5 or later (two words)\n3. It was \"one of a kind\"\n4. Multiple __________ can cause problems \n(two words)\n5. If you don't need to worry about lazy \ninstantiation, you can create your instance \n________\n8. One advantage over global variables: \n_______ creation\n9. Chocolate capital of the US\n11. Singleton ensures only one of these exist", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 225", "position": 225, "chunk_type": "semantic", "token_estimate": 241}
{"text": "you are here 4\u2003 \u2003 189: the singleton pattern\npublic class ChocolateBoiler {\n    private boolean empty;\n    private boolean boiled;\n    private static ChocolateBoiler uniqueInstance;\n    private ChocolateBoiler() {\n        empty = true;\n        boiled = false;\n    }\n    public static ChocolateBoiler getInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new ChocolateBoiler();\n        }\n        return uniqueInstance;\n    }\n    public void fill() {\n        if (isEmpty()) {\n            empty = false;\n            boiled = false;\n            // fill the boiler with a milk/chocolate mixture\n        }\n    }\n   // rest of ChocolateBoiler code...\n}\nCan you help Choc-O-Holic improve their ChocolateBoiler class \nby turning it into a Singleton?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 227", "position": 227, "chunk_type": "semantic", "token_estimate": 93}
{"text": "190\u2003 \u2003 Chapter 5: exercise solutions\nDesign \nPatterns \nCrossword \nSolution\nFor each solution, describe its applicability to the \nproblem of fixing the Chocolate Boiler code:\nSynchronize the getInstance() method:\nUse eager instantiation:\nDouble-checked locking:\nA straightforward technique that is guaranteed to work. We don\u2019t seem to have \nany performance concerns with the chocolate boiler, so this would be a good choice. We are always going to instantiate the chocolate boiler in our code, so statically initializing \nthe instance would cause no concerns. This solution would work as well as the synchronized \nmethod, although perhaps be less obvious to a developer familar with the standard pattern. Given we have no performance concerns, double-checked locking seems like overkill. In \naddition, we\u2019d have to ensure that we are running at least Java 5.", "domains": ["Software Quality Attributes"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 228", "position": 228, "chunk_type": "semantic", "token_estimate": 129}
{"text": "this is a new chapter\u2003 \u2003 191: In this chapter, we take encapsulation to a whole new level: \nwe\u2019re going to encapsulate method invocation. That\u2019s right\u2014by \nencapsulating method invocation, we can crystallize pieces of computation so that \nthe object invoking the computation doesn\u2019t need to worry about how to do things, it \njust uses our crystallized method to get it done. We can also do some wickedly smart \nthings with these encapsulated method invocations, like save them away for logging \nor reuse them to implement undo functionality in our code. Encapsulating Invocation \n \n \n \n \n \n \n \n \n \n6  the Command Pattern\nThese top secret drop \nboxes have revolutionized the spy \nindustry. I just drop in my request and \npeople disappear, governments change \novernight, and my dry cleaning gets done. I \ndon\u2019t have to worry about when, where, or \nhow; it just happens!", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 229", "position": 229, "chunk_type": "semantic", "token_estimate": 136}
{"text": "192\u2003 \u2003 Chapter 6: home automation or bust\nHome Automation or Bust, Inc.\n1221 Industrial Avenue, Suite 2000\nFuture City, IL 62914\nGreetings! I recently received a demo and briefing from Johnny \nHurricane, CEO of Weather-O-Rama, on their new \nexpandable weather station. I have to say, I was so \nimpressed with the software architecture that I\u2019d like to \nask you to design the API for our new Home Automation \nRemote Control. In return for your services we\u2019d be happy \nto handsomely reward you with stock options in Home \nAutomation or Bust, Inc.\nYou should have already received a prototype of our \nground-breaking remote control for your perusal. The \nremote control features seven programmable slots (each \ncan be assigned to a  different household device) along with \ncorresponding on/off buttons for each. The remote also has \na global undo button. I\u2019m also attaching to this email a set of  Java classes \nthat were created by various vendors to control home \nautomation devices such as lights, fans, hot tubs, audio \nequipment, and other similar controllable appliances. We\u2019d like you to create an API for programming the remote \nso that each slot can be assigned to control a device or set of \ndevices. Note that it is important that we be able to control \nall the current devices, and also any future devices that the \nvendors may supply. Given the work you did on the Weather-O-Rama weather \nstation, we know you\u2019ll do a great job on our remote control! We look forward to seeing your design. Sincerely,\nBill Thompson, CEO", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 230", "position": 230, "chunk_type": "semantic", "token_estimate": 255}
{"text": "you are here 4\u2003 \u2003 193: the command pattern\nThere are on and off \nbuttons for each of \nthe seven slots. We\u2019ve got seven slots to program. We \ncan put a different device in each \nslot and control it via the buttons. Here\u2019s the global undo button that \nundoes the operation of the last \nbutton pressed. These two buttons are \nused to control the \nhousehold device stored \nin slot one...\n...and these two control \nthe household device \nstored in slot two...\n...and so on. Free hardware! Let\u2019s check out the Remote Control...\nGet your Sharpie out and \nwrite your device names here.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 231", "position": 231, "chunk_type": "semantic", "token_estimate": 101}
{"text": "you are here 4\u2003 \u2003 195: the command pattern\nMary: Yes, I thought we\u2019d see a bunch of classes with on() and off() \nmethods, but here we\u2019ve got methods like dim(), setTemperature(), \nsetVolume(), and setInputChannel(), and waterOn(). Sue: Not only that, it sounds like we can expect more vendor classes in \nthe future with methods just as diverse. Mary: I think it\u2019s important we view this as a separation of concerns. Sue: Meaning? Mary: What I mean is that the remote should know how to interpret \nbutton presses and make requests, but it shouldn\u2019t know a lot about \nhome automation or how to turn on a hot tub. Sue: But if the remote is dumb and just knows how to make generic \nrequests, how do we design the remote so that it can invoke an action \nthat, say, turns on a light or opens a garage door? Mary: I\u2019m not sure, but we don\u2019t want the remote to have to know the \nspecifics of the vendor classes. Sue: What do you mean? Mary: We don\u2019t want the remote to consist of a set of if statements, \nlike \u201cif slot1 == Light, then light.on(), else if slot1 == Hottub then \nhottub.jetsOn()\u201d. We know that is a bad design. Sue: I agree. Whenever a new vendor class comes out, we\u2019d have to go \nin and modify the code, potentially creating bugs and more work for \nourselves! Cubicle Conversation\nSue\nYour teammates are already discussing how to design the remote control API...\nWell, we\u2019ve got another design to \ndo. My first observation is that we\u2019ve \ngot a simple remote with on and off \nbuttons but a set of vendor classes \nthat are quite diverse.", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 233", "position": 233, "chunk_type": "semantic", "token_estimate": 280}
{"text": "196\u2003 \u2003 Chapter 6: command pattern might work\nMary: Yeah? Tell us more. Joe: The Command Pattern allows you to decouple the requester of an action from \nthe object that actually performs the action. So, here the requester would be the remote \ncontrol and the object that performs the action would be an instance of one of your \nvendor classes. Sue: How is that possible? How can we decouple them? After all, when I press a button, \nthe remote has to turn on a light. Joe: You can do that by introducing command objects into your design. A command object \nencapsulates a request to do something (like turn on a light) on a specific object (say, the \nliving room light object). So, if we store a command object for each button, when the \nbutton is pressed we ask the command object to do some work. The remote doesn\u2019t have \nany idea what the work is, it just has a command object that knows how to talk to the right \nobject to get the work done. So, you see, the remote is decoupled from the light object! Sue: This certainly sounds like it\u2019s going in the right direction. Mary: Still, I\u2019m having a hard time wrapping my head around the pattern. Joe: Given that the objects are so decoupled, it\u2019s a little difficult to picture how the pattern \nactually works. Mary: Let me see if I at least have the right idea: using this pattern, we could create \nan API in which these command objects can be loaded into button slots, allowing the \nremote code to stay very simple. And the command objects encapsulate how to do a home \nautomation task along with the object that needs to do it. Joe: Yes, I think so. I also think this pattern can help you with that undo button, but I \nhaven\u2019t studied that part yet. Mary: This sounds really encouraging, but I think I have a bit of work to do to really \n\u201cget\u201d the pattern. Sue: Me too. Hey, I couldn\u2019t help \noverhearing. Since Chapter 1 \nI\u2019ve been boning up on Design \nPatterns. There\u2019s a pattern \ncalled \u201cCommand Pattern\u201d I think \nmight help. Joe", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 234", "position": 234, "chunk_type": "semantic", "token_estimate": 362}
{"text": "you are here 4\u2003 \u2003 197: the command pattern\nMeanwhile, back at the Diner..., \nor, \nA brief introduction to the Command Pattern\nOkay, we all know how the Diner operates:\nYou, the Customer, \ngive the Waitress \nyour Order. 1\nThe Waitress \ntakes the Order, \nplaces it on the \norder counter, \nand says \u201cOrder \nup!\u201d\nThe Short-Order Cook prepares your meal \nfrom the Order. As Joe said, it is a little hard to understand the Command Pattern by just hearing its \ndescription. But don\u2019t fear, we have some friends ready to help: remember \nour friendly diner from Chapter 1? It\u2019s been a while since we visited Alice, \nFlo, and the short-order cook, but we\u2019ve got good reason for returning \n(beyond the food and great conversation): the diner is going to help us \nunderstand the Command Pattern. So, let\u2019s take a short detour back to the diner and study the interactions \nbetween the customers, the waitress, the orders, and the short-order \ncook. Through these interactions, you\u2019re going to understand the \nobjects involved in the Command Pattern and also get a feel for how the \ndecoupling works. After that, we\u2019re going to knock out that remote control \nAPI. Checking in at the Objectville Diner...\n2\n3\nObjectville Diner\nWish you were here...\nBurger with Cheese\n  Malt Shake", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 235", "position": 235, "chunk_type": "semantic", "token_estimate": 213}
{"text": "you are here 4\u2003 \u2003 199: the command pattern\nThe Objectville Diner roles and responsibilities\nAn Order Slip encapsulates a request to prepare a meal. Think of the Order Slip as an object that acts as a \nrequest to prepare a meal. Like any object, it can be passed \naround\u2014from the Waitress to the order counter, or to the next \nWaitress taking over her shift. It has an interface that consists \nof only one method, orderUp(), that encapsulates the actions \nneeded to prepare the meal. It also has a reference to the object \nthat needs to prepare it (in our case, the Short-Order Cook). It\u2019s \nencapsulated in that the Waitress doesn\u2019t have to know what\u2019s in \nthe Order or even who prepares the meal; she only needs to pass \nthe slip through the order window and call \u201cOrder up!\u201d\nOkay, in real life a waitress would probably \ncare what is on the order slip and who cooks \nit, but this is Objectville...work with us here! public void orderUp() {\n    cook.makeBurger();\n    cook.makeShake();\n}\nThe Waitress\u2019s job is to take Order Slips and \ninvoke the orderUp() method on them. The Waitress has it easy: take an Order from the Customer, \ncontinue helping customers until she makes it back to the \norder counter, and then invoke the orderUp() method to have \nthe meal prepared. As we\u2019ve already discussed, in Objectville, the \nWaitress really isn\u2019t worried about what\u2019s on the Order or who is going \nto prepare it; she just knows Order Slips have an orderUp() method she \ncan call to get the job done. Now, throughout the day, the Waitress\u2019s takeOrder() method gets \nparameterized with different Order Slips from different customers, but \nthat doesn\u2019t faze her; she knows all Order Slips support the orderUp() \nmethod and she can call orderUp() any time she needs a meal prepared. The Short-Order Cook has the knowledge \nrequired to prepare the meal. The Short-Order Cook is the object that really knows \nhow to prepare meals. Once the Waitress has invoked \nthe orderUp() method; the Short-Order Cook takes over and \nimplements all the methods that are needed to create meals. Notice the Waitress and the Cook are totally decoupled: the \nWaitress has Order Slips that encapsulate the details of the \nmeal; she just calls a method on each Order to get it prepared. Likewise, the Cook gets his instructions from the Order Slip; he \nnever needs to directly communicate with the Waitress.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 237", "position": 237, "chunk_type": "semantic", "token_estimate": 403}
{"text": "200\u2003 \u2003 Chapter 6: the diner is a model for command pattern\nPatience, we\u2019re getting there... Think of the Diner as a model for an OO design pattern that allows \nus to separate an object making a request from the objects that receive \nand execute those requests. For instance, in our remote control API, \nwe need to separate the code that gets invoked when we press a button \nfrom the objects of the vendor-specific classes that carry out those \nrequests. What if each slot of the remote held an object like the Diner\u2019s \nOrder Slip object? Then, when a button is pressed, we could just call \nthe equivalent of the orderUp() method on this object and have the \nlights turn on without the remote knowing the details of how to make \nthose things happen or what objects are making them happen. Now, let\u2019s switch gears a bit and map all this Diner talk to the \nCommand Pattern... Okay, we have a Diner with \na Waitress who is decoupled \nfrom the Short-Order Cook \nby an Order Slip, so what? Get to the point! Before we move on, spend some time studying \nthe diagram two pages back along with Diner \nroles and responsibilities until you think you\u2019ve \ngot a handle on the Objectville Diner objects and \nrelationships. Once you\u2019ve done that, get ready \nto nail the Command Pattern!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 238", "position": 238, "chunk_type": "semantic", "token_estimate": 225}
{"text": "you are here 4\u2003 \u2003 201: the command pattern\ncreateCommandObject()\nsetCommand()\nexecute()\naction1(), action2()\nThe Client is responsible for \ncreating the Command object. The command object consists of \na set of actions on a Receiver. The Client calls setCommand() on \nan Invoker object and passes it the \nCommand object, where it gets \nstored until it is needed. At some point in the future \nthe Invoker calls the Command \nobject\u2019s execute() method...\n...which results \nin the actions \nbeing invoked \non the Receiver. R\ne\nc\ne\ni\nv\ne\nr\n \n \n \n \n \nC\no\nm\nma\nn\nd\nexecute()\n \n \nI\nn\nv\no\nke\nr\nsetCommand()\naction1()\naction2()\n     ...\n \n \n \n \n \n \n \n \n \n \n \nC\nl\ni\nent\ncreate\nCommand\nObject()\n \n \n \n \n \nC\no\nm\nma\nn\nd\nexecute()\n \n \n \n \n \n \n \n \n \n \nR\ne\nc\ne\ni\nv\ne\nr\naction1()\naction2()\n     ...\npublic void execute {\n    receiver.action1();\n    receiver.action2();\n}\nThe Command object provides \none method, execute(), that \nencapsulates the actions and \ncan be called to invoke the \nactions on the Receiver. The actions and the Receiver \nare bound together in the \ncommand object. From the Diner to the Command Pattern\nOkay, we\u2019ve spent enough time in the Objectville Diner that we know all the \npersonalities and their responsibilities quite well. Now we\u2019re going to rework \nthe Diner diagram to reflect the Command Pattern. You\u2019ll see that all the \nplayers are the same; only the names have changed. Start Here\n1\n2\n3\nThe client creates a \ncommand object. The client does a \nsetCommand() to store \nthe command object in \nthe invoker. Later...the client asks \nthe invoker to execute \nthe command. Note: \nas you\u2019ll see later in \nthe chapter, once the \ncommand is loaded into \nthe invoker, it may be \nused and discarded, or it \nmay remain and be used \nmany times. 1\n2\n3\nLoading the Invoker", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 239", "position": 239, "chunk_type": "semantic", "token_estimate": 295}
{"text": "202\u2003 \u2003 Chapter 6: who does what\nMatch the diner objects and methods with the corresponding names from the \nCommand Pattern. Diner\nCommand Pattern\nWaitress\nShort-Order Cook\norderUp()\nOrder\nCustomer\ntakeOrder()\nCommand \nexecute()\nClient\nInvoker\nReceiver\nsetCommand()", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 240", "position": 240, "chunk_type": "semantic", "token_estimate": 36}
{"text": "you are here 4\u2003 \u2003 203: the command pattern\npublic class LightOnCommand implements Command {\n    Light light;\n  \n    public LightOnCommand(Light light) {\n        this.light = light;\n    }\n \n    public void execute() {\n        light.on();\n    }\n}\npublic interface Command {\n    public void execute();\n}\nOur first command object\nIsn\u2019t it about time we built our first command object? Let\u2019s go ahead and write some \ncode for the remote control. While we haven\u2019t figured out how to design the remote \ncontrol API yet, building a few things from the bottom up may help us... Implementing the Command interface\nFirst things first: all command objects implement the same interface, which \nconsists of one method. In the Diner we called this method orderUp(); however, \nwe typically just use the name execute(). Here\u2019s the Command interface:\nNow, let\u2019s say you want to implement a command for turning a light on. Referring to our set of vendor classes, the Light class has two methods: on() \nand off(). Here\u2019s how you can implement this as a command:\nSimple. All we need is one method called execute(). The execute() method calls \nthe on() method on the \nreceiving object, which is \nthe light we are controlling. The constructor is passed the specific \nlight that this command is going to \ncontrol\u2014say the living room light\u2014\nand stashes it in the light instance \nvariable. When execute gets called, \nthis is the light object that is going \nto be the receiver of the request. Now that you\u2019ve got a LightOnCommand class, let\u2019s see if we can put it to use... Implementing a command to turn a light on\nThis is a command, so we need to \nimplement the Command interface. Light\non()\noff()", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 241", "position": 241, "chunk_type": "semantic", "token_estimate": 277}
{"text": "204\u2003 \u2003 Chapter 6: using the command object\npublic class SimpleRemoteControl {\n    Command slot;\n    public SimpleRemoteControl() {}\n \n    public void setCommand(Command command) {\n        slot = command;\n    }\n    public void buttonWasPressed() {\n        slot.execute();\n    }\n}\npublic class RemoteControlTest {\n    public static void main(String[] args) {\n        SimpleRemoteControl remote = new SimpleRemoteControl();\n        Light light = new Light();\n        LightOnCommand lightOn = new LightOnCommand(light);\n \n        remote.setCommand(lightOn);\n        remote.buttonWasPressed();\n    }\n}\nUsing the command object\nOkay, let\u2019s make things simple: say we\u2019ve got a remote control with only one \nbutton and corresponding slot to hold a device to control:\nHere\u2019s just a bit of code to test out the simple remote control. Let\u2019s take a look and \nwe\u2019ll point out how the pieces match the Command Pattern diagram:\nFile  Edit   Window  Help  DinerFoodYum\n%java RemoteControlTest\nLight is On\n%\nWe have one slot to hold our command, \nwhich will control one device. Creating a simple test to use the Remote Control\nWe have a method for setting the \ncommand the slot is going to control. This could be called multiple times if the \nclient of this code wanted to change \nthe behavior of the remote button. This method is called when the button \nis pressed. All we do is take the \ncurrent command bound to the slot \nand call its execute() method. This is our Client in Command Pattern-speak. The remote is our Invoker; \nit will be passed a command \nobject that can be used to \nmake requests. Now we create a Light \nobject. This will be the \nReceiver of the request. Here, create a command and \npass the Receiver to it. Here, pass the command \nto the Invoker. And then we simulate the \nbutton being pressed. Here\u2019s the output of \nrunning this test code.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 242", "position": 242, "chunk_type": "semantic", "token_estimate": 285}
{"text": "you are here 4\u2003 \u2003 205: the command pattern\npublic class RemoteControlTest {\n    public static void main(String[] args) {\n        SimpleRemoteControl remote = new SimpleRemoteControl();\n        Light light = new Light();\n        GarageDoor garageDoor = new GarageDoor();\n        LightOnCommand lightOn = new LightOnCommand(light);\n        GarageDoorOpenCommand garageOpen = \n            new GarageDoorOpenCommand(garageDoor);\n \n        remote.setCommand(lightOn);\n        remote.buttonWasPressed();\n        remote.setCommand(garageOpen);\n        remote.buttonWasPressed();\n    }\n}\nGarageDoor\nup()\ndown()\nstop()\nlightOn()\nlightOff()\npublic class GarageDoorOpenCommand \n        implements Command {\n}\nYour output here. Your code here\nOkay, it\u2019s time for you to implement the \nGarageDoorOpenCommand class. First, supply the code for the \nclass below. You\u2019ll need the GarageDoor class diagram. Now that you\u2019ve got your class, what is the output of the \nfollowing code? (Hint: the GarageDoor up() method prints out \n\u201cGarage Door is Open\u201d when it is complete.) File  Edit   Window  Help  GreenEggs&Ham\n%java RemoteControlTest", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 243", "position": 243, "chunk_type": "semantic", "token_estimate": 128}
{"text": "206\u2003 \u2003 Chapter 6: command pattern defined\nThe Command Pattern defined\nYou\u2019ve done your time in the Objectville Diner, you\u2019ve partly \nimplemented the remote control API, and in the process you\u2019ve \ngot a fairly good picture of how the classes and objects interact in \nthe Command Pattern. Now we\u2019re going to define the Command \nPattern and nail down all the details. Let\u2019s start with its official definition:\nLet\u2019s step through this. We know that a command object \nencapsulates a request by binding together a set of actions on a \nspecific receiver. To achieve this, it packages the actions and the \nreceiver into an object that exposes just one method, execute(). When called, execute() causes the actions to be invoked on the \nreceiver. From the outside, no other objects really know what \nactions get performed on what receiver; they just know that if they \ncall the execute() method, their request will be serviced. We\u2019ve also seen a couple examples of parameterizing an object with a \ncommand. Back at the diner, the Waitress was parameterized with \nmultiple orders throughout the day. In the simple remote control, \nwe first loaded the button slot with a \u201clight on\u201d command and \nthen later replaced it with a \u201cgarage door open\u201d command. Like \nthe Waitress, your remote slot didn\u2019t care what command object it \nhad, as long as it implemented the Command interface. What we haven\u2019t encountered yet is using commands to \nimplement queues and logs and support undo operations. Don\u2019t worry, \nthose are pretty straightforward extensions of the basic Command \nPattern, and we\u2019ll get to them soon. We can also easily support \nwhat\u2019s known as the Meta Command Pattern once we have the \nbasics in place. The Meta Command Pattern allows you to create \nmacros of commands so that you can execute multiple commands \nat once. C\no\nmm\na\nn\nd\nexecute() {\n  receiver.action();\n}\n \n  \n \n  \n  \n \n \nR\ne\nc\nei\nv\ne\nr\naction()\nAn encapsulated request. L\ni\ng\nh\nt\nO\nn\nC\no\nm\nm\na\nnd\nexecute()\n \n \n \n \n \n \n \n \n \nR\ne\nm\no\nt\ne\n \nS\nlo\nt\n \n  \n  \n \nG\na\nr\na\ngeD\no\no\nr\nO\np\nen\nexecute()\n  \n  \n  \n  \n  \n  \n  \nC\ne\ni\nl\ni\nn\ng\nF\na\nn\nH\ni\ng\nh\nexecute()\n  \n  \n  \n  \n  \n  \n  \n \n \nS\nt\ne\nre\no\nO\nf\nf\nexecute()\nAn invoker\u2009\u2014\u2009for instance, \none slot of the remote\u2009\u2014\ncan be parameterized with \ndifferent requests.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 244", "position": 244, "chunk_type": "semantic", "token_estimate": 397}
{"text": "206\u2003 \u2003 Chapter 6: C\no\nmm\na\nn\nd\nexecute() {\n  receiver.action();\n}\n \n  \n \n  \n  \n \n \nR\ne\nc\nei\nv\ne\nr\naction()\nAn encapsulated request. L\ni\ng\nh\nt\nO\nn\nC\no\nm\nm\na\nnd\nexecute()\n \n \n \n \n \n \n \n \n \nR\ne\nm\no\nt\ne\n \nS\nlo\nt\n \n  \n  \n \nG\na\nr\na\ngeD\no\no\nr\nO\np\nen\nexecute()\n  \n  \n  \n  \n  \n  \n  \nC\ne\ni\nl\ni\nn\ng\nF\na\nn\nH\ni\ng\nh\nexecute()\n  \n  \n  \n  \n  \n  \n  \n \n \nS\nt\ne\nre\no\nO\nf\nf\nexecute()\nAn invoker\u2009\u2014\u2009for instance, \none slot of the remote\u2009\u2014\ncan be parameterized with \ndifferent requests. The Command Pattern encapsulates a request as an \nobject, thereby letting you parameterize other objects \nwith different requests, queue or log requests, and \nsupport undoable operations.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 244", "position": 244, "chunk_type": "semantic", "token_estimate": 126}
{"text": "you are here 4\u2003 \u2003 207: the command pattern\nThe ConcreteCommand defines a binding between an \naction and a Receiver. The Invoker makes a request by \ncalling execute() and the ConcreteCommand carries it \nout by calling one or more actions on the Receiver. The Receiver knows how to \nperform the work needed to \ncarry out the request. Any class \ncan act as a Receiver. Command declares an interface for all commands. As \nyou already know, a command is invoked through its \nexecute() method, which asks a receiver to perform an \naction. You\u2019ll also notice this interface has an undo() \nmethod, which we\u2019ll cover a bit later in the chapter. The Client is responsible for \ncreating a ConcreteCommand and \nsetting its Receiver. The Command Pattern defined: \nthe class diagram\nThe Invoker holds \na command and at \nsome point asks the \ncommand to carry \nout a request by \ncalling its execute() \nmethod. Invoker\n<<interface>>\nCommand\nexecute()\nundo()\naction()\nReceiver\nClient\nConcreteCommand\nexecute()\nundo()\npublic void execute() {\n    receiver.action()\n}\nThe execute() \nmethod invokes \nthe action(s) \non the receiver \nneeded to fulfill \nthe request. setCommand()\nHow does the design of the Command Pattern support the decoupling \nof the invoker of a request and the receiver of the request?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 245", "position": 245, "chunk_type": "semantic", "token_estimate": 204}
{"text": "208\u2003 \u2003 Chapter 6: where do we begin? Mary: Me too. So where do we begin? Sue:  Like we did in the SimpleRemote, we need to provide a \nway to assign commands to slots. In our case we have seven slots, \neach with an on and off button. So we might assign commands to \nthe remote something like this:\u200a\n \nonCommands[0] = onCommand; \noffCommands[0] = offCommand; \nand so on for each of the seven command slots. Mary: That makes sense, except for the Light objects. How does \nthe remote know the living room from the kitchen light? Sue: Ah, that\u2019s just it\u2014it doesn\u2019t! The remote doesn\u2019t know \nanything but how to call execute() on the corresponding \ncommand object when a button is pressed. Mary: Yeah, I sorta got that, but in the implementation, how do \nwe make sure the right objects are turning on and off the right \ndevices? Sue: When we create the commands to be loaded into the \nremote, we create one LightCommand that is bound to the living \nroom light object and another that is bound to the kitchen light \nobject. Remember, the receiver of the request gets bound to \nthe command it\u2019s encapsulated in. So, by the time the button is \npressed, no one cares which light is which; the right thing just \nhappens when the execute() method is called. Mary: I think I\u2019ve got it. Let\u2019s implement the remote and I think \nthis will get clearer! Sue: Sounds good. Let\u2019s give it a shot... Okay, I think I\u2019ve got a good \nfeel for the Command Pattern now. Great tip, Joe, I think we\u2019re going to \nlook like superstars after finishing off \nthe Remote Control API.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 246", "position": 246, "chunk_type": "semantic", "token_estimate": 278}
{"text": "you are here 4\u2003 \u2003 209: the command pattern\n  \n  \n  \n  \n  \n  \n  \nC\ne\ni\nl\ni\nn\ng\nF\na\nn\nOf\nf\nexecute()\n \n \n \n \n \nL\ni\ng\nh\nt\nO\nn\nC\no\nm\nm\na\nnd\nexecute()\n \n  \n  \n \nG\na\nr\na\ngeD\no\no\nr\nO\np\nen\nexecute()\n  \n  \n  \n  \n  \n  \n  \nC\ne\ni\nl\ni\nn\ng\nF\na\nn\nH\ni\ng\nh\nexecute()\n  \n  \n  \n  \n  \n  \n  \n \n \nS\nt\ne\nre\no\nO\nf\nf\nexecute()\n \n  \n  \n \nG\na\nr\na\ngeD\no\no\nr\nC\nl\no\nse\nexecute()\n \n \n \n \n \nL\ni\ng\nh\nt\nO\nf\nf\nC\no\nm\nm\nand\nexecute()\n \n \n \n \n \nL\ni\ng\nh\nt\nO\nn\nC\no\nm\nm\na\nnd\nexecute()\n \n \n \n \n \nL\ni\ng\nh\nt\nO\nf\nf\nC\no\nm\nm\nand\nexecute()\n  \n  \n  \n  \n  \n  \n  \n \n \nS\nt\ne\nre\no\nO\nn\nF\no\nr", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 247", "position": 247, "chunk_type": "semantic", "token_estimate": 136}
{"text": "execute(): Assigning Commands to slots\nSo we have a plan: we\u2019re going to assign a command to each slot in the \nremote control. This makes the remote control our invoker. When a button \nis pressed, the execute() method will be called on the corresponding \ncommand, which results in actions being invoked on the receiver (like \nlights, ceiling fans, and stereos). S\nt\ne\nre\no\n  off()\n   on()\n(1) Each slot gets a command. (2) When the button is pressed, the \nexecute() method is called on the \ncorresponding command. (3) In the execute() method, \nactions are invoked on the receiver. The Invoker\nWe\u2019ll worry about the \nremaining slots in a bit. In our code you\u2019ll find that each \ncommand name has \u201cCommand\u201d \nappended to it, but in print, \nwe\u2019ve unfortunately run out of \nspace for a few of them.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 247", "position": 247, "chunk_type": "semantic", "token_estimate": 138}
{"text": "210\u2003 \u2003 Chapter 6: implementing the remote control\npublic class RemoteControl {\n    Command[] onCommands;\n    Command[] offCommands;\n \n    public RemoteControl() {\n        onCommands = new Command[7];\n        offCommands = new Command[7];\n \n        Command noCommand = new NoCommand();\n        for (int i = 0; i < 7; i++) {\n            onCommands[i] = noCommand;\n            offCommands[i] = noCommand;\n        }\n    }\n  \n    public void setCommand(int slot, Command onCommand, Command offCommand) {\n        onCommands[slot] = onCommand;\n        offCommands[slot] = offCommand;\n    }\n \n    public void onButtonWasPushed(int slot) {\n        onCommands[slot].execute();\n    }\n \n    public void offButtonWasPushed(int slot) {\n        offCommands[slot].execute();\n    }\n  \n    public String toString() {\n        StringBuffer stringBuff = new StringBuffer();\n        stringBuff.append(\"\\n------ Remote Control -------\\n\");\n        for (int i = 0; i < onCommands.length; i++) {\n            stringBuff.append(\"[slot \" + i + \"] \" + onCommands[i].getClass().getName()\n                + \"    \" + offCommands[i].getClass().getName() + \"\\n\");\n        }\n        return stringBuff.toString();\n    }\n}\nIn the constructor, all we need to \ndo is instantiate and initialize the \nOn and Off arrays. This time around, the remote is going \nto handle seven On and Off commands, \nwhich we\u2019ll hold in corresponding arrays. The setCommand() method takes a slot \nposition and an On and Off command to \nbe stored in that slot. When an On or Off button is \npressed, the hardware takes \ncare of calling the corresponding \nmethods onButtonWasPushed() or \noffButtonWasPushed(). We override toString() to print out each slot and \nits corresponding command. You\u2019ll see us use this \nwhen we test the remote control. Implementing the Remote Control\nIt puts these commands in the \nOn and Off arrays for later use.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 248", "position": 248, "chunk_type": "semantic", "token_estimate": 239}
{"text": "you are here 4\u2003 \u2003 211: the command pattern\npublic class StereoOnWithCDCommand implements Command {\n    Stereo stereo;\n \n    public StereoOnWithCDCommand(Stereo stereo) {\n        this.stereo = stereo;\n    }\n \n    public void execute() {\n        stereo.on();\n        stereo.setCD();\n        stereo.setVolume(11);\n    }\n}\npublic class LightOffCommand implements Command {\n    Light light;\n \n    public LightOffCommand(Light light) {\n        this.light = light;\n    }\n \n    public void execute() {\n        light.off();\n    }\n}\nImplementing the Commands\nWell, we\u2019ve already gotten our feet wet implementing the LightOnCommand for the \nSimpleRemoteControl. We can plug that same code in here and everything works \nbeautifully. Off commands are no different; in fact, the LightOffCommand looks like this:\nThe LightOffCommand works exactly \nthe same way as the LightOnCommand, \nexcept that we\u2019re binding the receiver to \na different action: the off() method. Let\u2019s try something a little more challenging; how about writing on and off \ncommands for the Stereo? Okay, off is easy, we just bind the Stereo to the off() \nmethod in the StereoOffCommand. On is a little more complicated; let\u2019s say we \nwant to write a StereoOnWithCDCommand... Stereo\non()\noff()\nsetCd()\nsetDvd()\nsetRadio()\nsetVolume()\nJust like the LightOnCommand, we \nget passed the instance of the stereo \nwe\u2019re going to be controlling and we \nstore it in an instance variable. T\no carry out this request, we need to call three \nmethods on the stereo: first, turn it on, then set \nit to play the CD, and finally set the volume to 11. Why 11? Well, it\u2019s better than 10, right? Not too bad. Take a look at the rest of the vendor classes; by now, you can definitely \nknock out the rest of the Command classes we need for those.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 249", "position": 249, "chunk_type": "semantic", "token_estimate": 269}
{"text": "212\u2003 \u2003 Chapter 6: testing the remote control\npublic class RemoteLoader {\n \n    public static void main(String[] args) {\n        RemoteControl remoteControl = new RemoteControl();\n \n        Light livingRoomLight = new Light(\"Living Room\");\n        Light kitchenLight = new Light(\"Kitchen\");\n        CeilingFan ceilingFan = new CeilingFan(\"Living Room\");\n        GarageDoor garageDoor = new GarageDoor(\"Garage\");\n        Stereo stereo = new Stereo(\"Living Room\");\n  \n        LightOnCommand livingRoomLightOn = \n                new LightOnCommand(livingRoomLight);\n        LightOffCommand livingRoomLightOff = \n                new LightOffCommand(livingRoomLight);\n        LightOnCommand kitchenLightOn = \n                new LightOnCommand(kitchenLight);\n        LightOffCommand kitchenLightOff = \n                new LightOffCommand(kitchenLight);\n  \n        CeilingFanOnCommand ceilingFanOn = \n                new CeilingFanOnCommand(ceilingFan);\n        CeilingFanOffCommand ceilingFanOff = \n                new CeilingFanOffCommand(ceilingFan);\n \n        GarageDoorUpCommand garageDoorUp =\n                new GarageDoorUpCommand(garageDoor);\n        GarageDoorDownCommand garageDoorDown =\n                new GarageDoorDownCommand(garageDoor);\n \n        StereoOnWithCDCommand stereoOnWithCD =\n                new StereoOnWithCDCommand(stereo);\n        StereoOffCommand stereoOff =\n                new StereoOffCommand(stereo);\n \nPutting the Remote Control through its paces\nOur job with the remote is pretty much done; all we need to do is run some tests and get \nsome documentation together to describe the API. Home Automation or Bust, Inc., sure \nis going to be impressed, don\u2019t ya think? We\u2019ve managed to come up with a design \nthat will allow them to produce a remote that is easy to maintain, and they\u2019re going \nto have no trouble convincing the vendors to write some simple command classes in \nthe future since those are so easy to write. Let\u2019s get to testing this code! Create all the devices in \ntheir proper locations. Create all the Light \nCommand objects. Create the On and Off \nfor the ceiling fan. Create the Up and Down \ncommands for the Garage. Create the stereo On \nand Off commands.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 250", "position": 250, "chunk_type": "semantic", "token_estimate": 240}
{"text": "you are here 4\u2003 \u2003 213: the command pattern\n        remoteControl.setCommand(0, livingRoomLightOn, livingRoomLightOff);\n        remoteControl.setCommand(1, kitchenLightOn, kitchenLightOff);\n        remoteControl.setCommand(2, ceilingFanOn, ceilingFanOff);\n        remoteControl.setCommand(3, stereoOnWithCD, stereoOff);\n  \n        System.out.println(remoteControl);\n \n        remoteControl.onButtonWasPushed(0);\n        remoteControl.offButtonWasPushed(0);\n        remoteControl.onButtonWasPushed(1);\n        remoteControl.offButtonWasPushed(1);\n        remoteControl.onButtonWasPushed(2);\n        remoteControl.offButtonWasPushed(2);\n        remoteControl.onButtonWasPushed(3);\n        remoteControl.offButtonWasPushed(3);\n    }\n}\nFile  Edit   Window  Help  CommandsGetThingsDone\n% java RemoteLoader\n------ Remote Control -------\n[slot 0] LightOnCommand            LightOffCommand\n[slot 1] LightOnCommand            LightOffCommand\n[slot 2] CeilingFanOnCommand       CeilingFanOffCommand\n[slot 3] StereoOnWithCDCommand     StereoOffCommand\n[slot 4] NoCommand                 NoCommand\n[slot 5] NoCommand                 NoCommand\n[slot 6] NoCommand                 NoCommand\nLiving Room light is on\nLiving Room light is off\nKitchen light is on\nKitchen light is off\nLiving Room ceiling fan is on high\nLiving Room ceiling fan is off\nLiving Room stereo is on\nLiving Room stereo is set for CD input\nLiving Room stereo volume set to 11\nLiving Room stereo is off\n%\nNow that we\u2019ve got \nall our commands, we \ncan load them into \nthe remote slots. Here\u2019s where we use our toString() method \nto print each remote slot and the command \nassigned to it. (Note that toString() gets \ncalled automatically here, so we don\u2019t have \nto call toString() explicitly.) All right, we are ready to roll! Now, we step through each slot \nand push its On and Off buttons. Now, let\u2019s check out the execution of our remote control test...\nOn slots    Off slots\nOur commands in action! Remember, the output \nfrom each device comes from the vendor classes. For instance, when a light object is turned on, it \nprints \u201cLiving Room light is on.\u201d", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 251", "position": 251, "chunk_type": "semantic", "token_estimate": 242}
{"text": "214\u2003 \u2003 Chapter 6: null object\nCommand noCommand = new NoCommand();\nfor (int i = 0; i < 7; i++) {\n    onCommands[i] = noCommand;\n    offCommands[i] = noCommand;\n}\npublic class NoCommand implements Command {\n    public void execute() { }\n}\nGood catch. We did sneak a little something in there. In the remote \ncontrol, we didn\u2019t want to check to see if a command was loaded every \ntime we referenced a slot. For instance, in the onButtonWasPushed() \nmethod, we would need code like this:\npublic void onButtonWasPushed(int slot) {\n    if (onCommands[slot] != null) {\n        onCommands[slot].execute();\n    }\n}\nSo, how do we get around that? Implement a command that does nothing! Then, in our RemoteControl constructor, we assign every slot a \nNoCommand object by default and we know we\u2019ll always have some \ncommand to call in each slot. So, in the output of our test run, you\u2019re seeing only slots that have been \nassigned to a command other than the default NoCommand object, \nwhich we assigned when we created the RemoteControl constructor. Pattern \n \n \n \n \n \n \n \n \n \n \n \n \nHonorable \nMention\nHead First\nHonorable \nMention\nThe NoCommand object is an example of a null object. A null object is useful when \nyou don\u2019t have a meaningful object to return, and yet you want to remove the \nresponsibility for handling null from the client. For instance, in our remote control we \ndidn\u2019t have a meaningful object to assign to each slot out of the box, so we provided \na NoCommand object that acts as a surrogate and does nothing when its execute() \nmethod is called. You\u2019ll find uses for Null Objects in conjunction with many Design Patterns, and \nsometimes you\u2019ll even see \u201cNull Object\u201d listed as a Design Pattern. Wait a second, what\u2019s \nwith that NoCommand \nthat\u2019s loaded in slots 4 \nthrough 6? Trying to pull a \nfast one?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 252", "position": 252, "chunk_type": "semantic", "token_estimate": 300}
{"text": "you are here 4\u2003 \u2003 215: the command pattern\nTime to write that documentation... Remote Control API Design for Home Automation or Bust, Inc.\nWe are pleased to present you with the following design and application programming interface for your Home \nAutomation Remote Control. Our primary design goal was to keep the remote control code as simple as possible so that \nit doesn\u2019t require changes as new vendor classes are produced. To this end we have employed the Command Pattern to \nlogically decouple the RemoteControl class from the Vendor Classes. We believe this will reduce the cost of producing \nthe remote as well as drastically reduce your ongoing maintenance costs. The following class diagram provides an overview of our design:\nUsing the Command Interface, we implement each action \nthat can be invoked by pressing a button on the remote \nwith a simple Command object. The Command object holds \na reference to an object that is an instance of a Vendor Class \nand implements an execute() method that calls one or more \nmethods on that object. Here we show two such classes \nthat turn a light on and off, respectively. The Vendor Classes are used to perform \nthe actual home automation work of \ncontrolling devices. Here, we\u2019re using the \nLight class as an example. All RemoteControl commands \nimplement the Command \ninterface, which consists of one \nmethod: execute(). Commands \nencapsulate a set of actions on a \nspecific vendor class. The remote \ninvokes these actions by calling \nthe execute() method. The RemoteLoader creates a \nnumber of Command objects \nthat are loaded into the slots \nof the Remote Control. Each \ncommand object encapsulates \na request of a home \nautomation device. RemoteControl\nsetCommand()\nonButtonWasPushed()\noffButtonWasPushed()\n<<interface>>\nCommand\nexecute()\non()\noff()\nLight\nRemoteLoader\nLightOnCommand\nexecute()LightOffCommand\nexecute()\npublic void execute() {\n    light.on()\n}\npublic void execute() {\n    light.off()\n}\nonCommands\noffCommands\nThe RemoteControl class manages a set of \nCommand objects, one per button. When a button \nis pressed, the corresponding ButtonWasPushed() \nmethod is called, which invokes the execute() \nmethod on the command. That is the full extent of \nthe remote\u2019s knowledge of the classes it\u2019s invoking \nas the Command object decouples the remote from \nthe classes doing the actual home automation work.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 253", "position": 253, "chunk_type": "semantic", "token_estimate": 364}
{"text": "216\u2003 \u2003 Chapter 6: public class RemoteLoader {\n \n   public static void main(String[] args) {\n      RemoteControl remoteControl = new RemoteControl();\n      Light livingRoomLight = new Light(\"Living Room\");\n      ... \n      LightOnCommand livingRoomLightOn = \n\t\n\t\n\t\n\t\nnew LightOnCommand(livingRoomLight);\n      LightOffCommand livingRoomLightOff = \n\t\n\t\n\t\n\t\nnew LightOffCommand(livingRoomLight);\n      ...\n      remoteControl.setCommand(0,() -> livingRoomLight.on(), \n                                 () -> livingRoomLight.off());\n      ...\n   }\n}\nThe updated code, using lambda expressions:\nWe create the Light \nobject like normal...\nWant to take your Command Pattern coding to the next level? You can use Java\u2019s lambda expressions \nto skip the step of creating all those concrete command objects. With lambda expressions, instead of \ninstantiating the concrete command objects, you can use function objects in their place. In other words, \nwe can use a function object as a command. And, while we\u2019re at it, we can delete all those concrete \nCommand classes, too. Let\u2019s take a look at how you\u2019d use lambda expressions as commands to simplify our previous code:\nOnce we\u2019ve replaced the concrete commands with lambda expressions, we can delete all those \nconcrete command classes (LightOnCommand, LightOffCommand, HottubOnCommand, \nHottubOffCommand, etc.). If you do this for every concrete command, you\u2019ll reduce the total number \nof classes in the remote control application from 22 to 9. Note that you can only do this if your Command interface has one abstract method. As soon as we add a \nsecond abstract method, the lambda shorthand no longer works. If you like this technique, check out your favorite Java reference for more information on the lambda \nexpression. But we can remove \nthe concrete \nLightOnCommand and \nLightOffCommand \nobjects. Instead we'll write the concrete commands as lambda \nexpressions that do the same work as the concrete \ncommand\u2019s execute() method was doing: that is, turning \nthe light on or turning the light off. represent commands with lambdas\nLater, when you click one of the remote\u2019s \nbuttons, the remote calls the execute() \nmethod of the command object in the \nslot for that button, which is represented \nby this lambda expression.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 254", "position": 254, "chunk_type": "semantic", "token_estimate": 320}
{"text": "you are here 4\u2003 \u2003 217: the command pattern\npublic interface Command {\n    public void execute();\n    public void undo();\n}\nWhoops! We almost forgot...luckily, once \nwe have our basic Command classes, \nundo is easy to add. Let\u2019s step through \nadding undo to our commands and to the \nremote control...\nHere\u2019s the new undo() method. What are we doing? Okay, we need to add functionality to support the undo button on the remote. It works like \nthis: say the Living Room Light is off and you press the on button on the remote. Obviously \nthe light turns on. Now if you press the undo button, then the last action will be reversed\u2014in \nthis case, the light will turn off. Before we get into more complex examples, let\u2019s get the light \nworking with the undo button:\n1\nWhen commands support undo, they have an undo() method that mirrors the execute() \nmethod. Whatever execute() last did, undo() reverses. So, before we can add undo to our \ncommands, we need to add an undo() method to the Command interface:\nThat was simple enough. Now, let\u2019s dive into the Light commands and implement the undo() method. Great job; it looks like \nyou\u2019ve come up with a terrific \ndesign, but aren\u2019t you forgetting one \nlittle thing the customer asked for? LIKE THE UNDO BUTTON? !", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 255", "position": 255, "chunk_type": "semantic", "token_estimate": 218}
{"text": "218\u2003 \u2003 Chapter 6: public class LightOffCommand implements Command {\n    Light light;\n \n    public LightOffCommand(Light light) {\n        this.light = light;\n    }\n \n    public void execute() {\n        light.off();\n    }\n \n    public void undo() {\n        light.on();\n    }\n}\npublic class LightOnCommand implements Command {\n    Light light;\n \n    public LightOnCommand(Light light) {\n        this.light = light;\n    }\n \n    public void execute() {\n        light.on();\n    }\n \n    public void undo() {\n        light.off();\n    }\n}\nCould this be any easier? Okay, we aren\u2019t done yet; we need to work a little \nsupport into the Remote Control to handle tracking the last button pressed \nand the undo button press. Piece of cake! Now for the LightOffCommand. Here the undo() method just \nneeds to call the Light\u2019s on() method. 2\nLet\u2019s start with the LightOnCommand: if the LightOnCommand\u2019s execute() method \nwas called, then the on() method was last called. We know that undo() needs to do the \nopposite of this by calling the off() method. And here, undo() turns \nthe light back on. execute() turns the light \non, so undo() simply turns \nthe light back off. implementing undo", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 256", "position": 256, "chunk_type": "semantic", "token_estimate": 172}
{"text": "you are here 4\u2003 \u2003 219: the command pattern\npublic class RemoteControlWithUndo {\n    Command[] onCommands;\n    Command[] offCommands;\n    Command undoCommand;\n \n    public RemoteControlWithUndo() {\n        onCommands = new Command[7];\n        offCommands = new Command[7];\n \n        Command noCommand = new NoCommand();\n        for(int i=0;i<7;i++) {\n            onCommands[i] = noCommand;\n            offCommands[i] = noCommand;\n        }\n        undoCommand = noCommand;\n    }\n  \n    public void setCommand(int slot, Command onCommand, Command offCommand) {\n        onCommands[slot] = onCommand;\n        offCommands[slot] = offCommand;\n    }\n \n    public void onButtonWasPushed(int slot) {\n        onCommands[slot].execute();\n        undoCommand = onCommands[slot];\n    }\n \n    public void offButtonWasPushed(int slot) {\n        offCommands[slot].execute();\n        undoCommand = offCommands[slot];\n    }\n \n    public void undoButtonWasPushed() {\n        undoCommand.undo();\n    }\n  \n    public String toString() {\n        // toString code here...\n    }\n}\n3\nTo add support for the undo button, we only have to make a few small changes to the Remote \nControl class. Here\u2019s how we\u2019re going to do it: we\u2019ll add a new instance variable to track the last \ncommand invoked; then, whenever the undo button is pressed, we retrieve that command and \ninvoke its undo() method. This is where we\u2019ll stash the last \ncommand executed for the undo button. Just like the other slots, undo \nstarts off with a noCommand, so \npressing undo before any other \nbutton won\u2019t do anything at all. When a button is pressed, we take \nthe command and first execute \nit; then we save a reference to \nit in the undoCommand instance \nvariable. We do this for both on \ncommands and off commands. When the undo button is pressed, we \ninvoke the undo() method of the \ncommand stored in undoCommand. This undoes the operation of the last \ncommand executed. Update to add undoCommands.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 257", "position": 257, "chunk_type": "semantic", "token_estimate": 258}
{"text": "220\u2003 \u2003 Chapter 6: public class RemoteLoader {\n \n    public static void main(String[] args) {\n        RemoteControlWithUndo remoteControl = new RemoteControlWithUndo();\n \n        Light livingRoomLight = new Light(\"Living Room\");\n \n        LightOnCommand livingRoomLightOn = \n                new LightOnCommand(livingRoomLight);\n        LightOffCommand livingRoomLightOff = \n                new LightOffCommand(livingRoomLight);\n \n        remoteControl.setCommand(0, livingRoomLightOn, livingRoomLightOff);\n \n        remoteControl.onButtonWasPushed(0);\n        remoteControl.offButtonWasPushed(0);\n        System.out.println(remoteControl);\n        remoteControl.undoButtonWasPushed();\n        remoteControl.offButtonWasPushed(0);\n        remoteControl.onButtonWasPushed(0);\n        System.out.println(remoteControl);\n        remoteControl.undoButtonWasPushed();\n    }\n}\nTime to QA that Undo button! Create a Light, and our new undo() \nenabled Light On and Off Commands. Add the light Commands \nto the remote in slot 0. And here are the test results... Okay, let\u2019s rework the test harness a bit to test the undo button:\nTurn the light on, then \noff, and then undo. Then, turn the light off, back on, and undo. File  Edit   Window  Help  UndoCommandsDefyEntropy\n% java RemoteLoader\nLight is on\nLight is off\n------ Remote Control -------\n[slot 0] LightOnCommand        LightOffCommand\n[slot 1] NoCommand             NoCommand\n[slot 2] NoCommand             NoCommand\n[slot 3] NoCommand             NoCommand\n[slot 4] NoCommand             NoCommand\n[slot 5] NoCommand             NoCommand\n[slot 6] NoCommand             NoCommand\n[undo] LightOffCommand\nLight is on\nLight is off\nLight is on\n------ Remote Control -------\n[slot 0] LightOnCommand        LightOffCommand\n[slot 1] NoCommand             NoCommand\n[slot 2] NoCommand             NoCommand\n[slot 3] NoCommand             NoCommand\n[slot 4] NoCommand             NoCommand\n[slot 5] NoCommand             NoCommand\n[slot 6] NoCommand             NoCommand\n[undo] LightOnCommand\nLight is off\nUndo was pressed...\u2009the LightOffCommand \nundo() turns the light back on. Here are the Light commands. Turn the light on, then off. Now undo holds the \nLightOffCommand, the \nlast command invoked. Then we turn the light off and back on. Undo was pressed, so the light is back off. Now undo holds the LightOnCommand, the last \ncommand invoked. test drive undo", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 258", "position": 258, "chunk_type": "semantic", "token_estimate": 268}
{"text": "you are here 4\u2003 \u2003 221: the command pattern\npublic class CeilingFan {\n    public static final int HIGH = 3;\n    public static final int MEDIUM = 2;\n    public static final int LOW = 1;\n    public static final int OFF = 0;\n    String location;\n    int speed;\n \n    public CeilingFan(String location) {\n        this.location = location;\n        speed = OFF;\n    }\n  \n    public void high() {\n        speed = HIGH;\n        // code to set fan to high\n    } \n \n    public void medium() {\n        speed = MEDIUM;\n        // code to set fan to medium \n    }\n \n    public void low() {\n        speed = LOW;\n        // code to set fan to low\n    }\n  \n    public void off() {\n        speed = OFF;\n        // code to turn fan off\n    }\n  \n    public int getSpeed() {\n        return speed;\n    }\n}\nUsing state to implement Undo\nOkay, implementing undo on the Light was instructive but a little too easy. Typically, \nwe need to manage a bit of state to implement undo. Let\u2019s try something a little more \ninteresting, like the CeilingFan from the vendor classes. The CeilingFan class allows a \nnumber of speeds to be set along with an off method. Here\u2019s the source code for the CeilingFan class:\nCeilingFan\nhigh()\nmedium()\nlow()\noff()\ngetSpeed()\nNotice that the CeilingFan class \nholds local state representing the \nspeed of the ceiling fan. These methods set the \nspeed of the ceiling fan. We can get the current \nspeed of the ceiling fan \nusing getSpeed(). Hmm, so to properly \nimplement undo, I\u2019d have \nto take the previous speed of \nthe ceiling fan into account...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 259", "position": 259, "chunk_type": "semantic", "token_estimate": 251}
{"text": "222\u2003 \u2003 Chapter 6: public class CeilingFanHighCommand implements Command {\n    CeilingFan ceilingFan;\n    int prevSpeed;\n  \n    public CeilingFanHighCommand(CeilingFan ceilingFan) {\n        this.ceilingFan = ceilingFan;\n    }\n \n    public void execute() {\n        prevSpeed = ceilingFan.getSpeed();\n        ceilingFan.high();\n    }\n \n    public void undo() {\n        if (prevSpeed == CeilingFan.HIGH) {\n            ceilingFan.high();\n        } else if (prevSpeed == CeilingFan.MEDIUM) {\n            ceilingFan.medium();\n        } else if (prevSpeed == CeilingFan.LOW) {\n            ceilingFan.low();\n        } else if (prevSpeed == CeilingFan.OFF) {\n            ceilingFan.off();\n        }\n    }\n}\nNow let\u2019s tackle adding undo to the various Ceiling Fan commands. To \ndo so, we need to track the last speed setting of the fan and, if the undo() \nmethod is called, restore the fan to its previous setting. Here\u2019s the code for \nthe CeilingFanHighCommand:\nWe\u2019ve added local state to \nkeep track of the previous \nspeed of the fan. In execute(), before we \nchange the speed of the \nfan, we need to first \nrecord its previous state, \njust in case we need to \nundo our actions. T\no undo, we set the \nspeed of the fan back \nto its previous speed. Adding Undo to the Ceiling Fan commands\nWe\u2019ve got three more ceiling fan commands to write: low, \nmedium, and off. Can you see how these are implemented? add undo to the ceiling fan", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 260", "position": 260, "chunk_type": "semantic", "token_estimate": 201}
{"text": "you are here 4\u2003 \u2003 223: the command pattern\npublic class RemoteLoader {\n \n    public static void main(String[] args) {\n        RemoteControlWithUndo remoteControl = new RemoteControlWithUndo();\n \n        CeilingFan ceilingFan = new CeilingFan(\"Living Room\");\n   \n        CeilingFanMediumCommand ceilingFanMedium = \n                new CeilingFanMediumCommand(ceilingFan);\n        CeilingFanHighCommand ceilingFanHigh = \n                new CeilingFanHighCommand(ceilingFan);\n        CeilingFanOffCommand ceilingFanOff = \n                new CeilingFanOffCommand(ceilingFan);\n  \n        remoteControl.setCommand(0, ceilingFanMedium, ceilingFanOff);\n        remoteControl.setCommand(1, ceilingFanHigh, ceilingFanOff);\n   \n        remoteControl.onButtonWasPushed(0);\n        remoteControl.offButtonWasPushed(0);\n        System.out.println(remoteControl);\n        remoteControl.undoButtonWasPushed();\n  \n        remoteControl.onButtonWasPushed(1);\n        System.out.println(remoteControl);\n        remoteControl.undoButtonWasPushed();\n    }\n}\nGet ready to test the ceiling fan\nTime to load up our remote control with the ceiling fan \ncommands. We\u2019re going to load slot 0\u2019s on button with the \nmedium setting for the fan and slot 1 with the high setting. Both corresponding off buttons will hold the ceiling fan off \ncommand. Here\u2019s our test script:\nHere we instantiate three \ncommands: medium, high, and off. Here we put medium in \nslot 0, and high in slot \n1. We also load up the \noff command. First, turn the fan on medium. Then turn it off. Undo! It should go back to medium... Turn it on to high this time. And, one more undo; it should go back \nto medium.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 261", "position": 261, "chunk_type": "semantic", "token_estimate": 177}
{"text": "224\u2003 \u2003 Chapter 6: v\n% java RemoteLoader\nLiving Room ceiling fan is on medium\nLiving Room ceiling fan is off\n------ Remote Control -------\n[slot 0] CeilingFanMediumCommand    CeilingFanOffCommand\n[slot 1] CeilingFanHighCommand      CeilingFanOffCommand\n[slot 2] NoCommand                  NoCommand\n[slot 3] NoCommand                  NoCommand\n[slot 4] NoCommand                  NoCommand\n[slot 5] NoCommand                  NoCommand\n[slot 6] NoCommand                  NoCommand\n[undo] CeilingFanOffCommand\nLiving Room ceiling fan is on medium\nLiving Room ceiling fan is on high\n------ Remote Control -------\n[slot 0] CeilingFanMediumCommand    CeilingFanOffCommand\n[slot 1] CeilingFanHighCommand      CeilingFanOffCommand\n[slot 2] NoCommand                  NoCommand\n[slot 3] NoCommand                  NoCommand\n[slot 4] NoCommand                  NoCommand\n[slot 5] NoCommand                  NoCommand\n[slot 6] NoCommand                  NoCommand\n[undo] CeilingFanHighCommand\nLiving Room ceiling fan is on medium\n%\nFile  Edit   Window  Help  UndoThis! One more undo, and the ceiling \nfan goes back to medium speed. Turn the ceiling fan on \nmedium, then turn it off. ...and undo has the last command \nexecuted, the CeilingFanOffCommand, \nwith the previous speed of medium. Here are the commands \nin the remote control... Undo the last command, and it goes back to medium. Now, turn it on high. Now, high is the last \ncommand executed. Testing the ceiling fan... Okay, let\u2019s fire up the remote, load it with commands, and push some buttons! test drive the ceiling fan", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 262", "position": 262, "chunk_type": "semantic", "token_estimate": 205}
{"text": "you are here 4\u2003 \u2003 225: the command pattern\npublic class MacroCommand implements Command {\n    Command[] commands;\n \n    public MacroCommand(Command[] commands) {\n        this.commands = commands;\n    }\n \n    public void execute() {\n        for (int i = 0; i < commands.length; i++) {\n            commands[i].execute();\n        }\n    }\n}\nEvery remote needs a Party Mode! Hottub\non()\noff()\ncirculate()\njetsOn()\njetsOff()\nsetTemperature()\nStereo\non()\noff()\nsetCd()\nsetDvd()\nsetRadio()\nsetVolume()\nLight\non()\noff()\ndim()\non()\noff()\nsetInputChannel()\nsetVolume()", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 263", "position": 263, "chunk_type": "semantic", "token_estimate": 70}
{"text": "Mary\u2019s idea is to make a new: kind of Command that can \nexecute other Commands... \nand more than one of them! Pretty good idea, huh? T\nake an array of Commands and store \nthem in the MacroCommand. When the macro gets executed by the remote, \nexecute those commands one at a time. What\u2019s the point of having a remote if you \ncan\u2019t push one button and have the lights \ndimmed, the stereo and TV turned on, and \nthe hot tub fired up? Hmm, our remote \ncontrol would need a \nbutton for each device, so \nI don\u2019t think we can do this. Hold on, Sue, don\u2019t be \nso sure. I think we can do \nthis without changing the \nremote at all!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 263", "position": 263, "chunk_type": "semantic", "token_estimate": 120}
{"text": "226\u2003 \u2003 Chapter 6: remoteControl.setCommand(0, partyOnMacro, partyOffMacro);\nCommand[] partyOn = { lightOn, stereoOn, tvOn, hottubOn};\nCommand[] partyOff = { lightOff, stereoOff, tvOff, hottubOff};\n  \nMacroCommand partyOnMacro = new MacroCommand(partyOn);\nMacroCommand partyOffMacro = new MacroCommand(partyOff);\nLight light = new Light(\"Living Room\");\nTV tv = new TV(\"Living Room\");\nStereo stereo = new Stereo(\"Living Room\");\nHottub hottub = new Hottub();\n \nLightOnCommand lightOn = new LightOnCommand(light);\nStereoOnCommand stereoOn = new StereoOnCommand(stereo);\nTVOnCommand tvOn = new TVOnCommand(tv);\nHottubOnCommand hottubOn = new HottubOnCommand(hottub);\nUsing a macro command\nLet\u2019s step through how we use a macro command:\n1\nFirst we create the set of commands we want to go into the macro:\nNext we create two arrays, one for the On commands and one for the Off \ncommands, and load them with the corresponding commands:\n3\nThen we assign MacroCommand to a button like we always do:\nCreate all the devices: a light, \ntv, stereo, and hot tub. Now create all the On \ncommands to control them. Create an array for \nOn commands and \nan array for Off \ncommands...\n...and  create two \ncorresponding macros \nto hold them. Assign the macro \ncommand to a button as \nyou would any command. We\u2019ll also need commands for the off buttons. Write the code to create those here:\n2\ncreate a macro command", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 264", "position": 264, "chunk_type": "semantic", "token_estimate": 210}
{"text": "you are here 4\u2003 \u2003 227: the command pattern\nSystem.out.println(remoteControl);\nSystem.out.println(\"--- Pushing Macro On---\");\nremoteControl.onButtonWasPushed(0);\nSystem.out.println(\"--- Pushing Macro Off---\");\nremoteControl.offButtonWasPushed(0);\nFile  Edit   Window  Help  You Can\u2019tBeatABabka\n% java RemoteLoader\n------ Remote Control -------\n[slot 0] MacroCommand    MacroCommand\n[slot 1] NoCommand       NoCommand\n[slot 2] NoCommand       NoCommand\n[slot 3] NoCommand       NoCommand\n[slot 4] NoCommand       NoCommand\n[slot 5] NoCommand       NoCommand\n[slot 6] NoCommand       NoCommand\n[undo] NoCommand\n--- Pushing Macro On---\nLight is on\nLiving Room stereo is on\nLiving Room TV is on\nLiving Room TV channel is set for DVD\nHottub is heating to a steaming 104 degrees\nHottub is bubbling! --- Pushing Macro Off---\nLight is off\nLiving Room stereo is off\nLiving Room TV is off\nHottub is cooling to 98 degrees\nHere are the two macro commands. All the Commands in the \nmacro are executed when we \ninvoke the on macro...\n...and when we invoke the off \nmacro. Looks like it works. 4\nFinally, we just need to push some buttons and see if this works. Here\u2019s the output.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 265", "position": 265, "chunk_type": "semantic", "token_estimate": 169}
{"text": "228\u2003 \u2003 Chapter 6: exercise with macro commands\nThe only thing our MacroCommand is missing is its undo functionality. When the undo \nbutton is pressed after a macro command, all the commands that were invoked in the \nmacro must undo their previous actions. Here\u2019s the code for MacroCommand; go ahead \nand implement the undo() method:\npublic class MacroCommand implements Command {\n    Command[] commands;\n    public MacroCommand(Command[] commands) {\n        this.commands = commands;\n    }\n    public void execute() {\n        for (int i = 0; i < commands.length; i++) {\n            commands[i].execute();\n        }\n    }\n    public void undo() {\n    }\n}\nQ: Do I always need a receiver? Why \ncan\u2019t the command object implement the \ndetails of the execute() method? A: In general, we strive for \u201cdumb\u201d \ncommand objects that just invoke an action \non a receiver; however, there are many \nexamples of \u201csmart\u201d command objects \nthat implement most, if not all, of the logic \nneeded to carry out a request. Certainly you \ncan do this; just keep in mind you\u2019ll no longer \nhave the same level of decoupling between \nthe invoker and receiver, nor will you be \nable to parameterize your commands with \nreceivers. Q: How can I implement a history \nof undo operations? In other words, I \nwant to be able to press the undo button \nmultiple times. A: Great question. It\u2019s pretty easy \nactually; instead of keeping just a reference \nto the last Command executed, you keep \na stack of previous commands. Then, \nwhenever undo is pressed, your invoker \npops the first item off the stack and calls its \nundo() method. Q: Could I have just implemented \nparty mode as a Command by creating \na PartyCommand and putting the calls \nto execute the other Commands in \nPartyCommand\u2019s execute() method? A: You could; however, you\u2019d essentially \nbe  \u201chardcoding\u201d the party mode into \nPartyCommand. Why go to the trouble? With MacroCommand, you can decide \ndynamically which Commands you want to \ngo into PartyCommand, so you have more \nflexibility using MacroCommands. In general, \nMacroCommand is a more elegant solution \nand requires less new code.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 266", "position": 266, "chunk_type": "semantic", "token_estimate": 336}
{"text": "you are here 4\u2003 \u2003 229: the command pattern\nMore uses of the Command Pattern: queuing requests\nNote that the job queue classes are totally decoupled from \nthe objects that are doing the computation. One minute a \nthread may be computing a financial computation, and the \nnext it may be retrieving something from the network. The \njob queue objects don\u2019t care; they just retrieve commands \nand call execute(). Likewise, as long as you put objects into \nthe queue that implement the Command Pattern, your \nexecute() method will be invoked when a thread is available. T\nh\nre\na\nd\n \n \n \n \n \n \n \n \n \n \nR\na\ny\nTr\na\nce\nexecute()\n  \n  \n  \n  \n  \n  \n  \n \n \nC\no\nmp\ni\nl\ne\nr\nT\na\ns\nk\n \n \n \n \n \n \n \n \n \n \n \nT\nh\nre\na\nd\nThreads computing \njobs\nObjects implementing the \ncommand interface are \nadded to the queue. Threads remove commands \nfrom the queue one by one \nand call their execute() \nmethod. Once complete, \nthey go back for a new \ncommand object. This gives us an effective way \nto limit computation to a \nfixed number of threads. F\ni\nn\na\nn\nc\ni\na\nl\nC\no\nm\np\nu\nt\na\nt\ni\non \n  \n  \n  \n  \n  \n  \n \nC\no\nm\np\nil\ne\nr\nTa\nsk\nexecute()\n  \n  \n  \n  \n  \n  \n  \nD\no\nw\nnlo\na\ndR\ne\nqu\nest\nexecute()\n  \n  \n  \n  \n  \n  \n \nC\no\nm\np\nil\ne\nr\nTa\nsk\nexecute()\n  \n  \n  \n  \n  \n  \n  \nN\ne\nt\nwo\nr\nk\nF\ne\nt\nc\nh\nexecute()\nF\ni\nn\na\nn\nc\ni\na\nl\n Co\nm\npu\nt\na\nt\nion\nexecute()\n \n \n \n \n \n \n \n \n \n \nR\na\ny\nTr\na\nce\nexecute()\n   \n   \n   \nD\nis\nt\nr\ni\nb\nu\nt\ne\ndC\no\nmp\nut\na\nt\ni\non\nexecute()\nexecute()\n  \n  \n  \n  \n  \n  \n  \nD\no\nw\nnlo\na\ndR\ne\nqu\nest\n  \n  \n  \n  \n  \n  \n  \n \n \nC\no\nmp\ni\nl\ne\nr\nT\na\ns\nk\nexecute()\n  \n  \n  \n  \n  \n  \n  \nN\ne\nt\nwo\nr\nk\nF\ne\nt\nc\nh\nexecute()\nF\ni\nn\na\nn\nc\ni\na\nl\nC\no\nm\np\nu\nt\na\nt\ni\non\nexecute()\n \n \n \n \n \n \n \n \n \n \nR\na\ny\nTr\na\nce\nexecute()\nexecute()\nJob queue\nCommands\nexecute()\n  \n  \n  \n  \n  \n  \n  \nD\no\nw\nnlo\na\ndR\ne\nqu\nest\n \n \n \n \n \n \n \n \n \n \n \nT\nh\nre\na\nd\nexecute()\n  \n  \n  \n  \n  \n  \n  \nN\ne\nt\nwo\nr\nk\nF\ne\nt\nc\nh\n \n \n \n \n \n \n \n \n \n \n \nT\nh\nre\na\nd\nexecute()\nCommands give us a way to package a piece of \ncomputation (a receiver and a set of actions) and pass \nit around as a first-class object.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 267", "position": 267, "chunk_type": "semantic", "token_estimate": 400}
{"text": "you are here 4\u2003 \u2003 229: This gives us an effective way \nto limit computation to a \nfixed number of threads. F\ni\nn\na\nn\nc\ni\na\nl\nC\no\nm\np\nu\nt\na\nt\ni\non \n  \n  \n  \n  \n  \n  \n \nC\no\nm\np\nil\ne\nr\nTa\nsk\nexecute()\n  \n  \n  \n  \n  \n  \n  \nD\no\nw\nnlo\na\ndR\ne\nqu\nest\nexecute()\n  \n  \n  \n  \n  \n  \n \nC\no\nm\np\nil\ne\nr\nTa\nsk\nexecute()\n  \n  \n  \n  \n  \n  \n  \nN\ne\nt\nwo\nr\nk\nF\ne\nt\nc\nh\nexecute()\nF\ni\nn\na\nn\nc\ni\na\nl\n Co\nm\npu\nt\na\nt\nion\nexecute()\n \n \n \n \n \n \n \n \n \n \nR\na\ny\nTr\na\nce\nexecute()\n   \n   \n   \nD\nis\nt\nr\ni\nb\nu\nt\ne\ndC\no\nmp\nut\na\nt\ni\non\nexecute()\nexecute()\n  \n  \n  \n  \n  \n  \n  \nD\no\nw\nnlo\na\ndR\ne\nqu\nest\n  \n  \n  \n  \n  \n  \n  \n \n \nC\no\nmp\ni\nl\ne\nr\nT\na\ns\nk\nexecute()\n  \n  \n  \n  \n  \n  \n  \nN\ne\nt\nwo\nr\nk\nF\ne\nt\nc\nh\nexecute()\nF\ni\nn\na\nn\nc\ni\na\nl\nC\no\nm\np\nu\nt\na\nt\ni\non\nexecute()\n \n \n \n \n \n \n \n \n \n \nR\na\ny\nTr\na\nce\nexecute()\nexecute()\nJob queue\nCommands\nexecute()\n  \n  \n  \n  \n  \n  \n  \nD\no\nw\nnlo\na\ndR\ne\nqu\nest\n \n \n \n \n \n \n \n \n \n \n \nT\nh\nre\na\nd\nexecute()\n  \n  \n  \n  \n  \n  \n  \nN\ne\nt\nwo\nr\nk\nF\ne\nt\nc\nh\n \n \n \n \n \n \n \n \n \n \n \nT\nh\nre\na\nd\nexecute()\nCommands give us a way to package a piece of \ncomputation (a receiver and a set of actions) and pass \nit around as a first-class object. Now, the computation \nitself may be invoked long after some client application \ncreates the command object. In fact, it may even be \ninvoked by a different thread. We can take this scenario \nand apply it to many useful applications, such as \nschedulers, thread pools, and job queues, to name a few. Imagine a job queue: you add commands to the \nqueue on one end, and on the other end sits a group \nof threads. Threads run the following script: they \nremove a command from the queue, call its execute() \nmethod, wait for the call to finish, and then discard the \ncommand object and retrieve a new one. How might a web server make \nuse of such a queue? What other \napplications can you think of?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 267", "position": 267, "chunk_type": "semantic", "token_estimate": 372}
{"text": "230\u2003 \u2003 Chapter 6: using the command pattern for logging requests\nThe semantics of some applications require that we log all actions and be able to \nrecover after a crash by reinvoking those actions. The Command Pattern can support \nthese semantics with the addition of two methods: store() and load(). In Java we could \nuse object serialization to implement these methods, but the normal caveats for using \nserialization for persistence apply. How does this work? As we execute commands, we store a history of them on disk. When a crash occurs, we reload the command objects and invoke their execute() \nmethods in batch and in order. Now, this kind of logging wouldn\u2019t make sense for a remote control; however, there \nare many applications that invoke actions on large data structures that can\u2019t be \nquickly saved each time a change is made. By using logging, we can save all the \noperations since the last checkpoint, and if there is a system failure, apply those \noperations to our checkpoint. Take, for example, a  spreadsheet application: we might \nwant to implement our failure recovery by logging the actions on the spreadsheet rather \nthan writing a copy of the spreadsheet to disk every time a change occurs. In more \nadvanced applications, these techniques can be extended to apply to sets of operations \nin a transactional manner so that all of the operations complete, or none of them do. <<interface>>\nCommand\nexecute()\nundo()\nstore()\nload()\nAs each command \nis executed, it is \nstored on disk. More uses of the Command Pattern: logging requests\nC\no\nm\nm\na\nn\nd\nO\nn\ne\nexecute()\nstore()\nload()\n \n \n \nC\no\nm\nm\nan\nd\nT\nw\no\nexecute()\nstore()\nload()\n \nC\no\nm\nm\na\nnd\nT\nh\nr\ne\ne\nexecute()\nstore()\nload()\nstore\nstore\nstore\n1. execute()\n \n \nI\nn\nv\no\nke\nr\n2. execute()\n3. execute()\n \n \nC\no\nm\nm\na\nnd\nO\nn\ne\nexecute()\nstore()\nload()\n \n \n \nC\no\nm\nm\nan\nd\nT\nw\no\nexecute()\nstore()\nload()\n \nC\no\nm\nm\na\nnd\nT\nh\nr\ne\ne\nexecute()\nstore()\nload()\nload\nload\nload\n \n \nI\nn\nv\no\nke\nr\n3. execute()\n2. execute()\n1. execute()\nCrash! Restore\nAfter a system \nfailure, the objects are \nreloaded and executed \nin the correct order. We add two methods \nfor logging.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 268", "position": 268, "chunk_type": "semantic", "token_estimate": 386}
{"text": "you are here 4\u2003 \u2003 231: the command pattern\nCommand Pattern in the Real World\nRemember the little life-changing application from Chapter 2? %java SwingObserverExample\nCome on, do it! Don\u2019t do it, you might regret it! %\nAnd here\u2019s the output when \nwe click on the button. Here\u2019s our fancy interface. Angel answer\nDevil answer\npublic class SwingObserverExample {\n\t\n// Set up ...\n        JButton button = new JButton(\"Should I do it? \");\n        button.addActionListener(new AngelListener());\n        button.addActionListener(new DevilListener());\n        // Set frame properties here\n    }\n    class AngelListener implements ActionListener {\n        public void actionPerformed(ActionEvent event) {\n            System.out.println(\"Don't do it, you might regret it! \");\n        }\n    }\n    class DevilListener implements ActionListener {\n        public void actionPerformed(ActionEvent event) {\n            System.out.println(\"Come on, do it! \");\n        }\n    }\n}\nIn that chapter we saw how Java\u2019s Swing \nlibrary is chock full of Observers in the \nform of ActionListeners that listen in (or \nobserve) events on user interface components. Well, it turns out that ActionListener  is \nnot just an Observer interface, it\u2019s also a \nCommand interface, and our AngelListener \nand DevilListener classes are not just \nObservers, but also concrete Commands. That\u2019s right, we have two patterns in one \nexample! Here\u2019s the code (the important bits anyway) for the little life-changing \napplication from Chapter 2. See if you can identify who is the Client, who are \nthe Commands, who is the Invoker, and who is the Receiver. File  Edit  Window  Help  HeMadeMeDoIt", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 269", "position": 269, "chunk_type": "semantic", "token_estimate": 230}
{"text": "232\u2003 \u2003 Chapter 6: exercise solution\npublic class SwingObserverExample {\n\t\n// Set up ...\n        JButton button = new JButton(\"Should I do it? \");\n        button.addActionListener(new AngelListener());\n        button.addActionListener(new DevilListener());\n        // Set frame properties here\n    }\n    class AngelListener implements ActionListener {\n        public void actionPerformed(ActionEvent event) {\n            System.out.println(\"Don't do it, you might regret it! \");\n        }\n    }\n    class DevilListener implements ActionListener {\n        public void actionPerformed(ActionEvent event) {\n            System.out.println(\"Come on, do it! \");\n        }\n    }\n}\nHere\u2019s the code (the important bits anyway) for the little life-changing \napplication from Chapter 2. See if you can identify who is the Client, who are \nthe Commands, who is the Invoker, and who is the Receiver? Here\u2019s our solution. The Client is the class that sets up the \nSwing components and sets the commands \n(AngelListener and DevilListener) in the \nInvoker (the Button). The button is our Invoker. The button \ncalls the actionPerformed() (like \nexecute()) methods in the commands (the \nActionListeners) when you click the button. ActionListener is the Command \nInterface: it has one method, \nactionPerformed() that, like \nexecute(), is executed when the \ncommand is invoked. AngelListener and DevilListener \nare our concrete Commands. They \nimplement the command interface (in \nthis case, ActionListener). The Receiver in this example is the System object. Remember, invoking a command results in actions on \nthe Receiver. In a typical Swing application this would \nresult in calling actions on other components in the UI.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 270", "position": 270, "chunk_type": "semantic", "token_estimate": 228}
{"text": "you are here 4\u2003 \u2003 233: the command pattern\nTools for your Design Toolbox\nYour toolbox is starting to get heavy! In this chapter \nwe\u2019ve added a pattern that allows us to encapsulate \nmethods into Command objects: store them, pass them \naround, and invoke them when you need them. Abstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies. Favor composition over inheritance. Program to interfaces, not \nimplementations. Strive for loosely coupled designs \nbetween objects that interact. Classes should be open for extension \nbut closed for modification. Depend on abstractions. Do not \ndepend on concrete classes. OO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it. OO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically. Decorators provide a flexible \nalternative to subclassing for extending \nfunctionality. Abstract Factory - Provide \nan interface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes. Factory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate. Factory Method lets \na class defer instantiation to the \nsubclasses. Singleton - Ensure a class only has \none instance and provide a global point \nof access to it. Command - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. When you need to decouple an \nobject making requests from \nthe objects that know how to \nperform the requests, use the \nCommand Pattern. \u0083\nThe Command Pattern \ndecouples an object making \na request from the one that \nknows how to perform it. \u0083\nA Command object is at the \ncenter of this decoupling and \nencapsulates a receiver with \nan action (or set of actions). \u0083\nAn invoker makes a request \nof a Command object by \ncalling its execute() method, \nwhich invokes those actions \non the receiver. \u0083\nInvokers can be \nparameterized with \nCommands, even \ndynamically at runtime. \u0083\nCommands may support \nundo by implementing an \nundo() method that restores \nthe object to its previous \nstate before the execute() \nmethod was last called. \u0083\nMacroCommands are a \nsimple extension of the \nCommand Pattern that \nallow multiple commands \nto be invoked. Likewise, \nMacroCommands can easily \nsupport undo().", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 271", "position": 271, "chunk_type": "semantic", "token_estimate": 399}
{"text": "you are here 4\u2003 \u2003 233: \u0083\nMacroCommands are a \nsimple extension of the \nCommand Pattern that \nallow multiple commands \nto be invoked. Likewise, \nMacroCommands can easily \nsupport undo(). \u0083\nIn practice, it\u2019s not \nuncommon for \u201csmart\u201d \nCommand objects to \nimplement the request \nthemselves rather than \ndelegating to a receiver. \u0083\nCommands may also be \nused to implement logging \nand transactional systems.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 271", "position": 271, "chunk_type": "semantic", "token_estimate": 61}
{"text": "5. Our favorite city.: 6. Company that got us word-of-mouth business. 7. Role of customer in the Command Pattern. 9. Object that knows the actions and the receiver. 12. Invoker and receiver are _________. 15. The Waitress was one. 16. Dr. Seuss diner food (four words). 17. Another thing Command can do.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 272", "position": 272, "chunk_type": "semantic", "token_estimate": 52}
{"text": "1. The Cook and this person were definitely decoupled.: 2. The Waitress didn\u2019t do this. 3. A command encapsulates this. 4. Act as the receivers in the remote control (two words). 8. Object that knows how to get things done. 10. Carries out a request. 11. All commands provide this. 13. Our first command object controlled this. 14. A command __________ a set of actions and a \nreceiver. 1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nAcross\n5. Our favorite city\n6. Company that got us word of mouth business\n7. Role of customer in the command pattern\n9. Object that knows the actions and the receiver\n12. Invoker and receiver are ______________\n15. The Waitress was one\n16. Dr. Seuss diner food\n17. Another thing Command can do\nDown\n1. The cook and this person were definitely \ndecoupled\n2. Waitress didn't do this\n3. A command encapsulates this\n4. Act as the receivers in the remote control (two \nwords)\n8. Object that knows how to get things done\n10. Carries out a request\n11. All commands provide this\n13. Our first command object controlled this\n14. A command ____ a set of actions and a receiver", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 272", "position": 272, "chunk_type": "semantic", "token_estimate": 206}
{"text": "you are here 4\u2003 \u2003 235: the command pattern\nSOlUTion\nMatch the diner objects and methods with the corresponding \nnames from the Command Pattern. Diner\nCommand Pattern\nWaitress\nShort-Order Cook\norderUp()\nOrder\nCustomer\ntakeOrder()\nCommand \nexecute()\nClient\nInvoker\nReceiver\nsetCommand()\nFile  Edit   Window  Help  GreenEggs&Ham\n%java RemoteControlTest\nLight is on\nGarage Door is Open\n%\nHere\u2019s the code for the GarageDoorOpenCommand class. Here\u2019s the output:\npublic class GarageDoorOpenCommand implements Command {\n    GarageDoor garageDoor;\n    public GarageDoorOpenCommand(GarageDoor garageDoor) {\n        this.garageDoor = garageDoor;\n    }\n    public void execute() {\n        garageDoor.up();\n    }\n}", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 273", "position": 273, "chunk_type": "semantic", "token_estimate": 87}
{"text": "236\u2003 \u2003 Chapter 6: exercise solutions\nHere\u2019s the code to create commands for the off button. LightOffCommand lightOff = new LightOffCommand(light);\nStereoOffCommand stereoOff = new StereoOffCommand(stereo);\nTVOffCommand tvOff = new TVOffCommand(tv);\nHottubOffCommand hottubOff = new HottubOffCommand(hottub);\nHere is the undo() \nmethod for the \nMacroCommand. public class MacroCommand implements Command {\n    Command[] commands;\n    public MacroCommand(Command[] commands) {\n        this.commands = commands;\n    }\n    public void execute() {\n        for (int i = 0; i < commands.length; i++) {\n            commands[i].execute();\n        }\n    }\n    public void undo() {\n        for (int i = commands.length - 1; i >= 0; i--) {\n            commands[i].undo();\n        }\n    }\n}", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 274", "position": 274, "chunk_type": "semantic", "token_estimate": 96}
{"text": "this is a new chapter\u2003 \u2003 237: In this chapter we\u2019re going to attempt such impossible feats \nas putting a square peg in a round hole. Sound impossible? Not when \nwe have Design Patterns. Remember the Decorator Pattern? We wrapped objects to \ngive them new responsibilities. Now we\u2019re going to wrap some objects with a different \npurpose: to make their interfaces look like something they\u2019re not. Why would we do that? So we can adapt a design expecting one interface to a class that implements a different \ninterface. That\u2019s not all; while we\u2019re at it, we\u2019re going to look at another pattern that wraps \nobjects to simplify their interface. Being Adaptive \n \n \n \n \n \n \n \n \n \n7  the Adapter and Facade Patterns\nYou mean it\u2019s not \nsupposed to be a \nfootball match? Do you think the \nreaders are really getting the \nimpression we\u2019re watching a \nhorse race rather than sitting \nin a photo studio? That\u2019s the beauty of \nour profession: we can \nmake things look like \nsomething they\u2019re not! Wrapped in this coat, \nI\u2019m a different man!", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 275", "position": 275, "chunk_type": "semantic", "token_estimate": 171}
{"text": "238\u2003 \u2003 Chapter 7: adapters everywhere\nYou know what the adapter does: it sits in between the plug of your laptop and the \nBritish AC outlet; its job is to adapt the British outlet so that you can plug your laptop \ninto it and receive power. Or look at it this way: the adapter changes the interface of the \noutlet into one that your laptop expects. Some AC adapters are simple\u2014they only change the shape of the outlet so that it \nmatches your plug, and they pass the AC current straight through\u2014but other adapters \nare more complex internally and may need to step the power up or down to match your \ndevices\u2019 needs. Okay, that\u2019s the real world; what about object-oriented adapters? Well, our OO adapters \nplay the same role as their real-world counterparts: they take an interface and adapt it \nto one that a client is expecting. Adapters all around us\nYou\u2019ll have no trouble understanding what an OO adapter is \nbecause the real world is full of them. How\u2019s this for an example: \nHave you ever needed to use a US-made laptop in Great Britain? Then you\u2019ve probably needed an AC power adapter...\nBritish Wall Outlet\nUS Standard AC Plug\nAC Power Adapter\nThe British wall outlet exposes \none interface for getting power. The US laptop expects \nanother interface. The adapter converts one \ninterface into another. How many other real-world \nadapters can you think of?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 276", "position": 276, "chunk_type": "semantic", "token_estimate": 236}
{"text": "you are here 4\u2003 \u2003 239: the adapter and facade patterns\nSay you\u2019ve got an existing software system that you need to work a new vendor class library \ninto, but the new vendor designed their interfaces differently than the last vendor:\nObject-oriented adapters\nOkay, you don\u2019t want to solve the problem by changing your existing code (and you can\u2019t \nchange the vendor\u2019s code). So what do you do? Well, you can write a class that adapts the \nnew vendor interface into the one you\u2019re expecting. The adapter acts as the middleman by receiving requests from the client and converting \nthem into requests that make sense on the vendor classes. Adapter\nVendor \nClass\nYour \nExisting \nSystem\nVendor \nClass\nYour \nExisting \nSystem\nTheir interface doesn\u2019t match the one you\u2019ve written \nyour code against. This isn\u2019t going to work! The adapter implements the \ninterface your classes expect...\n...and talks to the vendor interface \nto service your requests. No code changes. No code changes. New code. Can you think of a solution \nthat doesn\u2019t require YOU to \nwrite ANY additional code \nto integrate the new vendor \nclasses? How about making the \nvendor supply the adapter class? Vendor \nClass\nAdapter\nYour \nExisting \nSystem", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 277", "position": 277, "chunk_type": "semantic", "token_estimate": 197}
{"text": "240\u2003 \u2003 Chapter 7: turkey adapter\npublic interface Turkey {\n    public void gobble();\n    public void fly();\n}\npublic class MallardDuck implements Duck {\n    public void quack() {\n        System.out.println(\"Quack\");\n    }\n \n    public void fly() {\n        System.out.println(\"I'm flying\");\n    }\n}\npublic interface Duck {\n    public void quack();\n    public void fly();\n}\nIf it walks like a duck and quacks like a duck, \nthen it must might be a duck turkey wrapped \nwith a duck adapter...\nIt\u2019s time to see an adapter in action. Remember our ducks from Chapter 1? Let\u2019s review a slightly simplified version of the Duck interfaces and classes:\nThis time around, our \nducks implement a Duck \ninterface that allows \nDucks to quack and fly. Here\u2019s a subclass of Duck, the MallardDuck:\nSimple implementations: MallardDuck \njust prints out what it is doing. Now it\u2019s time to meet the newest fowl on the block:\nTurkeys don\u2019t quack, they gobble. Turkeys can fly, although they \ncan only fly short distances.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 278", "position": 278, "chunk_type": "semantic", "token_estimate": 156}
{"text": "you are here 4\u2003 \u2003 241: the adapter and facade patterns\npublic class WildTurkey implements Turkey {\n    public void gobble() {\n        System.out.println(\"Gobble gobble\");\n    }\n \n    public void fly() {\n        System.out.println(\"I'm flying a short distance\");\n    }\n}\npublic class TurkeyAdapter implements Duck {\n    Turkey turkey;\n \n    public TurkeyAdapter(Turkey turkey) {\n        this.turkey = turkey;\n    }\n    \n    public void quack() {\n        turkey.gobble();\n    }\n  \n    public void fly() {\n        for(int i=0; i < 5; i++) {\n            turkey.fly();\n        }\n    }\n}\nHere\u2019s a concrete implementation \nof Turkey; like MallardDuck, it \njust prints out its actions. Now, let\u2019s say you\u2019re short on Duck objects and you\u2019d like to use some Turkey objects in their \nplace. Obviously we can\u2019t use the turkeys outright because they have a different interface. So, let\u2019s write an Adapter:\nCode Up Close\nFirst, you need to implement the interface \nof the type you\u2019re adapting to. This is the \ninterface your client expects to see. Next, we need to get a reference to the \nobject that we are adapting; here we do \nthat through the constructor. Now we need to implement all the methods in \nthe interface; the quack() translation between \nclasses is easy: just call the gobble() method. Even though both interfaces have a fly() \nmethod, Turkeys fly in short spurts\u2014\nthey can\u2019t do long-distance flying like \nducks. T\no map between a Duck\u2019s fly() \nmethod and a Turkey\u2019s, we need to call \nthe Turkey\u2019s fly() method five times to \nmake up for it.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 279", "position": 279, "chunk_type": "semantic", "token_estimate": 237}
{"text": "242\u2003 \u2003 Chapter 7: test the adapter\npublic class DuckTestDrive {\n    public static void main(String[] args) {\n        Duck duck = new MallardDuck();\n \n        Turkey turkey = new WildTurkey();\n        Duck turkeyAdapter = new TurkeyAdapter(turkey);\n   \n        System.out.println(\"The Turkey says...\");\n        turkey.gobble();\n        turkey.fly();\n \n        System.out.println(\"\\nThe Duck says...\");\n        testDuck(duck);\n  \n        System.out.println(\"\\nThe TurkeyAdapter says...\");\n        testDuck(turkeyAdapter);\n    }\n \n    static void testDuck(Duck duck) {\n        duck.quack();\n        duck.fly();\n    }\n}\nTest drive the adapter\nFile  Edit   Window  Help  Don\u2019tForgetToDuck\n%java DuckTestDrive\nThe Turkey says...\nGobble gobble\nI'm flying a short distance\nThe Duck says...\nQuack\nI'm flying\nThe TurkeyAdapter says...\nGobble gobble\nI'm flying a short distance\nI'm flying a short distance\nI'm flying a short distance\nI'm flying a short distance\nI'm flying a short distance\nLet\u2019s create a Duck...\nNow we just need some code to test drive our adapter:\n...and a Turkey. And then wrap the turkey \nin a TurkeyAdapter, which \nmakes it look like a Duck. Now let\u2019s test the duck \nby calling the testDuck() \nmethod, which expects a \nDuck object. Then, let\u2019s test the Turkey: \nmake it gobble, make it fly. Now the big test: we try to pass \noff the turkey as a duck... The Duck quacks and flies \njust like you\u2019d expect. The Turkey gobbles and \nflies a short distance. And the adapter gobbles when \nquack() is called and flies a few times \nwhen fly() is called. The testDuck() \nmethod never knows it has a turkey \ndisguised as a duck! Here\u2019s our testDuck() method; it \ngets a duck and calls its quack() \nand fly() methods. T\nest run", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 280", "position": 280, "chunk_type": "semantic", "token_estimate": 249}
{"text": "you are here 4\u2003 \u2003 243: the adapter and facade patterns\nAdaptee\nClient\nAdapter\nrequest()\ntranslatedRequest()\nThe Adapter Pattern explained\nThe Client is implemented \nagainst the target interface. The Adapter implements the \ntarget interface and holds an \ninstance of the Adaptee. target interface\nadaptee \ninterface\nNow that we have an idea of what an Adapter is, let\u2019s step back and look \nat all the pieces again. The client makes a request to the adapter by \ncalling a method on it using the target interface. The adapter translates the request into one or \nmore calls on the adaptee using the adaptee \ninterface. The client receives the results of the call and never \nknows there is an adapter doing the translation. Here\u2019s how the Client uses the Adapter\n1\n2\n3\nNote that the Client and Adaptee \nare decoupled\u2014neither knows about \nthe other. TurkeyAdapter implemented \nthe target interface, Duck. Turkey was the \nadaptee interface.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 281", "position": 281, "chunk_type": "semantic", "token_estimate": 151}
{"text": "244\u2003 \u2003 Chapter 7: adapter pattern defined\nLet\u2019s say we also need an Adapter that converts a Duck to a \nTurkey. Let\u2019s call it DuckAdapter. Write that class:\nHow did you handle the fly() method (after all, we know ducks fly longer than turkeys)? Check the answers at the end of the chapter for our solution. Did you think of a better way? Q: How much \u201cadapting\u201d does an \nadapter need to do? It seems like if I need \nto implement a large target interface, I \ncould have a LOT of work on my hands. A: You certainly could. The job of \nimplementing an adapter really is \nproportional to the size of the interface you \nneed to support as your target interface. Think about your options, however. You \ncould rework all your client-side calls to \nthe interface, which would result in a lot \nof investigative work and code changes. Or, you can cleanly provide one class that \nencapsulates all the changes in that class. Q: Does an adapter always wrap one \nand only one class? A: The Adapter Pattern\u2019s role is to convert \none interface into another. While most \nexamples of the Adapter Pattern show an \nadapter wrapping one adaptee, we both \nknow the world is often a bit more messy. So, you may well have situations where an \nadapter holds two or more adaptees that are \nneeded to implement the target interface. This relates to another pattern called the \nFacade Pattern; people often confuse the \ntwo. Remind us to revisit this point when we \ntalk about facades later in this chapter. Q: What if I have old and new parts \nof my system, and the old parts expect \nthe old vendor interface, but we\u2019ve \nalready written the new parts to use the \nnew vendor interface? It's going to get \nconfusing using an adapter here and the \nunwrapped interface there. Wouldn\u2019t I be \nbetter off just writing my older code and \nforgetting the adapter? A: Not necessarily. One thing you can do \nis create a Two Way Adapter that supports \nboth interfaces. To create a Two Way \nAdapter, just implement both interfaces \ninvolved, so the adapter can act as an old \ninterface or a new interface.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 282", "position": 282, "chunk_type": "semantic", "token_estimate": 365}
{"text": "you are here 4\u2003 \u2003 245: the adapter and facade patterns\nAdapter Pattern defined\nThe Adapter Pattern converts the interface of a class \ninto another interface the clients expect. Adapter lets \nclasses work together that couldn\u2019t otherwise because of \nincompatible interfaces. Enough ducks, turkeys, and AC power adapters; let\u2019s get real and look at the official \ndefinition of the Adapter Pattern:\nNow, we know this pattern allows us to use a client with an incompatible interface by \ncreating an Adapter that does the conversion. This acts to decouple the client from \nthe implemented interface, and if we expect the interface to change over time, the \nadapter encapsulates that change so that the client doesn\u2019t have to be modified each \ntime it needs to operate against a different interface. We\u2019ve taken a look at the runtime behavior of the pattern; let\u2019s take a look at its class \ndiagram as well:\nspecificRequest()\nClient\nAdaptee\nrequest()\n<<interface>>\nTarget\nrequest()\nAdapter\nThe Adapter Pattern is full of good object-oriented design principles: check out the use of \nobject composition to wrap the adaptee with an altered interface. This approach has the \nadded advantage that we can use an adapter with any subclass of the adaptee. Also check out how the pattern binds the client to an interface, not an implementation; we \ncould use several adapters, each converting a different backend set of classes. Or, we could \nadd new implementations after the fact, as long as they adhere to the Target interface. The Adapter implements \nthe T\narget interface. Adapter is composed \nwith the Adaptee. All requests get \ndelegated to the \nAdaptee. The client sees only the \nT\narget interface.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 283", "position": 283, "chunk_type": "semantic", "token_estimate": 273}
{"text": "246\u2003 \u2003 Chapter 7: object and class adapters\nObject and class adapters\nNow despite having defined the pattern, we haven\u2019t told you the whole story yet. There are actually two kinds of adapters: object adapters and class adapters. This \nchapter has covered object adapters, and the class diagram on the previous page is \na diagram of an object adapter. So what\u2019s a class adapter and why haven\u2019t we told you about it? Because you need \nmultiple inheritance to implement it, which isn\u2019t possible in Java. But that doesn\u2019t \nmean you might not encounter a need for class adapters down the road when using \nyour favorite multiple inheritance language! Let\u2019s look at the class diagram for \nmultiple inheritance. specificRequest()\nrequest()\nAdapter\nClient\nAdaptee\nrequest()\nTarget\nInstead of using composition \nto adapt the Adaptee, the \nAdapter now subclasses the \nAdaptee and the T\narget classes. Look familiar? That\u2019s right\u2014the only difference is that with a class adapter \nwe subclass the Target and the Adaptee, while with an object adapter we use \ncomposition to pass requests to an Adaptee. Object adapters and class adapters use two different \nmeans of adapting the adaptee (composition \nversus inheritance). How do these implementation \ndifferences affect the flexibility of the adapter?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 284", "position": 284, "chunk_type": "semantic", "token_estimate": 202}
{"text": "you are here 4\u2003 \u2003 247: the adapter and facade patterns\nYour job is to take the duck and turkey magnets and drag \nthem over the part of the diagram that describes the role \nplayed by that bird, in our earlier example. (Try not to flip \nback through the pages.) Then add your own annotations \nto describe how it works. Duck Magnets\nspecificRequest()\nClient\nAdaptee\nrequest()\n<<interface>>\nTarget\nrequest()\nAdapter\nspecificRequest()\nrequest()\nAdapter\nClient\nAdaptee\nrequest()\nTarget\nClass Adapter\nObject Adapter\nDrag these onto the class diagram \nto show which part of the diagram \nrepresents the Duck class and which \nrepresents the Turkey class.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 285", "position": 285, "chunk_type": "semantic", "token_estimate": 103}
{"text": "248\u2003 \u2003 Chapter 7: exercise answer\nDuck Magnets \nAnswer\nspecificRequest()\nrequest()\nAdapter\nClient\nAdaptee\nrequest()\nTarget\nspecificRequest()\nClient\nAdaptee\nrequest()\n<<interface>>\nTarget\nrequest()\nAdapter\nClass Adapter\nObject Adapter\nClient thinks he\u2019s \ntalking to a Duck. The T\narget is the \nDuck class. This \nis what the client \ninvokes methods on. The Adapter lets the Turkey respond to \nrequests on a Duck, by extending BOTH \nclasses (Duck and Turkey). The Turkey class does not \nhave the same methods as \nDuck, but the Adapter can \ntake Duck method calls \nand turn around and invoke \nmethods on the Turkey class. Note: the class adapter uses \nmultiple inheritance, so you \ncan\u2019t do it in Java... Client thinks he\u2019s \ntalking to a Duck. Just as with the Class \nAdapter, the T\narget is the \nDuck class. This is what the \nclient invokes methods on. The Turkey class doesn\u2019t have the same \ninterface as the Duck. In other words, \nTurkeys don\u2019t have quack() methods, etc. The Adapter implements the Duck \ninterface, but when it gets a \nmethod call it turns around and \ndelegates the calls to Turkey. Thanks to the Adapter, the Turkey \n(Adaptee) will get calls that the \nclient makes on the Duck interface. Duck interface\nTurkey \nobject\nDuck class\nTurkey class", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 286", "position": 286, "chunk_type": "semantic", "token_estimate": 206}
{"text": "you are here 4\u2003 \u2003 249: the adapter and facade patterns\nTonight\u2019s talk: Object Adapter and Class \nAdapter meet face to face. Object Adapter:\nBecause I use composition I\u2019ve got a leg up. I can \nadapt not only an adaptee class, but any of its \nsubclasses. In my part of the world, we like to use composition \nover inheritance; you may be saving a few lines \nof code, but all I\u2019m doing is writing a little code \nto delegate to the adaptee. We like to keep things \nflexible. You\u2019re worried about one little object? You might be \nable to quickly override a method, but any behavior \nI add to my adapter code works with my adaptee \nclass and all its subclasses. Hey, come on, cut me some slack, I just need to \ncompose with the subclass to make that work. You wanna see messy? Look in the mirror! Class Adapter:\n\n\n\nThat\u2019s true, I do have trouble with that because I \nam committed to one specific adaptee class, but \nI have a huge advantage because I don\u2019t have to \nreimplement my entire adaptee. I can also override \nthe behavior of my adaptee if I need to because I\u2019m \njust subclassing. Flexible maybe, but efficient? No. There is just one \nof me, not an adapter and an adaptee. Yeah, but what if a subclass of Adaptee adds some \nnew behavior\u2014then what? Sounds messy...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 287", "position": 287, "chunk_type": "semantic", "token_estimate": 230}
{"text": "250\u2003 \u2003 Chapter 7: real world adapters\nReal-world adapters\nIf you\u2019ve been around Java for a while, you \nprobably remember that the early collection \ntypes (Vector, Stack, Hashtable, and a few \nothers) implement a method, elements(), which \nreturns an Enumeration. The Enumeration \ninterface allows you to step through the \nelements of a collection without knowing \nthe specifics of how they are managed in the \ncollection. <<interface>>\nEnumeration\nhasMoreElements()\nnextElement()\nT\nells you if there are any more \nelements in the collection. Gives you the next element \nin the collection. The more recent Collection classes use an \nIterator interface that, like the Enumeration \ninterface, allows you to iterate through a set of \nitems in a collection, and adds the ability to \nremove items. <<interface>\nIterator\nAnalogous to hasMoreElements() \nin the Enumeration interface. This method just tells you if \nyou\u2019ve looked at all the items in \nthe collection. Gives you the next \nelement in the collection. Removes an item from \nthe collection. We are sometimes faced with legacy code that exposes the \nEnumeration interface, yet we\u2019d like for our new code to use only \nIterators. It looks like we need to build an adapter. Enumerators\nIterators\nUsing Enumerators with code that expects Iterators\nLet\u2019s take a look at the use of a simple Adapter in the real world \n(something more serious than Ducks at least)...\nEnumeration has a simple interface. hasNext()\nnext()\nremove()", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 288", "position": 288, "chunk_type": "semantic", "token_estimate": 230}
{"text": "you are here 4\u2003 \u2003 251: the adapter and facade patterns\nAdapting an Enumeration to an Iterator\n<<interface>>\nEnumeration\nhasMoreElements()\nnextElement()\n<<interface>>\nIterator\nhasNext()\nnext()\nremove()\nThese two methods look easy. They map straight to hasNext() \nand next() in Iterator. But what about this method \nremove() in Iterator? There\u2019s \nnothing like that in Enumeration. Here\u2019s what the classes should look like: we need an adapter that implements the Target \ninterface and is composed with an adaptee. The hasNext() and next() methods are going \nto be straightforward to map from target to adaptee: we just pass them right through. But what do you do about remove()? Think about it for a moment (and we\u2019ll deal with it \non the next page). For now, here\u2019s the class diagram:\n<<interface>>\nEnumeration\nhasMoreElements()\nnextElement()\n<<interface>>\nIterator\nhasNext()\nnext()\nremove()\nYour new code still gets \nto use Iterators, even \nif there\u2019s really an \nEnumeration underneath. EnumerationIterator\nhasNext()\nnext()\nremove()\nEnumerationIterator \nis the adapter. A class \nimplementing \nthe Enumeration \ninterface is the \nadaptee. We\u2019re making the Enumerations \nin your old code look like \nIterators for your new code. T\narget interface\nAdaptee interface\nDesigning the Adapter\nFirst we\u2019ll look at the two interfaces to figure out how the methods map from one to \nthe other. In other words, we\u2019ll figure out what to call on the adaptee when the client \ninvokes a method on the target.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 289", "position": 289, "chunk_type": "semantic", "token_estimate": 229}
{"text": "252\u2003 \u2003 Chapter 7: enumeration iterator adapter\npublic class EnumerationIterator implements Iterator<Object> {\n    Enumeration<?> enumeration;\n \n    public EnumerationIterator(Enumeration<?> enumeration) {\n        this.enumeration = enumeration;\n    }\n \n    public boolean hasNext() {\n        return enumeration.hasMoreElements();\n    }\n \n    public Object next() {\n        return enumeration.nextElement();\n    }\n \n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n}\nSince we\u2019re adapting \nEnumeration to Iterator, \nour Adapter implements the \nIterator interface...it has to \nlook like an Iterator. The Enumeration we\u2019re \nadapting. We\u2019re using \ncomposition, so we stash it \nin an instance variable. The Iterator\u2019s hasNext() method \nis delegated to the Enumeration\u2019s \nhasMoreElements() method...\n...and the Iterator\u2019s next() method \nis delegated to the Enumeration\u2019s \nnextElement() method. Unfortunately, we can\u2019t support \nIterator\u2019s remove() method, so \nwe have to punt (in other words, \nwe give up!). Here we just throw \nan exception. Well, we know Enumeration doesn\u2019t support remove(). It\u2019s a \u201cread only\u201d interface. There\u2019s no \nway to implement a fully functioning remove() method on the adapter. The best we can do is \nthrow a runtime exception. Luckily, the designers of the Iterator interface foresaw this need and \ndefined the remove() method so that it supports an UnsupportedOperationException. This is a case where the adapter isn\u2019t perfect; clients will have to watch out for potential \nexceptions, but as long as the client is careful and the adapter is well documented, this is a \nperfectly reasonable solution. Dealing with the remove() method\nWriting the EnumerationIterator adapter\nHere\u2019s simple but effective code for all those legacy classes still producing Enumerations:", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 290", "position": 290, "chunk_type": "semantic", "token_estimate": 241}
{"text": "you are here 4\u2003 \u2003 253: the adapter and facade patterns\nWhile Java has gone in the direction of the Iterator interface, there is nevertheless still legacy \nclient code that depends on the Enumeration interface, so an Adapter that converts an Iterator to \nan Enumeration could potentially be useful. Write an Adapter that adapts an Iterator to an Enumeration. You can test your code by \nadapting an ArrayList. The ArrayList class supports the Iterator interface but doesn\u2019t support \nEnumerations. Some AC adapters do more than just change the interface\u2014they add other features \nlike surge protection, indicator lights, and other bells and whistles. If you were going to implement these kinds of features, what pattern would you use?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 291", "position": 291, "chunk_type": "semantic", "token_estimate": 116}
{"text": "254\u2003 \u2003 Chapter 7: fireside chats: decorator and adapter\nTonight\u2019s talk: The Decorator Pattern and the Adapter \nPattern discuss their differences. Decorator:\nI\u2019m important. My job is all about responsibility\u2014you \nknow that when a Decorator is involved, there\u2019s \ngoing to be some new responsibilities or behaviors \nadded to your design. That may be true, but don\u2019t think we don\u2019t work \nhard. When we have to decorate a big interface, \nwhoa, that can take a lot of code. Cute. Don\u2019t think we get all the glory; sometimes \nI\u2019m just one decorator that is being wrapped by who \nknows how many other decorators. When a method \ncall gets delegated to you, you have no idea how \nmany other decorators have already dealt with it \nand you don\u2019t know that you\u2019ll ever get noticed for \nyour efforts servicing the request. Adapter:\n\n\n\n\nYou decorators want all the glory while us adapters \nare down in the trenches doing the dirty work: \nconverting interfaces. Our jobs may not be \nglamorous, but our clients sure do appreciate us \nmaking their lives simpler. Try being an adapter when you\u2019ve got to bring \nseveral classes together to provide the interface your \nclient is expecting. Now that\u2019s tough. But we have a \nsaying: \u201cA decoupled client is a happy client.\u201d\nHey, if adapters are doing their job, our clients \nnever even know we\u2019re there. It can be a thankless \njob.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 292", "position": 292, "chunk_type": "semantic", "token_estimate": 229}
{"text": "you are here 4\u2003 \u2003 255: the adapter and facade patterns\nDecorator:\nWell, us decorators do that as well, only we allow \nnew behavior to be added to classes without altering \nexisting code. I still say that adapters are just fancy \ndecorators\u2014I mean, just like us, you wrap an object. Uh, no. Our job in life is to extend the behaviors or \nresponsibilities of the objects we wrap; we aren\u2019t a \nsimple pass through. Maybe we should agree to disagree. We seem to \nlook somewhat similar on paper, but clearly we are \nmiles apart in our intent. Adapter:\nBut the great thing about us adapters is that we \nallow clients to make use of new libraries and \nsubsets without changing any code; they just rely on \nus to do the conversion for them. Hey, it\u2019s a niche, \nbut we\u2019re good at it. No, no, no, not at all. We always convert the \ninterface of what we wrap; you never do. I\u2019d say a \ndecorator is like an adapter; it's just that you don\u2019t \nchange the interface! Hey, who are you calling a simple pass through? Come on down and we\u2019ll see how long you last \nconverting a few interfaces! Oh yeah, I\u2019m with you there.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 293", "position": 293, "chunk_type": "semantic", "token_estimate": 204}
{"text": "256\u2003 \u2003 Chapter 7: who does what? And now for something different...\nThere\u2019s another pattern in this chapter. You\u2019ve seen how the Adapter Pattern converts the interface of a class into one \nthat a client is expecting. You also know we achieve this in Java by wrapping \nthe object that has an incompatible interface with an object that implements \nthe correct one. We\u2019re going to look at a pattern now that alters an interface, but for a different \nreason: to simplify the interface. It\u2019s aptly named the Facade Pattern because \nthis pattern hides all the complexity of one or more classes behind a clean, \nwell-lit facade. Match each pattern with its intent:\nPattern\nIntent\nDecorator\nAdapter\nFacade\nConverts one interface to \nanother\nDoesn\u2019t alter the interface, \nbut adds responsibility\nMakes an interface simpler", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 294", "position": 294, "chunk_type": "semantic", "token_estimate": 132}
{"text": "you are here 4\u2003 \u2003 257: the adapter and facade patterns\nAmplifier\ntuner\nplayer\non()\noff()\nsetStreamingPlayer()\nsetStereoSound()\nsetSurroundSoud()\nsetTuner()\nsetVolume()\ntoString()\nStreamingPlayer\namplifier\non()\noff()\npause()\nplay()\nsetSurroundAudio()\nsetTwoChannelAudio()\nstop()\ntoString()\nTuner\non()\noff()\nsetAm()\nsetFm()\nsetFrequency()\ntoString()\namplifier\nScreen\nup()\ndown()\ntoString()\nProjector\non()\noff()\ntvMode()\nwideScreenMode()\ntoString()\nplayer\nPopcornPopper\non()\noff()\npop()\ntoString()\nTheaterLights\non()\noff()\ndim()\ntoString()\nBefore we dive into the details of the Facade Pattern, let\u2019s take a look at a \ngrowing national obsession: building a nice theater to binge-watch all those \nmovies and TV series. You\u2019ve done your research and you\u2019ve assembled a killer system complete \nwith a streaming player, a projection video system, an automated screen, \nsurround sound, and even a popcorn popper. Check out all the components you\u2019ve put together:\nHome Sweet Home Theater\nYou\u2019ve spent weeks running wire, mounting the projector, making all the \nconnections, and fine tuning. Now it\u2019s time to put it all in motion and enjoy a \nmovie...\nThat\u2019s a lot of \nclasses, a lot \nof interactions, \nand a big set \nof interfaces to \nlearn and use.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 295", "position": 295, "chunk_type": "semantic", "token_estimate": 179}
{"text": "you are here 4\u2003 \u2003 259: the adapter and facade patterns\npopper.on();\npopper.pop();\nlights.dim(10);\nscreen.down();\nprojector.on();\nprojector.setInput(player);\nprojector.wideScreenMode();\namp.on();\namp.setStreamingPlayer(player);\namp.setSurroundSound();\namp.setVolume(5);\nplayer.on();\nplayer.play(movie);\nTurn on the popcorn popper and start \npopping...\n\nDim the lights to 10%... Put the screen down... Turn on the projector and put it in \nwidescreen mode for the movie... Turn on the amp, set it to Streaming \nplayer, put it in surround-sound mode, \nand set the volume to 5... Turn on the Streaming player... \nand FINALLY, play the movie! Let\u2019s check out those same tasks in terms of the classes and the \nmethod calls needed to perform them:\nSix different classes \ninvolved! But there\u2019s more...\n\t\n\u0083\nWhen the movie is over, how do you turn everything off? Wouldn\u2019t you have to do all \nof this over again, in reverse? \u0083\nWouldn\u2019t it be as complex to listen to the radio? \u0083\nIf you decide to upgrade your system, you\u2019re probably going to have to learn a slightly \ndifferent procedure. So what to do? The complexity of using your home theater is becoming apparent! Let\u2019s see how the Facade Pattern can get us out of this mess so we can enjoy the movie...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 297", "position": 297, "chunk_type": "semantic", "token_estimate": 196}
{"text": "260\u2003 \u2003 Chapter 7: lights, camera, facade\nA Facade is just what you need: with the Facade Pattern you can take a complex \nsubsystem and make it easier to use by implementing a Facade class that provides \none, more reasonable interface. Don\u2019t worry; if you need the power of the complex \nsubsystem, it\u2019s still there for you to use, but if all you need is a straightforward \ninterface, the Facade is there for you. Let\u2019s take a look at how the Facade operates:\nLights, Camera, Facade! watchMovie()\nendMovie()\nlistenToRadio()\nendRadio()\nHomeTheaterFacade\nTheaterLights\non()\noff()\ndim()\ntoString()\nPopcornPopper\non()\noff()\npop()\ntoString()\nScreen\nup()\ndown()\ntoString()\nTuner\non()\noff()\nsetAm()\nsetFm()\nsetFrequency()\ntoString()\namplifier\nAmplifier\ntuner\nplayer\non()\noff()\nsetStreamingPlayer()\nsetStereoSound()\nsetSurroundSoud()\nsetTuner()\nsetVolume()\ntoString()\nProjector\non()\noff()\ntvMode()\nwideScreenMode()\ntoString()\nplayer\nStreamingPlayer\namplifier\non()\noff()\npause()\nplay()\nsetSurroundAudio()\nsetTwoChannelAudio()\nstop()\ntoString()\nOkay, time to create a \nFacade for the home \ntheater system. To do this \nwe create a new class \nHomeTheaterFacade, \nwhich exposes a few \nsimple methods such as \nwatchMovie(). 1\nThe Facade\nThe subsystem the \nFacade is simplifying. on()\nplay()\nThe Facade class treats \nthe home theater \ncomponents as a \nsubsystem, and calls \non the subsystem \nto implement its \nwatchMovie() method. 2", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 298", "position": 298, "chunk_type": "semantic", "token_estimate": 202}
{"text": "you are here 4\u2003 \u2003 261: the adapter and facade patterns\nwatchMovie()\nYour client code now calls \nmethods on the home theater \nFacade, not on the subsystem. So now to watch a movie we just \ncall one method, watchMovie(), \nand it communicates with \nthe lights, streaming player, \nprojector, amplifier, screen, and \npopcorn maker for us. 3\nA client of the \nsubsystem facade. Former president of the \nRushmore High School \nA/V Science Club. The Facade still leaves the subsystem \naccessible so it can be used directly. If \nyou need the advanced functionality \nof the subsystem classes, they are \navailable for your use. 4\nI\u2019ve got to have \nmy low-level access!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 299", "position": 299, "chunk_type": "semantic", "token_estimate": 108}
{"text": "262\u2003 \u2003 Chapter 7: facade versus adapter\nA facade not \nonly simplifies \nan interface, it \ndecouples a client \nfrom a subsystem \nof components. Facades and \nadapters may \nwrap multiple \nclasses, but a \nfacade\u2019s intent is \nto simplify, while \nan adapter\u2019s \nis to convert \nthe interface \nto something \ndifferent. Q: If the facade encapsulates the \nsubsystem classes, how does a client \nthat needs lower-level functionality gain \naccess to them? A: Facades don\u2019t \u201cencapsulate\u201d the \nsubsystem classes; they merely provide a \nsimplified interface to their functionality. The \nsubsystem classes still remain available \nfor direct use by clients that need to use \nmore specific interfaces. This is a nice \nproperty of the Facade Pattern: it provides \na simplified interface while still exposing the \nfull functionality of the system to those who \nmay need it. Q: Does the facade add any \nfunctionality or does it just pass through \neach request to the subsystem? A: A facade is free to add its own \u201csmarts\u201d \nin addition to making use of the subsystem. For instance, while our home theater facade \ndoesn\u2019t implement any new behavior, it is \nsmart enough to know that the popcorn \npopper has to be turned on before it can pop \n(as well as the details of how to turn on and \nstage a movie showing). Q: Does each subsystem have only \none facade? A: Not necessarily. The pattern certainly \nallows for any number of facades to be \ncreated for a given subsystem. Q: What is the benefit of the facade \nother than the fact that I now have a \nsimpler interface? A: The Facade Pattern also allows you \nto decouple your client implementation \nfrom any one subsystem. Let\u2019s say that you \nget a big raise and decide to upgrade your \nhome theater to all new components that \nhave different interfaces. Well, if you coded \nyour client to the facade rather than the \nsubsystem, your client code doesn\u2019t need to \nchange, just the facade (and hopefully the \nmanufacturer is supplying that!). Q: So the way to tell the difference \nbetween the Adapter Pattern and the \nFacade Pattern is that the adapter wraps \none class and the facade may represent \nmany classes? A: No! Remember, the Adapter Pattern \nchanges the interface of one or more classes \ninto one interface that a client is expecting.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 300", "position": 300, "chunk_type": "semantic", "token_estimate": 379}
{"text": "262\u2003 \u2003 Chapter 7: A: No! Remember, the Adapter Pattern \nchanges the interface of one or more classes \ninto one interface that a client is expecting. While most textbook examples show the \nadapter adapting one class, you may need to \nadapt many classes to provide the interface \na client is coded to. Likewise, a Facade may \nprovide a simplified interface to a single \nclass with a very complex interface. The difference between the two is not in \nterms of how many classes they \u201cwrap,\u201d it \nis in their intent. The intent of the Adapter \nPattern is to alter an interface so that it \nmatches one a client is expecting. The \nintent of the Facade Pattern is to provide a \nsimplified interface to a subsystem.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 300", "position": 300, "chunk_type": "semantic", "token_estimate": 123}
{"text": "you are here 4\u2003 \u2003 263: the adapter and facade patterns\npublic class HomeTheaterFacade {\n    Amplifier amp;\n    Tuner tuner;\n    StreamingPlayer player;\n    Projector projector;\n    TheaterLights lights;\n    Screen screen;\n    PopcornPopper popper;\n \n    public HomeTheaterFacade(Amplifier amp, \n                 Tuner tuner, \n                 StreamingPlayer player; \n                 Projector projector, \n                 Screen screen,\n                 TheaterLights lights,\n                 PopcornPopper popper) {\n \n        this.amp = amp;\n        this.tuner = tuner;\n        this.player = player;\n        this.projector = projector;\n        this.screen = screen;\n        this.lights = lights;\n        this.popper = popper;\n    }\n \n        // other methods here\n \n}\nConstructing your home theater facade\nLet\u2019s step through the construction of the HomeTheaterFacade class. The first step is to use composition so that the facade has access to all the \ncomponents of the subsystem:\nThe facade is passed a \nreference to each component \nof the subsystem in its \nconstructor. The facade \nthen assigns each to the \ncorresponding instance variable. Here\u2019s the composition; these \nare all the components of the \nsubsystem we are going to use. We\u2019re just about to fill these in...", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 301", "position": 301, "chunk_type": "semantic", "token_estimate": 153}
{"text": "264\u2003 \u2003 Chapter 7: implementing facade\npublic void watchMovie(String movie) {\n    System.out.println(\"Get ready to watch a movie...\");\n    popper.on();\n    popper.pop();\n    lights.dim(10);\n    screen.down();\n    projector.on();\n    projector.wideScreenMode();\n    amp.on();\n    amp.setStreamingPlayer(player);\n    amp.setSurroundSound();\n    amp.setVolume(5);\n    player.on();\n    player.play(movie);\n}\n \npublic void endMovie() {\n    System.out.println(\"Shutting movie theater down...\");\n    popper.off();\n    lights.on();\n    screen.up();\n    projector.off();\n    amp.off();\n    player.stop();\n    player.off();\n}\nImplementing the simplified interface\nNow it\u2019s time to bring the components of the subsystem together into a unified interface. Let\u2019s implement the watchMovie() and endMovie() methods:\nwatchMovie() follows the same sequence \nwe had to do by hand before, but wraps \nit up in a handy method that does all \nthe work. Notice that for each task we \nare delegating the responsibility to the \ncorresponding component in the subsystem. And endMovie() takes care of \nshutting everything down for \nus. Again, each task is delegated \nto the appropriate component in \nthe subsystem. Think about the facades you\u2019ve encountered in the Java \nAPI. Where would you like to have a few new ones?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 302", "position": 302, "chunk_type": "semantic", "token_estimate": 155}
{"text": "you are here 4\u2003 \u2003 265: the adapter and facade patterns\nHere\u2019s the output. Calling the Facade\u2019s \nwatchMovie() does all \nthis work for us...\n...and here, we\u2019re done \nwatching the movie, so \ncalling endMovie() turns \neverything off. public class HomeTheaterTestDrive {\n    public static void main(String[] args) {\n        // instantiate components here\n \n        HomeTheaterFacade homeTheater = \n                new HomeTheaterFacade(amp, tuner, player, \n                        projector, screen, lights, popper);\n \n        homeTheater.watchMovie(\"Raiders of the Lost Ark\");\n        homeTheater.endMovie();\n    }\n}\nIt\u2019s showtime! Time to watch a movie (the easy way)\n%java HomeTheaterTestDrive\nGet ready to watch a movie... Popcorn Popper on\nPopcorn Popper popping popcorn! Theater Ceiling Lights dimming to 10%\nTheater Screen going down\nProjector on\nProjector in widescreen mode (16x9 aspect ratio)\nAmplifier on\nAmplifier setting Streaming player to Streaming Player\nAmplifier surround sound on (5 speakers, 1 subwoofer)\nAmplifier setting volume to 5\nStreaming Player on\nStreaming Player playing \"Raiders of the Lost Ark\"\nShutting movie theater down... Popcorn Popper off\nTheater Ceiling Lights on\nTheater Screen going up\nProjector off\nAmplifier off\nStreaming Player stopped \"Raiders of the Lost Ark\"\nStreaming Player off\n%\nFile  Edit   Window  Help  SnakesWhy\u2019dItHaveToBeSnakes? First you instantiate \nthe Facade with all the \ncomponents in the subsystem. Use the simplified interface to \nfirst start the movie up, and \nthen shut it down. Here we\u2019re creating the components \nright in the test drive. Normally the \nclient is given a facade; it doesn\u2019t have \nto construct one itself.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 303", "position": 303, "chunk_type": "semantic", "token_estimate": 233}
{"text": "266\u2003 \u2003 Chapter 7: facade pattern defined\nFacade Pattern defined\nThe Facade Pattern provides a unified interface to a \nset of interfaces in a subsystem. Facade defines a higher-\nlevel interface that makes the subsystem easier to use. To use the Facade Pattern, we create a class that simplifies and unifies a set of more complex \nclasses that belong to some subsystem. Unlike a lot of patterns, Facade is fairly straightforward; \nthere are no mind-bending abstractions to get your head around. But that doesn\u2019t make it \nany less powerful: the Facade Pattern allows us to avoid tight coupling between clients and \nsubsystems, and, as you will see shortly, also helps us adhere to a new object-oriented principle. Before we introduce that new principle, let\u2019s take a look at the official definition of the pattern:\nThere isn\u2019t a lot here that you don\u2019t already know, but one of the most important things to \nremember about a pattern is its intent. This definition tells us loud and clear that the purpose \nof the facade is to make a subsystem easier to use through a simplified interface. You can see \nthis in the pattern\u2019s class diagram:\nClient\nFacade\nsubsystem classes\nUnified interface \nthat is easier to use. That\u2019s it; you\u2019ve got another pattern under your belt! Now, it\u2019s time for that new OO principle. Watch out, this one can challenge some assumptions! More complex subsystem. Happy client whose \njob just became \neasier because of \nthe facade.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 304", "position": 304, "chunk_type": "semantic", "token_estimate": 242}
{"text": "you are here 4\u2003 \u2003 267: the adapter and facade patterns\nThe Principle of Least Knowledge\nDesign Principle\nPrinciple of Least Knowledge: talk \nonly to your immediate friends. The Principle of Least Knowledge guides us to reduce the \ninteractions between objects to just a few close \u201cfriends.\u201d \nThe principle is usually stated as:\nBut what does this mean in real terms? It means when you \nare designing a system, for any object, be careful of the \nnumber of classes it interacts with and also how it comes to \ninteract with those classes. This principle prevents us from creating designs that have \na large number of classes coupled together so that changes \nin one part of the system cascade to other parts. When you \nbuild a lot of dependencies between many classes, you are \nbuilding a fragile system that will be costly to maintain and \ncomplex for others to understand. How many classes is this code coupled to? public float getTemp() {\n    return station.getThermometer().getTemperature();\n}", "domains": ["Design Patterns", "Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 305", "position": 305, "chunk_type": "semantic", "token_estimate": 163}
{"text": "268\u2003 \u2003 Chapter 7: principle of least knowledge\nNotice that these guidelines tell us not \nto call methods on objects that were \nreturned from calling other methods!! Think of a \u201ccomponent\u201d as any object that is \nreferenced by an instance variable. In other \nwords, think of this as a HAS-A relationship. Okay, but how do you keep from doing this? The principle \nprovides some guidelines: take any object, and from any \nmethod in that object, invoke only methods that belong to:\n\t\n\u0083\nThe object itself\n\t\n\u0083\nObjects passed in as a parameter to the method\n\t\n\u0083\nAny object the method creates or instantiates\n\t\n\u0083\nAny components of the object\nThis sounds kind of stringent, doesn\u2019t it? What\u2019s the harm \nin calling the method of an object we get back from another \ncall? Well, if we were to do that, then we\u2019d be making a \nrequest of another object\u2019s subpart (and increasing the \nnumber of objects we directly know). In such cases, the \nprinciple forces us to ask the object to make the request for us; \nthat way, we don\u2019t have to know about its component objects \n(and we keep our circle of friends small). For example:\nHow NOT to Win Friends and Influence Objects\npublic float getTemp() {\n    Thermometer thermometer = station.getThermometer();\n    return thermometer.getTemperature();\n}\nWithout the \nPrinciple\npublic float getTemp() {\n    return station.getTemperature();\n}\nWith the \nPrinciple\nHere we get the thermometer object \nfrom the station and then call the \ngetT\nemperature() method ourselves. When we apply the principle, we add a method \nto the Station class that makes the request \nto the thermometer for us. This reduces the \nnumber of classes we\u2019re dependent on.", "domains": ["Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 306", "position": 306, "chunk_type": "semantic", "token_estimate": 275}
{"text": "you are here 4\u2003 \u2003 269: the adapter and facade patterns\npublic class Car {\n\t\nEngine engine;\n\t\n// other instance variables\n\t\npublic Car() {\n\t\n\t\n// initialize engine, etc.\n\t\n} public void start(Key key) {\n\t\n\t\nDoors doors = new Doors();\n\t\n\t\nboolean authorized = key.turns();\n\t\n\t\nif (authorized) {\n\t\n\t\n\t\nengine.start();\n\t\n\t\n\t\nupdateDashboardDisplay();\n\t\n\t\n\t\ndoors.lock();\n\t\n\t\n}\n\t\n}\n\t\npublic void updateDashboardDisplay() {\n\t\n\t\n// update display\n\t\n}\n}\nKeeping your method calls in bounds...\nHere\u2019s a Car class that demonstrates all the ways you can call methods and still \nadhere to the Principle of Least Knowledge:\nYou can call a local method \nwithin the object. You can call a method on an \nobject passed as a parameter. You can call a method on a \ncomponent of the object. You can call a method on an \nobject you create or instantiate. Here\u2019s a component of this \nclass. We can call its methods. Here we\u2019re creating a new \nobject; its methods are legal. Q: There is another principle called the \nLaw of Demeter; how are they related? A: The two are one and the same, and \nyou\u2019ll encounter these terms being used \ninterchangeably. We prefer to use the \nPrinciple of Least Knowledge for a couple \nof reasons: (1) the name is more intuitive, \nand (2) the use of the word \u201cLaw\u201d implies we \nalways have to apply this principle. In fact, \nno principle is a law; all principles should \n\nbe used when and where they are helpful. All design involves tradeoffs (abstractions \nversus speed, space versus time, and so on) \nand while principles provide guidance, you \nshould take all factors into account before \napplying them. Q: Are there any disadvantages \nto applying the Principle of Least \nKnowledge? A: Yes; while the principle reduces \nthe dependencies between objects and \nstudies have shown this reduces software \nmaintenance, it is also the case that applying \nthis principle results in more \u201cwrapper\u201d \nclasses being written to handle method \ncalls to other components. This can result in \nincreased complexity and development time \nas well as decreased runtime performance.", "domains": ["Design Patterns", "Design Principles", "Software Quality Attributes", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 307", "position": 307, "chunk_type": "semantic", "token_estimate": 332}
{"text": "270\u2003 \u2003 Chapter 7: violating the principle of least knowledge\nHard hat area. watch out for \nfalling assumptions\nDo either of these classes violate the Principle of Least \nKnowledge? Why or why not? public House {\n    WeatherStation station;\n    // other methods and constructor\n    public float getTemp() {\n         return station.getThermometer().getTemperature();\n    }\n}\npublic House {\n     WeatherStation station;\n    // other methods and constructor\n    public float getTemp() {\n         Thermometer thermometer = station.getThermometer();\n         return getTempHelper(thermometer);\n    }\n \n    public float getTempHelper(Thermometer thermometer) {\n        return thermometer.getTemperature();\n    }\n}\nCan you think of a common use of Java that \nviolates the Principle of Least Knowledge? Should you care? Answer: How about System.out.println()?", "domains": ["Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 308", "position": 308, "chunk_type": "semantic", "token_estimate": 103}
{"text": "you are here 4\u2003 \u2003 271: the adapter and facade patterns\nThe Facade Pattern and the Principle of Least Knowledge\nClient\nThis client only has one friend: \nthe HomeTheaterFacade. In OO \nprogramming, having only one \nfriend is a GOOD thing! HomeTheaterFacade \nmanages all those subsystem \ncomponents for the client. It keeps the client simple \nand flexible. We try to keep subsystems \nadhering to the Principle of Least \nKnowledge as well. If this gets too \ncomplex and too many friends are \nintermingling, we can introduce \nadditional facades to form layers \nof subsystems. We can upgrade the home \ntheater components without \naffecting the client. watchMovie()\nendMovie()\nlistenToRadio()\nendRadio()\nHomeTheaterFacade\nTheaterLights\non()\noff()\ndim()\ntoString()\nPopcornPopper\non()\noff()\npop()\ntoString()\nScreen\nup()\ndown()\ntoString()\nTuner\non()\noff()\nsetAm()\nsetFm()\nsetFrequency()\ntoString()\namplifier\nAmplifier\ntuner\nplayer\non()\noff()\nsetStreamingPlayer()\nsetStereoSound()\nsetSurroundSoud()\nsetTuner()\nsetVolume()\ntoString()\nProjector\non()\noff()\ntvMode()\nwideScreenMode()\ntoString()\nplayer\nStreamingPlayer\namplifier\non()\noff()\npause()\nplay()\nsetSurroundAudio()\nsetTwoChannelAudio()\nstop()\ntoString()", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 309", "position": 309, "chunk_type": "semantic", "token_estimate": 156}
{"text": "272\u2003 \u2003 Chapter 7: your design toolbox\nTools for your Design Toolbox\nYour toolbox is starting to get heavy! In this chapter we\u2019ve \nadded a couple of patterns that allow us to alter interfaces and \nreduce coupling between clients and the systems they use. Abstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies. Favor composition over inheritance. Program to interfaces, not \nimplementations. Strive for loosely coupled designs \nbetween objects that interact. Classes should be open for extension \nbut closed for modification. Depend on abstractions. Do not \ndepend on concrete classes. T\nalk only to your friends. OO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it. OO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically. Decorators provide a flexible \nalternative to subclassing for extending \nfunctionality. Abstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes. Factory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate. Factory Method lets \na class defer instantiation to the \nsubclasses. Singleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it. Command - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Adapter - Converts the interface of \na class into another interface clients \nexpect. Lets classes work together \nthat couldn\u2019t otherwise because of \nincompatible interfaces. We have a new technique \nfor maintaining a low level \nof coupling in our designs \n(remember, talk only to your \nfriends)... Facade - Provides a unified interface \nto a set of interfaces in a subsystem. Facade defines a higher-level interface \nthat makes the subsystem easier to use. ...and TWO new patterns. Each changes an interface, \nthe adapter to convert, \nand the facade to unify \nand simplify. \u0083\nWhen you need to use \nan existing class and its \ninterface is not the one you \nneed, use an adapter. \u0083\nWhen you need to simplify \nand unify a large interface or \ncomplex set of interfaces, use \na facade. \u0083\nAn adapter changes an \ninterface into one a client \nexpects.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 310", "position": 310, "chunk_type": "semantic", "token_estimate": 396}
{"text": "272\u2003 \u2003 Chapter 7: \u0083\nWhen you need to simplify \nand unify a large interface or \ncomplex set of interfaces, use \na facade. \u0083\nAn adapter changes an \ninterface into one a client \nexpects. \u0083\nA facade decouples a client \nfrom a complex subsystem. \u0083\nImplementing an adapter may \nrequire little work or a great \ndeal of work depending on \nthe size and complexity of the \ntarget interface. \u0083\nImplementing a facade \nrequires that we compose \nthe facade with its subsystem \nand use delegation to \nperform the work of the \nfacade. \u0083\nThere are two forms of the \nAdapter Pattern: object \nand class adapters. Class \nadapters require multiple \ninheritance. \u0083\nYou can implement more than \none facade for a subsystem. \u0083\nAn adapter wraps an object \nto change its interface, a \ndecorator wraps an object \nto add new behaviors and \nresponsibilities, and a facade \n\u201cwraps\u201d a set of objects to \nsimplify.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 310", "position": 310, "chunk_type": "semantic", "token_estimate": 150}
{"text": "you are here 4\u2003 \u2003 273: the adapter and facade patterns\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nAcross\n1. True or false, Adapters can only wrap one object\n5. An Adapter _____ an interface\n6. Movie we watched (5 words)\n10. If in Europe you might need one of these (two \nwords)\n11. Adapter with two roles (two words)\n14. Facade still _____ low level access\n15. Ducks do it better than Turkeys\n16. Disadvantage of the Principle of Least \nKnowledge: too many __________\n17. A _________ simplifies an interface\n19. New American dream (two words)\nDown\n2. Decorator called Adapter this (3 words)\n3. One advantage of Facade\n4. Principle that wasn't as easy as it sounded (two \nwords)\n7. A ______ adds new behavior \n8. Masquerading as a Duck\n9. Example that violates the Principle of Least \nKnowledge: System.out.______\n12. No movie is complete without this\n13. Adapter client uses the _________ interface\n18. An Adapter and a Decorator can be said to \n_____ an object\nDesign Patterns Crossword\nYes, it\u2019s another crossword. All of the solution words are \nfrom this chapter.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 311", "position": 311, "chunk_type": "semantic", "token_estimate": 196}
{"text": "1. True or false? Adapters can wrap only one object.: 5. An Adapter __________ an interface. 6. Movie we watched (five words). 10. If in Britain, you might need one of these (two words). 11. Adapter with two roles (two words). 14. Facade still ________ low-level access. 15. Ducks do it better than Turkeys. 16. Disadvantage of the Principle of Least Knowledge: \ntoo many __________. 17. A __________ simplifies an interface. 19. New American dream (two words).", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 311", "position": 311, "chunk_type": "semantic", "token_estimate": 77}
{"text": "2. Decorator called Adapter this (three words).: 3. One advantage of Facade. 4. Principle that wasn't as easy as it sounded (two words). 7. A __________ adds new behavior. 8. Masquerading as a Duck. 9. Example that violates the Principle of Least \nKnowledge: System.out.__________. 12. No movie is complete without this. 13. Adapter client uses the __________ interface. 18. An Adapter and a Decorator can be said to ________ \nan object.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 311", "position": 311, "chunk_type": "semantic", "token_estimate": 71}
{"text": "274\u2003 \u2003 Chapter 7: exercise solutions\nLet\u2019s say we also need an Adapter that converts a Duck to a \nTurkey. Let\u2019s call it DuckAdapter. Here\u2019s our solution:\npublic class DuckAdapter implements Turkey {\n    Duck duck;\n    Random rand;\n    public DuckAdapter(Duck duck) {\n        this.duck = duck;\n        rand = new Random();\n    }\n    public void gobble() {\n        duck.quack();\n    }\n    public void fly() {\n        if (rand.nextInt(5) == 0) {\n             duck.fly();\n        }\n    }\n}\nNow we are adapting Turkeys to Ducks, so \nwe implement the Turkey interface. We stash a reference to the Duck we are adapting. We also create a random object; take a look at the \nfly() method to see how it is used. A gobble just becomes a quack. Since Ducks fly a lot longer than Turkeys, \nwe decided to only fly the Duck on average \none of five times. Do either of these classes violate the Principle of Least \nKnowledge? Why or why not? public House {\n    WeatherStation station;\n    // other methods and constructor\n    public float getTemp() {\n         return station.getThermometer().getTemperature();\n    }\n}\npublic House {\n     WeatherStation station;\n    // other methods and constructor\n    public float getTemp() {\n         Thermometer thermometer = station.getThermometer();\n         return getTempHelper(thermometer);\n    }\n \n    public float getTempHelper(Thermometer thermometer) {\n        return thermometer.getTemperature();\n    }\n}\nViolates the Principle of Least Knowledge! You are calling the method of an object \nreturned from another call. Doesn\u2019t violate Principle of \nLeast Knowledge! This seems \nlike hacking our way around \nthe principle. Has anything \nreally changed since we \njust moved out the call to \nanother method?", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 312", "position": 312, "chunk_type": "semantic", "token_estimate": 246}
{"text": "you are here 4\u2003 \u2003 275: the adapter and facade patterns\nMatch each pattern with its intent:\nSOlUTion\nPattern\nIntent\nDecorator\nAdapter\nFacade\nConverts one interface to \nanother\nDoesn\u2019t alter the interface, \nbut adds responsibility\nMakes an interface simpler\nYou\u2019ve seen how to implement an adapter that adapts an Enumeration to an Iterator; now write \nan adapter that adapts an Iterator to an Enumeration. public class IteratorEnumeration implements Enumeration<Object> {\n    Iterator<?> iterator;\n \n    public IteratorEnumeration(Iterator<?> iterator) {\n        this.iterator = iterator;\n    }\n \n    public boolean hasMoreElements() {\n        return iterator.hasNext();\n    }\n \n    public Object nextElement() {\n        return iterator.next();\n    }\n}\nNotice we keep the \ntype parameter \ngeneric so this will \nwork for any type \nof object.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 313", "position": 313, "chunk_type": "semantic", "token_estimate": 110}
{"text": "Across: 1. True or false, Adapters can only wrap one object \n[FALSE] \n5. An Adapter _____ an interface [CONVERTS] \n6. Movie we watched (5 words) \n[RAIDERSOFTHELOSTARK] \n10. If in Europe you might need one of these (two \nwords) [ACADAPTER] \n11. Adapter with two roles (two words) [TWOWAY] \n14. Facade still _____ low level access [ALLOWS] \n15. Ducks do it better than Turkeys [FLY] \n16. Disadvantage of the Principle of Least \nKnowledge: too many __________ \n[WRAPPERS] \n17. A _________ simplifies an interface [FACADE] \n19. New American dream (two words) \n[HOMETHEATER] \nDown\n2. Decorator called Adapter this (3 words) \n[SIMPLEPASSTHROUGH] \n3. One advantage of Facade [DECOUPLING] \n4. Principle that wasn't as easy as it sounded (two \nwords) [LEASTKNOWLEDGE] \n7. A ______ adds new behavior  [DECORATOR] \n8. Masquerading as a Duck [TURKEY] \n9. Example that violates the Principle of Least \nKnowledge: System.out.______ [PRINTLN] \n12. No movie is complete without this [POPCORN] \n13. Adapter client uses the _________ interface \n[TARGET] \n18. An Adapter and a Decorator can be said to \n_____ an object [WRAP] \nDesign Patterns Crossword Solution", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 314", "position": 314, "chunk_type": "semantic", "token_estimate": 174}
{"text": "this is a new chapter\u2003 \u2003 277: We\u2019re on an encapsulation roll; we\u2019ve encapsulated object \ncreation, method invocation, complex interfaces, ducks, \npizzas...what could be next? We\u2019re going to get down to encapsulating \npieces of algorithms so that subclasses can hook themselves right into a \ncomputation anytime they want. We\u2019re even going to learn about a design principle \ninspired by Hollywood. Let\u2019s get started...\n8  the Template Method Pattern\nEncapsulating \n               Algorithms \n \n \n \n \n \nYeah, he\u2019s a great \nboss until it comes to getting \ndown in this hole, then it ALL \nbecomes MY job. See what I \nmean? He\u2019s nowhere in sight!", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 315", "position": 315, "chunk_type": "semantic", "token_estimate": 97}
{"text": "you are here 4\u2003 \u2003 279: the template method pattern\npublic class Coffee {\n \n    void prepareRecipe() {\n        boilWater();\n        brewCoffeeGrinds();\n        pourInCup();\n        addSugarAndMilk();\n    }\n \n    public void boilWater() {\n        System.out.println(\"Boiling water\");\n    }\n \n    public void brewCoffeeGrinds() {\n        System.out.println(\"Dripping Coffee through filter\");\n    }\n \n    public void pourInCup() {\n        System.out.println(\"Pouring into cup\");\n    }\n \n    public void addSugarAndMilk() {\n        System.out.println(\"Adding Sugar and Milk\");\n    }\n}\nLet\u2019s play \u201ccoding barista\u201d and write some code for \ncreating coffee and tea. Here\u2019s the coffee:\nWhipping up some coffee and tea classes \n(in Java)\nHere\u2019s our Coffee class for making coffee. Here\u2019s our recipe for coffee, \nstraight out of the training manual. Each of the steps is implemented as \na separate method. Each of these methods \nimplements one step of \nthe algorithm. There\u2019s \na method to boil water, \nbrew the coffee, pour \nthe coffee in a cup, \nand add sugar and milk.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 317", "position": 317, "chunk_type": "semantic", "token_estimate": 138}
{"text": "you are here 4\u2003 \u2003 281: the template method pattern\n Design Puzzle\nYou\u2019ve seen that the Coffee and Tea classes have a fair bit of code duplication. Take another \nlook at the Coffee and Tea classes and draw a class diagram showing how you\u2019d redesign the \nclasses to remove redundancy:", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 319", "position": 319, "chunk_type": "semantic", "token_estimate": 49}
{"text": "you are here 4\u2003 \u2003 283: the template method pattern\n(1) Boil some water\n(2) Brew coffee in boiling water\n(3) Pour coffee in cup\n(4) Add sugar and milk\nStarbuzz Coffee Recipe\nStarbuzz Tea Recipe\n(1) Boil some water\n(2) Steep tea in boiling water\n(3) Pour tea in cup\n(4) Add lemon\nTaking the design further... So what else do Coffee and Tea have in common? Let\u2019s start with the recipes. Notice that both recipes follow the same algorithm:\n1\nBoil some water. 2\n3\n4\nUse the hot water to extract the coffee \nor tea. Pour the resulting beverage into a cup. Add the appropriate condiments to the \nbeverage. These two are \nalready abstracted \ninto the base class. These aren\u2019t \nabstracted but \nare the same; \nthey just apply \nto different \nbeverages. So, can we find a way to abstract prepareRecipe() too? Yes, let\u2019s find out...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 321", "position": 321, "chunk_type": "semantic", "token_estimate": 147}
{"text": "you are here 4\u2003 \u2003 285: the template method pattern\npublic class Coffee extends CaffeineBeverage {\n    public void brew() {\n        System.out.println(\"Dripping Coffee through filter\");\n    }\n    public void addCondiments() {\n        System.out.println(\"Adding Sugar and Milk\");\n    }\n}\npublic class Tea extends CaffeineBeverage {\n    public void brew() {\n        System.out.println(\"Steeping the tea\");\n    }\n    public void addCondiments() {\n        System.out.println(\"Adding Lemon\");\n    }\n}\npublic abstract class CaffeineBeverage {\n  \n    final void prepareRecipe() {\n        boilWater();\n        brew();\n        pourInCup();\n        addCondiments();\n    }\n \n    abstract void brew();\n  \n    abstract void addCondiments();\n \n    void boilWater() {\n        System.out.println(\"Boiling water\");\n    }\n  \n    void pourInCup() {\n        System.out.println(\"Pouring into cup\");\n    }\n}\nNow, the same prepareRecipe() method \nwill be used to make both T\nea and Coffee. prepareRecipe() is declared final because \nwe don\u2019t want our subclasses to be able to \noverride this method and change the recipe! We\u2019ve generalized steps 2 and 4 to brew() the \nbeverage and addCondiments(). CaffeineBeverage is abstract, \njust like in the class design. Because Coffee and T\nea handle these \nmethods in different ways, they\u2019re going to \nhave to be declared as abstract. Let the \nsubclasses worry about that stuff! Remember, we moved these into \nthe CaffeineBeverage class \n(back in our class diagram). Finally, we need to deal with the Coffee and Tea classes. They now rely on CaffeineBeverage \nto handle the recipe, so they just need to handle brewing and condiments:\n3\nAs in our design, T\nea and Coffee \nnow extend CaffeineBeverage. T\nea needs to define brew() and \naddCondiments()\u2014the two abstract \nmethods from CaffeineBeverage. Same for Coffee, except Coffee \ndeals with coffee, and sugar and milk \ninstead of tea bags and lemon.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 323", "position": 323, "chunk_type": "semantic", "token_estimate": 259}
{"text": "you are here 4\u2003 \u2003 287: the template method pattern\nWhat have we done? 1\nBoil some water\n2\n3\n4\nSteep the tea bag in the water\nPour tea in a cup\nAdd lemon\n1\nBoil some water\n2\n3\n4\nBrew the coffee grinds\nPour coffee in a cup\nAdd sugar and milk\n2\n4\nSteep the tea bag in the water\nAdd lemon\nT\nea subclass\nCoffee subclass\n2\n4\nBrew the coffee grinds\nAdd sugar and milk\n1\nBoil some water\n2\n3\n4\nBrew\nPour beverage in a cup\nAdd condiments\nCaffeine Beverage\nTea\nCoffee\nCaffeine Beverage \nknows and controls the \nsteps of the recipe, and \nperforms steps 1 and 3 \nitself, but relies on T\nea \nor Coffee to do steps \n2 and 4. We\u2019ve recognized \nthat the two recipes \nare essentially the \nsame, although \nsome of the steps \nrequire different \nimplementations. So \nwe\u2019ve generalized the \nrecipe and placed it \nin the base class. generalize\nrelies on \nsubclass \nfor some \nsteps\ngeneralize\nrelies on \nsubclass \nfor some \nsteps", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 325", "position": 325, "chunk_type": "semantic", "token_estimate": 173}
{"text": "288\u2003 \u2003 Chapter 8: meet the template method pattern\nMeet the Template Method \nWe\u2019ve basically just implemented the Template Method Pattern. What\u2019s that? Let\u2019s look at \nthe structure of the CaffeineBeverage class; it contains the actual \u201ctemplate method\u201d:\nfinal void prepareRecipe() {\n}\nbrew();\npourInCup();\naddCondiments();\nboilWater();\n   abstract void brew();\n   abstract void addCondiments();\n   void boilWater() {\n        // implementation\n   }\n   void pourInCup() {\n        // implementation\n   }\n}\npublic abstract class CaffeineBeverage {\nIn the template, each \nstep of the algorithm is \nrepresented by a method. prepareRecipe() is our \ntemplate method. Why? Because:\n   (1) It is a method, after all. (2) It serves as a template for an \nalgorithm\u2014in this case, an algorithm \nfor making caffeinated beverages. Some methods are \nhandled by this class...\n...and some are handled \nby the subclass. The methods that need to \nbe supplied by a subclass are \ndeclared abstract. The Template Method defines the steps of an algorithm and allows \nsubclasses to provide the implementation for one or more steps.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 326", "position": 326, "chunk_type": "semantic", "token_estimate": 162}
{"text": "you are here 4\u2003 \u2003 289: the template method pattern\nLet\u2019s make some tea...\nLet\u2019s step through making a tea and trace through how the \ntemplate method works. You\u2019ll see that the template method \ncontrols the algorithm; at certain points in the algorithm, it lets \nthe subclass supply the implementation of the steps...\n1\nTea myTea = new Tea();\nOkay, first we need a Tea object...\n2\nmyTea.prepareRecipe();\nThen we call the template method:\nwhich follows the algorithm for making caffeine \nbeverages...\nboilWater();\nbrew();\npourInCup();\naddCondiments();\n3\nboilWater();\nFirst we boil water:\nwhich happens in CaffeineBeverage. prepareRecipe()\nboilWater()\npourInCup()\nCaffeineBeverage\nbrew()\naddCondiments();\nTea\n4\nbrew();\nNext we need to brew the tea, which only the subclass knows \nhow to do:\n5\npourInCup();\nNow we pour the tea in the cup; this is the same for all beverages, \nso it happens in CaffeineBeverage:\n6\naddCondiments();\nFinally, we add the condiments, which are specific to each beverage, \nso the subclass implements this:\nThe prepareRecipe() method \ncontrols the algorithm. No \none can change this, and \nit counts on subclasses to \nprovide some or all of the \nimplementation. Behind \nthe Scenes", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 327", "position": 327, "chunk_type": "semantic", "token_estimate": 186}
{"text": "290\u2003 \u2003 Chapter 8: what did template method get us? Underpowered  Tea & Coffee \nimplementation\nWhat did the Template Method get us? Coffee and Tea are running the show; \nthey control the algorithm. Code changes to the algorithm \nrequire opening the subclasses and \nmaking multiple changes. The algorithm lives in one place and \ncode changes only need to be made \nthere. Code is duplicated across Coffee and \nTea. The CaffeineBeverage class \nmaximizes reuse among the \nsubclasses. The CaffeineBeverage class runs \nthe show; it has the algorithm, and \nprotects it. Classes are organized in a structure \nthat requires a lot of work to add a \nnew caffeine beverage. The Template Method Pattern provides \na framework that other caffeine \nbeverages can be plugged into. New \ncaffeine beverages only need to \nimplement a couple of methods. The CaffeineBeverage class \nconcentrates knowledge about the \nalgorithm and relies on subclasses to \nprovide complete implementations. Knowledge of the algorithm and how \nto implement it is distributed over \nmany classes. New, hip CaffeineBeverage \npowered by Template Method", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 328", "position": 328, "chunk_type": "semantic", "token_estimate": 169}
{"text": "you are here 4\u2003 \u2003 291: the template method pattern\nTemplate Method Pattern defined\nThe Template Method Pattern defines the skeleton \nof an algorithm in a method, deferring some steps to \nsubclasses. Template Method lets subclasses redefine \ncertain steps of an algorithm without changing the \nalgorithm\u2019s structure. You\u2019ve seen how the Template Method Pattern works in our Tea and Coffee example; \nnow, check out the official definition and nail down all the details:\nThis pattern is all about creating a template for an algorithm. What\u2019s a template? As you\u2019ve seen it\u2019s just a method; more specifically, it\u2019s a method that defines an \nalgorithm as a set of steps. One or more of these steps is defined to be abstract and \nimplemented by a subclass. This ensures the algorithm\u2019s structure stays unchanged, \nwhile subclasses provide some part of the implementation. Let\u2019s check out the class diagram:\ntemplateMethod()\nprimitiveOperation1()\nprimitiveOperation2()\nAbstractClass\nprimitiveOperation1()\nprimitiveOperation2()\nConcreteClass\nprimitiveOperation1();\nprimitiveOperation2();\nThe AbstractClass \ncontains the template \nmethod...\n...and abstract versions \nof the operations \nused in the template \nmethod. The ConcreteClass implements \nthe abstract operations, \nwhich are called when the \ntemplateMethod() needs them. There may be many \nConcreteClasses, each \nimplementing the full set of \noperations required by the \ntemplate method. The template method makes use of the \nprimitive operations to implement an \nalgorithm. It is decoupled from the actual \nimplementation of these operations.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 329", "position": 329, "chunk_type": "semantic", "token_estimate": 224}
{"text": "292\u2003 \u2003 Chapter 8: template method pattern up close\nCode Up Close\nHere we have our abstract class; it \nis declared abstract and meant to \nbe subclassed by classes that provide \nimplementations of the operations. Let\u2019s take a closer look at how the AbstractClass is defined, including the template method \nand primitive operations. abstract class AbstractClass {\n    \n    final void templateMethod() {\n        primitiveOperation1();\n        primitiveOperation2();\n        concreteOperation();\n    }\n    abstract void primitiveOperation1();\n    \n    abstract void primitiveOperation2();\n    \n    void concreteOperation() {\n        // implementation here\n    }\n}\nHere\u2019s the template method. It\u2019s \ndeclared final to prevent subclasses \nfrom reworking the sequence of \nsteps in the algorithm. The template method \ndefines the sequence of \nsteps, each represented \nby a method. In this example, two of \nthe primitive operations \nmust be implemented by \nconcrete subclasses. We also have a concrete operation \ndefined in the abstract class. This \ncould be overridden by subclasses, or we \ncould prevent overriding by declaring \nconcreteOperation() as final. More about \nthis in a bit...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 330", "position": 330, "chunk_type": "semantic", "token_estimate": 157}
{"text": "you are here 4\u2003 \u2003 293: the template method pattern\nNow we\u2019re going to look even closer at the types of method that can go in the abstract class:\nabstract class AbstractClass {\n    \n    final void templateMethod() {\n        primitiveOperation1();\n        primitiveOperation2();\n        concreteOperation();\n        hook();\n    }\n    abstract void primitiveOperation1();\n    \n    abstract void primitiveOperation2();\n    \n    final void concreteOperation() {\n        // implementation here\n    }\n    void hook() {}\n}\nWe still have our primitive \noperation methods; \nthese are abstract and \nimplemented by concrete \nsubclasses. A concrete operation is defined in the \nabstract class. This one is declared final \nso that subclasses can\u2019t override it. It \nmay be used in the template method \ndirectly, or used by subclasses. We can also have concrete methods that do nothing \nby default; we call these \u201chooks.\u201d Subclasses are free \nto override these but don\u2019t have to. We\u2019re going to \nsee how these are useful on the next page. A concrete method, but \nit does nothing! We\u2019ve changed the \ntemplateMethod() to \ninclude a new method call. Code Way Up Close", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 331", "position": 331, "chunk_type": "semantic", "token_estimate": 165}
{"text": "294\u2003 \u2003 Chapter 8: implement a hook\npublic abstract class CaffeineBeverageWithHook {\n \n    final void prepareRecipe() {\n        boilWater();\n        brew();\n        pourInCup();\n        if (customerWantsCondiments()) {\n            addCondiments();\n        }\n    }\n \n    abstract void brew();\n \n    abstract void addCondiments();\n \n    void boilWater() {\n        System.out.println(\"Boiling water\");\n    }\n \n    void pourInCup() {\n        System.out.println(\"Pouring into cup\");\n    }\n \n    boolean customerWantsCondiments() {\n        return true;\n    }\n}\nHooked on \nTemplate Method...\nA hook is a method that is declared in the \nabstract class, but only given an empty or default \nimplementation. This gives subclasses the ability to \n\u201chook into\u201d the algorithm at various points, if they \nwish; a subclass is also free to ignore the hook. There are several uses of hooks; let\u2019s take a look at \none now. We\u2019ll talk about a few other uses later:\nWe\u2019ve added a little conditional \nstatement that bases its \nsuccess on a concrete method, \ncustomerWantsCondiments(). If the \ncustomer WANTS condiments, only then \ndo we call addCondiments(). Here we\u2019ve defined a method \nwith a (mostly) empty default \nimplementation. This method just \nreturns true and does nothing else. This is a hook because the \nsubclass can override this \nmethod, but doesn\u2019t have to. With a hook, I can \noverride the method or not. It\u2019s my choice. If I don\u2019t, the \nabstract class provides a default \nimplementation.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 332", "position": 332, "chunk_type": "semantic", "token_estimate": 204}
{"text": "you are here 4\u2003 \u2003 295: the template method pattern\npublic class CoffeeWithHook extends CaffeineBeverageWithHook {\n \n    public void brew() {\n        System.out.println(\"Dripping Coffee through filter\");\n    }\n \n    public void addCondiments() {\n        System.out.println(\"Adding Sugar and Milk\");\n    }\n \n    public boolean customerWantsCondiments() {\n        String answer = getUserInput();\n        if (answer.toLowerCase().startsWith(\"y\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n \n    private String getUserInput() {\n        String answer = null;\n        System.out.print(\"Would you like milk and sugar with your coffee (y/n)? \");\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            answer = in.readLine();\n        } catch (IOException ioe) {\n            System.err.println(\"IO error trying to read your answer\");\n        }\n        if (answer == null) {\n            return \"no\";\n        }\n        return answer;\n    }\n}\nUsing the hook\nTo use the hook, we override it in our subclass. Here, the hook controls whether \nthe CaffeineBeverage class evaluates a certain part of the algorithm\u2014that is, \nwhether it adds a condiment to the beverage. How do we know whether the customer wants the condiment? Just ask! Here\u2019s where you override \nthe hook and provide your \nown functionality. Get the user\u2019s input on \nthe condiment decision \nand return true or false, \ndepending on the input. This code asks if the user would like milk and \nsugar and gets the input from the command line.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 333", "position": 333, "chunk_type": "semantic", "token_estimate": 204}
{"text": "you are here 4\u2003 \u2003 297: the template method pattern\nYou know what? We agree with you. But you \nhave to admit before you thought of that, it was \na pretty cool example of how a hook can be used \nto conditionally control the flow of the algorithm \nin the abstract class. Right? We\u2019re sure you can think of many other more \nrealistic scenarios where you could use the \ntemplate method and hooks in your own code. Now, I would have thought \nthat functionality like \nasking the customer could \nhave been used by all \nsubclasses? Q: When I\u2019m creating a template method, how do I know when \nto use abstract methods and when to use hooks? A: Use abstract methods when your subclass MUST provide an \nimplementation of the method or step in the algorithm. Use hooks \nwhen that part of the algorithm is optional. With hooks, a subclass \nmay choose to implement that hook, but it doesn\u2019t have to. Q: What are hooks really supposed to be used for? A: There are a few uses of hooks. As we just said, a hook may \nprovide a way for a subclass to implement an optional part of an \nalgorithm, or if it isn\u2019t important to the subclass\u2019s implementation, it \ncan skip it. Another use is to give the subclass a chance to react to \nsome step in the template method that is about to happen or just \nhappened. For instance, a hook method like justReorderedList() \nallows the subclass to perform some activity (such as redisplaying an \nonscreen representation) after an internal list is reordered. As you\u2019ve \nseen, a hook can also provide a subclass with the ability to make a \ndecision for the abstract class. Q: Does a subclass have to implement all the abstract \nmethods in the AbstractClass? A: Yes, each concrete subclass defines the entire set of abstract \nmethods and provides a complete implementation of the undefined \nsteps of the template method\u2019s algorithm. Q: It seems like I should keep my abstract methods small in \nnumber; otherwise, it will be a big job to implement them in the \nsubclass. A: That\u2019s a good thing to keep in mind when you write template \nmethods. Sometimes you can do this by not making the steps of \nyour algorithm too granular. But it\u2019s obviously a tradeoff: the less \ngranularity, the less flexibility.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 335", "position": 335, "chunk_type": "semantic", "token_estimate": 390}
{"text": "298\u2003 \u2003 Chapter 8: the hollywood principle\nThe Hollywood Principle\nThe Hollywood Principle\nDon\u2019t call us, we\u2019ll call you. We\u2019ve got another design principle for you; it\u2019s called the \nHollywood Principle:\nEasy to remember, right? But what has it got to do with OO \ndesign? The Hollywood Principle gives us a way to prevent \n\u201cdependency rot.\u201d Dependency rot happens when you have \nhigh-level components depending on low-level components \ndepending on high-level components depending on sideways \ncomponents depending on low-level components, and so \non. When rot sets in, no one can easily understand the way a \nsystem is designed. With the Hollywood Principle, we allow low-level components \nto hook themselves into a system, but the high-level \ncomponents determine when they are needed, and how. In \nother words, the high-level components give the low-level \ncomponents the \u201cdon\u2019t call us, we\u2019ll call you\u201d treatment. High-Level Component\nLow-Level \nComponent\nAnother \nLow-Level \nComponent\nLow-level components \ncan participate in the \ncomputation...\n...but the high-level \ncomponents control \nwhen and how. A low-level component never \ncalls a high-level component \ndirectly. You\u2019ve heard me say it \nbefore, and I\u2019ll say it again: \ndon\u2019t call me, I\u2019ll call you!", "domains": ["Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 336", "position": 336, "chunk_type": "semantic", "token_estimate": 188}
{"text": "you are here 4\u2003 \u2003 299: the template method pattern\nThe Factory Method and Observer; any others? The Hollywood Principle and Template Method\nThe connection between the Hollywood Principle and the Template Method \nPattern is probably somewhat apparent: when we design with the Template \nMethod Pattern, we\u2019re telling subclasses, \u201cdon\u2019t call us, we\u2019ll call you.\u201d How? Let\u2019s take another look at our CaffeineBeverage design: \nprepareRecipe()\nboilWater()\npourInCup()\nbrew()\naddCondiments()\nCaffeineBeverage\nbrew()\naddCondiments()\nTea\nbrew()\naddCondiments()\nCoffee\nCaffeineBeverage is our high-level \ncomponent. It has control over the \nalgorithm for the recipe, and calls on \nthe subclasses only when they\u2019re needed \nfor an implementation of a method. T\nea and Coffee never \ncall the abstract class \ndirectly without being \n\u201ccalled\u201d first. The subclasses are used simply to \nprovide implementation details. Clients of beverages will depend \non the CaffeineBeverage \nabstraction rather than a \nconcrete T\nea or Coffee, which \nreduces dependencies in the \noverall system. What other patterns make use of the Hollywood Principle?", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 337", "position": 337, "chunk_type": "semantic", "token_estimate": 160}
{"text": "300\u2003 \u2003 Chapter 8: who does what\nMatch each pattern with its description:\nPattern\nDescription\nTemplate Method\nStrategy\nFactory Method\nEncapsulate interchangeable \nbehaviors and use delegation to \ndecide which behavior to use. Subclasses decide how \nto implement steps in an \nalgorithm. Subclasses decide which \nconcrete classes to instantiate. Q: How does the Hollywood Principle relate to the \nDependency Inversion Principle that we learned a few chapters \nback? A: The Dependency Inversion Principle teaches us to avoid the \nuse of concrete classes and instead work as much as possible with \nabstractions. The Hollywood Principle is a technique for building \nframeworks or components so that lower-level components can be \nhooked into the computation, but without creating dependencies \nbetween the lower-level components and the higher-level layers. So, \nthey both have the goal of decoupling, but the Dependency Inversion \nPrinciple makes a much stronger and more general statement about \nhow to avoid dependencies in design. The Hollywood Principle gives us a technique for creating designs \nthat allow low-level structures to interoperate while preventing other \nclasses from becoming too dependent on them. Q: Is a low-level component disallowed from calling a \nmethod in a higher-level component? A: Not really. In fact, a low-level component will often end up \ncalling a method defined above it in the inheritance hierarchy purely \nthrough inheritance. But we want to avoid creating explicit circular \ndependencies between the low-level component and the high-level \nones.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 338", "position": 338, "chunk_type": "semantic", "token_estimate": 232}
{"text": "you are here 4\u2003 \u2003 301: the template method pattern\nTemplate Methods in the Wild\nThe Template Method Pattern is a very common pattern and \nyou\u2019re going to find lots of it in the wild. You\u2019ve got to have \na keen eye, though, because there are many implementations \nof the template methods that don\u2019t quite look like the \ntextbook design of the pattern. This pattern shows up so often because it\u2019s a great design tool \nfor creating frameworks, where the framework controls how \nsomething gets done, but leaves you (the person using the \nframework) to specify your own details about what is actually \nhappening at each step of the framework\u2019s algorithm. Let\u2019s take a little safari through a few uses in the wild (well, \nokay, in the Java API)... In training, we study the classic \npatterns. However, when we are out in \nthe real world, we must learn to recognize \nthe patterns out of context. We must also \nlearn to recognize variations of patterns, \nbecause in the real world a square hole is \nnot always truly square.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 339", "position": 339, "chunk_type": "semantic", "token_estimate": 176}
{"text": "302\u2003 \u2003 Chapter 8: sorting with template method\npublic static void sort(Object[] a) {\n    Object aux[] = (Object[])a.clone();\n    mergeSort(aux, a, 0, a.length, 0);\n}\nprivate static void mergeSort(Object src[], Object dest[],\n\t\n\t\nint low, int high, int off) \n{\n    // a lot of other code here\n    for (int i=low; i<high; i++){\n        for (int j=i; j>low &&\n             ((Comparable)dest[j-1]).compareTo((Comparable)dest[j])>0; j--)\n        {\n            swap(dest, j, j-1);\n        }\n    }\n    // and a lot of other code here\n}\nWhat\u2019s something we often need to do with arrays? Sort them! Recognizing that, the designers of the Java Arrays class \nhave provided us with a handy template method for \nsorting. Let\u2019s take a look at how this method operates:\nSorting with Template Method\nWe actually have two methods here and they act \ntogether to provide the sort functionality. compareT\no() is the method we \nneed to implement to \u201cfill out\u201d \nthe template method. This is a concrete method, already \ndefined in the Arrays class. We\u2019ve pared down this \ncode a little to make \nit easier to explain. If \nyou\u2019d like to see it all, \ngrab the Java source \ncode and check it out... Think of this as the \ntemplate method. The first method, sort(), is just a helper method that creates a \ncopy of the array and passes it along as the destination array to \nthe mergeSort() method. It also passes along the length of the \narray and tells the sort to start at the first element. The mergeSort() method contains the sort algorithm, and \nrelies on an implementation of the compareT\no() method to \ncomplete the algorithm. If you\u2019re interested in the nitty-\ngritty of how the sorting happens, you\u2019ll want to check out \nthe Java source code.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 340", "position": 340, "chunk_type": "semantic", "token_estimate": 280}
{"text": "you are here 4\u2003 \u2003 303: the template method pattern\nWe\u2019ve got an array of \nducks we need to sort. We\u2019ve got some ducks to sort... The compareTo() method compares two objects and returns whether one is less than, greater than, \nor equal to the other. sort() uses this as the basis of its comparison of objects in the array. Let\u2019s say you have an array of ducks that you\u2019d like to sort. How do \nyou do it? Well, the sort() template method in Arrays gives us the \nalgorithm, but you need to tell it how to compare ducks, which you do by \nimplementing the compareTo() method... Make sense? Good point. Here\u2019s the deal: the designers of sort() wanted \nit to be useful across all arrays, so they had to make sort() a \nstatic method that could be used from anywhere. But that\u2019s \nokay, since it works almost the same as if it were in a superclass. Now, here is one more detail: because sort() really isn\u2019t defined \nin our superclass, the sort() method needs to know that you\u2019ve \nimplemented the compareTo() method, or else you don\u2019t have \nthe piece needed to complete the sort algorithm. To handle this, the designers made use of the Comparable \ninterface. All you have to do is implement this interface, which \nhas one method (surprise): compareTo(). What is compareTo()? No, it doesn\u2019t. Aren\u2019t we supposed to be \nsubclassing something? I thought \nthat was the point of Template \nMethod. An array doesn\u2019t subclass \nanything, so I don\u2019t get how we\u2019d \nuse sort(). Am I greater \nthan you? I don\u2019t \nknow. That\u2019s what \ncompareTo() tells us.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 341", "position": 341, "chunk_type": "semantic", "token_estimate": 269}
{"text": "304\u2003 \u2003 Chapter 8: public class Duck implements Comparable<Duck> {\n    String name;\n    int weight;\n  \n    public Duck(String name, int weight) {\n        this.name = name;\n        this.weight = weight;\n    }\n \n    public String toString() {\n        return name + \" weighs \" + weight;\n    }\n \n \n  \n    public int compareTo(Duck otherDuck) {\n  \n        if (this.weight < otherDuck.weight) {\n            return -1;\n        } else if (this.weight == otherDuck.weight) {\n            return 0;\n        } else { // this.weight > otherDuck.weight\n            return 1;\n        }\n    }\n}\nimplementing comparable\nComparing Ducks and Ducks\nOkay, so you know that if you want to sort Ducks, \nyou\u2019re going to have to implement this compareTo() \nmethod; by doing that, you\u2019ll give the Arrays class \nwhat it needs to complete the algorithm and sort \nyour ducks. Here\u2019s the duck implementation:\nRemember, we need to implement the Comparable \ninterface since we aren\u2019t really subclassing. Our Ducks have a name and a weight. We\u2019re keepin\u2019 it simple; all Ducks do is \nprint their name and weight! Okay, here\u2019s what sort() needs...\ncompareT\no() takes another Duck to compare THIS Duck to. Here\u2019s where we specify how Ducks \ncompare. If THIS Duck weighs less \nthan otherDuck, we return -1; if \nthey are equal, we return 0; and \nif THIS Duck weighs more, we \nreturn 1.", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 342", "position": 342, "chunk_type": "semantic", "token_estimate": 203}
{"text": "you are here 4\u2003 \u2003 305: the template method pattern\npublic class DuckSortTestDrive {\n    public static void main(String[] args) {\n        Duck[] ducks = { \n                         new Duck(\"Daffy\", 8), \n                         new Duck(\"Dewey\", 2),\n                         new Duck(\"Howard\", 7),\n                         new Duck(\"Louie\", 2),\n                         new Duck(\"Donald\", 10), \n                         new Duck(\"Huey\", 2)\n         };\n        System.out.println(\"Before sorting:\");\n        display(ducks);\n        Arrays.sort(ducks);\n \n        System.out.println(\"\\nAfter sorting:\");\n        display(ducks);\n    }\n    public static void display(Duck[] ducks) {\n        for (Duck d : ducks) {\n            System.out.println(d);\n        }\n    }\n}\nLet\u2019s sort some Ducks\n%java DuckSortTestDrive\nBefore sorting:\nDaffy weighs 8\nDewey weighs 2\nHoward weighs 7\nLouie weighs 2\nDonald weighs 10\nHuey weighs 2\nAfter sorting:\nDewey weighs 2\nLouie weighs 2\nHuey weighs 2\nHoward weighs 7\nDaffy weighs 8\nDonald weighs 10\n%\nFile  Edit   Window  Help  DonaldNeedsToGoOnADiet\nThe unsorted Ducks\nThe sorted Ducks\nLet the sorting commence! Here\u2019s the test drive for sorting Ducks...\nWe need an array of \nDucks; these look good. Let\u2019s print them to see \ntheir names and weights. It\u2019s sort time! Let\u2019s print them (again) to see \ntheir names and weights. Notice that we \ncall Arrays\u2019 static \nmethod sort(), and \npass it our Ducks.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 343", "position": 343, "chunk_type": "semantic", "token_estimate": 179}
{"text": "306\u2003 \u2003 Chapter 8: behind the scenes: sorting ducks\nThe making of the sorting duck machine\nLet\u2019s trace through how the Arrays sort() template method works. We\u2019ll check out how the template method controls the algorithm, \nand at certain points in the algorithm, how it asks our Ducks to \nsupply the implementation of a step...\n1\nDuck[] ducks = {new Duck(\"Daffy\", 8), ... };\nFirst, we need an array of Ducks:\n2\nArrays.sort(ducks);\nThen we call the sort() template method in the Arrays \nclass and pass it our ducks:\nThe sort() method (and its helper, mergeSort()) control \nthe sort procedure. for (int i=low; i<high; i++){\n        ... compareTo() ...\n        ... swap() ...\n}\n3\nducks[0].compareTo(ducks[1]);\nTo sort an array, you need to compare two items one \nby one until the entire list is in sorted order. When it comes to comparing two ducks, the sort() \nmethod relies on the Duck\u2019s compareTo() method \nto know how to do this. The compareTo() method \nis called on the first duck and passed the duck to be \ncompared to:\nsort()\nswap()\nArrays\ncompareTo()\ntoString()\nDuck\n4\nswap()\nIf the Ducks are not in sorted order, they\u2019re swapped with \nthe concrete swap() method in Arrays:\nThe sort() method controls \nthe algorithm; no class can \nchange this. sort() counts \non a Comparable class to \nprovide the implementation \nof compareT\no(). 5\nThe sort() method continues comparing and swapping Ducks \nuntil the array is in the correct order! First Duck\nDuck to compare it to\nNo inheritance, \nunlike a typical \ntemplate method. Behind \nthe Scenes", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 344", "position": 344, "chunk_type": "semantic", "token_estimate": 256}
{"text": "you are here 4\u2003 \u2003 307: the template method pattern\nQ: Is this really the Template Method Pattern, or are you \ntrying too hard? A: The pattern calls for implementing an algorithm and letting \nsubclasses supply the implementation of the steps\u2014and the Arrays \nsort() is clearly not doing that! But, as we know, patterns in the \nwild aren\u2019t always just like the textbook patterns. They have to be  \nmodified to fit the context and implementation constraints. The designers of the Arrays sort() method had a few constraints. In \ngeneral, you can\u2019t subclass a Java array and they wanted the sort to \nbe used on all arrays (and each array is a different class). So they \ndefined a static method and deferred the comparison part of the \nalgorithm to the items being sorted. So, while it\u2019s not a textbook template method, this implementation is \nstill in the spirit of the Template Method Pattern. Also, by eliminating \nthe requirement that you have to subclass Arrays to use this \nalgorithm, they\u2019ve made sorting in some ways more flexible and \nuseful. Q: This implementation of sorting actually seems more like \nthe Strategy Pattern than the Template Method Pattern. Why do \nwe consider it Template Method? A: You\u2019re probably thinking that because the Strategy Pattern uses \nobject composition. You\u2019re right in a way\u2014we\u2019re using the Arrays \nobject to sort our array, so that\u2019s similar to Strategy. But remember, \nin Strategy, the class that you compose with implements the \nentire algorithm. The algorithm that Arrays implements for sort() is \nincomplete; it needs a class to fill in the missing compareTo() method. So, in that way, it\u2019s more like Template Method. Q: Are there other examples of template methods in the Java \nAPI? A: Yes, you\u2019ll find them in a few places. For example, java.io has a \nread() method in InputStream that subclasses must implement and is \nused by the template method read(byte b[], int off, int len). We know that we should favor composition over inheritance, right? Well, the \nimplementers of the sort() template method decided not to use inheritance and \ninstead to implement sort() as a static method that is composed with a Comparable \nat runtime. How is this better? How is it worse? How would you approach this \nproblem? Do Java arrays make this particularly tricky? Think of another pattern that is a specialization of the template method. In \nthis specialization, primitive operations are used to create and return objects.", "domains": ["Design Patterns", "Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 345", "position": 345, "chunk_type": "semantic", "token_estimate": 405}
{"text": "you are here 4\u2003 \u2003 307: Think of another pattern that is a specialization of the template method. In \nthis specialization, primitive operations are used to create and return objects. What pattern is this? 2", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 345", "position": 345, "chunk_type": "semantic", "token_estimate": 34}
{"text": "308\u2003 \u2003 Chapter 8: the paint hook\npublic class MyFrame extends JFrame {\n    public MyFrame(String title) {\n        super(title);\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        this.setSize(300,300);\n        this.setVisible(true);\n    }\n    public void paint(Graphics graphics) {\n        super.paint(graphics);\n        String msg = \"I rule!! \";\n        graphics.drawString(msg, 100, 100);\n    }\n    public static void main(String[] args) {\n        MyFrame myFrame = new MyFrame(\"Head First Design Patterns\");\n    }\n}\nSwingin\u2019 with Frames\nUp next on our Template Method safari...keep your eye out for swinging JFrames! If you haven\u2019t encountered JFrame, it\u2019s the most basic Swing container and inherits a \npaint() method. By default, paint() does nothing because it\u2019s a hook! By overriding paint(), \nyou can insert yourself into JFrame\u2019s algorithm for displaying its area of the screen and \nhave your own graphic output incorporated into the JFrame. Here\u2019s an embarrassingly \nsimple example of using a JFrame to override the paint() hook method:\nWe\u2019re extending JFrame, which contains a \nmethod update() that controls the algorithm \nfor updating the screen. We can hook into that \nalgorithm by overriding the paint() hook method. JFrame\u2019s update algorithm calls paint(). By \ndefault, paint() draws nothing...it\u2019s a hook. We\u2019re overriding paint() and telling the \nJFrame to draw a message in the window. Here\u2019s the message that gets \npainted in the frame because we\u2019ve \nhooked into the paint() method. Don\u2019t look behind the \ncurtain! Just some \ninitialization here...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 346", "position": 346, "chunk_type": "semantic", "token_estimate": 215}
{"text": "you are here 4\u2003 \u2003 309: the template method pattern\nCustom Lists with AbstractList\nOur final stop on the safari: AbstractList. The list collections in Java, like ArrayList and LinkedList, \nextend the AbstractList class, which provides some of the \nbasic implementations for list behavior. If you want to \ncreate your own custom list\u2014say, a list that contains only \nStrings\u2014you can do that by extending AbstractList so \nyou get that basic list behavior for free. AbstractList has a template method, subList(), that relies \non two abstract methods, get() and size(). So when you \nextend AbstractList to create your own custom list, you\u2019ll \nprovide implementations for these methods. Here\u2019s an implementation of a custom list that contains \nonly String objects, and uses arrays for the underlying \nimplementation: \nCreate a sublist of one item starting at \nindex 2...the Rubber Duck, of course. We create a custom list by \nextending AbstractList. subList()\nget(int)\nsize()\niterator()\nhashCode()\n// other methods\nAbstractList\nget(int)\nsize()\nMyList\nget(3);\nsize();\npublic class MyStringList extends AbstractList<String> {\n\t\nprivate String[] myList;\n\t\nMyStringList(String[] strings) {\n\t\n\t\nmyList = strings;\n\t\n}\n\t\npublic String get(int index) {\n\t\n\t\nreturn myList[index];\n\t\n}\n\t\npublic int size() {\n\t\n\t\nreturn myList.length;\n\t\n}\n\t\npublic String set(int index, String item) {\n\t\n\t\nString oldString = myList[index];\n\t\n\t\nmyList[index] = item;\n\t\n\t\nreturn oldString;\n\t\n}\n}\nString[] ducks = { \"Mallard Duck\", \"Redhead Duck\", \"Rubber Duck\", \"Decoy Duck\"};\nMyStringList ducksList = new MyStringList(ducks);\nList ducksSubList = ducksList.subList(2, 3);\nTest the subList() template method in your MyStringList implementation like this:\nWe must implement the methods get() \nand size(), which are both used by \nthe template method subList(). We also implement a method set() \nso we can modify the list.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 347", "position": 347, "chunk_type": "semantic", "token_estimate": 271}
{"text": "310\u2003 \u2003 Chapter 8: fireside chats: template method and strategy\nTonight\u2019s talk: Template Method and Strategy \ncompare methods. Template Method:\nHey Strategy, what are you doing in my chapter? I figured I\u2019d get stuck with someone boring like \nFactory Method. I was just kidding! But seriously, what are you doing \nhere? We haven\u2019t heard from you in seven chapters! You might want to remind the reader what you\u2019re \nall about, since it\u2019s been so long. Hey, that does sound a lot like what I do. But my \nintent\u2019s a little different from yours; my job is to \ndefine the outline of an algorithm, but let my \nsubclasses do some of the work. That way, I can \nhave different implementations of an algorithm\u2019s \nindividual steps, but keep control over the \nalgorithm\u2019s structure. Seems like you have to give up \ncontrol of your algorithms. Strategy:\n\n\n\n\n\nNope, it\u2019s me, although be careful\u2014you and Factory \nMethod are related, aren\u2019t you? I\u2019d heard you were on the final draft of your chapter \nand I thought I\u2019d swing by to see how it was going. We have a lot in common, so I thought I might be \nable to help... I don\u2019t know, since Chapter 1, people have been \nstopping me in the street saying, \u201cAren\u2019t you that \npattern...?\u201d So I think they know who I am. But \nfor your sake: I define a family of algorithms and \nmake them interchangeable. Since each algorithm is \nencapsulated, the client can use different algorithms \neasily. I\u2019m not sure I\u2019d put it quite like that...and anyway, \nI\u2019m not stuck using inheritance for algorithm \nimplementations. I offer clients a choice of \nalgorithm implementation through object \ncomposition. Hey, I heard that! Factory Method", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 348", "position": 348, "chunk_type": "semantic", "token_estimate": 281}
{"text": "you are here 4\u2003 \u2003 311: the template method pattern\nTemplate Method:\nI remember that. But I have more control over \nmy algorithm and I don\u2019t duplicate code. In fact, \nif every part of my algorithm is the same except \nfor, say, one line, then my classes are much more \nefficient than yours. All my duplicated code gets put \ninto the superclass, so all the subclasses can share it. Yeah, well, I\u2019m real happy for ya, but don\u2019t forget \nI\u2019m the most used pattern around. Why? Because I \nprovide a fundamental method for code reuse that \nallows subclasses to specify behavior. I\u2019m sure you \ncan see that this is perfect for creating frameworks. How\u2019s that? My superclass is abstract. Like I said, Strategy, I\u2019m real happy for you. Thanks \nfor stopping by, but I\u2019ve got to get the rest of this \nchapter done. Got it. Don\u2019t call us, we\u2019ll call you...\nStrategy:\n\n\n\n\n\nYou might be a little more efficient (just a little) and \nrequire fewer objects. And you might also be a little \nless complicated in comparison to my delegation \nmodel, but I\u2019m more flexible because I use object \ncomposition. With me, clients can change their \nalgorithms at runtime simply by using a different \nstrategy object. Come on, they didn\u2019t choose me for \nChapter 1 for nothing! Yeah, I guess...but what about dependency? You\u2019re \nway more dependent than me. But you have to depend on methods implemented \nin your subclasses, which are part of your algorithm. I don\u2019t depend on anyone; I can do the entire \nalgorithm myself! Okay, okay, don\u2019t get touchy. I\u2019ll let you work, but let \nme know if you need my special techniques anyway; \nI\u2019m always glad to help.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 349", "position": 349, "chunk_type": "semantic", "token_estimate": 282}
{"text": "312\u2003 \u2003 Chapter 8: crossword puzzle\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nAcross\n1. Huey, Louie and Dewey all weigh ________ \npounds\n2. The template method is usually defined in an \n___________ class\n4. In this chapter we gave you more \n_____________\n7. The steps in the algorithm that must be \nsupplied by the subclasses are usually \ndeclared ___________\n11. The JFrame hook method that we overrode \nto print \"I Rule\"\n12. _____List has a subList template method\n13. Type of sort used in Arrays\n14. The Template Method Pattern uses \n____________ to defer implementation to \nDown\n1. Coffee and _____\n3. Factory Method is a _______________ of \nTemplate Method\n5. A template method defines the steps of an \n____________\n6. Big headed pattern\n8. _________ algorithm steps are implemented \nby hook methods\n9. Our favorite coffee shop in Objectville\n10. The Arrays class implements its template \nmethod as a _________ method\n15. A method in the abstract superclass that \ndoes nothing or provides default behavior is \ncalled a _________ method\nDesign Patterns Crossword\nIt\u2019s that time again...", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 350", "position": 350, "chunk_type": "semantic", "token_estimate": 187}
{"text": "1. Huey, Louie, and Dewey all weigh __________ pounds.: 2. The template method is usually defined in an _______ \nclass. 4. In this chapter we gave you more _________. 7. The steps in the algorithm that must be supplied by the \nsubclasses are usually declared ___________. 11. The JFrame hook method that we overrode to print \u201cI \nrule! !\u201d\n12. ___________ has a subList() template method. 13. Type of sort used in Arrays. 14. The Template Method Pattern uses _____________ \nto defer implementation to other classes. 15. \u201cDon\u2019t call us, we\u2019ll call you\u201d is known as the \n_________ Principle.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 350", "position": 350, "chunk_type": "semantic", "token_estimate": 99}
{"text": "1. Coffee and ______.: 3. Factory Method is a __________ of Template Method. 5. A template method defines the steps of an ________. 6. Big-headed pattern. 8. _______ algorithm steps are implemented by hook \nmethods. 9. Our favorite coffee shop in Objectville. 10. The Arrays class implements its template method as \na ______ method. 15. A method in the abstract superclass that does nothing \nor provides default behavior is called a ____________  \nmethod.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 350", "position": 350, "chunk_type": "semantic", "token_estimate": 73}
{"text": "you are here 4\u2003 \u2003 313: the template method pattern\nTools for your Design Toolbox\nWe\u2019ve added Template Method to your toolbox. With Template Method, you can reuse code like a \npro while keeping control of your algorithms. Abstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nEncapsulate what varies. Favor composition over inheritance. Program to interfaces, not \nimplementations. Strive for loosely coupled designs \nbetween objects that interact. Classes should be open for extension \nbut closed for modification. Depend on abstractions. Do not \ndepend on concrete classes. T\nalk only to your friends. Don\u2019t call us, we\u2019ll call you. OO Principles\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it. OO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically. Decorators provide a flexible \nalternative to subclassing for extending \nfunctionality. Abstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes. Factory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate. Factory Method lets \na class defer instantiation to the \nsubclasses. Singleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it. Command - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Adapter - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Our newest principle \nreminds you that your \nsuperclasses are running \nthe show, so let them call \nyour subclass methods when \nthey\u2019re needed, just like \nthey do in Hollywood. Facade - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. And our newest \npattern lets classes \nimplementing an \nalgorithm defer some \nsteps to subclasses. T\nemplate Method - Define the \nskeleton of an algorithm in an operation, \ndeferring some steps to subclasses. T\nemplate Method lets subclasses redefine \ncertain steps of an algorithm without \nchanging the algorithm\u2019s structure. \u0083\nA template method defines the \nsteps of an algorithm, deferring to \nsubclasses for the implementation \nof those steps.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 351", "position": 351, "chunk_type": "semantic", "token_estimate": 398}
{"text": "you are here 4\u2003 \u2003 313: T\nemplate Method lets subclasses redefine \ncertain steps of an algorithm without \nchanging the algorithm\u2019s structure. \u0083\nA template method defines the \nsteps of an algorithm, deferring to \nsubclasses for the implementation \nof those steps. \u0083\nThe Template Method Pattern \ngives us an important technique \nfor code reuse. \u0083\nThe template method\u2019s abstract \nclass may define concrete \nmethods, abstract methods, and \nhooks. \u0083\nAbstract methods are \nimplemented by subclasses. \u0083\nHooks are methods that do \nnothing or default behavior in \nthe abstract class, but may be \noverridden in the subclass. \u0083\nTo prevent subclasses from \nchanging the algorithm in the \ntemplate method, declare the \ntemplate method as final. \u0083\nThe Hollywood Principle guides us \nto put decision making in high-\nlevel modules that can decide \nhow and when to call low-level \nmodules. \u0083\nYou\u2019ll see lots of uses of the \nTemplate Method Pattern in \nreal-world code, but (as with any \npattern) don\u2019t expect it all to be \ndesigned \u201cby the book.\u201d\n\t\n\u0083\nThe Strategy and Template \nMethod Patterns both encapsulate \nalgorithms, the first by composition \nand the other by inheritance. \u0083\nFactory Method is a specialization \nof Template Method.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 351", "position": 351, "chunk_type": "semantic", "token_estimate": 194}
{"text": "314\u2003 \u2003 Chapter 8: exercise solutions\nDraw the new class diagram now that we\u2019ve moved \nprepareRecipe() into the CaffeineBeverage class:\nMatch each pattern with its description:\nSOlUTion\nPattern\nDescription\nTemplate Method\nStrategy\nFactory Method\nEncapsulate interchangable \nbehaviors and use delegation to \ndecide which behavior to use. Subclasses decide how to \nimplement steps in an algorithm. Subclasses decide which \nconcrete classes to create. prepareRecipe()\nboilWater()\npourInCup()\nbrew()\naddCondiments()\nCaffeineBeverage\nbrew()\naddCondiments()\nCoffee\nbrew()\naddCondiments()\nTea", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 352", "position": 352, "chunk_type": "semantic", "token_estimate": 73}
{"text": "you are here 4\u2003 \u2003 315: the template method pattern\nDesign Patterns Crossword Solution\nIt\u2019s that time again...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 353", "position": 353, "chunk_type": "semantic", "token_estimate": 17}
{"text": "Across: 1. Huey, Louie and Dewey all weigh ________ \npounds [TWO] \n2. The template method is usually defined in an \n___________ class [ABSTRACT] \n4. In this chapter we gave you more \n_____________ [CAFFEINE] \n7. The steps in the algorithm that must be \nsupplied by the subclasses are usually \ndeclared ___________ [ABSTRACT] \n11. The JFrame hook method that we overrode \nto print \"I Rule\" [PAINT] \n12. _____List has a subList template method \n[ABSTRACTLIST] \n13 Type of sort used in Arrays [MERGESORT]\nDown\n1. Coffee and _____ [TEA] \n3. Factory Method is a _______________ of \nTemplate Method [SPECIALIZATION] \n5. A template method defines the steps of an \n____________ [ALGORITHM] \n6. Big headed pattern [STRATEGY] \n8. _________ algorithm steps are implemented \nby hook methods [OPTIONAL] \n9. Our favorite coffee shop in Objectville \n[STARBUZZ] \n10. The Arrays class implements its template \nmethod as a _________ method [STATIC] \n15. A method in the abstract superclass that \ndoes nothing or provides default behavior is", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 353", "position": 353, "chunk_type": "semantic", "token_estimate": 158}
{"text": "this is a new chapter\u2003 \u2003 317: There are lots of ways to stuff objects into a collection. Put them into an Array, a Stack, a List, a hash map\u2014take your pick. Each has its \nown advantages and tradeoffs. But at some point your clients are going to want \nto iterate over those objects, and when they do, are you going to show them your \nimplementation? We certainly hope not! That just wouldn\u2019t be professional. Well, you \ndon\u2019t have to risk your career; in this chapter you\u2019re going to see how you can allow \nyour clients to iterate through your objects without ever getting a peek at how you store \nyour objects. You\u2019re also going to learn how to create some super collections of objects \nthat can leap over some impressive data structures in a single bound. And if that\u2019s not \nenough, you\u2019re also going to learn a thing or two about object responsibility. 9  the Iterator and Composite Patterns\nWell-Managed\n          Collections\nYou bet I keep \nmy collections well \nencapsulated!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 355", "position": 355, "chunk_type": "semantic", "token_estimate": 169}
{"text": "you are here 4\u2003 \u2003 319: the iterator and composite patterns\npublic class MenuItem {\n    String name;\n    String description;\n    boolean vegetarian;\n    double price;\n \n    public MenuItem(String name, \n                    String description, \n                    boolean vegetarian, \n                    double price) \n    {\n        this.name = name;\n        this.description = description;\n        this.vegetarian = vegetarian;\n        this.price = price;\n    }\n  \n    public String getName() {\n        return name;\n    }\n  \n    public String getDescription() {\n        return description;\n    }\n  \n    public double getPrice() {\n        return price;\n    }\n  \n    public boolean isVegetarian() {\n        return vegetarian;\n    }\n}\nCheck out the Menu Items\nObjectville Diner\nVegetarian BLT                                                                          2.99\n        (Fakin\u2019) Bacon with lettuce & tomato on \n        whole wheat\nBLT                                                                                                      2.99\n        Bacon with lettuce & tomato on whole wheat\nSoup of the day                                                                        3.29\n        A bowl of the soup of the day, with \n        a side of potato salad\nHot Dog                                                                                       3.05\n        A hot dog, with sauerkraut, relish, onions, \n        topped with cheese\nSteamed Veggies and Brown Rice                           3.99\n        A medley of steamed vegetables over brown rice\nK&B\u2019s Pancake Breakfast                                           2.99\n        Pancakes with scrambled eggs and toast \nRegular Pancake Breakfast                                     2.99\n        Pancakes with fried eggs, sausage\nBlueberry Pancakes                                                      3.49\n        Pancakes made with fresh blueberries, \n        and blueberry syrup\nWaffles                                                                                   3.59\n        Waffles with your choice of blueberries \n        or strawberries\nObjectville Pancake House\nA MenuItem consists of a name, a description, \na flag to indicate if the item is vegetarian, \nand a price. You pass all these values into the \nconstructor to initialize the MenuItem. These getter methods let you access \nthe fields of the menu item. At least Lou and Mel agree on the \nimplementation of the MenuItems. Let\u2019s \ncheck out the items on each menu, and \nalso take a look at the implementation. The Diner menu has lots of lunch \nitems, while the Pancake House \nconsists of breakfast items. Every menu item has a name, a \ndescription, and a price.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 357", "position": 357, "chunk_type": "semantic", "token_estimate": 291}
{"text": "you are here 4\u2003 \u2003 321: the iterator and composite patterns\npublic class DinerMenu {\n    static final int MAX_ITEMS = 6;\n    int numberOfItems = 0;\n    MenuItem[] menuItems;\n  \n    public DinerMenu() {\n        menuItems = new MenuItem[MAX_ITEMS];\n \n        addItem(\"Vegetarian BLT\",\n            \"(Fakin') Bacon with lettuce & tomato on whole wheat\", true, 2.99);\n        addItem(\"BLT\",\n            \"Bacon with lettuce & tomato on whole wheat\", false, 2.99);\n        addItem(\"Soup of the day\",\n            \"Soup of the day, with a side of potato salad\", false, 3.29);\n        addItem(\"Hotdog\",\n            \"A hot dog, with sauerkraut, relish, onions, topped with cheese\",\n            false, 3.05);\n        // a couple of other Diner Menu items added here\n    }\n  \n    public void addItem(String name, String description, \n                         boolean vegetarian, double price) \n    {\n        MenuItem menuItem = new MenuItem(name, description, vegetarian, price);\n        if (numberOfItems >= MAX_ITEMS) {\n            System.err.println(\"Sorry, menu is full! Can't add item to menu\");\n        } else {\n            menuItems[numberOfItems] = menuItem;\n            numberOfItems = numberOfItems + 1;\n        }\n    }\n \n    public MenuItem[] getMenuItems() {\n        return menuItems;\n    }\n \n    // other menu methods here\n}\nAnd here\u2019s Mel\u2019s implementation of the Diner menu. Mel takes a different approach; he\u2019s using an Array \nclass so he can control the max size of the menu. Like Lou, Mel creates his menu items in the \nconstructor, using the addItem() helper method. addItem() takes all the parameters \nnecessary to create a MenuItem and \ninstantiates one. It also checks to make \nsure we haven\u2019t hit the menu size limit. Like Lou, Mel has a bunch of code that depends on the implementation \nof his menu being an Array. He\u2019s too busy cooking to rewrite all of this. Mel specifically wants to keep his menu \nunder a certain size (presumably so he \ndoesn\u2019t have to remember too many recipes). getMenuItems() returns the array of menu items. Haah! An ArrayList...I used a \nREAL Array so I can control the \nmaximum size of my menu.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 359", "position": 359, "chunk_type": "semantic", "token_estimate": 298}
{"text": "322\u2003 \u2003 Chapter 9: java-enabled waitress\nTo see why having two different menu representations complicates \nthings, let\u2019s try implementing a client that uses the two menus. Imagine you have been hired by the new company formed by the \nmerger of the Diner and the Pancake House to create a Java-enabled \nwaitress (this is Objectville, after all). The spec for the Java-enabled \nwaitress specifies that she can print a custom menu for customers on \ndemand, and even tell you if a menu item is vegetarian without having \nto ask the cook\u2014now that\u2019s an innovation! Let\u2019s check out the spec for the waitress, and then step through what it \nmight take to implement her...\nWhat\u2019s the problem with having two different \nmenu representations? The Waitress is getting \nJava-enabled. The Java-Enabled Waitress Specification\nJava-Enabled Waitress: code-name \"Alice\"\nprintMenu()\n   - prints every item on the breakfast and\n     lunch menus\nprintBreakfastMenu()\n   - prints just breakfast items\nprintLunchMenu()\n   - prints just lunch items\nprintVegetarianMenu()\n   - prints all vegetarian menu items\nisItemVegetarian(name)\n   - given the name of an item, returns true\n     if the items is vegetarian, otherwise,\n     returns false\nThe spec for \nthe Waitress", "domains": ["Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 360", "position": 360, "chunk_type": "semantic", "token_estimate": 186}
{"text": "you are here 4\u2003 \u2003 323: the iterator and composite patterns\n1\n3\n2\nTo print all the items on each menu, you\u2019ll need to call the getMenuItems() \nmethod on the PancakeHouseMenu and the DinerMenu to retrieve their \nrespective menu items. Note that each returns a different type:\nPancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();\nArrayList<MenuItem> breakfastItems = pancakeHouseMenu.getMenuItems();\nDinerMenu dinerMenu = new DinerMenu();\nMenuItem[] lunchItems = dinerMenu.getMenuItems();\nNow, to print out the items from the PancakeHouseMenu, we\u2019ll loop through the \nitems on the breakfastItems ArrayList. And to print out the Diner items, we\u2019ll loop \nthrough the Array. Implementing every other method in the Waitress is going to be a variation of \nthis theme. We\u2019re always going to need to get both menus and use two loops to \niterate through their items. If another restaurant with a different implementation \nis acquired, then we\u2019ll have three loops. for (int i = 0; i < breakfastItems.size(); i++) {\n    MenuItem menuItem = breakfastItems.get(i);\n    System.out.print(menuItem.getName() + \" \");\n    System.out.println(menuItem.getPrice() + \" \");\n    System.out.println(menuItem.getDescription());\n}\nfor (int i = 0; i < lunchItems.length; i++) {\n    MenuItem menuItem = lunchItems[i];\n    System.out.print(menuItem.getName() + \" \");\n    System.out.println(menuItem.getPrice() + \" \");\n    System.out.println(menuItem.getDescription());\n}\nThe method looks \nthe same, but the \ncalls are returning \ndifferent types. Now, we have to \nimplement two \ndifferent loops to \nstep through the two \nimplementations of the \nmenu items...\n...one loop for the \nArrayList...\n...and another for \nthe Array. The implementation is showing \nthrough: breakfast items are \nin an ArrayList, and lunch \nitems are in an Array. Let\u2019s start by stepping through how we\u2019d implement the printMenu() method:\nImplementing the spec: our first attempt", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 361", "position": 361, "chunk_type": "semantic", "token_estimate": 266}
{"text": "324\u2003 \u2003 Chapter 9: what\u2019s the goal\n\u274f   A. We are coding to the \nPancakeHouseMenu and DinerMenu \nconcrete implementations, not to an \ninterface. \u274f   B. The Waitress doesn\u2019t implement the \nJava Waitress API and so she isn\u2019t \nadhering to a standard. \u274f   C.\t If we decided to switch from using \nDinerMenu to another type of menu \nthat implemented its list of menu items \nwith a hash table, we\u2019d have to modify \na lot of code in the Waitress. \u274f   D.\t The Waitress needs to know how each \nmenu represents its internal collection of \nmenu items; this violates encapsulation. \u274f   E.\t We have duplicate code: the printMenu() \nmethod needs two separate loops to \niterate over the two different kinds of \nmenus. And if we added a third menu, \nwe\u2019d have yet another loop. \u274f   F.\t The implementation isn\u2019t based on \nMXML (Menu XML) and so isn\u2019t as \ninteroperable as it should be. Mel and Lou are putting us in a difficult position. They don\u2019t want to change their \nimplementations because it would mean rewriting a lot of code that is in each respective \nmenu class. But if one of them doesn\u2019t give in, then we\u2019re going to have the job of \nimplementing a Waitress that will be hard to maintain and extend. It would really be nice if we could find a way to allow them to implement the same \ninterface for their menus (they\u2019re already close, except for the return type of the \ngetMenuItems() method). That way we can minimize the concrete references in the \nWaitress code and also hopefully get rid of the multiple loops required to iterate over \nboth menus. Sound good? Well, how are we going to do that? What now? Based on our implementation of printMenu(), which of the following apply?", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 362", "position": 362, "chunk_type": "semantic", "token_estimate": 294}
{"text": "you are here 4\u2003 \u2003 325: the iterator and composite patterns\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArrayList\nAn ArrayList \nof MenuItems\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArray\nAn Array of \nMenuItems. for (int i = 0; i < breakfastItems.size(); i++) {\n    MenuItem menuItem = breakfastItems.get(i);\n}\nfor (int i = 0; i < lunchItems.length; i++) {\n    MenuItem menuItem = lunchItems[i];\n}\nCan we encapsulate the iteration? If we\u2019ve learned one thing in this book, it\u2019s to encapsulate what varies. It\u2019s \nobvious what is changing here: the iteration caused by different collections of \nobjects being returned from the menus. But can we encapsulate this? Let\u2019s work \nthrough the idea...\n1\nTo iterate through the breakfast items, we use the size() and get() \nmethods on the ArrayList:\n2\nAnd to iterate through the lunch items we use the Array length field and \nthe array subscript notation on the MenuItem Array. lunchItems[0]\nlunchItems[1]\nlunchItems[2]\nlunchItems[3]\nget(0)\nget(1)\nget(2)\nget(3)\nget() helps us step \nthrough each item. We use the array \nsubscripts to step \nthrough items.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 363", "position": 363, "chunk_type": "semantic", "token_estimate": 225}
{"text": "326\u2003 \u2003 Chapter 9: 3\nNow what if we create an object, let\u2019s call it an Iterator, \nthat encapsulates the way we iterate through a \ncollection of objects? Let\u2019s try this on the ArrayList:\nIterator iterator = breakfastMenu.createIterator();\nwhile (iterator.hasNext()) {\n    MenuItem menuItem = iterator.next();\n}\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArrayList\n \n \n \n \n \n \n \n \n \nI\nt\ne\nr\na\nt\no\nr\nWe ask the breakfastMenu \nfor an iterator of its \nMenuItems. And while there are more items left...\n...we get the next item. 4\nLet\u2019s try that on the Array too:\nIterator iterator = lunchMenu.createIterator();\nwhile (iterator.hasNext()) {\n    MenuItem menuItem = iterator.next();\n}\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArray\nlunchItems[0]\nlunchItems[1]\nlunchItems[2]\nlunchItems[3]\n \n \n \n \n \n \n \n \n \nI\nt\ne\nr\na\nt\no\nr\nThe client just calls hasNext() \nand next(); behind the scenes the \niterator calls get() on the ArrayList. Same situation here: the client just calls \nhasNext() and next(); behind the scenes, \nthe iterator indexes into the Array. Wow, this code \nis exactly the \nsame as the \nbreakfastMenu \ncode. get(0)\nget(1)\nget(2)\nget(3)\nnext()\nnext()\nencapsulating iteration", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 364", "position": 364, "chunk_type": "semantic", "token_estimate": 228}
{"text": "you are here 4\u2003 \u2003 327: the iterator and composite patterns\nMeet the Iterator Pattern\nWell, it looks like our plan of encapsulating iteration just might \nactually work; and as you\u2019ve probably already guessed, it is a \nDesign Pattern called the Iterator Pattern. The first thing you need to know about the Iterator Pattern is that \nit relies on an interface called Iterator. Here\u2019s one possible Iterator \ninterface:\nhasNext()\nnext()\n<<interface>>\nIterator\nThe hasNext() method \ntells us if there are \nmore elements in the \naggregate to iterate \nthrough. The next() method \nreturns the next \nobject in the \naggregate. Now, once we have this interface, we can implement Iterators for \nany kind of collection of objects: arrays, lists, hash maps\u2009...\u2009pick your \nfavorite collection of objects. Let\u2019s say we wanted to implement the \nIterator for the Array used in the DinerMenu. It would look like this:\nDinerMenuIterator is an \nimplementation of Iterator \nthat knows how to iterate \nover an array of MenuItems. hasNext()\nnext()\n<<interface>>\nIterator\nhasNext()\nnext()\nDinerMenuIterator\nLet\u2019s go ahead and implement this Iterator and incorporate it into \nDinerMenu to see how this works... When we say \nCOLLECTION we just mean a group \nof objects. They might be stored in \nvery different data structures like lists, \narrays, or hash maps, but they\u2019re still \ncollections. We also sometimes call \nthese AGGREGATES.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 365", "position": 365, "chunk_type": "semantic", "token_estimate": 221}
{"text": "328\u2003 \u2003 Chapter 9: public interface Iterator {\n    boolean hasNext();\n    MenuItem next();\n}\npublic class DinerMenuIterator implements Iterator {\n    MenuItem[] items;\n    int position = 0;\n \n    public DinerMenuIterator(MenuItem[] items) {\n        this.items = items;\n    }\n \n    public MenuItem next() {\n        MenuItem menuItem = items[position];\n        position = position + 1;\n        return menuItem;\n    }\n \n    public boolean hasNext() {\n        if (position >= items.length || items[position] == null) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\nAdding an Iterator to DinerMenu\nHere are our two methods:\nThe hasNext() method returns a boolean \nindicating whether or not there are \nmore elements to iterate over...\nTo add an iterator to the DinerMenu, we first need to define the Iterator interface:\n...and the next() method \nreturns the next element. And now we need to implement a concrete Iterator that works for the Diner menu:\nWe implement the \nIterator interface. The constructor takes the \narray of menu items we are \ngoing to iterate over. position maintains the \ncurrent position of the \niteration over the array. The next() method returns the \nnext item in the array and \nincrements the position. The hasNext() method checks to see \nif we\u2019ve seen all the elements of the \narray and returns true if there are \nmore to iterate through. Because the diner chef went ahead and \nallocated a max sized array, we need to \ncheck not only if we are at the end of \nthe array, but also if the next item is null, \nwhich indicates there are no more items. using iterator", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 366", "position": 366, "chunk_type": "semantic", "token_estimate": 249}
{"text": "you are here 4\u2003 \u2003 329: the iterator and composite patterns\npublic class DinerMenu {\n    static final int MAX_ITEMS = 6;\n    int numberOfItems = 0;\n    MenuItem[] menuItems;\n  \n    // constructor here\n  \n    // addItem here\n \n    public MenuItem[] getMenuItems() {\n        return menuItems;\n    }\n  \n    public Iterator createIterator() {\n        return new DinerMenuIterator(menuItems);\n    }\n \n    // other menu methods here\n}\nReworking the DinerMenu with Iterator\nOkay, we\u2019ve got the iterator. Time to work it into the DinerMenu; all we need to do is \nadd one method to create a DinerMenuIterator and return it to the client:\nWe\u2019re not going to need the getMenuItems() \nmethod anymore; in fact, we don\u2019t want it \nbecause it exposes our internal implementation! Here\u2019s the createIterator() method. It creates a DinerMenuIterator \nfrom the menuItems array and \nreturns it to the client. We\u2019re returning the Iterator interface. The client \ndoesn\u2019t need to know how the MenuItems are maintained \nin the DinerMenu, nor does it need to know how the \nDinerMenuIterator is implemented. It just needs to use \nthe iterators to step through the items in the menu. Go ahead and implement the PancakeHouseIterator yourself and make the changes \nneeded to incorporate it into the PancakeHouseMenu.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 367", "position": 367, "chunk_type": "semantic", "token_estimate": 191}
{"text": "330\u2003 \u2003 Chapter 9: public class Waitress {\n    PancakeHouseMenu pancakeHouseMenu;\n    DinerMenu dinerMenu;\n \n    public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) {\n        this.pancakeHouseMenu = pancakeHouseMenu;\n        this.dinerMenu = dinerMenu;\n    }\n \n    public void printMenu() {\n        Iterator pancakeIterator = pancakeHouseMenu.createIterator();\n        Iterator dinerIterator = dinerMenu.createIterator();\n        System.out.println(\"MENU\\n----\\nBREAKFAST\");\n        printMenu(pancakeIterator);\n        System.out.println(\"\\nLUNCH\");\n        printMenu(dinerIterator);\n    }\n \n    private void printMenu(Iterator iterator) {\n        while (iterator.hasNext()) {\n            MenuItem menuItem = iterator.next();\n            System.out.print(menuItem.getName() + \", \");\n            System.out.print(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n \n    // other methods here\n}\nFixing up the Waitress code\nIn the constructor the Waitress \nclass takes the two menus. The printMenu() \nmethod now creates \ntwo iterators, one for \neach menu...\n...and then calls the \noverloaded printMenu() \nwith each iterator. The overloaded \nprintMenu() \nmethod uses \nthe Iterator to \nstep through \nthe menu items \nand print them. Note that we\u2019re down \nto one loop. T\nest if there are \nany more items. Get the \nnext item. Use the item to \nget name, price, \nand description \nand print them. Now we need to integrate the iterator code into the \nWaitress class. We should be able to get rid of some \nof the redundancy in the process. Integration is pretty \nstraightforward: first we create a printMenu() method \nthat takes an Iterator; then we use the createIterator() \nmethod on each menu to retrieve the Iterator and \npass it to the new method. New and \nimproved with \nIterator. fixing the waitress", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 368", "position": 368, "chunk_type": "semantic", "token_estimate": 221}
{"text": "you are here 4\u2003 \u2003 331: the iterator and composite patterns\npublic class MenuTestDrive {\n    public static void main(String args[]) {\n        PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();\n        DinerMenu dinerMenu = new DinerMenu();\n \n        Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu);\n \n        waitress.printMenu();\n    }\n}\nTesting our code\nFile  Edit   Window  Help   \n% java DinerMenuTestDrive", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 369", "position": 369, "chunk_type": "semantic", "token_estimate": 49}
{"text": "332\u2003 \u2003 Chapter 9: What have we done so far? Woohoo! No code \nchanges other \nthan adding the \ncreateIterator() method. Veggie burger\nFor starters, we\u2019ve made our Objectville cooks \nvery happy. They settled their differences and \nkept their own implementations. Once we gave \nthem a PancakeHouseMenuIterator and a \nDinerMenuIterator, all they had to do was add a \ncreateIterator() method and they were finished. We\u2019ve also helped ourselves in the process. The \nWaitress will be much easier to maintain and \nextend down the road. Let\u2019s go through exactly \nwhat we did and think about the consequences:\nHard-to-Maintain \nWaitress Implementation\nNew, Hip \nWaitress Powered by Iterator\nThe Menus are not well \nencapsulated; we can see the \nDiner is using an ArrayList and the \nPancake House an Array. The Waitress is bound to concrete \nclasses (MenuItem[] and ArrayList). The Waitress now uses an interface \n(Iterator). We need two loops to iterate through \nthe MenuItems. All we need is a loop that \npolymorphically handles any \ncollection of items as long as it \nimplements Iterator. The Menu implementations are now \nencapsulated. The Waitress has \nno idea how the Menus hold their \ncollection of menu items. The Waitress is bound to two different \nconcrete Menu classes, despite their \ninterfaces being almost identical. The Menu interfaces are now exactly \nthe same and, uh oh, we still don\u2019t \nhave a common interface, which \nmeans the Waitress is still bound to \ntwo concrete Menu classes. We\u2019d \nbetter fix that. comparing our implementations", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 370", "position": 370, "chunk_type": "semantic", "token_estimate": 242}
{"text": "you are here 4\u2003 \u2003 333: the iterator and composite patterns\nhasNext()\nnext()\n<<interface>>\nIterator\nBefore we clean things up, let\u2019s get a bird\u2019s-eye view of our current design. Note that the iterator gives us a way to \nstep through the elements of an aggregate \nwithout forcing the aggregate to clutter its \nown interface with a bunch of methods to \nsupport traversal of its elements. It also allows \nthe implementation of the iterator to live \noutside of the aggregate; in other words, we\u2019ve \nencapsulated the iteration. PancakeHouseMenu and DinerMenu \nimplement the new createIterator() \nmethod; they are responsible for creating \nthe iterator for their respective menu \nitems\u2019 implementations. printMenu()\nWaitress\ncreateIterator()\nPancakeHouseMenu\nmenuItems\ncreateIterator()\nDinerMenu\nmenuItems\nhasNext()\nnext()\nDinerMenuIterator\nhasNext()\nnext()\nPancakeHouseMenuIterator\nReviewing our current design... These two menus implement the \nsame exact set of methods, but \nthey aren\u2019t implementing the same \ninterface. We\u2019re going to fix this \nand free the Waitress from any \ndependencies on concrete Menus. We\u2019re now using a \ncommon Iterator \ninterface \nand we\u2019ve \nimplemented two \nconcrete classes. The Iterator allows the Waitress to be decoupled \nfrom the actual implementation of the concrete \nclasses. She doesn\u2019t need to know if a Menu is \nimplemented with an Array, an ArrayList, or with \nPost-it  notes. All she cares about is that she can \nget an Iterator to do her iterating. \u00ae", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 371", "position": 371, "chunk_type": "semantic", "token_estimate": 220}
{"text": "334\u2003 \u2003 Chapter 9: Making some improvements... Okay, we know the interfaces of PancakeHouseMenu and DinerMenu are exactly the same \nand yet we haven\u2019t defined a common interface for them. So, we\u2019re going to do that and clean \nup the Waitress a little more. You may be wondering why we\u2019re not using the Java Iterator interface\u2014we did that so you \ncould see how to build an iterator from scratch. Now that we\u2019ve done that, we\u2019re going to \nswitch to using the Java Iterator interface, because we\u2019ll get a lot of leverage by implementing \nthat instead of our home-grown Iterator interface. What kind of leverage? You\u2019ll soon see. First, let\u2019s check out the java.util.Iterator interface: \nhasNext()\nnext()\nremove()\n<<interface>>\nIterator\nThis looks just like our previous definition...\n...except we have an additional method that \nallows us to remove the last item returned \nby the next() method from the aggregate. This is going to be a piece of cake: we just need to change the interface that both \nPancakeHouseMenuIterator and DinerMenuIterator extend, right? Almost...actually, it\u2019s even \neasier than that. Not only does java.util have its own Iterator interface, but ArrayList has an \niterator() method that returns an iterator. In other words, we never needed to implement our \nown iterator for ArrayList. However, we\u2019ll still need our implementation for the DinerMenu \nbecause it relies on an Array, which doesn\u2019t support the iterator() method. Q: What if I don\u2019t want to provide the ability to remove \nsomething from the underlying collection of objects? A: The remove() method is considered optional. You don\u2019t have \nto provide remove functionality. But you should provide the method \nbecause it\u2019s part of the Iterator interface. If you\u2019re not going to \nallow remove() in your iterator, you\u2019ll want to throw the runtime \nexception java.lang.UnsupportedOperationException. The Iterator \nAPI documentation specifies that this exception may be thrown \nfrom remove() and any client that is a good citizen will check for this \nexception when calling the remove() method. Q: How does remove() behave under multiple threads that \nmay be using different iterators over the same collection of \nobjects? A: The behavior of the remove() method is unspecified if the \ncollection changes while you are iterating over it. So you should be \ncareful in designing your own multithreaded code when accessing a \ncollection concurrently. using java\u2019s iterator", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 372", "position": 372, "chunk_type": "semantic", "token_estimate": 382}
{"text": "you are here 4\u2003 \u2003 335: the iterator and composite patterns\nimport java.util.Iterator;\n  \npublic class DinerMenuIterator implements Iterator<MenuItem> {\n    MenuItem[] items;\n    int position = 0;\n \n    public DinerMenuIterator(MenuItem[] items) {\n        this.items = items;\n    }\n \n    public MenuItem next() {\n        //implementation here\n    }\n \n    public boolean hasNext() {\n        //implementation here\n    }\n  \n    public void remove() {\n        throw new UnsupportedOperationException\n                    (\"You shouldn't be trying to remove menu items. \");\n    }\n}\nCleaning things up with java.util.Iterator\npublic Iterator<MenuItem> createIterator() {\n    return menuItems.iterator();\n}\nLet\u2019s start with the PancakeHouseMenu. Changing it over to \njava.util.Iterator is going to be easy. We just delete the \nPancakeHouseMenuIterator class, add an import java.util.Iterator \nto the top of PancakeHouseMenu, and change one line of the \nPancakeHouseMenu:\nInstead of creating our own iterator \nnow, we just call the iterator() \nmethod on the menuItems ArrayList \n(more on this in a bit). And that\u2019s it, PancakeHouseMenu is done. Now we need to make the changes to allow DinerMenu to work with java.util.Iterator. First we import java.util.Iterator, the \ninterface we\u2019re going to implement. None of our current \nimplementation changes... Remember, the remove() method is optional \nin the Iterator interface. Having our waitress \nremove menu items really doesn\u2019t make sense, \nso we\u2019ll just throw an exception if she tries.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 373", "position": 373, "chunk_type": "semantic", "token_estimate": 201}
{"text": "336\u2003 \u2003 Chapter 9: import java.util.Iterator;\n \npublic class Waitress {\n    Menu pancakeHouseMenu;\n    Menu dinerMenu;\n \n    public Waitress(Menu pancakeHouseMenu, Menu dinerMenu) {\n        this.pancakeHouseMenu = pancakeHouseMenu;\n        this.dinerMenu = dinerMenu;\n    }\n \n    public void printMenu() {\n        Iterator<MenuItem> pancakeIterator = pancakeHouseMenu.createIterator();\n        Iterator<MenuItem> dinerIterator = dinerMenu.createIterator();\n        System.out.println(\"MENU\\n----\\nBREAKFAST\");\n        printMenu(pancakeIterator);\n        System.out.println(\"\\nLUNCH\");\n        printMenu(dinerIterator);\n    }\n \n    private void printMenu(Iterator iterator) {\n        while (iterator.hasNext()) {\n            MenuItem menuItem = iterator.next();\n            System.out.print(menuItem.getName() + \", \");\n            System.out.print(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n \n    // other methods here\n}\nWe are almost there...\nNow we just need to give the Menus a common interface and rework the \nWaitress a little. The Menu interface is quite simple: we might want to add a \nfew more methods to it eventually, like addItem(), but for now we\u2019ll let the chefs \ncontrol their menus by keeping that method out of the public interface:\npublic interface Menu {\n    public Iterator<MenuItem> createIterator();\n}\nThis is a simple interface that \njust lets clients get an iterator \nfor the items in the menu. Now we need to add an implements Menu to both the PancakeHouseMenu \nand the DinerMenu class definitions and update the Waitress class:\nNow the Waitress uses the java.util.Iterator as well. We need to replace the \nconcrete Menu classes with \nthe Menu interface. Nothing changes \nhere. reworking the waitress", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 374", "position": 374, "chunk_type": "semantic", "token_estimate": 206}
{"text": "you are here 4\u2003 \u2003 337: the iterator and composite patterns\nThe PancakeHouseMenu and DinerMenu classes implement an interface, \nMenu. This allows the Waitress to refer to each menu object using the interface \nrather than the concrete class. So, we\u2019re reducing the dependency between \nthe Waitress and the concrete classes by \u201cprogramming to an interface, not an \nimplementation.\u201d\nAlso, the new Menu interface has one method, createIterator(), that is \nimplemented by PancakeHouseMenu and DinerMenu. Each menu class \nassumes the responsibility of creating a concrete Iterator that is appropriate for \nits internal implementation of the menu items. printMenu()\nWaitress\ncreateIterator()\nPancakeHouseMenu\nmenuItems\ncreateIterator()\nDinerMenu\nmenuItems\nhasNext()\nnext()\nremove()\n<<interface>>\nIterator\nHere\u2019s our new Menu interface. It specifies the new method, \ncreateIterator(). Now, Waitress \nonly needs to \nbe concerned \nwith Menus and \nIterators. We\u2019ve decoupled Waitress from the \nimplementation of the menus, so now \nwe can use an Iterator to iterate \nover any list of menu items without \nhaving to know about how the list of \nitems is implemented. PancakeHouseMenu and DinerMenu now \nimplement the Menu interface, which \nmeans they need to implement the new \ncreateIterator() method. DinerMenu returns \na DinerMenuIterator \nfrom its \ncreateIterator() \nmethod because \nthat\u2019s the kind of \niterator required \nto iterate over its \nArray of menu items. Each concrete Menu is responsible \nfor creating the appropriate \nconcrete Iterator class. What does this get us? This solves the problem \nof the Waitress \ndepending on the \nconcrete Menus. createIterator()\n<<interface>>\nMenu\ncreateIterator()\nhasNext()\nnext()\nremove()\nPancakeHouseMenuIterator\nhasNext()\nnext()\nremove()\nDinerMenuIterator\nWe\u2019re now using the \nArrayList iterator \nsupplied by java.util. We \ndon\u2019t need this anymore.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 375", "position": 375, "chunk_type": "semantic", "token_estimate": 262}
{"text": "338\u2003 \u2003 Chapter 9: Iterator Pattern defined\nThe Iterator Pattern provides a way to \naccess the elements of an aggregate object \nsequentially without exposing its underlying \nrepresentation. You\u2019ve already seen how to implement the Iterator \nPattern with your very own iterator. You\u2019ve also seen \nhow Java supports iterators in some of its collection-\noriented classes (ArrayList). Now it\u2019s time to check out \nthe official definition of the pattern:\nThis makes a lot of sense: the pattern gives you a way \nto step through the elements of an aggregate without \nhaving to know how things are represented under the \ncovers. You\u2019ve seen that with the two implementations \nof Menus. But the effect of using iterators in your design \nis just as important: once you have a uniform way of \naccessing the elements of all your aggregate objects, you \ncan write polymorphic code that works with any of these \naggregates\u2014just like the printMenu() method, which \ndoesn\u2019t care if the menu items are held in an Array or \nArrayList (or anything else that can create an Iterator), as \nlong as it can get hold of an Iterator. The other important impact on your design is that the \nIterator Pattern takes the responsibility of traversing \nelements and gives that responsibility to the iterator \nobject, not the aggregate object. This not only keeps \nthe aggregate interface and implementation simpler, \nit removes the responsibility for iteration from the \naggregate and keeps the aggregate focused on the \nthings it should be focused on (managing a collection of \nobjects), not on iteration. The Iterator Pattern \nallows traversal of the \nelements of an aggregate \nwithout exposing the \nunderlying implementation. It also places the task \nof traversal on the \niterator object, not \non the aggregate, \nwhich simplifies the \naggregate interface and \nimplementation, and \nplaces the responsibility \nwhere it should be. iterator pattern defined", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 376", "position": 376, "chunk_type": "semantic", "token_estimate": 302}
{"text": "you are here 4\u2003 \u2003 339: the iterator and composite patterns\nhasNext()\nnext()\nremove()\n<<interface>>\nIterator\nhasNext()\nnext()\nremove()\nConcreteIterator\ncreateIterator()\n<<interface>>\nAggregate\ncreateIterator()\nConcreteAggregate\nClient\nThe ConcreteAggregate \nhas a collection of \nobjects and implements \nthe method that \nreturns an Iterator for \nits collection. Each \nConcreteAggregate \nis responsible for \ninstantiating a \nConcreteIterator that \ncan iterate over its \ncollection of objects. The Iterator interface \nprovides the interface \nthat all iterators \nmust implement, and \na set of methods \nfor traversing over \nelements of a collection. Here we\u2019re using the \n \n \n \n \n \n \n \n \n \n \n \n \n \n \njava.util.Iterator. If \nyou don\u2019t want to \nuse Java\u2019s Iterator \ninterface, you can \nalways create your own. Having a common interface for your \naggregates is handy for your client; \nit decouples your client from the \nimplementation of your collection of objects. The ConcreteIterator is \nresponsible for managing \nthe current position of \nthe iteration. The class diagram for the Iterator Pattern looks very similar to another \npattern you\u2019ve studied; can you think of what it is? Hint: a subclass \ndecides which object to create. Let\u2019s check out the class diagram to put all the pieces in context... The Iterator Pattern Structure", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 377", "position": 377, "chunk_type": "semantic", "token_estimate": 185}
{"text": "340\u2003 \u2003 Chapter 9: the single responsibility principle\nOO Glue\nHead First\nThe Single Responsibility Principle\nDesign Principle\nA class should have only one \nreason to change. What if we allowed our aggregates to implement their internal \ncollections and related operations AND the iteration methods? Well, we already know that would expand the number of \nmethods in the aggregate, but so what? Why is that so bad? Well, to see why, you first need to recognize that when we allow \na class to not only take care of its own business (managing \nsome kind of aggregate) but also take on more responsibilities \n(like iteration) then we\u2019ve given the class two reasons to change. Two? Yup, two: it can change if the collection changes in some \nway, and it can change if the way we iterate changes. So once \nagain our friend CHANGE is at the center of another design \nprinciple:\nWe know we want to avoid change in our classes because \nmodifying code provides all sorts of opportunities for \nproblems to creep in. Having two ways to change increases \nthe probability the class will change in the future, and when \nit does, it\u2019s going to affect two aspects of your design. The solution? The principle guides us to assign each \nresponsibility to one class, and only one class. That\u2019s right, it\u2019s as easy as that, and then again it\u2019s not: \nseparating responsibility in design is one of the most \ndifficult things to do. Our brains are just too good at seeing \na set of behaviors and grouping them together even when \nthere are actually two or more responsibilities. The only \nway to succeed is to be diligent in examining your designs  \nand to watch out for signals that a class is changing in more \nthan one way as your system grows. Every responsibility of \na class is an area of \npotential change. More \nthan one responsibility \nmeans more than one area \nof change. This principle guides us to \nkeep each class to a single \nresponsibility. Cohesion is a term you\u2019ll \nhear used as a measure of \nhow closely a class or a \nmodule supports a single \npurpose or responsibility. We say that a module or \nclass has high cohesion when it \nis designed around a set of related \nfunctions, and we say it has low \ncohesion when it is designed around a \nset of unrelated functions.", "domains": ["Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 378", "position": 378, "chunk_type": "semantic", "token_estimate": 395}
{"text": "340\u2003 \u2003 Chapter 9: Cohesion is a term you\u2019ll \nhear used as a measure of \nhow closely a class or a \nmodule supports a single \npurpose or responsibility. We say that a module or \nclass has high cohesion when it \nis designed around a set of related \nfunctions, and we say it has low \ncohesion when it is designed around a \nset of unrelated functions. Cohesion is a more general concept \nthan the Single Responsibility Principle, \nbut the two are closely related. Classes that adhere to the principle \ntend to have high cohesion and are \nmore maintainable than classes that \ntake on multiple responsibilities and \nhave low cohesion.", "domains": ["Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 378", "position": 378, "chunk_type": "semantic", "token_estimate": 107}
{"text": "you are here 4\u2003 \u2003 341: the iterator and composite patterns\nhasNext()\nnext()\nremove()\nIterator\nhasNext()\nnext()\nremove()\naddCard()\nremoveCard()\nshuffle()\nDeckOfCards\nsetName()\nsetAddress()\nsetPhoneNumber()\nsave()\nload()\nPerson\ndial()\nhangUp()\ntalk()\nsendData()\nflash()\nPhone\ngetCount()\ngetState()\ngetLocation()\nGumballMachine\nadd()\nremove()\ncheckOut()\nsaveForLater()\nShoppingCart\nlogin()\nsignup()\nmove()\nfire()\nrest()\nGame\nHard hat area. watch out \nfor falling assumptions\ngetHighScore()\ngetName()\nPlayer\nlogin()\nsignup()\nmove()\nfire()\nrest()\ngetHighScore()\ngetName()\nGame\nmove()\nfire()\nrest()\nPlayerActions\nlogin()\nsignup()\nGameSession\nExamine these classes and determine which ones \nhave multiple responsibilities. Determine if these classes have low or high cohesion. 2", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 379", "position": 379, "chunk_type": "semantic", "token_estimate": 94}
{"text": "342\u2003 \u2003 Chapter 9: no dumb questions\nQ: I\u2019ve seen other books show the \nIterator class diagram with the methods \nfirst(), next(), isDone(), and currentItem(). Why are these methods different? A: Those are the \u201cclassic\u201d method names \nthat have been used. These names have \nchanged over time and we now have next(), \nhasNext(), and even remove() in \njava.util.Iterator. Let\u2019s look at the classic methods. The \nnext() and currentItem() have been merged \ninto one method in java.util. The isDone() \nmethod has become hasNext(), but we \nhave no method corresponding to first(). That\u2019s because in Java we tend to just get \na new iterator whenever we need to start \nthe traversal over. Nevertheless, you can \nsee there is very little difference in these \ninterfaces. In fact, there is a whole range \nof behaviors you can give your iterators. The remove() method is an example of an \nextension in java.util.Iterator. Q: I\u2019ve heard about \u201cinternal\u201d iterators \nand \u201cexternal\u201d iterators. What are they? Which kind did we implement in the \nexample? A: We implemented an external iterator, \nwhich means that the client controls the \niteration by calling next() to get the next \nelement. An internal iterator is controlled \nby the iterator itself. In that case, because \nit\u2019s the iterator that\u2019s stepping through the \nelements, you have to tell the iterator what \nto do with those elements as it goes through \nthem. That means you need a way to pass \nan operation to an iterator. Internal iterators \nare less flexible than external iterators \nbecause the client doesn\u2019t have control of \nthe iteration. However, some might argue \nthat they are easier to use because you just\n\n\n hand them an operation and tell them to \niterate, and they do all the work for you. Q: Could I implement an Iterator that \ncan go backward as well as forward? A: Definitely. In that case, you\u2019d probably \nwant to add two methods, one to get to the \nprevious element, and one to tell you when \nyou\u2019re at the beginning of the collection \nof elements. Java\u2019s Collection Framework \nprovides another type of iterator interface \ncalled ListIterator. This iterator adds \nprevious() and a few other methods to the \nstandard Iterator interface. It is supported \nby any Collection that implements the List \ninterface. Q: Who defines the ordering of the \niteration in a collection like Hashtable, \nwhich is inherently unordered? A: Iterators imply no ordering.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 380", "position": 380, "chunk_type": "semantic", "token_estimate": 392}
{"text": "342\u2003 \u2003 Chapter 9: Q: Who defines the ordering of the \niteration in a collection like Hashtable, \nwhich is inherently unordered? A: Iterators imply no ordering. The \nunderlying collections may be unordered as \nin a hash table or in a bag; they may even \ncontain duplicates. So ordering is related \nto both the properties of the underlying \ncollection and to the implementation. In \ngeneral, you should make no assumptions \nabout ordering unless the Collection \ndocumentation indicates otherwise. Q: You said we can write \n\u201cpolymorphic code\u201d using an iterator; can \nyou explain that more? A: When we write methods that take \nIterators as parameters, we are using \npolymorphic iteration. That means we are \ncreating code that can iterate over any \ncollection as long as it supports Iterator. We don\u2019t care about how the collection \nis implemented, we can still write code to \niterate over it. Q: If I\u2019m using Java, won\u2019t I always \nwant to use the java.util.Iterator \ninterface so I can use my own iterator \nimplementations with classes that are \nalready using the Java iterators? A: Probably. If you have a common \nIterator interface, it will certainly make it \neasier for you to mix and match your own \naggregates with Java aggregates like \nArrayList and Vector. But remember, if you \nneed to add functionality to your Iterator \ninterface for your aggregates, you can \nalways extend the Iterator interface. Q: I\u2019ve seen an Enumeration interface \nin Java; does that implement the Iterator \nPattern? A: We talked about this in the \nAdapter Pattern chapter (Chapter 7). Remember? The java.util.Enumeration \nis an older implementation of Iterator \nthat has since been replaced by java.util. Iterator. Enumeration has two methods, \nhasMoreElements(), corresponding to \nhasNext(), and nextElement(), corresponding \nto next(). However, you\u2019ll probably want to \nuse Iterator over Enumeration as more Java \nclasses support it. If you need to convert \nfrom one to another, review Chapter 7 again \nwhere you implemented the adapter for \nEnumeration and Iterator. Q: Is using Java\u2019s enhanced for loop \nrelated to iterators? A: Good question! It is, and to tackle that \nquestion we need to understand another \ninterface\u2014that is, Java\u2019s Iterable interface. This is a good time to do just that...", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 380", "position": 380, "chunk_type": "semantic", "token_estimate": 359}
{"text": "you are here 4\u2003 \u2003 343: the iterator and composite patterns\nMeet Java\u2019s Iterable interface\nYou\u2019re already up to speed on Java\u2019s Iterator interface, but there\u2019s \nanother interface you need to meet: Iterable. The Iterable interface \nis implemented by every Collection type in Java. Guess what? In your \ncode using the ArrayList, you\u2019ve already been using this interface. Let\u2019s take a look at the Iterable interface:\niterator()\n+ forEach()\n+ spliterator()\n<<interface>>\nIterable\nadd()\naddAll()\nclear()\ncontains()\ncontainsAll()\nequals()\nhashCode()\nisEmpty()\niterator()\nremove()\nremoveAll()\nretainAll()\nsize()\ntoArray()\n<<interface>>\nCollection\nnext()\nhasNext()\n+ remove()\n<<interface>>\nIterator\nThe Iterable interface \nincludes an iterator() \nmethod that returns \nan iterator that \nimplements the \nIterator interface. All Collection classes, like \nArrayList, implement the \nCollection interface, which \ninherits from the Iterable \ninterface, so all Collection \nclasses are Iterables. You already know about the \nIterator interface; that's the \nsame interface we\u2019ve been using \nwith our Diner and Pancake \nhouse iterators. Here\u2019s the Iterable \ninterface. If a class implements Iterable, we know that the class implements an \niterator() method. That method returns an iterator that implements \nthe Iterator interface. This interface also includes a default forEach() \nmethod that can be used as another way to iterate through the \ncollection. In addition to all that, Java even provides some nice \nsyntactic sugar for iteration, with its enhanced for loop. Let\u2019s see how \nthat works. The Iterable interface also \nincludes the spliterator() \nmethod, which provides even \nmore advanced ways to iterate \nthrough a collection.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 381", "position": 381, "chunk_type": "semantic", "token_estimate": 243}
{"text": "344\u2003 \u2003 Chapter 9: the enhanced for loop\nJava\u2019s enhanced for loop\nLet\u2019s take an object whose class implements the Iterable interface...why not \nthe ArrayList collection we used for the Pancake House menu items:\nList<MenuItem> menuItems = new ArrayList<MenuItem>();\nWe can iterate over ArrayList the way we have been:\nIterator iterator = menu.iterator();\nwhile (iterator.hasNext()) {\n\t\nMenuItem menuItem = iterator.next();\n\t\nSystem.out.print(menuItem.getName() + \", \");\n\t\nSystem.out.print(menuItem.getPrice() + \" -- \");\n\t\nSystem.out.println(menuItem.getDescription());\n}\nOr, given we know ArrayList is an Iterable, we could use Java\u2019s enhanced \nfor shorthand:\nfor (MenuItem item: menu) {\n\t\nSystem.out.print(menuItem.getName() + \", \");\n\t\nSystem.out.print(menuItem.getPrice() + \" -- \");\n\t\nSystem.out.println(menuItem.getDescription());\n}\nHere we can dispense with \nthe explicit iterator as the \nhasNext() and next() methods. This is the way we've been \ndoing iteration over our \ncollections, using an iterator \nalong with the hasNext() and \nnext() methods. Looks like a great way to use Iterators \nthat really results in simple code\u2014no more \nhasNext() or next() method calls. So, can we \nrework our Waitress code to use Iterable and \nthe enhanced for loop for both menus?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 382", "position": 382, "chunk_type": "semantic", "token_estimate": 174}
{"text": "you are here 4\u2003 \u2003 345: the iterator and composite patterns\nWe have some bad news: the Diner may not have made the best decision using an \nArray as the basis for its menus. As it turns out, Arrays are not Java Collections \nand so they don\u2019t implement the Iterable interface. Given that, we can\u2019t as easily \nconsolidate our Waitress code into one method that takes an Iterable and use it \nwith both the Pancake House\u2019s breakfastItems and the Diner\u2019s lunchItems. If you \ntry to change the Waitress\u2019s printMenu() method to take an Iterable instead of an \nIterator, and use the for-each loop instead of the Iterator API, like this: \nNot so fast; Arrays are not Iterables\npublic void printMenu(Iterable<MenuItem> iterable) {\n\t\nfor (MenuItem menuItem : iterable) {\n\t\n\t\n// print menuItem\n\t\n}\n}\nyou\u2019ll get a compiler error when you try to pass the lunchItems array to printMenu():\nprintMenu(lunchItems);\nbecause, again, Arrays don\u2019t implement the Iterable interface. If you keep both loops in the Waitress code, we\u2019re back to square one: the Waitress is \nonce again dependent on the aggregate types we\u2019re using to store the menus, and she \nhas duplicate code: one loop for the ArrayList, and one loop for the Array. So what do we do? Well, there are many ways to solve this issue, but they are a bit of a \nsideshow, as would be refactoring our code. After all, this chapter is about the Iterator \nPattern, not Java\u2019s Iterable interface. But the good news is you know about Iterable, you \nknow its relationship to Java\u2019s Iterator interface and to the Iterator Pattern. So, let\u2019s keep \nmoving, as we\u2019ve got a great implementation even if we aren\u2019t taking advantage of a \nlittle syntactic sugar from Java\u2019s for loop. This will only work for the \nArrayList we\u2019re using for the \nPancake House menu. Compile error! Arrays are not Iterables. breakfastItems.forEach(item -> System.out.println(item));\nYou probably noticed the forEach() method in the Iterable menu. It\u2019s used as the basis for \nJava\u2019s enhanced for loop, but you can also use it directly with Iterables. Here\u2019s how it works:\nHere\u2019s an Iterable, in this case \nour Pancake House ArrayList \nof menu items. We\u2019re calling forEach()...\n...and passing a lambda that takes a \nmenuItem, and just prints it. So this code will print every \nitem in the collection.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 383", "position": 383, "chunk_type": "semantic", "token_estimate": 384}
{"text": "346\u2003 \u2003 Chapter 9: a new acquisition\nWow, and we thought things \nwere already complicated. Now what are we going to do? Good thing you\u2019re \nlearning about the Iterator \nPattern because I just heard that \nObjectville Mergers and Acquisitions \nhas done another deal...we\u2019re merging \nwith Objectville Caf\u00e9 and adopting their \ndinner menu. Come on, think positively. I\u2019m sure we can find a way to \nwork them into the Iterator \nPattern.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 384", "position": 384, "chunk_type": "semantic", "token_estimate": 69}
{"text": "you are here 4\u2003 \u2003 347: the iterator and composite patterns\npublic class CafeMenu {\n    Map<String, MenuItem> menuItems = new HashMap<String, MenuItem>();\n  \n    public CafeMenu() {\n        addItem(\"Veggie Burger and Air Fries\",\n            \"Veggie burger on a whole wheat bun, lettuce, tomato, and fries\",\n            true, 3.99);\n        addItem(\"Soup of the day\",\n            \"A cup of the soup of the day, with a side salad\",\n            false, 3.69);\n        addItem(\"Burrito\",\n            \"A large burrito, with whole pinto beans, salsa, guacamole\",\n            true, 4.29);\n    }\n \n    public void addItem(String name, String description, \n                         boolean vegetarian, double price) \n    {\n        MenuItem menuItem = new MenuItem(name, description, vegetarian, price);\n        menuItems.put(name, menuItem);\n    }\n \n    public Map<String, MenuItem> getMenuItems() {\n        return menuItems;\n    }\n}\nHere\u2019s the caf\u00e9 menu. It doesn\u2019t look like too much trouble to integrate the \nCafeMenu class into our framework...let\u2019s check it out. CafeMenu doesn\u2019t implement our new Menu \ninterface, but this is easily fixed. The caf\u00e9 is storing their menu items in a HashMap. Does that support Iterator? We\u2019ll see shortly...\nLike the other Menus, the menu items \nare initialized in the constructor. Here\u2019s where we create a new MenuItem \nand add it to the menuItems HashMap. We\u2019re not going to need this anymore. 1. 2. 3. The key is the item name. The value is the menuItem object. Before looking at the next page, quickly jot down the three \nthings we have to do to this code to fit it into our framework:\nTaking a look at the Caf\u00e9 Menu", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 385", "position": 385, "chunk_type": "semantic", "token_estimate": 235}
{"text": "348\u2003 \u2003 Chapter 9: Are we violating \nthe Principle of \nLeast Knowledge \nhere? What can \nwe do about it? reworking the menu code\npublic class CafeMenu implements Menu {\n    Map<String, MenuItem> menuItems = new HashMap<String, MenuItem>();\n  \n    public CafeMenu() {\n        // constructor code here\n    }\n \n    public void addItem(String name, String description, \n                         boolean vegetarian, double price) \n    {\n        MenuItem menuItem = new MenuItem(name, description, vegetarian, price);\n        menuItems.put(name, menuItem);\n    }\n \n    public Map<String, MenuItem> getMenuItems() {\n        return menuItems;\n    }\n  \n    public Iterator<MenuItem> createIterator() {\n        return menuItems.values().iterator();\n    }\n}\nCode Up Close\nLet\u2019s rework the CafeMenu code. We\u2019re going to take care of implementing the \nMenu interface, and we also need to deal with creating an Iterator for the values \nstored in the HashMap. Things are a little different than when we did the same \nfor the ArrayList; check it out...\nCafeMenu implements the Menu interface, so the \nWaitress can use it just like the other two Menus. Just like before, we can get rid of getItems() \nso we don\u2019t expose the implementation of \nmenuItems to the Waitress. And here\u2019s where we implement the \ncreateIterator() method. Notice that \nwe\u2019re not getting an Iterator for the \nwhole HashMap, just for the values. public Iterator<MenuItem> createIterator() {\n        return menuItems.values().iterator();\n    }\nFirst we get the values of the \nHashMap, which is just a collection of \nall the objects in the HashMap. Luckily that collection supports the \niterator() method, which returns a \nobject of type java.util.Iterator. HashMap is a little more complex than ArrayList because it supports both \nkeys and values, but we can still get an Iterator for the values (which are \nthe MenuItems). We\u2019re using HashMap because it\u2019s a common \ndata structure for storing values. Reworking the Caf\u00e9 Menu code", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 386", "position": 386, "chunk_type": "semantic", "token_estimate": 280}
{"text": "you are here 4\u2003 \u2003 349: the iterator and composite patterns\npublic class Waitress {\n    Menu pancakeHouseMenu;\n    Menu dinerMenu;\n    Menu cafeMenu;\n \n    public Waitress(Menu pancakeHouseMenu, Menu dinerMenu, Menu cafeMenu) {\n        this.pancakeHouseMenu = pancakeHouseMenu;\n        this.dinerMenu = dinerMenu;\n        this.cafeMenu = cafeMenu;\n    }\n \n    public void printMenu() {\n        Iterator<MenuItem> pancakeIterator = pancakeHouseMenu.createIterator();\n        Iterator<MenuItem> dinerIterator = dinerMenu.createIterator();\n        Iterator<MenuItem> cafeIterator = cafeMenu.createIterator();\n        System.out.println(\"MENU\\n----\\nBREAKFAST\");\n        printMenu(pancakeIterator);\n        System.out.println(\"\\nLUNCH\");\n        printMenu(dinerIterator);\n        System.out.println(\"\\nDINNER\");\n        printMenu(cafeIterator);\n    }\n \n    private void printMenu(Iterator iterator) {\n        while (iterator.hasNext()) {\n            MenuItem menuItem = iterator.next();\n            System.out.print(menuItem.getName() + \", \");\n            System.out.print(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n}\nNow it\u2019s time to modify the Waitress to support our new Menu. Now that the \nWaitress expects Iterators, it should be straightforward:\nThe caf\u00e9 menu is passed into the Waitress \nin the constructor with the other menus, \nand we stash it in an instance variable. We\u2019re using the caf\u00e9\u2019s \nmenu for our dinner \nmenu. All we have to do \nto print it is create the \niterator, and pass it to \nprintMenu(). That\u2019s it! Nothing changes here. Adding the Cafe Menu to the Waitress\n\u2018", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 387", "position": 387, "chunk_type": "semantic", "token_estimate": 170}
{"text": "you are here 4\u2003 \u2003 351: the iterator and composite patterns\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArrayList\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArray\n...and we didn\u2019t want her to \nknow about how the menu \nitems are implemented. ArrayList has a \nbuilt-in iterator... ...Array \ndoesn\u2019t have \na built-in \nIterator so \nwe built our \nown. I\nt\ne\nr\nat\no\nr\nWe wanted to give the \nWaitress an easy way to \niterate over menu items...\nOur menu items had two \ndifferent implementations \nand two different \ninterfaces for iterating. I\nt\ne\nr\nat\no\nr\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArrayList\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nArray\nSo we gave the Waitress an \nIterator for each kind of \ngroup of objects she needed \nto iterate over...\n...one for \nArrayList...\n...and one for Array. next()\nnext()\nNow she doesn\u2019t have to worry about which \nimplementation we used; she always uses the same \ninterface\u2009\u2014\u2009Iterator\u2009\u2014\u2009to iterate over menu items. She\u2019s been decoupled from the implementation. What did we do? We decoupled the Waitress....", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 389", "position": 389, "chunk_type": "semantic", "token_estimate": 280}
{"text": "352\u2003 \u2003 Chapter 9: a more extensible waitress\n \n \n \n \n \n \n \n \n \nI\nt\ne\nr\na\nt\no\nr\nnext()\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nVector\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\nHashMap\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\nMost have different \ninterfaces. By giving her an Iterator, \nwe have decoupled her \nfrom the implementation \nof the menu items, so we \ncan easily add new Menus \nif we want. We easily added another \nimplementation of menu \nitems, and since we \nprovided an Iterator, \nthe Waitress knew what \nto do. Which is better for her, \nbecause now she can use the \nsame code to iterate over \nany group of objects. And \nit\u2019s better for us because \nthe implementation details \naren\u2019t exposed. ...and more! Making an Iterator \nfor the HashMap \nvalues was easy; \nwhen you call \nvalues.iterator() \nyou get an Iterator. LinkedList\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\nBut almost all of \nthem support a \nway to obtain an \nIterator. And if they don\u2019t support \nIterator, that\u2019s okay, because now \nyou know how to build your own. ...and we made the Waitress more extensible\nBut there\u2019s more! Java gives you a lot of \u201cCollection\u201d \nclasses that allow you to store \nand retrieve groups of objects; \nfor example, Vector and \nLinkedList.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 390", "position": 390, "chunk_type": "semantic", "token_estimate": 281}
{"text": "you are here 4\u2003 \u2003 353: the iterator and composite patterns\nIterators and Collections\nWe\u2019ve been using a couple of classes that are part of the Java Collections Framework. This \u201cframework\u201d is just a set of classes and interfaces, including ArrayList, which \nwe\u2019ve been using, and many others like Vector, LinkedList, Stack, and PriorityQueue. Each of these classes implements the java.util.Collection interface, which contains a \nbunch of useful methods for manipulating groups of objects. Let\u2019s take a quick look at the interface:\nadd()\naddAll()\nclear()\ncontains()\ncontainsAll()\nequals()\nhashCode()\nisEmpty()\niterator()\nremove()\nremoveAll()\nretainAll()\nsize()\ntoArray()\n<<interface>>\nCollection\nAs you can see, there\u2019s all kinds \nof good stuff here. You can add \nand remove elements from your \ncollection without even knowing \nhow it\u2019s implemented. Here\u2019s our old friend, the \niterator() method. With this \nmethod, you can get an Iterator \nfor any class that implements \nthe Collection interface. Other handy methods include \nsize(), to get the number of \nelements, and toArray() to turn \nyour collection into an array. HashMap is one of \na few classes that \nindirectly \nsupports Iterator. As you saw when we \nimplemented the CafeMenu, you \ncould get an Iterator from it, but \nonly by first retrieving its Collection \ncalled values. If you think about it, \nthis makes sense: the HashMap \nholds two sets of objects: keys and \nvalues. If we want to iterate over \nits values, we first need to retrieve \nthem from the HashMap, and then \nobtain the iterator. The nice thing about Collections and \nIterators is that each Collection object \nknows how to create its own Iterator. Calling \niterator() on an ArrayList returns a concrete \nIterator made for ArrayLists, but you never need \nto see or worry about the concrete class it uses; \nyou just use the Iterator interface. iterator()\n+ forEach()\n+ spliterator()\n<<interface>>\nIterable\nDon\u2019t forget the \nCollection interface \nimplements the \nIterable interface.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 391", "position": 391, "chunk_type": "semantic", "token_estimate": 308}
{"text": "354\u2003 \u2003 Chapter 9: code magnets\nThe Chefs have decided that they want to be able to alternate their lunch menu items; in other words, \nthey will offer some items on Monday, Wednesday, Friday, and Sunday, and other items on Tuesday, \nThursday, and Saturday. Someone already wrote the code for a new \u201cAlternating\u201d DinerMenu Iterator so \nthat it alternates the menu items, but she scrambled it up and put it on the fridge in the Diner as a joke. Can you put it back together? Some of the curly braces fell on the floor and they were too small to pick \nup, so feel free to add as many of those as you need. Code Magnets\n}\n}\n}\nMenuItem menuItem = items[position];\nposition = position + 2;\nreturn menuItem;\nimport java.util.Iterator;\nimport java.util.Calendar;\npublic Object next() {\npublic AlternatingDinerMenuIterator(MenuItem[] items)\nthis.items = items;\nposition = Calendar.DAY_OF_WEEK % 2;\npublic void remove() {\nimplements Iterator<MenuItem>\nMenuItem[] items;\nint position;\npublic class AlternatingDinerMenuIterator\npublic boolean hasNext() {\nthrow new UnsupportedOperationException(\n    \"Alternating Diner Menu Iterator does not support remove()\");\nif (position >= items.length || items[position] == null) {\n    return false;\n} else {\n    return true;\n}", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 392", "position": 392, "chunk_type": "semantic", "token_estimate": 193}
{"text": "you are here 4\u2003 \u2003 355: the iterator and composite patterns\n    public void printMenu() {\n        Iterator<MenuItem> pancakeIterator = pancakeHouseMenu.createIterator();\n        Iterator<MenuItem> dinerIterator = dinerMenu.createIterator();\n        Iterator<MenuItem> cafeIterator = cafeMenu.createIterator();\n        System.out.println(\"MENU\\n----\\nBREAKFAST\");\n        printMenu(pancakeIterator);\n        System.out.println(\"\\nLUNCH\");\n        printMenu(dinerIterator);\n        System.out.println(\"\\nDINNER\");\n        printMenu(cafeIterator);\n    }\nIs the Waitress ready for prime time? The Waitress has come a long way, but you\u2019ve gotta admit \nthose three calls to printMenu() are looking kind of ugly. Let\u2019s be real\u2014every time we add a new menu we\u2019re going to \nhave to open up the Waitress implementation and add more \ncode. Can you say \u201cviolating the Open Closed Principle\u201d? It\u2019s not the Waitress\u2019s fault. We\u2019ve done a great job of decoupling the menu implementation \nand extracting the iteration into an iterator. But we still are handling the menus with \nseparate, independent objects\u2014we need a way to manage them together. Three calls to \nprintMenu. Three createIterator() calls. Every time we add or remove a menu\u200a\n, we\u2019re going \nto have to open this code up for changes. The Waitress still needs to make three calls to printMenu(), one for each menu. Can you \nthink of a way to combine the menus so that only one call needs to be made? Or perhaps \nso that one Iterator is passed to the Waitress to iterate over all the menus?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 393", "position": 393, "chunk_type": "semantic", "token_estimate": 209}
{"text": "356\u2003 \u2003 Chapter 9: public class Waitress {\n    List<Menu> menus;\n  \n    public Waitress(List<Menu> menus) {\n\t\nthis.menus = menus;\n    }\n   \n    public void printMenu() {\n\t\nIterator<Menu> menuIterator = menus.iterator();\n\t\nwhile(menuIterator.hasNext()) {\n\t\n\t\nMenu menu = menuIterator.next();\n\t\n\t\nprintMenu(menu.createIterator());\n\t\n}\n    }\n   \n    void printMenu(Iterator<MenuItem> iterator) {\n\t\nwhile (iterator.hasNext()) {\n\t\n\t\nMenuItem menuItem = iterator.next();\n\t\n\t\nSystem.out.print(menuItem.getName() + \", \");\n\t\n\t\nSystem.out.print(menuItem.getPrice() + \" -- \");\n\t\n\t\nSystem.out.println(menuItem.getDescription());\n\t\n}\n    }\n} \na new design\nSounds like the chef is on to something. Let\u2019s give it a try:\nNow we just take a list \nof menus, instead of \neach menu separately. And we iterate through the \nmenus, passing each menu\u2019s \niterator to the overloaded \nprintMenu() method. No code \nchanges here. This looks pretty good, although we\u2019ve lost the names of the menus, \nbut we could add the names to each menu. This isn\u2019t so bad. All \nwe need to do is package the \nmenus up into an ArrayList and then \niterate through each Menu. The code in \nthe Waitress is going to be simple and it \nwill handle any number of menus.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 394", "position": 394, "chunk_type": "semantic", "token_estimate": 168}
{"text": "you are here 4\u2003 \u2003 357: the iterator and composite patterns\nP\na\nn\nc\na\nk\ne\nH\nou\ns\ne\nM\ne\nn\nu\n \n \nD\ni\nn\ne\nr\nM\ne\nn\nu\n \n \n \nC\na\nf\ne\nM\ne\nn\nu\n1\n2\n3\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nPancake Menu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nDiner Menu\nAll Menus\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n1\n2\n3\n4\nDessert Menu\nHere\u2019s our ArrayList \nthat holds the menus \nof each restaurant. We need for Diner Menu to hold a submenu, \nbut we can\u2019t actually assign a menu to a \nMenuItem array because the types are \ndifferent, so this isn\u2019t going to work. Array\nArrayList\nHashMap\nJust when we thought it was safe...\nNow they want to add a dessert submenu. Okay, now what? Now we have to support not only multiple \nmenus, but menus within menus. It would be nice if we could just make the dessert menu an \nelement of the DinerMenu collection, but that won\u2019t work as it is \nnow implemented. What we want (something like this):\nBut this won\u2019t \nwork! We can\u2019t assign a dessert menu to a \nMenuItem array. Time for a change! I just heard the Diner is \ngoing to be creating a dessert \nmenu that is going to be an insert \ninto their regular menu. M\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \n \nM\ne\nn\nu\nI\nt\nem\nCaf\u00e9 Menu\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny\n \n \n \n \n \n \n \n \n \n \nk\ne\ny", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 395", "position": 395, "chunk_type": "semantic", "token_estimate": 341}
{"text": "you are here 4\u2003 \u2003 359: the iterator and composite patterns\n \n \n \n \nA\nl\nl\n \nM\ne\nnu\ns\n \n \n \nD\ne\ns\ns\ne\nr\nt \nM\ne\nn\nu\nP\na\nn\nc\na\nk\ne\n \nHo\nu\ns\ne\n \nM\nenu\n \n \n \n \nD\ni\nn\ne\nr\n \nMe\nn\nu\n \n \n \n \n \nC\na\nf\n\u00e9\n \nMe\nn\nu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\nWe need to \naccommodate \nMenus...\n...and menu items. ...and submenus...\nBecause we need to represent \nmenus, nested submenus, and menu \nitems, we can naturally fit them \nin a tree-like structure. A\nl\nl\n \nM\ne\nnu\ns\n \n \n \nD\ne\ns\ns\ne\nr\nt \nM\ne\nn\nu\nP\na\nn\nc\na\nk\ne\n \nHo\nu\ns\ne\n \nM\nenu\n \n \n \n \nD\ni\nn\ne\nr\n \nMe\nn\nu\n \n \n \n \n \nC\na\nf\ne\n \nMe\nn\nu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nD\ne\ns\ns\ne\nr\nt \nM\ne\nn\nu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\nWe still need to be able \nto traverse all the items \nin the tree. We also need to be able to \ntraverse more flexibly, for \ninstance over one menu. How would you handle this new wrinkle to our design \nrequirements? Think about it before turning the page.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 397", "position": 397, "chunk_type": "semantic", "token_estimate": 400}
{"text": "360\u2003 \u2003 Chapter 9: composite pattern defined\nThe Composite Pattern defined\nThat\u2019s right; we\u2019re going to introduce another pattern \nto solve this problem. We didn\u2019t give up on Iterator\u2014it \nwill still be part of our solution\u2014however, the problem \nof managing menus has taken on a new dimension that \nIterator doesn\u2019t solve. So, we\u2019re going to step back and \nsolve it with the Composite Pattern. We\u2019re not going to beat around the bush on this \npattern; we\u2019re going to go ahead and roll out the official \ndefinition now:\nThe Composite Pattern allows you to \ncompose objects into tree structures to \nrepresent part-whole hierarchies. Composite \nlets clients treat individual objects and \ncompositions of objects uniformly. Let\u2019s think about this in terms of our menus: this pattern \ngives us a way to create a tree structure that can handle \na nested group of menus and menu items in the same \nstructure. By putting menus and items in the same \nstructure we create a part-whole hierarchy\u2014that is, a \ntree of objects that is made of parts (menus and menu \nitems) but that can be treated as a whole, like one big \n\u00fcber menu. Once we have our \u00fcber menu, we can use this \npattern to treat \u201cindividual objects and compositions \nuniformly.\u201d What does that mean? It means if we have \na tree structure of menus, submenus, and perhaps \nsubsubmenus along with menu items, then any menu \nis a \u201ccomposition\u201d because it can contain both other \nmenus and menu items. The individual objects are just \nthe menu items\u2014they don\u2019t hold other objects. As you\u2019ll \nsee, using a design that follows the Composite Pattern \nis going to allow us to write some simple code that can \napply the same operation (like printing!) over the entire \nmenu structure. Here\u2019s a tree structure. N\no\nd\ne\n \n \n \n \n \n \n \n \n \n \n \nL\ne\naf\n \n \n \n \n \n \n \n \n \nL\ne\na\nf\n \n \n \n \n \n \n \n \n \n \nL\ne\naf\nElements without children \nare called leaves. Elements with \nchild elements \nare called nodes. M\ne\nnu\n \n \n \n \n \n \n \n \n \nM\ne\nnu\nI\nt\ne\nm\n \n \n \n \n \nM\ne\nn\nu\nI\nte\nm\n \n \n \n \n \n \nM\ne\nn\nu\nI\nt\ne\nm\nMenus are nodes and \nMenuItems are leaves. We can represent \nour Menu and \nMenuItems in a \ntree structure.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 398", "position": 398, "chunk_type": "semantic", "token_estimate": 364}
{"text": "you are here 4\u2003 \u2003 361: the iterator and composite patterns\nThe Composite Pattern \nallows us to build \nstructures of objects in \nthe form of trees that \ncontain both compositions \nof objects and individual \nobjects as nodes. Using a composite \nstructure, we can apply \nthe same operations over \nboth composites and \nindividual objects. In \nother words, in most \ncases we can ignore the \ndifferences between \ncompositions of objects \nand individual objects. A\nl\nl\n \nM\ne\nnu\ns\n \n \n \nD\ne\ns\ns\ne\nr\nt \nM\ne\nn\nu\nP\na\nn\nc\na\nk\ne\n \nHo\nu\ns\ne\n \nM\nenu\n \n \n \n \nD\ni\nn\ne\nr\n \nMe\nn\nu\n \n \n \n \n \nC\na\nf\ne\n \nMe\nn\nu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\nMenus\nSubmenu\nMenuItems\nWe can create arbitrarily \ncomplex trees. A\nl\nl\n \nM\ne\nnu\ns\n \n \n \nD\ne\ns\ns\ne\nr\nt \nM\ne\nn\nu\nP\na\nn\nc\na\nk\ne\n \nHo\nu\ns\ne\n \nM\nenu\n \n \n \n \nD\ni\nn\ne\nr\n \nMe\nn\nu\n \n \n \n \n \nC\na\nf\ne\n \nMe\nn\nu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\nMenus\nSubmenu\nMenuItems\nAnd treat them as a whole...\n....or as parts.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 399", "position": 399, "chunk_type": "semantic", "token_estimate": 365}
{"text": "362\u2003 \u2003 Chapter 9: composite pattern class diagram\noperation()\nadd(Component)\nremove(Component)\ngetChild(int)\nComponent\nadd(Component)\nremove(Component)\ngetChild(int)\noperation()\nComposite\nClient\noperation()\nLeaf\nThe Component defines an \ninterface for all objects in the \ncomposition: both the composite \nand leaves. The Component may implement \na default behavior for add(), \nremove(), getChild() and its \noperations. A leaf has no \nchildren. A leaf defines the behavior for \nthe elements in the composition. It does this by implementing the \noperations the Composite supports. The Composite\u2019s role is to \ndefine behavior of the \ncomponents having children and \nto store child components. The Composite also \nimplements the Leaf-\nrelated operations. Note that some of \nthese may not make \nsense on a Composite, \nso in that case an \nexception might be \ngenerated. The Client uses the \nComponent interface to \nmanipulate the objects in \nthe composition. Note that the leaf also \ninherits methods like add(), \nremove(), and getChild(), \nwhich don\u2019t necessarily make a \nlot of sense for a leaf node. We\u2019re going to come back to \nthis issue. Q: Component, Composite, Trees? I\u2019m confused. A: A composite contains components. Components come in \ntwo flavors: composites and leaf elements. Sound recursive? It is. A composite holds a set of children; those children may be other \ncomposites or leaf elements. When you organize data in this way you end up with a tree structure \n(actually an upside-down tree structure) with a composite at the root \nand branches of composites growing up to leaves. Q: How does this relate to iterators? A: Remember, we\u2019re taking a new approach. We\u2019re going to \nre-implement the menus with a new solution: the Composite Pattern. So don\u2019t look for some magical transformation from an iterator to a \ncomposite. That said, the two work very nicely together. You\u2019ll soon \nsee that we can use iterators in a couple of ways in the composite \nimplementation.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 400", "position": 400, "chunk_type": "semantic", "token_estimate": 305}
{"text": "you are here 4\u2003 \u2003 363: the iterator and composite patterns\ngetName()\ngetDescription()\ngetPrice()\nisVegetarian()\nprint()\nadd(MenuComponent)\nremove(MenuComponent)\ngetChild(int)\nMenuComponent\ngetName()\ngetDescription()\ngetPrice()\nisVegetarian()\nprint()\nMenuItem\nWaitress\ngetName()\ngetDescription()\nprint()\nadd(MenuComponent)\nremove(MenuComponent)\ngetChild(int)\nMenu\nmenuComponents\nDesigning Menus with Composite\nSo, how do we apply the Composite Pattern to our menus? To start with, we need to create a \ncomponent interface; this acts as the common interface for both menus and menu items and allows \nus to treat them uniformly. In other words, we can call the same method on menus or menu items. Now, it may not make sense to call some of the methods on a menu item or a menu, but we can deal \nwith that, and we will in just a moment. But for now, let\u2019s take a look at a sketch of how the menus \nare going to fit into a Composite Pattern structure:\nMenuComponent represents the interface \nfor both MenuItem and Menu. We\u2019ve used an \nabstract class here because we want to provide \ndefault implementations for these methods. We have some of the same \nmethods you\u2019ll remember \nfrom our previous versions \nof MenuItem and Menu, \nand we\u2019ve added print(), \nadd(), remove() and \ngetChild(). We\u2019ll describe \nthese soon, when we \nimplement our new Menu \nand MenuItem classes. MenuItem overrides the methods that make \nsense, and uses the default implementations \nin MenuComponent for those that don\u2019t \nmake sense (like add()\u2009\u2014\u2009it doesn\u2019t make \nsense to add a component  to a MenuItem... \nwe can only add components to a Menu). Menu also overrides the methods that \nmake sense, like a way to add and remove \nmenu items (or other menus!) from its \nmenuComponents. In addition, we\u2019ll use the \ngetName() and getDescription() methods to \nreturn the name and description of the menu. Both MenuItem and \nMenu override print(). The Waitress is going to use the \nMenuComponent interface to access \nboth Menus and MenuItems. Here are the methods for \nmanipulating the components. The components are \nMenuItem and Menu.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 401", "position": 401, "chunk_type": "semantic", "token_estimate": 328}
{"text": "364\u2003 \u2003 Chapter 9: implementing composite menus\npublic abstract class MenuComponent {\n   \n    public void add(MenuComponent menuComponent) {\n        throw new UnsupportedOperationException();\n    }\n    public void remove(MenuComponent menuComponent) {\n        throw new UnsupportedOperationException();\n    }\n    public MenuComponent getChild(int i) {\n        throw new UnsupportedOperationException();\n    }\n  \n    public String getName() {\n        throw new UnsupportedOperationException();\n    }\n    public String getDescription() {\n        throw new UnsupportedOperationException();\n    }\n    public double getPrice() {\n        throw new UnsupportedOperationException();\n    }\n    public boolean isVegetarian() {\n        throw new UnsupportedOperationException();\n    }\n  \n    public void print() {\n        throw new UnsupportedOperationException();\n    }\n}\nImplementing MenuComponent\nOkay, we\u2019re going to start with the MenuComponent abstract \nclass; remember, the role of the menu component is to provide an \ninterface for the leaves and the composite nodes. Now you might \nbe asking, \u201cIsn\u2019t MenuComponent playing two roles?\u201d It might \nwell be and we\u2019ll come back to that point. However, for now we\u2019re \ngoing to provide a default implementation of the methods so that \nif the MenuItem (the leaf) or the Menu (the composite) doesn\u2019t \nwant to implement some of the methods (like getChild() for a leaf \nnode), it can fall back on some basic behavior:\nMenuComponent \nprovides default \nimplementations for \nevery method. We\u2019ve grouped together the \n\u201ccomposite\u201d methods\u2009\u2014\u2009that is, \nmethods to add, remove, and \nget MenuComponents. Here are the \u201coperation\u201d methods; \nthese are used by the MenuItems. It turns out we can also use a \ncouple of them in Menu too, as \nyou\u2019ll see in a couple of pages when \nwe show the Menu code. print() is an \u201coperation\u201d method \nthat both our Menus and \nMenuItems will implement, but we \nprovide a default operation here. Because some of these methods \nonly make sense for MenuItems, and \nsome only make sense for Menus, \nthe default implementation is \nUnsupportedOperationException. That \nway, if MenuItem or Menu doesn\u2019t \nsupport an operation, it doesn\u2019t have \nto do anything; it can just inherit the \ndefault implementation. All components must implement \nthe MenuComponent interface; \nhowever, because leaves and \nnodes have different roles we \ncan\u2019t always define a default \nimplementation for each \nmethod that makes sense. Sometimes the best you can do \nis throw a runtime exception.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 402", "position": 402, "chunk_type": "semantic", "token_estimate": 344}
{"text": "you are here 4\u2003 \u2003 365: the iterator and composite patterns\npublic class MenuItem extends MenuComponent {\n    String name;\n    String description;\n    boolean vegetarian;\n    double price;\n    \n    public MenuItem(String name, \n                    String description, \n                    boolean vegetarian, \n                    double price) \n    { \n        this.name = name;\n        this.description = description;\n        this.vegetarian = vegetarian;\n        this.price = price;\n    }\n  \n    public String getName() {\n        return name;\n    }\n  \n    public String getDescription() {\n        return description;\n    }\n  \n    public double getPrice() {\n        return price;\n    }\n  \n    public boolean isVegetarian() {\n        return vegetarian;\n    }\n  \n    public void print() {\n        System.out.print(\"  \" + getName());\n        if (isVegetarian()) {\n            System.out.print(\"(v)\");\n        }\n        System.out.println(\", \" + getPrice());\n        System.out.println(\"     -- \" + getDescription());\n    }\n}\nImplementing the MenuItem\nOkay, let\u2019s give the MenuItem class a shot. Remember, \nthis is the leaf class in the Composite diagram, and it \nimplements the behavior of the elements of the composite. First we need to extend \nthe MenuComponent \ninterface. The constructor just takes the \nname, description, etc., and \nkeeps a reference to them all. This is pretty much like our \nold MenuItem implementation. Here\u2019s our getter \nmethods\u2009\u2014\u2009just like our \nprevious implementation. This is different from the previous implementation. Here we\u2019re overriding the print() method in the \nMenuComponent class. For MenuItem this method \nprints the complete menu entry: name, description, \nprice, and whether or not it\u2019s veggie. I\u2019m glad we\u2019re going in this \ndirection. I\u2019m thinking this \nis going to give me the flexibility \nI need to implement that cr\u00eape \nmenu I\u2019ve always wanted.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 403", "position": 403, "chunk_type": "semantic", "token_estimate": 235}
{"text": "366\u2003 \u2003 Chapter 9: implementing the new menu class\npublic class Menu extends MenuComponent {\n    List<MenuComponent> menuComponents = new ArrayList<MenuComponent>();\n    String name;\n    String description;\n  \n    public Menu(String name, String description) {\n        this.name = name;\n        this.description = description;\n    }\n \n    public void add(MenuComponent menuComponent) {\n        menuComponents.add(menuComponent);\n    }\n \n    public void remove(MenuComponent menuComponent) {\n        menuComponents.remove(menuComponent);\n    }\n \n    public MenuComponent getChild(int i) {\n        return menuComponents.get(i);\n    }\n \n    public String getName() {\n        return name;\n    }\n \n    public String getDescription() {\n        return description;\n    }\n \n    public void print() {\n        System.out.print(\"\\n\" + getName());\n        System.out.println(\", \" + getDescription());\n        System.out.println(\"---------------------\");\n    }\n}\nImplementing the Composite Menu\nNow that we have the MenuItem, we just need the composite class, which we\u2019re \ncalling Menu. Remember, the composite class can hold MenuItems or other Menus. There\u2019s a couple of methods from MenuComponent this class doesn\u2019t implement, \ngetPrice() and isVegetarian(), because those don\u2019t make a lot of sense for a Menu. Menu can have any number of children \nof type MenuComponent. We\u2019ll use an \ninternal ArrayList to hold these. This is different than our old \nimplementation: we\u2019re going to give each \nMenu a name and a description. Before, \nwe just relied on having different classes \nfor each menu. Here\u2019s how you add MenuItems or \nother Menus to a Menu. Because \nboth MenuItems and Menus are \nMenuComponents, we just need one \nmethod to do both. You can also remove a MenuComponent \nor get a MenuComponent. Here are the getter methods for getting the name \nand description. Notice, we aren\u2019t overriding getPrice() or \nisVegetarian() because those methods don\u2019t make \nsense for a Menu (although you could argue that \nisVegetarian() might make sense). If someone tries \nto call those methods on a Menu, they\u2019ll get an \nUnsupportedOperationException. T\no print the Menu, we print its \nname and description. Menu is also a MenuComponent, \njust like MenuItem.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 404", "position": 404, "chunk_type": "semantic", "token_estimate": 293}
{"text": "you are here 4\u2003 \u2003 367: the iterator and composite patterns\npublic class Menu extends MenuComponent {\n    List<MenuComponent> menuComponents = new ArrayList<MenuComponent>();\n    String name;\n    String description;\n  \n    // constructor code here\n \n    // other methods here\n \n    public void print() {\n\t\nSystem.out.print(\"\\n\" + getName());\n\t\nSystem.out.println(\", \" + getDescription());\n\t\nSystem.out.println(\"---------------------\");\n  \n\t\nfor (MenuComponent menuComponent : menuComponents) {\n           menuComponent.print();\n\t\n}\n    }\n}\nLook! We get to use an Iterator behind \nthe scenes of the enhanced for loop. We \nuse it to iterate through all the Menu\u2019s \ncomponents...those could be other Menus, \nor they could be MenuItems. Good catch. Because Menu is a composite and contains \nboth MenuItems and other Menus, its print() method should \nprint everything it contains. If it doesn\u2019t, we\u2019ll have to iterate \nthrough the entire composite and print each item ourselves. That kind of defeats the purpose of having a composite \nstructure. As you\u2019re going to see, implementing print() correctly is easy \nbecause we can rely on each component to be able to print \nitself. It\u2019s all wonderfully recursive and groovy. Check it out:\nAll we need to do is change the print() method \nto make it print not only the information about \nthis Menu, but all of this Menu\u2019s components: \nother Menus and MenuItems. NOTE: If, during this iteration, we encounter another Menu object, \nits print() method will start another iteration, and so on. Fixing the print() method\nWait a sec, I don\u2019t \nunderstand the implementation of print(). I thought I was supposed to be able to apply the \nsame operations to a composite that I could to a leaf. If \nI apply print() to a composite with this implementation, \nall I get is a simple menu name and description. I don\u2019t \nget a printout of the COMPOSITE. Since both Menus and MenuItems \nimplement print(), we just call \nprint() and the rest is up to them.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 405", "position": 405, "chunk_type": "semantic", "token_estimate": 303}
{"text": "368\u2003 \u2003 Chapter 9: test drive the menu composite\npublic class Waitress {\n    MenuComponent allMenus;\n \n    public Waitress(MenuComponent allMenus) {\n        this.allMenus = allMenus;\n    }\n \n    public void printMenu() {\n        allMenus.print();\n    }\n}\nGetting ready for a test drive...\nIt\u2019s about time we took this code for a test drive, but we need to update the Waitress code before \nwe do\u2014after all, she\u2019s the main client of this code:\n \n \n \n \nA\nl\nl\n \nM\ne\nnu\ns\n \n \n \nD\ne\ns\ns\ne\nr\nt \nM\ne\nn\nu\nP\na\nn\nc\na\nk\ne\n \nHo\nu\ns\ne\n \nM\nenu\n \n \n \n \nD\ni\nn\ne\nr\n \nMe\nn\nu\n \n \n \n \n \nC\na\nf\ne\n \nMe\nn\nu\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\nComposite\nYup! The Waitress code really is this simple. Now we just hand her the top-level menu \ncomponent, the one that contains all the \nother menus. We\u2019ve called that allMenus. All she has to do to print the entire menu \nhierarchy\u2009\u2014\u2009all the menus and all the menu \nitems\u2009\u2014\u2009is call print() on the top-level menu. We\u2019re gonna have one happy Waitress. Okay, one last thing before we write our test drive. Let\u2019s get an idea of what the menu \ncomposite is going to look like at runtime:\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\n \n \n \nM\ne\nn\nu\nI\nt\nem\nThe top-level menu holds \nall menus and items. Each Menu \nholds items...\n...or items and \nother menus. Composite\nComposite\nLeaf\nEvery Menu and \nMenuItem implements the \nMenuComponent interface. Leaf\nLeaf\nLeaf", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 406", "position": 406, "chunk_type": "semantic", "token_estimate": 323}
{"text": "you are here 4\u2003 \u2003 369: the iterator and composite patterns\npublic class MenuTestDrive {\n    public static void main(String args[]) {\n        MenuComponent pancakeHouseMenu = \n            new Menu(\"PANCAKE HOUSE MENU\", \"Breakfast\");\n        MenuComponent dinerMenu = \n            new Menu(\"DINER MENU\", \"Lunch\");\n        MenuComponent cafeMenu = \n            new Menu(\"CAFE MENU\", \"Dinner\");\n        MenuComponent dessertMenu = \n            new Menu(\"DESSERT MENU\", \"Dessert of course! \");\n  \n        MenuComponent allMenus = new Menu(\"ALL MENUS\", \"All menus combined\");\n  \n        allMenus.add(pancakeHouseMenu);\n        allMenus.add(dinerMenu);\n        allMenus.add(cafeMenu);\n  \n        // add menu items here\n \n        dinerMenu.add(new MenuItem(\n            \"Pasta\",\n            \"Spaghetti with Marinara Sauce, and a slice of sourdough bread\",\n            true, \n            3.89));\n   \n        dinerMenu.add(dessertMenu);\n  \n        dessertMenu.add(new MenuItem(\n            \"Apple Pie\",\n            \"Apple pie with a flakey crust, topped with vanilla ice cream\",\n            true,\n            1.59));\n  \n        // add more menu items here\n  \n        Waitress waitress = new Waitress(allMenus);\n   \n        waitress.printMenu();\n    }\n}\nNow for the test drive... Okay, now we just need a test drive. Unlike our previous version, we\u2019re going to \nhandle all the menu creation in the test drive. We could ask each chef to give us \nhis new menu, but let\u2019s get it all tested first. Here\u2019s the code:\nLet\u2019s first create \nall the menu objects. We also need a top-\nlevel menu that we\u2019ll \nname allMenus. We\u2019re using the Composite add() method to add \neach menu to the top-level menu, allMenus. And we\u2019re also adding a menu to a \nmenu. All dinerMenu cares about is that \neverything it holds, whether it\u2019s a menu \nitem or a menu, is a MenuComponent. Add some apple pie to the \ndessert menu...\nOnce we\u2019ve constructed our \nentire menu hierarchy, we hand \nthe whole thing to the Waitress, \nand as you\u2019ve seen, it\u2019s as easy as \napple pie for her to print it out. Now we need to add all the menu \nitems. Here\u2019s one example; for \nthe rest, look at the complete \nsource code.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 407", "position": 407, "chunk_type": "semantic", "token_estimate": 288}
{"text": "you are here 4\u2003 \u2003 371: the iterator and composite patterns\nThere is some truth to that observation. We could \nsay that the Composite Pattern takes the Single Responsibility \nPrinciple and trades it for transparency. What\u2019s transparency? Well, by \nallowing the Component interface to contain the child management \noperations and the leaf operations, a client can treat both composites \nand leaves uniformly; so whether an element is a composite or leaf \nnode becomes transparent to the client. Now, given we have both types of operations in the Component \nclass, we lose a bit of safety because a client might try to do something \ninappropriate or meaningless on an element (like try to add a menu \nto a menu item). This is a design decision; we could take the design \nin the other direction and separate out the responsibilities into \ninterfaces. This would make our design safe, in the sense that any \ninappropriate calls on elements would be caught at compile time or \nruntime, but we\u2019d lose transparency and our code would have to use \nconditionals and the instanceof operator. So, to return to your question, this is a classic case of tradeoff. We \nare guided by design principles, but we always need to observe the \neffect they have on our designs. Sometimes we purposely do things \nin a way that seems to violate the principle. In some cases, however, \nthis is a matter of perspective; for instance, it might seem incorrect to \nhave child management operations in the leaves (like add(), remove(), \nand getChild()), but then again you can always shift your perspective \nand see a leaf as a node with zero children. What\u2019s the story? First you tell us One Class, One \nResponsibility, and now you\u2019re giving us a \npattern with two responsibilities in one class. The Composite Pattern manages a hierarchy \nAND it performs operations related to Menus.", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 409", "position": 409, "chunk_type": "semantic", "token_estimate": 309}
{"text": "372\u2003 \u2003 Chapter 9: interview with composite\nHeadFirst: We\u2019re here tonight speaking with the \nComposite Pattern. Why don\u2019t you tell us a little about \nyourself, Composite? Composite: Sure...I\u2019m the pattern to use when you have \ncollections of objects with whole-part relationships and \nyou want to be able to treat those objects uniformly. HeadFirst: Okay, let\u2019s dive right in here...what do you \nmean by whole-part relationships? Composite: Imagine a graphical user interface (GUI); \nthere you\u2019ll often find a top-level component like a Frame \nor a Panel, containing other components, like menus, \ntext panes, scrollbars, and buttons. So your GUI consists \nof several parts, but when you display it, you generally \nthink of it as a whole. You tell the top-level component \nto display, and count on that component to display all \nits parts. We call the components that contain other \ncomponents, composite objects, and components that don\u2019t \ncontain other components leaf  objects. HeadFirst: Is that what you mean by treating the objects \nuniformly? Having common methods you can call on \ncomposites and leaves? Composite: Right. I can tell a composite object to \ndisplay or a leaf object to display and it will do the right \nthing. The composite object will display by telling all its \ncomponents to display. HeadFirst: That implies that every object has the same \ninterface. What if you have objects in your composite that \ndo different things? Composite: In order for the composite to work \ntransparently to the client, you must implement the same \ninterface for all objects in the composite; otherwise, the \nclient has to worry about which interface each object \nis implementing, which kind of defeats the purpose. Obviously that means that at times you\u2019ll have objects for \nwhich some of the method calls don\u2019t make sense. HeadFirst: So how do you handle that? Composite: Well, there are a couple of ways to handle \nit; sometimes you can just do nothing, or return null or \nfalse\u2014whatever makes sense in your application. Other \ntimes you\u2019ll want to be more proactive and throw an \nexception. Of course, then the client has to be willing to \ndo a little work and make sure that the method call didn\u2019t \ndo something unexpected. HeadFirst: But if the client doesn\u2019t know which kind of \nobject they\u2019re dealing with, how would they ever know \nwhich calls to make without checking the type?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 410", "position": 410, "chunk_type": "semantic", "token_estimate": 388}
{"text": "372\u2003 \u2003 Chapter 9: Of course, then the client has to be willing to \ndo a little work and make sure that the method call didn\u2019t \ndo something unexpected. HeadFirst: But if the client doesn\u2019t know which kind of \nobject they\u2019re dealing with, how would they ever know \nwhich calls to make without checking the type? Composite: If you\u2019re a little creative you can structure \nyour methods so that the default implementations do \nsomething that does make sense. For instance, if the client \nis calling getChild() on the composite, this makes sense. And it makes sense on a leaf too, if you think of the leaf \nas an object with no children. HeadFirst: Ah...smart. But I\u2019ve heard some clients are \nso worried about this issue that they require separate \ninterfaces for different objects so they aren\u2019t allowed to \nmake nonsensical method calls. Is that still the Composite \nPattern? Composite: Yes. It\u2019s a much safer version of the \nComposite Pattern, but it requires the client to check the \ntype of every object before making a call so the object can \nbe cast correctly. HeadFirst: Tell us a little more about how these \ncomposite and leaf objects are structured. Composite: Usually it\u2019s a tree structure, some kind of \nhierarchy. The root is the top-level composite, and all its \nchildren are either composites or leaves. HeadFirst: Do children ever point back up to their \nparents? Composite: Yes, a component can have a pointer to a \nparent to make traversal of the structure easier. And, if \nThis week\u2019s interview: \nThe Composite Pattern, on implementation issues\nPatterns Exposed", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 410", "position": 410, "chunk_type": "semantic", "token_estimate": 262}
{"text": "you are here 4\u2003 \u2003 373: the iterator and composite patterns\nyou have a reference to a child and you need to delete it, \nyou\u2019ll need to get the parent to remove the child. Having \nthe parent reference makes that easier too. HeadFirst: There\u2019s really quite a lot to consider in your \nimplementation. Are there other issues we should think \nabout when implementing the Composite Pattern? Composite: Actually, there are. One is the ordering \nof children. What if you have a composite that needs to \nkeep its children in a particular order? Then you\u2019ll need a \nmore sophisticated management scheme for adding and \nremoving children, and you\u2019ll have to be careful about \nhow you traverse the hierarchy. HeadFirst: A good point I hadn\u2019t thought of. Composite: And did you think about caching? HeadFirst: Caching? Composite: Yeah, caching. Sometimes, if the \ncomposite structure is complex or expensive to traverse, \nit\u2019s helpful to implement caching of the composite nodes. For instance, if you are constantly traversing a composite \nand all its children to compute some result, you could \nimplement a cache that stores the result temporarily to \nsave traversals. HeadFirst: Well, there\u2019s a lot more to the Composite \nPatterns than I ever would have guessed. Before we wrap \nthis up, one more question: what do you consider your \ngreatest strength? Composite: I think I\u2019d definitely have to say simplifying \nlife for my clients. My clients don\u2019t have to worry about \nwhether they\u2019re dealing with a composite object or a \nleaf object, so they don\u2019t have to write if statements \neverywhere to make sure they\u2019re calling the right methods \non the right objects. Often, they can make one method \ncall and execute an operation over an entire structure. HeadFirst: That does sound like an important benefit. There\u2019s no doubt you\u2019re a useful pattern to have around \nfor collecting and managing objects. And, with that, we\u2019re \nout of time. Thanks so much for joining us and come \nback soon for another Patterns Exposed.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 411", "position": 411, "chunk_type": "semantic", "token_estimate": 328}
{"text": "374\u2003 \u2003 Chapter 9: crossword puzzle\nDesign Patterns Crossword\nWrap your brain around this composite crossword.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 412", "position": 412, "chunk_type": "semantic", "token_estimate": 15}
{"text": "1. Collection and Iterator are in this package.: 3. This class indirectly supports Iterator. 8. Iterators are usually created using this pattern (two \nwords). 12. A class should have only one reason to do this. 13. We encapsulated this. 15. User interface packages often use this pattern for \ntheir components. 16. Name of the principle that states only one \nresponsibility per class (two words). 17. This menu caused us to change our entire \nimplementation.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 412", "position": 412, "chunk_type": "semantic", "token_estimate": 74}
{"text": "2. Has no children.: 4. Merged with the Diner (two words). 5. The Iterator Pattern decouples the client from the \naggregate\u2019s ________. 6. A separate object that can traverse a collection. 7. HashMap values and ArrayList both implement this \ninterface. 9. We Java-enabled her. 10. A component can be a composite or this. 11. A composite holds these. 12. Third company acquired. 14. We deleted the PancakeHouseMenuIterator because \nthis class already provides an iterator. 1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nAcross\n1. Collection and Iterator are in this package\n3. This class indirectly supports Iterator. 8. Iterators are usually created using this \npattern. 12. A class should have only one reason to do \nthis. 13. We encapsulated this. 15. User interface packages often use this \npattern for their components. 16. Name of principle that states only one \nresponsibility per class. 17. This menu caused us to change our entire \nimplementation. Down\n2. Has no children. 4. Merged with the Diner. 5. The Iterator Pattern decouples the client \nfrom the aggregates _________. 6. A separate object that can traverse a \ncollection. 7. HashMap values and ArrayList both \nimplement this interface. 9. We java-enabled her. 10. A component can be a composite or this. 11. A composite holds these. 12. Third company acquired. 14. We deleted PancakeHouseMenuIterator \nbecause this class already provides an \niterator.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 412", "position": 412, "chunk_type": "semantic", "token_estimate": 233}
{"text": "you are here 4\u2003 \u2003 375: the iterator and composite patterns\nMatch each pattern with its description:\nPattern\nDescription\nStrategy\nAdapter\nIterator\nFacade\nComposite\nObserver\nClients treat collections \nof objects and individual \nobjects uniformly\nProvides a way to traverse \na collection of objects \nwithout exposing the \ncollection\u2019s implementation\nSimplifies the interface of \na group of classes\nChanges the interface of \none or more classes\nAllows a group of objects to \nbe notified when some state \nchanges\nEncapsulates interchangeable \nbehaviors and uses delegation to \ndecide which one to use", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 413", "position": 413, "chunk_type": "semantic", "token_estimate": 87}
{"text": "376\u2003 \u2003 Chapter 9: your design toolbox\nTools for your Design Toolbox\nTwo new patterns for your toolbox\u2014two great ways to \ndeal with collections of objects. Abstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it. OO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically. Decorators provide a flexible \nalternative to subclassing for extending \nfunctionality. Abstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes. Factory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate. Factory Method lets \na class defer instantiation to the \nsubclasses. Singleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it. Command - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Adapter - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Yet another important \nprinciple based on change \nin a design. Facade - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Another two-for-one \nchapter. T\nemplate Method - Define the \nskeleton of an algorithm in an operation, \n \ndeferring some steps to subclasses. T\nemplate Method lets subclasses \nredefine certain steps of an algorithm \nwithout changing the algorithm\u2019s \nstructure\nIterator - Provide a way to access \nthe elements of an aggregate object \nsequentially without exposing its \nunderlying representation\nComposite - Compose objects into \ntree structures to represent part-whole \nhierarchies. Composite lets clients treat \nindividual objects and compositions of \nobjects uniformly\nEncapsulate what varies\nFavor composition over inheritance. Program to interfaces, not \nimplementations. Strive for loosely coupled designs \nbetween objects that interact. Classes should be open for extension \nbut closed for modification. Depend on abstractions. Do not \ndepend on concrete classes. Only talk to your friends. Don\u2019t call us, we\u2019ll call you. A class should have only one reason \nto change. OO Principles\n\t\n\u0083\nAn Iterator allows access to an \naggregate\u2019s elements without \nexposing its internal structure.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 414", "position": 414, "chunk_type": "semantic", "token_estimate": 401}
{"text": "376\u2003 \u2003 Chapter 9: A class should have only one reason \nto change. OO Principles\n\t\n\u0083\nAn Iterator allows access to an \naggregate\u2019s elements without \nexposing its internal structure. \u0083\nAn Iterator takes the job of \niterating over an aggregate \nand encapsulates it in another \nobject. \u0083\nWhen using an Iterator, we \nrelieve the aggregate of the \nresponsibility of supporting \noperations for traversing its \ndata. \u0083\nAn Iterator provides a \ncommon interface for \ntraversing the items of an \naggregate, allowing you to use \npolymorphism when writing \ncode that makes use of the \nitems of the aggregate. \u0083\nThe Iterable interface provides \na means of getting an \niterator and enables Java\u2019s \nenchanced for loop. \u0083\nWe should strive to assign \nonly one responsibility to each \nclass. \u0083\nThe Composite Pattern allows \nclients to treat composites and \nindividual objects uniformly. \u0083\nA Component is any object \nin a Composite structure. Components may be other \ncomposites or leaves. \u0083\nThere are many design \ntradeoffs in implementing \nComposite. You need to \nbalance transparency and \nsafety with your needs.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 414", "position": 414, "chunk_type": "semantic", "token_estimate": 173}
{"text": "you are here 4\u2003 \u2003 377: the iterator and composite patterns\n\u274f   A. We are coding to the \nPancakeHouseMenu and DinerMenu \nconcrete implementations, not to an \ninterface. \u274f   B. The Waitress doesn\u2019t implement the \nJava Waitress API and so she isn\u2019t \nadhering to a standard. \u274f   C.\t If we decided to switch from using \nDinerMenu to another type of menu \nthat implemented its list of menu items \nwith a hash table, we\u2019d have to modify \na lot of code in the Waitress. \u274f   D.\t The Waitress needs to know how each \nmenu represents its internal collection of \nmenu items; this violates encapsulation. \u274f   E.\t We have duplicate code: the printMenu() \nmethod needs two separate loops to \niterate over the two different kinds of \nmenus. And if we added a third menu, \nwe\u2019d have yet another loop. \u274f   F.\t The implementation isn\u2019t based on \nMXML (Menu XML) and so isn\u2019t as \ninteroperable as it should be. Based on our implementation of printMenu(), which of the following apply? 1. 2. 3. Before looking at the next page, quickly jot down the three \nthings we have to do to this code to fit it into our framework:\nimplement the Menu interface\nget rid of getItems()\nadd createIterator() and return an Iterator that can step through the HashMap values", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 415", "position": 415, "chunk_type": "semantic", "token_estimate": 214}
{"text": "378\u2003 \u2003 Chapter 9: exercise solutions\nNotice that this Iterator \nimplementation does not \nsupport remove(). The unscrambled \u201cAlternating\u201d DinerMenu Iterator. Code Magnets Solution\n}\n}\n}\nimport java.util.Iterator;\nimport java.util.Calendar;\npublic MenuItem next() {\npublic AlternatingDinerMenuIterator(MenuItem[] items)\nthis.items = items;\nposition = Calendar.DAY_OF_WEEK % 2;\npublic void remove() {\nimplements Iterator<MenuItem>\npublic class AlternatingDinerMenuIterator\npublic boolean hasNext() {\nthrow new UnsupportedOperationException(\n    \"Alternating Diner Menu Iterator does not support remove()\");\nif (position >= items.length || items[position] == null) {\n    return false;\n} else {\n    return true;\n}\n}\nMenuItem menuItem = items[position];\nposition = position + 2;\nreturn menuItem;\n}\nMenuItem[] items;\nint position;\n}\n}", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 416", "position": 416, "chunk_type": "semantic", "token_estimate": 104}
{"text": "you are here 4\u2003 \u2003 379: the iterator and composite patterns\nMatch each pattern with its description:\nPattern\nDescription\nStrategy\nAdapter\nIterator\nFacade\nComposite\nObserver\nClients treat collections \nof objects and individual \nobjects uniformly\nProvides a way to traverse \na collection of objects \nwithout exposing the \ncollection\u2019s implementation\nSimplifies the interface of \na group of classes\nChanges the interface of \none or more classes\nAllows a group of objects to \nbe notified when some state \nchanges\nEncapsulates interchangeable \nbehaviors and uses delegation to \ndecide which one to use\nSOlUTion", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 417", "position": 417, "chunk_type": "semantic", "token_estimate": 88}
{"text": "380\u2003 \u2003 Chapter 9: crossword puzzle solution\nDesign Patterns Crossword Solution\nWrap your brain around this composite crossword. Here\u2019s our solution.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 418", "position": 418, "chunk_type": "semantic", "token_estimate": 20}
{"text": "Across: 1. Collection and Iterator are in this package \n[JAVA.UTIL] \n3. This class indirectly supports Iterator. [HASHMAP] \n8. Iterators are usually created using this \npattern. [FACTORYMETHOD] \n12. A class should have only one reason to do \nthis. [CHANGE] \n13. We encapsulated this. [ITERATION] \n15. User interface packages often use this \npattern for their components. [COMPOSITE] \n16. Name of principle that states only one \nresponsibility per class. [SINGLERESPONSIBILITY] \n17. This menu caused us to change our entire \nimplementation. [DESSERT] \nDown\n2. Has no children. [LEAF] \n4. Merged with the Diner. [PANCAKEHOUSE] \n5. The Iterator Pattern decouples the client \nfrom the aggregates _________. [IMPLEMENTATION] \n6. A separate object that can traverse a \ncollection. [ITERATOR] \n7. HashMap values and ArrayList both \nimplement this interface. [COLLECTION] \n9. We java-enabled her. [WAITRESS] \n10. A component can be a composite or this. [LEAF] \n11. A composite holds these. [COMPONENTS] \n12. Third company acquired. [CAFE] \n14. We deleted PancakeHouseMenuIterator \nbecause this class already provides an \niterator [ARRAYLIST]", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 418", "position": 418, "chunk_type": "semantic", "token_estimate": 160}
{"text": "this is a new chapter\u2003 \u2003 381: A little-known fact: the Strategy and State Patterns \nare twins separated at birth. You\u2019d think they\u2019d live similar lives, \nbut the Strategy Pattern went on to create a wildly successful business around \ninterchangeable algorithms, while State took the perhaps more noble path of helping \nobjects to control their behavior by changing their internal state. As different as their \npaths became, however, underneath you\u2019ll find almost precisely the same design. How \ncan that be? As you\u2019ll see, Strategy and State have very different intents. First, let\u2019s \ndig in and see what the State Pattern is all about, and then we\u2019ll return to explore their \nrelationship at the end of the chapter. 10  the State Pattern\nThe State of Things\nI thought things in Objectville were \ngoing to be so easy, but now every time I \nturn around there\u2019s another change request \ncoming in. I\u2019m at the breaking point! Oh, \nmaybe I should have been going to Betty\u2019s \nWednesday night patterns group all along. I\u2019m in such a state!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 419", "position": 419, "chunk_type": "semantic", "token_estimate": 173}
{"text": "you are here 4\u2003 \u2003 383: the state pattern\nCubicle Conversation\nJudy: This diagram looks like a state diagram. Joe: Right, each of those circles is a state...\nJudy:  ...and each of the arrows is a state transition. Frank: Slow down, you two, it\u2019s been too long since I studied state diagrams. Can you remind me what they\u2019re all about? Judy: Sure, Frank. Look at the circles; those are states. \u201cNo Quarter\u201d is \nprobably the starting state for the gumball machine because it\u2019s just sitting there \nwaiting for you to put your quarter in. All states are just different configurations \nof the machine that behave in a certain way and need some action to take them to \nanother state. Joe: Right. See, to go to another state, you need to do something like put a quarter in the machine. See the arrow \nfrom \u201cNo Quarter\u201d to \u201cHas Quarter\u201d? Frank: Yes...\nJoe: That just means that if the gumball machine is in the \u201cNo Quarter\u201d state and you put a quarter in, it will \nchange to the \u201cHas Quarter\u201d state. That\u2019s the state transition. Frank: Oh, I see! And if I\u2019m in the \u201cHas Quarter\u201d state, I can turn the crank and change to the \u201cGumball Sold\u201d \nstate, or eject the quarter and change back to the \u201cNo Quarter\u201d state. Judy: You got it! Frank: This doesn\u2019t look too bad then. We\u2019ve obviously got four states, and I think we also have four actions: \u201cinsert \nquarter,\u201d \u201ceject quarter,\u201d \u201cturn crank,\u201d and \u201cdispense.\u201d But...when we dispense, we test for zero or more gumballs \nin the \u201cGumball Sold\u201d state, and then either go to the \u201cOut of Gumballs\u201d state or the \u201cNo Quarter\u201d state. So we \nactually have five transitions from one state to another. Judy: That test for zero or more gumballs also implies we\u2019ve got to keep track of the number of gumballs too. Any \ntime the machine gives you a gumball, it might be the last one, and if it is, we need to transition to the \u201cOut of \nGumballs\u201d state. Joe: Also, don\u2019t forget that you could do nonsensical things, like try to eject the quarter when the gumball machine is \nin the \u201cNo Quarter\u201d state, or insert two quarters. Frank: Oh, I didn\u2019t think of that; we\u2019ll have to take care of those too. Joe: For every possible action we\u2019ll just have to check to see which state we\u2019re in and act appropriately.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 421", "position": 421, "chunk_type": "semantic", "token_estimate": 404}
{"text": "you are here 4\u2003 \u2003 383: Frank: Oh, I didn\u2019t think of that; we\u2019ll have to take care of those too. Joe: For every possible action we\u2019ll just have to check to see which state we\u2019re in and act appropriately. We can do \nthis! Let\u2019s start mapping the state diagram to code...\nJoe\nJudy\nFrank\nLet\u2019s take a look at this \ndiagram and see what the \nMighty Gumball guys want...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 421", "position": 421, "chunk_type": "semantic", "token_estimate": 69}
{"text": "384\u2003 \u2003 Chapter 10: review of state machines\nState machines 101 \ninsert quarter\neject quarter\nturn crank\nThese actions are \nthe gumball machine\u2019s \ninterface\u2009\u2014\u2009the things \nyou can do with it. How are we going to get from that state diagram to actual code? Here\u2019s a quick \nintroduction to implementing state machines:\nFirst, gather up your states:\n1\nGumball \n  Sold\n   No \nQuarter\n   Has \nQuarter\nOut of \nGumballs\nHere are the states\u2009\u2014\u2009four in total. Next, create an instance variable to hold the current state, and define values for each of the states:\n2\nfinal static int SOLD_OUT = 0;\nfinal static int NO_QUARTER = 1;\nfinal static int HAS_QUARTER = 2;\nfinal static int SOLD = 3;\n \nint state = SOLD_OUT;\nHere\u2019s each state represented \nas a unique integer...\n...and here\u2019s an instance variable that holds the \ncurrent state. We\u2019ll go ahead and set it to \u201cSold \nOut\u201d since the machine will be unfilled when it\u2019s \nfirst taken out of its box and turned on. Now we gather up all the actions that can happen in the system:\n3\nLooking at the diagram, invoking any of \nthese actions causes a state transition. dispense\nDispense is more of an internal \naction the machine invokes on itself. Let\u2019s just call \u201cOut of Gumballs\u201d \n\u201cSold Out\u201d for short.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 422", "position": 422, "chunk_type": "semantic", "token_estimate": 216}
{"text": "you are here 4\u2003 \u2003 385: the state pattern\npublic void insertQuarter() {\n    if (state == HAS_QUARTER) {\n        System.out.println(\"You can't insert another quarter\");\n    } else if (state == NO_QUARTER) {\n        state = HAS_QUARTER;\n        System.out.println(\"You inserted a quarter\");\n    } else if (state == SOLD_OUT) {\n        System.out.println(\"You can't insert a quarter, the machine is sold out\");\n    } else if (state == SOLD) {\n        System.out.println(\"Please wait, we're already giving you a gumball\");\n    }\n}\nNow we create a class that acts as the state machine. For each action, \nwe create a method that uses conditional statements to determine \nwhat behavior is appropriate in each state. For instance, for the \n\u201cinsert quarter\u201d action, we might write a method like this:\n4\nHere we\u2019re talking \nabout a common technique: \nmodeling state within an object \nby creating an instance variable to hold \nthe state values and writing conditional \ncode within our methods to handle \nthe various states. Each possible \nstate is checked \nwith a conditional \nstatement...\n...but can also transition to other states, \njust as depicted in the diagram. With that quick review, let\u2019s go implement the Gumball Machine! ...and exhibits the appropriate \nbehavior for each possible state...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 423", "position": 423, "chunk_type": "semantic", "token_estimate": 191}
{"text": "386\u2003 \u2003 Chapter 10: implement the gumball machine\npublic class GumballMachine {\n \n    final static int SOLD_OUT = 0;\n    final static int NO_QUARTER = 1;\n    final static int HAS_QUARTER = 2;\n    final static int SOLD = 3;\n \n    int state = SOLD_OUT;\n    int count = 0;\n  \n    public GumballMachine(int count) {\n        this.count = count;\n        if (count > 0) {\n            state = NO_QUARTER;\n        }\n    }\n \n    public void insertQuarter() {\n        if (state == HAS_QUARTER) {\n            System.out.println(\"You can't insert another quarter\");\n        } else if (state == NO_QUARTER) {\n            state = HAS_QUARTER;\n            System.out.println(\"You inserted a quarter\");\n        } else if (state == SOLD_OUT) {\n            System.out.println(\"You can't insert a quarter, the machine is sold out\");\n        } else if (state == SOLD) {\n            System.out.println(\"Please wait, we're already giving you a gumball\");\n        }\n    }\n   \nWriting the code\nHere are the four states; they match the \nstates in Mighty Gumball\u2019s state diagram. Here\u2019s the instance variable that is going \nto keep track of the current state we\u2019re \nin. We start in the SOLD_OUT state. We have a second instance variable that \nkeeps track of the number of gumballs \nin the machine. The constructor takes an initial inventory \nof gumballs. If the inventory isn\u2019t zero, \nthe machine enters state NO_QUARTER, \nmeaning it is waiting for someone to \ninsert a quarter; otherwise, it stays in \nthe SOLD_OUT state. Now we start implementing \nthe actions as methods.... When a quarter is inserted...\n...if a quarter is already \ninserted, we tell the \ncustomer...\n...otherwise, we accept the \nquarter and transition to \nthe HAS_QUARTER state. And if the machine is sold \nout, we reject the quarter. It\u2019s time to implement the Gumball Machine. We know we\u2019re going to have an instance \nvariable that holds the current state. From there, we just need to handle all the actions, \nbehaviors, and state transitions that can happen. For actions, we need to implement \ninserting a quarter, removing a quarter, turning the crank, and dispensing a gumball; we \nalso have the empty Gumball Machine condition to implement. If the customer just bought a \ngumball, he needs to wait until the \ntransaction is complete before \ninserting another quarter.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 424", "position": 424, "chunk_type": "semantic", "token_estimate": 345}
{"text": "you are here 4\u2003 \u2003 387: the state pattern\n \n \n    public void ejectQuarter() {\n        if (state == HAS_QUARTER) {\n            System.out.println(\"Quarter returned\");\n            state = NO_QUARTER;\n        } else if (state == NO_QUARTER) {\n            System.out.println(\"You haven't inserted a quarter\");\n        } else if (state == SOLD) {\n            System.out.println(\"Sorry, you already turned the crank\");\n        } else if (state == SOLD_OUT) {\n            System.out.println(\"You can't eject, you haven't inserted a quarter yet\");\n        }\n    }\n \n \n    public void turnCrank() {\n        if (state == SOLD) {\n            System.out.println(\"Turning twice doesn't get you another gumball! \");\n        } else if (state == NO_QUARTER) {\n            System.out.println(\"You turned but there's no quarter\");\n        } else if (state == SOLD_OUT) {\n            System.out.println(\"You turned, but there are no gumballs\");\n        } else if (state == HAS_QUARTER) {\n            System.out.println(\"You turned...\");\n            state = SOLD;\n            dispense();\n        }\n    }\n \n    public void dispense() {\n        if (state == SOLD) {\n            System.out.println(\"A gumball comes rolling out the slot\");\n            count = count - 1;\n            if (count == 0) {\n                System.out.println(\"Oops, out of gumballs! \");\n                state = SOLD_OUT;\n            } else {\n                state = NO_QUARTER;\n            }\n        } else if (state == NO_QUARTER) {\n            System.out.println(\"You need to pay first\");\n        } else if (state == SOLD_OUT) {\n            System.out.println(\"No gumball dispensed\");\n        } else if (state == HAS_QUARTER) {\n            System.out.println(\"You need to turn the crank\");\n        }\n    }\n \n    // other methods here like toString() and refill()\n}\nNow, if the customer tries to remove the quarter...\n...if there is a quarter, we \nreturn it and go back to the \nNO_QUARTER state... If the customer just \nturned the crank, we \ncan\u2019t give a refund; he \nalready has the gumball! ...otherwise, if there isn\u2019t \none we can\u2019t give it back. The customer tries to turn the crank...\nWe can\u2019t deliver \ngumballs; there \nare none. We need a \nquarter first. Success! They get a gumball. Change \nthe state to SOLD and call the \nmachine\u2019s dispense() method. Someone\u2019s trying to cheat the machine. You can\u2019t eject if the machine is sold \nout, it doesn\u2019t accept quarters! Called to dispense a gumball. Here\u2019s where we handle the \n\u201cout of gumballs\u201d condition: \nIf this was the last one, we \nset the machine\u2019s state to \nSOLD_OUT; otherwise, we\u2019re \nback to not having a quarter. We\u2019re in the \nSOLD state; give \n\u2019em a gumball! None of these should ever \nhappen, but if they do, \nwe give \u2019em an error, not \na gumball.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 425", "position": 425, "chunk_type": "semantic", "token_estimate": 378}
{"text": "388\u2003 \u2003 Chapter 10: test the gumball machine\npublic class GumballMachineTestDrive {\n    public static void main(String[] args) {\n        GumballMachine gumballMachine = new GumballMachine(5);\n        System.out.println(gumballMachine);\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        System.out.println(gumballMachine);\n        gumballMachine.insertQuarter();\n        gumballMachine.ejectQuarter();\n        gumballMachine.turnCrank();\n        System.out.println(gumballMachine);\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.ejectQuarter();\n        System.out.println(gumballMachine);\n        gumballMachine.insertQuarter();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        System.out.println(gumballMachine);\n    }\n}\nIn-house testing\nThat feels like a nice solid design using a well-thought-out methodology, doesn\u2019t \nit? Let\u2019s do a little in-house testing before we hand it off to Mighty Gumball to \nbe loaded into their actual gumball machines. Here\u2019s our test harness:\nLoad it up with five \ngumballs total. Print out the state of the machine. Throw a quarter in... Turn the crank; we should get our gumball. Print out the state of the machine again. Throw a quarter in... Ask for it back. Turn the crank; we shouldn\u2019t get our gumball. Print out the state of the machine again. Throw a quarter in... Turn the crank; we should get our gumball. Throw a quarter in... Turn the crank; we should get our gumball. Ask for a quarter back we didn\u2019t put in. Print out the state of the machine again. Throw TWO quarters in... Turn the crank; we should get our gumball. Now for the stress testing...\nPrint that machine state one more time.", "domains": ["Design Patterns", "Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 426", "position": 426, "chunk_type": "semantic", "token_estimate": 210}
{"text": "you are here 4\u2003 \u2003 389: the state pattern\nFile  Edit   Window  Help  mightygumball.com\n%java GumballMachineTestDrive\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 5 gumballs\nMachine is waiting for quarter\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 4 gumballs\nMachine is waiting for quarter\nYou inserted a quarter\nQuarter returned\nYou turned but there's no quarter\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 4 gumballs\nMachine is waiting for quarter\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot\nYou haven't inserted a quarter\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 2 gumballs\nMachine is waiting for quarter\nYou inserted a quarter\nYou can't insert another quarter\nYou turned...\nA gumball comes rolling out the slot\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot\nOops, out of gumballs! You can't insert a quarter, the machine is sold out\nYou turned, but there are no gumballs\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 0 gumballs\nMachine is sold out", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 427", "position": 427, "chunk_type": "semantic", "token_estimate": 202}
{"text": "you are here 4\u2003 \u2003 391: the state pattern\nDraw a state diagram for a Gumball Machine that handles the 1 in 10 \ncontest. In this contest, 10% of the time the Sold state leads to two \nballs being released, not one. Check your answer with ours (at the \nend of the chapter) to make sure we agree before you go further... Mighty Gumball, Inc.\nWhere the Gumball Machine \nis Never Half Empty\nUse Mighty Gumball\u2019s stationery to draw your state diagram. Design Puzzle", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 429", "position": 429, "chunk_type": "semantic", "token_estimate": 83}
{"text": "392\u2003 \u2003 Chapter 10: things get messy\nThe messy STATE of things...\nJust because you\u2019ve written your gumball machine using a well-thought-out \nmethodology doesn\u2019t mean it\u2019s going to be easy to extend. In fact, when you go back \nand look at your code and think about what you\u2019ll have to do to modify it, well...\nfinal static int SOLD_OUT = 0;\nfinal static int NO_QUARTER = 1;\nfinal static int HAS_QUARTER = 2;\nfinal static int SOLD = 3;\npublic void insertQuarter() {\n    // insert quarter code here\n}\npublic void ejectQuarter() {\n    // eject quarter code here\n}\npublic void turnCrank() {\n    // turn crank code here\n}\npublic void dispense() {\n    // dispense code here\n}\nFirst, you\u2019d have to add a new WINNER state \nhere. That isn\u2019t too bad...\n...but then, you\u2019d have to add a new conditional \nin every single method to handle the WINNER \nstate; that\u2019s a lot of code to modify. turnCrank() will get especially messy, because you\u2019d \nhave to add code to check to see whether you\u2019ve \ngot a WINNER and then switch to either the \nWINNER state or the SOLD state. \u274f   A. This code certainly isn\u2019t adhering to the \nOpen Closed Principle. \u274f   B. This code would make a FORTRAN \nprogrammer proud. \u274f   C.\t This design isn\u2019t even very object-\noriented. \u274f   D.\t State transitions aren\u2019t explicit; they \nare buried in the middle of a bunch of \nconditional statements. \u274f   E.\t We haven\u2019t encapsulated anything that \nvaries here. \u274f   F.\t Further additions are likely to cause bugs \nin working code. Which of the following describe the state of our implementation? (Choose all that apply.)", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 430", "position": 430, "chunk_type": "semantic", "token_estimate": 272}
{"text": "you are here 4\u2003 \u2003 393: the state pattern\nFrank: You\u2019re right about that! We need to refactor this code so that it\u2019s easy \nto maintain and modify. Judy: We really should try to localize the behavior for each state so that if we \nmake changes to one state, we don\u2019t run the risk of messing up the other code. Frank: Right; in other words, follow that ol\u2019 \u201cencapsulate what varies\u201d \nprinciple. Judy: Exactly. Frank:: If we put each state\u2019s behavior in its own class, then every state just \nimplements its own actions. Judy: Right. And maybe the Gumball Machine can just delegate to the state \nobject that represents the current state. Frank: Ah, you\u2019re good: favor composition...more principles at work. Judy: Cute. Well, I\u2019m not 100% sure how this is going to work, but I think \nwe\u2019re on to something. Frank: I wonder if this will make it easier to add new states? Judy: I think so...  We\u2019ll still have to change code, but the changes will be \nmuch more limited in scope because adding a new state will mean we just \nhave to add a new class and maybe change a few transitions here and there. Frank: I like the sound of that. Let\u2019s start hashing out this new design! Okay, this isn\u2019t good. I think \nour first version was great, but it isn\u2019t \ngoing to hold up over time as Mighty Gumball \nkeeps asking for new behavior. The rate of bugs \nis just going to make us look bad, not to mention \nthe CEO will drive us crazy.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 431", "position": 431, "chunk_type": "semantic", "token_estimate": 260}
{"text": "394\u2003 \u2003 Chapter 10: a new state design\nThe new design\n1\n2\n3\nFirst, we\u2019re going to define a State interface that \ncontains a method for every action in the Gumball \nMachine. Then we\u2019re going to implement a State class for \nevery state of the machine. These classes will be \nresponsible for the behavior of the machine when it \nis in the corresponding state. Finally, we\u2019re going to get rid of all of our conditional \ncode and instead delegate the work to the State class. It looks like we\u2019ve got a new plan: instead of maintaining our existing code, we\u2019re going to \nrework it to encapsulate state objects in their own classes and then delegate to the current \nstate when an action occurs. We\u2019re following our design principles here, so we should end up with a design that is easier to \nmaintain down the road. Here\u2019s how we\u2019re going to do it:\nNot only are we following design principles, as you\u2019ll see, we\u2019re actually implementing the \nState Pattern. But we\u2019ll get to all the official State Pattern stuff after we rework our code...\nNow we\u2019re going \nto put all the behavior of a \nstate into one class. That way, \nwe\u2019re localizing the behavior and \nmaking things a lot easier to \nchange and understand.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 432", "position": 432, "chunk_type": "semantic", "token_estimate": 213}
{"text": "you are here 4\u2003 \u2003 395: the state pattern\nDefining the State interfaces and classes\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\n<<interface>>\nState\nHasQuarterState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nNoQuarterState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nSoldOutState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\npublic class GumballMachine {\n \n    final static int SOLD_OUT = 0;\n    final static int NO_QUARTER = 1;\n    final static int HAS_QUARTER = 2;\n    final static int SOLD = 3;\n \n    int state = SOLD_OUT;\n    int count = 0;\n...and we map each state \ndirectly to a class. Here\u2019s the interface for all states. The methods map directly \nto actions that could happen to the Gumball Machine (these \nare the same methods as in the previous code). First let\u2019s create an interface for State, which all our states implement:\nT\no figure out what \nstates we need, we look \nat our previous code...\nThen take each state in our design and \nencapsulate it in a class that implements \nthe State interface. SoldState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nWinnerState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nDon\u2019t forget, we need a new \u201cwinner\u201d state \ntoo that implements the State interface. We\u2019ll \ncome back to this after we reimplement the \nfirst version of the Gumball Machine.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 433", "position": 433, "chunk_type": "semantic", "token_estimate": 192}
{"text": "you are here 4\u2003 \u2003 397: the state pattern\npublic class NoQuarterState implements State {\n    GumballMachine gumballMachine;\n \n    public NoQuarterState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n \n    public void insertQuarter() {\n        System.out.println(\"You inserted a quarter\");\n        gumballMachine.setState(gumballMachine.getHasQuarterState());\n    }\n \n    public void ejectQuarter() {\n        System.out.println(\"You haven't inserted a quarter\");\n    }\n \n    public void turnCrank() {\n        System.out.println(\"You turned, but there's no quarter\");\n     }\n \n    public void dispense() {\n        System.out.println(\"You need to pay first\");\n    } \n}\nImplementing our State classes\nTime to implement a state: we know what behaviors we want; we just need to get it down in code. We\u2019re going to \nclosely follow the state machine code we wrote, but this time everything is broken out into different classes. Let\u2019s start with the NoQuarterState:\nFirst we need to implement the State interface. We get passed a reference to \nthe Gumball Machine through the \nconstructor. We\u2019re just going to \nstash this in an instance variable. If someone inserts a quarter, \nwe print a message saying the \nquarter was accepted and then \nchange the machine\u2019s state to \nthe HasQuarterState. You can\u2019t get money \nback if you never gave \nit to us! And you can\u2019t get a gumball \nif you don\u2019t pay us. What we\u2019re doing is \nimplementing the behaviors that \nare appropriate for the state \nwe\u2019re in. In some cases, this behavior \nincludes moving the Gumball \nMachine to a new state. We can\u2019t be dispensing \ngumballs without payment. You\u2019ll see how these \nwork in just a sec...", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 435", "position": 435, "chunk_type": "semantic", "token_estimate": 237}
{"text": "398\u2003 \u2003 Chapter 10: state objects in the gumball machine\nIn the GumballMachine, we update the \ncode to use the new classes rather than \nthe static integers. The code is quite \nsimilar, except that in one class we have \nintegers and in the other objects...\nBefore we finish the State classes, we\u2019re going to rework the Gumball \nMachine\u2014that way, you can see how it all fits together. We\u2019ll start \nwith the state-related instance variables and switch the code from \nusing integers to using state objects:\nReworking the Gumball Machine\nOld code\nNew code\nAll the State objects are created \nand assigned in the constructor. This now holds a \nState object, not \nan integer. public class GumballMachine {\n \n    final static int SOLD_OUT = 0;\n    final static int NO_QUARTER = 1;\n    final static int HAS_QUARTER = 2;\n    final static int SOLD = 3;\n \n    int state = SOLD_OUT;\n    int count = 0;\npublic class GumballMachine {\n \n    State soldOutState;\n    State noQuarterState;\n    State hasQuarterState;\n    State soldState;\n \n    State state = soldOutState;\n    int count = 0;", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 436", "position": 436, "chunk_type": "semantic", "token_estimate": 168}
{"text": "you are here 4\u2003 \u2003 399: the state pattern\npublic class GumballMachine {\n \n    State soldOutState;\n    State noQuarterState;\n    State hasQuarterState;\n    State soldState;\n \n    State state;\n    int count = 0;\n \n    public GumballMachine(int numberGumballs) {\n        soldOutState = new SoldOutState(this);\n        noQuarterState = new NoQuarterState(this);\n        hasQuarterState = new HasQuarterState(this);\n        soldState = new SoldState(this);\n        this.count = numberGumballs;\n        if (numberGumballs > 0) {\n            state = noQuarterState;\n        } else {\n            state = soldOutState;\n        }\n    }\n \n    public void insertQuarter() {\n        state.insertQuarter();\n    }\n    public void ejectQuarter() {\n        state.ejectQuarter();\n    }\n    public void turnCrank() {\n        state.turnCrank();\n        state.dispense();\n    }\n    void setState(State state) {\n        this.state = state;\n    }\n \n    void releaseBall() {\n        System.out.println(\"A gumball comes rolling out the slot...\");\n        if (count > 0) {\n            count = count - 1;\n        }\n    }\n    // More methods here including getters for each State...\n}\nNow, let\u2019s look at the complete GumballMachine class... Here are all the States again...\n...and the State instance variable. The count instance variable holds the count \nof gumballs\u2009\u2014\u2009initially the machine is empty. Our constructor takes the initial \nnumber of gumballs and stores it \nin an instance variable. It also creates the State \ninstances, one of each. If there are more than 0 gumballs we \nset the state to the NoQuarterState; \notherwise, we start in the SoldOutState. Now for the actions. These are \nVERY EASY to implement now. We \njust delegate to the current state. Note that we don\u2019t need an \naction method for dispense() in \nGumballMachine because it\u2019s just an \ninternal action; a user can\u2019t ask the \nmachine to dispense directly. But we \ndo call dispense() on the State object \nfrom the turnCrank() method. The machine supports a releaseBall() \nhelper method that releases the ball and \ndecrements the count instance variable. This method allows other objects (like \nour State objects) to transition the \nmachine to a different state. This includes methods like getNoQuarterState() for getting each \nstate object, and getCount() for getting the gumball count.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 437", "position": 437, "chunk_type": "semantic", "token_estimate": 311}
{"text": "400\u2003 \u2003 Chapter 10: more states for the gumball machine\npublic class HasQuarterState implements State {\n    GumballMachine gumballMachine;\n \n    public HasQuarterState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n  \n    public void insertQuarter() {\n        System.out.println(\"You can't insert another quarter\");\n    }\n \n    public void ejectQuarter() {\n        System.out.println(\"Quarter returned\");\n        gumballMachine.setState(gumballMachine.getNoQuarterState());\n    }\n \n    public void turnCrank() {\n        System.out.println(\"You turned...\");\n        gumballMachine.setState(gumballMachine.getSoldState());\n    }\n    public void dispense() {\n        System.out.println(\"No gumball dispensed\");\n    }\n}\nImplementing more states\nNow that you\u2019re starting to get a feel for how the Gumball Machine and the states \nfit together, let\u2019s implement the HasQuarterState and the SoldState classes...\nAn inappropriate \naction for this \nstate. Another \ninappropriate \naction for this \nstate. Return the customer\u2019s \nquarter and \ntransition back to the \nNoQuarterState. When the crank is \nturned we transition \nthe machine to the \nSoldState state by \ncalling its setState() \nmethod and passing it \nthe SoldState object. The SoldState object \nis retrieved by the \ngetSoldState() \ngetter method  \n(there is one of these \ngetter methods for \neach state). When the state is instantiated \nwe pass it a reference to the \nGumballMachine. This is used \nto transition the machine to a \ndifferent state.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 438", "position": 438, "chunk_type": "semantic", "token_estimate": 179}
{"text": "you are here 4\u2003 \u2003 401: the state pattern\npublic class SoldState implements State {\n    //constructor and instance variables here\n \n    public void insertQuarter() {\n        System.out.println(\"Please wait, we're already giving you a gumball\");\n    }\n \n    public void ejectQuarter() {\n        System.out.println(\"Sorry, you already turned the crank\");\n    }\n \n    public void turnCrank() {\n        System.out.println(\"Turning twice doesn't get you another gumball! \");\n    }\n \n    public void dispense() {\n        gumballMachine.releaseBall();\n        if (gumballMachine.getCount() > 0) {\n            gumballMachine.setState(gumballMachine.getNoQuarterState());\n        } else {\n            System.out.println(\"Oops, out of gumballs! \");\n            gumballMachine.setState(gumballMachine.getSoldOutState());\n        }\n    }\n}\nNow, let\u2019s check out the SoldState class... Here are all the \ninappropriate \nactions for this \nstate. And here\u2019s where the \nreal work begins...\nWe\u2019re in the SoldState, which means the \ncustomer paid. So, we first need to ask \nthe machine to release a gumball. Then we ask the machine what the gumball \ncount is, and either transition to the \nNoQuarterState or the SoldOutState. Look back at the GumballMachine implementation. If the crank is turned and \nnot successful (say the customer didn\u2019t insert a quarter first), we call dispense() \nanyway, even though it\u2019s unnecessary. How might you fix this?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 439", "position": 439, "chunk_type": "semantic", "token_estimate": 177}
{"text": "402\u2003 \u2003 Chapter 10: your turn to implement a state\npublic class SoldOutState implements _______________  {\n    GumballMachine gumballMachine;\n \n    public SoldOutState(GumballMachine gumballMachine) {\n    }\n \n    public void insertQuarter() {\n    }\n \n    public void ejectQuarter() {\n    }\n    public void turnCrank() {\n    }\n    public void dispense() {\n    }\n}\nWe have one remaining class we haven\u2019t implemented: SoldOutState. Why don\u2019t you implement it? To do this, carefully think through how the \nGumball Machine should behave in each situation. Check your answer \nbefore moving on...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 440", "position": 440, "chunk_type": "semantic", "token_estimate": 78}
{"text": "you are here 4\u2003 \u2003 403: the state pattern\nFor starters, you now have a Gumball Machine implementation that is structurally quite \ndifferent from your first version, and yet functionally it is exactly the same. By structurally \nchanging the implemention, you\u2019ve:\n\u2003\n\u0083\nLocalized the behavior of each state into its own class. \u0083\nRemoved all the troublesome if statements that would have been difficult to maintain. \u0083\nClosed each state for modification, and yet left the Gumball Machine open to extension \nby adding new state classes (and we\u2019ll do this in a second). \u0083\nCreated a code base and class structure that maps much more closely to the Mighty \nGumball diagram and is easier to read and understand. Now let\u2019s look a little more at the functional aspect of what we did:\nLet\u2019s take a look at what we\u2019ve done so far...\nGumball Machine States\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\ncurrent state\nThe Gumball Machine now holds an \ninstance of each State class. The current state of the \nmachine is always one of \nthese class instances.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 441", "position": 441, "chunk_type": "semantic", "token_estimate": 209}
{"text": "404\u2003 \u2003 Chapter 10: state transitions\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nGumball Machine States\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nGumball Machine States\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\ncurrent state\nturnCrank()\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\ncurrent state\nWhen an action is called, it is \ndelegated to the current state. In this case, the turnCrank() \nmethod is being called when the \nmachine is in the HasQuarter \nstate, so as a result the machine \ntransitions to the Sold state. ....and then the \nmachine will \neither go to \nthe SoldOut \nor NoQuarter \nstate depending \non the number of \ngumballs remaining \nin the machine. The machine enters \nthe Sold state and a \ngumball is dispensed...\nturnCrank()\nMore gumballs\nSold out", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 442", "position": 442, "chunk_type": "semantic", "token_estimate": 173}
{"text": "you are here 4\u2003 \u2003 405: the state pattern\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nGumball Machine States\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nGumball Machine States\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nGumball Machine States\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \n \n \n \n \nS\no\nl\nd\nGumball Machine States\n1\n2\n4\n3\nBehind the Scenes: \nSelf-Guided Tour\nTrace the steps of the Gumball Machine starting with the NoQuarter state. Also annotate the diagram with actions \nand output of the machine. For this exercise you can assume there are plenty of gumballs in the machine.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 443", "position": 443, "chunk_type": "semantic", "token_estimate": 222}
{"text": "406\u2003 \u2003 Chapter 10: state pattern defined\nThe State Pattern defined\nThe State Pattern allows an object to alter its behavior \nwhen its internal state changes. The object will appear to \nchange its class. request()\nContext\nYes, it\u2019s true, we just implemented the State Pattern! So now, let\u2019s take a look at what it\u2019s all about:\nThe first part of this description makes a lot of sense, right? Because the pattern encapsulates \nstate into separate classes and delegates to the object representing the current state, we know \nthat behavior changes along with the internal state. The Gumball Machine provides a good \nexample: when the gumball machine is in the NoQuarterState and you insert a quarter, you get \ndifferent behavior (the machine accepts the quarter) than if you insert a quarter when it\u2019s in the \nHasQuarterState (the machine rejects the quarter). What about the second part of the definition? What does it mean for an object to \u201cappear to \nchange its class\u201d? Think about it from the perspective of a client: if an object you\u2019re using can \ncompletely change its behavior, then it appears to you that the object is actually instantiated from \nanother class. In reality, however, you know that we are using composition to give the appearance \nof a class change by simply referencing different state objects. Okay, now it\u2019s time to check out the State Pattern class diagram:\nstate.handle()\nhandle()\nState\nhandle()\nConcreteStateA\nhandle()\nConcreteStateB\nMany concrete \nstates are possible. The Context is the class that  \ncan have a number of internal \nstates. In our example, the \nGumballMachine is the Context. Whenever the request() is \nmade on the Context\u200a\n, it \nis delegated to the state \nto handle. The State interface defines a common \ninterface for all concrete states; the \nstates all implement the same interface, \nso they are interchangeable. ConcreteStates handle requests from the \nContext. Each ConcreteState provides its \nown implementation for a request. In this \nway, when the Context changes state, its \nbehavior will change as well.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 444", "position": 444, "chunk_type": "semantic", "token_estimate": 330}
{"text": "you are here 4\u2003 \u2003 407: the state pattern\nYou\u2019ve got a good eye (or you read the beginning of the chapter)! Yes, the class diagrams are essentially the same, but the two patterns \ndiffer in their intent. With the State Pattern, we have a set of behaviors encapsulated in \nstate objects; at any time the context is delegating to one of those \nstates. Over time, the current state changes across the set of state \nobjects to reflect the internal state of the context, so the context\u2019s \nbehavior changes over time as well. The client usually knows very \nlittle, if anything, about the state objects. With Strategy, the client usually specifies the strategy object that \nthe context is composed with. Now, while the pattern provides the \nflexibility to change the strategy object at runtime, often there is \na strategy object that is most appropriate for a context object. For \ninstance, in Chapter 1, some of our ducks were configured to fly \nwith typical flying behavior (like mallard ducks), while others were \nconfigured with a fly behavior that kept them grounded (like rubber \nducks and decoy ducks). In general, think of the Strategy Pattern as a flexible alternative to \nsubclassing; if you use inheritance to define the behavior of a class, \nthen you\u2019re stuck with that behavior even if you need to change it. With Strategy you can change the behavior by composing with a \ndifferent object. Think of the State Pattern as an alternative to putting lots of \nconditionals in your context; by encapsulating the behaviors within \nstate objects, you can simply change the state object in context to \nchange its behavior. Wait a sec; from what \nI remember of the Strategy \nPattern, this class diagram is \nEXACTLY the same.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 445", "position": 445, "chunk_type": "semantic", "token_estimate": 289}
{"text": "408\u2003 \u2003 Chapter 10: q&a about the state pattern\nQ: In GumballMachine, the states decide what the \nnext state should be. Do the ConcreteStates always \ndecide what state to go to next? A: No, not always. The alternative is to let the Context \ndecide on the flow of state transitions. As a general guideline, when the state transitions are fixed \nthey are appropriate for putting in the Context; however, \nwhen the transitions are more dynamic, they are typically \nplaced in the state classes themselves (for instance, in \nGumballMachine the choice of the transition to NoQuarter or \nSoldOut depended on the runtime count of gumballs). The disadvantage of having state transitions in the state \nclasses is that we create dependencies between the state \nclasses. In our implementation of GumballMachine we tried \nto minimize this by using getter methods on the Context, \nrather than hardcoding explicit concrete state classes. Notice that by making this decision, you are making a \ndecision as to which classes are closed for modification\u2014\nthe Context or the state classes\u2014as the system evolves. Q: Do clients ever interact directly with the states? A: No. The states are used by the Context to represent \nits internal state and behavior, so all requests to the states \ncome from the Context. Clients don\u2019t directly change the \nstate of the Context. It is the Context\u2019s job to oversee its \nstate, and you don\u2019t usually want a client changing the state \nof a Context without that Context\u2019s knowledge. Q: If I have lots of instances of the Context in my \napplication, is it possible to share the state objects \nacross them? A: Yes, absolutely, and in fact this is a very common \nscenario. The only requirement is that your state objects do \nnot keep their own internal context; otherwise, you\u2019d need a \nunique instance per context. To share your states, you\u2019ll typically assign each state to a \nstatic instance variable. If your state needs to make use of \nmethods or instance variables in your Context, you\u2019ll also \nhave to give it a reference to the Context in each handler() \nmethod. Q: It seems like using the State Pattern always \nincreases the number of classes in our designs. Look \nhow many more classes our GumballMachine had than \nthe original design! A: You\u2019re right; by encapsulating state behavior \ninto separate state classes, you\u2019ll always end up with \nmore classes in your design.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 446", "position": 446, "chunk_type": "semantic", "token_estimate": 396}
{"text": "408\u2003 \u2003 Chapter 10: Look \nhow many more classes our GumballMachine had than \nthe original design! A: You\u2019re right; by encapsulating state behavior \ninto separate state classes, you\u2019ll always end up with \nmore classes in your design. That\u2019s often the price you \npay for flexibility. Unless your code is some \u201cone-off\u201d \nimplementation you\u2019re going to throw away (yeah, right), \nconsider building it with the additional classes and you\u2019ll \nprobably thank yourself down the road. Note that often what \nis important is the number of classes that you expose to \nyour clients, and there are ways to hide these extra classes \nfrom your clients (say, by declaring them package private). Also, consider the alternative: if you have an application \nthat has a lot of state and you decide not to use separate \nobjects, you\u2019ll instead end up with very large, monolithic \nconditional statements. This makes your code hard to \nmaintain and understand. By using objects, you make states \nexplicit and reduce the effort needed to understand and \nmaintain your code. Q: The State Pattern class diagram shows that State \nis an abstract class. But didn\u2019t you use an interface in \nthe implementation of the gumball machine\u2019s state? A: Yes. Given we had no common functionality to put \ninto an abstract class, we went with an interface. In your \nown implementation, you might want to consider an abstract \nclass. Doing so has the benefit of allowing you to add \nmethods to the abstract class later, without breaking the \nconcrete state implementations.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 446", "position": 446, "chunk_type": "semantic", "token_estimate": 248}
{"text": "you are here 4\u2003 \u2003 409: the state pattern\npublic class WinnerState implements State {\n \n    // instance variables and constructor\n    // insertQuarter error message\n    // ejectQuarter error message\n    // turnCrank error message\n \n    public void dispense() {\n        gumballMachine.releaseBall();\n        if (gumballMachine.getCount() == 0) {\n            gumballMachine.setState(gumballMachine.getSoldOutState());\n        } else {\n            gumballMachine.releaseBall();\n            System.out.println(\"YOU'RE A WINNER! You got two gumballs for your quarter\");\n            if (gumballMachine.getCount() > 0) {\n                gumballMachine.setState(gumballMachine.getNoQuarterState());\n            } else {\n                System.out.println(\"Oops, out of gumballs! \");\n                gumballMachine.setState(gumballMachine.getSoldOutState());\n            }\n        }\n    }\n}\npublic class GumballMachine {\n \n    State soldOutState;\n    State noQuarterState;\n    State hasQuarterState;\n    State soldState;\n    State winnerState;\n \n    State state = soldOutState;\n    int count = 0;\n    // methods here\n}\nWe still need to finish the Gumball 1 in 10 game\nRemember, we\u2019re not done yet. We\u2019ve got a game to implement, but now that we\u2019ve got the State \nPattern implemented, it should be a breeze. First, we need to add a state to the GumballMachine class:\nAll you need to add here is \nthe new WinnerState and \ninitialize it in the constructor. Now let\u2019s implement the WinnerState class; it\u2019s remarkably similar to the SoldState class:\nHere we release two gumballs and then \neither go to the NoQuarterState or \nthe SoldOutState. Just like SoldState. If we have a second gumball, we release it. Don\u2019t forget you also have \nto add a getter method for \nWinnerState too. If we were able \nto release two \ngumballs, we let \nthe user know \nhe was a winner.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 447", "position": 447, "chunk_type": "semantic", "token_estimate": 234}
{"text": "410\u2003 \u2003 Chapter 10: implementing the 1 in 10 game\npublic class HasQuarterState implements State {\n    Random randomWinner = new Random(System.currentTimeMillis());\n    GumballMachine gumballMachine;\n \n    public HasQuarterState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n  \n    public void insertQuarter() {\n        System.out.println(\"You can't insert another quarter\");\n    }\n \n    public void ejectQuarter() {\n        System.out.println(\"Quarter returned\");\n        gumballMachine.setState(gumballMachine.getNoQuarterState());\n    }\n \n    public void turnCrank() {\n        System.out.println(\"You turned...\");\n        int winner = randomWinner.nextInt(10);\n        if ((winner == 0) && (gumballMachine.getCount() > 1)) {\n            gumballMachine.setState(gumballMachine.getWinnerState());\n        } else {\n            gumballMachine.setState(gumballMachine.getSoldState());\n        }\n    }\n    public void dispense() {\n        System.out.println(\"No gumball dispensed\");\n    }\n}\nFirst we add a \nrandom number \ngenerator to \ngenerate the 10% \nchance of winning...\nFinishing the game\nWe\u2019ve got just one more change to make: we need to implement the random \nchance game and add a transition to the WinnerState. We\u2019re going to add both to \nthe HasQuarterState since that\u2019s where the customer turns the crank:\n...then we determine \nif this customer won. Wow, that was pretty simple to implement! We just added a new state to the GumballMachine \nand then implemented it. All we had to do from there was to implement our chance game and \ntransition to the correct state. It looks like our new code strategy is paying off... If they won, and there\u2019s enough gumballs \nleft for them to get two, we go to \nWinnerState; otherwise, we go to \nSoldState (just like we always did).", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 448", "position": 448, "chunk_type": "semantic", "token_estimate": 222}
{"text": "you are here 4\u2003 \u2003 411: the state pattern\npublic class GumballMachineTestDrive {\n    public static void main(String[] args) {\n        GumballMachine gumballMachine = new GumballMachine(5);\n        System.out.println(gumballMachine);\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        System.out.println(gumballMachine);\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        gumballMachine.insertQuarter();\n        gumballMachine.turnCrank();\n        System.out.println(gumballMachine);\n    }\n}\nDemo for the CEO of Mighty Gumball, Inc. The CEO of Mighty Gumball has dropped by for a demo of your new gumball game code. Let\u2019s \nhope those states are all in order! We\u2019ll keep the demo short and sweet (the short attention span of \nCEOs is well documented), but hopefully long enough so that we\u2019ll win at least once. This code really hasn\u2019t changed at all; \nwe just shortened it a bit. Once, again, start with a gumball \nmachine with 5 gumballs. We want to get a winning state, \nso we just keep pumping in those \nquarters and turning the crank. We \nprint out the state of the gumball \nmachine every so often... The whole engineering team is waiting \noutside the conference room to see \nif the new State Pattern-based \ndesign is going to work! !", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 449", "position": 449, "chunk_type": "semantic", "token_estimate": 171}
{"text": "412\u2003 \u2003 Chapter 10: testing the gumball machine\nFile  Edit   Window  Help  Whenisagumballajawbreaker? %java GumballMachineTestDrive\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 5 gumballs\nMachine is waiting for quarter\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot...\nA gumball comes rolling out the slot...\nYOU'RE A WINNER! You got two gumballs for your quarter\nMighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 3 gumballs\nMachine is waiting for quarter\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot...\nYou inserted a quarter\nYou turned...\nA gumball comes rolling out the slot...\nA gumball comes rolling out the slot...\nYOU'RE A WINNER! You got two gumballs for your quarter\nOops, out of gumballs! Mighty Gumball, Inc.\nJava-enabled Standing Gumball Model #2004\nInventory: 0 gumballs\nMachine is sold out\n%\nGee, did we get lucky \nor what? In our demo \nto the CEO, we won \nnot once, but twice! Yes! That rocks! Q: Why do we need the WinnerState? Couldn\u2019t we just have the SoldState dispense two gumballs? A: That\u2019s a great question. SoldState and WinnerState are almost identical, except that WinnerState dispenses two \ngumballs instead of one. You certainly could put the code to dispense two gumballs into SoldState. The downside is, of \ncourse, that now you\u2019ve got TWO states represented in one State class: the state in which you\u2019re a winner, and the state \nin which you\u2019re not. So you are sacrificing clarity in your State class to reduce code duplication. Another thing to consider \nis the principle you learned in the previous chapter: the Single Responsibility Principle. By putting the WinnerState \nresponsibility into the SoldState, you\u2019ve just given the SoldState TWO responsibilities. What happens when the \npromotion ends? Or the stakes of the contest change? So, it\u2019s a tradeoff and comes down to a design decision.", "domains": ["Design Patterns", "Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 450", "position": 450, "chunk_type": "semantic", "token_estimate": 308}
{"text": "you are here 4\u2003 \u2003 413: the state pattern\nBravo! Great job, \ngang. Our sales are already \ngoing through the roof with the new \ngame. You know, we also make soda \nmachines, and I was thinking we could put \none of those slot-machine arms on the \nside and make that a game too. We\u2019ve got \nfour-year-olds gambling with the \ngumball machines; why stop there? Sanity check... Yes, the CEO of Mighty Gumball probably needs a sanity check, but that\u2019s not what \nwe\u2019re talking about here. Let\u2019s think through some aspects of the GumballMachine \nthat we might want to shore up before we ship the gold version:\n\u2003\n\u0083\nWe\u2019ve got a lot of duplicate code in the Sold and Winning \nstates and we might want to clean those up. How would we \ndo it? We could make State into an abstract class and build \nin some default behavior for the methods; after all, error \nmessages like, \u201cYou already inserted a quarter,\u201d aren\u2019t going \nto be seen by the customer. So all \u201cerror response\u201d behavior \ncould be generic and inherited from the abstract State class. \u0083\nThe dispense() method always gets called, even if the crank is \nturned when there is no quarter. While the machine operates \ncorrectly and doesn\u2019t dispense unless it\u2019s in the right state, we \ncould easily fix this by having turnCrank() return a boolean \nor by introducing exceptions. Which do you think is a better \nsolution? \u0083\nAll of the intelligence for the state transitions is in the State \nclasses. What problems might this cause? Would we want to \nmove that logic into the GumballMachine? What would be \nthe advantages and disadvantages of that? \u0083\nWill you be instantiating a lot of GumballMachine objects? If so, you may want to move the state instances into static \ninstance variables and share them. What changes would this \nrequire to the GumballMachine and the States? Dammit Jim, \nI\u2019m a gumball \nmachine, not a \ncomputer!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 451", "position": 451, "chunk_type": "semantic", "token_estimate": 322}
{"text": "414\u2003 \u2003 Chapter 10: fireside chats: state and strategy\nTonight\u2019s talk: A Strategy and State Pattern Reunion. Strategy:\nHey, bro. Did you hear I was in Chapter 1? I was just over giving the Template Method guys a \nhand\u2014they needed me to help them finish off their \nchapter. So, anyway, what is my noble brother up to? I don\u2019t know, you always sound like you\u2019ve just \ncopied what I do and you\u2019re using different words \nto describe it. Think about it: I allow objects to \nincorporate different behaviors or algorithms \nthrough composition and delegation. You\u2019re just \ncopying me. Oh yeah? How so? I don\u2019t get it. Yeah, that was some fine work...and I\u2019m sure you can \nsee how that\u2019s more powerful than inheriting your \nbehavior, right? Sorry, you\u2019re going to have to explain that. State:\nYeah, word is definitely getting around. Same as always\u2014helping classes to exhibit different \nbehaviors in different states. I admit that what we do is definitely related, but my \nintent is totally different than yours. And the way I \nteach my clients to use composition and delegation \nis totally different. Well, if you spent a little more time thinking about \nsomething other than yourself, you might. Anyway,  \nthink about how you work: you have a class you\u2019re \ninstantiating and you usually give it a strategy object \nthat implements some behavior. Like, in Chapter 1 \nyou were handing out quack behaviors, right? Real \nducks got a real quack; rubber ducks got a quack \nthat squeaked. Yes, of course. Now, think about how I work; it\u2019s \ntotally different.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 452", "position": 452, "chunk_type": "semantic", "token_estimate": 259}
{"text": "you are here 4\u2003 \u2003 415: the state pattern\nStrategy:\n\n\nHey, come on, I can change behavior at runtime \ntoo; that\u2019s what composition is all about! Well, I admit, I don\u2019t encourage my objects to have \na well-defined set of transitions between states. In \nfact, I typically like to control what strategy my \nobjects are using. Yeah, yeah, keep living your pipe dreams, brother. You act like you\u2019re a big pattern like me, but check \nit out: I\u2019m in Chapter 1; they stuck you way out in \nChapter 10. I mean, how many people are actually \ngoing to read this far? That\u2019s my brother, always the dreamer. State:\nOkay, when my Context objects get created, I may \ntell them the state to start in, but then they change \ntheir own state over time. Sure you can, but the way I work is built around \ndiscrete states; my Context objects change state \nover time according to some well-defined state \ntransitions. In other words, changing behavior is \nbuilt in to my scheme\u2014it\u2019s how I work! Look, we\u2019ve already said we\u2019re alike in structure, but \nwhat we do is quite different in intent. Face it, the \nworld has uses for both of us. Are you kidding? This is a Head First book and \nHead First readers rock. Of course they\u2019re going to \nget to Chapter 10!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 453", "position": 453, "chunk_type": "semantic", "token_estimate": 222}
{"text": "you are here 4\u2003 \u2003 417: the state pattern\nYou\u2019ve done some amazing work! I\u2019ve got some more ideas that \nare going to change the gumball \nindustry and I need you to implement \nthem. Shhhhh! I\u2019ll let you in on these \nideas in the next chapter. We need you to write the refill() method for the Gumball machine. It has one \nargument\u2014the number of gumballs you\u2019re adding to the machine\u2014and \nshould update the gumball machine count and reset the machine\u2019s state.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 455", "position": 455, "chunk_type": "semantic", "token_estimate": 80}
{"text": "418\u2003 \u2003 Chapter 10: who does what? Pattern\nDescription\nState\nStrategy\nTemplate Method\nEncapsulate interchangeable \nbehaviors and use delegation to \ndecide which behavior to use. Subclasses decide how \nto implement steps in an \nalgorithm. Encapsulate state-based \nbehavior and delegate \nbehavior to the current state. Match each pattern with its description:", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 456", "position": 456, "chunk_type": "semantic", "token_estimate": 49}
{"text": "you are here 4\u2003 \u2003 419: the state pattern\nTools for your Design Toolbox\nIt\u2019s the end of another chapter; you\u2019ve got enough \npatterns here to breeze through any job interview! Abstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it. OO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically. Decorators provide a flexible \nalternative to subclassing for extending \nfunctionality. Abstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes. Factory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate. Factory Method lets \na class defer instantiation to the \nsubclasses. Singleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it. Command - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Adapter - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. No new principles this \nchapter. That gives you \ntime to sleep on them. Facade - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Here\u2019s our new \npattern. If you\u2019re \nmanaging state in \na class, the State \nPattern gives you \na technique for \nencapsulating that \nstate. State - Allow an object to alter its \nbehavior when its internal state changes. The object will appear to change its \nclass. Encapsulate what varies. Favor composition over inheritance. Program to interfaces, not \nimplementations. Strive for loosely coupled designs \nbetween objects that interact. Classes should be open for extension \nbut closed for modification. Depend on abstractions. Do not \ndepend on concrete classes. Only talk to your friends. Don\u2019t call us, we\u2019ll call you. A class should have only one reason \nto change. OO Principles\n\t\n\u0083\nThe State Pattern allows an \nobject to have many different \nbehaviors that are based on \nits internal state. \u0083\nUnlike a procedural state \nmachine, the State Pattern \nrepresents each state as a \nfull-blown class.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 457", "position": 457, "chunk_type": "semantic", "token_estimate": 396}
{"text": "you are here 4\u2003 \u2003 419: OO Principles\n\t\n\u0083\nThe State Pattern allows an \nobject to have many different \nbehaviors that are based on \nits internal state. \u0083\nUnlike a procedural state \nmachine, the State Pattern \nrepresents each state as a \nfull-blown class. \u0083\nThe Context gets its behavior \nby delegating to the current \nstate object it is composed \nwith. \u0083\nBy encapsulating each state \ninto a class, we localize any \nchanges that will need to be \nmade. \u0083\nThe State and Strategy \nPatterns have the same class \ndiagram, but they differ in \nintent. \u0083\nThe Strategy Pattern typically \nconfigures Context classes \nwith a behavior or algorithm. \u0083\nThe State Pattern allows \na Context to change its \nbehavior as the state of the \nContext changes. \u0083\nState transitions can be \ncontrolled by the State \nclasses or by the Context \nclasses. \u0083\nUsing the State Pattern will \ntypically result in a greater \nnumber of classes in your \ndesign. \u0083\nState classes may be shared \namong Context instances.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 457", "position": 457, "chunk_type": "semantic", "token_estimate": 165}
{"text": "420\u2003 \u2003 Chapter 10: exercise solutions\nOut of \nGumballs\n   Has \nQuarter\n   No \nQuarter\ninsert quarter\neject quarter\nturn crank, no winner\nWinner\nturn crank, we \nhave a winner! Mighty Gumball, Inc.\nWhere the Gumball Machine \nis Never Half Empty\nGumball \n  Sold\ndispense \ngumball\ngumballs = 0\ngumballs > 0\ngumballs = 0\ngumballs > 0\ndispense 2 \ngumballs\nDraw a state diagram for a Gumball Machine that handles the 1-in-10 \ncontest. In this contest, 10% of the time the Sold state leads to two \nballs being released, not one. Here\u2019s our solution. Design Puzzle Solution", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 458", "position": 458, "chunk_type": "semantic", "token_estimate": 94}
{"text": "you are here 4\u2003 \u2003 421: the state pattern\nWhich of the following describe the state of our implementation? (Choose all that apply.) Here\u2019s our solution. We have one remaining class we haven\u2019t implemented: SoldOutState. Why \ndon\u2019t you implement it? To do this, carefully think through how the Gumball \nMachine should behave in each situation. Here\u2019s our solution. public class SoldOutState implements State {\n    GumballMachine gumballMachine;\n \n    public SoldOutState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n \n    public void insertQuarter() {\n        System.out.println(\"You can't insert a quarter, the machine is sold out\");\n    }\n \n    public void ejectQuarter() {\n        System.out.println(\"You can't eject, you haven't inserted a quarter yet\");\n    }\n \n    public void turnCrank() {\n        System.out.println(\"You turned, but there are no gumballs\");\n    }\n \n    public void dispense() {\n        System.out.println(\"No gumball dispensed\");\n    }\n}\nIn the Sold Out state, we really \ncan\u2019t do anything until someone \nrefills the Gumball Machine. \u274f   A. This code certainly isn\u2019t adhering to the \nOpen Closed Principle. \u274f   B. This code would make a FORTRAN \nprogrammer proud. \u274f   C.\t This design isn\u2019t even very object-\noriented. \u274f   D.\t State transitions aren\u2019t explicit; they \nare buried in the middle of a bunch of \nconditional statements. \u274f   E.\t We haven\u2019t encapsulated anything that \nvaries here. \u274f   F.\t Further additions are likely to cause bugs \nin working code.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 459", "position": 459, "chunk_type": "semantic", "token_estimate": 209}
{"text": "422\u2003 \u2003 Chapter 10: exercise solutions\nGo to HasQuarterState. T\nell the customer, \u201cYou haven\u2019t inserted a quarter.\u201d\nT\nell the customer, \u201cPlease wait, we\u2019re already giving you a gumball.\u201d\nT\nell the customer, \u201cSorry, you already turned the crank.\u201d\nT\nell the customer, \u201cTurning twice doesn\u2019t get you another gumball.\u201d\nT\nell the customer, \u201cThe machine is sold out.\u201d\nT\nell the customer, \u201cYou haven\u2019t inserted a quarter yet.\u201d\nT\nell the customer, \u201cYou can\u2019t insert another quarter.\u201d\nT\nell the customer, \u201cThere are no gumballs.\u201d\nGo to SoldState. Give back quarter, go to NoQuarter state. T\nell the customer, \u201cYou turned, but there\u2019s no quarter.\u201d\nNoQuarterState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nSoldOutState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nSoldState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nHasQuarterState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nT\nell the customer, \u201cYou need to pay first.\u201d\nT\nell the customer, \u201cNo gumball dispensed.\u201d\nDispense one gumball. Check number of gumballs; if > 0, go \nto NoQuarter state; otherwise, go to SoldOut state. T\nell the customer, \u201cNo gumball dispensed.\u201d\nT\nell the customer, \u201cPlease wait, we\u2019re already giving you a gumball.\u201d\nT\nell the customer, \u201cSorry, you already turned the crank.\u201d\nT\nell the customer, \u201cTurning twice doesn\u2019t get you another gumball.\u201d\nWinnerState\ninsertQuarter()\nejectQuarter()\nturnCrank()\ndispense()\nDispense two gumballs. Check number of gumballs; if > 0, \ngo to NoQuarter state; otherwise, go to SoldOutState. To implement the states, we first need to define what the behavior will \nbe when the corresponding action is called. Annotate the diagram below \nwith the behavior of each action in each class; here\u2019s our solution.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 460", "position": 460, "chunk_type": "semantic", "token_estimate": 260}
{"text": "you are here 4\u2003 \u2003 423: the state pattern\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\n \n \n \n \n \n \n \n \nS\no\nl\nd\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\n \n \n \n \n \n \n \n \nS\no\nl\nd\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\n \n \n \n \n \n \n \n \nS\no\nl\nd\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\n \n \n \n \n \n \n \n \nS\no\nl\nd\n \n \n \n \nH\na\ns\nQ\nu\nart\ne\nr\n \n \n \n \nN\no\nQ\nu\na\nrte\nr\n \n \n \n \n \n \nS\no\nl\nd\nO\nut\nGumball Machine States\nGumball Machine States\nGumball Machine States\nGumball Machine States\n1\n2\n4\n3\ncurrent state\ncurrent state\ncurrent state\ncurrent state\nBehind the Scenes: \nSelf-Guided Tour \nSolution\ninsertQuarter()\ninsertQuarter()\ndelegates to \ncurrent state\nturnCrank()\nturnCrank()\ndelegates\ntransitions to \nHasQuarter state\nmachine action\nmachine action\ntransitions to \nSold state\ndispense()\nHere the machine \ngives out a gumball \nby calling the internal \ndispense() action...\n...and then transitions \nto NoQuarter.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 461", "position": 461, "chunk_type": "semantic", "token_estimate": 234}
{"text": "424\u2003 \u2003 Chapter 10: exercise solutions\npublic void refill() { \n    gumballMachine.setState(gumballMachine.getNoQuarterState());\n}\nPattern\nDescription\nState\nStrategy\nTemplate Method\nEncapsulate interchangeable \nbehaviors and use delegation to \ndecide which behavior to use. Subclasses decide how \nto implement steps in an \nalgorithm. Encapsulate state-based \nbehavior and delegate \nbehavior to the current state. Match each pattern with its description:\nSOlUTion\nTo refill the Gumball Machine, we add a refill() method to the State interface, \nwhich each State must implement. In every state except SoldOutState, the \nmethod does nothing. In SoldOutState, refill() transitions to NoQuarterState. We also add a refill() method to GumballMachine that adds to the count of \ngumballs, and then calls the current state\u2019s refill() method. void refill(int count) {\n    this.count += count;\n    System.out.println(\"The gumball machine was just refilled; its new count is: \" + this.count);\n    state.refill();\n}\nWe add this method to \nthe SoldOutState...\n...and add this method to \nthe GumballMachine class.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 462", "position": 462, "chunk_type": "semantic", "token_estimate": 149}
{"text": "this is a new chapter\u2003 \u2003 425: Ever play good cop, bad cop? You\u2019re the good cop and you provide all \nyour services in a nice and friendly manner, but you don\u2019t want everyone asking you \nfor services, so you have the bad cop control access to you. That\u2019s what proxies do: \ncontrol and manage access. As you\u2019re going to see, there are lots of ways in which \nproxies stand in for the objects they proxy. Proxies have been known to haul entire \nmethod calls over the internet for their proxied objects; they\u2019ve also been known to \npatiently stand in for some pretty lazy objects. Controlling \n     Object Access\n11  the Proxy Pattern\nWith you as my proxy, \nI\u2019ll be able to triple the \namount of lunch money I can \nextract from friends!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 463", "position": 463, "chunk_type": "semantic", "token_estimate": 131}
{"text": "426\u2003 \u2003 Chapter 11: what\u2019s the goal\nSounds easy enough. If you remember, we\u2019ve already \ngot methods in the gumball machine code for getting the \ncount of gumballs, getCount(), and getting the current \nstate of the machine, getState(). All we need to do is create a report that can be printed out \nand sent back to the CEO. Hmmm, we should probably \nadd a location field to each gumball machine as well; that \nway the CEO can keep the machines straight. Let\u2019s just jump in and code this. We\u2019ll impress the CEO \nwith a very fast turnaround. Remember the CEO of \nMighty Gumball, Inc.? Hey team, I\u2019d really like to \nget some better monitoring for \nmy gumball machines. Can you find a \nway to get me a report of inventory \nand machine state?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 464", "position": 464, "chunk_type": "semantic", "token_estimate": 132}
{"text": "you are here 4\u2003 \u2003 427: the proxy pattern\npublic class GumballMonitor {\n    GumballMachine machine;\n \n    public GumballMonitor(GumballMachine machine) {\n        this.machine = machine;\n    }\n \n    public void report() {\n        System.out.println(\"Gumball Machine: \" + machine.getLocation());\n        System.out.println(\"Current inventory: \" + machine.getCount() + \" gumballs\");\n        System.out.println(\"Current state: \" + machine.getState());\n    }\n}\npublic class GumballMachine {\n    // other instance variables\n    String location;\n \n    public GumballMachine(String location, int count) {\n        // other constructor code here\n        this.location = location;\n    }\n \n    public String getLocation() {\n        return location;\n    }\n \n    // other methods here\n}\nCoding the Monitor\nNow let\u2019s create another class, GumballMonitor, that retrieves the machine\u2019s \nlocation, inventory of gumballs, and current machine state and prints them in a \nnice little report:\nThe monitor takes the machine in \nits constructor and assigns it to \nthe machine instance variable. Our report() method just prints a report with \nlocation, inventory, and the machine\u2019s state. Let\u2019s start by adding support to the GumballMachine class so that it \ncan handle locations:\nA location is just a String. The location is passed into the \nconstructor and stored in the \ninstance variable. Let\u2019s also add a getter method to \ngrab the location when we need it.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 465", "position": 465, "chunk_type": "semantic", "token_estimate": 190}
{"text": "428\u2003 \u2003 Chapter 11: local gumball monitor\npublic class GumballMachineTestDrive {\n    public static void main(String[] args) {\n        int count = 0;\n        if (args.length < 2) {\n            System.out.println(\"GumballMachine <name> <inventory>\");\n            System.exit(1);\n        }\n        count = Integer.parseInt(args[1]);\n        GumballMachine gumballMachine = new GumballMachine(args[0], count);\n        GumballMonitor monitor = new GumballMonitor(gumballMachine);\n \n        // rest of test code here\n        monitor.report();\n    }\n}\nTesting the Monitor\nWe implemented that in no time. The CEO is going to be thrilled and amazed by our \ndevelopment skills. Now we just need to instantiate a GumballMonitor and give it a machine to monitor:\nDon\u2019t forget to give \nthe constructor a \nlocation and count...\n...and instantiate a monitor and pass it a \nmachine to provide a report on. And here\u2019s the output! When we need a report on \nthe machine, we call the \nreport() method. Pass in a location and initial # of \ngumballs on the command line. File  Edit   Window  Help  FlyingFish\n%java GumballMachineTestDrive Austin 112\nGumball Machine: Austin\nCurrent Inventory: 112 gumballs\nCurrent State: waiting for quarter\nThe monitor output looks \ngreat, but I guess I wasn\u2019t clear. I need \nto monitor gumball machines REMOTELY! In fact, we already have the networks in \nplace for monitoring. Come on guys, you\u2019re \nsupposed to be the internet generation!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 466", "position": 466, "chunk_type": "semantic", "token_estimate": 204}
{"text": "you are here 4\u2003 \u2003 429: the proxy pattern\nFrank: A remote what? Joe: Remote proxy. Think about it: we\u2019ve already got the monitor code written, right? We give the \nGumballMonitor class a reference to a machine and it gives us a report. The problem is that the monitor runs \nin the same JVM as the gumball machine and the CEO wants to sit at his desk and remotely monitor the \nmachines! So what if we left our GumballMonitor class as is, but handed it a proxy to a remote object? Frank: I\u2019m not sure I get it. Jim: Me neither. Joe: Let\u2019s start at the beginning...a proxy is a stand in for a real object. In this case, the proxy acts just like it \nis a Gumball Machine object, but behind the scenes it is communicating over the network to talk to the real, \nremote GumballMachine. Jim: So you\u2019re saying we keep our code as it is, and we give the monitor a reference to a proxy version of the \nGumballMachine...\nFrank: And this proxy pretends it\u2019s the real object, but it\u2019s really just communicating over the net to the real \nobject. Joe: Yeah, that\u2019s pretty much the story. Frank: It sounds like something that\u2019s easier said than done. Joe: Perhaps, but I don\u2019t think it\u2019ll be that bad. We have to make sure that the gumball machine can act as \na service and accept requests over the network; we also need to give our monitor a way to get a reference to \na proxy object, but we\u2019ve got some great tools already built into Java to help us. Let\u2019s talk a little more about \nremote proxies first...\nJoe\nJim\nFrank\nDon\u2019t worry, guys, I\u2019ve \nbeen brushing up on my design \npatterns. All we need is a remote \nproxy and we\u2019ll be ready to go. Well, that will teach us to \ngather some requirements \nbefore we jump in and code. I hope \nwe don\u2019t have to start over...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 467", "position": 467, "chunk_type": "semantic", "token_estimate": 328}
{"text": "430\u2003 \u2003 Chapter 11: remote proxy\nA remote proxy acts as a local representative to a remote object. What\u2019s a \u201cremote \nobject\u201d? It\u2019s an object that lives in the heap of a different Java Virtual Machine \n(or more generally, a remote object that is running in a different address space). What\u2019s a \u201clocal representative\u201d? It\u2019s an object that you can call local methods on \nand have them forwarded on to the remote object. The role of the \u2018remote proxy\u2019\nYour client object acts like it\u2019s making remote method calls. But what it\u2019s really doing is calling methods on a heap-\nlocal \u201cproxy\u201d object that handles all the low-level details of \nnetwork communication. G\nu\nm\nb\na\nl\nl\n \nM\na\nc\nhi\nn\ne \nRemote Heap\nG\nu\nm\nb\na\nl\nl\n \nM\non\ni\nt\no\nr\nLocal Heap\n \n \n \n \n \n \n \nP\nr\no\nx\ny\nHere the Gumball \nMonitor is the client \nobject; it thinks it\u2019s \ntalking to the Real \ngumball machine, but  \nit\u2019s really just talking \nto the proxy, which \nthen talks to the \nReal gumball machine \nover the network. The proxy pretends to \nbe the remote object, \nbut it\u2019s just a stand in \nfor the Real Thing. The Remote object IS \nthe Real Thing. It\u2019s the \nobject with the method \nthat actually does the \nreal work. CEO\u2019s desktop\nRemote Gumball Machine \nwith a JVM. Same as your old \ncode, only it\u2019s \ntalking to a proxy. The client object is the object \nmaking use of the proxy-in our \ncase, the GumballMonitor class.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 468", "position": 468, "chunk_type": "semantic", "token_estimate": 254}
{"text": "you are here 4\u2003 \u2003 431: the proxy pattern\nThis is a pretty slick idea. We\u2019re going to write some code that \ntakes a method invocation, somehow transfers it \nover the network, and invokes the same method \non a remote object. Then I presume when the call is \ncomplete, the result gets sent back over the network \nto our client. But it seems to me this code is going \nto be very tricky to write. Hold on now, we aren\u2019t going \nto write that code ourselves; it\u2019s \npretty much built into Java\u2019s remote \ninvocation functionality. All we have to \ndo is retrofit our code so that it takes \nadvantage of RMI. Before going further, think about how you\u2019d design a system to enable Remote Method \nInvocation (RMI). How would you make it easy on the developer so that she has to write as \nlittle code as possible? How would you make the remote invocation look seamless? Should making remote calls be totally transparent? Is that a good idea? What might be a \nproblem with that approach? 2", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 469", "position": 469, "chunk_type": "semantic", "token_estimate": 176}
{"text": "432\u2003 \u2003 Chapter 11: rmi detour\nAdding a remote proxy to the Gumball \nMachine monitoring code\nOn paper our plan looks good, but how do we create a proxy that knows how to invoke a \nmethod on an object that lives in another JVM? Hmmm. Well, you can\u2019t get a reference to something on another heap, right? In other words, \nyou can\u2019t say:\n       Duck d = <object in another heap>\nWhatever the variable d is referencing must be in the same heap space as the code running \nthe statement. So how do we approach this? Well, that\u2019s where Java\u2019s Remote Method \nInvocation (RMI) comes in...RMI gives us a way to find objects in a remote JVM and allows \nus to invoke their methods. Now might be a good time to brush up on RMI with your favorite Java reference, or you can \ntake the RMI Detour ahead, and we\u2019ll walk you though the high points of RMI before adding \nthe proxy support to the Gumball Machine code. In either case, here\u2019s our plan:\nAn RMI Detour\nIf you\u2019re new to RMI, \ntake the detour that runs \nover the next few pages; \notherwise, you might want to \njust quickly thumb through \nthe detour as a review. If \nyou\u2019d like to continue on, \njust getting the gist of the \nremote proxy, that is fine \ntoo\u2014you can skip the detour. 1\n2\n3\nFirst, we\u2019re going to take the RMI \nDetour and explore RMI. Even if you are \nfamiliar with RMI, you might want to \nfollow along and check out the scenery. Then we\u2019re going to take our Gumball \nMachine and make it a remote service \nthat provides a set of methods calls \nthat can be invoked remotely. Finally, we going to create a proxy that \ncan talk to a remote Gumball Machine, \nagain using RMI, and put the monitoring \nsystem back together so that the CEO can \nmonitor any number of remote machines.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 470", "position": 470, "chunk_type": "semantic", "token_estimate": 320}
{"text": "you are here 4\u2003 \u2003 433: the proxy pattern\nLet\u2019s say we want to design a system that allows us to call a local object that forwards each request \nto a remote object. How would we design it? We\u2019d need a couple of helper objects that do the \ncommunicating for us. The helpers make it possible for the client to act as though it\u2019s calling a method \non a local object (which it is). The client calls a method on the client helper, as if the client helper were \nthe actual service. The client helper then takes care of forwarding that request for us. In other words, the client object thinks it\u2019s calling a method on the remote service, because the client \nhelper is pretending to be the service object\u2014that is, pretending to be the thing with the method the \nclient wants to call. But the client helper isn\u2019t really the remote service. Although the client helper acts like it (because it has \nthe same method that the service is advertising), the client helper doesn\u2019t have any of the method logic \nthe client is expecting. Instead, the client helper contacts the server, transfers information about the \nmethod call (e.g., name of the method, arguments, etc. ), and waits for a return from the server. On the server side, the service helper receives the request from the client helper (through a Socket \nconnection), unpacks the information about the call, and then invokes the real method on the real service \nobject. So, to the service object, the call is local. It\u2019s coming from the service helper, not a remote client. The service helper gets the return value from the service, packs it up, and ships it back (over a Socket\u2019s \noutput stream) to the client helper. The client helper unpacks the information and returns the value to \nthe client object. Let\u2019s walk through this to make it clearer... Remote methods 101\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nServer heap\nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nClient heap\nC\nl\ni\ne\nn\nt\n \nh\ne\nl\nper\nS\ne\nr\nv\ni\nc\ne\n \nh\nelp\ne\nr\nClient object thinks \nit\u2019s talking to the \nReal Service. It \nthinks the client \nhelper is the thing \nthat can actually do \nthe real work.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 471", "position": 471, "chunk_type": "semantic", "token_estimate": 390}
{"text": "you are here 4\u2003 \u2003 433: Remote methods 101\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nServer heap\nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nClient heap\nC\nl\ni\ne\nn\nt\n \nh\ne\nl\nper\nS\ne\nr\nv\ni\nc\ne\n \nh\nelp\ne\nr\nClient object thinks \nit\u2019s talking to the \nReal Service. It \nthinks the client \nhelper is the thing \nthat can actually do \nthe real work. Client helper pretends \nto be the service, but \nit\u2019s just a proxy for the \nReal Thing. Service helper gets the \nrequest from the client \nhelper, unpacks it, and \ncalls the method on the \nReal Service. The Service object IS \nthe Real Service. It\u2019s the \nobject with the method \nthat actually does the \nreal work. Consider this design... This is going \nto be our \nproxy. An RMI Detour\nWalking through the design", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 471", "position": 471, "chunk_type": "semantic", "token_estimate": 151}
{"text": "you are here 4\u2003 \u2003 435: the proxy pattern\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nServer heap\nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nClient heap\nC\nl\ni\ne\nn\nt\n \nh\ne\nl\nper\nS\ne\nr\nv\ni\nc\ne\n \nh\nelp\ne\nr\n4\nThe method is invoked on the service object, which returns \nsome result to the service helper. S\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nServer heap\nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nClient heap\nC\nl\ni\ne\nn\nt\n \nh\ne\nl\nper\nS\ne\nr\nv\ni\nc\ne\n \nh\nelp\ne\nr\n5\nThe Service helper packages up information returned from the \ncall and ships it back over the network to the client helper. packaged up result\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nServer heap\nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nClient heap\nC\nl\ni\ne\nn\nt\n \nh\ne\nl\nper\nS\ne\nr\nv\ni\nc\ne\n \nh\nelp\ne\nr\n6\nThe Client helper unpackages the returned values and returns \nthem to the client object. To the client object, this was all \ntransparent. result\nresult\nAn RMI Detour", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 473", "position": 473, "chunk_type": "semantic", "token_estimate": 222}
{"text": "RMI nomenclature: in RMI, the client helper is a \u201cstub\u201d and the: service helper is a \u201cskeleton.\u201d\nThis is going \nto act as our \nproxy! Now let\u2019s go through all the steps needed to make an object \ninto a service that can accept remote calls and also the steps \nneeded to allow a client to make remote calls. You might want to make sure your seat belt is fastened; there \nare a lot of steps\u2014but nothing to be too worried about. An RMI Detour", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 474", "position": 474, "chunk_type": "semantic", "token_estimate": 84}
{"text": "you are here 4\u2003 \u2003 437: the proxy pattern\nAn RMI Detour\nMaking the Remote service\nMake a Remote Interface\nMake a Remote Implementation\nStart the RMI registry (rmiregistry)\nStart the remote service \nMyService.java\npublic interface \nMyRemote extends \nRemote { }\nMyServiceImpl.java\npublic interface \nMyRemote extends \nRemote { }\nThis is an overview of the five steps for making the remote service\u2014in other \nwords, the steps needed to take an ordinary object and supercharge it so it can \nbe called by a remote client. We\u2019ll be doing this later to our Gumball Machine. For now, let\u2019s get the steps down and then we\u2019ll explain each one in detail. The remote interface defines the methods that \na client can call remotely. It\u2019s what the client \nwill use as the class type for your service. Both \nthe Stub and actual service will implement \nthis. This interface defines the \nremote methods that you \nwant clients to call. This is the class that does the Real Work. It \nhas the real implementation of the remote \nmethods defined in the remote interface. It\u2019s the object that the client wants to call \nmethods on (e.g., GumballMachine). The Real Service: the class \nwith the methods that do \nthe real work. It implements \nthe remote interface. The Stub and Skeleton are \ngenerated dynamically for you \nbehind the scenes. File  Edit   Window  Help  Drink\n%rmiregistry\nFile  Edit   Window  Help  BeMerry\n%java MyServiceImpl\nThe rmiregistry is like the white pages of a phone \nbook. It\u2019s where the client goes to get the proxy \n(the client stub/helper object). You have to get the service object up and running. Your \nservice implementation class instantiates an instance \nof the service and registers it with the RMI registry. Registering it makes the service available for clients. Run this in a separate \nterminal window. Step one:\nStep two:\nStep three:\nStep four:\nStub\n101101 \n10 110 1 \n0 11 0 \n001 10 \n001 01\nSkeleton\n101101 \n10 110 1 \n0 11 0 \n001 10 \n001 01", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 475", "position": 475, "chunk_type": "semantic", "token_estimate": 330}
{"text": "438\u2003 \u2003 Chapter 11: make a remote interface\nStep one: make a Remote interface\n1\nExtend java.rmi.Remote\nRemote is a \u201cmarker\u201d interface, which means it has no methods. It has \nspecial meaning for RMI, though, so you must follow this rule. Notice that \nwe say \u201cextends\u201d here. One interface is allowed to extend another interface. public interface MyRemote extends Remote {\n2\nDeclare that all methods throw RemoteException\nThe remote interface is the one the client uses as the type for the service. In \nother words, the client invokes methods on something that implements the \nremote interface. That something is the stub, of course, and since the stub is \ndoing networking and I/O, all kinds of bad things can happen. The client has \nto acknowledge the risks by handling or declaring the remote exceptions. If \nthe methods in an interface declare exceptions, any code calling methods on a \nreference of that type (the interface type) must handle or declare the exceptions. import java.rmi. *;\npublic interface MyRemote extends Remote {\n    public String sayHello() throws RemoteException;\n}\n3\nBe sure arguments and return values are primitives or Serializable\nArguments and return values of a remote method must be either primitive \nor Serializable. Think about it. Any argument to a remote method has to \nbe packaged up and shipped across the network, and that\u2019s done through \nSerialization. The same thing applies with return values. If you use primitives, \nStrings, and the majority of types in the API (including arrays and collections), \nyou\u2019ll be fine. If you are passing around your own types, just be sure that you \nmake your classes implement Serializable. public String sayHello() throws RemoteException;\nThis tells us that the \ninterface is going to be used \nto support remote calls. Every remote method \ncall is considered \n\u201crisky.\u201d Declaring \nRemoteException on \nevery method forces the \nclient to pay attention \nand acknowledge that \nthings might not work. This return value is gonna be shipped over the wire from the \nserver back to the client, so it must be Serializable. That\u2019s \nhow args and return values get packaged up and sent. Remote interface is in java.rmi. Check out your \nfavorite Java \nreference if you \nneed to refresh your \nmemory on Serializable. An RMI Detour", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 476", "position": 476, "chunk_type": "semantic", "token_estimate": 370}
{"text": "you are here 4\u2003 \u2003 439: the proxy pattern\nStep two: make a Remote implementation\n1\nImplement the Remote interface\nYour service has to implement the remote interface\u2014the one with \nthe methods your client is going to call. public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {\n    public String sayHello() {\n       return \"Server says, 'Hey'\";\n   }\n   // more code in class\n}\n2\nExtend UnicastRemoteObject\nIn order to work as a remote service object, your object needs some functionality \nrelated to \u201cbeing remote.\u201d The simplest way is to extend UnicastRemoteObject \n(from the java.rmi.server package) and let that class (your superclass) do the \nwork for you. public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {\n    private static final long serialVersionUID = 1L;\n3\nWrite a no-arg constructor that declares RemoteException\nYour new superclass, UnicastRemoteObject, has one little problem\u2014its \nconstructor throws RemoteException. The only way to deal with this is to declare \na constructor for your remote implementation, just so that you have a place to \ndeclare RemoteException. Remember,  when a class is instantiated, its superclass \nconstructor is always called. If your superclass constructor throws an exception, \nyou have no choice but to declare that your constructor also throws an exception. public MyRemoteImpl() throws RemoteException { }\n4\nRegister the service with the RMI registry\nNow that you\u2019ve got a remote service, you have to make it available to remote \nclients. You do this by instantiating it and putting it into the RMI registry (which \nmust be running or this line of code fails). When you register the implementation \nobject, the RMI system actually puts the stub in the registry, since that\u2019s what the \nclient really needs. Register your service using the static rebind() method of the \njava.rmi.Naming class. try {\n    MyRemote service = new MyRemoteImpl();\n    Naming.rebind(\"RemoteHello\", service);\n} catch(Exception ex) {...}      \nThe compiler will make sure that you\u2019ve implemented \nall the methods from the interface you implement. In this case, there\u2019s only one. You don\u2019t have to put anything in \nthe constructor. You just need a \nway to declare that your superclass \nconstructor throws an exception. Give your service a name (that clients can use \nto look it up in the registry) and register it \nwith the RMI registry. When you bind the \nservice object, RMI swaps the service for the \nstub and puts the stub in the registry. An RMI Detour\nUnicastRemoteObject implements \nSerializable, so we need the \nserialVersionUID field.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 477", "position": 477, "chunk_type": "semantic", "token_estimate": 397}
{"text": "440\u2003 \u2003 Chapter 11: start the service\nStep three: run rmiregistry\n1\nBring up a terminal and start the rmiregistry. Be sure you start it from a directory that has access to \nyour classes. The simplest way is to start it from your \nclasses directory. File  Edit   Window  Help  Huh? %rmiregistry\nStep four: start the service\n1\nBring up another terminal and start your service\nThis might be from a main() method in your remote \nimplementation class or from a separate launcher class. In this simple example, we put the starter code in the \nimplementation class, in a main method that instantiates \nthe object and registers it with RMI registry. Q: Why are you showing stubs and skeletons in the diagrams for the RMI code? I thought we got \nrid of those way back. A: You\u2019re right; for the skeleton, the RMI runtime can dispatch the client calls directly to the remote \nservice using reflection, and stubs are generated dynamically using Dynamic Proxy (which you\u2019ll learn \nmore about a bit later in the chapter). The remote object\u2019s stub is a java.lang.reflect.Proxy instance (with an \ninvocation handler) that is automatically generated to handle all the details of getting the local method calls \nby the client to the remote object. But we like to show both the stub and skeleton, because conceptually \nit helps you to understand that there is something under the covers that\u2019s making that communication \nbetween the client stub and the remote service happen. An RMI Detour\nFile  Edit   Window  Help  Huh? %java MyRemoteImpl", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 478", "position": 478, "chunk_type": "semantic", "token_estimate": 254}
{"text": "you are here 4\u2003 \u2003 441: the proxy pattern\nComplete code for the server side\nimport java.rmi. *;\nimport java.rmi.server. *;\npublic class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {\n    private static final long serialVersionUID = 1L;\n    public String sayHello() {\n        return \"Server says, 'Hey'\";\n    }\n    public MyRemoteImpl() throws RemoteException { }\n    public static void main (String[] args) {\n        try {\n            MyRemote service = new MyRemoteImpl();\n            Naming.rebind(\"RemoteHello\", service);\n        } catch(Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}\nimport java.rmi. *;\npublic interface MyRemote extends Remote {\n    public String sayHello() throws RemoteException;\n}\nRemoteException and the Remote \ninterface are in the java.rmi package. Your interface MUST extend java.rmi.Remote. All of your remote methods must \ndeclare RemoteException. UnicastRemoteObject is in \nthe java.rmi.server package. The Remote interface:\nThe Remote service (the implementation):\nExtending UnicastRemoteObject is the \neasiest way to make a remote object. You MUST implement \nyour remote interface!! You have to implement all the \ninterface methods, of course. But \nnotice that you do NOT have to \ndeclare the RemoteException. Your superclass constructor (for \nUnicastRemoteObject) declares an exception, \nso YOU must write a constructor, because it \nmeans that your constructor is calling risky \ncode (its super constructor). Make the remote object, then \u201cbind\u201d it to the \nrmiregistry using the static Naming.rebind(). The \nname you register it under is the name clients will \nuse to look it up in the RMI registry. An RMI Detour\nLet\u2019s take a look at all the code for the server side:", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 479", "position": 479, "chunk_type": "semantic", "token_estimate": 240}
{"text": "442\u2003 \u2003 Chapter 11: how to get the stub object\nAnd that\u2019s where the RMI registry comes in. And, you\u2019re right; the client has to get the stub object \n(our proxy), because that\u2019s the thing the client will call \nmethods on. To do that, the client does a \u201clookup,\u201d \nlike going to the white pages of a phone book, and \nessentially says, \u201cHere\u2019s a name, and I\u2019d like the stub \nthat goes with that name.\u201d \nLet\u2019s take a look at the code we need to look up and \nretrieve a stub object. Code Up Close\nMyRemote service = \n    (MyRemote) Naming.lookup(\"rmi://127.0.0.1/RemoteHello\");\nThe client always uses the remote \ninterface as the type of the service. In fact, the client never needs to \nknow the actual class name of your \nremote service. You have to cast it to the \ninterface, since the lookup \nmethod returns type Object. lookup() is a static method \nof the Naming class. The host name or IP \naddress where the \nservice is running. (127.0.0.1 is localhost.) This must be the name \nthat the service was \nregistered under. Here\u2019s how it works \non the next page. An RMI Detour\nHow does the client actually get \nthe stub object?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 480", "position": 480, "chunk_type": "semantic", "token_estimate": 197}
{"text": "you are here 4\u2003 \u2003 443: the proxy pattern\nS\ne\nr\nv\ni\nc\ne\n \no\nbje\nc\nt \nC\nl\ni\ne\nn\nt\n \no\nb\nj\ne\nc\nt\n \nS\nt\nu\nb\nS\nk\ne\nl\ne\nt\no\nn\nServer\nClient\nRemote Hello\nStub\nRMI registry (on server)\n1\nClient does a lookup on the RMI registry\n2\nRMI registry returns the stub object\n(as the return value of the lookup method) and RMI \ndeserializes the stub automatically. 3\nClient invokes a method on the stub, as if the \nstub IS the real service\n1\n2\n3\nNaming.lookup(\"rmi://127.0.0.1/RemoteHello\");\nlookup( )\nstub returned\nsayHello( )\nHow it works...\nAn RMI Detour", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 481", "position": 481, "chunk_type": "semantic", "token_estimate": 114}
{"text": "444\u2003 \u2003 Chapter 11: the remote client\nimport java.rmi. *;\npublic class MyRemoteClient {\n   public static void main (String[] args) {\n        new MyRemoteClient().go();\n   }\n   public void go() {\n     try {\n        MyRemote service = (MyRemote) Naming.lookup(\"rmi://127.0.0.1/RemoteHello\");\n        String s = service.sayHello(); \n        System.out.println(s);\n      } catch(Exception ex) {\n         ex.printStackTrace();\n      }\n   }\n}\nThe Naming class (for doing the rmiregistry \nlookup) is in the java.rmi package. It comes out of the registry as type \nObject, so don\u2019t forget the cast. You need the IP \naddress or hostname...\n...and the name used to \nbind/rebind the service. It looks just like a regular old \nmethod call! (Except it must \nacknowledge the RemoteException.) 1. The things programmers do wrong \nwith RMI are:\n1. Forget to start rmiregistry before starting the remote \nservice (when the service is registered using Naming. rebind(), the rmiregistry must be running!) 2. Forget to make arguments and return types serializable \n(you won\u2019t know until runtime; this is not something the \ncompiler will detect). An RMI Detour\nComplete code for the client side\nLet\u2019s take a look at all the code for the client side:", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 482", "position": 482, "chunk_type": "semantic", "token_estimate": 179}
{"text": "you are here 4\u2003 \u2003 445: the proxy pattern\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nServer heap\nG\nu\nm\nb\na\nl\nl\nM\noni\nt\no\nr\nClient heap\nG\nu\nm\nb\na\nl\nl\nS\ntub\nG\nu\nm\nb\na\nl\nl\nS\nkel\ne\nto\nn\nThis is our \nMonitor code. It \nuses a proxy to \ntalk to remote \ngumball machines. The stub is a proxy \nto the remote \nGumballMachine. The skeleton accepts the \nremote calls and makes \neverything work on the \nservice side. The \nGumballMachine is \nour remote service; \nit\u2019s going to expose \na remote interface \nfor the client to \nuse. Back to our GumballMachine remote proxy\nOkay, now that you have the RMI basics down, you\u2019ve got the tools you need \nto implement the gumball machine remote proxy. Let\u2019s take a look at how the \nGumballMachine fits into this framework:\nCEO\u2019s desktop\nRemote GumballMachine \nwith a JVM. Stop and think through how we\u2019re going to adapt the gumball machine code to work with \na remote proxy. Feel free to make some notes here about what needs to change and \nwhat\u2019s going to be different than the previous version.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 483", "position": 483, "chunk_type": "semantic", "token_estimate": 203}
{"text": "446\u2003 \u2003 Chapter 11: remote interface for the gumball machine\nimport java.io. *;\n  \npublic interface State extends Serializable {\n    public void insertQuarter();\n    public void ejectQuarter();\n    public void turnCrank();\n    public void dispense();\n}\nimport java.rmi. *;\n \npublic interface GumballMachineRemote extends Remote {\n    public int getCount() throws RemoteException;\n    public String getLocation() throws RemoteException;\n    public State getState() throws RemoteException;\n}\nGetting the GumballMachine ready to \nbe a remote service\nThe first step in converting our code to use the remote proxy is to enable the \nGumballMachine to service remote requests from clients. In other words, \nwe\u2019re going to make it into a service. To do that, we need to:\n1. Create a remote interface for the GumballMachine. This will provide a set \nof methods that can be called remotely. 2. Make sure all the return types in the interface are serializable. 3. Implement the interface in a concrete class. We\u2019ll start with the remote interface:\nThis is the remote interface. Don\u2019t forget to import java.rmi. * \nHere are the methods we\u2019re going to support. Each one throws RemoteException. All return types need \nto be primitive or \nSerializable...\nWe have one return type that isn\u2019t Serializable: the State class. Let\u2019s fix it up...\nSerializable is in the java.io package. Then we just extend the Serializable \ninterface (which has no methods in it). And now State in all the subclasses can \nbe transferred over the network.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 484", "position": 484, "chunk_type": "semantic", "token_estimate": 230}
{"text": "you are here 4\u2003 \u2003 447: the proxy pattern\npublic class NoQuarterState implements State {\n    private static final long serialVersionUID = 2L;\n    transient GumballMachine gumballMachine;\n    // all other methods here\n}\nimport java.rmi. *;\nimport java.rmi.server. *;\n \npublic class GumballMachine\n        extends UnicastRemoteObject implements GumballMachineRemote \n{\n    private static final long serialVersionUID = 2L;\n    // other instance variables here\n \n    public GumballMachine(String location, int numberGumballs) throws RemoteException {\n        // code here\n    }\n \n    public int getCount() {\n        return count;\n    }\n \n    public State getState() {\n        return state;\n    }\n \n    public String getLocation() {\n        return location;\n    }\n    // other methods here\n}\nActually, we\u2019re not done with Serializable yet; we have one problem with State. As you may \nremember, each State object maintains a reference to a gumball machine so that it can call the \ngumball machine\u2019s methods and change its state. We don\u2019t want the entire gumball machine \nserialized and transferred with the State object. There is an easy way to fix this:\nIn each implementation of State, we add \nthe serialVersionUID and the transient \nkeyword to the GumballMachine instance \nvariable. The transient keyword tells the \nJVM not to serialize this field. Note \nthat this can be slightly dangerous if you \ntry to access this field once the object\u2019s \nbeen serialized and transferred. We\u2019ve already implemented our GumballMachine, but we need to make sure it can act as a service and \nhandle requests coming from over the network. To do that, we have to make sure the GumballMachine is \ndoing everything it needs to implement the GumballMachineRemote interface. As you\u2019ve already seen in the RMI detour, this is quite simple; all we need to do is add a couple of things...\nFirst, we need to import the \nRMI packages. GumballMachine is \ngoing to subclass the \nUnicastRemoteObject; \nthis gives it the ability to \nact as a remote service. GumballMachine also needs to \nimplement the remote interface...\n...and the constructor needs \nto throw a remote exception, \nbecause the superclass does. That\u2019s it! Nothing \nchanges here at all!", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 485", "position": 485, "chunk_type": "semantic", "token_estimate": 328}
{"text": "you are here 4\u2003 \u2003 449: the proxy pattern\nimport java.rmi. *;\n \npublic class GumballMonitor {\n    GumballMachineRemote machine;\n \n    public GumballMonitor(GumballMachineRemote machine) {\n        this.machine = machine;\n    }\n \n    public void report() {\n        try {\n            System.out.println(\"Gumball Machine: \" + machine.getLocation());\n            System.out.println(\"Current inventory: \" + machine.getCount() + \" gumballs\");\n            System.out.println(\"Current state: \" + machine.getState());\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n}\nNow for the GumballMonitor client... Remember the GumballMonitor? We wanted to reuse it without \nhaving to rewrite it to work over a network. Well, we\u2019re pretty much \ngoing to do that, but we do need to make a few changes. We also need to catch any remote exceptions \nthat might happen as we try to invoke methods \nthat are ultimately happening over the network. Now we\u2019re going to rely on the remote \ninterface rather than the concrete \nGumballMachine class. We need to import the RMI package because we \nare using the RemoteException class below...\nJoe was right; \nthis is working out \nquite nicely!", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 487", "position": 487, "chunk_type": "semantic", "token_estimate": 161}
{"text": "450\u2003 \u2003 Chapter 11: test drive the monitor\nimport java.rmi. *;\n \npublic class GumballMonitorTestDrive {\n \n    public static void main(String[] args) {\n        String[] location = {\"rmi://santafe.mightygumball.com/gumballmachine\",\n                             \"rmi://boulder.mightygumball.com/gumballmachine\",\n                             \"rmi://austin.mightygumball.com/gumballmachine\"}; \n \n        GumballMonitor[] monitor = new GumballMonitor[location.length];\n \n        for (int i=0; i < location.length; i++) {\n            try {\n                GumballMachineRemote machine = \n                        (GumballMachineRemote) Naming.lookup(location[i]);\n                monitor[i] = new GumballMonitor(machine);\n                System.out.println(monitor[i]);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n \n        for (int i=0; i < monitor.length; i++) {\n            monitor[i].report();\n        }\n    }\n}\nWriting the Monitor test drive\nNow we\u2019ve got all the pieces we need. We just need to write some \ncode so the CEO can monitor a bunch of gumball machines:\nHere\u2019s all the locations \nwe\u2019re going to monitor. Here\u2019s the monitor test drive. The \nCEO is going to run this! We create an array \nof locations, one for \neach machine. Then we iterate through each \nmachine and print out its report. Now we need to get a proxy \nto each remote machine. We also create an \narray of monitors.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 488", "position": 488, "chunk_type": "semantic", "token_estimate": 160}
{"text": "you are here 4\u2003 \u2003 451: the proxy pattern\nCode Up Close\nOn each machine, run rmiregistry in \nthe background or from a separate \nterminal window...\ntry {\n    GumballMachineRemote machine = \n\t\n        (GumballMachineRemote) Naming.lookup(location[i]);\n    monitor[i] = new GumballMonitor(machine);\n} catch (Exception e) {\n    e.printStackTrace();\n}\nRemember, Naming.lookup() is a \nstatic method in the RMI package \nthat takes a location and service \nname and looks it up in the \nrmiregistry at that location. This returns a proxy to the remote \nGumball Machine (or throws an exception \nif one can\u2019t be located). Once we get a proxy to the remote \nmachine, we create a new GumballMonitor \nand pass it the machine to monitor. Another demo for the CEO of Mighty Gumball...\n...and then run the GumballMachine, giving it \na location and an initial gumball count. % rmiregistry &\n% java GumballMachineTestDrive santafe.mightygumball.com 100\nFile  Edit   Window  Help  Huh? File  Edit   Window  Help  Huh? % rmiregistry &\n% java GumballMachineTestDrive boulder.mightygumball.com 100\nFile  Edit   Window  Help  Huh? % rmiregistry &\n% java GumballMachineTestDrive austin.mightygumball.com 250\nPopular machine! Okay, it\u2019s time to put all this work together and give another demo. First let\u2019s make \nsure a few gumball machines are running the new code:", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 489", "position": 489, "chunk_type": "semantic", "token_estimate": 198}
{"text": "452\u2003 \u2003 Chapter 11: demoing the monitor\nAnd now let\u2019s put the monitor in the hands of the CEO. Hopefully, this time he\u2019ll love it:\nFile  Edit   Window  Help  GumballsAndBeyond\n% java GumballMonitorTestDrive\nGumball Machine: santafe.mightygumball.com\nCurrent inventory: 99 gumballs\nCurrent state: waiting for quarter\nGumball Machine: boulder.mightygumball.com\nCurrent inventory: 44 gumballs\nCurrent state: waiting for turn of crank\nGumball Machine: austin.mightygumball.com\nCurrent inventory: 187 gumballs\nCurrent state: waiting for quarter\n%\nThe monitor iterates \nover each remote \nmachine and calls \nits getLocation(), \ngetCount(), and \ngetState() methods. By invoking methods on the proxy, we make \na remote call across the wire, and get back \na String, an integer, and a State object. Because we are using a proxy, the Gumball \nMonitor doesn\u2019t know, or care, that calls \nare remote (other than having to worry \nabout remote exceptions). This is amazing; it\u2019s going to \nrevolutionize my business and \nblow away the competition!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 490", "position": 490, "chunk_type": "semantic", "token_estimate": 150}
{"text": "you are here 4\u2003 \u2003 453: the proxy pattern\nThis worked great! But \nI want to make sure I \nunderstand exactly what\u2019s \ngoing on...\nCEO\u2019s desktop\nRemote GumballMachine \nwith a JVM\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nG\nu\nm\nb\na\nl\nl\nM\no\nn\ni\nt\no\nr\nP\nr\no\nx\ny\n/\nS\nt\nub\nS\nk\ne\nl\ne\nt\no\nn\naustin\nProxy/Stub\nRMI registry (on gumball machine)\n1\n3\nlookup( \u201caustin\u201d)\nproxy returned\ngetState( )\n2\nType is GumballMachineRemote\n1\nThe CEO runs the monitor, which first grabs the proxies to the remote \ngumball machines and then calls getState() on each one (along with \ngetCount() and getLocation()). Behind \nthe Scenes", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 491", "position": 491, "chunk_type": "semantic", "token_estimate": 125}
{"text": "454\u2003 \u2003 Chapter 11: proxy behind the scenes\nG\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nG\nu\nm\nb\na\nl\nl\nM\no\nn\ni\nt\no\nr\nP\nr\no\nx\ny\n/\nS\nt\nub\nS\nk\ne\nl\ne\nt\no\nn\ngetState( )\n2\ngetState() is called on the proxy, which forwards the call to the remote \nservice. The skeleton receives the request and then forwards it to the \nGumballMachine. getState()\n3\nGumballMachine returns the state to the skeleton, which serializes it and \ntransfers it back over the wire to the proxy. The proxy deserializes it and \nreturns it as an object to the monitor. G\nu\nm\nb\na\nl\nl\nM\na\nc\nh\ni\nn\ne\nG\nu\nm\nb\na\nl\nl\nM\no\nn\ni\nt\no\nr\nP\nr\no\nx\ny\n/\nS\nt\nub\nS\nk\ne\nl\ne\nt\no\nn\nState \nobject\nState \nobject\nSerialized \nState\nThe monitor hasn\u2019t changed at all, \nexcept it knows it may encounter \nremote exceptions. It also uses the \nGumballMachineRemote interface rather \nthan a concrete implementation. Likewise, the GumballMachine \nimplements another interface and \nmay throw a remote exception in its \nconstructor, but other than that, the \ncode hasn\u2019t changed. We also have a small bit of code to register and locate stubs using the \nRMI registry. But no matter what, if we were writing something to \nwork over the internet, we\u2019d need some kind of locator service.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 492", "position": 492, "chunk_type": "semantic", "token_estimate": 253}
{"text": "you are here 4\u2003 \u2003 455: the proxy pattern\nWell, we\u2019ve seen how the Proxy Pattern provides a surrogate or \nplaceholder for another object. We\u2019ve also described the proxy as \na \u201crepresentative\u201d for another object. But what about a proxy controlling access? That sounds a little \nstrange. No worries. In the case of the gumball machine, just think \nof the proxy controlling access to the remote object. The proxy \nneeded to control access because our client, the monitor, didn\u2019t \nknow how to talk to a remote object. So in some sense the remote \nproxy controlled access so that it could handle the network details \nfor us. As we just discussed, there are many variations of the Proxy \nPattern, and the variations typically revolve around the way the \nproxy \u201ccontrols access.\u201d We\u2019re going to talk more about this later, \nbut for now here are a few ways proxies control access:\n\u2003\n\u0083\nAs we know, a remote proxy controls access to a remote \nobject. \u0083\nA virtual proxy controls access to a resource that is expensive \nto create. \u0083\nA protection proxy controls access to a resource based on \naccess rights. Now that you\u2019ve got the gist of the general pattern, check out the \nclass diagram... The Proxy Pattern defined\nThe Proxy Pattern provides a surrogate or \nplaceholder for another object to control access to it. We\u2019ve already put a lot of pages behind us in this chapter; as you \ncan see, explaining the Remote Proxy is quite involved. Despite that, \nyou\u2019ll see that the definition and class diagram for the Proxy Pattern \nis actually fairly straightforward. Note that the Remote Proxy is one \nimplementation of the general Proxy Pattern; there are actually \nquite a few variations of the pattern, and we\u2019ll talk about them later. For now, let\u2019s get the details of the general pattern down. Here\u2019s the Proxy Pattern definition:\nUse the Proxy \nPattern to create a \nrepresentative object \nthat controls access \nto another object, \nwhich may be remote, \nexpensive to create, or \nin need of securing.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 493", "position": 493, "chunk_type": "semantic", "token_estimate": 336}
{"text": "456\u2003 \u2003 Chapter 11: the proxy pattern defined\nBoth the Proxy and the \nRealSubject implement the \nSubject interface. This \nallows any client to treat \nthe proxy just like the \nRealSubject. The RealSubject is \nusually the object \nthat does most \nof the real work; \nthe Proxy controls \naccess to it. The Proxy keeps a \nreference to the \nSubject, so it can \nforward requests \nto the Subject \nwhen necessary. <<interface>>\nSubject\nrequest()\nRealSubject\nrequest()\nProxy\nsubject\nrequest()\nThe Proxy often instantiates \nor handles the creation of \nthe RealSubject. Let\u2019s step through the diagram...\nFirst we have a Subject, which provides an interface for the RealSubject and the \nProxy. Because it implements the same interface as the RealSubject, the Proxy can \nbe substituted for the RealSubject anywhere it occurs. The RealSubject is the object that does the real work. It\u2019s the object that the Proxy \nrepresents and controls access to. The Proxy holds a reference to the RealSubject. In some cases, the Proxy may be \nresponsible for creating and destroying the RealSubject. Clients interact with the \nRealSubject through the Proxy. Because the Proxy and RealSubject implement the \nsame interface (Subject), the Proxy can be substituted anywhere the Subject can be \nused. The Proxy also controls access to the RealSubject; this control may be needed \nif the Subject is running on a remote machine, if the Subject is expensive to create \nin some way, or if access to the subject needs to be protected in some way. Now that you understand the general pattern, let\u2019s look at some other ways of using \nproxy beyond the Remote Proxy...", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 494", "position": 494, "chunk_type": "semantic", "token_estimate": 262}
{"text": "you are here 4\u2003 \u2003 457: the proxy pattern\nGet ready for the Virtual Proxy\nOkay, so far you\u2019ve seen the definition of the Proxy Pattern and you\u2019ve taken a look \nat one specific example: the Remote Proxy. Now we\u2019re going to take a look at a different \ntype of proxy, the Virtual Proxy. As you\u2019ll discover, the Proxy Pattern can manifest \nitself in many forms, yet all the forms follow roughly the general proxy design. Why \nso many forms? Because the Proxy Pattern can be applied to a lot of different use \ncases. Let\u2019s check out the Virtual Proxy and compare it to the Remote Proxy:\n \n \n \n \nR\ne\na\nl\nS\nu\nbje\nc\nt\n \n \n \n \n \n \nC\nl\ni\ne\nn\nt\nP\nr\no\nx\ny\nRemote Proxy\nrequest( )\nrequest( )\nWith the Remote Proxy, the proxy \nacts as a local representative \nfor an object that lives in a \ndifferent JVM. A method call on \nthe proxy results in the call being \ntransferred over the wire and \ninvoked remotely, and the result \nbeing returned back to the proxy \nand then to the Client. R\ne\na\nl\nS\nu\nbje\nc\nt\n \n \n \n \n \n \nC\nl\ni\ne\nn\nt\nP\nr\no\nx\ny\nVirtual Proxy\nThe Virtual Proxy acts as a \nrepresentative for an object that \nmay be expensive to create. The \nVirtual Proxy often defers the \ncreation of the object until it \nis needed; the Virtual Proxy \nalso acts as a surrogate for \nthe object before and while it is \nbeing created. After that, the proxy \ndelegates requests directly to the \nRealSubject. We know this diagram \npretty well by now...\nBig \u201cexpensive to create\u201d object. The proxy creates \nthe RealSubject \nwhen it\u2019s needed. request( )\nrequest( )\nThe proxy may handle the request, or if \nthe RealSubject has been created, delegate \nthe calls to the RealSubject.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 495", "position": 495, "chunk_type": "semantic", "token_estimate": 308}
{"text": "458\u2003 \u2003 Chapter 11: image proxy controls access\nWhile the album cover is loading, \nthe proxy displays a message. When the album cover is \nfully loaded, the proxy \ndisplays the image. Choose the album cover of \nyour liking here. Displaying Album covers\nLet\u2019s say you want to write an application that displays your favorite album covers. You might create a menu of the album titles and then retrieve the images from an \nonline service like Amazon.com. If you\u2019re using Swing, you might create an Icon \nand ask it to load the image from the network. The only problem is, depending \non the network load and the bandwidth of your connection, retrieving an album \ncover might take a little time, so your application should display something while \nyou\u2019re waiting for the image to load. We also don\u2019t want to hang up the entire \napplication while it\u2019s waiting on the image. Once the image is loaded, the message \nshould go away and you should see the image. An easy way to achieve this is through a virtual proxy. The virtual proxy can stand \nin place of the icon, manage the background loading, and before the image is \nfully retrieved from the network, display \u201cLoading album cover, please wait...\u201d. Once the image is loaded, the proxy delegates the display to the Icon.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 496", "position": 496, "chunk_type": "semantic", "token_estimate": 218}
{"text": "you are here 4\u2003 \u2003 459: the proxy pattern\nDesigning the Album Cover Virtual Proxy\n<<interface>>\nIcon\ngetIconWidth()\ngetIconHeight()\npaintIcon()\nImageProxy\nsubject\ngetIconWidth()\ngetIconHeight()\npaintIcon()\ngetIconWidth()\ngetIconHeight()\npaintIcon()\nImageIcon\nThis is javax.swing.ImageIcon, \na class that displays an Image. This is our proxy, which first \ndisplays a message and then, when \nthe image is loaded, delegates to \nImageIcon to display the image. This is the Swing \nIcon interface used \nto display images in a \nuser interface. Before writing the code for the Album Cover Viewer, let\u2019s look at the class diagram. You\u2019ll see this looks just like our Remote Proxy class diagram, but here the proxy is \nused to hide an object that is expensive to create (because we need to retrieve the data \nfor the Icon over the network) as opposed to an object that actually lives somewhere \nelse on the network. ImageProxy first creates an ImageIcon and starts \nloading it from a network URL. While the bytes of the image are being retrieved, \nImageProxy displays  \u201cLoading album cover, please \nwait...\u201d. When the image is fully loaded, ImageProxy delegates \nall method calls to the image icon, including \npaintIcon(), getIconWidth(), and getIconHeight(). If the user requests a new image, we\u2019ll create a new \nproxy and start the process over. How ImageProxy is going to work:\n1\n2\n3\n4", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 497", "position": 497, "chunk_type": "semantic", "token_estimate": 217}
{"text": "460\u2003 \u2003 Chapter 11: the image proxy\nclass ImageProxy implements Icon {\n    volatile ImageIcon imageIcon;\n    final URL imageURL;\n    Thread retrievalThread;\n    boolean retrieving = false;\n     \n    public ImageProxy(URL url) { imageURL = url; }\n    public int getIconWidth() {\n        if (imageIcon != null) {\n            return imageIcon.getIconWidth();\n        } else {\n            return 800;\n        }\n    }\n    public int getIconHeight() {\n        if (imageIcon != null) {\n            return imageIcon.getIconHeight();\n        } else {\n            return 600;\n        }\n    }\n    synchronized void setImageIcon(ImageIcon imageIcon) {\n        this.imageIcon = imageIcon;\n    }\n     \n    public void paintIcon(final Component c, Graphics  g, int x,  int y) {\n        if (imageIcon != null) {\n            imageIcon.paintIcon(c, g, x, y);\n        } else {\n            g.drawString(\"Loading album cover, please wait...\", x+300, y+190);\n            if (!retrieving) {\n                retrieving = true;\n                retrievalThread = new Thread(new Runnable() {\n                    public void run() {\n                        try {\n                            setImageIcon(new ImageIcon(imageURL, \"Album Cover\"));\n                            c.repaint();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                });\n                retrievalThread.start();\n            }\n        }\n    }\n}\nWriting the Image Proxy\nWe pass the URL of the image into \nthe constructor. This is the image we \nneed to display once it\u2019s loaded! The imageIcon is the REAL icon that we \neventually want to display when it\u2019s loaded. We return a default width and height \nuntil the imageIcon is loaded; then we \nturn it over to the imageIcon. Here\u2019s where things get interesting. This code paints the icon on the \nscreen (by delegating to imageIcon). However, if we don\u2019t have a fully \ncreated imageIcon, then we create \none. Let\u2019s look at this up close on the \nnext page...\n<<interface>>\nIcon\ngetIconWidth()\ngetIconHeight()\npaintIcon()\nThe ImageProxy \nimplements the Icon \ninterface. imageIcon is used by two different \nthreads, so along with making the variable \nvolatile (to protect reads), we use a \nsynchronized setter (to protect writes).", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 498", "position": 498, "chunk_type": "semantic", "token_estimate": 280}
{"text": "you are here 4\u2003 \u2003 461: the proxy pattern\n. Code Up Close\n   public void paintIcon(final Component c, Graphics  g, int x,  int y) {\n        if (imageIcon != null) {\n            imageIcon.paintIcon(c, g, x, y);\n        } else {\n            g.drawString(\"Loading album cover, please wait...\", x+300, y+190);\n            if (!retrieving) {\n                retrieving = true;\n                retrievalThread = new Thread(new Runnable() {\n                    public void run() {\n                        try {\n                            setImageIcon(new ImageIcon(imageURL, \"Album Cover\"));\n                            c.repaint();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                });\n                retrievalThread.start();\n            }\n        }\n    }\nThis method is called when it\u2019s time to paint the icon on the screen. If we\u2019ve got an icon already, we go \nahead and tell it to paint itself. Otherwise we  \ndisplay the \n\u201cloading\u201d message. Here\u2019s where we load the REAL icon image. Note that \nthe image loading with IconImage is synchronous: the \nImageIcon constructor doesn\u2019t return until the image \nis loaded. That doesn\u2019t give us much of a chance to do \nscreen updates and have our message displayed, so we\u2019re \ngoing to do this asynchronously. See the \u201cCode Way Up \nClose\u201d on the next page for more...", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 499", "position": 499, "chunk_type": "semantic", "token_estimate": 177}
{"text": "462\u2003 \u2003 Chapter 11: image proxy up close\n            \n            if (!retrieving) {\n                retrieving = true;\n                retrievalThread = new Thread(new Runnable() {\n                    public void run() {\n                        try {\n                            setImageIcon(new ImageIcon(imageURL, \"Album Cover\"));\n                            c.repaint();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                });\n                retrievalThread.start();\n            }\nIn our thread we \ninstantiate the \nIcon object. Its \nconstructor will not \nreturn until the \nimage is loaded. If we aren\u2019t already trying to retrieve the image...\nWe don\u2019t want to hang up the \nentire user interface, so we\u2019re \ngoing to use another thread to \nretrieve the image. When we have the image, \nwe tell Swing that we \nneed to be repainted. So, the next time the display is painted after the ImageIcon is instantiated, \nthe paintIcon() method will paint the image, not the loading message. ...then it\u2019s time to start retrieving it (in case you \nwere wondering, only one thread calls paint, so we \nshould be okay here in terms of thread safety). Code Way Up Close", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 500", "position": 500, "chunk_type": "semantic", "token_estimate": 159}
{"text": "you are here 4\u2003 \u2003 463: the proxy pattern\nclass ImageProxy implements Icon {\n    // instance variables & constructor here\n     \n    public int getIconWidth() {\n        if (imageIcon != null) {\n            return imageIcon.getIconWidth();\n        } else {\n            return 800;\n        }\n    }\n \n    public int getIconHeight() {\n        if (imageIcon != null) {\n            return imageIcon.getIconHeight();\n        } else {\n            return 600;\n        }\n    }\n     \n    public void paintIcon(final Component c, Graphics  g, int x,  int y) {\n        if (imageIcon != null) {\n            imageIcon.paintIcon(c, g, x, y);\n        } else {\n            g.drawString(\"Loading album cover, please wait...\", x+300, y+190);\n\t\n     // more code here\n        }             \n    }\n}\nThe ImageProxy class appears to have two states that are controlled \nby conditional statements. Can you think of another pattern that might \nclean up this code? How would you redesign ImageProxy? Two states\nTwo states\nTwo states\n Design Puzzle", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 501", "position": 501, "chunk_type": "semantic", "token_estimate": 132}
{"text": "464\u2003 \u2003 Chapter 11: test drive the image proxy\npublic class ImageProxyTestDrive {\n    ImageComponent imageComponent;\n    public static void main (String[] args) throws Exception {\n        ImageProxyTestDrive testDrive = new ImageProxyTestDrive();\n    }\n \n    public ImageProxyTestDrive() throws Exception {\n        \n        // set up frame and menus\n \n        Icon icon = new ImageProxy(initialURL);\n        imageComponent = new ImageComponent(icon);\n        frame.getContentPane().add(imageComponent);\n    }\n}\nTesting the Album Cover Viewer\nHere we create an image proxy and \nset it to an initial URL. Whenever \nyou choose a selection from the Album \nmenu, you\u2019ll get a new image proxy. Okay, it\u2019s time to test out this fancy new virtual proxy. Behind the scenes \nwe\u2019ve been baking up a new ImageProxyTestDrive that sets up the window, \ncreates a frame, installs the menus, and creates our proxy. We don\u2019t go \nthrough all that code in gory detail here, but you can always grab the \nsource code and have a look, or check it out at the end of the chapter \nwhere we list all the source code for the Virtual Proxy. Here\u2019s a partial view of the test drive code:\nNext we wrap our proxy in a \ncomponent so it can be added to \nthe frame. The component will \ntake care of the proxy's width, \nheight, and similar details. Finally we add the proxy to the \nframe so it can be displayed. Now let\u2019s run the test drive:\nRunning ImageProxyT\nestDrive \nshould give you a window like this. Use the menu to load different album covers; watch the \nproxy display \u201cloading\u201d until the image has arrived. Resize the window as the \u201cloading\u201d message is displayed. Notice that the proxy is handling the loading without \nhanging up the Swing window. Add your own favorite albums to ImageProxyTestDrive. Things to try...\n1\n2\n3\nFile  Edit   Window  Help  JustSomeOfTheAlbumsThatGotUsThroughThisBook\n% java ImageProxyTestDrive\nReady Bake\nCode\naphex twin", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 502", "position": 502, "chunk_type": "semantic", "token_estimate": 299}
{"text": "you are here 4\u2003 \u2003 465: the proxy pattern\nI\nm\na\ng\ne\nI\nc\no\nn\nget image\nget image\nWhat did we do? I\nm\na\ng\ne\nI\nc\no\nn\n \n \n \n \n \n \nI\nm\na\ng\ne\nPr\no\nx\ny\nimage retrieved\nimage retrieved\nWe created an ImageProxy class for the display. The \npaintIcon() method is called and ImageProxy fires off a \nthread to retrieve the image and create the ImageIcon. paintIcon()\npaintIcon()\nImageProxy creates a \nthread to instantiate the \nImageIcon, which starts \nretrieving the image. displays loading \ndisplays loading \nmessage\nmessage\nAt some point the image is returned and \nthe ImageIcon fully instantiated. After the ImageIcon is created, the next time paintIcon() \nis called, the proxy delegates to the ImageIcon. I\nm\na\ng\ne\nI\nc\no\nn\n \n \n \n \n \n \nI\nm\na\ng\ne\nPr\no\nx\ny\npaintIcon()\npaintIcon()\ndisplays the real image\ndisplays the real image\npaintIcon()\npaintIcon()\n1\n2\n3\nSome image \nSome image \nserver on \nserver on \nthe internet\nthe internet\nBehind \nthe Scenes", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 503", "position": 503, "chunk_type": "semantic", "token_estimate": 172}
{"text": "466\u2003 \u2003 Chapter 11: q&a about the image proxy\nQ: The Remote Proxy and Virtual \nProxy seem so different to me; are \nthey really ONE pattern? A: You\u2019ll find a lot of variants of the \nProxy Pattern in the real world; what \nthey all have in common is that they \nintercept a method invocation that the \nclient is making on the subject. This \nlevel of indirection allows us to do \nmany things, including dispatching \nrequests to a remote subject, providing \na representative for an expensive \nobject as it is created, or, as you\u2019ll see, \nproviding some level of protection that \ncan determine which clients should be \ncalling which methods. That\u2019s just the \nbeginning; the general Proxy Pattern \ncan be applied in many different ways, \nand we\u2019ll cover some of the other ways \nat the end of the chapter. Q: ImageProxy seems just like \na Decorator to me. I mean, we are \nbasically wrapping one object with \nanother and then delegating the calls \nto the ImageIcon. What am I missing? A: Sometimes Proxy and Decorator \nlook very similar, but their purposes are \ndifferent: a decorator adds behavior to \na class, while a proxy controls access \nto it. You might ask, \u201cIsn\u2019t the loading \nmessage adding behavior?\u201d In some \nways it is; however, more importantly,  \nthe ImageProxy is controlling access \nto an ImageIcon. How does it control \naccess? Well, think about it this way: \nthe proxy is decoupling the client from \nthe ImageIcon. If they were coupled \n\nthe client would have to wait until each \nimage is retrieved before it could paint \nits entire interface. The proxy controls \naccess to the ImageIcon so that before \nit is fully created, the proxy provides \nanother onscreen representation. Once \nthe ImageIcon is created, the proxy \nallows access. Q: How do I make clients use the \nProxy rather than the Real Subject? A: Good question. One common \ntechnique is to provide a factory that \ninstantiates and returns the subject. Because this happens in a factory \nmethod, we can then wrap the subject \nwith a proxy before returning it. The \nclient never knows or cares that it\u2019s \nusing a proxy instead of the real thing. Q: I noticed in the ImageProxy \nexample, you always create a new \nImageIcon to get the image, even if \nthe image has already been retrieved. Could you implement something \nsimilar to the ImageProxy that \ncaches past retrievals?", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 504", "position": 504, "chunk_type": "semantic", "token_estimate": 394}
{"text": "466\u2003 \u2003 Chapter 11: Q: I noticed in the ImageProxy \nexample, you always create a new \nImageIcon to get the image, even if \nthe image has already been retrieved. Could you implement something \nsimilar to the ImageProxy that \ncaches past retrievals? A: You are talking about a \nspecialized form of a Virtual Proxy \ncalled a Caching Proxy. A caching proxy \nmaintains a cache of previously created \nobjects and when a request is made it \nreturns a cached object, if possible. We\u2019re going to look at this and at \nseveral other variants of the Proxy \nPattern at the end of the chapter. Q: I see how Decorator and Proxy \nrelate, but what about Adapter? An \nadapter seems very similar as well. A: Both Proxy and Adapter sit in front \nof other objects and forward requests to \nthem. Remember that Adapter changes \nthe interface of the objects it adapts, \nwhile Proxy implements the same \ninterface. There is one additional similarity that \nrelates to the Protection Proxy. A \nProtection Proxy may allow or disallow \na client access to particular methods \nin an object based on the role of the \nclient. In this way a Protection Proxy \nmay only provide a partial interface to \na client, which is quite similar to some \nAdapters. We are going to take a look at \nProtection Proxy in a few pages.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 504", "position": 504, "chunk_type": "semantic", "token_estimate": 222}
{"text": "you are here 4\u2003 \u2003 467: the proxy pattern\nTonight\u2019s talk: Proxy and Decorator get intentional. Proxy:\nHello, Decorator. I presume you\u2019re here because \npeople sometimes get us confused? Me copying your ideas? Please. I control access to \nobjects. You just decorate them. My job is so much \nmore important than yours it\u2019s just not even funny. Fine, so maybe you\u2019re not entirely frivolous...but I \nstill don\u2019t get why you think I\u2019m copying all your \nideas. I\u2019m all about representing my subjects, not \ndecorating them. I don\u2019t think you get it, Decorator. I stand in for \nmy Subjects; I don\u2019t just add behavior. Clients use \nme as a surrogate of a Real Subject, because I can \nprotect them from unwanted access, or keep their \nGUIs from hanging up while they\u2019re waiting for big \nobjects to load, or hide the fact that their Subjects \nare running on remote machines. I\u2019d say that\u2019s a \nvery different intent from yours! Decorator:\n\n\nWell, I think the reason people get us confused is \nthat you go around pretending to be an entirely \ndifferent pattern, when in fact, you\u2019re just Decorator \nin disguise. I really don\u2019t think you should be \ncopying all my ideas. \u201cJust\u201d decorate? You think decorating is some \nfrivolous, unimportant pattern? Let me tell you \nbuddy, I add behavior. That\u2019s the most important \nthing about objects\u2014what they do! You can call it \u201crepresentation\u201d but if it looks like \na duck and walks like a duck... I mean, just look at  \nyour Virtual Proxy; it\u2019s just another way of adding \nbehavior to do something while some big expensive \nobject is loading, and your Remote Proxy is a way \nof talking to remote objects so your clients don\u2019t \nhave to bother with that themselves. It\u2019s all about \nbehavior, just like I said. Call it what you want. I implement the same \ninterface as the objects I wrap; so do you.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 505", "position": 505, "chunk_type": "semantic", "token_estimate": 314}
{"text": "468\u2003 \u2003 Chapter 11: fireside chats: proxy and decorator\nProxy:\nOkay, let\u2019s review that statement. You wrap an \nobject. While sometimes we informally say a proxy \nwraps its Subject, that\u2019s not really an accurate term. Think about a remote proxy...what object am \nI wrapping? The object I\u2019m representing and \ncontrolling access to lives on another machine! Let\u2019s see you do that. Sure, okay, take a virtual proxy...think about the \nalbum viewer example. When the client first uses \nme as a proxy the subject doesn\u2019t even exist! So \nwhat am I wrapping there? I never knew decorators were so dumb! Of course \nI sometimes create objects. How do you think a \nvirtual proxy gets its subject?! Okay, you just pointed \nout a big difference between us: we both know \ndecorators only add window dressing; they never get \nto instantiate anything. Hey, after this conversation I\u2019m convinced you\u2019re \njust a dumb proxy! Very seldom will you ever see a proxy get into \nwrapping a subject multiple times; in fact, if you\u2019re \nwrapping something 10 times, you better go back \nreexamine your design. Decorator:\n\n\n\n\nOh yeah? Why not? Okay, but we all know remote proxies are kinda \nweird. Got a second example? I doubt it. Uh huh, and the next thing you\u2019ll be saying is that \nyou actually get to create objects. Oh yeah? Instantiate this! Dumb proxy? I\u2019d like to see you recursively wrap \nan object with 10 decorators and keep your head \nstraight at the same time. Just like a proxy, acting all real when in fact you just \nstand in for the objects doing the real work. You \nknow, I actually feel sorry for you.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 506", "position": 506, "chunk_type": "semantic", "token_estimate": 274}
{"text": "you are here 4\u2003 \u2003 469: the proxy pattern\nUsing the Java API\u2019s Proxy to create a \nprotection proxy\nJava\u2019s got its own proxy support right in the java.lang.reflect package. With this package, \nJava lets you create a proxy class on the fly that implements one or more interfaces and \nforwards method invocations to a class that you specify. Because the actual proxy class is \ncreated at runtime, we refer to this Java technology as a dynamic proxy. We\u2019re going to use Java\u2019s dynamic proxy to create our next proxy implementation (a \nprotection proxy), but before we do that, let\u2019s quickly look at a class diagram that shows \nhow dynamic proxies are put together. Like most things in the real world, it differs \nslightly from the classic definition of the pattern:\n<<interface>>\nSubject\nrequest()\nRealSubject\nrequest()\nProxy\nrequest()\n<<interface>>\nInvocationHandler\ninvoke()\nInvocationHandler\nThe Proxy now consists \nof two classes. The Proxy is generated \nby Java and implements \nthe entire Subject \ninterface. You supply the InvocationHandler, which gets passed \nall method calls that are invoked on the Proxy. The InvocationHandler controls access to the \nmethods of the RealSubject. Because Java creates the Proxy class for you, you need a way to tell the Proxy class what \nto do. You can\u2019t put that code into the Proxy class like we did before, because you\u2019re not \nimplementing one directly. So, if you can\u2019t put this code in the Proxy class, where do \nyou put it? In an InvocationHandler. The job of the InvocationHandler is to respond to \nany method calls on the proxy. Think of the InvocationHandler as the object the Proxy \nasks to do all the real work after it has received the method calls. Okay, let\u2019s step through how to use the dynamic proxy...\ninvoke()", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 507", "position": 507, "chunk_type": "semantic", "token_estimate": 293}
{"text": "470\u2003 \u2003 Chapter 11: protection proxy\npublic interface Person {\n \n    String getName();\n    String getGender();\n    String getInterests();\n    int getGeekRating();\n \n    void setName(String name);\n    void setGender(String gender);\n    void setInterests(String interests);\n    void setGeekRating(int rating); \n \n}\nGeeky Matchmaking in Objectville\nEvery town needs a matchmaking service, right? You\u2019ve risen to the task and \nimplemented a dating service for Objectville. You\u2019ve also tried to be innovative \nby including a \u201cGeek rating\u201d feature where participants can rate each other\u2019s \ngeekiness (a good thing)\u2014you figure this keeps your customers engaged and \nlooking through possible matches; it also makes things a lot more fun. Your service revolves around a Person interface that allows you to set and get \ninformation about a person:\nHere we can get information \nabout the person\u2019s name, \ngender, interests, and Geek \nrating (1-10). We can also set the same \ninformation through the \nrespective method calls. setGeekRating() takes an integer \nand adds it to the running \naverage for this person. This is the interface; we\u2019ll \nget to the implementation \nin just a sec...\nNow let\u2019s check out the implementation...", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 508", "position": 508, "chunk_type": "semantic", "token_estimate": 172}
{"text": "you are here 4\u2003 \u2003 471: the proxy pattern\npublic class PersonImpl implements Person {\n    String name;\n    String gender;\n    String interests;\n    int rating;\n    int ratingCount = 0;\n  \n    public String getName() {\n        return name;    \n    } \n  \n    public String getGender() {\n        return gender;\n    }\n  \n    public String getInterests() {\n        return interests;\n    }\n   \n    public int getGeekRating() {\n        if (ratingCount == 0) return 0;\n        return (rating/ratingCount);\n    }\n  \n \n    public void setName(String name) {\n        this.name = name;\n    }\n \n    public void setGender(String gender) {\n        this.gender = gender;\n    } \n  \n    public void setInterests(String interests) {\n        this.interests = interests;\n    } \n  \n    public void setGeekRating(int rating) {\n        this.rating += rating;  \n        ratingCount++;\n    }\n}\nThe instance variables. The PersonImpl implements the Person interface. All the getter methods; they each return \nthe appropriate instance variable...\n...except for getGeekRating(), \nwhich computes the average \nof the ratings by dividing the \nratings by the ratingCount. And here\u2019s all the setter \nmethods, which set the \ncorresponding instance variable. Finally, the setGeekRating() method \nincrements the total ratingCount and \nadds the rating to the running total. The Person implementation", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 509", "position": 509, "chunk_type": "semantic", "token_estimate": 166}
{"text": "472\u2003 \u2003 Chapter 11: person needs protecting\nWhile we suspect other factors may be keeping Elroy from getting \ndates, he\u2019s right: you shouldn\u2019t be able to vote for yourself or to \nchange another customer\u2019s data. The way Person is defined, any client \ncan call any of the methods. This is a perfect example of where we might be able to use a \nProtection Proxy. What\u2019s a Protection Proxy? It\u2019s a proxy that controls \naccess to an object based on access rights. For instance, if we had an \nemployee object, a Protection Proxy might allow the employee to call \ncertain methods on the object, a manager to call additional methods \n(like setSalary()), and a human resources employee to call any method \non the object. In our dating service we want to make sure that a customer can set \nhis own information while preventing others from altering it. We also \nwant to allow just the opposite with the Geek ratings: we want the \nother customers to be able to set the rating, but not that particular \ncustomer. We also have a number of getter methods in Person, and \nbecause none of these return private information, any customer \nshould be able to call them. Elroy\nI wasn\u2019t very successful finding dates. Then I noticed someone had changed my \ninterests. I also noticed that a lot of \npeople are bumping up their Geek scores \nby giving themselves high ratings. You \nshouldn\u2019t be able to change someone else\u2019s \ninterests or give yourself a rating!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 510", "position": 510, "chunk_type": "semantic", "token_estimate": 248}
{"text": "you are here 4\u2003 \u2003 473: the proxy pattern\nFive-minute drama: protecting subjects\nThe internet bubble seems a distant memory; those were the days \nwhen all you needed to do to find a better, higher-paying job was \nto walk across the street. Even agents for software developers \nwere in vogue...\nLike a protection \nproxy, the agent \nprotects access to his \nsubject, letting only \ncertain calls through... Agent\nJane DotCom\nI\u2019d like to make an \noffer, can we get her on \nthe phone? Come on. You\u2019re wasting our time \nhere! Not a chance! Come \nback later with a better \noffer. She\u2019s tied up...uh...\nin a meeting right now, \nwhat did you have in \nmind? We think we can \nmeet her current \nsalary plus 15%. Subject", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 511", "position": 511, "chunk_type": "semantic", "token_estimate": 123}
{"text": "474\u2003 \u2003 Chapter 11: big picture of proxy\nBig Picture: creating a Dynamic Proxy \nfor the Person\nWe have a couple of problems to fix: customers shouldn\u2019t be changing their \nown Geek rating and customers shouldn\u2019t be able to change other customers\u2019 \npersonal information. To fix these problems we\u2019re going to create two proxies: \none for accessing your own Person object and one for accessing another \ncustomer\u2019s Person object. That way, the proxies can control what requests can \nbe made in each circumstance. <<interface>>\nSubject\nrequest()\nRealSubject\nrequest()\nProxy\nrequest()\n<<interface>>\nInvocationHandler\ninvoke()\nInvocationHandler\nCreate two InvocationHandlers. Write the code that creates the \ndynamic proxies. Wrap any Person object with the \nappropriate proxy. InvocationHandlers implement the behavior \nof the proxy. As you\u2019ll see, Java will take care \nof creating the actual proxy class and object; \nwe just need to supply a handler that knows \nwhat to do when a method is called on it. We need to write a little bit of code to \ngenerate the proxy class and instantiate it. We\u2019ll step through this code in just a bit. When we need to use a Person object, either it\u2019s \nthe object of the customer himself (in that case, \nwe\u2019ll call him the \u201cowner\u201d), or it\u2019s another user \nof the service that the customer is checking out \n(in that case we\u2019ll call him \u201cnon-owner\u201d). In either case, we create the appropriate proxy \nfor the Person. Step one:\nStep two:\nStep three:\nWe need two \nof these. We create the \nproxy itself at \nruntime. request()\nProxy\ninvoke()\nOwnerInvocationHandler\nrequest()\nProxy\ninvoke()\nNonOwnerInvocationHandler\nWhen a customer is viewing his own bean\nWhen a customer is viewing someone else\u2019s bean\ninvoke()\nTo create these proxies we\u2019re going to use the Java \nAPI\u2019s dynamic proxy that you saw a few pages \nback. Java will create two proxies for us; all we \nneed to do is supply the handlers that know what \nto do when a method is invoked on the proxy. Remember this diagram \nfrom a few pages back...", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 512", "position": 512, "chunk_type": "semantic", "token_estimate": 334}
{"text": "you are here 4\u2003 \u2003 475: the proxy pattern\nStep one: creating Invocation Handlers\nWe know we need to write two invocation handlers, one for the owner and one for \nthe non-owner. But what are invocation handlers? Here\u2019s the way to think about \nthem: when a method call is made on the proxy, the proxy forwards that call to \nyour invocation handler, but not by calling the invocation handler\u2019s corresponding \nmethod. So, what does it call? Have a look at the InvocationHandler interface:\nThere\u2019s only one method, invoke(), and no matter what methods get called \non the proxy, the invoke() method is what gets called on the handler. Let\u2019s see \nhow this works:\nproxy.setGeekRating(9);\ninvoke(Object proxy, Method method, Object[] args)\nLet\u2019s say the setGeekRating() \nmethod is called on the proxy. The proxy then \nturns around and \ncalls invoke() on the \nInvocationHandler. 1\n2\nThe handler decides \nwhat it should do \nwith the request \nand possibly \nforwards it on to \nthe RealSubject. How does the \nhandler decide? We\u2019ll find out next. 3\nreturn method.invoke(person, args);\nHere we invoke the \noriginal method that was \ncalled on the proxy. This \nobject was passed to us in \nthe invoke call. Only now we \ninvoke it on the \nRealSubject...\n...with the original \narguments. Here\u2019s how \nwe invoke the \nmethod on the \nRealSubject. The Method class, part of the \nreflection API, tells us what \nmethod was called on the proxy \nvia its getName() method. <<interface>>\nInvocationHandler\ninvoke()", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 513", "position": 513, "chunk_type": "semantic", "token_estimate": 240}
{"text": "476\u2003 \u2003 Chapter 11: creating an invocation handler\nimport java.lang.reflect. *;\n \npublic class OwnerInvocationHandler implements InvocationHandler { \n    Person person;\n \n    public OwnerInvocationHandler(Person person) {\n        this.person = person;\n    }\n \n    public Object invoke(Object proxy, Method method, Object[] args) \n            throws IllegalAccessException {\n  \n        try {\n            if (method.getName().startsWith(\"get\")) {\n                return method.invoke(person, args);\n            } else if (method.getName().equals(\"setGeekRating\")) {\n                throw new IllegalAccessException();\n            } else if (method.getName().startsWith(\"set\")) {\n                return method.invoke(person, args);\n            } \n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        } \n        return null;\n    }\n}\nCreating Invocation Handlers, continued... When invoke() is called by the proxy, how do you know what to do with the call? Typically, you\u2019ll examine the method that was called on the proxy and make \ndecisions based on the method\u2019s name and possibly its arguments. Let\u2019s implement \nOwnerInvocationHandler to see how this works:\nInvocationHandler is part of the java.lang.reflect \npackage, so we need to import it. All invocation handlers \nimplement the \nInvocationHandler interface. We're passed the \nRealSubject in the \nconstructor and we \nkeep a reference to it. Here\u2019s the invoke() \nmethod that gets \ncalled every time a \nmethod is invoked \non the proxy. If the method is a getter, \nwe go ahead and invoke it \non the real subject. Otherwise, if it is \nthe setGeekRating() \nmethod we disallow \nit by throwing \nIllegalAccessException. Because we are the \nowner, any other set \nmethod is fine and we \ngo ahead and invoke it \non the real subject. If any other method is called, \nwe\u2019re just going to return null \nrather than take a chance. This will happen if \nthe real subject \nthrows an exception.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 514", "position": 514, "chunk_type": "semantic", "token_estimate": 253}
{"text": "you are here 4\u2003 \u2003 477: the proxy pattern\nThe NonOwnerInvocationHandler works just like the OwnerInvocationHandler except \nthat it allows calls to setGeekRating() and it disallows calls to any other set method. Go ahead and write this handler yourself:", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 515", "position": 515, "chunk_type": "semantic", "token_estimate": 38}
{"text": "478\u2003 \u2003 Chapter 11: create the proxy\nPerson getOwnerProxy(Person person) {\n    \n    return (Person) Proxy.newProxyInstance( \n            person.getClass().getClassLoader(),\n            person.getClass().getInterfaces(),\n            new OwnerInvocationHandler(person));\n}\nNow, all we have left is to dynamically create the Proxy class and instantiate the proxy \nobject. Let\u2019s start by writing a method that takes a Person object and knows how to create \nan owner proxy for it. That is, we\u2019re going to create the kind of proxy that forwards its \nmethod calls to OwnerInvocationHandler. Here\u2019s the code:\nStep two: creating the Proxy class and \ninstantiating the Proxy object\nThis method takes a Person object (the real \nsubject) and returns a proxy for it. Because the \nproxy has the same interface as the subject, we \nreturn a Person. This code creates the \nproxy. Now this is some \nmighty ugly code, so let\u2019s \nstep through it carefully. T\no create a proxy we use the \nstatic newProxyInstance() \nmethod on the Proxy class. We pass it the class loader for our subject...\n...and the set of interfaces the \nproxy needs to implement...\n...and an invocation handler, in this \ncase our OwnerInvocationHandler. We pass the real subject into the constructor of \nthe invocation handler. If you look back two pages, \nyou\u2019ll see this is how the handler gets access to \nthe real subject. While it is a little complicated, there isn\u2019t much to creating \na dynamic proxy. Why don\u2019t you write getNonOwnerProxy(), \nwhich returns a proxy for NonOwnerInvocationHandler:\nTake it further: can you write a method called getProxy() that takes \na handler and a person and returns a proxy that uses that handler?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 516", "position": 516, "chunk_type": "semantic", "token_estimate": 258}
{"text": "you are here 4\u2003 \u2003 479: the proxy pattern\npublic class MatchMakingTestDrive {\n    // instance variables here\n  \n    public static void main(String[] args) {\n        MatchMakingTestDrive test = new MatchMakingTestDrive();\n        test.drive();\n    }\n \n    public MatchMakingTestDrive() {\n        initializeDatabase();\n    }\n    public void drive() {\n        Person joe = getPersonFromDatabase(\"Joe Javabean\"); \n        Person ownerProxy = getOwnerProxy(joe);\n        System.out.println(\"Name is \" + ownerProxy.getName());\n        ownerProxy.setInterests(\"bowling, Go\");\n        System.out.println(\"Interests set from owner proxy\");\n        try {\n            ownerProxy.setGeekRating(10);\n        } catch (Exception e) {\n            System.out.println(\"Can't set rating from owner proxy\");\n        }\n        System.out.println(\"Rating is \" + ownerProxy.getGeekRating());\n        Person nonOwnerProxy = getNonOwnerProxy(joe);\n        System.out.println(\"Name is \" + nonOwnerProxy.getName());\n        try {\n            nonOwnerProxy.setInterests(\"bowling, Go\");\n        } catch (Exception e) {\n            System.out.println(\"Can't set interests from non owner proxy\");\n        }\n        nonOwnerProxy.setGeekRating(3);\n        System.out.println(\"Rating set from non owner proxy\");\n        System.out.println(\"Rating is \" + nonOwnerProxy.getGeekRating());\n    }\n    // other methods like getOwnerProxy and getNonOwnerProxy here\n}\nTesting the matchmaking service\nLet\u2019s give the matchmaking service a test run and see how it controls access to \nthe setter methods based on the proxy that is used. The main() method just creates \nthe test drive and calls its drive() \nmethod to get things going. The constructor initializes our database \nof people in the matchmaking service. Let\u2019s retrieve a person \nfrom the database...\n...and create an owner proxy. Call a getter...\n...and then a setter. And then try to \nchange the rating. This shouldn\u2019t work! Now create a non-\nowner proxy...\n...and call a getter...\n...followed by a \nsetter. This shouldn\u2019t work! Then try to set \nthe rating. This should work!", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 517", "position": 517, "chunk_type": "semantic", "token_estimate": 239}
{"text": "480\u2003 \u2003 Chapter 11: test drive the protection proxy\nFile  Edit   Window  Help  Born2BDynamic\n% java MatchMakingTestDrive \nName is Joe Javabean\nInterests set from owner proxy\nCan't set rating from owner proxy\nRating is 7\nName is Joe Javabean\nCan't set interests from non owner proxy\nRating set from non owner proxy\nRating is 5\n%\nRunning the code...\nOur Owner proxy allows \ngetting and setting, \nexcept for the Geek \nrating. Our NonOwner proxy allows \ngetting only, but also \nallows calls to set the Geek \nrating. The new rating is the average of the previous rating, 7, \nand the value set by the NonOwner proxy, 3. Q: So what exactly is the \u201cdynamic\u201d \naspect of dynamic proxies? Is it that I\u2019m \ninstantiating the proxy and setting it to a \nhandler at runtime? A: No, the proxy is dynamic because \nits class is created at runtime. Think about \nit: before your code runs there is no proxy \nclass; it is created on demand from the set of \ninterfaces you pass it. Q: My InvocationHandler seems like a \nvery strange proxy; it doesn\u2019t implement \nany of the methods of the class it\u2019s \nproxying. A: That\u2019s because the InvocationHandler \nisn\u2019t a proxy\u2014it\u2019s a class that the proxy \ndispatches to for handling method calls. The \nproxy itself is created dynamically at runtime  \nby the static Proxy.newProxyInstance() \nmethod. Q: Is there any way to tell if a class is \na Proxy class? A: Yes. The Proxy class has a static \nmethod called isProxyClass(). Calling this \nmethod with a class will return true if the \nclass is a dynamic proxy class. Other than \nthat, the proxy class will act like any other \nclass that implements a particular set of \ninterfaces. Q: Are there any restrictions on \nthe types of interfaces I can pass into \nnewProxyInstance()? A: Yes, there are a few. First, it \nis worth pointing out that we always \npass newProxyInstance() an array of \ninterfaces\u2014only interfaces are allowed, no \nclasses. The major restrictions are that \nall non-public interfaces need to be from \nthe same package. You also can\u2019t have \ninterfaces with clashing method names \n(that is, two interfaces with a method with \nthe same signature). There are a few other \nminor nuances as well, so at some point \nyou should take a look at the fine print on \ndynamic proxies in the javadoc.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 518", "position": 518, "chunk_type": "semantic", "token_estimate": 387}
{"text": "you are here 4\u2003 \u2003 481: the proxy pattern\nMatch each pattern with its description:\nPattern\nDescription\nDecorator\nFacade\nProxy\nAdapter\nWraps another object \nand provides a different \ninterface to it. Wraps another object \nand provides additional \nbehavior for it. Wraps another object \nto control access to it. Wraps a bunch of \nobjects to simplify \ntheir interface.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 519", "position": 519, "chunk_type": "semantic", "token_estimate": 56}
{"text": "482\u2003 \u2003 Chapter 11: the proxy zoo\nThe Proxy Zoo\nWelcome to the Objectville Zoo! You now know about the remote, virtual, and protection proxies, but \nout in the wild you\u2019re going to see lots of mutations of this pattern. Over here in the Proxy corner of the zoo we\u2019ve got a nice collection \nof wild proxy patterns that we\u2019ve captured for your study. Our job isn\u2019t done; we\u2019re sure you\u2019re going to see more variations of \nthis pattern in the real world, so give us a hand in cataloging more \nproxies. Let\u2019s take a look at the existing collection:\nCaching Proxy provides \ntemporary storage for \nresults of operations \nthat are expensive. It \ncan also allow multiple clients to share \nthe results to reduce computation or \nnetwork latency. Firewall Proxy \ncontrols access to a \nset of network \nresources, protecting \nthe subject from \u201cbad\u201d clients. Smart Reference Proxy \nprovides additional actions \nwhenever a subject is \nreferenced, such as counting \nthe number of references to \nan object. Habitat: often seen in the location \nof corporate firewall systems. Habitat: often seen in web server proxies as well \nas content management and publishing systems. Help find a habitat", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 520", "position": 520, "chunk_type": "semantic", "token_estimate": 193}
{"text": "you are here 4\u2003 \u2003 483: the proxy pattern\nSynchronization Proxy \nprovides safe access to a \nsubject from multiple threads. Complexity Hiding Proxy \nhides the complexity of \nand controls access to a \ncomplex set of classes. This is sometimes called \nthe Facade Proxy for obvious reasons. The Complexity Hiding Proxy differs from \nthe Facade Pattern in that the proxy \ncontrols access, while the Facade Pattern \njust provides an alternative interface. Copy-On-Write Proxy \ncontrols the copying of \nan object by deferring \nthe copying of an \nobject until it is required by \na client. This is a variant of \nthe Virtual Proxy. Seen hanging around Collections, where it controls \nsynchronized access to an underlying set of objects \nin a multithreaded environment. Field Notes: please add your observations of other proxies in the wild here:\nHabitat: seen in the vicinity of the \nJava\u2019s CopyOnWriteArrayList. Help find a habitat", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 521", "position": 521, "chunk_type": "semantic", "token_estimate": 144}
{"text": "5. Group of first album cover displayed (two words).: 7. Commonly used proxy for web services (two words). 8. In RMI, the object that takes the network requests on \nthe service side. 11. Proxy that protects method calls from unauthorized \ncallers. 13. Group that did the album MCMXC a.D.\n14. A ________ proxy class is created at runtime. 15. Place to learn about the many proxy variants. 16. The Album viewer used this kind of proxy. 17. In RMI, the proxy is called this. 18. We took one of these to learn RMI. 19. Why Elroy couldn\u2019t get dates.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 522", "position": 522, "chunk_type": "semantic", "token_estimate": 99}
{"text": "1. Objectville Matchmaking is for ________.: 2. Java\u2019s dynamic proxy forwards all requests to this (two \nwords). 3. This utility acts as a lookup service for RMI. 4. Proxy that stands in for expensive objects. 6. Remote ______ was used to implement the gumball \nmachine monitor (two words). 9. Software developer agent was being this kind of proxy. 10. Our first mistake: the gumball machine reporting was \nnot _____. 12. Similar to proxy, but with a different purpose. 1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nAcross\n5. Group of first Album cover displayed (two \nwords)\n7. Commonly used proxy for web services (two \nwords)\n8. In RMI, the object that takes the network \nrequests on the service side\n11. Proxy that protects method calls from \nunauthorized callers\n13. Group that did the album MCMXC A.D.\n14. A _______ proxy class is created at runtime\n15. Place to learn about the many proxy variants\n16. The Album viewer used this kind of proxy\n17. In RMI, the proxy is called this\n18. We took one of these to learn RMI\n19. Why Elroy couldn't get dates\nDown\n1. Objectville Matchmaking is for _____\n2. Java's dynamic proxy forwards all requests \nto this (two words)\n3. This utility acts as a lookup service for RMI\n4. Proxy that stands in for expensive objects\n6. Remote ________  was used to implement \nthe gumball machine monitor (two words)\n9. Software developer agent was being this kind \nof proxy\n10. Our first mistake: the gumball machine \nreporting was not _______\n12. Similar to proxy, but with a different \npurpose", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 522", "position": 522, "chunk_type": "semantic", "token_estimate": 276}
{"text": "you are here 4\u2003 \u2003 485: the proxy pattern\nTools for your Design Toolbox\nYour design toolbox is almost full; you\u2019re prepared for \nalmost any design problem that comes your way. Abstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it. OO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically. Decorators provide a flexible \nalternative to subclassing for extending \nfunctionality. Abstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes. Factory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate. Factory Method lets \na class defer instantiation to the \nsubclasses. Singleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it. Command - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Adapter - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. No new principles this \nchapter; can you close the \nbook and remember them all? Facade - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Our new pattern. A Proxy acts as a \nrepresentative for \nanother object. State - Allow an object to alter its \nbehavior when its internal state changes. The object will appear to change its \nclass. Encapsulate what varies. Favor composition over inheritance. Program to interfaces, not \nimplementations. Strive for loosely coupled designs \nbetween objects that interact. Classes should be open for extension \nbut closed for modification. Depend on abstractions. Do not \ndepend on concrete classes. Only talk to your friends. Don\u2019t call us, we\u2019ll call you. A class should have only one reason \nto change. OO Principles\nProxy - Provide a surrogate or \nplaceholder for another object to \ncontrol access to it. \u0083\nThe Proxy Pattern provides \na representative for another \nobject in order to control the \nclient\u2019s access to it. There \nare a number of ways it can \nmanage that access.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 523", "position": 523, "chunk_type": "semantic", "token_estimate": 397}
{"text": "you are here 4\u2003 \u2003 485: \u0083\nThe Proxy Pattern provides \na representative for another \nobject in order to control the \nclient\u2019s access to it. There \nare a number of ways it can \nmanage that access. \u0083\nA Remote Proxy manages \ninteraction between a client \nand a remote object. \u0083\nA Virtual Proxy controls \naccess to an object that is \nexpensive to instantiate. \u0083\nA Protection Proxy controls \naccess to the methods of an \nobject based on the caller. \u0083\nMany other variants of \nthe Proxy Pattern exist \nincluding caching proxies, \nsynchronization proxies, \nfirewall proxies, copy-on-write \nproxies, and so on. \u0083\nProxy is structurally similar \nto Decorator, but the two \npatterns differ in their purpose. \u0083\nThe Decorator Pattern adds \nbehavior to an object, while \nProxy controls access. \u0083\nJava\u2019s built-in support for \nProxy can build a dynamic \nproxy class on demand and \ndispatch all calls on it to a \nhandler of your choosing. \u0083\nLike any wrapper, proxies \nwill increase the number of \nclasses and objects in your \ndesigns.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 523", "position": 523, "chunk_type": "semantic", "token_estimate": 169}
{"text": "486\u2003 \u2003 Chapter 11: exercise solutions\nimport java.lang.reflect. *;\n \npublic class NonOwnerInvocationHandler implements InvocationHandler { \n    Person person;\n \n    public NonOwnerInvocationHandler(Person person) {\n        this.person = person;\n    }\n \n    public Object invoke(Object proxy, Method method, Object[] args) \n            throws IllegalAccessException {\n  \n        try {\n            if (method.getName().startsWith(\"get\")) {\n                return method.invoke(person, args);\n            } else if (method.getName().equals(\"setGeekRating\")) {\n                return method.invoke(person, args);\n            } else if (method.getName().startsWith(\"set\")) {\n                throw new IllegalAccessException();\n            } \n        } catch (InvocationTargetException e) {\n            e.printStackTrace();\n        } \n        return null;\n    }\n}\nThe NonOwnerInvocationHandler works just like the OwnerInvocationHandler except \nthat it allows calls to setGeekRating() and it disallows calls to any other set method. Here\u2019s our solution:\nThe ImageProxy class appears to have two states that are controlled \nby conditional statements. Can you think of another pattern that might \nclean up this code? How would you redesign ImageProxy? Design Puzzle Solution\nUse the State Pattern: implement two states, ImageLoaded and ImageNotLoaded. Then put \nthe code from the if statements into their respective states. Start in the ImageNotLoaded state \nand then transition to the ImageLoaded state once the ImageIcon had been retrieved.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 524", "position": 524, "chunk_type": "semantic", "token_estimate": 171}
{"text": "you are here 4\u2003 \u2003 487: the proxy pattern", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 525", "position": 525, "chunk_type": "semantic", "token_estimate": 8}
{"text": "Across: 5. Group of first Album cover displayed (two \nwords) [APHEXTWIN] \n7. Commonly used proxy for web services (two \nDown\n1. Objectville Matchmaking is for _____ \n[GEEKS] \n2. Java's dynamic proxy forwards all requests \nPerson getNonOwnerProxy(Person person) {\n    \n    return (Person) Proxy.newProxyInstance(\n            person.getClass().getClassLoader(),\n            person.getClass().getInterfaces(),\n            new NonOwnerInvocationHandler(person));\n}\nWhile it is a little complicated, there isn\u2019t much to creating a dynamic \nproxy. Why don\u2019t you write getNonOwnerProxy(), which returns a \nproxy for the NonOwnerInvocationHandler? Here\u2019s our solution:\nDesign Patterns Crossword Solution", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 525", "position": 525, "chunk_type": "semantic", "token_estimate": 79}
{"text": "488\u2003 \u2003 Chapter 11: exercise solutions\nMatch each pattern with its description:\nPattern\nDescription\nDecorator\nFacade\nProxy\nAdapter\nWraps another object \nand provides a different \ninterface to it. Wraps another object \nand provides additional \nbehavior for it. Wraps another object \nto control access to it. Wraps a bunch of \nobjects to simplify \ntheir interface. SOlUTion", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 526", "position": 526, "chunk_type": "semantic", "token_estimate": 54}
{"text": "you are here 4\u2003 \u2003 489: the proxy pattern\nThe code for the Album Cover Viewer\nReady Bake\nCode\npackage headfirst.designpatterns.proxy.virtualproxy;\nimport java.net. *;\nimport java.awt. *;\nimport java.awt.event. *;\nimport javax.swing. *;\nimport java.util. *;\npublic class ImageProxyTestDrive {\n    ImageComponent imageComponent;\n    JFrame frame = new JFrame(\"Album Cover Viewer\");\n    JMenuBar menuBar;\n    JMenu menu;\n    Hashtable<String, String> albums = new Hashtable<String, String>();\n \n    public static void main (String[] args) throws Exception {\n        ImageProxyTestDrive testDrive = new ImageProxyTestDrive();\n    }\n \n    public ImageProxyTestDrive() throws Exception{\n        albums.put(\"Buddha Bar\",\"http://images.amazon.com/images/P/B00009XBYK.01.LZZZZZZZ. jpg\");\n        albums.put(\"Ima\",\"http://images.amazon.com/images/P/B000005IRM.01.LZZZZZZZ.jpg\");\n        albums.put(\"Karma\",\"http://images.amazon.com/images/P/B000005DCB.01.LZZZZZZZ. gif\");\n        albums.put(\"MCMXC a.D.\",\"http://images.amazon.com/images/P/B000002URV.01.LZZZZZZZ. jpg\");\n        albums.put(\"Northern Exposure\",\"http://images.amazon.com/images/P/B000003SFN.01. LZZZZZZZ.jpg\");\n        albums.put(\"Selected Ambient Works, Vol. 2\",\"http://images.amazon.com/images/P/\nB000002MNZ.01.LZZZZZZZ.jpg\");\n        URL initialURL = new URL((String)albums.get(\"Selected Ambient Works, Vol. 2\"));\n        menuBar = new JMenuBar();\n        menu = new JMenu(\"Favorite Albums\");\n        menuBar.add(menu);", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 527", "position": 527, "chunk_type": "semantic", "token_estimate": 115}
{"text": "you are here 4\u2003 \u2003 491: the proxy pattern\nThe code for the Album Cover \nViewer, continued...\nReady Bake\nCode\npackage headfirst.designpatterns.proxy.virtualproxy;\nimport java.net. *;\nimport java.awt. *;\nimport javax.swing. *;\nclass ImageProxy implements Icon {\n    volatile ImageIcon imageIcon;\n    final URL imageURL;\n    Thread retrievalThread;\n    boolean retrieving = false;\n     \n    public ImageProxy(URL url) { imageURL = url; }\n     \n    public int getIconWidth() {\n        if (imageIcon != null) {\n            return imageIcon.getIconWidth();\n        } else {\n            return 800;\n        }\n    }\n \n    public int getIconHeight() {\n        if (imageIcon != null) {\n            return imageIcon.getIconHeight();\n        } else {\n            return 600;\n        }\n    }\n\t\n    synchronized void setImageIcon(ImageIcon imageIcon) {\n        this.imageIcon = imageIcon;\n    }\n     \n    public void paintIcon(final Component c, Graphics  g, int x,  int y) {\n        if (imageIcon != null) {\n            imageIcon.paintIcon(c, g, x, y);\n        } else {\n            g.drawString(\"Loading album cover, please wait...\", x+300, y+190);\n            if (!retrieving) {\n                retrieving = true;", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 529", "position": 529, "chunk_type": "semantic", "token_estimate": 137}
{"text": "492\u2003 \u2003 Chapter 11: ready-bake code: album cover viewer\nThe code for the Album Cover Viewer, \ncontinued...\nReady Bake\nCode\n                retrievalThread = new Thread(new Runnable() {\n                    public void run() {\n                        try {\n                            setImageIcon(new ImageIcon(imageURL, \"Album Cover\"));\n                            c.repaint();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                        }\n                    }\n                });\n                retrievalThread.start();\n            }\n        }\n    }\n}\npackage headfirst.designpatterns.proxy.virtualproxy;\nimport java.awt. *;\nimport javax.swing. *;\nclass ImageComponent extends JComponent {\n    private Icon icon;\n    public ImageComponent(Icon icon) {\n        this.icon = icon;\n    }\n    public void setIcon(Icon icon) {\n        this.icon = icon;\n    }\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        int w = icon.getIconWidth();\n        int h = icon.getIconHeight();\n        int x = (800 - w)/2;\n        int y = (600 - h)/2;\n        icon.paintIcon(this, g, x, y);\n    }\n}", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 530", "position": 530, "chunk_type": "semantic", "token_estimate": 115}
{"text": "494\u2003 \u2003 Chapter 12: patterns can work together\nWorking together\nOne of the best ways to use patterns is to get them out of the house so \nthey can interact with other patterns. The more you use patterns the \nmore you\u2019re going to see them showing up together in your designs. We \nhave a special name for a set of patterns that work together in a design \nthat can be applied over many problems: a compound pattern. That\u2019s right, \nwe are now talking about patterns made of patterns! You\u2019ll find a lot of compound patterns in use in the real world. Now \nthat you\u2019ve got patterns in your brain, you\u2019ll see that they are really just \npatterns working together, and that makes them easier to understand. We\u2019re going to start this chapter by revisiting our friendly ducks in the \nSimUDuck duck simulator. It\u2019s only fitting that the ducks should be here \nwhen we combine patterns; after all, they\u2019ve been with us throughout \nthe entire book and they\u2019ve been good sports about taking part in lots \nof patterns. The ducks are going to help you understand how patterns \ncan work together in the same solution. But just because we\u2019ve combined \nsome patterns doesn\u2019t mean we have a solution that qualifies as a \ncompound pattern. For that, it has to be a general-purpose solution that \ncan be applied to many problems. So, in the second half of the chapter \nwe\u2019ll visit a real compound pattern: the Model-View-Controller, otherwise \nknown as MVC. If you haven\u2019t heard of MVC, you will, and you\u2019ll find \nMVC is one of the most powerful compound patterns in your design \ntoolbox. Patterns are often used together and \ncombined within the same design solution. A compound pattern combines two or \nmore patterns into a solution that solves a \nrecurring or general problem.", "domains": ["Architectural Patterns and Styles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 532", "position": 532, "chunk_type": "semantic", "token_estimate": 302}
{"text": "you are here 4\u2003 \u2003 495: compound patterns\npublic interface Quackable {\n    public void quack();\n}\npublic class MallardDuck implements Quackable {\n    public void quack() {\n        System.out.println(\"Quack\");\n    }\n}\npublic class RedheadDuck implements Quackable {\n    public void quack() {\n        System.out.println(\"Quack\");\n    }\n}\nQuackables only need to do \none thing well: Quack! Your standard \nMallard duck. We\u2019ve got to have some variation \nof species if we want this to be \nan interesting simulator. Duck reunion\nAs you\u2019ve already heard, we\u2019re going to get to work with the ducks again. This \ntime the ducks are going to show you how patterns can coexist and even \ncooperate within the same solution. We\u2019re going to rebuild our duck simulator from scratch and give it some \ninteresting capabilities by using a bunch of patterns. Okay, let\u2019s get started...\nLike we said, we\u2019re starting from scratch. This time around, the Ducks are \ngoing to implement a Quackable interface. That way we\u2019ll know what things \nin the simulator can quack()\u2014like Mallard Ducks, Redhead Ducks, Duck \nCalls, and we might even see the Rubber Duck sneak back in. 1\nFirst, we\u2019ll create a Quackable interface. What good is an interface without some classes to implement it? Time to \ncreate some concrete ducks (but not the \u201clawn art\u201d kind, if you know what \nwe mean). 2\nNow, some Ducks that implement Quackable", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 533", "position": 533, "chunk_type": "semantic", "token_estimate": 222}
{"text": "you are here 4\u2003 \u2003 497: compound patterns\npublic class Goose {\n    public void honk() {\n        System.out.println(\"Honk\");\n    }\n}\n% java DuckSimulator\nDuck Simulator\nQuack\nQuack\nKwak\nSqueak\nFile  Edit   Window  Help  ItBetterGetBetterThanThis\nNot too exciting yet, but we \nhaven\u2019t added patterns! A Goose is a honker, \nnot a quacker. Where there is one waterfowl, there are probably two. Here\u2019s a Goose \nclass that has been hanging around the simulator. 4\nWhen ducks are around, geese can\u2019t be far. It looks like everything is working; so far, so good. They all implement the same Quackable \ninterface, but their implementations allow \nthem to quack in their own way. Let\u2019s say we wanted to be able to use a Goose anywhere we\u2019d want to use a \nDuck. After all, geese make noise; geese fly; geese swim. Why can\u2019t we have \nGeese in the simulator? What pattern would allow Geese to easily intermingle with Ducks?", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 535", "position": 535, "chunk_type": "semantic", "token_estimate": 151}
{"text": "498\u2003 \u2003 Chapter 12: goose adapter\npublic class GooseAdapter implements Quackable {\n    Goose goose;\n \n    public GooseAdapter(Goose goose) {\n        this.goose = goose;\n    }\n \n    public void quack() {\n        goose.honk();\n    }\n}\npublic class DuckSimulator {\n    public static void main(String[] args) {\n        DuckSimulator simulator = new DuckSimulator();\n        simulator.simulate();\n    }\n    void simulate() {\n        Quackable mallardDuck = new MallardDuck();\n        Quackable redheadDuck = new RedheadDuck();\n        Quackable duckCall = new DuckCall();\n        Quackable rubberDuck = new RubberDuck();\n        Quackable gooseDuck = new GooseAdapter(new Goose());\n \n        System.out.println(\"\\nDuck Simulator: With Goose Adapter\");\n \n        simulate(mallardDuck);\n        simulate(redheadDuck);\n        simulate(duckCall);\n        simulate(rubberDuck);\n        simulate(gooseDuck);\n    }\n \n    void simulate(Quackable duck) {\n        duck.quack();\n    }\n}\nThe constructor takes the \ngoose we are going to adapt. Remember, an Adapter \nimplements the target interface, \nwhich in this case is Quackable. When quack is called, the call is delegated \nto the goose\u2019s honk() method. We make a Goose that acts \nlike a Duck by wrapping the \nGoose in the GooseAdapter. Once the Goose is wrapped, we can treat \nit just like other duck Quackable objects. Our simulator expects to see Quackable interfaces. Since geese \naren\u2019t quackers (they\u2019re honkers), we can use an adapter to adapt \na goose to a duck. 5\nWe need a goose adapter. All we need to do is create a Goose and wrap it in an adapter \nthat implements Quackable, and we should be good to go. 6\nNow geese should be able to play in the simulator, too.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 536", "position": 536, "chunk_type": "semantic", "token_estimate": 227}
{"text": "you are here 4\u2003 \u2003 499: compound patterns\n% java DuckSimulator\nDuck Simulator: With Goose Adapter\nQuack\nQuack\nKwak\nSqueak\nHonk\nFile  Edit   Window  Help  GoldenEggs\nThere\u2019s the goose! Now the \nGoose can quack with the \nrest of the Ducks. 7\nNow let\u2019s give this a quick run...\nQuackology\nThis time when we run the simulator, the list of objects passed \nto the simulate() method includes a Goose wrapped in a duck \nadapter. The result? We should see some honking! J. Brewer, \nPark Ranger and \nQuackologist\nQuackologists are fascinated by all aspects of Quackable behavior. One \nthing Quackologists have always wanted to study is the total number of \nquacks made by a flock of ducks. How can we add the ability to count duck quacks without having to \nchange the duck classes? Can you think of a pattern that would help?", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 537", "position": 537, "chunk_type": "semantic", "token_estimate": 140}
{"text": "500\u2003 \u2003 Chapter 12: duck decorator\npublic class QuackCounter implements Quackable {\n    Quackable duck;\n    static int numberOfQuacks;\n  \n    public QuackCounter (Quackable duck) {\n        this.duck = duck;\n    }\n  \n    public void quack() {\n        duck.quack();\n        numberOfQuacks++;\n    }\n \n    public static int getQuacks() {\n        return numberOfQuacks;\n    }\n}\n8\nWe\u2019re going to make those Quackologists happy and give \nthem some quack counts. How? Let\u2019s create a decorator that gives the ducks some new \nbehavior (the behavior of counting) by wrapping them with a \ndecorator object. We won\u2019t have to change the Duck code at all. As with Adapter, we need to \nimplement the target interface. We\u2019ve got an instance variable \nto hold on to the quacker \nwe\u2019re decorating. And we\u2019re counting ALL \nquacks, so we\u2019ll use a static \nvariable to keep track. We get the reference to the \nQuackable we\u2019re decorating \nin the constructor. When quack() is called, we delegate the call \nto the Quackable we\u2019re decorating...\n...then we increase the number of quacks. We\u2019re adding one other method to the \ndecorator. This static method just \nreturns the number of quacks that \nhave occurred in all Quackables. QuackCounter is a decorator.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 538", "position": 538, "chunk_type": "semantic", "token_estimate": 184}
{"text": "you are here 4\u2003 \u2003 501: compound patterns\npublic class DuckSimulator {\n    public static void main(String[] args) {\n        DuckSimulator simulator = new DuckSimulator();\n        simulator.simulate();\n    }\n    void simulate() {\n        Quackable mallardDuck = new QuackCounter(new MallardDuck());\n        Quackable redheadDuck = new QuackCounter(new RedheadDuck());\n        Quackable duckCall = new QuackCounter(new DuckCall());\n        Quackable rubberDuck = new QuackCounter(new RubberDuck());\n        Quackable gooseDuck = new GooseAdapter(new Goose());\n        System.out.println(\"\\nDuck Simulator: With Decorator\");\n        simulate(mallardDuck);\n        simulate(redheadDuck);\n        simulate(duckCall);\n        simulate(rubberDuck);\n        simulate(gooseDuck);\n        System.out.println(\"The ducks quacked \" + \n                           QuackCounter.getQuacks() + \" times\");\n    }\n    void simulate(Quackable duck) {\n        duck.quack();\n    }\n}\n9\nWe need to update the simulator to create decorated ducks. Now, we must wrap each Quackable object we instantiate in a \nQuackCounter decorator. If we don\u2019t, we\u2019ll have ducks running \naround making uncounted quacks. Here\u2019s where we \ngather the quacking \nbehavior for the \nQuackologists. Each time we create a \nQuackable, we wrap it with \na new decorator. Here\u2019s the \noutput! % java DuckSimulator\nDuck Simulator: With Decorator\nQuack\nQuack\nKwak\nSqueak\nHonk\nThe ducks quacked 4 times\n%\nFile  Edit   Window  Help  DecoratedEggs\nNothing changes here; the decorated \nobjects are still Quackables. The park ranger told us he \ndidn\u2019t want to count geese \nhonks, so we don\u2019t decorate it. Remember, \nwe\u2019re not \ncounting geese.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 539", "position": 539, "chunk_type": "semantic", "token_estimate": 198}
{"text": "502\u2003 \u2003 Chapter 12: duck factory\npublic abstract class AbstractDuckFactory {\n \n    public abstract Quackable createMallardDuck();\n    public abstract Quackable createRedheadDuck();\n    public abstract Quackable createDuckCall();\n    public abstract Quackable createRubberDuck();\n}\n10\nWe need a factory to produce ducks! Okay, we need some quality control to make sure our ducks get wrapped. We\u2019re going to build an entire factory just to produce them. The factory \nshould produce a family of products that consists of different types of \nducks, so we\u2019re going to use the Abstract Factory Pattern. Let\u2019s start with the definition of the AbstractDuckFactory class:\nHe\u2019s right, that\u2019s the problem with wrapping objects: \nyou have to make sure they get wrapped or they don\u2019t \nget the decorated behavior. Why don\u2019t we take the creation of ducks and localize \nit in one place; in other words, let\u2019s take the duck \ncreation and decorating and encapsulate it. What pattern does that sound like? We\u2019re defining an abstract factory \nthat subclasses will implement to \ncreate different families. Each method creates one kind of duck. You have to decorate objects to \nget decorated behavior. This quack counting is great. We\u2019re learning \nthings we never knew about the little quackers. But we\u2019re finding that too many quacks aren\u2019t \nbeing counted. Can you help?", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 540", "position": 540, "chunk_type": "semantic", "token_estimate": 205}
{"text": "you are here 4\u2003 \u2003 503: compound patterns\npublic class CountingDuckFactory extends AbstractDuckFactory {\n  \n    public Quackable createMallardDuck() {\n        return new QuackCounter(new MallardDuck());\n    }\n  \n    public Quackable createRedheadDuck() {\n        return new QuackCounter(new RedheadDuck());\n    }\n  \n    public Quackable createDuckCall() {\n        return new QuackCounter(new DuckCall());\n    }\n   \n    public Quackable createRubberDuck() {\n        return new QuackCounter(new RubberDuck());\n    }\n}\npublic class DuckFactory extends AbstractDuckFactory {\n  \n    public Quackable createMallardDuck() {\n        return new MallardDuck();\n    }\n  \n    public Quackable createRedheadDuck() {\n        return new RedheadDuck();\n    }\n  \n    public Quackable createDuckCall() {\n        return new DuckCall();\n    }\n   \n    public Quackable createRubberDuck() {\n        return new RubberDuck();\n    }\n}\nNext we\u2019ll create a factory that creates ducks without decorators, just to \nget the hang of the factory:\nNow let\u2019s create the factory we really want, the CountingDuckFactory:\nDuckFactory extends \nthe abstract factory. Each method creates a product: \na particular kind of Quackable. The actual product is unknown to \nthe simulator\u2009\u2014\u2009it just knows it\u2019s \ngetting a Quackable. CountingDuckFactory \nalso extends the \nabstract factory. Each method wraps the \nQuackable with the quack \ncounting decorator. The \nsimulator will never know \nthe difference; it just \ngets back a Quackable. But now our rangers can \nbe sure that all quacks \nare being counted.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 541", "position": 541, "chunk_type": "semantic", "token_estimate": 190}
{"text": "504\u2003 \u2003 Chapter 12: families of ducks\npublic class DuckSimulator {\n    public static void main(String[] args) {\n        DuckSimulator simulator = new DuckSimulator();\n        AbstractDuckFactory duckFactory = new CountingDuckFactory();\n \n        simulator.simulate(duckFactory);\n    }\n \n    void simulate(AbstractDuckFactory duckFactory) {\n        Quackable mallardDuck = duckFactory.createMallardDuck();\n        Quackable redheadDuck = duckFactory.createRedheadDuck();\n        Quackable duckCall = duckFactory.createDuckCall();\n        Quackable rubberDuck = duckFactory.createRubberDuck();\n        Quackable gooseDuck = new GooseAdapter(new Goose());\n \n        System.out.println(\"\\nDuck Simulator: With Abstract Factory\");\n \n        simulate(mallardDuck);\n        simulate(redheadDuck);\n        simulate(duckCall);\n        simulate(rubberDuck);\n        simulate(gooseDuck);\n \n        System.out.println(\"The ducks quacked \" + \n                           QuackCounter.getQuacks() + \n                           \" times\");\n    }\n \n    void simulate(Quackable duck) {\n        duck.quack();\n    }\n}\n11\nLet\u2019s set up the simulator to use the factory. Remember how Abstract Factory works? We create a polymorphic method \nthat takes a factory and uses it to create objects. By passing in different \nfactories, we get to use different product families in the method. We\u2019re going to alter the simulate() method so that it takes a factory and \nuses it to create ducks. First we create \nthe factory \nthat we\u2019re going \nto pass into \nthe simulate() \nmethod. The simulate() \nmethod takes an \nAbstractDuckFactory \nand uses it to create \nducks rather than \ninstantiating them \ndirectly. Nothing changes \nhere! Same ol\u2019 code.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 542", "position": 542, "chunk_type": "semantic", "token_estimate": 182}
{"text": "you are here 4\u2003 \u2003 505: compound patterns\nSame as last time, \nbut this time \nwe\u2019re ensuring that \nthe ducks are all \ndecorated because \nwe are using the \nCountingDuckFactory. % java DuckSimulator\nDuck Simulator: With Abstract Factory\nQuack\nQuack\nKwak\nSqueak\nHonk\n4 quacks were counted\n%\nFile  Edit   Window  Help  EggFactory\nHere\u2019s the output using the factory...\nWe\u2019re still directly instantiating Geese by relying on concrete \nclasses. Can you write an Abstract Factory for Geese? How should \nit handle creating \u201cgoose ducks\u201d?", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 543", "position": 543, "chunk_type": "semantic", "token_estimate": 82}
{"text": "you are here 4\u2003 \u2003 507: compound patterns\npublic class Flock implements Quackable {\n    List<Quackable> quackers = new ArrayList<Quackable>();\n \n    public void add(Quackable quacker) {\n        quackers.add(quacker);\n    }\n \n    public void quack() {\n        Iterator<Quackable> iterator = quackers.iterator();\n        while (iterator.hasNext()) {\n            Quackable quacker = iterator.next();\n            quacker.quack();\n        }\n    }\n}\n12\nLet\u2019s create a flock of ducks (well, actually a flock of Quackables). Remember the Composite Pattern that allows us to treat a collection of \nobjects in the same way as individual objects? What better composite than \na flock of Quackables! Let\u2019s step through how this is going to work:\nRemember, the composite needs to implement \nthe same interface as the leaf elements. Our \nleaf elements are Quackables. We\u2019re using an ArrayList inside each Flock to \nhold the Quackables that belong to the Flock. The add() method adds a \nQuackable to the Flock. Now for the quack() method\u2009\u2014\u2009after all, the Flock is a Quackable too. The quack() method in Flock needs to work over the entire Flock. Here \nwe iterate through the ArrayList and call quack() on each element. Did you notice that we tried to sneak a Design Pattern \nby you without mentioning it? public void quack() {\n        Iterator<Quackable> iterator = quackers.iterator();\n        while (iterator.hasNext()) {\n            Quackable quacker = iterator.next();\n            quacker.quack();\n        }\n    }\nThere it is! The Iterator \nPattern at work! Code Up Close", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 545", "position": 545, "chunk_type": "semantic", "token_estimate": 220}
{"text": "508\u2003 \u2003 Chapter 12: duck composite\npublic class DuckSimulator {\n    // main method here\n \n    void simulate(AbstractDuckFactory duckFactory) {\n        Quackable redheadDuck = duckFactory.createRedheadDuck();\n        Quackable duckCall = duckFactory.createDuckCall();\n        Quackable rubberDuck = duckFactory.createRubberDuck();\n        Quackable gooseDuck = new GooseAdapter(new Goose());\n        System.out.println(\"\\nDuck Simulator: With Composite - Flocks\");\n        Flock flockOfDucks = new Flock();\n        flockOfDucks.add(redheadDuck);\n        flockOfDucks.add(duckCall);\n        flockOfDucks.add(rubberDuck);\n        flockOfDucks.add(gooseDuck);\n        Flock flockOfMallards = new Flock();\n        Quackable mallardOne = duckFactory.createMallardDuck();\n        Quackable mallardTwo = duckFactory.createMallardDuck();\n        Quackable mallardThree = duckFactory.createMallardDuck();\n        Quackable mallardFour = duckFactory.createMallardDuck();\n        flockOfMallards.add(mallardOne);\n        flockOfMallards.add(mallardTwo);\n        flockOfMallards.add(mallardThree);\n        flockOfMallards.add(mallardFour);\n        flockOfDucks.add(flockOfMallards);\n        System.out.println(\"\\nDuck Simulator: Whole Flock Simulation\");\n        simulate(flockOfDucks);\n        System.out.println(\"\\nDuck Simulator: Mallard Flock Simulation\");\n        simulate(flockOfMallards);\n        System.out.println(\"\\nThe ducks quacked \" + \n                           QuackCounter.getQuacks() + \n                           \" times\");\n    }\n    void simulate(Quackable duck) {\n        duck.quack();\n    }\n}\n13\nNow we need to alter the simulator. Our composite is ready; we just need some code to round up the \nducks into the composite structure. Create all the \nQuackables, \njust like before. First we create a Flock and \nload it up with Quackables. Here we\u2019re \ncreating a \nlittle family of \nmallards...\nThen we create a new \nFlock of mallards. ...and adding them to the \nFlock of mallards. Then we add the Flock of \nmallards to the main flock. Let\u2019s test out the entire Flock! Then let\u2019s just test out the mallard Flock. Finally, let\u2019s give the \nQuackologist the data. Nothing needs to change here; a Flock is a Quackable!", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 546", "position": 546, "chunk_type": "semantic", "token_estimate": 215}
{"text": "you are here 4\u2003 \u2003 509: compound patterns\nLet\u2019s give it a spin...\n% java DuckSimulator\nDuck Simulator: With Composite - Flocks\nDuck Simulator: Whole Flock Simulation\nQuack\nKwak\nSqueak\nHonk\nQuack\nQuack\nQuack\nQuack\nDuck Simulator: Mallard Flock Simulation\nQuack\nQuack\nQuack\nQuack\nThe ducks quacked 11 times\nFile  Edit   Window  Help  FlockADuck\nHere\u2019s the first flock. And now the mallards. The data looks \ngood (remember the \ngoose doesn\u2019t get \ncounted). Safety versus transparency\nYou might remember that in the Composite Pattern chapter the composites (the Menus) and the \nleaves (the MenuItems) had the same exact set of methods, including the add() method. Because \nthey had the same set of methods, we could call methods on MenuItems that didn\u2019t really make \nsense (like trying to add something to a MenuItem by calling add()). The benefit of this was that the \ndistinction between leaves and composites was transparent: the client didn\u2019t have to know whether \nit was dealing with a leaf or a composite; it just called the same methods on both. Here, we\u2019ve decided to keep the composite\u2019s child maintenance methods separate from the leaf \nnodes: that is, only Flocks have the add() method. We know it doesn\u2019t make sense to try to add \nsomething to a Duck, and in this implementation, you can\u2019t. You can only add() to a Flock. So \nthis design is safer\u2014you can\u2019t call methods that don\u2019t make sense on components\u2014but it\u2019s less \ntransparent. Now the client has to know that a Quackable is a Flock in order to add Quackables to it. As always, there are tradeoffs when you do OO design and you need to consider them as you create \nyour own composites.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 547", "position": 547, "chunk_type": "semantic", "token_estimate": 279}
{"text": "510\u2003 \u2003 Chapter 12: duck observer\npublic interface QuackObservable {\n    public void registerObserver(Observer observer);\n    public void notifyObservers();\n}\npublic interface Quackable extends QuackObservable {\n    public void quack();\n}\n14\nFirst we need an interface for our Subject. Remember that the Subject is the object being observed. Let\u2019s call it \nsomething more memorable\u2014how about Observable? An Observable needs \nmethods for registering and notifying observers. We could also have a \nmethod for removing observers, but we\u2019ll keep the implementation simple \nhere and leave that out. It sounds like the Quackologist would like to observe individual \nduck behavior. That leads us right to a pattern made for observing \nthe behavior of objects: the Observer Pattern. QuackObservable is the interface \nthat Quackables should implement \nif they want to be observed. It also has a method for \nnotifying the observers. It has a method for registering \nObservers. Any object implementing \nthe Observer interface can listen \nto quacks. We\u2019ll define the Observer \ninterface in a sec. Now we need to make sure all Quackables implement this interface... So, we extend the Quackable \ninterface with QuackObserver. Can you say \u201cobserver\u201d? The Composite is working great! Thanks! Now we have the opposite request: we also \nneed to track individual ducks. Can you give \nus a way to keep track of individual duck \nquacking in real time?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 548", "position": 548, "chunk_type": "semantic", "token_estimate": 217}
{"text": "you are here 4\u2003 \u2003 511: compound patterns\npublic class Observable implements QuackObservable {\n    List<Observer> observers = new ArrayList<Observer>();\n    QuackObservable duck;\n \n    public Observable(QuackObservable duck) {\n        this.duck = duck;\n    }\n  \n    public void registerObserver(Observer observer) {\n        observers.add(observer);\n    }\n  \n    public void notifyObservers() {\n        Iterator iterator = observers.iterator();\n        while (iterator.hasNext()) {\n            Observer observer = iterator.next();\n            observer.update(duck);\n        }\n    }\n}\nNow, we need to make sure all the concrete \nclasses that implement Quackable can handle \nbeing a QuackObservable. We could approach this by implementing registration and \nnotification in each and every class (like we did in Chapter \n2). But we\u2019re going to do it a little differently this time: \nwe\u2019re going to encapsulate the registration and notification \ncode in another class, call it Observable, and compose it \nwith QuackObservable. That way, we only write the real \ncode once and QuackObservable just needs enough code to \ndelegate to the helper class Observable. Let\u2019s begin with the Observable helper class. Observable implements all the functionality \na Quackable needs to be an observable. We \njust need to plug it into a class and have \nthat class delegate to Observable. QuackObserverable\nIn the constructor we get \npassed the QuackObservable \nthat is using this object \nto manage its observable \nbehavior. Check out the \nnotifyObservers() method \nbelow; you\u2019ll see that when \na notify occurs, Observable \npasses this object along so \nthat the observer knows \nwhich object is quacking. Here\u2019s the code for \nregistering an observer. And the code for doing \nthe notifications. Now let\u2019s see how a Quackable class uses this helper...\nObservable must implement QuackObservable \nbecause these are the same method calls \nthat are going to be delegated to it. Stop looking at me. You\u2019re making me \nnervous! 15", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 549", "position": 549, "chunk_type": "semantic", "token_estimate": 278}
{"text": "512\u2003 \u2003 Chapter 12: quack decorators are observables too\npublic class MallardDuck implements Quackable {\n    Observable observable;\n \n    public MallardDuck() {\n        observable = new Observable(this);\n    }\n \n    public void quack() {\n        System.out.println(\"Quack\");\n        notifyObservers();\n    }\n \n    public void registerObserver(Observer observer) {\n        observable.registerObserver(observer);\n    }\n \n    public void notifyObservers() {\n        observable.notifyObservers();\n    }\n}\n16\nIntegrate the helper Observable with the Quackable classes. This shouldn\u2019t be too bad. All we need to do is make sure the Quackable classes \nare composed with an Observable and that they know how to delegate to it. After \nthat, they\u2019re ready to be Observables. Here\u2019s the implementation of MallardDuck; \nthe other ducks are the same. Each Quackable has an \nObservable instance variable. In the constructor, we create an \nObservable and pass it a reference \nto the MallardDuck object. When we quack, we need \nto let the observers know \nabout it. Here are our two QuackObservable \nmethods. Notice that we just \ndelegate to the helper. We haven\u2019t changed the implementation of one Quackable, the \nQuackCounter decorator. We need to make it an Observable too. Why don\u2019t you write that one:", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 550", "position": 550, "chunk_type": "semantic", "token_estimate": 176}
{"text": "you are here 4\u2003 \u2003 513: compound patterns\npublic interface Observer {\n    public void update(QuackObservable duck);\n}\npublic class Quackologist implements Observer {\n \n    public void update(QuackObservable duck) {\n        System.out.println(\"Quackologist: \" + duck + \" just quacked. \");\n    }\n}\n17\nWe\u2019re almost there! We just need to work on the Observer side \nof the pattern. We\u2019ve implemented everything we need for the Observables; now we \nneed some Observers. We\u2019ll start with the Observer interface:\nThe Observer interface just has one \nmethod, update(), which is passed the \nQuackObservable that is quacking. Now we need an Observer: where are \nthose Quackologists?! The Quackologist is simple; it just has one \nmethod, update(), which prints out the \nQuackable that just quacked. We need to implement the Observer interface or else \nwe won\u2019t be able to register with a QuackObservable.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 551", "position": 551, "chunk_type": "semantic", "token_estimate": 134}
{"text": "514\u2003 \u2003 Chapter 12: flock composites are observables too\nWhat if a Quackologist wants to observe an entire flock? What does that \nmean anyway? Think about it like this: if we observe a composite, then \nwe\u2019re observing everything in the composite. So, when you register with \na flock, the flock composite makes sure you get registered with all its \nchildren (sorry, all its little quackers), which may include other flocks. Go ahead and write the Flock observer code before we go any further.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 552", "position": 552, "chunk_type": "semantic", "token_estimate": 82}
{"text": "you are here 4\u2003 \u2003 515: compound patterns\npublic class DuckSimulator {\n    public static void main(String[] args) {\n        DuckSimulator simulator = new DuckSimulator();\n        AbstractDuckFactory duckFactory = new CountingDuckFactory();\n \n        simulator.simulate(duckFactory);\n    }\n  \n    void simulate(AbstractDuckFactory duckFactory) {\n  \n        // create duck factories and ducks here\n \n        // create flocks here\n \n        System.out.println(\"\\nDuck Simulator: With Observer\");\n        Quackologist quackologist = new Quackologist();\n        flockOfDucks.registerObserver(quackologist);\n        simulate(flockOfDucks);\n        System.out.println(\"\\nThe ducks quacked \" + \n                           QuackCounter.getQuacks() + \n                           \" times\");\n    }\n \n    void simulate(Quackable duck) {\n        duck.quack();\n    }\n}\n18\nWe\u2019re ready to observe. Let\u2019s update the \nsimulator and give it a try:\nAll we do here is create \na Quackologist and set \nhim as an observer of \nthe flock. Let\u2019s give it a try \nand see how it works! This time we\u2019ll \nwe just simulate \nthe entire flock.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 553", "position": 553, "chunk_type": "semantic", "token_estimate": 122}
{"text": "516\u2003 \u2003 Chapter 12: the duck finale\nThis is the big finale. Five\u2014no, six\u2014patterns have come together to \ncreate this amazing Duck Simulator. Without further ado, we present \nDuckSimulator! File  Edit   Window  Help  DucksAreEverywhere\n% java DuckSimulator\nDuck Simulator: With Observer\nQuack\nQuackologist: Redhead Duck just quacked. Kwak\nQuackologist: Duck Call just quacked. Squeak\nQuackologist: Rubber Duck just quacked. Honk\nQuackologist: Goose pretending to be a Duck just quacked. Quack\nQuackologist: Mallard Duck just quacked. Quack\nQuackologist: Mallard Duck just quacked. Quack\nQuackologist: Mallard Duck just quacked. Quack\nQuackologist: Mallard Duck just quacked. The Ducks quacked 7 times. After each \nquack, no \nmatter what \nkind of quack \nit was, the \nobserver gets a \nnotification. And the \nquackologist still \ngets his counts. Q: So this was a compound pattern? A: No, this was just a set of patterns \nworking together. A compound pattern is a \nset of a few patterns that are combined to \nsolve a general problem. We\u2019re just about \nto take a look at the Model-View-Controller \ncompound pattern; it\u2019s a collection of a few \npatterns that has been used over and over in \nmany design solutions. Q: So the real beauty of Design \nPatterns is that I can take a problem and \nstart applying patterns to it until I have a \nsolution. Right? A: Wrong. We went through this exercise \nwith Ducks to show you how patterns can \nwork together. You\u2019d never actually want to \napproach a design like we just did. In fact, \nthere may be solutions to parts of the Duck \nSimulator for which some of these patterns \nwere big-time overkill. Sometimes just using \ngood OO design principles can solve a \nproblem well enough on its own. We\u2019re going to talk more about this in the \nnext chapter, but you only want to apply \npatterns when and where they make sense. You never want to start out with the intention \nof using patterns just for the sake of it. You \nshould consider the design of the Duck \nSimulator to be forced and artificial. But hey, \nit was fun and gave us a good idea of how \nseveral patterns can fit into a solution.", "domains": ["Architectural Patterns and Styles", "Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 554", "position": 554, "chunk_type": "semantic", "token_estimate": 355}
{"text": "you are here 4\u2003 \u2003 517: compound patterns\nWhat did we do? We started with a bunch of Quackables...\nA goose came along and wanted to act like a Quackable too. So we \nused the Adapter Pattern to adapt the goose to a Quackable. Now, you can call quack() on a \ngoose wrapped in the adapter and it will honk! Then, the Quackologists decided they wanted to count quacks. So we \nused the Decorator Pattern to add a QuackCounter decorator that keeps track of the number \nof times quack() is called, and then delegates the quack to the Quackable it\u2019s wrapping. But the Quackologists were worried they\u2019d forget to add the \nQuackCounter decorator. So we used the Abstract Factory Pattern to create ducks \nfor them. Now, whenever they want a duck, they ask the factory for one, and it hands back \na decorated duck. (And don\u2019t forget, they can also use another duck factory if they want an \nundecorated duck!) We had management problems keeping track of all those ducks and \ngeese and quackables. So we used the Composite Pattern to group Quackables \ninto Flocks. The pattern also allows the Quackologist to create subFlocks to manage duck \nfamilies. We used the Iterator Pattern in our implementation by using java.util\u2019s iterator in \nArrayList. The Quackologists also wanted to be notified when any Quackable \nquacked. So we used the Observer Pattern to let the Quackologists register as Quackable \nObservers. Now they\u2019re notified every time any Quackable quacks. We used iterator again \nin this implementation. The Quackologists can even use the Observer Pattern with their \ncomposites. That was quite a Design Pattern \nworkout. You should study the class \ndiagram on the next page and then \ntake a relaxing break before continuing \non with Model-View-Controller.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 555", "position": 555, "chunk_type": "semantic", "token_estimate": 290}
{"text": "518\u2003 \u2003 Chapter 12: duck's-eye view\nDuckSimulator\ncreateMallardDuck()\ncreateRedheadDuck()\ncreateDuckCall()\ncreateRubberDuck()\nAbstractDuckFactory\ncreateMallardDuck()\ncreateRedheadDuck()\ncreateDuckCall()\ncreateRubberDuck()\nDuckFactory\ncreateMallardDuck()\ncreateRedheadDuck()\ncreateDuckCall()\ncreateRubberDuck()\nCountingDuckFactory\nupdate(QuackObservable)\n<<interface>> \nObserver\nupdate(QuackObservable)\nQuackologist\nA bird\u2019s duck\u2019s-eye view: the class diagram\nDuckSimulator uses a factory to create Ducks. Here are two different \nfactories that produce \nthe same family of \nproducts. The DuckFactory \ncreates ducks, and the \nCountingDuckFactory \ncreates Ducks wrapped in \nQuackCounter decorators. We only implemented one kind of Observer \nfor the Quackables\u2009\u2014\u2009the Quackologist. But any class that implements the Observer \ninterface can observe ducks...how about \nimplementing a BirdWatcher observer? If a class \nimplements \nObserver, that \nmeans it can \nobserve Quackables, \nand will be notified \nwhenever a \nQuackable quacks. We\u2019ve packed a lot of patterns into one small duck simulator! Here\u2019s the big picture of what we did:", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 556", "position": 556, "chunk_type": "semantic", "token_estimate": 132}
{"text": "you are here 4\u2003 \u2003 519: compound patterns\nregisterObserver(Observer)\nnotifyObservers()\n<<interface>> \nQuackObservable\nquack()\n<<interface>> \nQuackable\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nMallardDuck\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nRedheadDuck\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nDuckCall\nregisterObserver(Observer)\nnotifyObservers()\nObservable\nList observers\nQuackObservable duck\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nGooseAdapter\nGoose goose\nadd(Quackable)\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nFlock\nList ducks\ngetQuacks()\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nQuackCounter\nQuackable duck\nquack()\nregisterObserver(Observer)\nnotifyObservers()\nRubberDuck\nThe QuackObservable interface \ngives us a set of methods that \nany Observable must implement. We have two kinds of \nQuackables: ducks and \nother things that want \nQuackable behavior: like \nthe GooseAdapter, which \nwraps a Goose and makes \nit look like a Quackable; \nFlock, which is a \nQuackable Composite, and \nQuackCounter, which adds \nbehavior to Quackables. Quackable is the interface \nthat all classes that have \nquacking behavior implement. Each Quackable has an \ninstance of Observable \nto keep track of their \nobservers and notify them \nwhen the Quackable quacks. This Adapter...\n...and this \nComposite...\n...and this \nDecorator \nall act like \nQuackables!", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 557", "position": 557, "chunk_type": "semantic", "token_estimate": 156}
{"text": "520\u2003 \u2003 Chapter 12: the model view controller song\nModel, View, Controller\nLyrics and music by James Dempsey. MVC\u2019s a paradigm for factoring your code\ninto functional segments, so your brain does not explode. T\no achieve reusability, you gotta keep those boundaries \nclean\nModel on the one side, View on the other, the Controller\u2019s \nin between. Model View, it\u2019s got three layers like Oreos do \nModel View Controller\nModel View, Model View, Model View Controller\nModel objects represent your application\u2019s raison d\u2019\u00eatre\nCustom objects that contain data, logic, and et cetera\nYou create custom classes, in your app\u2019s problem domain\nyou can choose to reuse them with all the views\nbut the model objects stay the same. You can model a throttle and a manifold\nModel the toddle of a two year old\nModel a bottle of fine Chardonnay\nModel all the glottal stops people say\nModel the coddling of boiling eggs\nYou can model the waddle in Hexley\u2019s legs\nModel View, you can model all the models that pose for GQ\nModel View Controller\nView objects tend to be controls used to display and edit\nCocoa\u2019s got a lot of those, well written to its credit. T\nake an NST\nextView, hand it any old Unicode string\nThe user can interact with it, it can hold most anything\nBut the view don\u2019t know about the Model\nThat string could be a phone number or the works of \nAristotle\nKeep the coupling loose \nand so achieve a massive level of reuse\nModel View, all rendered very nicely in aqua blue\nModel View Controller\nYou\u2019re probably wondering now\nYou\u2019re probably wondering how\nData flows between Model and View\nThe Controller has to mediate\nBetween each layer\u2019s changing state\nT\no synchronize the data of the two\nIt pulls and pushes every changed value\nModel View, mad props to the smalltalk crew! Model View Controller\nThe King of Compound Patterns\nIf Elvis were a compound pattern, his name would be Model-View-Controller, \nand he\u2019d be singing a little song like this...\nModel\nView\nCreamy \nController\nSo does Java!", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 558", "position": 558, "chunk_type": "semantic", "token_estimate": 345}
{"text": "you are here 4\u2003 \u2003 521: compound patterns\nModel View, it\u2019s pronounced Oh Oh not Ooo Ooo\nModel View Controller\nThere\u2019s a little left to this story\nA few more miles upon this road\nNobody seems to get much glory \nFrom writing the controller code\nWell, the model\u2019s mission critical \nAnd gorgeous is the view\nI might be lazy, but sometimes it\u2019s just crazy \nHow much code I write is just glue\nAnd it wouldn\u2019t be so tragic\nBut the code ain\u2019t doing magic\nIt\u2019s just moving values through\nAnd I don\u2019t mean to be vicious\nBut it gets repetitious\nDoing all the things controllers do\nAnd I wish I had a dime\nFor every single time \nI sent a T\nextField StringValue. Model View\nHow we gonna deep six all that glue\nModel View Controller\nControllers know the Model and View very intimately \nThey often use hardcoding which can be foreboding for \nreusability\nBut now you can connect each model key that you select \nto any view property\nAnd once you start binding\nI think you\u2019ll be finding less code in your source tree\nYeah, I know I was elated by the stuff they\u2019ve automated\nand the things you get for free\nAnd I think it bears repeating \nall the code you won\u2019t be needing\nwhen you hook it up in IB. Model View even handles multiple selections too\nModel View Controller\nModel View, bet I ship my application before you\nModel View Controller\nEar\npower\nDon\u2019t just read! After all, this is a Head First book...check out this URL:\nhttps://www.youtube.com/watch?v=YYvOGPMLVDo\nSit back and give it a listen. Using Swing.", "domains": ["Software Quality Attributes"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 559", "position": 559, "chunk_type": "semantic", "token_estimate": 270}
{"text": "you are here 4\u2003 \u2003 523: compound patterns\nMeet Model-View-Controller\nView\nController\nyou use the \nyou use the \ninterface and \ninterface and \nyour actions \nyour actions \ngo to the \ngo to the \ncontroller\ncontroller\nclass Player {\n  play(){}\n  rip(){}\n  burn(){}\n}\nModel\nImagine you\u2019re using your favorite music player, like iTunes. You can use its interface to add \nnew songs, manage playlists, and rename tracks. The player takes care of maintaining a little \ndatabase of all your songs along with their associated names and data. It also takes care of \nplaying the songs and, as it does, the user interface is constantly updated with the current song \ntitle, the running time, and so on. Well, underneath it all sits Model-View-Controller...\nthe controller \nmanipulates \nthe model\nthe model  notifies \nthe view of a change \nin state\nthe view \ndisplay is \nupdated for \nyou \n \n\u201cPlay new song\u201d\nController asks \nPlayer model to \nbegin playing \nsong\nModel tells the \nview the state has \nchanged\nYou see the song \ndisplay update and \nhear the new song \nplaying\nThe model contains all the state, \ndata, and application logic needed \nto maintain and play mp3s.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 561", "position": 561, "chunk_type": "semantic", "token_estimate": 188}
{"text": "The model holds all: the data, state, and \napplication logic. The \nmodel is oblivious to \nthe view and controller, \nalthough it provides an \ninterface to manipulate \nand retrieve its \nstate and it can send \nnotifications of state  \nchanges to observers.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 562", "position": 562, "chunk_type": "semantic", "token_estimate": 40}
{"text": "Gives you a presentation: of the model. The view \nusually gets the state \nand data it needs to \ndisplay directly from \nthe model. View\nA closer look...\n2\nI\u2019ve changed! I need your state \ninformation\nThe user did \nsomething\nChange your \ndisplay\nChange your \nstate\n3\n1\n4\n5\nThis is the user \ninterface. Here\u2019s the \nmodel; it \nhandles all \napplication data \nand logic. Here\u2019s the creamy \ncontroller; it lives in \nthe middle. The music player description gives us a high-level view of MVC, but it really \ndoesn\u2019t help you understand the nitty-gritty of how the compound pattern \nworks, how you\u2019d build one yourself, or why it\u2019s such a good thing. Let\u2019s start by \nstepping through the relationships among the model, view, and controller, and \nthen we\u2019ll take second look from the perspective of Design Patterns. class Player {\n  play(){}\n  rip(){}\n  burn(){}\n}", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 562", "position": 562, "chunk_type": "semantic", "token_estimate": 143}
{"text": "you are here 4\u2003 \u2003 525: compound patterns\nThe view is your window to the model. When you do something to the view (like click \nthe Play button), then the view tells the controller what you did. It\u2019s the controller\u2019s \njob to handle that. 1\nYou\u2019re the user\u2014you interact with the view. The controller takes your actions and interprets them. If you click a button, \nit\u2019s the controller\u2019s job to figure out what that means and how the model \nshould be manipulated based on that action. 2\nThe controller asks the model to change its state. When the controller receives an action from the view, it may need to tell the view \nto change as a result. For example, the controller could enable or disable certain \nbuttons or menu items in the interface. 3\nThe controller may also ask the view to change. When something changes in the model, based either on some action you took (like \nclicking a button) or some other internal change (like the next song in the playlist \nhas started), the model notifies the view that its state has changed. 4\nThe model notifies the view when its state has changed. The view gets the state it displays directly from the model. For instance, when the \nmodel notifies the view that a new song has started playing, the view requests the \nsong name from the model and displays it. The view might also ask the model for \nstate as the result of the controller requesting some change in the view. 5\nThe view asks the model for state. Q: Does the controller ever become an \nobserver of the model? A: Sure. In some designs the controller \nregisters with the model and is notified \nof changes. This can be the case when \nsomething in the model directly affects the \nuser interface controls. For instance, certain \nstates in the model may dictate that some \ninterface items be enabled or disabled. If so, \nit\u2019s really the controller\u2019s job to ask the view \nto update its display accordingly. Q: All the controller does is take user \ninput from the view and send it to the \nmodel, correct? Why have it at all if that \nis all it does? Why not just have the code \nin the view itself? In most cases isn\u2019t the \ncontroller just calling a method on the \nmodel?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 563", "position": 563, "chunk_type": "semantic", "token_estimate": 390}
{"text": "you are here 4\u2003 \u2003 525: Why not just have the code \nin the view itself? In most cases isn\u2019t the \ncontroller just calling a method on the \nmodel? A: The controller does more than just \n\u201csend it to the model\u201d; it is responsible for \ninterpreting the input and manipulating the \nmodel based on that input. But your real \nquestion is probably, \u201cWhy can\u2019t I just do that \nin the view code?\u201d\n\nYou could; however, you don\u2019t want to for two \nreasons. First, you\u2019ll complicate your view \ncode because it now has two responsibilities: \nmanaging the user interface and dealing \nwith the logic of how to control the model. Second, you\u2019re tightly coupling your view \nto the model. If you want to reuse the view \nwith another model, forget it. The controller \nseparates the logic of control from the view \nand decouples the view from the model. By keeping the view and controller loosely \ncoupled, you are building a more flexible and \nextensible design, one that can more easily \naccommodate change down the road.", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 563", "position": 563, "chunk_type": "semantic", "token_estimate": 173}
{"text": "526\u2003 \u2003 Chapter 12: the patterns in mvc\nUnderstanding MVC as a set of Patterns\nWe\u2019ve already suggested that the best path to learning MVC is to see it for what it is: a \nset of patterns working together in the same design. Let\u2019s start with the model: the model uses Observer to keep the views and controllers \nupdated on the latest state changes. The view and the controller, on the other hand, \nimplement the Strategy Pattern. The controller is the strategy of the view, and it \ncan be easily exchanged with another controller if you want different behavior. The \nview itself also uses a pattern internally to manage the windows, buttons, and other \ncomponents of the display: the Composite Pattern. Let\u2019s take a closer look:\nThe display consists of a nested set of \nwindows, panels, buttons, text labels, and so \non. Each display component is a composite \n(like a window) or a leaf (like a button). When \nthe controller tells the view to update, it \nonly has to tell the top view component, and \nComposite takes care of the rest. The model implements the Observer Pattern \nto keep interested objects updated when \nstate changes occur. Using the Observer \nPattern keeps the model completely \nindependent of the views and controllers. It \nallows us to use different views with the same \nmodel, or even use multiple views at once. Model\nController\nView\nI\u2019ve changed! I need your state \ninformation\nThe user did \nsomething\nChange your \ndisplay\nChange your \nstate\nStrategy\nObserver\nComposite\nThe view and controller implement the classic Strategy Pattern: the \nview is an object that is configured with a strategy. The controller \nprovides the strategy. The view is concerned only with the visual \naspects of the application, and delegates to the controller any \ndecisions about the interface behavior. Using the Strategy Pattern also \nkeeps the view decoupled from the model because it is the controller \nthat is responsible for interacting with the model to carry out user \nrequests. The view knows nothing about how this gets done. class Player {\n  play(){}\n  rip(){}\n  burn(){}\n}", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 564", "position": 564, "chunk_type": "semantic", "token_estimate": 344}
{"text": "you are here 4\u2003 \u2003 527: compound patterns\nView\nModel\nclass Foo {\n void bar() \n{\n   doBar();\n }\n}\n   \nView\nController\nView\nView\nObservers\nObservable\nI\u2019d like to register \nas an observer\nMy state has \nchanged! Observer\nController\nView\nStrategy\nController\nThe user did \nsomething\nComposite\nAll these observers will be \nnotified whenever state \nchanges in the model. Any object that\u2019s \ninterested in state \nchanges in the model \nregisters with the \nmodel as an observer. The controller is the \nstrategy for the \nview\u2009\u2014\u2009it\u2019s the object \nthat knows how to \nhandle the user actions. We can swap in \nanother behavior for \nthe view by changing \nthe controller. The view \ndelegates to \nthe controller \nto handle the \nuser actions. The view is a composite \nof  GUI components (labels, \nbuttons, text entry, etc.). The top-level component \ncontains other components, \nwhich contain other \ncomponents, and so on until \nyou get to the leaf nodes. paint()\nThe model has no dependencies on \nviewers or controllers! The view only worries about presentation. The controller \nworries about translating user input to actions on the model.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 565", "position": 565, "chunk_type": "semantic", "token_estimate": 179}
{"text": "528\u2003 \u2003 Chapter 12: mvc and the dj view\nUsing MVC to control the beat...\nIt\u2019s your time to be the DJ. When you\u2019re a DJ it\u2019s all about the beat. You might start \nyour mix with a slowed, down-tempo groove at 95 beats per minute (BPM) and \nthen bring the crowd up to a frenzied 140 BPM of trance techno. You\u2019ll finish off \nyour set with a mellow 80 BPM ambient mix. How are you going to do that? You have to control the beat, and you\u2019re going to \nbuild the tool to get you there. The view has two \nparts, the part \nfor viewing the \nstate of the model \nand the part for \ncontrolling things. Increases \nthe BPM by \none beat per \nminute. Decreases \nthe BPM by \none beat per \nminute. You can enter a specific BPM and click \nthe Set button to set a specific beats \nper minute, or you can use the increase \nand decrease buttons for fine tuning. A pulsing bar shows the beat in real time. A display shows the current BPMs and is \nautomatically set whenever the BPM changes. Let\u2019s start with the view of the tool. The view allows you to create \na driving drumbeat and tune its beats per minute...\nMeet the Java DJ View\n120", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 566", "position": 566, "chunk_type": "semantic", "token_estimate": 214}
{"text": "you are here 4\u2003 \u2003 529: compound patterns\nLet\u2019s not forget about the model underneath it all...\nYou can\u2019t see the model, but you can hear it. The \nmodel sits underneath everything else, managing the \nbeat and driving the speakers. B\ne\na\nt\nM\no\nd\ne\nl\nsetBPM()\ngetBPM()\non()\noff()\nYou can start the \nbeat kicking by \nchoosing the Start \nmenu item in the \u201cDJ \nControl\u201d menu. Notice Stop is \ndisabled until you \nstart the beat. You use the Stop \nbutton to shut \ndown the beat \ngeneration. Notice Start is \ndisabled after \nthe beat has \nstarted. The controller is in the middle... Controller\nAll user actions are \nsent to the controller. The controller sits between the view and \nmodel. It takes your input, like selecting \nStart from the DJ Control menu, and turns \nit into an action on the model to start the \nbeat generation. The controller takes input \nfrom the user and figures \nout how to translate that \ninto requests on the model. The BeatModel is the heart of \nthe application. It implements \nthe logic to start and stop \nthe beat, set the BPM, and \ngenerate the sound. Here are a few more ways to control the DJ View... The model also allows us to \nobtain its current state through \nthe getBPM() method.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 567", "position": 567, "chunk_type": "semantic", "token_estimate": 216}
{"text": "530\u2003 \u2003 Chapter 12: the dj model, view, and controller\nB\ne\na\nt\nM\no\nd\ne\nl\nController\nsetBPM()\ngetBPM()\non()\noff()\nClick the \nincrease beat \nbutton... The controller asks \nthe model to update \nits BPM by one. View is notified that the \nBPM changed. It calls \ngetBPM() on the model state. Because the BPM is 120, the \nview gets a beat notification \nevery 1/2 second. The beat is set at 119 BPM and you \nwould like to increase it to 120. ...which results in the \ncontroller being invoked. The view is updated \nto 120 BPM. You see the beat bar \npulse every 1/2 second. View\nView\nPutting the pieces together", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 568", "position": 568, "chunk_type": "semantic", "token_estimate": 112}
{"text": "you are here 4\u2003 \u2003 531: compound patterns\npublic interface BeatModelInterface {\n    void initialize();\n  \n    void on();\n  \n    void off();\n  \n    void setBPM(int bpm);\n  \n    int getBPM();\n  \n    void registerObserver(BeatObserver o);\n  \n    void removeObserver(BeatObserver o);\n  \n    void registerObserver(BPMObserver o);\n  \n    void removeObserver(BPMObserver o);\n}\nBuilding the pieces\nThese are the methods \nthe controller will \nuse to direct the \nmodel based on user \ninteraction. These methods allow \nthe view and the \ncontroller to get \nstate and to become \nobservers. This should look familiar. These methods allow objects \nto register as observers for \nstate changes. We\u2019ve split this into two kinds of observers: \nobservers that want to be notified on every \nbeat, and observers that just want to be \nnotified when the beats per minute change. Okay,  you know the model is responsible for maintaining all the data, state, and any \napplication logic. So what\u2019s the BeatModel got in it? Its main job is managing the beat, \nso it has state that maintains the current beats per minute and code to play an audio \nclip to create the beat that we hear. It also exposes an interface that lets the controller \nmanipulate the beat and lets the view and controller obtain the model\u2019s state. Also, \ndon\u2019t forget that the model uses the Observer Pattern, so we also need some methods to \nlet objects register as observers and send out notifications. This gets called after \nBeatModel is instantiated. These methods turn the \nbeat generator on and off. This method sets the beats per \nminute. After it is called, the beat \nfrequency changes immediately. The getBPM() method \nreturns the current BPMs, \nor 0 if the generator is off. Let\u2019s check out the BeatModelInterface before \nlooking at the implementation:", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 569", "position": 569, "chunk_type": "semantic", "token_estimate": 275}
{"text": "you are here 4\u2003 \u2003 533: compound patterns\nThe View\nNow the fun starts; we get to hook up a view and visualize the BeatModel! The first thing to notice about the view is that we\u2019ve implemented it so that it is displayed in two \nseparate windows. One window contains the current BPM and the pulse; the other contains \nthe interface controls. Why? We wanted to emphasize the difference between the interface that \ncontains the view of the model and the rest of the interface that contains the set of user controls. Let\u2019s take a closer look at the two parts of the view:\nWe\u2019ve separated \nthe view of the \nmodel from the \nview with the \ncontrols. The DJ view \ndisplays two \naspects of the \nBeatModel...\n...the current \nbeats per \nminute, from the \nBPMObserver \nnotifications...\n...and a \u201cbeat bar\u201d \nthat pulses in sync \nwith the beat, driven \nby the BeatObserver \nnotifications. A textual view that displays a music genre based on the BPM (ambient, downbeat, techno, etc.). A light show that is based on the real-time beat. This is the part of the view that \nyou use to change the beat. This \nview passes everything you do on \nto the controller. Our BeatModel makes no assumptions about the view. The model is implemented using the \nObserver Pattern, so it just notifies any view registered as an observer when its state changes. The view uses the model\u2019s API to get access to the state. We\u2019ve implemented one type of view; \ncan you think of other views that could make use of the notifications and state in the BeatModel?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 571", "position": 571, "chunk_type": "semantic", "token_estimate": 266}
{"text": "534\u2003 \u2003 Chapter 12: the dj view\npublic class DJView implements ActionListener,  BeatObserver, BPMObserver {\n    BeatModelInterface model;\n    ControllerInterface controller;\n    JFrame viewFrame;\n    JPanel viewPanel;\n    BeatBar beatBar;\n    JLabel bpmOutputLabel;\n  \n    public DJView(ControllerInterface controller, BeatModelInterface model) { \n \n \n        this.controller = controller;\n        this.model = model;\n        model.registerObserver((BeatObserver)this);\n        model.registerObserver((BPMObserver)this);\n    }\n    \n    public void createView() {\n        // Create all Swing components here\n    }\n  \n    public void updateBPM() {\n        int bpm = model.getBPM();\n        if (bpm == 0) {\n            bpmOutputLabel.setText(\"offline\");\n        } else {\n            bpmOutputLabel.setText(\"Current BPM: \" + model.getBPM());\n        }\n    }\n  \n    public void updateBeat() {\n        beatBar.setValue(100);\n    }\n}\nImplementing the View\nThe two parts of the view\u2014the view of the model, and \nthe view with the user interface controls\u2014are displayed \nin two windows, but live together in one Java class. We\u2019ll \nfirst show you just the code that creates the view of the \nmodel, which displays the current BPM and the beat bar. Then we\u2019ll come back on the next page and show you just \nthe code that creates the user interface controls, which \ndisplays the BPM text entry field, and the buttons. DJView is an observer for both real-time beats and BPM changes. Here, we create a few \ncomponents for the display. The view holds a reference to both the model and \nthe controller. The controller is only used by the \ncontrol interface, which we\u2019ll go over in a sec... The constructor gets a reference \nto the controller and the model, \nand we store references to those \nin the instance variables. We also register as a BeatObserver and \na BPMObserver of the model. The updateBPM() method is called when a state \nchange occurs in the model. When that happens, we \nupdate the display with the current BPM. We can get \nthis value by requesting it directly from the model. Likewise, the updateBeat() method is called \nwhen the model starts a new beat. When that \nhappens, we need to pulse our beat bar. We do \nthis by setting it to its maximum value (100) \nand letting it handle the animation of the pulse. The code on these two \npages is just an outline! What we\u2019ve done here is \nsplit ONE class into TWO, \nshowing you one part of \nthe view on this page, and the other \npart on the next page. All this code is \nreally in ONE class\u2014DJView.java. It\u2019s \nall listed at the end of the chapter.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 572", "position": 572, "chunk_type": "semantic", "token_estimate": 383}
{"text": "you are here 4\u2003 \u2003 535: compound patterns\npublic class DJView implements ActionListener,  BeatObserver, BPMObserver {\n    BeatModelInterface model;\n    ControllerInterface controller;\n    JLabel bpmLabel;\n    JTextField bpmTextField;\n    JButton setBPMButton;\n    JButton increaseBPMButton;\n    JButton decreaseBPMButton;\n    JMenuBar menuBar;\n    JMenu menu;\n    JMenuItem startMenuItem;\n    JMenuItem stopMenuItem;\n  \n    public void createControls() {\n        // Create all Swing components here\n    }\n    public void enableStopMenuItem() {\n        stopMenuItem.setEnabled(true);\n    }\n    public void disableStopMenuItem() {\n        stopMenuItem.setEnabled(false);\n    }\n    public void enableStartMenuItem() {\n        startMenuItem.setEnabled(true);\n    }\n    public void disableStartMenuItem() {\n        startMenuItem.setEnabled(false);\n    }\n    public void actionPerformed(ActionEvent event) {\n        if (event.getSource() == setBPMButton) {\n            int bpm = Integer.parseInt(bpmTextField.getText());\n            controller.setBPM(bpm);\n        } else if (event.getSource() == increaseBPMButton) {\n            controller.increaseBPM();\n        } else if (event.getSource() == decreaseBPMButton) {\n            controller.decreaseBPM();\n        }\n    }\n}\nImplementing the View, continued...\nNow, we\u2019ll look at the code for the user interface controls part of the view. This view lets you control \nthe model by telling the controller what to do, which in turn, tells the model what to do. Remember, \nthis code is in the same class file as the other view code. All these methods allow the start and \nstop items in the menu to be enabled and \ndisabled. We\u2019ll see that the controller uses \nthese to change the interface. This method creates all the controls and places them \nin the interface. It also takes care of the menu. When \nthe stop or start items are chosen, the corresponding \nmethods are called on the controller. This method is called when a button is clicked. If the Set button is \nclicked, then it is passed \non to the controller \nalong with the new bpm. Likewise, if the increase or \ndecrease button is clicked, \nthis information is passed \non to the controller.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 573", "position": 573, "chunk_type": "semantic", "token_estimate": 270}
{"text": "536\u2003 \u2003 Chapter 12: the dj controller\npublic interface ControllerInterface {\n    void start();\n    void stop();\n    void increaseBPM();\n    void decreaseBPM();\n    void setBPM(int bpm);\n}\nNow for the Controller\nIt\u2019s time to write the missing piece: the controller. Remember the controller \nis the strategy that we plug into the view to give it some smarts. Because we are implementing the Strategy Pattern, we need to start with \nan interface for any Strategy that might be plugged into the DJ View. We\u2019re \ngoing to call it ControllerInterface. Here are all the \nmethods the view can \ncall on the controller. These should look familiar to you after seeing \nthe model\u2019s interface. You can stop and start \nthe beat generation and change the BPM. This interface is \u201cricher\u201d than the BeatModel \ninterface because you can adjust the BPMs \nwith increase and decrease. You\u2019ve seen that the view and controller together make use of the Strategy \nPattern. Can you draw a class diagram of the two that represents this pattern? Design Puzzle", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 574", "position": 574, "chunk_type": "semantic", "token_estimate": 165}
{"text": "you are here 4\u2003 \u2003 537: compound patterns\npublic class BeatController implements ControllerInterface {\n    BeatModelInterface model;\n    DJView view;\n   \n    public BeatController(BeatModelInterface model) {\n        this.model = model;\n        view = new DJView(this, model);\n        view.createView();\n        view.createControls();\n        view.disableStopMenuItem();\n        view.enableStartMenuItem();\n        model.initialize();\n    }\n  \n    public void start() {\n        model.on();\n        view.disableStartMenuItem();\n        view.enableStopMenuItem();\n    }\n  \n    public void stop() {\n        model.off();\n        view.disableStopMenuItem();\n        view.enableStartMenuItem();\n    }\n    \n    public void increaseBPM() {\n        int bpm = model.getBPM();\n        model.setBPM(bpm + 1);\n    }\n    \n    public void decreaseBPM() {\n        int bpm = model.getBPM();\n        model.setBPM(bpm - 1);\n    }\n  \n    public void setBPM(int bpm) {\n        model.setBPM(bpm);\n    }\n}\nAnd here\u2019s the implementation of the controller:\nThe controller implements \nthe ControllerInterface. The controller is the creamy stuff \nin the middle of the MVC Oreo \ncookie, so it is the object that \ngets to hold on to the view and the \nmodel and glues it all together. The controller is passed the \nmodel in the constructor and \nthen creates the view. Likewise, when you choose Stop from \nthe menu, the controller turns the \nmodel off and alters the user interface \nso that the Stop menu item is disabled \nand the Start menu item is enabled. When you choose Start from the user \ninterface menu, the controller turns \nthe model on and then alters the user \ninterface so that the Start menu \nitem is disabled and the Stop menu \nitem is enabled. NOTE: the controller is \nmaking the intelligent \ndecisions for the view. The view just knows how \nto turn menu items on \nand off; it doesn\u2019t know \nthe situations in which \nit should disable them. If the increase button is clicked, \nthe controller gets the current \nBPM from the model, adds one, \nand then sets a new BPM. Same thing here, only we subtract \none from the current BPM. Finally, if the user interface is used to \nset an arbitrary BPM, the controller \ninstructs the model to set its BPM.", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 575", "position": 575, "chunk_type": "semantic", "token_estimate": 303}
{"text": "538\u2003 \u2003 Chapter 12: putting it all together\npublic class DJTestDrive {\n    public static void main (String[] args) {\n        BeatModelInterface model = new BeatModel();\n        ControllerInterface controller = new BeatController(model);\n    }\n}\nPutting it all together...\nWe\u2019ve got everything we need: a model, a view, and a controller. Now it\u2019s time to put them all together! We\u2019re going to see and \nhear how well they work together. All we need is a little code to get things started; it won\u2019t take much:\nFirst create a model...\n...then create a controller and \npass it the model. Remember, \nthe controller creates the view, \nso we don\u2019t have to do that. And now for a test run...\n% java DJTestDrive\n%\nFile  Edit   Window  Help  LetTheBassKick\nRun this...\n...and you\u2019ll see this. Start the beat generation with the Start menu item; \nnotice the controller disables the item afterward. Use the text entry along with the increase and \ndecrease buttons to change the BPM. Notice how the \nview display reflects the changes despite the fact that \nit has no logical link to the controls. Notice how the beat bar always keeps up with the beat \nsince it\u2019s an observer of the model. Put on your favorite song and see if you can match the \nbeat by using the increase and decrease controls. Stop the generator. Notice how the controller disables \nthe Stop menu item and enables the Start menu item. Things to try\n5\n4\n3\n2\n1\nMake sure you have \nthe file clip.wav at \nthe top level of the \ncode folder!", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 576", "position": 576, "chunk_type": "semantic", "token_estimate": 257}
{"text": "you are here 4\u2003 \u2003 539: compound patterns\nExploring Strategy\nLet\u2019s take the Strategy Pattern just a little further to get a \nbetter feel for how it is used in MVC. We\u2019re going to see \nanother friendly pattern pop up too\u2014a pattern you\u2019ll often \nsee hanging around the MVC trio: the Adapter Pattern. Think for a second about what the DJ View does: it displays \na beat rate and a pulse. Does that sound like something else? How about a heartbeat? It just so happens that we have a \nheart monitor class; here\u2019s the class diagram:\ngetHeartRate()\nregisterBeatObserver()\nregisterBPMObserver()\n// other heart methods\nHeartModel\nWe\u2019ve got a method for getting \nthe current heart rate. And luckily, its developers knew about the \nBeat and BPM Observer interfaces! It certainly would be nice to reuse our current view with the HeartModel, but we need a \ncontroller that works with this model. Also, the interface of the HeartModel doesn\u2019t match what \nthe view expects because it has a getHeartRate() method rather than a getBPM(). How would \nyou design a set of classes to allow the view to be reused with the new model? Jot down your \nclass design ideas below.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 577", "position": 577, "chunk_type": "semantic", "token_estimate": 196}
{"text": "540\u2003 \u2003 Chapter 12: mvc and adapter\npublic class HeartAdapter implements BeatModelInterface {\n    HeartModelInterface heart;\n \n    public HeartAdapter(HeartModelInterface heart) {\n        this.heart = heart;\n    }\n    public void initialize() {}\n  \n    public void on() {}\n  \n    public void off() {}\n   \n    public int getBPM() {\n        return heart.getHeartRate();\n    }\n  \n    public void setBPM(int bpm) {}\n   \n    public void registerObserver(BeatObserver o) {\n        heart.registerObserver(o);\n    }\n    \n    public void removeObserver(BeatObserver o) {\n        heart.removeObserver(o);\n    }\n     \n    public void registerObserver(BPMObserver o) {\n        heart.registerObserver(o);\n    }\n  \n    public void removeObserver(BPMObserver o) {\n        heart.removeObserver(o);\n    }\n}\nAdapting the Model\nFor starters, we\u2019re going to need to adapt the HeartModel to a BeatModel. If we don\u2019t, the \nview won\u2019t be able to work with the model, because the view only knows how to getBPM(), \nand the equivalent heart model method is getHeartRate(). How are we going to do this? We\u2019re going to use the Adapter Pattern, of course! It turns out that this is a common \ntechnique when working with MVC: use an adapter to adapt a model to work with existing \ncontrollers and views. Here\u2019s the code to adapt a HeartModel to a BeatModel:\nWe need to implement the \ntarget interface\u2009\u2014\u2009in this \ncase, BeatModelInterface. Here, we store a reference \nto the heart model. We don\u2019t know what these would \ndo to a heart, but it sounds scary. So we\u2019ll just leave them as \u201cno ops.\u201d\nWhen getBPM() is called, we\u2019ll just \ntranslate it to a getHeartRate() \ncall on the heart model. We don\u2019t want to do this on a heart! Again, let\u2019s leave it as a \u201cno op.\u201d\nHere are our observer methods. We just delegate them to the \nwrapped heart model.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 578", "position": 578, "chunk_type": "semantic", "token_estimate": 263}
{"text": "you are here 4\u2003 \u2003 541: compound patterns\npublic class HeartTestDrive {\n    public static void main (String[] args) {\n        HeartModel heartModel = new HeartModel();\n        ControllerInterface model = new HeartController(heartModel);\n    }\n}\npublic class HeartController implements ControllerInterface {\n    HeartModelInterface model;\n    DJView view;\n  \n    public HeartController(HeartModelInterface model) {\n        this.model = model;\n        view = new DJView(this, new HeartAdapter(model));\n        view.createView();\n        view.createControls();\n        view.disableStopMenuItem();\n        view.disableStartMenuItem();\n    }\n  \n    public void start() {}\n \n    public void stop() {}\n    \n    public void increaseBPM() {}\n    \n    public void decreaseBPM() {}\n  \n    public void setBPM(int bpm) {}\n}\nNow we\u2019re ready for a HeartController\nWith our HeartAdapter in hand, we should be ready to create a controller and get \nthe view running with the HeartModel. Talk about reuse! The HeartController implements \nthe ControllerInterface, just \nlike the BeatController did. Like before, the \ncontroller creates the \nview and gets everything \nglued together. There is one change: we are passed \na HeartModel, not a BeatModel...\n...and we need to wrap that \nmodel with an adapter before \nwe hand it to the view. There\u2019s not a lot to do here; after all, \nwe can\u2019t really control hearts like we \ncan beat machines. And that\u2019s it! Now it\u2019s time for some test code...\nAll we need to do is create the \ncontroller and pass it a heart monitor. Finally, the HeartController disables the \nmenu items because they aren\u2019t needed.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 579", "position": 579, "chunk_type": "semantic", "token_estimate": 216}
{"text": "542\u2003 \u2003 Chapter 12: test the heart model\n% java HeartTestDrive\n%\nFile  Edit   Window  Help  CheckMyPulse\nRun this...\n...and you\u2019ll see this. Notice that the display works great with a heart! The beat bar looks just like a pulse. Because the \nHeartModel also supports BPM and Beat Observers, \nwe can get beat updates just like with the DJ beats. As the heartbeat has natural variation, notice the \ndisplay is updated with the new beats per minute. Each time we get a BPM update, the adapter is doing \nits job of translating getBPM() calls to getHeartRate() \ncalls. The Start and Stop menu items are not enabled \nbecause the controller disabled them. The other buttons still work but have no effect \nbecause the controller implements no ops for them. The view could be changed to support the disabling \nof these items. Things to try\nAnd now for a test run...\n5\n4\n3\n2\n1\nNice healthy \nheart rate.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 580", "position": 580, "chunk_type": "semantic", "token_estimate": 157}
{"text": "you are here 4\u2003 \u2003 543: compound patterns\nQ: It seems like you are really hand-\nwaving the fact that the Composite \nPattern is really in MVC. Is it really there? A: Yes, Virginia, there really is a \nComposite Pattern in MVC. But, actually, \nthis is a very good question. Today GUI \npackages, like Swing, have become so \nsophisticated that we hardly notice the \ninternal structure and the use of Composite \nin the building and update of the display. It\u2019s even harder to see when we have web \nbrowsers that can take markup language \nand convert it into a user interface. Back when MVC was first discovered, \ncreating GUIs required a lot more manual \nintervention and the pattern was more \nobviously part of the MVC. Q: Does the controller ever implement \nany application logic? A: No, the controller implements behavior \nfor the view. It is the smarts that translates \nthe actions from the view to actions on the \nmodel. The model takes those actions and \nimplements the application logic to decide \nwhat to do in response to those actions. The \ncontroller might have to do a little work to \ndetermine what method calls to make on \nthe model, but that\u2019s not considered the \n\u201capplication logic.\u201d The application logic is the \ncode that manages and manipulates your \ndata and it lives in your model. Q: I\u2019ve always found the word \u201cmodel\u201d \nhard to wrap my head around. I now \nget that it\u2019s the guts of the application, \nbut why was such a vague, hard-to-\nunderstand word used to describe this \naspect of MVC? A: When MVC was named they needed a \nword that began with a \u201cM\u201d or otherwise they \ncouldn\u2019t have called it MVC. But seriously, we agree with you. Everyone \nscratches their head and wonders what a \nmodel is. But then everyone comes to the \nrealization that they can\u2019t think of a better \nword either. Q: You\u2019ve talked a lot about the state \nof the model. Does this mean it has the \nState Pattern in it? A: No, we mean the general idea of state. But certainly some models do use the State \nPattern to manage their internal states. Q: I\u2019ve seen descriptions of MVC \nwhere the controller is described as \na \u201cmediator\u201d between the view and the \nmodel. Is the controller implementing the \nMediator Pattern?", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 581", "position": 581, "chunk_type": "semantic", "token_estimate": 386}
{"text": "you are here 4\u2003 \u2003 543: Q: I\u2019ve seen descriptions of MVC \nwhere the controller is described as \na \u201cmediator\u201d between the view and the \nmodel. Is the controller implementing the \nMediator Pattern? A: We haven\u2019t covered the Mediator \nPattern (although you\u2019ll find a summary of \nthe pattern in the appendix), so we won\u2019t go \ninto too much detail here, but the intent of \nthe mediator is to encapsulate how objects \ninteract and promote loose coupling by \nkeeping two objects from referring to each \nother explicitly. So, to some degree, the \ncontroller can be seen as a mediator, since \nthe view never sets state directly on the \nmodel, but rather always goes through the \ncontroller. Remember, however, that the \nview does have a reference to the model to \naccess its state. If the controller were truly a \nmediator, the view would have to go through \nthe controller to get the state of the model \nas well. Q: Does the view always have to ask \nthe model for its state? Couldn\u2019t we use \nthe push model and send the model\u2019s \nstate with the update notification? A: Yes, the model could certainly send \nits state with the notification, and we could \ndo something similar with the BeatModel \nby sending just the state that the view \nis interested in. If you remember the \nObserver Pattern chapter, however, you\u2019ll \nalso remember that there are a couple of \ndisadvantages to this. If you don\u2019t, go back \nto Chapter 2 and have a second look. The \nMVC model has been adapted to a number \nof similar models\u2014in particular, for the web\u2019s \nbrowser/server environment\u2014so you\u2019ll find a \nlot of exceptions to the rule out there. Q: If I have more than one view, do I \nalways need more than one controller? A: Typically, you need one controller \nper view at runtime; however, the same \ncontroller class can easily manage many \nviews. Q: The view is not supposed to \nmanipulate the model; however, I noticed \nin your implementation that the view has \nfull access to the methods that change \nthe model\u2019s state. Is this dangerous? A: You are correct; we gave the view full \naccess to the model\u2019s set of methods. We \ndid this to keep things simple, but there may \nbe circumstances where you want to give the \nview access to only part of your model\u2019s API.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 581", "position": 581, "chunk_type": "semantic", "token_estimate": 389}
{"text": "you are here 4\u2003 \u2003 543: A: You are correct; we gave the view full \naccess to the model\u2019s set of methods. We \ndid this to keep things simple, but there may \nbe circumstances where you want to give the \nview access to only part of your model\u2019s API. There\u2019s a great design pattern that allows \nyou to adapt an interface to provide only a \nsubset. Can you think of it?", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 581", "position": 581, "chunk_type": "semantic", "token_estimate": 70}
{"text": "544\u2003 \u2003 Chapter 12: your design toolbox\nYes! MVC is so useful that it has been adapted to many web \nframeworks. Of course, the web works differently than your \nstandard application, so there are several different approaches \nto applying the MVC Pattern to the web. Web applications have a client side (the browser) and a server \nside. Given that, we can make different design tradeoffs based \non where the model, the view, and the controller reside. In \nthin client approaches, the model, most of the view, and the \ncontroller all reside in the server, with the browser providing \na way to display the view, and to get input from the browser \nto the controller. Another approach is the single page application, \nwhere almost all of the model, view, and controller reside on \nthe client side. Those are the two ends of the spectrum, and \nyou\u2019ll find frameworks that vary the extent to which each \ncomponent\u2014that is the model, the view, and the controller\u2014\nreside on the client or the server, along with hybrid models \nwhere some components are shared across the client and server. There are many popular web MVC frameworks, like Spring \nWeb MVC, Django, ASP\n.NET MVC, AngularJS, EmberJS, \nJavaScriptMVC, Backbone, and no doubt more on the way. For the most part each framework has its own unique way it \nmaps the model, the view, and the controller across the client \nand the server. Now that you know the MVC Pattern, you \nwill have no problem adapting your knowledge to whatever \nframework you choose to use. Most of my user \ninterfaces are \nactually browser-based. Is any of this going to \nhelp me?", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 582", "position": 582, "chunk_type": "semantic", "token_estimate": 273}
{"text": "you are here 4\u2003 \u2003 545: compound patterns\nTools for your Design Toolbox\nYou could impress anyone with your design toolbox. Wow, look \nat all those principles, patterns, and now, compound patterns! Abstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nStrategy - defines a family \nof algorithms, encapsulates \neach one, and makes them \ninterchangeable. Strategy \nlets the algorithm vary \nOO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically. Decorators provide a flexible \nalternative to subclassing for extending \nfunctionality. Abstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes. Factory Method  - Define an \ninterface for creating an object, but \nlet subclasses decide which class to \ninstantiate. Factory Method lets \na class defer instantiation to the \nsubclasses. Singleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it. Command - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Adapter - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Facade - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. We have a new \ncategory! MVC \nis  a  compound \npattern. State - Allow an object to alter its \nbehavior when its internal state changes. The object will appear to change its \nclass. Encapsulate what varies. Favor composition over inheritance. Program to interfaces, not \nimplementations. Strive for loosely coupled designs \nbetween objects that interact. Classes should be open for extension \nbut closed for modification. Depend on abstractions. Do not \ndepend on concrete classes. Only talk to your friends. Don\u2019t call us, we\u2019ll call you. A class should have only one reason \nto change. OO Principles\nProxy - Provide a surrogate or \nplaceholder for another object to \ncontrol access to it. A Compound Pattern combines two or \nmore patterns into a solution that \nsolves a recurring or general problem. Compound Patterns\n\t\n\u0083\nThe Model View Controller \n(MVC) Pattern is a compound \npattern consisting of the \nObserver, Strategy, and \nComposite Patterns.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 583", "position": 583, "chunk_type": "semantic", "token_estimate": 385}
{"text": "you are here 4\u2003 \u2003 545: A Compound Pattern combines two or \nmore patterns into a solution that \nsolves a recurring or general problem. Compound Patterns\n\t\n\u0083\nThe Model View Controller \n(MVC) Pattern is a compound \npattern consisting of the \nObserver, Strategy, and \nComposite Patterns. \u0083\nThe model makes use of the \nObserver Pattern so that it \ncan keep observers updated \nyet stay decoupled from them. \u0083\nThe controller is the Strategy \nfor the view. The view can use \ndifferent implementations of \nthe controller to get different \nbehavior. \u0083\nThe view uses the Composite \nPattern to implement \nthe user interface, which \nusually consists of nested \ncomponents like panels, \nframes, and buttons. \u0083\nThese patterns work together \nto decouple the three players \nin the MVC model, which \nkeeps designs clear and \nflexible. \u0083\nThe Adapter Pattern can be \nused to adapt a new model \nto an existing view and \ncontroller. \u0083\nMVC has been adapted to \nthe web. \u0083\nThere are many web MVC \nframeworks with various \nadaptations of the MVC \npattern to fit the client/server \napplication structure.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 583", "position": 583, "chunk_type": "semantic", "token_estimate": 176}
{"text": "546\u2003 \u2003 Chapter 12: public class QuackCounter implements Quackable {\n    Quackable duck;\n    static int numberOfQuacks;\n  \n    public QuackCounter(Quackable duck) {\n        this.duck = duck;\n    }\n  \n    public void quack() {\n        duck.quack();\n        numberOfQuacks++;\n    }\n \n    public static int getQuacks() {\n        return numberOfQuacks;\n    }\n \n    public void registerObserver(Observer observer) {\n        duck.registerObserver(observer);\n    }\n \n    public void notifyObservers() {\n        duck.notifyObservers();\n    }\n}\nQuackCounter is a Quackable, so \nnow it\u2019s a QuackObservable too. All of this code is the \nsame as the previous \nversion of QuackCounter. Here\u2019s the duck that QuackCounter \nis decorating. It\u2019s this duck that \nreally needs to handle the observable \nmethods. Here are the two \nQuackObservable \nmethods. Notice that \nwe just delegate both \ncalls to the duck \nthat we\u2019re decorating. Exercise Solutions\nThe QuackCounter is a Quackable too. When we change \nQuackable to extend QuackObservable, we have to change every \nclass that implements Quackable, including QuackCounter:\nexercise solutions", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 584", "position": 584, "chunk_type": "semantic", "token_estimate": 139}
{"text": "you are here 4\u2003 \u2003 547: compound patterns\npublic class Flock implements Quackable {\n    List<Quackable> quackers = new ArrayList<Quackable>();\n  \n    public void add(Quackable duck) {\n        ducks.add(duck);\n    }\n  \n    public void quack() {\n        Iterator<Quackable> iterator = quackers.iterator();\n        while (iterator.hasNext()) {\n            Quackable duck = iterator.next();\n            duck.quack();\n        }\n    }\n   \n    public void registerObserver(Observer observer) {\n        Iterator<Quackable> iterator = ducks.iterator();\n        while (iterator.hasNext()) {\n            Quackable duck = iterator.next();\n            duck.registerObserver(observer);\n        }\n    }\n  \n    public void notifyObservers() { }\n  \n}\nWhat if our Quackologist wants to observe an entire flock? What does that \nmean anyway? Think about it like this: if we observe a composite, then we\u2019re \nobserving everything in the composite. So, when you register with a flock, the \nflock composite makes sure you get registered with all its children, which may \ninclude other flocks. Flock is a Quackable, so now \nit\u2019s a QuackObservable too. Here are the Quackables \nthat are in the Flock. When you register as an Observer \nwith the Flock, you actually \nget registered with everything \nthat\u2019s IN the flock, which is \nevery Quackable, whether it\u2019s a \nduck or another Flock. We iterate through all the \nQuackables in the Flock \nand delegate the call to \neach Quackable. If the \nQuackable is another Flock, \nit will do the same. Each Quackable does its own notification, so \nFlock doesn\u2019t have to worry about it. This \nhappens when Flock delegates quack() to each \nQuackable in the Flock.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 585", "position": 585, "chunk_type": "semantic", "token_estimate": 226}
{"text": "548\u2003 \u2003 Chapter 12: You\u2019ve seen that the view and controller together make use of the Strategy \nPattern. Can you draw a class diagram of the two that represents this pattern? Design Puzzle Solution\nsetBPM()\nincreaseBPM()\ndecreaseBPM()\n<<interface>> \nControllerInterface\ncreateView()\nupdateBPM()\nupdateBeat()\ncreateControls()\nenableStopMenuItem()\ndisableStopMenuItem()\nenableStartMenuItem()\ndisableStartMenuItem()\nactionPerformed()\nDJView\ncontroller\nsetBPM()\nincreaseBPM()\ndecreaseBPM()\nController\nThe \nControllerInterface \nis the interface \nthat all concrete \ncontrollers \nimplement. This \nis the strategy \ninterface. We can plug \nin different \ncontrollers \nto provide \ndifferent \nbehaviors for \nthe view. The view delegates \nbehavior to the \ncontroller. The \nbehavior it \ndelegates is how to \ncontrol the model \nbased on user \ninput. We\u2019re still directly instantiating Geese by relying on concrete classes. Can you write an Abstract Factory for Geese? How should it handle \ncreating \u201cgoose ducks\u201d? You could add a createGooseDuck() method to the existing Duck Factories. Or, \nyou could create a completely separate Factory for creating families of Geese. exercise solutions", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 586", "position": 586, "chunk_type": "semantic", "token_estimate": 153}
{"text": "you are here 4\u2003 \u2003 549: compound patterns\npackage headfirst.designpatterns.combined.djview;\n  \npublic class DJTestDrive {\n    public static void main (String[] args) {\n        BeatModelInterface model = new BeatModel();\n        ControllerInterface controller = new BeatController(model);\n    }\n}\npackage headfirst.designpatterns.combined.djview;\n  \npublic interface BeatModelInterface {\n    void initialize();\n  \n    void on();\n  \n    void off();\n  \n    void setBPM(int bpm);\n  \n    int getBPM();\n  \n    void registerObserver(BeatObserver o);\n  \n    void removeObserver(BeatObserver o);\n  \n    void registerObserver(BPMObserver o);\n  \n    void removeObserver(BPMObserver o);\n}\nHere\u2019s the complete implementation of the DJView. It shows all the \nMIDI code to generate the sound, and all the Swing components to \ncreate the view. You can also download this code at \nhttps://www.wickedlysmart.com. Have fun! The Beat Model\nReady Bake\nCode", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 587", "position": 587, "chunk_type": "semantic", "token_estimate": 104}
{"text": "550\u2003 \u2003 Chapter 12: package headfirst.designpatterns.combined.djview;\nimport java.util. *;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport java.io. *;\nimport javax.sound.sampled.Line;\npublic class BeatModel implements BeatModelInterface, Runnable {\n\t\nList<BeatObserver> beatObservers = new ArrayList<BeatObserver>();\n\t\nList<BPMObserver> bpmObservers = new ArrayList<BPMObserver>();\n\t\nint bpm = 90;\n\t\nThread thread;\n\t\nboolean stop = false;\n\t\nClip clip;\n\t\npublic void initialize() {\n\t\n\t\ntry {\n\t\n\t\n\t\nFile resource = new File(\"clap.wav\");\n\t\n\t\n\t\nclip = (Clip) AudioSystem.getLine(new Line.Info(Clip.class));\n\t\n\t\n\t\nclip.open(AudioSystem.getAudioInputStream(resource));\n\t\n\t\n}\n\t\n\t\ncatch(Exception ex) {\n\t\n\t\n\t\nSystem.out.println(\"Error: Can\u2019t load clip\");\n\t\n\t\n\t\nSystem.out.println(ex);\n\t\n\t\n}\n\t\n}\n\t\npublic void on() {\n\t\n\t\nbpm = 90;\n\t\n\t\nnotifyBPMObservers();\n\t\n\t\nthread = new Thread(this);\n\t\n\t\nstop = false;\n\t\n\t\nthread.start();\n\t\n}\n\t\npublic void off() {\n\t\n\t\nstopBeat();\n\t\n\t\nstop = true;\n\t\n}\nready-bake code: model", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 588", "position": 588, "chunk_type": "semantic", "token_estimate": 103}
{"text": "you are here 4\u2003 \u2003 551: compound patterns\nReady Bake\nCode\n\t\npublic void run() {\n\t\n\t\nwhile (!stop) {\n\t\n\t\n\t\nplayBeat();\n\t\n\t\n\t\nnotifyBeatObservers();\n\t\n\t\n\t\ntry {\n\t\n\t\n\t\n\t\nThread.sleep(60000/getBPM());\n\t\n\t\n\t\n} catch (Exception e) {}\n\t\n\t\n}\n\t\n}\n\t\npublic void setBPM(int bpm) {\n\t\n\t\nthis.bpm = bpm;\n\t\n\t\nnotifyBPMObservers();\n\t\n}\n\t\npublic int getBPM() {\n\t\n\t\nreturn bpm;\n\t\n}\n\t\npublic void registerObserver(BeatObserver o) {\n\t\n\t\nbeatObservers.add(o);\n\t\n}\n\t\npublic void notifyBeatObservers() {\n\t\n\t\nfor (int i = 0; i < beatObservers.size(); i++) {\n\t\n\t\n\t\nBeatObserver observer = (BeatObserver)beatObservers.get(i);\n\t\n\t\n\t\nobserver.updateBeat();\n\t\n\t\n}\n\t\n}\n\t\npublic void registerObserver(BPMObserver o) {\n\t\n\t\nbpmObservers.add(o);\n\t\n}\n\t\npublic void notifyBPMObservers() {\n\t\n\t\nfor (int i = 0; i < bpmObservers.size(); i++) {\n\t\n\t\n\t\nBPMObserver observer = (BPMObserver)bpmObservers.get(i);\n\t\n\t\n\t\nobserver.updateBPM();\n\t\n\t\n}\n\t\n}", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 589", "position": 589, "chunk_type": "semantic", "token_estimate": 102}
{"text": "you are here 4\u2003 \u2003 553: compound patterns\npackage headfirst.designpatterns.combined.djview;\n  \npublic interface BPMObserver {\n    void updateBPM();\n}\npackage headfirst.designpatterns.combined.djview;\n  \npublic interface BeatObserver {\n    void updateBeat();\n}\nThe View\nReady Bake\nCode\npackage headfirst.designpatterns.combined.djview;\n    \nimport java.awt. *;\nimport java.awt.event. *;\nimport javax.swing. *;\npublic class DJView implements ActionListener,  BeatObserver, BPMObserver {\n    BeatModelInterface model;\n    ControllerInterface controller;\n    JFrame viewFrame;\n    JPanel viewPanel;\n    BeatBar beatBar;\n    JLabel bpmOutputLabel;\n    JFrame controlFrame;\n    JPanel controlPanel;\n    JLabel bpmLabel;\n    JTextField bpmTextField;\n    JButton setBPMButton;\n    JButton increaseBPMButton;\n    JButton decreaseBPMButton;\n    JMenuBar menuBar;\n    JMenu menu;\n    JMenuItem startMenuItem;\n    JMenuItem stopMenuItem;\n  \n    public DJView(ControllerInterface controller, BeatModelInterface model) {   \n        this.controller = controller;\n        this.model = model;\n        model.registerObserver((BeatObserver)this);\n        model.registerObserver((BPMObserver)this);\n    }", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 591", "position": 591, "chunk_type": "semantic", "token_estimate": 98}
{"text": "556\u2003 \u2003 Chapter 12: public void enableStartMenuItem() {\n        startMenuItem.setEnabled(true);\n    }\n    public void disableStartMenuItem() {\n        startMenuItem.setEnabled(false);\n    }\n    public void actionPerformed(ActionEvent event) {\n        if (event.getSource() == setBPMButton) {\n            int bpm = 90;\n            String bpmText = bpmTextField.getText();\n            if (bpmText == null || bpmText.contentEquals(\"\")) {\n                bpm = 90;\n            } else {\n                bpm = Integer.parseInt(bpmTextField.getText());\n            }\n            controller.setBPM(bpm);\n        } else if (event.getSource() == increaseBPMButton) {\n            controller.increaseBPM();\n        } else if (event.getSource() == decreaseBPMButton) {\n            controller.decreaseBPM();\n        }\n    }\n    public void updateBPM() {\n        int bpm = model.getBPM();\n        if (bpm == 0) {\n            bpmOutputLabel.setText(\"offline\");\n        } else {\n            bpmOutputLabel.setText(\"Current BPM: \" + model.getBPM());\n        }\n    }\n  \n    public void updateBeat() {\n        beatBar.setValue(100);\n    }\n}\npackage headfirst.designpatterns.combined.djview;\n  \npublic interface ControllerInterface {\n    void start();\n    void stop();\n    void increaseBPM();\n    void decreaseBPM();\n    void setBPM(int bpm);\n}\nThe Controller\nready-bake code: controller", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 594", "position": 594, "chunk_type": "semantic", "token_estimate": 123}
{"text": "you are here 4\u2003 \u2003 557: compound patterns\npackage headfirst.designpatterns.combined.djview;\n  \npublic class BeatController implements ControllerInterface {\n    BeatModelInterface model;\n    DJView view;\n   \n    public BeatController(BeatModelInterface model) {\n        this.model = model;\n        view = new DJView(this, model);\n        view.createView();\n        view.createControls();\n        view.disableStopMenuItem();\n        view.enableStartMenuItem();\n        model.initialize();\n    }\n  \n    public void start() {\n        model.on();\n        view.disableStartMenuItem();\n        view.enableStopMenuItem();\n    }\n  \n    public void stop() {\n        model.off();\n        view.disableStopMenuItem();\n        view.enableStartMenuItem();\n    }\n    \n    public void increaseBPM() {\n        int bpm = model.getBPM();\n        model.setBPM(bpm + 1);\n    }\n    \n    public void decreaseBPM() {\n        int bpm = model.getBPM();\n        model.setBPM(bpm - 1);\n    }\n  \n    public void setBPM(int bpm) {\n        model.setBPM(bpm);\n    }\n}\nReady Bake\nCode", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 595", "position": 595, "chunk_type": "semantic", "token_estimate": 88}
{"text": "558\u2003 \u2003 Chapter 12: package headfirst.designpatterns.combined.djview;\npublic interface HeartModelInterface {\n    int getHeartRate();\n    void registerObserver(BeatObserver o);\n    void removeObserver(BeatObserver o);\n    void registerObserver(BPMObserver o);\n    void removeObserver(BPMObserver o);\n}\npackage headfirst.designpatterns.combined.djview;\n  \npublic class HeartTestDrive {\n    public static void main (String[] args) {\n        HeartModel heartModel = new HeartModel();\n        ControllerInterface model = new HeartController(heartModel);\n    }\n}\nThe Heart Model\npackage headfirst.designpatterns.combined.djview;\nimport java.util. *;\npublic class HeartModel implements HeartModelInterface, Runnable {\n    List<BeatObserver> beatObservers = new ArrayList<BeatObserver>();\n    List<BPMObserver> bpmObservers = new ArrayList<BPMObserver>();\n    int time = 1000;\n    int bpm = 90;\n    Random random = new Random(System.currentTimeMillis());\n    Thread thread;\n    public HeartModel() {\n        thread = new Thread(this);\n        thread.start();\n    }\n    public void run() {\n        int lastrate = -1;\n        for(;;) {\n            int change = random.nextInt(10);\n            if (random.nextInt(2) == 0) {\n                change = 0 - change;\n            }\n            int rate = 60000/(time + change);\nready-bake code: heart model", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 596", "position": 596, "chunk_type": "semantic", "token_estimate": 133}
{"text": "you are here 4\u2003 \u2003 559: compound patterns\nReady Bake\nCode\n            if (rate < 120 && rate > 50) {\n                time += change;\n                notifyBeatObservers();\n                if (rate != lastrate) {\n                    lastrate = rate;\n                    notifyBPMObservers();\n                }\n            }\n            try {\n                Thread.sleep(time);\n            } catch (Exception e) {}\n        }\n    }\n    public int getHeartRate() {\n        return 60000/time;\n    }\n    public void registerObserver(BeatObserver o) {\n        beatObservers.add(o);\n    }\n    public void removeObserver(BeatObserver o) {\n        int i = beatObservers.indexOf(o);\n        if (i >= 0) {\n            beatObservers.remove(i);\n        }\n    }\n    public void notifyBeatObservers() {\n        for(int i = 0; i < beatObservers.size(); i++) {\n            BeatObserver observer = (BeatObserver)beatObservers.get(i);\n            observer.updateBeat();\n        }\n    }\n    public void registerObserver(BPMObserver o) {\n        bpmObservers.add(o);\n    }\n    public void removeObserver(BPMObserver o) {\n        int i = bpmObservers.indexOf(o);\n        if (i >= 0) {\n            bpmObservers.remove(i);\n        }\n    }\n    public void notifyBPMObservers() {\n        for(int i = 0; i < bpmObservers.size(); i++) {\n            BPMObserver observer = (BPMObserver)bpmObservers.get(i);\n            observer.updateBPM();\n        }\n    }\n}", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 597", "position": 597, "chunk_type": "semantic", "token_estimate": 140}
{"text": "560\u2003 \u2003 Chapter 12: package headfirst.designpatterns.combined.djview;\npublic class HeartAdapter implements BeatModelInterface {\n    HeartModelInterface heart;\n \n    public HeartAdapter(HeartModelInterface heart) {\n        this.heart = heart;\n    }\n    public void initialize() {}\n  \n    public void on() {}\n  \n    public void off() {}\n   \n    public int getBPM() {\n        return heart.getHeartRate();\n    }\n  \n    public void setBPM(int bpm) {}\n   \n    public void registerObserver(BeatObserver o) {\n        heart.registerObserver(o);\n    }\n    \n    public void removeObserver(BeatObserver o) {\n        heart.removeObserver(o);\n    }\n     \n    public void registerObserver(BPMObserver o) {\n        heart.registerObserver(o);\n    }\n  \n    public void removeObserver(BPMObserver o) {\n        heart.removeObserver(o);\n    }\n}\nThe Heart Adapter\nready-bake code: heart adapter", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 598", "position": 598, "chunk_type": "semantic", "token_estimate": 81}
{"text": "you are here 4\u2003 \u2003 561: compound patterns\npackage headfirst.designpatterns.combined.djview;\n  \npublic class HeartController implements ControllerInterface {\n    HeartModelInterface model;\n    DJView view;\n  \n    public HeartController(HeartModelInterface model) {\n        this.model = model;\n        view = new DJView(this, new HeartAdapter(model));\n        view.createView();\n        view.createControls();\n        view.disableStopMenuItem();\n        view.disableStartMenuItem();\n    }\n  \n    public void start() {}\n \n    public void stop() {}\n    \n    public void increaseBPM() {}\n    \n    public void decreaseBPM() {}\n  \n    public void setBPM(int bpm) {}\n}\nThe Controller\nReady Bake\nCode", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 599", "position": 599, "chunk_type": "semantic", "token_estimate": 64}
{"text": "570\u2003 \u2003 Chapter 13: using a patterns catalog\nFrank: Wow, that\u2019s earth-shattering, a name! Imagine that. Jim: Hold on, Frank; actually, the name is really important. When we have a name \nfor a pattern, it gives us a way to talk about the pattern; you know, that whole shared \nvocabulary thing. Frank: Okay, okay. I was just kidding. Go on, what else is there? Jim: Well, like I was saying, every pattern follows a template. For each pattern we have \na name and a few sections that tell us more about the pattern. For instance, there is an \nIntent section that describes what the pattern is, kind of like a definition. Then there are \nMotivation and Applicability sections that describe when and where the pattern might be \nused. Joe: What about the design itself? Jim: There are several sections that describe the class design along with all the classes \nthat make it up and what their roles are. There is also a section that describes how to \nimplement the pattern and often sample code to show you how. Frank: It sounds like they\u2019ve thought of everything. Jim: There\u2019s more. There are also examples of where the pattern has been used in real \nsystems, as well as what I think is one of the most useful sections: how the pattern relates \nto other patterns. Frank: Oh, you mean they tell you things like how the State and Strategy Patterns differ? Jim: Exactly! Joe:  So Jim, how are you actually using the catalog? When you have a problem, do you \ngo fishing in the catalog for a solution? Jim: I try to get familiar with all the patterns and their relationships first. Then, when I \nneed a pattern, I have some idea of what it is. I go back and look at the Motivation and \nApplicability sections to make sure I\u2019ve got it right. There is also another really important \nsection: Consequences. I review that to make sure there won\u2019t be some unintended effect \non my design. Frank: That makes sense. So once you know the pattern is right, how do you approach \nworking it into your design and implementing it? Jim:  That\u2019s where the class diagram comes in. I first read over the Structure section to \nreview the diagram and then over the Participants section to make sure I understand each \nclass\u2019s role.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 608", "position": 608, "chunk_type": "semantic", "token_estimate": 391}
{"text": "Object Creational: Intent\nEt aliquat, velesto ent lore feuis acillao rperci tat, quat nonsequam il ea at nim nos do enim \nqui eratio ex ea faci tet, sequis dion utat, volore magnisi. Motivation\nEt aliquat, velesto ent lore feuis acillao rperci tat, quat nonsequam il ea at nim nos do enim qui \neratio ex ea faci tet, sequis dion utat, volore magnisi.Rud modolore dit laoreet augiam iril el \ndipis dionsequis dignibh eummy nibh esequat. Duis nulputem ipisim esecte conullut wissi. Os nisissenim et lumsandre do con el utpatuero corercipis augue doloreet luptat amet vel \niuscidunt digna feugue dunt num etummy nim dui blaor sequat num vel etue magna augiat. Aliquis nonse vel exer se minissequis do dolortis ad magnit, sim zzrillut ipsummo dolorem \ndignibh euguer sequam ea am quate magnim illam zzrit ad magna feu facinit delit ut\nApplicability\nDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre \ndolore magna feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min \nea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit \nirit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \ndiam nonullu tpatiss ismodignibh er. Structure\nSingleton\nstatic uniqueInstance\n// Other useful Singleton data...\nstatic getInstance()\n// Other useful Singleton methods... Participants\nDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre \ndolore magna feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min \nea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit \nirit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \ndiam nonullu tpatiss ismodignibh er\n\u0083\t A dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem diam \nnonullu tpatiss ismodignibh er\n\t\n\t\n\t\n\u2013  A feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min ea \t\n\t\n\t\n    feuipit ing enit laore magnibh eniat wisissec\n\t\n\t\n\t\n\u2013  Ad magnim quate modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit\nCollaborations\n\u0083\t Feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit \nirit, conse dolore. Consequences\nDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre:\t\n\t\n1. Dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \t\n\t\n     diam nonullu tpatiss ismodignibh er.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 609", "position": 609, "chunk_type": "semantic", "token_estimate": 402}
{"text": "Object Creational: Consequences\nDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre:\t\n\t\n1. Dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \t\n\t\n     diam nonullu tpatiss ismodignibh er. 2. Modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit laore magnibh \t\n\t\n     eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit irit, conse dolore dolore \t\n\t\n     et, verci enis enit ip elesequisl ut ad esectem. 3. Dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \t\n\t\n     diam nonullu tpatiss ismodignibh er. 4. Modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit laore magnibh \t\n\t\n     eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit irit, conse dolore dolore \t\n\t\n     et, verci enis enit ip elesequisl ut ad esectem. Implementation/Sample Code\nDuDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre \ndolore magna feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min \nea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit \nirit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \ndiam nonullu tpatiss ismodignibh er. Nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit \nlaore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit irit, conse dolore \ndolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem diam nonullu \ntpatiss ismodignibh er. public class Singleton {\n    private static Singleton uniqueInstance;\n \n    // other useful instance variables here\n \n    private Singleton() {}\n \n    public static synchronized Singleton getInstance() \n{\n        if (uniqueInstance == null) {\n            uniqueInstance = new Singleton();\n        }\n        return uniqueInstance;\n    }\n \n    // other useful methods here\n}\nKnown Uses\nDuDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre \ndolore magna feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min \nea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit \nirit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \ndiam nonullu tpatiss ismodignibh er. DuDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre \ndolore magna feuis nos alit ad magnim quate modolore vent lut luptat prat.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 609", "position": 609, "chunk_type": "semantic", "token_estimate": 383}
{"text": "Object Creational: Dui blaore min \nea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit \nirit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \ndiam nonullu tpatiss ismodignibh er. DuDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre \ndolore magna feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min \nea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit \nirit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem \ndiam nonullu tpatiss ismodignibh er. alit ad magnim quate modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam \ndolorpe rcilit irit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con \neros autem diam nonullu tpatiss ismodignibh er. Related Patterns\nElesequisl ut ad esectem ing ea con eros autem diam nonullu tpatiss ismodignibh er. alit \nad magnim quate modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit laore \nmagnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit irit, conse dolore dolore \net, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem diam nonullu tpatiss \nismodignibh er. The structure provides a \ndiagram illustrating the \nrelationships among the \nclasses that participate \nin the pattern. The participants are the classes and \nobjects in the design. This section \ndescribes their responsibilities and roles \nin the pattern. Collaborations tells us \nhow the participants work \ntogether in the pattern. The consequences describe the \neffects that using this pattern \nmay have: good and bad. All patterns in a catalog start with \na name. The name is a vital part of \na pattern\u2009\u2014\u2009without a good name, \na pattern can\u2019t become part of \nthe vocabulary that you share with \nother developers. This is the pattern\u2019s \nclassification or \ncategory. We\u2019ll talk \nabout these in a few \npages. The intent describes what \nthe pattern does in a short \nstatement. You can also think \nof this as the pattern\u2019s \ndefinition (just like we\u2019ve been \nusing in this book). The motivation gives you a concrete \nscenario that describes the problem and \n \nhow the solution solves the problem. The applicability describes situations \nin which the pattern can be applied.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 609", "position": 609, "chunk_type": "semantic", "token_estimate": 395}
{"text": "Object Creational: The motivation gives you a concrete \nscenario that describes the problem and \n \nhow the solution solves the problem. The applicability describes situations \nin which the pattern can be applied. Implementation provides \ntechniques you need to use when \nimplementing this pattern, and \nissues you should watch out for. Sample Code \nprovides code \nfragments that \nmight help with your \nimplementation. Known Uses describes \nexamples of this pattern \nfound in real systems. Related Patterns \ndescribes the \nrelationship between \nthis pattern and others.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 609", "position": 609, "chunk_type": "semantic", "token_estimate": 81}
{"text": "you are here 4\u2003 \u2003 573: better living with patterns\nName\nIntent\nMotivation\nApplicability\nStructure\nParticipants\nCollaborations\n ...\nUse one of the existing \npattern templates to \ndefine your pattern. A lot \nof thought has gone into \nthese templates and other \npattern users will recognize \nthe format. So you wanna be a Design Patterns writer\nDo your homework. You need to be well versed in the \nexisting patterns before you can create a new one. Most patterns \nthat appear to be new, are, in fact, just variants of existing \npatterns. By studying patterns, you become better at recognizing \nthem, and you learn to relate them to other patterns. Take time to reflect, evaluate. Your experience\u2014the \nproblems you\u2019ve encountered, and the solutions you\u2019ve used\u2014\nare where ideas for patterns are born. So take some time to \nreflect on your experiences and comb them for novel designs \nthat recur. Remember that most designs are variations on \nexisting patterns and not new patterns. And when you do find \nwhat looks like a new pattern, its applicability may be too \nnarrow to qualify as a real pattern. Get your ideas down on paper in a way others can \nunderstand. Locating new patterns isn\u2019t of much use if \nothers can\u2019t make use of your find; you need to document your \npattern candidates so that others can read, understand, and \napply them to their own solution and then supply you with \nfeedback. Luckily, you don\u2019t need to invent your own method of \ndocumenting your patterns. As you\u2019ve already seen with the GoF \ntemplate, a lot of thought has already gone into how to describe \npatterns and their characteristics. Have others try your patterns; then refine and refine \nsome more. Don\u2019t expect to get your pattern right the first \ntime. Think of your pattern as a work in progress that will \nimprove over time. Have other developers review your candidate \npattern, try it out, and give you feedback. Incorporate that \nfeedback into your description and try again. Your description \nwill never be perfect, but at some point it should be solid enough \nthat other developers can read and understand it. Don\u2019t forget the Rule of Three. Remember, unless your \npattern has been successfully applied in three real-world \nsolutions, it can\u2019t qualify as a pattern. That\u2019s another good \nreason to get your pattern into the hands of others so they can \ntry it, give feedback, and allow you to converge on a working \npattern.", "domains": ["Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 611", "position": 611, "chunk_type": "semantic", "token_estimate": 404}
{"text": "574\u2003 \u2003 Chapter 13: who does what? Match each pattern with its description:\nPattern\nDescription\nWraps an object and provides a different \ninterface to it. Subclasses decide how to implement steps in an \nalgorithm. Subclasses decide which concrete classes to \ncreate. Ensures one and only one object is created. Encapsulates interchangeable behaviors and uses \ndelegation to decide which one to use. Clients treat collections of objects and individual \nobjects uniformly. Encapsulates state-based behaviors and uses \ndelegation to switch between behaviors. Provides a way to traverse a collection of objects \nwithout exposing its implementation. Simplifies the interface of a set of classes. Wraps an object to provide new behavior. Allows a client to create families of objects \nwithout specifying their concrete classes. Allows objects to be notified when state changes. Wraps an object to control access to it. Encapsulates a request as an object. Decorator\nState\nIterator\nFacade\nStrategy\nProxy\nFactory Method\nAdapter\nObserver\nTemplate Method\nComposite\nSingleton\nAbstract Factory\nCommand", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 612", "position": 612, "chunk_type": "semantic", "token_estimate": 159}
{"text": "you are here 4\u2003 \u2003 575: better living with patterns\nOrganizing Design Patterns\nAs the number of discovered Design Patterns grows, it makes sense to partition them into \nclassifications so that we can organize them, narrow our searches to a subset of all Design Patterns, \nand make comparisons within a group of patterns. In most catalogs, you\u2019ll find patterns grouped into one of a few classification schemes. The most \nwell-known scheme was used by the first patterns catalog and partitions patterns into three distinct \ncategories based on their purposes: Creational, Behavioral, and Structural. Any pattern that is a Behavioral \nPattern is concerned with how \nclasses and objects interact and \ndistribute responsibility. Structural Patterns let you \ncompose classes or objects \ninto larger structures. Abstract Factory\nFactory Method\nSingleton\nAdapter\nComposite\nDecorator\nFacade\nProxy\nCommand\nIterator\nObserver\nState\nStrategy\nTemplate Method\nBehavioral\nCreational\nStructural\nCreational Patterns involve object \ninstantiation and all provide a \nway to decouple a client from the \nobjects it needs to instantiate. Each of these patterns belongs \nin one of those categories. Read each category description and \nsee if you can corral these patterns \ninto their correct categories. This is a \ntoughy! But give it your best shot and \nthen check out the answers on the \nnext page.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 613", "position": 613, "chunk_type": "semantic", "token_estimate": 208}
{"text": "576\u2003 \u2003 Chapter 13: pattern categories\nAny pattern that is a Behavioral \nPattern is concerned with how \nclasses and objects interact and \ndistribute responsibility. Structural Patterns let you \ncompose classes or objects \ninto larger structures. Abstract Factory\nFactory Method\nSingleton\nAdapter\nComposite\nDecorator\nFacade\nProxy\nCommand\nIterator\nObserver\nState\nStrategy\nTemplate Method\nBehavioral\nCreational\nStructural\nPrototype\nBuilder\nInterpreter\nChain of Responsibility\nMediator\nMemento\nVisitor\nBridge\nFlyweight\nWe\u2019ve got a few patterns \n(in grey) that you haven\u2019t \nseen yet. You\u2019ll find an \noverview of these patterns \nin the Appendix. Creational Patterns involve object \ninstantiation and all provide a \nway to decouple a client from the \nobjects it needs to instantiate. Pattern Categories\nHere\u2019s the grouping of patterns into categories. You probably found the exercise difficult, because \nmany of the patterns seem like they could fit into more than one category. Don\u2019t worry, everyone \nhas trouble figuring out the right categories for the patterns.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 614", "position": 614, "chunk_type": "semantic", "token_estimate": 151}
{"text": "you are here 4\u2003 \u2003 577: better living with patterns\nClass Patterns describe how relationships between \nclasses are defined via inheritance. Relationships in \nclass patterns are established at compile time. Abstract Factory\nFactory Method\nSingleton\nAdapter\nComposite\nDecorator\nFacade\nProxy\nCommand\nIterator\nObserver\nState\nStrategy\nTemplate Method\nObject\nClass\nPrototype\nBuilder\nInterpreter\nChain of Responsibility\nMediator\nMemento\nVisitor\nBridge\nFlyweight\nPatterns are often classified by a second attribute: whether or not \nthe pattern deals with classes or objects:\nObject Patterns describe \nrelationships between objects \nand are primarily defined by \ncomposition. Relationships in \nobject patterns are typically \ncreated at runtime and are \nmore dynamic and flexible. Notice there are \na lot more object \npatterns than \nclass patterns! Q: Are these the only classification \nschemes? A: No, other schemes have been \nproposed. Some other schemes start \nwith the three categories and then add \nsubcategories, like \u201cDecoupling Patterns.\u201d \nYou\u2019ll want to be familiar with the most \ncommon schemes for organizing patterns, \nbut also feel free to create your own, if it \nhelps you to understand the patterns better. Q: Does organizing patterns into \ncategories really help you remember \nthem? A: It certainly gives you a framework for \nthe sake of comparison. But many people \nare confused by the creational, structural, \nand behavioral categories; often a pattern \nseems to fit into more than one category. The most important thing is to know the \npatterns and the relationships among them. When categories help, use them! Q: Why is the Decorator Pattern in the \nstructural category? I would have thought \nof that as a behavioral pattern; after all, it \nadds behavior! A: Yes, lots of developers say that! Here\u2019s the thinking behind the Gang of Four \nclassification: structural patterns describe \nhow classes and objects are composed to \ncreate new structures or new functionality. The Decorator Pattern allows you to \ncompose objects by wrapping one object \nwith another to provide new functionality. So \nthe focus is on how you compose the objects \ndynamically to gain functionality, rather than \non the communication and interconnection \nbetween objects, which is the purpose of \nbehavioral patterns. But remember, the \nintent of these patterns is different, and \nthat\u2019s often the key to understanding which \ncategory a pattern belongs to.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 615", "position": 615, "chunk_type": "semantic", "token_estimate": 366}
{"text": "578\u2003 \u2003 Chapter 13: pattern categories\nGuru and Student...\nGuru: Student, you look troubled. Student: Yes, I\u2019ve just learned about \npattern classification and I\u2019m confused. Guru: Continue...\nStudent: After learning much about patterns, I\u2019ve \njust been told that each pattern fits into one of three \nclassifications: structural, behavioral, or creational. Why \ndo we need these classifications? Guru: Whenever we have a large collection of anything, \nwe naturally find categories to fit those things into. It \nhelps us to think of the items at a more abstract level. Student: Guru; can you give me an example? Guru: Of course. Take automobiles; there are many \ndifferent models of automobiles and we naturally put \nthem into categories like economy cars, sports cars, \nSUVs, trucks, and luxury cars. Guru: You look shocked; does this not make sense? Student: Guru, it makes a lot of sense, but I am \nshocked you know so much about cars! Guru: I can\u2019t relate everything to lotus flowers or rice \nbowls. Now, may I continue? Student: Yes, yes, I\u2019m sorry, please continue. Guru: Once you have classifications or categories, you \ncan easily talk about the different groupings: \u201cIf you\u2019re \ndoing the mountain drive from Silicon Valley to Santa \nCruz, a sports car with good handling is the best \noption.\u201d Or, \u201cWith the worsening oil situation, you really \nwant to buy a economy car; they\u2019re more fuel-efficient.\u201d\nStudent: So by having categories, we can talk about a \nset of patterns as a group. We might know we need a \ncreational pattern, without knowing exactly which one, \nbut we can still talk about creational patterns. Guru: Yes, and it also gives us a way to compare a \nmember to the rest of the category. For example, \u201cThe \nMini really is the most stylish compact car around,\u201d or \nto narrow our search, \u201cI need a fuel-efficient car.\u201d", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 616", "position": 616, "chunk_type": "semantic", "token_estimate": 304}
{"text": "you are here 4\u2003 \u2003 579: better living with patterns\nStudent: I see. So I might say that the Adapter Pattern \nis the best structural pattern for changing an object\u2019s \ninterface. Guru: Yes. We also can use categories for one more \npurpose: to launch into new territory. For instance, \n\u201cWe really want to deliver a sports car with Ferrari \nperformance at Honda prices.\u201d\nStudent: That sounds like a death trap. Guru: I\u2019m sorry, I did not hear you, student. Student: Uh, I said \u201cI see that.\u201d\nStudent: So categories give us a way to think about the \nway groups of patterns relate and how patterns within \na group relate to one another. They also give us a way \nto extrapolate to new patterns. But why are there three \ncategories and not four or five? Guru: Ah, like stars in the night sky, there are as many \ncategories as you want to see. Three is a convenient \nnumber and a number that many people have decided \nmakes for a nice grouping of patterns. But others have \nsuggested four, five, or more.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 617", "position": 617, "chunk_type": "semantic", "token_estimate": 179}
{"text": "580\u2003 \u2003 Chapter 13: thinking in patterns\nThinking in Patterns\nYour Brain on Patterns\nContexts, constraints, forces, catalogs, classifications...boy, this \nis starting to sound mighty academic. Okay, all that stuff is \nimportant and knowledge is power. But, let\u2019s face it, if you \nunderstand the academic stuff and don\u2019t have the experience and \npractice using patterns, then it\u2019s not going to make much difference \nin your life. Here\u2019s a quick guide to help you start to think in patterns. What do \nwe mean by that? We mean being able to look at a design and see \nwhere patterns naturally fit and where they don\u2019t. Keep it simple (KISS)\nFirst of all, when you design, solve things in the simplest way possible. Your goal should be simplicity, \nnot \u201chow can I apply a pattern to this problem?\u201d Don\u2019t feel like you aren\u2019t a sophisticated developer if \nyou don\u2019t use a pattern to solve a problem. Other developers will appreciate and admire the simplicity \nof your design. That said, sometimes the best way to keep your design simple and flexible is to use a \npattern. Design Patterns aren\u2019t a magic bullet; in fact, they\u2019re not even a bullet! Patterns, as you know, are general solutions to recurring problems. Patterns also have the benefit of \nbeing well tested by lots of developers. So, when you see a need for one, you can sleep well knowing \nmany developers have been there before and solved the problem using similar techniques. However, patterns aren\u2019t a magic bullet. You can\u2019t plug one in, compile, and then take an early lunch. To use patterns, you also need to think through the consequences for the rest of your design. You know you need a pattern when...\nAh...the most important question: when do you use a pattern? As you approach your design, introduce \na pattern when you\u2019re sure it addresses a problem in your design. If a simpler solution might work, give \nthat consideration before you commit to using a pattern. Knowing when a pattern applies is where your experience and knowledge come in. Once you\u2019re sure \na simple solution will not meet your needs, you should consider the problem along with the set of \nconstraints under which the solution will need to operate\u2014these will help you match your problem to \na pattern. If you\u2019ve got a good knowledge of patterns, you may know of a pattern that is a good match.", "domains": ["Design Principles"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 618", "position": 618, "chunk_type": "semantic", "token_estimate": 400}
{"text": "you are here 4\u2003 \u2003 581: better living with patterns\nThere is one situation in which you\u2019ll want to use a pattern even if a \nsimpler solution would work: when you expect aspects of your system to \nvary. As we\u2019ve seen, identifying areas of change in your design is usually a \ngood sign that a pattern is needed. Just make sure you are adding patterns \nto deal with practical change that is likely to happen, not hypothetical change \nthat may happen. Design time isn\u2019t the only time you want to consider introducing patterns; \nyou\u2019ll also want to do so at refactoring time. Refactoring time is Patterns time! Refactoring is the process of making changes to your code to improve \nthe way it is organized. The goal is to improve its structure, not change \nits behavior. This is a great time to reexamine your design to see if it \nmight be better structured with patterns. For instance, code that is full of \nconditional statements might signal the need for the State Pattern. Or, it \nmay be time to clean up concrete dependencies with Factory. Entire books \nhave been written on the topic of refactoring with patterns, and as your \nskills grow, you\u2019ll want to study this area more. Take out what you don\u2019t really need. Don\u2019t be afraid \nto remove a Design Pattern from your design. No one ever talks about when to remove a pattern. You\u2019d think it was \nblasphemy! Nah, we\u2019re all adults here; we can take it. So when do you remove a pattern? When your system has become \ncomplex and the flexibility you planned for isn\u2019t needed. In other words, \nwhen a simpler solution without the pattern would be better. If you don\u2019t need it now, don\u2019t do it now. Design Patterns are powerful, and it\u2019s easy to see all kinds of ways they \ncan be used in your current designs. Developers naturally love to create \nbeautiful architectures that are ready to take on change from any direction. Resist the temptation. If you have a practical need to support change in \na design today, go ahead and employ a pattern to handle that change. However, if the reason is only hypothetical, don\u2019t add the pattern; it will \nonly add complexity to your system, and you might never need it! Center your thinking on \ndesign, not on patterns. Use \npatterns when there is a natural \nneed for them.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 619", "position": 619, "chunk_type": "semantic", "token_estimate": 399}
{"text": "you are here 4\u2003 \u2003 583: better living with patterns\nZen Mind\nBeginner Mind\nIntermediate \nMind\nYour Mind on Patterns\nThe Beginner uses patterns everywhere. This is good: \nthe beginner gets lots of experience with and practice \nusing patterns. The beginner also thinks, \u201cThe more \npatterns I use, the better the design.\u201d The beginner will \nlearn this is not so, that all designs should be as simple as \npossible. Complexity and patterns should only be used \nwhere they are needed for practical extensibility. As learning progresses, the Intermediate \nmind starts to see where patterns are needed \nand where they aren\u2019t. The intermediate \nmind still tries to fit too many square patterns \ninto round holes, but also begins to see that  \npatterns can be adapted to fit situations where \nthe canonical pattern doesn\u2019t fit. The Zen mind is able to see patterns where they fit naturally. The Zen mind is not obsessed with using patterns; rather, it \nlooks for simple solutions that best solve the problem. The Zen \nmind thinks in terms of the object principles and their tradeoffs. When a need for a pattern naturally arises, the Zen mind applies \nit knowing well that it may require adaptation. The Zen mind \nalso sees relationships to similar patterns and understands the \nsubtleties of  differences in the intent of related patterns. The \nZen mind is also a Beginner mind\u2014it doesn\u2019t let all that pattern \nknowledge overly influence design decisions. \u201cI need a pattern for Hello World.\u201d\n\u201cMaybe I need a Singleton here.\u201d\n\u201cThis is a natural place for Decorator.\u201d", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 621", "position": 621, "chunk_type": "semantic", "token_estimate": 256}
{"text": "you are here 4\u2003 \u2003 585: better living with patterns\nDon\u2019t forget the power of the \nshared vocabulary\nSo I created this broadcast class. It \nkeeps track of all the objects listening to it \nand any time a new piece of data comes along \nit sends a message to each listener. What\u2019s cool \nis that the listeners can join the broadcast at any \ntime or they can even remove themselves. And the \nbroadcast class itself doesn\u2019t know anything about \nthe listeners; any object that implements the \nright interface can register. Time-consuming\nIncomplete\nConfusing\nWe\u2019ve spent so much time in this book discussing OO nuts and bolts that it\u2019s \neasy to forget the human side of Design Patterns\u2014they don\u2019t just help load \nyour brain with solutions, they also give you a shared vocabulary with other \ndevelopers. Don\u2019t underestimate the power of a shared vocabulary, it\u2019s one of \nthe biggest benefits of Design Patterns. Just think, something has changed since the last time we talked about shared \nvocabularies; you\u2019ve now started to build up quite a vocabulary of your own! Not to mention, you have also learned a full set of OO design principles from \nwhich you can easily understand the motivation and workings of any new \npatterns you encounter. Now that you\u2019ve got the Design Pattern basics down, it\u2019s time for you to \ngo out and spread the word to others. Why? Because when your fellow \ndevelopers know patterns and use a shared vocabulary as well, it leads to \nbetter designs and better communication, and, best of all, it\u2019ll save you a lot \nof time that you can spend on cooler things.", "domains": ["Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 623", "position": 623, "chunk_type": "semantic", "token_estimate": 270}
{"text": "586\u2003 \u2003 Chapter 13: five ways to share your vocabulary\nPrecise\nSuccinct\nComplete\nTop five ways to share your vocabulary\n1. In design meetings:  When you meet with your team to discuss \na software design, use design patterns to help stay \u201cin the design\u201d \nlonger. Discussing designs from the perspective of Design Patterns \nand OO principles keeps your team from getting bogged down in \nimplementation details and prevents many misunderstandings. 2. With other developers:  Use patterns in your discussions \nwith other developers. This helps other developers learn about new \npatterns and builds a community. The best part about sharing what \nyou\u2019ve learned is that great feeling when someone else \u201cgets it\u201d! 3. In architecture documentation:  When you write \narchitectural documentation, using patterns will reduce the amount \nof documentation you need to write and gives the reader a clearer \npicture of the design. 4. In code comments and naming conventions:  When \nyou\u2019re writing code, clearly identify the patterns you\u2019re using in \ncomments. Also, choose class and method names that reveal any \npatterns underneath. Other developers who have to read your \ncode will thank you for allowing them to quickly understand your \nimplementation. 5. To groups of interested developers: Share your knowledge. Many developers have heard about patterns but don\u2019t have a good \nunderstanding of what they are. Volunteer to give a brown-bag lunch \non patterns or a talk at your local user group. Observer", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 624", "position": 624, "chunk_type": "semantic", "token_estimate": 232}
{"text": "you are here 4\u2003 \u2003 587: better living with patterns\nErich Gamma\nCruisin\u2019 Objectville with the \nGang of Four\nYou won\u2019t find the Jets or Sharks hanging around Objectville, but \nyou will find the Gang of Four. As you\u2019ve probably noticed, you \ncan\u2019t get far in the World of Patterns without running into them. So, who is this mysterious gang? Put simply, \u201cthe GoF,\u201d which includes Erich Gamma, Richard \nHelm, Ralph Johnson, and John Vlissides, is the group of guys who \nput together the first patterns catalog and in the process, started an \nentire movement in the software field! How did they get that name? No one knows for sure; it\u2019s just a \nname that stuck. But think about it: if you\u2019re going to have a \u201cgang \nelement\u201d running around Objectville, could you think of a nicer \nbunch of guys? In fact, they\u2019ve even agreed to pay us a visit...\nObjectville Patterns Tour\nThe GoF launched the software \npatterns movement, but many others \nhave made significant contributions, \nincluding Ward Cunningham, Kent \nBeck, Jim Coplien, Grady Booch, Bruce \nAnderson, Richard Gabriel, Doug Lea, \nPeter Coad, and Doug Schmidt, to \nname just a few. Go for simplicity \nand don\u2019t become overexcited. If you can come up with a \nsimpler solution without using a \npattern, then go for it. John Vlissides*\nRichard \nHelm\nRalph \nJohnson\nToday \nthere are more \npatterns than in the \nGoF book; learn about \nthem as well. Shoot for practical \nextensibility. Don\u2019t \nprovide hypothetical\ngenerality; be extensible \nin ways that matter. Patterns are tools, not \nrules\u2014they need to be \ntweaked and adapted to\nyour problem. *John Vlissides passed away in 2005. A great loss to the Design Patterns community.", "domains": ["Software Quality Attributes"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 625", "position": 625, "chunk_type": "semantic", "token_estimate": 278}
{"text": "you are here 4\u2003 \u2003 589: better living with patterns\nOther Design Patterns resources\nWebsites\nThe Portland Patterns Repository, run by Ward \nCunningham, is a wiki devoted to all things related to \npatterns. You\u2019ll find threads of discussion on every topic \nyou can think of related to patterns and OO systems. c2.com/cgi/wiki?WelcomeVisitors\nThe Hillside Group fosters common programming \nand design practices and provides a central resource for \npatterns work. The site includes information on many \npatterns-related resources such as articles, books, mailing \nlists, and tools. hillside.net\nO\u2019Reilly Online Learning provides online design \npatterns books, courses, and live teaching. You\u2019ll also find \na design patterns bootcamp course based on this book. oreilly.com\nYou\u2019re going to find there is a vibrant, friendly community of patterns \nusers and writers out there and they\u2019re glad to have you join them. Here are a few resources to get you started... Conferences and Workshops\nIf you\u2019d like to interact with the patterns \ncommunity, be sure to check out the many \npatterns-related conferences and workshops. The \nHillside site maintains a complete list. Check out \nPattern Languages of Programs (PLoP) and the \nACM Conference on Object-Oriented Systems, \nLanguages and Applications (OOPSLA), which is \nnow part of the SPLASH conference. Other Resources\nWe\u2019d be remiss if we didn\u2019t mention Google, Stack Overflow, Quora, and many other sites \nand services as good places to ask questions, find answers, and discuss design patterns. As \nwith anything on the web, always double-check the information you receive.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 627", "position": 627, "chunk_type": "semantic", "token_estimate": 243}
{"text": "you are here 4\u2003 \u2003 591: better living with patterns\nBusiness Process Patterns \ndescribe the interaction \nbetween businesses, customers, \nand data, and can be applied \nto problems such as how \nto effectively make and \ncommunicate decisions. Organizational Patterns \ndescribe the structures \nand practices of human \norganizations. Most \nefforts to date have \nfocused on organizations \nthat produce and/or \nsupport software. User Interface \nDesign Patterns \naddress the \nproblems of how to \ndesign interactive \nsoftware programs. Seen hanging around corporate \nboardrooms and project \nmanagement meetings. Field notes: please add your observations of pattern domains here:\nHabitat: seen in the vicinity \nof video game designers, GUI \nbuilders, and producers. Help find a habitat\nDevelopment team\nCustomer support team", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 629", "position": 629, "chunk_type": "semantic", "token_estimate": 113}
{"text": "you are here 4\u2003 \u2003 593: better living with patterns\nAnti-Pattern\nName: Golden Hammer \nProblem: You need to choose technologies \nfor your development and you believe that \nexactly one technology must dominate the \narchitecture. Context: You need to develop some new \nsystem or piece of software that doesn\u2019t \nfit well with the technology that the \ndevelopment team is familiar with. Forces:\n\u2022 The development team is committed \nto the technology they know. \u2022 The development team is not familiar \nwith other technologies. \u2022 Unfamiliar technologies are seen as \nrisky. \u2022 It is easy to plan and estimate for \ndevelopment using the familiar \ntechnology. Supposed solution: Use the familiar \ntechnology anyway. The technology is applied \nobsessively to many problems, including \nplaces where it is clearly inappropriate. Refactored solution: Expand the knowledge \nof developers through education, training, and \nbook study groups that expose developers to \nnew solutions. Examples: \nWeb companies keep using and maintaining \ntheir internal homegrown caching systems \nwhen open source alternatives are in use. Adapted from the Portland Pattern Repository\u2019s wiki \nat https://wiki.c2.com/?WelcomeVisitors where you\u2019ll \nfind many anti-patterns and discussions. The bad, yet attractive, solution. T\nells you why \nthe solution is \nattractive. How to get to a \ngood solution. The problem and context, \njust like a Design Pattern \ndescription. Just like a Design Pattern, \nan anti-pattern has a name \nso we can create a shared \nvocabulary. Here\u2019s an example of a software development anti-pattern. Example of where this anti-pattern \nhas been observed.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 631", "position": 631, "chunk_type": "semantic", "token_estimate": 242}
{"text": "594\u2003 \u2003 Chapter 13: your design toolbox\nTools for your Design Toolbox\nYou\u2019ve reached that point where you\u2019ve outgrown us. Now\u2019s the \ntime to go out in the world and explore patterns on your own...\nAbstraction\nEncapsulation\nPolymorphism\nInheritance\nOO Basics\nStrategy - defines a family of algorithms, \nencapsulates each one, and makes them \ninterchangeable. Strategy lets the algorithm \nvary independently from clients that use it. OO Patterns\nObserver - defines a one-to-many \ndependency between objects so that \nwhen one object changes state, all its \ndependents are notified and updated \nautomatically\nDecorator - Attach additional \nresponsibilities to an object dynamically. Decorators provide a flexible \nalternative to subclassing for extending \nfunctionality. Abstract Factory - Provide an \ninterface for creating families of \nrelated or depedent objects without \nspecifying their concrete classes. skip\nSingleton - Ensure a class only has one \ninstance and provide a global point of \naccess to it. Command - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Adapter - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. Facade - Encapsulates a request \nas an object, thereby letting you \nparameterize clients with different \nrequests, queue or log requests, and \nsupport undoable operations. The time has come \nfor you to go out and \ndiscover more patterns \non your own. There are \nmany domain-specific \npatterns we haven\u2019t even \nmentioned and there are \nalso some foundational \nones we didn\u2019t cover. You\u2019ve also got patterns \nof your own to create. State - Allow an object to alter its \nbehavior when its internal state changes. The object will appear to change its \nclass. Proxy - Provide a surrogate or \nplaceholder for another object to \ncontrol access to it. A Compound Pattern combines two or \nmore patterns into a solution that \nsolves a recurring or general problem. Compound Patterns\n____________________\n____________________\n_____________________\nYour Patterns Here! Check out the \nAppendix; we\u2019ll \ngive you a heads \nup on some more \nfoundational \npatterns you\u2019ll \nprobably want to \nhave a look at. Encapsulate what varies. Favor composition over inheritance. Program to interfaces, not \nimplementations. Strive for loosely coupled designs \nbetween objects that interact. Classes should be open for extension but \nclosed for modification. Depend on abstractions. Do not depend \non concrete classes. Only talk to your friends. Don\u2019t call us, we\u2019ll call you.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 632", "position": 632, "chunk_type": "semantic", "token_estimate": 400}
{"text": "596\u2003 \u2003 Chapter 13: exercise solutions\nMatch each pattern with its description:\nPattern\nDescription\nWraps an object and provides a different \ninterface to it. Subclasses decide how to implement steps in an \nalgorithm. Subclasses decide which concrete classes to \ncreate. Ensures one and only one object is created. Encapsulates interchangeable behaviors and uses \ndelegation to decide which one to use. Clients treat collections of objects and individual \nobjects uniformly. Encapsulates state-based behaviors and uses \ndelegation to switch between behaviors. Provides a way to traverse a collection of objects \nwithout exposing its implementation. Simplifies the interface of a set of classes. Wraps an object to provide new behavior. Allows a client to create families of objects \nwithout specifying their concrete classes. Allows objects to be notified when state changes. Wraps an object to control access to it. Encapsulates a request as an object. Decorator\nState\nIterator\nFacade\nStrategy\nProxy\nFactory Method\nAdapter\nObserver\nTemplate Method\nComposite\nSingleton\nAbstract Factory\nCommand\nSOlUTion", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 634", "position": 634, "chunk_type": "semantic", "token_estimate": 159}
{"text": "598\u2003 \u2003 Appendix: bridge pattern\nBridge\nUse the Bridge Pattern to vary not only your \nimplementations, but also your abstractions. Imagine you\u2019re writing the code for a new \nergonomic and user-friendly remote control for \nTVs. You already know that you\u2019ve got to use \ngood object-oriented techniques because while \nthe remote is based on the same abstraction, there \nwill be lots of implementations\u2014one for each model \nof TV\n. A scenario\nYour dilemma\nYou know that the remote\u2019s user interface won\u2019t be right the \nfirst time. In fact, you expect that the product will be refined \nmany times as usability data is collected on the remote \ncontrol. So your dilemma is that the remotes are going to change and \nthe TVs are going to change. You\u2019ve already abstracted the user \ninterface so that you can vary the implementation over the many \nTVs your customers will own. But you are also going to need \nto vary the abstraction because it is going to change over time as \nthe remote is improved based on the user feedback. So how are you going to create an object-oriented design that \nallows you to vary the implementation and the abstraction? Every remote has the \nsame abstraction. RemoteControl\non()\noff()\nsetChannel()\n// more methods\nLots of \nimplementations, \none for each TV. SonyControl\non()\noff()\nsetChannel()\n// more methods\nRCAControl\non()\noff()\nsetChannel()\n// more methods\nThis is an abstraction. It could be \nan interface or an abstract class. {\n  tuneChannel(channel);\n}\nUsing this design we can vary \nonly the TV implementation, not \nthe user interface.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 636", "position": 636, "chunk_type": "semantic", "token_estimate": 257}
{"text": "you are here 4\u2003 \u2003 599: leftover patterns\nBridge Benefits\n\u0083\t\nDecouples an implementation so that it is not bound \npermanently to an interface. \u0083\t\nAbstraction and implementation can be extended \nindependently. \u0083\t\nChanges to the concrete abstraction classes don\u2019t \naffect the client. \u0083\t\nUseful in graphics and windowing systems that need \nto run over multiple platforms. \u0083\t\nUseful any time you need to vary an interface and an \nimplementation in different ways. \u0083\t\nIncreases complexity. Bridge Uses and Drawbacks \nWhy use the Bridge Pattern? The Bridge Pattern allows you to vary the implementation and \nthe abstraction by placing the two in separate class hierarchies.", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 637", "position": 637, "chunk_type": "semantic", "token_estimate": 104}
{"text": "on(): off()\ntuneChannel()\n// more methods\nConcreteRemote\non()\noff()\nsetChannel()\nnextChannel()\npreviousChannel()\n// more methods\nRemoteControl\nimplementor\non()\noff()\nsetChannel()\n// more methods\nHas-A\nimplementor.tuneChannel(channel);\nAbstraction \nclass hierarchy. Implementation class hierarchy. The relationship between \nthe two is referred to as \nthe \u201cbridge.\u201d\nAll methods in the abstraction \nare implemented in terms of \nthe implementation. setChannel(currentStation + 1);\ncurrentStation\nConcrete subclasses are implemented in terms of the \nabstraction, not the implementation. Now you have two hierarchies, one for the remotes and a separate one for platform-\nspecific TV implementations. The bridge allows you to vary either side of the two \nhierarchies independently.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 637", "position": 637, "chunk_type": "semantic", "token_estimate": 101}
{"text": "600\u2003 \u2003 Appendix: builder pattern\nBuilder\nUse the Builder Pattern to encapsulate the construction of \na product and allow it to be constructed in steps. You\u2019ve just been asked to build a vacation planner for Patternsland, a new theme \npark just outside of Objectville. Park guests can choose a hotel and various types of \nadmission tickets, make restaurant reservations, and even book special events. To create \na vacation planner, you need to be able to create structures like this:\nA scenario\nYou need a flexible design\nEach guest\u2019s planner can vary in the number of days and types of activities it includes. For instance, a local resident might not need a hotel, but wants to make dinner and \nspecial event reservations. Another guest might be flying into Objectville and needs a \nhotel, dinner reservations, and admission tickets. So, you need a flexible data structure that can represent guest planners and all their \nvariations; you also need to follow a sequence of potentially complex steps to create the \nplanner. How can you provide a way to create the complex structure without mixing it \nwith the steps for creating it? Each day can have any combination \nof hotel reservations, tickets, \nmeals, and special events. Each vacation is planned \nover some number of days. V\na\nc\na\nt\ni\no\nn\n \n \n \n \n \n \n \n \n \nD\na\nyO\nn\ne\n \n \n \n \n \n \n \nD\na\ny\nTw\no\n \n \n \n \n \n \nD\na\ny\nT\nh\nr\ne\ne\n \n \n \n \n \n \n \n \nD\ni\nn\ni\nn\ng\n \n \n \n \nS\np\ne\nc\ni\na\nl E\nv\ne\nn\nt\n \n \n \nP\na\nr\nk\n \nT\ni\nck\ne\nts\n \n \n \nP\na\nr\nk\n \nT\ni\nck\ne\nts\n \n \n \nP\na\nr\nk\n \nT\ni\nck\ne\nts\n \n \n \n \n \n \n \n \nH\no\nt\nel\n \n \n \n \n \n \n \n \nH\no\nt\nel\n \n \n \n \n \n \n \n \n \nD\ni\nn\nn\ne\nr\nP\na\nt\nt\ne\nr\nn\ns\n \no\nn\n \nI\nc\ne\n \n \n \n \n \n \n \n \nH\no\nt\nel\n \n \n \n \n \n \n \n \nD\ni\nn\ni\nn\ng\n \n \n \n \n \n \n \n \n \nD\ni\nn\nn\ne\nr\n \n \n \n \nS\np\ne\nc\ni\na\nl E\nv\ne\nn\nt\nC\ni\nr\nq\nu\ne\n \nD\nu\n \nP\na\ntt\ne\nr\nns", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 638", "position": 638, "chunk_type": "semantic", "token_estimate": 350}
{"text": "you are here 4\u2003 \u2003 601: leftover patterns\nBuilder Benefits\n\u0083\t\nEncapsulates the way a complex object is \nconstructed. \u0083\t\nAllows objects to be constructed in a multistep and \nvarying process (as opposed to one-step factories). \u0083\t\nHides the internal representation of the product from \nthe client. \u0083\t\nProduct implementations can be swapped in and out \nbecause the client only sees an abstract interface. Builder Uses and Drawbacks \nWhy use the Builder Pattern? Remember Iterator? We encapsulated the iteration into a separate \nobject and hid the internal representation of the collection from the \nclient. It\u2019s the same idea here: we encapsulate the creation of the \ntrip planner in an object (let\u2019s call it a builder), and have our client \nask the builder to construct the trip planner structure for it. The Client directs \nthe builder to \nconstruct the \nplanner. AbstractBuilder\nbuildDay()\naddHotel()\naddReservation()\naddSpecialEvent()\naddTickets()\ngetVacationPlanner()\nClient\nbuilder.buildDay(date);\nbuilder.addHotel(date, \"Grand Facadian\");\nbuilder.addTickets(\"Patterns on Ice\");\n  // plan rest of vacation \nPlanner yourPlanner = \n        builder.getVacationPlanner();\nThe client uses an \nabstract interface to \nbuild the planner. The concrete builder \ncreates real products \nand stores them in \nthe vacation composite \nstructure. The Client directs the builder to create \nthe planner in a number of steps and \nthen calls the getVacationPlanner() \nmethod to retrieve the complete object. VacationBuilder\nvacation\nbuildDay()\naddHotel()\naddReservation()\naddSpecialEvent()\naddTickets()\ngetVacationPlanner()\nbuilder\nconstructPlanner()\n\u0083\t\nOften used for building composite structures. \u0083\t\nConstructing objects requires more domain \nknowledge of the client than when using a Factory.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 639", "position": 639, "chunk_type": "semantic", "token_estimate": 243}
{"text": "602\u2003 \u2003 Appendix: chain of responsibility pattern\nChain of Responsibility\nUse the Chain of Responsibility Pattern when you want to \ngive more than one object a chance to handle a request. Mighty Gumball has been getting more email \nthan they can handle since the release of the \nJava-powered Gumball Machine. From their \nown analysis they get four kinds of email: fan \nmail from customers that love the new 1-in-10 \ngame, complaints from parents whose kids are \naddicted to the game, requests to put machines \nin new locations, and a fair amount of spam. All fan mail should go straight to the CEO, all \ncomplaints should go to the legal department, \nand all requests for new machines should go to \nbusiness development. Spam should be deleted. A scenario\nYour task\nMighty Gumball has already written some AI \ndetectors that can tell if an email is spam, fan \nmail, a complaint, or a request, but they need \nyou to create a design that can use the detectors \nto handle incoming email. You\u2019ve got to help us \ndeal with the flood of email we\u2019re \ngetting since the release of the \nJava Gumball Machine.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 640", "position": 640, "chunk_type": "semantic", "token_estimate": 189}
{"text": "you are here 4\u2003 \u2003 603: leftover patterns\n Chain of Responsibility Benefits\n\u0083\t\nDecouples the sender of the request and its \nreceivers. \u0083\t\nSimplifies your object because it doesn\u2019t have \nto know the chain\u2019s structure and keep direct \nreferences to its members. \u0083\t\nAllows you to add or remove responsibilities \ndynamically by changing the members or order of \nthe chain. \u0083\t\nCommonly used in Windows systems to handle \nevents like mouse clicks and keyboard events. \u0083\t\nExecution of the request isn\u2019t guaranteed; it may \nfall off the end of the chain if no object handles it \n(this can be an advantage or a disadvantage). \u0083\t\nCan be hard to observe and debug at runtime. Chain of Responsibility Uses and Drawbacks \nHow to use the Chain of Responsibility Pattern\nWith the Chain of Responsibility Pattern, you create a chain of objects \nto examine requests. Each object in turn examines a request and either \nhandles it or passes it on to the next object in the chain. Handler\nSpamHandler\nFanHandler\nComplaintHandler\nNewLocHandler\nSpam \nHandler\nFan     \nHandler\nComplaint \nHandler\nNewLoc  \nHandler\nEach object in the chain \nacts as a handler and has \na successor object. If it \ncan handle the request, \nit does; otherwise, it \nforwards the request to \nits successor. As email is received, it is passed to the first handler: \nSpamHandler. If the SpamHandler can\u2019t handle the request, it \nis passed on to the FanHandler. And so on...\nEach email is passed to \nthe first handler. Email is not handled if it \nfalls off the end of the \nchain\u2009\u2014\u2009although you can always \nimplement a catch-all handler. successor\nhandleRequest()\nhandleRequest()\nhandleRequest()\nhandleRequest()\nhandleRequest()", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 641", "position": 641, "chunk_type": "semantic", "token_estimate": 272}
{"text": "604\u2003 \u2003 Appendix: flyweight pattern\nFlyweight\nUse the Flyweight Pattern when one instance of a class \ncan be used to provide many virtual instances. You want to add trees as objects in your new landscape design application. In your \napplication, trees don\u2019t really do very much; they have an X-Y location, and they can \ndraw themselves dynamically, depending on how old they are. The thing is, a user \nmight want to have lots and lots of trees in one of their home landscape designs. It \nmight look something like this:\nA scenario\nYour big client\u2019s dilemma\nYou have a key client you\u2019ve been pitching for months. They\u2019re going to buy 1,000 seats of your application, and \nthey\u2019re using your software to do the landscape design for \nhuge planned communities. After using your software for a \nweek, your client is complaining that when they create large \ngroves of trees, the app starts getting sluggish...\nTree\nTree\nTree\nTree\nTree\nTree\nTree\nHouse\nEach Tree instance \nmaintains its own state. Tree\nxCoord\nyCoord\nage\ndisplay()  {\n  // use X-Y coords\n  // & complex age\n  // related calcs\n}", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 642", "position": 642, "chunk_type": "semantic", "token_estimate": 185}
{"text": "you are here 4\u2003 \u2003 605: leftover patterns\n Flyweight Benefits\n\u0083\t\nReduces the number of object instances at runtime, \nsaving memory. \u0083\t\nCentralizes state for many \u201cvirtual\u201d objects into a \nsingle location. \u0083\t\nThe Flyweight is used when a class has many \ninstances, and they can all be controlled identically. \u0083\t\nA drawback of the Flyweight Pattern is that once \nyou\u2019ve implemented it, single, logical instances of the \nclass will not be able to behave independently from \nthe other instances. Flyweight Uses and Drawbacks \nWhy use the Flyweight Pattern? What if, instead of having thousands of Tree objects, you \ncould redesign your system so that you\u2019ve got only one \ninstance of Tree, and a client object that maintains the state \nof ALL your trees? That\u2019s the Flyweight! One, single, state-free \nTree object. All the state, for ALL \nof your virtual Tree \nobjects, is stored in this \n2D array. TreeManager\ntreeArray\ndisplayTrees() {\n  // for all trees {\n    // get array row\n    display(x, y, age);\n   }\n}\nTree\ndisplay(x, y, age) {\n  // use X-Y coords\n  // & complex age\n  // related calcs\n}", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 643", "position": 643, "chunk_type": "semantic", "token_estimate": 182}
{"text": "606\u2003 \u2003 Appendix: interpreter pattern\nexpression ::=  <command> | <sequence> | <repetition>\nsequence ::= <expression> ';' <expression>\ncommand ::= right | quack | fly\nrepetition ::= while '(' <variable> ')'<expression>\nvariable ::= [A-Z,a-z]+\nInterpreter\nUse the Interpreter Pattern to build an \ninterpreter for a language. Remember the Duck Simulator? You have a hunch it would also \nmake a great educational tool for children to learn programming. Using the simulator, each child gets to control one duck with a \nsimple language. Here\u2019s an example of the language:\nA scenario\nNow what? You\u2019ve got a grammar; now all you need is a way to represent and \ninterpret sentences in the grammar so that the students can see the \neffects of their programming on the simulated ducks. Now, remembering how to create grammars from one of your old \nintroductory programming classes, you write out the grammar:\nTurn the duck right. Fly all day...\n...and then quack. A program is an expression consisting \nof sequences of commands and \nrepetitions (\u201cwhile\u201d statements). A while statement is just \na conditional variable and \nan expression. right;\nwhile (daylight) fly;\nquack;\nA sequence is a set of \nexpressions separated \nby semicolons. We have three \ncommands: right, \nquack, and fly. The Interpreter \nPattern requires \nsome knowledge of \nformal grammars. If you\u2019ve never studied formal grammars, \ngo ahead and read through the pattern; \nyou\u2019ll still get the gist of it.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 644", "position": 644, "chunk_type": "semantic", "token_estimate": 229}
{"text": "you are here 4\u2003 \u2003 607: leftover patterns\n Interpreter Benefits\n\u0083\t\nRepresenting each grammar rule in a class makes \nthe language easy to implement. \u0083\t\nBecause the grammar is represented by classes, you \ncan easily change or extend the language. \u0083\t\nBy adding methods to the class structure, you can \nadd new behaviors beyond interpretation, like pretty \nprinting and more sophisticated program validation. \u0083\t\nUse Interpreter when you need to implement a \nsimple language. \u0083\t\nAppropriate when you have a simple grammar and \nsimplicity is more important than efficiency. \u0083\t\nUsed for scripting and programming languages. \u0083\t\nThis pattern can become cumbersome when \nthe number of grammar rules is large. In these \ncases a parser/compiler generator may be more \nappropriate. Interpreter Uses and Drawbacks \nHow to implement an interpreter\nWhen you need to implement a simple language, the  \nInterpreter Pattern defines a class-based representation for its \ngrammar along with an interpreter to interpret its sentences. To represent the language, you use a class to represent each \nrule in the language. Here\u2019s the duck language translated into \nclasses. Notice the direct mapping to the grammar. To interpret the language, call the interpret() method on each \nexpression type. This method is passed a context\u2014which \ncontains the input stream of the program we\u2019re parsing\u2014and \nmatches the input and evaluates it. Expression\ninterpret(context)\nSequence\nRepetition\nFlyCommand\ninterpret(context)\nVariable\nRightCommand\nQuackCommand\ninterpret(context)\ninterpret(context)\ninterpret(context)\ninterpret(context)\nexpression1\nexpression2\nvariable\nexpression\ninterpret(context)", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 645", "position": 645, "chunk_type": "semantic", "token_estimate": 234}
{"text": "608\u2003 \u2003 Appendix: mediator pattern\nMediator\nUse the Mediator Pattern to centralize complex \ncommunications and control between related objects. Calendar\nBob has an automated home, thanks to the good folks at HouseOfTheFuture. All of \nhis appliances are designed to make his life easier. When Bob stops hitting the snooze \nbutton, his alarm clock tells the coffee maker to start brewing. Even though life is good \nfor Bob, he and other customers are always asking for lots of new features: No coffee \non the weekends... Turn off the sprinkler 15 minutes before a shower is scheduled...  \nSet the alarm early on trash days... \nA scenario\nSprinkler\nCoffeePot\nAlarm\nHouseOfTheFuture\u2019s dilemma\nIt\u2019s getting really hard to keep track of which rules reside in which objects, and how \nthe various objects should relate to each other. Alarm\nonEvent() {\n  checkCalendar()\n  checkSprinkler()\n  startCoffee()\n  // do more stuff\n}\nCalendar\nonEvent() {\n  checkDayOfWeek()\n  doSprinkler()\n  doCoffee()\n  doAlarm()\n  // do more stuff\n}\nCoffeePot\nonEvent() {\n  checkCalendar()\n  checkAlarm()\n  // do more stuff\n}\nSprinkler\nonEvent() {\n  checkCalendar()\n  checkShower()\n  checkTemp()\n  checkWeather()\n  // do more stuff\n}", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 646", "position": 646, "chunk_type": "semantic", "token_estimate": 177}
{"text": "you are here 4\u2003 \u2003 609: leftover patterns\n Mediator Benefits\n\u0083\t\nIncreases the reusability of the objects supported by \nthe Mediator by decoupling them from the system. \u0083\t\nSimplifies maintenance of the system by centralizing \ncontrol logic. \u0083\t\nSimplifies and reduces the variety of messages sent \nbetween objects in the system. \u0083\t\nThe Mediator is commonly used to coordinate \nrelated GUI components. \u0083\t\nA drawback of the Mediator Pattern is that without \nproper design, the Mediator object itself can become \noverly complex. Mediator Uses and Drawbacks \nMediator\nCalendar\nSprinkler\nCoffeePot\nAlarm\nMediator in action...\nWith a Mediator added to the system, all \nof the appliance objects can be greatly \nsimplified:\n  \n\u0083 They tell the Mediator when their state \nchanges. \u0083 They respond to requests from the \nMediator. Before we added the Mediator, all of the \nappliance objects needed to know about each \nother; that is, they were all tightly coupled. With the Mediator in place, the appliance \nobjects are all completely decoupled from \neach other. The Mediator contains all of the control \nlogic for the entire system. When an existing \nappliance needs a new rule, or a new \nappliance is added to the system, you\u2019ll know \nthat all of the necessary logic will be added to \nthe Mediator. Mediator \nif(alarmEvent){\n checkCalendar()\n checkShower()\n checkTemp()\n}\nif(weekend) {\n checkWeather()\n // do more stuff\n}\nif(trashDay) {\n resetAlarm()\n // do more stuff\n}\nIt\u2019s such a relief, \nnot having to figure \nout that Alarm clock\u2019s \npicky rules!", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 647", "position": 647, "chunk_type": "semantic", "token_estimate": 243}
{"text": "610\u2003 \u2003 Appendix: memento pattern\n \nMemento\nUse the Memento Pattern when you need \nto be able to return an object to one of its \nprevious states; for instance, if your user \nrequests an \u201cundo.\u201d\nYour interactive role-playing game is hugely successful, \nand has created a legion of addicts, all trying to get \nto the fabled \u201clevel 13.\u201d As users progress to more \nchallenging game levels, the odds of encountering \na game-ending situation increase. Fans who have \nspent days progressing to an advanced level are \nunderstandably miffed when their character gets snuffed, \nand they have to start all over. The cry goes out for a \n\u201csave progress\u201d command, so that players can store their \ngame progress and at least recover most of their efforts \nwhen their character is unfairly extinguished. The \n\u201csave progress\u201d function needs to be designed to return \na resurrected player to the last level she completed \nsuccessfully. A scenario\nJust be careful how you go about \nsaving the game state. It\u2019s pretty \ncomplicated, and I don\u2019t want anyone \nelse with access to it mucking it up and \nbreaking my code.", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 648", "position": 648, "chunk_type": "semantic", "token_estimate": 181}
{"text": "you are here 4\u2003 \u2003 611: leftover patterns\nThe Memento at work\nThe Memento has two goals:\n \n\u0083 Saving the important state of a system\u2019s key object\n \n\u0083 Maintaining the key object\u2019s encapsulation\nKeeping the Single Responsibility Principle in mind, it\u2019s also \na good idea to keep the state that you\u2019re saving separate from \nthe key object. This separate object that holds the state is \nknown as the Memento object. Memento Benefits\n\u0083\t\nKeeping the saved state external from the key \nobject helps to maintain cohesion. \u0083\t\nKeeps the key object\u2019s data encapsulated. \u0083\t\nProvides easy-to-implement recovery capability. \u0083\t\nThe Memento is used to save state. \u0083\t\nA drawback to using Memento is that saving and \nrestoring state can be time-consuming. \u0083\t\nIn Java systems, consider using Serialization to \nsave a system\u2019s state. Memento Uses and Drawbacks \nWhile this isn\u2019t \na terribly fancy \nimplementation, notice \nthat the Client has \nno access to the \nMemento\u2019s data. Client\n// when new level is reached\nObject saved = \n  (Object) mgo.getCurrentState();\n// when a restore is required\nmgo.restoreState(saved);\nGameMemento\nsavedGameState\nMasterGameObject\nObject getCurrentState() {\n  // gather state\n  return(gameState);\n}\nrestoreState(Object savedState) {\n  // restore state\n}\n// do other game stuff\ngameState", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 649", "position": 649, "chunk_type": "semantic", "token_estimate": 197}
{"text": "612\u2003 \u2003 Appendix: prototype pattern\nYour interactive role-playing game has an insatiable appetite for monsters. As your \nheroes make their journey through a dynamically created landscape, they encounter \nan endless chain of foes that must be subdued. You\u2019d like the monster\u2019s characteristics \nto evolve with the changing landscape. It doesn\u2019t make a lot of sense for bird-like \nmonsters to follow your characters into underseas realms. Finally, you\u2019d like to allow \nadvanced players to create their own custom monsters. Prototype\nUse the Prototype Pattern when creating an instance \nof a given class is either expensive or complicated. A scenario\nIt would be a lot cleaner if \nwe could decouple the code that \nhandles the details of creating the \nmonsters from the code that actually \nneeds to create the instances on \nthe fly. Yikes! Just the act \nof creating all of these different \nkinds of monster instances is getting \ntricky... Putting all sorts of state detail in the \nconstructors doesn\u2019t seem to be very cohesive. It \nwould be great if there was a single place where \nall of the instantiation details could be \nencapsulated...", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 650", "position": 650, "chunk_type": "semantic", "token_estimate": 181}
{"text": "you are here 4\u2003 \u2003 613: leftover patterns\n<<interface>>\nMonster\nPrototype to the rescue\nThe Prototype Pattern allows you to make new instances by \ncopying existing instances. (In Java this typically means using \nthe clone() method, or deserialization when you need deep \ncopies.) A key aspect of this pattern is that the client code can \nmake new instances without knowing which specific class is \nbeing instantiated. Prototype Benefits\n\u0083\t\nHides the complexities of making new instances \nfrom the client. \u0083\t\nProvides the option for the client to generate \nobjects whose type is not known. \u0083\t\nIn some circumstances, copying an object can be \nmore efficient than creating a new object. \u0083\t\nPrototype should be considered when a system \nmust create new objects of many types in a \ncomplex class hierarchy. \u0083\t\nA drawback to using Prototype is that making a \ncopy of an object can sometimes be complicated. Prototype Uses and Drawbacks \nThe registry finds the appropriate \nmonster, makes a clone of it, and \nreturns the clone. The client needs a new monster \nappropriate to the current \nsituation. (The client won\u2019t know \nwhat kind of monster he gets.) WellKnownMonster\nDynamicPlayerGeneratedMonster\nMonsterMaker\nmakeRandomMonster() {\n   Monster m = \n     MonsterRegistry.getMonster();\n}\nMonsterRegistry\nMonster getMonster() {\n  // find the correct monster\n  return correctMonster.clone();\n}", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 651", "position": 651, "chunk_type": "semantic", "token_estimate": 209}
{"text": "614\u2003 \u2003 Appendix: visitor pattern\nVisitor\nUse the Visitor Pattern when you want to \nadd capabilities to a composite of objects \nand encapsulation is not important. Customers who frequent the Objectville Diner and Objectville \nPancake House have recently become more health conscious. They \nare asking for nutritional information before ordering their meals. Because both establishments are so willing to create special orders, \nsome customers are even asking for nutritional information on a \nper-ingredient basis. A scenario\nLou\u2019s proposed solution:\nMenuItem\nMenu\nIngredient\nMenuItem\nIngredient\n// new methods\ngetHealthRating()\ngetCalories()\ngetProtein()\ngetCarbs()\n// new methods\ngetHealthRating()\ngetCalories()\ngetProtein()\ngetCarbs()\nMel\u2019s concerns...\n\u201cBoy, it seems like we\u2019re opening Pandora\u2019s box. Who knows what \nnew method we\u2019re going to have to add next, and every time we \nadd a new method we have to do it in two places. Plus, what if \nwe want to enhance the base application with, say, a recipes class? Then we\u2019ll have to make these changes in three different places...\u201d", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 652", "position": 652, "chunk_type": "semantic", "token_estimate": 161}
{"text": "you are here 4\u2003 \u2003 615: leftover patterns\nThe Visitor drops by\nThe Visitor works hand in hand with a Traverser. The Traverser \nknows how to navigate to all of the objects in a Composite. The \nTraverser guides the Visitor through the Composite so that the Visitor \ncan collect state as it goes. Once state has been gathered, the Client \ncan have the Visitor perform various operations on the state. When \nnew functionality is required, only the Visitor must be enhanced. Visitor Benefits\n\u0083\t\nAllows you to add operations to a Composite \nstructure without changing the structure itself. \u0083 \t Adding new operations is relatively easy. \u0083\t\nThe code for operations performed by the Visitor is \ncentralized. \u0083\t\nThe Composite classes\u2019 encapsulation is broken \nwhen the Visitor is used. \u0083\t\nBecause the traversal function is involved, \nchanges to the Composite structure are more \ndifficult. Visitor Drawbacks \nVisitor\n  Client / \nTraverser\ngetState()\ngetState()\ngetState()\ngetState()\ngetState()\ngetHealthRating()\ngetCalories()\ngetProtein()\ngetCarbs()\nAll these composite \nclasses have to do is add \na getState() method \n(and not worry about \nexposing themselves). The Client asks \nthe Visitor to get \ninformation from the \nComposite structure... \nNew methods can be \nadded to the Visitor \nwithout affecting the \nComposite. The Visitor needs to be able to call \ngetState() across classes, and this is \nwhere you can add new methods for \nthe client to use. The Traverser knows how to \nguide the Visitor through \nthe Composite structure. MenuItem\nMenu\nIngredient\nMenuItem\nIngredient", "domains": ["Design Patterns", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 653", "position": 653, "chunk_type": "semantic", "token_estimate": 241}
{"text": "this is the index\u2003 \u2003 617: Index\nA\nAbstractButton class  65\nabstract class  128, 292, 293\nAbstract Factory Pattern\nabout  153\nbuilding ingredient factories  146\u2013148, 167\ncombining patterns  502\u2013505, 548\ndefined  156\u2013157\nexercise matching description of  574, 596\nFactory Method Pattern and  158\u2013161\nimplementing  158\ninterview with  158\u2013159\nAbstractList  309\nabstract superclasses  12\nAdapter Pattern\nabout  243\u2013244\nadapting to Iterator Enumeration interface  251\ncombining patterns  498\u2013499\ndealing with remove() method  252\nDecorator Pattern vs.  254\u2013255\ndefined  245\ndesigning Adapter  251\nexercises for  256, 275, 375, 379, 481, 574, 596\nFacade Pattern vs.  262\nin Model-View-Controller  540\nobject and class adapters  246\u2013249\nProxy Pattern vs.  466\nsimple real world adapters  250\nwriting Enumeration Iterator Adapter  252\u2013253\nadapters, OO (Object-Oriented)\nabout  238\u2013239\ncreating Two Way Adapters  244\nin action  240\u2013241\nobject, class object and class  246\u2013249\ntest driving  242\naggregates  327, 338\nalbum covers, displaying using Proxy Pattern\nabout  458\ncode for  489\u2013492\ndesigning Virtual Proxy  459\nreviewing process  465\ntesting viewer  464\nwriting Image Proxy  460\u2013463\nAlexander, Christopher\nA Pattern Language  588\nThe Timeless Way of Building  588\nalgorithms, encapsulating\nabout  277\nabstracting prepareRecipe()  284\u2013287\nStrategy Pattern and  24\nTemplate Method Pattern and\nabout  288\u2013290\napplets in  309\ncode up close  292\u2013293\ndefined  291\nThe Hollywood Principle and  298\u2013300\nhooks in  293\u2013295\nin real world  301\nsorting with  302\u2013307\nSwing and  308\ntesting code  296\nalgorithms, family of  22\nAnti-Patterns  592\u2013593\nApplicability section, in pattern catalog  571\nApplication Patterns  590\nArchitectural Patterns  590\nArrayList, arrays and  320\u2013325, 351\narrays\niteration and  325\u2013326, 345\niterator and hasNext() method with  328\niterator and next() method with  328", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 655", "position": 655, "chunk_type": "semantic", "token_estimate": 263}
{"text": "618\u2003 \u2003 Index: the index\nB\nbehavioral patterns categories, Design Patterns  576, \n578\u2013579\nbehaviors\nclasses as  14\nclasses extended to incorporate new  86\ndeclaring variables  15\ndelegating to decorated objects while adding  90\ndesigning  11\u201312\nencapsulating  11, 22\nimplementing  11, 13\nseparating  10\nsetting dynamically  20\u201321\nBe the JVM solution exercises, dealing with multithreading \n \n179\u2013180, 188\nBridge Pattern  598\u2013599\nBuilder Pattern  600\u2013601\nBusiness Process Patterns  591\nC\nCaching Proxy, as form of Virtual Proxy  466, 482\nCaf\u00e9 Menu, integrating into framework (Iterator Pattern)  \n347\nChain of Responsibility Pattern  602\u2013603\nchange\nas the one constant in software development  8\nidentifying  54\niteration and  340\nchocolate factory example, using Singleton Pattern  \n175\u2013176, 183\nclass adapters, object vs.  246\u2013249\nclass design, of Observer Pattern  51\u201352\nclasses. See also\u00a0subclasses\nabstract  128, 292, 293\nadapter  244, 274\nAdapter Pattern  245\naltering decorator  108\nas behaviors  14\ncollection  352\ncreating  10\nextended to incorporate new behaviors  86\nFactory Method Pattern creator and product  131\u2013132\nhaving single responsibility  340\u2013341\nhigh-level component  139\nidentifying as Proxy class  480\nrelationships between  22\nstate\ndefining  395\nimplementing  397, 400\u2013405, 409\nincreasing number in design of  408\nreworking  398\u2013399\nstate transitions in  408\nusing composition with  23\nusing instance variables instead of  82\u201383\nusing instead of Singletons static  184\nusing new operator for instantiating concrete  110\u2013113\nClassification section, in pattern catalog  571\nclassloaders, using with Singletons  184\nclass patterns, Design Patterns  577\nclient heap  433\u2013436\nclient helper (stubs), in RMI  436\u2013437, 440, 442\u2013444, \n453\u2013454\nCode Magnets exercise\nfor DinerMenu Iterator  354, 378\nfor Observer Pattern  70, 76\ncohesion  340\nCollaborations section, in pattern catalog  571\ncollection classes  352\ncollection of objects\nabstracting with Iterator Pattern\nabout  317\nadding Iterators  328\u2013334\ncleaning up code using java.util.Iterator  335\u2013337\nremove() method in  334\nimplementing Iterators for  327\nintegrating into framework  347\nmeaning of  327\nusing Composite Pattern\nabout  363\nimplementing components  364\u2013366\ntesting code  368\u2013370\ntree structure  360\u2013362, 368\nusing whole-part relationships  372\nCollections, Iterators and  353", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 656", "position": 656, "chunk_type": "semantic", "token_estimate": 323}
{"text": "you are here 4\u2003 \u2003 619: the index\nCombining Patterns\nAbstract Factory Pattern  502\u2013505\nAdapter Pattern  498\u2013499\nclass diagram for  518\u2013519\nComposite Pattern  507\u2013509\nDecorator Pattern  500\u2013501\nIterator Pattern  507\nObserver Pattern  510\u2013516\ncommand objects\nencapsulating requests to do something  196\nmapping  201\nusing  204\nCommand Pattern\ncommand objects\nbuilding  203\nencapsulating requests to do something  196\nmapping  201\nusing  204\ndefined  206\u2013207\ndumb and smart command objects  228\nexercise matching description of  574, 596\nhome automation remote control\nabout  193\nbuilding  203\u2013205, 235\nclass diagram  207\ncreating commands to be loaded  208\u2013209\ndefining  206\ndesigning  195\u2013196\nimplementing  210\u2013212\nmacro commands  225, 226\u2013228, 236\nmapping  201\u2013202, 235\nNull Object in  214\ntesting  204, 212\u2013213, 227\nundo commands  217\u2013221, 223\u2013224, 228, 236\nvendor classes for  194\nwriting documentation  215\nlogging requests using  230\nmapping  201\u2013202, 235\nNull Object  214\nqueuing requests using  229\nunderstanding  197\u2013200\ncompareTo() method  303\nComplexity Hiding Proxy  483\ncomponents of object  267\u2013271\nComposite Pattern\ncombining patterns  507\u2013509\ndefined  360\ndessert submenu using\nabout  357\ndesigning  363, 371\nimplementing  364\u2013367\ntesting  368\u2013370\nexercise matching description of  375, 379, 574, 596\nin Model-View-Controller  526\u2013527, 543\ninterview with  372\u2013373\non implementation issues  372\u2013373\nsafety vs. transparency  509\ntransparency in  371\ntree structure of  360\u2013362, 368\ncomposition\nadding behavior at runtime  85\nfavoring over inheritance  23, 85\ninheritance vs.  93\nobject adapters and  249\ncompound patterns, using\nabout  493\u2013494\nModel-View-Controller\nabout  520\u2013521, 523\u2013525\nAdapter Pattern  539\nBeat model  529, 549\u2013552\nComposite Pattern  526\u2013527, 543\ncontrollers per view  543\nHeart controller  541, 561\nHeart model  539, 558\u2013560\nimplementing controller  536\u2013537, 556\u2013557\nimplementing DJ View  528\u2013535, 553\u2013556\nMediator Pattern  543\nmodel in  543\nObserver Pattern  526\u2013527, 531\u2013533\nsong  520\u2013521\nstate of model  543\nStrategy Pattern  526\u2013527, 536\u2013537, 539, 558\u2013560\ntesting  538\nviews accessing model state methods  543\nmultiple patterns vs.  516\nconcrete classes\nderiving from  143\nFactory Pattern and  134\ngetting rid of  116", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 657", "position": 657, "chunk_type": "semantic", "token_estimate": 310}
{"text": "620\u2003 \u2003 Index: the index\ninstantiating objects and  138\nusing new operator for instantiating  110\u2013113\nvariables holding reference to  143\nconcrete creators  135\nconcrete implementation object, assigning,  12\nconcrete methods, as hooks  293\u2013295\nconcrete subclasses  121\u2013122, 297\nConsequences section, in pattern catalog  571\ncontrolling object access, using Proxy Pattern\nabout  426\u2013428\nCaching Proxy  466, 482\nComplexity Hiding Proxy  483\nCopy-On-Write Proxy  483\nFirewall Proxy  482\nProtection Proxy\nabout  469\ncreating dynamic proxy  474\u2013478\nimplementing matchmaking service  471\u2013472\nprotecting subjects  473\ntesting matchmaking service  479\u2013480\nusing dynamic proxy  469\u2013470\nRemote Proxy\nabout  429\nadding to monitoring code  432\npreparing for remote service  446\u2013447\nregistering with RMI registry  448\nreusing client for  449\nreviewing process  453\u2013455\nrole of  430\u2013431\ntesting  450\u2013452\nwrapping objects and  468\nSmart Reference Proxy  482\nSynchronization Proxy  483\nVirtual Proxy\nabout  457\ndesigning Virtual Proxy  459\nreviewing process  465\ntesting  464\nwriting Image Proxy  460\u2013463\nCopy-On-Write Proxy  483\ncreate method\nreplacing new operator with  116\nstatic method vs.  115\nusing subclasses with  121\u2013122\ncreating static classes instead of Singleton  179\u2013180\ncreational patterns category, Design Patterns  576, \n578\u2013579\ncreator classes, in Factory Method Pattern  131\u2013132, \n134\u2013135\ncrossword puzzle  33, 74, 163, 187, 234, 273, 311, 374, \n484\nCunningham, Ward  589\nD\nDecorator Pattern\nabout  88\u201390, 104\nAdapter Pattern vs.  254\u2013255\ncombining patterns  500\u2013501\ndefined  91\ndisadvantages of  101\nexercises for  256, 275, 481, 574, 596\nin Java I/O  100\u2013101\nin Structural patterns category  577\ninterview with  104\nProxy Pattern vs.  466\u2013468\nStarbuzz Coffee project\nabout  80\u201381\nadding sizes to code  99\nconstructing drink orders  89\u201390\ndrawing beverage order process  94, 107\ntesting order code  98\u201399\nwriting code  95\u201397\ndecoupling, Iterator allowing  333, 337, 339, 351\u2013352\ndelegation, adding behavior at runtime  85\ndependence, in Observer Pattern  52\nDependency Inversion Principle (DIP)  139\u2013143, 300\ndependency rot  298\ndepend upon abstractions design principle  139\nDesign Patterns\nbecoming writer of  573\nbehavioral patterns category  576, 578\u2013579\ncategories of  576\u2013579\nclass patterns  577\ncreational patterns category  576, 578\u2013579\ndefined  565\u2013567\ndiscovering own  572\nexercise matching description of  596", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 658", "position": 658, "chunk_type": "semantic", "token_estimate": 333}
{"text": "you are here 4\u2003 \u2003 621: the index\nframeworks vs.  29\nguide to better living with  564\nimplement on interface in  117\nlibraries vs.  29\nobject patterns  577\norganizing  575\noverusing  584\nresources for  588\u2013589\nrule of three applied to  573\nstructural patterns category  576, 578\u2013579\nthinking in patterns  580\u2013581\nusing  29, 582, 584\nyour mind on patterns  583\nDesign Patterns- Reusable Object-Oriented Software \n(Gamma et al.) 588\ndesign principles\nDependency Inversion Principle  139\u2013143\ndepend upon abstractions  139\nEncapsulate what varies  9, 73, 75, 136, 393\nFavor composition over inheritance  23, 73, 75, 393\nThe Hollywood Principle  298\u2013300\nOne Class, One Responsibility Principle  184, 340, \n371\none instance. See\u00a0Singleton Pattern\nOpen-Closed Principle  355, 392\nPrinciple of Least Knowledge  267\u2013271\nProgram to an interface, not an implementation  \n11\u201312, 73, 75\u201376, 337\nSingle Responsibility Principle (SRP)  340\u2013341\nusing Observer Pattern  73, 75\nDesign Puzzles\ndrawing class diagram making use of view and con\u00ad\ntroller  536, 548\ndrawing parallel set of classes  133, 165\ndrawing state diagram  391, 420\nof classes and interfaces  25, 34\nredesigning classes to remove redundancy  281, \n278\u2013283\nredesigning Image Proxy  463, 486\ndessert submenu, using Composite Pattern\nabout  357\ndesigning  363, 371\nimplementing  364\u2013367\ntesting  368\u2013370\ndiner menus, merging (Iterator Pattern)\nabout  318\u2013319\nadding Iterators  328\u2013334\ncleaning up code using java.util.Iterator  335\u2013337\nencapsulating Iterator  325\u2013326\nimplementing Iterators for  327\nimplementing of  320\u2013325\nDIP (Dependency Inversion Principle)  139\u2013143, 300\nDJ View  528\u2013535, 549\u2013561\nDomain-Specific Patterns  590\ndouble-checked locking, reducing use of synchronization \nusing  182\nDuck Magnets exercises, object and class object and class \nadapters  247\u2013248\nduck simulator, rebuilding\nabout  495\u2013497\nadding Abstract Factory Pattern  502\u2013505, 548\nadding Adapter Pattern  498\u2013499\nadding Composite Pattern  507\u2013509\nadding Decorator Pattern  500\u2013501\nadding Iterator Pattern  507\nadding Observer Pattern  510\u2013516\nclass diagram  518\u2013519\ndumb command objects  228\ndynamic aspect of dynamic proxies  480\ndynamic proxy  469\u2013470, 474\u2013478\nE\nEncapsulate what varies design principle  9, 73, 75, 136, \n393\nencapsulating\nbehavior  11\ncode  22\u201323, 114\u2013115, 136\niteration  325\u2013326\nmethod invocation  191, 206\nobject construction  600\nrequests  206\nencapsulating algorithms\nabout  277\nabstracting prepareRecipe()  284\u2013287\nTemplate Method Pattern and\nabout  288\u2013290\nAbstractList and  309\ncode up close  292\u2013293\ndefined  291\nThe Hollywood Principle and  298\u2013300", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 659", "position": 659, "chunk_type": "semantic", "token_estimate": 360}
{"text": "622\u2003 \u2003 Index: the index\nhooks in  293\u2013295\nin real world  301\nsorting with  302\u2013307\nSwing and  308\ntesting code  296\nencapsulating subsystem, Facades  262\nEnumeration\nabout  250\nadapting to Iterator  251\njava.util.Enumeration as older implementation of \nIterator  250, 342\nremove() method and  252\nwriting Adapter that adapts Iterator to  253, 275\nexercises\nBe the JVM solution, dealing with multithreading  \n179\u2013180, 188\nCode Magnets\nfor DinerMenu Iterator  354, 378\nfor Observer Pattern  70, 76\ndealing with multithreading  247\u2013248\nDesign Puzzles\ndrawing class diagram making use of view and \ncontroller  536, 548\ndrawing parallel set of classes  133, 165\ndrawing state diagram  391, 420\nof classes and interfaces  25, 34\nredesigning classes to remove redundancy  281\u2013\n282\nredesigning Image Proxy  463, 486\nDuck Magnets exercises, object and class object and \nclass adapters  247\nimplementing Iterator  329\nimplementing undo button for macro command  228, \n236\nSharpen Your Pencil\naltering decorator classes  99, 108\nannotating Gumball Machine states  405, 423\nannotating state diagram  396, 422\nbuilding ingredient factory  148, 167\nchanging classes for Decorator Pattern  512, 546\nchanging code to fit framework in Iterator Pattern  \n347, 377\nchoosing descriptions of state of implementation  \n392, 421\nclass diagram for implementation of prepareR\u00ad\necipe()  286, 314\ncode not using factories  137, 166\ncreating commands for off buttons  226, 236\ncreating heat index  62\ndetermining classes violating Principle of Least \nKnowledge  270, 274\ndrawing beverage order process  107\nfixing Chocolate Boiler code  183, 190\nidentifying factors influencing design  84\nimplementing garage door command  205, 235\nimplementing state classes  402, 421\nmaking pizza store  124, 164\nmatching patterns with categories  575\u2013577\nmethod for refilling gumball machine  417, 424\non adding behaviors  14\non implementation of printmenu()  324, 377\non inheritance  5, 35\nsketching out classes  55\nthings driving change  8, 35\nturning class into Singleton  176, 189\nweather station SWAG  42, 75\nwriting Abstract Factory Pattern  505, 548\nwriting classes for adapters  244, 274\nwriting dynamic proxy  478, 487\nwriting Flock observer code  514, 547\nwriting methods for classes  83, 106\nWho Does What\nmatching objects and methods to Command Pat\u00ad\ntern  202, 235\nmatching patterns with its intent  256, 275\nmatching pattern with description  300, 314, 375, \n379, 418, 424, 481, 488, 574, 596\nwriting Adapter that adapts Iterator to Enumeration  \n253, 275\nwriting handler for matchmaking service  477, 486\nexternal iterators  342\nF\nFacade Pattern\nabout  256\nAdapter Pattern vs.  262\nadvantages  262", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 660", "position": 660, "chunk_type": "semantic", "token_estimate": 397}
{"text": "you are here 4\u2003 \u2003 623: the index\nbenefits of  262\nbuilding home theater system\nabout  257\u2013259\nconstructing Facade in  263\nimplementing Facade class  260\u2013262\nimplementing interface  264\nclass diagram  266\nComplexity Hiding Proxy vs.  483\ndefined  266\nexercises for  256, 275, 375, 379, 481, 574, 596\nPrinciple of Least Knowledge and  271\nfactory method\nabout  125, 134\nas abstract  135\ndeclaring  125\u2013127\nFactory Method Pattern\nabout  131\u2013132\nabout factory objects  114\nAbstract Factory Pattern and  158\u2013161\ncode up close  151\nconcrete classes and  134\ncreator classes  131\u2013132\ndeclaring factory method  125\u2013127\ndefined  134\nDependency Inversion Principle  139\u2013143\ndrawing parallel set of classes  133, 165\nexercise matching description of  574, 596\ninterview with  158\u2013159\nlooking at object dependencies  138\nproduct classes  131\u2013132\nSimple Factory and  135\nFactory Pattern\nAbstract Factory\nabout  153\nbuilding ingredient factories  146\u2013148, 167\ncombining patterns  502\u2013505, 548\ndefined  156\u2013157\nexercise matching description of  574, 596\nFactory Method Pattern and  158\u2013160\nimplementing  158\nexercise matching description of  300, 314\nFactory Method\nabout  131\u2013132\nadvantages of  135\ncode up close  151\ncreator classes  131\u2013132\ndeclaring factory method  125\u2013127\ndefined  134\nDependency Inversion Principle  139\u2013143\ndrawing parallel set of classes  133, 165\nexercise matching description of  574, 596\nlooking at object dependencies  138\nproduct classes  131\u2013132\nSimple Factory and  135\nSimple Factory\nabout factory objects  114\nbuilding factory  115\ndefined  117\nFactory Method Pattern and  135\npattern honorable mention  117\nusing new operator for instantiating concrete \nclasses  110\u2013113\nFavor composition over inheritance design principle  23, \n73, 75, 393\nFireside Chat\nDecorator Pattern vs. Adapter Pattern  254\u2013255\nStrategy Pattern vs. State Pattern  414\u2013415\nFirewall Proxy  482\nFlyweight Pattern  604\u2013605\nforces  568\nfor loop  344\nframeworks vs. libraries  29\nG\nGamma, Erich  587\u2013588\nGang of Four (GoF)  569, 587\u2013588\nglobal access point  177\nglobal variables, Singleton vs.  184\nguide to better living with Design Patterns  564\ngumball machine controller implementation, using State \nPattern\ncleaning up code  413\ndemonstration of  411\u2013412\ndiagram to code  384\u2013385\nfinishing  410\none in ten contest\nabout  390\u2013391\nannotating state diagram  396, 422\nchanging code  392\u2013393", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 661", "position": 661, "chunk_type": "semantic", "token_estimate": 338}
{"text": "624\u2003 \u2003 Index: the index\ndrawing state diagram  391, 420\nimplementing state classes  397, 400\u2013405, 409\nnew design  394\u2013396\nreworking state classes  398\u2013399\nrefilling gumball machine  416\u2013417\nSoldState and WinnerState in  412\ntesting code  388\u2013389\nwriting code  386\u2013387\ngumball machine monitoring, using Proxy Patterns\nabout  426\u2013428\nRemote Proxy\nabout  429\nadding to monitoring code  432\npreparing for remote service  446\u2013447\nregistering with RMI registry  448\nreusing client for  449\nreviewing process  453\u2013454\nrole of  430\u2013431\ntesting  450\u2013452\nwrapping objects and  468\nH\nHAS-A relationships  23, 91\nHashMap  348, 352, 353\nhasNext() method  328, 342, 344\nHead First learning principles  xxviii\nHelm, Richard  587\u2013588\nhigh-level component classes  139\nThe Hollywood Principle  298\u2013300\nhome automation remote control, using Command Pattern\nabout  193\nbuilding  203\u2013205, 235\nclass diagram  207\ncreating commands to be loaded  208\u2013209\ndefining  206\ndesigning  195\u2013196\nimplementing  210\u2013212\nmacro commands\nabout  225\nhard coding vs.  228\nundo button  228, 236\nusing  226\u2013227\nmapping  201\u2013202, 235\nNull Object  214\ntesting  204, 212\u2013213, 227\nundo commands\ncreating  217\u2013219, 228\nimplementing for macro command  236\ntesting  220, 223\u2013224\nusing state to implement  221\nvendor classes for  194\nwriting documentation  215\nhome theater system, building\nabout  257\u2013259\nconstructing Facade in  263\nimplementing interface  264\nSharpen Your Pencil  270\nusing Facade Pattern  260\u2013262\nhooks, in Template Method Pattern  293\u2013295\nI\nImage Proxy, writing  460\u2013463\nimplementations  13, 17, 43\nImplementation section, in pattern catalog  571\nimplement on interface, in design patterns  117\nimport and package statements  128\ninheritance\ncomposition vs.  93\ndisadvantages of  5, 85\nfavoring composition over  23\nfor maintenance  4\nfor reuse  4, 13\nimplementing multiple  246\ninstance variables  82\u201383, 97\u201398\ninstantiating  110\u2013113, 138, 170\u2013172\nintegrating Caf\u00e9 Menu, using Iterator Pattern  347\nIntent section, in pattern catalog  571\ninterface  11\u201312, 110\u2013113\ninterface type  15, 18\ninternal iterators  342\nInterpreter Pattern  606\u2013607\nInterview With\nComposite Pattern  372\u2013373\nDecorator Pattern  104", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 662", "position": 662, "chunk_type": "semantic", "token_estimate": 304}
{"text": "you are here 4\u2003 \u2003 625: the index\nFactory Method Pattern and Abstract Factory Pattern  \n158\u2013159\nSingleton Pattern  174\ninversion, in Dependency Inversion Principle  141\ninvoker  201, 206\u2013207, 209, 233\nIS-A relationships  23\nIterable interface  343\nIterator Pattern\nabout  327\nclass diagram  339\ncode up close using HashMap  348\ncode violating Open-Closed Principle  355\u2013356\nCollections and  353\ncombining patterns  507\ndefined  338\u2013339\nexercise matching description of  375, 379, 574, 596\nintegrating Caf\u00e9 Menu  347\njava.util.Iterator  334\nmerging diner menus\nabout  318\u2013319\nadding Iterators  328\u2013334\ncleaning up code using java.util.Iterator  335\u2013337\nencapsulating Iterator  325\u2013326\nimplementing Iterators for  327\nimplementing of  320\u2013325\nremoving objects  334\nSingle Responsibility Principle (SRP)  340\u2013341\nIterators\nadding  328\u2013334\nallowing decoupling  333, 337, 339, 351\u2013352\ncleaning up code using java.util.Iterator  335\u2013337\nCollections and  353\nencapsulating  325\u2013326\nEnumeration adapting to  251, 342\nexternal  342\nHashMap and  353\nimplementing  327\ninternal  342\nordering of  342\npolymorphic code using  338, 342\nusing ListItterator  342\nwriting Adapter for Enumeration  252\u2013253\nwriting Adapter that adapts to Enumeration  253, 275\nJ\nJavaBeans library  65\nJava Collections Framework  353\nJava decorators (java.io packages)  100\u2013103\nJava Development Kit (JDK)  65\nJava Iterable interface  343\njava.lang.reflect package, proxy support in  440, 469, 476\njava.util.Collection  353\njava.util.Enumeration, as older implementation of Iterator \n \n250, 342\njava.util.Iterator\ncleaning up code using  335\u2013337\ninterface of  334\nusing  342\nJava Virtual Machines (JVMs)  182, 432\nJButton class  65\nJFrames, Swing  308\nJohnson, Ralph  587\u2013588\nK\nKeep It Simple (KISS), in designing patterns  580\nKnown Uses section, in pattern catalog  571\nL\nlambda expressions  67\nLaw of Demeter. See\u00a0Principle of Least Knowledge\nlazy instantiation  177\nleaves, in Composite Pattern tree structure  360\u2013362, 368\nlibraries  29\nLinkedList  352\nListItterator  342\nlogging requests, using Command Pattern  230\nlooping through array items  323\nLoose Coupling Principle  54", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 663", "position": 663, "chunk_type": "semantic", "token_estimate": 291}
{"text": "626\u2003 \u2003 Index: the index\nM\nmacro commands\nabout  225\nmacro commands  228, 236\nusing  226\u2013227\nmaintenance, inheritance for,  4\nmatchmaking service, using Proxy Pattern\nabout  470\ncreating dynamic proxy  474\u2013478\nimplementing  471\u2013472\nprotecting subjects  473\ntesting  479\u2013480\nMediator Pattern  543, 608\u2013609\nMemento Pattern  610\u2013611\nmerging diner menus (Iterator Pattern)\nabout  318\u2013319\nadding Iterators  328\u2013334\ncleaning up code using java.util.Iterator  335\u2013337\nencapsulating Iterator  325\u2013326\nimplementing Iterators for  327\nimplementing of  320\u2013325\nmethod of objects, components of object vs.  267\u2013271\nmethods  143, 293\u2013295\nmodeling state  384\u2013385\nModel-View-Controller (MVC)\nabout  520\u2013521, 523\u2013525\nAdapter Pattern  540\nBeat model  529, 549\u2013552\nComposite Pattern  526\u2013527, 543\ncontrollers per view  543\nHeart controller  541, 561\nHeart model  539\nimplementing controller  536\u2013537, 556\u2013557\nimplementing DJ View  528\u2013535, 553\u2013556\nMediator Pattern  543\nmodel in  543\nObserver Pattern  526\u2013527, 531\u2013533\nsong  520\u2013521\nstate of model  543\nStrategy Pattern  526\u2013527, 536\u2013537, 539, 558\u2013560\ntesting  538\nviews accessing model state methods  543\nMotivation section, in pattern catalog  571\nmultiple patterns, using\nabout  493\u2013494\nin duck simulator\nabout rebuilding  495\u2013497\nadding Abstract Factory Pattern  502\u2013505, 548\nadding Adapter Pattern  498\u2013499\nadding Composite Pattern  507\u2013509\nadding Decorator Pattern  500\u2013501\nadding Iterator Pattern  507\nadding Observer Pattern  510\u2013516\nclass diagram  518\u2013519\nmultithreading  181\u2013182, 188\nN\nName section, in pattern catalog  571\nnew operator\nrelated to Singleton Pattern  171\u2013172\nreplacing with concrete method  116\nnext() method  328, 342, 344\nNoCommand, in remote control code  214\nnodes, in Composite Pattern tree structure  360\u2013362, 368\nNull Objects  214\nO\nobject access, using Proxy Pattern for controlling\nabout  426\u2013428\nCaching Proxy  466, 482\nComplexity Hiding Proxy  483\nCopy-On-Write Proxy  483\nFirewall Proxy  482\nProtection Proxy\nabout  469\ncreating dynamic proxy  474\u2013478\nimplementing matchmaking service  471\u2013472\nprotecting subjects  473\ntesting matchmaking service  479\u2013480\nusing dynamic proxy  469\u2013470\nRemote Proxy\nabout  429\nadding to monitoring code  432\npreparing for remote service  446\u2013447\nregistering with RMI registry  448", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 664", "position": 664, "chunk_type": "semantic", "token_estimate": 306}
{"text": "you are here 4\u2003 \u2003 627: the index\nreusing client for  449\nreviewing process  453\u2013454\nrole of  430\u2013431\ntesting  450\u2013452\nwrapping objects and  468\nSmart Reference Proxy  482\nSynchronization Proxy  483\nVirtual Proxy\nabout  457\ndesigning Virtual Proxy  459\nreviewing process  465\ntesting  464\nwriting Image Proxy  460\u2013463\nobject adapters vs. class adapters  246\u2013249\nobject construction, encapsulating  600\nobject creation, encapsulating  114\u2013115, 136\nObject-Oriented (OO) design. See also\u00a0design principles\nadapters\nabout  238\u2013239\ncreating Two Way Adapters  244\nin action  240\u2013241, 242\nobject and class object and class  246\u2013249\ndesign patterns vs.  30\u201331\nextensibility and modification os code in  87\nguidelines for avoiding violation of Dependency Inver\u00ad\nsion Principle  143\nloosely coupled designs and  54\nobject patterns, Design Patterns  577\nobjects\ncomponents of  267\u2013271\ncreating  134\nloosely coupled designs between  54\nsharing state  408\nSingleton  171, 174\nwrapping  88, 244, 254, 262, 502\nObserver Pattern\nabout  37, 44\nclass patterns category  574\ncombining patterns  510\u2013516\ncomparison to Publish-Subscribe  45\ndependence in  52\nexamples of  65\nexercise matching description of  375, 379, 596\nin Five-minute drama  48\u201350\nin Model-View-Controller  526\u2013527, 531\u2013533\nloose coupling in  54\nObserver object in  45\none-to-many relationships  51\u201352\nprocess  46\u201347\nSubject object in  45\nweather station using\nbuilding display elements  60\ndesigning  57\nimplementing  58\npowering up  61", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 665", "position": 665, "chunk_type": "semantic", "token_estimate": 210}
{"text": "observers: in class diagram  52\nin Five-minute drama  48\u201350\nin Observer Pattern  45\nOCP (Open-Closed Principle)  355, 392\nOne Class, One Responsibility Principle. See\u00a0Single Re\u00ad\nsponsibility Principle (SRP)\none in ten contest in gumball machine, using State Pattern\nabout  390\u2013391\nannotating state diagram  396, 422\nchanging code  392\u2013393\ndrawing state diagram  391, 420\nimplementing state classes  397, 400\u2013405, 409\nnew design  394\u2013396\nreworking state classes  398\u2013399\nOO (Object-Oriented) design. See\u00a0Object-Oriented (OO) \ndesign\nOpen-Closed Principle (OCP)  355, 392\nOrganizational Patterns  591\noverusing Design Patterns  584\nP\npackage and import statements  128\nParticipants section, in pattern catalog  571\npart-whole hierarchy  360\npattern catalogs  567, 569\u2013572\nPattern Death Match pages  493\nA Pattern Language (Alexander)  588\npatterns, using compound  493\u2013494", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 665", "position": 665, "chunk_type": "semantic", "token_estimate": 119}
{"text": "628\u2003 \u2003 Index: the index\npatterns, using multiple\nabout  493\nin duck simulator\nabout rebuilding  495\u2013497\nadding Abstract Factory Pattern  502\u2013505, 548\nadding Adapter Pattern  498\u2013499\nadding Composite Pattern  507\u2013509\nadding Decorator Pattern  500\u2013501\nadding Iterator Pattern  507\nadding Observer Pattern  510\u2013516\nclass diagram  518\u2013519\npattern templates, uses of  573\nPizza Store project, using Factory Pattern\nAbstract Factory in  153, 156\u2013157\nbehind the scenes  154\u2013155\nbuilding factory  115\nconcrete subclasses in  121\u2013122\ndrawing parallel set of classes  133, 165\nencapsulating object creation  114\u2013115\nensuring consistency in ingredients  144\u2013148, 167\nframework for  120\nfranchising store  118\u2013119\nidentifying aspects in  112\u2013113\nimplementing  142\nmaking pizza store in  123\u2013124\nordering pizza  128\u2013132\nreferencing local ingredient factories  152\nreworking pizzas  149\u2013151\npolymorphic code, using on iterator  338, 342\npolymorphism  12\nprepareRecipe(), abstracting  284\u2013287\nPrinciple of Least Knowledge  267\u2013271. See also\u00a0Single \nResponsibility Principle (SRP)\nprint() method, in dessert submenu using Composite Pat\u00ad\ntern  364\u2013367\nprogramming  12\nProgram to an interface, not an implementation design \nprinciple  11\u201312, 73, 75\u201376, 337\nprogram to interface vs. program to supertype  12\nProtection Proxy\nabout  469\ncreating dynamic proxy  474\u2013478\nimplementing matchmaking service  471\u2013472\nprotecting subjects  473\nProxy Pattern and  466\ntesting matchmaking service  479\u2013480\nusing dynamic proxy  469\u2013470\nPrototype Pattern  612\u2013613\nproxies  425\nProxy class, identifying class as  480\nProxy Pattern\nAdapter Pattern vs.  466\nComplexity Hiding Proxy  483\nCopy-On-Write Proxy  483\nDecorator Pattern vs.  466\u2013468\ndefined  455\u2013456\ndynamic aspect of dynamic proxies  480\nexercise matching description of  481, 574, 596\nFirewall Proxy  482\nimplementation of Remote Proxy\nabout  429\nadding to monitoring code  432\npreparing for remote service  446\u2013447\nregistering with RMI registry  448\nreusing client for  449\nreviewing process  453\u2013454\nrole of  430\u2013431\ntesting  450\u2013452\nwrapping objects and  468\njava.lang.reflect package  440, 469, 476\nProtection Proxy and\nabout  469\nAdapters and  466\ncreating dynamic proxy  474\u2013478\nimplementing matchmaking service  471\u2013472\nprotecting subjects  473\ntesting matchmaking service  479\u2013480\nusing dynamic proxy  469\u2013470\nReal Subject\nas surrogate of  466\ninvoking method on  475\nmaking client use Proxy instead of  466\npassing in constructor  476\nreturning proxy for  478\nrestrictions on passing types of interfaces  480\nSmart Reference Proxy  482\nSynchronization Proxy  483\nvariations  466, 482\u2013483", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 666", "position": 666, "chunk_type": "semantic", "token_estimate": 356}
{"text": "you are here 4\u2003 \u2003 629: the index\nVirtual Proxy\nabout  457\nCaching Proxy as form of  466, 482\ndesigning  459\nreviewing process  465\ntesting  464\nwriting Image Proxy  460\u2013463\nPublish-Subscribe, as Observer Pattern  45\nQ\nqueuing requests, using Command Pattern  229\nR\nReal Subject\nas surrogate of Proxy Pattern  466\ninvoking method on  475\nmaking client use proxy instead of  466\npassing in constructor  476\nreturning proxy for  478\nrefactoring  358, 581\nRelated patterns section, in pattern catalog  571\nrelationships, between classes  22\nRemote Method Invocation (RMI)\nabout  432\u2013433, 436\ncode up close  442\ncompleting code for server side  441\u2013444\nimporting java.rmi  446\nimporting packages  447, 449\nmaking remote service  437\u2013441\nmethod call in  434\u2013435\nregistering with RMI registry  448\nthings to watch out for in  444\nRemote Proxy\nabout  429\nadding to monitoring code  432\npreparing for remote service  446\u2013447\nregistering with RMI registry  448\nreusing client for  449\nreviewing process  453\u2013454\nrole of  430\u2013431\ntesting  450\u2013452\nwrapping objects and  468\nremove() method\nEnumeration and  252\nin collection of objects  334\nin java.util.Iterator  342\nrequests, encapsulating  206\nresources, Design Patterns  588\u2013589\nreuse  4, 85\nrule of three, applied to inventing Design Patterns  573\nruntime errors, causes of  135\nS\nSample code section, in pattern catalog  571\nserver heap  433\u2013436\nservice helper (skeletons), in RMI  436\u2013437, 440, 442\u2013\n444, 453\u2013454\nshared vocabulary  26\u201327, 28, 585\u2013586\nSharpen Your Pencil\naltering decorator classes  99, 108\nannotating Gumball Machine States  405, 423\nannotating state diagram  396, 422\nbuilding ingredient factory  148, 167\nchanging classes for Decorator Pattern  512, 546\nchanging code to fit framework in Iterator Pattern  \n347, 377\nchoosing descriptions of state of implementation  392, \n421\nclass diagram for implementation of prepareRecipe()  \n286, 314\ncode not using factories  137, 166\ncreating commands for off buttons  226, 236\ncreating heat index  62\ndetermining classes violating Principle of Least \nKnowledge  270, 274\ndrawing beverage order process  107\nfixing Chocolate Boiler code  183, 190\nidentifying factors influencing design  84\nimplementing garage door command  205, 235\nimplementing state classes  402, 421\nmaking pizza store  124, 164\nmatching patterns with categories  575\u2013577\nmethod for refilling gumball machine  417, 424\non adding behaviors  14\non implementation of printmenu()  324, 377", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 667", "position": 667, "chunk_type": "semantic", "token_estimate": 362}
{"text": "630\u2003 \u2003 Index: the index\non inheritance  5, 35\nsketching out classes  55\nthings driving change  8, 35\nturning class into Singleton  176, 189\nweather station SWAG  42, 75\nwriting Abstract Factory Pattern  505, 548\nwriting classes for adapters  244, 274\nwriting dynamic proxy  478, 487\nwriting Flock observer code  514, 547\nwriting methods for classes  83, 106\nSimple Factory Pattern\nabout factory objects  114\nbuilding factory  115\ndefinition of  117\nFactory Method Pattern and  135\npattern honorable mention  117\nusing new operator for instantiating concrete classes  \n110\u2013113\nSingle Responsibility Principle (SRP)  184, 340\u2013341, 371\nSingleton objects  171, 174\nSingleton Pattern\nabout  169\u2013172\nadvantages of  170\nChocolate Factory  175\u2013176, 183\nclass diagram  177\ncode up close  173\ndealing with multithreading  179\u2013182, 188\ndefined  177\ndisadvantages of  184\ndouble-checked locking  182\nexercise matching description of  574\nglobal variables vs.  184\nimplementing  173\ninterview with  174\nOne Class, One Responsibility Principle and  184\nsubclasses in  184\nusing  184\nskeletons (service helper), in RMI  436\u2013437, 440, 442\u2013\n444, 453\u2013454\nsmart command objects  228\nSmart Reference Proxy  482\nsoftware development, change as a constant in  8\nsorting methods, in Template Method Pattern  302\u2013307\nsort() method  306\u2013311\nspliterator method  343\nSRP (Single Responsibility Principle)  184, 340\u2013341, 371\nStarbuzz Coffee Barista training manual project\nabout  278\u2013283\nabstracting prepareRecipe()  284\u2013287\nusing Template Method Pattern\nabout  288\u2013290\ncode up close  292\u2013293\ndefined  291\nThe Hollywood Principle and  298\u2013300\nhooks in  293\u2013295\ntesting code  296\nStarbuzz Coffee project, using Decorator Pattern\nabout  80\u201381\nadding sizes to code  99\nconstructing drink orders  89\u201390\ndrawing beverage order process  94, 107\ntesting order code  98\u201399\nwriting code  95\u201397\nstate machines  384\u2013385\nState Pattern\ndefined  406\nexercise matching description of  418, 424, 574, 596\ngumball machine controller implementation\ncleaning up code  413\ndemonstration of  411\u2013412\ndiagram to code  384\u2013385\nfinishing  410\nrefilling gumball machine  416\u2013417\nSoldState and WinnerState in  412\ntesting code  388\u2013389\nwriting code  386\u2013387\nincreasing number of classes in design  408\nmodeling state  384\u2013385\none in ten contest in gumball machine\nabout  390\u2013391\nannotating state diagram  396, 422\nchanging code  392\u2013393\ndrawing state diagram  391, 420\nimplementing state classes  397, 400\u2013405, 409\nnew design  394\u2013396\nreworking state classes  398\u2013399\nsharing state objects  408\nstate transitions in state classes  408\nStrategy Pattern vs.  381, 407, 414\u2013415\nstate transitions, in state classes  408", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 668", "position": 668, "chunk_type": "semantic", "token_estimate": 379}
{"text": "you are here 4\u2003 \u2003 631: the index\nstate, using to implement undo commands  221\nstatic classes, using instead of Singletons  184\nstatic method vs. create method  115\nStrategy Pattern\nalgorithms and  24\ndefined  24\nexercise matching description of  300, 314, 375, 379, \n418, 424, 574, 596\nin Model-View-Controller  526\u2013527, 536\u2013537, 539\nState Pattern vs.  381, 407, 414\u2013415\nTemplate Method Pattern and  307\nstrive for loosely coupled designs between objects that in\u00ad\nteract design principle  54. See also\u00a0Loose Coupling \nPrinciple\nstructural patterns category, Design Patterns  576, \n578\u2013579\nStructure section, in pattern catalog  571\nstubs (client helper), in RMI  436\u2013437, 440, 442\u2013444, \n453\u2013454\nsubclasses\nconcrete commands and  207\nconcrete states and  406\nexplosion of classes  81\nFactory Method and, letting subclasses decide which \nclass to instantiate  134\nin Singletons  184\nPizza Store concrete  121\u2013122\nTemplate Method  288\ntroubleshooting  4\nSubject\nin class diagram  52\nin Five-minute drama  48\u201350\nin Observer Pattern  45\u201347\nsubsystems, Facades and  262\nsuperclasses  4, 12\nsupertype (programming to interface), vs. programming to \ninterface  12\nSwing library  65, 308, 543\nsynchronization, as overhead  180\nSynchronization Proxy  483\nT\nTemplate Method Pattern\nabout  288\u2013290\nabstract class in  292, 293, 297\napplets in  309\nclass diagram  291\ncode up close  292\u2013293\ndefined  291\nexercise matching description of  300, 314, 418, 424, \n574, 596\nThe Hollywood Principle and  298\u2013300\nhooks in  293\u2013295, 297\nin real world  301\nsorting with  302\u2013307\nStrategy Pattern and  307\nSwing and  308\ntesting code  296\nthinking in patterns  580\u2013581\ntightly coupled  54\nThe Timeless Way of Building (Alexander)  588\ntransparency, in Composite Pattern  371\ntree structure, Composite Pattern  360\u2013362, 368\nTwo Way Adapters, creating  244\ntype safe parameters  135\nU\nundo commands\ncreating  217\u2013219, 228\nimplementing for macro command  228\nsupport of  217\ntesting  220, 223\u2013224\nusing state to implement  221\nUser Interface Design Patterns  591\nV\nvariables\ndeclaring behavior  15\nholding reference to concrete class  143\ninstance  82\u201383, 97\u201398", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 669", "position": 669, "chunk_type": "semantic", "token_estimate": 314}
{"text": "632\u2003 \u2003 Index: the index\nVector  352\nVirtual Proxy\nabout  457\nCaching Proxy as form of  466, 482\ndesigning  459\nreviewing process  465\ntesting  464\nwriting Image Proxy  460\u2013463\nVisitor Pattern  614\u2013615\nVlissides, John  587\u2013588\nvolatile keyword  182\nW\nweather station\nbuilding display elements  60\ndesigning  57\nimplementing  58\npowering up  61\nWho Does What exercises\nmatching objects and methods to Command Pattern  \n202, 235\nmatching patterns with its intent  256, 275\nmatching pattern with description  300, 314, 375, 379, \n418, 424, 481, 488, 574, 596\nwhole-part relationships, collection of objects using  372\nWickedlysmart website  xxxiii\nwrapping objects  88, 244, 254, 262, 468, 502\nY\nyour mind on patterns design pattern  583", "domains": ["Design Patterns"], "source": "[O`Reilly. Head First] - Head First Design Patterns 2nd Edition - [Freeman].pdf", "section": "Page 670", "position": 670, "chunk_type": "semantic", "token_estimate": 111}
