{"text": "Software Architecture: and Design Illuminated\n \nKai Qian\nSouthern Polytechnic\nState University\nChong-wei Xu\nKennesaw State\nUniversity\nXiang Fu\nHofstra\nUniversity\nJorge L. D\u00edaz-Herrera\nRochester Institute\nof Technology\nLixin Tao\nPace\nUniversity", "domains": ["Design Patterns"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 3", "position": 3, "chunk_type": "semantic", "token_estimate": 31}
{"text": "Contents: Preface\n \nChapter 1 Introduction to Software Architecture\n \n1.1 Overview\n \n1.2 Software Architecture: Bridging Requirements and Implementation\n \n1.3 Architecture Styles\n \n1.4 Quality Attributes\n \n1.5 Software Architecture Design Guidelines\n \n1.6 Summary\n \n1.7 Self-Review Questions\n \nChapter 2 Software Architecture Design Space\n \n2.1 Overview\n \n2.2 Types of Software Structures\n \n2.2.1 Software Static Structure\n \n2.2.2 Software Runtime Structure\n \n2.2.3 Software Management Structure\n \n2.3 Software Elements\n \n2.4 Software Connectors\n \n2.5 An Agile Approach to Software Architecture Design\n \n2.6 Summary\n \n2.7 Self-Review Questions\n \n2.8 Exercises\n \n2.9 Design Exercises\n \nChapter 3 Models for Software Architecture\n \n3.1 Overview\n \n3.2 UML for Software Architecture\n \n3.2.1 Structural Diagrams\n \n3.2.2 Behavioral Diagrams\n \n3.3 Architecture View Models", "domains": ["Design Patterns"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 5", "position": 5, "chunk_type": "semantic", "token_estimate": 105}
{"text": "3.3.1 The Scenario View: 3.3.2 The Logical or Conceptual View\n \n3.3.3 The Development or Module View\n \n3.3.4 The Process View\n \n3.3.5 The Physical View\n \n3.3.6 The User Interface View\n \n3.4 Architecture Description Languages (ADL)\n \n3.5 Summary\n \n3.6 Self-Review Questions\n \n3.7 Exercises\n \n3.8 Design Exercises\n \n3.9 Challenge Exercises\n \nChapter 4 Object-Oriented Paradigm\n \n4.1 Overview\n \n4.2 Introducing the Object-Oriented Paradigm\n \n4.2.1 Classes and Objects\n \n4.2.2 Relationships\n \n4.3 OO Analysis\n \n4.3.1 Step 1: Design of a UML Use Case Diagram\n \n4.3.2 Step 2: Develop an Analysis Class Diagram via Noun Extraction\n \n4.4 OO Design\n \n4.4.1 Step 1: Identify Classes\u2014CRC Card\n \n4.4.2 Step 2: Construct an Interaction Diagram\n \n4.4.3 Step 3: Build a State Machine Diagram\n \n4.4.4 Step 4: Class Specification\n \n4.5 Design Principles\n \n4.5.1 Principle of Decoupling\n \n4.5.2 Ensuring Cohesion\n \n4.5.3 Open-Closed Principle\n \n4.6 Summary\n \n4.7 Self-Review Questions\n \n4.8 Exercises\n \n4.9 Design Exercises", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 6", "position": 6, "chunk_type": "semantic", "token_estimate": 140}
{"text": "4.10 Challenge Exercises\n \nChapter 5 Data Flow Architectures\n \n5.1 Overview\n \n5.2 Batch Sequential\n \n5.3 Pipe and Filter Architecture\n \n5.4 Process Control Architecture\n \n5.5 Summary\n \n5.6 Self-Review Questions\n \n5.7 Exercises\n \n5.8 Design Exercises\n \n5.9 Challenge Exercises\n \nChapter 6 Data-Centered Software Architecture\n \n6.1 Overview\n \n6.2 Repository Architecture Style\n \n6.3 Blackboard Architecture Style\n \n6.4 Summary\n \n6.5 Self-Review Questions\n \n6.6 Exercises\n \n6.7 Design Exercises\n \n6.8 Challenge Exercise\n \nChapter 7 Hierarchical Architecture\n \n7.1 Overview\n \n7.2 Main-Subroutine\n \n7.3 Master-Slave\n \n7.4 Layered\n \n7.5 Virtual Machine\n \n7.6 Summary\n \n7.7 Self-Review Questions\n \n7.8 Exercises\n \n7.9 Design Exercises\n \n7.10 Challenge Exercises\n \nChapter 8 Implicit Asynchronous Communication Software Architecture", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 7", "position": 7, "chunk_type": "semantic", "token_estimate": 98}
{"text": "8.1 Overview\n \n8.2 Nonbuffered Event-Based Implicit Invocations\n \n8.3 Buffered Message-Based Software Architecture\n \n8.4 Summary\n \n8.5 Self-Review Questions\n \n8.6 Exercises\n \n8.7 Design Exercises\n \n8.8 Challenge Exercise\n \nChapter 9 Interaction-Oriented Software Architectures\n \n9.1 Overview\n \n9.2 Model-View-Controller (MVC)\n \n9.2.1 MVC-I\n \n9.2.2 MVC-II\n \n9.3 Presentation-Abstraction-Control (PAC)\n \n9.4 Summary\n \n9.5 Self-Review Questions\n \n9.6 Exercises\n \n9.7 Design Exercises\n \n9.8 Challenge Exercises\n \nChapter 10 Distributed Architecture\n \n10.1 Overview\n \n10.2 Client-Server\n \n10.3 Multi-tiers\n \n10.4 Broker Architecture Style\n \n10.4.1 Broker Implementation in the Common Object Request Broker Architecture (CORBA)\n \n10.4.2 Message Broker Architecture\n \n10.5 Service-Oriented Architecture (SOA)\n \n10.5.1 SOA Implementation in Web Services\n \n10.5.2 SOA Implementation for Grid Service Computing\n \n10.6 Summary\n \n10.7 Self-Review Questions\n \n10.8 Exercises\n \n10.9 Design Exercises", "domains": ["Architectural Patterns and Styles"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 8", "position": 8, "chunk_type": "semantic", "token_estimate": 111}
{"text": "10.10 Challenge Exercise\n \nChapter 11 Component-Based Software Architecture\n \n11.1 Overview\n \n11.2 What Is a Component? 11.3 Principles of Component-Based Design\n \n11.3.1 Connections of Components\n \n11.3.2 Component-Level Design Guidelines\n \n11.4 Summary\n \n11.5 Self-Review Questions\n \n11.6 Exercises\n \n11.7 Design Exercises\n \n11.8 Challenge Exercises\n \nChapter 12 Heterogeneous Architecture\n \n12.1 Overview\n \n12.2 Methodology of Architecture Decision\n \n12.3 Quality Attributes\n \n12.4 Selection of Architecture Styles\n \n12.5 Evaluation of Architecture Designs\n \n12.6 Case Study: Online Computer Vendor\n \n12.6.1 Overall Architecture Design of OCVS\n \n12.6.2 Architecture Design of Order Processing Component\n \n12.6.3 Architecture Design of Inventory Management\n \n12.6.4 Architecture Design of Manufacture and Shipping Component\n \n12.7 Summary\n \n12.8 Self-Review Questions\n \n12.9 Exercises\n \n12.10 Design Exercises\n \n12.11 Challenge Exercises\n \nChapter 13 Architecture of User Interfaces\n \n13.1 Overview\n \n13.2 Evolution of User Interfaces\n \n13.3 Look and Feel (Syntax) of User Interfaces", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 9", "position": 9, "chunk_type": "semantic", "token_estimate": 132}
{"text": "Preface: For decades, software architecture has received primary focus in the field of software engineering. With the growth of the software\nindustry, it has become clear that an early and careful architectural design can greatly reduce the failure rates of software projects. A\ngood architectural design partitions the functional requirements of a software system into a manageable set of interacting elements. Quality attributes such as efficiency, usability, modifiability, reliability, and security can be verified and estimated with respect to the\ndesign before any code is produced. As the blueprint of a software system, the architectural design allows system analysts and\nsoftware architects to communicate effectively with one another and with other stakeholders. It also sets the foundation for the\nsubsequent design and development processes. The detailed design process furnishes the specifics of each architectural element,\nwhich can then be implemented via coding, followed by debugging, testing, and maintenance. All of these software development\nactivities greatly benefit from an architectural design that clearly depicts the structure of the software being built. The new standards for baccalaureate Software Engineering (SwE) education require that software architecture and design be taught\nas part of the core curriculum. For example, the Software Engineering Volume (SE 2004*) of the ACM/IEEE computing curriculum\nproject** recommends software design (which includes architecture) as one of its ten essential areas. Software design ranks as the\nsecond highest concentration for software engineering majors and the fourth highest for computer science (CS) majors. Other\ncomputing degree programs, such as computer engineering and information technology, also offer software architecture classes. Approach\n \nSoftw\nare Architecture and Design Illuminated provides a coherent and integrated approach to the discipline of software architectural\ndesign. It is based on rich practical examples and case studies. The book covers a complete set of important software design\nmethodologies, architectural styles, design guidelines, and design tools. Java is used throughout the book to explain design principles\nand present case studies. All of the authors have taught these topics in related undergraduate and graduate courses, and have\npracticed software architectural design in many research and industry projects in the past. Self-review questions with answers,\nexercises, design exercises, and challenge exercises appear at the end of most chapters. Audience\n \nThis text is intended for software architecture and design courses for upper-level undergraduate or graduate students. It can also be\nused as a reference book for software engineering courses.", "domains": ["Software Quality Attributes"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 12", "position": 12, "chunk_type": "semantic", "token_estimate": 395}
{"text": "Preface: Audience\n \nThis text is intended for software architecture and design courses for upper-level undergraduate or graduate students. It can also be\nused as a reference book for software engineering courses. Students majoring in any of the computing disciplines, who have\ncompleted the introductory programming course sequence (CS1, CS2), can read and work through this book without difficulty. Professionals in the software industry who desire a coherent introduction to software architecture and design will also benefit from this\nbook. Organization\n \nThe book is organized into four parts. Part 1 includes Chapters 1, 2, and 3 and serves as an introduction to software architecture\ndesign. This part covers general software architecture concepts and guidelines, including software system structure decomposition,\nsubsystems, software attributes, taxonomy of software architectural styles, the Unified Modeling Language (UML), and Architecture\nDescription Languages (ADL). Part 2 consists of a single chapter (Chapter 4) and is dedicated to the object-oriented software design methodology. The OO\nmethodology can be applied to all architecture styles. It can be used in detailed design and is well-supported by UML tools. Part 3 contains Chapters 5-11. This part covers all architectural styles in detail, including but not limited to: data flow architectures (e.g.,\nbatch sequential, pipe and filter, and process control), data-centered architectures (e.g., data repository and blackboard), hierarchical\narchitectures (e.g., main- subroutine, master-slaves, layered, and virtual machine), implicit asynchronous communication architectures\n(e.g., event-based and buffered message-based), interaction architectures (e.g., model-view-controller), distributed architectures (e.g.,\nclient-server and service-oriented architecture), and component-based architectures. Part 4 contains three chapters. Chapter 12 covers a comprehensive case study that integrates heterogeneous architectural styles. Chapter 13 addresses architecture of Graphical User Interfaces (GUI). Chapter 14 was prepared by Jorge L. Diaz-Herrera, Dean of B.\nThomas Golisano College of Computing and Information Sciences at Rochester Institute of T\nechnology. This chapter discusses\nProduct Line Architectures (PLA) and large scale software domain analysis and design. Student and Instructor Resources\n \nThe \nPowerPoint \nlecture \nslides, \ntest \nitems, \nand \nsolutions \nto \nodd \nexercises \nare \navailable \nat", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 12", "position": 12, "chunk_type": "semantic", "token_estimate": 331}
{"text": "1 Introduction to Software Architecture\n \nObjectives of this Chapter\n \n\u2022   Introduce the relationship between software requirements and architecture\n \n\u2022   Introduce the relationship between architecture styles and architecture\n \n\u2022   Introduce the elements of software architecture\n \n\u2022   Describe quality attributes and tradeoff analysis\n \n1.1 Overview\n \nThe goal of software design is to build a model that meets all customer requirements and leads to successful implementation. As\nsoftware systems continue to grow in scale, complexity, and distribution, their proper design becomes extremely important in software\nproduction. Any software, regardless of its application domain, should have an overall architecture design that guides its construction\nand development. The success of a software product or system largely depends on the success of its architecture design. What is the architecture design? \u201cThe architecture design defines the relationship between major structural elements of the software,\nthe styles and design patterns that can be used to achieve the requirements defined for the system, and the constraints that affect the\nway in which architecture can be implemented\u201d (Garlan and Shaw, 1996). The architecture design representation is derived from the\nsystem requirement specification and the analysis model. Who is responsible for developing the architecture design? Software architects and designers are involved in this process. They\ntranslate (map) the software system requirements into architecture design. During the translation process, they apply various design\nstrategies to divide and conquer the complexities of an application domain and resolve the software architecture. Why is software architecture design so important? There are several reasons. A poor design may result in a deficient product that does\nnot meet system requirements, is not adaptive to future requirement changes, is not reusable, exhibits unpredictable behavior, or\nperforms badly. Without proper planning in the architecture design stage, software production may be very inefficient in terms of time\nand cost. In contrast, a good software design reduces the risks associated with software production, helps development teams work\ntogether in an orderly fashion, makes the system traceable for implementation and testing, and leads to software products that have\nhigher quality attributes. When is software design conducted? Software design is an early phase of the Software Development Life Cycle (SDLC). During this\nphase, software designers model the system and assess its quality so that improvements may be made before the software goes into\nthe production phase.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 14", "position": 14, "chunk_type": "semantic", "token_estimate": 383}
{"text": "Software design is an early phase of the Software Development Life Cycle (SDLC). During this\nphase, software designers model the system and assess its quality so that improvements may be made before the software goes into\nthe production phase. As shown in Figure 1.1, SDLC consists of the following stages: software requirements analysis; software design\n(architecture and detailed); software development and implementation; and testing and quality assurance, maintenance, and evolution. The dashed box in Figure 1.1 depicts the scope of software design. The Software Requirements Specification (SRS) provides the\ninput necessary for design. SRS is the result of requirements analysis; it records the functional and nonfunctional requirements that\nmust be met by the software system. Figure 1.1\n \nA simplified software development life cycle\n \nWhat is the outcome of the software architecture design? Simply put, it is an overall representation of the software to be built. The IEEE\nStd 1016-IEEE Recommended Practice for Software Design Descriptions (SDD), shown in Figure 1.1, describes an organization for\nsoftware design descriptions. The SDD serves as the blueprint for the implementation phase. It describes the elements of a system,\nthe modules that compose each element, and the detailed information (such as data attributes, operations, and algorithms) of each\nmodule. The SDD is used as a template for software design description. The following is a sample outline of SDD based on IEEE 1016. \u2022   design overview, purpose, scope", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 14", "position": 14, "chunk_type": "semantic", "token_estimate": 232}
{"text": "\u2022   decomposition description (module, data, process)\n \n\u2022   dependency and connection description (between modules, data, and processes)\n \n\u2022   attributes\n \n\u2022   user interface description\n \n\u2022   detailed design (module and data)\n \nNotice that the architecture design is a front strategy design for the detailed design. During the architecture design stage, a designer\nmust specify user-accessible elements and the interconnections that are visible to stakeholders. Detailed design, also called tactical\ndesign, is concerned with local design constraints and the internal details of each element. For example, in the architecture design of a\ncity traffic controller system, the designer can specify a priority queue that stores and dispatches incoming requests. In the detailed\ndesign, the designer must choose internal data structures from alternative solutions. For example, the priority queue can be\nimplemented using a singly linked list, a doubly linked list, or an array. The designer must then document his reasons for selecting a\nparticular internal data structure. In large-scale software design, the software architect may perform subsystem design before the\ndetailed design. We will now elaborate on the concepts of architecture design, which is the emphasis of this book. T\nake house construction as an\nanalogy. Before construction begins, the builders need to know the requirements from customers and the architects must design\nblueprints. The architects have many options to choose from, such as the style (e.g., Victorian, Colonial, Cape Cod, etc. ), functionality\n(e.g., vocational or residential), and features of the house (e.g., basement or sunroom). Similarly, the specifications of software\nelements, connectors, constraints (space, time, budget, etc.) and desired quality attributes (such as availability and performance) must\nbe addressed in software design, and this is called the \u201csoftware architecture,\u201d or high-level design. In practice, designers designate architecture styles by separating out common features of elements and connectors into \u201cfamilies of\narchitecture.\u201d Each style represents a layout topology of elements, and connectors and interactions among them. Each style also\ndescribes its semantic constraints and behaviors relating to data transfer and control transfer among the elements in the system, as\nwell as the quality attributes tradeoff. Software quality attributes include nonfunctional requirements such as performance, reliability, portability, usability, security, testability,\nmaintainability, adaptability, modifiability, and scalability. Quality attributes are closely related to architecture styles in that each\narchitecture style supports some quality features. An architecture style encapsulates the tradeoffs among many conflicting quality\nattributes.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 15", "position": 15, "chunk_type": "semantic", "token_estimate": 389}
{"text": "Quality attributes are closely related to architecture styles in that each\narchitecture style supports some quality features. An architecture style encapsulates the tradeoffs among many conflicting quality\nattributes. For example, with system performance, there is always a tradeoff between time/resources and system reliability and\navailability. The rest of Chapter 1 is organized as follows: Section 1.2 elaborates on the notion of software architecture; Section 1.3 presents a\ngeneral discussion of architecture styles; Section 1.4 discusses quality attributes; and Section 1.5 enumerates guidelines for software\narchitects. The chapter concludes with a brief summary in Section 1.6. 1.2 Software Architecture: Bridging Requirements and Implementation\n \nSoftware architecture plays a very important role in the Software Development Life Cycle. The architecture design provides a blueprint\nand guideline for developing a software system based on its requirement analysis specification. The architecture design embodies the\nearliest decisions that have a decisive impact on the ultimate success of the software product. The design shows how the system\nelements are structured, and how they work together. An architecture design must cover the software's functional and nonfunctional\nrequirements as well. It serves as an evaluation and implementation plan for software development and software evolution. The box-and-line diagram in Figure 1.2 shows what an architecture design typically looks like. Notice that it does not contain the\ncomplete set of information found in a development blueprint. For example, it does not provide enough guidelines for programmers to\nfollow, nor does it describe any quality attributes. In Figure 1.2, each element (also called a \u201csubsystem\u201d) symbolizes a sole\nresponsibility such as business logic processing, logic control, interface presentation, data gathering, and service brokering and\nmediating. This division of elements is based on their functionality, location, and runtime images. The elements may be in the form of\nmodules, objects, packages, deployed elements, tasks, functions, processes, distributed programs, etc. The topology of the static\nstructure focuses on the system composition configuration such as layered, flattened, star-typed, centralized, or distributed. The\ndynamic runtime connectors may be batch-sequential, multithreaded, explicit direct invocation, implicit indirect invocation (such as\nmessage queue or event notification), synchronous or asynchronous communication, peer-to-peer message exchange or message\nbroadcasting, or another applicable coordination and cooperation mechanism among the elements. Figure 1.2\nBox-and-line diagramshowingsubsystems", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 15", "position": 15, "chunk_type": "semantic", "token_estimate": 370}
{"text": "Box-and-line diagram showing subsystems\n \nFigure 1.2 illustrates the idea of software architecture, but what is its formal definition? Here we list two definitions, one by IEEE and the\nother by Garlan and Shaw (1996). IEEE Std 1471 defines system architecture as \u201cthe fundamental organization of a system embodied in its elements, their relationships\nto each other, and to the environment, and the principles guiding its design and evolution\u201d (Maier, Emery, Hilliard). Garlan and Shaw define software architecture as \u201cthe description of elements that comprise a system, the interactions and patterns of\nthese elements, the principles that guide their composition, and the constraints on these elements\u201d (1996). In these definitions, the architecture elements can be a module, subsystem, object, or binary software such as a DLL component; a\nJavaBean, EJB, CORBA, or web component; or even a whole system. In this book we use \u201celements\u201d to refer to the generic units of\nsoftware architecture, and we use \u201ccomponent\u201d as its synonym in discussions related to software architectures. Don't confuse this\nsoftware component term with \u201ccomponent-based technology.\u201d\n \nSoftware design depends on the Software Requirement Specification (SRS) produced by analysis in the first step of SDLC. The\nrequirements process covers information domain modeling, data modeling, function modeling, behavioral modeling, and user interface\nmodeling. There are two aspects of software requirements: functional and nonfunctional. A functional requirement specifies the\nfunctionality of the software system whereas a nonfunctional requirement specifies system qualities, constraints, and behaviors. There are many mechanisms used to specify a software requirement. The well-known box-and-line diagram in Figure 1.2 shows the\nconceptual analysis model of the system, which may be a starting point for software architecture design. However, a box-and-line\ndiagram cannot fully capture the semantics of software architecture design because it does not provide the information necessary for\nsoftware development in the next phase. Other descriptive notations also report the results of requirements analysis; these include\nUnified Modeling Language (UML) use-case specifications, Data Flow Diagrams (DFD), and State Transition Diagrams (STD). All\nthese notations and tools can help software designers better understand the software requirements. However, they are conceptual\nmodels for analysis and not descriptions of the software architecture. A complete software architecture specification must describe not only the elements and connectors between elements, but also the\nconstraints and runtime behaviors so that developers know what and how the design should be implemented.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 16", "position": 16, "chunk_type": "semantic", "token_estimate": 392}
{"text": "However, they are conceptual\nmodels for analysis and not descriptions of the software architecture. A complete software architecture specification must describe not only the elements and connectors between elements, but also the\nconstraints and runtime behaviors so that developers know what and how the design should be implemented. The following lists a software architect's tasks:\n \n\u2022   Perform static partition and decomposition of a system into subsystems and communications among subsystems. A software\nelement can be configured, delivered, developed, and deployed, and is replaceable in the future. Each element's interface\nencapsulates details and provides loose coupling with other elements or subsystems. \u2022   Establish dynamic control relationships among different subsystems in terms of data flow, control flow orchestration, or message\ndispatching. \u2022   Consider and evaluate alternative architecture styles that suit the problem domain at hand. \u2022   Perform tradeoff analysis on quality attributes and other nonfunctional requirements during the selection of architecture styles. The\nselection of element type and connector type will have a direct impact on system properties and its quality attributes. Many quality\nattributes must be taken into account early in the design phase. For example, in order to increase a distributed system's extensibility,\nportability, or maintainability, software components and Web services may be the best choice of element types, and a loose\nconnection among these elements may be most appropriate. The architects need to have stakeholders involved in this process. The most important job of a software architect is to map the Software Requirements Specification to the software architecture design\nand guarantee that functional and nonfunctional requirements are met. If it is not possible to satisfy all requirements, system analysts\nand software architects can use the architecture designs to communicate with stakeholders. 1.3 Architecture Styles\n \nAn architecture style (also known as an \u201carchitecture pattern\u201d) abstracts the common properties of a family of similar designs. An\narchitecture style contains a set of rules, constraints, and patterns of how to structure a system into a set of elements and connectors. It\ngoverns the overall structure design pattern of constituent element types and their runtime interaction of flow control and data transfer.", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 16", "position": 16, "chunk_type": "semantic", "token_estimate": 349}
{"text": "data. In the dataflow style, input data is transformed by a series of computational or manipulative elements. In the call-and-return style,: functions and procedures are the elements organized in a control hierarchy with a main program invoking several subprograms. In the\nobject-oriented style, elements are represented as objects that encapsulate data and operations, and the communication among them\nis by message passing. In the layered style, each module or package completes tasks that progress in a framework from higher-level\nabstractions to lower-level implementations. All of these styles will be discussed in detail in later chapters. For now, let us take a look at the multi-tier architecture style in detail. Multi-tier architecture is commonly used for distributed systems. It\nusually consists of three element types: client, middleware server, and data server. Each element type serves a distinct function. The client element is responsible for GUI interface presentation, accepting user requests,\nand rendering results. The middleware element gets the requests from the client element, processes the requests based on the\nbusiness logic, and sends a data request to the back-end tier. The data store server element manages data querying and updating. All\nthree types of elements are connected via a network (e.g., the Internet). Many enterprise software architectures are of the multi-tier style\nbecause they share the same set of constraints. Why are architecture styles so important? Because each style has a set of quality attributes that it promotes. By identifying the styles\nthat a software architecture design supports, we can verify whether the architecture is consistent with the requirement specifications,\nand identify which tactics we can use to better implement the architecture. Theoretically, an architecture style is a viewpoint abstraction for a software structure that is domain-independent. In most cases, a\nsoftware system has its own application domain such as image processing, motor control, Web portal, expert system, or mail server. Each domain may have its own reference model. For instance, the Model-View-Controller (MVC) is widely adopted by designers of\ninteractive systems. Such a reference model partitions the functionalities of a system into subsystems or software components. In many\ncases, a system can adopt heterogeneous architectures, i.e., more than one architecture style can coexist in the same design. It is also\ntrue that an architecture style maybe applied to many application domains. 1.4 Quality Attributes\n \nEach architecture style has its advantages, disadvantages, and potential risks. Choosing the right style to satisfy required functions and\nquality attributes is very important. Quality attributes are identified in the requirement analysis process.", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 17", "position": 17, "chunk_type": "semantic", "token_estimate": 417}
{"text": "data. In the dataflow style, input data is transformed by a series of computational or manipulative elements. In the call-and-return style,: Choosing the right style to satisfy required functions and\nquality attributes is very important. Quality attributes are identified in the requirement analysis process. Quality attributes can be\ncategorized into the following three groups:\n \n1. Implementation attributes (not observable at runtime)\n\u2022   Interoperability: universal accessibility and the ability to exchange data among internal components and with the outside world. Interoperability requires loose dependency of infrastructure. \u2022   Maintainability and extensibility: the ability to modify the system and conveniently extend it. \u2022   Testability: the degree to which the system facilitates the establishment of test cases. T\nestability usually requires a complete\nset of documentation accompanied by system design and implementation. \u2022   Portability: the system's level of independence on software and hardware platforms. Systems developed using high-level\nprogramming languages usually have good portability. One typical example is Java\u2014most Java programs need only be\ncompiled once and can run everywhere. \u2022   Scalability: a system's ability to adapt to an increase in user requests. Scalability disfavors bottlenecks in system design. \u2022   Flexibility: the ease of system modification to cater to different environments or problems for which the system was not\noriginally designed. Systems developed using component-based architecture or service-oriented architecture usually possess\nthis attribute. 2. Runtime attributes (observable at runtime)\n\u2022   Availability: a system's capability to be available 24/7. Availability can be achieved via replication and careful design to cope\nwith failures of hardware, software, or the network. \u2022   Security: a system's ability to cope with malicious attacks from outside or inside the system. Security can be improved by\ninstalling firewalls, establishing authentication and authorization processes, and using encryption. \u2022   Performance: increasing a system's efficiency with regard to response time, throughput, and resource utilization, attributes\nwhich usually conflict with each other. \u2022   Usability: the level of human satisfaction from using the system. Usability includes matters of completeness, correctness,\ncompatibility, as well as a friendly user interface, complete documentation, and technical support. \u2022   Reliability: the failure frequency, the accuracy of output results, the Mean-Time-to-Failure (MTTF), the ability to recover from\nfailure, and the failure predictability. \u2022   Maintainability (extensibility, adaptability, serviceability, testability, compatibility, and configurability):  the ease of software", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 17", "position": 17, "chunk_type": "semantic", "token_estimate": 372}
{"text": "system change.: 3. Business attributes\n\u2022   Time to market: the time it takes from requirements analysis to the date a product is released. \u2022   Cost: the expense of building, maintaining, and operating the system. \u2022   Lifetime: the period of time that the product is \u201calive\u201d before retirement. In many cases, no single architecture style can meet all quality attributes simultaneously. Software architects often need to balance\ntradeoffs among attributes. Typical quality attribute tradeoff pairs include the following:\n \n\u2022   Tradeoff betw\neen space and time. For example, to increase the time efficiency of a hash table means a decrease in its space\nefficiency. \u2022   Tradeoff betw\neen reliability and performance. For instance, Java programs are well protected against buffer overflow due to\nsecurity measures such as boundary checks on arrays. Such reliability features come at the cost of time efficiency, compared with\nthe simpler and faster C language which provides the \u201cdangerous,\u201d yet efficient, pointers. \u2022   Tradeoff betw\neen scalability and performance. For example, one typical approach to increase the scalability of a service is to\nreplicate servers. T\no ensure consistency of all servers (e.g., to make sure that each server has the same logically consistent data),\nperformance of the whole service is compromised. When an architecture style does not satisfy all the desired quality attributes, software architects work with system analysts and\nstakeholders to nail down the priority of quality attributes. By enumerating alternative architecture designs and calculating a weighted\nevaluation of quality attributes, software architects can select the optimal design. 1.5 Software Architecture Design Guidelines\n \nIn the following section we provide several rules of thumb to help software developers better understand requirements, identify the right\narchitecture styles to decompose a complex system into its constituent elements, choose the proper element and connector types,\nmeet stakeholders\u2019 requirements for quality attributes, and provide proper execution tactics for efficient implementation. \u2022   Think of w\nhat to do before thinking of how\n to do it. Functional and nonfunctional requirements should be identified, verified, and\nvalidated before architecture and detailed design work is done. Using an abstract architecture design to communicate with\nstakeholders helps avoid the need to overhaul the system design in later stages of the software development cycle. A successful architecture design relies on inherent iterative requirement analysis. Notice that different stakeholders of software\nsystems have their own concerns. Software architects need to confirm what is needed and what can be traded off.", "domains": ["Software Quality Attributes"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 18", "position": 18, "chunk_type": "semantic", "token_estimate": 402}
{"text": "system change.: Notice that different stakeholders of software\nsystems have their own concerns. Software architects need to confirm what is needed and what can be traded off. For example, the\ninvestors of a project are usually concerned with the system release date, budget, usability, and so on; whereas the end users of the\nsame project are concerned with performance, reliability, and usage scenarios. Thus, the software architect must be concerned with\ntradeoff analysis of the quality attributes, as well as the completeness and consistency of the architecture. Software developers, on the\nother hand, focus on implementation and are concerned with whether the software design is detailed enough for coding. Software\nproject managers may be concerned with software architecture evolution and maintenance in the future. \u2022   Think of abstract design before thinking of concrete design. Always start with an abstract design that specifies interfaces of\ncomponents and abstract data types. Use multiple levels of abstraction if necessary. Make implementation decisions based on the\nabstract interfaces instead of the concrete ones because those are more stable\u2014they are the contracts between service providers\nand service requesters, so they are defined at the early stages of the software development cycle. \u2022   Think of nonfunctional requirements early in the design process. When you map functional requirements to an architecture design,\nyou should consider nonfunctional requirements as well. Communicate with stakeholders and document their preferences for quality\nattributes. If it is not possible to find a design that meets all quality attributes, try to find the right balance of quality attributes and\nconsider heterogeneous architecture styles when necessary. \u2022   Think of softw\nare reusability and extensibility as much as possible. For most software systems, it is likely that new functionalities\nwill be added after the systems are deployed. Y\nou need to consider how to reuse existing software components to increase the\nreliability and cost-effectiveness of new systems. Always try hard to make software extensible in the future. \u2022   Try to promote high cohesion w\nithin each element and loose coupling betw\neen elements. A highly coherent subsystem,\ncomponent, or module performs one sole function. For example, in object-oriented design, if a class is assigned to bear two\nunrelated responsibilities, it is regarded as incoherent. Y\nou must consider cohesion factors during the very early stages of the design\nprocess.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 18", "position": 18, "chunk_type": "semantic", "token_estimate": 384}
{"text": "system change.: For example, in object-oriented design, if a class is assigned to bear two\nunrelated responsibilities, it is regarded as incoherent. Y\nou must consider cohesion factors during the very early stages of the design\nprocess. Low cohesion of a system implies that functional composition is not designed well; for example, a single function can be\nscattered across a large number of different components, making it very hard to maintain. Each architecture style should show a clear division between elements to guarantee loose coupling. In most cases, loose coupling\nmeans less interdependency between components, so the change of one component is not likely to cause ripple-changes of other\ncomponents. The coupling attribute can be measured by interface signature counts. Message passing and asynchronous\ncommunication are good examples of loose coupling between the service requestor and the service provider. For example, an email\nconversation has a much looser tie than that of a phone conversation.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 18", "position": 18, "chunk_type": "semantic", "token_estimate": 155}
{"text": "\u2022   Tolerate refinement of design. Never expect to have software design completely perfect in one step. Y\nou may need to use\nprototyping and iteration to refine the design. \u2022   Avoid ambiguous design and over-detailed design. Ambiguous design lacks constraints and over-detailed design restricts\nimplementation. How are architecture designs described? UML notation is one of many solutions, in addition to text documentation, that are available to\ndesigners. UML provides graphic notations that are available to architects and designers in nearly every stage of SDLC, e.g., use case\ndiagrams for documenting system requirements, class diagrams for describing the logical structure of a system, and state machine\ndiagrams and interaction diagrams for specifying the dynamic behaviors of a system. The \u201c4+1\u201d view model, developed by P. B.\nKruchten, is a way to show different views of a software system, from the perspective of different stakeholders. It is especially useful in\ndescribing a complete set of functional and nonfunctional requirements. Another choice is to use Architecture Description Languages\n(ADL) to formally specify the structure and semantics of software architecture. 1.6 Summary\n \nSoftware architecture design has emerged as an important part of software development. A software architecture specification\nconsists of software elements, connectors and collaborations among the elements, and desired quality attributes. An architecture style\nis a set of rules, constraints, or patterns that guide how to structure a system into a set of elements and connectors, and how to govern\noverall structure design patterns of constituent element types and their runtime interaction. One specific architecture style may not\nsatisfy all of the system's desired quality attributes, in which case tradeoffs must be made. Thus, how to properly balance quality\nattributes is an important design issue. 1.7 Self-Review Questions\n \n1. The constituent elements of software architecture are software elements and their connections. a. True\n    b. False\n2. Software architecture design involves many software design methodologies and architecture styles. a. True\n    b. False\n3. The purpose of the software design phase is to produce a software requirement specification. a. True\n    b. False\n4. Object-oriented design is a design methodology. a. True\n    b. False\n5. Pipe-and-filter is one of the architecture styles. a. True\n    b. False\n6. Software architecture is a static software structure description. a. True\n    b. False\n7. Software quality attributes must satisfy functional requirements. a. True\n    b. False\n8. Architecture styles contribute to software quality attributes. a. True\n    b. False\n9.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 19", "position": 19, "chunk_type": "semantic", "token_estimate": 398}
{"text": "True\n    b. False\n9. Software architecture = software architecture styles. a. True\n    b. False\n10. Software architecture design is based on the software requirement specification. a. True\n    b. False\nAnswers to the Self-Review Questions\n \n1. b 2. a 3. b 4. a 5. a 6.b 7.b 8. a 9.b 10. a\n \nReferences\n \nGarlan David and Mary Shaw. Softw\nare Architecture: Perspectives on an Emerging Discipline. Upper Saddle River, NJ: Prentice Hall,\n1996, 1-4. Maier M.W., D. Emery, R. Hilliard. \u201cSoftware architecture: introducing IEEE Standard 1471.\u201d IEEE Xplore. Vol. 34, No. 4 (April 2001),\nhttp://ieeexplore.ieee.org/Xplore/login.jsp?url=/iel5/2/19820/00917550.pdf? temp=x. Suggested Reading", "domains": ["Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 19", "position": 19, "chunk_type": "semantic", "token_estimate": 97}
{"text": "2 Software Architecture Design Space: e\n \nObjectives of this Chapter\n \n\u2022   Introduce major perspectives on, and structures used in, software architecture\n \n\u2022   Introduce major element and connector types used in software architecture\n \n\u2022   Introduce the iterative refinement process for software architecture design\n \n2.1 Overview\n \nA software architect is responsible for proposing a concrete architecture that best supports the detailed design and implementation of\na specific project. Software architects must know what design alternatives are available to them, and which one will best support the\nfunctional and nonfunctional requirements. T\no put it another way, a software architect must understand the software architecture's\ndesign space. In its simplest form, a software architecture design is a set of software elements connected by a set of connectors. From a dynamic\nstructure point of view, a software element can be a process, an object, an instance of a software component, or a service. Different\nsoftware elements may run on different hardware and software platforms and may be implemented in different programming languages\nor on different software frameworks. Two software elements can run in the same process, on the same computer system, within an\nintranet, or distributed over the Internet. Depending on their relative location, the connectors between a pair of software elements can\nbe implemented in various forms including local method invocations, remote method invocations, service calls, and messaging through\na message queue. The connectors can also work in synchronous or asynchronous nodes. In terms of the static structure, a software element can be a package, a class, a component, or a loadable library. Correspondingly, a\nconnector can be an import clause, inheritance clause, interface specification, pipe, or filter. T\noday's software industry is characterized by constantly changing project requirements. An organization's expansion or merger may\nlead to heterogeneous intranet IT infrastructure, just as B2B (business-to-business) integration may make integration across the\nInternet critical to its smooth operation. A good software architecture should be able to easily adapt to these changing environments\nwithout the need for major reengineering of corresponding software systems. Over the last decade, information technology has gone through significant changes. Component-based software engineering calls for\nthe use of software frameworks. For example, technologies such as. NET and J2EE (Java 2 Enterprise Edition) have greatly enhanced\nthe level of encapsulation. Web services and service-oriented architectures have brought us more flexible connector implementation\ntechnologies and software architecture varieties.", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 21", "position": 21, "chunk_type": "semantic", "token_estimate": 395}
{"text": "2 Software Architecture Design Space: NET and J2EE (Java 2 Enterprise Edition) have greatly enhanced\nthe level of encapsulation. Web services and service-oriented architectures have brought us more flexible connector implementation\ntechnologies and software architecture varieties. In the rest of this chapter we discuss the design space for software architectures and put in perspective the fundamental concepts\nbehind the latest implementation technologies. 2.2 Types of Software Structures\n \nAs indicated previously, a software architecture design can be described with various software structures, each from a different\nperspective. It may be described in terms of software code units like source/binary code files, software modules, or software\ncomponent deployment units; this is known as the static structure. It may also be described based on the runtime dynamic structure, in\nwhich the software elements are threads, processes, sessions, transactions, objects, or software component instances at execution\ntime. Furthermore, an allocation structure may also be used to describe the project management structure of an architecture design. These different types of structures use different connector types and different performance attributes. We provide more details about\nthese structural perspectives in the following subsections. 2.2.1 Software Static Structure\n \nA software project is typically implemented in multiple files. This includes static file types such as executable files; library files; binary\nsoftware component modules (usually in the form of DLLs [dynamic linking libraries], JavaBeans, and Enterprise JavaBeans);\ndeployment descriptors; and other resource files. At software development time, the main software elements are source code modules or files. Each module has assigned functional\nand nonfunctional attributes, and the public APIs (application programming interfaces), defined for each module separate the module's\ninterfaces and implementations. The connectors at this level are module dependent. Module A is connected to module B if, and only if,\nA needs to invoke some methods in B during execution. Such connectors may exhibit the following attributes:", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 21", "position": 21, "chunk_type": "semantic", "token_estimate": 308}
{"text": "\u2022   Direction: If module A invokes a method of module B during execution, there is a unidirectional connector from module A to module\nB. \u2022   Synchronization: A method invocation can be synchronous or asynchronous. \u2022   Sequence: Some connectors must be used in a particular sequence. For example, module A may invoke a method of module B and\npass a callback reference during the invocation. Later, some events in module B may trigger a callback to module A. Both of these\nmethod invocations are represented by their connector abstractions, and a sequence attribute associated with them consists of a\nsequence ID and number. In this case both connectors will have the same sequence ID but different sequence numbers, which\nindicates the order of method invocation. Note that the terms method and method invocation are used in a very general sense in this\nchapter. Normally, classes and methods will only be available at the detailed design phase, which takes place after a software\narchitecture design has been chosen. At software deployment time, the elements are binary versions of the project modules and files. Several source code modules may be\npackaged into the same deployment unit, but the connectors in the deployment structures are the same as those for the source module\nstructures. Let us look at the software structure Java. Classes are the basic building blocks of Java software. A Java program is a hierarchical collection of one or more classes. A large\nprogram consists of thousands of classes. Files are the compilation units in Java; that is, each file can be separately compiled. Packages allow the grouping of closely related classes and interfaces. Thus, they support the hierarchical and static organization of a\nlarge Java program as \u201clogical and name space\u201d managing units. Package declarations are file-based, meaning that all classes in the same file belong to the same package (name space), if the source\nfile contains a package declaration. When the package declaration is absent from a file, all the classes contained therein belong to an\nunnamed (anonymous) package. When packages are used, source and class files must be placed in directories whose structures\nmatch the structures of the packages. Naming the classes inside a package can be done by fully qualifying the name as follows:\npackage-name.class-name. Alternatively, we can import a package, one of its subunits, or all of its classes.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 22", "position": 22, "chunk_type": "semantic", "token_estimate": 392}
{"text": "Naming the classes inside a package can be done by fully qualifying the name as follows:\npackage-name.class-name. Alternatively, we can import a package, one of its subunits, or all of its classes. Java units declared inside other units, such as packages, classes, or interfaces, yield a tree-like hierarchy. In contrast, importing\nseparately compiled units defines a linear partial ordering which, when combined with the tree structure of subunits, defines the\nsoftw\nare static structure. The software static structure refers to the organization of physical software modules and their interrelations and this structure plays a\ncritical role in software architecture design. Static structure affects the architecture's clarity, construction strategy, maintenance,\nreengineering, reusability, etc. It plays a crucial role in the management of large software systems because it deals with the packaging\nof software modules in order to facilitate system construction and maintenance through a clear portrayal of intermodule relations. The\nfact that systems are developed incrementally increases the need for tight control of this structure in the physical software element. Managing static structures involves layers of abstraction and of refinement showing visibility and encapsulation, respectively. These two\nnotions define different kinds of hierarchical relations as described in the following:\n \n\u2022   A linear client-server relation is formed when a component provides primitive abstractions to another component. In this sense\ncomponents may refer to abstractions that, once defined, may be used throughout the entire design (at all levels). Layers of\nabstractions are connected when a module, the client, explicitly requests to use the facilities or abstractions provided by another\nmodule, the server. This relationship forms a linear hierarchy, whereby visibility is not transitive. Note that in support for reusability,\nserver units must not know the identity of the client modules. \u2022   A tree-like hierarchy of refinement relations is formed when an abstraction (i.e., a component) is implemented, and recursively\ndivides into subcomponents. A refinement relation specifies how a module (parent) is decomposed into a refinement module (child). This relationship always defines a tree-like hierarchy. Inheritance is a special case of refinement relations. Figure 2.1 illustrates the client-server and refinement relations essential for specifying the static structure. A server unit is an\nindependently compiled unit available for use in the given scope, whereas a subunit (and its sub-subunits, and so on) is a refinement\ncomponent of another unit, and hence exists only within the context of that unit.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 22", "position": 22, "chunk_type": "semantic", "token_estimate": 394}
{"text": "Figure 2.1 illustrates the client-server and refinement relations essential for specifying the static structure. A server unit is an\nindependently compiled unit available for use in the given scope, whereas a subunit (and its sub-subunits, and so on) is a refinement\ncomponent of another unit, and hence exists only within the context of that unit. Figure 2.1\n \nA summary of client-server and refinement relationships\n \n2.2.2 Software Runtime Structure", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 22", "position": 22, "chunk_type": "semantic", "token_estimate": 68}
{"text": "At runtime a project consists of one or more threads, processes, functional units, and data units. These elements may run on the same\ncomputer or on multiple computers across a network. The same element in a code structure may implement or support multiple runtime\nelements. For example, in a client-server application, the same client module may run on many client computers. Conversely, several\ncode structure elements may implement or support a single runtime element. For example, many threads will run multiple methods from\ndifferent classes that maybe packaged in different code units. The connectors at this level inherit attributes from their source-code structure counterparts, along with the following other attributes:\n \n\u2022   Multiplicity: One element can be connected to multiple elements if it needs to invoke methods of multiple elements at runtime. \u2022   Distance and connection media: Two connected elements may communicate in the same thread, in the same process, on the same\ncomputer, or on different computers across a network. Based on the distance between two elements, the communication media may\nvary from copper/optical cable or wireless based LAN to the Internet. \u2022   Universally invocable: A connector with this attribute set to true allows any external software system, no matter what hardware/\nsoftware platforms they run on and in which programming languages or software frameworks they are developed, to invoke the\nmethod at the connector's target. This attribute is critical for heterogeneous enterprise information systems that must be integrated\nefficiently. \u2022   Self-descriptive: A connector with this attribute set to true can allow an external software system to invoke its target method without\nthe pre-installation of any software specific to the method. This attribute allows clients to choose service providers dynamically. It also\nallows software systems developed at different companies at potentially different times to dynamically interact with each other. For\nexample, agents from different companies may be able to collaborate without special software installation. 2.2.3 Software Management Structure\n \nA large software project is normally designed and implemented by several project teams, each having its well-defined responsibilities\nat specific SDLC process stages. At this level, each element consists of manipulation (design, implementation, debugging, etc.) of\nspecific code units assigned to each project team, and the connectors are derived from runtime dependency among the code units and\nsoftware process dependencies. Some software architectures are best implemented by a particular software management structure. Software management structures are also used for project resource allocation.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 23", "position": 23, "chunk_type": "semantic", "token_estimate": 400}
{"text": "Some software architectures are best implemented by a particular software management structure. Software management structures are also used for project resource allocation. Software runtime structures serve as the technical backbone of architecture designs and provide the basis from which other structures\nare derived. In this book we focus on software runtime structures and their efficient mapping to the best implementation technologies. 2.3 Software Elements\n \nAt runtime each software element has well-defined functions and connects to the other elements into a dependency graph through\nconnectors. The elements of a software architecture are usually refined through multiple transformation steps based on their attributes\nand the project requirement specifications. Depending on each software element's assigned function, there may be different synchronization and performance constraints. For\nexample, some elements are reentrant objects or software components (meaning that multiple threads can execute in an element\nconcurrently without interfering with each other) while some elements are not reentrant and no more than one thread may execute in it at\nany time. Depending on the multiplicity of an element, it could be invoked by a limited number of other elements at execution time, or it\ncould be invoked by unlimited elements, as in the case of a server element. In the latter case, scalability, response time, and throughput\nbecome important performance constraints and must be considered during the element's implementation. The following are the basic guidelines for mapping runtime elements into their implementations:\n \n\u2022   If an element is reentrant, it can be implemented by a thread or a process. Reentrant elements are usually more efficient because\nthey avoid many synchronization issues and support shared thread or process pools. However, business logics may not allow some\nelements to be reentrant. \u2022   If an element is not reentrant and multiple threads or processes need to communicate with it, it must be run on separate threads or\nprocesses in order to be thread-safe (meaning that the system behavior is not affected by the multiplicity of threads executing\nconcurrently). \u2022   If an element has high multiplicity and its performance is important to the global system performance, an application server (a\nsoftware system running business logics) should be used for the element's implementation so that it can take advantage of thread\nand resource pooling, data caching, and dynamic element life cycle management to conserve resources.", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 23", "position": 23, "chunk_type": "semantic", "token_estimate": 383}
{"text": "\u2022   If an element is not reentrant and multiple threads or processes need to communicate with it, it must be run on separate threads or\nprocesses in order to be thread-safe (meaning that the system behavior is not affected by the multiplicity of threads executing\nconcurrently). \u2022   If an element has high multiplicity and its performance is important to the global system performance, an application server (a\nsoftware system running business logics) should be used for the element's implementation so that it can take advantage of thread\nand resource pooling, data caching, and dynamic element life cycle management to conserve resources. \u2022   If the elements contain heavy computations for deployment at a particular location, a cluster of processors will enhance CPU data\nprocessing power. The cluster size and the elements' mapping to the cluster computers should be done carefully to balance each\ncluster's computation load and minimize the total communication traffic on the cluster's network.", "domains": ["Software Quality Attributes"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 23", "position": 23, "chunk_type": "semantic", "token_estimate": 155}
{"text": "\u2022   If an element is assigned complex but well-defined functions, similar to those of some commercial off-the-shelf software components,: and the performance of this element is not critical, then it is more cost-effective to use an existing software component to implement\nthe element's functions. \u2022   A complex element can be expanded into a subsystem with its own elements and connectors. A well-defined interface should be\nused to encapsulate the subsystem's design and implementation details from the existing architecture. \u2022   A complex element can be transformed into a sequence of vertical layered elements if each layer provides a virtual machine or\ninterface to its immediate upper-layer element, and each layered element hides away some low-level system details from the upper\nlayers. \u2022   A complex element can be transformed into a sequence of horizontally tiered elements if the business logic can be achieved by\nprocessing data with a sequence of discrete processing stages, and these processing stages can be implemented by tiered\nelements with well-defined interfaces and balanced workloads. 2.4 Software Connectors\n \nThe connectors in a software architecture are refined during the design process and are heavily influenced by a project's deployment\nenvironment. In the most abstract form, a connector indicates the necessity during system execution for one of the elements to send a\nmessage to another element and potentially get a return message. During software architecture refinement, if two elements are\nmapped to a single process, the connector can be mapped to a local method invocation. If two elements are mapped to two different\nprocesses on the same computer, the connector can be mapped to a local message queue or a pipe. If the two elements are mapped\nto two different computers, then remote method invocation or web service invocation can be used to refine the connector between\nthem. Software connectors are classified according to many attributes, including synchronization mode, initiator, implementation type, active\ntime span, fan-out, information carrier, and environment. Based on the connector's synchronization mode, we can classify all\nconnectors into two categories: blocking connectors and non-blocking connectors, as shown in Figure 2.2 (a). A blocking connector\nallows one of its incident elements to send a request (method call or message) to another and wait for a response (method return value\nor message). The element will be blocked from further execution until it receives a response. A non-blocking connector allows one of its\nincident elements to send a request (method call or message) to another and then continue its execution without waiting for a response.", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 24", "position": 24, "chunk_type": "semantic", "token_estimate": 416}
{"text": "\u2022   If an element is assigned complex but well-defined functions, similar to those of some commercial off-the-shelf software components,: The element will be blocked from further execution until it receives a response. A non-blocking connector allows one of its\nincident elements to send a request (method call or message) to another and then continue its execution without waiting for a response. Based on the connector's initiator, we can classify all connectors into two categories: one-initiator connectors and tw\no-initiator\nconnectors, as shown in Figure 2.2 (b). An initiator is an incident element of a connector that can make a request to its partner. A one-\ninitiator connector allows only one of its two incident elements to make a request to the other element, but not the another way around. A two-initiator connector allows either one of its two incident elements to make a request to the other element. For a system to support\ncallback between its two subsystems, the two subsystems must be connected by a two-initiator connector. The information flow on a connector can be implemented using various information carriers, as shown in Figure 2.2 (c). If the two\nincident elements are in the same process, say as two threads, they may use a shared variable to exchange information. If they are\nmapped to different processes on the same processor, then resources like pipes, files, or local message queues may be used to\nimplement the connector. Method invocations and message passing are more common and more structured ways for carrying\ninformation. Remote method invocation and messaging can also allow communication among elements deployed on different\nprocessors. Figure 2.3 shows that a message system, consisting of a message sender module and a message receiver module\nconnected by a network, is used to implement a one-initiator connector for subsystem 1 to send messages/requests to subsystem 2. A\nmessage format must be defined so both the sender and the receiver can understand the messages, and a protocol must be adopted\nto determine the proper handshaking and synchronization between the two parties. The two small circles in the arrows connecting the\nmessage system to the two subsystems represent the two interfaces that connect the message system to its incident elements.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 24", "position": 24, "chunk_type": "semantic", "token_estimate": 367}
{"text": "Figure 2.2\n \nConnector type classification\n \n \nFigure 2.3\n \nA simple message system\n \nBased on the implementation type, a connector may be classified as signature-based or protocol-based, as shown in Figure 2.2 (d). For signature-based connectors, the method's name indicates an operation, and the parameters carry argument values for the\noperation's execution. If we assign one or more method parameter to indicate operation types, the connector can be used to implement\nprotocols. Whereas signature-based connectors can only be used to request one type of operation, a protocol-based connector can implement\nmultiple operation types with a single binding signature. Furthermore, a protocol-based connector can support new operation types\nafter the system interfaces are fixed. The connectors between an interpreter subsystem and its client subsystems are protocol-based. Message-based connectors support more flexible forms of protocols where all information about operations, arguments, and return\nvalues are coded in message formats and handshaking conventions among the involved parties. The HTTP protocol between web\nservers and web browsers is a familiar example of implementing a protocol-based connector. Connector active time refers to when an operation request or message is sent over a connector. Connectors may be classified into\nprogrammed connectors and event-driven connectors, as shown in Figure 2.2 (e). Normally a method call will be made at a time\nspecified during programming time: When execution comes to a line in a particular method, a call is made to another method. But for\nreal-time systems, reactive systems, and any system with graphic user interfaces, an event-driven programming model becomes a\nmuch more flexible connection mechanism. One element will function as an event source, and all elements that need be notified of the\nevent will register as listeners of the event source. When the event happens, all the registered listener elements will be notified for\npotential reaction. Figure 2.4\n \nNetworked connector implemented with the proxy design pattern\n \nMethod callback can be considered a special case of this event-driven mechanism. One element calls a method of another element,", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 25", "position": 25, "chunk_type": "semantic", "token_estimate": 328}
{"text": "with one of its parameters passing a callback object/method (listener object) reference. When some event happens in the latter: element, it will use the saved reference to call back and notify the first element. Event-driven connectors support late binding among\nsubsystems. Based on the connector span between incident elements, we classify the connectors as local connectors or netw\norked connectors, as\nshown in Figure 2.2 (f). This connector attribute depends on whether the incident elements are located in the same processor. This\nattribute has major impact in the connector's implementation technologies. Networked connectors are normally implemented with the\nproxy design pattern to support object-oriented programming paradigm in a distributed environment. Suppose that there is a one-\ninitiator and networked connector from subsystem 1 to subsystem 2, and subsystem 2 exposes an interface for subsystem 1 to invoke. A pair of proxy and skeleton objects will be generated from the interface by some technology-dependent tool, and they will be\nconnected by a message system, as shown in Figure 2.4. The proxy object exposes the same interface as subsystem 2, and it is\nlocated in the same process as subsystem 1. Subsystem 1 gives the illusion that the proxy object is subsystem 2 deployed in the same\nprocess. When subsystem 1 invokes a method of the proxy object, the method body will send the operation and arguments to its\nskeleton partner, which is deployed in the same process as subsystem 2, over the network through the message system. The skeleton\nwill then make the corresponding local method call against subsystem 2 and send the return value or any exceptions back to the proxy\nobject over the message system. The proxy object will then send the received return value as its own to subsystem 1. One major\nadvantage of this approach is that neither of the subsystems need be network-enabled at their design and implementation time. Based on connector fan-out (the number of elements one element can connect to) we classify connectors as 1-1 connectors and 1-*\nconnectors, as shown in Figure 2.2 (g). The 1-1 connectors are for connecting two elements only. The 1-* connectors are for connecting\none element with a variable number of elements of the same type. For example, a web server and web browsers are connected with a\n1-* connector, as are the server and clients in a client-server architecture. A connector's fan-out attribute may significantly impact\nconnector implementation technology and performance.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 26", "position": 26, "chunk_type": "semantic", "token_estimate": 404}
{"text": "with one of its parameters passing a callback object/method (listener object) reference. When some event happens in the latter: For example, a web server and web browsers are connected with a\n1-* connector, as are the server and clients in a client-server architecture. A connector's fan-out attribute may significantly impact\nconnector implementation technology and performance. Based on connector environment, which is the implementation technology or supporting platforms of a connector's two incident\nelements, we classify connectors into homogeneous connectors and heterogeneous connectors, as shown in Figure 2.2 (h). The\nincident elements of a homogeneous connector are implemented with the same programming language and software framework and\nrun on the same operating system. The incident elements of a heterogeneous connector may be implemented with different\nprogramming languages or software frameworks and may run on different operating systems. CORBA, web services, and messaging\nare typical implementation technologies for heterogeneous connectors. Heterogeneous connectors are usually implemented with the broker design pattern. This means that a message system might be\nimplemented with the message sender and receiver modules implemented in different programming languages or on different\nplatforms. Suppose that the two subsystems in Figure 2.4 are implemented in different programming languages and deployed on\ndifferent platforms of two networked computer systems. This illustrates the broker design pattern with the following modifications. First, the proxy object and the message sender module will be implemented in the same programming language, and run on the same\ncomputer system, as subsystem 1. The skeleton object and the message receiver module will be implemented in the same\nprogramming language, and run on the same computer system, as subsystem 2. Second, an application-level protocol will be defined\nto represent operations and argument values in a platform-and language-independent way. Both the proxy object and the skeleton\nobject will support data marshaling (transforming data from a platform-or language-dependent form to the platform-and language-\nindependent form) and unmarshaling (transforming data from the platform-and language-independent form to a platform, and language-\ndependent form). When the proxy object receives a method call from subsystem 1, it will marshal the argument values and send the\nresulting values and operation name to the skeleton object on the other side of the network, which will unmarshal the argument values\ninto the form used by subsystem 2. Upon receiving the return value, the skeleton object will marshal it and send it back to the proxy\nobject, which will then unmarshal the return value into the form used by subsystem 1 and return it as its own return value.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 26", "position": 26, "chunk_type": "semantic", "token_estimate": 419}
{"text": "with one of its parameters passing a callback object/method (listener object) reference. When some event happens in the latter: When the proxy object receives a method call from subsystem 1, it will marshal the argument values and send the\nresulting values and operation name to the skeleton object on the other side of the network, which will unmarshal the argument values\ninto the form used by subsystem 2. Upon receiving the return value, the skeleton object will marshal it and send it back to the proxy\nobject, which will then unmarshal the return value into the form used by subsystem 1 and return it as its own return value. 2.5 An Agile Approach to Software Architecture Design\n \nTraditional software architecture designs, fundamentally based on a waterfall model (a linear process without integrating feedbacks),\ndo not emphasize the iterative refinement nature and do not use element and connector attributes to capture the key architecture\nrequirements of a software project. As a result there is big gap between a project's requirement specification and a concrete software\narchitecture for its detailed design and implementation. Another weak point of traditional architecture design is that if the deployment\nenvironment changes, which is happening more often with the economy's globalization, the architecture design must start from scratch. This book adopts an iterative, agile approach for developing software architectures that maximizes the reuse of architecture, design,\nand implementation investments. Given a project specification, an abstract high-level software architecture will first be proposed, and\nattributes will be identified for its elements and connectors. This abstract software architecture will generally be free of deployment\nconsiderations. The architecture will then go through multiple refinement processes to support particular deployment constraints. The\nunique features of this approach include the delayed binding of software connectors for more flexible implementation decisions and the\nseamless integration of multiple architecture styles in realizing different subsystems or levels of the same system. In this section we incrementally extend an artificial system into a complex software architecture integrating multiple architecture styles. The resulting system is very similar to current web architecture. This example will illustrate how specification attributes can be used to\nrefine an existing design recursively, to achieve the design objectives. This example also applies the most important software\narchitecture styles, thus serving as a preview before their formal treatment in the following chapters. Figure 2.5\n \nStand-alone data presenter", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 26", "position": 26, "chunk_type": "semantic", "token_estimate": 393}
{"text": "Let us start with the design of an architecture for presenting data in a database to a client. This is a stand-alone application for serving: data to a single user. Figure 2.5 shows a possible design, in which the client GUI module receives data retrieval criteria from the client\nand presents the selected data to the client in a graphical user interface. The data retrieval & processing module retrieves data from\nthe database following client criteria and preprocesses the retrieved data. These two modules are supposed to run in different threads\nof the same process. Now suppose the requirement specification changes and the application needs to run on a server to present the data over the Internet\nto multiple clients with matching client software. The connector between the client GUI module and the data retrieval & processing\nmodule now has a new netw\norked attribute, as shown in Figure 2.6. Because all the clients will use the same client software to access\nthe data server, the modules can be implemented in the same programming language using remote method invocation technology. If\nboth of the modules are implemented in Java, then Java RMI can be used to implement the networked connector. If both modules are\nimplemented in Windows, then Microsoft. NET remote invocation can be used to implement the networked connector. In both of these examples, the connector between the client GUI module and the data retrieval & processing module is one-initiator,\nnetworked, and signature-based. Now suppose we decide to support client GUI devices from third parties and present data in formats customizable on the server. Because we don't have control over the implementation technologies of the client GUI module, a message-and protocol-based\nconnector can provide the needed flexibility. We use HTTP as the application-level protocol on top of the TCP/IP network connection\nbetween the client-side client GUI module and the server-side modules. For flexible data presentation that is modifiable on the server,\nwe adopt the HTML markup language to specify how to present data to the client and submit client requests to the server through the\nHTTP protocol. As a result we introduce two tiers for data presentation: the server-side data presentation tier, implemented by the\nHTML generator module on the server, for dynamically generating HTML files; and the client-side data presentation tier, implemented\nby the HTML presenter module on the client side, for rendering data to the user according to the HTML markups. This is shown in\nFigure 2.7.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 27", "position": 27, "chunk_type": "semantic", "token_estimate": 410}
{"text": "Let us start with the design of an architecture for presenting data in a database to a client. This is a stand-alone application for serving: As a result we introduce two tiers for data presentation: the server-side data presentation tier, implemented by the\nHTML generator module on the server, for dynamically generating HTML files; and the client-side data presentation tier, implemented\nby the HTML presenter module on the client side, for rendering data to the user according to the HTML markups. This is shown in\nFigure 2.7. Figure 2.6\n \nNetworked data presenter\n \nNow suppose we need to support significant data processing capability on the server. We apply the divide-and-conquer approach to\nthe software architecture and divide the server-side software into three tiers: the presentation tier for generating HTML files, the\nbusiness logic tier for serious data processing, and the data source tier for documents and data persistency. If we use the layered\narchitecture style to design and implement the HTML generator and the Data retrieval & processing modules, our server-side\npresentation tier and business logic tier will be very similar to the web server and the application server of a typical web architecture. See Figure 2.8. Figure 2.7\n \nHTML and HTTP based data presenter\n \n \nFigure 2.8\n \nWeb architecture\n \n2.6 Summary\n \nSoftware architecture determines the overall structure of a software system and greatly impacts its quality. The architecture can be\nviewed from multiple perspectives including the code structure (or static structure), runtime structure (or dynamic structure), and\nmanagement structure (or deployment structure). Each type of structure consists of elements and connectors and their constraint\nattributes, which are derived from the requirements specification. T\no minimize the impact of changing project requirements and to\nmaximize the ability to reuse design and implementation, an architect should adopt an iterative process during the design phase. Initial\narchitecture designs should focus on the core functional and nonfunctional requirements; the resulting complex elements can then be\nrefined into subsystems with their own architecture designs. A good architecture solution is typically based on multiple architecture\nstyles for different subsystems or for different system abstraction levels. 2.7 Self-Review Questions\n \n1. Which of the following structures describe the static properties of software architecture? a. Software code structure", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 27", "position": 27, "chunk_type": "semantic", "token_estimate": 368}
{"text": "3 Models for Software Architecture: e\n \nObjectives of this Chapter\n \n\u2022   Introduce concepts of software architecture view models\n \n\u2022   Discuss the UML notations as modeling tools for software architecture specification\n \n\u2022   DiscussADLas a modeling tool for software architecture specification\n \n3.1 Overview\n \nSoftware architecture specifies a high level of software system abstraction by employing decomposition, composition, architecture\nstyles, and quality attributes. Every software architecture must describe its collection of components and the connections and\ninteractions among these components. It must also specify the deployment configuration of all components and connections. Additionally, a software architecture design must conform to the project's functional and nonfunctional requirements. There are many ways to describe software architecture. Box-and-line diagrams are often used to describe the business concepts and\nprocesses during the analysis phase of the software development lifecycle. These diagrams come with descriptions of components\nand connectors, as well as other descriptions that provide common intuitive interpretations. Box-and-line diagrams will be used\nthroughout this book for specification purposes. Figure 3.1 presents a box-and-line diagram for an online shopping business where customers browse the catalog and put their\nselected items in a shopping cart. After a customer checks out, the system examines the customer's credit record, updates the\ninventory, and notifies the shipping department to process the order. Figure 3.1\n \nBox-and-line diagram\n \nLines in the box-and-line diagrams indicate the relationship among components. Notice that, unlike UML, the semantics of lines may\nvary\u2014they may refer to dependency, control flow, data flow, etc. Lines may be associated with arrows to indicate the process direction\nand sequence. A box-and-line diagram can be used as a business concept diagram describing its application domain and process concepts. This\ntype of diagram helps us to understand the business concepts and to derive other software modeling and design diagrams such as\nUML. UML is one of the object-oriented solutions used in software modeling and design. We discuss this further in Section 3.2. The 4+1 view model is another way to show the functional and nonfunctional requirements of a software project. There are five views in\nthe model: the logical view, the process view, the development view, the physical view, and the user interface view. The logical view is\nused to identify software modules and their boundaries, interfaces, external environment, usage scenarios, etc. The process view\naddresses nonfunctional requirements such as module communication styles and performance issues at runtime.", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 29", "position": 29, "chunk_type": "semantic", "token_estimate": 394}
{"text": "3 Models for Software Architecture: The logical view is\nused to identify software modules and their boundaries, interfaces, external environment, usage scenarios, etc. The process view\naddresses nonfunctional requirements such as module communication styles and performance issues at runtime. The development\nview organizes the software units in well-defined ways according to the actual file or directory structure. The physical view specifies the\ndeployment infrastructure in terms of software, hardware, networking configurations, and installation for delivery purposes. All of these\nviews work with, and are validated by, the scenarios view. The user interface view provides the look and feel of the system, and it may\nalso impact other views. We explore the details of the 4+1 view model in Section 3.3. The Architecture Description Language (ADL) is another way to describe software architecture formally and semantically. A simple\nsoftware architecture specification example is demonstrated in Section 3.4. 3.2 UML for Software Architecture", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 29", "position": 29, "chunk_type": "semantic", "token_estimate": 151}
{"text": "The Unified Modeling Language (UML) is a graphical language for visualizing, specifying, constructing, and documenting the artifacts: of a software-intensive system. UML offers a standard way to draw a system's blueprints including conceptual notions such as business\nprocesses and system functions as well as concrete designs such as programming language statements, database schemas, and\nreusable software components. UML is a typical object-oriented analysis and design notation tool that provides many useful analysis\ndiagrams and even generates code skeleton. UML is widely used as a guideline for software requirement analysis and design documents, which are the basis for software\ndevelopment. Typically, UML can be used to model the problem domain; describe the user requirements; identify significant\narchitecture elements during software design, such as classes and objects; describe behavior and interactions among these elements;\nand organize the software structure, specify its constraints, describe the necessary attributes, and more. UML provides several modeling diagrams that can be grouped into two major categories: structural (static) and behavioral (dynamic). Structural software architecture describes the static structure of all software elements in a system: class hierarchy, class library\nstructure, and relationships between classes such as inheritance (is a), aggregation (has a), association (uses a), and messaging\n(method invocation). Static structural UML diagrams depict the control flow between system elements, and are time-independent. These can be class diagrams, component diagrams, deployment diagrams, etc. A dynamic software architecture describes the behavior of objects (i.e., instances of classes) in the system such as object\ncollaboration, interaction, activity, and concurrency. The related UML diagrams are sequence diagrams, collaboration diagrams,\nactivity diagrams, etc. They are many UML IDE (Interactive Development Environment) tools available; some of them are open source. The most popular UML\ntools are Rational Rose, Boland T\nogether, and Microsoft Visio. Many of these are capable of mapping from UML diagrams directly to\ncoding framework in popular programming languages such as C++, C#, and Java. The following table summarizes the 13 UML 2.0 diagrams in the structural and behavioral categories:\n \n1. Structural (Static) Diagrams\n \nDiagram\nDescription\nClass\nAn overview of classes for modeling and design. It shows how classes are statically related, but not how classes\ndynamically interact with each other. Object\nObjects and their relationship at runtime. An overview of particular instances of a class diagram at a point of time\nfor a specific case. It is based on the class diagram. Composite\nstructure\nDescribes the inner structure of a component including all classes within the component, interface of the\ncomponent, etc.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 30", "position": 30, "chunk_type": "semantic", "token_estimate": 414}
{"text": "The Unified Modeling Language (UML) is a graphical language for visualizing, specifying, constructing, and documenting the artifacts: It is based on the class diagram. Composite\nstructure\nDescribes the inner structure of a component including all classes within the component, interface of the\ncomponent, etc. Component Describes all components in a system, their interrelationships, interactions, and the interface of the system. It is an\noutline of the composition structure of components or modules. Package\nDescribes the package structure and organization. It covers classes in the package and packages within another\npackage. Deployment Describes system hardware, software, and network connections for distributed computing. It covers server\nconfiguration and network connections between server nodes in real-world setting. 2. Behavioral (Dynamic) Diagrams\n \nDiagram\nDescription\nUse case\nDerived from use-case study scenarios. It is an overview of use cases, actors, and their communication\nrelationships to demonstrate how the system reacts to requests from external users. It is used to capture\nsystem requirements. Activity\nOutline of activity\u2014s data and control flow among related objects. An activity is an action for a system\noperation or a business process, such as those outlined in the use-case diagram. It also covers decision\npoints and threads of complex operation processes. It describes how activities are orchestrated to achieve the\nrequired functionality. State machine\nDescribes the life cycle of objects using a finite state machine. The diagram consists of states and the\ntransitions between states. Transitions are usually caused by external stimuli or events. They can also\nrepresent internal moves by the object. Sequence\nDescribes time sequence of messages passed among objects in a timeline. Interaction\noverview\nCombines activity and sequence diagrams to provide control flow overview of the system and business\nprocess. Communication\nDescribes the sequence of message passing among objects in the system. Equivalent to sequence diagram,\nexcept that it focuses on the object\u2014s role. Each communication link is associated with a sequence order\nnumber plus the passed messages. Time sequence Describes the changes by messages in state, condition, and events. In the following section, we provide details of the aforementioned diagrams. 3.2.1 Structural Diagrams", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 30", "position": 30, "chunk_type": "semantic", "token_estimate": 346}
{"text": "The structural description diagrams comprise class and object diagrams; component, structure, and package diagrams; and: deployment diagrams. We discuss each in turn. 3.2.1.1 Class Diagram\n \nThe class diagram provides a static view of the system. It captures the vocabulary of the designed system. It is the foundation diagram\nof the system design and the most frequently used UML diagram as well. Class diagrams can be derived from use-case diagrams or from text analysis of the given problem domain. A class diagram is\ngenerated by system analysts and designers and will be iteratively refined in the subsequent phases during the software development\nlife cycle. Class diagrams describe each individual class with its type, interface, properties, and methods. The accessibility (visibility) of each\nattribute and operation can also be specified. Popular accessibility modifiers include private, public, protected, and default. One important part of a class diagram is the interface of each class. A class interface provides the behavioral contracts that the class\nmust support. There are three main relationships among classes: inheritance, aggregation, and association. These relationships can be represented\ngraphically in a class diagram. For each relationship, multiplicities among classes can also be denoted. Typical multiplicity types\ninclude one-to-one, one-to-many, and many-to-many mappings. In UML multiplicity notations, 1 stands for one instance, 0 stands for no\ninstance, 0..1 stands for zero or one instance, and 1..* stands for at least one instance. Figure 3.2 shows a class diagram for an online purchase order processing system. Here we see all kinds of relationships among\nclasses such as inheritance (represented using hollow triangle arrows), aggregation (represented using hollow diamond arrows), and\nassociation (lines without arrows). The multiplicity indicators are also shown. Generally, the diagram describes the logical structure of a\npurchase order system that consists of six classes. The customer class is the base class of new and existing. A customer can\nplace zero or more orders. Each order consists of multiple itemlines, which in turn, contain items. A class diagram may be refined from time to time during the software development life cycle. Object diagrams and component\nstructure diagrams can be derived directly from a class diagram. Other dynamic behavioral diagrams such as sequence diagrams and\ncommunication (collaboration) diagrams are also based on the class diagram. Figure 3.2\n \nClass diagram\n \nWe will revisit class diagrams in Chapter 4 when we discuss the methodology of object-oriented design in detail.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 31", "position": 31, "chunk_type": "semantic", "token_estimate": 396}
{"text": "The structural description diagrams comprise class and object diagrams; component, structure, and package diagrams; and: Other dynamic behavioral diagrams such as sequence diagrams and\ncommunication (collaboration) diagrams are also based on the class diagram. Figure 3.2\n \nClass diagram\n \nWe will revisit class diagrams in Chapter 4 when we discuss the methodology of object-oriented design in detail. We will explore many\nissues related to specifying relationships among classes (e.g., inheritance, dependency, association, aggregation, and composition) in\nestablishing the logical model of a system. 3.2.1.2 Object Diagram\n \nObjects are the instances of classes. The object diagram is used to describe a sample subset of objects in the system at a specific\npoint in time. This diagram shows a snapshot of class instance connection and interaction. It is derived from the preceding class\ndiagram and is a concrete example of the class diagram at runtime. Many other behavioral diagrams (sequence diagrams,\ncommunication diagrams, and interaction diagrams) may make reference to the object diagram. Figure 3.3 shows an object diagram based on the class diagram in Figure 3.2. Each rectangular box in the diagram represents an\nobject that is an instance of some class. The diagram tells us that the customer with identification #1234 has ordered two items: book\nand gift. 3.2.1.3 Composite Structure Diagram\n \nThe composite structure diagram is used to describe the composition of interconnected elements or the collaboration of runtime\ninstances. There are two basic notations in a composite structure diagram: collaboration (represented using a dashed eclipse) and\nstructured class (represented using a rectangular box). Each structure class may have an annotation that indicates its role in the\ncollaboration. For example, Figure 3.4 describes two classes involved in an OrderProcess collaboration. The Customer class\nplays the role of \u201cbuyer\u201d and the Order Processing System plays the role of \u201cseller.\u201d Notice that OrderProcess is neither a\nclass nor an object, it is a collaboration.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 31", "position": 31, "chunk_type": "semantic", "token_estimate": 312}
{"text": "Figure 3.3\n \nObject diagram\n \n \nFigure 3.4\n \nSimple composite structure\n \n3.2.1.4 Component Diagram\n \nA component is neither a class nor an object. A component is a deployable, reusable building block used in software design and\ndevelopment. For example, a JavaBean component is deployed in a jar file, an EJB component is deployed in an ear file, and a. NET\ncomponent is deployed in a. dll file. Each component has an interface to expose its services and hide its implementations. The\ninterface is the contract between a reusable component and its clients. Figure 3.5\n \nComponent diagram\n \n \nFigure 3.6\n \nAnother example of a UML 2 component diagram\n \nUML 2.0 introduced a new notation for components and their connections. A lollipop shape of a component represents an implemented\ninterface. A cup shape represents the required interface, and the required interface must be provided by some other components. In a\ncomponent diagram, some of the components may exist and be available in-house or on the market. Other components are designed\nand developed by those working on the project. Figure 3.5 shows a component diagram for a shopping cart application. The cart component provides services to front-end GUI\ninterfaces such as ASP, JSP, or PHP web pages. The cart component itself may need services from other components: catalog,\ninventory, shipping, and credit-check. The component diagram in Figure 3.6 shows four components: the clinic component, the billing component, the patient component,\nand the doctor component. The clinic component provides the following services (in the form of interface): make appointment by\npatient, update appointment by patient, and update schedule by doctor. The clinic component also needs services from the billing\ncomponent, patient component, and doctor component.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 32", "position": 32, "chunk_type": "semantic", "token_estimate": 278}
{"text": "3.2.1.5 Package Diagram\n \nA package is represented by a tabbed folder that indicates where all included classes and subpackages reside. Packages play a\nsimilar role as a directory for grouping files in a file system; they allow the organization of all closely related classes in one \u201ccontainer.\u201d\n \nFor example, namespaces in. NET and packages in Java provide well-formed structures for class accessibility and class correlations. We can organize functionally related classes in the same package so that these classes can access each other within a default\naccessibility or visibility. We can also organize related packages in a same parent package to build a class and package hierarchy just\nlike. NET class library and Java API. Another reason for using the package organization is namespace sharing; in this way, all classes\nin the same package have a unique name but they may have the same name in different packages (namespaces). A package diagram shows the dependency relationship between packages in which a change of one package may result in changes\nin other packages. The package diagram may also specify the contents of a package, i.e., the classes that constitute a package and\ntheir relationships. The use of package diagrams to represent system structures can help reduce the dependency complexity and\nsimplify relationships among groups of classes. Figure 3.7 shows a simple package diagram in which the checkout package, containing all checkout-related classes, depends on\nclasses grouped in the shopping cart package. Same with the user interface package which has all GUI presentation classes to render\nthe catalog and shopping cart. The package diagram also describes the dependency relationship of the package units. This diagram\nis often used for component-based software architecture design. 3.2.1.6 Deployment Diagram\n \nA deployment diagram depicts the physical configuration of the software system deployed on hardware server nodes and the network\nbetween the nodes (defined as protocols). This diagram is generated in the later phase of the software development life cycle. All\ncomponents in the system must be deployed on servers to provide services via network protocols. Component diagrams are the basis\nfor deployment diagrams. Figure 3.7\n \nPackage diagram\n \n \nFigure 3.8\n \nDeployment diagram\n \nUML uses a cube symbol to represent a computing resource node; such a resource can be a hardware device or a deployed software\nsubsystem. For example, data servers, web servers, and application servers can be nodes and are described by cubes in a\ndeployment diagram.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 33", "position": 33, "chunk_type": "semantic", "token_estimate": 400}
{"text": "Figure 3.7\n \nPackage diagram\n \n \nFigure 3.8\n \nDeployment diagram\n \nUML uses a cube symbol to represent a computing resource node; such a resource can be a hardware device or a deployed software\nsubsystem. For example, data servers, web servers, and application servers can be nodes and are described by cubes in a\ndeployment diagram. The link between nodes is the network connection depicted by the network protocol. The deployment diagram is\nused widely to model and design distributed software systems. Figure 3.8 shows a deployment diagram in which a shopping cart is deployed in a web server, the business transaction component is\ndeployed in a separate application server, and the database is available in a data server. The other services are available from three\ncomponents deployed by the corresponding service providers. 3.2.2 Behavioral Diagrams\n \nThe behavior description diagrams comprise use case diagrams, activity diagrams, state machines, interaction diagrams, sequence\ndiagrams, collaboration diagrams, and timing diagrams. We discuss each in turn.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 33", "position": 33, "chunk_type": "semantic", "token_estimate": 159}
{"text": "3.2.2.1 Use Case Diagram: Use case diagrams describe user requirements in terms of system functionality as a contract between the users (actors) and the\nsoftware system. This diagram consists of actors, use cases, and the links between them. An example of a use case is shown in Figure\n3.9. Figure 3.9\n \nUse case diagram\n \nAn actor in a use case diagram is an external \u201cuser\u201d; this may be a human end user, an application, an external device, or another\nsystem. Each use case is a meaningful operational work scenario. That is, use cases are scenario-oriented in the sense that each is a\nsequence of working steps to be carried out by classes in order to provide the required system functionality. The detailed steps are\nspecified in a separate note including the pre-and post-conditions of the action in the sequence. The (simple) connection link from actor to use case shows the direction of actors using the use case. An <<include>> link, a special\nkind of link, from one use case to another, indicates that the first use case reuses or includes the second use case and is needed to\ncomplete the work necessary to fulfill the requirement. The <<include>> link is a dashed line with an arrow pointing to the reused\nuse case. An <<extend>> link, another special link, shows a newly created optional use case from an existing use case. It covers\nalternative cases that may or may not necessarily take place. An <<extend>> link is also a dashed directed line with an arrow\npointing toward the extended use case; these special links are labeled accordingly. A complete use case diagram describes a set of scenarios; scenarios may have a set of subordinate, or lower-level, use cases. Use\ncase diagrams are used in the early stages of the software development life cycle, such as analysis and design. These diagrams are\none of the most frequently used UML diagrams for object-oriented system analysis and design. System analysts employ use case diagrams to capture and verify user requirements. Architects and designers use these diagrams to\nderive structural diagrams (e.g., class diagrams) and behavioral diagrams (e.g., sequence diagrams and communication diagrams). 3.2.2.2 Activity Diagram\n \nAn activity diagram is used to describe complex business processes. This diagram typically involves complex workflow, decision\nmaking, concurrent executions, exception handling, process termination, etc. An activity diagram is a workflow-oriented diagram\ndescribing the steps in a single process.", "domains": ["Design Patterns"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 34", "position": 34, "chunk_type": "semantic", "token_estimate": 400}
{"text": "Figure 3.10\n \nActivity diagram\n \n3.2.2.3 State Machine Diagram\n \nA state machine diagram, called a state chart in UML 1. x, is widely used for embedded systems and device software analysis and\ndesign. It is an event-oriented diagram in which the system's elements change their states in response to external or internal stimuli\n(such as time events or other system events). These diagrams are ideal for specifying the internal behavior of objects. In a state machine diagram, a state is a rounded rectangle with three subdivisions: state name, state variables, and state activities. A\nstate is a situation in which an object meets conditions, takes actions, and waits for a new event. When a new event takes place in the\ncurrent state, the machine will perform specified actions and then will enter a new state (the next state). A complex composite state may have a subordinate state diagram. The sub-states in a composite state may be transited from one to\nthe next, sequentially or concurrently. Each state machine diagram has one starting point in a solid black circle and has one or more endpoints, the latter indicated by eye-\ncircles. The transition links between states are solid lines with arrowheads to indicate direction. State diagrams help software\ndevelopers understand how a system responds and handles external events and the corresponding event-triggering condition. Figure 3.11 shows a state machine diagram that depicts a login process. Initially, the state machine executes a busy loop to wait for\nuser login, and then the username/password pair is verified. If the pair matches the system records, the login is confirmed; otherwise\nthe login is rejected. 3.2.2.4 Interaction Overview Diagram\n \nAn interaction overview diagram describes the control flow of the interactions rather than the message. It is a variant of the activity\ndiagram. The nodes in an interaction overview diagram represent either a reference to an existing diagram (ref), a basic interaction\nelement [activity diagram(ad)], or a sequence diagram(sd)]. Figure 3.11\n \nState machine diagram", "domains": ["Design Patterns", "Design Principles"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 35", "position": 35, "chunk_type": "semantic", "token_estimate": 327}
{"text": "Each node (or frame) can be an interaction diagram such as a sequence diagram, communication diagram, activity diagram, or nested: interaction overview diagram. A reference node, indicated by \u201cref\u201d in the upper left-hand corner of the frame, points to an existing\ndiagram, while the basic element displays the frame's dynamic interaction diagram. A basic element is indicated by an \u201cad\u201d label for an\nactivity diagram, an \u201csd\u201d label for a sequence diagram, or a \u201ccd\u201d label for a communication diagram, and so on. The interaction\noverview diagram is a high-level abstraction of an interaction overview description. Figure 3.12 presents an example interaction overview diagram showing reference diagrams that point to other UML diagrams and one\n\u201cad\u201d diagram displaying a detailed activity diagram. Figure 3.12\n \nInteraction overview diagram\n \n3.2.2.5 Sequence Diagram\n \nA sequence diagram is one of the most important and widely used UML diagrams for software system analysis and design. It is a time-\noriented interaction diagram showing the chronological sequence of messages between objects. Usually, one sequence diagram\ncorresponds to one use case. Each participant object in this diagram has a vertical timeline for its life cycle. Time goes forward along with the downward timeline. Each vertical timeline has a number of narrow rectangular boxes (called activations) representing the object-activated state in which it\nreceives or sends out messages. Each activation box may also have a self-recursive directed link pointed back to itself, indicating that\nthe object passes messages to itself. An activation may also branch or fork many separate lifelines for the if-selection scenario\nconditions; eventually all forked lines will join together. Passing messages between objects is represented by a horizontal arrow link from the source to the destination. A simple transfer\nmessage line, represented by a solid line with an arrowhead, transfers control from one object to the other. An object can send a\nsynchronous message to another object by a line with a full arrowhead. A synchronous message means that the sender must wait for a\nreply from the target object before it can move forward in the timeline. An object can also send an asynchronous message to another\nobject, which is indicated by a line with a half arrowhead. The sender of an asynchronous message can continue its work down the\ntimeline without waiting for a return message from the target object. Figure 3.13 shows a simplified sequence diagram for online shopping. The sequence of message exchanges starts from the cart\nobject.", "domains": ["Design Patterns", "Design Principles"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 36", "position": 36, "chunk_type": "semantic", "token_estimate": 407}
{"text": "Figure 3.13\n \nSequence diagram\n \n3.2.2.6 Communication or Collaboration Diagram\n \nThe UML communication diagram, known as the collaboration diagram in UML 1. x, is a message-oriented diagram that describes all\nmessage passing sequences, flow control, object coordination, etc., among the objects that participate in certain use cases. It\nsummarizes how objects in the system receive and send messages. It is an extension of the static object diagram in which the links\nbetween objects represent association relationships. Above the links in a communication diagram are the numbered messages,\nindicating the order in which they are sent or received. The messages tell the receiver to perform an operation with specified\narguments. Every communication diagram is equivalent to a sequence diagram, i.e., a communication diagram can be converted to an\nequivalent sequence diagram and vice versa. These two types of diagrams provide a message-oriented and time-oriented view,\nrespectively. Figure 3.14 shows an example of a communication diagram. It is equivalent to the sequence diagram shown in Figure 3.13 except that\nmessage names are given. Figure 3.14\n \nCommunication diagram\n \n \nFigure 3.15\n \nTiming diagram\n \n3.2.2.7 Timing Diagram\n \nThe timing diagram is a new diagram in UML 2.0. It combines the state diagram and time sequences to show the dynamic view of state\nchange caused by external events over time. It is often used in time-critical systems such as real-time operating systems, embedded\nsystem designs, etc. Figure 3.15 shows a timing diagram for seasonal discount air ticket prices. 3.3 Architecture View Models\n \nA model is a complete, simplified description of a system from a particular perspective or viewpoint. There is no single view that can\npresent all aspects of complex software to stakeholders. View models provide partial representations of the software architecture to\nspecific stakeholders such as the system users, the analyst/designer, the developer/programmer, the system integrator, and the system\nengineer. Software designers can organize the description of their architecture decisions in different views. Stakeholders can use a\nview to find what they need in the software architecture. The 4+1 view model was originally introduced by Philippe Kruchten (Kruchten, 1995). The model provides four essential views: the\nlogical view, the process view, the physical view, and the development view. The logical view describes, for example, objects and their\ninteractions; the process view describes system activities, their concurrency and synchronization; the physical view describes the", "domains": ["Design Patterns"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 37", "position": 37, "chunk_type": "semantic", "token_estimate": 387}
{"text": "mapping of the software onto the hardware, the server, and the network configuration; and the development view describes the: software's static structure within a given development environment. There is also another view called the scenario view; this view describes the scenarios that capture the most important aspects of the\nfunctional requirements, drive the system design, and validate the system. The 4+1 view model is a multiple-view model that addresses\ndifferent aspects and concerns of the system. The 4+1 view model standardizes the software design documents and makes the design\neasy to understand by all stakeholders. Figure 3.16\n \n4+1 view model\n \nWe extend the 4+1 view model with one more view, the user interface (UI) view. The UI view, for end users of the software system,\ndescribes the graphical user interface to verify and validate the user interface requirements; these significantly impact the system\nusability and other quality attributes. Figure 3.16 shows the 4+1 view model extended with our fifth view, the user interface view. The scenario view is coherent with the other\nfour views, whereas the user interface view complies with the scenario view and is supported by the other four views. 3.3.1 The Scenario View\n \nThe scenario view describes the functionality of the system, i.e., how the user employs the system and how the system provides\nservices to the users. This view provides a foundation for the other four views and lets them work together seamlessly and coherently. It\nhelps designers to discover architecture elements during the design process and to validate the architecture design afterward. So, the\nscenario view helps to make the software architecture consistent with functional and nonfunctional requirements. The UML use case diagram and other verbal documents are used to describe this view. The stakeholders of this view are end-users,\narchitects, developers, and all users of the other four views. Figure 3.9 on page 49 describes a use case diagram for online shopping. The scenario view is used to drive architecture design in the earlier phases of software development and is also used for software\nvalidation at later phases of the development cycle. 3.3.2 The Logical or Conceptual View\n \nThe logical view is based on application domain entities necessary to implement the functional requirements. It focuses on functional\nrequirements, the main building blocks, and key abstractions of the system. The logical view is an abstraction of the system's functional\nrequirements. It is typically used for object-oriented (OO) modeling from which the static and dynamic system structures emerge.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 38", "position": 38, "chunk_type": "semantic", "token_estimate": 412}
{"text": "mapping of the software onto the hardware, the server, and the network configuration; and the development view describes the: The logical view is an abstraction of the system's functional\nrequirements. It is typically used for object-oriented (OO) modeling from which the static and dynamic system structures emerge. The\nlogical view specifies system decomposition into conceptual entities (such as objects) and connections between them (such as\nassociations). This view helps to understand the interactions between entities in the problem space domain of the application and their\npotential variation. In an object-oriented system, the architecture elements may be classes and objects. The logical view is typically supported by UML static diagrams including class/object diagrams and UML dynamic diagrams such as\nthe interaction overall diagram, sequence diagram, communication diagram, state diagram, and activity diagram. The class diagram is\nused to describe the conceptual or logical view. A class diagram defines classes and their attributes, methods, and associations to\nother classes in the system. A class diagram is static in the sense that it does not describe any user interaction nor any sequence of\nmodule interaction in the system. A block diagram can also be used to provide an overview of the whole system. A sequence diagram shows how objects in the system\ninteract. A communication diagram shows system objects and the message passing between them in time order. In summary, the logical view points out all major tasks the system must complete, and presents the major components and their static\nrelationships. The stakeholders of the logical view are the end-users, analysts, and designers. We can apply an object-oriented design\nmethodology in the logical view because the view itself is object-oriented.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 38", "position": 38, "chunk_type": "semantic", "token_estimate": 277}
{"text": "Figure 3.17\n \nPackage diagram in the development view\n \n3.3.3 The Development or Module View\n \nThe development view derives from the logical view and describes the static organization of the system modules. Modules such as\nnamespaces, class library, subsystem, or packages are building blocks that group classes for further development and\nimplementation. This view addresses the subsystem decomposition and organizational issue. The software is packaged and\npartitioned into small units such as program libraries or subsystems created by many teams of developers. Each package has its own\nvisibility and accessibility as package or default scope visibility (see static structure discussion on page 42). The development view maps software component elements to actual physical directories and files. UML diagrams such as package\ndiagrams and component diagrams are often used to support this view. The stakeholders of this view can be programmers and\nsoftware project managers. Figure 3.17 shows a simple development view using a package diagram. 3.3.4 The Process View\n \nThe process view focuses on the dynamic aspects of the system, i.e., its execution time behavior. This view also derives from the\nlogical view. It is an abstraction of processes or threads dealing with process synchronization and concurrency. It contributes to many\nnonfunctional requirements and quality attributes such as scalability and performance requirements. The process view looks at the system's processes and the communications among them. A software system can be decomposed into\nmany runtime execution units. How to organize all execution units at runtime is presented in this view. The quality attributes such as\nperformance, scalability, concurrency, synchronization, distribution, and system throughput are all addressed in the process view. This\nview maps functions, activities, and interactions onto runtime implementation with a focus on nonfunctional requirements as well as the\nimplementation of the functional requirements. The process view takes care of the concurrency and synchronization issues between subsystems. It can be described at several levels\nof abstraction, from independently executing logical networks of communicating programs to basic tasks running within the same\nprocessing node. The process view must also address nonfunctional requirements such as multithreading and\nsynchronous/asynchronous communications for performance and availability. The UML activity diagram and interaction overview\ndiagram support this view. Figure 3.18 presents an activity diagram that documents the process view. Notice that after the check credit step, two processes are\nspawned to run concurrently. The stakeholders of this view are the developers and integrators.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 39", "position": 39, "chunk_type": "semantic", "token_estimate": 396}
{"text": "Figure 3.18\n \nActivity diagram in the process view\n \nA physical view also takes into account the system's nonfunctional requirements such as system availability, reliability (fault-tolerance),\nthroughput performance, scalability performance, and security. For example, software can be delivered in different hardware and\nnetworking layouts, which will result in significant differences in these quality attributes. Figure 3.19\n \nDeployment diagram in the physical view\n \nThe system topology in terms of hardware, network, and other infrastructure is all part of this view. This view explains the nonfunctional\nrequirements and quality attributes such as performance, availability, reliability, and scalability. The physical view must address network\nconnections and communication protocols such as server nodes and multi-tier distributed environment configurations. The UML\ndeployment diagrams and other documentation are often used to support this view. The stakeholders of this view are system installers, system administrators, system engineers, and operators. Figure 3.19 presents an\nexample of a deployment diagram showing that the order processing system is deployed on two servers. 3.3.6 The User Interface View\n \nThe User Interface (UI) view is an extended view that provides a clear user-computer interface view and hides implementation details. This view may be provided as a series of screen snapshots or a dynamic, interactive prototype demo. Any modification on this view will\nhave direct impact on the scenarios view. The screenshot in Figure 3.20 shows a GUI user interface for an online shopping cart.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 40", "position": 40, "chunk_type": "semantic", "token_estimate": 231}
{"text": "Figure 3.20\n \nForms in the user interface view\n \nIn summary, the 4+1 view is an architecture verification technique for studying and documenting software architecture design. Each\nview provides a window into the different aspects of the system. The 4+1 view covers all aspects of a software architecture for all\nstakeholders. The views are interconnected; thus, based on the scenarios view, we can start with the logical view, move to the\ndevelopment or process view, and finally go to the physical view. The user interface view is also established during this process. The 4+1 view architecture model is available in the Rational Rose IDE kit. 3.4 Architecture Description Language (ADL)\n \nAn ADL is a notation specification providing syntax and semantics for defining software architecture. It also provides designers with the\nability to decompose components, combine components, and define interfaces of components. An ADL is a formal specification\nlanguage with well-defined syntax and semantics used to describe architecture components and their connections, interfaces, and\nconfigurations. Garlan and Shaw (1996) list the following requirements for an ADL:\n \n\u2022   Composition: \u201cIt should be possible to describe a system as a composition of independent components and connections.\u201d Large\nsystems should be built from constituent elements, and it should be possible to consider each element independently of the system. \u2022   Abstraction: \u201cIt should be possible to describe the components and their interactions in a way that describes their abstract roles in a\nsystem.\u201d It should not be necessary to consider implementation issues while specifying the architecture. \u2022   Reuse: Reusability should be built-in at the component and connection level. The derivation of architecture patterns should also be\nsupported to facilitate the reuse of architecture descriptions. \u2022   Configuration: Architecture descriptions should enable comprehension and modification of an architecture without examination of\neach component and connector. \u2022   Heterogeneity: \u201cIt should be possible to combine multiple, heterogeneous architectural descriptions.\u201d\n \n\u2022   Analysis: The use of an ADL should facilitate the analysis of an architecture design. Analysis might include consideration of\nthroughput, deadlock, input/output behavior, and scheduling. A number of ADLs have been proposed over the last few years. These include UniCon and Wright, both from CMU; C2sadel from UC\nIrvine and USC; Rapide from Stanford; and Darwin from Imperial College, London. Acme is another ADL available in the research\ncommunity. UML can also provide many of the artifacts needed for architecture descriptions, but is not a complete or sufficient ADL.", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 41", "position": 41, "chunk_type": "semantic", "token_estimate": 399}
{"text": "Acme is another ADL available in the research\ncommunity. UML can also provide many of the artifacts needed for architecture descriptions, but is not a complete or sufficient ADL. Let's take a close look at one of the ADLs listed earlier. Acme provides a formal and semiformal way to describe a software\narchitecture as a static structure in a high-level of abstraction. This ADL provides many building block elements for architecture design\ndescription. Three of these basic elements are components, connectors, and systems; additional elements include ports, roles,\nrepresentations, and rep-maps. Component elements can be any computing or data store units. Connectors represent interactions\namong components. The connector elements implement the communication and interactions among components in a system, such as\nsynchronous or asynchronous communications. Components and connectors in Acme play the same roles as boxes and lines in the block (box-and-line) diagram. However, they have\na more specific purpose. For example, components have interfaces that are defined by a set of ports. Each port identifies a contact\npoint between the component and its clients. A component may provide multiple interfaces by using different types of ports. A simple\nport may represent only a single procedure signature. Connectors also have interfaces defined by a set of roles. Each role represents an interaction participant of the connector. A simple\nbinary connector has two roles, such as the caller and callee roles of an RPC connector, the reading and w\nriting roles of a pipe, or the\nsender and receiver roles of a message passing connector. Multiple role connectors may serve multiple roles; for example an event\nbroadcast connector might have a single event-publisher role and multiple event-receiver roles.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 41", "position": 41, "chunk_type": "semantic", "token_estimate": 277}
{"text": "Here, we present several examples showing how the Acme ADL and the AcmeStudio tool work together. As shown in the following screenshot, a user can conveniently construct an architecture design using the AcmeStudio tool. The simple\ndesign consists of two components, a client and a server, connected by a connector. This architecture style is the client/server model. We can define the name and properties of each component and the connector in the diagram. The diagram can be translated by\nAcmeStudio to a specification in the Acme language. Any constraints preset by designers in the specification can be examined by\nAcmeStudio. The AcmeStudio also has plug-ins for many other checks, such as portability analysis. The Acme specification can also\nbe used to construct a code framework in popular programming languages such as C++. The next screenshot shows the architecture description (in Acme) generated automatically by AcmeStudio. The architecture description generated by AcmeStudio may be translated into C++ or Java implementation as illustrated here. System event-listener =\n{\n    Component Client = { Port send-request; };\n    Component server = { Port receive-request; };\n    Connector broadcast = {\n      Roels {event-announcer, event-receiver}\n    };\n    Attachments {\n      Server.receive-request to broadcast.event-anouncer;\n      Client.send-request to broadcast.event-receiver;\n    }\n}\nThe next screenshot shows an example of multiple users with a single-server architecture design. There are multiple event-receivers for a single event-announcer in this simple architecture. The following is the ADL architecture\ndescription generated by AcmeStudio.", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 42", "position": 42, "chunk_type": "semantic", "token_estimate": 234}
{"text": "From the AcmeStudio demo we see that an ADL can be used to describe an architecture design using a description language with its\nown syntax and grammar. A software architecture specified by an ADL can be used to generate the implementation code, which\nmakes the developer's job much easier. 3.5 Summary\n \nDecomposition is the most important step in software design. The separation of software architecture into multiple views helps by\nreducing complexity; it also allows for the optimization of design guidelines such as low coupling and high cohesion within and between\nelements of a system. Multiple architecture views can also help with design trade-offs between software quality attributes. An architecture design is based on the software requirement specification and generated in the design phase of the software\nengineering life cycle. The software architecture must satisfy the functional requirements as well as the nonfunctional requirements. UML is a common modeling language for specifying complex software systems. It is widely accepted in the software industry for\nsoftware analysis and design. This chapter discussed how to use UML to specify software architectures, to simplify the OO design, and\nto improve software design quality. UML notations are useful tools in describing software architectures. UML is also used in the 4+1\nview model. This view model describes not only the functional requirements but deals with nonfunctional requirements as well. The 4+1\nview model is a blueprint for the next phase of software development. This model derives the software architecture's description from several viewpoints. Different views represent different aspects of the\nsoftware; all views are based on use cases or the scenario view. The user interface view (added by the authors) is an end-user external\nview supported by all the other views, including the scenario view. In this chapter, we also introduced Architecture Description Languages (ADLs); these are formal or semi-formal notations to describe\nsoftware architecture. In the next part of this book, we will discuss all the architecture styles in detail and you will find a case study chapter showing different\nstyles applied to the same problem, which results in different quality attributes. 3.6 Self-Review Questions\n \n1. Which of the following notations is used to support the logical view? a. Sequence diagram\n    b. Collaboration diagram\n    c. State diagram\n    d. All of the above\n2. Which of the following notations is used to support the physical view? a. Sequence diagram\n    b.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 43", "position": 43, "chunk_type": "semantic", "token_estimate": 395}
{"text": "Which of the following notations is used to support the physical view? a. Sequence diagram\n    b. Collaboration diagram\n    c. State diagram\n    d. None of the above\n3. Activity diagrams are used to support the process view. a. True\n    b. False\n4. Deployment diagrams are used to support the physical view. a. True\n    b. False\n5. Component diagrams are used to support the development view. a. True\n    b. False\n6. The software submodules and their interfaces are described in the logical view. a. True\n    b. False\n7. Concurrency control activity is part of the process view. a. True\n    b. False\n8. System and network configuration decisions are part of the physical view", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 43", "position": 43, "chunk_type": "semantic", "token_estimate": 111}
{"text": "a. True: True\n    b. False\n9. Software architecture is concerned only with functional requirements. a. True\n    b. False\n10. Prototyping can be used to support UI design. a. True\n    b. False\n11. ADL is a programming language. a. True\n    b. False\n12. ADL can produce target code. a. True\n    b. False\n13. ADL is used only for software architecture specification. a. True\n    b. False\n14. UML diagrams are used for system analysis and design. a. True\n    b. False\n15. Use case diagrams are generated in the early stages of the SDLC, whereas deployment diagrams are generated in the later\nstages of the SDLC. a. True\n    b. False\n16. Composite structure diagrams are based on object diagrams\n    a. True\n    b. False\n17. Component diagrams are based on object diagrams. a. True\n    b. False\n18. A UML diagram must provide a complete view of the entire software system. a. True\n    b. False\n19. A component is a class or an object. a. True\n    b. False\n20. Asynchronous message invocation can be expressed in sequence diagrams. a. True\n    b. False\n21. Conditional branching can be represented in sequence diagrams. a. True\n    b. False\n22. An activation in an object lifeline may have its own cycle message pointed back to itself in a sequence diagram. a. True\n    b. False\n23. An interaction overview diagram is based on all low-level interaction diagrams. a. True\n    b. False\nAnswers to the Self-Review Questions\n \n1. d 2. d 3. a 4. a 5. a 6. a 7. a 8. a 9. b 10. a 11. b 12. a 13. b 14. a 15. a 16. a 17. a 18. a 19. b 20. a 21. a 22. a 23. a\n \n3.7 Exercises\n \n1. List all interaction UML diagrams. 2. List all structural UML diagrams. 3. List all early phase SDLC UML diagrams. 4. List all late phase SDLC UML diagrams. 5. Describe the relationship between sequence diagrams, communication diagrams, and interaction diagrams. 6. Enumerate the problem domains suitable to state machine diagrams. 7. List problem domains suitable to time diagrams. 8. In what case is the activity diagram a good choice? 9. What is ADL? 10. What is the 4+1 view model? 11. Describe the logical view in the 4+1 view model. 12. Does the 4+1 model work only with object-oriented design methodology? 13. Can ADL support a non-object-oriented model system? 14. Which diagrams are the static UML diagrams? 15.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 44", "position": 44, "chunk_type": "semantic", "token_estimate": 402}
{"text": "a. True: Which diagrams are the static UML diagrams? 15. Which diagrams are the dynamic UML diagrams? 16. Is the component diagram used only for component-based design? 17. Is a 4+1 view model changed once it is released?", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 44", "position": 44, "chunk_type": "semantic", "token_estimate": 38}
{"text": "18. Is an ADL specification changed once it is released?: 3.8 Design Exercises\n \n1. Draw a use case diagram for an ATM machine transaction application software. 2. Draw a class diagram and object diagram for an ATM machine transaction application software. 3. Draw a state machine diagram and a sequence diagram for an ATM transaction application software. 4. Draw a use case diagram for a student online registration software system. 5. Draw a class diagram and an object diagram for a student online registration software system. 6. Draw a sequence diagram and a communication diagram for a student online registration software system. 7. Draw package and deployment diagrams for a student online registration software system. 8. Draw a component diagram for a hotel reservation system. Assume there are four components: customer, reservation, hotel, and\nbilling. The billing component is available for reuse. 9. Use the 4+1 view model to describe an online bookstore software architecture. 10. Use the 4+1 view model to describe an inventory control software architecture. 11. Make the inventory control system part of the online bookstore system. 12. Use ADL to describe an online camping registration system for a national park. 3.9 Challenge Exercises\n \n1. Use UML to model the software architecture of an online trusted payment system. The system users are buyer, seller, payer, and\nsecurity trustee. There are many e-payment selections available. The buyers may be consumers, corporations, or organizations. The sellers may be merchants, service providers, and others. The payers may be banks, financial services, credit card\ncompanies, etc. The trustee may be a security service, transaction auditing company, etc. The system supports payment selection, security services, transaction protection, and process flow management. The system\nadministrator is also a special system user. 2. Use UML to model the nationwide chain motel online reservation system. The system provides the reservation request service for\nroom selection, date selection, reservation deposit handling, reservation cancellation, and reservation confirmation. The system\nalso provides online information about location, direction, facility, motel photos, etc. References\n \nGarlan, David and Mary Shaw. Softw\nare Architecture: Perspectives on an Emerging Discipline. Upper Saddle River, NJ: Prentice\nHall, 1996, 39-40. Kruchten, Philippe. \u201cArchitectural Bluprint\u2014The '4+1' View\n Model of Softw\nare Architecture.\u201d IEEE Software, vol. 12, no. 6. (1995): 42-\n50. Suggested Reading\n \nAcmeWEB. \u201cThe Acme Project.\u201d ABLE Project, Carnegie Mellon University, 2006, http://www.cs.cmu.edu/~acme/ (accessed in 2007). The Object Management Group. \u201cUnified Modeling Language.\u201d Catalog of OMG Modeling and Metadata Specifications,\nhttp://www.omg.org/technology/documents/modeling_spec_catalog.htm#UML (accessed in 2007).", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 45", "position": 45, "chunk_type": "semantic", "token_estimate": 409}
{"text": "18. Is an ADL specification changed once it is released?: The Object Management Group. \u201cUnified Modeling Language.\u201d Catalog of OMG Modeling and Metadata Specifications,\nhttp://www.omg.org/technology/documents/modeling_spec_catalog.htm#UML (accessed in 2007). The \nObject \nManagement \nGroup. \u201cUML \n2.0 \nSpecification.\u201d \nUnified \nModeling \nLanguage \n(UML), \n2004,\nhttp://www.omg.org/technology/documents/formal/uml.htm. Sparx Systems Pty Ltd. \u201cUML Tutorial.\u201d 2005, http://www.sparxsystems.com.au/UML_Tutorial.htm.", "domains": ["Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 45", "position": 45, "chunk_type": "semantic", "token_estimate": 49}
{"text": "4 Object-Oriented Paradigm: m\n \nObjectives of this Chapter\n \n\u2022   Introduce concepts of object-oriented software architecture\n \n\u2022   Describe a complete object-oriented analysis and design process\n \n\u2022   Discuss general design principles in the context of object-oriented design\n \n4.1 Overview\n \nThis chapter introduces you to the object-oriented (OO) analysis and design paradigm. A very popular design approach, object\norientation applies to many of the software architecture styles introduced in later chapters. Y\nou may choose to skip this chapter if you\nare already familiar with the OO paradigm. The popularity of the OO analysis and design paradigm is the logical result of the wide adoption of OO programming languages. OO\nprogramming languages did not become popular until the early 1980s. However, their history dates back to 1960s when high-level\nprogramming languages were still in their infancy. Simula 67 is probably the first programming language that introduced OO concepts\nsuch as objects, classes, inheritance, and virtual procedures. From the 1980s on, many programming languages were designed as\npure OO languages or enhanced to include OO features. Typical examples include SmallTalk, Eiffel, C++, Ada, and CLOS. OO software engineering is a much broader concept than OO programming. It refers to the whole process of analysis, design, and\nprogramming following the object-oriented paradigm. The output of OO analysis is a model of the requirements. OO design transforms\nthis model into an architecture object design (or blueprint) to guide the next phase in software engineering\u2014code development. Finally,\nOO programming produces code by using OO programming languages or tools. There are generally three main OO principles that are\napplied throughout the whole OO software engineering process: encapsulation, inheritance, and polymorphism. \u2022   Encapsulation: Often called information hiding, the purpose of encapsulation is to separate interface from implementation. By hiding\nthe implementation details that are likely to change, encapsulation allows for flexibility in design. For example, a stack interface can\ndefine two public operations, push and pop, that are available to other parts of the program. However, its internal data organization,\ne.g., whether to use a linked list or an array for storing stack elements, can be hidden. \u2022   Inheritance: Developers can define new classes that derive from existing base classes, thus inheriting the base classes' interface\nelements (attributes and operations) and implementation of operations. Inheritance allows software reuse, hence improving the\neffectiveness of software development.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 46", "position": 46, "chunk_type": "semantic", "token_estimate": 386}
{"text": "4 Object-Oriented Paradigm: \u2022   Inheritance: Developers can define new classes that derive from existing base classes, thus inheriting the base classes' interface\nelements (attributes and operations) and implementation of operations. Inheritance allows software reuse, hence improving the\neffectiveness of software development. \u2022   Polymorphism: Polymorphism refers to the ability of an object to behave differently and assume different forms based on its\ninheritance hierarchy. Polymorphism includes vertical override operations between parent classes and derived classes, and\nhorizontal overloading operations within the same class. The object-oriented paradigm is a very important methodology in software development. Many of the architecture patterns (e.g.,\ncomponent-based, pipe and filter, data repository, etc.) can be implemented using the OO paradigm. Therefore, understanding the OO\nconcepts will be important for understanding later chapters. 4.2 Introducing the Object-Oriented Paradigm\n \nThis section starts with the review of classes and objects, which are the building blocks of an OO design. Then you will investigate\nvarious relationships that exist among classes. 4.2.1 Classes and Objects\n \nA class groups together related data and their operations. An object is an instance of a class. A class defines the attributes and\nbehaviors shared by all of its objects. Although the syntactic description of a class may vary in different languages, it generally consists\nof three elements: a class name, a list of attributes, and a list of operations. 4.2.2 Relationships\n \nIn the OO paradigm, the blueprint of a design usually is represented using a class diagram. T\no describe a system, both dynamic and\nstatic descriptions must be provided. The dynamic (behavioral) specification describes the relationships among objects, e.g., how\nobjects of the system accomplish the required functionalities via message exchanging. At the static (logical) level, the relationships", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 46", "position": 46, "chunk_type": "semantic", "token_estimate": 283}
{"text": "among classes are described. Classes may be derived from other classes by composition and by inheritance. Classes may have other: consistency requirements that are similar to those in relational database theory. Next you will have a brief review of the various static\nrelationships among classes: composition, aggregation, association, and inheritance. Figure 4.1\n \nUML representation of composition and aggregation\n \n4.2.2.1 Composition\n \nComposition represents the whole/part relationship between classes. For example, an online order may consist of multiple items. Such\na relationship is called \u201ccomposition.\u201d In composition, the parts of a class have the same lifespan as their owner, and the parts cannot\nbe involved in another composition. This restriction usually is enforced by the constructor and destructor operations of a class. For\nexample, when an online order instance is destructed, all of its items are destructed. In UML, a composition relationship is represented\nusing a solid diamond arrowhead. The diagram on the left of Figure 4.1 is an example of composition. 4.2.2.2 Aggregation\n \nA similar but more relaxed compositional relationship is called aggregation. In UML, aggregation is represented using a hollow\ndiamond arrowhead. Parts involved in an aggregation relationship do not have to share the same lifespan as the owner. In addition,\nthey may be involved in more than one aggregation relationship. For example, a faculty member can serve as a committee member of\nmultiple academic conferences at the same time. Or, to use the example of the windshield of a car, it exhibits an aggregation\nrelationship as shown on the right side of Figure 4.1. Whereas in a composition relationship, the description of an object means that all\nof its attributes must be de-allocated from memory. In an aggregation relationship these attributes may instead be reused by other\nobjects. 4.2.2.3 Association\n \nAssociation represents the logical relationship among classes. Composition is one specific type of association. In UML, an\nassociation is represented by a solid line and it has the following parts: name of the association, end type at each end of the\nassociation link, and multiplicity at each end. For example, the upper portion of Figure 4.2 describes the relationship between a\nCustomer class and an Order class. The name of the association is place-order. The solid triangle next to the name indicates the\ndirection of the association, and the association reads as Customer place-order on Order.", "domains": ["Design Principles"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 47", "position": 47, "chunk_type": "semantic", "token_estimate": 387}
{"text": "among classes are described. Classes may be derived from other classes by composition and by inheritance. Classes may have other: The name of the association is place-order. The solid triangle next to the name indicates the\ndirection of the association, and the association reads as Customer place-order on Order. The type on the left end is composition,\nwhich, together with the multiplicities \u201c1\u201d and \u201c*\u201d at both ends, indicates that one Customer can place multiple Orders, and that each\nOrder is associated to exactly one Customer. The right end arrow indicates the navigation relation. It means that from an instance of\nCustomer it is possible to reference all Order instances that are associated with that Customer. In coding, navigation usually is\naccomplished by including a collection of references to the destination class as attributes of the source class. A dependency relation can be regarded as a special type of binary association in which class X depends on class Y, if changes to the\nelements of Y lead to the changes of X. Usually class X depends on Y if X invokes Y's operation or accesses Y's attributes. For\nexample, if the Shipping Dept class needs to access the list of products in an Order to estimate the shipping cost, then the\nShipping Dept class depends on the Order class. If the Order class is recompiled, the Shipping Dept class may need to be re-\ncompiled. In UML, the dependency relationship is denoted by a dotted arrow line. The bottom part of Figure 4.2 is one example of\ndependency. In OO design, it is desirable to minimize the number of dependency relationships. This not only expedites compiling, but\nalso reduces the possibility of cascading modifications in design. Figure 4.2\n \nAn example of association\n \n4.2.2.4 Inheritance\n \nIn an OO design, very often two or more classes may have a large set of attributes and operations in common. T\no prevent repeatedly\nwriting the same code for similar classes, OO provides the inheritance mechanism. When class A is derived from class B, class A\ninherits all attributes and operations of class B unless otherwise specified (e.g., private attributes are not to be inherited by derived\nclasses). One special case of the inheritance association is polymorphism. Operations of base classes can be overridden by derived", "domains": ["Design Principles"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 47", "position": 47, "chunk_type": "semantic", "token_estimate": 381}
{"text": "classes so that a base class reference (which points to an instance of a derived class) can exhibit different behaviors at runtime.: In UML, the inheritance relationship is represented using a line with a closed arrowhead. If the line is dashed, it is a realization\nrelationship. In a realization relationship, the base class is an abstract class, i.e., a class that does not provide implementation for each\nof its operations, and the derived classes have to implement all their inherited operations. Figure 4.3 presents the inheritance\nrelationship among three classes. The Regular and Member classes derive from the Customer class. Both of these classes inherit\nattributes such as custID and totalSpending from the Customer class. However, the two derived classes also use two different\nways to track customers. For a Regular customer, a cookie number is used to track the user's browser. For a registered Member,\nuser name and password are used for identification. Registered Members receive discounts according to their shopping history. Figure 4.3\n \nAn example of inheritance\n \n4.2.2.5 Composition vs. Inheritance\n \nThe OO paradigm provides two different approaches for reusing a design: composition (aggregation) and inheritance. In practice, how\ndesigners choose between the two depends on a number of principles. For example, suppose that you have two base classes:\nPerson and House. How do you model a house owner? Do you model the HouseOwner class as a derived class of both Person\nand House ? Or would you model it as a class that has two attributes referencing Person and House, respectively? Or would you\nrather model HouseOwner as a derived class of Person but with an attribute of House ? Here are three general principles to follow\nto make the right decision:\n \n\u2022   Use the inheritance relationship only when the derived class \u201cis-a\u201d base class. For example, a HouseOwner is a Person; however,\na HouseOwner is not a House. Thus, the HouseOwner class should not inherit from the House class. \u2022   Composition (or aggregation) can be used to model the \u201chas-a\u201d relationship among classes. For example, it is natural to include an\nattribute referencing to House in the HouseOwner class, because a HouseOwner has a House. \u2022   Be careful when using inheritance. Inheritance could possibly weaken the encapsulation of an OO design (Venners, 1998). Consider the following scenario in Figure 4.4 (a). An AmericanCitizen has to pay federal tax each year, the amount of which is\nbased on the yearly income.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 48", "position": 48, "chunk_type": "semantic", "token_estimate": 404}
{"text": "classes so that a base class reference (which points to an instance of a derived class) can exhibit different behaviors at runtime.: Consider the following scenario in Figure 4.4 (a). An AmericanCitizen has to pay federal tax each year, the amount of which is\nbased on the yearly income. The calculation of tax rate is a very complicated process, and fortunately it is encapsulated in the\nReportTax() operation of the AmericanCitizen class. AmericanLawyer and AmericanProfessor are derived from\nAmericanCitizen and inherit its attributes. Notice that, in the current design, ReportTax() returns an integer. A fourth class IRS\nis implemented by another group of designers, and it invokes the ReportTax() function of each derived class to collect tax. Now\nsuppose that the system designer of AmericanCitizen decides to increase the accuracy of tax reports, and changes the return\ntype of ReportTax() to a floating point number. What happens? The implementation of IRS has to change, because\nReportTax() does not return an integer anymore. Clearly, one weakness of inheritance is that changes to the design of a base class may lead to cascading changes to derived classes\nand the users of derived classes. This problem can be solved by using a delegation mechanism provided by the aggregation\napproach. Consider the classes shown in Figure 4.4 (b). T\no handle tax related affairs, an AmericanCitizenTaxHandler class is\ncreated. Each of the AmericanLawyer \nand AmericanProfessor class has an attribute referencing an instance of\nAmericanCitizenTaxHandler. Both AmericanLawyer and AmericanProfessor provide the operation ReportTax(),\nwhich invokes the ReportTax() operation provided by AmericanCitizenTaxHandler, rounds the double number to an integer,\nand returns the result. Such delegation mechanisms allow great flexibility\u2014while the invocation interface provided to IRS can remain\nintact, the implementation of ReportTax() can be changed by replacing the tax handler classes at any time.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 48", "position": 48, "chunk_type": "semantic", "token_estimate": 298}
{"text": "Figure 4.4\n \nComposition vs. inheritance\n \nY\nou might wonder, what about polymorphism? In Figure 4.4 (a), if IRS needs to invoke the ReportTax() of a list of American\ncitizens, programmers can simply use an AmericanCitizen reference to iterate through the list and invoke the operation. However,\nit is not able to do so in Figure 4.4 (b) because AmericanLawyer and AmericanProfessor are two separate classes. Figure 4.5\n \nRefined design of Figure 4.4 (b)\n \nIn Figure 4.5 an improved design of Figure 4.4 (b) is provided. Both AmericanLawyer and AmericanProfessor realize an\ninterface called AmericanTaxPayer. AmericanTaxPayer defines a public operation ReportTax(), which has to be\nimplemented by both the AmericanLawyer and AmericanProfessor classes. On the other hand, the actual processing work of\nReportTax() is done by the AmericanCitizenTaxHandler class\u2014the ReportTax() operation of AmericanLawyer and\nAmericanProfessor simply rounds and returns the result generated by AmericanCitizenTaxHandler. Thus the design in\nFigure 4.5 enjoys the benefits provided by both inheritance and aggregation. 4.3 OO Analysis\n \nThe next two sections guide you through the complete process of OO software development. Generally an OO development process\nhas three stages: OO analysis, OO design, and OO implementation. The first stage, OO analysis, is concerned with initial domain and\nproblem requirement analysis. As a result, it establishes an object-oriented abstract model of the system to be built. The results\nproduced by OO analysis are then utilized during the design phase. In the design process, responsibilities are assigned to each class\nthat constitutes the system. The attributes and operations of each class also are determined in the design stage. Finally, the OO design\nis implemented using an OO programming language. This is followed by testing, deployment, and product maintenance. For a more\nthorough discussion of OO analysis and design, you can consult UML 2 and the Unified Process: Practical Object-Oriented Analysis\nand Design (Arlow and Neustadt, 2005). Throughout the chapter, a case study is used to illustrate the main concept of OO analysis and design. Y\nou will design a web\napplication for this case study. (However, notice that, OO analysis and design can be used in many other application domains.) Assume that you are going to construct an Order Processing System (OPS). OPS is an important part of an online store.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 49", "position": 49, "chunk_type": "semantic", "token_estimate": 373}
{"text": "\u2022   A customer can choose to cancel the transaction by clearing all items in the shopping cart. \u2022   OPS must be available as a web accessible system. Customers can use popular Internet browsers to interact with OPS. Next you will proceed with OO analysis of the OPS system. The purpose of OO analysis is to understand the application domain and\nspecific requirements of the system. The outcome of the analysis stage is a requirement specification and an initial analysis of the\nlogical structure and feasibility of the system. Different from the traditional software analysis process, OO analysis relies on two UML\ntools: use case diagram and analysis-class diagram. The UML use case diagram captures user requirements. The analysis-class\ndiagram describes the conceptual abstractions in the system and breaks down the system into components so that the complex design\nprocess can be divided and conquered. 4.3.1 Step 1: Design of a UML Use Case Diagram\n \nAn effective approach to understanding a system is to build use case diagrams to describe the functionality of a system. A use case\ndiagram consists of multiple actors and use cases. Here an actor is a role played by a user\u2014a user might be a real person, an\norganization, a computer system, or a component of the whole software system. A use case may be a concrete use case, or an\nabstract one. A use case is composed of other use cases, and can be extended by other use cases. Figure 4.6 shows the use case\ndiagram of OPS. T\no come up with the details of such a diagram, developers must go through a time-consuming interview process with\nall stakeholders of the system. As shown in Figure 4.6, OPS has three actors: the customer, the financial department, and the shipping department. A customer can\nregister an account as a new user. A customer can also interact with the system in a session to conduct a number of operations. These\noperations include logging in, logging out, adding an item into the shopping cart, deleting an item from the shopping cart, clearing the\nshopping cart, and checking out the shopping cart. Each use case (represented using an oval in Figure 4.6) is accompanied by a brief text description, which specifies the flow of events\nassociated with the use case. Based on the flow of events, sequence diagrams can be developed in the detailed-level design stage.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 50", "position": 50, "chunk_type": "semantic", "token_estimate": 398}
{"text": "Each use case (represented using an oval in Figure 4.6) is accompanied by a brief text description, which specifies the flow of events\nassociated with the use case. Based on the flow of events, sequence diagrams can be developed in the detailed-level design stage. In\nthe following, a number of use cases in Figure 4.6 are described. Figure 4.6\n \nUse case diagram of the OPS system\n \n\u2022   Register: A customer visits the registration page and specifies the desired user name and password. If there is already an existing\nuser name/password pair, the system reports error; otherwise, it reports success. When registration is completed, the user name,\npassword, real name, and the billing address are stored in a database system. \u2022   Session: When a customer logs in using the correct user name and password, the customer starts a session. During the session,\nthe system maintains a shopping cart for the user, which records the list of items the customer wants to purchase. The session is\nterminated when the user checks out the shopping cart, logs out of the system, or times out. A session consists of a list of operations. \u2022   Operation: The operation use case is an abstract use case. It is extended by more specific operations such as log in, log out, adding\nan item, removing item, clearing the cart, and checking out. \u2022   Log in: This is always the first operation of any session. When the supplied user name and password are correct, a session starts. A\nmaximum number of three trials is allowed for each user to submit the correct user name and password. The account is locked if a\nuser fails to log in after three times. \u2022   Log out: When the customer has not checked out all items in the shopping cart, the shopping cart is saved in the database so that\nwhen the customer logs in again, his shopping cart is loaded with those items. \u2022   Add item: Before an item is added to the shopping cart, the catalog and inventory database should be checked to verify availability,\ncost, and price of the item. \u2022   Remove item: By removing an item from the shopping cart, the item is put back into the inventory database.", "domains": ["Software Quality Attributes"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 50", "position": 50, "chunk_type": "semantic", "token_estimate": 370}
{"text": "\u2022   Clear shopping cart: This use case removes all items from the shopping chart. \u2022   Checkout: The user is asked to input credit card information, which is then sent to the financial department for verification. If the\ntransaction is approved, the credit card is charged; otherwise, the system prompts the user that the checkout process has failed. When the transaction is successful, instructions are sent to the shipping department. Usually in an OO design, each use case is monitored by a controller class, especially when the use case has a complex event\nflow. Sometimes a use case can be modeled as an operation, if its logic is simple. Next, you will proceed to the development of an\nanalysis class diagram. 4.3.2 Step 2: Develop an Analysis Class Diagram via Noun Extraction\n \nAnother useful tool for describing a system in its entirety is the analysis class diagram (also called a conceptual class diagram). An\nanalysis class diagram describes the key classes of a system and their interrelationships but is not the design of the system. An\nanalysis class diagram describes the functionality of the system in terms of abstractions (classes) of the concepts found in the problem\nand the domain. It captures the functionalities and logical relationships among the different elements of the system. It is a model of the\nsystem, abstracting design details so that people can better understand the system's overall architecture. In the design stage, the class\ndiagram will be further refined; the relationships among the classes might be changed or fine-tuned to trade for speed, economy, or\nother system requirements. Because the details of each class will be furnished in the design stage, a set of simpler graphical notations can be used in an analysis\nclass diagram. Many UML editors (such as Visio) provide UML stereotypes, or extensions, that include the three graphical notations\nshown in Figure 4.7: boundary class, entity class, and controller class. Boundary classes are those classes that serve as\nthe interface between a system and the outside world. These are usually in the form of graphic user interface classes (e.g., web forms,\nwindows dialogs, browser plug-in widgets, etc.) or wrapper classes of other systems (e.g., middle-ware wrappers of remote\nprocedures). Entity classes are used to represent the information stored and exchanged among elements of the system. For\nexample, the product information in OPS should be modeled as an entity class.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 51", "position": 51, "chunk_type": "semantic", "token_estimate": 397}
{"text": "Entity classes are used to represent the information stored and exchanged among elements of the system. For\nexample, the product information in OPS should be modeled as an entity class. Controller classes control and coordinate the\nactivities of other classes. Usually a controller class is associated with one specific use case or a set of closely related use cases. A controller class coordinates the interactions that are required to accomplish the use case. For example, it is appropriate to\nmodel the session of the OPS system as a controller class. The session class must maintain and keep track of all related\ninformation, such as shopping cart and customer identity information. It has to interact with other components of the system, such as the\nfinancial and shipping departments, to ensure that each operation in the session is executed. The session class handles exceptions\nthrown out by any of its operations. Figure 4.7\n \nThree types of classes in an analysis class diagram\n \n\u2022   T\no construct an analysis class diagram, developers must first identify the classes that constitute the system. One simple approach is\nto extract nouns and verbs from the use case descriptions. Nouns are candidates of classes and verbs are candidates of their\nfunctions and relations. For example, take a look at the registration use case shown in the following (where nouns are in italics):\n \n\u2022   Register: A customer visits the registration page and specifies the desired user name and passw\nord. If there is already such a user\nname/passw\nord pair, the system reports error; otherwise, it reports success. When the registration is completed, the user name,\npassw\nord, real name, and the billing address are stored in a database system. The following nouns are extracted from the register use case description. (Notice that not all of the nouns will be represented as\nclasses.) \u2022   customer: actors (which are outside of the system) need not be represented. Consequently, customer should not be a class of the\nsystem. \u2022   registration page: modeled as a boundary class. \u2022   user name: an attribute, not a class. It is modeled as an attribute of the CustomerIdentity class. \u2022   passw\nord: similarly, this is an attribute of CustomerIdentity. \u2022   username/passw\nord pair: attributes of CustomerIdentity. \u2022   system: the phrase \u201csystem reports error\u201d in the initial description of the use case is not accurate enough.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 51", "position": 51, "chunk_type": "semantic", "token_estimate": 390}
{"text": "\u2022   error: it should not be modeled as a class, following the same argument for system.: \u2022   success: following the same argument for system, RegistrationSuccessPage is created as a boundary class. \u2022   registration: refers to the registration process. Y\nou have to create a controller class named RegistrationController for\nthis use case. \u2022   real name: part of the CustomerInformation class. \u2022   billing address: part of CustomerInformation class. \u2022   database system: the catalog and inventory database systems are out of the scope of OPS. However, a wrapper class (i.e.,\nboundary class) called CustomerInfoDB is created to interact with the database. After the analysis on the Registration use case, the following classes are now included in the analysis class diagram:\n \n\u2022   RegistrationPage: a boundary class for registration. \u2022   RegistrationErrorPage: a boundary class for reporting registration error. \u2022   RegistrationSuccessPage: a boundary class for concluding the registration process. \u2022   CustomerIdentity: an entity class that records the user name and password of a customer. \u2022   CustomerInfomation: an entity class that records the information of a customer, including CustomerIdentity, real\nname, and billing address. \u2022   CustomerInfoDB: a boundary class that manipulates the customer information database. \u2022   RegistrationController: a controller class which coordinates the registration process. By examining other use cases, the following classes are identified:\n \n\u2022   SessionController: a controller class for coordinating a session. This class provides various operations for logging in, logging\noff, adding items, deleting items, clearing the shopping cart, and checking out. \u2022   BrowserPage: a boundary class for browsing the product catalog. \u2022   LoginPage: a boundary class for logging in. \u2022   LogoutPage: a boundary class for logging off. \u2022   CheckoutPage: a boundary class for accepting user credit card information and checking out. \u2022   CheckoutSuccessPage: a boundary class for presenting success information and a receipt. \u2022   CheckoutFailurePage: a boundary class for presenting failure information. \u2022   ShoppingCartPage: a boundary class for displaying the contents of a shopping cart and allowing the customer to add/remove\nitems. \u2022   FinancialDeptWrapper: a boundary class for interacting with the financial department. \u2022   ShippingDeptWrapper: a boundary class for interacting with the shipping department. \u2022   InventoryDB: a boundary class for interacting with the inventory database. All user operations (such as adding and deleting items) are included as operations of the SessionController class. An alternative\nway is to map directly from the use case diagram\u2014declare an abstract class called operation, and then make each related use\ncase a derived class of the operation class. The first solution is chosen because of its simplicity.", "domains": ["Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 52", "position": 52, "chunk_type": "semantic", "token_estimate": 410}
{"text": "associations are natural because each web page needs a controller object for handling events, and the controller object: needs access to every page so that it can coordinate the entire customer service process by redirection of web pages. Usually\nnavigation is accomplished by including a reference attribute in a class design, for example, each registration-related web page should\nhave a reference to the RegistrationController object. Notice that both the RegistrationController and\nSessionController classes depend on the CustomerInformation class because they pass CustomerInformation\nobjects as parameters when invoking operations provided by CustomerInfoDB. Figure 4.8\n \nAnalysis class diagram of OPS\n \nWith the domain and requirement analyses complete, you can now proceed to the design stage. Notice that the UML use-case\ndiagram and analysis class diagram are very useful in the OO design process. For example, from use-case descriptions designers are\nable to derive interaction diagrams such as sequence diagrams and communication diagrams. From the use case diagram and\nanalysis class diagram, Class-Responsibility-Collaborator (CRC) card analysis can be applied to discover more classes needed for\ndetailed design. These techniques will be covered in the next section. 4.4 OO Design\n \nThe goal of design is to develop the structural architecture of a system. There are numerous design approaches, including structured\ndesign, data-driven design, event-driven design, real-time design, and others. All of these approaches break down the problem into\nmanageable pieces. A unique feature of OO design is that a system is decomposed into logical components called classes. For each\nclass, its interface, consisting of public attributes and public operations, is clearly specified in the design stage. Then, in the\nimplementation stage, the interface of each class is translated into code using an OO language. Generally, OO design can be split into two stages: high-level (conceptual) design and low-level (detailed) design. In high-level design,\nall classes needed for building the system are identified and each class is assigned a certain responsibility. Then a class diagram is\nconstructed to further clarify the relations among the classes. Based on the analysis of use cases, interaction diagrams also are drawn\nto depict the flow of events. In low-level design, attributes and operations are assigned to each class based on the interaction\ndiagrams. Then state machine diagrams are developed to describe further design details. 4.4.1 Step 1: Identify Classes\u2014CRC Card\n \nAn analysis class diagram presents an abstract logical structure of the system. The classes included in this diagram may be only a\nsubset of the classes that are needed by the system.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 53", "position": 53, "chunk_type": "semantic", "token_estimate": 413}
{"text": "Figure 4.14\n \nSequence diagram of the Registration use case\n \nT\no build a sequence diagram you follow the flow of events description for each use case. Each action or step mentioned in the use\ncase description is modeled as a message sent from one object to another, which translates into an invocation of an operation on the\ntarget object. The translation procedure is natural. Figure 4.14 presents the sequence diagram for the Registration use case. First, the customer browser (an actor) visits the\nregistration page and instantiates a new instance of RegistrationPage. Once created, the RegistrationPage object creates\none RegistrationController object that monitors the whole registration process. When the customer fills out the desired user\nname and password information and clicks the Submit button on the RegistrationPage, a request to register the new user is sent\nto the RegistrationController. The RegistrationController attempts to register the new account by interacting with the\nCustomerInfoDB object. Based on its response, the RegistrationController object creates an instance of either the\nRegistrationSuccessPage or the RegistrationFailurePage and redirects the customer browser to the corresponding\npage. Notice \nthat \nboth \nof \nthe \nobjects SuccessPage: \nRegistrationSuccessPage \nand FailurePage:\nRegistrationFailurePage are named objects, because their names are passed by the RegistrationController to\nredirect the customer's browser. 4.4.3 Step 3: Build a State Machine Diagram\n \nWhen the analysis class diagram, interaction diagrams for each use case, and CRC card designs are completed, you can proceed to\nthe detailed level design. The objective of the detailed level design is to specify the interface of each class and make decisions about\nimplementation. The interface is the public interconnection border of the class that is accessible by other components of the system. Implementation means to realize the behaviors specified by the interface. The outcome of the detailed design process is a detailed\nclass design diagram, where for each class a list of attributes and operations are listed. For classes with complex behaviors, state\nmachine diagrams are usually defined to clarify the design. This section introduces the state machine diagram design. A state machine diagram (e.g., Figure 4.15) consists of two types of basic\nelements: (1) state, which is represented using a rounded rectangle, and (2) transition, which is a directed arc between states. There\nare two cases of building a state machine diagram:\n \n1.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 56", "position": 56, "chunk_type": "semantic", "token_estimate": 380}
{"text": "A state machine diagram (e.g., Figure 4.15) consists of two types of basic\nelements: (1) state, which is represented using a rounded rectangle, and (2) transition, which is a directed arc between states. There\nare two cases of building a state machine diagram:\n \n1. When a class is responsible for a single use case, designers simply look into the flow of events and corresponding interaction\ndiagram to identify the different states that an object of this class goes through and the corresponding transitions. 2. When a class is involved in multiple use cases, designers have to combine all the information and consider the environment and\nthe change of internal data values to identify the states. Sometimes, when a state machine diagram is too complex, you can take\nadvantage of the substate utility included in UML 2. Figure 4.15 presents the state machine diagram for the SessionController class. The SessionController is triggered by\nthe logon event. When the logon is successful, the session class enters a READY state that waits for user interactions. When a user\ninvokes an operation, the system enters in a corresponding state to process that call (e.g., HANDLING_DEL_ITEM,\nHANDLING_CHECKOUT, HANDLING_ADD_ITEM, etc). Finally, when the LogoutPage is visited, the session enters a final state. Notice that a complex state machine diagram design can be simplified using \u201cdivide and conquer\u201d strategy. A state in a high-level\ndiagram can be represented using another low-level state diagram (the idea is similar to the encapsulation provided by procedural\ncall). Such a state is called composite-state and the states that are nested within the composite-state are called substates. For\nexample, the HANDLING_ADD_ITEM is a composite-state that handles the invocation from BrowserPage when its \u201cadd to shopping\ncart\u201d button is clicked. The composite-state itself is essentially one state machine, which starts from the READY state, invokes a\nRemoveFromStock() operation provided by InventoryDB, updates and saves the shopping cart, and finally displays results to\nthe user using boundary web forms.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 56", "position": 56, "chunk_type": "semantic", "token_estimate": 325}
{"text": "Figure 4.15\n \nState machine diagram of SessionController class\n \n4.4.4 Step 4: Class Specification\n \nThe first step in a detailed class specification is to identify the public interface of the class. While the implementation of a class can\nchange over the time, the public interface is nailed down after the design phase. Any changes to the public interface might damage the\nwork already done by other designers. Therefore, the public interface should be complete and stable. Public interface design starts with CRC cards. By examining the class's responsibilities and interaction diagram, you can list the\nattributes and operations that must be declared in the class. Note that, if it is too complex, the class can be split into more classes in\nthe detailed design. A class should be split if it cannot be described using a simple sentence. When a class is split, the CRC model\nshould be reorganized accordingly. In general, unless designers are pursuing for speed, declaring public attributes for information security reasons is discouraged. (One\nexception is for declaring class-wide constant values.) The following discussion of the public interface will be concentrated on public\noperations. Generally, a class provides four categories of operations in its public interface: (1) constructor operations, (2) destructor operations, (3)\naccessor operations, and (4) mutator operations. A constructor operation is used to initialize the data members of an object when it is created. A class can have a number of\nconstructors for different scenarios. A destructor operation is used to clean up memory and free system resources when an object is no longer in use. Notice that even if the\nimplementation environment provides garbage collection (i.e., the runtime system automatically reclaims the memory occupied by\nunused objects), destructors are useful in many situations. For example, when a process object is destroyed in an operating system, all\nthe files opened by that process should be closed. Such clean-up actions can be defined in a destructor. An accessor operation retrieves information from the object\u2014it can retrieve the value of a data member, or finish some computation\nbased on the state of the object. An accessor operation does not change the state of an object. A mutator operation resets the value of one or more object attributes. Invocation of a mutator operation usually causes the transition\nbetween object states.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 57", "position": 57, "chunk_type": "semantic", "token_estimate": 382}
{"text": "A mutator operation resets the value of one or more object attributes. Invocation of a mutator operation usually causes the transition\nbetween object states. Once the public operations are identified, you can define the implementation details of the class, i.e., the private attributes and\nadditional operations. The implementation design process goes through a similar procedure identifying the needed attributes and\noperations. Usually designers start from the state machine diagram of the class, if one exists, examine each of the public operations,\nand then nail down what attributes are needed. Designers continue this process until no more attributes and operations are needed. You must consider the following when identifying private attributes. 1. According to the CRC cards, what must be known by the class? 2. Based on the state machine diagram, what states does the object go through? (States will be defined as constant attributes.) 3. What association factors (especially dependency and navigation) should be modeled? 4. What other data members might be needed for the implementation of operations? Breaking down the implementation of public operations can help you identify private operations. For example, suppose that when\nimplementing the SaveShoppingCart() operation of CustomerInfoDB, a hash is generated for the shopping cart contents to", "domains": ["Design Patterns"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 57", "position": 57, "chunk_type": "semantic", "token_estimate": 202}
{"text": "facilitate product search. The hashing algorithm is system specific. In this case, it is desirable to define a separate private operation: called computeHash(). In the following, the SessionController class is taken as an example for class design. Examining the CRC card of SessionController (Figure 4.13), you can identify the following two attributes:\nrefCustomerInformation (an instance of CustomerInfomation) and refShoppingCart (a list of ProductInfo). Y\nou can also examine the analysis class diagram to ensure that the detailed design is complete. For example, all associations in the\nanalysis class diagram need to be modeled. Because the SessionController class navigates to CustomerInfoDB,\nInventoryDB, FinancialDeptWrapper, and ShippingDeptWrapper, you must include a reference for each of these\nwrapper classes. All of these attributes should be private because they are for the internal use of SessionController. Another place you can look for attributes is the state machine diagram (Figure 4.15). It is desirable to define an attribute for recording\nthe state of the object, and correspondingly, you need several predefined constants for state names (e.g., READY, WAIT_LOG_ON,\nHANDLING_ADD_ITEM, etc.). All of them can be declared as private attributes because they are for internal use only. Are there any more operations to be included in the detailed design? A good place to start is the interaction diagram. Each incoming\nsolid arrow is modeled as a public operation of the class. Operations such as add_item, delete_item, clear_cart, log_in,\nlog_out, and check_out are included in the class design; all of these operations should be public. Combining the earlier analysis\nresults, a sample design of SessionController is shown in Figure 4.16. The next step is to refine the design of operations. Two important problems must be addressed for each operation: (1) What\nparameters are needed to invoke the operation?, and (2) What should be the return value? Given all the alternatives, you should\nconsider the pros and cons of each and make the best decision based on the project requirements. After you repeat the same design process for each class, the final outcome is a detailed design class diagram containing\ndocumentation of each class in the system (specification of public interface, attributes, and operations, including the parameters, return\ntype, pre-/post-conditions, and brief algorithm descriptions of each operation). Figure 4.16\n \nDetailed design of SessionController class\n \n4.5 Design Principles\n \nThe design process does not simply identify one solution for a problem and then furnish the solution's details. Instead, a good designer\nhas to identify several alternative design solutions and select the one that fits the project requirements best.", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 58", "position": 58, "chunk_type": "semantic", "token_estimate": 417}
{"text": "Figure 4.18\n \nInitial design of Professor class\n \nOne problem with the design in Figure 4.18 is that the Professor class has to bear two unrelated responsibilities: (1) to prepare a\ngraduation application as an advisor, and (2) to distribute course materials as an instructor. While there is nothing wrong with the\nfunctionality of the system, the design is not cohesive. One solution to improve the design in Figure 4.18 is simply to split the Professor class into two subclasses: an Advisor class and\na n Instructor class. The corresponding attributes and operations can be moved down to those classes, leaving the shared\nattributes and operations up in the root Professor class. If the Professor class cannot be split, the use of inheritance and public interface can help improve cohesion. One sample solution is\nshown in Figure 4.19. Two new interfaces are defined in the improved design: Advisor and Instructor. These interfaces declare\nthe operations that must be realized by the derived classes, e.g., prepareGradApp() and getLectureNotes(). The\nProfessor class realizes these two interfaces. In addition, when the Student and the RegistrarOffice need to access the\ncorresponding functions provided by the Professor class, they do not directly refer to the Professor class. Instead, they depend\non the Advisor and Instructor interfaces. Such minor changes in class relationships can greatly improve the cohesion of the\noverall design. Figure 4.19\n \nImproved design of Professor class\n \n4.5.3 Open-Closed Principle\n \nThe open-closed principle was first proposed by Bertrand Meyer in his book Object-Oriented Softw\nare Construction (Meyer, 1997). The principle encourages OO designers to practice the following two guidelines:\n \n1. Open to extension: the system should have the ability to be extended to meet new requirements. 2. Closed to modification: the existing implementation and code of the system should not be modified as a result of system\nexpansion. One technical approach to achieve the open-closed principle is abstraction via inheritance and polymorphism. A typical example may\nbe seen in Figure 4.17 (b). When a new shape, e.g., trapezium, is added into the system, the code of the Shape class and its derived\nclasses do not need modification. Another example may be seen in Figure 4.19. The Professor class is made to realize two\ninterfaces: Advisor and Instructor. The users of the Professor class do not depend on the Professor class. Such\narrangement allows for great flexibility.", "domains": ["Design Principles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 60", "position": 60, "chunk_type": "semantic", "token_estimate": 391}
{"text": "The users of the Professor class do not depend on the Professor class. Such\narrangement allows for great flexibility. The open-closed principle has many interesting implications that also serve as the thumb of\nrules during OO design:\n \n\u2022   Separate interface and implementation: For each concrete class (i.e., a class that has implementations of its operations), it will be\nbeneficial to abstract out its functionality in one or more interfaces and let the class realize the interface(s). \u2022   Keep attributes private: When a class has attributes that are publicly visible to other classes, any change of these public attributes\nleads to reexaminination of all classes that use them. In a multithreaded environment, exposing public attributes is more dangerous\u2014\nracing conditions in attempts to access public attributes might cause bizarre and hard-to-debug errors.", "domains": ["Design Principles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 60", "position": 60, "chunk_type": "semantic", "token_estimate": 131}
{"text": "\u2022   Minimize the use ofglobal variables: It is hard to trace uses of global variables. Changes in the definition of such global variables\ncan easily lead to their misuse, which causes other modules to crash. The same rule applies to class variables (e.g., static class\nattributes in the Java language). 4.6 Summary\n \nThe OO paradigm is probably the most popular design methodology in use since the 1990s. One advantage of OO is to bundle data\nand its related operations together in one unit. Inheritance and polymorphism not only allow for reuse of code and implementation, but\nalso provide vital mechanisms for abstraction and encapsulation. With the invention of UML, the OO-based software engineering\nprocess has matured. Use cases and class diagrams are used in the analysis stage to help further designers' understanding of a\nsystem's requirements and overall structure. In addition, these diagrams can be integrated into the design stage. Using CRC cards,\ninteraction diagrams, state machine diagrams, and design class diagrams, OO designs can be refined, verified, and documented. The key to design is not to create only one solution for a problem, but to choose among several possible solutions and make the best\ndecision. Given the same problem, there are numerous possible designs, at different costs and with different qualities. The\nresponsibility of a system analyst or a designer is to follow the general principles of OO design and to make the design sustainable,\nreusable, expandable, and easily maintainable. The trade-offs of various design alternatives\u2014e.g., composition vs. inheritance, loose\ncoupling vs. tight coupling, public vs. private visibility, etc.\u2014must be evaluated against the problem setting. In general, the OO paradigm is a design methodology that is both easy and difficult to use. The \u201ceasy\u201d part is its natural modeling\ncapability that allows designers to describe and abstract the real world in a way much easier to understand than the structured\nprogramming paradigm. The \u201chard\u201d part is the numerous design principles that a designer must follow. There may be many designs\nthat work for a problem; however, it is very likely that only a few of them are really good. 4.7 Self-Review Questions\n \n1. Which of the following are benefits of OO design? a. Ease of code reuse\n    b. Well-supported by programming tools\n    c. Information hiding\n    d. Real-world problems mapping\n    e. All of the above\n2. Which of the following are features of OO methodology?", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 61", "position": 61, "chunk_type": "semantic", "token_estimate": 395}
{"text": "Ease of code reuse\n    b. Well-supported by programming tools\n    c. Information hiding\n    d. Real-world problems mapping\n    e. All of the above\n2. Which of the following are features of OO methodology? a. Concurrency\n    b. Interactivity\n    c. Inheritance\n    d. Exchangeability\n3. C is a popular OO programming language. a. True\n    b. False\n4. The set of classes in a design is nailed down when the analysis class diagram is finished. a. True\n    b. False\n5. The CRC card method is used to identify the responsibilities of each class. a. True\n    b. False\n6. Sequence diagrams do not describe loops in a message exchange process. a. True\n    b. False\n7. A class is said to be cohesive if it supports as many associated responsibilities as possible\n    a. True\n    b. False\n8. Abstraction via inheritance is one effective way to achieve the open-closed principle. a. True\n    b. False\n9. A part involved in an aggregation relationship should be born and terminate at the same moment as its owner. a. True\n    b. False\n10. To conform to the open-closed principle the use of global variables should be minimized. a. True\n    b. False\nAnswers to the Self-Review Questions\n \n1. e 2. c 3. b 4. b 5. a 6.b 7.b 8. a 9.b 10. a\n \n4.8 Exercises\n \n1. Explain how encapsulation is achieved in Java.", "domains": ["Design Principles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 61", "position": 61, "chunk_type": "semantic", "token_estimate": 220}
{"text": "2. Compare C++ and Java, from the perspective of their support of inheritance.: 3. Using one example, explain the difference between coupling and cohesion. 4. Give one example that shows composition is more appropriate than aggregation for modeling the relationship between two\nclasses. 5. Give one example that shows aggregation is more appropriate than composition for modeling the relationship between two\nclasses. 6. Give one scenario that shows inheritance is more appropriate than composition in design reuse. 7. Give one scenario that shows composition is more appropriate than inheritance in design reuse. 8. Give one example that shows tight coupling is not always bad. 4.9 Design Exercises\n \n1. Use the noun extraction method to extract the set of classes involved in the check-out use case. 2. Develop the CRC card for the InventoryDB class. 3. Design the sequence diagram for the check-out use case. 4. Design the state machine diagram for the RegistrationController class. 5. Develop the public interface of the InventoryDB class. 4.10 Challenge Exercises\n \n1. Follow and complete the design of OPS in this chapter. Y\nour design should include: (1) the complete use case diagram,\naccompanied by the event flow description for each use case; (2) analysis class diagram; (3) design of CRC cards; (4) sequence\ndiagrams for each use case; (5) state machine diagrams for all the controller classes in the design; and (6) specification and\ndesign of each class. The specification of each class should include: (1) the class name, (2) a list of public operations and public\nattributes if there are any, and (3) a list of private/protected attributes and operations. For each operation, the specification should include: (1) a list of parameters and the return type, (2) pre-and post-conditions, and\n(3) a brief explanation or pseudocode of the operation. 2. Implement your design of Challenge Exercise 1 using a popular OO language. 3. If there are multiple solutions to Challenge Exercise 1, select and compare two different designs, considering the following\nfactors: (1) development cost, (2) extensibility, (3) modifiability, and (4) system performance. References\n \nArlow, Jim and Ila Neustadt. UML 2 and the Unified Process: Practical Object-Oriented Analysis and Design. 2nd ed. Addison-\nWesley Professional, 2005, 1-624. Beck, Kent and Ward Cunningham. \u201cA Laboratory for Teaching Object-Oriented Thinking.\u201d OOPSLA'89, Object-oriented programming\nsystems, languages and applications. SIGPLAN: ACM Special Interest Group on Programming Languages. New Orleans, LA,\nOctober 1989, 1-6. DeMarco, T\nom. Structured Analysis and System Specification. Y\nourdon Press Computing Series.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 62", "position": 62, "chunk_type": "semantic", "token_estimate": 409}
{"text": "2. Compare C++ and Java, from the perspective of their support of inheritance.: Structured Analysis and System Specification. Y\nourdon Press Computing Series. Upper Saddle River, NJ: Prentice\nHall, 1979, 310-312. Meyer, Bertrand. Object-Oriented Softw\nare Construction. 2nd ed. Upper Saddle River, NJ: Prentice Hall, 1997, 57-61. Venners, Bill. \u201cInheritance versus composition: Which one should you choose? A Comparative Look at Tw\no Fundamental Ways to\nRelate Classes.\u201d JavaWorld.com (November 1, 1998). Network World, Inc., http://www.javaworld.com/jw-11-1998/jw-11-\ntechniques.html. Suggested Reading\n \nGorman, Jason. \u201cObject-Oriented Analysis & Design.\u201d (from \u201cUML for Managers,\u201d ch. 3) 2005, http://www.parlezuml.com/e-\nbooks/umlformanagers/umlformanagers_ch3.pdf.", "domains": ["Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 62", "position": 62, "chunk_type": "semantic", "token_estimate": 94}
{"text": "5 Data Flow Architectures: s\n \nObjectives of this Chapter\n \n\u2022   Introduce the concepts of data flow architectures\n \n\u2022   Describe the data flow architecture in UML\n \n\u2022   Discuss the application domains of the data flow architecture approach\n \n\u2022   Assess the benefits and limitations of the data flow architecture approach\n \n\u2022   Demonstrate the batch sequential and pipe and filter architectures in OS and Java scripts\n \n5.1 Overview\n \nThe data flow software architecture style views the entire software system as a series of transformations on successive sets of data,\nwhere data and operations on it are independent of each other. The software system is decomposed into data processing elements\nwhere data directs and controls the order of data computation processing. Each component in this architecture transforms its input\ndata into corresponding output data. The connection between the subsystem components may be implemented as I/O streams, I/O\nfiles, buffers, piped streams, or other types of connections. Data can flow in a graph topology with cycles or in a linear structure without\ncycles, or even in a tree type structure. A sample block diagram for data flow architecture is shown in Figure 5.1.Regardless of the type\nof topology, the data moves from one subsystem to another. In general, there is no interaction between the modules except for the\noutput and the input data connections between subsystems. In other words, the subsystems are independent of each other in such a\nway that one subsystem can be substituted by another without affecting the rest of the system, as long as the new subsystem is\ncompatible with the corresponding input and output data format. Since each subsystem does not need to know the identity of any other\nsubsystem, modifiability and reusability are important property attributes of the data flow architecture. There are many different ways to connect the output data of a module to the input of other modules which result in a range of data flow\npatterns. There are two categories of execution sequences between modules: batch sequential and pipe and filter (nonsequential\npipeline mode). The close-loop process control is a typical data flow architecture style where data also drives the sequence of the\nprogram executions. From the standpoint of design orientation philosophy, we can choose either a traditional procedure-oriented\ndesign or an object-oriented design. Figure 5.1\n \nBlock diagram of data flow architecture\n \nThe data flow architecture is applicable in certain problem domains.", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 63", "position": 63, "chunk_type": "semantic", "token_estimate": 396}
{"text": "and COBOL are two typical programming languages working on this model.: In batch sequential architecture, each data transformation subsystem or module cannot start its process until its previous subsystem\ncompletes its computation. Data flow carries a batch of data as a whole from one subsystem to another. Figure 5.2 shows a typical\nexample of batch sequential style. Figure 5.2\n \nBatch sequential architecture\n \nIn this example, the first subsystem validates the transaction requests (insert, delete, and update) in their totality. Next, the second\nsubsystem sorts all transaction records in an ascending order on the primary key of data records to speed up the update on the master\nfile since the master file is sorted by the primary key. The transaction update module updates the master file with the sorted transaction\nrequests, and then the report module generates a new list. The architecture is in a linear data flow order. All communications (connection link arrows) between subsystem modules are conducted through transient intermediate files which can\nbe removed by successive subsystems. Business data processing such as banking and utility billing are typical applications of this\narchitecture. Figure 5.3 depicts a similar example of this architecture. A script is often used to make the batch sequence of the\nsubsystems in the system. Figure 5.3 is a detailed example of the previous block diagram of Figure 5.2. It shows that the data files are the driving force for\nprocessing forward. We can run a Unix Shell script as follows in batch sequential mode:\n \nmyShell.sh\n(exec) searching kwd < inputFile > matchedFile\n(exec) counting < matchedFile > countedFile\n(exec) sorting < countedFile > myReportFile\nWhere (exec) may be required by some Unix shell. In this Unix shell script, each executable program takes its input from stdin and outputs the results to stdout, the Unix default\ninput/output. The redirect operators (\u201c<\" and \">\u201d) are used to make stdin and stdout point to specific files. The first executable\nprogram, searching, reads in the text file inputFile and sends its output into file matchedFile. The second command line runs another\nexecutable program called counting, which takes its input from matchedFile and places its output into countedFile, and so on. We can\neasily replace any one of these executable commands as long as the input/output formats are the same.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 64", "position": 64, "chunk_type": "semantic", "token_estimate": 380}
{"text": "and COBOL are two typical programming languages working on this model.: The second command line runs another\nexecutable program called counting, which takes its input from matchedFile and places its output into countedFile, and so on. We can\neasily replace any one of these executable commands as long as the input/output formats are the same. For example, taking advantage of the search methods of String class in Java API, we can substitute a Java program performing similar\nfunctions:\n \nexec java searching kwd inputFile matchedFile\nHere, searching is a Java bytecode class file instead of a Unix executable file. This example shows that a change of one executable\nmodule will not affect the others as long as it produces identical formatted data to be used by the subsequent executable module. This\nis very similar in a DOS environment, for example, in making a batch file called myBatch.bat with the following:\n \nsearching kwd inputFile matchedFile\ncounting matchedFile countedFile\nsorting countedFile", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 64", "position": 64, "chunk_type": "semantic", "token_estimate": 158}
{"text": "Figure 5.3\n \nBatch sequential in business data processing\n \nWe can also implement the batch sequential software architecture at the programming language level. Here is a Java sketch template:\n \npublic class batch_sequential\n{\n. . . public static void main() {\n      searching(kwd, inputFile, matchedFile);\n      counting(matchedFile, countedFile);\n      sorting (countedFile, reportFile);\n}\npublic static void searching(String kwd, String\n inFile, String outFile)\n  { . . . } public static void counting(String inFile,\nString outFile)\n{ . . . } public static void sorting(String inFile, String\noutFile)\n{ . . . } }\nThis is a sample skeleton of the batch sequential architecture in Java. Notice that there is no single instance (object). This is because\nwe used static methods, and these do not belong to any individual object; rather, they belong to the class where they are defined. Applicable domains of batch sequential architecture:\n \n\u2022   Data are batched. \u2022   Intermediate file is a sequential access file. \u2022   Each subsystem reads related input files and writes output files. Benefits:\n \n\u2022   Simple divisions on subsystems. \u2022   Each subsystem can be a stand-alone program working on input data and producing output data. Limitations:\n \n\u2022   Implementation requires external control. \u2022   It does not provide interactive interface. \u2022   Concurrency is not supported and hence throughput remains low\n \n\u2022   High latency. 5.3 Pipe and Filter Architecture\n \nPipe and filter architecture is another type of data flow architecture where the flow is driven by data. This architecture decomposes the whole system into components of data source, filters, pipes, and data sinks. The connections\nbetween components are data streams. The particular property attribute of the pipe and filter architecture is its concurrent and\nincremented execution. A data stream is a first-in/first-out buffer which can be a stream of bytes, characters, or even records of XML or any other type. Most\noperating systems and programming languages provide a data stream mechanism; thus it is also an important tool for marshaling and\nunmarshaling in any distributed system. Each filter is an independent data stream transformer; it reads data from its input data stream, transforms and processes it, and then\nwrites the transformed data stream over a pipe for the next filter to process. A filter does not need to wait for batched data as a whole. As soon as the data arrives through the connected pipe, the filter can start working right away.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 65", "position": 65, "chunk_type": "semantic", "token_estimate": 389}
{"text": "\u2022   Push only (Write only): A data source may push data in a downstream. A filter may push data in a downstream. \u2022   Pull only (Read only)\nA data sink may pull data from an upstream. A filter may pull data from an upstream. \u2022   Pull/Push (Read/Write)\nA filter may pull data from an upstream and push transformed data in a downstream. There are two types of filters: active and passive. \u2022   An active filter pulls in data and pushes out the transformed data (pull/push); it works with a passive pipe that provides read/write\nmechanisms for pulling and pushing. The pipe and filter mechanism in Unix adopts this mode. The PipedWriter and PipedReader\npipe classes in Java are also passive pipes that active filters must work with to drive the data stream forward. \u2022   A passive filter lets connected pipes push data in and pull data out. It works with active pipes that pull data out from a filter and push\ndata into the next filter. The filter must provide the read/write mechanisms in this case. This is very similar to data flow architecture. The Java PipedWriter and PipedReader classes work together to synchronize the data stream pulling and the data stream pushing\nbetween active filters. In the following class diagram for pipe and filter architecture in Figure 5.4, the solid lines indicate the class connections, the data source\nprovides the read mechanism, the data sink provides the write mechanism, and the pipe provides both read and write mechanisms for\nfilters to use. So, this class diagram covers active filter and passive pipe. Both the data source and the data sink are also passive. The\ndashed lines indicate an alternative configuration for pipes that connects the data source and data sink with filter. As we can see in the UML class diagram in Figure 5.4, one pipe class may connect to three other classes. They are data source, filter,\nand data sink. In a pipe and filter system there may be many pipe instances and filter instances. This class diagram focuses only on\nactive filters which push data into pipe and pull data from a pipe. Figure 5.4\n \nPipe and filter class diagram\n \nThe UML sequence diagram Figure 5.5 shows one pipe connecting to two filters. One filter connects to a data source and the other\nconnects to a data sink.", "domains": ["Design Principles"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 66", "position": 66, "chunk_type": "semantic", "token_estimate": 391}
{"text": "Figure 5.6\n \nPipelined pipe and filter\n \nFigure 5.7 shows that there are two types of reading: no-blocking reading and blocking reading. The reading operation is blocked out\nin the blocking reading if data is not available for reading. This case is shown in Filter2's first reading. Figure 5.7\n \nPipe and filter sequence diagram\n \nPipe and Filter in Unix\n \nThe pipe operator \u201cI\u201d moves the stdout from its predecessor to the stdin of its successor. The successor can start data transformation\nover the data stream before the predecessor completes its transformation or processing. For example, the pipeline of Unix commands\nreports the number of users who are currently logged onto the system. who | wc -l\nThe who command sends the current users to its output stream; the wc command takes its input stream from the pipe and counts the\nnumber of lines (i.e., the number of the current users). The wc command starts its counting before the who command completes its\noutput. Unix also supports named pipes to connect the filters. A named pipe may be placed between two processes as a Unix stream pipe. The following example, illustrated in Figure 5.8, shows two Unix processes, one running in the background and the other running in the\nforeground. Both of these processes have their data pipe streams, one is a Unix implicit pipeline and other consists of pipeA and\npipeB. The cat command sends the contents of the infile to the pipe, and the tee command sends the same data to two pipelines. The\nbackground process with named pipeline searches for 'a' and the foreground one searches for 'c'; the two processes are joined\ntogether at the second cat command with \u201d-\u201c (current process) and pipeB; the last filter reports the counts of each character matched. Figure 5.8\n \nSimple Unix pipe and filter architecture\n \nThe filter used above can be replaced by any other Unix command or application program as long as they take input from stdin and", "domains": ["Design Patterns"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 67", "position": 67, "chunk_type": "semantic", "token_estimate": 328}
{"text": "outputs data to stdout. Here is such a situation:: $ mkfifo pipeA\n$ mkfifo pipeB\n$ grep a < pipeA >pipeB &\n$ cat infile | tee pipeA | grep c |cat - pipeB | uniq -c\nPipe and Filter in Java\n \nThe Java API provides the PipedWriter and PipedReader classes in the java.io package; this allows for filters to push data into\ndownstream or to pull data from the upstream. Filters can run in separate threads, and they can be synchronized in a parallel manner by\nPipedWriter and PipedReader. Here is a simple example to illustrate the use of Java pipe and filter facilities: The Filterl runs in one thread and produces a data\nstream to a pipe which is consumed by Filter2 in another thread. Filter1.java:\npackage pf;\nimport java.io. *;\npublic class Filter1 extends Thread {\n  PipedWriter myPw;\n  public Filter1(PipedWriter pw) { myPw=pw; }\n  public void run() {\n    int j;\n    try {\n      for (int j = 1; j<100; j++) pw.write(j);\n      pw.write(-1);\n    }\n    catch(Exception e){. . .} }\n}\n Filter2.java:\npackage pf;\nimport java.io. *;\nclass Filter2 extends Thread {\n  PipedReader myPr;\n  public Filter2(PipedReader pr) { myPr = pr; }\n  public void run() {\n    int j;\n    try {\n      while (myPr.read()!= -1){ . . . } }\n    catch(Exception e){. . .} }\n}\npipeFilter.java:\nimport pf. *;\nimport java.io. *;\npublic class pipeFilter {\n  public static void main(String[] args) {\n    try {\n      PipedWriter pw = new PipedWriter();\n      PipedReader pr = new PipedReader(pw);\n      Filter1 f1 = new Filter1(pw);\n      Filter2 f2 = new Filter2(pr);\n      f2.start();\n      f1.start();\n    }\n    catch(Exception e){ . . . } }\n}\nThe pipeFilter Java program runs two threads in addition to itself: Filter1 and Filter2. They are connected by a synchronized pipe\n(PipedWriter and PipedReader). Filter1 writes to the pipe and Filter2 reads from the pipe. It is not necessary to start Filter1 before\nstarting Filter2. The main program actually starts Filter2 before Filter1. The order of filters in the sequence is not important as long as\nthe synchronization is set. Applicable domains of pipe and filter architecture:\n \n\u2022   The system can be broken into a series of processing steps over data streams, and at each step filters consume and move data\nincrementally. \u2022   The data format on the data streams is simple, stable, and adaptable if necessary. \u2022   Significant work can be pipelined to gain increased performance. \u2022   Producer or consumer-related problems are being addressed.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 68", "position": 68, "chunk_type": "semantic", "token_estimate": 399}
{"text": "Benefits:\n \n\u2022   Concurrency: It provides high overall throughput for excessive data processing. \u2022   Reusability: Encapsulation of filters makes it easy to plug and play, and to substitute. \u2022   Modifiability: It features low coupling between filters, less impact from adding new filters, and modifying the implementation of any\nexisting filters as long as the I/O interfaces are unchanged. \u2022   Simplicity: It offers clear division between any two filters connected by a pipe. \u2022   Flexibility: It supports both sequential and parallel execution. Limitations:\n \n\u2022   It is not suitable for dynamic interactions. \u2022   A low common denominator is required for data transmission in the ASCII formats since filters may need to handle data streams in\ndifferent formats, such as record type or XML type rather than character type. \u2022   Overhead of data transformation among filters such as parsing is repeated in two consecutive filters. \u2022   It can be difficult to configure a pipe and filter system dynamically. 5.4 Process Control Architecture\n \nProcess control software architecture is suitable for the embedded system software design where the system is manipulated by a\nprocess control variable data. Process control architecture decomposes the whole system into subsystems (modules) and connections\nbetween subsystems. There are two types of subsystems: an executor processing unit for changing process control variables and\ncontroller unit for calculating the amounts of the changes. Figure 5.9 shows the data flow of a feedback close-loop process control\nsystem. The connections between the subsystems are the data flow. A process control system must have the following process control data:\n \n\u2022   Controlled variable: a target controlled variable such as speed in a cruise control system or the temperature in an auto H/A system. It has a set point goal to reach. The controlled variable data should be measured by sensors as a feedback reference to recalculate\nmanipulated variables. \u2022   Input variable: a measured input data such as the temperature of return air in a temperature control system. \u2022   Manipulated variable: can be adjusted by the controller. The input variables and manipulated variables are applied to the execution processor which results in a controlled variable. The set\npoint and controlled variables are the input data to the controller; the difference between the controlled variable value and the set point\nvalue is used to arrive at a new manipulated value. Car cruise-control and building temperature control systems are examples of this\nprocess control software architecture type of application.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 69", "position": 69, "chunk_type": "semantic", "token_estimate": 399}
{"text": "6 Data-Centered Software Architecture: e\n \nObjectives of this Chapter\n \n\u2022   Introduce the concepts of data-centered software architecture\n \n\u2022   Describe repository and blackboard architectures\n \n\u2022   Discuss applicable domains for data-centered software architecture\n \n\u2022   Evaluate the benefits and limitations of data-centered software architecture\n \n\u2022   Examine data-centered architecture when incorporated with other architectures\n \n6.1 Overview\n \nData-centered software architecture is characterized by a centralized data store that is shared by all surrounding software components. The software system is decomposed into two major partitions: data store and independent software component or agents. The\nconnections between the data module and the software components are implemented either by explicit method invocation or by implicit\nmethod invocation. In pure data-centered software architecture, the software components don't communicate with each other directly;\ninstead, all the communication is conducted via the data store. The shared data module provides all mechanisms for software\ncomponents to access it, such as insertion, deletion, update, and retrieval. There are two categories of data-centered architecture: repository and blackboard. These are differentiated by the flow control\nstrategy. The data store in the repository architecture is passive, and clients of the data store are active; that is, clients (software\ncomponents or agents) control the logic flow. Clients may access the repository interactively or by a batch transaction request. The\nrepository style is widely used in database management systems, library information systems, the interface repository (IR) in CORBA,\nthe UDDI registry for web services, compilers, and Computer Aided Software Engineering (CASE) environments. A well-known CASE\ntool is Rational Rose. It supports a graphic editor to draw UML diagrams, generates various programming code, and provides reverse\nengineering functionality to generate graphic diagrams from code. All Interactive Development Environments (IDE), and similar\nsoftware development kits are good examples of application domains for the repository architecture. It is also widely used in complex\ninformation management systems where the most important issue is reliable data management. The data store in the blackboard architecture option is active, and its clients are passive; thus, the flow of logic is determined by the\ncurrent data status in the data store. The clients of a blackboard are called knowledge sources, listeners, or subscribers. A new data\nchange may trigger events so that the knowledge sources take actions to respond to these events. These actions may result in new\ndata, which may in turn change the logic flow; this could happen continuously until a goal is reached.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 72", "position": 72, "chunk_type": "semantic", "token_estimate": 400}
{"text": "6 Data-Centered Software Architecture: A new data\nchange may trigger events so that the knowledge sources take actions to respond to these events. These actions may result in new\ndata, which may in turn change the logic flow; this could happen continuously until a goal is reached. Many applications designed in the\nblackboard architecture include knowledge-based AI systems, voice and image recognition systems, security systems, business\nresource management systems, etc. Figure 6.1\n \nBlock diagram of typical data-centered architecture\n \nFigure 6.1 shows an overall block diagram of a data-centered architecture. The solid lines in the diagram describe the bidirectional\ndata link (get data and put data), while the dashed lines describe the bidirectional control flow links (control over the data or control over\nthe agents). 6.2 Repository Architecture Style\n \nThe repository architecture style is a data-centered architecture that supports user interaction for data processing (as opposed to the\nbatch sequential transaction processing discussed earlier). The software component agents of the data store control the computation\nand flow of logic of the system. Figure 6.2 gives a general picture of the repository architecture. The dashed lines pointing toward\nrepository in Figure 6.2 indicate that repository clients have full control over the logic flow. Clients can get data from the data store and", "domains": ["Design Principles", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 72", "position": 72, "chunk_type": "semantic", "token_estimate": 210}
{"text": "put data in the data store. Different clients may have different interfaces and different data access privileges.: Figure 6.3 shows a class diagram for a simple data store for student management. It describes the static relationships between data\nclasses and their backup database tables, and between data classes and their collection classes. This diagram presents a\nprogramming-oriented view of the repository design architecture. A Students collection (Vector or ArrayList, or any other\nsuitable collection type) has an aggregation relationship with Student class. Figure 6.2\n \nRepository architecture\n \n \nFigure 6.3\n \nClass diagram\n \nClients can add in or remove a student from the Students set that will also affect the Students table in the database via database\nconnectivity technology. We use a simple fragment of java code to explain the class diagram above. public class Student implements Serializable {\n  String SSN;\n  String Name;\npublic Student() {\n  SSN = \"\";\n  Name = \"\";\n}\npublic Student(String ssn, String name) {\n  SSN = ssn;\n  Name = name;\n}\npublic void setSSN(String ssn) { SSN = ssn; }\npublic String getSSN() { return SSN; }\npublic void setName(String name) { Name=name; }\npublic String getName() { return Name; }\n}\nThe Student class is a data bean backed up by a corresponding table in a database. The instance of this class represents one\nspecific record in the database table (a table row) at a time. Assume that there is a table called students which has two columns: ssn\nand name. This class provides a default constructor and a customized constructor. It also provides getter and setter methods for\neach of its attributes. The following fragment shows the connection between the data bean class and the database. The Java DataBase Connectivity\n(JDBC) driver makes a connection to an Oracle database table called students first, as follows. . . . try {\n Class.forName(\u201csun.jdbc.odbc.JdbcOdbcDriver\u201d);\nConnection connection =\n DriverManager.getConnection(\n  \"jdbc:odbc:students\");\n }\n catch(Exception e){\u2026}\nThe Java code below creates a JDBC SQL statement to select all records from the students table and place them in the ResultSet. An instance of the data bean class is created by the new\n operator. The while loop iterates the ResultSet and adds every record\ninto the studentList one at a time through the instance of the Student class.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 73", "position": 73, "chunk_type": "semantic", "token_estimate": 373}
{"text": ". . . ArrayList studentList = new ArrayList();\nStatement statement = connection.createStatement();\nResultSet results =\n  statement.executeQuery(\u201cSELECT * FROM students\u201d);\nStudent student = new Student();\nwhile (results.next()) {\n student.setSsn(results.getSsn(1));\n student.setName(results.getName(2));\n studentList.add(student);\n}\nThis code fragment may be a part of client application program. The clients iterate the JDBC ResultSet and put data in the object of\nthe data bean class Student which then associates with a record in the corresponding table by JDBC and, in turn, adds the object\nto the studentList, an ArrayList collection type data structure. Figure 6.4 depicts a dynamic view of this repository architecture. It indicates that one instance object can be shared and accessed by\nmultiple clients with reading and writing for search, update, insertion, and deletion. The clients can access the same data with\ncommand line interface, GUI interface, program interface, Remote Procedure Call interfaces (RPC), or object-oriented Remote Method\nInvocation (RMI). The relational database management system is a typical design domain for the repository architecture. The data store of the repository\nmaintains all types of data including schema (metadata), data tables, and index files for data tables. Many tools are available to\ndevelop applications on the database stored in the database management system. These include design, development, maintenance,\nand documentation tools. Oracle Designer, Oracle Developer (Form, Graphics, and Reporter), Oracle SQL and PL/SQL, Oracle\nFinancials, Oracle e-Business, Oracle data warehouse, and many other software tools are available for Oracle database system. The\ndiagram in Figure 6.5 shows a typical database system with its data repository. Figure 6.4\n \nSequence diagram of repository architecture\n \n \nFigure 6.5\n \nDatabase system\n \nA Computer Aided Software Engineering (CASE) system is another popular application domain for the repository software\narchitecture. There are many CASE tools surrounding the data store in Figure 6.6. A user of CASE tools can draw a UML design\ndiagram such as a class diagram, collaboration diagram, or sequence diagram by Booch method, Rumbaugh method, or Jacobson\nmethod, and store the design blueprints in the CASE data store. These UML diagrams can then be converted from one format to\nanother. Java or C++ skeleton code can also be generated based on these UML diagrams. If there is code without the original design\ndiagram, the UML diagram can still be regenerated by reverse engineering tool. There are many other input formats available for\ndesign and many output formats, as well.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 74", "position": 74, "chunk_type": "semantic", "token_estimate": 391}
{"text": "Figure 6.6\n \nCASE system\n \nThe biggest advantage of CASE tools is its centralized data with many supporting software tools which can generate different products\nfor different purposes based on the same set of data. Compiler construction is another good example of the repository architecture design. Every compiler system has its own reserved\nkeyword table, identifier symbol table, constant table generated after lexical analysis, and syntax and semantics trees generated by\nsyntax and semantics analysis. These tables' data structure in memory is shared by all phases of the compilation. Each phase will\ngenerate new data or update the existing data in the data repository. The flow control is controlled by a program which takes a source\ncode as its input, then goes through each phase step by step, and finally produces the target binary code which is either executable or\ninterpretable, such as Java bytecode. In other words, all agents in a repository system are not necessarily completely independent. There is a logical order in the executions of all compilation phases. There may still be some communication between individual agents. For example, the lexical analysis may find some unacceptable characters, so that the compilation must be abandoned and compile\nerrors must be reported. Let's take a closer look at the simple compilation example shown in Figure 6.7. Figure 6.7\n \nCompiler system\n \nThe scanner takes two lines of an int type variable declaration and an assignment statement. The lexical analyzer (scanner) tokenizes\nall input entities and puts them in the symbol table used by the syntax analyzer (parser) to build a syntax tree based on the grammar. This syntax tree is checked again by the semantics analyzer (not shown) and is also used by the code generator to produce the target\ncode. We can see that the data in memory are shared by all agents and that the agents don't pass on data to each other directly. There are variants of repository architecture such as virtual repository and decentralized (distributed) repository. The virtual repository\nis built up on the top of multiple physical repositories. Most database systems allow users or developers to create views that are virtual\nrepositories since they do not exist physically. This approach can simplify the complexity of overall database structure; it can also\nprovide security management of authority privileges in terms of scope of data and types of manipulations for different users or groups.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 75", "position": 75, "chunk_type": "semantic", "token_estimate": 396}
{"text": "Most database systems allow users or developers to create views that are virtual\nrepositories since they do not exist physically. This approach can simplify the complexity of overall database structure; it can also\nprovide security management of authority privileges in terms of scope of data and types of manipulations for different users or groups. In a distributed repository system, also known as a distributed database system or an enterprise information system, all data are\ndistributed over all sites linked by network. Data are replicated in order to improve reliability and local accessibility. But it brings up\nmany other issues such as vertical or horizontal data partitions, synchronizations of duplicated data, and cost of data transmission on\nthe network; collaboration in a distributed transaction is a complicated two-phase transaction commitment.", "domains": ["Software Quality Attributes", "Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 75", "position": 75, "chunk_type": "semantic", "token_estimate": 129}
{"text": "Applicable domains of repository architecture:\n \n\u2022   Suitable for large, complex information systems where many software component clients need to access them in different ways\n \n\u2022   Requires data transactions to drive the control flow of computation\n \nBenefits:\n \n\u2022   Data integrity: easy to back up and restore\n \n\u2022   System scalability and reusability of agents: easy to add new software components because they do not have direct communication\nwith each other\n \n\u2022   Reduces the overhead of transient data between software components\n \nLimitations:\n \n\u2022   Data store reliability and availability are important issues. Centralized repository is vulnerable to failure compared to distributed\nrepository with data replication. \u2022   High dependency between data structure of data store and its agents. Changes in data structure have significant impacts on its\nagents. Data evolution is more difficult and expensive. \u2022   Cost of moving data on network if data is distributed. Related architecture:\n \n\u2022   Layered, multi-tier, and MVC\n \n6.3 Blackboard Architecture Style\n \nThe blackboard architecture was developed for speech recognition applications in the 1970s. Other applications for this architecture\nare image pattern recognition and weather broadcast systems. Typical examples of this architecture are the Hearsay-II speech\nrecognition expert system and the CRYSTALIS molecular structure analysis system. The word blackboard comes from classroom teaching and learning. T\neachers and students can share data in solving classroom\nproblems via a blackboard. Students and teachers play the role of agents to contribute to the problem solving. They can all work in\nparallel, and independently, trying to find the best solution. The idea of blackboard architecture is similar to the classroom blackboard used in solving problems without deterministic outcome. It is\na data- directed and a partially data-driven architecture. The entire system is decomposed into two major partitions. One partition,\ncalled the blackboard, is used to store data (hypotheses and facts), while the other partition, called know\nledge sources, stores domain-\nspecific knowledge. There also may be a third partition, called the controller, that is used to initiate the blackboard and knowledge\nsources and that takes a bootstrap role and overall supervision control. The connections between the blackboard subsystem and knowledge sources are basically implicit invocations from the blackboard to\nspecific knowledge sources, which are registered with the blackboard in advance. Data changes in the blackboard trigger one or more\nmatched knowledge source to continue processing. Data changes may be caused by new deduced information or hypotheses results\nby some knowledge sources.", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 76", "position": 76, "chunk_type": "semantic", "token_estimate": 398}
{"text": "Data changes in the blackboard trigger one or more\nmatched knowledge source to continue processing. Data changes may be caused by new deduced information or hypotheses results\nby some knowledge sources. This connection can be implemented in publish/subscribe mode. Figure 6.8 illustrates a block diagram of the blackboard architecture. The solid lines indicate data links, while dashed lines represent\nthe flow logic control, which is controlled by any data changes in the data store. That is, the data in the blackboard store directs the flow\nof the computation. Many domain-specific knowledge sources collaborate together to solve a complex problem such as pattern recognition or\nauthentication in information security. Each knowledge source is relatively independent from the other knowledge sources. They don't\nneed to interact with each other, which is very similar to a repository system. They need only interact and respond to the blackboard\nsubsystem. Each source works on a specific aspect of the problem and contributes a partial solution to the ultimate solution. Figure 6.8\nBlackboard architecture", "domains": ["Design Principles", "Software Quality Attributes", "Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 76", "position": 76, "chunk_type": "semantic", "token_estimate": 168}
{"text": "Blackboard architecture\n \nFigure 6.9 shows a UML class diagram of a rule-based blackboard software architecture. As we can see, one blackboard may have\nmany knowledge sources associated with it, working on given data and deduced data available in the blackboard subsystem. Each\nknowledge source helps to solve problems in its expertise area. Knowledge can be stored in different knowledge representation\nformats depending on the reasoning strategy. For example, a knowledge source stores all related rules and provides activation\nmechanisms for the blackboard to trigger in rule-based expert system. Of course, knowledge sources must register themselves with the\nblackboard so that if any change takes place in the blackboard, they will be notified to fire up actions in the corresponding knowledge\nsources, which can deduce new facts and update the blackboard. Each individual knowledge source may have its own problem solving\nstrategy and use its own knowledge expertise to contribute to a partial solution which will lead to a final solution. The blackboard class\nholds the current data state, and the final problem solution will be placed in the blackboard for the controller to pick up and use to\ngenerate a final report. The rule-based strategy is one of many reasoning algorithms in use today. There are many other problem\nsolving strategies that can be applied including Fuzzy set theory, probability and statistics, neural network, data mining, and heuristic\nsearching. Figure 6.9\n \nClass diagram of blackboard architecture\n \nSince the blackboard architecture is basically a self-activated system, the controller subsystem in the architecture only acts at the\nbeginning of the process to initiate blackboard and all knowledge sources; it also periodically inspects the current state of the\nblackboard to determine whether to terminate the processing if the solution is acceptable or optimal enough. Let's take a look at a well-known animal identification knowledge-based system (KBS). The knowledge is represented in the format of\nproduction rules with condition and action parts. For each rule, if the condition is true then the action is taken. The action is to put new\nconclusion data in the data store, which is the blackboard.", "domains": ["Design Patterns"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 77", "position": 77, "chunk_type": "semantic", "token_estimate": 347}
{"text": "For each rule, if the condition is true then the action is taken. The action is to put new\nconclusion data in the data store, which is the blackboard. Here is a set of rules:\n \nR1: IF animal gives milk then animal is mammal\n \nR2: IF animal eats meat then animal is carnivore\n \nR3: IF animal is mammal and animal is carnivore and animal has tawny color and animal has black stripes then animal is tiger\n \nThe set of facts is:\n \nF1: animal eats meat\n \nF2: animal gives milk\n \nF3: animal has black stripes\n \nF4: animal has tawny color\n \nThe goal is to recognize the animal. The problem may ask you to approve a statement or get a best recognition in the animal category. All the facts are placed in the blackboard and all knowledge is placed in the knowledge sources by the controller. There may be many\ndifferent reasoning models such as forward reasoning or backward reasoning. The forward reasoning starts with the initial state of data and proceeds toward a goal. It may reach the given goal or it may fail to reach\nthe goal. If the goal is not given, the reasoning will arrive at a point where no more new facts can be derived, indicating that the best\nresult has been determined. The backward reasoning works in the opposite direction. Let's follow the forward reasoning sequence. F1 matches the condition of R2, and \u201canimal is carnivore\u201d is derived and stored in the\nblackboard. If the algorithm checks the newest generated data first and the new fact does not match any rules, it then checks F2 which\nmatches the condition of R1. Then, \u201canimal is mammal\u201d is derived and stored in the blackboard. After this point there is no single fact", "domains": ["Design Patterns"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 77", "position": 77, "chunk_type": "semantic", "token_estimate": 294}
{"text": "Applicable domain of blackboard architecture:\n \n\u2022   Suitable for solving open-ended and complex problems such as artificial intelligence (AI) problems where no preset solutions exist. \u2022   The problem spans multiple disciplines, and each problem involves completely different types of knowledge expertise and problem-\nsolving paradigms that require cooperation. \u2022   Partial or approximate solution is acceptable to the problems. \u2022   Exhaustive searching is impossible and impractical since it may take forever because available knowledge and even data and\nhypotheses may not be complete or precisely accurate. Figure 6.12\n \nBlackboard architecture for a travel consulting system\n \nBenefits:\n \n\u2022   Scalability: easy to add or update knowledge source. \u2022   Concurrency: all knowledge sources can work in parallel since they are independent of each other. \u2022   Supports experimentation for hypotheses. \u2022   Reusability of knowledge source agents. Limitations:\n \n\u2022   Due to the close dependency between the blackboard and knowledge source, the structure change of the blackboard may have a\nsignificant impact on all of its agents. \u2022   Since only partial or approximate solutions are expected, it can be difficult to decide when to terminate reasoning. \u2022   Synchronization of multiple agents is an issue. Since multiple agents are working and updating the shared data in the blackboard\nsimultaneously, the preference or priority of executions of multiple agents must be coordinated. \u2022   Debugging and testing of the system is a challenge. Related architecture:\n \n\u2022   Implicit invocation architecture such as event-based, MVC architecture\n \n6.4 Summary\n \nData centered repository architecture may be one of the most popular software architectures since most software applications require\na data repository. Repositories are often used in layered architecture, client-server architecture, data tier in multi-tier architecture, and\nmany other architecture designs. Agents of the data store in data-centered repository architecture control the logic flow. The data store\nis passive in the repository architecture, and agents control and trigger all operations on the data store. Data-centered blackboard\narchitecture is a knowledge-based architecture where the status of the data in the data store controls and triggers most operations. The\ndata store is active in the blackboard software architecture. The connection between the components in the blackboard architecture is", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 79", "position": 79, "chunk_type": "semantic", "token_estimate": 350}
{"text": "implemented implicitly (instead of explicit invocation) in the repository systems. There are many expert systems for pattern recognition,: voice or speech recognition, or other similar systems with this architecture. 6.5 Self-Review Questions\n \n1. Which of the following is not a benefit of repository architecture? a. Independent agents\n    b. Reusable agents\n    c. Concurrency\n    d. Loose coupling\n2. Which of the following is a typical design domain of blackboard architecture? a. AI system\n    b. Business information system\n    c. Compilers\n    d. Virtual machine\n3. The Yellow Page of web service is an example of repository design. a. True\n    b. False\n4. Implicit notification is often used in blackboard architecture. a. True\n    b. False\n5. Repository architecture design must also be object-oriented design. a. True\n    b. False\n6. Agents in the repository architecture normally do not talk with each other directly, except though the data store. a. True\n    b. False\n7. Loose coupling is used between repository agents. a. True\n    b. False\n8. There is tight dependency of agents on the data store in the repository architecture. a. True\n    b. False\n9. Rule-based knowledge is installed in the blackboard component of the blackboard architecture. a. True\n    b. False\n10. The facts or hypotheses are stored in the knowledge source component of a blackboard system. a. True\n    b. False\nAnswers to the Self-Review Questions\n \n1. c 2. a 3. a 4. a 5. b 6. a 7. a 8. a 9. b 10. b\n \n6.6 Exercises\n \n1. What is data-centered architecture? 2. How many sub-architecture styles are there in this category? 3. What is the domain for repository architecture? 4. What is the domain for blackboard architecture? 5. What are the benefits of repository architecture and its limitation? 6. Is JVM an example of repository architecture? 7. Can a repository be decentralized? 8. Can repository architecture be a virtual repository? 9. Can the agents of a repository talk with each other? 6.7 Design Exercises\n \n1. Design software architecture for a student record management system by repository architecture. The system provides privileges\nfor the administrator to add or update student records and lets students check their own records. 2. Design software architecture for a weather broadcast system using blackboard architecture. Draw the block diagram and class\ndiagram. 3. Design software architecture for an animal identification system using a rule-based blackboard architecture style. Draw the block\ndiagram and class diagram. 6.8 Challenge Exercise\n \nDesign a security check-in system that provides face, fingerprint, voice, height, weight, and other document identification recognition\nmeans.", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 80", "position": 80, "chunk_type": "semantic", "token_estimate": 414}
{"text": "implemented implicitly (instead of explicit invocation) in the repository systems. There are many expert systems for pattern recognition,: Draw the block\ndiagram and class diagram. 6.8 Challenge Exercise\n \nDesign a security check-in system that provides face, fingerprint, voice, height, weight, and other document identification recognition\nmeans. The system has its recognition rules and preinstalled facts about trusted and target people. All KSS cooperate together to\nprovide the authentication integrity.", "domains": ["Software Quality Attributes", "Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 80", "position": 80, "chunk_type": "semantic", "token_estimate": 69}
{"text": "7 Hierarchical Architecture: e\n \nObjectives of this Chapter\n \n\u2022   Introduce the concepts of hierarchical software architecture\n \n\u2022   Describe the main-subroutine, master-slave, and layered architectures\n \n\u2022   Discuss the application domains of hierarchical software architecture\n \n\u2022   Discuss the benefits and limitations of hierarchical software architecture\n \n\u2022   Demonstrate the hierarchical software architecture in OS scripts and Java\n \n7.1 Overview\n \nThe hierarchical software architecture is characterized by viewing the entire system as a hierarchy structure. The software system is\ndecomposed into logical modules (subsystems) at different levels in the hierarchy. Modules at different levels are connected by explicit\nor implicit method invocations. In other words, a lower-level module provides services to its adjacent upper-level modules, which\ninvokes the methods or procedures in the lower level. In procedural language, the function and procedures may be organized in a\nheader file or in a library. In order to make use of services, an upper-level module must call the functions or procedures from these files\nor from library. In an object-orientation implementation of this architecture style, the services may be organized in a package of classes,\nthis package is then imported by the upper-level modules to obtain the needed services by making calls to the corresponding class\noperations. System software is typically designed using the hierarchical architecture style; examples include Microsoft .NET\n, Unix operating\nsystem, TCP/IP, etc. One thing these have in common is that services at lower levels provide more specific functionality down to\nfundamental utility services such as I/O services, transaction, scheduling, and security services, etc. Middle layers, in an application\nsetting, provide more domain- dependent functions such as business logic or core processing services. Upper layers provide more\nabstract functionality in the form of user interfaces such as command line interpreters, GUIs, Shell programming facilities, etc. Each\nlayer provides services to its immediate upper layer. Any changes to a specific layer may affect only its adjacent upper layer, but only\nwhen its interface is changed. Otherwise there are no ripple effects of changes. This architecture category is characterized by the hierarchical structure and explicit method invocation (call-and-return) connection\nstyles. It is also used in the organization of class libraries such as Java API in package hierarchy or .NET class library in name space\nhierarchy. A variety of design types\u2014procedure-oriented, object-oriented, component- oriented, domain-specific\u2014can all implement the\nhierarchical software architecture. Figure 7.1\n \nHierarchical architecture\n \nAdditionally, as discussed earlier, an architecture style can work together with other styles.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 82", "position": 82, "chunk_type": "semantic", "token_estimate": 403}
{"text": "7 Hierarchical Architecture: A variety of design types\u2014procedure-oriented, object-oriented, component- oriented, domain-specific\u2014can all implement the\nhierarchical software architecture. Figure 7.1\n \nHierarchical architecture\n \nAdditionally, as discussed earlier, an architecture style can work together with other styles. In fact, it is hard to find software designs that\nonly use one architecture style. The hierarchical structure is one of the most popular styles that often combine with other styles. There are four particular styles that are hierarchical: the main-subroutine, master-server, layered, and virtual machine. Figure 7.1 shows the block diagram of typical hierarchical software architecture. 7.2 Main-Subroutine", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 82", "position": 82, "chunk_type": "semantic", "token_estimate": 94}
{"text": "The main-subroutine design architecture has dominated the software design methodologies for a very long time. The purpose of this: architecture style is to reuse the subroutines and have individual subroutines developed independently. In the classical procedural\nparadigm, typically data are shared by related subroutines at the same level. With object orientation, the data is encapsulated in each\nindividual object so that the information is protected. People often refer to the main-subroutine style as a traditional style rather than OO\nstyle. Using this style, a software system is decomposed into subroutines hierarchically refined according to the desired functionality of the\nsystem. Refinements are conducted vertically until the decomposed subroutine is simple enough to have its sole independent\nresponsibility, and whose functionality may be reused and shared by multiple callers in the upper layers. Figure 7.2\n \nMain-subroutines architecture\n \nData is passed as parameters to subroutines from callers. Two ways to pass on parameter data are:\n \n\u2022   Pass by reference where the subroutine may change the value of data referenced by the parameter; and\n \n\u2022   Pass by value where the subroutine only uses the passed data but cannot change it. Another less frequently used parameter passing is passing by name, depending on the implementation technology used. Y\nou can even\npass in a reference to a procedure or function to implement callbacks (see next section). Typically a \u201cmain\u201d program drives the control over the sequencing of the subroutine calls by at least once looping over the invocations in\nsome order. Figure 7.2 shows subroutine sharing in the main-subroutine hierarchy style. The following describes how to map a requirement specification to the main-subroutine design style. A data flow diagram (DFD) is\noften used to model the software requirement in this case, where bubbles or circles represent processing or activities and arrows\nrepresent data flow. Figure 7.3 shows a DFD for the purchase order processing requirement. There may be two types of information\nflows: transform flow and transaction flow. In a DFD, the overall information flow is sequential. Both transform and transaction flows can\noccur in the same DFD. In a transform flow, incoming flow feeds data in an external format, such as XML, which is transformed into another format; then the\noutgoing flow carries the data out. Figure 7.3\n \nDFD mapped into mainsubroutine structure", "domains": ["Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 83", "position": 83, "chunk_type": "semantic", "token_estimate": 380}
{"text": "The transaction flow evaluates its incoming data and decides to follow one of many action paths.: During the mapping from DFD to the main-subroutine architecture, first we need to find the transform or transaction flows (Pressman,\n2005). Separate the incoming path and all action paths, and classify each action path as transform or transaction flows. The resulting\naction modules themselves may be transaction centers too or may involve transform flows. This factoring analysis continues until each\nmodule in the software architecture has its sole responsibility. In most cases an overall flow is a transform flow. The transform center can be easily isolated from the incoming and outgoing flows. A\ntransform flow is mapped by a controlling module for incoming, transform, and outgoing information processing. A transaction center can also be easily located in a DFD because the transaction centre is located at the fork origin of action paths. The transaction centre becomes a dispatcher control module that controls all subordinate action modules. The DFD diagram in Figure 7.3 depicts a simple example of a purchase process requirement. The process circle #1 receives\nrequests from the customer and records all related information. The data is forwarded to the next process (circle #2) which validates\nthe request (either return or purchase), and if the request is invalid it is rejected and the customer is notified (circle #4). T\no continue the transaction process #3 next selects one of the two different action paths; process #5 checks stock availability, while\nprocess #6 checks the customer credentials before making the invoice. On the alternate path, process #7 checks the return policy,\nwhile process #8 performs the refund transaction accordingly. If procedure-oriented software architecture is adopted, the software architect or designer needs to map the DFD to a hierarchy\nstructure with the mapping rules previously discussed. The result is shown at the bottom of Figure 7.3\n \nBenefits:\n \n\u2022   It is easy to decompose the system based on the definition of the tasks in a top-down refinement manner. \u2022   This architecture can still be used in a subsystem of OO design. Limitations:\n \n\u2022   Globally shared data in classical main-subroutines introduces vulnerabilities. \u2022   Tight coupling may cause more ripple effects of changes as compared to OO design. 7.3 Master-Slave\n \nThe master-slave architecture is a variant of the main-subroutine architecture style that supports fault tolerance and system reliability. In\nthis architecture, slaves provide replicated services to the master, and the master selects a particular result among slaves by certain\nselection strategies.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 84", "position": 84, "chunk_type": "semantic", "token_estimate": 413}
{"text": "The transaction flow evaluates its incoming data and decides to follow one of many action paths.: 7.3 Master-Slave\n \nThe master-slave architecture is a variant of the main-subroutine architecture style that supports fault tolerance and system reliability. In\nthis architecture, slaves provide replicated services to the master, and the master selects a particular result among slaves by certain\nselection strategies. The slaves may perform the same functional task by different algorithms and methods or by a totally different\nfunctionality. Figure 7.4 shows a master-slave architecture where all slaves implement the same service. The master configures the invocations of\nthe replicated services and receives the results back from all slaves. It then determines which of the returned results will be selected. The diagram in Figure 7.5 shows a UML class diagram for the master-slave architecture where multiple slave classes implement the\nsame interface in different ways. Figure 7.4\n \nBlock diagram for masterslave architecture\n \n \nFigure 7.5\n \nClass diagram for masterslave architecture\n \nOther characteristics of this architecture include parallel computing and accuracy of computation. All slaves can be executed in parallel.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 84", "position": 84, "chunk_type": "semantic", "token_estimate": 177}
{"text": "Since the same task is delegated to several different implementations, inaccurate results can be ruled out easily with a majority vote: strategy or other algorithms. Applicable domains of master-slave architecture:\n \nMaster-slave architecture is used for the software system where reliability is critical. This is due to the replication (redundancy) of\nservers. It should be noted that in database schema design, the terms master-slave or parent-child are employed to specify the dependency of\none entity on another. If the master node is deleted then the slave node has reason to stay. This concept does not apply to the\ndiscussion here. 7.4 Layered\n \nAs its name suggests, in a layered architecture the system is decomposed into a number of higher and lower layers in a hierarchy;\neach layer consists of a group of related classes that are encapsulated in a package, in a deployed component, or as a group of\nsubroutines in the format of method library or header file. Also, each layer has its own sole responsibility in the system. A request to layeri+1 invokes the services provided by the layeri via the interface of layeri. The response may go back to the layeri+1 if\nthe task is completed; otherwise layeri continually invokes services from the layeri-1 below. The interface of each layer encapsulates all\ndetailed service implementations in the current layer and the interfaces of the layers below. A request from a higher layer to the layer\nbelow is made via method invocation and the response goes back up via the method return. Each layer has two interfaces: the up interface provides services to its upper layer and the low interface requires services from its lower\nlayer. In a pure layered hierarchy, each layer only provides services to the adjacent upper layer and only requests services from the adjacent\nlayer directly below. Special cases may employ a bridge type connection, where an upper layer get services from a layer more than\none level down, and a breach connection where a lower layer gets services from its upper layer. Figure 7.6\n \nA partial layered architecture: business example\n \nThe higher layer provides more generic or application oriented services, which are more abstract; the lower layer provides more\nspecific utility type services, which are less abstract, and common services which many upper layer components may need. Figure 7.6 also depicts a typical layered architecture for business application software with user interaction. The solid lines indicate the\nservice request direction path, while the dashed lines indicate the response path.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Design Principles", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 85", "position": 85, "chunk_type": "semantic", "token_estimate": 415}
{"text": "Since the same task is delegated to several different implementations, inaccurate results can be ruled out easily with a majority vote: Figure 7.6 also depicts a typical layered architecture for business application software with user interaction. The solid lines indicate the\nservice request direction path, while the dashed lines indicate the response path. The higher the layer, the more abstract the services\nare (in terms of the distance from the physical operating system layer). On the top level, users only see the user interfaces such as a\nGUI, but not any detailed implementations. We can deploy each layer in a component format such as a jar file in Java. This is a compressed file deployed as a component of a\npackage. A jar file includes all the service classes from lower levels plus other related classes provided in the same layer, and possibly\nthose provided by Java API. As long as a jar file is on the classpath environment variable, you can access any classes in the jar file. Figure 7.7 shows an example of the logical package organization of the layered architecture. The UML notation for class package is\nused here. The top level deals with user interface, the next level is for utilities, and the one below utility provides core services. Each\nlayer gets support from its lower adjacent layer by an interface implementation and from the related classes in the same layer.", "domains": ["Architectural Patterns and Styles", "Design Principles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 85", "position": 85, "chunk_type": "semantic", "token_estimate": 235}
{"text": "Figure 7.7\n \nComponent-based layered architecture\n \nA simple software system may consist of two layers: an interaction layer and a processing layer:\n \n\u2022   The interaction layer provides user interfaces to clients, takes requests, validates and forwards requests to the processing layer for\nprocessing, and responds to clients. \u2022   The processing layer receives the forwarded requests and performs the business logic process, accesses the database, returns the\nresults to its upper layer, and lets the upper layer respond to clients since the upper layer has the GUI interface responsibility. The diagram in Figure 7.7 shows the separate responsibilities for upper and lower layers and decoupling of business logic from\npresentation. There are many good and widely known models designed using the layered architecture, such as ISO's OSI 7-layered model with\nlayers of application, presentation, session, transport, network, data link, and physical. Another is the web services model with layers of\nSOAP, XML, HTML, TCP, and IP; other examples are the Unix operating system design with layers of shell, core utility, device drivers,\nand the Microsoft .NET platform with CTS, JIT, and CLR sublayers. The networks protocols are designed also as layered architecture, except that there are two layered stacks connected by a network\nlink. A client makes a message or service request to the top layer of one stack. Then all subsequent layers perform their supporting\nservices and pass on the data with the request all the way down to the bottom layer. The request with the data is sent to the server side\nand moves all the way up until it reaches the server application. The response will come in the reverse direction. This works in a\nrequest-response mode. Figure 7.8. shows an example of the Simple Object Access Protocol (SOAP). The SOAP based web services technology supports\ncross-platform remote object, request-response Internet computing. A web service client sends a request in the SOAP message format\nto a web service housed at a web service engine and gets a SOAP formatted response message back from the web service via the\npair of protocol stacks. SOAP needs XML and HTML protocols support; the XML and HTML get services from TCP/IP protocol, while\nTCP/IP takes care of communication over the Internet.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 86", "position": 86, "chunk_type": "semantic", "token_estimate": 368}
{"text": "Figure 7.8\n \nSOAP protocol layered architecture\n \n \nFigure 7.9\n \nClass diagram for layered architecture\n \nA simplified UML class diagram for layered architecture is shown in Figure 7.9. All layers implement a common layer interface thus\nmaking each layer easier to be replaced. A higher layer is linked to its immediate lower layer by an aggregation relationship. Applicable domains of layered architecture:\n \n\u2022   Any system that can be divided between the application-specific portions and platform-specific portions which provide generic\nservices to the application of the system. \u2022   Applications that have clean divisions between core services, critical services, user interface services, etc. \u2022   Applications that have a number of classes that are closely related to each other so that they can be grouped together into a\npackage to provide the services to others. Benefits:\n \n\u2022   Incremental software development based on increasing levels of abstraction. \u2022   Enhanced independence of upper layer to lower layer since there is no impact from the changes of lower layer services as long as\ntheir interfaces remain unchanged. \u2022   Enhanced flexibility: interchangeability and reusability are enhanced due to the separation of the standard interface and its\nimplementation. \u2022   Component-based technology is a suitable technology to implement layered architecture; this makes it much easier for the system to\nallow for plug-and-play of new components. \u2022   Promotion of portability: each layer can be an abstract machine (see Section 7.5) deployed independently. Limitations:\n \n\u2022   Lower runtime performance since a client's request or a response to a client must go through potentially several layers. There are\nalso performance concerns of overhead on the data marshaling and buffering by each layer. \u2022   Many applications cannot fit this architecture design. \u2022   Breach of interlayer communication may cause deadlocks, and \u201cbridging\u201d may cause tight coupling. \u2022   Exceptions and error handling are issues in the layered architecture, since faults in one layer must propagate upward to all calling\nlayers.", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 87", "position": 87, "chunk_type": "semantic", "token_estimate": 312}
{"text": "Related architecture:: \u2022   Virtual machine, repository, and client-server\n \n7.5 Virtual Machine\n \nA virtual machine is built up on an existing system and provides a virtual abstraction, a set of attributes, and operations. In most cases a\nvirtual machine separates a programming language or application environment from an execution platform. A virtual machine may\nappear similar to emulation software. The diagram in Figure 7.10 describes the Unix operating system as a virtual machine; one that provides multiple shells such as C shell,\nKorn shell, and Born shell on top of the Unix kernel. The Unix kernel provides all core capabilities and utility libraries, which make all\nshell system calls independent from the underlying device drivers and actual physical devices. The common language runtime (CLR) of Microsoft .NET platform also plays the role of a virtual machine that uses a single intermediate\nlanguage to unify several modules VB.NET\n, VC.NET\n, and C# (see Figure 7.11.). This way, a VB.NET client can use a component\nwritten in C# or C++. Another well-known example of virtual machine is the Java Virtual Machine (JVM). This is a runtime environment (RTE) that makes the\nJava programming language platform independent. In other words, the Java bytecode and other Java internal code generated by a\ncompilation system (e.g., javac) can run on any operating system that supports JVM. JVM itself is platform dependent in that the RTE\nmust be developed based on a specific platform. JVM makes Java programs portable, which is one of the most significant advantages\nover other executable programming languages such as C++. The early procedural language Pascal introduced the concept for the first\ntime in the late 1970s (the P-machine and P-code). The Ada programming language specifies a standard runtime kernel, thus making\nit also similar to a virtual machine environment. In contrast, a C++ executable program can only run on the type of platform on which it\nwas generated. If we want to run it on another machine we must get the original source code recompiled on that machine, and hence it\nis not portable, at least at the runtime level. Figure 7.10\n \nUnix virtual machine\n \n \nFigure 7.11\n \nCLR virtual machine in .NET platform\n \nFigure 7.12 describes how the JVM separates the bytecode from the OS machine code. The bytecode is actually in a method format,\nand each op code can be interpreted by an interpreter.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 88", "position": 88, "chunk_type": "semantic", "token_estimate": 394}
{"text": "Related architecture:: Figure 7.10\n \nUnix virtual machine\n \n \nFigure 7.11\n \nCLR virtual machine in .NET platform\n \nFigure 7.12 describes how the JVM separates the bytecode from the OS machine code. The bytecode is actually in a method format,\nand each op code can be interpreted by an interpreter. The virtual machine itself is thus implemented as an interpreter. Any interpreter is like an execution engine which keeps track of the current state of the engine including the Program Counter (PC),\ndata registers, program-wide data, parameter data, method local data, operation stacks, and the source code being interpreted. The\ninterpreter system itself can be decomposed into code (class) loader and an executor. Let's look at a very simple java code and see\nhow it is interpreted by its JVM. public class simple{\npublic static void main(){\n for (int i=0; i<2; i++)\n   System.out.println(i);\n}\n}", "domains": ["Design Patterns"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 88", "position": 88, "chunk_type": "semantic", "token_estimate": 142}
{"text": "Figure 7.12\n \nRole of Java Virtual Machine\n \nAfter compiling the bytecode into a class file, you can view it by issuing the command \u201cjavap -c simple\u201d. The bytecode class file\nconsists of a series of method calls (similar to assembly code) that operate on an internal stack in memory. The following section describes the VM detailed interpretation. The label n: at the beginning of each line tells the offset of the bytecode from the beginning address of the interpreted code. The\ncharacter \u201ci\u201d at the beginning of the instruction indicates an integer operation. The execution engine fetches the first bytecode instruction at location 0. The iconst_0 instruction at location 0 is an in-line instruction pushing a constant 0 onto the stack. Stack: 0\nThe istore_0 at location 1 pops the top of the stack to a register variable V0\n \n                           Stack: ; V0: 0\nThe iload_0 at location 2 pushes the V0 onto the stack. Stack: 0 ; V0:0\nThe iconst_2 at location 3 pushes constant 2 onto the stack. Stack:0,2; V0:0\nThe is_icmpge at location 4 pops the top two values and compare 0 with 2, if 0 >= 2 is true go to 20. Because 0<2 the execution\nengine continues on to the next instruction at location 7. (if_icmpge instruction itself takes 3 bytes)\n \n                   Stack: ; V0:0\nThe getstatic #2 at location 7 pushes reference to the out field of the PrintStream class onto the stack. Stack: ref; V0:\nThe iload_0 at location 10 pushes the V0 onto the stack. Stack: ref,0; V0:0\nThe invokevirtual at location #3 invokes the println() method after it pops out the ref and data 0. 0 is printed out at this time. Stack: ; V0:0\nThe iinc 0, 1 increments the V0 by 1. Stack:   ;V0: 1\nGoto location 2 to start a new iteration until i equals 2.", "domains": ["Design Patterns"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 89", "position": 89, "chunk_type": "semantic", "token_estimate": 306}
{"text": "From the preceding discussion we can track the life cycle of an interpreter execution engine; its logic flow emulates a CPU operation. Figure 7.13 depicts the block diagram of a virtual machine for an interpreter. An execution engine of a virtual machine can be described by the following pseudocode. Assume that the bytecode is loaded in\nmemory already. It keeps running until it comes to the end of the interpreted code. Void virtualMachine(\u2026){\n. . . While(more bytecode)\n{fetch next bytecode;\n     fetch opcode;\n     fetch parameters if any;\n    switch(opcode)\n \nFigure 7.13\n \nInterpreter Execution Engine\n \n {\n . . . ILOAD:\n      Pop top of stack to a register;\n      Update the pc(program pointer);\n      Break;\n . . . IRETURN:\n      Goto end;\n }\n}\n  end;\n}\nApplicable domain of virtual machine architecture:\n \n\u2022   It is suitable for solving a problem by simulation or translation if there is no direct solution. \u2022   Sample applications include interpreters of microprogramming, XML processing, script command language execution, rule-based\nsystem execution, Smalltalk and Java interpreter type programming languages. Benefits:\n \n\u2022   Portability and machine platform independency\n \n\u2022   Simplicity of software development\n \n\u2022   Simulation for disaster working model\n \nLimitations:\n \n\u2022   Slow execution of the interpreter due to the interpreter nature\n \n\u2022   Additional overhead due to the new layer\n \nRelated architecture:\n \n\u2022   Interpreter, repository, and layered architecture\n \n7.6 Summary\n \nThe hierarchy architecture style decomposes a system into a number of layers in a hierarchical manner. Upper layers get services from\nadjacent lower layers. The connection between two adjacent layers is made by explicit method invocations from the upper layer to the\nlower layer. The main- subroutines, master-slave, layered, and virtual machine styles are all sub- architecture styles of the hierarchical\narchitecture model. Hierarchical architecture style, although very popular for the design of system software, such as operating system design, networking", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 90", "position": 90, "chunk_type": "semantic", "token_estimate": 296}
{"text": "protocol design, interpreters, and other business data processing, is also used in the design of application software. The style can be: implemented using structural technology, as well as modern object-oriented and component-oriented approaches. Here are some design guidelines for hierarchical architecture modeling. \u2022   Define the decomposition criteria: a layer only depends on its lower layer; each layer has its clear and specific tasks. \u2022   Determine the number of layers (\u2264 7) based on the division criteria. \u2022   Define the interface for each layer. \u2022   Define each layer services. \u2022   Define the connections between any two adjacent layers. \u2022   Design error handling. 7.7 Self-Review Questions\n \n1. Which of the following is not a benefit of hierarchical architecture? a. Concurrency\n    b. Interactive\n    c. Security\n    d. Exchangeable\n2. Which of the following is a disadvantage of hierarchical architecture? a. Overhead\n    b. Interface separation\n    c. Incremental\n    d. Exchangeable\n3. Web service is an example of hierarchy architecture design. a. True\n    b. False\n4. Hierarchical architecture is a procedure-oriented design paradigm only. a. True\n    b. False\n5. Hierarchical architecture can also be applied in any object- oriented software design. a. True\n    b. False\n6. Only directly adjacent layers can invoke each other's methods in a layered architecture. a. True\n    b. False\n7. Component deployment is a good practice in a layered architecture. a. True\n    b. False\n8. There is data sharing between all layers in a layered architecture. a. True\n    b. False\n9. The callback method is typically used in a main-subroutine architecture. a. True\n    b. False\n10. The master-slave architecture is a specialized form of main- subroutine architecture. a. True\n    b. False\nAnswers to the Self-Review Questions_\n \n1. a 2. a 3. a 4. b 5. a 6. b 7. a 8. b 9. b 10. a\n \n7.8 Exercises\n \n1. What is a hierarchy architecture? 2. Enumerate all the sub-architecture styles in this category. 3. What is the application domain for layered architectures? 4. What is the application domain for master-slave architectures? 5. What are the benefits of hierarchy architecture and its limitations? 6. Is JVM an example of hierarchical architecture? Explain why or why not? 7. Can a hierarchical architecture be built in bottom-up mode? 8. Can a hierarchical architecture be built in a top-down mode? 9. Can a request-response process model be applied in a hierarchical architecture design?", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 91", "position": 91, "chunk_type": "semantic", "token_estimate": 386}
{"text": "7.9 Design Exercises: 1. Design the software architecture for a student record management system using an OO layered architecture. The top layer is the\nGUI interface, the middle layer is the business process layer, and the bottom layer is for data access. Draw a block diagram, a\nUML class diagram, and a sequence diagram. 2. Implement the above system using Java according to the design architecture. 3. Design the software architecture for a device driver by a layered architecture. 4. Design an XML interpreter virtual machine that processes XML documents according to a DTD or an XML Schema that you\ndefine for the XML documents. 7.10 Challenge Exercises\n \n1. Construct a layered architecture using the application presentation layer, application domain layer, library service layer, and third\nparty layer to group all software components in the online payment system and motel reservation system at the end of Chapter 3. 2. Analyze the .NET framework class library and sketch the .NET framework in a layered architecture. 3. Analyze the Java 2 Enterprise Edition framework API and sketch the Java 2 EE framework in a layered architecture. References\n \nPressman, Roger. Softw\nare Engineering: A Practitioner's Approach. 6th ed. New York: McGraw-Hill, 2005, 255-291. Suggested Reading\n \nGarlan, David and Mary Shaw. Softw\nare Architecture: Perspectives on an Emerging Discipline. Upper Saddle River, NJ: Prentice\nHall, 1996.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 92", "position": 92, "chunk_type": "semantic", "token_estimate": 222}
{"text": "8 Implicit Asynchronous Communication Software Architecture: e\n \nObjectives of this Chapter\n \n\u2022   Introduce concepts of the asynchronous communication software architecture\n \n\u2022   Describe the nonbuffered event-based and buffered message-based architectures\n \n\u2022   Discuss applicable domains\n \n\u2022   Discuss the benefits and limitations of the asynchronous software architecture\n \n\u2022   Discuss other related architectures\n \n8.1 Overview\n \nThis chapter discusses software designs with asynchronous implicit invocation communications used in blackboard architecture in\nChapter 6. An asynchronous implicit invocation communication can be specified in two different modes: nonbuffered and buffered. We\nhave seen some architectures that apply the publisher-subscriber or producer-consumer patterns where the subscribers/consumers\nare interested in some events or messages issued by a publisher/producer. Subscribers register themselves with the event source. The subscriber is actually an event listener that, after registration, is notified of such occurrences. Once an event is fired off by an event\nsource, all corresponding subscribers are notified, which then take corresponding actions. It is up to the subscribers to decide on the\nactions to execute. The Observer pattern is another name used for this type of architecture. The message queue and message topic are typical buffered asynchronous architectures that subscribers/consumers also need to\nregister their interests with; the event/message is fired off when available on the buffered message queue or topic. A message queue\nis a one-to-one or point-to-point architecture between message senders and message receivers; whereas a message topic is a one-\nto-many architecture between publishers and subscribers. Regardless of the type of asynchronous architecture, the main purpose of this type of communication architecture is to provide a\ndecoupling between the event/message, the publishers/producers, and the subscribers/customers. These are very popular\narchitectures in distributed applications. Specific examples of implicit invocation architectures include, but are not limited to, JavaBean\ncomponents, ActiveX components, .NET components, the Enterprise JavaBean (EJB) callback methods by the EJB container, the\nCommon Object Request Broker Architecture (CORBA) callback mechanism, passing function pointers as parameters of function in\nmethod invocations in C++, Java XML SAX parser, and MS .NET Remote mechanisms. 8.2 Nonbuffered Event-Based Implicit Invocations\n \nThe nonbuffered event-based implicit invocation architecture breaks the software system into two partitions: eventsources and event\nlisteners. The event registration process connects these two partitions. There is no buffer available between these two parties. The event-based implicit invocations (nonbuffered) is part of SmallTalk language where each object keeps its own dependency list. Any\nstate changes of the object will impact its dependents.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 93", "position": 93, "chunk_type": "semantic", "token_estimate": 400}
{"text": "8 Implicit Asynchronous Communication Software Architecture: The event-based implicit invocations (nonbuffered) is part of SmallTalk language where each object keeps its own dependency list. Any\nstate changes of the object will impact its dependents. The diagram in Figure 8.1 shows the software architecture for the event-based\nimplicit invocation in SmallTalk. The graphic View components register themselves with the interested event source Model via the event\nspace. When the data is changed in the Model (event source) the target is notified via the event space and the target handles the event\naccordingly. These are the basics of the concept of event-based implicit invocation, which is the opposite of the direct explicit method\ninvocation whereby the invoker must wait for the response from the called module; in this case, the invoker does not proceed until the\ncalled party responds. The MVC adopts this for the connection between model and view. The diagram in Figure 8.2 depicts the explicit synchronous and implicit asynchronous connection architecture in a UML sequence\ndiagram. The upper portion of the diagram demonstrates the synchronous invocation, while the lower portion shows the asynchronous\none. In the latter, the service requester does not wait for the response; instead, it spawns a separate thread to receive the response\nfrom the service provider and resumes its own execution. The half arrow pointer in this portion of the figure indicates the asynchronous\ninvocations. In many cases the service provider needs to spend a significant amount of computing time before it can reply to the\nrequestors. That is also why asynchronous communication is necessary in many applications. In many other cases, such as a GUI\ninterface application, there is no need to loop-check on the user actions due to the nondeterministic feature of applications. Event-\ndriven asynchronous architecture better serves such applications, where events trigger and drive the computation.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 93", "position": 93, "chunk_type": "semantic", "token_estimate": 305}
{"text": "Figure 8.1\n \nEvent implicit invocations in SmallTalk\n \n \nFigure 8.2\n \nSynchronous vs. asynchronous invocations\n \nA typical event-based implicit invocation class diagram is given in Figure 8.3. The event source class must provide mechanisms to\nregister or deregister event targets and to notify event targets of the occurrence of the event. Event targets must specify the action in the\nhandleEvent() method to respond to incoming events. Above the concrete classes are the interfaces for event source and event\nlistener. The event-based implicit invocation is a good solution for user interaction in a user interface application. Simple Java fragments that\nfollow demonstrate how event sources and event targets (listeners) work together in an event-driven architecture for a user interface\napplication. package myEvent;\nimport java.applet.Applet;\n \nFigure 8.3\n \nClass diagram for event-based implicit invocation architecture\n \nimport java.awt. *;\nimport java.awt.event. *;\npublic class Source extends Applet {\n  private TextField text1;\n  private Button button1;\n  private Target target;\n  // Source is the place where event is triggered\n  public void init() {\n     text1 = new TextField(20);\n     add(text1);\n     button1=new Button(\u201cClick Me\u201d);\n     add(button1);\n     target = new Target(button1,text1);\n     button1.addActionListener(target);\n  }\n}\nThe T\narget registers with the event source by the following statement button1.addActionListener(target) where target\nis an object of class Target. The \u201cClick Me\u201d button is the event source. If it is pressed it will fire off an AWT event of ActionEvent,\nwhich will be intercepted by an ActionListener that has registered for it. In this case, the Target is the ActionListener\nwhere the actionPerformed() method specifies the event handling processing. The greeting message of \u201cHello <user>\u201d will be\ndisplayed in the text field text1 where the <user> is the user name typed in the text field before the button is pushed.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 94", "position": 94, "chunk_type": "semantic", "token_estimate": 282}
{"text": "The screen shot below shows the word \u201cJava\u201d typed in the text field of the Applet and the button \u201cClick Me.\u201d: The Target.java code is listed below. It specifies the actions which handle the ActionEvent event triggered by the button in the\nevent source. package myEvent;\nimport java.applet.Applet;\nimport java.awt. *;\nimport java.awt.event. *;\npublic class Target implements ActionListener {\n private Button button1;\n private TextField text1;\n public Target(Button b,TextField t) {\n  button1 = b;\n  text1 = t;\n }\n // Target is the event listener\n public void actionPerformed(ActionEvent event) {\n   String msg = new String(\u201cHello\u201d);\n   if (event.getSource()==button1) {\n    text1.setText(msg + \" \" + text1.getText());\n   }\n }\n}\nAfter \u201cClick Me\u201d is pushed, a greeting message \u201cHello Java\u201d is displayed in the text field. An event can also be generic non-GUI related which users themselves can define. We call such events user-defined events. The following Java fragments show a user-defined event-based architecture in Java. In the Java API, all events are subclasses of the\nEventObject class, regardless of whether they are built-in events or user-defined events. GUI event classes are subclasses of\nAWTEvent class or the Swing class, which is a subclass of EventObject. All the event listeners regardless of whether they are GUI\nbuilt-in listeners or user-defined listeners are subclasses of EventListener. Here is a user-defined event listener called MyListener. public interface MyListener extends EventListener\n{ void handleEvent(EventObject e); }\nNext is a user-defined event object MyEventObject which is just like the GUI event object. This event object holdsa long integer type\nof system time variable. It also provides a getTime() method to return the time when the object was created. public class MyEventObject extends EventObject {\n  long t1;\n  public MyEventObject(Object o) {\n   super(o);\n   t1 = System.currentTime();\n  }\n  public long getTime(){ return t1;}\n}\nThe target class Sink is a class of MyListener and handles the event by simply printing the time the event object holds. public class Sink implements MyListener {\n  \u2026\u2026\u2026..\n  public void handleEvent(EventObject e) {\n   System.out.println(\"Time is\" + e.getTime());\n  }\n  \u2026\u2026..\n}\nThe event source class Source is a thread class so that the event source and event sink can run on different threads concurrently. This\nevent source triggers a time event once every second. It also provides a registration vector for the event targets to register with this\nsource. The addMyListener() method adds event targets to the vector.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 95", "position": 95, "chunk_type": "semantic", "token_estimate": 391}
{"text": "Thread = new Thread(this);: An example from business is a stock managing system whereby a user can set upper and lower threshold levels of a specific stock. When the stock value goes either too high or too low, the user will be notified automatically by the system and action will be taken\nautomatically which can be configured by the user in advance. In an e-commerce system, when the inventory level of an item goes\nbelow the minimum stock level, the system is set to notify the contracted suppliers to order more items in order to keep the item in the\nstock. These are two typical applications where the event-handling approach is suitable. Applicable domains of nonbuffered event-driven architecture:\n \n\u2022   Interactive GUI component communication and integrated development environment (IDE) tools", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 96", "position": 96, "chunk_type": "semantic", "token_estimate": 129}
{"text": "\u2022   Applications that require loose coupling between components that need to notify or trigger other components to take actions upon: asynchronous notifications\n \n\u2022   The implementation of state machines\n \n\u2022   When event handlings in the application are not predictable\n \nBenefits:\n \n\u2022   Framew\nork availability: Many vendor APIs such as Java AWT and Swing components are available. \u2022   Reusability of components: It is easy to plug in new event handlers without affecting the rest of the system. \u2022   System maintenance and evolution: Both event sources and targets are easy to update. \u2022   Independency and flexible connectivity: Dynamic registration and deregistration can be done dynamically at runtime. \u2022   Parallel execution of event handlings is possible. Limitations:\n \n\u2022   It is difficult to test and debug the system since it is hard to predict and verify responses and the order of responses from the\nlisteners. The event trigger cannot determine when a response has finished or the sequence of all responses. \u2022   There is tighter coupling between event sources and their listeners than in message queue-based or message topic-based implicit\ninvocation. Data sharing and data passing in the event object forwarded from event sources to event listeners also make the\ncoupling tighter and somewhat hard to debug and test. \u2022   Reliability and overhead of indirect invocations may be an issue. Related architecture:\n \n\u2022   PAC, message-based, MVC, multi-tier, and state machine architectures\n \n8.3 Buffered Message-Based Software Architecture\n \nThe buffered message-based software architecture breaks the software system into three partitions: message producers, message\nconsumers, and message service providers. They are connected asynchronously by either a message queue or a message topic. This\narchitecture is also considered data-centric. In a message-based system, also referred to as a fire and forget system, a sender sends\nout a message that requires only a guaranteed message delivery reply. It is typically implemented as a message-oriented middleware\n(MOM) providing a reliable message service on a distributed system. Message-based software architecture has long been in use. Messaging systems are used to build reliable, scalable, and flexible\ndistributed applications supporting asynchronous communication. Messaging system architecture is essentially a peer-to-peer client-\nserver architecture. The high degree of independency of components within the messaging system is one of its most important\nfeatures. Its high scalability, interoperability in heterogeneous networks, and reliability also make the messaging system more popular. Messaging-based architectures are widely used in the infrastructure for network management, telecommunication services, e-\ncommerce, customer care, weather forecasting, supply chain management, banking systems, and many other systems.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 97", "position": 97, "chunk_type": "semantic", "token_estimate": 410}
{"text": "\u2022   Applications that require loose coupling between components that need to notify or trigger other components to take actions upon: Its high scalability, interoperability in heterogeneous networks, and reliability also make the messaging system more popular. Messaging-based architectures are widely used in the infrastructure for network management, telecommunication services, e-\ncommerce, customer care, weather forecasting, supply chain management, banking systems, and many other systems. In addition,\nmessaging systems are also used as bridges for system merging in the enterprise integration. Many platforms provide message queue mechanisms, including Unix and Microsoft MQ, while others like IBM MQseries, Progress\nSonicMQ, JBossMQ, and FioranoMQ implement directly the Java Message Server (JMS). The BEA WebLogic JMS provides\nadditional messaging flexibility over JMS. JMS is a typical API in J2EE platform that supports asynchronous messaging including\nMessage-Driven Bean (MDB), a special type of enterprise JavaBean, that asynchronously consumes messages. A message is a structured data with a message ID, message header, property, and a body. A typical example of a message is an\nXML document. Messaging is a mechanism or technology that handles asynchronous or synchronous message delivery effectively and reliably. A\nmessaging client can produce and send messages to other clients, and can also consume messages from other clients. Each client\nmust register with a messaging destination in a connection session provided by a message service provider for creating, sending,\nreceiving, reading, validating, and processing messages. Messaging supports loosely coupled distributed communication between software components; this is similar to the implicit event-\ndriven communication discussed earlier. However, a message receiver does not need to be available at the same time as the\nmessage sender in order for the communication to take place. In fact, the sender and receiver don't need to know each other's identity\nat all. The receiver, however, needs to know the message format and the message destination where the message is available.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 97", "position": 97, "chunk_type": "semantic", "token_estimate": 311}
{"text": "Most messaging systems support asynchronous communication that delivers messages to a client as they arrive; thus, a consumer\ndoes not have to request messages in order to receive them. Most messaging systems also support reliable message delivery that guarantees that the message is delivered exactly once. This kind of messaging system is similar to email except that the producers and the receivers of an email message are human beings\ninstead of software components. Point-to-Point Messaging (P2P) The message queue architecture is a point-to-point structure between producer and consumer. A\nP2P messaging architecture is composed of message queues, senders, and receivers. Each message is sent to a destination (a\nspecific queue) which is maintained by the consumer; consumer clients extract messages from these queues. The queue retains all\nmessages it receives either until the messages are consumed or until the messages expire. Each message has only one consumer,\nthat is, the message is \u201cgone\u201d once it is delivered. This approach allows multiple message receivers but only one of them will receive\nthe message as determined by the message service provider. A sender and a receiver of a message have no timing dependencies;\nthe receiver can still receive the message even if it was not available when the sender sent the message. P2P messaging requires that\nevery message sent to the message queue be processed successfully by a consumer. It is much more reliable than the simple event-\nlistener based system discussed earlier. Figure 8.5\n \nMessage queue of JMS\n \nThe Message Driven Bean (MDB) of EJB is a consumer of the message queue supported by JMS. The diagram in Figure 8.5 shows\nthe block diagram of Java Message Server (JMS) message queue. A message producer sends a message to the message queue\ndestination which is taken by the MDB without timing restrictions. Publish-Subscribe Messaging (P&S) The publish-subscribe messaging architecture is a hub-like architecture where publisher\nclients send messages to a message topic that acts like a bulletin board. Message topic publishers and subscribers are not aware of\neach other. One difference between P&S and P2P is that each topic message can have multiple consumers. The system delivers the\nmessages to all of its multiple subscribers instead of to a single receiver, as in the message queue system. Publishers and subscribers have a timing coupling dependency.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 98", "position": 98, "chunk_type": "semantic", "token_estimate": 383}
{"text": "The system delivers the\nmessages to all of its multiple subscribers instead of to a single receiver, as in the message queue system. Publishers and subscribers have a timing coupling dependency. A message topic consumer must subscribe the topic before it is\npublished unless the subscription is a durable subscription that is able to receive any topic messages sent while the subscribers are\nnot active or not ready yet. Figure 8.6\n \nMessage topics of JMS\n \nSimilar to event-based connection architectures, message-based connection architecture is mainly implemented by asynchronous\ncommunications (although it can also be synchronous). A software component can register a message listener with a consumer. A\nmessage listener is similar to an event listener. Whenever a message arrives at the destination, the provider delivers the message by\ncalling the listener's onMessage() method, which performs the message handling operation just like the actionPerformed()\nmethod of the class ActionListener for AWT or Swing event in the Java API discussed previously. Figure 8.6 describes the JMS message topics showing one published topic subscribed by multiple subscribers. In most applications the JMS and the consumers (MDBs) can be remote distributed clients of the message queue or message topics. The MDB can also provide services to its own clients while it can access a database if necessary. A message-based software application consists of the following parts. 1. A messaging service provider or message server: A messaging system that provides administrative and control features such\nas connection, session, and destination. 2. Clients of message service: Software components that produce and consume messages. 3. Messages: The objects that communicate information between message senders and message consumers. Figure 8.7 and Figure 8.8 illustrate the JMS architecture, which supports both the point-to-point and the publish-subscribe messaging", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 98", "position": 98, "chunk_type": "semantic", "token_estimate": 288}
{"text": "approaches.: Figure 8.7\n \nClass diagram for the message queue and message topic\n \n \nFigure 8.8\n \nSequence diagram of a message queue\n \nMessage clients (the message producer and message consumer) need to create connections to the message service provider and\nthen create their session on the message server. The message destination (the queue or topic) is created by either administrator or by\nclient programming. The message producer generates a message and sends it to the destination queue or topic; the message consumer receives the\nmessage from the destination asynchronously by accepting the call OnMessage(). A message listener acts as an asynchronous event handler for messages just like the ActionListener for ActionEvent in the\nJava AWT API. The message listener has a method onMessage() which specifies message handling just like the\nactionPerformed() method of the ActionListener. 1. Create a connection to the messaging system provider. 2. Create sessions for sending and receiving messages. 3. Create MessageProducers to produce messages and MessageConsumers to receive messages. Figure 8.9\n \nComplex enterprise system with JMS\n \nThen the message-producing client will create messages and publish them to topics, while a message-consuming client will listen for\nmessages associated with a topic and consume them as they arrive. The MDB in Figure 8.9 plays the role of message listener. The onMessage() method will be called back whenever the message\narrives at message queue or message topic destinations. Then the MDB can connect other session EJBs or entity EJBs on remote\nsites to let them take over the next distributed computation. An enterprise web online business-to-business (B2B) application can use message-based architecture in situations like the following:\n \n\u2022   The inventory component sends a message to the supplier component when the inventory level for an item drops below a certain\nlevel and needs to be replenished. \u2022   The inventory component also sends a message to the business office component to prepare cash to purchase more inventory\nitems and update the budgets. \u2022   The supplier component sends a notification message to the catalog component to update the information after the supplier\ncomponent gets more items in. Academic retail, financial services, manufacturing, health services, and other settings can take advantages of messaging applications.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 99", "position": 99, "chunk_type": "semantic", "token_estimate": 359}
{"text": "Applicable domains of message-based architecture:: \u2022   Suitable for a software system where the communication between a producer and a receiver requires buffered message-based\nasynchronous implicit invocation for performance and distribution purposes. \u2022   The provider wants components that function independently of information about other component interfaces so that components can\nbe easily replaced. \u2022   The provider wants the application to run whether or not all other components are running simultaneously. \u2022   The application business model allows a component to send information and to continue to operate on its own without waiting for an\nimmediate response. Benefits:\n \n\u2022   Anonymity: provides high degree of anonymity between message producer and consumer. The message consumer does not know\nwho produced the message (user independence), where the producer lives on the network (location independence), or when the\nmessage was produced (time independence). \u2022   Concurrency: supports concurrency both among consumers and between producer and consumers. \u2022   Scalability and reliability of message delivery: Reliability mechanisms include: control level setting of message acknowledgement;\nmessage persistence setting without loss; message priority level setting; and message expiration setting. \u2022   Supports batch processing. \u2022   Supports loose coupling between message producers and consumers, and between legacy systems and modern systems for\nintegration development. Limitations:\n \n\u2022   Capacity limit of message queue: This is not an inherent limitation but an implementation issue that can be minimized if the queue\nis implemented as a dynamic data structure (e.g., linked lists). However, there is an absolute limit based on available memory. It is\nalso difficult to determine the numbers of agents needed to satisfy the loose couplings between agents. \u2022   Complete separation of presentation and abstraction by control in each agent generates development complexity since\ncommunication between agents only takes place between the control of agents. \u2022   Increased complexity of the system design and implementation. Related architecture:\n \n\u2022   Event-based system, layered, multi-tier, and MVC\n \n8.4 Summary\n \nImplicit invocation architectures break the system into two parties: one party a publisher, sender, producer, source, or any other titles for\nevent or message announcement, and the other a subscriber, receiver, consumer, target, or any other title with the same meaning for\nregistering their interest and handling the events or messages. The communication between these two parties can be synchronous or\nasynchronous in a one-to-one (message queue), one-to-many (message topic, event-based), or many-to-one (event-based) mode.", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 100", "position": 100, "chunk_type": "semantic", "token_estimate": 384}
{"text": "Applicable domains of message-based architecture:: Related architecture:\n \n\u2022   Event-based system, layered, multi-tier, and MVC\n \n8.4 Summary\n \nImplicit invocation architectures break the system into two parties: one party a publisher, sender, producer, source, or any other titles for\nevent or message announcement, and the other a subscriber, receiver, consumer, target, or any other title with the same meaning for\nregistering their interest and handling the events or messages. The communication between these two parties can be synchronous or\nasynchronous in a one-to-one (message queue), one-to-many (message topic, event-based), or many-to-one (event-based) mode. Thus, the implicit invocation architecture style bases its invariants on whether the event source or message sender know what\ncomponents are interested in such events or messages; whether they care how the event target or message receiver will handle the\nevent or message; and whether the two parties (source and target) are loosely connected. This architecture style is commonly found in user interface design, e-commerce application design, and other distributed transactional\nbusiness applications where the system involves many pairs of producer-consumer models that are loosely and asynchronously\nconnected. The coupling between the sender and the receiver in message-based implicit invocation connected system is even looser\nthan the event-based connected system because there are no time constraints dependency. A message receiver can still receive\nmessages even if it is not running at the time the message was sent. In an event-based invocation system the event handler must be\nready in order to be able to intercept an event and take an action upon that event. This architecture style is commonly used in the connection between the Model subsystem and the view subsystem in an MVC or PAC\narchitecture. 8.5 Self-Review Questions\n \n1. Which of the following is one of the benefits of asynchronous architecture? a. Multiple independent agents", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 100", "position": 100, "chunk_type": "semantic", "token_estimate": 298}
{"text": "b. Flexible GUI interfaces: aces\n    c. Multiple views\n    d. Loose coupling of modules\n2. Which of the followings is not typical design domain of the asynchronous architecture? a. Multiple agents in a distributed system\n    b. Hierarchical structure\n    c. Web server site application\n    d. Java AWT and Swing\n3. The testing of synchronous architecture is more straightforward than asynchronous architecture. a. True\n    b. False\n4. Implicit notification is often used in MVC architecture. a. True\n    b. False\n5. Multiple event targets can register with same event source. a. True\n    b. False\n6. An event can be either visible or invisible. a. True\n    b. False\n7. Coupling in message-driven architecture is even looser than in event-driven architecture. a. True\n    b. False\n8. A registered event target must be ready to handle the event when the event is fired off. a. True\n    b. False\n9. A message receiver is not required to be ready when the message arrives. a. True\n    b. False\n10. The notification of events or messages is different from local or remote method invocation. a. True\n    b. False\n11. Multiple consumers can consume a message on a message queue. a. True\n    b. False\n12. An event can be declared on the fly. a. True\n    b. False\n13. Message-based architecture is appropriate for a compiler in an IDE design. a. True\n    b. False\nAnswers to the Self-Review Questions\n \n1. d 2. b 3. a 4. a 5. a 6. a 7. a 8. a 9. a 10. a 11. a 12. a 13. b\n \n8.6 Exercises\n \n1. What is asynchronous application? 2. Typically, how many major partitions are there in an implicit invocation or asynchronous architecture? Explain why. 3. Describe the common features of asynchronous architecture. 4. Are web services or grid services asynchronous-oriented technology? 5. What are the problem domains for event-driven implicit architectures? Why? 6. What are the problem domains of message queue-oriented architectures? Why? 7. Are Java AWT GUI components examples of asynchronous architectures? Why? 8. Describe the limitations of asynchronous architecture. 9. Explain the advantages of event-driven invocation over message-driven invocation. 10. Explain the advantages of message-driven architecture over event-driven architecture. 8.7 Design Exercises\n \n1. Design a software architecture for an online student registration waiting list system using the event-driven asynchronous\narchitecture. When a course section is closed, the system must register students in a waiting list. When seats are available,\nstudents registered in the waiting list will be notified.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 101", "position": 101, "chunk_type": "semantic", "token_estimate": 403}
{"text": "b. Flexible GUI interfaces: When a course section is closed, the system must register students in a waiting list. When seats are available,\nstudents registered in the waiting list will be notified. Draw a block diagram, class diagram, and either a sequence diagram or\ncollaboration diagram of your design, or both. 2. Design an event-driven software architecture for a GUI-oriented application. Draw a block diagram, class diagram, and either a\nsequence diagram or collaboration diagram, or both. 3. Design a software architecture for an inventory management system using the implicit invocation architecture. When the inventory\nhas less than the minimum stock amount the system would notify the supplier to reorder more such items. Draw a block diagram,\nclass diagram, and either a sequence diagram or collaboration diagram, or both. 8.8 Challenge Exercise", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 101", "position": 101, "chunk_type": "semantic", "token_estimate": 132}
{"text": "9 Interaction-Oriented Software Architectures: s\n \nObjectives of this Chapter\n \n\u2022   Introduce the concepts of interaction-oriented software architectures\n \n\u2022   Describe the MVC and PAC architecture styles\n \n\u2022   Discuss the application domains of interaction-oriented software architectures\n \n\u2022   Assess the benefits and limitations of the interaction-oriented software architecture style\n \n\u2022   Discuss other related architectures\n \n9.1 Overview\n \nMore and more software applications involve user input/output interactions and specific user interfaces to software systems. In this\nchapter we focus on the software architecture that best supports user interaction in the application. We will also discuss software\narchitectures for user interface design. The interaction-oriented software architecture decomposes the system into three major partitions: data module, control module, and\nview presentation module. Each module has its own responsibilities. The data module provides the data abstraction and all core\nbusiness logic on data processing. The view presentation module is responsible for visual or audio data output presentation and may\nalso provide user input interface when necessary. The control module determines the flow of control involving view selections,\ncommunications between modules, job dispatching, and certain data initialization and system configuration actions. The key point of\nthis architecture is its separation of user interactions from data abstraction and business data processing. Since there may be many\nview presentations in different formats, multiple views may be supported for the same data set. Even for a specific view presentation,\nthe interfaces or views may need to change often, so loose coupling between data abstractions and its presentations is helpful and is\nsupported by this style. The loose coupling connections can be implemented in a variety of ways such as explicit method invocation or\nimplicit registration/notification method invocation. The control module plays a central role that mediates the data module and view\npresentation modules. All three modules may be fully connected. This chapter presents two major style categories of interaction-oriented architectures: Presentation-Abstraction-Control (PAC) and\nModel-View-Controller (MVC). These two models are similar in the sense that they propose three component decompositions. The Presentation module of PAC is\nlike the View module of MVC; the Abstraction module of PAC looks like the data (or Model) module of MVC; the Control module of\nPAC is like the Controller module of MVC. Both MVC and PAC are used for interactive applications such as web online applications\nand distributed applications with multiple tasks and user interactions. They differ in their flow of control and organi zation.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 103", "position": 103, "chunk_type": "semantic", "token_estimate": 398}
{"text": "9 Interaction-Oriented Software Architectures: Both MVC and PAC are used for interactive applications such as web online applications\nand distributed applications with multiple tasks and user interactions. They differ in their flow of control and organi zation. The PAC is\nan agent-based hierarchical architecture, whereas MVC does not have a clear hierarchical structure and all three modules are\nconnected together. The Apache Strut is a well-known pattern-based framework for MVC architecture that is widely used in web application design. 9.2 Model-View-Controller (MVC)\n \nMost web developers are familiar with the MVC architecture because it is widely adopted for web server site interactive application\ndesign such as online shopping, surveys, student registration, and many other interactive service systems. MVC architecture is\nspecifically used in applications where user interfaces are prone to data changes. MVC also typically supports \u201clook and feel\u201d features\nin GUI systems. The Java Swing components and Java Swing layout managers are designed using the MVC architecture. This architecture was first introduced in Smalltalk-80. According to Glenn Krasner and Stephen Pope (1988):\n \nModel-View-Controller programming is the application of this three-way factoring whereby objects of different classes take over\nthe operations related to the application domain (the model), the display of the application's state (the view), and the user\ninteraction with the model and the view (the controller). Models: The model of an application is the domain-specific software simulation or implementation of the application's central\nstructure. Views: In this metaphor, views deal with everything graphical: they request data from their model and display the data.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 103", "position": 103, "chunk_type": "semantic", "token_estimate": 254}
{"text": "Controllers: Controllers contain the interface between their associated models and views and the input devices (e.g., keyboard,: pointing device, time). In summary, the Controller manages the user input requests, controls the sequence of user interactions, selects desired views for output\ndisplays, and manages all initialization, instantiations, and registrations of other modules in the MVC system. The Model module\nprovides all core functional services and encapsulates all data details. The Model module does not depend on other modules, and it\ndoes not know which views are registered with or attached to it. The View module is responsible for displaying the data provided by the\nModel module and updating the interfaces whenever the data changes are notified. Figure 9.1\n \nMVC-I architecture\n \n9.2.1 MVC-I\n \nThe MVC-I is a simple version of MVC architecture where the system is simply decomposed into two subsystems: The Controller-View\nand the Model. Basically, the Controller-View takes care of input and output processing and their interfaces; the Model module copes\nwith all core functionality and the data. The Controller-View module registers with (attaches to) the data module. The Model module\nnotifies the Controller-View module of any data changes so that any graphics data display will be changed accordingly; the controller\nalso takes appropriate action upon the changes. The connection between the Controller-View and the Model can be designed in a\npattern of subscribe-notify whereby the Controller-View subscribes to the Model and the Model notifies the Controller-View of any\nchanges. In other words, the Controller-View is an observer of the data in the Model module. In Figure 9.1 the Controller and View are\ncombined together to act as input/output user interface and the Model provides all data and domain services. Let's look at a simple GUI example designed in MVC-I. The View has a GUI interface with two text fields; the user enters a new number\nin one of the text fields and the accumulated summation is displayed in the other. The summation is held in the Model module. The\nModel provides all business logics including all getter and setter methods. Whenever the data in the Model is updated, it will notify the\nregistered GUI components of changes. Then the GUI components will update their displays. This is why we say that the data in the\nModel of MVC architecture is active rather than passive. Actually, for this specific example there is no need to have a separated Model to notify the change because actionPerformed()\ncan take care of all necessary changes.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 104", "position": 104, "chunk_type": "semantic", "token_estimate": 412}
{"text": "Controllers: Controllers contain the interface between their associated models and views and the input devices (e.g., keyboard,: This is why we say that the data in the\nModel of MVC architecture is active rather than passive. Actually, for this specific example there is no need to have a separated Model to notify the change because actionPerformed()\ncan take care of all necessary changes. This example shows how MVC-I architecture works. // ViewController.java: ViewController makes a \nconnection to the\n// Model first. It sets up a GUI environment for input\n// and output. It also attaches the display view of the\n// textField to the Model by an attach() function,\n// whenever user inputs a number in the textfield and\n// hits a return key the actionEventListener requests\n// service from the Model, performs business process,\n// and reports the result. package mvc1;\nimport java.awt. *;\nimport java.awt.event. *;\nimport javax.swing. *;\npublic class ViewController extends JFrame implements\n   ActionListener {\n   Model myModel;\n   JTextField myInput;\n   JTextField mySum;\n   JPanel content;\n public ViewController(Model model) {\n    myModel = model;\n    myInput = new JTextField(5);\n    mySum = new JTextField(15);\n    content = new JPanel();\n    content.add(myInput);\n    content.add(mySum);\n    setContentPane(content);\n    myInput.addActionListener(this);\n }\n Public void update() {\n     mySum.setText(\u201c \u201d + myModel.getSum());\n }\n public void actionPerformed(ActionEvent e) {\n    try {\n       myModel.add(myInput.getText());\n  } catch (Exception ex) { \u2026 }\n }\n}\n// Model.java: The Model of MVC-I\n provides data and services, It\n// provides mechanism for View/Controller to be", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 104", "position": 104, "chunk_type": "semantic", "token_estimate": 235}
{"text": "// registered and notified when any data is changed.: package mvc1;\nimport java.util. *;\npublic class Model {\n  int sum;\n  Vector listeners;\n public Model() {\n   sum = 0;\n   listeners = new Vector();\n }\n public void attach(ViewController vc) {\n   listeners.addElement(vc);\n }\n public void notifyVC() {\n    for (int i = 0; i < listeners.size(); i++) {\n       ViewController vc = (ViewController)\n                           listeners.elementAt(i);\n       vc.update();\n    }\n }\n public void add(String st) {\n    sum += Integer.parseInteger(st);\n    notifyVC();\n }\n public int getSum() {\n    return sum;\n    }\n }\n// MVC1.java: application client instantiates\n the View/Controller\n// and Model Attach View/Controller with the Model, and\n// starts this event driven application. import mvc1. *;\nimport javax.swing. *;\npublic class MVC1{\n  public static void main(String[] args) {\n    Model myModel = new Model();\n    ViewController vc = new ViewController(myModel);\n    myModel.attach(vc);\n    vc.setTitle(\u201cmy MVC-I\u201d);\n    vc.setVisible(true);\n  }\n}\nFor a simple GUI application we can combine the View and the Controller. For a more complex GUI application, it is better to separate\nthe View and the Controller. It is relatively easy to divide the View and the Controller in the previous example. Students can do it as an\nexercise. 9.2.2 MVC-II\n \nThe MVC-II architecture is a further development from the MVC-I architecture. The Model module provides all core functionality and\ndata supported by a database. The View module displays the data while the Controller module takes input requests, validates input\ndata, initiates the Model and the View and their connection, and dispatches tasks. The Controller and the View register with the Model\nmodule. Whenever the data in the Model module is changed, the View module and the Controller module are notified of the changes. In\nother words, the Model module plays an active role in MVC-II architecture as in the MVC-I. In MVC-II architecture, the View module and\nthe Controller module are separate. This allows for the division of labor; for example, programming experts can work on the\ndevelopment of Controller while graphics interface design experts can work on the development of View. Also, because graphics\ninterface technology is updated rapidly and business requirements are changed very often, it is much better to keep the View\nseparated from the Controller. The MVC in Figure 9.2 is the same as the MVC-I in Figure 9.1 except that the Controller and the View\nare separated. Figure 9.3 shows a class diagram for MVC-II.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 105", "position": 105, "chunk_type": "semantic", "token_estimate": 386}
{"text": "Figure 9.3\n \nA detailed MVC-II architecture\n \nFigure 9.4 depicts a sequence diagram for a generic MVC architecture. After clients start up the MVC application, the Controller\ninitializes the Model and View, and attaches itself and the View to the Model (this is called a registration with the Model). Later, the\nController intercepts a user request either directly from a command line or though the View interface, and forwards the request to the\nModel to update the data in the Model. The changes in the Model will trigger the Model to notify all attached or registered listeners of all\nchanges, and the interfaces in the View will also be immediately updated. Figure 9.4\n \nSequence diagram for MVC architecture\n \nThe diagram in Figure 9.5 shows a typical MVC block architecture diagram in Java technology. The JavaServer Pages (JSP) is used\nin the View module development; the Java Servlet is used in the Controller module implementation; and the Java Bean, Java\nEnterprise Bean (EJB), and the Java Data Base Connectivity (JDBC) are used in the Model module development. Similar to Java\ntechnology, Microsoft ASP .NET technology is used for View development and ADO .NET for Model development. The Controller gets\na request from the user via the GUI, or the command line interfaces and instantiates corresponding instances in the Model, selects the\nrelated Views for data display, calls business functions of the Model, and forwards the control to the View. The View gets the data from\nthe Model and displays the data in the GUI interface. The following example illustrates a simple implementation of an MVC-II architecture where there is only one Java class in each of the\nthree modules of the MVC architecture. The MyBean JavaBean class plays the role of data Model; MyServlet Servlet class\nplays the role of Controller; and the from-Servlet JSP plays a role of display View\n. Figure 9.5 shows the architecture diagram of this web application. The myServlet Servlet sets an item value and stores this item in a\nJavaBean named myBean. It then transfers the control to a JSP page named fromServlet.jsp which retrieves the item from the\nmyBean and displays it on a web page. Figure 9.5\n \nMVC architecture on Java Web platform", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 106", "position": 106, "chunk_type": "semantic", "token_estimate": 369}
{"text": "Whenever the data is changed the display is also changed. The following Java classes show a MVC-II template to provide more: detailed explanations on the MVC-II architecture. MyBean is a JavaBean class responsible for storing and providing data for business processing. This data JavaBean has one\nuserName private property and two public methods to read from and write to this item property. // MyBean.java for Model in MVC-II\npackage myPackage;\npublic class MyBean {\n   private String item;\n   public MyBean(){ item = \"\"; }\n   public void setItem(String item) {\n      this.item = item;\n  }\n  public String getItem() {\n     return this.item;\n  }\n}\nThe MyServlet Servlet class in the controller module sets the item property of myBean, stores this bean as an attribute (beanInfo)\nof the session implicit object, and dispatches the control to fromServlet.jsp of the View module. // MyServlet.java for Controller in MVC-II\nimport java.io. *;\nimport javax.servlet. *;\nimport javax.servlet.http. *;\nimport myPackage.MyBean;\npublic class MyServlet extends HttpServlet {\n    public void service(HttpServletRequest request,\n        HttpServletResponse response) throws\n        ServletException, IOException {\n     \n        MyBean myBean = new MyBean();\n        myBean.setItem(\u201cMVC\u201d);\n        HttpSession session = request.getSession();\n        session.setAttribute(\u201cbeanInfo\u201d, myBean);\n        RequestDispatcher rd;\n        rd = getServletContext().getRequestDispatcher\n                                 (\u201c/fromServlet.jsp\u201d);\n        rd.forward(request, response);\n    }\n}\nThe fromServlet.jsp in the View module just retrieves the item property stored in the myBean with the beanInfo id and\ndisplays it on the resulting page. // fromServelt.jsp for View in MVC-II\n   <jsp:useBean id=\u201cbeanInfo\u201d class=\"myPackage.MyBean\"\n    scope=\"session\"/>\n   <html>\n   <body>\n  <b>Hello <jsp:getProperty name=\"beanInfo\"\n     property=\"item\"/></b>\n   </body>\n   </html>\nApplicable domains of MVC architecture\n \n\u2022   Interactive applications where multiple views are needed for a single data model and the interfaces are prone to frequent data\nchanges. \u2022   Applications with clear divisions between controller, view, and data modules so that different professionals can be assigned to work\non different aspects of such applications concurrently. Benefits:\n \n\u2022   Many MVC vendor framework toolkits are available. \u2022   Multiple views synchronized with same data model. \u2022   Easy to change or plug in new interface views, allowing updating of interface views with new technologies without overhauling the\nrest of the system. \u2022   Very effective for developments if graphics, programming, and database development professionals are working in a team in a\ndesigned project. Limitations:", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 107", "position": 107, "chunk_type": "semantic", "token_estimate": 353}
{"text": "\u2022   Not suitable for agent-oriented applications such as interactive mobile and robotics applications. \u2022   Multiple pairs of controllers and views based on the same data model make any data model change expensive. \u2022   The division between the View and the Controller is not clear in some cases. Related architecture:\n \n\u2022   PAC, and implicit invocation such as event-based, multi-tier architecture\n \n9.3 Presentation-Abstraction-Control (PAC)\n \nThe PAC architecture is similar to MVC but with some important differences. PAC was developed from MVC to support the application\nrequirement of multiple agents in addition to interactive requirements. In PAC, the system is decomposed into a hierarchy of\ncooperating agents. Each agent has three components (Presentation, Abstraction, and Control). The Control component in each agent\nis in charge of communications with other agents. The top-level agent provides core data and business logics. The bottom-level agents\nprovide detailed data and presentations. A middle-level agent may coordinate low-level agents. Within each agent, there are no direct\nconnections between the abstraction component and Presentation component. The PACs three components concepts are applied to all concrete subsystem architectures. PAC is suitable for any distributed system\nwhere all the agents are distantly distributed and each agent has its own functionalities with data and interactive interface. In such a\nsystem, all agents need to communicate with other agents in a well-structured manner. PAC is also used in applications with rich GUI\ncomponents where each of them keeps its own current data and interactive interface and needs to communicate with other\ncomponents. Of course, some concrete agents need all three components and others do not. For some middle-level agents, the interactive\npresentations are not required, so they do not have a presentation component. The control component is required for all agents\nbecause this is the only way for an agent to talk to another agent. Figure 9.6 shows a diagram for a single agent in a PAC design. The Control component is a mediator between the Presentation\ncomponent and the Abstraction component within the agent, and also a bridge between the agent itself and other agents, as well. The\nPresentation and Abstraction components are loosely coupled. The Presentation component is responsible for both data input and\noutput in GUI interfaces where the data come from the Abstraction component. The Abstraction component is responsible for providing\nlogical data concepts and services and encapsulating all detailed data manipulation.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 108", "position": 108, "chunk_type": "semantic", "token_estimate": 393}
{"text": "The Presentation component is responsible for both data input and\noutput in GUI interfaces where the data come from the Abstraction component. The Abstraction component is responsible for providing\nlogical data concepts and services and encapsulating all detailed data manipulation. Figure 9.6\n \nA single agent in PAC\n \n \nFigure 9.7\n \nMultiple agents in PAC\n \nLet's discuss how PAC works by using a simple example. We design a desktop presentation application that can browse and display\npresentation pages in a graphic document one at a time. The application provides four buttons to show the first page, last page,\nprevious page, and the next page, respectively. The agent A1 (see Figure 9.7) has a connection to the data repository, which is the\ndocument file. This agent points to the current page in the document while agent P1 can display the current page in a specified format.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 108", "position": 108, "chunk_type": "semantic", "token_estimate": 143}
{"text": "Assume that the current page is the second to last page in the document at this time. If the user clicks on the next button, the control\nagent C4 informs agent P4 to update its presentation; in this case, it also hides the next button since there is no next page after the last\npage. Agent C4 also informs agent A4 to update the data on the next button. After C4 handles all local processing, it contacts its parent\nagent, C1, to let it take over. After C1 gets the message from C4, it tells A1 to move the next page, which is the last page in the\ndocument, and then asks P1 to display that page. C1 also informs C5 to hide the last button since the current page is the last page (or\nlet the last button stay based on the requirement specification). We can see that all the agents communicate via the controls. The data\nstructure shown on the upper-right corner of Figure 9.7 indicates the pointer and data. Since PAC2, PAC3, PAC4, and PAC5 are all\nbuttons, they have very similar data and presentation functions such as hide, move-over, and gray-out features; their controls, however,\nare different. The class diagram in Figure 9.8 represents the PAC architecture shown in the concept diagram of Figure 9.7. The diagram in Figure 9.9 shows the interaction sequence in the example just discussed. When the next button is pressed to display\nthe last page in the document, PAC4 and PAC1 react as follows:\n \nP4 informs C4 that the \u201cnext\u201d button was pressed. C4 sends an update to A4. C4 informs P4 to update its presentation or shape. C4 contacts C1 (a top level agent). C1 sends an update to A1 to move the pointer to next (last page). C1 instructs P1 to display the last page. Applicable domains of the PAC architecture:\n \n\u2022   Suitable for an interactive system where the system can be divided into many cooperating agents in a hierarchical manner and each\nagent has its own specific assigned job. \u2022   Suitable when the coupling among the agents is expected to be loose so that changes on an agent do not affect others.", "domains": ["Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 109", "position": 109, "chunk_type": "semantic", "token_estimate": 364}
{"text": "Applicable domains of the PAC architecture:\n \n\u2022   Suitable for an interactive system where the system can be divided into many cooperating agents in a hierarchical manner and each\nagent has its own specific assigned job. \u2022   Suitable when the coupling among the agents is expected to be loose so that changes on an agent do not affect others. Benefits :\n \n\u2022   Support of multitasking and multiviewing\n \n\u2022   Support agent reusability and extensibility\n \n\u2022   Easy to plug in new agent or replace an existing one\n \n\u2022   Support for concurrency where multiple agents run in parallel in different threads or on different devices or computers\n \nLimitations:\n \n\u2022   Extra time lost due to the control bridge between presentation and abstraction and the communication of controls among agents. \u2022   Difficult to determine the correct number of the agents due to the loose coupling and high independence between agents. \u2022   Complete separation of presentation and abstraction by control in each agent generates development complexity since\ncommunications between agents only take place between the controls of agents. Figure 9.8\n \nClass diagram for PAC", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 109", "position": 109, "chunk_type": "semantic", "token_estimate": 177}
{"text": "Figure 9.9\n \nA sample sequence diagram for PAC\n \nRelated architecture:\n \n\u2022   Layered, multi-tier, and MVC\n \n9.4 Summary\n \nThe MVC and PAC architectures are interaction-oriented. Both support the three-module decomposition of Presentation/View,\nAbstraction/ Model, and Control/Controller. An important difference between the two styles is that the data in the MVC is active\nwhereas the data in PAC is passive. Active data in MVC notifies the other two modules of any changes in the data; changes in passive\ndata in PAC are under full control of the control component. Although both of these two architectures are popular in interactive applications with GUIs, PAC is a better choice for such systems\nwhere subsystems require their own customized interactive interfaces. The MVC architecture is widely used in web application design,\nwhile the PAC architecture is widely used in agent-based distributed systems, where each agent has a specific task and interface. The\nPAC architecture is the right choice for distributed applications of wireless mobile communication systems since each device needs to\nhave its own data and its own interactive interface, and also needs to communicate with other devices. A typical PAC software design\nis a networked traffic control management system that requires many mobile agents to monitor traffic and get data; display the\nanalyzed data in graphics; coordinate the data from agents; and many other management tasks. The PAC architecture is layered in a hierarchy where the top agent has access to the data repository, that is, it is global, while the\nbottom-level agents have their own local data and local interface. The middle-layered PAC agents coordinate the low-level agents. All\ncommunication is conducted by the control components of each individual agent. It is not realistic to have a single architecture style in a\ndesign problem. 9.5 Self-Review Questions\n \n1. Which of the following is not a benefit of the MVC architecture? a. Supports multiple independent agents\n    b. Provides flexible GUI interfaces\n    c. Supports multiple views\n    d. Supports loose data coupling\n2. Which of the following is a typical design domain for the MVC architecture? a. Multiple agents in a distributed system\n    b. Hierarchical structure\n    c. Web server site application\n    d. Web client site application\n3. Traffic control agents in a city traffic management system may be designed using PAC. a. True\n    b. False\n4. Implicit notification is often used in the MVC architecture. a. True\n    b. False\n5.", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 110", "position": 110, "chunk_type": "semantic", "token_estimate": 394}
{"text": "True\n    b. False\n5. The data in the Model component of the MVC architecture is active. a. True\n    b. False\n6. The data in the Abstraction component of a PAC agent is passive. a. True\n    b. False\n7. PAC agents are loosely coupled. a. True\n    b. False\n8. The Abstraction and Presentation components in a PAC agent do not talk to each other directly. a. True", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 110", "position": 110, "chunk_type": "semantic", "token_estimate": 66}
{"text": "b. False: alse\n9. The \u201cLook and Feel\u201d feature is well supported in the MVC architecture. a. True\n    b. False\n10. The PAC architecture is a hierarchically structured software architecture. a. True\n    b. False\nAnswers to the Self-Review Questions\n \n1. a 2. c 3. a 4. a 5. a 6. a 7. a 8. a 9. a 10. a\n \n9.6 Exercises\n \n1. What is an interactive application? 2. Typically, how many layers does PAC architecture contain? 3. Describe the features common to both the PAC and MVC architectures. 4. Describe the major differences between the PAC and MVC arcitectures. 5. What are the problem domains for MVC architecture? 6. What are the problem domains for PAC architecture? 7. Are Java AWT GUI components examples of PAC architecture? 8. Describe the limitations of PAC architecture. 9. Describe the advantages of MVC over PAC architecture. 10. Describe the advantages of PAC over MVC architecture. 9.7 Design Exercises\n \n1. Design the software architecture for a student online registration system using the MVC architecture. Draw the corresponding\nblock diagram, class diagram, and either a sequence or collaboration diagram. 2. Design the software architecture for a distributed traffic control system using the PAC architecture. Draw the corresponding block\ndiagram, class diagram, and either a sequence or collaboration diagram. 3. Design the software architecture for a distributed game system using the PAC architecture. Draw the corresponding block\ndiagram, class diagram, and either a sequence or collaboration diagram. 4. Design the software architecture for an online bookstore system using the PAC architecture. Draw the corresponding block\ndiagram, class diagram, and either a sequence or collaboration diagram. 9.8 Challenge Exercises\n \n1. Design the software architecture for a professional conference online registration system using the MVC architecture. The\nfunctional requirements include: announcement, call for papers, online paper submission, online paper reviews, paper\nnotification, conference online registration, etc. Draw the corresponding block diagram, class diagram, and either a sequence or\ncollaboration diagram. When designing a solution based on this architecture, be sure to consider how to increase performance,\nextensibility, and scalability. 2. Design the software architecture for an online distribution system for a business enterprise using the PAC architecture. Draw the\ncorresponding block diagram, class diagram, and either a sequence or collaboration diagram. When designing a solution based\non this architecture, be sure to consider how to increase performance, extensibility, and scalability. References\n \nKrasner, Glenn and Stephen Pope.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 111", "position": 111, "chunk_type": "semantic", "token_estimate": 398}
{"text": "b. False: When designing a solution based\non this architecture, be sure to consider how to increase performance, extensibility, and scalability. References\n \nKrasner, Glenn and Stephen Pope. \u201cA Cookbook for Using the Model-View\n Controller User Interface Paradigm in Smalltalk-80.\u201d\nJournal of Object-Oriented Programming, Vol. 1, No. 3. SIGS Publications (1988): 26-49. Suggested Reading\n \nBuschmann, Frank, Regine Meunier, Hans Rohnert, Peter Sommerlad, and Michael Stal. Pattern-Oriented Softw\nare Architecture: A\nSystem of Patterns. Vol. 1. West Sussex, England: John Wiley & Sons Ltd., 1996. Coutaz, Jo\u00eblle. \u201cPAC, an Object-Oriented Model for Dialog Design.\u201d In: Bullinger, Hans-Jorg and Shackel, Brian (eds.) INTERACT 87 -\n2nd IFIP International Conference on Human-Computer Interaction, Stuttgart, Germany, September 1-4, 1987, 431-436.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 111", "position": 111, "chunk_type": "semantic", "token_estimate": 115}
{"text": "10 Distributed Architecture: e\n \nObjectives of this Chapter\n \n\u2022   Introduce the client-server and multi-tier architectures\n \n\u2022   Introduce the invocation and message broker architectures\n \n\u2022   Introduce the service-oriented architecture\n \n10.1 Overview\n \nA distributed system is a collection of computational and storage devices connected through a communications network. In this type of\nsystem, data, software, and users are distributed. The subsystems or components within a distributed system communicate with each\nother using a number of methods including message passing, remote procedure calls, and remote method invocation. Two important\nelements of designing a distributed system are: netw\nork topology, the way in which entities are organized to form a connected network;\nand communications mode, the method by which components communicate with each other. Many systems in the real world are naturally distributed. These systems are widely used in large enterprise environments such as a\ndatabase system that enables data to be accessed remotely, a B2B system with its distributed suppliers and clients, or an SAP\nsystem to manage distributed resources. Distributed systems are everywhere. A distributed system can be modeled by the client-server architecture, and this forms the basis for multi-tier architectures. Alternatives\nare the broker architecture such as CORBA, and the service-oriented architecture (SOA) such as web services and grid services. Key\nfeatures of a distributed architecture are its service location transparency and its services reliability and availability. Additionally, there\nare several technology frameworks to support distributed architectures, including .NET\n, J2EE, CORBA, .NET web services, AXIS Java\nweb services, and GloBus grid services. Next, we discuss the technical details of various distributed architecture styles including client-server, multi-tier, broker, and service-\noriented architecture. 10.2 Client-Server\n \nThe client-server model is the most commonly distributed system architecture. It is based on two communicating processes, usually\nrunning on different processors, and thus decomposes a system into two major subsystems: client and server. The first process, the\nclient, issues a request to the second process, the server. The server process receives the request (serving data from a database,\nprinting a document), carries it out, and sends a reply to the client. Figure 10.1\n \nTwo-tier client-server architecture\n \nFigure 10.1 displays a sample two-tier client-server architecture. The front-end tier focuses on the user interaction, and the back-end\ntier focuses on business logic and database management.", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 112", "position": 112, "chunk_type": "semantic", "token_estimate": 377}
{"text": "10 Distributed Architecture: Figure 10.1\n \nTwo-tier client-server architecture\n \nFigure 10.1 displays a sample two-tier client-server architecture. The front-end tier focuses on the user interaction, and the back-end\ntier focuses on business logic and database management. The separation of client from data server releases clients from data query and management (such as SQL development) so that it\nsupports the parallel developments for different tiers respectively. Advantages:\n \n\u2022   Separation of responsibilities such as user interface presentation and business logic processing", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 112", "position": 112, "chunk_type": "semantic", "token_estimate": 78}
{"text": "\u2022   Reusability of server components: Disadvantages:\n \n\u2022   Lack of heterogeneous infrastructure to deal with the requirement changes\n \n\u2022   Security complications\n \n\u2022   Server availability and reliability\n \n\u2022   Testability and scalability\n \n\u2022   Fat clients with presentation and business logic together\n \n \nFigure 10.2\n \nThree-tier architecture\n \n10.3 Multi-tiers\n \nThe front-end tier in a multi-tier architecture, such as a three-tier architecture, is still the user interface presentation tier. The middle tier\nmanages business logic and execution. The back-end tier usually handles database management. Multi-tier architecture is gaining\npopularity in today's enterprise applications. Figure 10.2 presents a sample three-tier architecture. The advantage of multi-tier over the two-tier architecture is the enhancement of reusability and scalability by adding the middle tier. Any\nbusiness related changes are made only to the middle tier. For example, the middle tier in a three-tier architecture can have portable\nand nonproprietary design and implementation. The middle tier can also provide multithreading supports for scalability. Multi-tier\narchitecture also reduces traffic on the network. Its main disadvantage is testability due to the general lack of testing tools. Adding\nmultiple servers in the system makes the server reliability and availability even more critical. 10.4 Broker Architecture Style\n \nThe broker architecture is a middleware architecture used in distributed computing to coordinate and facilitate communication between\nregistered servers and clients. Buschmann developed the broker architecture pattern to design a distributed system into components that interact by remote service\ninvocations:\n \nThe Broker architectural pattern can be used to structure distributed software systems with decoupled components that interact by\nremote service invocations. A broker component is responsible for coordinating communication, such as forwarding requests, as\nwell as for transmitting results and exceptions (Buschmann et al., 1996). A broker can be either an invocation-oriented service, to which clients send invocation requests for brokering, or a document or\nmessage-oriented broker to which clients send a message (such as an XML document). Better decoupling between clients and servers is one of the most important quality attributes for this architecture; client and server\ncomponents are decoupled through the use of a broker. In other words, communication never takes place directly between the client\nand the server. A broker system is also called proxy-based system. Servers make their services available to their clients by registering and publishing their interfaces with the broker. Clients can request\nthe services of servers from the broker statically or dynamically by lookup.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 113", "position": 113, "chunk_type": "semantic", "token_estimate": 393}
{"text": "\u2022   Reusability of server components: Servers make their services available to their clients by registering and publishing their interfaces with the broker. Clients can request\nthe services of servers from the broker statically or dynamically by lookup. A broker component is responsible for coordinating\ncommunications\u2014brokering the service requests, locating a proper server, forwarding and dispatching requests, and sending\nresponses or exceptions back to clients. A broker acts as a policeman in a busy intersection who controls and interacts with the client\ncomponents and server components. The connection between clients and servers is maintained by the broker. Common Object\nRequest Broker Architecture (CORBA) is a good implementation example of broker architecture. With the broker pattern, a distributed client can access distributed services simply by calling a remote method of a remote object just", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 113", "position": 113, "chunk_type": "semantic", "token_estimate": 132}
{"text": "as if it were a local method call. This concept is similar to Remote Procedure Call (RPC) in Unix distributed structured programming: and Remote Method Invocation (RMI) in Java distributed object-oriented programming. The distributed clients only need to obtain a\nreference to the appropriate object, instead of writing detailed code for protocol-oriented communication. In addition, the clients can\ndynamically invoke the remote methods even if the interfaces of the remote objects are not available at the compilation time. The client has a direct connection to its client-proxy and the server has direct connection to its server-proxy. The proxy talks to the\nmediator-broker. The proxy is a well-known pattern for hiding low-level detailed communication processing such as data marshaling\nand unmarshaling, I/O port processing, and supporting location transparency. A client proxy resides in the client address space and\nimplements the servant interface in this space. The client-proxy plays the role of mediator or interceptor, which intercepts the client's\nrequest, gets all arguments, packets it, marshals and formats the package in the format of communication protocol, and then sends it to\nthe broker. For the same reason, there is another proxy on the server-side to free the server from knowing the location of its client and\nthe details of the communication protocol. Let's decompose the broker architecture into subcomponents:\n \n\u2022   Broker: coordinates communications, passing on requests and returning replies. The broker stares all servers\u2019 registration\ninformation, including their functionality and services as well as location information. The broker provides APIs for clients to request,\nservers to respond, registering or unregistering server components, transferring messages, and locating servers. \u2022   Stub (client-side proxy): mediates between the client and the broker and provides additional transparency between them. T\no the\nclient, a remote object appears like a local one. The proxy hides the interprocess communication at protocol level, marshals\nparameter values, and unmarshals results from the server. The stub is generated at the static compilation time and deployed to the\nclient-side to be used as a proxy for the client. \u2022   Skeleton (server-side proxy): is also statically generated by the service interface compilation and then deployed to the server-side. It\nencapsulates low-level system-specific networking functions like the client-proxy and provides high-level APIs to mediate between\nthe server and the broker. It receives and unpacks the requests, unmarshals the method arguments, and calls the appropriate\nservice. When it receives the result back from the server it also marshals the result before sending it back to the client.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 114", "position": 114, "chunk_type": "semantic", "token_estimate": 411}
{"text": "as if it were a local method call. This concept is similar to Remote Procedure Call (RPC) in Unix distributed structured programming: It receives and unpacks the requests, unmarshals the method arguments, and calls the appropriate\nservice. When it receives the result back from the server it also marshals the result before sending it back to the client. \u2022   Bridges: are optional components used to hide implementation details when two brokers interoperate. Bridges encapsulate\nunderlying network detail implementation and mediate different brokers such as DCOM, .NET Remote, and Java CORBA brokers. They can translate requests and parameters from one format to another. A bridge can connect two different networks based on\ndifferent communication protocols. Figure 10.3\n \nBroker model\n \n\u2022   Netw\nork: connects components using designated protocol standards such as TCP/IP, OIIP, or SOAP. The request carries data in a\nmessage document or method invocation format. The diagram in Figure 10.3 shows the objects involved in the broker system. A broker gets requests from clients and manages the\nrequests by either forwarding them to service providers directly or dispatching the requests to another connected broker. Once it gets\nresults back from the broker, it sends the results back to the clients. Many brokers can work together in a complex system as shown in\nFigure 10.4. Figure 10.4\n \nConnected brokers with client-server proxy\n \nFigure 10.5 and Figure 10.6 show the class diagram and a sequence diagram of a broker architecture. We can see that the proxy\npattern plays an important role in the broker architecture. A proxy is like a surrogate or placeholder for a server component providing a", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 114", "position": 114, "chunk_type": "semantic", "token_estimate": 267}
{"text": "local interface to the real remote object.: Advantages:\n \n\u2022   Server component implementation and location transparency\n \n\u2022   Changeability and extensibility\n \n\u2022   Simplicity for clients to access server and server portability\n \n \nFigure 10.5\n \nClass diagram for broker architecture\n \n \nFigure 10.6\n \nSequence diagram for broker architecture\n \n\u2022   Interoperability via broker bridges\n \n\u2022   Reusability\n \n\u2022   Feasibility of runtime changes of server components (add or remove server components on the fly)\n \nDisadvantages:\n \n\u2022   Inefficiency due to the overhead of proxies", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 115", "position": 115, "chunk_type": "semantic", "token_estimate": 75}
{"text": "\u2022   Low fault-tolerance: \u2022   Difficulty in testing due to the amount of proxies\n \n10.4.1 Broker Implementation in the Common Object Request Broker Architecture (CORBA)\n \nIn this section we discuss the CORBA architecture, a typical broker architecture implementation. The diagram in Figure 10.7 shows an\noverview of the CORBA architecture. Static Remote Invocation in CORBA\n \nCORBA is an open standard for distributed, remote-method invocation computing schemes. It provides platform and language-\nindependent middleware to integrate distributed applications, including legacy code. The services and operations that a CORBA\nobject provides are specified in interfaces using the Interface Definition Language (IDL) so that clients can make requests without\nknowing the detailed implementation and location of the CORBA objects. The Object Request Broker (ORB) protocol provides a software bus on the network for brokering the requests from clients and the\nresponses from servers; the protocol also supports increased interoperability with other implementations. CORBA object IDL specifications are compiled into a stub and a skeleton by the IDL compiler. The stub is deployed on the client-side\nwhile the skeleton is deployed on the server-side. The IDL stub has the responsibility to serialize and marshal client requests. The stub\nthus functions as a proxy for the distributed object, and it can receive a local call from the client to this distributed CORBA object. It talks\nto its partner skeleton deployed on the server-side, which in turn unmarshals the requests, dispatches the requests to the correct object,\nand sends the results back to the stub on the client-side via ORB. Figure 10.7\n \nCORBA architecture\n \nDynamic Remote Invocation in CORBA\n \nCORBA also supports the Dynamic Invocation Interface (DII), which allows CORBA clients to use another CORBA object without\nknowing its interface information until runtime. Dynamic Skeleton Interface (DSI) is used by ORB to issue requests to objects that are\nimplemented independently and for which the ORB has no compile-time knowledge of their implementation. Although the dynamic\napproach of DII and DSI is more flexible, they are always slower than their static IDL counterpart. The dynamic remote invocation mode\nwas the only invocation mode available in the early version of CORBA. In some cases the IDL is not available at compilation time and\nthe stub and skeleton cannot be generated at compilation time.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 116", "position": 116, "chunk_type": "semantic", "token_estimate": 374}
{"text": "\u2022   Low fault-tolerance: The dynamic remote invocation mode\nwas the only invocation mode available in the early version of CORBA. In some cases the IDL is not available at compilation time and\nthe stub and skeleton cannot be generated at compilation time. For example, if a COM client wants to make a CORBA request or a\nDCOM object wants to provide its services on CORBA, a bridge interface is required to do the conversion. In the following we\nelaborate on some important notions of dynamic remote invocation in CORBA. CORBA Interface Repository (IFR)\n \nThis repository keeps all registered IDL interface information such as method names, arguments, and types, and IDL identifiers for\nclients and servers to use in dynamic method invocation. The IFR can be updated by the IDL utility. Dynamic Invocation Interface (DII)\n \nThis interface allows a client to dynamically discover the interface at runtime. DII provides all that is necessary for a client to generate a\nself-contained, self-described request that can directly access the ORB underlying the request mechanisms. When a server has an IDL but clients have no knowledge of it, DII can work with the IDL static skeleton and the IFR. If the server\nimplementation object by DII is registered with IFR, an IDL stub can be generated from the information on the IFR. In summary, DII helps clients invoke remote object methods without the support of a stub proxy, but the client must create its own\nrequest by DII API, which incidentally is less efficient than static invocation. Dynamic Skeleton Interface (DSI)\n \nDSI is a dynamic skeleton that allows an ORB to send requests to an object implementation for which the ORB does not have static\nknowledge of the interface-type specification. DSI has the responsibility of dispatching incoming method invocations on the sever-side.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 116", "position": 116, "chunk_type": "semantic", "token_estimate": 298}
{"text": "A DSI CORBA implementation can be dynamically registered in IFR for clients to look up. Using either client IDL skeletons or dynamic: skeletons makes no difference to a CORBA client. Of course, a DII can also pair with a DSI for a true dynamic method invocation if the server and the client don't know anything about the\nIDL specification at compilation time. The IFR is the facility for servers to post their registrations and for clients to look up the\nregistrations at runtime. In short, DSI allows the ORB to forward requests to server objects without the support of skeletons. 10.4.2 Message Broker Architecture\n \nA message is a packaged or formatted information such as an XML document sent and received between applications. A message\nbroker is a Message-Oriented Middleware (MOM) server in a message-oriented distributed system. It performs message routing,\nmessage transformation, message invocation, security checking, and exception handling. A message broker must be able to route messages from a sender to a receiver based on the content of the message. A broker can\ntransform a message from one format to another to meet the different requirements of the sender and the recipient. A broker may also\ntransform a message by modifying, inserting, merging, or removing some data elements in the message. Figure 10.8\n \nMessage broker\n \nIn addition to point-to-point messaging, a broker can also handle message distribution by publishing and subscribing. An application\ncan publish on topics, and many applications can subscribe them on the broker. A broker usually consists of three main parts: a front-listener subsystem that receives incoming messages based on the protocol used;\nthe core broker subsystem that makes decisions on the message and dispatches the jobs; and the back-end subsystem that will finally\nperform business logic based on the incoming message. There are commercial message broker systems such as WebSphere message broker, IBM MQSeries, Sun JMS, and others. Most\nmessage broker systems only provide asynchronous one-way communications, but some systems provide alternative communication\nsemantics, including synchronous or asynchronous, one-way or two-way, and blocking or nonblocking communications. A simple example of a message broker is email processing. When a business receives an email, the business application must\nanalyze the heading of the email message, transform the message to some suitable format, and route the transformed message to a\ntarget destination for processing by a local application or via another remote broker. A message usually falls into one of two categories: The Remote Procedure Call (RPC) category or the document category.", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 117", "position": 117, "chunk_type": "semantic", "token_estimate": 414}
{"text": "A DSI CORBA implementation can be dynamically registered in IFR for clients to look up. Using either client IDL skeletons or dynamic: When a business receives an email, the business application must\nanalyze the heading of the email message, transform the message to some suitable format, and route the transformed message to a\ntarget destination for processing by a local application or via another remote broker. A message usually falls into one of two categories: The Remote Procedure Call (RPC) category or the document category. In an RPC-\noriented mode, the client knows the remote procedure or remote method; hence the message that the client passes contains the\nparameters to the remote procedure or method. In a document message mode, the client may not know the remote procedure or\nmethod that handles the message. The client just sends the message in an agreed-upon format such as XML or SOAP to a message\nbroker and lets the message broker decide which procedure or method to invoke. Advantages:\n \n\u2022   Reusability and maintainability: Loose coupling between the client and server component leads to easy maintenance and extension\non both sides. \u2022   Flexibility: Invocation-oriented or document-oriented messaging; message heading and body can be altered for specific purposes. Disadvantages:\n \n\u2022   Overhead, indirection complexity, and difficulty in debugging and testing due to the new protocol stack added\n \n10.5 Service-Oriented Architecture (SOA)\n \nA Service-Oriented Architecture (SOA) starts with a businesses process. In this context, a service is a business functionality that is\nwell-defined, self-contained, independent from other services, and published and available to be used via a standard programming\ninterface. Software manages business processes through an SOA with well-defined, standard interfaces that can build, enhance, and\nexpand their existing infrastructure more flexibly. SOA services can be extensively reused within a given domain or product line, even", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 117", "position": 117, "chunk_type": "semantic", "token_estimate": 299}
{"text": "among legacy systems. Loose coupling of service orientation provides great flexibility for enterprises to make use of all available: service resourses regardless of platform and technology restrictions. The connections between services are conducted by common and universal message-oriented protocols, such as the SOAP web\nservice protocol, which can deliver requests and responses between services loosely. A connection can be established statically or\ndynamically. Figure 10.9 illustrates how SOA works. A client can find a service via a service directory and then accesses it in a service request-\nresponse mode. A typical service-oriented application makes use of many available services using some flow control language (e.g., BPEL for web\nservices). Such orchestration languages allow for specifying the sequence and logical order of the business executions based on the\nbusiness logic. Figure 10.10 presents a purchase business web service application that reuses some available web services such as\npurchase order, credit processing, inventory control, shipping and handling, and its own business logic processing. We can compose\nthis application programmatically by embedding all these available web services to reduce the cost and time of software development\nsignificantly. The internal implementations of those atomic web services (e.g., credit processing and inventory control) can be changed\nover time as long as they stick to their public interfaces. Another positive feature is the reusability of all the atomic web services. Some\nservices can be reused by other applications for which they were not originally designed. For example, the credit processing service\ncan be sold to some other companies (e.g., a wedding planner) if they want to support online payment. Figure 10.9\n \nClient with services and service directory\n \n \nFigure 10.10\n \nService composition\n \nA complex service-oriented application can constitute many services in such a way that some are responsible for receiving requests,\nothers for responding, and others that may not even be connected to external users at all (e.g., services #2 and #3 in the diagram in\nFigure 10.11). Figure 10.11\n \nService reuse\n \n \nFigure 10.12\n \nService composition model\n \nCoarse-grained services consist of multiple services working together coordinately. Via service aggregation and composition,", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 118", "position": 118, "chunk_type": "semantic", "token_estimate": 344}
{"text": "services can be recursively constructed to satisfy more complex business needs. A new service can be built out of existing services: using either the aggregation or containment structure afforded by OO concepts (as shown in Figure 10.12). An aggregation just\nextends one endpoint of a service to make a new interface of the new service. A containment has one interface that wraps all used\nservices. In this way, an SOA is a way to organize and widely share business functions. Advantages of SOA:\n \n\u2022   Loosely-coupled connections: Loose-coupling is the key attribute of service-oriented architecture. Each service component is\nindependent due to the stateless service feature. The implementation of a service will not affect its application as long as the\nexposed interface is not changed. This makes SOA software much easier to evolve and update. \u2022   Interoperability: T\nechnically, any client or service can access other services regardless of their platform, technology, vendors, or\nlanguage implementations. \u2022   Reusability: Any service can be reused by any other service. Because clients of a service need only to know its public interfaces,\nservice composition and integration become much easier. This makes SOA-based business application development much more\nefficient in terms of time and cost. \u2022   Scalability: Loosely-coupled services are easy to scale. The coarse-grained, document-oriented, and asynchronous service\nfeatures enhance the scalability attribute. 10.5.1 SOA Implementation in Web Services\n \nA web service (as shown in Figure 10.13) is a service that communicates with other services or clients via standard protocols and\ntechnologies such as SOAP, XML, and HTTP. A web service is a message-oriented service that can deliver document-oriented\nmessages as well as RPC messages. Because an XML-based message is semistructured, it makes a web service architecture\nuniversally accessible and flexible. The two key specification standards for web service architecture are the Simple Object Access Protocol (SOAP) and the Web\nServices Description Language (WSDL). SOAP (as shown in Figure 10.14) provides a common message exchange format between\nclients and services, and also between services. The envelope specifies an XML namespace and an encoding style. The XML\nnamespace specifies the names that can be used in the SOAP message. XML namespaces serve similar purposes as .NET\nnamespaces or Java packages\u2014they allow the avoidance of name clashes. Figure 10.13\n \nService working model\n \n \nFigure 10.14\n \nSOAP envelope\n \nThe SOAP header may include security, source and destination location, and other elements that can be used by an intermediate\nservice.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 119", "position": 119, "chunk_type": "semantic", "token_estimate": 401}
{"text": "services can be recursively constructed to satisfy more complex business needs. A new service can be built out of existing services: XML namespaces serve similar purposes as .NET\nnamespaces or Java packages\u2014they allow the avoidance of name clashes. Figure 10.13\n \nService working model\n \n \nFigure 10.14\n \nSOAP envelope\n \nThe SOAP header may include security, source and destination location, and other elements that can be used by an intermediate\nservice. The body contains the main part of the SOAP message; that is, the part intended for the final recipient of the SOAP message. A SOAP message is an XML-based document that is independent of any platform and thus can be transported by many protocols,\nsuch as HTTP or SMTP. The following is a SOAP message requesting the quote for a stock. The SOAP envelope <SOAP-ENV: Envelope> contains an\noptional <SOAP-ENV:Header> element and the required <SOAP-ENV: Body> elements. Clearly, the SOAP message specifies a\nquote that asks for the price of \u201cMy Life and Times.\u201d\n \n<SOAP-ENV: Envelope xmlns:SOAP-ENV=\n    \u201chttp://schemas.xmlsoap.org/soap/envelope/\u201d \n    SOAP-ENV:encodingStyle=\n    \u201chttp://schemas.xmlsoap.org/soap/encoding/\u201d>\n    <SOAP-ENV:Header>\n          <from>a_client</from>\n                <to>a_target</to>\n      </SOAP-ENV:Header>\n    <SOAP-ENV:Body>\n          <m:GetQuote xmlns:m=\u201cmyURI\u201d>\n             <name>My Life and Times</name>", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 119", "position": 119, "chunk_type": "semantic", "token_estimate": 179}
{"text": "</m: GetQuote>: GetQuote>\n    </SOAP-ENV:Body>\n</SOAP-Envelope>\nWeb Service Description Language (WSDL)\n \nA WSDL document is an interface document that describes the interface of a web service. T\no access a web service, a client has to\nknow the endpoint of a web service directly or indirectly via a web service registry repository where the Web service has registered. The interface information in the WSDL document helps build programmatic calls to the web service. A WSDL document describes a web service as a set of \u201cports,\u201d or \u201cend-points,\u201d and the actions\u2019 signatures performed by the web\nservice. Actions are represented by \u201coperations,\u201d while argument data is represented by \u201cmessages.\u201d A collection of related operations\nis known as a \u201cport type.\u201d A binding specifies the network protocol and the message format specifications for a particular port type. A\nbinding binds a port with an IP address. A web service client first locates a WSDL document, finds the binding and network address for\neach port, and then calls the operations of this web service. Here is a WSDL document for an online stock price search web service, where getStock is an operation of this web service declared\nin WSDL. <operation name=\u201cgetStock\u201d \u2026\nThe input message is a symbol and the output message is the price for this operation. <complexType>\n    <all>\n       <element name=\u201csymbol\u201d type=\u201cstring\u201d/>\n       <element name=\u201cprice\u201d type=\u201cstring\u201d/>\n    </all>\nThe binding tag specifies the document style in the SOAP request. <soap:binding transport=\n  \u201ctransport=http://schemas.xmlsoap.org/soap/http\u201d \n. . . The Business Process Execution Language (BPEL) is an XML-based description language for organizing existing web services to\nwork together. BPEL describes the web services that participate in a process, the workflow of these web services, and interactions\nbetween them. For example, the following BPEL entry describes one of the services in the purchase order process: It receives a\npurchase order by an operation called purchaseOrder with a purchaseOrder port type which specifies its input and output\nmessages from a participating web service partner link purchase. After the purchase order is received, the BPEL spawns the flow\ncontrol into two concurrent flows: makeInvoice and scheduleShipping. <sequence>\n      <receive partnerLink=\u201cpurchase\u201d\n         portType=\u201clns:purchaseOrderPT\u201d\n         operation=\u201cPurchaseOrder\u201d\n         variable=\u201cPO\u201d>\n      </receive>\n      <flow>\n           <invoke partnerLink=\u201cinvoicelnk\u201d\n               portType=\u201clns:invoicePT\u201d\n               operation=\u201cmakeInvoice\u201d\n         />\n           <invoke partnerLink=\u201cshippinglnk\u201d\n               portType=\u201clns:shipping\u201d\n               operation=\"scheduleShipping\"\n          />\n    </flow>\n</sequence>\nFigure 10.15 presents another simple purchase order as an example using BPEL composition. There are three vertical parallel flows in\nthe middle box, indicating that all three flows are executed in parallel.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 120", "position": 120, "chunk_type": "semantic", "token_estimate": 396}
{"text": "</m: GetQuote>: <sequence>\n      <receive partnerLink=\u201cpurchase\u201d\n         portType=\u201clns:purchaseOrderPT\u201d\n         operation=\u201cPurchaseOrder\u201d\n         variable=\u201cPO\u201d>\n      </receive>\n      <flow>\n           <invoke partnerLink=\u201cinvoicelnk\u201d\n               portType=\u201clns:invoicePT\u201d\n               operation=\u201cmakeInvoice\u201d\n         />\n           <invoke partnerLink=\u201cshippinglnk\u201d\n               portType=\u201clns:shipping\u201d\n               operation=\"scheduleShipping\"\n          />\n    </flow>\n</sequence>\nFigure 10.15 presents another simple purchase order as an example using BPEL composition. There are three vertical parallel flows in\nthe middle box, indicating that all three flows are executed in parallel. The solid arrow line indicates the sequential execution of the\nconnected web service from top to bottom. The arrow line between the flows indicates the constraints by other flows in the concurrent\nexecution. For example, the total charge cannot be determined until the shipping and handling fee is determined. The diagram offers a\nclear picture of how BPEL uses web services to compose a business process application. Figure 10.16 presents as another example an online travel agency system. It consists of four existing web services: airline reservation,\ncar rental, hotel reservation, and attraction reservation. With built-in business rules and business strategy such as decision making and\nbudget and schedule constraints, the system should be able to make optimal decisions enabling clients to choose from a combination\nof airlines and hotels. BPEL can also be used to construct workflows among these web services. This system itself can provide a new\nweb service for clients to use.", "domains": ["Design Patterns", "Design Principles"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 120", "position": 120, "chunk_type": "semantic", "token_estimate": 209}
{"text": "Figure 10.15\n \nWeb service compositions by BPEL\n \n \nFigure 10.16\n \nWeb service business process model\n \n10.5.2 SOA Implementation for Grid Service Computing\n \nGrid service computing is another implementation of SOA. Grid service computing makes use of all disparate resources spread over\ndifferent locations via networks. It can provide both program services, such as web services and hardware services. Each grid can\neither be a computing grid supporting computational resources or a data grid supporting data integration, or both. Figure 10.17 shows\na grid service architecture that manages all resources such as CPU, database, applications, storage, and network, by collective and\nvisualizable management. A grid service scheduler coordinates the scheduling of all resource sharing. When a client submits a job request, the service directory locates the service and lets the Grid service scheduler select the job that\ndepends on the service availability. After the job is completed, the user will then be notified by the system. Figure 10.17\n \nG\nrid service architecture\n \n10.6 Summary", "domains": ["Software Quality Attributes"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 121", "position": 121, "chunk_type": "semantic", "token_estimate": 162}
{"text": "This chapter discussed the software architectures for distributed computing systems, those systems where data, users, and processing: elements are all distributed over remote sites connected by networks. Multi-tier architecture distributes and separates data and processing duties over different tiers so that each tier has its own\nresponsibilities. It reduces message traffic on the network and increases system reliability. The client-server architecture is widely used in current enterprise business and industry. Web server, data server, and application\nserver are all examples of server tiers. A broker, in the broker architecture, has the responsibility of brokering messages between remote components or other brokers so that\na complex enterprise system may involve into multiple brokers, clients, and servers. The CORBA, a primordial broker architecture implementation, is also a component-oriented architecture. Service-oriented architectures are widely used in B2B enterprise business applications. Each service is a building-block component,\nsuch as web or grid service, which can be reused by other service components or other business process applications. 10.7 Self-Review Questions\n \n1. Which of the following is not one of the benefits of distributed architecture? a. Supports multiple independent agents\n    b. Scalability\n    c. Supports multiple views\n    d. Loose-coupling of modules\n2. Which of the following is not a typical style of distributed architecture? a. Client-server\n    b. Hierarchical structure\n    c. Broker\n    d. SOA\n3. Client-server architecture in general is more scalable than the multi-tier model. a. True\n    b. False\n4. CORBA is an example of the broker architecture. a. True\n    b. False\n5. Web service is an example of SOA architecture. a. True\n    b. False\nAnswers to the Self-Review Questions\n \n1. c 2. b 3. b 4. a 5. a\n \n10.8 Exercises\n \n1. What is client-server architecture? 2. What is multi-tier architecture? 3. What are the benefits of broker architecture? 4. What are the benefits of SOA architecture? 5. Define the stack of standards for supporting web services. 10.9 Design Exercises\n \n1. Design a three-tier, web-based, online bookstore application. The client front-end tier is a web browser that coordinates user\naccount login and GUI interface. The middle tier is the application server that coordinates business logic such as shopping cart,\ntransaction, checkout processing, and others. The back-end tier is a database server. The database stores all necessary\ninformation such as book catalog, customer, and order status information. 2. Design a travel agency application software using SOA. The application helps customers make travel plans including air, hotel,\ncar rental, attraction visits, and time schedules.", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 122", "position": 122, "chunk_type": "semantic", "token_estimate": 406}
{"text": "This chapter discussed the software architectures for distributed computing systems, those systems where data, users, and processing: Design a travel agency application software using SOA. The application helps customers make travel plans including air, hotel,\ncar rental, attraction visits, and time schedules. This application makes use of existing web services of airlines, car rentals,\nhotels, and attractions. 3. Design a stock exchange application using the broker architecture. Assume that the existing stockbroker legacy systems vary in\nplatform, language, and technology. For example, some systems are implemented in Java and the others reimplemented in .NET. 10.10 Challenge Exercise\n \nAn enterprise company information system has heterogeneous infrastructure where many different software applications and\ndatabases are supported by many different operating systems. The headquarters include accounting, finance, and human resource\noffices and is located in New Y\nork. The Research and Development department is in Chicago. The sales departments are located all\nover the world. There are many distribution centers near the sales department. Find a solution to integrate the system software so that it\nwill be easy to maintain and expand in the future. Which is better, broker architecture or service-oriented architecture? Explain the", "domains": ["Architectural Patterns and Styles"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 122", "position": 122, "chunk_type": "semantic", "token_estimate": 192}
{"text": "advantages and disadvantages of each solution.: References\n \nBuschmann, Frank, Regine Meunier, Hans Rohnert, Peter Sommerlad, and Michael Stal. Pattern-Oriented Softw\nare Architecture: A\nSystem of Patterns .Vol. 1, West Sussex, England: John Wiley & Sons Ltd., 1996, 305-344. Suggested Reading\n \nArmstrong, Eric, Jennifer Ball, Stephanie Bodoff, et al. \u201cThe JMS API Programming Model.\u201d .December 5, 2005. Sun Microsystems,\nhttp://java.sun.com/j2ee/1.4/docs/tutorial/doc/JMS4.html. Orfali, Robert and Dan Harkey. Client/Server Programming w\nith JAVA and CORBA. 2nd ed New York: John Wiley & Sons, 1998. Ort, Ed. \u201dService-Oriented Architecture and Web Services: Concepts, Technologies, and Tools.\u201d  April 2005. Sun Microsystems,\nhttp://java.sun.com/developer/technicalArticles/WebServices/soa2/WSProtocols.html.", "domains": ["Architectural Patterns and Styles"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 123", "position": 123, "chunk_type": "semantic", "token_estimate": 96}
{"text": "11 Component-Based Software Architecture: e\n \nObjectives of this Chapter\n \n\u2022   Introduce concepts of the software components\n \n\u2022   Discuss UML notations for component-based architectures\n \n\u2022   Introduce principles of component-based design\n \n\u2022   Introduce quality attributes of component-based design\n \n11.1 Overview\n \nComponent-based software architecture divides a problem into subproblems each associated with component partitions. The\ninterfaces of the components play important roles in the component-based design. The main motivation behind component-based\ndesign is component reusability: a component encapsulates the functionality and behaviors of a software element into a reusable and\nself-deployable binary unit. Designs can make use of existing reusable commercial off-the-shelf (COTS) components or ones\ndeveloped in-house, and they may produce reusable components for future reuse. This increases overall system reliability since the\nreliability of each individual component enhances the reliability of the whole system via reuse. There are many standard component frameworks such as COM/DCOM, JavaBean, EJB, CORBA, .NET\n, web services, and grid\nservices. These target component technologies are widely adopted in local desktop GUI application designs such as graphic\nJavaBean components, MS ActiveX components, and COM components which can be reused by drag and drop. Many components\nare invisible, especially those distributed in enterprise business applications and Internet web applications such as Enterprise\nJavaBean (EJB), and .NET\n, and CORBA components. The combination of service-oriented and component technologies is getting\nmore attention today; these include web and grid services. A component is a deployable software package that can provide services to its clients; it may also itself require services from other\ncomponents. A component remains self-contained and substitutable as long as its interface is unchanged. A component-oriented design represents a higher level of abstraction than an equivalent object-oriented design; the former defines\ncomponents and connections between them instead of classes and connections between classes. A component is a higher-level\nconcept, usually incorporating more than one class. Thus, in component-oriented design we first identify all components and their\ninterfaces instead of identifying classes and their relationships. Component-oriented software architecture and design have many advantages over their traditional object-oriented counterparts. These\ninclude: reduced time in market, lower development costs by reuse of existing components, and increased reliability with reuse of\nexisting components. The challenge is to design components in such a way as to make it possible to adapt existing components in order to reuse them. Product line architecture design helps with this as discussed in Chapter 14. 11.2 What Is a Component?", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 124", "position": 124, "chunk_type": "semantic", "token_estimate": 402}
{"text": "11 Component-Based Software Architecture: Product line architecture design helps with this as discussed in Chapter 14. 11.2 What Is a Component? A component is a modular (cohesive), deployable (portable), replaceable (plug-and-play), and reusable set of well-defined\nfunctionalities that encapsulates its implementation and exports it as a higher-level interface. Szyperski defines a software component\nas a unit of composition with a contractually specified interface and explicit context dependencies only (Szyperski, 2002). That is, a\nsoftware component can be deployed independently and is subject to composition by third parties. In the generic model in Figure 11.1\na component is represented by a box the inside of which is its implementation. The dark boxes on the boundary represent the exported\ninterface elements, and the \u201cplugs\u201d sticking out represent required explicit context (usually plugged into another component's interface). The diagram on the right shows how a (larger) component is implemented by interconnecting other components. This larger component\ncan in turn be connected to another component. In this way, a \u201csystem\u201d built out of a \u201cnetwork of components\u201d is itself a component. A component represented in UML 2.0 notation is shown in Figure 11.2.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 124", "position": 124, "chunk_type": "semantic", "token_estimate": 189}
{"text": "Figure 11.1\n \nG\neneral concept of a component and nested composition\n \n \nFigure 11.2\n \nUML component notation\n \nThe circle interface symbol, called provided port, represents the services the component provides; the cup-like interface symbol, called\nrequired port, represents the services the component requires from other components. The ports may be connected synchronously or\nasynchronously, or connected via I/O streams. A UML component can be mapped to any target technology component. An EJB component is packaged in a .JAR archive file. A Java\nweb component is packaged in a WAR archive file. A remote distributed component is accessed by the \u201clookup\u201d command for the\ncomponent's deployment name. A .NET component is deployed as a .DLL dynamic linked library file that is accessed by the \u201cUsing\u201d\ndirective in .NET client code. A JavaBean component is deployed as a JAR file and is accessed by \u201cimport <package>. *\u201d\ndirective in Java client code. Why use components? Reusability, productivity, composability, adaptability, scalability, reliability, and many other features make\ncomponent-oriented design and development very useful especially in enterprise frameworks. Because a component is developed for reusability it must have a clear functionality and be self-contained. Components must be\ndesigned and developed for easy reuse. Components should, therefore, be very reliable. Since detailed coding is significantly reduced by the adoption of a component architecture, the approach increases productivity in the\nsoftware development process. Instead of development by programming, it will be possible to construct a new component or new\nsoftware by component composition with development kits. It should be easy to replace or adapt any existing components. It should also be possible to scale the service capacity by replacing\ncomponents to increase functionality in the system. The diagram in Figure 11.3 shows a simple component composition where the client component requires (gets) services from a server\ncomponent via the server's provided port. Figure 11.3\n \nComponent composition\n \nA component may contain a set of collaborating classes grouped together in packages. A component-oriented architecture\nemphasizes building systems out of existing components chosen from a reusable library. First, let's look at a simple Java component\nexample. It is specified in a package named counter. Packages can be deployed as single units. Here is a Java Counter interface with its abstract methods. package counter;\ninterface Counter {\n    public void setCount(int c); \n       public int getCount(); \n       public void inc();\n}\nClass CounterImpl1 is a possible implementation of interface Counter:\n \nimport counter.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 125", "position": 125, "chunk_type": "semantic", "token_estimate": 398}
{"text": "Here is a Java Counter interface with its abstract methods. package counter;\ninterface Counter {\n    public void setCount(int c); \n       public int getCount(); \n       public void inc();\n}\nClass CounterImpl1 is a possible implementation of interface Counter:\n \nimport counter. *;\nclass CouterImpl1 implements Counter { \n    private int count;\n    public void setCount(int c){ count = c;}\n    public int getCount(){ return count;}\n    public void inc() { count ++; }\n   }\nThe interface exposes all the operations of the component while the class implements this interface. A client can use this component as\nfollows:\n \n CounterImpl1 myCounter = new CounterImpl1(); \n myCounter.inc();\nThe first line can be replaced by using another implementation component ConterImpl2 without any change to the rest of code if", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 125", "position": 125, "chunk_type": "semantic", "token_estimate": 116}
{"text": "both CounterImpl1 and ConterImpl2 implement the same interface Counter.: CounterImpl2 myCounter = new CounterImpl2();\nThe interface separates the implementation of a component from its clients. We can easily convert a Counter implementation class to\na JavaBean by following the JavaBean convention, compile the source code for JavaBean, and generate file\nCounterImp1.class. We know a Java Bean is a deployed component of a java class just like the MS DLL components. It is\nnecessary to create a manifest file to specify this Java class as a bean. The manifest file becomes part of the Java component JAR\nfile. At this time we can use any bean development tools such as Bean Builder or NetBean Visual Studio to load this bean into the tool\nlibrary and reuse it. The deployed component also can be placed in any directory as long as it is on the classpath. The following\nscreen-shot shows the composition of a button component and a counter component, whereby counter is able to display the\ncounts that the button has been pressed. This is a simple form of composition of two components. This composition can be\nimplemented by many Java IDE tools listed above. We can also build the Counter component using CORBA technology, deploy it on any CORBA compatible server, and access it by\nremote clients. A CORBA component can work together with other components. Here is a CORBA interface definition of the Counter\ncomponent:\n \nmodule Counter {\n    interface Count {\n        attribute long count; \n        long inc();\n    }\n}\nThis IDL interface definition can be mapped into a Java package and interface, and implemented by Java classes or mapped to other\nlanguage implementations so that clients can use this component. package counter;\npublic interface CountOperations { \n    int count();\n    void count(int newCount); \n    int inc();\n}\nIn addition to the above file, idlj produces more files such as Count.java, a subclass of this interface, implementing all the\noperations in the interface. In this section we introduced component concepts illustrating their implementation using several target technologies. During\ncomponent-oriented design we focus on abstract component specification, which can then be mapped into any target component for\nimplementation. 11.3 Principles of Component-Based Design\n \n11.3.1 Connections of Components\n \nThe software system is decomposed into reusable, cohesive, and encapsulated component units. Each component has its own\ninterface that specifies the required ports and provided ports; each component hides its detailed implementation.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 126", "position": 126, "chunk_type": "semantic", "token_estimate": 394}
{"text": "both CounterImpl1 and ConterImpl2 implement the same interface Counter.: 11.3 Principles of Component-Based Design\n \n11.3.1 Connections of Components\n \nThe software system is decomposed into reusable, cohesive, and encapsulated component units. Each component has its own\ninterface that specifies the required ports and provided ports; each component hides its detailed implementation. In other words, each\ncomponent can be seen as a black box building block grouping functionalities and data cohesively as a module (package). Connectors connect components, specifying and ruling their interaction. Component interaction can take the form of method\ninvocations, asynchronous invocations such as event listener and registrations, broadcasting, message-driven interactions, data\nstream communications, and other protocol specific interactions. The interaction type is specified by the interfaces of the components. Figure 11.4 shows a component-based software architecture. The manager component gets service support from a single component\n(requests) and a combined service component subsystem (Service 1 and Service n), and the latter gets data access service from a\ndatabase. The whole software system is a set of components connected by their interfaces. Each component may be replaced or\nupdated without any changes of the other part of the system.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 126", "position": 126, "chunk_type": "semantic", "token_estimate": 189}
{"text": "Figure 11.4\n \nUML component-based architecture\n \nThere are three categories of connections:\n \n\u2022   Ball and cup (b2c or c2b) connection: connects two internal or two external components\n \n\u2022   Ball to ball (b2b) or cup to cup (c2c) delegation: connects an external ball (cup) port to an internal ball (cup) port\n \n\u2022   I/O stream connection\n \nAll above connections can be direct method invocation, implicit (indirect) event-based invocation, or message-based notification. The\nstream connection is often used for network connection, file read, and file write operations. The component-oriented software architecture is an architecture style that can be applied to both system and partial system design. Component-based software design is design by contract. The contract specifies the interface between the component and its clients. T\no support reusability, one of the most important features of components, we can substitute any component in the system if the new\ncomponent provides no less than what the old component provides and requires no more than what the old component required. During the design we consider not only reuse or adaptation of existing components but also the construction of new reusable\ncomponents. Components are building blocks just like classes are in the object-oriented paradigm. Class diagrams are the blueprints in object-\noriented design; other diagrams refer to, and exist within, the context of this overall class structure. In a component-based design approach, it is necessary to first identify all components (instead of locating classes first). In most cases,\nseveral iterations are required to identify all components. We need to refine the component-based design step-by-step to meet all the\nrequirements, make maximum use of available components, and make all new components necessary for future reuse. Once all\ncomponents are identified and their interfaces designed, we can move ahead to design the classes that conform each component. We can see that component-based software design starts from a more abstract level than does OO design. 11.3.2 Component-Level Design Guidelines\n \nUse case modeling and business concept modeling of the project are available before the design phase. Use case diagrams describe\nuser interactions with the system which indicate all necessary operations (interfaces) of the component. We can map use case\ndiagrams to the provided service interfaces of the first-cut component specification. The business concept diagram depicts the relationships of the business process entities in the domain.", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 127", "position": 127, "chunk_type": "semantic", "token_estimate": 383}
{"text": "We can map use case\ndiagrams to the provided service interfaces of the first-cut component specification. The business concept diagram depicts the relationships of the business process entities in the domain. We can extract the business\nprocess entities that can exist independently without any associated dependency on other entities. We can recognize and discover\nthese independent entities as new components. The current component needs the provided services from these new discovered\ncomponents. In this way, we can also map the business concept diagrams to the required service interfaces of the first-cut component\nspecification. A collaboration is any identifiable slice of functionality that describes a meaningful service involving, in general, several concepts. A\ncollaboration can be seen as the implementation of a use case. Thus, for each use case U, there will be a collaboration diagram\n\u201cencapsulated\u201d in a component C (one or more sequence diagrams will be drawn to exercise the use case through scenarios). Figure\n11.5 illustrates the component implementation of use case U (that happens to lay in between two other use cases). Figure 11 5", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 127", "position": 127, "chunk_type": "semantic", "token_estimate": 178}
{"text": "Figure 11.5\n \nUse case component implementation\n \nAt the first design step, we derive a first-cut component design that defines the number of components. We know what services each\ncomponent can provide at this stage. In the next step we need to find out what services each component requires in order to provide its\nown services. Some required services may be available but some others may not. We need to refine the design, which may result in\nnew component specifications and additional interface ports for existing components. Following these two steps we get a new component specification with its provided service interface (from step 1) and its required\nservice interfaces (from step 2). We also get other new components, which will need to be refined. We need to repeat these steps until\nno more new components are left. UML is a good design tool for component-based software design. T\no present the event-driven behavior time sequences, not only\ncomponent and class diagrams, but also dynamic diagrams such as sequence collaboration diagrams are needed. One class may be\nused in many components, and one component may need many collaborating classes. One component may be reused many times in\nthe software system, and one software system needs many components to work together. We don't need to address any specific target component technology in the design phase since the component software architecture\ncan be mapped to a target technology later during the implementation phase. Let us now look at a problem domain to see how to apply component-based software architecture in its design. The software is used to\nmanage clinic appointments. The requirement is described as follows. A clinic has a dozen family doctors. Each doctor has a daily schedule with 15-minute time slots. A patient can make an appointment\nwith any doctor. Patients may change or cancel their appointments. New patients are welcome. All appointments include patient name,\ndoctor name, data, time slot, reason, and insurance policy. Patients must pay any copayment for the office visit at the sign-in time and\nthe accounting office will bill the rest of the charges. Assume that we know the system requirements from the analysis process. The system requirements come with text documents, UML\ndiagrams such as a use case diagram, and a business concept diagram. The analysis class diagram may also be available.", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 128", "position": 128, "chunk_type": "semantic", "token_estimate": 387}
{"text": "The system requirements come with text documents, UML\ndiagrams such as a use case diagram, and a business concept diagram. The analysis class diagram may also be available. The use\ncase diagram shown in Figure 11.6 provides a partial description of the scenario. The reader can refine it further. The business process concept diagram shown in Figure 11.7 describes the possible situations. Each doctor has many daily\nschedules; any doctor can mark off any unavailable slots on the daily schedule so that patients can select available slots from the\nschedule when making an appointment. A doctor's daily schedule consists of many appointments with different individuals. Each\nappointment must connect with the billing system. One patient may have at most one daily appointment. This diagram shows the\ndomain entities and business concepts. Figure 11.6\n \nUse case for clinic appointment system\n \n \nFigure 11.7\n \nBusiness concept diagram\n \nThe component-based design produces a draft solution for software development based on the requirement analysis. It involves top-\ndown refinement iterations. For example, the first-cut component architecture shows all top-level components; then each subsequent\nrefinement iteration will break down a large and complex component into a number of subcomponents until all component elements\nmatch some reusable components or are suitable to be created anew.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 128", "position": 128, "chunk_type": "semantic", "token_estimate": 208}
{"text": "Assume there is no class diagram available. We refine the business concept diagram with the following process.: First, identify the independent entities, those that can exist alone without any dependency on other entities (Cheesman and Daniels,\n2001). Doctor and patient are such entities. A schedule belongs to a doctor and is derived from appointments; daily appointments are\ngenerated from patient-doctor schedules. The UML notation for interface type or core type is \u201c<< >>\u201d. The <<core>> type can exist\nindependently, and each core type has a management interface to the core type. The other types are derived types that cannot exist\nindependently. We focus on the core types and complete the interface management types first. Figure 11.8\n \nIdentification of components\n \n \nFigure 11.9\n \nFirst cut of component-based software architecture\n \nFigure 11.9 depicts the first-cut of a component-based software architecture for this business process problem domain. There are two\nlevels of components: clinic appointments at the top, and billing, patient, and doctor management components on the next level. Each core type entity is transformed to a component element that provides services to the root controlling component. Each use case\nis transformed into an interface provider for users to interact with. Billing may be another system, which can then be designed in the\nsame manner: break it down into many subcomponents and establish corresponding interfaces. The patient component and the doctor\ncomponent are used to manage persistent data. The clinic appointment system component itself has a lot of business logic to manage. If it is too complicated, we can refine it following the same guidelines as a separate subsystem. We can conduct the top-down component-based design as shown in Figure 11.10. We can also do the architecture design from the\nbottom up if the class diagram is available. We can group related classes into a component and work out the interface of this\ncomponent. Sometimes a component-based software design needs a glue component to integrate multiple ones into a single\ncomponent so that they can work together. Figure 11.10\n \ncycle\n \nApplicable domains of component-based architecture:\n \n\u2022   Applications where the interface contracts between subsystems are clear\n \n\u2022   Applications that require loose coupling between the components and where many reusable components are available\n \n\u2022   Suitable for the class library system organization (.NET class library and Java API are built in component architecture)\n \nBenefits:", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 129", "position": 129, "chunk_type": "semantic", "token_estimate": 387}
{"text": "\u2022   Reusability of components.: \u2022   System maintenance and evolution; easy to change and update the implementation without affecting the rest of the system. \u2022   Independency and flexible connectivity of components. \u2022   Independent development of components by different groups in parallel. \u2022   Productivity for the current and future software development. \u2022   Many OO design tools can also be used for component-based software development. Limitations:\n \n\u2022   It can be difficult to find suitable available components to reuse. \u2022   Adaptation of components is an issue. \u2022   Few component-oriented dedicated design tools are available. Related architecture:\n \n\u2022   OO architecture, distributed architecture, SOA\n \n11.4 Summary\n \nComponent-based software architecture is an extension of object-oriented architecture. Its basic unit is a component in component-\norientation instead of classes in object-orientation. Component is a higher level of abstract concept than class. A component may consist of many related classes stored and deployed in\nthe same binary assembly. The interface of a component plays the role of contract between its implementation and its clients; hence the\napproach is also called a contract-oriented software architecture. The first step in component-based software design is to identify first-\ncut components and specify all necessary connections among these components. The connections are conducted via the interfaces of\ncomponents. UML component diagrams are useful to specify the topology configuration of connected components. Dynamic UML diagrams are also\nneeded to describe the dynamic behaviors of the assembly of connected components. An abstract component-based software architecture is ultimately mapped to a target technology component architecture that will be\nimplemented by that technology. Component-based software design has many advantages over object-oriented design in the quality attributes of reusability,\nproductivity, reliability, scalability, portability, and others. The challenges for adopting a component-based architecture include the\nadaptation between components, the determination of component unit, and finding suitable existing components. 11.5 Self-Review Questions\n \n1. Which of the following is not a benefit of component architecture? a. Concurrency\n    b. Interactivity\n    c. Incrementalism\n    d. Productivity\n2. Which of the following is not a benefit of component architecture? a. Performance\n    b. Interactivity\n    c. Evolution-Adaptability\n    d. Reusability\n3. CCM is a target technology for component technology. a. True\n    b. False\n4. Each component may have its provided ports and required ports from other components. a. True\n    b. False\n5. Each component must have its provided ports and required ports. a. True\n    b. False\n6. The provided interface ports may be in synchronous or asynchronous modes. a. True\n    b. False", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 130", "position": 130, "chunk_type": "semantic", "token_estimate": 404}
{"text": "7. A component architecture can be derived from use case analysis and business concept diagrams.: a. True\n    b. False\n8. Core type classes can be recognized as a new component. a. True\n    b. False\n9. A core type component does not depend on any other classes. a. True\n    b. False\n10. The interaction operations in the use case diagrams should be included as part of provided interfaces of components. a. True\n    b. False\nAnswers to Self-Review Questions\n \n1.a,b 2. a, b 3. a 4. a 5.b 6. a 7. a 8. a 9. a 10. a\n \n11.6 Exercises\n \n1. What is a software component? 2. Why are components needed? 3. What is component-oriented architecture and design? 4. What is component reusability? 5. What is component deployment? 6. List at least three target component technologies that you know. 7. Is Java API component-oriented? 8. Is .NET class library component-oriented? 9. Is a .jar or .DLL file a component? 11.7 Design Exercises\n \n1. Design a component software architecture for an ordering system involving customer, order, order line, item (product), and billing. 2. Design a student registration system with component-oriented methods where a student can register courses with session\nnumber in certain terms with a certain instructor. A student can modify or cancel a registration. 3. Design a hotel reservation system with component-oriented methods where a customer can reserve hotel rooms in a specific\nhotel within the hotel chain headquarters. Customers may change or confirm their reservation. 11.8 Challenge Exercises\n \n1. Continue the design of the online payment system and the motel reservation system at the end of Chapter 3. After identifying the\nsubsystems in the problem domain, identify the components for the subsystems and specify the connection between the\ncomponents. Recall that components and layered architecture are often used together to design a large-scale software. 2. Use the same design strategy and software architecture to design an online textbook exchange store. References\n \nCheesman, John and John Daniels. UML Components: A Simple Process for Specifying Component-Based Softw\nare. Addison-\nWesley Professional, 2001, 83-119. Szyperski, Clemens. Component Softw\nare: Beyond Object-Oriented Programming. 2nd ed. Component Software Series. Addison-\nWesley, 2002, 49-56. Suggested Reading\n \nWang, Andy Ju An and Kai Qian. Component-Oriented Programming. Hoboken, NJ: John Wiley & Sons, 2005.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 131", "position": 131, "chunk_type": "semantic", "token_estimate": 375}
{"text": "12 Hetero: o\ng\neneous Architecture\n \nObjectives of this Chapter\n \n\u2022   Introduce a general methodology of making architecture decisions\n \n\u2022   Summarize the benefits and limitations of each architecture style\n \n\u2022   Demonstrate how to apply the general principles in case study examples\n \n12.1 Overview\n \nIn practice, multiple architecture styles often have to be used in the same project. Imagine yourself as the architect of a medieval castle. It is unlikely that the same architecture style can be used for all parts of a castle (e.g., moat, tower, drawbridge, curtain wall, castle hall,\nresidential buildings for civilians). Similarly, for a large-scale software project, heterogeneous architecture styles are used to combine\nbenefits of multiple styles and to ensure quality and appropriateness. This chapter provides a case study on the heterogeneous architecture. It examines the analysis and design of a relatively large-scale\nproject (an online computer vendor and manufacturer) using the time-tested \u201cdivide and conquer\u201d approach. The case study will help\nyou to review knowledge obtained in previous chapters and to practice the general principles in a more realistic design. 12.2 Methodology of Architecture Decision\n \nA successful army commander has to take all factors into account before sending soldiers out. Similarly, the responsibility of a good\nsoftware architect is not to work out one feasible solution, but to determine which architecture best suits the business needs. A number\nof architecture styles have been covered, including the data flow architectures (batch sequential, pipe filter, process control), data\ncentric architectures (repository, blackboard), hierarchical, implicit asynchronous communication, interaction-oriented, distributed, and\ncomponent-based architectures. Given the large number of alternative architecture styles available, how do you choose the right one that will achieve the project goals\noptimally (e.g., with the minimal cost)? This section guides you through a brief introduction of the general methodology of determining\nsoftware architecture under given system constraints. The process of selecting the architecture of a software system is closely related to requirements analysis. The requirements of a\nsystem, the priority of each requirement, and the system constraints (project budget, release date, etc.) all determine the architecture to\nbe used, even if it might not be the most elegant, the fastest, or the most economical. The chosen architecture must be \u201coptimal\u201d and\nnot necessarily focus on one particular aspect of the system constraints. T\nake the design of an operating system as an example.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 132", "position": 132, "chunk_type": "semantic", "token_estimate": 389}
{"text": "12 Hetero: The chosen architecture must be \u201coptimal\u201d and\nnot necessarily focus on one particular aspect of the system constraints. T\nake the design of an operating system as an example. The\nlayered architecture and its variants are widely adopted by designers of many operating systems, such as Mac OS, OS2, Unix and its\nvariations, and the various versions of the Windows operating system. One strength of the layered architecture is robustness, and this\nis critical for an OS; since errors do not propagate from one layer to another, if an upper layer crashes it will not affect bottom-layer\nservices. Figure 12.1 presents a simplified architecture selection process combined with requirement analysis. When a project starts, the system\nanalysts and software architects interact with the project stakeholders, collecting project requirements, identifying system constraints,\nand defining system quality attributes. Then software architects decompose functionalities and propose feasible architecture styles. For\neach proposed architecture design, required functions are mapped to the components of the architecture. When all required functions\nare satisfied, quality attributes are evaluated against the architecture design. The results, together with the architecture design, are\ndocumented and collected in a set of candidate solutions. The process is repeated for all possible architecture styles and the results\nevaluated. If none of the proposed architecture designs work, system analysts must talk with stakeholders about project requirements\nchanges such as extended deadline, increased budget, or fewer functional requirements. When the set of requirements and system\nconstraints is refined, the whole process starts all over again, until the most appropriate architecture is identified (or the project is\nterminated).", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 132", "position": 132, "chunk_type": "semantic", "token_estimate": 264}
{"text": "Figure 12.1\n \nFlowchart of the architecture selection process\n \n12.3 Quality Attributes\n \nWhile the overall pattern of the architecture selection process is clear, how it is implemented can vary a great deal depending upon the\npractitioners. An especially challenging step in the process is identifying and evaluating project quality attributes. The success of this\nstep depends on the expertise and experiences of software architects and system analysts. Quality attributes are an essential part of the nonfunctional requirements of a system. It is the responsibility of system analysts to put\ntogether a complete list of quality attributes before the detailed design process can begin. For most computer systems, quality\nattributes often include efficiency (time efficiency, resource economy), functionality (completeness, security, interoperability),\nmaintainability (expandability, modifiability, testability), portability (hardware independence, software independence, installability,\nreusability), reliability (error tolerance, availability), and usability (under-standability of code, user interface, learnability). Each system, with its specific application domain, may have special requirements for quality attributes. System analysts need to\ninteract with stakeholders to identify the relative importance of quality attributes. Notice that, even for the same type of software\nsystems, different stakeholders might prefer different quality attributes. For example, operating systems on IBM mainframes, which are\nwidely deployed in banks, have very high standards on maintainability, reliability, and security. However, efficiency and usability may be\nof less concern. On the other hand, some stakeholders may prefer efficiency over security. In many cases, quality attributes can be quantified. For instance, to define the performance attribute of an online media broadcast\nserver, many factors can be defined and evaluated quantitatively, such as bandwidth, throughput, latency, loss rate, and jitter rate. For\nother quality attributes, such as understandability and reliability, qualitative evaluation may be also converted to quantitative values. Comments such as \u201cexcellent\u201d and \u201cbad\u201d can be mapped to numerical points in a scale of 100. When all quality attributes are represented quantitatively, software architects can enumerate feasible architecture designs and evaluate\neach quality attribute for each design. As each quality attribute is assigned a weighting factor, defined during the earlier requirement\nanalysis, a total score can be calculated for each design. When the evaluation process is complete, the design with the highest score\ncan be selected. Figure 12.2 is a simple example of quantitative evaluation of architecture designs. Suppose that the system analysts on a project\nidentify five quality attributes during the requirement analysis: performance, reliability, usability, reusability, and cost-effectiveness.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 133", "position": 133, "chunk_type": "semantic", "token_estimate": 399}
{"text": "Figure 12.2 is a simple example of quantitative evaluation of architecture designs. Suppose that the system analysts on a project\nidentify five quality attributes during the requirement analysis: performance, reliability, usability, reusability, and cost-effectiveness. Each\nof the quality attributes is assigned a percentage weighting factor; for example, performance accounts for 50% of stakeholder concern\namong all quality attributes. For each quality attribute the evaluation is represented using a value between 0 and 100. Figure 12.2\n \nSample quantitative evaluation of quality attributes", "domains": ["Software Quality Attributes"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 133", "position": 133, "chunk_type": "semantic", "token_estimate": 81}
{"text": "A weighted score can be calculated for each design. For example, the total score of Design 1 is calculated as follows:\n \n10*50% + 90*10% + 90*10% + 80*10% + 100*20% = 51\n \nBy comparing the total scores of all designs, we find that the choice is Design 2. Once a quantitative evaluation framework is defined, software architects can proceed with the architecture design with the following two\nsteps:\n \n1. Choose a proper architecture style. 2. Furnish the details of the architecture design; for example, when the pipe-filter style is chosen, software architects still have to\ndetermine what the filters will be and how to connect them. 12.4 Selection of Architecture Styles\n \nThe selection of architecture styles usually depends on the expertise of software architects. However, one helpful tool is Grady Booch's\ninitiative to create the Handbook of Softw\nare Architecture (Booch, 2004). It inventories software systems and discusses applications of\nvarious architecture styles. For developers working on routine projects (e.g., web applications, relational database applications, online\ngames, traffic control, etc. ), the handbook is a fast and convenient way to find related projects in the same application domain and learn\nabout architecture styles that are already in use. [Also, progress in product line architectures is promising (see Chapter 14).] However, general direction on how to select architecture style based on project requirements and constraints does exist. Figure 12.3\npresents a concise comparison of the architecture styles introduced in this book and enumerates quality attributes. Each cell denotes\nwhether an architecture style meets the corresponding quality attribute as follows: \u201c+\u201d signifies good, \u201c++\u201d signifies very good,\u201c-\u201d\nsignifies bad, and \u201c\u2014\u201d signifies very bad. An empty cell denotes no explicit judgment for the style/attribute pair in the general case. By\nexamining the architecture style against each required quality attribute in Figure 12.3, and the application domain of each architecture\nstyle, a software architect can gain a rough idea of the applicability of an architecture style in a project. 12.5 Evaluation of Architecture Designs\n \nNext we address the second step in architecture selection: how to evaluate an architecture design. There are many systematic\nevaluation approaches, such as ATAM (Architecture Trade-off Analysis Method), SAAM (Software Architecture Analysis Method), and\nARID (Active Reviews for Intermediate Designs). This section briefly discusses the application of the SAAM approach (Kazman,\nAbowd, Bass, and Clements, 1996).", "domains": ["Architectural Patterns and Styles"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 134", "position": 134, "chunk_type": "semantic", "token_estimate": 387}
{"text": "use case. A use case captures the required usage of the system; however, a scenario may contain situations that are not included in: the current scope of the project. For example, to evaluate the modifiability of an online registration system of a university, one scenario\ncould be: What should developers do when the internal data representation of a graduation application package is changed? This is a\nscenario used in SAAM, but not a use case of the system. The SAAM analysis process generally consists of three stages:\n \n1. Define a collection of design scenarios that cover the functional and nonfunctional requirements. Quality attributes should be\nreflected. 2. Perform an evaluation on all candidate architecture designs, using the collection of scenarios. 3. Perform an analysis on the interaction relationship among scenarios. The following case study demonstrates the first two stages in SAAM. The case study is based on the taxpayer example in Chapter 4. Assume that you are going to design an online tax processing system for the Internal Revenue Service (IRS). Operators input the\ninformation of each taxpayer into the system, which is recorded in an instance of a class like AmericanLaw\nyer and AmericanProfessor,\nbased on the occupation of the taxpayer. One instance of the IRS class is used to process tax information for each taxpayer. Two\ncandidate architecture designs (both of OO style) are presented in Figure 12.4. The stakeholders are interested in the following quality\nattributes:\n \n\u2022   Expandability: Over time, more occupation types could be added into the system, such as AmericanFarmer,\nAmericanBusinessOw\nner, etc. \u2022   Performance: Since millions of cases could be processed each day during peak times, time efficiency is very important. However,\nspace efficiency is of less concern because the stakeholders have enough funding to purchase computer storage (which is cheaper\neach day). Figure 12.4\n \nTwo candidate architecture designs for IRS\n \n\u2022   Modifiability: The format of tax forms and the method of calculating tax rates change every year. The system should be adaptable to\nsuch changes. To evaluate the two candidate designs in Figure 12.4, the following three scenarios are designed:\n \n\u2022   Scenario 1: Add one more occupation, called AmericanFarmer, into the system. This scenario tests the expandability of the system. \u2022   Scenario 2: Perform a virtual exhaustive testing on the system. How will the system behave if it has to process one million taxpayers\nper day? The IRS object includes a list of one million taxpayers, and it has to process each one by calling the ReportTax()\noperation. This scenario tests the performance of the system.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 135", "position": 135, "chunk_type": "semantic", "token_estimate": 423}
{"text": "use case. A use case captures the required usage of the system; however, a scenario may contain situations that are not included in: The IRS object includes a list of one million taxpayers, and it has to process each one by calling the ReportTax()\noperation. This scenario tests the performance of the system. \u2022   Scenario 3: Alter the tax rate calculation algorithm in ReportTax(), for example, to change the rules of itemized deduction. This\nscenario tests the modifiability of the system. Now consider how to evaluate the two designs in Figure 12.4. Scenario 1: In Design 1 (on the left of Figure 12.4), if a new class American-Farmer is added, the code of the IRS class has to be\nmodified. When iterating through the list of taxpayers, the IRS object has a big switch case to test the type of each taxpayer instance\nand calls the corresponding operation. A case has to be added into that switch case statement. In Design 2 (on the right of Figure\n12.4), programmers can simply insert the new class file of AmericanFarmer, and all other classes remain intact. Obviously, Design 2\nbeats Design 1 in Scenario 1. Scenario 2: It is easy to see that the two architecture designs are similar in performance. Design 1 will have a slightly higher overhead\nin deciding which ReportTax() operation to call based on the type of taxpayer instance. The greater the number of occupation types\nin the system, the longer the switch case statement and the larger the overhead. Design 2 does not have this problem due to\npolymorphism, whose extra overhead is a constant value. However, their difference in overhead is negligible compared with the\ncomplexity of tax rate calculation. Hence both designs perform equally on Scenario 2. Another question to consider is whether or not the two designs will both pass the test of Scenario 2. One million cases have to be\nprocessed per day, which amounts to 11.57 cases per second. This goal could roughly be met if no heavy I/O is involved. However, if", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 135", "position": 135, "chunk_type": "semantic", "token_estimate": 341}
{"text": "additional functions are required (e.g., to generate an automatically filled out tax report for each case), this could easily surpass the: capability of both architecture designs. Hence, both designs may have performance issues when additional functional requirements are\nadded. T\no improve the time efficiency, duplication of the current designs can be considered (as shown in Figure 12.5). A task dispatcher\naccesses the sequential user data and distributes the data to a number of IRS offices. Each IRS office is essentially a deployment of\nDesign 2 in Figure 12.4. Notice that the architecture can be easily expanded to introduce more IRS offices to achieve further\nperformance gains. The task dispatcher can also be replicated because there is no interdependency relationship among taxpayer\ncases. Figure 12.5 is essentially a batch sequential architecture style. Scenario 3: Both designs in Figure 12.4 will perform equally in Scenario 3. If the tax calculation algorithm changes, the\nAmericanCitizenTaxHandler class has to be modified in both designs. Figure 12.5\n \nTask dispatcher for parallelism\n \n \nFigure 12.6\n \nSAAM analysis results\n \nFigure 12.6 summarizes the results of the SAAM analysis on the two architecture designs in Figure 12.4 and the one in Figure 12.5. 12.6 Case Study: Online Computer Vendor\n \nThis section presents a case study on how to construct the design blueprint for an online computer vendor (OCV). The resulting system\nis called OCVS, in which the last \u201cS\u201d stands for \u201cSystem.\u201d\n \nThe business goal of an OCV is to minimize the price of products and increase the satisfaction rate of customers via the latest\ntechnology. An OCV sells computers directly to customers via the Internet. Customers directly specify what they need online. When an\norder is received, parts are assembled to meet the customer's requirements. Direct selling allows the removal of middlemen and\ndealers, and hence reduces the cost of product. Just-in-time (JIT) manufacture is used to minimize inventory cost and maximize\nmanufacturing efficiency. Parts are ordered only when required. The whole order processing and product manufacturing process is\nmonitored by a computer system (OCVS), and accurate orders of parts are sent to suppliers every day so that the requirements on\nparts can be precisely met. The success of OCV relies on the computer system, which bridges the information among all departments\nand maximizes the efficiency of the whole organization in its entirety. The general requirements of the OCVS are outlined as follows:\n \n1. Requirement 1 A web portal is provided to customers to place orders.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 136", "position": 136, "chunk_type": "semantic", "token_estimate": 409}
{"text": "additional functions are required (e.g., to generate an automatically filled out tax report for each case), this could easily surpass the: The general requirements of the OCVS are outlined as follows:\n \n1. Requirement 1 A web portal is provided to customers to place orders. An order can be highly customized where a customer can\nset the configuration of products step-by-step. Customers can check out directly via the shopping cart or save the shopping cart\nfor later use. Credit card is the only acceptable payment method. The web portal can serve 10,000 customers simultaneously. 2. Requirement 2 A subsystem is provided to product designers. When a product is released, the designer can input the basic\nconfiguration of the product into OCVS. A design can also specify the configuration process of the product. When the\nspecification of a new product is done, the corresponding web pages should be automatically generated in OCVS. Inventory and\nthe subsystem for assembly lines can also incorporate the information immediately. 3. Requirement 3 A subsystem is to assist assembly lines. Each worker on an assembly line is equipped with a computer system\nthat describes in detail the job that the worker has to perform. 4. Requirement 4 An automatic inventory management subsystem is developed to track the inventory. An automatic scheduler\nreports the estimated number of parts required every day. The reports, if approved by business managers, are converted to parts\norders to suppliers. 5. Requirement 5 The OCVS should bridge information among all departments to maximize organizational efficiency. The\ndepartments involved include order processing, manufacturing and shipping, product design, and business strategy. 6. Requirement 6 The required quality attributes of OCVS include:\n\u2022   expandability, so that new products (and their configuration process) can be easily added into the system;", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 136", "position": 136, "chunk_type": "semantic", "token_estimate": 293}
{"text": "\u2022   modifiability, to allow for modifications of internal representation of products and configuration processes over the time, since\nthe business rules (e.g., parts usage prediction), product web pages, and configuration process will go through frequent\nchanges;\n \n\u2022   availability and reliability, especially for the modules that interact with customers and the manufacture assembly lines; and\n \n\u2022   time efficiency, for all modules to cope with the requirement of producing one million PCs per year. Peak time requirement of\nits customer web portal is to support 10,000 customers simultaneously at any given time. The next task is to construct a feasible architecture design blueprint of OCVS. Follow a top-down strategy: provide the overall\narchitecture design first and then decompose system into components, where the design of each component is furnished. 12.6.1 Overall Architecture Design of OCVS\n \nRecall that the process of architecture design contains two steps: (1) selection of architecture styles, and (2) architecture design. We\nnow have to make decisions on architecture style(s) of the overall structure of OCVS. There are many architecture styles from which to\nchoose, and some of them can be screened out easily. Figure 12.7 illustrates the screening process. OCVS does not fall into the\napplication domain of many architecture styles listed, such as process control (which favors embedded systems), pipe and filter (which\nrequires data streams between components), main/subroutine (which does not support distributed architecture), MVC (which suits the\nweb portal component of OCVS only), and so on. Since pure batch sequential and repository styles do not work for OCVS in isolation, they are combined as one candidate\n(heterogeneous) architecture style. Hence, after the initial screening in Figure 12.7, the candidate architecture styles are: (1) batch\nsequential + repository, (2) layered, (3) multi-tier, (4) service-oriented architecture (SOA), and (5) component-based architecture\n(CBA). Figure 12.7\n \nScreening of architectural styles for OCVS\n \nTwo pairs of architecture styles are very similar: layered vs. multi-tier and SOA vs. CBA. Multi-tier architecture can be simply regarded\nas the layered architecture style in a distributed system. First you have to break the tie between SOA and CBA. 12.6.1.1 SOA vs. CBA\n \nIn both SOA and CBA, components (\u201cservices\u201d in SOA) have well-defined interfaces. CBA is an older technique than SOA, which is\nmainly supported by middleware techniques such as CORBA. In addition, CBA has weaker directory services than those provided in\nSOA (such as UDDI, the Universal Description, Discovery, and Integration services).", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 137", "position": 137, "chunk_type": "semantic", "token_estimate": 399}
{"text": ",: y\np\ng g\ny\np\ny\np\npassing, SOA is essentially stateless and lacks the capability of passing remote object references. All remote object references have\nto be serialized, which creates much larger network overhead for SOA implementations (Brown, Johnston, and Kelly, 2002). In addition,\nthe network overhead of passing the same message by SOA is significantly greater than CBA. Therefore, considering the\nrequirements of OCVS, the CBA architecture style is preferred. 12.6.1.2 Final Decision on Architecture Selection\n \nThe decision is made to select component-based architecture (CBA) over the other alternatives. The batch sequential to data\nrepository is ruled out due to the following argument: Batch sequential is suitable for order processing; however, it supports the\nworkflow of one particular task only. OCVS has to perform several major tasks concurrently. With multi-tier view you can use the following three tiers to model the system: (1) front-end, (2) business model, and (3) database. Notice that many functional units, such as Web portal and manufacturing system, have to be broken down into three tiers and their\ncomponents mixed in the same tier. Hence, logically the system does not look like a clear-cut choice for this style. The preceding\ncomparison leads to the choice of CBA. Figure 12.8\n \nOverall architecture of OCVS\n \nFigure 12.8 presents the architecture design of the overall structure of OCVS. The system generally consists of five components: Order\nProcessing, Data Repository, Inventory Management, Manufacture and Shipping, and Financial Department. Note that each\ncomponent may be deployed on one or more computers, and the overall OCVS system is a distributed system. There are four actors\nthat interact with OCVS: Customer, Parts Suppliers, Credit Card Company, and Shipping Service Supplier. Components interact\nwith each other via remote procedure call. For example, when the Order Processing department finishes the order transaction of one\ncustomer, the SaveOrder interface of the Data Repository is used to save the order. In the meantime, the ReserveParts interface of\nInventory Management is used to reserve parts for that order. Later the Manufacture and Shipping component will TakeOrder from\nData Repository, and RetrieveParts from Inventory Management. The Manufacture and Shipping will periodically Update-\nOrderStatus to Data Repository so customers can trace order status. When an order is finished, Shipping Service Supplier will be\ncontacted to deliver products to customers. The next task is to evaluate how the architecture design in Figure 12.8 satisfies the requirements of OCVS.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 138", "position": 138, "chunk_type": "semantic", "token_estimate": 401}
{"text": ",: When an order is finished, Shipping Service Supplier will be\ncontacted to deliver products to customers. The next task is to evaluate how the architecture design in Figure 12.8 satisfies the requirements of OCVS. Requirement 1 (customer\nWeb portal) is mapped to the Order Processing component. Requirement 2 (insertion of product configuration) is not satisfied by the\narchitecture design yet. System analysts and software architects may suggest removing this requirement. The argument is that to\nachieve Requirement 2, a specific product description language has to be defined and the corresponding language interpreter has to\nbe implemented. Since OCVS does not release more than 20 products per year, there is no need to build a product description\nlanguage and interpretation system. A more convenient way is to insert product configuration modules into the order processing system\nmanually by the system engineer. Requirement 3 (computer assisted manufacture system) is mapped to the Manufacture and\nShipping component. Requirement 4 (smart inventory management) is mapped to the Inventory Management component. Requirement 5 is reflected in the design of the overall structure where the Data Repository component takes charge of maintaining\nlive data. Requirement 6 is about quality attributes. The expandability requirement can be solved by manual addition of product configuration\nmodules into the Order Processing component (not as good as the product description language solution, but much less costly). Time\nefficiency and availability can be achieved through replication of components, for example, Order Processing and Data Repository\ncomponents. The only quality attribute that is not handled well is modifiability. When internal data representations of customer profiles\nor order details are changed, Data Repository and other correlated components have to be modified. The SOA architecture might do a\nlittle better due to the semistructured XML. However, the modifiability is traded for the time efficiency and convenience of\nimplementation. Next we will address the architecture design of Order Processing, Inventory Management, and Manufacture and Shipping\ncomponents. The discussion of Financial Department and Data Repository is omitted here because the design is straightforward:\nFinancial Department contacts credit card companies for charging cards, and Data Repository is a simple wrapper class of relational\ndatabases.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 138", "position": 138, "chunk_type": "semantic", "token_estimate": 357}
{"text": "12.6.2 Architecture Design of Order Processing Component: The Order Processing component is similar to the Order Processing System (OPS) discussed in Chapter 4 and the JSP/Servlet MVC\nII example discussed in Chapter 9. In summary, the Order Processing component naturally falls into the application domain of web-\nbased interactive architecture style. There are two choices of interactive architecture: MVC and PAC. MVC model is chosen due to its\nsimplicity. As requested by the stakeholders of OCV, it should be relatively easy to add new product information and product configuration\nprocess into the Order Processing component. T\no achieve this, the overall structure of the component is organized using component-\nbased architecture, where each component represents the set of correlated JSP pages, Java Servlet classes, and the corresponding\nJava Beans for a certain \u201cstage\u201d during a shopping session. These components do not invoke any functions of each other, and the only\ntype of association among them is that one component might forward (i.e., redirect) to another. Figure 12.9 presents the overall structure of the Order Processing component. Notice that there are multiple components for product\nconfiguration (e.g., A1, B1, and B2). If a new product is released, the corresponding configuration component can be inserted into the\nOrder Processing component with all other product configuration components and the Check Out component remains intact. Only the\nBrow\nse Product Catalog component will need to be recompiled if a new product is added. Figure 12.9\n \nMajor components of the Order Processing component\n \nThe architecture design of the Brow\nse Product Catalog, Check Out, and Product Configuration components will be similar. All of them\nuse the Model-View-Controller (MVC) architecture, which allows separation of presentation and business logic, and hence the flexibility\nin extension and modification. The basic idea of MVC is to use a model to maintain the data of the system, a view for presenting the\ndata, and a controller to serve as a middleman between view and model. MVC can be implemented on many platforms including both\n.Net and Java. For example, on Java platforms, JSP pages are usually used as View, Java Servlet classes are used as Controller, and\nJava Bean objects and back-end databases are used as Model. The architecture design of the Product Configuration component is\npresented in Figure 12.10.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 139", "position": 139, "chunk_type": "semantic", "token_estimate": 380}
{"text": "12.6.2 Architecture Design of Order Processing Component: For example, on Java platforms, JSP pages are usually used as View, Java Servlet classes are used as Controller, and\nJava Bean objects and back-end databases are used as Model. The architecture design of the Product Configuration component is\npresented in Figure 12.10. Figure 12.10\n \nArchitecture design of Product Configuration\n \nIn Figure 12.10, the \u201cView\u201d of a Product Configuration component consists of three JSP pages, one for displaying error message, one\nfor displaying product catalog (actually a part of the Brow\nse Product Catalog component), and the last one (ProdConfig.jsp) for\ninteracting with a customer in each step of the configuration process. Each JSP page has static HTML contents, designed by graphic\ndesigners, which may change frequently. The dynamic contents are set by the Controller Servlet. For example, the step number of\nconfiguration process, instructions for the configuration step, as well as a list of parts by different vendors for the customer to choose\nfrom, parameterizes ProdConfig.jsp. All these contents are eventually retrieved from the model, a Java Bean called Configuration. The model shown in Figure 12.10 works as follows. After the customer selects one product model in the Brow\nse Product Catalog\ncomponent, the controller of the Brow\nse Product Catalog redirects the browser to ProdConfig.jsp. The Controller Servlet is\ncreated and it, in turn, creates the model Configuration bean. Then the ProdConfig.jsp page helps the customer to configure the\ncomputer step-by-step\u2014selecting CPU model, memory type and size, graphic card, etc. A customer can choose to advance to the next\nstep, or go back to the previous step. When a step is finished, the list of parts that are selected during that step is forwarded to", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 139", "position": 139, "chunk_type": "semantic", "token_estimate": 284}
{"text": "Controller and then to Configuration. When the whole configuration is completed and confirmed by the user, the AddToCart request is: sent to Controller and central database will be updated. The choice to implement the modules of the Product Configuration is obvious, that is, object-oriented paradigm. A state machine\ndiagram can capture the design of configuration beautifully, and one example is shown in Figure 12.11. Each state of the state machine\ndiagram represents one step in the configuration. When the state machine enters one state, the part list variable is set correspondingly\nfor that step. Users can step backward and forward between states. From each state, a call of the Cancel operation causes the state\nmachine to end up in the final state. Notice that the design in Figure 12.11 does not furnish all the details. For example, to allow\ncustomers to step backward, a stack should be established to record the history of selected parts. When the state machine advances\nto the next state, the latest parts list submitted by the customer should be pushed into the stack; when the state machine steps\nbackward, a pop operation should be conducted. Another problem with the current design is that from each state the Next transition\nshould be disabled if the user has not submitted the selected parts for that step. You can refine the design in Figure 12.11. Figure 12.11\n \nState machine diagram of the Configuration class\n \n12.6.3 Architecture Design of Inventory Management\n \nAs shown in Figure 12.8, the Inventory Management component has the following responsibilities:\n \n\u2022   It maintains the records of all parts (e.g., CPU, memory chip, hard drive, monitor, etc.). The warehouse of OCVS is managed\ndigitally. Each item has a full record in the database system of Inventory Management and each item (not its type) has a unique\nbarcode. \u2022   It allows customers to reserve parts for an order. When a reservation succeeds, the barcodes of the reserved items are associated\nwith the order. Customers receive an immediate response when parts they ordered are not available. When a customer steps\nbackward in product configuration, the reservation locks on the corresponding parts are released by invoking the UndoReserve\noperation. \u2022   It allows the Manufacture and Shipping component to check out parts by calling RetrieveParts. Each worker in the warehouse has a\nworking desk equipped with a computer and a barcode scanner.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 140", "position": 140, "chunk_type": "semantic", "token_estimate": 392}
{"text": "Controller and then to Configuration. When the whole configuration is completed and confirmed by the user, the AddToCart request is: \u2022   It allows the Manufacture and Shipping component to check out parts by calling RetrieveParts. Each worker in the warehouse has a\nworking desk equipped with a computer and a barcode scanner. When the remote invocation of RetrieveParts occurs, the Inventory\nManagement generates a job order, which specifies the items to check out and their destination, and assigns a barcode and an\ninternal mail package box for the job order. A worker receives a job order via computer, selects the required items, assembles the\nproduct, and then sends it out. Whenever an item is put into a package, its barcode first has to be scanned. When the package box\narrives at Manufacture & Shipping, the barcode of the package is scanned again to confirm the completion of the job order. \u2022   It routinely examines the inventory of all parts. Based on the history of inventory, it issues a daily order for each type of parts to\nsuppliers. Each supplier has established a transaction server that conforms to the supply-chain interface of OCVS. From the above requirements, it is easy to infer that the inventory management should include:\n \n\u2022   a database which maintains information on all parts stored in the warehouse;\n \n\u2022   a controller system which is able to accept remote invocation from the Order Processing and Manufacture and Shipping\ncomponents; and\n \n\u2022   satellite computers (with barcode scanners) that are used by the workers. The next step is to decide how to organize these modules. The application domain of the Inventory Management soon leads to a\nheterogeneous architecture style: the combination of data repository and client server styles. The block diagram in Figure 12.12\ndisplays the general structure of Inventory Management. Both the Inventory Management Controller and Satellite Computers interact\nwith a relational database for insertion, removal, and update of computer parts records. The relationship between the Satellite\nComputer and Inventory Management Controller is client/server. The Inven-tory Management Controller keeps a list of job orders.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 140", "position": 140, "chunk_type": "semantic", "token_estimate": 344}
{"text": "When a Satellite Computer has completed one job, it retrieves the details of another job order and displays the job to worker.: Figure 12.12\n \nArchitecture design of the Inventory Management component\n \nClearly, the Inventory Management Controller can be developed using the OO paradigm, and the Satellite Computer can be\ndeveloped using MVC architecture (as it interacts with workers). We will examine the design details of these two modules as\nexercises. 12.6.4 Architecture Design of Manufacture and Shipping Component\n \nThe last task of this chapter is the architecture design for the Manufacture and Shipping component. This subsystem has to manage\nthe information flow of the manufacture department, which is responsible for producing over one million PCs per year. Figure 12.13\n \nAn intuitive diagram of OCVS assembly line\n \nBackground The major equipment of the manufacture department is its assembly line. The major idea of an assembly line is to take advantage of the economic principle of \u201cdivision of labor.\u201d If managers break down the\nuse of labor into well-defined, specialized, and repetitive tasks, they can greatly increase the efficiency of the output. The structure of an\nOCV assembly line is presented in Figure 12.13. Its major component is the conveyor belt, which moves materials forward. Multiple\nstages are attached to the conveyor belt (the number of stages can vary and can be adjusted dynamically). The hardware of each stage\nconsists of the following:\n \n\u2022   A workstation that provides the space for workers to assemble parts. The workstation is equipped with a computer (called \u201cstage\ncomputer\u201d) that displays job details to operators and allows operators to send messages to central controller (e.g., reporting testing\nfailures, malfunction of parts, etc.). \u2022   A parts rack to hold the parts required for the stage. The inventory department fills the parts rack. With the assistance of OCVS, it\nguarantees that when a computer chassis arrives at one stage, the required parts at this stage are already in the parts rack. \u2022   A barcode scanner which is used: (1) to check in parts when they are delivered by the inventory department; (2) to check in computer\nchassis when it arrives; and (3) to check out computer chassis when the job is completed at this stage. Figure 12.14\n \nArchitecture of Manufacture and Shipping component", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 141", "position": 141, "chunk_type": "semantic", "token_estimate": 375}
{"text": "Overall Structure of Manufacture and Shipping Component The project goal is to coordinate the information flow to expedite the\nproduction process. The scope of the Manufacture and Shipping component includes the central controller that interacts with other\ncomponents of OCVS, and the stage computers (with barcode scanner); control of the conveyor belt pulley is out of the scope. Given the requirements and the nature of the assembly line, one natural choice for the overall structure of the Manufacture and\nShipping component is the client-server architecture, shown in Figure 12.14. The server part in the design is called MS-Controller. Design of MS-Controller Recall that the responsibilities of the MS-Controller are: (1) to interact with Order Processing and Inventory\nManagement components for smooth supply-chain; and (2) to manage all stage computers to coordinate the manufacture process,\nsuch as displaying job details to operators when a computer chassis arrives to the stage or accepting exception reports from\noperators. Since MS-Controller bears many responsibilities, a layered architecture can be used to simplify its design. The basic idea is to split\nMS-Controller into three layers: (1) a communication layer that accepts messages sent by stage computers and communicates with\nother remote components such as Order Processing and Inventory Management; (2) a core engine layer that handles requests from\nstage computers and controls the whole manufacturing process; and (3) a business logic layer that defines and interprets business\nrules. Figure 12.15 shows the architecture design of MS-Controller. The communication layer has to communicate with remote\ncomputers/components. Figure 12.15\n \nArchitecture design of MS-Controller\n \nRequests from the outside world are forwarded to the core engine to be processed. The business module sitting behind parameterizes\nthe processing by the core engine. The next step is to drill down to the design of the three modules of MS-Controller. The design details of Communication Layer and\nBusiness Logic are left to you as assignments. In the following, the focus is on the design of the Core Engine. The Core Engine has to perform many different tasks. For example, when the assembly lines are started, it is responsible for retrieving\nthe daily job orders from the Data Repository. If anything goes wrong (e.g., sound card malfunctioning), the Core Engine has to send\ninstructions to the stage for taking remediate actions (e.g., to pull the product off the line and to temporarily stop all products of the\nsame model number).", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 142", "position": 142, "chunk_type": "semantic", "token_estimate": 397}
{"text": "For example, when the assembly lines are started, it is responsible for retrieving\nthe daily job orders from the Data Repository. If anything goes wrong (e.g., sound card malfunctioning), the Core Engine has to send\ninstructions to the stage for taking remediate actions (e.g., to pull the product off the line and to temporarily stop all products of the\nsame model number). There are several feasible alternatives for the design of Core Engine. These include the blackboard and event-\nbased architecture styles. However, the best solution is to use the buffered message architecture. The message registration service\ncan be easily set up using messaging services such as Java Message Service. Then events can be added into the message\nregistration service, and the handlers are registered. Figure 12.16 presents some sample events and the corresponding actions to be\ntaken.", "domains": ["Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 142", "position": 142, "chunk_type": "semantic", "token_estimate": 138}
{"text": "Figure 12.16\n \nSample events and handlers of Core Engine\n \nAn outstanding feature of the buffered message system is its flexibility. New events and handlers can be defined conveniently without\ninterrupting the existing modules. Although the architecture decision of the Core Engine is to use the buffered message style, its\ndetailed design can be conveniently implemented using the OO approach. 12.7 Summary\n \nChoosing the best architecture design for a software system is indeed an art. This chapter introduced several methodologies for\nmaking architecture decisions and evaluating alternative architecture designs. The general principles were practiced in a case study of\nbuilding an online computer vendor system. Various architecture styles such as the component-based, service-oriented, batch\nsequential, model-view-controller, client-server, data repository, and buffered message systems were considered in its design. Y\nou are\nencouraged to complete the unfinished modules of the online computer vendor system. Remember: expertise comes from experience! 12.8 Self-Review Questions\n \n1. Which of the following is used to evaluate architecture designs? a. ATAM\n    b. SAAM\n    c. ARID\n    d. ALL\n2. Which of the following is true about heterogeneous architecture? a. There is no mixed architecture style at one abstraction level. b. Heterogeneous architecture implies increased time efficiency. c. If the general structure of a system is connected using one architecture style, and each component can use a different one,\nthis is one example of heterogeneous architecture. d. None\n3. Modifiability and expandability are essentially the same quality attribute. a. True\n    b. False\n4. SAAM relies on use cases to test an architecture design. a. True\n    b. False\n5. There is always an architecture design that can meet all requirements. a. True\n    b. False\n6. Service-oriented architecture is stateless, while component-based architecture is not. a. True\n    b. False\n7. Batch sequential architecture is generally more time efficient than pipe and filter. a. True\n    b. False\n8. It is beneficial to integrate architecture design with the process of requirements analysis. a. True\n    b. False\n9. Event-based architecture is a good candidate for interactive systems with graphic user interface. a. True\n    b. False\n10. Blackboard architecture is difficult to debug.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 143", "position": 143, "chunk_type": "semantic", "token_estimate": 347}
{"text": "a. True: True\n    b. False\nAnswers to the Self-Review Questions\n \n1. d 2. c 3. b 4. b 5.b 6. a 7.b 8. a 9. a 10. a\n \n12.9 Exercises\n \n1. List the application domain of every architecture style that is introduced in this book. 2. Is there any difference between modifiability and expandability? Explain. 3. Give one scenario for which batch sequential architecture is a better choice than pipe and filter. 4. Give one scenario for which service-oriented architecture (SOA) is a better choice than component-based architecture (CBA). 5. Give one scenario for which event-based architecture (non-buffered) is a better choice than the message passing architecture\n(buffered). 12.10 Design Exercises\n \n1. Use the SAAM approach to evaluate the modifiability of the design in Figure 12.9. 2. Finish the detailed design and implementation of the Production Configuration component (in Figure 12.10) using\nJSF/Servlet/JavaBean. 3. Finish the detailed design of the Configuration class in Figure 12.11. 4. Complete the detailed design of the Inventory Management System in Figure 12.12 using the OO paradigm. 5. Select a proper architecture style for the Business Logic module in Figure 12.15. 6. Enumerate three more events and the corresponding actions that can be listed in Figure 12.16. 12.11 Challenge Exercises\n \n1. Assume that the stakeholders ask for an additional module in the Manufacture and Shipping component. The module should\nprovide a graphical user interface that allows business managers to adjust the mapping of a manufacturing process (of a product)\nto the stages of assembly lines. Choose the architecture style for this module and furnish the detailed design. 2. Assume that OCV has expanded its business and sells 50 million PCs per year. Every year, OCV brings over 50 new products to\nthe market. Now the support of Requirement 2 (which was discarded in the original design of OCVS) has been an urgent task. How would you expand the existing OCVS system to make the following a reality? \u201cRequirement 2: A subsystem shall be provided to product designers. When a product is released, the designer can input the\nbasic configuration of the product into OCVS. A design can also specify the configuration process of the product. When the\nspecification of a new product is done, the corresponding web pages should be automatically generated in OCVS. Inventory and\nthe subsystem for assembly lines shall also incorporate the information immediately.\u201d\nThink of the architecture style for the new module.", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 144", "position": 144, "chunk_type": "semantic", "token_estimate": 401}
{"text": "a. True: When the\nspecification of a new product is done, the corresponding web pages should be automatically generated in OCVS. Inventory and\nthe subsystem for assembly lines shall also incorporate the information immediately.\u201d\nThink of the architecture style for the new module. Furnish the detailed design of the module and implement your design using\nJSP/Servlet. References\n \nBooch, Grady. Handbook of Softw\nare Architecture, 2004, http://www.handbookofsoftwarearchitecture.com/ (accessed November\n2008). Brown, Alan, Simon Johnston, and Kevin Kelly. \u201cUsing Service-Oriented Architecture and Component-Based Development to Build\nWeb Service Applications.\u201d A Rational Software White Paper. Rational Software Corporation, 2002, 8-9. http://www-\n128.ibm.com/developerworks/rational/library/content/03July/2000/2169/2169.pdf. Kazman, Rick, Gregory Abowd, Len Bass, and Paul Clements. \u201cScenario-Based Analysis of Softw\nare Architecture.\u201d IEEE Software,\nVol. 13, No. 6. Los Alamitos, CA: IEEE Computer Society Press, 1996, 47-55. Suggested Reading\n \nShaw, Mary. \u201cHeterogeneous Design Idioms for Softw\nare Architecture.\u201d IWSSD \u201891: Proceedings of the sixth international workshop\non software specification and design. Los Alamitos, CA: IEEE Computer Society Press, 1991, 158-165. Garland, Jeff and Richard Anthony. Large-Scale Softw\nare Architecture: A Practical Guide Using UML. Wiley, 2002.", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 144", "position": 144, "chunk_type": "semantic", "token_estimate": 178}
{"text": "13 Architecture of User Interfaces: s\n \nObjectives of this Chapter\n \n\u2022   Introduce the look and feel and the usability of user interfaces\n \n\u2022   Discuss the design considerations\n \n\u2022   Demonstrate the enabling technology\n \n13.1 Overview\n \nAny software system is a service. A good service must satisfy the user's expectations. From the user's viewpoint, the first impression of\na software system is its user interface (UI). Due to the fact that any software system should accept inputs, conduct computations, and\ndisplay outputs, the user interface mainly performs two functions. One is accepting the user's inputs (input data or control commands),\nand the other is displaying the outputs (or the current states of the software system). Even a batch software system, such as a software\nsystem for a numeric computation, has at least one command, \u201crun,\u201d and a display of the computational results. As we discussed in Chapter 3, we have introduced a \u201cuser interface view\u201d into the 4+1 view model, which we compiled with the\n\u201cscenario view.\u201d In other words, the user interface of a software system is a very important portion of the system, just like a wrapper is a\nvery important part of a candy. Why is it so important? In some sense, the user interface could be the most important part of a software system. No matter what the internal architecture of the\nsoftware system is, users will first see the architecture of its external user interface. The users' choices for a software package are very\noften based on what is offered by the user interface of the software. A good user interface will attract the user while a bad one may\ncause a market failure against the competition of the software system. In this sense, the user interface is the external, and possibly the\nonly, visible aspect of the underlying software system. As a \u201clanguage\u201d for describing the software to users, the user interface has its syntax and semantics. The syntax includes the\ncomponent types (textual, icon, button, etc.) and their composition (organization and layout). There are no rules, like grammar rules, that\ncan be used to check the correctness of the syntax of the user interface; instead we use the look and feel to summarize it. The\nsemantics of the user interface includes the linkages between the components of the user interface and the functionalities associated\nwith the software system.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 145", "position": 145, "chunk_type": "semantic", "token_estimate": 393}
{"text": "13 Architecture of User Interfaces: There are no rules, like grammar rules, that\ncan be used to check the correctness of the syntax of the user interface; instead we use the look and feel to summarize it. The\nsemantics of the user interface includes the linkages between the components of the user interface and the functionalities associated\nwith the software system. A good user interface should help the user to understand the software system easily, without misleading\ninformation, and attract the user to use the software system joyfully without mistakes. Usability summarizes the semantics of the user\ninterface. Software in different domains may require different styles of its user interface. A calculator requires only a small area for displaying\nnumeric numbers but a big area for commands. A text editor needs a big area for displaying information but a small area for\ncommands. An Integrated Development Environment (IDE) for software development requires a complicated menu system, a property\nlisting, a palette for holding all UI components, and a panel for accepting UI components with a drag-and-drop method. A web page, a\nweb application, or a web service needs forms, links, tabs, etc. A computer game needs a totally different user interface. However, no\nmatter which kind of user interface it is, every user interface supports accepting commands and displaying information. Based on the appearance, we group user interfaces into three styles: static, dynamic, and customizable. Additionally, based on the way\ncommands are issued, we divide user interfaces into three categories: textual, graphical, and other kinds, such as voice. In general, the\ntextual user interfaces are being faded out. This chapter primarily discusses the graphical user interfaces. In the discussion, we will mainly focus on the common architecture and\ndesign principles. The topics include: (1) evolution of user interfaces; (2) look and feel of user interfaces; (3) usability of user interfaces;\n(4) design considerations; and (5) enabling technology. Through these topics, we will evaluate and analyze the existing user interfaces,\nand then synthesize the observations to draw common principles. Finally we will discuss the design considerations and enabling\ntechnologies as solutions for realizing the requirements of user interfaces. 13.2 Evolution of User Interfaces\n \nThe architecture of user interfaces supports its look and feel and usability aspects. The evolution from textual user interfaces to\ngraphical user interfaces can give us an idea about why the look and feel and the usability came to be.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 145", "position": 145, "chunk_type": "semantic", "token_estimate": 402}
{"text": "13 Architecture of User Interfaces: 13.2 Evolution of User Interfaces\n \nThe architecture of user interfaces supports its look and feel and usability aspects. The evolution from textual user interfaces to\ngraphical user interfaces can give us an idea about why the look and feel and the usability came to be. Let us take a calculator in a\nsoftware version as an example. In the early days, before calculators became commercial hardware products in the market, many\nstudents had developed software calculators with a command line. (Using the DOS prompt panel, we can experience what the\ncommand line is today.) When the software calculator is running, the user types in the command \u201cadd 5 10 <Enter>\u201d, and the screen\ndisplays the computation result. This was the first type of interface for interactive systems. It was known as command-line interface. A\nlarge number of systems have been developed with command-line interfaces, particularly operating systems. Users of some operating\nsystems still prefer using this kind of textual command line user interface today.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 145", "position": 145, "chunk_type": "semantic", "token_estimate": 169}
{"text": "The command-line interface uses a command language. Creating a command language processor is usually easier than implementing\na graphical user interface. However, users have to learn and memorize the command language. It is not suitable for casual and\ninexperienced users. In addition, users inevitably make errors in expressing commands so that the language processor must include\nerror handling and message generation facilities. T\no overcome these drawbacks, a listing of commands was used. When the calculator starts running, a set of commands was listed as\na group of \u201cchoices\u201d like this:\n \n1. addition\n2. subtraction\n3. multiplication\n4. division\n5. \u2026\nWhen the user clicks one of the number keys on the keyboard and types in two operands, the calculator will display the corresponding\ncomputation result on the screen. The entire screen is for listing the commands, displaying the input data, and showing the output\nresults. The display moves up line-by-line along the screen when the user issues more commands. T\noday's calculator, for example the Windows calculator shown in Figure 13.1, looks totally different. A dedicated small window is used\nfor showing the numeric numbers. Buttons and check boxes represent all commands (functions). The user points and selects buttons\nand check boxes to operate these commands. These two versions of user interfaces, namely the textual command-line and the graphical point-and-click user interfaces, have a\ndifferent syntax (look and feel) while their semantics are the same; both of them access the same internal functionalities behind the\ntextual listing or the buttons. Figure 13.1\n \nThe Windows calculator\n \nImagine that we map all functions supported by the Windows calculator shown in Figure 13.1 to a command listing, the listing will\ncontain about 40 lines or so. Users have to browse the entire list each time to find the function they need. Not only is the list display a\nmess but selecting a command from the long listing is a tedious and error-prone task. Thus, the graphical user interface is more\nmeaningful and easier to use than the text-based user interface. From this example we also can see that a user interface itself, especially the graphical user interface, is sophisticated software. It\nneeds codes not only for displaying, arranging, and laying out all buttons, labels, and components but also for linking these elements in\nthe user interface with the internal functions of the software.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 146", "position": 146, "chunk_type": "semantic", "token_estimate": 391}
{"text": "From this example we also can see that a user interface itself, especially the graphical user interface, is sophisticated software. It\nneeds codes not only for displaying, arranging, and laying out all buttons, labels, and components but also for linking these elements in\nthe user interface with the internal functions of the software. This example also reveals a separating principle: to separate the view (user\ninterface) from the logic (computations). The internal architecture of a software system follows the logic of the application\nspecifications. Its user interface is the view of the logic of the software. We may have the same logic for the computations but different\nviews for different users. If we would like to design a calculator for a blind person, we need another kind of user interface. Fortunately, many programming languages, such as Visual Basic, Java, etc., provide built-in components and layout managers for\nimplementing user interfaces. In addition, many IDEs support drag-and-drop metaphors for making the implementation of graphical\nuser interfaces easier. However, organizing these components to form a user interface can be an art. We need to understand this art\nand the way to map it into an engineering practice. The points of this understanding mainly include what kind of components should be\nused, how to arrange them in a proper fashion in terms of its syntax (look and feel), and what the architecture of the user interface\nshould be in terms of its semantics (usability, consistency, and integration). 13.3 Look and Feel (Syntax) of User Interfaces\n \nThe syntax of user interfaces refers to its appearance, or its look and feel. As we have previously mentioned, the arrangement of a user\ninterface is an art. There are no engineering \u201crules\u201d that can be used to check its \u201ccorrectness,\u201d like grammar rules used to check the\nsyntax of a programming, or even a spoken, language. The design and implementation of the look and feel are based on the belief that\nmost humans know how to appreciate artwork. In general, graphical user interfaces have three styles: static, dynamic, and\ncustomizable. 13.3.1 Static Style of User Interfaces\n \nThe static style of user interfaces refers to those user interfaces that have statically \u201cprefixed\u201d components and compositions. The\nWindows calculator shown in Figure 13.1 is a typical example. The components used on the user interface include button, radio button,\nand check box.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 146", "position": 146, "chunk_type": "semantic", "token_estimate": 392}
{"text": "The\nWindows calculator shown in Figure 13.1 is a typical example. The components used on the user interface include button, radio button,\nand check box. All these components are arranged into three rows and two columns. The frequently used digits and commands are in", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 146", "position": 146, "chunk_type": "semantic", "token_estimate": 44}
{"text": "the right-hand column. The infrequently used commands, including scientific, statistic, and memory access commands, are in the left-: hand column. The digits [0-9] are grouped into a panel that is almost the same as the digit panels on other popular devices like phones. The digits [A-F] will be activated only when the user selects the \u201chex\u201d (hexadecimal) operation. Different colors identify different clusters\nof commands or data. The key \u201cSta\u201d will pop-up a hidden window that extends the functionality of the user interface. All these\narrangements together form the architecture of the user interface. The architecture provides context for the content and tells us what we\ncan do. The architecture also illustrates the syntax of the user interface. In addition, the \u201cHelp\u201d menu is one of precious tools for helping\nusers find tutorials and hints on using the system. Many user interfaces fall into this style, such as text editors and IDEs for software development. In general, these user interfaces are\nwell-defined, in the sense that they are usually developed by professionals, and many are commercial products. Secondly, the IDEs\nhave a clearly defined application domain and serving targets, that of supporting program development with a selected programming\nlanguage; an IDE deals with a certain set of menus, such as File, Edit, Search, Build, Run, and so on. The organization and layout of\nthese user interfaces of IDEs and Editors can be summarized in the following. \u2022   1D layout: This simply has only one menu bar that supports fundamental functions for editing\u2014such as MS Notepad, MS Word, and\nso on\u2014and leaves central space for information editing. The menus usually have pull-down menus and walking menus, as shown in\nFigure 13.2. They could be considered as 2D layout, but the menu system appears along the x-direction only as a 1D layout. \u2022   2D layout: besides a menu system along the x-direction, there are certain left or right panels along the y-direction for arranging\nmore tool bars or for displaying properties. Some of them also use the bottom portion for displaying status. T\nextPad, Visual Basic\neditor, and Paint are some examples of this kind, as shown in Figure 13.3. \u2022   3D layout: a menu along the x-direction, toolbars along the y-direction, and tabs or more multiple choices along the z-direction,\nsuch as Eclipse, Java Studio IDEs, and .NET studio, and the like, as shown in Figure 13.4. \u2022   4D layout: The user interface of Maya (Figure 13.5) is one example.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 147", "position": 147, "chunk_type": "semantic", "token_estimate": 409}
{"text": "the right-hand column. The infrequently used commands, including scientific, statistic, and memory access commands, are in the left-: \u2022   3D layout: a menu along the x-direction, toolbars along the y-direction, and tabs or more multiple choices along the z-direction,\nsuch as Eclipse, Java Studio IDEs, and .NET studio, and the like, as shown in Figure 13.4. \u2022   4D layout: The user interface of Maya (Figure 13.5) is one example. It has a menu along the x-direction, toolbars along the y-\ndirection, tabs along the z-direction, and when the menu-sets\u2014which include Animation, Modeling, Dynamics, Rendering, and Live\netc.\u2014change from one to the other, part of the menu is changed. This creates an additional direction. Figure 13.2\n \nPull-down menu (left) and walking menu (right) in MS Word\n \n \nFigure 13.3\n \n2D layout in a user interface (Paint)", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 147", "position": 147, "chunk_type": "semantic", "token_estimate": 134}
{"text": "Figure 13.4\n \n3D layout in a user interface (Java Studio Enterprise 8)\n \nIn addition to these \u201cstatic\u201d arrangements, many user interfaces include right-click, context pop-up menus, pop-up windows, or \u201chot\nkeys\u201d that extend the \u201cstatic\u201d layouts. Some of them summarize important actions, which were originally spread throughout different\nmenus and now are pulled together in one place, while some of them introduce new commands. Figure 13.5\n \n4D layout (Maya)\n \nWith the rapid increase of mobile or handheld devices, such as cell phones and personal digital assistants (PDAs), a new kind of user\ninterface is becoming popular. Due to the fact that handheld devices impose limitations, such as small screen size, limited screen\nresolution, and cumbersome input mechanisms, their user interfaces should be categorized as page-based or layer-based. The user\nhas to search page-by-page or layer-by-layer for the required button and information. These user interfaces are still prearranged but\nembed more intelligent designs. 13.3.2 Dynamic Style of User Interfaces\n \nWebsites allow users to ask, browse, and search for information that the user would like to obtain. This kind of user interface also\nprovides menus, tabs, and some static links. Specifically, these user interfaces leave space for displaying information, and the\ninformation may embed many \u201cdynamic\u201d links, known as hyperlinks. These dynamic hyperlinks are not part of prefixed UI components\nbut are dynamic occurrences of components that guide users from one web page to another or from one website to the world. Consequently, a website needs to accept a user's query, conduct searching, and display the results with further searching links that\ndynamically depend on the displayed contents. A browser (e.g., MS Internet Explorer) can be used to access any available web object\nuniquely linked by the Unified Resource Locator (URL). T\noday, almost all organizations have their own websites and so do many\nindividuals. These websites provide different content and embedded hyperlinks to guide users to search more URLs. Web pages, with their hyperlinks and displayed content, need to have a structure, an organization, and a labeling system. The structure\ndetermines the appropriate levels of granularity for the information units. The organization involves grouping those components into\nmeaningful and distinctive categories. The labeling system can be used for figuring out what to call those categories for the series of\nnavigation links that lead to them.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 148", "position": 148, "chunk_type": "semantic", "token_estimate": 384}
{"text": "The organization involves grouping those components into\nmeaningful and distinctive categories. The labeling system can be used for figuring out what to call those categories for the series of\nnavigation links that lead to them. Since many web pages belong to organizations and individuals, a web page could be designed and\nimplemented by professionals or laymen. Some websites provide logical structures that help users find answers and complete tasks\nwith relative ease. Others lack any intelligible organization and are difficult to navigate. In other words, the assessment of the quality of\nthis kind of user interface often mixes the concept of the \u201ctraditional\u201d user interface with the information structure of the contents. With the rapid growth of the Internet and wireless networks, e-business and m-business are based on web applications and web\nservices and are increasing rapidly. Their user interfaces are the environment in which online users conduct communication,\ninformation searches, and transactions. They are not only web pages with hyperlinks but they also dynamically support users' interactive\ninput and output. These user interfaces deal with more complicated software systems, supported by the so-called three-tier\narchitecture, and depend on the dynamically changed market and business logic. Their look and feel should satisfy both customers' and\nentrepreneurs' expectations. 13.3.3 Customizable Style of User Interfaces\n \nA developing trend of user interfaces is the customizable style. This style of user interface is tightly integrated with the entire software", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 148", "position": 148, "chunk_type": "semantic", "token_estimate": 235}
{"text": "system. A simple example is the Windows calculator shown in Figure 13.1. The user interface of the calculator has a menu labeled: \u201cView.\u201d Click this menu item and a pull-down menu pops up with an option: \u201cStandard\u201d or \u201cScientific.\u201d If the user selects \u201cStandard,\u201d the\ncalculator will provide a much simplified user interface without the sophisticated scientific functions, as shown in Figure 13.6. That is,\nsuch a customizable user interface can make the calculator easy to be used either by pupils in elementary schools or by scientists for\ntheir research. Figure 13.6\n \nThe \u2014Standard\u2014 version of Windows calculator\n \nThis means that the entire software system supports all needed functions with a specific customizable user interface. Many user\ninterfaces that belong to the static style also have some setting functions for customizing the user interface appearance, such as text\ncolors, contents of tool bars, etc. However, they do not change the functionality provided via the user interface. More customizable user interfaces are being developed. Eclipse and NetBeans are typical examples. These software systems have a\nmain part and a set of plug-in modules. The modules can be attached for increasing functionality of the entire system. For example,\nNetBeans is used for developing Java applications. It has attachable modules for developing specific software including Mobility Pack,\nVisual Web Pack, Enterprise Pack, C/C++ Pack, Profiler, and UML modeling. When these modules are added, the user interface is\ntailored accordingly. Figure 13.7 shows the user interface of the NetBeans IDE after adding some plug-in modules. This type of design provides a lot of\nbenefits for users. We can imagine that in the future, users will only pay a small amount for buying (or free-downloading) the main body\nof a software system. Whenever they need additional functions, they can buy, rent, or freely download some extra modules. This style of\nuser interface can satisfy users' expectations. The numerous widgets available for the Mac OS Dashboard interface are another good\nexample. 13.3.4 No User Interfaces\n \nUltimately, user interfaces as we known them today, may be replaced by new technology such as multitouch sensors, brain electrode\nconnections, as well as audio input that can be used to interactively access the underlying computers without static user interfaces\n(Han, 2006). Figure 13.7\n \nAfter adding plug-in modules (NetBeans)\n \nMultitouch sensing enables a user to interact with a system with more than one finger at a time, as in chording and bimanual\noperations.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 149", "position": 149, "chunk_type": "semantic", "token_estimate": 402}
{"text": "system. A simple example is the Windows calculator shown in Figure 13.1. The user interface of the calculator has a menu labeled: 13.3.4 No User Interfaces\n \nUltimately, user interfaces as we known them today, may be replaced by new technology such as multitouch sensors, brain electrode\nconnections, as well as audio input that can be used to interactively access the underlying computers without static user interfaces\n(Han, 2006). Figure 13.7\n \nAfter adding plug-in modules (NetBeans)\n \nMultitouch sensing enables a user to interact with a system with more than one finger at a time, as in chording and bimanual\noperations. Such sensing devices are also inherently able to accommodate multiple users simultaneously, which is especially useful for\nlarger interaction scenarios such as interactive walls and tabletops. The technique is force sensitive, and provides unprecedented\nresolution and scalability that can be used to create sophisticated multipoint widgets for displaying panels large enough to\naccommodate both hands and multiple users. This technique offers the ability to make computing more accessible to children, seniors,\nand populations unfamiliar with traditional computer interfaces. 13.4 Usability (Semantics) of User Interfaces\n \nThe semantics of user interfaces mainly refers to usability, consistency, and integration (Torres, 2001). Usability is the key attribute that\ndetermines the quality of a user interface. Whatever the software system, be it a simple calculator, an IDE, or a website, a beautiful user\ninterface does not mean that the software system has a high degree of usability. An engineering student may only derive 30% usability\nfrom the standard version of the Windows calculator shown in Figure 13.6 because the standard version does not support required\nfunctionalities for scientific calculations. At the same time, an elementary school student may derive only 50% usability from the", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 149", "position": 149, "chunk_type": "semantic", "token_estimate": 288}
{"text": "scientific version of the Windows calculator shown in Figure 13.1 because the student never uses the advanced scientific functions. The: customizable interface of the calculator, which can switch from the \u201cstandard\u201d version to the \u201cscientific\u201d version, illustrates an idea that\nsignificantly increases the usability of the interface. That is, the usability of a user interface depends not only on the architecture of the\nuser interface and the entire software system, but also refers to the needs, experiences, and capabilities of the system users. Usability also includes information presentation since the purpose of most systems is to input commands and watch for new\ninformation returned by the system. Presentation may simply be a direct representation of the input information, such as text in a word\nprocessor, or it may present the information in some other more meaningful way, such as information returned by web pages as\nimages or even videos. This is an important point in the dynamic style of user interfaces. The usability of a user interface reflects the usability of the entire software system. Web pages where partial user interface is\nembedded in the contents of the information require structure, organization, and a labeling system. Their combinations support\n\u201cfindability.\u201d Thus, if users cannot find what they need through a combination of browsing and searching, the website fails. A properly\ndesigned information architecture is required to effectively support findability (Rosenfeld and Morville, 2002). As we can imagine,\ninformation architecture is a mixture of science and art; designers have to deal with the complexity and ambiguity of natural languages,\nand they must rely on their experience, intuition, and creativity. An important factor that increases complexity is related to the\nexponential growth of information. A study at the University of California at Berkeley found that the world produces one to two billion\ngigabytes of unique information per year (Rosenfeld and Morville, 2002). The classification of the information is built on the foundation\nof natural languages. Unfortunately, natural languages are inherently ambiguous. For example, if a paper has an \u201cInformation\nT\nechnology\u201d phrase in its title, should the paper belong to the discipline of IT (information technology), IS (information systems), or CS\n(computer science)? Similarly, how should a paper with \u201cInformation Security\u201d in its title be categorized? The labeling system can also\nbe misleading if labels are buzzwords of categories. There are no classification systems that can create unique categories.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 150", "position": 150, "chunk_type": "semantic", "token_estimate": 397}
{"text": "scientific version of the Windows calculator shown in Figure 13.1 because the student never uses the advanced scientific functions. The: The labeling system can also\nbe misleading if labels are buzzwords of categories. There are no classification systems that can create unique categories. Additionally, users often lack a clear idea of what they may be looking for and they also have an uncertain category labeling system in\nmind. Furthermore, embedded hyperlinks are often idiosyncratic and personal in nature. They provide browsing paths for you to find\nwhat you like, but after tracking a certain number of links you may find that you either entered an unexpected website or you could not\nfind a way back to your starting point. 13.5 Design Considerations of User Interfaces\n \nBased on the preceding discussion, a user interface can be viewed as a mixture of engineering and art. Human beings know how to\nappreciate artwork. However, individuals have their own angles from which they view it. All of this makes the design and\nimplementation of user interfaces difficult. Nevertheless, from the evaluation of existing user interfaces and the analysis of the syntax\nand semantics of user interfaces, we can at least find a direction for designing a \u201cbest\u201d user interface. That is, a user interface that is\nboth user and service-providers oriented. In order to approach this direction, the user interface should be customizable, component-\nbased, and apply the separating rule: to separate the user interface from the underlying software logic. Consequently, the following\nmajor design considerations and implementation processes are key. \u2022   User-centered: As pointed out previously, user interface design must take into account the needs, experiences, and capabilities of\nthe system users. A user interface must be a user-centered product. The key is to apply the user-centered methodology that involves\nusers early and often throughout a product's development. It means involving users in all processes including planning, identifying\nrequirements, design, construction, product evaluation, and deployment. In order to understand users' needs, prototyping is an\nessential step. The prototype of a user interface should be available to users, and feedback from users should be incorporated into\nthe final product. \u2022   Intuitive: No matter how many variants there are, the central attributes remain the same: simplicity, intuitiveness, and usability. The\n\u201cbest\u201d user interface is one that people can figure out how to use quickly and effectively even without instructions.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 150", "position": 150, "chunk_type": "semantic", "token_estimate": 394}
{"text": "scientific version of the Windows calculator shown in Figure 13.1 because the student never uses the advanced scientific functions. The: \u2022   Intuitive: No matter how many variants there are, the central attributes remain the same: simplicity, intuitiveness, and usability. The\n\u201cbest\u201d user interface is one that people can figure out how to use quickly and effectively even without instructions. Graphical user\ninterfaces are better than textual user interfaces in the sense that a graphical user interface usually consists of windows, menus,\nbuttons, and icons, and is operated by using a mouse. The layout of these components is usually consistent, and over time users\nlearn hidden and advanced features. Once a user establishes a comfortable interaction approach, the experiences can be\ntransferred across other graphical user interfaces. \u2022   Consistency: Designers must consider the physical and mental limitations of users of the software system. They need to recognize\nthe limitations on the size of short-term memory and to avoid overloading users with information. User interface consistency reduces\nthe probability of errors. Consistency supports usability. User interface consistency refers to either or both syntax and semantics. Consistency means that the software system is expected to be consistent with itself and with other software on the same platform or\nin related domains. An interface's commands and menus should have the same format, parameters should be passed to all\ncommands in the same way, and command punctuation should be similar. For example, a user interface cannot be designed to have\na panel for [0-9] digits with a digit order that is different than some common devices like a phone's digits panel. Even in two user\ninterfaces, it is not advisable to use \u201cAlt + a\u201d to mean \u201cAccept the input\u201d in one user interface and to mean \u201cAbort the transmission\u201d in\nanother. The interface should use terms and concepts drawn from the experience of the anticipated class of users; should be\nconsistent in that comparable operations can be activated in the same way; should not have behaviors that can surprise users;\nshould include mechanisms to allow users to recover from their mistakes; and should incorporate some form of context-sensitive\nuser guidance and assistance. \u2022   Integration: Integration is another important factor that supports the usability of user interfaces. The software system should\nintegrate smoothly with other applications. For example, different editors in the Windows operating system, such as MS Notepad and\nMS Office applications, can use \u201cClipboard\u201d commands (Cut, Copy, and Paste) to directly perform data interchange.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 150", "position": 150, "chunk_type": "semantic", "token_estimate": 411}
{"text": "scientific version of the Windows calculator shown in Figure 13.1 because the student never uses the advanced scientific functions. The: The software system should\nintegrate smoothly with other applications. For example, different editors in the Windows operating system, such as MS Notepad and\nMS Office applications, can use \u201cClipboard\u201d commands (Cut, Copy, and Paste) to directly perform data interchange. MS Word can\nlaunch the PDF (Adobe Portable Document Format) package to convert documents from Word to PDF format. The printing manager\ncan send the data to a printer and also to a file. Maya's import and export commands can accept an image file created by other\napplications or export a scene file to other software systems. The Paint software can convert an input GIF (Graphics Interchange", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 150", "position": 150, "chunk_type": "semantic", "token_estimate": 126}
{"text": "Format) image to different formats like JPEG (Joint Photographic Experts Group). The Java Studio Enterprise IDE can draw a UML: (Unified Modeling Language) diagram based on the code of a project. These integrations extend the usability of one application,\nenhance the usability of the other, and greatly impact the design and organization of the user interface. The integration of a user interface is also reflected in the usage of its components. In what situation is a radio button or a check box a\nproper choice? Under what conditions is a slider a better choice than a radio button? The answer depends on the nature of the\nfunctions of the software. \u2022   Component-oriented: In addition to consistency and integration, component-oriented architecture should be applied in the design\nof the user interface. A user interface is a sophisticated software system. Some software systems contribute 50% of their code to the\nuser interface. Therefore, the design of the user interface will have the same requirements as the design of the main body of the\nsoftware system. It is important that a user interface be modular, incorporating the component-oriented philosophy. Modules can be\neasily modified and replaced without ramifications to other parts of the system. For example, an IDE system is able to plug-and-play\ncomponents, such as a word spelling checker, a coloring subsystem, a compiler, or a library of a different programming language. Gradually, these well-defined software components can be manufactured as reusable and adaptable components for common\nsharing. \u2022   Customizable: Customizable user interfaces require that the architecture of the entire software system be based on component-\noriented philosophy in order to incorporate plug-in modules. Let us take the Eclipse IDE as an example. The architecture of the\nEclipse software package is based on Eclipse Modeling Framework (EMF), which unifies Java, XML (Extensible Markup\nLanguage), and UML technologies so that they can be used together to build better customizable and integrated software tools. Extensibility and integration are its paramount goals. It allows many different people to independently extend the software in ways we\ncould not even previously imagine. For supporting its customization, its integration includes user interface integration (the ability of\nindependent extensions to contribute to a single user interface) and asset integration (the ability of the persistent files produced and\nused by various extensions to be managed by common resource management mechanisms). The development work in Eclipse is\ndivided into three main projects: the Eclipse Project, the T\nools Project, and the T\nechnology Project.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 151", "position": 151, "chunk_type": "semantic", "token_estimate": 413}
{"text": "Format) image to different formats like JPEG (Joint Photographic Experts Group). The Java Studio Enterprise IDE can draw a UML: For supporting its customization, its integration includes user interface integration (the ability of\nindependent extensions to contribute to a single user interface) and asset integration (the ability of the persistent files produced and\nused by various extensions to be managed by common resource management mechanisms). The development work in Eclipse is\ndivided into three main projects: the Eclipse Project, the T\nools Project, and the T\nechnology Project. The Eclipse Project is divided\ninto three subprojects: the Platform, the Java Development T\nools (JDT), and the Plug-in Development Environment (PDE). The T\nools\nProject defines and coordinates the integration of different sets of categories of tools based on the Eclipse platform. The T\nechnology\nProject provides an opportunity for researchers, academics, and educators to become involved in the ongoing evolution of Eclipse. The Eclipse Platform is a framework for building IDEs. It is described as \u201can IDE for anything, and nothing in particular.\u201d The addition\nof specific tools (plug-ins) extends the framework and collectively defines a particular IDE. A plug-in in the Eclipse IDE is a component or basic unit of function. A plug-in includes everything needed to run the functionality\nprovided in a manifest file, named plugin.xml, which declares the interconnections to other plug-ins, among other things. The Eclipse\ncore includes a class, named Plugin, which represents a plug-in component. The attribute plugin on the top-level of the class Plugin can\nbe identified in the manifest file. When a plug-in component is used for the first time, an object of the Plugin class is instantiated. Through the object, the plug-in's resource bundle, its location, and the platform's logging facilities can be accessed (Budinsky et al.,\n2004.) \u2022   Separation: User interfaces are tightly integrated with the underlying software system through their architecture for supporting the\nsystem. However, they are intended to be separated from the logic of the system through its implementation for increasing reusability\nand maintainability. According to the MVC (Model-View-Controller) model, if we separate the View (the user interface) from the Model (the logic of the\nsoftware system), then based on the same functionalities of the software system, we can design different user interfaces depending on\nthe system users' needs, experiences, and capabilities. The same set of data could be displayed using different information\nrepresentation, such as data shown as either a bar diagram or a pie diagram.", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 151", "position": 151, "chunk_type": "semantic", "token_estimate": 410}
{"text": "Format) image to different formats like JPEG (Joint Photographic Experts Group). The Java Studio Enterprise IDE can draw a UML: According to the MVC (Model-View-Controller) model, if we separate the View (the user interface) from the Model (the logic of the\nsoftware system), then based on the same functionalities of the software system, we can design different user interfaces depending on\nthe system users' needs, experiences, and capabilities. The same set of data could be displayed using different information\nrepresentation, such as data shown as either a bar diagram or a pie diagram. This separation allows designers to change the\ninformation representation on the user's screen without having to change the underlying computing functions and the logic of the\nsystem. In addition, requirements of the user interface team will not be tightly coupled with the requirements of the logic design team. This criterion is especially important for those service providers who deal with a dynamically changing environment, such as the market\nand the business logic. Therefore, this criterion has been widely used in the design of web applications and also is important for\ngeneral user interfaces such that the same internal functionality of software may support textual, graphical, or other kinds of user\ninterfaces for satisfying users' needs. \u2022   Information representation: The same data or information can be represented in using different shapes, colors, digital or analog\nsigns, and so on. For making design decisions, a number of factors must be taken into account: (1) Is the user interested in precise\ninformation or in the relationships between different data values? If precise numeric information is required, information should be\nrepresented as text or tables. If the relationship is more important than the numeric data, then graphical diagrams are preferred. (2)\nHow quickly do the information values change? Should the change in a value be indicated immediately to the user? If the information\nvalues are changed quickly and the user should observe the changes immediately, text display or slider type of graphical display with\nscales should be used. (3) Must the user take some action in response to a change in information? Depending on whether the user\nis interested in relative or absolute changes, graphical or textual display is preferred and an action mechanism should be provided,\nsuch as a button or a menu. Dynamically varying numeric information is usually best presented graphically using an analog\nrepresentation like gauge displays in car dashboards. Very large amounts of information are better visualized graphically.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 151", "position": 151, "chunk_type": "semantic", "token_estimate": 411}
{"text": "Format) image to different formats like JPEG (Joint Photographic Experts Group). The Java Studio Enterprise IDE can draw a UML: Dynamically varying numeric information is usually best presented graphically using an analog\nrepresentation like gauge displays in car dashboards. Very large amounts of information are better visualized graphically. The presentation may be used to navigate through the information\nor as a way of exposing relationships that are not obvious from the raw data. Examples include weather information, a model of a\nmolecule, etc. Systems for information visualization rely on high-performance computers, color graphics, and some specialized\nequipment, such as a virtual reality helmet display, data glove, and the like. \u2022   Friendliness: Friendliness is embedded in any aspects listed previously, from the look and feel to the usability. Besides supporting\na complete set of functions including redo functions, customizable settings, hot keys, and so on, it should also include features such", "domains": ["Software Quality Attributes"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 151", "position": 151, "chunk_type": "semantic", "token_estimate": 150}
{"text": "as tutorials, search engines, help facilities, or updating links.: \u2022   Summary: In summary, the user interface should satisfy five major principles, with the acronym SAPCO: simple, aesthetic,\nproductive, customizable, and other (Torres, 2001). \u2022   Simple means that a user interface does not require use of a book or online help in order to get started with simple tasks. It is\nsufficiently intuitive that a user need only be told once how to operate using the user interface. \u2022   Aesthetic refers to appearance and appeal. For example, all components in the user interface are arranged symmetrically, following\na popular style, and clearly cut into groups based on their roles from very frequently used to very rarely used, or from very simple\nfunctions to very complicated functions. \u2022   Productive indicates that a minimal number of work steps can accomplish a task. A user interface should be able to tolerate small\nmistakes, such as supporting redo functions, and following conventions, such as mouse left-click, right-click, single-click, double-\nclick, and drag-and-drop. \u2022   Customizable allows individual users to select from various available forms in order to suit personal preferences and needs,\nincluding customizable user interfaces, settings, and status lines. \u2022   Other implies that beyond these principles there are countless other principles available. The majority are variants of the SAPC. 13.6 Enabling Technology\n \nAs discussed in Chapter 1, software architecture is regarded as \u201cthe description of elements that comprise a system, the interactions\nand patterns of these elements, the principles that guide their composition, and the constraints on these elements.\u201d This description\nalso applies to the software architecture of a user interface, with regards to its elements and compositions. This is mainly a design\naspect; traditionally, enabling technology belongs to the implementation aspects. However, due to the fact that the drag-and-drop\nmetaphor is widely used and can automatically generate required codes for all UI components and their compositions in user\ninterfaces, designers can directly use the metaphor to build up a blueprint for a user interface. Thus, selecting and using an enabling\ntechnology is no longer a \u201cpure\u201d implementation aspect. More importantly, as we have discussed, organizing components to create a\nuser interface can be an art. We need to understand this art and determine how to map it into an engineering practice.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 152", "position": 152, "chunk_type": "semantic", "token_estimate": 377}
{"text": "as tutorials, search engines, help facilities, or updating links.: More importantly, as we have discussed, organizing components to create a\nuser interface can be an art. We need to understand this art and determine how to map it into an engineering practice. The points of\nthis understanding include what type of components should be used, how to arrange them in terms of syntax (look and feel), and what\nthe architecture of the user interface should be in terms of semantics (usability, consistency, and integration). Therefore, both user\ninterface designers and implementers need to have the required knowledge of enabling technologies and how to apply them in creating\na user interface. Here, we will focus on the relationships between the principles we have discussed and what can be used to realize\nthese principles, which is the goal of this section. Some customizable and component-oriented graphical user interfaces, such as Eclipse or NetBeans IDEs, are built from the ground up\nwith a module- or component-oriented architecture. This kind of architecture not only deals with software module integration but also\nwith user interface integration, or the ability of independent extensions to contribute to a single user interface. T\no realize this integration,\nthe graphical user interface itself must be made of components. Currently, many programming languages directly support the design and implementation of user interfaces by integrating components. The Java programming language is one of these kinds of programming language. Java is a \u201cpure\u201d object-oriented programming\nlanguage. It has three editions: the Java 2 Enterprise Edition (J2EE) supports enterprise applications, the Java 2 Standard Edition\n(J2SE) is suitable for general purpose applications, and the Java 2 Micro Edition (J2ME) can be used for developing applications for\nhandheld devices, such as PDAs and cell phones. All three editions have rich sets of UI components for making graphical user\ninterfaces, layout managers for organizing the components according to the designer's requirements, and listeners that listen to the\nevents when users access the components in the graphical user interfaces. Listeners trigger event handlers to perform the functions of\nthe corresponding components. That is, the components and layout managers fulfill the look and feel needs of a graphical user\ninterface, while the events link the users' actions with the internal logic of the software system. This loosely coupled mechanism makes\nthe customizable user interfaces and the separating principle possible.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 152", "position": 152, "chunk_type": "semantic", "token_estimate": 392}
{"text": "as tutorials, search engines, help facilities, or updating links.: That is, the components and layout managers fulfill the look and feel needs of a graphical user\ninterface, while the events link the users' actions with the internal logic of the software system. This loosely coupled mechanism makes\nthe customizable user interfaces and the separating principle possible. With its popularity, many powerful IDEs that support Java\nprogramming language come in handy for using the drag-and-drop metaphor to build up user interfaces. Designers can directly\ndescribe the look and feel of a user interface easily. In J2SE edition, Java provides two packages for all GUI components. One package is java.awt (Abstract Windows T\noolkit), which\ncontains all components that are automatically mapped to platform-specific elements through their respective agents, known as peers. These components are prone to platform-specific bugs because the peer-based approach relies heavily on the underlying operating\nsystem. AWT is fine for developing simple graphical user interfaces, but not for developing comprehensive GUI projects. Since Java 2,\nthe java.awt GUI components were replaced by a more robust, versatile, and flexible package known as javax.swing. Swing\ncomponents are painted directly by Java code, except the components java.awt.Window and java.awt.Panel. Swing\ncomponents rely less on the underlying platform and are referred to as lightweight components. These components are categorized\nand described in the following subsections. 13.6.1 Containers\n \nThe package javax.swing provides the three top-level container classes, JFrame, JApplet, and JDialog. Each Java GUI has\nat least one top-level container. This top-level container is the root of a containment hierarchy.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 152", "position": 152, "chunk_type": "semantic", "token_estimate": 257}
{"text": "Figure 13.8\n \nInternal structure of a JFrame\n \n \nFigure 13.9\n \nThe intermediate containers in Java\n \nJFrame is used for standalone Java applications, while JApplet is widely used in Web applications. The internal structure of a JFrame\nhas four layered panes as shown in Figure 13.8. The root pane, layered pane, and glass pane are required to organize the menu bar\nand the content pane. The content pane is the main container in all frames, applets, and dialogs which adds all visible components in\nthat top-level container. Swing provides several general-purpose intermediate containers as shown in Figure 13.9. These intermediate containers can group\nrelated components together as a unit by using any layout manager. The one most often used is JPanel. Others include JScrollPane\nthat provides scroll bars around a large of extendable component; JSplitPane that displays two components in a place, letting the user\nadjust the amount of space for each of them; JT\nabbedPane that contains multiple components but shows only one at a time; and\nJToolBar that holds a group of components in a row or column, allowing the user to drag it. Figure 13.10\n \nBorderLayout and BoxLayout\n \n13.6.2 Layout Managers\n \nAll container classes have layout managers for general use. The layout managers include BorderLayout, BoxLayout, CardLayout,\nFlowLayout, Grid-BagLayout, GridLayout, AbsoluteLayout, and NullLayout. Every content pane is initialized to use a BorderLayout. In\nFigure 13.10, a BorderLayout (a) places components in up to five areas: top, bottom, left, right, and center. All extra space is placed in\nthe center area. A BoxLayout (b) puts components in a single row or column. It respects the components' requested maximum sizes\nand also lets designers align components. A CardLayout lets designers implement an area that contains different components at different times. A CardLayout is often controlled\nby a combo box. The state of the combo box determines which panel (card) the CardLayout displays. In Figure 13.11, (a) shows card 1\nthat contains a JT\nextArea component in a CardLayout, while (b) shows card 2 that contains a JT\nable in the same CardLayout. A\nFlowLayout is the default layout manager for every JPanel. It simply lays out components in a single row, starting a new row if its\ncontainer is not sufficiently wide, as shown in (c). Figure 13.11\n \nCardLayout and FlowLayout", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 153", "position": 153, "chunk_type": "semantic", "token_estimate": 380}
{"text": "Figure 13.12\n \nG\nridLayout and G\nridBagLayout\n \n \nFigure 13.13\n \nAbsoluteLayout\n \nIn Figure 13.12 a GridLayout (a) simply makes a group of components equal in size and displays them in the requested number of rows\nand columns. A GridBagLayout (b) is a sophisticated and flexible layout manager. It aligns components by placing them within a grid of\ncells, allowing some components to span more than one cell. The rows in the grid can have different heights, and grid columns can\nhave different widths. An AbsoluteLayout, shown in Figure 13.13, lets designers specify an absolute location for components. The components can be\nmoved around and resized using their selection border. An AbsoluteLayout is particularly useful for making prototypes since there are\nno formal limitations and designers do not have to enter any property settings. The NullLayout shown in Figure 13.14 is similarly useful\nfor making prototypes since it means no layout management for components. However, both Absolute-Layout and NullLayout are not\nrecommended for production applications due to the fact that the fixed locations and sizes of components do not change when the\nenvironment changes. For example, if the size of the container changes, the location of some components may be changed arbitrarily\nunder the AbsoluteLayout manager as shown in Figure 13.13 (b), while some components may be partially missing under the\nNullLayout manager as shown in Figure 13.14 (b). Figure 13.14\n \nNullLayout\n \n13.6.3 Major UI Components\n \nAll subclasses of the JComponent class are the components needed for building graphical user interfaces. These UI components can\nbe added into containers, such as JFrame, JApplet, and JPanel as previously described. T\no illustrate, some selected components are depicted as follows. A Button is a component that triggers an action event when clicked. Swing provides JButtons, JRadioButtons, JCheckBoxes, (shown in Figure 13.15), and JT\noggleButtons. JRadioButtons support a\nmutually exclusive choice while JCheckBoxes support a multiple choice. For making a choice from a list of items, Swing provides JComboBoxes and JLists (shown in Figure 13.16). A JComboBox will pop-up\na list of items when users click on the expanding arrow so that it saves the space of user interfaces. A JList explicitly displays a set of\nitems. Both components allow single or multiple selections. Figure 13.15\n \nJButton, JRadioButton, and JCheckBox\n \n \nFigure 13.16\n \nJComboBox and JList", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 154", "position": 154, "chunk_type": "semantic", "token_estimate": 380}
{"text": "Figure 13.17\n \nJTable, JTextArea, and JTree\n \n \nFigure 13.18\n \nJColorChooser and JFileChooser\n \nFor organizing texts, Swing provides JTables, JTextAreas, JTrees (shown in Figure 13.17) and JTextFields. Swing supports two major choosers as shown in Figure 13.18 The JColor-Chooser organizes all colors for selections. It is composed\nof two separate areas. One area is a set of color chooser panels with three panels that allow a color chooser to be selected among\nSwatches, HSB, and RGB. The other area is a preview panel that visually communicates the selected color. JColorChooser is typically\ndisplayed in a dialog box, but since it is a component, it can be contained in any container. The JFileChooser supports three display\nmodes: file only, directories only, and files and directories. It comes with both single and multiple selections. Specific files or types of\nfiles can be filtered from a file chooser. Understanding these components and their layout managers helps designers decide when and how to use these components and their\ncompositions for designing a graphical user interface. Moreover, in J2EE edition, JavaServer Faces supports UI components for\ndeveloping web applications and services; in J2ME edition, it supports specially designed UI components available for developing\nGUIs for a variety of mobile devices. 13.6.4 Event Listeners\n \nEvent listeners are the linkages between the UI components and the internal logic of the software system. Functions of a UI component\nare triggered by users' actions, such as entering the mouse into the area of the component, clicking on the component, or exiting from\nthe area of the component. The process for making the component accept users' actions, called events, and performing its functions\ntakes three phases. The first phase, the register phase, occurs at compile time. In this phase, the component is registered with an\nevent listener. The event listener has an event handler. The functions of the event handler are the codes in the event handler. Designers\nand implementers design the functions and provide the codes during compile time. The second phase, known as the capture phase,\nhappens at runtime. When users access a component, such as clicking on it, the event is captured by the event listener. The event\nlistener stimulates the event handler. This brings in the third phase, the action phase, to perform the functions of the component, such as\ninvoking the internal logic of the software system for the users.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 155", "position": 155, "chunk_type": "semantic", "token_estimate": 393}
{"text": "The event\nlistener stimulates the event handler. This brings in the third phase, the action phase, to perform the functions of the component, such as\ninvoking the internal logic of the software system for the users. That is, graphical user interface design and implementation is based on\nthe event-driven philosophy. From this description we can see that the Java event model consists of three types of elements: the event object (the signal), the source\nobject (the component that fired the event), and the event listener object (the event handler for performing the functions). Different types\nof components associate with different types of events. Different types of events are generated by different users' actions. Each of the\nevents has a corresponding event listener. 13.6.5 A Case Study\n \nLet us take the standard version of Windows Calculator as an example. By using the IDE of NetBeans, we can design and implement\nthe graphical user interface of the Calculator easily as shown in Figure 13.19. The IDE has a palette on the rightmost column of its GUI\ncontaining all JComponents defined in Swing. The middle column of its GUI is the design form of a JFrame or a JPanel. Simply drag-\nand-drop the components from the palette and put them on the form; a graphical user interface of the Calculator will be built up quickly. In Figure 13.19, we have placed a JMenubar with a JMenu, a JT\nextfield, and seven JButtons. The properties of each component, such\nas the label text, the color, the size, etc., can be edited in the properties window located on the rightmost column of the IDE's user\ninterface.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 155", "position": 155, "chunk_type": "semantic", "token_estimate": 271}
{"text": "Figure 13.19\n \nImplementing the G\nUI of a Calculator using NetBeans\n \n \nFigure 13.20\n \nThe codes of the Calculator are generated automatically. At the same time when the component is placed on the JFrame, the corresponding codes are generated automatically by the IDE as\nshown in Figure 13.20. This step sets up the look and feel of the graphical user interface in implementation. After the layout of the components, the next step is to build up the linkage between the components in the user interface with the\nfunctionalities of the internal logic of the software system. As discussed in the previous section, this takes three phases. For example, if\nusers click the button with the label \u201cC\u201d (Clear) in the GUI of the standard calculator, then all information displayed in the JT\nextField will\nbe erased. This is done by an ActionListener that has been associated with the button \u201cC\u201d. The ActionListener has an\nactionPerfomed() event handler, which will erase all information displayed on the JT\nextField as shown in Figure 13.21. Further\ndiscussion of the implementation of event listeners is beyond the scope of this chapter. Figure 13.21\n \nThree phases of an event listener\n \n13.7 Direct Manipulation\n \nAll user interfaces that we have discussed to this point belong to a type of user interface known as direct manipulation interface. It\nallows users to interact with objects via the use of a pointer. Almost all user interfaces of word processors or screen editors fall into this\ncategory. The information space of word processors is composed of a sequence of paragraphs that are presented to the user as a\ndocument. T\no insert text, the cursor is positioned at the appropriate place in the display and text is typed. Users get immediate\nfeedback on their actions. Mistakes can often be detected and corrected quickly. Many actions performed using choices on menus are\navailable via direct manipulation. For example, dragging a document icon to a desktop printer icon directly prints the document. Other\nactions, such as move, copy, delete, and link, are also performed via direct manipulation. Another example of direct manipulation interfaces is a form-based interface. This kind of user interface is gaining popularity with the\nincreasing popularity of web applications and web services. Figure 13.22 shows a web application for conducting a survey. It asks\nusers to fill out a form by typing in the information requested.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 156", "position": 156, "chunk_type": "semantic", "token_estimate": 396}
{"text": "Figure 13.22\n \nA form-based user interface\n \nDirect manipulation supports users to interact with the software through direct actions. Modifications to the presented information\nimmediately change the state of the system and the displayed information. Its advantages include:\n \n\u2022   Learning time is relatively short due to its simplicity. \u2022   It is intuitive and users are not intimidated by it. \u2022   Mistakes can often be detected and corrected quickly. Other kinds of manipulations include clipboard, shortcut keys, access keys in menus and dialogs, and mouse-keyboard augmentations. Although useful, these mechanisms are not considered essential features of graphical user interfaces. 13.8 Evaluation of User Interfaces\n \nPart of the software system quality assurance process is concerned with an evaluation of the user interface design. This evaluation\nfocuses on the defects in user interface features, the usability of the interface, and the degree to which it meets users' requirements. Possible usability attributes of a user interface include:\n \n\u2022   How long does it take a new user to become productive with the user interface? For example, a new user can master the usage of\nthe user interface in a three-day training seminar. \u2022   What percentage of the user interface components and the system functions are usable for users? For example, some components\nof the user interface and functions of the system are \u201credundant.\u201d\n \n\u2022   What is the user's observation of the look and feel of the user interface? For example, the user may operate the user interface\nwithout looking at it, the system is well implemented with consistency and integration, and the system uses colors to distinguish\nimportant information. \u2022   How effective is the user interface at recovering from user errors? For example, the system can check spelling and automatically\ncorrect spelling errors. The system can format source codes and automatically import packages. The system can redo 50 step\nactions. \u2022   Can the user interface be customized and adapted to a new environment? For example, the user interface can be switched from one\nversion to the other for different users. The user interface can incorporate additional components with plug-and-play. \u2022   How well does the system response match the user's work practice? For example, a right-click context sensitive menu saves user's\nactions. \u2022   How tolerant is the system of user error? For example, what happens if the user accidentally clicked two components or hit three\nkeys at the same time? Will the system be aborted?", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 157", "position": 157, "chunk_type": "semantic", "token_estimate": 398}
{"text": "For example, what happens if the user accidentally clicked two components or hit three\nkeys at the same time? Will the system be aborted? \u2022   Is the user interface complete? For example, the system also includes a user guidance, tutorials, and help tools. Systematic evaluation of a user interface design can be an expensive proposition. Surveying users via questionnaires or some other\nsimple methods can be relatively cheap. Simpler approaches can use a group of volunteers to discover and correct many problems of\nthe user interface design and implementation. 13.9 Summary", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 157", "position": 157, "chunk_type": "semantic", "token_estimate": 91}
{"text": "User interfaces are an integral part of a software system. Sometimes, it determines the market value of the software. There are two\nmajor kinds of user interfaces: textual and graphical. In general, users better recognize graphical user interfaces. The quality of a user\ninterface is characterized by its look and feel and its usability. Quality results from a mixture of engineering practice and art. All user\ninterfaces are serving users, including information providers, in certain circumstances. Therefore, a user interface is a user-centered\ndesign product. Consequently, design and implementation of user interfaces must satisfy users' requirements. In addition, user\ninterfaces themselves usually are sophisticated software. Their design and implementation should follow the general software\nprinciples, including object-oriented and component-oriented architecture. 13.10 Self-Review Questions\n \n1. A user interface is mainly for accepting inputs, conducting computations, and displaying outputs. a. True\n    b. False\n2. Chapter 3 of this book, on \u201cmodels for software architecture,\u201d has nothing to do with user interfaces described in this chapter. a. True\n    b. False\n3. User interface refers to static components and their layout, not dynamically displayed information. a. True\n    b. False\n4. The MVC model suggests the separation of the user interface from the logic of the software system. a. True\n    b. False\n5. Which of the following is true for implementing the separation of the user interface from the logic of the software system? a. Increases reusability. b. Eases maintainability. c. The same contents can be accessed by different kinds of user interfaces. d. The business logic and the user interface can be modified without affecting each other. 6. The look and feel of a user interface can be defined by using engineering rules. a. True\n    b. False\n7. A customizable user interface is not a good style since it will confuse users. a. True\n    b. False\n8. The usability of a user interface is enhanced by consistency and integration. a. True\n    b. False\n9. The acronym SAPCO describes\n    a. the structure of user interfaces\n    b. the market values of user interfaces\n    c. the satisfactory principles of user interfaces\n    d. the development process of user interfaces\n10. The Java programming language supports graphical user interface components, layout managers, and event listeners, all needed\nfor designing and implementing user interfaces. a. True\n    b.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 158", "position": 158, "chunk_type": "semantic", "token_estimate": 377}
{"text": "a. True\n    b. False\nAnswers to the Self-Review Questions\n \n1. b 2. b 3. b 4. a 5. all 6.b 7.b 8. a 9. c 10. a\n \n13.11 Exercises\n \n1. What are the differences between the static and dynamic graphical user interfaces? 2. What are the special features of the technique of multitouch sensors? 3. Why is the MVC model important for designing user interfaces? 4. List as many as possible existing user interface examples that implement consistency and integration principles. 5. The Eclipse Modeling Framework (EMF) is a methodology for developing customizable and integrated software tools and their\nuser interfaces. What are its major points? 6. What techniques can be used to involve users in planning, requirements, design, construction, product evaluation, and\ndeployment of a user interface? 7. Why do we need to apply component-oriented philosophy to designing user interfaces? 8. Estimate the usability of an example software system referring to different users with different experiences and capabilities. 9. Is Java programming language suitable for designing and implementing user interfaces? 10. Search your own name by using a search engine. Do you satisfy the returned information? 13.12 Challenge Exercises\n \n1. Implement the user interface of the TI-83 Calculator, selectively implement certain computational functions, and link the functions\nwith the user interface. 2. Design and implement a website for yourself. Pay attention to its user interface and the internal structure of the information that", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 158", "position": 158, "chunk_type": "semantic", "token_estimate": 234}
{"text": "you would like to display with embedded hyperlinks.: 3. Define some specifications or conventions for implementing a well-accepted, dynamic style of user interfaces. 4. Make comments and suggestions for the EMF model and draw patterns for designing customizable user interfaces. 5. Predict the evolution of graphical user interfaces in the future. References\n \nBudinsky, Frank, David Steinberg, Ed Merks, Ray Ellersick, and Timothy J. Grose. Eclipse Modeling Framew\nork. The Eclipse Series. Gamma, Erich, Lee Nackman, and John Wiegand, eds. Boston: Addison-Wesley Professional, 2003, 2-44, 238-240. Han, Jeff. Unveiling the Genius of Multi-touch Interface Design (TED 2006), 9 min., 32 sec. From TED2006 in Monterey, CA,\nFebruary 2006. http://tedblog.typepad.com/tedblog/2006/08/jeff_han_on_ted.html. Rosenfeld, Louis and Peter Morville. Information Architecture for the World Wide Web: Designing Large-Scale Web Sites. 2nd ed. O'Reilly Media, Inc., 2002, 4-5, 211-242. T\norres, R.J. Practitioner's Handbook for User Interface Design and Development. Software Quality Institute Series. Prentice Hall\nPTR, 2001, 248-253, 263-274. Suggested Reading\n \nSun Microsystems, \u201cThe Java Tutorials.\u201d http://java.sun.com/docs/books/tutorial/.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 159", "position": 159, "chunk_type": "semantic", "token_estimate": 161}
{"text": "14 Product Line Architectures: s\n \nObjectives of this Chapter\n \n\u2022   Advance the concept of systematic reuse and its particular implementation using product lines\n \n\u2022   Discuss design considerations for product line architectures and component bases\n \n\u2022   Demonstrate the enabling technology\n \n14.1 Overview\n \nT\noday, organizations are emphasizing component-based development (CBD) to achieve the elusive goal of systematic reuse. The\nidea of systematic reuse has gained success in commercial products, creating a plethora of technological solutions to build software\nout of \u201creusable\u201d components such as OMG's CORBA, Microsoft's COM and .NET\n, and Sun's JavaBeans, mainly due to \u201cflexibility\nthrough a capability of composition.\u201d\n \nThis current focus provides a renewed interest in devising a framework for incorporating processes, methods, and technology to\nengineer robust applications by interconnecting prefabricated components. One result of such an approach is the notion of product line\nsoftware architectures and their supporting library of reusable components, or componentbase. This chapter presents product line\narchitectures and component bases as a way of institutionalizing systematic reuse.1 It discusses motivation, benefits, and technical\nsupport for the modeling and development processes. The concepts of product line architecture (PLA) and of reusable componentbase (CB) have become dominant themes for addressing\nsystematic reuse. These two themes implement two critical design features necessary for systematic reuse to work: design-for-\ncommonality and control-of-variability. Design-for-commonality forms the basis for reusability and standardization by identifying those\ncrosscutting aspects that are typically present in the systems in a given domain. Design-for- variability anticipates variation without\ncompromising commonality, capturing the way these aspects may vary from one product to another and providing plug-in compatibility\nvia standard interfaces to achieve control-of-variability. A domain is an area of expertise with particular specialized tasks organized into systems where all tasks work towards a common\ngoal, such as MS Office Suite. A PLA provides a common architecture framework as a design model that standardizes and maximizes\nthe reuse potential of all software artifacts generated during the development process of systems within a given domain. At the same\ntime, it clearly identifies variation points. These artifacts include requirements, designs and patterns, and the actual software\ncomponents. * A reusable componentbase specifies common functionality across families of systems with direct control of variability. 14.2 Introduction and Motivation\n \nIn today's post-PC era, new artifacts and systems are increasingly software- driven.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 160", "position": 160, "chunk_type": "semantic", "token_estimate": 383}
{"text": "14 Product Line Architectures: * A reusable componentbase specifies common functionality across families of systems with direct control of variability. 14.2 Introduction and Motivation\n \nIn today's post-PC era, new artifacts and systems are increasingly software- driven. Plummeting hardware costs are leading to rapid\ngrowth in many new application areas all of which depend on well-engineered software for their continuing functioning; they require\nmore software to be built and in shorter time frames. However, for many such systems each time a new product is built, routine\nfunctionality is custom written repeatedly from scratch. Typically, development takes place according to the standard stovepipe\napproach. This conventional approach contributes to higher demands for more software since quality and productivity suffer. For some time now there has been an explicit recognition of the need for building software based on reusable components, paving the\nway for systematic reuse. The goal of systematic reuse is to produce quality software products consistently and predictably by moving\ntoward an asset- supported development approach. In short, we need to move our focus from engineering single systems to\nengineering families of systems by identifying reusable solutions within a collection of related products. These collections are called\nsoftware product lines. Product line is defined as a collection of applications sharing a common, managed set of features that satisfy the specific needs of a\nselected market to fulfill an organization's mission.2\n \n14.2.1 Software Reuse and Product Lines\n \nEarlier definitions of software reuse include the following:\n \n\u201cRe-use is considered as a means to support the construction of new programs using in a systematical way existing designs,\ndesign fragments, program texts, documentation, or other forms of program representation.\u201d3\n \n\u201cReusability is the extent to which a software component can be used (with or without adaptation) in multiple problem solutions.\u201d4,5", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 160", "position": 160, "chunk_type": "semantic", "token_estimate": 294}
{"text": "From these definitions, we can highlight three important aspects:\n \n1. Reuse is not an end in itself but a means to an end. Systematic reuse refers to the organized creation of common assets with controlled variability that forms the basis for building\nsystems in a domain of expertise by assembling them (systematically) from these reusable assets. 2. Reusable assets are not limited to code components. *\nReusable assets include any artifact produced during the development cycle and serve as templates for the generation of the\nvarious work products during product development. T\no assure higher probability of success, assets should be organized around\nongoing business activities or domains, such as specific mission areas, areas of expertise, or core competencies (e.g.,\ncommand and control, automotive, web development, etc). 3. Software components may need adaptation. Assets must adapt to particular problem solutions at reuse time. This process requires original design effort only once, and it can\nbe applied in two ways:\n\u2022   Adaptive design: use known, established solution principles adapting the embodiment to the requirements. It may be\nnecessary to perform original design on some individual parts or components. \u2022   Variant design: arrangements of parts or components and other product properties (size, etc.) are varied within the limits set\nby a previously designed product structure. From this discussion we can also see that reuse actually occurs both within and across product lines, a notion discovered earlier and\nassociated with the concepts of horizontal and vertical reuse. The notions of horizontal and vertical reuse have been formally\nincorporated in the CORBA software construction technology. The top layers of the CORBA architecture specify standard objects that\ncan be shared by applications across domains; they are known as the Horizontal CORBA Facilities. Standard objects that are\nreusable within products in a given domain are referred to as the Vertical (Domain) CORBA Facilities. This is illustrated graphically in\nFigure 14.1\n \n \nFigure 14.1", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 161", "position": 161, "chunk_type": "semantic", "token_estimate": 316}
{"text": "\u2022   reduces cycle time and cost of new products by eliminating redundancy and by producing them from common assets;\n \n\u2022   reduces risk and improves quality by using trusted components;\n \n\u2022   manages its legacy assets more efficiently;\n \n\u2022   evolves a common marketing strategy and strengthens core competency around strategic business investments and goals; and\n \n\u2022   makes decisions based on the (worth of) the asset base and the strategic goals. This approach represents another evolutionary step in the development of the software field. It is a move in the right direction toward the\nmore encompassing aim of attaining industrial-strength software engineering, a necessary condition that naturally leads to systematic\nreuse as in other engineering fields. 14.2.2 Methodologies, Processes, and Tools\n \nA technological solution to the systematic reuse problem covers anything that can be used to help you produce software. This includes\nmethodologies and accompanying processes, techniques, and tools. A methodology refers to a specific approach to developing software as an overarching set of guiding principles, or a way of doing\nbusiness for building software. Methodologies also have an impact on an organization and the way people work in teams. For example,\nachieving systematic reuse requires making reuse an organization-wide strategy, not a project-centered one. The entire organization\nmay need to be redesigned to align with the \u201cdomain- model building and product construction processes\u201d that are needed to support\nsystematic reuse as illustrated in Figure 14.3 In a reuse-based methodology, products are \u201cderived\u201d from generic or solutions models. A process specifies a list of activities and the work products produced, so that if followed carefully, it increases the likelihood of\nproducing better software. The Software Engineering Institute at Carnegie Mellon University has put extensive effort into this area with\nsignificant results. The process models produced cover the entire spectrum ranging from the corporation as a whole with the Capability\nMaturity Model for Software (Sw-CMM)7 to the Personal Software Process (PSP) and the T\neam Software Process (TSP)*8,9 More\nrecently industry is also focusing on process, although at a higher level than the CMM, and we see efforts on the Rational Unified\nProcess (RUP). On the process front, the focus of systematic reuse is to provide specific activities for: (1) design-for-reuse\u2014the\ncreation of reusable assets; and (2) design-with-reuse the creation of individual products out of these reusable assets.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 162", "position": 162, "chunk_type": "semantic", "token_estimate": 384}
{"text": "The process models produced cover the entire spectrum ranging from the corporation as a whole with the Capability\nMaturity Model for Software (Sw-CMM)7 to the Personal Software Process (PSP) and the T\neam Software Process (TSP)*8,9 More\nrecently industry is also focusing on process, although at a higher level than the CMM, and we see efforts on the Rational Unified\nProcess (RUP). On the process front, the focus of systematic reuse is to provide specific activities for: (1) design-for-reuse\u2014the\ncreation of reusable assets; and (2) design-with-reuse the creation of individual products out of these reusable assets. Figure 14.3\n \nModeling/development duality\n \nThe techniques and tools directly support the production of the various artifacts by packaging known best practices. The current focus\nis mostly on object orientation, as explained earlier in this book, and modeling techniques and tools are all gravitating around the\nobject-oriented paradigm. One such tool (and language) that has become an industry standard is the Unified Modeling Language\n(UML). In fact, UML actually encompasses OO techniques with more traditional techniques, some seemingly orthogonal to others, such\nas state diagrams and flowcharts (known as activity diagrams in UML). The platform is a set of subsystems and technologies that provide a coherent set of functionality that any product supported by that\nplatform can use without concern for the details of how the functionality provided is implemented. Product line designs should strive to\nbe platform independent as much as feasible, although this is a relative concept. The actual products, however, are platform-specific\nproducts. A product line can be supported by one or more platforms. A model of the architecture is a description or specification of that system and its environment. Product line architectures capture\ncommon high-level structures of related products for building products, identifying common assets, and defining the means for\nconnecting these assets. They allow integration of optional/alternative components. There is a strong relationship between a\ncomponent model and architecture constraints. Product line engineering results from using a domain-driven, model-based methodology for building software. A model-driven\napproach to software development prescribes certain kinds of models to be used, how those models may be prepared, and the\nrelationships between the different kinds of models. Product line engineering is a model-driven approach because it provides a means", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 162", "position": 162, "chunk_type": "semantic", "token_estimate": 374}
{"text": "for using models to direct the course of understanding, designing, constructing, deploying, operating, and continued evolution and: modification of the software systems within the given domain. A PLA provides structural organization of the assemblage of\ncomponents that are needed to build products in a domain. This structure is a standardized topology of how components are\nconnected and how they interact to provide functionality for applications in the domain. The PLA is a generalized architecture for\neffective reuse across a given domain. The Object Management Group (OMG), formed to help reduce complexity, lower costs, and hasten the introduction of new software\napplications, has introduced the notion of the Model Driven Architecture (MDA) framework. The approach starts with the well-known\nand long-established idea of separating the specification of the operation of a system from the details of the way that system uses the\ncapabilities of its platform. MDA provides an approach, and enables tools for:\n \n\u2022   specifying a system independently of the platform that supports it;\n \n\u2022   specifying platforms;\n \n\u2022   choosing a particular platform for the system; and\n \n\u2022   transforming the system specification into one for a particular platform. PLA documented using DMA specifications will lead the industry towards interoperable, reusable, portable software components and\ndata models based on standard models. PLA together with MDA allow for long-term flexibility to be maximized:\n \n\u2022   Implementation: since the PLA is less platform-specific, new (\u201chot technology\u201d) infrastructure can be accommodated. \u2022   Integration: integration bridges can be automated. \u2022   Continued evolution: access to systems specification and design for future features make \u201cmaintenance\u201d simpler. \u2022   Testing and simulation: models can be used to generate valid requirements and simulate (executable specification) target system. 14.3 Product Line Engineering: Design-for-Reuse\n \nIn this section we focus on the process needed to support product development following a product line approach. The process is\nmultiplexed to correspond to the various product lines. This approach achieves design-for- commonality and control-of-variability by\nestablishing a reuse infrastructure;that is, an overall framework that integrates the corresponding set of modeling, planning, and asset\nconstruction activities necessary for systematic reuse, and that, at the same time, allows the effective assimilation of technology. Fundamentally, it has the effect of reducing variance and increasing homogeneity, two essential aspects observed from disciplines that\nhave moved into industrialization. Modeling is an important practice in increasing homogeneity. The domain modeling process\nprimarily includes domain analysis and architectural design to produce a generic problem description.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 163", "position": 163, "chunk_type": "semantic", "token_estimate": 400}
{"text": "for using models to direct the course of understanding, designing, constructing, deploying, operating, and continued evolution and: Modeling is an important practice in increasing homogeneity. The domain modeling process\nprimarily includes domain analysis and architectural design to produce a generic problem description. It is clear that two sets of complementary activities are required: modeling generic solutions and product development by applying\nthese solution models. Generative product development can be applied, whereby the developer states requirements in abstract terms\nand a generator produces the desired system or component. The causal relationship between building model solutions, on the one\nhand, and constructing actual products from these models, on the other, directly supports the modeling-first/development-second\nduality, whereby development focuses on setting problems in terms of known solutions and not building products from first principles. This approach provides a sound basis for industrial-strength software engineering. Within the duality of modeling development,\nproducts are created by instantiating models and by integrating prefabricated artifacts. We refer to this methodology or approach as\nmodel-based development. In this way, one part of the development process (front part) is a development-for-reuse process for creating reusable software assets. The complementary back-end part refers to a development-with-reuse process to create specific systems with these prefabricated\nassets. The former is like performing original engineering (using first principles) to new tasks and problems that are realized by\nsynthesizing new solution principles and sometimes by inventing completely new technology; this process requires careful technical and\neconomic analyses. This development-for-reuse process creates reusable software assets by carefully analyzing the features provided\nby a family of systems in a domain, and subsequently designing a generic architecture (PLA) and the components implementation, that\nis, a corresponding CB. It primarily involves an investment for future work (efforts to create assets for future software development), and\nit basically focuses on building \u201cgeneric\u201d models, even at the code level.10 Thus, the focus is one of analysis and design of variability\nwithin a set of products and the analysis and design of commonality across products. This takes special consideration of contextual\ndifferences to allow an asset to cater to the variability found in the various products, while designing for commonality across products. 14.4 Product Development: Design-with-Reuse\n \nThe latter, back-end development process is referred to as routine practice, involving the application of known solutions to solve\nreoccurring problems, thus becoming more of a routine activity mapping from needs to solutions rather than a synthesis activity of\nbuilding from scratch.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 163", "position": 163, "chunk_type": "semantic", "token_estimate": 407}
{"text": "Figure 14.4\n \nProduct development activities\n \nIn order to describe the process more clearly, we use the formalism introduced by Gunter et al.11 in their reference model for\nrequirements engineering to label the various artifacts produced during the process of PLA generation and product instantiation. In this\nmodel, the primary information elements manipulated are in the Domain Knowledge {W}, which encompasses known facts about the\ndomain environment or outside World. The domain modeling activity (see following) is constrained by the chosen scope {d} thus\nsubsetting the domain knowledge to the specific set of products {Wd} based on strategic goals and organizational mission. The\nRequirements {R} define needs from an end-user point of view of a specific product. The resulting specification {S} is produced as a\nprecise description of {Wd} from where an optimal Product {P} can be built. The target platform, or Machine, {M} provides the specific\ncomputing environment(s) on which the delivered products and assets will execute. The various representations of W, R, and S contain models from different viewpoints. Each of these models highlights different aspects\nof the world, needs, and requirements, and they are collectively referred to as domain models. Domain models describe typical\nsystems features, including functional and nonfunctional, as well as mandatory and optional features. A domain model formalizes\nknowledge about existing systems and requirements for new systems, all represented using information modeling techniques such as\nobject models (use cases are very useful here) and feature models. They may also form the basis for business process reengineering. Models are subject to validation and verification before being put on a baseline. Model V&V, as well as product V&V, are carried out\nthrough a continuous cycle. One of the most critical questions is to be able to define correct, unambiguous, and useful mappings\nbetween all these sets of conceptual elements and generated artifacts. For example, it follows that\n \n\u2022   S  R  Wd, and that S \n M * P, where\n \n\u2022   {W + R} = abstract problem model,\n \n\u2022   {S + M} = concrete problem model,\n \n\u2022   G = generic solution model, and\n \n\u2022   P = concrete solution model. A complete analysis of these equations is beyond the scope of the current chapter. Interested readers should look at Sw-CMM. In what follows we describe the basics of the essential activities grouped into three main, natural phases known as product line\nanalysis, product line design, and product line implementation.", "domains": ["Domain-Driven Design"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 164", "position": 164, "chunk_type": "semantic", "token_estimate": 399}
{"text": "arise from differences in capabilities, operating environments, domain technology, and implementation techniques, that is, a range of: possible implementations within the domain. A specific product implementation would thus provide a consistent set of feature values\ndescribing its capabilities. Recently, and due to the popularity of use case modeling, researchers and practitioners have been linking the notion of features to use\ncase models. Groups of use cases can be used to model features. The mapping covers all possibilities for features modeling. Thus,\nsome use cases can be optional while others can be alternate; scenarios within a particular use case may also be optional or there can\nbe alternate ones; the same goes for the flow of events within a particular scenario, that is, it can vary or may be optional. Interested\nreaders should look at the work of Eriksson. *\n \nSection 14.5 contains an example of a product line analysis of the domain of traffic management. 14.4.2 Product Line Design: Design-for-Commonality and Control- of-Variability\n \nDomain design focuses on a common architecture of related systems in such a way that design models become the means for system\nconstruction and for incremental growth. This common architecture is a PLA, a high- level architecture with an explicit identification of\nthe points of variation (hot spots) and corresponding component flexibility, thus focusing on design-for-commonality and control-of-\nvariability. As defined in this book, the architecture design process produces architectures that specify products and components. It refers to\n\u201cmodularizing\u201d for component-based development, thus increasing the probability that significant portions of the products can be built\nfrom standard parts (components) as specified in the design model. The resulting designs make tradeoffs between function (domain\nmodel) and form (domain design), and between generality and specificity. The architecture model proposes a \u201cbest fit\u201d high-level\narchitecture style(s) for the kind of problems in hand. The design contains details of specific behavior and systems properties (such as\ntimeliness, and other SWaP** constraints) complete enough that they can be subject to analytical tools. Design-for-commonality forms the basis for standardizing assets to build products in a domain of expertise by encapsulating common\nfeatures of related products, and by defining a common architecture for related products. In this way, design-for-commonality translates\ninto a:\n \n\u2022   a common structure of related products (PLA);\n \n\u2022   a specific design created by instantiating a common design;\n \n\u2022   a clearly coordinated role in meeting a common need; and\n \n\u2022   a product implemented by the identified reusable components.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 165", "position": 165, "chunk_type": "semantic", "token_estimate": 406}
{"text": "arise from differences in capabilities, operating environments, domain technology, and implementation techniques, that is, a range of: Design-for-commonality forms the basis for standardizing assets to build products in a domain of expertise by encapsulating common\nfeatures of related products, and by defining a common architecture for related products. In this way, design-for-commonality translates\ninto a:\n \n\u2022   a common structure of related products (PLA);\n \n\u2022   a specific design created by instantiating a common design;\n \n\u2022   a clearly coordinated role in meeting a common need; and\n \n\u2022   a product implemented by the identified reusable components. Control-of-variability is the basis for providing flexibility in the assets to meet requirements for a variety of products without\ncompromising commonality. It requires careful design to include appropriate levels of parameterization, generalization and\nspecialization, and extension. Like commonality, adaptability must be engineered a priori, and thus, analysis must explicitly identify\nvariations that anticipate adaptations. Control-of- variability results into:\n \n\u2022   a specification of optional components;\n \n\u2022   clearly specified alternate structures; and\n \n\u2022   parameterized context dependencies. Optional parts are very important. Possible combinations of optional features must be supported by the PLA and the flexibility\nincorporated in the component design, otherwise it may be impossible to reuse an asset \u201cas-is\u201d because commonality and specificity\nare mixed. This would make it necessary to modify the asset when reused in the new context, and this should obviously be avoided\nwhenever feasible. As we saw earlier in this book, components interact via architecture connections specified by protocols. Thus, connections are\nrelations among components. This happens at two levels, namely at the static level as context dependencies, and at the dynamic level\nfor control and data flow. Rapide,13 an architecture description language, makes this distinction explicit: an Object Connection\nArchitecture specifies collaborations as runtime message exchanges, whereas an Interface Connection Architecture defines\nconnections between the components of a system using only the interfaces. The design activities are supported by system/software\narchitecture technology, most notably Architecture Description Languages or ADLs. Component design is supported by Interface\nDefinition Languages or IDLs. Finally, the quality of the products is maintained through rigorous analysis and prediction, continuous improvement and refinement, and\nthrough designed experimentation and feedback from observations of actual systems generated from the generic solutions (the\nPLA/CB). The Attribute-Driven Design (ADD) method is a method for designing the software architecture of a product line to ensure\nthat the resulting products have the desired qualities. The ADD method is based on the following:\n \n\u2022   Both functional and quality requirements must be specified.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 165", "position": 165, "chunk_type": "semantic", "token_estimate": 415}
{"text": "decomposition are validated against both the functional and quality requirements. The steps at each stage of the decomposition are:: 1. \u2022   Choose architecturally significant requirements, that is, the combination of quality, business, and functional goals that \u201cshape\u201d\nthe architecture. 2. \u2022   Choose patterns and children component types to satisfy drivers. Choose the solutions that are most appropriate for the high-\npriority qualities. 3. \u2022   Instantiate children design elements and allocate functionality from use cases using multiple views. 4. \u2022   Identify commonalities across component instances. 5. \u2022   Validate quality, functional requirements, and any constraints. 6. \u2022   Refine use cases and quality scenarios as constraints to children design elements. \u2022   The relationship between qualities and the architecture patterns that achieve those qualities can be codified and catalogued. The ADD method has been used for application domains ranging from information systems to embedded systems. 14.4.3 Product Line Implementation: Configuration Model and Componentbase\n \nThe domain implementation includes selection of suitable target platforms, the partitioning and allocation of functionality among\nhardware/ software components, and the implementation of the various components that populate the system architecture. The\nimplementation activities define the solution space with all their possible combinations. Domain implementation also includes a\nprocess for the creation of reusable software (code) components and their storage and retrieval in the domain library. Domain\nimplementation is supported by component composition technology, most notably Module Interconnection Languages such as Ada and\nJava. *\n \nDesign models describe the generic solutions that are the result of PLA design. Implementation models include configuration models\nwith specific information to support adaptation. A configuration model maps between the problem models and solution models in terms\nof product construction rules. These rules translate capabilities into implementation components, and describe legal feature\ncombinations, default settings, etc. For example, certain combinations of features may be not allowed; also, if a product does specify\ncertain features, some reasonable defaults may be assumed and other defaults can be computed based on some other features. The\nconfiguration model isolates abstract requirements into specific configurations of components in a PLA. The domain libraries contain\ngeneric solutions and components that for a given target platform M satisfy the set of needs described by reference requirements or\ndomain model. It involves the use of product line languages, code generators, and component libraries. The componentbase specifies common functionality across families of systems with direct control of variability. There are different\nways to control variability: class hierarchies, generators, generic parameters (templates), libraries, configurations, etc.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 166", "position": 166, "chunk_type": "semantic", "token_estimate": 409}
{"text": "decomposition are validated against both the functional and quality requirements. The steps at each stage of the decomposition are:: The componentbase specifies common functionality across families of systems with direct control of variability. There are different\nways to control variability: class hierarchies, generators, generic parameters (templates), libraries, configurations, etc. Components in\nthis way imply some form of code, and, from this viewpoint, architecture components are relevant at two levels: at the static or source-\nmanagement level, and at the dynamic or execution level. Quite explicitly, the term component is being used to refer to this static nature\nas the \u201cunit of software deployment,\u201d whereas \u201cobjects\u201d capture software's runtime behavior. Thus, \u201ccomponents and objects together\nenable the construction of next generation software.\u201d14 Several definitions of this kind of components abound; they address granularity,\ncontextual dependencies, and explicit, as well as implicit, interfaces. Two fundamental component characteristics that affect composition ability and reuse payoff are scope and granularity. A component's\nscope can be domain independent, product line, or product specific. A component's granularity has two dimensions, namely fine-\ngrained (small-scale) and coarse-grained (large-scale) granularity. The former is typically found in domain-independent components,\nwhereas the latter are typical of application subsystems, or semifinished applications (such as frameworks). Component functionality\nhas less to do with the size of it, but reuse profit is directly proportional to size. A domain-independent component has a general-purpose focus with broad applicability to many domains (across boundaries). These\ncomponents are almost entirely abstract data types such as list managers, mathematical functions, user-interface toolkits, and\ndatabase management systems. The term horizontal reuse commonly refers to domain-independent components. More recently, these\nissues have reached the programming level with the notion of \u201cadapters\u201d and aspect-oriented programming. Product line components have more limited applicability and are especially reusable within a specific domain. The term vertical reuse\nis used to refer to these components. The semantics of the component are domain dependent and hence have little or no use outside\ndomain. These are things like packages that compute taxes, flight control laws, scheduling routines, etc. Such product line components\nmake certain assumptions about how they will be used, reducing generality but increasing its usability. This refers to the traditional\nconflict between design-for-reuse and design-with-reuse.15\n \nProduct-specific components may be reusable within a product line, but they are specific to a product. The semantics of the component\nare bound to a specific application type. The product line may dictate a generic architecture, and component roles will be developed to\nfit it.", "domains": ["Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 166", "position": 166, "chunk_type": "semantic", "token_estimate": 415}
{"text": "decomposition are validated against both the functional and quality requirements. The steps at each stage of the decomposition are:: The semantics of the component\nare bound to a specific application type. The product line may dictate a generic architecture, and component roles will be developed to\nfit it. Typical product- specific components are entire architectures developed internally or in-house. This means that the organization is\ndeveloping for reuse and providing services internally. Hence it does not have a company barrier between service providers and\ncustomers. There are also externally developed product line components. This means that the organization is developing for reuse and\nproviding services on the external market and hence does have a company barrier between service providers and customers, which\ncomplicates communication. Each component is a means of achieving one or more reusability features. They must have syntactically and semantically clear\nspecification (separate from implementation) and independence from environment (e.g., parametric coupling). A component\nspecification captures its functional description and operability (parameters, conditions, etc.). A description of the connections among\nthe interface elements and level of parameterization and kind of extension (e.g., parametric polymorphism vs. inheritance) enhances\nadaptability. Users of higher-level components may instead develop their own lower-level components to create the parameters", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 166", "position": 166, "chunk_type": "semantic", "token_estimate": 205}
{"text": "needed to instantiate the higher-level component.: 14.4.4 Heuristics\n \nHere are some guidelines to address many of the issues discussed. The tradeoff between generality vs. specificity is also related to\ncomplexity and specificity. The fundamental problem is to produce generic models that are useful, to the point where routine\nengineering can be brought to bear. The focus is in reducing complexity, uncertainty, and ambiguity at the same time that we strive to\nproduce specifiable, adaptable concepts. The difficulty is in making feasible concepts work, resolving conflicts, and making all the\npieces fit. During analysis the greatest impact on the preliminary system definition (or product line specification) is at the interfaces. This focus\nallows us to highlight important distinctions with conventional development. These are:\n \n\u2022   analysis identifies, most notably, the variability in the set of systems in the domain\n \n\u2022   separates optional features from the essential, necessary ones, but anticipates new requirements\n \n\u2022   no feature redundancy but provides alternate uses of needed features\n \n\u2022   implementation features not imposed on existing technology\n \nDesign produces architectures to specify products and components in the form of a high-level design solution. An architecture model or\nhigh-level design for products in the domain is developed. Detailed design and component construction can be done from this model. The focus is on modularizing for a product line, that is, design for commonality and control of variability. This increases the probability\nthat significant portions of the products can be built from standard parts as specified in the design model. \u2022   Avoid constraining design unnecessarily. For example, hierarchies that are too shallow do not allow sharing and commonality\nsuffers. \u2022   Avoid simplifying design unnecessarily. For example, hierarchies that are too deep do not control variability effectively and also lose\ncommonality. \u2022   Enhance iteration between function (domain model) and form (domain design). Form follows function in the sense that product line\nanalysis is feature-based whereas design is form-based. Product lines are designed from the top down, driven by function instead of\nform. \u2022   Enforce strict layering. Objects enforce encapsulation by hiding local variables and local functions. The idea is to permit changes to\nan object's implementation without triggering changes to other objects (by keeping its specification \u201cclean\u201d). Design encapsulation,\non the other hand, is the form of encapsulation that is required for software component technology. It is the hiding of design decisions\nwithin \u201clayers.\u201d Unlike object encapsulation, design encapsulation is not (currently) enforceable by language processing tools.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 167", "position": 167, "chunk_type": "semantic", "token_estimate": 405}
{"text": "needed to instantiate the higher-level component.: Design encapsulation,\non the other hand, is the form of encapsulation that is required for software component technology. It is the hiding of design decisions\nwithin \u201clayers.\u201d Unlike object encapsulation, design encapsulation is not (currently) enforceable by language processing tools. Interfaces across levels make the distinction between design encapsulation and object encapsulation clear: higher-level components\nutilize lower-level ones, hence users of higher-level component reuse the lower-level ones. New capabilities offered to the user can be introduced through prototyping of new system components (possibly utilizing different\nimplementation technology). Such prototypes coexist alongside the operational system and may get hardened through incremental\nreengineering. 14.4.5 Software Technology for Systematic Reuse\n \nThis section describes the technological aspects of systematic reuse processes. While we do not discuss specific technology in detail,\nwe suggest a road map for its application in the various phases and outline problems that have surfaced, especially in relation to\nobject-oriented technology and systematic reuse. We explicitly show the different kinds of models needed during modeling and\ndevelopment, at the same time that we show each of the different levels of abstraction needed for PLs. The models represent the\ndifferent stages of product development ranging from requirements to implementation, whereas the levels of abstraction indicate the\ndegree of domain information incorporated in the artifact being reused. In general, we need modeling methods and specification\nlanguages; architecture styles, frameworks, architecture description languages; and component meta- models, patterns, and\ncomponent description languages. All these models then serve as the basis for requirements and design analysis for a specific\nproduct, and they support creation of component libraries. Figure 14.5 illustrates this. In this figure we juxtapose software technology with product generation stages. The x-axis, \u201cproduct\nartifacts,\u201d plots software technology used to model the different product artifacts generated during the production process; these\nmodels range from high-level artifacts such as requirement models to more specific implementations such as components and\nsystems. Thus, product artifacts fall into three categories, namely requirements models, architecture models, and component models.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 167", "position": 167, "chunk_type": "semantic", "token_estimate": 336}
{"text": "They specify how to implement a product or a part of it by extending the framework with appropriate\ninstantiations of some specific \u201cplug-ins\u201d and \u201chot- spots\u201d; the latter refers to variability identified in the requirements. More recently, the\nfocus has been on higher-level abstractions called object- oriented patterns (specially designed patterns). These are abstract\ndescriptions of solutions that work within a given context, allowing developers to reuse successful \u201cworking principles.\u201d In this sense,\nframeworks are concrete realizations of patterns, and patterns are abstract descriptions of frameworks. Collections of interrelated\npatterns form pattern languages, an \u201cinformal\u201d communication tool to share architecture knowledge relating how the various individual\nsolutions may work together to solve a larger problem. Variation points can be explicitly identified as abstract classes. Although the principle of reuse is at the center of object-oriented development, and the technology does provide superior technical\nsupport for code reuse, object-oriented programming is simply not enough for large-scale systematic reuse.16 Reusing code artifacts\nhas the least amount of reuse payoff. Also, object hierarchies do not directly support the definition of families of systems. A more\nfundamental problem is that systems are not being designed for reuse; thus, because of object-orientation focus on code, it is not easy\nto design the system architecture a priori, that is, before components (e.g., classes) are built. For instance, architecture patterns and\nframeworks cannot be created before the actual components (classes) that they connect do exist. This, however, may not be a serious\nproblem since we expect to have a library of components to begin with. The real question is the identification of the components in the\nfirst place and the way they fit together in an architecture. Also, objects in a class library are potentially reusable, but problems arise\nwhen we try to interface them with the outside world. 14.5 Sample Product Line Analysis\n \nThe following example of product lines is based on the Universal Traffic Management Society of Japan established in 1993 for the\nachievement of a safe, comfortable, and environment friendly automotive society. The following subsections refer to Figure 14.5\n \n14.5.1 WHY: Mission and Strategic Goals\n \nTraffic management needs can be grouped as follows, each serving a different constituency:\n \n\u2022   law enforcement and education", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 168", "position": 168, "chunk_type": "semantic", "token_estimate": 369}
{"text": "strategy: warning information at roads\ntraffic planning\ndriving information about neighboring vehicles\ncontrol parameters\ndriving information on high-speed traffic", "domains": ["Design Patterns"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 170", "position": 170, "chunk_type": "semantic", "token_estimate": 19}
{"text": "Controlling elements: Controlled elements\nroute guidance\npedestrians (including wheel chairs)\narterial/wide area traffic control\nthe environment\nintersection traffic control\npublic transportation (including taxis)\nlane oriented traffic control\ncommercial vehicles\nzone oriented traffic control\nemergency vehicles\ngrade crossing\nspecial vehicles (governor,s, pope,s)\n \nDomain analysis will identify the various systems features, commonalities, and differences. The domain design will identify a high-level\narchitecture with an explicit identification of the points of variation (hot-spots) and corresponding component flexibility. 14.6 Ultra-Large-Scale Systems\n \nSoftware is moving in two directions at once. It is simultaneously becoming found everywhere and growing very, very large. Software is\nincreasingly of public importance, and high-quality software is becoming critical to our daily lives, our safety and security, and the\nnational and global economies. Software is also increasingly becoming very complex. Its systems are characterized by thousands of\nplatforms, sensors, and actuators affecting decision makers and connected through heterogeneous wired and wireless networks. These systems are pushing fast and far beyond what can be comprehended, with thousands of millions of lines of code; hundreds of\nthousands of people employing the system for different purposes; the amount of data stored, accessed, manipulated in the billions (so-\ncalled data tsunami); thousands of connections and interdependencies among architecture components. They are being called\nultralarge-scale systems (ULS).17\n \nAccording to the SEI report, characteristics that will distinguish ULS systems from large monolithic systems include:\n \n\u2022   Operational independence of elements: component systems are independently useful. \u2022   Managerial independence of elements: component systems are acquired and operated independently. \u2022   Evolutionary development: they are not created fully formed but come into existence gradually. \u2022   Emergent behavior: behaviors are not localized to any component system. \u2022   Geographic distribution: components are geographically distributed. Furthermore, the characteristics of ULS systems that will develop because of their scale include:\n \n\u2022   decentralization of data, development, evolution, and operational control;\n \n\u2022   inherently conflicting, unknowable, and diverse requirements;\n \n\u2022   continuous evolution and deployment; and\n \n\u2022   heterogeneous, inconsistent, and changing elements. Finally, the design of ULS systems\n \n\u201cbroadens the traditional technology-centric definition of design to include people and organizations; social, cognitive, and\neconomic considerations; and design structures such as design rules and government policies.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 170", "position": 170, "chunk_type": "semantic", "token_estimate": 356}
{"text": "models to be able to build new systems as variations of \u201cold\u201d systems. A prime example of this promising technology can be observed: in the development of CORBA and its recent focus on domain technology. There are currently eight vertical-domain task forces and\nspecial groups, and a wealth of information can be found at OMG's website. * This in turn promotes the development of new, higher-\nlevel domains as illustrated in Figure 14.5 With these important efforts we are at the brink of finally beginning to have product line\nengineering handbooks, a most critical component of an industrial-strength engineering discipline for software. Organizations must invest in creating models of the common capabilities of related software products. Organizations use these models\nas software assets supporting the creation of products that meet increasingly changing requirements. The former is a development-for-\nreuse process to create software assets, whereas the latter is a development-w\nith-reuse process to create specific systems with\nthese prefabricated assets. An important aspect to secure institutionalization of systematic reuse is the attainment of \u201ceconomies of scope.\u201d Component-based\ndevelopment focuses on the structure of a set of components, embodying features within a domain, leveraging prior investment to the\nmaximum degree in support of developing multiple products. Components, objects, and architectures will all be important parts of the\nnext generation of software development technologies. An architecture style is a description of component types and a pattern of their interaction. A style can be thought of as a set of\nconstraints (on the component types and on the interaction patterns) in an architecture; for example, in the client-server style, clients are\nanonymous. Architecture styles are not architectures. However they represent, in a very high-level sense, families of related systems. A\nrelated concept is that of a reference model, which specifies a division of functionality into conceptual components, a standard\ndecomposition of a known problem into parts that cooperatively solve the problem. They are characteristic of matured domains, such\nas compilers. A reference software architecture is a reference model mapped onto software components and their relations (mapping\nof functionality onto software components). One problem in design is the management of complexity. Design principles deal with complexity and are also important for component-\nbased development. These include decomposition and hierarchical structuring to increase understanding, cohesion/coupling to allow\naggregation, encapsulation to support optional parts, and abstraction/hiding to support modifi- ability. High cohesion and low coupling\nare desirable properties in any system. Heuristics deal with design issues that cannot be specified exactly in algorithmic form.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 171", "position": 171, "chunk_type": "semantic", "token_estimate": 418}
{"text": "models to be able to build new systems as variations of \u201cold\u201d systems. A prime example of this promising technology can be observed: High cohesion and low coupling\nare desirable properties in any system. Heuristics deal with design issues that cannot be specified exactly in algorithmic form. Creating a product line architecture rather than single-product unique designs directly supports a desire to implement systematic reuse. When product lines are designed to support an organization's objective or mission, we are institutionalizing reuse. The approach allows\nengineers to come up with the \u201cright\u201d solution quickly and effectively by assembling applications out of \u201cproven\u201d components. This also\nrepresents a main motivation for component-based software engineering: a desire to modularize a system in such a way that there is a\nhigh probability that significant portions of the system can be built from \u201cstandard\u201d parts\u2014at least within an application domain. Solution models represent both software and hardware architectures (components and their interfaces) suitable for solving typical\nproblems in the domain, and include PLAs and component designs. A PLA depicts the structure for the design of related products and\nprovides models for integrating optional/alternative components. Component designs specify the structure for the explicit variability of\ncomponents across products; they serve as models for specifying and encapsulating commonality. The notions of vertical and horizontal reuse have been formally incorporated in important software construction technology such as\nCORBA. The top layers of the CORBA architecture specify standard objects that can be shared by applications across domains; these\nare known as the Horizontal CORBA Facilities. Standard objects that are reusable within products in a given product line are referred\nto as the Vertical (Domain) CORBA Facilities. Object-oriented technology does provide superior technical support for code reuse. However, it by itself is not enough for\ninstitutionalized systematic reuse. Interestingly enough, claims are being made that object technology is neither necessary nor sufficient\nfor systematic component-based development. (It is worth emphasizing that component-based development seems to work with and\nwithout objects. For additional examples visit the SEI web page. *) One problem with object-oriented development is the low level of\ngranularity of the assets being reused. Furthermore, the perceived benefits of reusing patterns and frameworks will not be materialized\nunless they are taken into account by the product development process. The reason for this is that, in contrast with functionally\ndecomposed systems, object-oriented systems will not have high-level functions that map directly to the functional requirements. This\ninformation is not easily extracted from the code either since the focus there is on inheritance.", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 171", "position": 171, "chunk_type": "semantic", "token_estimate": 422}
{"text": "models to be able to build new systems as variations of \u201cold\u201d systems. A prime example of this promising technology can be observed: The reason for this is that, in contrast with functionally\ndecomposed systems, object-oriented systems will not have high-level functions that map directly to the functional requirements. This\ninformation is not easily extracted from the code either since the focus there is on inheritance. The development process for product\nline components (frameworks) should follow the traditional domain analysis process. An important change in the traditional object-\noriented analysis process to accommodate for systematic reuse is the need for a more formal variability analysis. Product line domain\nanalysis must be done (not just domain analysis of one application domain) with emphasis on variability analysis. It is also important to\nkeep domain-independent, product line, and product-specific components apart and possibly physically separate. Object-oriented systems are typically monolithic pieces with difficult-to- detach \u201ccomponents.\u201d Current object-oriented component\ntechnology (including JavaBeans, ActiveX, COM) imposes severe constraints on the components, tightly coupling them to\nimplementation infrastructure. Truly reusable components must be specified as free of constraints as possible. In summary, object technology is in fact neither necessary nor sufficient for systematic reuse. The properties of adaptability and\ncomposability are not yet automatically achieved by applying object-oriented concepts. Identifying flexibility and designing mechanisms\nthat control this flexibility are the real issues. 14.8 Self-Review Questions\n \n1. The constituent parts of the architecture of a system are:\n    a. its components, connectors, and the rules governing their interactions\n    b. its connectors, concurrency, and the rules governing their interactions\n    c. its classes, connectors, and the rules governing their interactions", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 171", "position": 171, "chunk_type": "semantic", "token_estimate": 270}
{"text": "d. its classes, concurrency, and the rules governing their interactions: ions\n2. Domain analysis identifies the various common features in a domain and their differences. a. True\n    b. False\n3. Control-of-variability forms the basis for reusability and standardization by identifying those crosscutting aspects that are typically\npresent in the systems in a given domain. a. True\n    b. False\n4. Product line processes are a way to institutionalize systematic reuse. a. True\n    b. False\n5. Design-for-commonality anticipates variation without compromising commonality. a. True\n    b. False\n6. A domain is an area of expertise with specialized particular tasks organized into systems where all tasks work toward a common\ngoal. a. True\n    b. False\n7. The goal of systematic reuse is to produce quality software products consistently and predictably by moving toward an asset-\nsupported development approach. a. True\n    b. False\n8. A software product line is a collection of components sharing a common, managed set of features that satisfy the specific needs\nof a selected system. a. True\n    b. False\n9. Reuse is not an end in itself but a means to an end. a. True\n    b. False\n10. Reusable assets are limited to code components. a. True\n    b. False\n11. Software components do not need adaptation. a. True\n    b. False\n12. Horizontal reuse refers to the use of an asset across several distinct domains or different product lines. a. True\n    b. False\nAnswers to the Self-Review Questions\n \n1. a 2. a 3.b 4.b 5.b 6. a 7. a 8.b 9. a 10.b 11.b 12. a\n \n14.9 Exercises\n \n1. Select an area of expertise (domain) you are familiar with and list five features that are common and that support horizontal reuse. 2. Select an area of expertise (domain) you are familiar with and list five features that are not common in all systems but that support\nvertical reuse. 3. Describe briefly the three main phases of product line engineering. 4. Using the definition given for artifact during product line engineering and corresponding product development, explain each of the\nfollowing relations:\nS  R  Wd, and that S \n M * P, where\n{W + R} = abstract problem model,\n{S + M} = concrete problem model,\nG = generic solution model, and\nP = concrete solution model. 5. Two fundamental component characteristics that affect composition ability and reuse-payoff are scope and granularity. a. What is a component's scope? b. What is a component's granularity? 6.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 172", "position": 172, "chunk_type": "semantic", "token_estimate": 401}
{"text": "d. its classes, concurrency, and the rules governing their interactions: What is a component's granularity? 6. Each component is a means of achieving one or more reusability features. They must have syntactically and semantically clear\nspecifications (i.e., separate from implementation) and independence from environment. Show examples of component\nspecifications using:\n    a. parameters and conditions to specify variability\n    b. inheritance to enhance adaptability\n7. Provide examples of the application of two heuristic rules for domain analysis and three for domain design. 8. Discuss the impact of current software technology on the implementation of systematic reuse and product lines in general. For\nexample, what are the advantages and disadvantages of object- orientation for large scale reuse? 9. What is model-based software engineering? 10. Establish differences between original engineering and routine practice. 14.10 Design Exercises", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 172", "position": 172, "chunk_type": "semantic", "token_estimate": 132}
{"text": "1. Perform a small-domain analysis for a domain you are familiar with using use cases and indicating:: a. optional use cases\n    b. alterative use cases\n    c. optional scenarios\n    d. alternative scenarios\n    e. optional activities\n    f. alternative activities\n(Hint: Use the approach described in \u201cSoftware Product Line Modeling Made Practical.\u201d18)\n2. Using the ADD method, perform a product line design of the domain you used in the previous exercise. Follow the four steps\nspecified by the method, namely:\n    a. Choose architecturally significant requirements. b. Choose patterns and children component types to satisfy drivers. c. Instantiate children design elements and allocate functionality from use cases. d. Identify commonalities across component instances. 3. The componentbase contains components implementing common functionality across families of systems with direct control of\nvariability. There are different ways to control variability, e.g., class hierarchies, generators, generic parameters (templates),\nlibraries, configurations, etc. From the design you have performed in the previous question, identify components in each of the\nfollowing levels:,\n    a. domain-independent\n    b. product line specific\n    c. product-specific\nReferences\n \nDiaz-Herrera, J.L., Cohen S. and Withey, J. \u201cInstitutionalizing Systematic Reuse: A Model-Based Approach.\u201d (In Proceedings of the\nSeventh Workshop on Institutionalizing Software Reuse. Chicago, 1995). Cohen, S., Friedman, Martin, Solderitsch, and Webster. \u201cProduct Line Identification for ESC-Hanscom.\u201d (CMU/SEI-95-SR-024,\nPittsburgh, Pa.: Software Engineering Institute, Carnegie Mellon University. 1995). Dusink, E.M. and Katwijk, J. van. \u201cReflections on Reusable Softw\nare and Softw\nare Components. Ada Components: Libraries and\nTools.\u201d (In Proceedings of the Ada-Europe Conference, Stockholm. Ed. by S. T\nafvelin, Cambridge University Press, Cambridge, U.K.\n1987), pp. 113-126. Hooper, J.W. and Chester, R.O. Softw\nare Reuse, Guidelines and Methods. (Plenum Press, New York, New York, 1991.) Katz, S., et al. Glossary of Softw\nare Reuse Terms. (Gaithersburg, MD: National Institute of Standards and Technology. 1994)\n \nWeiss, D. M. and C. T. R. Lai. Softw\nare Product-Line Engineering. (Addison-Wesley, Reading, MA. 1999). Sw-CMM. Software Capability Maturity Model. http://www.sei.cmu.edu/cmm/. Humphrey, W. S. A Discipline for Softw\nare Engineering. Addison-Wesley, Boston, MA: 1995. Humphrey, W. S. Introduction to the Team Softw\nare Process. Addison-Wesley, Reading, MA: 2000. Diaz-Herrera, J.L. and V. Madissetti. \u201cEmbedded Systems Product Lines.\u201d (Softwareproduct lines, ICSE Workshop. Limerick, Ireland. June, 2000). Gunter, C. A., Gunter, E. L., Jackson, M. and P. Zave. \u201cA Reference Model for Requirements and Specifications.\u201d (IEEE Software,\nMay/June 2000), pp. 37-43. Arango, G. \u201cDomain Analysis Methods.\u201d In Software Reusability. (Chichester, England: Ellis Horwood, 1994), pp. 17-49.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 173", "position": 173, "chunk_type": "semantic", "token_estimate": 399}
{"text": "1. Perform a small-domain analysis for a domain you are familiar with using use cases and indicating:: (Chichester, England: Ellis Horwood, 1994), pp. 17-49. Luckham, D., Kenney, J. J., Augustin, L. M., Vera, J., Bryan, D., and Mann, D. \u201cSpecification and Analysis of System Architecture\nusing Rapide.\u201d (IEEE Transactions on Software Engineering, 21(4), April 1995), pp. 336-355. Szyperski C. \u201cComponent Softw\nare: Beyond Object-Oriented Programming.\u201d (Addison-Wesley, Harlow, UK. 1998). M. Becker and J. L. Diaz-Herrera. \u201cCreating Product Line Libraries: a Methodology and Design Guidelines.\u201d IEEE International\nConference in Software Reuse, Rio de Janeiro, Brazil, November 1-4, 1994. Diaz-Herrera, J.L. and B. Thomas. \u201cModel-Based Systematic Reuse: an Analysis of OOT Support.\u201d (OOPSLA workshop #18 Object\nTechnology, Architecture, and Domain Analysis. 1998). Peter Feiler, et al. \u201cUltra-Large-Scale Systems: The Softw\nare Challenge of the Future.\u201d Software Engineering Institute, Carnegie\nMellon University. June 2006. Magnus Eriksson, Jurgen Borstler, Kjell Borg. \u201cSoftw\nare Product Line Modeling Made Practical.\u201d Communications of the ACM, Vol. 49\nNo. 12, 2006:49-54. * We use the term components in its most widely understood form to include requirements, software and hardware architectures, as", "domains": ["Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 173", "position": 173, "chunk_type": "semantic", "token_estimate": 183}
{"text": "Index: The index that appeared in the print version of this title does not match the pages in your eBook. Please use the search function on your eReading device to search for\nterms of interest. For your reference, the terms that appear in the print index are listed below. A\nAbsoluteLayout\nabstract models\nabstraction\nAbstraction component\nabstraction via inheritance\nAcmeAcmeStudio\n \narchitecture description\nconstructing an architecture design\nmultiple users\ncomponents\n \nconnectors\n \naction phase\nevents\n \nactivations\nactive data\nactive filter\nActive Reviews for Intermediate Designs (ARID)\nActiveX component\nactivity diagram\nactor\nadaptation\ndesign-with-reuse\n \nproduct line architecture\n \nadaptive design\nADD (Attribute-Driven Design)\nadd item\nad-hoc reuse\nADO .NET, MVC architecture\naggregation\nanalysis\nanalysis models\nanimal identification knowledge based system (KBS)\nanonymity\nApache Strut\nAPIs (application programming interfaces)\napplication server\napplication-level protocol\nArchitecture Analysis Method\nArchitecture Description Languages (ADLs)\nAcme\n \nAcmeStudio\narchitecture description\nconstructing an architecture design\nmultiple users\ncomponents\nconnectors\nrequirements for\n \narchitecture design. See software architecturedesign; software architecture design space\narchitecture pattern\narchitecture style\ncomponents\n \nimportance of\n \nModel-View-Controller (MVC)\n \nmulti-tiered architecture\n \nquality attributes\n \nbusiness attributes\nimplementation attributes\nruntime attributes\ntradeoff pairs\nArchitecture Trade-off Analysis Method (ATAM)\narchitecture view models\n4+1 view model\n \ndevelopment or module view\n \nlogical or conceptual view\n \nphysical view\n \nprocess view\n \nscenario view\n \nUser Interface (UI) view\n \nARID (Active Reviews for Intermediate Designs)\nassociation\nasynchronous communication software architecture buffered message-based software architecture\napplicable domains\nbenefits\nlimitations\nthe messaging mechanism\npartitions\nplatforms for\npoint-to-point messaging (P2P)\npublish-subscribe messaging (P&S)", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 175", "position": 175, "chunk_type": "semantic", "token_estimate": 239}
{"text": "class diagram of a message queue: complex enterprise system with JMS\nmessage listener\nmessage topics of JMS\nparts of\nP&S and P2P compared\nsequence diagram of a message queue\ntiming coupling dependency\nrelated architecture\nuses for\nnon-buffered event-based implicit invocations\n \napplicable domains\nbenefits\nclass diagram for\nlimitations\nMVC model\nrelated architecture\nSmallTalk language\nsoftware application designs for\nsynchronous vs. asynchronous invocations\nuser interface application, Java fragments\nuser-defined events, GUI event classes\noverview\n \nsummary\nasynchronous message. See also asynchronous communication software architecture\nasynchronous notification\nATAM (Architecture Trade-off Analysis Method)\nAttribute-Driven Design (ADD) method\naudio input\navailability\nAXIS Java web services\n \n \nB\nback-end tier\nball and cup (b2c or c2b) connection\nball to ball (b2b) delegation\nbatch processing\nbatch sequential architecture\napplicable domains of\n \nbenefits\n \nbusiness data processing example\n \nexample of\n \nJava program\n \nlimitations\n \nrelated architecture\n \nUnix shell script\n \nBEA WebLogic JMS\nbehavioral (dynamic) diagrams\nactivity diagram\n \ncommunication or collaboration diagram\n \ninteraction overview diagram\n \nsequence diagram\n \nstate machine diagram\n \ntiming diagram\n \nuse-case diagram\n \nblackboard architecture style animal identification knowledge based system (KBS)\napplicable domain of\n \nbenefits\n \nblock diagram of\n \ndata changes\n \nexamples\n \nknowledge sources\n \nlimitations\n \npartitions\n \nrelated architecture\n \nsequence diagram\n \nUML class diagram, rule-based software architecture\n \nblocking connectors\nBoland Together\nBorderLayout\nboundary class\nbox and line diagram\nBoxLayout\nBPEL (Business Process Execution Language)\nbrain electrodes connections\nbridges\nbroker architecture\u2013229. See also CORBA(Common Object Request Broker Architecture); message broker architecture\nadvantages\n \nbroker model\n \nclass diagram for\n \nconcepts\n \nconnected brokers with client-server proxy\n \ndecoupling between clients and servers\n \ndescription of\n \ndisadvantages\n \ninvocation-oriented service\n \nmessage-oriented broker\n \nsequence diagram for\n \nsubcomponents bridges\n \nbroker\nnetwork\nskeleton (server-side proxy)\nstub (client-side proxy)\nbuffered message-based software architecture\napplicable domains\n \nbenefits\n \nlimitations\n \nthe messaging mechanism\n \npartitions\nplatforms for", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 176", "position": 176, "chunk_type": "semantic", "token_estimate": 278}
{"text": "platforms for\n \npoint-to-point messaging (P2P)\n \npublish-subscribe messaging (P&S)\n \nbusiness-to-business (B2B) application\nclass diagram of a message queue\ncomplex enterprise system with JMS\nmessage listener\nmessage topics of JMS\nparts of\nP&S and P2P compared\nsequence diagram of a message queue\ntiming coupling dependency\nrelated architecture\n \nuses for\n \nbusiness attributes\nBusiness Process Execution Language (BPEL)\nBusiness to Business (B2B) integration\nBusiness-to-Business (B2B) application\n \n \nC\nC++\nC2sadel\ncall\ncall-and-return style\ncallee\ncaller\nCapability Maturity Model for Software (Sw-CMM)\ncapture phase, events\nCardLayout\nCarnegie Mellon University\nCASE. See Computer Aided Software Engineering (CASE)\nCBS architecture. See component-based software (CBS) architecture\nC/C++Pack\ncd label\ncheck out\nclass\nclass diagramt\u201344f. See also under specific topics\nclass hierarchies (class libraries)\nClass-Responsibility-Collaborator (CRC) card analysis. See also under object-oriented (OO) design\nclear shopping cart\nclient server\nclient server architecture\nadvantages\n \ndisadvantages\n \nprocess\n \ntwo-tiered\n \nclients of message service\nclient-server proxy, connected brokers with\nCLR (Common Language Runtime)\nCLR virtual machine in .NET platform\ncode reuse\ncode structure\ncohesion\ncohesion design principle\nProfessor class improved design\n \nProfessor class initial design\n \ncohesive class\ncollaboration diagram\ncollaborators\nCOM/DCOM\ncommand-line interfaces\nCommon Language Runtime (CLR) virtual machine in .NET platform\nCommon Object Request Broker Architecture. See under CORBA\ncommunication diagram\ncommunications mode\ncompilation units\ncompiler construction\ncomplexity\ncomponent diagram\ncomponent interaction\ncomponent reusability\ncomponent specification\ncomponentbase (CB)\ncomponent-based architecture (CB)\napplicable domains\n \nbenefits\n \ncomponent\n \nconcept of a component and nested composition\nCORBA component example\ndefined\nIDL interface definition\nJava component example\nsimple composition\nUML component notation\nlimitations\n \noverview\n \nprinciples of component-based design\n \ncomponent-level design guidelines\nbusiness concept diagrams\ncollaboration\nfirst cut of component-based software architecture\ntop-down component-based design\nUML design tool\nuse case component implementation\nuse case diagrams\nuse case for clinic appointment system\nbusiness concept diagram\nidentification of components\npossible situations", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 177", "position": 177, "chunk_type": "semantic", "token_estimate": 290}
{"text": "user interactions: connections of components\ncategories of connections\ncomponent interaction\nidentifying components\nsupport for reusability\nUML component-based architecture\nrelated architecture\n \nstandard component frameworks\n \nsummary\n \ncomponent-oriented UI design\ncomposite structure diagram\ncomposition\ncomposition vs. inheritance\nComputer Aided Software Engineering (CASE)\nevent-based connection\n \nconceptual view\nconcrete models\nconcurrency\nin pipe and filter architecture\n \nconcurrent systems\nconfiguration\nconfiguration topology\nconnector\nAcme\n \nclassification\n \noverview\n \nconnector active time\nconnector attribute\nconnector environment\nconnector fan-out\nconnector implementation type\nconnector information carriers\nconnector span\nconsistency in UI design\ncontinued evolution\ncontrol module\ncontrolled variable\ncontroller class\ncontrol-of-variability\ncoordination (communication) diagram\nCORBA (Common Object Request Broker Architecture)\ncallback mechanism\n \ncomponent\n \nDynamic Invocation Interface (DII)\n \nDynamic Skeleton Interface (DSI)\n \nHorizontal CORBA Facilities\n \nInterface Definition Language (IDL)\n \nInterface Repository (IFR)\n \nObject Request Broker (ORB) protocol\n \nstatic remote invocation in\n \nVertical (Domain) CORBA Facilities\n \nCore Engine design\ncore type component\ncost\nCRC (Class-Responsibility-Collaborator). See also under object-oriented (OO) design\ncruise control system\nC++skeleton code\ncup to cup (c2c) delegation\nCustomerInfoDB\ncustomizable user interfaces\ncustomizable user interfaces design\n \n \nD\ndata bean\ndata flow architecture\nbatch sequential architecture\n \napplicable domains of\nbenefits\nbusiness data processing example\nexample of\nJava program\nlimitations\nrelated architecture\nUnix shell script\nblock diagram of\n \nguidelines\n \noverview\n \npipe and filter architecture\n \nactive filter\napplicable domains of\nbenefits\nblock and sequence diagram for\nclass diagram for\ndata stream\nin Java\nJava PipedReader\nJava PipedWriter\nlimitations\npassive filter\npipelined pipe and filter\nsequence diagram\nin Unix\nprocess control architecture\n \napplicable domains\nbenefits of close-loop feedback\ncontrolled variable\nin a cruise control system\ninput variable", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 178", "position": 178, "chunk_type": "semantic", "token_estimate": 253}
{"text": "manipulated variable: summary\n \nData Flow Diagrams (DFD)\ndata marshaling\ndata module\ndata server\ndata store\ndata stream\ndata unmarshaling\ndata-centered software architecture\nblackboard architecture style\n \nanimal identification knowledge based system (KBS)\napplicable domain of\nbenefits\nblock diagram of\ndata changes\nexample application\nexamples of\nknowledge sources\nlimitations\npartitions\nrelated architecture\nsequence diagram\nUML class diagram, rule-based software architecture\nknowledge sources\n \noverview\n \nrepository architecture style\n \napplicable domains\nbenefits\nblock diagram of\nCASE system\nclass diagram for a simple data store\ncompiler construction\ndatabase system with data repository\ndecentralized (distributed) repository\ndesign domain for\nJava code\nJava DataBase Connectivity (JDBC) driver\nlimitations\nrelated architecture\nsequence diagram\ntools for development of applications\nvirtual repository\nsummary\n \ndata-centric style\ndata-flow style\nDCOM broker\ndecentralized (distributed) repository\ndecomposition\ndecoupling between clients and servers\ndecoupling design principle\ndeployable\ndeployment diagram\ndeployment environment\ndescription of\ndesign analysts\ndesign encapsulation\ndesign-for-commonality\ndetailed design of SessionController class\ndetailed interpretation\ndevelopment view\ndevelopment-for-reuse process\ndevelopment-with-reuse process\nDFD (Data Flow Diagram)\nDII (Dynamic Invocation Interface)\ndirect manipulation, user interfaces\ndirection\ndistributed architecture\nbroker architecture\n \nadvantages\nbroker model\nclass diagram for\n \nconcepts\n \nconnected brokers with client-server proxy", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 179", "position": 179, "chunk_type": "semantic", "token_estimate": 184}
{"text": "Dynamic Invocation Interface (DII): Dynamic Skeleton Interface (DSI)\nInterface Definition Language (IDL)\nInterface Repository (IFR)\nObject Request Broker (ORB) protocol\nstatic remote invocation in\ndecoupling between clients and servers\n \ndescription of\n \ndisadvantages\n \ninvocation-oriented service\n \nmessage broker architecture\n \nadvantages\ndisadvantages\ndocument category\nexample\nmain parts\nMessage-Oriented Middleware (MOM)\npoint-to-point messaging\nprocess\npublishing and subscribing\nRemote Procedure Call (RPC) category\nsystems\nmessage-oriented broker\n \nsequence diagram forf subcomponents\n \nbridges\nbroker", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 179", "position": 179, "chunk_type": "semantic", "token_estimate": 67}
{"text": "broker\n \nnetwork\n \nskeleton (server-side proxy)\n \nstub (client-side proxy)\n \nclient server architecture\nadvantages\n \ndisadvantages\n \nprocess\n \ntwo-tiered\n \ncommunications mode\nintroduction\nmulti-tier architecture\nnetwork topology\nSOA (Service-Oriented Architecture)\nadvantages\napplications\nservice composition\nservice composition model\nservice reuse\nbusiness process\nconnections between services\nSOA for grid service computing\n \nSOA in web services\n \nBusiness Process Execution Language (BPEL)\ndescribed\nSimple Object Access Protocol (SOAP)\nWeb Service Description Language (WSDL)\nsummary\n \ndivide-and-conquer methodology\nDLL component\ndocument (message) oriented broker\ndomain design\ndomain libraries\ndomain models\ndomain users\ndomain-independent component\nDSI (Dynamic Skeleton Interface)\nDynamic Invocation Interface (DII)\ndynamic linked library (DLL) file\ndynamic runtime connectors\nDynamic Skeleton Interface (DSI)\ndynamic user interfaces\n \n \nE\nEclipse IDE\nEclipse Modeling Framework (EMF)\nEJB (Enterprise JavaBean) callback method\nEJB (Enterprise JavaBean) component\nelement\nembedded software system\nenabling technology of user interfaces\ncase study:Windows Calculator\n \ngenerating codes\nimplementing the GUI using NetBeans\nphases of an event listener\ncontainers\nintermediate containers in Java\ninternal structure of a JFrame\nevent listeners\n \nintegrating UI components\n \nlayout managers\n \nmajor UI components\n \nencapsulation\nEnterprise JavaBean (EJB) callback method\nEnterprise JavaBean (EJB) component\nEnterprise Pack\nentity class\nevaluation of user interfaces\nevent\nevent handler\nevent listeners\nevent object\nevent-based architecture\nevent-based connection\nevent-based implicit invocation architecture. See non-buffered event-based implicit invocations event-driven connector\nevent-listener role\nevent-oriented diagram\nevent-publisher role\nevent-receiver role\nevolution of user interfaces\ncommand-line interfaces\n \nimplementation of graphical user interfaces\n \nfrom textual to graphical user interfaces\n \nWindows Calculator\n \nexpandability\nexpert system\nextend link\nextensibility\nexternal event\n \n \nF\nfamilies of systems. See product line architecture\n(PLA) fault-tolerance\nFeature Oriented Domain Analysis (FODA)\nfiles\nfindability of user interfaces\nfire and forget system. See buffered message-based\nsoftware architecture flexibility", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 180", "position": 180, "chunk_type": "semantic", "token_estimate": 271}
{"text": "flow chart of selection process: flow control\nFlowLayout\nFODA (Feature Oriented Domain Analysis)\nfork/join actions\n4+1 view model\nfriendliness in UI design\nfront-end tier\nfunctional requirements\n \n \nG\nGIF (Graphic Interchange Format)\nGloBus grid services\nglue component\nGraphical user interfaces (GUI). See also enabling technology of user interfaces; user interfaces; user interfaces, design considerations\nevent classes\n \nexample, MVC-I architecture\n \nGrid Service computing\nGrid services\nGridBagLayout\nGridLayout\n \n \nH\nhandheld devices\nheterogeneity\nheterogeneous architecture. See also online computer vendor (OCV)\nevaluation of architecture designs\n \napproaches", "domains": ["Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 181", "position": 181, "chunk_type": "semantic", "token_estimate": 82}
{"text": "definition of a design scenario: process stages\nSAAM case study: two candidate designs for IRS,\nanalysis results\nevaluation of scenarios 1 and 2\nquality attributes for\nscenarios designed\ntask dispatcher for parallelism\nmethodology of architecture decision\n \narchitecture styles available\nflow chart of selection process\nrequirements analysis\noverview\n \nquality attributes\n \nfinal steps\nidentifying importance of\nlist of\nquantitative evaluation of\nselection of architecture styles\n \nsummary\n \nheterogeneous connector\nheuristics, during analysis and design\nhierarchical software architecture\nblock diagram of\n \ndesign guidelines\n \nlayered\n \napplicable domains\nbenefits\nclass diagram for\ncomponent-based\ninteraction layer\ninterfaces\njar file\nlimitations\nmodels\nnetwork protocols\noverview\npartial layered architecture: business example\nprocessing layer\npure layered hierarchy\nrelated architecture\nSimple Object Access Protocol (SOAP)\nmain-subroutine design architecture\n \nbenefits\ndata flow diagram (DFD) mapped into\nlimitations\n\u201cmain\u201d program\npurpose of\ntransform or transaction flows\nways to pass on parameter data\nmaster-slave\n \napplicable domains\nblock diagram for\nclass diagram for\noverview\n \nsummary\n \nvirtual machine\n \napplicable domain\nbenefits\nCLR virtual machine in .NET platform\ndefinition of\ndetailed interpretation\nJava Virtual Machine (JVM)\ninterpreter system\nrole of\nlimitations\nrelated architecture\nUnix virtual machine\nhierarchical structure", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 181", "position": 181, "chunk_type": "semantic", "token_estimate": 181}
{"text": "hierarchy diagram: homogeneous connector\nHorizontal CORBA Facilities\nhorizontal overload\nhorizontal reuse\nHTTP and HTML based data presenter\n \n \nI\nIBM MQseries\nIDE. See Integrated Development Environment\n(IDE) IDL (Interface Definition Language)\nIEEE, definition of software architecture\nIFR (Interface Repository)\nif-selection scenario\nimage processing\nimplementation\nimplementation attributes\nimplementation components\nimplicit registration/notification\ninclude link\ninformation representation in UI design\ninheritance\ninheritance vs. composition\ninput variable\ninstance of the class\nIntegrated Development Environment (IDE). See also under user interfaces user\ninterfaces in\n \nintegrated-MBSE[25]\nintegration\nintegration in UI design\ninteraction layer\ninteraction overview diagram\ninteraction-oriented software architecture\nApache Strut\n \ncontrol module\n \ndata module\n \nModel-View-Controller (MVC)\n \napplicable domains\nbenefits\nController\nlimitations\nModels\nMVC-I architecture\nGUI example\nsubsystems\nMVC-II architecture\nclass diagram for\nexample on Java Web platform\noverview\nsequence diagram for\nrelated architecture\nuses for\nViews\noverview\n \npartitions\n \nPresentation-Abstraction-Control (PAC) architecture\n \napplicable domains\nbenefits\nblock diagram for a single agent\nclass diagram for\ncomponent concepts\nlimitations\nmultiple agents in\nrelated architecture\nsequence diagram for\nsingle agent in\nsummary\n \nview presentation module\n \nInteractive Development Environment (IDE) tools\ninterceptor\nInterface Connection Architecture\nInterface Definition Language (IDL)\ninterface port\nInterface Repository (IFR)\ninterface type component\ninteroperability\nintroduction\nintuitive UI design\ninvocation-oriented service\nI/O stream connection", "domains": ["Architectural Patterns and Styles", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 182", "position": 182, "chunk_type": "semantic", "token_estimate": 196}
{"text": "Java event model: Java Message Server (JMS) message queue\nJava PipedReader\nJava PipedWriter\nJava Servlet, MVC architecture\nJava Studio Enterprise IDE\nJava Virtual Machine (JVM)\ninterpreter system\n \nrole of\n \nJava XML SAX parser\nJavaBean\ncomponent\n \nMVC architecture\n \nJavaServer Faces\nJavaServer Pages (JSP), MVC architecture\nJavaSwing, layout managers\nJavaSwing components\nJBossMQ\nJComponent class\nJDBC (Java DataBase Connectivity)\nJMS message queue\nJMS message topics\nJPEG (Joint Photographic Experts)\n \n \nK\nknowledge-based systems (KBS), animal identification\n \n \nL\nlayered architecture\napplicable domains\n \nbenefits\n \nclass diagram for\n \ncomponent-based\n \ninteraction layer\n \ninterfaces\n \njar file\n \nlimitations\n \nmodels\n \nnetwork protocols\n \noverview\n \npartial layered architecture: business example\n \nprocessing layer\n \npure layered hierarchy\n \nrelated architecture\n \nSimple Object Access Protocol (SOAP)\n \nlayered style\nlayering\nlifelines\nlifetime\nlistener\nlocal connector\nlog in/log out\nlogical view\nlook and feel features\nlook and feel (syntax) of user interfaces\ncustomizable style\n \ndynamic style\n \nno user interfaces\n \nstatic style\n \narchitecture of\nhot keys\nmobile or handheld devices\norganization and layout\ntext editors and IDEs\nlookup command\nloosely coupled connection\nloosely coupled components\nloosely coupled distributive communication\nlow-level design agents\n \n \nM\nMac OS Dashboard\nMail server\nMain-subroutine design architecture\nbenefits\n \ndata flow diagram (DFD) mapped into\n \nlimitations\n \n\u201cmain\u201d program\n \npurpose of\n \ntransform or transaction flows\n \nways to pass on parameter data\n \nMaintainability\nMaintenance and evolution\nManipulated variable\nMaster-slave architecture\napplicable domains\n \nblock diagram for\n \nclass diagram forf MDA (Model Driven Architecture) framework\n \nMDB (Message-Driven Bean)\nMean-Time-to-Failure (MTTF)\nMediator\nMediator-broker\nMessage broker architecture\nadvantages\n \ndisadvantages\n \ndocument category\nexample", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 183", "position": 183, "chunk_type": "semantic", "token_estimate": 239}
{"text": "example\n \nMain parts\n \nMessage-Oriented Middleware (MOM)\n \npoint-to-point messaging\n \nprocess\n \npublishing and subscribing\n \nRemote Procedure Call (RPC) category\n \nsystems\n \nMessage clients\nMessage consumer\nMessage listener\nMessage passing, message producer\nMessage queue, message receiver module\nMessage sender module\nMessage service providers\nMessage topic, message-based connector, message-based software architecture. See buffered\nMessage-based software architecture message-based system\nMessage-Driven Bean (MDB)\nMessage-oriented broker\nMessage-Oriented Middleware (MOM)\nMessages\nMethod\nMethod callback\nMethod invocation, Microsoft ASP .NET, MVC architecture\nMicrosoft MQ\nMicrosoft .NET\nMicrosoft Visio\nMiddleware server\nMiddleware tier, mobile devices\nMobility Pack\nMode\nModel Driven Architecture (MDA) framework\nModel-driven approach to software development\nModels for software architecture. See also Architecture Description Languages (ADLs); UML for software architecture\n4+1 view model\n \nArchitecture Description Language (ADL)\n \nbox-and-line diagrams, overview\n \nsummary\n \nModel-View-Controller (MVC)\napplicable domains\n \nbenefits\n \nController\n \nlimitations\n \nModels\n \nMVC-I architecture, GUI example\n \nsubsystems\n \nMVC-II architecture\n \nclass diagram for\nexample on Java Web platform\noverview\nsequence diagram for, related architecture\n \nuses for\n \nview presentation module\n \nViews\n \nModifiability\nin pipe and filter architecture\n \nModule communication styles\nModule view\nMOM (Message-Oriented Middleware)\nMotor control\nMS Internet Explorer\nMS-Controller design\nMS.NET Remote mechanisms\nMTTF (Mean-Time-to-Failure)\nMultiple role connectors\nMultiple-event receiver roles\nMultiplicity notations, UML\nMulti-tier architecture\nMultitouch sensors\nMVC. See Model-View-Controller (MVC) MyBean class\n \n \nN\n.NET\n.NET client code .NET component .NET Remote broker .NET web services\nNetBeans\nNetwork\nNetwork topology\nNetworked connector\nNon-blocking connectors\nnon-buffered event-based implicit invocations\napplicable domains\n \nbenefits\n \nclass diagram for\n \nlimitations\n \nMVC model\n \nrelated architecture\n \nSmallTalk language\n \nsoftware application designs for\n \nsynchronous vs. asynchronous invocations\n \nuser interface application, Java fragments\n \nuser-defined events, GUI event classes\n \nnonfunctional requirements\nNotification message\nNullLayout\n \n \nO\nObject Connection Architecture\nObject diagram", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 184", "position": 184, "chunk_type": "semantic", "token_estimate": 269}
{"text": "Object Management Group (OMG): Object Request Broker (ORB) protocol\nObject-oriented component technology\nObject-oriented development\nObject-oriented frameworks\nObject-oriented (OO) analysis. See also object-oriented (OO) design\nanalysis class diagram\n \nclasses\nboundary class\ncontroller class\nentity class\nof OPS, register use-case description\nsession class\nClass-Responsibility-Collaborator (CRC) card analysis\nuses for\nOverview\n \nUML use-case diagram abstract use case\n \nOf an OPS, concrete use case\n \ndefinition of\n \nObject-oriented (OO) design\nstep 2:identify classes\u2014CRC card\n \nconcurrent systems\nCRC card template class name\ncollaborator\nresponsibility\nCustomerInfoDB\nracing conditions\nRegistrationController\nRegistrationPage\nSessionController\nteam-based approach\ntypes of participants\ncollaborators\ndesign analysts\ndomain users\ndesign approaches\n \ndesign principles\n \ncohesion\nProfessor class improved design\nProfessor class initial design\ndecoupling, Open-Closed\nstages\n \nstep 2:construct an interaction diagram communication diagram\n \nsequence diagram, Registration use case\nstep 3:build a state machine diagram composite-state\n \nelements of\nstate\ntransition\nObject of the detailed level design\nstep 4:class specification\n \ncategories of operations\nidentify public interface\nimplementation design process\ndetailed design of SessionController class\nidentifying private attributes\ninteraction diagram\nrefine design of operations\nObject-oriented (OO) modeling\nObject-oriented (OO) paradigm,. See also Object-oriented (OO) analysis; object-oriented (OO) design\nclasses and objects\n \nOverview\n \nprocess\n \nencapsulation\ninheritance\npolymorphism\nrelationships\n \naggregation\nassociation\ncomposition\ncomposition vs. inheritance\ninheritance, summary\nObject-oriented patterns\nObject-oriented Remote Method Invocation (RMI)\nObject-oriented solutions\nObject-oriented style\nObserver pattern\nOffice Suite\nOMG (Object Management Group)\n1-* connector\n1-1 connector\nOne-initiator connector\nOnline Computer Vendor (OCV)\narchitecture design of Inventory Management component\n \nrequirements\nresponsibilities\nstructure of\narchitecture design of Manufacture & Shipping component\n \ndesign of Core Engine\ndesign of MS-Controller\noverall structure\npurpose of\nstructure of an OCV assembly line\narchitecture design of OCVS\n \ncandidate architectural syles\nfinal decision on architecture selection: CBA architecture of OCVS, multi-tier view\nscreening of architectural styles\nSOA vs. CBA\narchitecture design of Order Processing component\n \narchitecture design of Product Configuration component\nchoices of interactive architecture: MVC and PAC", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 185", "position": 185, "chunk_type": "semantic", "token_estimate": 303}
{"text": "Overall structure: state machine diagram of Configuration class\nbusiness goal of\n \ngeneral requirements\n \nrequired quality attributes of OCVS\n \nOpen-Closed design principle\nOperation\nOracle database software\nORB (Object Request Broker)\nOrder Processing System (OPS)\nanalysis class diagram of, UML use-case diagram of\n \nOriginal design\nOverloading operations\n \n \nP\nPAC architecture. See Presentation-Abstraction-Control (PAC) architecture package diagram\nPaint software\nPartial layered architecture: business example\nPartitions\nPassing function pointers\nPassive data\nPassive filter\nPeer-to-peer client-server architecture\nPerformance\nPersonal Software Process (PSP)\nPhysical configuration\nPhysical view, pipe and filter\nPipe and filter architecture\nactive filter\n \napplicable domains of\n \nbenefits\n \nblock and sequence diagram\n \nclass diagram for\n \ndata stream\n \nin Java\n \nJava PipedReader\n \nJava PipedWriter\n \nlimitations\n \nPassive filter\nPipelined pipe and filter\nsequence diagram\n \nin Unix, plug-and-play\n \nPlug-in, in Eclipse IDE\nPoint-to-point (P2P) messaging architecture\n \n \nPolymorphism\nPortability\nPorts\nPost-condition\nPresentation-Abstraction-Control (PAC) architecture\napplicable domains\n \nbenefits\n \nblock diagram for a single agent\n \nclass diagram for\n \ncomponent concepts\n \nlimitations\n \nmultiple agents in\n \nrelated architecture\n \nsequence diagram for\n \nsingle agent in\n \nprinciple of decoupling design\nprivate attributes\nProcess control architecture\napplicable domains\n \nbenefits of close-loop feedback\n \ncontrolled variable\n \nin a cruise control system\n \ninput variable\n \nmanipulated variable\n \nProcess view\nproduct artifacts\nProduct development:design-with-reuse\nheuristics\n \nduring analysis\nduring design\nintroduction\n \nProduct line analysis:domain models\n \nProduct line design\n \narchitecture connections\nAttribute-Driven Design (ADD) method\nControl-of-Variability\nDesign-for-Commonality\noptional features\nquality of products\nProduct line implementation: configuration model and component base\n \ncomponent specification\nComponentbase\ndomain libraries\ndomain-independent component\nimplementation components\nProduct line components\nProduct specific components\nscope and granularity\nsolution space\nsoftware technology for systematic reuse\n \nabstract models\nanalysis models\nclass hierarchies (class libraries)\ncode reuse", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Design Principles", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 186", "position": 186, "chunk_type": "semantic", "token_estimate": 263}
{"text": "concrete models: integrated-MBSE[25], introduction\nobject-oriented frameworks\nobject-oriented patterns\nsolution models\nProduct line architecture (PLA). See also product development:design-with-reuse example of product lines\nHow: Asset Base\n \nWHAT:Product Families\nWHY: Mission and Strategic Goals\nintroduction and motivation\n \ndefinition of product line\nmethodologies, processes, and tools\nmethodology\nModel Driven Architecture (MDA) framework\nmodeling/development duality\nPlatform\nProcess\nProduct line engineering\ntechniques and tools\nsoftware reuse and product lines\nad-hoc reuse\naspects of\ndefinitions of software reuse\nhorizontal and vertical reuse\nindustrial-strength software engineering\nProduct line engineering\nreuse within and across product lines\nsystematic reuse\noverview\nProduct line engineering:design for reuse\nsummary\nultralarge-scale systems (ULS)\nProduct line components\nProduct line engineering\nProduct-specific components\nProfessor class improved design\nProfessor class initial design\nProfiler\nProgrammed connector\nProgress SonicMQ\nProtocol-based connector\nProvided port\nProxy object\nProxy-based system\nPSP (Personal Software Process)\nPublic interface design\nPublish-subscribe messaging (P&S)\nbusiness-to-business (B2B) application\n \nclass diagram of a message queue\n \ncomplex enterprise system with JMS\n \nmessage listener\n \nmessage topics of JMS\n \nParts of\n \nP&S and P2P compared\n \nsequence diagram of a message queue\n \ntiming coupling dependency\n \n \n \nQ\nquality attributes\nbusiness attributes\n \nheterogeneous architecture\n \nfinal steps\nidentifying importance of\nlist of\nquantitative evaluation of\n \nimplementation attributes\n \nruntime attributes\n \ntradeoff pairs\n \n \n \nR\nracing conditions\nrational Rose\nrational Unified Process (RUP)\nreading role of a pipe\nrealization relationship\nreference model\nregister\nregister phase, events\nregister use-case description\nregistrationController\nregistrationPage\nrelationships\naggregation\n \nassociation\n \ncomposition\n \ncomposition vs. inheritance\n \ninheritance, reliability\n \nrep-map\nremote Method Invocation (RMI)\nremote Procedure Call (RPC)\nremove item\nreplicated services\nrepository architecture style\napplicable domains\n \nbenefits\n \nblock diagram of\n \nCASE system\n \nclass diagram for a simple data store\nil\nt\nti", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 187", "position": 187, "chunk_type": "semantic", "token_estimate": 267}
{"text": "compiler construction\n \ndatabase system with data repository\n \ndecentralized (distributed) repository\n \ndesign domain for\n \nJava code\n \nJava DataBase Connectivity (JDBC) driver\n \nlimitations\n \nrelated architecture\n \nsequence diagram\n \ntools for development of applications\n \nvirtual repository\n \nrequired port\nreusability\nin pipe and filter architecture\n \nreusable assets\nreuse. See product development:design-with-reuse\nRMI (Remote Method Invocation)\nRPC (Remote Procedure Call)\nrule-based software architecture\nruntime environment\nruntime attributes\nruntime structure\nrUP (Rational Unified Process)\n \n \nS\nSAAM (Software Architecture Analysis Method)\ncase study:two candidate designs for IRS\n \nanalysis results\nevaluation of scenarios 1 and 2\nquality attributes for\nScenarios designed\ntask dispatcher for parallelism\ndefinition of a design scenario\n \nprocess stages\n \nSAPCO:simple, aesthetic, productive, customizable, and other\nSAX parser\nScalability\nScalability performance\nScenario view\nScope and granularity\nScroll Pane\nSDD (Software Design Descriptions)\nSDLC (Software Development Life Cycle)\nSecurity\nSeparation in UI design\nSequence\nSequence diagram\nserver proxy\nService-Oriented Architecture. See SOA (Service-Oriented Architecture) session\nSession class\nSessionController class\nsignature-based connector\nSimplicity, in pipe and filter architecture\nSkeleton object\nSkeleton (server-side proxy)\nSmallTalk language\nSmalltalk-\nSOA (Service-Oriented Architecture), distributed architecture\nadvantages\n \napplications\n \nService composition\nservice composition model\nservice reuse\nbusiness process\nconnections between services\nSOA for grid service computing\n \nSOA in web services\n \nBusiness Process Execution Language (BPEL)\ndescribed, document\nSimple Object Access Protocol (SOAP)\nWeb Service Description Language (WSDL)\nSOAP (Simple Object Access Protocol)\nsoftware architects and designers\nSoftware Architecture Analysis Method. See SAAM (Software Architecture Analysis Method)\nsoftware architecture design. See also software architecture design space\narchitecture style\n \ncomponents\nimportance of\nModel-View-Controller (MVC)\nmulti-tiered architecture\nquality attributes\nbusiness attributes\nimplementation attributes\nruntime attributes\ntradeoff pairs\nconcepts of\ndescribing architecture designs 4+1 view model\nArchitecture Description Languages (ADL)\nUML notation\nformal definitions of\n \nguidelines\n \nimportance of\n \nSoftware architect\u2019s tasks\n \nSoftware Design Descriptions (SDD)\n \nSoftware Development Life Cycle (SDLC)\n \nSoftware quality attributes\n \nSoftware Requirements Specification (SRS)\n \nSubsystems, summary\n \nSoftware architecture design space agile approach to", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 188", "position": 188, "chunk_type": "semantic", "token_estimate": 307}
{"text": "an iterative agile approach: HTTP and HTML based data presenter\nnetworked data presenter\nstand-alone data presenter\ntraditional design\nweb architecture\ndefinition of\noverview\nSoftware connectors\n \nclassification\noverview\nSoftware elements\n \nguidelines for mapping\noverview\nSummary\n \ntypes of software structures\n \nSoftware management structure\nSoftware runtime structure attributes\ndistance and connection media\nuniversally invocable\nconnector attributes\nmultiplicity\nSelf-descriptive\nSoftware static structure\n \nclasses\nconnector attributes\ndeployment time\nlinear client-server relation\npackage\nServer unit\nStatic file types\nSoftware deployment infrastructure\nSoftware Design Descriptions (SDD)\nSoftware Development Life Cycle (SDLC)\nSoftware elements\nguidelines for mapping\n \noverview\n \nSoftware management structure\nSoftware product line\nSoftware Requirements Specification (SRS)\nSoftware runtime structure\nattributes\n \ndistance and connection media\n \nuniversally invocable\n \nconnector attributes multiplicity\n \nSelf-descriptive\nSoftware static organization\nSoftware static structure\nclasses\n \nconnector attributes\n \ndeployment time\n \nlinear client-server relation\n \npackage\n \nServer unit\nStatic file types\nSolution models\nSolution space\nSource code module\nSource object\nSRS (Software Requirements Specification)\nStakeholders\nStandard stovepipe approach\nStarting point\nState chart, state machine architecture\nState machine diagram\nState Transition Diagrams (STD)\nState variable\nStatic logical relationship\nStatic remote invocation in CORBA\nStatic structural (UML) diagram\nStatic structure\nStatic user interfaces\narchitecture of\n \nhot keys\n \nmobile or handheld devices\n \norganization and layout\n \ntext editors and IDEs\n \nStructural (static) UML diagrams\nclass diagram\n \ncomponent diagram\n \ncomposite structure diagram\n \ndeployment diagram\n \nobject diagram\n \npackage diagram, structured class\n \nStub (client-side proxy)\nSubscriber\nSubsystem decomposition\nSw-CMM (Capability Maturity Model for Software)\nSwing\nSwing event\nSynchronization\nSynchronization mode, synchronous message\nSystem decomposition\nSystem design\nSystem usability\nSystematic reuse\n \n \nT\ntask dispatcher for parallelism", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 189", "position": 189, "chunk_type": "semantic", "token_estimate": 251}
{"text": "TCP/IP: Team Software Process (TSP)\ntestability\ntesting and simulation models\ntext editors and IDEs\nthroughput performance\ntime sequence diagram\ntime to market\ntiming coupling dependency\ntiming diagram\ntradeoff pairs, quality attributes\ntraffic control management system\nTSP (Team Software Process)\ntwo-initiator connector\ntwo-tier architecture\n \n \nU\nUDDI (Universal Description, Discovery, and Integration services)\nregistry repository\n \nin SOA\n \nultralarge-scale systems (ULS)\nuML component notation, UML for software architecture\nmodeling diagrams\n \nbehavioral (dynamic) diagrams\nactivity diagram\ncommunication or collaboration diagram\ninteraction overview diagram\nsequence diagram\nstate machine diagram\ntiming diagram\nuse-case diagram\nstructural (static) diagrams class diagram\ncomponent diagram\ncomposite structure diagram\ndeployment diagram\nobject diagram\npackage diagram\noverview\n \nuML IDE tools\n \nuML modeling\nuML notation\nuML use-case diagram\nabstract use case\n \nof an OPS\n \nconcrete use case\n \ndefinition of\n \nuniCon\nunified Modeling Language (UML). See entries\nunder UML Unified Resource Locator (URL)\nuniversally invocable\nunix pipe and filter architecture in\n \nUnix operating system\nunix shell script\nunix virtual machine\nURL (Unified Resource Locator)\nusability\nusability (semantics) of user interfaces\nfindability\n \ninformation presentation\n \nneeds of the system users\n \nuse-case diagram\nuse-case specifications\nuser Interface (UI) view, user interfaces. See also enabling technology of user interfaces\ncategories\n \ndesign considerations\n \ncomponent-oriented\nconsistency\ncustomizable\nfriendliness\ninformation representation\nintegration\nintuitive\nseparation\nsummary\nuser-centered\nfor different domains\n \ndirect manipulation, evaluation of\n \nevolution of\n \ncommand-line interfaces\nimplementation of graphical user interfaces\nfrom textual to graphical user interfaces\nWindows Calculator\nlook-and-feel (syntax) of user interfaces\n \ncustomizable style, dynamic style\nno user interfaces\nstatic style\narchitecture of\nhot keys\nmobile or handheld devices\norganization and layout\ntext editors and IDEs\noverview\n \nstyles\n \nsummary\n \nusability (semantics) of\n \nfindability\ninformation presentation\nneeds of the system users", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 190", "position": 190, "chunk_type": "semantic", "token_estimate": 272}
{"text": "user-centered design: V\nvariant design\nvertical override\nvertical reuse\nview presentation module\nvirtual machine architecture\napplicable domain\n \nbenefits\n \nCLR virtual machine in .NET platform\n \ndefinition of\n \ndetailed interpretation\n \nJava Virtual Machine (JVM)\n \ninterpreter system\nrole of\nlimitations\n \nrelated architecture\n \nUnix virtual machine\n \nvirtual repository\nVisual Web Pack\n \n \nW\nWAR archive file\nwaterfall model\nweb component\nweb pages, structure, organization, and labeling system\nWeb Service Description Language (WSDL)\nweb services\nWebSphere message broker\nworkflow-oriented diagram\nwrapper class\nWright\nwriting role of a pipe\nWSDL (Web Service Description Language)\n \n \nX\nXML document\nView publication stats", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "SoftwareArchitectureDesignIlluminated.pdf", "section": "Page 191", "position": 191, "chunk_type": "semantic", "token_estimate": 93}
