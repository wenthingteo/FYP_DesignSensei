{"text": "Software Design Basics: Software design is a process to transform user requirements into \nsome suitable form, which helps the programmer in software \ncoding and implementation. For assessing user requirements, an SRS (Software Requirement \nSpecification) document is created whereas for coding and \nimplementation, there is a need of more specific and detailed \nrequirements in software terms. The output of this process can \ndirectly be used into implementation in programming languages. Software design is the first step in SDLC (Software Design Life \nCycle), which moves the concentration from problem domain to \nsolution domain. It tries to specify how to fulfill the requirements \nmentioned in SRS. Software Design Levels \nSoftware design yields three levels of results: \n\uf0b7 Architectural Design - The architectural design is the \nhighest abstract version of the system. It identifies the \nsoftware as a system with many components interacting \nwith each other. At this level, the designers get the idea of \nproposed solution domain. \uf0b7 High-level Design- The high-level design breaks the \u2018single \nentity-multiple component\u2019 concept of architectural design \ninto less-abstracted view of sub-systems and modules and \ndepicts their interaction with each other. High-level design \nfocuses on how the system along with all of its components \ncan be implemented in forms of modules. It recognizes \nmodular structure of each sub-system and their relation and \ninteraction among each other.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 1", "position": 1, "chunk_type": "semantic", "token_estimate": 218}
{"text": "\uf0b7 Detailed: Design- Detailed \ndesign \ndeals \nwith \nthe \nimplementation part of what is seen as a system and its sub-\nsystems in the previous two designs. It is more detailed \ntowards modules and their implementations. It defines \nlogical structure of each module and their interfaces to \ncommunicate with other modules. Modularization \nModularization is a technique to divide a software system into \nmultiple discrete and independent modules, which are expected \nto be capable of carrying out task(s) independently. These \nmodules may work as basic constructs for the entire software. Designers tend to design modules such that they can be executed \nand/or compiled separately and independently. Modular design unintentionally follows the rules of \u2018divide and \nconquer\u2019 problem-solving strategy this is because there are many \nother benefits attached with the modular design of a software. Advantage of modularization: \n\uf0b7 Smaller components are easier to maintain \n\uf0b7 Program can be divided based on functional aspects \n\uf0b7 Desired level of abstraction can be brought in the program \n\uf0b7 Components with high cohesion can be re-used again \n\uf0b7 Concurrent execution can be made possible \n\uf0b7 Desired from security aspect \nConcurrency \nBack in time, all software are meant to be executed sequentially. By sequential execution we mean that the coded instruction will", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 2", "position": 2, "chunk_type": "semantic", "token_estimate": 205}
{"text": "be executed one after another implying only one portion of: program being activated at any given time. Say, a software has \nmultiple modules, then only one of all the modules can be found \nactive at any time of execution. In software design, concurrency is implemented by splitting the \nsoftware into multiple independent units of execution, like \nmodules and executing them in parallel. In other words, \nconcurrency provides capability to the software to execute more \nthan one part of code in parallel to each other. It is necessary for the programmers and designers to recognize \nthose modules, which can be made parallel execution. Example \nThe spell check feature in word processor is a module of software, \nwhich runs alongside the word processor itself. Coupling and Cohesion \nWhen a software program is modularized, its tasks are divided \ninto several modules based on some characteristics. As we know, \nmodules are set of instructions put together in order to achieve \nsome tasks. They are though, considered as single entity but may \nrefer to each other to work together. There are measures by \nwhich the quality of a design of modules and their interaction \namong them can be measured. These measures are called \ncoupling and cohesion. Cohesion \nCohesion is a measure that defines the degree of intra-\ndependability within elements of a module. The greater the \ncohesion, the better is the program design. There are seven types of cohesion, namely \u2013", "domains": ["Domain-Driven Design", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 3", "position": 3, "chunk_type": "semantic", "token_estimate": 236}
{"text": "\uf0b7 Co-incidental cohesion - It is unplanned and random: cohesion, which might be the result of breaking the program \ninto smaller modules for the sake of modularization. Because it is unplanned, it may serve confusion to the \nprogrammers and is generally not-accepted. \uf0b7 Logical cohesion - When logically categorized elements are \nput together into a module, it is called logical cohesion. \uf0b7 Temporal Cohesion - When elements of module are \norganized such that they are processed at a similar point in \ntime, it is called temporal cohesion. \uf0b7 Procedural cohesion - When elements of module are \ngrouped together, which are executed sequentially in order \nto perform a task, it is called procedural cohesion. \uf0b7 Communicational cohesion - When elements of module \nare grouped together, which are executed sequentially and \nwork \non \nsame \ndata \n(information), \nit \nis \ncalled \ncommunicational cohesion. \uf0b7 Sequential cohesion - When elements of module are \ngrouped because the output of one element serves as input \nto another and so on, it is called sequential cohesion. \uf0b7 Functional cohesion - It is considered to be the highest \ndegree of cohesion, and it is highly expected. Elements of \nmodule in functional cohesion are grouped because they all \ncontribute to a single well-defined function. It can also be \nreused. Coupling \nCoupling is a measure that defines the level of inter-dependability \namong modules of a program. It tells at what level the modules", "domains": ["Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 4", "position": 4, "chunk_type": "semantic", "token_estimate": 232}
{"text": "interfere and interact with each other. The lower the coupling, the: better the program. There are five levels of coupling, namely - \n\uf0b7 Content coupling - When a module can directly access or \nmodify or refer to the content of another module, it is called \ncontent level coupling. \uf0b7 Common coupling- When multiple modules have read and \nwrite access to some global data, it is called common or \nglobal coupling. \uf0b7 Control coupling- Two modules are called control-coupled \nif one of them decides the function of the other module or \nchanges its flow of execution. \uf0b7 Stamp coupling- When multiple modules share common \ndata structure and work on different part of it, it is called \nstamp coupling. \uf0b7 Data coupling- Data coupling is when two modules interact \nwith each other by means of passing data (as parameter). If a \nmodule passes data structure as parameter, then the \nreceiving module should use all its components. Ideally, no coupling is considered to be the best. Design Verification \nThe output of software design process is design documentation, \npseudo codes, detailed logic diagrams, process diagrams, and \ndetailed \ndescription \nof \nall \nfunctional \nor \nnon-functional \nrequirements. The next phase, which is the implementation of software, depends \non all outputs mentioned above.", "domains": ["Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 5", "position": 5, "chunk_type": "semantic", "token_estimate": 205}
{"text": "It is then becomes necessary to verify the output before: proceeding to the next phase. The early any mistake is detected, \nthe better it is or it might not be detected until testing of the \nproduct. If the outputs of design phase are in formal notation \nform, then their associated tools for verification should be used \notherwise a thorough design review can be used for verification \nand validation. By structured verification approach, reviewers can detect defects \nthat might be caused by overlooking some conditions. A good \ndesign review is important for good software design, accuracy \nand quality. Software Design Strategies \nSoftware design is a process to conceptualize the software \nrequirements into software implementation. Software design \ntakes the user requirements as challenges and tries to find \noptimum solution. While the software is being conceptualized, a \nplan is chalked out to find the best possible design for \nimplementing the intended solution. There are multiple variants of software design. Let us study them \nbriefly: \nStructured Design \nStructured design is a conceptualization of problem into several \nwell-organized elements of solution. It is basically concerned with \nthe solution design. Benefit of structured design is, it gives better \nunderstanding of how the problem is being solved. Structured \ndesign also makes it simpler for designer to concentrate on the \nproblem more accurately. Structured design is mostly based on \u2018divide and conquer\u2019 \nstrategy where a problem is broken into several small problems", "domains": ["Design Patterns"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 6", "position": 6, "chunk_type": "semantic", "token_estimate": 234}
{"text": "and each small problem is individually solved until the whole: problem is solved. The small pieces of problem are solved by means of solution \nmodules. Structured design emphasis that these modules be well \norganized in order to achieve precise solution. These modules are arranged in hierarchy. They communicate \nwith each other. A good structured design always follows some \nrules for communication among multiple modules, namely - \nCohesion - grouping of all functionally related elements. Coupling - communication between different modules. A good structured design has high cohesion and low coupling \narrangements. Function Oriented Design \nIn function-oriented design, the system is comprised of many \nsmaller sub-systems known as functions. These functions are \ncapable of performing significant task in the system. The system is \nconsidered as top view of all functions. Function oriented design inherits some properties of structured \ndesign where divide and conquer methodology is used. This design mechanism divides the whole system into smaller \nfunctions, which provides means of abstraction by concealing the \ninformation and their operation.. These functional modules can \nshare information among themselves by means of information \npassing and using information available globally. Another characteristic of functions is that when a program calls a \nfunction, the function changes the state of the program, which \nsometimes is not acceptable by other modules. Function oriented", "domains": ["Design Patterns", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 7", "position": 7, "chunk_type": "semantic", "token_estimate": 215}
{"text": "design works well where the system state does not matter and: program/functions work on input rather than on a state. Design Process \n\uf0b7 The whole system is seen as how data flows in the system by \nmeans of data flow diagram. \uf0b7 DFD depicts how functions changes data and state of entire \nsystem. \uf0b7 The entire system is logically broken down into smaller \nunits known as functions on the basis of their operation in \nthe system. \uf0b7 Each function is then described at large. Object Oriented Design \nObject oriented design works around the entities and their \ncharacteristics instead of functions involved in the software \nsystem. This design strategy focuses on entities and its \ncharacteristics. The whole concept of software solution revolves \naround the engaged entities. Let us see the important concepts of Object Oriented Design: \n\uf0b7 Objects - All entities involved in the solution design are \nknown as objects. For example, person, banks, company and \ncustomers are treated as objects. Every entity has some \nattributes associated to it and has some methods to perform \non the attributes. \uf0b7 Classes - A class is a generalized description of an object. An \nobject is an instance of a class. Class defines all the \nattributes, which an object can have and methods, which \ndefines the functionality of the object.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 8", "position": 8, "chunk_type": "semantic", "token_estimate": 216}
{"text": "In the solution design, attributes are stored as variables and: functionalities are defined by means of methods or procedures. \uf0b7 Encapsulation - In OOD, the attributes (data variables) and \nmethods (operation on the data) are bundled together is \ncalled encapsulation. Encapsulation not only bundles \nimportant information of an object together, but also \nrestricts access of the data and methods from the outside \nworld. This is called information hiding. \uf0b7 Inheritance - OOD allows similar classes to stack up in \nhierarchical manner where the lower or sub-classes can \nimport, implement and re-use allowed variables and \nmethods from their immediate super classes. This property \nof OOD is known as inheritance. This makes it easier to \ndefine specific class and to create generalized classes from \nspecific ones. \uf0b7 Polymorphism - OOD languages provide a mechanism \nwhere methods performing similar tasks but vary in \narguments, can be assigned same name. This is called \npolymorphism, which allows a single interface performing \ntasks for different types. Depending upon how the function \nis invoked, respective portion of the code gets executed. Design Process \nSoftware design process can be perceived as series of well-\ndefined steps. Though it varies according to design approach \n(function oriented or object oriented, yet It may have the \nfollowing steps involved: \n\uf0b7 A solution design is created from requirement or previous \nused system and/or system sequence diagram.", "domains": ["Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 9", "position": 9, "chunk_type": "semantic", "token_estimate": 224}
{"text": "\uf0b7 Objects are identified and grouped into classes on behalf of: similarity in attribute characteristics. \uf0b7 Class hierarchy and relation among them is defined. \uf0b7 Application framework is defined. Software Design Approaches \nHere are two generic approaches for software designing: \nTop Down Design \nWe know that a system is composed of more than one sub-\nsystems and it contains a number of components. Further, these \nsub-systems and components may have their on set of sub-system \nand components and creates hierarchical structure in the system. Top-down design takes the whole software system as one entity \nand then decomposes it to achieve more than one sub-system or \ncomponent based on some characteristics. Each sub-system or \ncomponent is then treated as a system and decomposed further. This process keeps on running until the lowest level of system in \nthe top-down hierarchy is achieved. Top-down design starts with a generalized model of system and \nkeeps on defining the more specific part of it. When all \ncomponents are composed the whole system comes into \nexistence. Top-down design is more suitable when the software solution \nneeds to be designed from scratch and specific details are \nunknown. Bottom-up Design \nThe bottom up design model starts with most specific and basic \ncomponents. It proceeds with composing higher level of", "domains": ["Domain-Driven Design", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 10", "position": 10, "chunk_type": "semantic", "token_estimate": 211}
{"text": "components by using basic or lower level components. It keeps: creating higher level components until the desired system is not \nevolved as one single component. With each higher level, the \namount of abstraction is increased. Bottom-up strategy is more suitable when a system needs to be \ncreated from some existing system, where the basic primitives \ncan be used in the newer system. Both, top-down and bottom-up approaches are not practical \nindividually. Instead, a good combination of both is used. Software Implementation \nStructured Programming \nIn the process of coding, the lines of code keep multiplying, thus, \nsize of the software increases. Gradually, it becomes next to \nimpossible to remember the flow of program. If one forgets how \nsoftware and its underlying programs, files, procedures are \nconstructed it then becomes very difficult to share, debug and \nmodify the program. The solution to this is structured \nprogramming. It encourages the developer to use subroutines and \nloops instead of using simple jumps in the code, thereby bringing \nclarity in the code and improving its efficiency Structured \nprogramming also helps programmer to reduce coding time and \norganize code properly. Structured programming states how the program shall be coded. Structured programming uses three main concepts: \n\uf0b7 Top-down analysis - A software is always made to perform \nsome rational work. This rational work is known as problem \nin the software parlance. Thus it is very important that we \nunderstand how to solve the problem. Under top-down \nanalysis, the problem is broken down into small pieces", "domains": ["Design Patterns", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 11", "position": 11, "chunk_type": "semantic", "token_estimate": 248}
{"text": "where each one has some significance. Each problem is: individually solved and steps are clearly stated about how to \nsolve the problem. \uf0b7 Modular Programming - While programming, the code is \nbroken down into smaller group of instructions. These \ngroups are known as modules, subprograms or subroutines. Modular programming based on the understanding of top-\ndown analysis. It discourages jumps using \u2018goto\u2019 statements \nin the program, which often makes the program flow non-\ntraceable. Jumps are prohibited and modular format is \nencouraged in structured programming. \uf0b7 Structured Coding - In reference with top-down analysis, \nstructured coding sub-divides the modules into further \nsmaller units of code in the order of their execution. Structured programming uses control structure, which \ncontrols the flow of the program, whereas structured coding \nuses control structure to organize its instructions in \ndefinable patterns. Functional Programming \nFunctional programming is style of programming language, which \nuses the concepts of mathematical functions. A function in \nmathematics should always produce the same result on receiving \nthe same argument. In procedural languages, the flow of the \nprogram runs through procedures, i.e. the control of program is \ntransferred to the called procedure. While control flow is \ntransferring from one procedure to another, the program changes \nits state. In procedural programming, it is possible for a procedure to \nproduce different results when it is called with the same \nargument, as the program itself can be in different state while", "domains": ["Design Patterns", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 12", "position": 12, "chunk_type": "semantic", "token_estimate": 235}
{"text": "calling it. This is a property as well as a drawback of procedural: programming, in which the sequence or timing of the procedure \nexecution becomes important. Functional programming provides means of computation as \nmathematical functions, which produces results irrespective of \nprogram state. This makes it possible to predict the behavior of \nthe program. Functional programming uses the following concepts: \n\uf0b7 First class and High-order functions - These functions \nhave capability to accept another function as argument or \nthey return other functions as results. \uf0b7 Pure functions - These functions do not include destructive \nupdates, that is, they do not affect any I/O or memory and if \nthey are not in use, they can easily be removed without \nhampering the rest of the program. \uf0b7 Recursion - Recursion is a programming technique where a \nfunction calls itself and repeats the program code in it unless \nsome pre-defined condition matches. Recursion is the way of \ncreating loops in functional programming. \uf0b7 Strict evaluation - It is a method of evaluating the \nexpression passed to a function as an argument. Functional \nprogramming has two types of evaluation methods, strict \n(eager) or non-strict (lazy). Strict evaluation always \nevaluates the expression before invoking the function. Non-\nstrict evaluation does not evaluate the expression unless it is \nneeded. \uf0b7 \u03bb-calculus - Most functional programming languages use \u03bb-\ncalculus as their type systems. \u03bb-expressions are executed by \nevaluating them as they occur.", "domains": ["Design Patterns"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 13", "position": 13, "chunk_type": "semantic", "token_estimate": 235}
{"text": "\uf0b7 Operators - Defines the rules of writing mathematical,: assignment and logical operators. For example, assignment \noperator \u2018=\u2019 should have space before and after it, as in \u201cx = \n2\u201d. \uf0b7 Control Structures - The rules of writing if-then-else, case-\nswitch, while-until and for control flow statements solely \nand in nested fashion. \uf0b7 Line length and wrapping - Defines how many characters \nshould be there in one line, mostly a line is 80 characters \nlong. Wrapping defines how a line should be wrapped, if is \ntoo long. \uf0b7 Functions - This defines how functions should be declared \nand invoked, with and without parameters. \uf0b7 Variables - This mentions how variables of different data \ntypes are declared and defined. \uf0b7 Comments - This is one of the important coding \ncomponents, as the comments included in the code describe \nwhat the code actually does and all other associated \ndescriptions. This \nsection \nalso \nhelps \ncreating \nhelp \ndocumentations for other developers. Software Documentation \nSoftware documentation is an important part of software process. A well written document provides a great tool and means of \ninformation repository necessary to know about software \nprocess. Software documentation also provides information about \nhow to use the product. A well-maintained documentation should involve the following \ndocuments:", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 15", "position": 15, "chunk_type": "semantic", "token_estimate": 206}
{"text": "\uf0b7 Requirement documentation - This documentation works: as key tool for software designer, developer and the test \nteam to carry out their respective tasks. This document \ncontains all the functional, non-functional and behavioral \ndescription of the intended software. Source of this document can be previously stored data about the \nsoftware, already running software at the client\u2019s end, client\u2019s \ninterview, questionnaires and research. Generally it is stored in \nthe form of spreadsheet or word processing document with the \nhigh-end software management team. This documentation works as foundation for the software to be \ndeveloped and is majorly used in verification and validation \nphases. Most test-cases are built directly from requirement \ndocumentation. \uf0b7 Software Design documentation - These documentations \ncontain all the necessary information, which are needed to \nbuild the software. It contains: (a) High-level software \narchitecture, (b) Software \ndesign \ndetails, (c) Data \nflow \ndiagrams, (d) Database design \nThese documents work as repository for developers to implement \nthe software. Though these documents do not give any details on \nhow to code the program, they give all necessary information that \nis required for coding and implementation. \uf0b7 Technical documentation - These documentations are \nmaintained by the developers and actual coders. These \ndocuments, as a whole, represent information about the \ncode. While writing the code, the programmers also mention \nobjective of the code, who wrote it, where will it be required, \nwhat it does and how it does, what other resources the code \nuses, etc.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 16", "position": 16, "chunk_type": "semantic", "token_estimate": 240}
{"text": "configuration related documentation. This documentation: needs to be highly accurate and available on time. \uf0b7 Target-Host - The software program, which is being \ndeveloped in the organization, needs to be designed for host \nmachines at the customers end. But at times, it is impossible \nto design a software that works on the target machines. Design-notations \nSoftware Design Strategies \nSoftware analysis and design includes all activities, which help the \ntransformation of requirement specification into implementation. Requirement specifications specify all functional and non-\nfunctional expectations from the software. These requirement \nspecifications come in the shape of human readable and \nunderstandable documents, to which a computer has nothing to \ndo. Software analysis and design is the intermediate stage, which \nhelps human-readable requirements to be transformed into \nactual code. Let us see few analysis and design tools used by software \ndesigners: \nData Flow Diagram \nData flow diagram is graphical representation of flow of data in an \ninformation system. It is capable of depicting incoming data flow, \noutgoing data flow and stored data. The DFD does not mention \nanything about how data flows through the system.", "domains": ["Domain-Driven Design"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 18", "position": 18, "chunk_type": "semantic", "token_estimate": 181}
{"text": "\uf0b7 Level 2 - At this level, DFD shows how data flows inside the \nmodules mentioned in Level 1. Higher level DFDs can be transformed into more specific lower \nlevel DFDs with deeper level of understanding unless the desired \nlevel of specification is achieved. Structure Charts \nStructure chart is a chart derived from Data Flow Diagram. It \nrepresents the system in more detail than DFD. It breaks down \nthe entire system into lowest functional modules, describes \nfunctions and sub-functions of each module of the system to a \ngreater detail than DFD. Structure chart represents hierarchical structure of modules. At \neach layer a specific task is performed. Here are the symbols used in construction of structure charts -", "domains": ["Domain-Driven Design", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 21", "position": 21, "chunk_type": "semantic", "token_estimate": 117}
{"text": "\uf0b7 Module - It represents process or subroutine or task. A: control module branches to more than one sub-module. Library Modules are re-usable and inviolable from any \nmodule. \uf0b7 Condition - It is represented by small diamond at the base \nof module. It depicts that control module can select any of \nsub-routine based on some condition. \uf0b7 Jump - An arrow is shown pointing inside the module to \ndepict that the control will jump in the middle of the sub- \nmodule.", "domains": ["Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 22", "position": 22, "chunk_type": "semantic", "token_estimate": 81}
{"text": "\uf0b7 Loop - A curved arrow represents loop in the module. All: sub-modules covered by loop repeat execution of module. \uf0b7 Data flow - A directed arrow with empty circle at the end \nrepresents data flow. Control flow - A directed arrow with filled circle at the end \nrepresents control flow.", "domains": ["Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 23", "position": 23, "chunk_type": "semantic", "token_estimate": 51}
{"text": "HIPO Diagram: HIPO (Hierarchical Input Process Output) diagram is a \ncombination of two organized method to analyze the system and \nprovide the means of documentation. HIPO model was developed \nby IBM in year 1970. HIPO diagram represents the hierarchy of modules in the \nsoftware system. Analyst uses HIPO diagram in order to obtain \nhigh-level view of system functions. It decomposes functions into \nsub-functions in a hierarchical manner. It depicts the functions \nperformed by system. HIPO diagrams are good for documentation purpose. Their \ngraphical representation makes it easier for designers and \nmanagers to get the pictorial idea of the system structure. In contrast to IPO (Input Process Output) diagram, which depicts \nthe flow of control and data in a module, HIPO does not provide \nany information about data flow or control flow.", "domains": ["Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 24", "position": 24, "chunk_type": "semantic", "token_estimate": 131}
{"text": "Do no action: Table : Decision Table \u2013 In-house Internet Troubleshooting \nEntity-Relationship Model \nEntity-Relationship model is a type of database model based on \nthe notion of real world entities and relationship among them. We \ncan map real world scenario onto ER database model. ER Model \ncreates a set of entities with their attributes, a set of constraints \nand relation among them. ER Model is best used for the conceptual design of database. ER \nModel can be represented as follows :", "domains": ["Domain-Driven Design"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 29", "position": 29, "chunk_type": "semantic", "token_estimate": 80}
{"text": "\uf0b7 Entity - An entity in ER Model is a real world being, which \nhas some properties called attributes. Every attribute is \ndefined by its corresponding set of values, called domain. For example, consider a school database. Here, a student is an \nentity. Student has various attributes like name, id, age and class \netc. \uf0b7 Relationship - The logical association among entities is \ncalled relationship. Relationships are mapped with entities \nin various ways. Mapping cardinalities define the number of \nassociations between two entities. Mapping cardinalities: \no one to one \no one to many \no many to one \no many to many \nData Dictionary \nData dictionary is the centralized collection of information about \ndata. It stores meaning and origin of data, its relationship with \nother data, data format for usage etc. Data dictionary has rigorous \ndefinitions of all names in order to facilitate user and software \ndesigners.", "domains": ["Domain-Driven Design"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 30", "position": 30, "chunk_type": "semantic", "token_estimate": 146}
{"text": "Data dictionary is often referenced as meta-data (data about data): repository. It is created along with DFD (Data Flow Diagram) \nmodel of software program and is expected to be updated \nwhenever DFD is changed or updated. Requirement of Data Dictionary \nThe data is referenced via data dictionary while designing and \nimplementing software. Data dictionary removes any chances of \nambiguity. It helps keeping work of programmers and designers \nsynchronized while using same object reference everywhere in \nthe program. Data dictionary provides a way of documentation for the \ncomplete database system in one place. Validation of DFD is \ncarried out using data dictionary. Contents \nData dictionary should contain information about the following \n\uf0b7 Data Flow \n\uf0b7 Data Structure \n\uf0b7 Data Elements \n\uf0b7 Data Stores \n\uf0b7 Data Processing \nData Flow is described by means of DFDs as studied earlier and \nrepresented in algebraic form as described. = \nComposed of \n{} \nRepetition", "domains": ["Domain-Driven Design"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 31", "position": 31, "chunk_type": "semantic", "token_estimate": 148}
{"text": "(): Optional \n+ \nAnd \n[ / ] \nOr \nExample \nAddress = House No + (Street / Area) + City + State \nCourse ID = Course Number + Course Name + Course Level + \nCourse Grades \nData Elements \nData elements consist of Name and descriptions of Data and \nControl Items, Internal or External data stores etc. with the \nfollowing details: \n\uf0b7 Primary Name \n\uf0b7 Secondary Name (Alias) \n\uf0b7 Use-case (How and where to use) \n\uf0b7 Content Description (Notation etc. ) \uf0b7 Supplementary Information (preset values, constraints etc.) Data Store \nIt stores the information from where the data enters into the \nsystem and exists out of the system. The Data Store may include - \n\uf0b7 Files \no Internal to software. o External to software but on the same machine.", "domains": ["Design Patterns"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 32", "position": 32, "chunk_type": "semantic", "token_estimate": 127}
{"text": "Principles of Software Design & Concepts in Software: Engineering \nOnce the requirements document for the software to be \ndeveloped is available, the software design phase begins. While \nthe requirement specification activity deals entirely with the \nproblem domain, design is the first phase of transforming the \nproblem into a solution. In the design phase, the customer and \nbusiness requirements and technical considerations all come \ntogether to formulate a product or a system. The design process comprises a set of principles, concepts and \npractices, which allow a software engineer to model the system or \nproduct that is to be built. This model, known as design model, is \nassessed for quality and reviewed before a code is generated and \ntests are conducted. The design model provides details about \nsoftware data structures, architecture, interfaces and components \nwhich are required to implement the system. This chapter \ndiscusses the design elements that are required to develop a \nsoftware design model. It also discusses the design patterns and \nvarious software design notations used to represent a software \ndesign. Basic of Software Design \nSoftware design is a phase in software engineering, in which a \nblueprint is developed to serve as a base for constructing the \nsoftware system. IEEE defines software design as 'both a process \nof defining, the architecture, components, interfaces, and other \ncharacteristics of a system or component and the result of that \nprocess.' In the design phase, many critical and strategic decisions are \nmade to achieve the desired functionality and quality of the \nsystem. These decisions are taken into account to successfully", "domains": ["Domain-Driven Design", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 34", "position": 34, "chunk_type": "semantic", "token_estimate": 256}
{"text": "application, different programming paradigms such as: procedure \noriented, \nobject-oriented, \nand \nprototyping \nparadigms can be used. The paradigm should be chosen \nkeeping constraints in mind such as time, availability of \nresources and nature of user's requirements. 3. Software \ndesign \nshould \nbe \nuniform \nand \nintegrated: Software design is considered uniform and \nintegrated, if the interfaces are properly defined among the \ndesign components. For this, rules, format, and styles are \nestablished before the design team starts designing the \nsoftware. 4. Software design should be flexible: Software design \nshould be flexible enough to adapt changes easily. To \nachieve the flexibility, the basic design concepts such as \nabstraction, refinement, and modularity should be applied \neffectively. 5. Software design should ensure minimal conceptual \n(semantic) errors: The design team must ensure that major \nconceptual errors of design such as ambiguousness and \ninconsistency are addressed in advance before dealing with \nthe syntactical errors present in the design model. 6. Software design should be structured to degrade \ngently: Software should be designed to handle unusual \nchanges and circumstances, and if the need arises for \ntermination, it must do so in a proper manner so that \nfunctionality of the software is not affected. 7. Software design should represent correspondence \nbetween the software and real-world problem: The \nsoftware design should be structured in such away that it \nalways relates with the real-world problem.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 36", "position": 36, "chunk_type": "semantic", "token_estimate": 222}
{"text": "8. Software reuse: Software engineers believe on the phrase:: 'do not reinvent the wheel'. Therefore, software components \nshould be designed in such a way that they can be effectively \nreused to increase the productivity. 9. Designing for testability: A common practice that has been \nfollowed is to keep the testing phase separate from the \ndesign and implementation phases. That is, first the software \nis developed (designed and implemented) and then handed \nover to the testers who subsequently determine whether the \nsoftware is fit for distribution and subsequent use by the \ncustomer. However, it has become apparent that the process \nof separating testing is seriously flawed, as if any type of \ndesign \nor \nimplementation \nerrors \nare \nfound \nafter \nimplementation, then the entire or a substantial part of the \nsoftware requires to be redone. Thus, the test engineers \nshould be involved from the initial stages. For example, they \nshould be involved with analysts to prepare tests for \ndetermining whether the user requirements are being met. 10. Prototyping: Prototyping should be used when the \nrequirements are not completely defined in the beginning. The user interacts with the developer to expand and refine \nthe requirements as the development proceeds. Using \nprototyping, a quick 'mock-up' of the system can be \ndeveloped. This mock-up can be used as a effective means to \ngive the users a feel of what the system will look like and \ndemonstrate functions that will be included in the developed \nsystem. Prototyping also helps in reducing risks of designing \nsoftware that is not in accordance with the customer's \nrequirements. Note that design principles are often constrained by the existing \nhardware configuration, the implementation language, the", "domains": ["Software Quality Attributes", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 37", "position": 37, "chunk_type": "semantic", "token_estimate": 273}
{"text": "existing file and data structures, and the existing organizational: practices. Also, the evolution of each software design should be \nmeticulously designed for future evaluations, references and \nmaintenance. Software Design Concepts  \nEvery software process is characterized by basic concepts along \nwith certain practices or methods. Methods represent the manner \nthrough which the concepts are applied. As new technology \nreplaces older technology, many changes occur in the methods \nthat are used to apply the concepts for the development of \nsoftware. However, the fundamental concepts underlining the \nsoftware design process remain the same, some of which are \ndescribed here. Abstraction \nAbstraction refers to a powerful design tool, which allows \nsoftware designers to consider components at an abstract level, \nwhile \nneglecting \nthe \nimplementation \ndetails \nof \nthe \ncomponents. IEEE defines abstraction as 'a view of a problem that \nextracts the essential information relevant to a particular purpose \nand ignores the remainder of the information.' The concept of \nabstraction can be used in two ways: as a process and as an entity. As a process, it refers to a mechanism of hiding irrelevant details \nand representing only the essential features of an item so that one \ncan focus on important things at a time. As an entity, it refers to a \nmodel or view of an item. Each step in the software process is accomplished through \nvarious levels of abstraction. At the highest level, an outline of the \nsolution to the problem is presented whereas at the lower levels, \nthe solution to the problem is presented in detail. For example, in \nthe requirements analysis phase, a solution to the problem is", "domains": ["Domain-Driven Design", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 38", "position": 38, "chunk_type": "semantic", "token_estimate": 265}
{"text": "defined by architectural pattern) of a software system or the: relationship among them. Specific design elements such as \nrelationship among components or mechanisms that affect \ncomponent-to-component interaction are addressed by \ndesign patterns. Note that design patterns are often \nconsidered equivalent to software components. 3. Idioms: These patterns are low-level patterns, which are \nprogramming-language \nspecific. They \ndescribe \nthe \nimplementation of a software component, the method used \nfor interaction among software components, etc., in a \nspecific programming language. Note that idioms are often \ntermed as coding patterns. Modularity \nModularity is achieved by dividing the software into uniquely \nnamed and addressable components,which are also known \nas modules. A complex system (large program) is partitioned into \na set of discrete modules in such a way that each module can be \ndeveloped independent of other modules. After developing the \nmodules, they are integrated together to meet the software \nrequirements. Note that larger the number of modules a system is \ndivided into, greater will be the effort required to integrate the \nmodules.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 42", "position": 42, "chunk_type": "semantic", "token_estimate": 166}
{"text": "Modularizing a design helps to plan the development in a more \neffective manner, accommodate changes easily, conduct testing \nand \ndebugging \neffectively \nand \nefficiently, \nand \nconduct \nmaintenance work without adversely affecting the functioning of \nthe software. Information Hiding \nModules should be specified and designed in such a way that the \ndata structures and processing details of one module are not \naccessible to other modules. They pass only that much \ninformation to each other, which is required to accomplish the \nsoftware functions. The way of hiding unnecessary details is \nreferred to as information hiding. IEEE defines information \nhiding as 'the technique of encapsulating software design \ndecisions in modules in such a way that the module's interfaces \nreveal as little as possible about the module's inner workings; \nthus each module is a 'black box' to the other modules in the \nsystem.", "domains": ["Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 43", "position": 43, "chunk_type": "semantic", "token_estimate": 138}
{"text": "Information hiding is of immense use when modifications are \nrequired during the testing and maintenance phase. Some of the \nadvantages associated with information hiding are listed below. 1. Leads to low coupling \n2. Emphasizes communication through controlled interfaces \n3. Decreases the probability of adverse effects \n4. Restricts the effects of changes in one component on others \n5. Results in higher quality software. Stepwise Refinement \nStepwise refinement is a top-down design strategy used for \ndecomposing a system from a high level of abstraction into a \nmore detailed level (lower level) of abstraction. At the highest \nlevel of abstraction, function or information is defined \nconceptually without providing any information about the \ninternal workings of the function or internal structure of the data. As we proceed towards the lower levels of abstraction, more and \nmore details are available.", "domains": ["Design Patterns", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 44", "position": 44, "chunk_type": "semantic", "token_estimate": 135}
{"text": "Note: Stepwise refinement can also be performed for PROCESS: and OUTPUT phase. Refactoring \nRefactoring is an important design activity that reduces the \ncomplexity of module design keeping its behaviour or function \nunchanged. Refactoring can be defined as a process of modifying a \nsoftware system to improve the internal structure of design \nwithout changing its external behavior. During the refactoring \nprocess, the existing design is checked for any type of flaws like \nredundancy, poorly constructed algorithms and data structures, \netc., in order to improve the design. For example, a design model \nmight yield a component which exhibits low cohesion (like a \ncomponent performs four functions that have a limited \nrelationship with one another). Software designers may decide to \nrefactor the component into four different components, each \nexhibiting high cohesion. This leads to easier integration, testing, \nand maintenance of the software components. Structural Partitioning  \nWhen the architectural style of a design follows a hierarchical \nnature, the structure of the program can be partitioned either \nhorizontally or vertically. In horizontal partitioning, the control \nmodules are used to communicate between functions and execute \nthe functions. Structural partitioning provides the following \nbenefits. \uf0b7 The testing and maintenance of software becomes easier. \uf0b7 The negative impacts spread slowly. \uf0b7 The software can be extended easily.", "domains": ["Design Patterns", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 46", "position": 46, "chunk_type": "semantic", "token_estimate": 209}
{"text": "Besides these advantages, horizontal partitioning has some: disadvantage also. It requires to pass more data across the \nmodule interface, which makes the control flow of the problem \nmore complex. This usually happens in cases where data moves \nrapidly from one function to another. In vertical partitioning, the functionality is distributed among \nthe modules--in a top-down manner. The modules at the top level \ncalled control modules perform the decision-making and do \nlittle processing whereas the modules at the low level \ncalled worker modules perform all input, computation and \noutput tasks. Concurrency \nComputer has limited resources and they must be utilized \nefficiently as much as possible. To utilize these resources \nefficiently, multiple tasks must be executed concurrently. This \nrequirement makes concurrency one of the major concepts of \nsoftware design. Every system must be designed to allow multiple \nprocesses to execute concurrently, whenever possible. For \nexample, if the current process is waiting for some event to occur, \nthe system must execute some other process in the mean time. However, concurrent execution of multiple processes sometimes \nmay result in undesirable situations such as an inconsistent state,", "domains": ["Design Patterns", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 47", "position": 47, "chunk_type": "semantic", "token_estimate": 182}
{"text": "deadlock, etc. For example, consider two processes A and B and a: data item Q1 with the value '200'. Further, suppose A and B are \nbeing executed concurrently and firstly A reads the value of Q1 \n(which is '200') to add '100' to it. However, before A updates es \nthe value of Q1, B reads the value ofQ1 (which is still '200') to add \n'50' to it. In this situation, whether A or B first updates the value \nof Q1, the value of would definitely be wrong resulting in an \ninconsistent state of the system. This is because the actions of A \nand B are not synchronized with each other. Thus, the system \nmust control the concurrent execution and synchronize the \nactions of concurrent processes. One way to achieve synchronization is mutual exclusion, which \nensures that two concurrent processes do not interfere with the \nactions of each other. To ensure this, mutual exclusion may use \nlocking technique. In this technique, the processes need to lock \nthe data item to be read or updated. The data item locked by some \nprocess cannot be accessed by other processes until it is \nunlocked. It implies that the process, that needs to access the data \nitem locked by some other process, has to wait. Developing a Design Model  \nTo develop a complete specification of design (design model), \nfour design models are needed. These models are listed below. 1. Data design: This specifies the data structures for \nimplementing the software by converting data objects and \ntheir relationships identified during the analysis phase. Various studies suggest that design engineering should \nbegin with data design, since this design lays the foundation \nfor all other design models. 2. Architectural \ndesign: This \nspecifies \nthe \nrelationship \nbetween the structural elements of the software, design", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 48", "position": 48, "chunk_type": "semantic", "token_estimate": 294}
{"text": "patterns, architectural styles, and the factors affecting the: ways in which architecture can be implemented. 3. Component-level \ndesign: This \nprovides \nthe \ndetailed \ndescription of how structural elements of software will \nactually be implemented. 4. Interface \ndesign: This \ndepicts \nhow \nthe \nsoftware \ncommunicates with the system that interoperates with it \nand with the end-users. Differentiate Between Top Down and Bottom UP Approaches \nIn top down strategy we start by testing the top of the hierarchy \nand we incrementally add modules that it calls and then test the \nnew combined system. This approach of testing requires stubs to \nbe written. A stub is a dummy routine that simulates a module.", "domains": ["Design Patterns", "Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 49", "position": 49, "chunk_type": "semantic", "token_estimate": 108}
{"text": "In the top-down approach, a module cannot be tested in isolation: because they invoke some other modules. To allow the modules \nto be tested before their subordinates have been coded, stubs \nsimulate the behavior of the subordinates. The bottom-up approach starts from the bottom of the hierarchy. First the modules at the very bottom, which have no subordinates, \nare tested. Then these modules are combined with higher-level \nmodules for testing. At any stage of testing all the subordinate \nmodules exist and have been tested earlier. To perform bottom-up testing, drivers are needed to set up the \nappropriate environment and invoke the module. It is the job of \nthe driver to invoke the module under testing with the different \nset of test cases.", "domains": ["Code Organization"], "source": "MCS_202_SOFTWARE ENGINEERING_UNIT_II_Software Design Basics.pdf", "section": "Page 50", "position": 50, "chunk_type": "semantic", "token_estimate": 122}
