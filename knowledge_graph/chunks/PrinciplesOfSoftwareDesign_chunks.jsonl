{"text": "The notion that a complex system can be completely designed in every detail before \nimplementation begins is fallacious. Such an approach deprives designers of valuable \nknowledge and experience that come only from actually implementing the design. The \nopposite extreme is also dangerous, starting implementation having done little or no \ndesign at all. Those who start coding immediately and wing it as they go are even more \nprone to failure than those who try to design everything up front. The truth lies between \nthese two extremes. You should do enough design to have a fairly detailed idea of how \nthings will work, and then implement the design to discover its deficiencies. Then, go \nback and incorporate what you\u2019ve learned into the design, and then implement some \nmore. This process will eventually converge on a good design. Abstraction \nAbstraction is one of the software designer\u2019s primary tools for coping with complexity. Most programming languages and their associated libraries are meant to be general \npurpose. They can be used to implement solutions to problems in any application domain \n(finance, retail, biology, communications, etc.). Due to their general purpose nature, \nthese languages provide only low-level abstractions such as bit, byte, character, string, \ninteger, float, array, file, etc. that model the machines on which the software will run \nrather than the application domain of the problem being solved. Programs written solely \nin terms of these low-level abstractions are extremely difficult to understand. Effective \nsoftware design requires the creation of new, higher-level abstractions that map directly \nto the application domain rather than the underlying computer. In object-oriented design, application-specific abstractions are represented as classes. Classes encapsulate the state (or data) and operations (or algorithms) associated with a \nparticular higher-level application concept. For example, the design for a word processor \nwould contain classes such as Document, Font, Table, Figure, and Printer. Similarly, the design for a web browser would contain classes such as Favorites, \nURL, Viewer, and NetworkProtocol. Software written in terms of such higher-\nlevel abstractions is far more understandable to the human reader because it is expressed \nin terms of the application domain rather than the underlying machine. There may also be mid-level abstractions such as ArrayList, ThreadPool, and \nConnectionManager that don\u2019t map directly the concepts of the application domain, \nbut that still play an important role in the implementation of the system.", "domains": ["Design Patterns"], "source": "PrinciplesOfSoftwareDesign.pdf", "section": "Page 2", "position": 2, "chunk_type": "semantic", "token_estimate": 388}
{"text": "string contained a valid phone number, the constructor would store it in the object: for later use. If the string was not a valid phone number, an exception would be \nthrown. Domain checking is an excellent reason to create classes to represent \ndata values that could otherwise be stored directly as built-in data types. 2) Additional Operations \u2013 Creating classes to represent simple data values provides \na place to put operations that operate on those data types. For example, URLs \ncould be stored directly as strings, but if we do so there will be no place to locate \nURL-related algorithms that may be needed as the program evolves (parsing \nURLs into their component parts, resolving relative URLs, etc.). Creating a URL \nclass, however, would provide an excellent place to put such URL-related \noperations. 3) Code Readability \u2013 Creating classes for simple abstractions can enhance a \nprogram\u2019s readability. For example, if you see a variable of type String, you \ndon\u2019t know much about what the variable represents. If you see a variable of type \nURL, you know a lot about what it represents (i.e., a URL). Creating classes for \nsimple data types enhances readability because variable, parameter, and return \ntypes are much more descriptive about what kind of data they represent. Of \ncourse, giving good names to variables and parameters will go a long way toward \ntelling the reader what kind of data they represent. Return values, however, don\u2019t \nhave names (at least not directly). Decomposition \nIn addition to abstraction, another fundamental technique for dealing with complexity is \ntaking the original problem and dividing it into several smaller sub-problems. The sub-\nproblems are smaller and hence less complex than the original, thus making them more \napproachable. After solving each sub-problem individually, the solutions to the sub-\nproblems can be combined to create a solution to the original, larger problem. This \napproach is frequently called \u201cdivide and conquer\u201d. After breaking the original problem into sub-problems, we may find that the sub-\nproblems themselves are still too complex to solve directly. In this case, we decompose \nthe sub-problems yet again to create second-level sub-problems that are even simpler. Sub-problems are divided into smaller and smaller parts until the smallest sub-problems \nare simple enough to solve directly, and thus require no further subdivision. In effect, we \ncreate a tree of problems, where the original problem is at the root, and each successive \nlevel of subdivision adds another level of nodes to the tree.", "domains": ["Code Organization"], "source": "PrinciplesOfSoftwareDesign.pdf", "section": "Page 5", "position": 5, "chunk_type": "semantic", "token_estimate": 409}
{"text": "It is through the decomposition process that many of the necessary abstractions are: discovered (or invented). Levels of Design \n \n \nSystem \n \n \n \nSubsystems \n \n \n \nPackages \n \n \n \n \nClasses \n \n \nRoutines \n \n \n \nDecomposition is inherently a top-down process. At the topmost level we have the entire \nsystem. The first level of decomposition divides the system into subsystems, each of \nwhich represents a major but somewhat independent chunk of the system\u2019s functionality. For example, the subsystems for a web browser might be Network Protocols, \nFile Viewers, History, Favorites, Printing, etc. At the next level of decomposition, each subsystem is further subdivided into packages. Each package is responsible for implementing a part of the subsystem\u2019s functionality. For example, a web browser\u2019s File Viewers subsystem might contain a separate \npackage for each different file format that the browser can display (HTML, PDF, XML, \netc.). The package corresponding to a particular format would contain the code that \nimplements the file viewer for that format. A package is further decomposed into a collection of one or more classes that together \nimplement that package\u2019s functionality. For example, the web browser\u2019s HTML viewer \nmight consist of a dozen different classes. The functionality of each class is further decomposed into routines which implement the \noperations (or algorithms) of the class. Significant algorithms are typically decomposed", "domains": ["Code Organization"], "source": "PrinciplesOfSoftwareDesign.pdf", "section": "Page 6", "position": 6, "chunk_type": "semantic", "token_estimate": 209}
{"text": "replacing the original statements with a call to the new subroutine will do much to: simplify the original routine. Consistently applying this technique of algorithm \ndecomposition will have a significant positive impact on the quality of your code. Algorithm & Data Structure Selection \nA major part of software design is selecting appropriate algorithms and data structures for \nthe problem at hand. Using an algorithm that is O(n3) on data sets that become very large \nwill almost certainly be far too slow, regardless of how well we have decomposed and \nabstracted the problem. Similarly, storing data values as unsorted, linear lists will be far \ntoo slow if the data set is large and needs to be searched frequently. Selecting (or \ninventing) algorithms and data structures with good performance characteristics \n(including running time and memory consumption) for the intended application is a \nfundamental design skill. No amount of decomposition or abstraction will hide a \nfundamentally flawed selection of algorithm or data structure. Minimize Dependencies (or, Low Coupling) \nLarge systems contain many classes. As a system is decomposed into its constituent \nclasses, it is important to keep each class as independent as possible from the other \nclasses in the system. Classes A and B depend on each other if: \n \n1) Class A invokes a method on class B \n2) Class A accesses the internal state of class B \n3) Class A inherits from class B \n4) Class A has a method parameter of class B \n5) Class A and Class B both access the same global data structure or file \n6) Etc. Minimizing the number of communication channels and interactions between different \nclasses has several benefits: \n \n1) A class with few dependencies on other classes is generally easier to understand \nthan a class with many dependencies on other classes (i.e., dependencies increase \na class\u2019s complexity) \n2) A class with few dependencies on other classes is less prone to ripple effects \ncaused by changes or defects in other classes (i.e., dependencies make a system \nharder to modify and debug). 3) A class with few dependencies on other classes is easier to reuse in a different \nprogram than a class with many dependencies (i.e., dependencies discourage \nreuse). Imagine a system in which every class depends on every other class. Every time any \nclass is changed, we must consider the potential impact on all other classes (very \nconfusing, indeed).", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "PrinciplesOfSoftwareDesign.pdf", "section": "Page 9", "position": 9, "chunk_type": "semantic", "token_estimate": 393}
{"text": "At the other extreme, imagine a system where there are no dependencies between classes: (i.e., each class is an island unto itself). In this case, the software doesn\u2019t do anything. Making a program perform useful functions requires a certain level of communication \n(and therefore dependency) between the classes in the system. The goal is not to remove \nall dependencies, but rather to minimize the number and strength of dependencies. When two classes must interact, it is desirable to keep the interaction as simple and \nstraightforward as possible. The ideal form of interaction between two classes is through \nsimple method calls. A method call is simple if it has a good name and the data passed \nthrough the parameter list and return value is easy to understand. Simple method calls \nhave the advantage of being direct and obvious in the code. Other more indirect forms of \ncommunication between classes, such as accessing the same global data structure, make \nthe dependency less explicit and harder to detect and comprehend. To the extent \npossible, interactions between classes should be through explicit, well-defined method \ninterfaces. Separation of Interface and Implementation \nOne important technique for minimizing dependencies between classes is maintaining a \nstrict separation between a class\u2019s public interface and its internal implementation. A \nclass\u2019s public interface consists of the operations (or methods) through which clients can \naccess its services. In order to use a class, a client needs only to understand the class\u2019s \npublic interface. The details of how the public interface is implemented internally are \nincidental to the client, and should not be accessed or relied upon by the client in any \nway. The code that implements the public interface, including all variables and \nsubroutines that support that code, should not be accessed by clients. By relying only on \nthe details of the public interface, a class\u2019s internal implementation can be changed \nwithout affecting (i.e., breaking) its clients. Only changes to the public interface itself \naffect the clients. The strict separation of interface and implementation goes a long way \ntoward minimizing dependencies between classes. Information Hiding \nBecause the separation of interface and implementation is so central to good software \ndesign, programming languages often provide features to help enforce this separation. Some languages physically separate a class\u2019s public interface and internal \nimplementation into separate source files. Other languages require the designer to \ndeclare all class features (variables and methods) as \u201cpublic\u201d, \u201cprivate\u201d, or \u201cprotected\u201d, \nthus preventing clients from accessing private details.", "domains": ["Code Organization"], "source": "PrinciplesOfSoftwareDesign.pdf", "section": "Page 10", "position": 10, "chunk_type": "semantic", "token_estimate": 407}
{"text": "At the other extreme, imagine a system where there are no dependencies between classes: Some languages physically separate a class\u2019s public interface and internal \nimplementation into separate source files. Other languages require the designer to \ndeclare all class features (variables and methods) as \u201cpublic\u201d, \u201cprivate\u201d, or \u201cprotected\u201d, \nthus preventing clients from accessing private details. Such language features encourage \ndesigners to hide as much information as possible from clients, thus reducing \nopportunities for dependency between classes. A class\u2019s public interface should be as small (or \u201cthin\u201d) as possible, ideally including \nonly a small number of methods. Each public method\u2019s parameters should be as simple \nas possible. All internal variables should be hidden, and only methods that are directly \ninvoked by clients should be made public.", "domains": ["Code Organization"], "source": "PrinciplesOfSoftwareDesign.pdf", "section": "Page 10", "position": 10, "chunk_type": "semantic", "token_estimate": 124}
{"text": "This advice applies even to inheritance relationships.  By making variables \u201cprotected\u201d, it: is easy for a superclass to directly expose its internal variables to its subclasses. This \nmakes the subclasses highly dependent on the internal details of the superclass. As \nalways, this makes it difficult to change the superclass implementation without breaking \nthe subclasses. A designer may choose to make superclasses and subclasses highly \ncoupled in this manner, but the downsides of doing so should be considered when making \nthis decision. Another approach would be to define the superclass/subclass interface in \nterms of \u201cprotected\u201d methods only (i.e., no \u201cprotected\u201d variables), thus reducing the level \nof dependency between superclass and subclass. Designers should also be careful to ensure that internal implementation details do not \n\u201cleak out\u201d of a class. For example, a method that performs a search algorithm might be \nnamed binarySearch. Unfortunately, the name binarySearch reveals the \nmethod\u2019s internal implementation. This choice of name forever binds the method to use \nthe binary search algorithm as its implementation. Alternatively, naming the method \nsearch would preserve the designer\u2019s freedom to vary the internal algorithm without \nviolating the client contract. Similarly, a grade-keeping program might represent the notion of a class roll with a class \nnamed StudentLinkedList. However, doing so betrays the fact that the class uses a \nlinked list as the internal data structure for storing a sequence of students. A better \nchoice would be to name the class ClassRoll, thus hiding all details of how students \nare actually stored internally, and preserving freedom to change that representation at \nwill. There are times, however, when a class or method is inherently tied to a particular \nimplementation. In such cases, it is appropriate to name classes or methods in terms of \ntheir internal details. For example, a class whose sole purpose is to implement a hash \ntable could appropriately be named HashTable because its implementation is an \ninherent part of its existence. A hash table will always be a hash table, and that will \nnever change. However, clients of the HashTable class should not reveal their internal \nuse of HashTable unless that choice is inherent and will never change. Avoid Code Duplication \nAnother core principle of good software design is that code duplication should be \nstrenuously avoided. Frequently, programs will contain duplicated sections of code, or \nsections of code that are very similar.", "domains": ["Code Organization"], "source": "PrinciplesOfSoftwareDesign.pdf", "section": "Page 11", "position": 11, "chunk_type": "semantic", "token_estimate": 390}
{"text": "3) Duplication makes the program longer, thus decreasing its maintainability.: If the same or similar code appears in N places, the obvious solution is to isolate the \nduplicated code in one place, and then have all N clients invoke the shared copy. If all N \ncopies are in the same class, the duplicated code can be factored out into a private method \non that class. If the N copies are in different classes, the shared copy could be placed on \none of the client classes, or placed on some other (possibly new) class that provides a \nlogical home for the shared code. Another solution would be to place the shared code in \na superclass, and then make each client class a subclass of the superclass. If the duplicated code is similar but not identical, it might be possible to create a generic \nversion that will serve the needs of all clients. If the implementation language provides \ngeneric types (e.g., C++ templates), a generic type or subroutine will often be a good \nimplementation choice for the shared code. Design Principles Summary \n1. Abstraction \na. Naming \nb. Cohesion \nc. Abstracting All the Way \n2. Decomposition \na. Levels of Design (System, Subsystem, Package, Class, Routine) \nb. Hypo- and Hyper- Decomposition \nc. Size and Length Metrics \nd. Complexity Metrics \n3. Algorithm & Data Structure Selection \n4. Minimize Dependencies (or, Low Coupling) \na. Separation of Interface and Implementation \nb. Information Hiding \n5. Avoid Code Duplication", "domains": ["Software Quality Attributes", "Code Organization"], "source": "PrinciplesOfSoftwareDesign.pdf", "section": "Page 12", "position": 12, "chunk_type": "semantic", "token_estimate": 240}
