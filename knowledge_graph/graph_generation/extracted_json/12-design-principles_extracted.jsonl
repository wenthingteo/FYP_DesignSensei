{"text": "Design Principles\n1\n", "page": 1, "type": "text", "section": "Page 1"}
{"text": "Previous Code Convention Discussions\n\u2022 Style\n\u2022 What does the code look like?\n\u2022 Is it consistent, scalable, and maintainable?\n\u2022 Appearance, format, readability\n\u2022 Naming\n\u2022 How are we describing the identifiers in our code?\n\u2022 Are they understandable?\n\u2022 Do the names reflect purpose/responsibility?\n\u2022 Program comprehension\n2\n", "page": 2, "type": "text", "section": "Page 2"}
{"text": "SOLID Principles for Object-Oriented Design\n\u2022 Five basic principles (guidelines) for Object-Oriented Design (OOD)\n\u2022 Results in systems that are:\n\u2022 Easy to maintain\n\u2022 Easy to extend\n\u2022 SOLID is a guide for:\n\u2022 Creating designs from scratch\n\u2022 Improving existing designs\n3\n", "page": 3, "type": "text", "section": "Page 3"}
{"text": "SOILD Principles\n\u2022 Single Responsibility Principle (SRP)\n\u2022 Open/closed Principle (OCP)\n\u2022Liskov Substitution Principle (LSP)\n\u2022Interface Segregation Principle (ISP)\n\u2022Dependency Inversion Principle (DIP)\n4\n", "page": 4, "type": "text", "section": "Page 4"}
{"text": "Single Responsibility Principle\n\u2022 Every class should have A SINGLE RESPONSIBILITY\n\u2022 The responsibility of a class drives its need to change\n\u2022 Responsibility should be entirely encapsulated by the class\n\u2022 All functionality of the class should focus on that single responsibility\n\u2022 Why? \n\u2022 More cohesive\n\u2022 Easier to understand\n\u2022 Easier to maintain\n5\n", "page": 5, "type": "text", "section": "Page 5"}
{"text": "SRP Analysis\n\u2022 A basic method for determining if a method belongs with a given \nclass.\n\u2022 A rough approximation\n\u2022 Need to apply context about the domain and the abstraction\nThe _[class name] \n_[method name]_ itself. \n6\n", "page": 6, "type": "text", "section": "Page 6"}
{"text": "7\n", "page": 7, "type": "text", "section": "Page 7"}
{"text": "8\n", "page": 8, "type": "text", "section": "Page 8"}
{"text": "9\n", "page": 9, "type": "text", "section": "Page 9"}
{"text": "SRP Example\n10\n", "page": 10, "type": "text", "section": "Page 10"}
{"text": "SRP Example - Violation\n11\n", "page": 11, "type": "text", "section": "Page 11"}
{"text": "SRP Example - Compliant\n12\n", "page": 12, "type": "text", "section": "Page 12"}
{"text": "Open/Closed Principle\n\u2022 Software entities (classes, function, etc.) should be open for extension but \nclosed for modification\n\u2022 Closed - as can be compiled, stored in a library, and used by client classes\n\u2022 Open - as any new class can inherit and add new features\n\u2022 Why? \n\u2022 Client code dependent on base (closed) class unaffected\n\u2022 Less testing\n\u2022 Less code to review\n13\n", "page": 13, "type": "text", "section": "Page 13"}
{"text": "Meyer\u2019s Open/Closed Principle\n\u2022 Implementation is extended through inheritance\n\u2022 \u201cOpen\u201d means available for extension (generalization/inheritance)\n\u2022 \u201cClosed\u201d to avoid changes to the original class\n\u2022 New functionality by adding a new class, not changing current ones\n\u2022 Results in tight coupling between base and derived classes\n14\n", "page": 14, "type": "text", "section": "Page 14"}
{"text": "Polymorphic Open/Closed Principle\n\u2022 Abstract base class and multiple implementations that we can \nsubstitute for each other\n\u2022 Base design on abstract base classes\n\u2022 Focus on sharing the interface, not the implementation\n\u2022 \u201cCode to an interface, not an implementation\u201d\n\u2022 Reuse implementation via delegation\n\u00ababstract\u00bb\nParser\n+parse()\nParserImplementation\n+parse()\nParserRubyImplementation\n+parse()\n15\n", "page": 15, "type": "text", "section": "Page 15"}
{"text": "Liskov Substitution Principle\n\u2022 An Object in a program should be replaceable with an instance of subtypes \nwithout affecting program correctness\n\u2022 \u201cObjects of subtypes should behave like those of supertypes if used via supertype \nmethods.\u201d\n\u2022 Preconditions cannot be strengthened in a subtype\n\u2022 Postconditions cannot be weakened in a subtype\n\u2022 Invariants of supertype must be preserved in subtype\n\u2022 History constraint - new methods in subtype cannot introduce state \nchanges in a way that is not permissible in the supertype\n\u2022 Why? \n\u2022 Knowledge/assumptions about base class apply to the subclass\n\u2022 Easier to understand\n\u2022 Easier to maintain.\n16\n", "page": 16, "type": "text", "section": "Page 16"}
{"text": "LSP Example\n17\n", "page": 17, "type": "text", "section": "Page 17"}
{"text": "LSP Example - Violation\n18\n", "page": 18, "type": "text", "section": "Page 18"}
{"text": "LSP Example\n19\n", "page": 19, "type": "text", "section": "Page 19"}
{"text": "LSP Example\n20\n", "page": 20, "type": "text", "section": "Page 20"}
{"text": "21\n", "page": 21, "type": "text", "section": "Page 21"}
{"text": "Interface Segregation Principle\n\u2022 A client should NOT be forced to depend on methods it does not use\n\u2022 Having many client-specific interfaces is better than one general-\npurpose interface\n\u2022 Why?\n\u2022 More cohesive\n\u2022 Lower coupling\n\u2022 Easier to understand\n\u2022 Easier to maintain\n22\n", "page": 22, "type": "text", "section": "Page 22"}
{"text": "ISP Example \u2013 How can we make this better?\n23\n", "page": 23, "type": "text", "section": "Page 23"}
{"text": "ISP Example \u2013 How can we make this better?\nBird\n#name: string\nFlyingBird\n+fly()\nOstrich\nDuck\nCREATED WITH YUML\n24\n", "page": 24, "type": "text", "section": "Page 24"}
{"text": "Dependency Inversion Principle\n\u2022 Depend upon abstractions, not concretions (specific implementations \nof an abstraction)\n\u2022 Abstractions should not depend on details, but details on abstractions\n\u2022 High-level modules are independent and should not depend on low-\nlevel modules\n\u2022 Why?\n\u2022 Lower coupling\n\u2022 Reuse\n\u2022 Easier to test\n\u2022 Easer to understand\n\u2022 Easier to maintain\n25\n", "page": 25, "type": "text", "section": "Page 25"}
{"text": "DIP Example\n26\n", "page": 26, "type": "text", "section": "Page 26"}
{"text": "DIP Example \u2013 Can We Do Better?\n27\n", "page": 27, "type": "text", "section": "Page 27"}
{"text": "DIP Example \u2013 Can We Do Better?\nhttps://medium.com/@kedren.villena/simplifying-dependency-inversion-principle-dip-59228122649a\nLamp\n#isOn: boolean\n#powerSource: OutletInterface\n+turnOn()\n+turnOff()\n+changeOutlet(OutletInterface)\n<<OutletInterface>>\nDormOutlet\nGarageOutlet\nClassroomOutlet\nCREATED WITH YUML\n28\n", "page": 28, "type": "text", "section": "Page 28"}
{"text": "29\n", "page": 29, "type": "text", "section": "Page 29"}
{"text": "Other Helpful Principles\n\u2022 DRY- Don\u2019t Repeat Yourself\n\u2022 Use functional decomposition or abstractions to reduce redundancies\n\u2022 YAGNI \u2013 You Aren\u2019t Gonna Need It\n\u2022 Don\u2019t try to build out features now that you think your software MIGHT need \nlater\n\u2022 Software development is too volatile for that, focus on what is needed now \nand the maintainability of your design\n\u2022 Occam\u2019s Razor/KISS \u2013 Keep it simple\n\u2022 Don\u2019t introduce unnecessary complexity or overblown designs\n\u2022 GRASP \u2013 General Responsibility Assignment Software Patterns\n\u2022 Design patterns that can help with your software design/implementation\n\u2022 More on design patterns later\u2026\n30\n", "page": 30, "type": "text", "section": "Page 30"}
{"text": "Conclusion\n\u2022 Meant to be applied together\n\u2022 Make it more likely that the system is easy to maintain and extend \nover time\n\u2022 SOLID principles are guidelines\n\u2022 Do not guarantee success\n\u2022 Can be misused\n\u2022 Use in conjunction with other principles\n\u2022 Don\u2019t chase perfection\n\u2022 Design based on your needs \n\u2022 Good enough design gets software delivered\n31\n", "page": 31, "type": "text", "section": "Page 31"}
