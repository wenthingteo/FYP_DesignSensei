{"text": "TCSS 360 C: Software Development & Quality \nAssurance Techniques [Winter 2017]  \nInstitute of Technology, UW-Tacoma\n1/23/2017\nSlides by Wes J. Lloyd\nL8.1\nSoftware Design and\nSOLID Principles\nWes J. Lloyd\nInstitute of Technology\nUniversity of Washington - Tacoma\nTCSS 360: SOFTWARE DEVELOPMENT \nAND QUALITY ASSURANCE\nSessionMgr\nSessionMgr\nDatabase\nDatabase\nread_from_db()\nstore_in_db()\nread_from_db()\nstore_in_db()\nSessionMgr\nSessionMgr\nget_session()\nstore_session()\nget_session()\nstore_session()\n\u00abinterface\u00bb\nSessionStore\n\u00abinterface\u00bb\nSessionStore\nDatabase\nDatabase\n\u0001 From chapter 11: Engineering SaaS\n\u0001SOLID Design Principles\n\u0001Design Patterns\n\u0001Software Metrics\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.2\nOBJECTIVES\n\u0001 Single Responsibility\n\u0001 A class should have one and only one reason to change\n\u0001 Open/Closed\n\u0001 Classes should be open for extension but closed for modification\n\u0001 Liskov Substitution\n\u0001 Substituting a subclass for a class should preserve correct program \nbehavior\n\u0001 Interface Segregation\n\u0001 No client should depend on methods it does not use\n\u0001 Injecting Dependencies\n\u0001 Collaborating classes who implementation may vary at runtime \nshould depend on an intermediate \u201cinjected\u201d dependency\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.3\nSOLID DESIGN GUIDELINES\n\u0001 A class should have one and only one responsibility\n\u0001 Example: class named \u201cReviewers\u201d  in CoffeeFinder which \ndefines information about users who review coffee shops\n\u0001 A \u201csign-on\u201d operation could be added to \u201cReviewers\u201d \nto enable a reviewer to log in \n\u0001 This does not separate responsibility!\n\u0001 Single Responsibility:\nUse a \u201cSessions\u201d class\n\u0001 Decouples the design of logging-in from the Reviewers Class \n\u0001 What if the authentication strategy changes?\n\u0001 Reviewers class would need to change\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.4\nSINGLE RESPONSIBILITY PRINCIPLE\n\u0001 \u201cSign-on\u201d operation added to \u201cReviewers\u201d Class\n\u0001 How do other classes of users sign-on?\n\u0001 Does each user class implement their own?\n\u0001 Decouple key features/functions into reusable classes\n\u0001 MVC: Controllers\n\u0001 Each controller provides business logic for system components\n\u0001 Components\n\u0001 ReviewerController: User who contributes coffee shop reviews\n\u0001 UserController: General system user\n\u0001 AdminController: Admin user that performs DB maintenance\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.5\nSINGLE RESPONSIBILITY - 2\n\u0001 Classes should be: open for extension, \nbut closed for modification\n\u0001 Extending a class shouldn\u2019t require modifying existing \ncode\n\u0001 Case statement code smell:\n\u0001 Factory pattern\n\u0001 Template pattern\n\u0001 Strategy pattern\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.6\nOPEN/CLOSED PRINCIPLE (OCP)\nClass Report\ndef output\nformatter = \ncase @format\nwhen :html\nHtmlFormatter.new(self)\nwhen :pdf\nPdfFormatted.new(self)\n# . . . Etc\nend\nend\nend  \n", "page": 1, "type": "text", "section": "Page 1"}
{"text": "TCSS 360 C: Software Development & Quality \nAssurance Techniques [Winter 2017]  \nInstitute of Technology, UW-Tacoma\n1/23/2017\nSlides by Wes J. Lloyd\nL8.2\n\u0001 Class subtypes can substitute for base types\n\u0001 Current formulation attributed to (Turing Award winner) \nBarbara Liskov\nType/subtype != Class/subclass\nAll of T\u2019s subtypes should preserve T\u2019s \ncontract\u2026\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.7\nLISKOV SUBSTITUTION PRINCIPLE (LSP)\n\u201cA method that works on an instance of \ntype T, should also work on any \nsubtype of T\u201d\n\u0001 Clients should not be forced to depend on methods \nthey do not use\u2026\n\u0001 Split large interfaces into smaller, more specific ones\n\u0001 ISP reduces coupling\n\u0001 High code coupling is \ncorrelates with higher\nsoftware maintenance\ncosts\n\u0001 Code is harder to modify,\nrefactor, extend\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.8\nINTERFACE SEGREGATION PRINCIPLE (ISP)\n\u0001 Coupling measures dependencies between \nsubsystems\n\u0001 High coupling: changes to one subsystem will have \nhigh impact on the other subsystem \u2013 BAD!!\n\u0001 Require change of model, massive compilation\n\u0001 Low coupling: change in one subsystem does not \naffect any other subsystem - - GOOD!!\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.9\nISP: COUPLING SUMMARY\n\u0001 Also called dependency injection\u2026\n\u0001 If two classes depend on each other, but their \nimplementations may change, it is better if they depend on an \nabstract interface that is \u201cinjected\u201d dynamically\n\u0001 Enables interface to change with changing original class\n\u0001 Code is not statically bound to the external dependency\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.10\nDEPENDENCY INVERSION PRINCIPLE (DIP)\n\u0001 Example: one class (user code), makes use of a 3rd party \nlibrary or framework (e.g. logging API)\n\u0001 Without dependency injection, the user class is dependent \n(coupled) to the 3rd party library or framework\n\u0001 \u201cCoupling\u201d becomes pandemic throughout the code\n\u0001 It\u2019s everywhere\u2026\n\u0001 If the 3rd party library goes defunct (company or group \ndisbands), program code is now dependent on an unsupported \nlibrary\n\u0001 Solution: Inject an abstract logging interface \n(which a 3rd party library or framework implements)\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.11\nDIP: EXAMPLE\n\u0001 Traditional coupling to logging class (API)\n\u0001 Program must have access to a specific 3rd party library\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.12\nDIP: JAVA EXAMPLE\npackage com.example.e4.rcp.todo.parts;\nimport java.util.logging.Logger;\npublic class MyClass {\nprivate final static Logger logger;\npublic MyClass(Logger logger) {\nthis.logger = logger;\n// write an info log message\nlogger.info(\"This is a log message.\")\n}\n}\n", "page": 2, "type": "text", "section": "Page 2"}
{"text": "TCSS 360 C: Software Development & Quality \nAssurance Techniques [Winter 2017]  \nInstitute of Technology, UW-Tacoma\n1/23/2017\nSlides by Wes J. Lloyd\nL8.3\n\u0001 Using Java annotations to inject to dependent logger\n\u0001 Enables use of \u201cmock objects\u201d for testing\n\u0001 Can inject a \u201cmock object\u201d of a library not yet available\n\u0001 Another developer may be completing the code\n\u0001 Mock object implements generic interface \nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.13\nDIP: JAVA EXAMPLE - 2\npublic class MyPart {\n@Inject private Logger logger;\n// inject class for database access\n@Inject private DatabaseAccessClass dao;\n@Inject\npublic void createControls(Composite parent) {\nlogger.info(\"UI will start to build\");\nLabel label = new Label(parent, SWT.NONE);\nlabel.setText(\"Eclipse 4\");\nText text = new Text(parent, SWT.NONE);\ntext.setText(dao.getNumber());\n}\n}\n\u0001 Annotation location \u2013 where the dependency is injected\n\u0001 Constructor of the class (construction injection)\n\u0001 Field variable (field injection)\n\u0001 Parameters of a method (method injection)\n\u0001 Dependency injection occurs \nin same order: constructor, \nfields, method parameters\n\u0001 Frameworks exist to assist \nnative dependency injection \n\u0001 AspectJ\nAspect Oriented Programming\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.14\nDIP: JAVA ANNOTATIONS\n\u0001 Language extension for dynamic dependency injection (AspectJ)\n\u0001 Less coupling that with Java annotations (interface)\n\u0001 Programming paradigm to increase modularity by separating cross-\ncutting concerns. \n\u0001 Behavior is declared into \u201cadvices\u201d, similar to a classes - they \ndefine behavior (e.g. logging) without modifying main program.  \n\u0001 Pointcut specifications define where advices are to be \nautomatically \u201cweaved\u201d into the main program\u2026  \n\u0001 Example pointcut: log all function calls when the function's name \nbegins with 'set'. \n\u0001 Behaviors not central to the business logic (such as logging) can be \nadded to a program without changing or cluttering main program\n\u0001 AOP forms the basis for aspect-oriented software development.\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.15\nDIP: ASPECT ORIENTED PROGRAMMING\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.16\nCOUPLING LEVELS\n\u0001 Content: one module relies on internal \nworkings or data of another.  One class reads/depends on\nanother internal variables\n\u0001 Common: two modules share global data; all modules using\nthe global data are impacted by a change\n\u0001 External: two modules share an externally imposed data\nformat, communication protocol, device interface\n\u0001 Control: one module controls the flow of another by passing\nit information on what to do\n\u0001 Stamp: modules share a common data structure, though may \nonly sparsely use some of its fields\n\u0001 Data: modules share data through parameters passing\n\u0001 Message: modules communicate through message passing\ncode not explicitly coupled, messages come through channels\nAspectJ (functionality injected at joinpoints)\nJava annotations (interface coupling)\n\u0001 Alternate solution to dependency inversion \n\u0001 Define an \u201cAdapter\u201d class\n\u0001 Serves to convert an existing API into one that\u2019s \ncompatible with an existing caller\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.17\nDIP: ADAPTER PATTERN\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.18\nDIP: ADAPTER PATTERN\npublic interface MediaPlayer {\npublic void play(String audioType, String fileName);\n}\npublic interface AdvancedMediaPlayer {\npublic void playVlc(String fileName);\npublic void playMp4(String fileName);\n}\npublic class VlcPlayer implements AdvancedMediaPlayer ... {}\npublic class MediaAdapter implements MediaPlayer {\nAdvancedMediaPlayer advancedMusicPlayer;\npublic MediaAdapter(String audioType){\nif(audioType.equalsIgnoreCase(\"vlc\") ){\nadvancedMusicPlayer = new VlcPlayer();\n}else if (audioType.equalsIgnoreCase(\"mp4\")){\nadvancedMusicPlayer = new Mp4Player();\n}\n}\n@Override\npublic void play(String audioType, String fileName) {\nif(audioType.equalsIgnoreCase(\"vlc\")){\nadvancedMusicPlayer.playVlc(fileName);\n}\nelse if(audioType.equalsIgnoreCase(\"mp4\")){\nadvancedMusicPlayer.playMp4(fileName);\n}\n}\n}\nAdapter\nClass\nAdapter pattern:\nSupports adding new media player features\nwithout changing dependent code\u2026\n", "page": 3, "type": "text", "section": "Page 3"}
{"text": "TCSS 360 C: Software Development & Quality \nAssurance Techniques [Winter 2017]  \nInstitute of Technology, UW-Tacoma\n1/23/2017\nSlides by Wes J. Lloyd\nL8.4\n\u0001 Single Responsibility\n\u0001 A class should have one and only one reason to change\n\u0001 Open/Closed\n\u0001 Classes should be open for extension but closed for modification\n\u0001 Liskov Substitution\n\u0001 Substituting a subclass for a class should preserve correct program \nbehavior\n\u0001 Interface Segregation\n\u0001 No client should depend on methods it does not use\n\u0001 Injecting Dependencies\n\u0001 Collaborating classes who implementation may vary at runtime \nshould depend on an intermediate \u201cinjected\u201d dependency\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.19\nSOLID DESIGN GUIDELINES\n\u0001 Postgresql database persistence, heroku\u2026\n\u0001 http://faculty.washington.edu/wlloyd/courses/tcss360/tutori\nals/TCSS360_w2017_Tutorial_3.pdf\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL8.20\nTUTORIAL #3\nQUESTIONS\nFebruary 1, 2017\nTCSS360: Software Development and Quality Assurance [Winter 2017]\nInstitute of Technology, University of Washington - Tacoma\nL23.21\n", "page": 4, "type": "text", "section": "Page 4"}
