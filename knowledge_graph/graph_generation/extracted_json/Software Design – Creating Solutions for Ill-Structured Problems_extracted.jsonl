{"text": "Software Design\n", "page": 2, "type": "text", "section": "Page 2"}
{"text": "Chapman & Hall/CRC Innovations in Software Engineering and Software Development \nSeries\nRichard LeBlanc\nSeattle University, Washington, USA\nThis series covers all aspects of software engineering and software development. Books \nin the series include innovative reference books, research monographs, and textbooks \nat the undergraduate and graduate level. The series covers traditional subject matter, \ncutting-edge research, and current industry practice, such as agile software development \nmethods and service-oriented architectures. We also welcome proposals for books that \ncapture the latest results on the domains and conditions in which practices are most \neffective.\nIntroduction to Combinatorial Testing \nD. Richard Kuhn, Raghu N. Kacker, Yu Lei\nSoftware Test Attacks to Break Mobile and Embedded Devices \nJon Duncan Hagar\nSoftware Essentials Design and Construction \nAdair Dingle\nSoftware Metrics A Rigorous and Practical Approach, Third Edition \nNorman Fenton, James Bieman\nComputer Games and Software Engineering \nKendra M. L. Cooper, Walt Scacchi\nEvidence-Based Software Engineering and Systematic Reviews \nBarbara Ann Kitchenham, David Budgen, Pearl Brereton\nEngineering Modeling Languages Turning Domain Knowledge into Tools \nBenoit Combemale, Robert France, Jean-Marc J\u00e9z\u00e9quel, Bernhard Rumpe, James Steel, \nDidier Vojtisek\nSpeed, Data, and Ecosystems Excelling in a Software-Driven World \nJan Bosch\nIntroduction to Software Engineering, Second Edition \nRonald J. Leach\nSoftware Design, Third Edition \nDavid Budgen\nFor more information about this series, please visit: https://www.routledge.com/\nChapman--HallCRC-Innovations-in-Software-Engineering-and-Software-Development/\nbook-series/CHCRCINNSOFEN\n", "page": 3, "type": "text", "section": "Page 3"}
{"text": "Software Design\nCreating Solutions for Ill-\nStructured Problems\nThird Edition\nDavid Budgen\n", "page": 4, "type": "text", "section": "Page 4"}
{"text": "MATLAB\u00ae is a trademark of The MathWorks, Inc. and is used with permission. The MathWorks does not warrant \nthe accuracy of the text or exercises in this book. This book\u2019s use or discussion of MATLAB\u00ae software or related \nproducts does not constitute endorsement or sponsorship by The MathWorks of a particular pedagogical approach \nor particular use of the MATLAB\u00ae software. \nThird edition published 2021 \nby CRC Press\n6000 Broken Sound Parkway NW, Suite 300, Boca Raton, FL 33487-2742\nand by CRC Press\n2 Park Square, Milton Park, Abingdon, Oxon, OX14 4RN\n\u00a9 2021 Taylor & Francis Group, LLC \nFirst edition published by Addison-Wesley 1993\nSecond edition published by Addison-Wesley 2003\nCRC Press is an imprint of Taylor & Francis Group, LLC\nReasonable efforts have been made to publish reliable data and information, but the author and publisher cannot \nassume responsibility for the validity of all materials or the consequences of their use. The authors and publishers \nhave attempted to trace the copyright holders of all material reproduced in this publication and apologize to \ncopyright holders if permission to publish in this form has not been obtained. If any copyright material has not been \nacknowledged please write and let us know so we may rectify in any future reprint.\nExcept as permitted under U.S. Copyright Law, no part of this book may be reprinted, reproduced, transmitted, or \nutilized in any form by any electronic, mechanical, or other means, now known or hereafter invented, including \nphotocopying, microfilming, and recording, or in any information storage or retrieval system, without written \npermission from the publishers.\nFor permission to photocopy or use material electronically from this work, access www.copyright.com or contact \nthe Copyright Clearance Center, Inc. (CCC), 222 Rosewood Drive, Danvers, MA 01923, 978-750-8400. For works \nthat are not available on CCC please contact mpkbookspermissions@tandf.co.uk\nTrademark notice: Product or corporate names may be trademarks or registered trademarks and are used only for \nidentification and explanation without intent to infringe.\nISBN: 9780367676568 (hbk)\nISBN: 9781138196612 (pbk)\nISBN: 9781315300078 (ebk)\nTypeset in Computer Modern font \nby KnowledgeWorks Global Ltd.\nLibrary of Congress Cataloging-in-Publication Data\nNames: Budgen, David, author.  \nTitle: Software design : creating solutions for ill-structured problems /  \nDavid Budgen.  \nDescription: Third edition. | Boca Raton : CRC Press, 2021. | Series:  \nChapman & Hall/CRC innovations in software engineering | Includes  \nbibliographical references and index.  \nIdentifiers: LCCN 2020037195 (print) | LCCN 2020037196 (ebook) | ISBN  \n9781138196612 (paperback) | ISBN 9780367676568 (hardcover) | ISBN  \n9781315300078 (ebook)  \nSubjects: LCSH: Computer software--Development.  \nClassification: LCC QA76.76.D47 B83 2021 (print) | LCC QA76.76.D47  \n(ebook) | DDC 005.1--dc23  \nLC record available at https://lccn.loc.gov/2020037195 \nLC ebook record available at https://lccn.loc.gov/2020037196\n", "page": 5, "type": "text", "section": "Page 5"}
{"text": "To the late Jim Tomayko.\nHistorian, software engineer, teacher, sportsman, coach, aviator, author, fam-\nily man, and an inspiring friend who had a huge heart for others, whatever\ntheir role in life.\n", "page": 6, "type": "text", "section": "Page 6"}
{"text": "Contents\nPreface to the Third Edition\nxiii\nThe City Car Club\n1\nI\nAddressing Ill-Structured Problems\n5\n1\nWhat Is Designing About?\n7\n1.1\nWhen is design needed? . . . . . . . . . . . . . . . . . . . . .\n7\n1.2\nA bit about software\n. . . . . . . . . . . . . . . . . . . . . .\n10\n1.3\nWhat exactly do we mean by \u2018design\u2019?\n. . . . . . . . . . . .\n12\n1.4\nThree perspectives upon design thinking\n. . . . . . . . . . .\n14\nKey take-home points about what designing is about\n. . . . . . .\n16\n2\nDoing Design\n19\n2.1\nDesigning as a creative process . . . . . . . . . . . . . . . . .\n19\n2.2\nIll-structured problems\n. . . . . . . . . . . . . . . . . . . . .\n21\n2.3\nWhat does a designer do? . . . . . . . . . . . . . . . . . . . .\n24\n2.4\nA simple example: the house move . . . . . . . . . . . . . . .\n27\nKey take-home points about designing\n. . . . . . . . . . . . . . .\n28\n3\nManaging the Design Process\n31\n3.1\nCognitive capacity . . . . . . . . . . . . . . . . . . . . . . . .\n31\n3.2\nThe power of abstraction\n. . . . . . . . . . . . . . . . . . . .\n32\n3.3\nModelling and making design choices\n. . . . . . . . . . . . .\n34\n3.4\nRecording design decisions\n. . . . . . . . . . . . . . . . . . .\n35\n3.5\nCommunicating ideas about a design model . . . . . . . . . .\n37\nKey take-home points about the design process . . . . . . . . . . .\n40\n4\nDesign Knowledge\n43\n4.1\nWhat do expert software designers do?\n. . . . . . . . . . . .\n43\n4.2\nSome software design principles\n. . . . . . . . . . . . . . . .\n49\n4.2.1\nFitness for purpose . . . . . . . . . . . . . . . . . . . .\n49\n4.2.2\nSeparation of concerns . . . . . . . . . . . . . . . . . .\n50\nvii\n", "page": 8, "type": "text", "section": "Page 8"}
{"text": "viii\nContents\n4.2.3\nMinimum coupling . . . . . . . . . . . . . . . . . . . .\n51\n4.2.4\nMaximum cohesion . . . . . . . . . . . . . . . . . . . .\n52\n4.2.5\nInformation hiding . . . . . . . . . . . . . . . . . . . .\n52\n4.3\nThe evolution of design ideas\n. . . . . . . . . . . . . . . . . .\n53\n4.4\nThe nature of expert design knowledge\n. . . . . . . . . . . .\n55\nKey take-home points about design knowledge\n. . . . . . . . . . .\n57\n5\nEmpirical Knowledge about Software Design\n59\n5.1\nMeasuring software development processes\n. . . . . . . . . .\n59\n5.1.1\nMeasuring physical phenomena . . . . . . . . . . . . .\n60\n5.1.2\nMeasuring human reactions . . . . . . . . . . . . . . .\n61\n5.2\nEmpirical studies in software engineering\n. . . . . . . . . . .\n63\n5.2.1\nThe empirical spectrum . . . . . . . . . . . . . . . . .\n64\n5.2.2\nThe research protocol\n. . . . . . . . . . . . . . . . . .\n65\n5.2.3\nQualitative studies . . . . . . . . . . . . . . . . . . . .\n65\n5.2.4\nQuantitative studies . . . . . . . . . . . . . . . . . . .\n66\n5.2.5\nCase studies . . . . . . . . . . . . . . . . . . . . . . . .\n67\n5.3\nSystematic reviews . . . . . . . . . . . . . . . . . . . . . . . .\n69\n5.4\nUsing empirical knowledge\n. . . . . . . . . . . . . . . . . . .\n71\nKey take-home points about empirical knowledge\n. . . . . . . . .\n72\nII\nDesign as a Noun: How Software Is Structured\n75\n6\nSoftware Architecture\n77\n6.1\nWhat architecture provides for us\n. . . . . . . . . . . . . . .\n77\n6.2\nArchitectural style . . . . . . . . . . . . . . . . . . . . . . . .\n79\n6.2.1\nPipe-and-\ufb01lter architectural style . . . . . . . . . . . .\n82\n6.2.2\nCall-and-return architectural style\n. . . . . . . . . . .\n83\n6.2.3\nData-centred repository architectural style . . . . . . .\n84\n6.3\nArchitectural patterns . . . . . . . . . . . . . . . . . . . . . .\n87\n6.3.1\nModel-view-controller (MVC) . . . . . . . . . . . . . .\n88\n6.3.2\nLayers . . . . . . . . . . . . . . . . . . . . . . . . . . .\n90\n6.4\nEmpirical knowledge about architecture . . . . . . . . . . . .\n91\nKey take-home points about software architecture\n. . . . . . . . .\n92\n7\nModelling Software Properties\n93\n7.1\nWhat is a design model?\n. . . . . . . . . . . . . . . . . . . .\n93\n7.2\nRepresentations, perspectives and viewpoints . . . . . . . . .\n96\n7.2.1\nThe constructional viewpoint . . . . . . . . . . . . . .\n100\n7.2.2\nThe behavioural viewpoint\n. . . . . . . . . . . . . . .\n101\n7.2.3\nThe functional viewpoint\n. . . . . . . . . . . . . . . .\n101\n7.2.4\nThe data-modelling viewpoint . . . . . . . . . . . . . .\n102\n7.3\nDesign notations . . . . . . . . . . . . . . . . . . . . . . . . .\n102\n", "page": 9, "type": "text", "section": "Page 9"}
{"text": "Contents\nix\n7.3.1\nTextual description forms . . . . . . . . . . . . . . . .\n103\n7.3.2\nBox and line description forms\n. . . . . . . . . . . . .\n103\n7.3.3\nMathematical notations . . . . . . . . . . . . . . . . .\n105\n7.4\nEmpirical knowledge related to viewpoint notations\n. . . . .\n106\nKey take-home points about design modelling\n. . . . . . . . . . .\n107\n8\nSketching Design Models\n109\n8.1\nWhy do designers sketch? . . . . . . . . . . . . . . . . . . . .\n109\n8.2\nSketching: developing informal models . . . . . . . . . . . . .\n110\n8.3\nCharacterising the design elements . . . . . . . . . . . . . . .\n112\n8.3.1\nSoftware design as an ISP . . . . . . . . . . . . . . . .\n112\n8.3.2\nSketching initial models . . . . . . . . . . . . . . . . .\n113\n8.4\nEmpirical knowledge about the use of sketching\n. . . . . . .\n116\nKey take-home points about sketching . . . . . . . . . . . . . . . .\n116\n9\nModelling Software Processes\n119\n9.1\nCharacteristics of software processes . . . . . . . . . . . . . .\n119\n9.2\nModelling function: the data-\ufb02ow diagram (DFD)\n. . . . . .\n121\n9.3\nModelling behaviour: the state transition diagram (STD) and\nthe state transition table (STT)\n. . . . . . . . . . . . . . . .\n126\n9.4\nModelling data: the entity-relationship diagram (ERD)\n. . .\n130\n9.5\nModelling construction: the structure chart\n. . . . . . . . . .\n134\n9.6\nEmpirical knowledge about modelling processes\n. . . . . . .\n136\nKey take-home points about modelling processes . . . . . . . . . .\n136\n10 Modelling Objects and Classes\n139\n10.1 Characteristics of objects and classes\n. . . . . . . . . . . . .\n140\n10.1.1 The notion of an object . . . . . . . . . . . . . . . . .\n141\n10.1.2 Objects and classes . . . . . . . . . . . . . . . . . . . .\n145\n10.2 Relationships between objects\n. . . . . . . . . . . . . . . . .\n150\n10.3 Conceptual issues for object modelling . . . . . . . . . . . . .\n153\n10.4 Object modelling: the issue of notations . . . . . . . . . . . .\n156\n10.5 Modelling construction: the class diagram . . . . . . . . . . .\n157\n10.5.1 Distinguishing classes from objects . . . . . . . . . . .\n158\n10.5.2 Class relationships . . . . . . . . . . . . . . . . . . . .\n159\n10.6 Modelling behaviour: the statechart and the message sequence\ndiagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n161\n10.6.1 The statechart\n. . . . . . . . . . . . . . . . . . . . . .\n161\n10.6.2 The message sequence diagram . . . . . . . . . . . . .\n164\n10.7 Modelling function: the activity diagram\n. . . . . . . . . . .\n167\n10.8 Use cases\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n169\n10.9 Empirical knowledge about modelling objects and classes\n. .\n172\n", "page": 10, "type": "text", "section": "Page 10"}
{"text": "x\nContents\n10.9.1 The object model . . . . . . . . . . . . . . . . . . . . .\n173\n10.9.2 Object modelling notations . . . . . . . . . . . . . . .\n173\n10.9.3 Object-oriented metrics\n. . . . . . . . . . . . . . . . .\n174\nKey take-home points about modelling objects and classes\n. . . .\n174\n11 Modelling Software Components and Services\n177\n11.1 Reuse\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n178\n11.2 Modelling software components\n. . . . . . . . . . . . . . . .\n180\n11.2.1 Component characteristics . . . . . . . . . . . . . . . .\n181\n11.2.2 Component frameworks . . . . . . . . . . . . . . . . .\n183\n11.2.3 Designing components . . . . . . . . . . . . . . . . . .\n185\n11.2.4 COTS . . . . . . . . . . . . . . . . . . . . . . . . . . .\n186\n11.3 Modelling software services\n. . . . . . . . . . . . . . . . . . .\n187\n11.4 Empirical knowledge about modelling components and services 190\n11.4.1 Empirical knowledge about components . . . . . . . .\n190\n11.4.2 Empirical knowledge about services\n. . . . . . . . . .\n191\nKey take-home points about modelling components and services\n.\n191\nIII Design as a Verb: Designing Software\n193\n12 Structuring the Ill-Structured\n195\n12.1 Challenges in creating a design . . . . . . . . . . . . . . . . .\n195\n12.2 Evolution of knowledge transfer mechanisms\n. . . . . . . . .\n197\n12.3 Designing with others\n. . . . . . . . . . . . . . . . . . . . . .\n199\n12.4 Empirical knowledge about design creation\n. . . . . . . . . .\n200\nKey take-home points about structuring \u2018solutions\u2019 to ISPs\n. . . .\n201\n13 Plan-Driven Software Design\n203\n13.1 What does plan-driven mean?\n. . . . . . . . . . . . . . . . .\n204\n13.2 Decompositional and compositional strategies\n. . . . . . . .\n205\n13.2.1 Top-down decomposition\n. . . . . . . . . . . . . . . .\n206\n13.2.2 Compositional design strategies . . . . . . . . . . . . .\n207\n13.3 What do plan-driven methods provide?\n. . . . . . . . . . . .\n208\n13.4 SSA/SD: example of an early plan-driven form\n. . . . . . . .\n211\n13.4.1 SSA/SD representation part . . . . . . . . . . . . . . .\n212\n13.4.2 SSA/SD process part\n. . . . . . . . . . . . . . . . . .\n212\n13.4.3 SSA/SD heuristics . . . . . . . . . . . . . . . . . . . .\n214\n13.5 SSADM: a designed design method\n. . . . . . . . . . . . . .\n214\n13.5.1 SSADM representation part . . . . . . . . . . . . . . .\n215\n13.5.2 SSADM process part . . . . . . . . . . . . . . . . . . .\n217\n13.5.3 SSADM heuristics\n. . . . . . . . . . . . . . . . . . . .\n218\n13.6 Plan-driven design for object-oriented models . . . . . . . . .\n219\n13.6.1 The Fusion method . . . . . . . . . . . . . . . . . . . .\n219\n", "page": 11, "type": "text", "section": "Page 11"}
{"text": "Contents\nxi\n13.6.2 The Uni\ufb01ed Process (UP) . . . . . . . . . . . . . . . .\n226\n13.7 Empirical knowledge related to plan-driven design\n. . . . . .\n233\nKey take-home points about plan-driven design practices\n. . . . .\n235\n14 Incremental Design in Agile Software Development\n237\n14.1 Using software prototypes . . . . . . . . . . . . . . . . . . . .\n238\n14.2 Incremental development and the spiral model\n. . . . . . . .\n241\n14.3 RAD: the DSDM method . . . . . . . . . . . . . . . . . . . .\n243\n14.3.1 The DSDM principles . . . . . . . . . . . . . . . . . .\n244\n14.3.2 The DSDM process . . . . . . . . . . . . . . . . . . . .\n247\n14.4 The agile manifesto\n. . . . . . . . . . . . . . . . . . . . . . .\n249\n14.5 Extreme programming (XP)\n. . . . . . . . . . . . . . . . . .\n250\n14.6 Agile development: Scrum\n. . . . . . . . . . . . . . . . . . .\n253\n14.7 Refactoring . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n255\n14.8 Empirical knowledge about design in agile development\n. . .\n257\n14.8.1 Empirical knowledge about DSDM . . . . . . . . . . .\n258\n14.8.2 Empirical knowledge about agile methods . . . . . . .\n258\n14.8.3 Empirical knowledge about refactoring . . . . . . . . .\n259\nKey take-home points about designing in an agile context . . . . .\n259\n15 Designing with Patterns\n261\n15.1 Patterns as a mechanism for knowledge transfer\n. . . . . . .\n262\n15.2 Architectural patterns . . . . . . . . . . . . . . . . . . . . . .\n265\n15.2.1 Model-view-controller (MVC) . . . . . . . . . . . . . .\n266\n15.2.2 Layers . . . . . . . . . . . . . . . . . . . . . . . . . . .\n268\n15.2.3 Broker . . . . . . . . . . . . . . . . . . . . . . . . . . .\n270\n15.3 Design patterns\n. . . . . . . . . . . . . . . . . . . . . . . . .\n271\n15.3.1 Proxy (207) . . . . . . . . . . . . . . . . . . . . . . . .\n275\n15.3.2 Observer (293) . . . . . . . . . . . . . . . . . . . . . .\n278\n15.3.3 Abstract Factory(87) . . . . . . . . . . . . . . . . . . .\n281\n15.4 Other uses of patterns . . . . . . . . . . . . . . . . . . . . . .\n283\n15.4.1 Software service patterns\n. . . . . . . . . . . . . . . .\n283\n15.4.2 Design anti-patterns and code smells . . . . . . . . . .\n284\n15.5 Designing with patterns . . . . . . . . . . . . . . . . . . . . .\n286\n15.6 Empirical knowledge about designing with patterns\n. . . . .\n288\nKey take-home points about designing with patterns\n. . . . . . .\n290\n16 Designing with Components and Services\n293\n16.1 Modular design\n. . . . . . . . . . . . . . . . . . . . . . . . .\n293\n16.2 Designing with components . . . . . . . . . . . . . . . . . . .\n294\n16.3 Designing with software services\n. . . . . . . . . . . . . . . .\n298\n16.4 Empirical knowledge about modular design\n. . . . . . . . . .\n302\nKey take-home points about designing with components and services 302\n", "page": 12, "type": "text", "section": "Page 12"}
{"text": "xii\nContents\n17 How Good Is My Design?\n305\n17.1 Quality assessment\n. . . . . . . . . . . . . . . . . . . . . . .\n306\n17.1.1 The \u2018ilities\u2019 . . . . . . . . . . . . . . . . . . . . . . . .\n307\n17.1.2 Design metrics\n. . . . . . . . . . . . . . . . . . . . . .\n308\n17.2 Reviews and walkthroughs\n. . . . . . . . . . . . . . . . . . .\n311\n17.3 Refactoring of designs\n. . . . . . . . . . . . . . . . . . . . . .\n313\n17.4 Empirical knowledge about quality assessment\n. . . . . . . .\n313\nKey take-home points about assessing design quality\n. . . . . . .\n314\n18 And What About...\n315\n18.1 Open source software (OSS)\n. . . . . . . . . . . . . . . . . .\n315\n18.2 Formal description techniques (FDTs)\n. . . . . . . . . . . . .\n317\n18.3 Model driven engineering (MDE)\n. . . . . . . . . . . . . . .\n321\n18.4 And the rest. . .\n. . . . . . . . . . . . . . . . . . . . . . . . .\n322\nBibliography\n325\nIndex\n339\n", "page": 13, "type": "text", "section": "Page 13"}
{"text": "Preface to the Third Edition\n\u201cScience is built up of facts as a house is built of stones, but an\naccumulation of facts is no more a science than a heap of stones\nis a house.\u201d Jules Henri Poincar\u00e9 (1854-1912)\nWhen using this quotation to open the second edition of this book I ob-\nserved that it is sometimes hard not to feel that our knowledge about how\nto design software might sometimes feel akin to having a heap of stones. We\npossess a collection of observations, techniques and experiences, but \ufb01nding\nways of putting them together to provide an organised corpus of knowledge\nabout how to design software is something of a challenge. The \ufb01rst and second\neditions of this book have sought to gather, classify, categorise and interpret\nthe available knowledge with the aim of providing some sort of structure that\nwill help the reader to understand and use it\u2014and this one aims to do the\nsame.\nThe ten years that elapsed between the \ufb01rst and second editions of this\nbook saw the emergence of many new and sometimes radically di\ufb00erent ideas\nabout how we might go about designing software. The software designer\u2019s\ntoolbox acquired concepts such as architecture and new forms of software\ntechnology such as software services; there was a move away from \u2018waterfall\u2019\nthinking with agile methods as well as with new forms of reuse through design\npatterns; and there was a greater \u2018standardisation\u2019 of modelling forms with\nthe Uni\ufb01ed Modeling Language (UML).\nIn the (rather longer) period between the second edition and this one,\nalthough new ideas have continued to emerge, mostly they have been less rad-\nical in their scope. Perhaps this has been partly because software developers\nhave also had to cope with signi\ufb01cant changes in the context within which\nsoftware design takes place. It is now increasingly the case that applications\nmay well be developed by globally dispersed teams; make use of open source\ncomponents; be in the form of product lines; need to operate within a global\nnetwork of systems rather than in a purely local environment; and of course,\nincreasingly need to cope with the possibility of malicious attacks. In addition,\nthe growing availability of knowledge that is based upon empirical evidence is\nslowly giving us a better understanding of what works, when and why.\nSo, in order to keep the focus upon ideas about design, rather than being\nswamped with detail about software, this edition has been organised very dif-\nferently to the previous two. In particular, the presentation of material about\ndesign has placed a much greater emphasis upon the role of design as related\nxiii\n", "page": 14, "type": "text", "section": "Page 14"}
{"text": "xiv\nPreface to the Third Edition\nto the concept and characteristics of ill-structured problems (ISPs). Software\ndevelopment presents a particularly challenging example of an ISP\u2014and de-\nsign forms an important problem-solving tool for addressing ISPs (indeed, the\nmain one). Using the idea of the ISP as a framework for introducing many of\nthe ideas involved may therefore help with understanding the roles of many\nof the topics addressed in the book.\nA rather di\ufb00erent approach to codifying and presenting knowledge about\nsoftware design itself has also been adopted for this third edition. This knowl-\nedge is organised around the way that the word design can be used as both:\n\u2022 a noun, as when we refer to \u2018a design\u2019, meaning our description of how\na software system should be structured and the ways that its elements\nshould behave and interact; and also as\n\u2022 a verb, referring to the activity of creating a design, as in \u2018to design\u2019\nsomething.\nTogether, these ideas underpin the way that this book has been organised.\nStarting with a set of chapters that use the concept of an ISP to help examine\ndesign issues in the wider sense, we then have a set of chapters that examine\ndi\ufb00erent aspects of the ways that we can describe a software application and its\nproperties. This is then followed by a set of chapters that look at the di\ufb00erent\nactivities that can provide the creative processes needed to produce these\ndescriptions. Using such a structure embodies a sound pedagogical principle\nrelated to how we learn\u2014we \ufb01rst learn that words have some sort of meaning,\nmove on to read (the words that others have created) and eventually learn to\nwrite (and so create our own words). We can learn about designing software\nin the same way, gaining an understanding of why we need to design software,\nwhat a software design is, and what qualities to look for in it, before we can\ngo on to think about how we might set about producing a design.\nAs well as adopting a new structure for this edition, there are many other\nchanges that re\ufb02ect our increasing knowledge about, and experiences with,\nsoftware design (both as noun and verb). Some older material has been omit-\nted, the terminology has been revised in places, and there is a greater emphasis\nupon the context within which the development of a design takes place. The\nbibliography has been updated and extended, with particular emphasis upon\nincluding knowledge drawn from empirical studies where this is available.\nOne other change is that the material of the book has been presented in a\nless \u2018formal\u2019 manner. This is re\ufb02ected in a number of ways. One of these is the\ngreater use of informal illustrations and \ufb01gures. When we provide students of\ndesign with neatly produced diagrams, as we usually do in books, papers and\nlectures, we easily do them a disservice. Designs are not produced via drawing\ntools, they are far more likely to be sketched on a whiteboard or a sheet\nof paper. And all too often, such sketches will not use a particularly formal\nsyntax or semantics either. So in this edition, there is a move away from neatly\nformatted \u2018box and line\u2019 diagrams to greater use of hand-drawn sketches\u2014and\n", "page": 15, "type": "text", "section": "Page 15"}
{"text": "Preface to the Third Edition\nxv\nwith it my apologies for the accompanying handwriting. This move to greater\ninformality has also been extended to the illustrations intended to provide\n\u2018memory aid\u2019 via visualisations of various concepts\u2014within the capacity of\nmy draughtsmanship at least!\nWhat has not changed is what has usually been considered as the unique\nstrength of this book, in that it seeks to describe the available knowledge\nabout software design in a balanced and advocacy-free manner. In a \ufb01eld\nsuch as computing, where enthusiastic advocacy may drown out evidence and\nevaluation, this role continues to be an important one. This is not to imply that\nthe aim is to create a \u201cdry and dusty tome\u201d. The act of designing something\nis a creative and exciting one, whatever the domain, and is one that readily\nprovokes enthusiasm among practitioners and students\u2014and can often lead to\nsome frustration too, we might admit. This is every bit as true for designing\nsoftware as it is for designing cars, aircraft, bridges, toasters and televisions\u2014\nthe aim as always is (or should be) to create something new and better for its\nusers.\nOne other aspect of the book that has not changed is the issue of using\nmaterial taken from the web. The ephemeral nature of these sources, combined\nwith the di\ufb03culty of \ufb01nding out how up-to-date they are, as well as the issues\nof provenance for the material they contain, means that I have been rather\nreluctant to cite other than a small number of those that I have consulted.\nWhere possible, I have tried to cite only those sites that I consider to be\nrelatively stable, and that can also be regarded as being authoritative in a\ntechnical sense.\nAcknowledgements\nMy interest in software design now dates back over some forty years (oh\ndear!), so giving due acknowledgement to all of the people who have in\ufb02uenced\nmy understanding and my thinking would be a very long list indeed. However,\nI should particularly acknowledge here the contribution made by the late\nNorm Gibbs when he was Director of the Education Program at the Software\nEngineering Institute of Carnegie Mellon University. Norm encouraged me\nto persist with my early attempts to categorise and classify knowledge about\nsoftware design, starting with my work on developing a prototype for the SEI\u2019s\ncurriculum modules, which eventually led to the \ufb01rst edition of this book. I\nwould also like to thank Marian Petre and Andr\u00e9 van der Hoek for making\nme so much more aware of the importance of sketching and informality, for\nboth the purpose of design and also for presenting ideas.\nI would also like to repeat my thanks to all those who helped clarify my\nthinking for the \ufb01rst two editions: \ufb01rstly the students who have had to put\nup with my use of my teaching role to explore new ways of explaining this\n", "page": 16, "type": "text", "section": "Page 16"}
{"text": "xvi\nPreface to the Third Edition\nmaterial; secondly, my family, who have put up with \u2018yet another book\u2019 (and\nyet another set of promises about \u2018nearly done\u2019), mentioning particularly my\ndaughter Jane who went through my sketches to check how well they conveyed\nthe issues (certainly not to check their artistic merit!).\nAnd as with the previous two editions, any errors of fact and any omissions\nare entirely my own (and unintended)!\nDavid Budgen\n", "page": 17, "type": "text", "section": "Page 17"}
{"text": "The City Car Club\nBefore we engage in thinking about designing things, this is a good point at\nwhich to introduce the City Car Club (CCC). The CCC provides a running\nexample that will be used through most of the following chapters to help\nillustrate various issues. While it is by no means the only example that will\nbe used in these, it has the bene\ufb01t that once described (here) it can be easily\nused without the need for lengthy explanations.\nVery brie\ufb02y, the City Car Club is a car-sharing system that will be op-\nerating within a city. We haven\u2019t said which one, so you can assume your\nfavourite city when picturing it in your mind. The team behind the CCC will\nneed extensive software support to make the venture work successfully, and\nan initial speci\ufb01cation of what is needed is given below.\nThe Speci\ufb01cation\nThe City Car Club (CCC) is an organisation that is planning to set up a\ncar-sharing system that will eventually operate in di\ufb00erent cities, and requires\na software system to manage this. They will be trying out this idea for the\n\ufb01rst time in \u27e8your favourite city\u27e9. CCC will provide a number of small \u2018city-\nfriendly\u2019 cars that can be used by members of the club, who pay a monthly\nmembership fee. When using a car, the pick-up and drop-o\ufb00points must lie\nwithin a speci\ufb01ed central zone of the city, although a car may go outside this\narea while it is in use. There will be some designated locations where cars can\nbe left and collected, indicated by specially coloured hatching on the parking\nbays, and with these being protected by a lockable \u2018fold-down\u2019 post where it\nis necessary to stop others from using them. Cars may also be left in any other\nsuitable parking area, including a number of supermarket car parks (approval\nhas been obtained for this), but if a car is left in any other non-designated\nplaces, the club member who is leaving the car will be personally responsible\nfor any parking fees or \ufb01nes that might be incurred. A member will also be\ncharged an additional fee if a car is left outside of the designated central zone.\nThe position and status of the cars is tracked using a GPS system built into\neach car. At any time each car will have a status, describing its availability,\nwhich can have one of the following values:\n1\n", "page": 18, "type": "text", "section": "Page 18"}
{"text": "2\nThe City Car Club\n\u2022 Unavailable \u2013 the car is currently in use by a member of the club, or has\nbeen identi\ufb01ed by the support team as needing attention in some way.\n\u2022 Available \u2013 the car is available for use and can be booked by a club\nmember.\n\u2022 Reserved \u2013 a member has requested use of the car, but has not yet taken\ncharge of it.\nCCC\u2019s central monitoring system will continuously record and track the po-\nsition and status of each car.\nTo use a car (a \u2018session\u2019), a member uses their club id to access the cen-\ntral booking system, identi\ufb01es a car that is available as well as conveniently\npositioned for their use, and makes a reservation, with a unique con\ufb01rmation\ncode being sent to them as an SMS text or in an e-mail. The reservation can\nbe made using a laptop application or a phone app (these are provided when\na member registers with CCC). A reservation automatically expires if a car\nhas not been collected within 20 minutes of making the reservation, but it can\nbe extended for one additional period of 20 minutes (the system prompts the\nmember at the end of the \ufb01rst 20-minute period and gives them the opportu-\nnity to extend it). On reaching the car they have reserved, the member uses\nthe unique code to open the car and to operate the ignition system, as well\nas to unlock the security post if one is in use. This can all be done by using\neither a small keypad that is provided to members by CCC, or by means of a\nBluetooth link to the app on their phone or tablet. Entering the code starts\nthe session, and from that point on the member is responsible for the car until\nthey \ufb01nish the session by locking the car and notifying the central booking\nsystem.\nBilling for a session is based upon a formula that takes account of distance\ncovered and the length of time the car is being used. Members can also add\nfuel to a car at a number of authorised agencies (including the supermarkets\nproviding car parking) using a payment card that charges the fuel to CCC,\nfor which they get credit. There is a \u2018\ufb01ne\u2019 for leaving a car with an inade-\nquate reserve of fuel in the tank (the fuel level is transmitted to the central\nmonitoring system at the start and end of a session). As well as identifying\nwhere nearby available cars are located, the phone app provided by CCC can\nbe used to locate nearby \ufb01lling stations.\nThe support team of CCC can perform various \u2019mobile\u2019 tasks of mainte-\nnance, including \ufb01xing any problems with cars and retrieving any that have\nbeen left outside of the central area. While out \u2018on the road\u2019, they will use\na similar set of apps to those provided for ordinary members, but with addi-\ntional privileges (for example, allowing them to declare a car to be unavailable\nwhen they begin work on it, and available once they have \ufb01nished).\nIn the longer term, once the system has been tested out in this \ufb01rst loca-\ntion, CCC plan to make their cars available in other cities. So the design of\ntheir software needs to ensure that this is adaptable for use in other places,\nin addition to the usual requirements for security, robustness and e\ufb03ciency.\n", "page": 19, "type": "text", "section": "Page 19"}
{"text": "The City Car Club\n3\nHighlighting the examples\nTo help the reader identify where the CCC has been used to illustrate an\nissue, the relevant text and any associated diagrams will normally be placed\ninside a separate shaded box as in the illustration below.\nUsing the CCC in an example\nWhen we are talking about how we might use a particular concept\nwith the CCC then it will appear in a box with grey background and\nrounded corners like this.\nAnd when we are using a diagram or a sketch to illustrate an issue,\nthen it will be included as part of the example, like the one below.\nA simple model of the CCC\nOf course, where we simply make reference to the CCC, rather than dis-\ncussing how it might form an example of something, we will just do so in the\nnormal text of a chapter.\nSketches versus diagrams\nWe will say more about what we mean by sketching later on, but it is\nworth pointing out here you will \ufb01nd that many illustrations and \ufb01gures in\n", "page": 20, "type": "text", "section": "Page 20"}
{"text": "4\nThe City Car Club\nthis book have been drawn and lettered by hand (admittedly, not always\nvery elegantly). This is because sketching is what designers actually do (Petre\n& van der Hoek 2016), and producing neat diagrams, of the form usually\nencountered in textbooks, often comes later, if at all.\nSo, when syntax and clarity are important, diagrams will usually be in\n\u2018textbook style\u2019, but when the issue is more one of thinking like a designer,\nthen expect to get a sketch!\n", "page": 21, "type": "text", "section": "Page 21"}
{"text": "Part I\nAddressing Ill-Structured\nProblems\n5\n", "page": 22, "type": "text", "section": "Page 22"}
{"text": "Chapter 1\nWhat Is Designing About?\n1.1\nWhen is design needed? ..........................................\n7\n1.2\nA bit about software .............................................\n10\n1.3\nWhat exactly do we mean by \u2018design\u2019? ..........................\n12\n1.4\nThree perspectives upon design thinking ........................\n14\nKey take-home points about what designing is about ...........\n17\nThe purpose of this book is to look in detail at how the activities involved\nin designing can be applied to the context of software development. Both are\nchallenging topics in their own right, so the chapters that follow draw upon a\nhost of ideas that come from quite an eclectic variety of sources. This chapter\nis mainly concerned with explaining something of the essential characteristics\nof design thinking, and the various ways in which this is employed during\nsoftware development. However, since it is largely written from the perspective\nof \u201cwhat should a software developer need to know about software design?\u201d,\nwe also provide a brief review of the relevant characteristics of software. After\nall, it is these characteristics that make the task of designing software to be\nsuch a unique challenge.\n1.1\nWhen is design needed?\nIn our everyday lives we are surrounded by things that have been designed.\nThe chairs we sit upon, the cars we drive, the phones we use to communicate\nwith others, the houses/\ufb02ats that we live in. These are all examples of artifacts,\nthings that have been created through some form of human activity. All of\nthese have also been created to meet some form of human need and hence can\nbe considered as providing a solution to some form of \u2018problem\u2019.\nIn the (relatively) early days of computing, Herb Simon (1973) recognised\nthat computers could be used to help address two distinct types of problem.\n\u2022 Well-Structured Problems or WSPs. These are distinguished by having\na \u2018right\u2019 solution, and some clear tests that help demonstrate that this\nhas been found. For example, to \ufb01nd the roots of the quadratic equation\nx2 \u22125x + 6 = 0, we can either use inspection or the standard formula\n7\n", "page": 24, "type": "text", "section": "Page 24"}
{"text": "8\nSoftware Design: Creating Solutions for Ill-Structured Problems\nto determine that their values are x = 2 and x = 3. Putting either\nvalue back into the original expression provides a simple and complete\ntest of correctness for that solution. Applications such as \ufb01nancial mod-\nelling and database transactions provide examples of using computers\nto address WSPs.\n\u2022 Ill-Structured Problems or ISPs. For such problems there will usually\nbe no explicit formulation, and many possible solutions, with these be-\ning characterised by being good or bad rather than right or wrong. For\nISPs there will be no de\ufb01nitive test to determine the correctness of a\nresult, and so no way of knowing that the \u2018best\u2019 available solution has\nbeen achieved (usually termed \u2018no stopping rule\u2019). Computer applica-\ntions such as face or voice recognition, that have to cope with incomplete\ninformation, can be considered as addressing ISPs.\nWhen we look at problem-solving more broadly, not just through the use\nof computers, these distinctions are every bit as useful. Many problems en-\ncountered in science, particularly in physics and maths, are well-structured\nproblems that can be solved through mathematical analysis. However, the\nproblems addressed by engineers, including software engineers, are nearly al-\nways ill-structured problems. The need for a bridge can be met in many ways,\nand there are many ways of writing even a simple computer program. So ad-\ndressing an ISP involves employing some form of design process which enables\nus to formulate a possible solution and then evaluate how well it might meet\na particular need.\nThe CCC system as an ISP\nLet\u2019s consider a design scenario that might occur when the software\ndesign team start to plan how they will develop the software for CCC.\n1. The head designer suggests representing each car as an object,\nwith its current status being stored internally, and a set of meth-\nods that allow customers and other users (such as the mainte-\nnance team and the accounting software) to access that status.\n2. The next question is how to organise all of these objects. So\na member of the team suggests using an array of objects. One\nconsequence is that every car now has to have an index number\nso that the relevant object can be accessed.\n3. And then there\u2019s the question of how to model the status of a\ncar internally (is it available, unavailable or reserved?).\nNone of these decisions exists in isolation, and each one has implica-\ntions for the way that the design will evolve.\nFigure 1.1 provides a simple schematic illustration of the di\ufb00erent ways in\n", "page": 25, "type": "text", "section": "Page 25"}
{"text": "What Is Designing About?\n9\nwhich we need to approach the task of \u2018solving\u2019 ISPs and WSPs.\nA really\nimportant distinction is the way that postulating a possible solution to one\naspect of an ISP may in\ufb02uence our understanding of that aspect as well as\ninteracting with the ideas we may have for solving its other aspects (indicated\nby the dashed-line backward pointing arrows).\nproblem\nspecification\nsolution\nprocedure\nsolution\nset of algorithmic\nrules to apply when\nsolving such problems\nset of algorithmic\nrules to apply when\nsolving such problems\na) Process for 'solving' a WSP\nproblem\nspace\npart\nproblem 1\npart\nproblem 2\npart\nproblem 3\npart\nsolution 1\npart\nsolution 2\npart\nsolution 3\nsolution\nspace\nexternal design\nknowledge and problem\nexpertise used to\nexplore the 'solutions'\nexternal design\nknowledge and problem\nexpertise used to\nexplore the 'solutions'\nb) Process for 'solving' an ISP\nFIGURE 1.1: The solution processes for WSPs and ISPs\nSo this is really a book about how we tackle ISPs within the domain of\nsoftware development. We look a bit more closely at the nature of ISPs in the\nnext chapter, and in the rest of this chapter we brie\ufb02y consider some of the\nother factors that are likely to be involved in designing software.\n", "page": 26, "type": "text", "section": "Page 26"}
{"text": "10\nSoftware Design: Creating Solutions for Ill-Structured Problems\n1.2\nA bit about software\nBefore engaging with design concepts and \u2018design thinking\u2019, we need to\ngive a (brief) mention to the other word that appears in the title of this book,\nas it forms an important in\ufb02uence upon the sections and chapters that follow.\nIn the \u2018pre-internet\u2019 era (and yes, there was such a time), software came\nin two main \ufb02avours. System software, supplied with the computer, provided\nan operating environment and applications written by users were executed\nin the context that this provided. So, for most purposes, anyone setting out\nto design an application could do so within a fairly well-bounded context\nthat was largely determined by their choice of programming language and\nthe resources provided through the particular operating system. This didn\u2019t\nnecessarily mean that the task of design was easier than it is today though,\nsince the designer might well have to design around a lack of resources rather\nthan having to choose between di\ufb00erent ones.\nFrom the early 1990s, the internet era began to extend this context. And at\nthe same time, the emergence of new ideas about how to organise and structure\nsoftware, such as classes, objects and software services required that developers\n\ufb01nd new ways of creating and organising applications. In particular, when\ndesigning an application, it might be necessary to envisage not just how it\nwould interact with other applications on its \u2018host\u2019, but also with applications\nrunning on remote computers, where these might or might not need to be\ndeveloped as part of the design task.\nAnd of course, technology has continued to evolve. Rather than being\ncon\ufb01ned to a local computer, the di\ufb00erent parts of an application might now\nbe found hosted in the cloud, tablets, phones or even domestic appliances (the\n\u2018Internet of Things\u2019). Systems might well need to be dynamically con\ufb01gured\nduring execution, and the designer may well only be responsible for part of a\nmuch more extensive system or application.\nAnd even in the pre-internet era it was recognised that the e\ufb00ort invested\nin creating software applications meant that an application might have quite\na long lifetime in use. It was also realised that an application might need\nto evolve during that lifetime in various ways, so as to meet new needs or\nchanges in its environment (Bennett & Rajlich 2000). (What is now often\ntermed evolution was then more likely to be described as maintenance, with\nadaptive maintenance describing those changes made to address changes in\nan application\u2019s environment.) So the need to anticipate future developments\nhas always provided an in\ufb02uence (or constraint) upon a designer\u2019s ideas.\nIn more recent times, the associated concept of technical debt is one\nthat has introduced a rather di\ufb00erent perspective upon design thinking\n(Cunningham 1992, Allman 2012). Technical debt refers to the future con-\nsequences that may arise as a consequence of the current decisions that we\nmake about software development. In particular, it has been observed that,\n", "page": 27, "type": "text", "section": "Page 27"}
{"text": "What Is Designing About?\n11\nunlike other forms of debt, the repayment of technical debt may well need to\nbe undertaken by those other than the ones who incurred it in the \ufb01rst place.\nThe team that develops a software product may well have no responsibility\nfor its later evolution\u2014so any problems stemming from compromises in the\ndesign may well eventually need to be addressed by others.\nIn many ways, the concept of technical debt highlights a key di\ufb00erence\nbetween the \u2018student experience\u2019 and the environment within which the soft-\nware developer operates. Once a particular student exercise has been com-\npleted (and assessed), it is discarded and the student moves on to new topics.\nSo students rarely have to think about other than the very immediate con-\nsequences of any software design decisions they make. As such, their work\nincurs no \u2018debts\u2019. Unfortunately though, when thinking about software design\nin almost any other context, the opposite is true!\nThe CCC and technical debt\nLet\u2019s consider some possible scenarios for how the business of CCC\nmight evolve and some possible e\ufb00ects that these may have upon the\ndesign decisions outlined earlier.\n\u2022 If the scheme proves highly successful, CCC may need to expand\ntheir \ufb02eet of cars. Consequence: the early decision to use an array\nof objects might prove inconvenient, although this does depend\nupon how it was implemented.\n\u2022 Some customers may need larger cars (even though this is a \u2018city\u2019\nclub!). Consequence: while this can be addressed by using inher-\nitance to create new subclasses of the \u2018car\u2019 class, doing so may\ncreate other problems, such as how to meet the need for billing\nfor use according to car size.\n\u2022 CCC may conclude that they need a more elaborate set of status\nvalues, for example: \u201cavailable but outside of the central zone\u201d.\nConsequence: this may complicate or extend the set of methods\nfor each object, depending on how these were speci\ufb01ed.\nNone of these is insurmountable, but it emphasises the point that de-\nsign decisions, especially those made at early stages, may have conse-\nquences for later.\nSo we might reasonably ask if our ideas about how to (successfully) design\nsoftware have been able to keep up with these changes and concepts? And of\ncourse, the answer is both \u2018yes\u2019 and \u2018no\u2019. Concepts such as architecture and\npatterns have emerged to help us conceptualise our ideas about software de-\nsign, but equally, because design ideas tend to draw heavily upon experience,\nour ability to make good use of these concepts always lags behind. Indeed,\nit might be argued that the emergence of the concept of agile development\n", "page": 28, "type": "text", "section": "Page 28"}
{"text": "12\nSoftware Design: Creating Solutions for Ill-Structured Problems\nimplicitly re\ufb02ects this process of ongoing change. Plan-driven design strate-\ngies, as favoured in the pre-internet era, essentially assume a stable operat-\ning environment for an application, while agile ones allow designers to adapt\ntheir ideas to a changing context, which itself may well be changing (and\nbeing clari\ufb01ed) as development proceeds. However, despite this, since design\nideas usually stem from experience, technology developments are usually well\nahead.\nThis book therefore aims to provide the reader both with conceptual tools\nfor thinking about how a design might be organised, and also with knowledge\nabout some of the strategies that might be used to produce a design. When\nthinking about software at this level, the Internet of Things (IoT), the cloud,\nthe mobile phone app, the web application, and the more \u2018conventional\u2019 ap-\nplication have much in common, although the detailed realisations might be\nquite di\ufb00erent. Hence this is not a book about software design for distributed\nsystems, web applications, or phone apps, it is a book that explains di\ufb00erent\nways of approaching the task of software design. And with that, let\u2019s get on\nwith thinking about design. . .\n1.3\nWhat exactly do we mean by \u2018design\u2019?\nOne of the complications of the English language is that a word can have\nmultiple uses, and we may often have to work out which meaning is intended\nby considering the context in which the word appears. The word design is just\nsuch a word, and in this book we are going to be concerned with exploring\na range of key concepts and ideas related to each of its meanings. So it is\nappropriate to begin by examining just what these meanings are.\nFirstly, we can speak of \u2018a design\u2019, using it as a noun that describes some-\nthing that forms a plan of how we intend some artifact to be constructed.\nIndeed, we often speak of a \u2018design plan\u2019 in this context, where the purpose\nof this is to provide a \u2018model\u2019 of how some form of \u2018product\u2019 should be con-\nstructed. This particular meaning is therefore widely associated with the idea\nof manufacturing something, whether crafted by an individual, or assembled\nin a factory (mass production)1. So, we may have a design plan that provides\nguidance on how to construct a model boat (or a real one, depending on how\nambitious we are), or an item of clothing, or a car. The information provided\nin the plan about how to realise that design might be quite detailed and need\nto be followed exactly, which is probably a good idea when building a boat\nor a kit car, or it might be something of a more strategic nature that we\n1London\u2019s \u2018Great Exhibition\u2019 of 1851, which occurred at a relatively early stage of indus-\ntrial development, was essentially about design, and contained over 100,000 exhibits that\nwere essentially design artifacts\u2014admittedly of widely varying taste and usefulness.\n", "page": 29, "type": "text", "section": "Page 29"}
{"text": "What Is Designing About?\n13\nare expected to interpret and adapt, which would be more appropriate when\nmaking a garment to \ufb01t our own \ufb01gure.\nHowever, rather than a physical artifact the design plan may describe some\nform of procedure or process that is to be performed in some way. Again,\nthere are many forms this can take\u2014we can regard a musical score as being\na plan for a particular form of process, that is to be followed by the player\nor players. Again, it may be very detailed, or leave scope for improvisation.\nOther examples of such procedures might be concerned with form-\ufb01lling, such\nas applying on-line for a driving licence or a passport, describing the various\nthings we need to do, and possibly in what order. And of course, we can\nconsider a recipe for making a cake as being a plan that describes a process,\nbut also one that a competent cook will be expected to adapt quite freely.\nExecuting a (musical) design\nplan\nThe two forms of plan can also be com-\nbined. As an example, the design for a bicy-\ncle may describe both the structure of the\nbike and also specify the way in which it\nshould be assembled in order to ensure that\nits physical characteristics are not compro-\nmised.\nAn important characteristic of the use\nof the word \u2018design\u2019 in this way is that\nwe usually associate it with some form(s)\nof description for the plan. And of course,\nthere are many forms of description, which\nmay employ words, pictures, mathemati-\ncal forms, musical notation, etc. as well as\ncombinations of these. (Few diagrams are\nvery meaningful without some accompany-\ning text, as anyone who has tried to assemble\n\ufb02at-pack furniture will be only too aware.)\nThe second meaning, which is closely re-\nlated to the \ufb01rst one, and probably even more important to us here, is when\nwe use the word design as a verb, as in \u2018to design\u2019. This is concerned with\nthe process of designing something\u2014with the goal being to produce a plan.\nThe activity of designing something forms the most creative (and usually\nchallenging) aspect of design as a concept, and indeed, much of this book\nwill be concerned with this second meaning, and with the di\ufb00erent processes\nemployed for designing software.\nWhile design plans may vary in terms of how exactly they need to be\nfollowed, there is usually a degree of formality associated with their structure\nthat is required to make them understandable. In contrast, design processes\ntend to be much less constrained, and even following a recommended practice\ninvariably requires some interpretation and adaptation. So we can interpret\ndesign thinking as meaning thinking about how to design something.\n", "page": 30, "type": "text", "section": "Page 30"}
{"text": "14\nSoftware Design: Creating Solutions for Ill-Structured Problems\nIn\nthis\nbook\nyou\nwill\n\ufb01nd\nthat\nwe\nare\nvery\nmuch\nconcerned\nwith both uses of the word \u2018design\u2019. While their roles are distinctive,\nDesign as verb creating de-\nsign as noun\nthey are not wholly independent either: the form\nof design plan we want to create may in\ufb02uence\nthe way that we approach the task of designing.\nLikewise, the way that we approach the act of\ndesigning will in\ufb02uence the sort of plan that we\nproduce. And of course, the activities of design\nand implementation of software lack the clear\ndistinction that usually occurs in industrial man-\nufacturing, since many detailed design decisions\nmay be left for the programmer to resolve dur-\ning implementation. However, wherever possible\nwe will treat them separately, not least for the\nsake of our own sanity!\n1.4\nThree perspectives upon design thinking\nThe idea of designing is one that pops up in many of the things that\nwe do\u2014not just when developing software\u2014and what is involved will take\ndi\ufb00erent forms. Here we brie\ufb02y look at three quite di\ufb00erent perceptions about\nwhat the act of designing might involve. They all o\ufb00er a di\ufb00erent perspective\nupon what design thinking might involve, and they all have a place in this\nbook.\nIf we see the word \u2018design\u2019 used in a newspaper or magazine, then it is\nquite likely that we will be looking at the fashion pages. (Admittedly, very\nfew newspapers have technology pages.) This highlights the \ufb01rst perspective\nupon design\u2014which relates to how some form of artifact is styled, whether it\nbe clothing, spectacles, mobile phones or electric bikes. Indeed, this is prob-\nably what many people think of as being \u2018design\u2019. It is an important one for\nsoftware too, for example, when we use ideas from Human Computer Inter-\naction (HCI) and Interaction Design to determine the \u2018look and feel\u2019 of a\nsoftware application\u2014and hence seek to ensure its acceptability to users.\nA second perspective is associated with what we often think of as plan-\nning. Planning spans a wide range of activities and end-products (think of\nsocial planning, game plans, etc.). Again, this meaning is also used in soft-\nware development, where the activities involved in a development project need\nto be planned so that e\ufb00ort is used e\ufb00ectively, and where testing needs to be\nplanned so that it is as comprehensive as possible. Although this form is less\nwidely used in software development itself, doing so by creating software from\n\u2018components\u2019 (including software services) can involve elements of this form.\n", "page": 31, "type": "text", "section": "Page 31"}
{"text": "What Is Designing About?\n15\nBoth \u2018design as styling\u2019 and \u2018design as planning\u2019 (as we will term them) are\nlargely concerned with how we deploy existing and largely familiar resources.\nAnd when new elements appear (such as touch-screens) they are likely to stem\nfrom external factors, such as technology developments created by others.\nThe third perspective is rather di\ufb00erent, and we can term it as \u2018design as\nadaptation\u2019. This is concerned with how we create new ways of doing things,\noften making something possible that couldn\u2019t have been done before, usually\nby adapting and modifying ideas we have used before on some other task, and\nsometimes combining these in new and di\ufb00erent ways. Many ideas we examine\nin this book provide models that are intended to be adapted, such as patterns\nand architectural style. Often the degree of adaptation is fairly limited\u2014if we\nhave found an approach that works, we are unlikely to want to change it too\nradically\u2014but there will still be times when our ideas have to be modi\ufb01ed quite\nextensively to meet the needs of a particular problem. Figure 1.2 provides a\nvery simple illustration of this concept. At one extreme, someone designing a\nnew database system might well be able to reuse and adapt the experiences\nof previously developing a very similar one, and so the designer can largely\nreuse their design model. At the other extreme, designing a completely new\napplication may involve bringing together a range of previous experiences and\nwell-known design forms and then adapting them to work together to address\nthe need.\nLimited\nadaptation\nExtensive\nadaptation\nE.g.reuse database\nschema, making\nsmall changes\nE.g.reuse database\nschema, making\nsmall changes\nE.g bring together \nideas about architecture,\nas well as many patterns\nE.g bring together \nideas about architecture,\nas well as many patterns\nFIGURE 1.2: The spectrum of adaptation involved in designing\nAll of these three forms embody the concept and characteristics of design\nthinking that we explore in the rest of this book, albeit in di\ufb00erent ways. While\nfor software development design activities are often likely to relate mainly to\nthe third perspective, there are going to be elements of all three perspectives\nin many of our examples. As such, they are not distinct concepts, but more a\nmatter of having di\ufb00erent ways of viewing things.\n", "page": 32, "type": "text", "section": "Page 32"}
{"text": "16\nSoftware Design: Creating Solutions for Ill-Structured Problems\nDesign perspectives and the CCC\nDesigning the software for the CCC will mainly be about design as\nadaptation, bringing di\ufb00erent forms together to create the models and\nstructures required to meet the needs of CCC. However it will also\ninvolve some design as styling when considering things like user in-\nterfaces that need to be easy to use on a mobile phone. Design as\nplanning will mainly be concerned with how the development process\nis organised\u2014for example whether or not we employ an agile approach\nto development, although there will be some interaction with the \ufb01rst\nform when considering how the business might develop and expand.\nDesign Thinking\nSo, what is it that characterises de-\nsign thinking? We explore this more fully\nin the following chapters, but in essence\nit involves thinking creatively about how\na task is to be performed. Implicitly, de-\nsign (in any domain) is concerned with\n\ufb01nding ways to do things. That in turn\nrequires an ability to envisage how some-\nthing might work before we set about\ntrying to construct it. For \u2018design as\nstyling\u2019 that might involve having a vi-\nsion of how something might appear\nand/or behave, and then trying to work\nout how we can bring that e\ufb00ect about.\nFor \u2018design as planning\u2019 we may be concerned with how to use available re-\nsources to bring about some result. And for \u2018design as adaptation\u2019 we are likely\nto be trying to identify a set of mechanisms that will produce the desired ef-\nfect. The key requirement is one of thinking \u2018out of the box\u2019\u2014envisaging the\nend e\ufb00ect that is wanted, and then trying to work backwards to see how that\nmight be achieved.\nAnd this isn\u2019t an easy thing to do. While in principle, anyone can create\nnew things, those things have to meet a range of expectations: they must\nachieve \ufb01tness for purpose, be e\ufb03cient (in whatever way that matters), have\nan \u2018appeal\u2019 to users, and many other attributes as well. Somehow, a good\ndesigner can draw all these things together while keeping a balance between\nthem\u2014and while we might recognise that they can do so, that doesn\u2019t mean\nthat it is an easy task for them, or easy for us to learn to do the same.\nSo, as we explore design thinking in this book, the aim is to provide a\ndeeper understanding of what makes for good design (largely in a software\ncontext, but sometimes more widely too). That doesn\u2019t mean that every reader\nwill become a great designer\u2014but at least you can hope to become a com-\npetent one. And indeed, most of us will be satis\ufb01ed to feel con\ufb01dent that\nwe know enough about software design issues to be able to avoid developing\nsoftware lemons!\n", "page": 33, "type": "text", "section": "Page 33"}
{"text": "What Is Designing About?\n17\nKey take-home points about what designing is about\nThis \ufb01rst chapter has swept across a fairly wide set of issues related to\ndesign itself. Here we very brie\ufb02y recap some key concepts that will be par-\nticularly useful when reading the later chapters.\nIll-Structured Problems (ISPs) are characterised by a lack of true/false\nproperties\u2014and are the type of problem that needs to be \u2018solved\u2019\nthrough the use of design rather than analysis. (And software devel-\nopment is de\ufb01nitely an example of an ISP.)\nTechnical debt is a concept that distinguishes software development that is\nundertaken \u2018for real\u2019 from software that is written as a learning exercise\nand then discarded. Designers need to think about the consequences of\ntheir decisions in terms of their e\ufb00ect upon the future evolution of an\napplication.\nDesign can be used as a noun. Employed in this way, \u2018a design\u2019 means a\nplan for how some goal is to be achieved, whether this be physical (how\nto construct something) or a process (how to perform something).\nDesign can be used as a verb. This refers to the act of designing (pro-\nducing a plan).\nThere are di\ufb00erent perspectives upon design. Design thinking applies\nto a range of activities that can all be considered as being design in\nsome form. Three major perspectives on design that are all relevant to\nsoftware development are design as styling, design as planning and design\nas adaptation (experience and models).\nDesigning is creative. When undertaking design activities, our objective is\nto create something that does not already exist, which involves predict-\ning an e\ufb00ect upon the future that will only be realised if the design plan\nis feasible. To do so, we need to be able to envisage how something will\nbe done, and then work backwards to devise ways of bringing this about.\n", "page": 34, "type": "text", "section": "Page 34"}
{"text": "Chapter 2\nDoing Design\n2.1\nDesigning as a creative process ..................................\n19\n2.2\nIll-structured problems ...........................................\n21\n2.3\nWhat does a designer do? ........................................\n24\n2.4\nA simple example: the house move ..............................\n27\nKey take-home points about designing ..........................\n28\nThe previous chapter introduced the idea of design thinking and its in\ufb02uence\nupon software development. In this chapter we look at what it means to apply\nthis to produce a design \u2018solution\u2019. In particular we examine the in\ufb02uence on\nthis of the ill-structured (or wicked) nature of design problems and consider\nhow this might a\ufb00ect the ways that we set about \u2018doing design\u2019.\n2.1\nDesigning as a creative process\nA distinctive characteristic of humans is the ability to use tools to create\nnew artifacts, where these are new in the sense that we end up with something\nthat did not exist before. The meaning of \u2018artifact\u2019 is \u201csomething made by\nhumans\u201d, so distinguishing an artifact from the things found in the natural\nworld. Indeed, the range of artifacts seems almost endless: clothing, books,\nfurniture, buildings, bridges, ships, machinery, computers. . .\nAnd those are simply the physical forms of artifact. There are also many\nexamples of procedures that humans devise in order to add structure to our\nlives, whether it involves the process for getting married, organising the way\nthat passengers should board a plane, or negotiating an overdraft with our\nbank. The tools used to create these are likely to include a variety of conceptual\nforms (such as work\ufb02ows and legal frameworks)\u2014but the procedures that\nresult are still artifacts, helping to organise our lives and businesses in an ever\nmore complex world.\nThe material in the chapters that follow this one is concerned with largely\nconceptual tools such as design methods, software architecture and software\npatterns. Software tools for producing more \u2018physical\u2019 aspects of design meth-\nods such as diagrams and speci\ufb01cations do exist, but since their purpose is\n19\n", "page": 36, "type": "text", "section": "Page 36"}
{"text": "20\nSoftware Design: Creating Solutions for Ill-Structured Problems\nmainly one of recording design decisions rather than helping to create new\nmodels, they do not really \ufb01t into the scope of this book.\nCreativity requires more than the availability of conceptual tools of course.\nWhat creativity involves is the ability to \u201cthink outside the box\u201d and to \ufb01nd\nnew and e\ufb00ective ways to meet a particular need. While this may occasionally\ninvolve coming up with a radically di\ufb00erent way of doing something, quite\noften the creative element will be realising that doing things a bit di\ufb00erently\nmight produce something that is more e\ufb00ective, robust, elegant, or some com-\nbination of such attributes.\nOur perception of how design is involved in producing new ideas will vary,\nand probably not always be correct. No-one is likely to deny the importance\nof using rigorous and well-proven engineering design practices when creating\nmotorway bridges, aircraft and buildings, not least because of the safety issues\nassociated with their role and use. Yet good design is important for everyday\nthings too (Norman 2002), even if the e\ufb00ects of poor design lead to noth-\ning more than the odd stubbed toe, or the irritation of having to restart a\ntransaction on our phone or tablet because some information has been \u2018lost\u2019.\nA second, and associated, human characteristic is that of communication\u2014\nalthough in a design context its importance may arise more from the variety\nof ways in which it is employed.\nCommunication with the team\nCommunication usually plays a vital supporting role to creativity, since\ndeveloping any new form of artifact almost always requires us to formulate\nin some way the concept of what this artifact is to be and then to tell others\nabout our ideas. Communication has always been necessary to gain approval\nand assistance from others, whether it be for the purpose of persuading them\nto join in with building a megalithic barrow; obtaining a commission to paint a\n", "page": 37, "type": "text", "section": "Page 37"}
{"text": "Doing Design\n21\nmural for a medieval pope; creating a new social welfare system; constructing\na steam locomotive; or creating an on-line banking system. And the act of\ncommunication can take many forms, spoken or written words, scale models,\nmathematical formulae, sketches, simple prototypes etc. And obviously it is\nclosely related to the issue of how we represent our ideas.\nCommunication also plays another, rather di\ufb00erent, role in creative activ-\nities. This is to act as the vehicle by which experience and expertise about\nhow to do something (in our case, design software) can be conveyed from an\n\u2018expert\u2019 to a \u2018novice\u2019, as well as be shared among a community of experts. In-\ndeed, the ability to reuse ideas is a major element in the development of design\nexpertise, and it is the systematic codi\ufb01cation and organisation of knowledge\nfor the purpose of its reuse that forms an important characteristic of both\ncraft and engineering disciplines, although these may di\ufb00er in the degree of\nformality involved in the codi\ufb01cation of their bodies of knowledge.\nBoth creativity and communication are core concepts that underpin the\nideas presented in this book. Indeed, one of the roles for a book like this is\nthat of communication, seeking to explain to others a range of ideas about\ndesign and its realisation in a software context.\n2.2\nIll-structured problems\nAs explained in Chapter 1, software development tasks are examples of\nill-structured problems (ISPs). ISPs cannot be \u2018solved\u2019 by straightforward an-\nalytical means. Well-structured problems (WSPs) can often be solved by using\na reductionist approach, gradually transforming the (possibly quite complex)\nmodel of the problem into a model of the solution. A good example of this is\nmathematic models of three-dimensional motion, where the use of an appro-\npriate system of axes can separate out the components so that they can be\nsolved independently. In contrast, ISPs require some form of design process,\nwhere this usually involves iteratively postulating a (increasingly complex)\n\u2018solution\u2019 model, and then evaluating how well this meets the requirements.\nWe discuss this approach more fully later.\nAn example of the problems posed by an ISP is demonstrated by the way\nthat feature interaction can occur when modifying software systems that need\nto support many options in their operation (such as the software for a phone).\nFeature interaction is something that arises when the act of adding a new\nfeature that was probably never even envisaged in the original design model\ncauses some of the existing features to stop working correctly. While it may be\npossible to use analytical techniques to identify where the interactions occur,\na resolution of this may quite possibly require a major redesign of internal\ndata structures and the software used to access these.\n", "page": 38, "type": "text", "section": "Page 38"}
{"text": "22\nSoftware Design: Creating Solutions for Ill-Structured Problems\nUsing a slightly di\ufb00erent terminology drawn from \u2018design as planning\u2019,\ndesign problems can be regarded as being examples of what is termed a wicked\nproblem. This term was coined by Rittel & Webber (1984) and arose from\ntheir analysis of the nature of social planning problems. A wicked problem\ndemonstrates some interesting properties, and it can be brie\ufb02y summarised as\nbeing a problem for which its form is such that the act of \ufb01nding a solution\nfor one of its aspects will also have the e\ufb00ect of changing our understanding of\nthe problem1. (For the discussion of this section, we can largely interpret the\nterm \u2018solution\u2019 as meaning a design plan.) For the purposes of this section we\nwill continue to use Simon\u2019s terminology and refer to such problems as ISPs.\nRittel and Webber identi\ufb01ed ten distinguishing features of ISPs/wicked\nproblems. Most of these can be equally well interpreted as applying to software\nsystems (Peters & Tripp 1976). Here we brie\ufb02y review those characteristics of\nan ISP that relate most closely to software design, and interpret them for a\nsoftware related context.\n\u2022 There is no de\ufb01nitive formulation of an ISP. The challenges involved in\nspecifying what software systems should do are well known, and indeed,\nbecause both speci\ufb01cation and design can involve modelling of some\nrequired functionality as we illustrate in Figure 2.1, they can be di\ufb03cult\nto separate clearly. Rittel and Webber make the point that the activity\nof specifying and understanding a problem or need is also prone to be\nbound up with our ideas about how it might be solved. This of course\nis one reason why simple life-cycle models in which the activities of\nspeci\ufb01cation (by the customer) are performed in advance and form the\nbasis for the task of design (by the developer) are usually unrealistic.\n\u2022 ISPs have no stopping rule. This emphasises the point that there are no\ncriterion that we can use to establish when the solution to a problem\nhas been found, such that any further work is unlikely to improve it\nsigni\ufb01cantly. When designing software it lacks any characteristic we can\nmeasure and use to demonstrate that a particular design model is \u2018com-\nplete\u2019. So, rather inconveniently, we have no reliable way of determining\nwhen we should stop working on a design task.\n\u2022 Solutions to ISPs are not true or false, but good or bad. In science, we\ncan often identify whether a \u2018solution\u2019 is correct or not, perhaps math-\nematically, or experimentally. In contrast, there are very many ways\nof writing bits of software, or structuring them, which will all pro-\nduce the intended (\u2018correct\u2019) outcomes. They may di\ufb00er in many ways\n(length, clarity, speed of execution) while performing the required task\nsuccessfully. (Anyone who has marked student programming exercises\n1Those familiar with Sellar & Yeatman\u2019s classic work \u201c1066 And All That\u201d (1930) might\nfeel that this idea is aptly illustrated by their description of Gladstone\u2019s frustration with\ntrying to guess the answer to the Irish Question, and their explanation that \u201cunfortunately,\nwhenever he was getting warm, the Irish secretly changed the Question\u201d.\n", "page": 39, "type": "text", "section": "Page 39"}
{"text": "Doing Design\n23\nInternal design\nmodel of how the\nfunctionality will\nbe provided\nRequirements specification of\nexternal functionality, describing\nwhat the system is to do.\nModel of\nexternal\nbehaviour\nSystem specification\nDesign\nModel of\ninternal\norganisation\n(structure)\nFIGURE 2.1: The interaction between requirements and design models\nwill be familiar with the wide variation of style and structure commonly\nencountered\u2014even for the programs that work!)\n\u2022 There is no immediate and no ultimate test of a solution to an ISP. What\nthis e\ufb00ectively observes is that we can\u2019t really be sure that what we have\nproduced meets all the identi\ufb01ed needs by means of any simple form of\ntest. As we will see, evaluation of a software design is very challenging,\nand even apparently simple comparisons between design solutions need\nto be made by using multiple criteria.\n\u2022 Every ISP is essentially unique. In later chapters we discuss ideas about\nhow we can reuse design experience for part-designs through forms such\nas design patterns and software product lines. But even with these, the\ndesigner needs to adapt and interpret the idea in order to apply them to\na speci\ufb01c requirement\u2014which of course is why design activities do not\nlend themselves to being automated.\nTaken together, these ideas are certainly at variance with the reductionist\napproaches to problem-solving widely employed in mathematics and science.\nSuch an approach seeks to break a problem down into smaller, more manage-\nable (and solvable) elements, with an implicit assumption that there will be\na single solution that this process will converge on.\nIn contrast, ill-structured design problems require the designer to juggle\nmany di\ufb00erent aspects of their \u2018solution\u2019 simultaneously. This then requires the\ndevelopment and use of complex models, and making a \u2018wrong\u2019 design choice\n", "page": 40, "type": "text", "section": "Page 40"}
{"text": "24\nSoftware Design: Creating Solutions for Ill-Structured Problems\nearlier in the design process may make it harder to resolve later choices. The\nconcept of orthogonality, whereby the parameters of a model are independent\nfrom each other, doesn\u2019t apply to an ISP, where factors may interact in di\ufb00er-\nent ways and the best that we can hope to do is to make trade-o\ufb00s between\nthem. Our choices between options are apt to be driven by the need to \ufb01nd a\nbalance, rather than expecting to \ufb01nd the \u2018right\u2019 outcome.\nSo, these are the types of problems that we will be addressing in the\nfollowing chapters. Successful designing does not result simply from following\nprescribed processes or reusing structures that have worked for others. As we\nwill see, these things might well be useful elements in the design process, or in\nlearning about it, but even then, their use will probably involve some degree\nof adaptation.\n2.3\nWhat does a designer do?\nSo, what exactly is involved in designing something? A good starting point\nis to consider the words of a pioneering \u2018design methodologist\u2019, J. Christopher\nJones, taken from his classic work, Design Methods: Seeds of Human Futures\n(1970).\n\u201cThe fundamental problem is that designers are obliged to use\ncurrent information to predict a future state that will not come\nabout unless their predictions are correct. The \ufb01nal outcome of\ndesigning has to be assumed before the means of achieving it can\nbe explored; the designers have to work backwards in time from an\nassumed e\ufb00ect upon the world to the beginning of a chain of events\nthat will bring the e\ufb00ect about.\u201d\nScience\nseeks\nto\nreduce\ncomplexity\nThis statement describes an approach to\ntackling an ISP that is radically di\ufb00erent from\nthe reductionist practices of \u2018scienti\ufb01c method\u2019\ncommonly used with WSPs, and involving sub-\ndividing a complex problem into simpler ones.\nSo in its way the statement from Jones is both\nchallenging and unsettling\u2014we are asked to pos-\ntulate the form of the desired end result in or-\nder to try to achieve it, rather than to proceed\nthrough a process of deduction and analysis to\ndetermine what its form should be.\nOne reason for this di\ufb00erence of philosophy is\nbecause science is largely concerned with study-\ning things as they are, using observation and ex-\nperiment as the means of testing ideas. A rather\n", "page": 41, "type": "text", "section": "Page 41"}
{"text": "Doing Design\n25\nsimpli\ufb01ed view of the scienti\ufb01c process goes as follows: a scientist observes\nsome phenomenon, builds models of how they think this arises, and then seeks\nto verify and test those models by using them to make predictions, which are\nthen compared with reality through further observation and experiment. (Of\ncourse, this will often be iterative.) In contrast, the description of the design\nprocess outlined by Jones is one that is more familiar to engineers, and is one\nthat is seeking to create new things. The focus is upon devising some mecha-\nnism that will have a new e\ufb00ect upon the world, rather than upon analysing\nsomething that exists. To achieve this, we need to postulate what the end\nresult will be, and then to try to devise the means of bringing it about. So\nthis is where creativity comes into play!\nImplicitly, such an approach contains some degree of uncertainty, mainly\nbecause the \u2018solution space\u2019 for an ISP is potentially very large. And this\nuncertainty occurs partly because we are usually tackling the whole problem,\nnot trying to use a reductionist approach to resolve it as a set of constituent\nparts. As a result, we may fail to \ufb01nd an e\ufb00ective means of bringing an e\ufb00ect\nabout, or at least, our early attempts might not \ufb01nd the best ways to do this.\n(Think about some of the early designs for cars, aircraft, television sets etc.)\nAlthough of course, an appreciation that these are not the best ways might\nnot be obvious at the time. And while scienti\ufb01c deduction can lead us down\nblind alleys too, there are usually better tests that can be used to identify\nand recognise these than are available for assessing the practicality of design\nsolutions.\nScientific\nactivities\nDesign\nactivities\nStudy of things as they are\n(astronomy, biology, chemistry...)\nMaking new things\n(buildings, ships, phones...)\nObserve\nMeasure\nAnalyse\nExperiment\nObserve\nMeasure\nAnalyse\nExperiment\nCreate\nUse\nEvaluate\nCreate\nUse\nEvaluate\nBetter understanding\nBetter tools\nHuman interaction\nwith the world\nFIGURE 2.2: How science and design interact with the world\n", "page": 42, "type": "text", "section": "Page 42"}
{"text": "26\nSoftware Design: Creating Solutions for Ill-Structured Problems\nFigure 2.2 shows the di\ufb00erence between these two processes in a schematic\nform. Both are gross simpli\ufb01cations of course, but they focus upon the essen-\ntial di\ufb00erences, not the detailed nature. And the implication that the role of\nscience is to provide a better understanding of the world, while that of design\nis to provide better tools for living in it, is also something of a simpli\ufb01cation.\nIf we examine the quotation from Jones a little more closely, and rephrase\nit a little, we can identify some of the actions that a designer will need to\nperform when deriving and specifying a \u2018design solution\u2019 (usually termed a\ndesign model) to meet a given need. And, as there will be many possible\nsolutions, the designer needs to refer to \u201ca solution\u201d where the scientist can\nusually refer to their goal as \u201cthe solution\u201d. These actions include:\n\u2022 postulating how a solution may be organised;\n\u2022 building a model of the solution (the design model);\n\u2022 evaluating the model against the original need;\n\u2022 elaborating the design model to a level where it can be realised.\nOf course it is never as simple as this! While there is an implicit ordering\nfor these activities, they are by no means likely to be performed as a simple\nsequence. It is usually necessary to perform many iterations at each stage as\nwell as between stages, and quite extensive backtracking may be needed when\ndesign choices have to be re-evaluated. Indeed, as Jones (1970) recognises, the\nposition may be even worse, since:\n\u201cIf, as is likely, the act of tracing out the intermediate steps ex-\nposes unforeseen di\ufb03culties or suggests better objectives, the pat-\ntern of the original problem may change so drastically that the\ndesigners are thrown back to square one.\u201d\nIn other words, the act of elaborating the original model may reveal its inad-\nequacies or even total unsuitability, requiring that it be discarded altogether!\nDiscarding a design idea\n", "page": 43, "type": "text", "section": "Page 43"}
{"text": "Doing Design\n27\nWindow\nLounge\nKitchen\nBathroom\nStorage\nHallway\nBedroom 1\nBedroom 2\nPower outlet\nFIGURE 2.3: Plan of a single-storey house\n2.4\nA simple example: the house move\nAt this point, it may be useful to look at a simple illustration of the use of\ndesign thinking. Moving to a new house or \ufb02at is a fairly common experience,\nand is widely regarded as one of the major traumas in life. However, within\nthis lies a good illustration of the use of design thinking, so for our example, we\nbrie\ufb02y examine some of the activities that might be involved when planning\na move into a new house. Strictly of course, this is \u2018design as planning\u2019 rather\nthan \u2018design as adaptation\u2019. However, using this perspective provides a rather\neasier introduction to, and illustration of, the nature of designing as well as\nof ISPs, while possessing the same key characteristics.\nOne of the practices often recommended for organising a move is to begin\nby measuring the dimensions of the various rooms in the house, then to obtain\nsome squared paper and use this to draw a scale plan showing all of the rooms,\nwith the positions of doors, windows etc. (If this sounds a bit low-tech, just\nwait. . . ) Figure 2.3 shows a simple example of this. The next step is to measure\nthe dimensions of our furniture and then to cut out pieces of cardboard with\nshapes that represent this on the chosen scale. Together with the scale plan,\nthese form a \u2018model\u2019 of the house and its future contents.\nThe following bit of the process is the \u2018design\u2019 element, which is also pretty\nlow-tech, and involves trying to identify the \u2018best\u2019 positions for all of our\nfurniture in the new house by placing the cardboard shapes on our model and\ntrying to visualise the outcomes. There are some obvious constraints (we don\u2019t\n", "page": 44, "type": "text", "section": "Page 44"}
{"text": "28\nSoftware Design: Creating Solutions for Ill-Structured Problems\nusually want bedroom furniture in the kitchen), and there may be issues of\ncolour or style which a\ufb00ect how speci\ufb01c items of furniture might go together,\nbut essentially there is really no systematic way of doing this. Nor is there a\nclear measure that tells us that we have found the \u2018best\u2019 plan. And of course,\nthis is really a two-dimensional representation of a three-dimensional situation,\nso we also have to consider the possibility of furniture blocking windows or\nradiators, or obstructing access to power sockets 2.\nThe decisions that result from this process can then be regarded as pro-\nviding a plan that can help the removal team on the day. Indeed, not only\nwill it tell them where items are meant to go, it may also a\ufb00ect the way that\nthey pack the items in their van so that unloading is made easier. So, the\noutcomes from our design activity may well feed into the way that they go\nabout planning their tasks too.\nCompared with designing software, this is a relatively simple process. Yet it\nis su\ufb03cient to illustrate some of the ways that design di\ufb00ers from analysis. As\nnoted previously, when solving WSPs, especially when these are mathematical\nin nature, we try to separate di\ufb00erent variables and simplify our task by\nderiving a solution for each of them separately (reductionism). In contrast,\nfor design we have to manipulate all or most of the elements of a complex\nmodel throughout the process. There are also many possible \u2018solutions\u2019; there\nis no really useful criterion to tell us that we have found the optimum one, and\nno way of knowing when to stop (other than exhaustion). And there may be\ntrade-o\ufb00s too: we may need to accept the odd partially-blocked power socket\nin order to get the layout that we want in a particular room. Finally, it is still\na (design) model\u2014on the day, when we see everything in place, there\u2019s a good\nchance that it will become blindingly obvious that it is possible to improve\nsubstantially on what we have devised, or even worse, that there is a major\n\ufb02aw in it.\nHowever, in many ways, this provides a much simpler environment than\nthe one that the software designer faces. The model is closely and physically\nrelated to the solution, the set of objects being manipulated is a \ufb01xed one,\nand the properties for each of them are known. Also, the design process only\ninvolves us in modelling physical objects rather than processes, unlike design-\ning with software. So, while the example illustrates some key aspects about\nthe design process, we should not forget that things are rapidly going to get\nmore complicated when we come to design software applications.\n2The reaction of many software engineers is probably to suggest building some sort of\nsoftware tool to assist with this, that could help by highlighting any constraints that are\nviolated. Useful though this might be, it doesn\u2019t do anything to change the fact that we\nstill have to make all of the decisions about where things are to go.\n", "page": 45, "type": "text", "section": "Page 45"}
{"text": "Doing Design\n29\nKey take-home points about designing\nThis second chapter has largely focused on how design thinking is applied\nto designing new things.\nDesigning is creative. The aim of designing is to create something that\ndoes not already exist. This requires the designer to predict a (desired)\noutcome and explore ways of bringing this about.\nDesign is used to address ill-structured problems (ISPs). This means\nthat there will be a large number of possible \u2018solutions\u2019 (designs) for a\ngiven problem, and that the process of designing has no \u2018stopping rule\u2019\nthat tells the designer that the current state of their design solution is\ngood enough. As an added complication, there are no simple measures\nthat can be used to assess the feasibility of a design plan.\nDesigners solve problems di\ufb00erently to scientists. Scientists commonly\naddress problems by following a process of reductionism, seeking to re-\nsolve a complex problem into separate simpler ones that can be more\nreadily solved analytically. Designing involves exploring all, or most, of\nthe characteristics of the \u2018design model\u2019 at once, rather than being able\nto consider them separately.\n", "page": 46, "type": "text", "section": "Page 46"}
{"text": "Chapter 3\nManaging the Design Process\n3.1\nCognitive capacity ...............................................\n31\n3.2\nThe power of abstraction ........................................\n32\n3.3\nModelling and making design choices ............................\n34\n3.4\nRecording design decisions .......................................\n35\n3.5\nCommunicating ideas about a design model .....................\n37\nKey take-home points about the design process .................\n40\nGiven that design (as a verb) is an important means of developing \u2018solutions\u2019\nto complex ill-structured problems, an important question is how we manage\nthis process, and what information we need to record as part of that task.\n3.1\nCognitive capacity\nBack in 1956, George Miller, a psychologist from Harvard University, pub-\nlished a paper titled The Magical Number Seven, Plus or Minus Two: Some\nLimits on our Capacity for Processing Information (Miller 1956). Essentially,\nthis very extensively-cited paper was about the limitations of human cogni-\ntive capacity for processing di\ufb00erent forms of information. Strictly speaking,\nMiller\u2019s main focus was upon the ability to make judgements related to dis-\ntinguishing between di\ufb00erent stimuli of the same type, such as sound tones,\nor tastes, although he also discussed the quite distinct limitations upon im-\nmediate memory. However his use of the number seven as representing some\nform of limit on cognitive capacity has subsequently been interpreted (or mis-\ninterpreted) very liberally.\nThe key point for our purposes here is to appreciate that the human brain\nhas a limited capacity for recognising things on a \u2018one-dimensional\u2019 scale.\nIndeed, the exact number of things that can be distinguished is not too critical\nas far as we are concerned; what matters is that there is a limit on how much\ninformation about a design can be readily accommodated in the designer\u2019s\nhead, and that the limit is set quite low.\n31\n", "page": 48, "type": "text", "section": "Page 48"}
{"text": "32\nSoftware Design: Creating Solutions for Ill-Structured Problems\nIn practical terms, what this means is that managing the design\nprocess\nrequires\nthat\nthe\ndesigner\nneeds\nto\nuse\nsome\nway\nof\nhan-\ndling very many design elements that each have complex properties.\nIt simply isn\u2019t possible to hold everything that\nneeds to be considered in one\u2019s head while de-\nveloping or modifying a design model, meaning\nthat the designer needs tools to help them cope\nwith these limitations upon cognitive capacity.\n(And of course, the tools themselves may involve\ncognitive limitations. As we will see, diagram-\nmatical notations do seem to be harder to use\nwhen they have overly many symbols\u2014a point\nthat the designers of the UML do not seem to\nhave grasped (Moody 2009).)\nSo the rest of this chapter looks at some of\nthe ways that we can cope with these cognitive limitations, and what it is\nnecessary for a designer to do.\n3.2\nThe power of abstraction\nIn order to create manageable models of the intended system and envisage\nhow it will behave, we need to \ufb01nd ways to put aside the details that don\u2019t\nmatter and to focus upon the factors that do matter.\nThe concept of abstraction is an essential one when formulating design\nideas in any branch of engineering. The process of abstraction involves re-\nmoving or omitting unneeded detail from a description of a model or plan,\nwhile still retaining a description of those properties that are relevant. Doing\nso reduces the cognitive load involved in understanding particular aspects of\na design model.\nOur earlier example of moving house illustrates this well\u2014the two-\ndimensional plan provides a model of the house that retains only the infor-\nmation that is important to consider when positioning furniture. It describes\nthe things we need to know for this purpose (where sockets are located, which\nways the doors open etc.) but omits such information as whether windows are\nclear or opaque, what colours the walls have been painted, or where the lights\nare located etc. Of course, for other tasks we might need a quite di\ufb00erent\nabstraction of the house. If we are planning to modify the power outlets and\nlights, we would need a very di\ufb00erent sort of representation that relates to the\ndi\ufb00erent electrical circuits, and that probably omits much of the information\nconsidered appropriate for positioning furniture.\nAbstraction is both an important concept and also one that novice soft-\nware designers may well \ufb01nd di\ufb03cult to employ e\ufb00ectively, as demonstrated\n", "page": 49, "type": "text", "section": "Page 49"}
{"text": "Managing the Design Process\n33\nin an early study by Adelson & Soloway (1985). Programmers are used to\nworking with what in many ways is a wonderfully pliable medium, but the\nnature of programming requires that the programmer needs to anticipate all\nof the di\ufb00erent ways that a chunk of software will need to work. It is only too\ntempting for the novice designer to focus upon the \u2018comfort zone\u2019 of detailed\nprogramming structures when thinking about design, since these are likely\nto be more familiar, whereas as a designer, they need to learn how to think\nabout the properties of a system in an abstract way. Design models need to\nrelate to events, entities, objects or whatever other key elements are involved\nin thinking about a particular aspect of the design, and to leave to a later\nphase issues of detail such as the choice of speci\ufb01c data structures, or the\nform of loop construct needed for a given algorithm etc.\nAbstraction therefore plays a key role in this book, corresponding to its\ncentral role in designing systems. In particular, when we look at how the\ncharacteristics of a design can be represented we will \ufb01nd that we need to\nthink about a number of di\ufb00erent abstractions. The e\ufb00ective and appropriate\nuse of abstraction is a key skill that any designer needs to learn and employ.\nWe will be revisiting this in the next chapter and in many of the later chapters.\nAs a \ufb01nal thought about abstraction, and to provide a tangible illustration,\nwe brie\ufb02y revisit our \ufb01rst sketch related to the CCC.\nAn abstract description of the CCC\nThe sketch below is about as abstract a description of the CCC system\nas we can devise. It certainly omits a lot of detail, yet still manages\nto identify the main elements involved, together with something about\ntheir roles.\nA simple model of the CCC\n", "page": 50, "type": "text", "section": "Page 50"}
{"text": "34\nSoftware Design: Creating Solutions for Ill-Structured Problems\n3.3\nModelling and making design choices\nWhen describing what designing is about, we might say that our aim is to\nproduce a \u2018design solution\u2019 that will meet a speci\ufb01c need. In computing, that\nneed will typically be documented in some form of requirements speci\ufb01cation.\nThis may be little more than a few jotted notes or sketches, through to a\nvery detailed formal document (the speci\ufb01cation for the CCC system comes\nsomewhere between those). It is then the task of the designer or design team\nto formulate a way of meeting that need by creating some form of design\nmodel for the proposed solution.\nThe act of designing something usually involves identifying suitable op-\ntions for the key features of our \u2018design solution\u2019 and then evaluating the\nconsequences of adopting each of them. For example, one of our \ufb01rst deci-\nsions may well be to choose an appropriate architectural style for our ap-\nplication. (We will discuss the idea of system architecture and architectural\nstyle more fully in later chapters; for the moment we can just consider the\narchitecture of an application as being the types of software module we will\nemploy.) So, for a particular application, we might consider organising it using\nan object-oriented form, based upon a set of classes and objects, or organising\nit around a central database. Both approaches will have their merits: using\nobjects may mean that any future evolution of our application that is an-\nticipated will be easier to achieve; while using a database may mean that\nthe application can be delivered to the end-users more quickly, although fu-\nture changes may require more work. And here we can see one aspect of the\nproblem of choice, in that our reasons for preferring one design solution over\nanother may well be based upon how we rank quite di\ufb00erent criteria, with\nthe options also incurring quite di\ufb00erent degrees and forms of technical debt.\nMaking a choice between the di\ufb00erent design options\nmay also be based upon criteria that are relatively ill-\nde\ufb01ned. And as the early choices we have to make are\ngoing to be based upon a very abstract and incomplete\nmodel, making them will almost always involve making\ntrade-o\ufb00s between estimates of the likely impact of the\ndi\ufb00erent options upon both system functionality as well\nas such non-functional properties of the model as size,\nspeed and ease of change. There may also be other more\ncontext-speci\ufb01c factors that might in\ufb02uence design choices: in that an appli-\ncation may need to conform to the way that an organisation operates; it may\nneed to work with, and communicate with, other systems; and there will nearly\nalways be the need to plan for likely future extensions. This last point, with\nits implications of di\ufb00erent levels of technical debt, reminds us that designers\nneed to think to the future, not just to the present.\n", "page": 51, "type": "text", "section": "Page 51"}
{"text": "Managing the Design Process\n35\nThroughout this process though, the designer needs to keep in mind that\nthe ultimate criterion has to be \ufb01tness for purpose. It is not that the other\nfactors don\u2019t matter, they certainly do, but they need to be subordinate to\nthe need to produce a system that does the required job. This goes for most\nartifacts of course\u2014however much we might like the added \u201cbells and whistles\u201d\nof a particular model of car or of a speci\ufb01c hi-\ufb01ampli\ufb01er\u2014pragmatism usually\nmeans that our ultimate choice will need to be made on the basis that it can\nbe relied upon to do the job that we need it to do, and that it will do so at a\nreasonable cost.\nUsing these criteria to help evaluate possible options can be made easier\nif the designer produces some form of design model that can be used to help\nmanage the cognitive processes involved. The nature of an ISP means that\nwe need to postulate a design solution and then re\ufb02ect on whether or not\nit will do the job we want, and how well it will do it. Having some form of\nabstract design model, possibly realised in the form of diagrams and text, can\nhelp with managing this process of re\ufb02ection, perhaps by using it to evaluate\ndi\ufb00erent scenarios of use or change via some form of \u2018design walk-through\u2019.\nAnd \ufb01nally, the idea of \ufb01tness for purpose isn\u2019t some abstract concept, it\nneeds to be given concrete values that can be used to assess the terms above.\nWe need to have a clear picture of what we expect of something that \u2018should\nwork\u2019 and of what we mean by \u2018as well as possible\u2019. If we are building something\nthat is safety-critical (that is, lives will be at risk if it fails), then we should\nhave some quite de\ufb01nite ideas about these terms. This is less so where the\nconcept of \u2018works\u2019 might be less precise (such as an application that depends\nupon some form of image recognition), where we might be willing to accept a\nless than complete level of reliability, at least in early versions.\nThis is maybe where some reverse thinking may help. Rather than trying\nto de\ufb01ne \u2018should work\u2019, we might try to consider what sort of shortfalls in\nfunctionality or performance might still mean that we consider that the system\n\u2018works\u2019, even if it is not doing so as well as we wish. For the example of image\nrecognition, we might be willing to accept that our application may sometimes\nbe unable to recognise an image, or fail to get the right match, particularly\nif such a failure can be easily identi\ufb01ed by the user. On the other hand, an\napplication where the outputs are occasionally badly in error in a way that\ncannot easily be recognised by the user is likely to be considered unacceptable,\neven if this occurs very infrequently.\n3.4\nRecording design decisions\nSomething that is often overlooked when a software application is devel-\noped is the value that can be derived from noting why particular design choices\nwere made. While the rationale for these may have been obvious to the design-\n", "page": 52, "type": "text", "section": "Page 52"}
{"text": "36\nSoftware Design: Creating Solutions for Ill-Structured Problems\ners of the original system, they may well be far less obvious to those who are\nlater tasked with extending or modifying a system. However, while our design\nmodel will usually record what choices were made, the rationale behind those\nchoices is not so readily included. And although the absence of knowledge\nabout the original rationale can add signi\ufb01cantly to technical debt, it often\nremains overlooked. (In fairness, this problem is not one that is con\ufb01ned to\nsoftware engineering; it happens in other forms of engineering too.)\nBeginning with the original design, the\nrecording of rationale is more likely to be en-\ncouraged if the software development project in-\ncludes some form of design audit. Such an audit\nmay consist of a peer review of the designer\u2019s\nideas, or it may be something rather more for-\nmal. Whatever form it takes, an audit may help\nwith recording the reasons for particular design\nchoices. And conducting such an audit requires\nthat we have a design model that is recorded in\na form that can be shared with others.\nArguably there is an equally good reason for\nthe rationale for maintenance (design evolution) changes to be recorded. Soft-\nware applications may have quite long lifetimes and undergo extensive changes\nover that period, often involving much greater developer time than the orig-\ninal development. Ideally, the maintenance team need to be able to recreate\nthe original models used by the designers so that they can reliably decide\nhow to implement their changes in a manner that preserves the structure of\nthe application (Littman, Pinto, Letovsky & Soloway 1987). In turn, they too\nshould record the reasons for their changes.\nUnfortunately, while di\ufb00erent software design approaches generally encour-\nage the recording of decisions about how an application should be structured,\nthey are apt to place less emphasis upon recording the rationale for those\ndecisions. It is easy to understand why this is so. A design usually evolves\nthrough a set of di\ufb00erent stages and forms, and recording the reasons for each\nstep and/or change in thinking may well be seen as a chore by the design team.\nThis issue was recognised many years ago by Parnas & Clements (1986). They\nobserve that, even if the design process was not a rational one (which it usu-\nally isn\u2019t), the documentation that described it could still make it appear as\nthough it were. In other words, the design documentation should be written\nso as to describe a consistent and rational process.\nParnas & Clements argue that the principal bene\ufb01ts of doing so are that\nnew members of a design team (or those later charged with extending the\ndesign) will then be able to absorb knowledge about the project more easily.\nIndeed, they observe that even for scienti\ufb01c studies such as mathematical\nproofs, the form eventually published is rarely the form in which the proof\nwas actually derived, because as understanding grows, various aspects can\nusually be simpli\ufb01ed. In the same way, it is the actual structure of the system\n", "page": 53, "type": "text", "section": "Page 53"}
{"text": "Managing the Design Process\n37\ndesign, and the reasons for it, rather than the way that these emerged, that\nwill be of importance to new team members.\nAn excellent example of the complexity of team development is that of\nmany open source software (OSS) projects. Although various tools exist to\nhelp track a project through its many iterations, there still seems to be rela-\ntively limited scope (or perhaps motivation) to record design rationale, which\nin turn can provide a challenge to anyone joining a project (Steinmacher,\nSilva, Gerosa & Redmiles 2015). And for professional developers, recording\ndecisions and rationale is still only likely to occur where there are some ap-\npropriate quality control processes in place.\n3.5\nCommunicating ideas about a design model\nOnce a designer has formulated a \u2018solution\u2019 intended to meet the need of\ntheir customer, the next step is to consider how their ideas about the form of\ntheir design model are to be conveyed to others, since to be useful, a design\nneeds to be implemented in some way.\nJust when the concept of the creation of an artifact requiring some form\nof \u2018design activity\u2019 \ufb01rst emerged can only be a matter for conjecture. Many\nof the major creations of antiquity such as the Egyptian pyramids must have\nrequired quite a signi\ufb01cant element of planning, so civil engineering in the\nbroadest sense, may well be where this \ufb01rst became recognised1. Later on, in\nthe thirteenth century, King Edward I of England employed \u2018Master James of\nSt George\u2019 to build some of his major castles, many of which still stand today.\nWhile he was originally described as a \u2018master mason\u2019, his heritage leaves little\ndoubt that he was someone who possessed signi\ufb01cant design skills. Certainly,\nthe nature of civil engineering did require clear directions to be conveyed from\ndesigner to the \u2018production team\u2019.\nWhen software engineering \ufb01rst emerged as a discipline, ideas about the\nform software development should take were strongly in\ufb02uenced by the prac-\ntices used in existing branches of engineering. Hence, the notion of there being\nsome form of distinct design step tended to be assumed in early thinking about\nsoftware development, as illustrated by the idea of the \u2018waterfall model\u2019, shown\nin Figure 3.1. In this approach, the expectation is that the design model will\nbe complete before being implemented. However, this was always regarded as\nrather idealised, and design activities can also be, and usually are, interleaved\nwithin the other steps of development. This is particularly useful where the\ndetails of an application are not fully known, so its design may need to evolve\n1And Pharaoh\u2019s contract lawyers were probably not far behind in establishing themselves\nas a related and very pro\ufb01table branch of the legal profession. . .\n", "page": 54, "type": "text", "section": "Page 54"}
{"text": "38\nSoftware Design: Creating Solutions for Ill-Structured Problems\nRequirements\nelicitation\nRequirements\nelicitation\nRequirements\nspecification\nRequirements\nspecification\nTesting\nTesting\nCoding\nCoding\nDesign\nDesign\nInstallation\nInstallation\nFIGURE 3.1: A waterfall model of software development\nas understanding of its role emerges, leading to the evolution of more \u2018agile\u2019\napproaches as we will see later.\nSo, while a design model may help the designer cope with the cognitive\nchallenges of designing complex things, it also plays an important role in\nsharing ideas about the design with others. The model may be little more\nthan a list (as in the example of moving house), or it may be much more\ndetailed, as in the \u2018blueprint\u2019 traditionally produced for mechanical design.\nThe level of detail will depend upon how much freedom can be given to those\nresponsible for fabricating the design ideas. For mechanical engineering where\nend-products are not easily modi\ufb01ed or adjusted, the degree of tolerance that\ncan be permitted is important, so those responsible for fabrication activities\nwill need to follow the design plan very closely. For house-movers and software\nengineers, whose processes can be modi\ufb01ed rather more easily, the plan can be\nmuch less detailed, to the point that it can evolve while the implementation\ntask is progressing. This is a point that we will return to, as it is one of the\nways in which too close an adherence to traditional design thinking is often\nnot appropriate for the software domain.\nSo we can conclude that communication with those who are responsible for\nfabricating the solution is likely to be an important part of a designer\u2019s role.\nIn addition though, there is also a need for communication with those who are\ncommissioning the design. Their requirements might be very tightly speci\ufb01ed\nand the description of these may focus upon such factors as their market and\nother constraints (\u201ca table for use in village halls, cheap to fabricate, durable,\neasily cleaned, being capable of being safely stacked, and being light enough\n", "page": 55, "type": "text", "section": "Page 55"}
{"text": "Managing the Design Process\n39\nfor one person to move it easily\u201d). Or they may be rather broad and sweeping\n(the medieval baron who wants \u201ca castle bigger and grander than the one\nowned by their rival across the valley\u201d).\nSo here we see another demand upon the designer and their skill-set. The\ndesigner needs to have a good understanding of the problem domain (we can\nassume that in the examples of the previous paragraph the designer would\nknow about tables or castles) and also of the materials that they need to\nwork with. The great Victorian engineers like Isambard Kingdom Brunel were\nprepared to design railways, ships, bridges, railway stations, and many other\nnecessary items as part of their portfolio. However, since that time design ac-\ntivities have tended to become more specialised, partly because of this need for\ndeeper knowledge about the context of a design. So an aeronautical engineer\nis unlikely to be employed to design roads.\nOne thing Brunel didn\u2019t\ndesign was software!\nIn some ways though, software designers \ufb01nd\nthemselves more in the situation of needing to\ncreate a wide range of applications, more as the\nVictorian engineers did (but fortunately with-\nout the need to wear tall stove-pipe hats). The\nuse of software is so ubiquitous and its form so\nadaptable that over-specialisation is rarely an\noption. Admittedly a specialist in (say) database\nsystems might (or almost certainly should) hes-\nitate to take on the task of designing a real-time\ncommand and control system, but in principle\nat least, one person could possess the necessary\nrange of skills for both.\nSo the acquisition of domain knowledge plays\na particularly important role for software design.\nSome of this may be obtained from the cus-\ntomer\u2019s speci\ufb01cation, but as we will see later,\nthis may well fail to identify key elements of the\n\u2018tacit\u2019 knowledge that are familiar to everyone\nworking in the domain\u2014but that may not necessarily be familiar to the soft-\nware designers.\nIf we think about designing software rather than castles, and particularly\nabout designing software applications that will be implemented by a large\nteam of people, what sort of thing are they likely to want to know from the\ndesigner(s)? At the very least this is likely to include:\n\u2022 what the overall \u2018architecture\u2019 of the application is to be\u2014what will be\nthe major elements, what they will do and how they will interact (this\nwill determine many things, including how the elements will behave);\n\u2022 the details of key data objects that the application will need to use\n(usually the \u2018real world\u2019 things that need to be modelled or represented);\n\u2022 any speci\ufb01c algorithms to be used to achieve the necessary functionality;\n", "page": 56, "type": "text", "section": "Page 56"}
{"text": "40\nSoftware Design: Creating Solutions for Ill-Structured Problems\n\u2022 how the elements of the application will be packaged and organised;\n\u2022 how the elements of the application will interact, including any depen-\ndencies (coupling) and causal (event-driven) links;\n\u2022 how the application will interface to, and interact with, its environment\n(users, other software components such as browsers, etc.).\nMostly these are concerned with the form or structure of the application, but\nsome are also concerned with its behaviour, both overall and in detail. So the\noutcomes of the design process (the design model) is likely to be concerned\nwith the way that the elements are structured, the functions that the system\nwill perform, and the way that di\ufb00erent elements will behave, individually and\ncollectively. Whew!\nKey take-home points about the design process\nIn this chapter we have considered the outcomes of the process of designing\nsoftware, and addressed some ideas about what we might consider to be a\n\u2018good\u2019 design.\nAbstraction is an important design tool. A designer needs to focus on\nthe core issues that are relevant to a solution, and to successfully manage\ntheir ideas about this, needs to be able to \u2018discard\u2019 consideration of other\nissues that are not relevant to this.\nFitness for purpose should be the ultimate criterion. While a good\ndesign solution may exhibit many qualities, the ultimate need is that\nit should work and do what is required as well as possible.\nDesign models are a key product of designing. Design as a process\n(verb) leads to design as a product (noun). In its most simple form,\nwhere a designer also implements their design, the design model may\nsimply reside in the designer\u2019s head, but beyond that it needs to be\nmore formally recorded in whatever manner is most appropriate.\nThe rationale for design decisions should be recorded. While this may\nnot be of immediate value to the original application development team,\nit will help others to ensure that future modi\ufb01cations and extensions will\npreserve the integrity of the original design structures, and so reduce the\ntechnical debt during later evolution of the system.\nDesign solutions need to be shared with others. While communication\nis particularly important where manufacturing forms a part of develop-\nment, software applications are often created by teams of developers,\n", "page": 57, "type": "text", "section": "Page 57"}
{"text": "Managing the Design Process\n41\nand they all need to be aware of, and conforming to, a common set of\ngoals and models.\nDesigners need domain knowledge. As well as knowing what can be\ndone with a particular medium (in our case, software) a designer also\nneeds to know something about the environment in which the eventual\napplication is to operate.\n", "page": 58, "type": "text", "section": "Page 58"}
{"text": "Chapter 4\nDesign Knowledge\n4.1\nWhat do expert software designers do? ..........................\n43\n4.2\nSome software design principles ..................................\n49\n4.2.1\nFitness for purpose ......................................\n49\n4.2.2\nSeparation of concerns ...................................\n50\n4.2.3\nMinimum coupling .......................................\n51\n4.2.4\nMaximum cohesion ......................................\n52\n4.2.5\nInformation hiding .......................................\n52\n4.3\nThe evolution of design ideas ....................................\n53\n4.4\nThe nature of expert design knowledge ..........................\n55\nKey take-home points about design knowledge ..................\n57\nThe previous chapters have spelt out some of the challenges associated with\ndesign in general, as well as with designing software, and from this point we\nfocus upon the latter task. Clearly, there are people who can very ably and\nsuccessfully juggle the many factors involved in designing software, and in this\nchapter we look at what it is that characterises expert designers, the designs\nthat they produce, and the nature of their expert knowledge about designing.\n4.1\nWhat do expert software designers do?\nWhen learning any skill, it is useful to analyse what the experts do (and why\nthey do things as they do). Studying the experts might (will) not instantly\nturn anyone into a tournament-winning tennis player, or an award-winning\nartist, but it will almost certainly be a good way to improve one\u2019s skills.\nIn their witty little book Software Design Decoded: 66 Ways Experts Think,\nMarian Petre and Andr\u00e9 van der Hoek (2016) provide just such a study of\nsoftware designers. Their book brie\ufb02y illustrates and explains some of the\npractices that expert software designers are observed to employ. Of course\nthis is only half of the story. It isn\u2019t just what an expert does that matters, it\nis what they don\u2019t do that may be just as important. (And particularly, the\nsort of things that novices will probably do, and that experts will avoid!)\n43\n", "page": 60, "type": "text", "section": "Page 60"}
{"text": "44\nSoftware Design: Creating Solutions for Ill-Structured Problems\nSo it is worth considering here something of what is known about expert\nsoftware designers, not least because it reinforces some of the issues described\nin the preceding chapters. It also recognises that designing software is a social\nprocess as well as a technical one (Shapiro 1997). What follows is by no means\neverything that is known about expert designers, but we identify some sig-\nni\ufb01cant studies (many of which have been conducted by psychologists rather\nthan software engineers) and extract some of the key concepts and terms that\nemerged from these.\nOne of the earliest studies of how people set about the task of designing\nsoftware was undertaken by Adelson & Soloway (1985). They observed how\nboth experienced and inexperienced designers set about the task of designing\nsolutions when the problem set before them was:\n\u2022 familiar to the participant; or\n\u2022 unfamiliar in detail, but set in a context/domain that was familiar to\nthe participant; or\n\u2022 unfamiliar in both senses.\nThey had a small number of participants, and in many ways what they termed\n\u2018experiments\u2019 might be better categorised as \u2018controlled observational studies\u2019.\nHowever, some key observations that were produced from this work are ones\nthat have also been noted in later studies of the ways that designers work,\nand those related to expert behaviour are summarised in Table 4.1.\nTABLE 4.1: Key \ufb01ndings from the study by Adelson & Soloway\nObserved Behaviour\nPurpose\nThe designer forms an abstract mental\nmodel for their design.\n\u2018Mental\nexecution\u2019\nof\nthe\n\u2018design\nmodel\u2019 assists the designer with sim-\nulating the dynamic behaviour of the\neventual system.\nThe model is systematically expanded,\nkeeping all elements of the design at the\nsame level of detail.\nAssists with the task of simulation,\nwhich itself becomes more detailed as\nthe design model evolves.\nConstraints on the problem/solution\nare made as explicit as possible.\nBounds the \u2018decision space\u2019 when ad-\ndressing an unfamiliar problem.\nReuse of previous design plans. (\u2018La-\nbels for plans\u2019)\nOccurs when the designer recognises\nthat part of the design task can make\nuse of a previous solution or part-\nsolution. This is then \u2018labelled\u2019 (as a\nplan for how this will be resolved in the\nfuture) and the designer moves on to\nfocus on less familiar aspects.\nMaking of notes about future inten-\ntions.\nAiding systematic expansion of the de-\nsign model.\n", "page": 61, "type": "text", "section": "Page 61"}
{"text": "Design Knowledge\n45\nSimulating the \u2018execution\u2019 of a design model in one\u2019s head is a concept\nfamiliar to programmers, who often mentally trace through the execution of\ncode as a check on the formulation of such constructs as conditional expres-\nsions. Arguably this is something that is particular to designing software\u2014\nwhereas such activities as note-making and reuse are design activities widely\nobserved in other domains too. As we will see later, the idea of \u2018labelling\u2019\npreviously used plans is one that also resonates with the idea of the design\npattern, described in Chapter 15.\nAn observational study by Bill Curtis and his co-workers examined the\ncharacteristics of a set of designers who had been identi\ufb01ed by their organi-\nsations as being particularly successful (Curtis, Krasner & Iscoe 1988). They\nobserved that the number of exceptional designers identi\ufb01ed in this way was\nsmall\u2014and hence they were usually treated as an important resource within\nan organisation. Interestingly though, the outstanding designers were often\nnot considered to possess particularly good programming skills, suggesting\nthat programming and design may call upon di\ufb00erent abilities in an individ-\nual. Table 4.2 summarises three key \ufb01ndings from this study.\nTABLE 4.2: Key \ufb01ndings from the study by Curtis et al.\nObserved Behaviour\nPurpose\nFamiliarity with the application do-\nmain.\nMaking it possible to map between prob-\nlem characteristics and solution structures\nwith ease.\nSkill in communicating technical vi-\nsion to other project members.\nMuch of the design work was often accom-\nplished while interacting with others.\nIdenti\ufb01cation with project perfor-\nmance.\nAchievement of technical progress\u2014the de-\nsigner might even take on signi\ufb01cant man-\nagement responsibilities to ensure this.\nIn studying the ways that designers make decisions, Visser & Hoc (1990)\nused the term opportunistic to describe the way that an expert designer would\nrevise their strategy for \u2018solving\u2019 a design problem. When working opportunis-\ntically, although a designer may have chosen a strategy for how they are going\nto develop their design ideas such as \u2018top-down\u2019 (systematically decomposing\nthe solution elements into smaller actions), they may still deviate from the\nstrategy to either:\n\u2022 postpone a decision, perhaps because the information needed to make\nthis has not yet been resolved; or\n\u2022 process information that is readily at hand, and can be used to de\ufb01ne\ndesign elements in anticipation of the way that the design will evolve.\nThe term \u2018opportunistic\u2019 was originally introduced by Hayes-Roth & Hayes-\nRoth (1979) in the context of planning (an activity which can be considered\nas a form of design, as we noted earlier). It stems from the ill-structured\n", "page": 62, "type": "text", "section": "Page 62"}
{"text": "46\nSoftware Design: Creating Solutions for Ill-Structured Problems\nSkill in communicating technical vision\naspects of design , in that, as a solution to a problem (i.e. a design model)\nemerges, and creates a correspondingly better understanding of the problem,\nthis improved knowledge may well lead the designer to modify their strategy\nfor solving the problem. So this can also be considered as a form of feed-back\nmechanism that occurs during the design process.\nWhat else drives such opportunistic behaviour? Well, Akin (1990) has sug-\ngested that there are three \u2018classic\u2019 actions that occur during creative activities\nsuch as design. These are:\n1. The recognition step, sometimes termed as the \u2018Aha!\u2019 response. This\narises when the designer recognises a solution that has been there all\nalong. As a creative act, it typically occurs when a designer realises that\nthere is a simpler way of doing something than the model that they have\nbeen employing.\n2. The problem restructuring step, in which a change in the way that a\nproblem or design solution is being described or modelled leads to a\nmajor advance towards \ufb01nding a design solution. In many ways this is\nsimilar to the idea of refactoring that we will discuss later in the con-\ntext of agile design. As a simple example, a designer might be planning\nto store some of the key information for an application in a relational\ndatabase, but then realises that managing the information within a set\nof objects will greatly simplify all of the associated operations.\n3. The development of procedural knowledge about how a particular type of\nproblem is best addressed, allowing the designer to perform many cre-\native acts within a domain. One way that this is manifested in software\nengineering is through the use of patterns to provide reusable solution\nmodels.\n", "page": 63, "type": "text", "section": "Page 63"}
{"text": "Design Knowledge\n47\nAll three actions involve recognising that a di\ufb00erent (and better) way to ad-\ndress the current problem can be achieved by changing the way that it is\nviewed or modelled. All are related to the concept of \u2018design as adaptation\u2019,\ndrawing upon the experiences of the designer as well as of others.\nAn observational mode of study was also employed for the project \u2018Study-\ning Professional Software Designers\u2019, which is summarised in the book Soft-\nware Designers in Action (van der Hoek & Petre 2014). Three video recordings\nof pairs of software designers who all addressed the same design task provided\nthe basis for a number of di\ufb00erent analyses, using a range of perspectives. This\nstudy also provided some of the underpinnings for the later book by Petre &\nvan der Hoek (2016) that was mentioned at the beginning of this section.\nIt is useful here to look at three of the 66 characteristics of \u2018expertness\u2019\nidenti\ufb01ed in the latter, where these identify some characteristics that have\nonly partly emerged so far, and that are very important to the later mate-\nrial covered in this book. They are also ones where expert behaviour may\nparticularly be likely to di\ufb00er from the behaviour of inexperienced designers.\nEach characteristic has been highlighted by placing it in a box, a format that\nwe will also use in later chapters. The numbers identify their position in the\n66 characteristics. (The discussions provided here are formulated in a rather\ndi\ufb00erent way to those provided in their book, although they contain the same\nessential messages.)\nExperts prefer simple solutions. PvdH #1\nExperts prefer simple solutions\nGiven a choice between doing something in a simple way and doing it in\na more complicated way, the expert will almost always choose the former. In\ncontrast, an inexperienced designer is more likely to choose a solution that\ninvolves bells & whistles and incorporates features that \u2018may be useful in the\n", "page": 64, "type": "text", "section": "Page 64"}
{"text": "48\nSoftware Design: Creating Solutions for Ill-Structured Problems\nfuture\u2019, even though (or perhaps because) their vision of what that future may\nbe is less clear than that of the expert.\nExperts externalise their thoughts. PvdH #24\nWhat this really means is that experts sketch\u2014on paper, whiteboards or\nany other readily available surface (paper napkins, backs of envelopes etc.).\nWhile the sketches may well be simple \u2018box and line\u2019 diagrams, sketching can\nalso involve making lists, drawing tables, or a mix of the three. Externalising\ntheir ideas in this way helps the expert think them through (including use of\n\u2018mental execution\u2019 at a relatively abstract level), and adapt them. Inexperi-\nenced designers appear to be more reluctant to explore di\ufb00erent ideas once\nthey have a design model that they think looks feasible.\nExperts externalise their thoughts\nExperts invent notations. PvdH #28\nThis partly relates to the previous item. Essentially, what this says is that\nexperts are not constrained to using particular notations. Part of this book\nis about the variety of notations used to describe software models, and about\ntheir syntax and semantics. However, while these may be (and are) useful\nfor documenting and sharing design models, they are not always so useful\nfor developing them, and over-attention to syntax may constrain thinking.\nDesign sketches can take all sorts of forms (and do so) and the less experienced\ndesigner should not feel bound to keep too closely to the syntax of established\nnotations, even when following a plan-based design strategy.\nIn the rest of this chapter we brie\ufb02y look at the sort of experiences and\nmechanisms that help build up design expertise. One thing that this book\nde\ufb01nitely can\u2019t do is teach anyone how to be a great designer. That only\n", "page": 65, "type": "text", "section": "Page 65"}
{"text": "Design Knowledge\n49\ncomes from experience together with understanding. And so one thing that\nthis book can do is to help the reader to acquire a deeper understanding of\nthe processes involved in software design. First though, we consider a bit more\nfully just what the factors might be that determine how \u2018good\u2019 we consider a\nparticular design model to be.\n4.2\nSome software design principles\nWhen considering the design choices involved in developing a design model\nfor a software application, what are the desirable characteristics that might\nmake us consider a particular design model as being \u2018good\u2019?\nMost of us will readily accept that the software used for controlling an\naircraft needs to be carefully designed and rigorously tested\u2014particularly if\nwe think that we might be a passenger on that aircraft one day. Yet good\ndesign matters for smaller and less obviously safety-critical things too, not\nleast because the end-users expect e\ufb03ciency (whatever that means) and relia-\nbility. We expect our software tools to behave reliably and consistently\u2014if our\nbank\u2019s software systems lose an on-line transaction involving a payment into\nour account, it may not be life-threatening, but it can still signi\ufb01cantly disrupt\nour lives. The associated non-functional properties are often referred to as the\n\u2018ilities\u2019, and form yet another perspective upon the complex process of ad-\ndressing ISPs. And they can be much harder to assess from the design model\nthan functionality itself (since we can assess this by use of mental execution\nof the model).\nOne way of trying to ensure that our design model will be reliable, consis-\ntent, robust, and maintainable, is to be guided by some of the basic principles\nthat have emerged over the years. Although conformance to these cannot en-\nsure that we have a sound design model, non-conformance will almost certainly\nmean that we don\u2019t have one! We outline some important ones below and will\nreturn to them at various points in the following chapters. All of them relate\nto the characteristics of the \u2018design model\u2019 itself.\n4.2.1\nFitness for purpose\nThis should be considered as the \u2018ultimate\u2019 requirement for any design\nmodel\u2014and as a principle, it is one that comes close to providing the ultimate\ntest for an ISP. However elegant or e\ufb03cient a design model may be, the two\nbasic needs are that the eventual system should work reliably, and that it\nshould perform the required task. That is not to say that other factors are\nnot important, but simply that they are subordinate to the need to create a\nsoftware application that does the job required of it.\n", "page": 66, "type": "text", "section": "Page 66"}
{"text": "50\nSoftware Design: Creating Solutions for Ill-Structured Problems\nNeedless to say, this is an easier goal to specify than to achieve. The nature\nof ISPs makes it di\ufb03cult to obtain a de\ufb01nitive speci\ufb01cation of purpose or a\ntest that demonstrates that it is achieved. However, what this principle really\nmeans is that the designer should not get diverted into providing unnecessary\n\u2018bells and whistles\u2019 and should focus upon the essence of what a piece of\nsoftware should do. (Remember too that \u201cexperts prefer simple solutions\u201d.)\nThe wonderful pliability of software makes it easy to add features that are not\nreally necessary, and the temptation to do so needs to be avoided. So, what\nthis principle gives us is a \u2018litmus test\u2019 for assessing a design model, in that we\ncan look at each of its features and structures and ask if it is really essential\nand what it contributes to this principle.\nIf we ask why this should be so, the answer is very simple. Anything\nadditional to what is needed for the core purpose of the software adds potential\ntechnical debt by incurring unnecessary complexity.\n4.2.2\nSeparation of concerns\nMost of us are familiar with the concept of the Swiss Army Knife as a\ntool that can be used to do many things (almost unlimited things if we have\na really grand model). However, although a single knife can be used to do\nmany things, each component of the knife has been designed to do one thing,\nwhether it be cutting, \ufb01ling, sawing etc. And this principle of having each\nelement \u201cdo one thing and do it well\u201d also applies to the design of software.\nWhat this means for software is that a design model should clearly sepa-\nrate di\ufb00erent elements. Input, output, data storage, handling user interaction\netc. are all quite distinct tasks. And this is where the \ufb02exibility and pliability\nof software (Brooks 1987) can tempt the designer to cut corners and com-\nbine di\ufb00erent things in the elements of the model. When writing software in\nthis way, we refer to the end result as \u201cspaghetti code\u201d, implying complexity\n(rather than edibility) and hence longer-term problems of technical debt, to\nsay nothing of shorter-term problems with testing. The same issues are true\nfor design\u2014clear separation of concerns can greatly assist with later changes\nand updates to an application, as well as making for more modular testing.\nSeparation of concerns\n", "page": 67, "type": "text", "section": "Page 67"}
{"text": "Design Knowledge\n51\nSeparation of concerns in the CCC\nIn the context of the CCC we can identify some obvious \u2018concerns\u2019\nthat should be treated as distinct elements. These include the following\n(note that the list is not meant to be exhaustive).\n\u2022 knowledge about the cars\n\u2022 knowledge about bookings\n\u2022 customer interaction\n\u2022 billing for car usage\n\u2022 \ufb01nding available cars that are within a given area\nThese all interact to provide the overall functionality, but represent\nquite di\ufb00erent facets of the design model.\n4.2.3\nMinimum coupling\nWhen constructing anything but the smallest software applications, we\nneed to adopt some form of modularity for its organisation, whether the mod-\nules concerned are methods (sub-programs), classes, processes or some other\nform. Indeed, the choice of these may well relate to the previous principle\nregarding the separation of concerns. And since these modules are part of\nthe whole, they need to interact and share information in some manner. This\ninter-module dependency is usually termed coupling, a concept that was \ufb01rst\nrecognised in the early 1970s when the modules concerned were most likely to\nbe sub-programs (Stevens, Myers & Constantine 1974). And as new forms of\nmodular structure for software have emerged, it is one that has continued to\nbe relevant.\nCoupling can take a range of forms. For example, module A may make use\nof operations, data or data types that are provided by module B. And it can\noccur in di\ufb00erent ways too. Module A may invoke methods in Module B, or\nobtain values of variables it contains, or even inherit properties from it. The\npresence of any of these forms will create a dependency of A upon B, and\nwhat it particularly means is that if any changes are made to module B, they\nmay potentially a\ufb00ect module A. Some coupling is of course necessary for the\nconstruction of any software system\u2014the point is that this should be as much\nas is needed and no more\u2014since unnecessary coupling can add to technical\ndebt, complicating future evolution of an application.\nExcessive or unnecessary coupling may well indicate a poor choice of mod-\nular structure. If the concerns are well separated, the dependency of a module\nupon other modules should be minimal, and in particular, should not involve\nrequiring knowledge about how the other modules perform their tasks.\n", "page": 68, "type": "text", "section": "Page 68"}
{"text": "52\nSoftware Design: Creating Solutions for Ill-Structured Problems\n4.2.4\nMaximum cohesion\nThe concept of cohesion is concerned with intra-module relationships. The\nissue here is that the elements grouped within a module should all share the\ncharacteristic of being related to the purpose of the module. For example, if\nwe have a class that consists of a data structure representing some part of an\napplication, all of the other elements of the class should be concerned with\nupdating and reporting on that data structure. Cohesion is conceptually fairly\nstraightforward, but can be quite di\ufb03cult to assess.\n4.2.5\nInformation hiding\nThis principle is also related to the way that modularity is achieved within\nan application, but incorporates additional notions about how information\nshould be organised and stored within an application. It is particularly rele-\nvant to thinking about objects and in this context it is often referred to as\nencapsulation.\nThe basic concept is concerned with knowledge about the detailed form\nin which data is represented and stored. The aim is to keep this knowledge\nlocal to a module, so that it is not visible outside of a particular module\n(Parnas 1972, Parnas 1979). Like cohesion it is concerned with intra-module\nproperties, and its use requires that a module should provide a number of\nmethods that can be used to access the data, where these are used to \u2018hide\u2019\nthe way that the data is organised internally. Again, the motivation for this\nis to enable and simplify subsequent changes to an application.\nInformation hiding in the CCC\nThere are several items of information employed in the CCC software\nthat should clearly be encapsulated (hidden) so that they cannot be\ndirectly modi\ufb01ed or accessed by other objects. These include:\n\u2022 details that describe the full status of a speci\ufb01c car\u2014not just\navailability but also such things as distance covered, its current\nposition etc.;\n\u2022 the way in which information about the set of cars is organised,\nso that objects using this just refer to a particular car without\nknowing how that information is organised internally;\n\u2022 information relating to customer accounts.\n", "page": 69, "type": "text", "section": "Page 69"}
{"text": "Design Knowledge\n53\n4.3\nThe evolution of design ideas\nGiven that we have some ideas about the characteristics of an e\ufb00ective\nand even great designer, together with some ideas about what they are trying\nto achieve, this then raises the question of what knowledge does a software\ndesigner need to acquire?\nLong before software was thought of, people probably began learning their\ndesign skills primarily through some form of \u2018apprenticeship\u2019, and many would\nthen continue to learn from sharing their experiences with their peers. There\nis still quite a strong element of this in many creative disciplines, and indeed,\nthe concept of the \u2018design studio\u2019 has been successfully adapted for teaching\nabout software development (Tomayko 1996).\nWe can reasonably assume that the craftsmen who designed the pyra-\nmids of Egypt and those who created Europe\u2019s medieval cathedrals, will have\nexchanged ideas with, and learned from, their peers. However, each resulting\nbuilding was a single unique creation, and while new ideas did emerge, such as\nthe use of ribbed vaulting or \ufb02ying buttresses, these were more likely to relate\nto the design product rather than to the process of learning about designing.\nIt was only with the emergence of what we would now consider as engineering\npractices that new contributions to the way that people learn about designing\nreally began to occur. Two of these are worth noting here as being particularly\nrelevant to software design.\n1. Knowledge gained from scienti\ufb01c research. As the properties of materials\nbecame better understood, and the means of predicting their behaviour\nbecame more re\ufb01ned and dependable, so designers could utilise such\nknowledge to help create new structures. It is interesting to note that\nin a period when the distinctions between the professions were less rigid\n(and probably not even recognised) Sir Christopher Wren, the designer\nof some of London\u2019s most iconic churches, including St Paul\u2019s Cathedral,\nbegan his career as an astronomer and was regarded as an outstanding\nmathematician and geometer.\n2. The concept of reuse. While ideas were certainly reused before the indus-\ntrial revolution, the idea of fabricating structures by using \u2018standardised\u2019\ncomponents was not. The availability of reusable components both ex-\ntends and constrains a designer\u2019s repertoire. Their use may reduce the\ndesign task as well as o\ufb00ering speedier development and time to market\nand reducing costs\u2014while at the same time introducing new trade-o\ufb00s\ninto the design process. In particular, the opportunity to reuse things\nraises the question as to when it would be better to \u2018buy-in\u2019 existing\nelements and adapt one\u2019s design around these, which introduces a de-\npendency upon a supplier, or to adopt a policy of \u2018build-your-own\u2019?\nThere is also the related question of how to document and catalogue\n", "page": 70, "type": "text", "section": "Page 70"}
{"text": "54\nSoftware Design: Creating Solutions for Ill-Structured Problems\ncomponents. Two of the greatest designers of the past maintained records\nin the form of \u2018sketchbooks\u2019 (Leonardo da Vinci) and the engineer\u2019s\n\u2018commonplace book\u2019 (Isambard Kingdom Brunel). These both formed\nan aid to their own thinking and also provided a \u2018pattern book\u2019 that\ncould help convey their ideas to others.\nBoth scienti\ufb01c knowledge and reuse have had an in\ufb02uence upon ideas about\nsoftware design as will emerge in later chapters. In the 1970s and 1980s, it\nwas expected that using the power of mathematics could enhance the process\nof software design, largely by providing rigorous speci\ufb01cation through the use\nof \u2018formal methods\u2019 (Shapiro 1997). We will examine this further later, but\napart from fairly specialised areas such as safety-critical systems, mathemat-\nical forms of modelling have probably had much less impact than expected.\n(However, as we will see in the next chapter, scienti\ufb01c knowledge of a di\ufb00erent\nform is playing an increasing role in software development as a whole. The\ndevelopment of rigorous empirical studies is increasingly providing insight into\ndesign activities.)\nThe concept of reuse has been much more in\ufb02uential and has provided\nsoftware developers with an increasingly large palette of options as well as\na range of forms of reusable components that have in\ufb02uenced design ideas\nand also design products. Concepts related to di\ufb00erent forms of reuse such as\npatterns, software product lines and components have all enriched the design\nprocess itself, playing an important role in \u2018design as adaptation\u2019 alongside a\ndesigner\u2019s own experiences.\nThere are probably many reasons why these two practices have had rather\ndi\ufb00erent degrees of in\ufb02uence on thinking about software design. One possi-\nble reason is that they embody (or at least support) di\ufb00erent philosophies.\nMathematical forms and scienti\ufb01c models (as we have already observed) are\nessentially associated with reductionist thinking, commonly associated with\nWSPs. While that is not wholly incompatible with designing software ap-\nplications, it is likely to be more successful where the requirements for such\napplications are very well understood. They also require an element of formal\nmathematical understanding for their application. On the other hand, reuse\nlends itself to a more compositional way of thinking, in which we build up a\nsolution from parts, and hence is intrinsically more suited for use with ISPs.\nIt certainly \ufb01ts better with the idea of an opportunistic design strategy, as\nused by agile approaches to software development, and as such, is probably\nmuch more widely applicable to software development.\nFinally, a useful concept \ufb01rst posited by Herb Simon is that of satis\ufb01cing.\nThis can be summarised as \u201cseeking a satisfactory solution to a problem rather\nthan the optimal one\u201d (van Vliet & Tang 2016). Satis\ufb01cing is often observed\nas occurring during design activities and forms an important decision-making\nstrategy. It may be employed for a variety of reasons: a designer may have only\nlimited time to work on an issue; there is a lack of information needed to make\nan optimal decision; or the designer is trying to simplify a cognitively complex\nissue. In essence, the use of satis\ufb01cing often involves taking the \ufb01rst solution\n", "page": 71, "type": "text", "section": "Page 71"}
{"text": "Design Knowledge\n55\nthat \u2018\ufb01ts\u2019 a need and can be considered \u2018good enough\u2019. It may involve the use\nof analogy with other software applications to help make a decision, although\nas van Vliet and Tang observe, the risk is that \u201cthe context is di\ufb00erent from\nwhat one is used to\u201d.\n4.4\nThe nature of expert design knowledge\nFrom the material of the preceding sections, we can see that a designer\nclearly needs to acquire quite a lot of rather complex knowledge, both about\nhow to proceed with developing a design, and also about how to model their\nideas. Since much of the content of Parts II and III is concerned with describing\nways of sharing design knowledge and ideas, it is important to understand\nsomething of the challenges such sharing poses, and the associated limitations\nin what can be done.\nIndeed,while the idea of being able to transfer design knowledge from ex-\nperts to less experienced designers is an attractive one, when we look at the\nnature of design knowledge, the reality involved in doing it is rather more\ncomplex. To begin with, an expert designer may well be unable to explain\nwhy they know how to do something. As an example, someone who is an ex-\npert in graphic design may know which typefaces can be most e\ufb00ectively used\nfor a particular type of document, but be unable to provide a rationalised\nargument as to why this combination works well.\nSuch design heuristics or \u2018rules of thumb\u2019 are no less e\ufb00ective or less valid\nfor the lack of an explanation. Indeed the tacit knowledge that underpins them\nmay be based upon such deep and complex cognitive issues that any explana-\ntion will be of limited general usefulness. When studying how people design\nsoftware, Vessey & Conger (1994) observed that \u201cexamining expert problem\nsolving can be quite di\ufb03cult, since experts automate their problem-solving\nprocesses to the point at which they are no longer able to articulate what\nthey are doing\u201d. Unfortunately, without some understanding of why particu-\nlar solution strategies work\u2014one of the characteristics that distinguishes an\nengineering discipline from a craft\u2014a heuristic may be limited in usefulness.\nIn a domain where the problems are relatively repetitive (something that\ncharacterises many crafts), this may not be too critical an issue. However,\nin software development, although there may be common elements between\ndi\ufb00erent applications, the requirements that they address are usually quite\ndistinctive.\nAn obvious, and related, question is how do designers \u2018store\u2019 their ex-\npertise in their brains? While this is really a question for which any se-\nrious answer must fall well beyond the scope of this book, there has\nbeen research that examines how software designers organise their de-\nsign knowledge. Clearly this is not something that can readily be ob-\n", "page": 72, "type": "text", "section": "Page 72"}
{"text": "56\nSoftware Design: Creating Solutions for Ill-Structured Problems\nserved, but in D\u00e9tienne (2002), the author uses the term schema to\ndescribe an important and rather abstract form of design knowledge.\nExperts\ndevelop\nknowledge\nschemas\nThere are di\ufb00erent forms of schema, and\nin this model, programming expertise is\npartly based upon the possession of a set of\nconstructional schemas, which may be fur-\nther reinforced by a set of domain-speci\ufb01c\nschemas that help map and adapt the pro-\ngramming schemas on to certain types of\nproblems. So implicitly, in addressing a de-\nsign problem, an expert may well make use\nof a number of such schemas, where these\naddress di\ufb00erent facets of the problem.\nNot only does the transfer of knowledge\npose a challenge, the quality of much of our\nknowledge about how to design software may\nalso be rather mixed. The concept of shells of\nknowledge proposed by Brooks (1988), pro-\nvides a useful way of categorising the con\ufb01-\ndence that we might be able to place in spe-\nci\ufb01c pieces of design knowledge, using the\nfollowing three classi\ufb01cations.\n1. Findings, or well-established scienti\ufb01c truths, with their value being\nmeasured in forms that correspond to the rigour with which they have\nbeen established. In terms of empirical software engineering concepts,\nthese would most likely correspond to \ufb01ndings from a systematic review\n(Kitchenham, Budgen & Brereton 2015).\n2. Observations, that report on actual phenomena, with their value being\ndetermined by the degree of \u2018interestedness\u2019 that they possess for us.\nAgain, in terms of empirical studies, these would be the outcomes from\na \u2018good\u2019 primary study, whether experimental or observational in nature.\n3. Rules of Thumb, which consist of generalisations that are \u2018signed\u2019 by the\nauthor, but not necessarily supported by data, with their value being\ndetermined by their usefulness. These might well be found in \u2018experi-\nence reports\u2019\u2014lacking empirical rigour, but possibly providing useful, if\ninformal, analysis of experiences.\nAdvances in empirical software engineering have improved our knowledge\nabout many aspects of software engineering in the period since Brooks pro-\nposed this model, and these are reviewed in the next chapter. In a paper by\nle Goues, Jaspan, Ozkaya, Shaw & Stolee (2018) the authors o\ufb00er a more de-\ntailed set of categories for the quality of evidence and discuss how these map\non to this smaller set proposed by Brooks. However, regardless of how we cat-\negorise software engineering knowledge, the quality of much of our knowledge\n", "page": 73, "type": "text", "section": "Page 73"}
{"text": "Design Knowledge\n57\nabout designing software largely falls into the categories of observations and\nrules of thumb.\nSo, given that design knowledge is di\ufb03cult to codify, and its quality is\nmixed, this emphasises why expert knowledge about how to design software\nsystems can be di\ufb03cult to share with others. From the 1970s onwards, various\nmechanisms have been developed to assist with this, starting with plan-driven\ndesign methods, and going on through such ideas as software architecture, ag-\nile methods and design patterns. In essence, these provide ways of translating\nexpert design schemas into some \u2018rules\u2019 that can be used when designing\nsoftware intended to meet speci\ufb01c purposes. While they may be relatively\ncrude, relative to the subtlety of the cognitive knowledge involved, they have\nnonetheless shown themselves to be useful, and we will be looking more closely\nat them in Parts II and III of this book.\nKey take-home points about design knowledge\nThis chapter has examined some of the characteristics of expert software\ndesigners and of the ways that they design software systems.\nExperienced designers use abstract mental models. An important role\nfor these models is to allow the designer to mentally \u2018simulate\u2019 the way\nthat a system will behave in particular conditions. This characteris-\ntic is one that is largely peculiar to software design, since the \u2018prod-\nuct+process\u2019 nature of software forms one of its distinctive features.\nDesigners often work opportunistically. Rather than following some\n\ufb01xed set of procedures to develop their design model (as advocated\nby plan-driven design approaches), experienced designers will employ\na general strategy but adapt it as their understanding of the problem\n(and solution) evolves.\nDesigners sketch their ideas. Design ideas are \ufb02uid and experts like to\nconcentrate on abstractions which can easily be revised to allow ready\nexploration of their models for a solution. Using informal notations to\naid the development of a design model helps with this by avoiding the\nconstraints of a \ufb01xed syntax and semantics.\nDesign principles embody accumulated design experience and provide a set\nof criteria for assessing the quality of a design model.\nDesigners reuse. This may occur at the abstract level, where designers reuse\npart-solutions that they previously found to be successful, and also at\nthe level of reusing actual software components that are known to work\n", "page": 74, "type": "text", "section": "Page 74"}
{"text": "58\nSoftware Design: Creating Solutions for Ill-Structured Problems\nand be trusted, restructuring and adapting their design plans to accom-\nmodate these where appropriate.\nDesign decisions may rely upon satis\ufb01cing\u2014whereby the designer opts to\nuse a \u2018good enough\u2019 solution to a need, rather than expending time and\ne\ufb00ort to try and \ufb01nd an optimum solution.\nIt may be di\ufb03cult to articulate and codify design knowledge. So far,\neverything described in this book emphasises that design cannot be per-\nformed by \u2018following a procedure\u2019. Indeed, successful designers may \ufb01nd\nit di\ufb03cult to explain why they make particular decisions, since their\nexpertise is encapsulated in the form of a set of schemas rather than\nprocedural rules.\n", "page": 75, "type": "text", "section": "Page 75"}
{"text": "Chapter 5\nEmpirical Knowledge about Software\nDesign\n5.1\nMeasuring software development processes ......................\n59\n5.1.1\nMeasuring physical phenomena .........................\n60\n5.1.2\nMeasuring human reactions .............................\n61\n5.2\nEmpirical studies in software engineering .......................\n63\n5.2.1\nThe empirical spectrum .................................\n64\n5.2.2\nThe research protocol\n...................................\n65\n5.2.3\nQualitative studies .......................................\n65\n5.2.4\nQuantitative studies .....................................\n66\n5.2.5\nCase studies\n.............................................\n67\n5.3\nSystematic reviews ...............................................\n69\n5.4\nUsing empirical knowledge .......................................\n71\nKey take-home points about empirical knowledge ...............\n72\nA key characteristic of this book is that wherever possible, when discussing\nissues about software design, the reader is provided with relevant empirical\nevidence to support the discussion. So this chapter provides a brief outline of\nwhat typically constitutes such evidence and how it is acquired.\nWe begin by discussing some issues related to measurement, since this\nunderpins any discussion of empirical studies. We then go on to discuss some-\nthing of these studies, what we mean by evidence in this context, and how it\nmight be used to support software design.\nWhat we will see is that acquiring empirical knowledge about software\ndesign issues can be quite challenging, and may not always lend itself to pro-\nviding detailed guidance to the designer. However, empirical studies can often\nprovide considerable insight into design choices, while also forming a more\nrigorous source of knowledge than \u2018expert opinion\u2019.\n5.1\nMeasuring software development processes\nEmpirical knowledge is usually based upon the use of some form of mea-\nsurement. So, before discussing the forms of empirical study and the types of\n59\n", "page": 76, "type": "text", "section": "Page 76"}
{"text": "60\nSoftware Design: Creating Solutions for Ill-Structured Problems\nknowledge that they can provide, it is important to understand the forms of\nmeasure commonly used in empirical studies.\nMany of our ideas about what constitutes \u2018measurement\u2019 stem from dis-\nciplines such as physics that involve measuring the properties of real-world\nphenomena. An important feature of subjects such as physics (as well as most\nother sciences and technologies) is that they are founded upon a positivist phi-\nlosophy, embodying the assumption that there are general rules that apply to\nthe phenomena being studied. In the physical world that philosophy is com-\nmonly manifested in such assumptions as \u201call electrons have the same mass\nand charge\u201d1. A further assumption is that the \u2018observer\u2019 who is performing\nthe measurements has no in\ufb02uence upon the values obtained.\nBoth of these assumptions present a challenge when we seek to study\nhuman-centric activities such as designing software. For practical purposes we\nhave to adopt a positivist philosophy, while accepting that this is probably\nsomething of an approximation given that people have di\ufb00erent abilities. And\nwhen designing our studies, we have to plan them so as to minimise the extent\nto which bias can arise from the involvement of the observer, particularly\nwhere any observations may involve an element of interpretation.\n5.1.1\nMeasuring physical phenomena\nIn the physics laboratory, a desirable form of experiment is one where the\nobserver has as little to do with the measurement process as possible. If the\nmeasurement can be performed by instruments that (say) count the number\nof electrons hitting a \u2018target\u2019, then although measurement errors cannot be\nwholly eliminated, they can usually be kept to a very low level.\nOften however, it isn\u2019t possible to avoid having the involvement of an\nobserver when making measurements. For example, analysing traces that show\nhow much a beam of electrons is de\ufb02ected by a magnetic \ufb01eld. For this, some\nerrors are likely to occur because the observer didn\u2019t have their head in quite\nthe right position to read the relevant point on the scale, or simply made a\nsmall error in identifying or recording what the value should be.\nScientists are accustomed to this form of error and its properties. For one\nthing it is expected that over a large number of measurements there will\nbe roughly as many \u2018over-measures\u2019 as \u2018under-measures\u2019, and that errors of\nthis type will have a normal distribution, based on the well-known bell-shaped\ncurve. Experimenters will be expected to make an assessment of the magnitude\nof such errors and to report them. While this will represent a (usually small)\ndegree of uncertainty about the measured value, the important thing is that\nthis uncertainty essentially stems from the limitations of the measurement\ninstruments. Taken together with the original assumption that there is a single\n1The opposite philosophy is termed an interpretivist one. Interpretivists view each mea-\nsurement as being unique, so that it can only be understood in terms of its speci\ufb01c context.\nWhile this perspective is one that is adopted by many social scientists, research into software\nengineering practices usually adopts a positivist approach.\n", "page": 77, "type": "text", "section": "Page 77"}
{"text": "Empirical Knowledge about Software Design\n61\n\u2018right\u2019 value, the expectation will be that any variation that we see in the\nmeasured values can be attributed to the way they were obtained.\n5.1.2\nMeasuring human reactions\nHumans (a category generally accepted as including software developers)\nintroduce a whole new element of complexity when we seek to make measure-\nments related to the consequences arising from their actions.\nHuman-centric studies take many forms, as we will see in the next section.\nUsually they involve studying the e\ufb00ects arising from introducing some form\nof treatment or intervention to some situation. This requires the collection\nof measurements for one or more dependent variables in order to assess the\ne\ufb00ects. To explain about the issue of measurement, we focus on two major\ncategories of treatment.\n\u2022 The \ufb01rst is those studies where the human participant is a recipient\nof the experimental treatment. An important form used for these is\nthe Randomised Controlled Trial (RCT), as used in many branches of\nmedical research. An RCT can be used to make comparison between\nthe e\ufb00ects arising from the application of some form of experimental\ntreatment and what happens when no treatment (or possibly, another\ntreatment) is applied. An RCT uses two groups of human participants.\nOne is the experimental group, whose members receive the treatment\nbeing investigated, in whatever form this might be administered, such\nas the use of tablets. The second is the control group whose members\nreceive what appears to be the same treatment, but where this either\nemploys some form of harmless placebo or consists of using an existing\ntreatment for comparison.\nAn RCT compares the e\ufb00ects experienced by two groups\nThe key issue here is that the experimenters expect to observe con-\nsiderable variation when measuring the reactions of the participants in\n", "page": 78, "type": "text", "section": "Page 78"}
{"text": "62\nSoftware Design: Creating Solutions for Ill-Structured Problems\nthe two groups. This is because humans are complex and di\ufb00erent and\nwhile everyone in the trial will have been selected because they have\nsome condition that could potentially be a\ufb00ected by the treatment, this\nmay occur in di\ufb00erent degrees, and they may also have other conditions,\npossibly unknown, that could a\ufb00ect the outcomes.\nSome people in the experimental group may therefore respond well to\nthe treatment, but others less so, or even negatively. As a result the mea-\nsured outcomes will vary between participants, and to a much greater\ndegree than would arise from measurement errors alone.\nSo it can\u2019t be assumed that any measurements across each group will be\nspread in a normal distribution. This makes it necessary to use reason-\nably large groups of participants for such studies, together with statis-\ntical tests to determine whether or not the spread of results arises from\nthe treatment, or could have been produced at random (that is, with\nthe treatment not being the cause of any observed e\ufb00ects).\n\u2022 The second category contains those studies where the treatment involves\nthe participants in performing some form of activity. This is of course\nwhat arises in software development, where the activities may involve\nusing a particular test strategy to debug a block of code, or revising a\ndesign that was produced using a speci\ufb01c technique. The use of RCTs is\nclearly impractical for this type of study, since participants can hardly\nbe unaware of which group they are in. Although experiments and quasi-\nexperiments2 can sometimes be used to make comparisons, it may well\nbe di\ufb03cult to identify a suitable form of activity for the control group.\nSo in order to study such activities we often end up using observational\nforms of study. (The study of designer behaviour by Adelson & Soloway\n(1985) described in Chapter 4 is an example of an observational study.)\nSince everyone taking part in such a study comes along\nwith their own experience and opinions, together with their\nnatural ability, it can be expected that there will again be\nsigni\ufb01cant variation in the values for any outcome measure-\nments of the way that the participants react to the interven-\ntion (or its absence), such as the time to complete a task, or\nthe sort of \u2018solutions\u2019 produced. Again though, measurement\nof what appears to be a relatively simple choice of dependent\nvariable (the time to complete a task) can be confounded by\nthe ill-structured nature of such tasks, since it may well be di\ufb03cult to de\ufb01ne\nexactly what constitutes \u2018completion\u2019.\nWhen we do perform some form of experimental study, we often plot the\nresults using something like the box plot illustrated in Figure 5.1. This shows\n2A quasi-experiment is a form of experiment where some factor cannot be randomised\nacross the participants (Shadish, Cook & Campbell 2002). This form is particularly relevant\nwhere the factor might be something like experience of performing object-oriented design.\n", "page": 79, "type": "text", "section": "Page 79"}
{"text": "Empirical Knowledge about Software Design\n63\nboth the distribution of the results, as well as such aspects as \u2018skew\u2019 (where\nresults are biased to the positive or negative side). And although it appears\nthat, with a few exceptions, most people perform the task more quickly using\nthe experimental tool, the task of determining whether this means that we\nare seeing a real e\ufb00ect or not still has to depend upon a statistical analysis.\nTime in\n(minutes)\nWithout tool\nWith tool\n20\n15\n10\nFour quartiles\nEach containing\n25% of values\nmedian\nFIGURE 5.1: Using a boxplot to summarise the outcomes of a study\nWhy do we need to know about these things in a book about software\ndesign? Well, \ufb01rstly to understand that conducting empirical studies that\ninvestigate design activity are by no means simple to perform. nor are the\nproperties that we are interested in necessarily easy to measure. Secondly, to\nappreciate that the naturally-occurring variations that arise in the measured\nvalues will mean that any \ufb01ndings from such studies are unlikely to be clear-\ncut. That isn\u2019t to say that there won\u2019t be any useful \ufb01ndings, but rather that\nthe \ufb01ndings will be subject to some sort of \u2018con\ufb01dence\u2019 assessment, based\nupon the extent to which those conducting the study can be sure that the\ne\ufb00ects that they have observed stem from the \u2018treatment\u2019 employed in the\nstudy, and not from other confounding factors that are not controlled by the\ninvestigators.\n5.2\nEmpirical studies in software engineering\nWhen software engineering \ufb01rst emerged as a distinct sub-discipline of\ncomputing, empirical knowledge was largely acquired from experiences gained\nduring the creation of software applications \u2018in the \ufb01eld\u2019, and was codi\ufb01ed\n", "page": 80, "type": "text", "section": "Page 80"}
{"text": "64\nSoftware Design: Creating Solutions for Ill-Structured Problems\nby identifying those practices that seemed to work well. This was assisted by\nthe way that many software applications used a limited set of architectural\nforms for their implementation. Writing down guidelines so that others could\nbene\ufb01t from these experiences was therefore unquestionably useful, but such\nexperience reports did lack rigour and might fail to record and report all of\nthe relevant factors.\nThrough the 1990s, there was a growing interest in performing more rig-\norous empirical studies to investigate how software engineers performed a\nrange of tasks. Much of this was concerned with trying to understand how\nthey acquired and used the knowledge needed to underpin their activities\nand decisions. This might seem strange, as the obvious comment is \u201cdidn\u2019t\nthey know that\u201d. However, as noted in the previous chapter, expert decision-\nmaking draws upon many forms of knowledge, much of which may be tacit,\nto the point where an expert cannot explain the exact reasons for making a\nparticular choice.\n5.2.1\nThe empirical spectrum\nEmpirical studies take a wide range of forms. However, for our purpose we\ncan identify two important groups of studies as follows.\n\u2022 Studies of individuals that try to elicit the basis on which an individual\nmakes decisions (that is, why they make them as they do). Primarily\nthese are qualitative studies that involve making detailed observations,\nand are usually conducted with a small number of experts as the partic-\nipants. Analysis of qualitative studies is likely to involve categorisation,\nnarrative reporting, and interpretation of what the participants say. Such\nstudies are also likely to be \ufb01eld studies in which any observations are\nmade in the workplace when the participants are working normally.\n\u2022 Comparisons between groups of participants where the members of a\ngroup have (preferably) similar levels of expertise, possibly for the pur-\npose of comparing expert and novice behaviours. Often these are quan-\ntitative studies, drawing upon the positivist assumption that many in-\ndividuals will behave in a similar manner when faced with a particular\nproblem. Data collection will involve some form of counting and analysis\nis likely to employ statistical techniques. Quantitative studies are likely\nto be more concerned with what is done than with why it is done. Such\nstudies are more likely to take place in the laboratory, where conditions\ncan be controlled. However, this does introduce an arti\ufb01cial element to\nthe context, and usually limits the duration of a study.\nEmpirical software engineering draws upon various other disciplines for its\nresearch practices, adapting them as necessary (Kitchenham et al. 2015). In\nthis section, we focus upon those characteristics that will help us understand\nwhat the outcomes from di\ufb00erent studies might mean.\n", "page": 81, "type": "text", "section": "Page 81"}
{"text": "Empirical Knowledge about Software Design\n65\n5.2.2\nThe research protocol\nEmpirical studies in software engineering are commonly human-centric,\nstudying how software developers undertake the various activities involved in\ncreating and updating software systems. An important role in this type of\nstudy is that of the observer, who is often called upon to make interpretations\nof what they observe, not least because participants do not always behave\nquite as anticipated.\nOne of the hazards of such interpretations is that, since the observer will\nbe aware of what the study is investigating, they may be unconsciously biased\nor in\ufb02uenced by this when making their interpretations. To help avoid, or at\nleast reduce, the degree of any resulting bias, it is common practice to develop\na comprehensive plan for conducting and analysing an empirical study, which\nis known as the research protocol.\nThe research protocol may well be quite a substantial and detailed docu-\nment, but inevitably it may still not anticipate every situation. For example,\nwhen faced with a particular choice as part of a study, the protocol might\nexpect that participants will usually make one of three fairly obvious choices,\nand so the task of the analyst will be to determine how to categorise each\nparticipant\u2019s actions against these. However, when the study is performed, it\nmay well be that a small number of participants make another, and signi\ufb01-\ncantly di\ufb00erent, choice. In that case, the research team may agree to create\na fourth category for purposes of analysis, and this decision is then recorded\nand reported as a deviation from the protocol. Deviations may occur for all\nsorts of reasons, including errors that the experimenters make in conduct-\ning the study, but may also occur as a result of encountering unanticipated\nparticipant actions.\nSo the purpose of the research protocol is to help ensure that the study is\nconducted rigorously, and that in analysing the results, the experimenters do\nnot \u2018\ufb01sh\u2019 for interesting results.\n5.2.3\nQualitative studies\nQualitative studies are apt to be observational in their nature and concen-\ntrate upon gaining insight into the reasoning that lies behind the activities of\nan individual designer. Here we provide two examples of the ways that such\nstudies might be conducted (they are by no means the only ones).\n\u2022 Interviews. One way of \ufb01nding out what designers think about what they\ndo (and why they do it that way) is to talk with them. An interview lets\nthe researcher probe into issues that look promising, but equally it needs\nto be kept under control. A commonly-used procedure for organising\nthis is the semi-structured interview, in which the interviewer has a set\nof questions developed in advance, but can deviate from these to pursue\nissues that arise, as and when necessary.\n", "page": 82, "type": "text", "section": "Page 82"}
{"text": "66\nSoftware Design: Creating Solutions for Ill-Structured Problems\n\u2022 Think-aloud. This is really one element in the technique known as Proto-\ncol Analysis developed for knowledge elicitation in psychological studies\n(Ericsson & Simon 1993). It involves asking the participant to under-\ntake some task and to describe their thinking verbally as they perform it\n(think-aloud). A transcript of their verbal \u2018utterances\u2019 is then analysed,\nthose utterances that are not directly relevant to the task are discarded,\nand a model is developed around the others. In practice, think-aloud is\nby no means easy to perform (among other problems, participants tend\nto \u2018dry up\u2019 when they are concentrating), but it can provide valuable\ninsight into the basis for their actions, including identifying where this\ninvolves the use of tacit knowledge (Owen, Budgen & Brereton 2006).\nA challenge when conducting qualitative studies is to be able to analyse the\noutcomes in as rigorous and unbiased a manner as possible, particularly since\nan element of human interpretation is usually required. To help reduce the risk\nof bias, good practice involves using more than one person to analyse the data,\nwith the analysts working independently and then checking for consistency of\ninterpretation between them. And of course, the analysis should be planned\nin advance as part of the research protocol.\nWe will examine a number of outcomes derived from such studies as we\nprogress through the following chapters, and some of the studies described in\nthe previous chapter such as (Curtis et al. 1988) employed qualitative forms.\nQualitative studies tend to use ordinal or \u2018ranking\u2019 forms of measurement\nscale. So, when making measurements, the observer (or participants) will typ-\nically rank (say) issues or preferences in terms of their perceived importance,\nwith no sense that the elements are equally spaced.\n5.2.4\nQuantitative studies\nBecause quantitative studies are more likely to be laboratory-based and\nuse statistical techniques for analysis, they usually need larger numbers of\nparticipants than qualitative studies, in order to provide an appropriate level\nof con\ufb01dence in the results. Two of the more widely-used tools of quantitative\nstudies are experiments (and quasi-experiments), and surveys.\n\u2022 Experiments and quasi-experiments take a range of forms, but are usually\ncomparative in form. The purpose is to test a hypothesis and to establish\nwhere this is true or not. More precisely, the aim is to establish whether\nthe hypothesis or the alternate hypothesis is true. For example, a hy-\npothesis to be tested might be that design models created by using the\nobserver design pattern (described in Chapter 15) will produce larger\nclasses than those that do not use patterns. The alternate (or null) hy-\npothesis will then be that there will be no di\ufb00erences in terms of the\nsizes of class involved.\nExperiments are similar to RCTs, but less rigorous, because the partic-\nipants cannot be blinded about their role. Most experiments performed\n", "page": 83, "type": "text", "section": "Page 83"}
{"text": "Empirical Knowledge about Software Design\n67\non software engineering topics are actually quasi-experiments. This is\nbecause participants can rarely be randomly assigned to groups, as this\nis often done on the basis of experience (Sj\u00f8berg, Hannay, Hansen, Kam-\npenes, Karahasanovic, Liborg & Rekdal 2005).\nAs an example, an experiment may be used to investigate whether inex-\nperienced developers can make speci\ufb01c modi\ufb01cations to code more easily\nwhen the code has been structured using a particular design pattern. To\nreduce any bias that might arise from the choice of the experimental\nmaterial, each participant may be asked to make changes to several dif-\nferent pieces of code, although this then complicates the analysis!\n\u2022 Surveys provide what may be a more familiar tool. However, it can be\ndi\ufb03cult to recruit enough participants who have relevant expertise. For\nexample, if a survey seeks to ask participants who have appropriate\nexpertise with object-oriented design to rank a set of di\ufb00erent object\ninheritance notations, then recruiting a su\ufb03ciently large set of partic-\nipants who have the time and inclination to do this will be di\ufb03cult,\nas will determining just what comprises \u2018su\ufb03cient expertise\u2019. As a re-\nsult, the design and conduct of a survey can be just as challenging as\ndesigning an experiment (Fink 2003, Zhang & Budgen 2013).\nAs indicated in the previous section,\nthere are many factors that may in\ufb02uence\nindividual choices and decisions, and when\nstudying software design, one limitation with\nusing quantitative forms is that they provide\nlittle explanation of why particular decisions\nare made. Their positivist nature also as-\nsumes that a degree of commonality in rea-\nsoning lies behind the particular decisions\nmade by the participants, which in many\nways con\ufb02icts with the whole ethos of de-\nsigning something being considered as an exercise in individual skill.\nQuantitative studies usually employ \u2018counting\u2019 forms of measurement scale\n(ratio measurements). In the example of a survey given above, this might\ninvolve counting how many times each notation appeared as the top choice\nfor a participant.\n5.2.5\nCase studies\nIn recent years, the case study, long regarded as a major research tool\nfor the social sciences, has become more widely used in software engineer-\ning (Runeson, H\u00f6st, Rainer & Regnell 2012, Budgen, Brereton, Williams &\nDrummond 2018).\nHowever, the term is sometimes used by authors in a\nrather informal way, so some care is needed to determine the degree of rigour\ninvolved in an individual case study.\n", "page": 84, "type": "text", "section": "Page 84"}
{"text": "68\nSoftware Design: Creating Solutions for Ill-Structured Problems\nA case study can be viewed as a structured form of observational study.\nWhen conducting an experiment the researcher aims to get many repeated\nmeasures of the same property. For example, the amount of time participants\nneed to complete a design task when using a particular strategy. Since we can\nexpect that this will vary considerably for di\ufb00erent people, we need to mea-\nsure the time for many participants. In contrast, a case study seeks to measure\nmany di\ufb00erent variables related to a particular \u2018case\u2019, which might be a soft-\nware development project, and then to triangulate the knowledge provided\nby the di\ufb00erent measures to see how well they provide mutual reinforcement\nabout some particular characteristic.\nTriangulation aggregates di\ufb00erent measures\nWhile many social scientists consider case studies to be an interpretivist\nform of study, with any \ufb01ndings only applying to that particular case, others\ndo consider that the \ufb01ndings of di\ufb00erent case studies may be combined, so\nproviding a positivist interpretation. Robert K Yin has been a major proponent\nof the positivist approach to case study research, and the use of case studies\nin software engineering has largely been based upon his work (Yin 2014).\nYin suggests that case studies can be particularly useful when addressing\nthree types of research question, as described below.\n\u2022 An explanatory case study is concerned with examining how something\nworks or is performed, and identifying any conditions that determine\nwhy it is successful or otherwise.\n\u2022 A descriptive case study is more concerned with performing a detailed\nobservation of the case and therefore \u201cproviding a rich and detailed\nanalysis of a phenomenon and its context\u201d. Essentially it is concerned\nwith identifying what occurs.\n\u2022 An exploratory case study forms a preliminary investigation of some\ne\ufb00ect, laying the groundwork for a later (fuller) study of some form.\nCase studies can use a mix of qualitative and quantitative data, and both\nexplanatory and descriptive case studies may usefully make use of one or more\npropositions that direct attention to some aspect that should be investigated.\n", "page": 85, "type": "text", "section": "Page 85"}
{"text": "Empirical Knowledge about Software Design\n69\nPropositions can be considered to be a less formal equivalent to the hypothesis\nused to pose the research question for an experiment.\nCase studies are a particularly useful way to conduct \ufb01eld studies that\ninvolve experienced industrial practitioners working in their own environ-\nment, rather that in a laboratory context (as occurs with experiments). Their\nuse overcomes the practical di\ufb03culty involved in having enough practitioners\navailable to perform an experiment, and makes it possible to conduct larger\nscale investigations, often over a relatively long period of time (\u2018longitudi-\nnal\u2019 studies). An analysis of the \u2018primary\u2019 studies used in a set of system-\natic reviews in software engineering over the period 2004-2015, suggests that\nmany of these can be classi\ufb01ed as case studies (Budgen, Brereton, Williams &\nDrummond 2018), although many authors did not give a clear de\ufb01nition for\nexactly what they classi\ufb01ed as being a case study.\n5.3\nSystematic reviews\nA systematic review synthe-\nsises the \ufb01ndings of many pri-\nmary studies\nThe forms of study described so far are\nall examples of what we term primary stud-\nies. Primary studies directly study the issue\nof interest in a particular context. This sec-\ntion examines the use of systematic reviews,\nsometimes termed systematic literature re-\nviews, which are a form of secondary study\nthat seeks to locate all of the \u2018primary stud-\nies\u2019 that are relevant to its research question\nand then aggregates and synthesises their re-\nsults in order to provide a more comprehen-\nsive answer to that question.\nSystematic reviews provide an increas-\ningly important source of knowledge about\nsoftware engineering practices. The concept of the systematic review was orig-\ninally developed in the domain of clinical medicine, where it forms a major\nsource of clinical knowledge for a wide range of healthcare interventions and\nthe basis for what is termed Evidence-Based Medicine (EBM). They have\nsince been adopted and adapted for a whole range of other disciplines, includ-\ning Evidence-Based Software Engineering (EBSE) (Kitchenham et al. 2015).\nThe procedures followed in performing a systematic review are intended\nto reduce the variation in the outcomes and produce \ufb01ndings that are less\nsusceptible to bias than those from individual studies. The \u2018systematic\u2019 aspect\nis especially important when planning and performing such a review (and like\nall empirical studies, a systematic review requires a detailed research protocol).\n", "page": 86, "type": "text", "section": "Page 86"}
{"text": "70\nSoftware Design: Creating Solutions for Ill-Structured Problems\nTwo elements where the systematic aspect plays a major role are in the\nprocess of searching for primary studies, and also when performing the activity\nof inclusion/exclusion that determines which primary studies will be included\nin the review on the basis of their relevance and quality. Performing these tasks\nsystematically helps to overcome one of the problems of \u2018expert reviews\u2019, in\nwhich an expert synthesises the primary studies that they think are relevant\nto a topic (which may well be those that agree with their opinions of course).\nAs might be expected, there are di\ufb00erences between the use of systematic\nreviews in software engineering and their role in clinical studies. The use of\nRCTs for clinical studies, and the role of participants in these as recipients of a\ntreatment, make it possible to use statistical techniques such as meta-analysis\nto synthesise the outcomes of multiple studies. This strengthens the con\ufb01dence\nthat can be placed in the \ufb01ndings of a systematic review. In software engi-\nneering, systematic reviews often have to use rather weaker forms of synthesis\nto combine a range of primary study forms (Budgen, Brereton, Drummond &\nWilliams 2018), making the \ufb01ndings correspondingly less authoritative.\nWhen used in software engineering, systematic reviews can involve synthe-\nsising both quantitative and qualitative forms of primary study. When used\nto synthesise quantitative studies, they may be employed in a role that is\nsomewhat closer to how they are used in clinical medicine, being used to ad-\ndress research questions that are comparative in form (such as \u2018does use of\ntreatment A result in fewer errors per object than the use of treatment B?\u2019).\nWhereas systematic reviews that involve synthesising qualitative studies tend\nto address more open research questions such as \u2018what are the problems en-\ncountered in adopting practice X within a company?\u2019.\nIn clinical medicine, education, and other disciplines that employ system-\natic reviews, these are apt to be commissioned by government departments,\nhealth agencies and the like, to help provide advice about practice and pol-\nicy. However, in software engineering they have so far largely been driven by\nthe interests of researchers. One consequence is that they are less likely to\nprovide \ufb01ndings that are relevant to, and directly usable by, practitioners. A\nstudy seeking reviews with outcomes that were useful for teaching and prac-\ntice found only 49 systematic reviews published up to the end of 2015 that\nhad \u2018usable\u2019 \ufb01ndings, from 276 reviews that were analysed. (Most systematic\nreviews were concerned with analysing research trends rather than practice.)\nHowever, as the use of systematic reviews in software engineering matures, this\nshould begin to change (Budgen, Brereton, Williams & Drummond 2020).\nThe important thing about empirical studies in general, and systematic\nreviews in particular, is that not only can they provide more rigorously derived\nempirical knowledge about software engineering practices, they can also help\nwould-be adopters of these practices to assess how useful the practices may\nbe to them.\n", "page": 87, "type": "text", "section": "Page 87"}
{"text": "Empirical Knowledge about Software Design\n71\n5.4\nUsing empirical knowledge\nEach of the chapters following this one has a short section discussing the\navailable empirical evidence related to the topic of the chapter. (Well, Chapter\n18 doesn\u2019t, but there is a discussion in each section instead!) Most of this\nevidence comes from the \ufb01ndings of systematic reviews.\nWhere a systematic review performed in software engineering provides\n\ufb01ndings that can be used to advise practice, the empirical knowledge derived\nfrom its \ufb01ndings is often presented in one of three forms (or a combination of\nthese).\n1. Knowledge that has been derived from the experiences of others, usually\nin the form of \u2018lessons\u2019 related to what works (or doesn\u2019t) when doing\nsomething. A good example of this is the bene\ufb01ts of reuse in industry\nstudies by Mohagheghi & Conradi (2007).\n2. A list of factors to consider when using some practice (a more structured\nform of experience). Again, a good illustration of this is the study of\npair programming in agile development by Hannay, Dyb\u00e5, Arisholm &\nSj\u00f8berg (2009).\n3. Ranking of knowledge about di\ufb00erent options to help with making\nchoices between them. The study of aspect-oriented programming by\nAli, Babar, Chen & Stol (2010) provides an example of this form of\nknowledge classi\ufb01cation.\nAll three forms are relevant to studies of design, as demonstrated by the\nexamples, although systematic reviews that explicitly address design topics\nare still relatively uncommon. There may be several reasons for this, but one is\ncertainly the shortage of primary studies (Zhang & Budgen 2012). However, it\nis worth noting that many practically-oriented systematic reviews in software\nengineering do tend to make the most of the available material synthesising\nthe \ufb01ndings from a variety of forms of primary study, including case studies.\nAn interesting analysis of the use of evidence in another discipline (man-\nagement research) by Joan van Aken (2004) makes a useful distinction between\nthe ways that research knowledge is used in di\ufb00erent disciplines.\n\u2022 Description-driven research is commonly used in the \u2018explanatory\u2019 sci-\nences, such as the natural sciences, for which the purpose is to \u201cdescribe,\nexplain and possibly predict observable phenomena within its \ufb01eld\u201d.\n\u2022 Design sciences research such as performed in engineering, medical sci-\nence and other health-related disciplines, for which the purpose is to\n\u201cdevelop valid and reliable knowledge to be used in designing solutions\nto problems\u201d.\n", "page": 88, "type": "text", "section": "Page 88"}
{"text": "72\nSoftware Design: Creating Solutions for Ill-Structured Problems\nSo, where does the use of systematic reviews in software engineering research\n\ufb01t into these categories? Well, researchers would probably view their use as\nperforming a form of description-driven research, while practitioners would\nprobably prefer to be provided with \ufb01ndings from design sciences research.\nFor the purpose of this book, it is de\ufb01nitely the latter group that is of interest.\nOf the 276 systematic reviews analysed\nin Budgen et al. (2020), the bulk, described\nearlier as being focused on studying research\ntrends, really \ufb01t into the \ufb01rst category and\ncan be considered as largely description-\ndriven research. The 49 that were considered\nto have \ufb01ndings relevant to teaching and\npractice probably mostly \ufb01t into the second\ncategory of design sciences research, in the\nsense that they provide some guidance for\nproblem-solving. And as new studies emerge\nthere should be a growing corpus of useful\nguidance derived from empirical knowledge.\nKey take-home points about empirical knowledge\nThis chapter has introduced concepts about measurement and empirical\nstudies that are important when seeking to understand the nature and form of\ndesign knowledge that can be obtained through the use of empirical research.\nVariation is to be expected in the measurements that are obtained when\nperforming the sort of human-centric studies used to answer questions\nabout software engineering and its practice. This variation is natural,\nand arises because each participant draws upon individual experience\nand di\ufb00erent levels of expertise when performing the experimental tasks.\nEmpirical studies of software design activities are challenging to per-\nform, and so any \ufb01ndings should be associated with some level of \u2018con-\n\ufb01dence\u2019, based on the procedures followed in conducting the study.\nThe research protocol is an essential element when undertaking a rigorous\nempirical study. The protocol should incorporate plans for performing\nthe study and analysing the results, and should be produced in advance\nof undertaking the study.\nBoth quantitative and qualitative studies have value for research into\nsoftware design issues. They respectively address questions related to\nwhat occurs and why something occurs.\n", "page": 89, "type": "text", "section": "Page 89"}
{"text": "Empirical Knowledge about Software Design\n73\nThe use of systematic reviews can help overcome the e\ufb00ects of bias that\ncan arise in the \ufb01ndings of individual \u2018primary\u2019 studies and hence can\nprovide the most reliable sources of evidence for making design decisions\nor selecting a design strategy. The empirical knowledge provided by such\nevidence can be presented for use in a number of ways, including: sum-\nmary of experience; lists of factors to consider; and comparative ranking\nof techniques.\n", "page": 90, "type": "text", "section": "Page 90"}
{"text": "Part II\nDesign as a Noun: How\nSoftware Is Structured\n75\n", "page": 92, "type": "text", "section": "Page 92"}
{"text": "Chapter 6\nSoftware Architecture\n6.1\nWhat architecture provides for us ...............................\n77\n6.2\nArchitectural style ...............................................\n79\n6.2.1\nPipe-and-\ufb01lter architectural style .......................\n82\n6.2.2\nCall-and-return architectural style ......................\n83\n6.2.3\nData-centred repository architectural style .............\n84\n6.3\nArchitectural patterns ...........................................\n87\n6.3.1\nModel-view-controller (MVC) ...........................\n88\n6.3.2\nLayers ....................................................\n90\n6.4\nEmpirical knowledge about architecture .........................\n91\nKey take-home points about software architecture ..............\n92\nThe idea that a software application might have an architecture has become an\nimportant concept in thinking about how applications are composed, and how\ntheir operations are organised. As in other domains, its value largely stems\nfrom providing a highly abstract and readily visualised perspective on how\nsomething is organised and structured, whether it be a building, a ship, or a\nsoftware application. And the idea of architecture also captures more than the\nway something is constructed. It also embodies ideas about how it functions\n(think of how \u2018tanker\u2019, \u2018car ferry\u2019 relate to a combination of di\ufb00erent forms\nand functions when considering naval architecture).\nSo, architecture turns out to be a versatile concept: we can describe an\napplication as having \u2018an architecture\u2019; use ideas about \u2018architectural style\u2019 to\ncategorise architectures; and employ \u2018architectural patterns\u2019 when designing\nan application. These facets are all explored in the rest of this chapter, but\n\ufb01rst we look a bit more closely at what we mean by the concept itself.\n6.1\nWhat architecture provides for us\nWhen software applications consisted of programs executed on isolated\ncomputers (the \u2018pre-internet era\u2019), there was little need for the concept\nof architecture. Software was largely developed using imperative program-\nming languages (Algol, COBOL, FORTRAN etc.) which used broadly similar\nstructures. Certainly, there were di\ufb00erent ways that an application could be\n77\n", "page": 94, "type": "text", "section": "Page 94"}
{"text": "78\nSoftware Design: Creating Solutions for Ill-Structured Problems\norganised. It might be structured as a single process with a \u2018main\u2019 program in-\nvoking sub-programs; or as a database, organised around tables of data; and it\nmight be organised as a sequence of connected processes (through such mech-\nanisms as the Unix \u2018pipe\u2019 that provided data-streams for this purpose). An\napplication might even run as a set of concurrent processes interacting across\na small local network of computers that shared a common area of memory.\nBut only a limited vocabulary was needed for describing these distinctions.\nVarious in\ufb02uences played a part in subsequently extending the options\navailable to the software developer. Some arose from developments in imple-\nmentation technology (objects, services), while others were concerned with\nthe way that the internet introduced new ways for an application to interact\nwith the world. And as these combined and proliferated, so too did the range\nof forms that software could take, and hence the need to codify the role of\n\u2018architecture\u2019\u2014recognised in the pioneering work of Shaw & Garlan (1996).\nSoftware components interact in many di\ufb00erent ways (invocation, uses,\ninheritance, data transfer etc.). All of these interactions create dependencies\nor coupling between the components, and this remains as important a concept\nnow as it was when \ufb01rst identi\ufb01ed\u2014not least because the range of forms it\ncan take has expanded.\nThe implication of concepts such as coupling and that of separation of\nconcerns, is that we should seek to make the major parts of our application as\nindependent of one another as possible, both when considering functionality\nand also information. And it is in \ufb01nding ways to provide such independence\nthat the choice of an architecture plays a useful role. When designing the\narchitecture of an application we need to devise ways of keeping coupling to a\nminimum, and the manner in which this should be organised should obviously\ndepend upon the task that is to be performed by the application. So, the\nway that (say) the components of a compiler are organised, will need to be\nquite di\ufb00erent to the way that we might organise the components of a word\nprocessor, or those of an on-line multi-user game.\nOther factors may also in\ufb02uence the speci\ufb01c choice of architectural form for\nan application. One of the earliest discussions of the bene\ufb01ts of thinking of the\norganisation of an application in terms of architecture was provided in Garlan\n& Perry (1995). Introducing a collection of papers on software architecture,\nthey described many of the key issues lucidly and concisely. In particular, they\nargued that the concept of architecture can have a positive impact upon each\nof the following aspects of software development.\nUnderstanding. Architectural concepts provide a vocabulary that can aid\nour understanding of an application\u2019s high-level design (model).\nReuse. The cost of developing software encourages the reuse of existing code\n(and designs) wherever possible, and the high-level components com-\nprising a system architecture may assist with identifying where there is\nscope for reuse.\n", "page": 95, "type": "text", "section": "Page 95"}
{"text": "Software Architecture\n79\nEvolution. When designing a software application, we need to consider how\nit might evolve, and facilitate future changes by allocating the elements\nthat we think most likely to change into distinct sub-systems. Doing\nso also provides a guide for anyone who may later need to change the\ndesign of the application\u2014ensuring that any changes conform to the\narchitecture should help retain the overall integrity of the application.\nAnalysis. The architecture can help with checking for consistency across dif-\nferent characteristics of a design.\nManagement. Anticipating how an application may evolve is (or should be)\na factor in determining its architectural form. Implicitly, making a poor\nchoice can create a technical debt that will constrain future evolution.\nThe last point captures an important aspect of architecture. For any ap-\nplication, the choice of its architecture is an important and early decision,\nin\ufb02uencing the later design stages as well as implementation. And not only\nis this decision made at an early stage in development, it is also one that is\ndi\ufb03cult to change signi\ufb01cantly at a later time since the choice of architecture\nunderpins so many aspects. So thinking about how a system will evolve might\nbe something that is di\ufb03cult to do, but it is something that is vitally impor-\ntant and that needs to occur right at the outset of the design process (van\nVliet & Tang 2016).\nThus far we have con\ufb01ned discussion of architecture mostly to some fairly\nabstract ideas of what an architecture is and what in\ufb02uence it has. The next\nstep is to consider how we might describe the form of an architecture, and\nthat requires that we employ the idea of an architectural style.\n6.2\nArchitectural style\nThe concept of architectural style is both useful and something that is\nfamiliar from other domains. When we describe a building to someone else,\nwe might refer to it as being in a \u2018Tudor style\u2019 or a \u20181960s style\u2019. For buildings,\ndescriptions of their style may also be related to the materials used in their\nconstruction. So, although we often use such a temporal label to describe a\nstyle (and implicitly the materials used in their construction), we also use\nterms like \u2018New England\u2019 or \u2018Steel Frame\u2019, re\ufb02ecting the way that the form of\nbuildings has tended to evolve as new materials for their construction came\ninto use. And as already noted above, in the context of \u2018naval architecture\u2019\nwe tend to use labels that relate to function, such as \u2018oil tanker\u2019, \u2018car ferry\u2019\netc. For both buildings and ships, the use of such a label gives us an idea of\nthe characteristics that a particular building or ship might have.\n", "page": 96, "type": "text", "section": "Page 96"}
{"text": "80\nSoftware Design: Creating Solutions for Ill-Structured Problems\nFor software, the concept of architectural style can similarly be viewed as\nproviding a very abstract description of a set of general characteristics related\nto the form of an application. When provided with such a description, we will\nthen know something about the general form this has, although there may\nstill be great variation of detail. More speci\ufb01cally, and a point that we will\nreturn to, is that this will also tell us something about what might be involved\nin modifying the resulting application in the future.\nFor software the sort of label we use may relate to the way that the ap-\nplication is intended to operate. So we might refer to styles using terms such\nas \u2018client-server\u2019 or \u2018pipeline\u2019. However, such labels are not a very systematic\nway of classifying architectural styles, although very useful for easy reference.\nAnd as it became realised that the idea of an application\u2019s architecture was\nuseful, so ideas emerged about how best to describe and classify this.\nIn Perry & Wolf (1992), the authors proposed a classi\ufb01cation scheme based\non the following characteristics:\nsoftware architecture \u2194{elements, form, rationale}\nThey categorised elements as being concerned with processing, data or con-\nnections, and form as a \u2018set of weighted properties and relationships\u2019, while\nrationale recorded the motivation for particular choices.\nThe in\ufb02uential book by Shaw & Garlan (1996), that helped to consolidate\nthe idea of architecture and its importance, adopted a rather simpler approach\nto classi\ufb01cation, employing a basic framework based solely upon components\nand connectors.\nA rather more detailed scheme was used in (Shaw & Clements 1997). This\ncategorised architectural style in terms of the following major features.\n\u2022 the kinds of components and connectors used in the style (for example,\nobjects and method calls);\n\u2022 the ways in which control (of execution) is shared, allocated and trans-\nferred among the components;\n\u2022 how data is communicated through the system;\n\u2022 how data and control interact;\n\u2022 the type of (design) reasoning that is compatible with the style.\nThe features described in the last four bullets can be considered as forming the\n\u2018context\u2019 in which an application will execute, and so we can then categorise\narchitectural styles in terms of:\nsoftware architectural style \u2194{components, connectors, context}\nIt is also worth noting that while researchers have sought to formalise\nthe description of architectural style using \u2018architecture description languages\u2019\n(ADLs), this does not seem to have led to anything that is widely used (Ozkaya\n", "page": 97, "type": "text", "section": "Page 97"}
{"text": "Software Architecture\n81\n2017). Indeed, architectural concepts tend to be rather abstract as well as\nvery diverse, and hence are probably not really easily described using formal\nnotations.\nAs indicated earlier, applications created in the 1970s and 1980s were\nusually organised in a self-contained \u2018monolithic\u2019 form, with all of the elements\nresiding on the same computer, and having a form such as call-and-return or\ndata-centred-repository. With the advent of the internet in the 1990s new\nforms evolved (such as client-server), exploiting the ability to distribute the\nelements of an application. The later evolution of the cloud, and related ideas\nabout services has added further to the choices available to the designer.\nBecause architectural concepts are relatively abstract, the vocabulary as-\nsociated with them lacks precision\u2014one of the factors motivating the cate-\ngorisation process provided in early works such as (Shaw & Garlan 1996).\nTable 6.1 summarises the major categories of architectural style identi\ufb01ed\nin (Shaw & Clements 1997). Perhaps not surprisingly, these largely relate to\n\u2018monolithic\u2019 forms of application construction\u2014distributed forms can be hard\nto classify\u2014and many categories do encompass a variety of styles.\nTABLE 6.1: Some major categories of software architectural style\nCategory\nCharacteristics\nExamples of Styles\nData-\ufb02ow\nMotion of data, with no \u2018up-\nstream content control\u2019 by\nthe recipient\nbatch\nsequential;\npipe-and-\ufb01lter\nCall-and-return\nOrder of computation with a\nsingle thread of control\nmain\nprogram/sub-\nprograms;\n\u2018classical\u2019\nobjects\nInteracting-processes\nCommunication among in-\ndependent, concurrent pro-\ncesses\ncommunicating\npro-\ncesses;\ndistributed\nobjects\nData-centred repository\nComplex central data store\ntransactional\ndatabases;\nclient-\nserver; blackboard\nData-sharing\nDirect\nsharing\nof\ndata\namong components\nhypertext;\nlightweight threads\nOne caveat emphasised by Shaw & Clements (1997) and one that we should\nnote, is that applications are not necessarily \u2018pure\u2019 in terms of their style and\nso may possess the characteristics of more than one style. And of course, if a\nsystem is classi\ufb01ed as being a \u2018hybrid\u2019, that doesn\u2019t reduce the value of the\nclassi\ufb01cation process, indeed it may even render it more important.\nBass, Clements & Kazman (2013) describe how thinking about architecture\nhas subsequently evolved. Many of the original ideas are still there, but they\nare apt to be expressed di\ufb00erently. Rather than categorising styles in terms of\ntheir elements and the connections between them, they argue that architecture\nshould be viewed in terms of three di\ufb00erent structures, which in turn relate\nto di\ufb00erent sets of decisions that occur during the process of design.\n", "page": 98, "type": "text", "section": "Page 98"}
{"text": "82\nSoftware Design: Creating Solutions for Ill-Structured Problems\n1. Module structures consist of the blocks of code or data that will form\nthe application, and relate to design decisions about how responsibility\nis allocated, the ways that the modules depend upon each other (the\nforms of coupling), and the use of external modules.\n2. Component-and-connector structures are more concerned with how the\napplication will behave when it executes and how the di\ufb00erent elements\nwill interact during execution. Whereas module structures are essentially\nstatic, these are concerned with system execution.\n3. Allocation structures are concerned with where di\ufb00erent modules will\nreside, and from where external resources will be sourced.\nWhile this can be simpli\ufb01ed to a model of \u2018component-connector-context\u2019\nit goes much further and relates much more closely to the decision-making\nprocesses involved in architectural design.\nTo help illustrate the concepts involved, we now look brie\ufb02y at the forms\nof three widely used architectural styles. Other styles such as object-oriented\nand service-oriented architecture will be discussed in later chapters, and these\nexamples have been chosen simply to illustrate the variety that can occur.\n6.2.1\nPipe-and-\ufb01lter architectural style\nAn application based upon this style is one in which a sequence of trans-\nformations are performed upon data, typically by a series of processes. Each\nprocess performs its allocated task and then passes the data on to the next\none. As a style it emphasises separation of concerns, where the concerns are\nprovided by the transformations embodied in the individual processes. It is\norganised around \ufb02ow of data. Table 6.2 summarises the main characteristics\nof the style using the classi\ufb01cation scheme from (Shaw & Clements 1997).\nTABLE 6.2: The pipe-and-\ufb01lter architectural style\nFeature\nInstantiation in pipe-and-\ufb01lter\nComponents\nData transformation processes.\nConnectors\nData transfer mechanisms (e.g. Unix pipes, \ufb01les etc.).\nControl of execution\nTypically asynchronous. Control is transferred by the\narrival of data at the input to a process.\nData communication\nData is generally passed with control.\nControl/data interaction\nControl and data generally share the same topology\nand control is achieved through the activity of trans-\nferring data.\nDesign reasoning\nTends to employ a bottom-up approach based upon\nfunction due to the emphasis placed upon the \ufb01l-\nters (components). Fits well with incremental devel-\nopment forms.\n", "page": 99, "type": "text", "section": "Page 99"}
{"text": "Software Architecture\n83\nFigure 6.1 illustrates the use of the Unix \u2018pipe\u2019 mechanism, introduced in\nthe early 1970s, to provide an example of an application that uses this style.\nThe pipes provide data streams linking the \u2018standard output\u2019 and \u2018standard\ninput\u2019 of successive processes (the \u2018\ufb01lters\u2019), labelled as P1, P2 and P3 in the\n\ufb01gure. An example of the type of application well-suited to this style is a\nsimple compiler, in which a succession of operations gradually transforms the\ndata stream from input text to output code. So here, P1 might be a lexical\nanalyser, used to separate the \u2018tokens\u2019 in the input program; P2 could be a\nsyntactic checker, ensuring that the tokens obeyed the syntax rules for the\nlanguage; and P3 might perform a semantic analysis of the stream of tokens,\nleading on to further processes to generate and optimise code.\nP1\nP3\nP2\nStandard\nInput\nPipe\nPipe\nStandard\nOutput\nFIGURE 6.1: Unix pipe and \ufb01lter using three processes: P1 | P2 | P3\nAs an architectural style this is more versatile than the example might\nimply and is well suited for use with data-driven operations. Data transfer\ndoes not necessarily have to be asynchronous, and the topology is not con\ufb01ned\nto linear sequences of processes. It also provides scope for strong separation of\nconcerns as far as processing is concerned, since each process usually occupies\nits own unique address space with no shared data. (However, knowledge about\nthe form(s) of the data does need to be shared.) There is also ready scope for\nreuse of processes, because of the strong decoupling. It is also well suited to\na development approach based on prototyping, and o\ufb00ering scope to perform\nthis incrementally, with each process being developed and integrated in turn.\n6.2.2\nCall-and-return architectural style\nThis architectural style is one that closely mirrors the way that the under-\nlying computer operates, using an ordered and hierarchical transfer of control\nbetween di\ufb00erent processing tasks. Again it is based upon a philosophy of sepa-\nration of concerns, but unlike pipe-and-\ufb01lter, the main emphasis lies upon the\ntransfer of control between processing activities, rather than transfer of data,\nand so the \u2018concerns\u2019 being partitioned are essentially those related to func-\ntion. Imperative programming languages (such as Pascal, C. and many others)\nprovide structures that implement this form, whereby a \u2018main\u2019 program ele-\nment transfers control to a network of sub-programs. Typically, sub-programs\neither access data through the passing of parameters (arguments) or through\n", "page": 100, "type": "text", "section": "Page 100"}
{"text": "84\nSoftware Design: Creating Solutions for Ill-Structured Problems\nthe use of static global variables that are visible to all sub-programs. Object-\noriented languages such as Java often use this as an underpinning mechanism,\nand so can also be used to write software in this style.\nmain\noutput\ninput\nprocessing\nProcess 2\nProcess 1\nFIGURE 6.2: Call and return using a main program and sub-programs\nFigure 6.2 shows a simple illustration of an application structured in\nthis style, with a main program unit (which sequences the calls to the sub-\nprograms), and a hierarchical set of sub-programs that perform the tasks.\nHere the arrows indicate transfer of control by a conventional sub-program\ninvocation mechanism, and further annotation can be used to show transfer\nof data via sub-program parameters.\nTable 6.3 summarises the main characteristics of this architectural style.\nWhile this is a simple and convenient form to employ for constructing mono-\nlithic applications, and likely to produce e\ufb03cient code because of the way that\nit \u2018mirrors\u2019 the underlying computer mechanisms, it provides limited scope for\nreuse beyond employing a \u2018library\u2019 of sub-programs. However, it is quite ver-\nsatile and widely employed\u2014for example, it could be used to structure the\ninternal forms of the processes used in Figure 6.1.\n6.2.3\nData-centred repository architectural style\nThis style encompasses those applications for which the key element is\nsome central mechanism that is used for the persistent storage of information\n(not necessarily a database management system), so that the information\ncan then be manipulated by a set of external processing units. So for this\narchitectural style, the \u2018concerns\u2019 are related to data and its use. However, it\nalso o\ufb00ers scope to provide an element of information hiding regarding the\nway that the information is actually stored.\nObvious examples of applications in this category are database systems\nand blackboard-style expert systems (here the blackboard itself provides the\ncentral mechanism). Shaw & Clements (1997) argue that client-server systems\nalso come into this general category, on the basis that the server acts as a\n", "page": 101, "type": "text", "section": "Page 101"}
{"text": "Software Architecture\n85\nTABLE 6.3: The call-and-return architectural style\nFeature\nInstantiation in call-and-return\nComponents\nSub-program units.\nConnectors\nInvocation of sub-programs.\nControl of execution\nSequencing of calls is organised by the algorithms in\nthe components that form the invocation hierarchy.\nData communication\nData can be passed through parameters and may also\nbe shared using a global storage mechanism (variables\ndeclared in the main component).\nControl/data interaction\nThis is largely limited to the passing of parameters\nand the return of data through function calls.\nDesign reasoning\nBecause the \u2018concerns\u2019 (functions) are sub-divided, it\nis usually associated with top-down thinking. Many\ntraditional plan-driven design approaches produce de-\nsign models that have this form. Use of global data\nstructures can constrain the e\ufb00ective separation of\nconcerns.\ncentral repository, and may well include a database. Figure 6.3 provides an\nillustration of the general form of a client-server system (whether the server\nis \u2018local\u2019 or in the cloud is not important, since it is the role that matters).\n'Thin' client\n(e.g. laptop,\nphone, tablet)\nApplication\ndatabase\nServer\nFIGURE 6.3: Data-centred repository: a simple client-server model\nWhen the repository is an actual database, the central mechanism is likely\nto be concerned with providing one or more forms of indexed access to a poten-\ntially large volume of data. Blackboard systems and object-oriented databases\ncan provide a less highly structured form of repository, which may well be used\nto acquire, aggregate, and record a variety of forms of \u2018knowledge\u2019. Table 6.4\nsummarises the characteristics of this architectural style.\n", "page": 102, "type": "text", "section": "Page 102"}
{"text": "86\nSoftware Design: Creating Solutions for Ill-Structured Problems\nTABLE 6.4: The data-centred repository architectural style\nFeature\nInstantiation in data-centred repository\nComponents\nStorage mechanisms and processing units.\nConnectors\nTransactions, queries, direct access (blackboard).\nControl of execution\nOperations are usually asynchronous and may also\noccur in parallel.\nData communication\nData is usually passed through some form of param-\neter mechanism.\nControl/data interaction\nThis varies quite widely. For a database or a client-\nserver system, these may be highly synchronised,\nwhereas in the case of blackboard there may be little\nor no interaction.\nDesign reasoning\nThe strong focus on data usually means that mod-\nelling the data is an important element. The variety\nof forms such systems take tends to mean that design\nlogic may also vary extensively.\nAn architectural style for the CCC\nThe\nCCC\nsystem\nis\nessentially\none\nthat\nis\nused\nto\nmanage\ninformation\u2014about the cars, the members and the way that mem-\nbers are charged for the use of the cars. So the choice of a data-centred\nrepository style seems to be appropriate, providing a central \u2018knowl-\nedge base\u2019 that can be accessed to manage bookings, accounts etc. And\nsince the customers will be using remote forms of access such as mobile\nphones, it also seems appropriate to adopt a client-server form for this.\nOne question that this then raises is \u201cwhat form will the server take?\u201d.\nWe could adopt the use of a relational database to hold details of cars,\nbookings etc., but equally we could use an object model in which we\nhave objects that represent cars. The latter is likely to prove more\n\ufb02exible. We can see this could cope with di\ufb00erent models of car using\ninheritance if CCC later decide to o\ufb00er di\ufb00erent options, and an object\nmodel does encapsulate all of the relevant data about a car within an\nobject. However, given the various things that the CCC system does\n(and may do in the future) it may well be that some form of compromise\nwould be a good way to handle this. The more changeable activities\nrelated to cars could be modelled as objects, but things like recording\nbookings and charging for use might employ a database.\nAt this stage we will focus on the choice of style and \ufb01ll out the details\nlater, deferring decisions about these until we have a clearer picture of\nhow the CCC system will work and the directions in which it will later\nexpand.\n", "page": 103, "type": "text", "section": "Page 103"}
{"text": "Software Architecture\n87\n6.3\nArchitectural patterns\nThe concept of using some form of abstract \u2018pattern\u2019 to transfer knowl-\nedge about useful design models that could be used to \u2018solve\u2019 issues that are\nrepeatedly encountered across a range of applications emerged in the 1990s,\nand has been realised in a number of ways. It has been widely adopted for use\nin object-oriented software development, as a means of describing solutions\nto recurring challenges that might face the designer (Gamma, Helm, Johnson\n& Vlissides 1995), usually involving particular parts of a system or applica-\ntion. It has also been suggested that patterns could be adapted to perform a\nsimilar role in the design of service-oriented applications (Erl 2009). We will\ndiscuss the pattern concept in much more detail in Chapter 15, but in this\nsection we discuss how the concept can be used to describe the overall form of\na system, by making use of architectural design patterns, a concept proposed\nby Buschmann, Meunier, Rohnert, Sommerlad & Stal (1996).\nThe idea of using patterns to help with transferring knowledge about de-\nsign \u2018solutions\u2019 is rooted in the work of the architect Christopher Alexander\n(Alexander, Ishikawa, Silverstein, Jacobson, Fiksdahl-King & Angel 1977),\nand has been described by him in the following words.\n\u201cEach pattern describes a problem which occurs over and over\nagain in our environment, and then describes the core of the solu-\ntion to that problem, in such a way that you can use this solution\na million times over, without ever doing it the same way twice.\u201d\nEssentially, a pattern provides a generic description of, and \u2018solution\u2019 to,\na problem, and being generic, it will always need to be instantiated in a way\nthat addresses the speci\ufb01c situation that the designer is actually facing. (This\n\ufb01ts in with the concept of \u2018design as adaptation\u2019 introduced in Chapter 1 and\nFigure 1.2.)\nCouched in terms of knowledge transfer, a pattern identi\ufb01es a particular\ndesign problem that might be encountered, together with a strategy for ad-\ndressing that problem. We also expect that the description of a pattern will\nidentify some possible consequences of adopting the pattern, since the choice\nof whether or not to use a pattern may well involve making trade-o\ufb00s between\ndi\ufb00erent aspects of the design model.\nIn some ways using patterns has similarities to the sort of learning involved\nin the traditional master/apprentice relationship. Learning about patterns\ninvolves learning about possible problems that a designer may face as well as\nabout how these might be resolved\u2014usually involving relatively manageable\n\u2018chunks\u2019 of knowledge. Patterns also have to be learned (an issue that we return\nto when considering the use of object-oriented design patterns). The idea of\na pattern also \ufb01ts well with some of the observed practices of designers, such\nas the notion of \u2018labels for plans\u2019 that was observed by Adelson & Soloway\n", "page": 104, "type": "text", "section": "Page 104"}
{"text": "88\nSoftware Design: Creating Solutions for Ill-Structured Problems\n(1985), whereby a designer would note the presence of a sub-problem for which\nthey already had a solution strategy, (again, re\ufb02ecting the idea of designing\nby adaptation).\nAt the architectural level of software design the pattern concept is used\nslightly di\ufb00erently. Here, patterns o\ufb00er models for the general structure that\nthe application should take, rather than for a part of the design solution. The\nideas involved in architectural patterns do overlap with architectural styles to\nsome degree\u2014some patterns can be realised using a variety of styles, whereas\nothers are implicitly linked to the idea of using a particular type of design\nelement (the most obvious example of such an overlap is that of \u2018pipes-and-\n\ufb01lters\u2019 which is essentially a pattern that can be employed with processes).\nArchitectural patterns provide di\ufb00erent ways of \u2018separating the concerns\u2019\nfor an application, aiming to organise its structure so that future changes\ncan be made with a minimum impact from any side-e\ufb00ects. However, to do so\nsuccessfully does implicitly assume that the designer (system architect) is able\nto envisage the ways in which the application may later evolve\u2014and a possible\nrisk is that the architectural pattern adopted may not be well suited to what\nactually does happen. So, while patterns do o\ufb00er bene\ufb01ts, the adoption of any\narchitectural pattern, like the adoption of an architectural style, does create\nthe potential for generating technical debt.\nTable 6.5 summarises the roles provided by a selection of the patterns\nintroduced in (Buschmann et al. 1996). In the rest of this section we examine\ntwo examples from this set in order to illustrate the idea more fully.\nTABLE 6.5: Some examples of architectural patterns\nPattern\nDescription of Role\nModel-view-controller\nProvides a structure for decoupling the various ele-\nments of an interactive system.\nLayers\nUsed where an application can be organised as a hi-\nerarchy of sub-tasks performed at di\ufb00erent levels of\nabstraction.\nPipes-and-\ufb01lters\nFor systems that process a stream of data (this is\nrather similar to the architectural style).\nBroker\nUsed to structure the interaction of distributed sys-\ntems with highly decoupled components, where the\nchoice of components may be made \u2018on the \ufb02y\u2019 when\nthe application executes.\nRe\ufb02ection\nIntended to support dynamic adaptation of the struc-\nture for a system.\n6.3.1\nModel-view-controller (MVC)\nThis is a widely encountered pattern used to structure the sort of appli-\ncations in which end-users will interact with some form of \u2018data repository\u2019,\n", "page": 105, "type": "text", "section": "Page 105"}
{"text": "Software Architecture\n89\nperforming updates to the data and viewing di\ufb00erent projections from it. As\nan example of where it could be used, it is well suited for use with applications\nwhich involve extensive user interaction with a dataset, such as a spreadsheet\nor word processor.\nThis pattern is motivated by the principle of separation of concerns, and\nis concerned with keeping the details of the model (the data repository) in-\ndependent from the elements that need to interact with it, namely the views\nand controllers. Essentially the model is encapsulated in such a way that its\ndetails (and format) are not directly visible to the views and controllers (the\nlink to designing with objects may be fairly obvious here, since both place\nemphasis upon information hiding through the encapsulation of data).\ncontroller\nmodel\nview\nInvokes methods\nin the model's API\nto change its state\nQueries\nmodel state\nNotifies of any\nchanges in the\nmodel state\nSelect view\nUser actions\nFIGURE 6.4: The MVC pattern\nFigure 6.4 shows the idea of MVC in a rather abstract way. It is worth\nnoting that a wide variety of such diagrams exist, often providing slightly dif-\nferent interpretations of the elements making up MVC and how they interact.\nThe roles for the elements are as follows.\nModel. This provides the core functionality of the application (that is, the\noperations performed upon the data) and the associated data.\nView. Each view provides a di\ufb00erent way of presenting knowledge about the\nmodel, obtained from the model, to the user.\nController A controller handles user input, and each view is likely to have\na distinct controller associated with it.\nThe views and controllers make up the user interface and are largely inde-\npendent of the model, beyond sharing knowledge of the data types making\nup the model. The model may well also need to provide updates to the views\nand controllers when changes are made to it (or at least, provide them with\n", "page": 106, "type": "text", "section": "Page 106"}
{"text": "90\nSoftware Design: Creating Solutions for Ill-Structured Problems\ninformation that an update is available). An important characteristic of this\ndesign structure is that it makes it possible to provide quite di\ufb00erent \u2018look\nand feel\u2019 forms of interaction without a need to modify the model itself.\nUsing MVC for the CCC system\nWe can easily see that the software for the CCC \ufb01ts well with the MVC\npattern. We can interpret the elements as follows:\n\u2022 The model is the information held centrally about the cars, book-\nings, customer accounts etc. This is continually being modi\ufb01ed\nand updated as cars are claimed, customers make bookings, cars\nare taken out of use for servicing etc.\n\u2022 There are a number of di\ufb00erent views. Some are ones presented to\na customer, perhaps reporting which cars are nearby and avail-\nable, or present data pertaining to a recently completed hire ses-\nsion. Other views are available to the managers, accounts depart-\nment, maintenance team etc. They all relate to the same core set\nof information, but present di\ufb00erent elements of it in ways that\nare meaningful to the needs of a particular user.\n\u2022 The controllers relate to interaction with di\ufb00erent users who are\nmaking requests, choices etc. Some may be phone apps, others\nmay be devices in the \u2018back o\ufb03ce\u2019 of CCC.\nAn important feature of MVC is that the characteristics of the model\nas seen by di\ufb00erent users through di\ufb00erent views should be consistent.\nThis alone is an excellent reason for thinking of the model as a cohesive\nwhole.\n6.3.2\nLayers\nOpportunities to employ the Layers pattern occur less commonly than\nthose for using MVC. However, as an example, it illustrates a di\ufb00erent way of\nthinking about how to organise the separation of concerns within the structure\nof an application, placing greater emphasis upon function.\nThis pattern structures an application by separating its functionality into\ndi\ufb00erent groups of operations, with each group performing its tasks at a di\ufb00er-\nent level of abstraction within a hierarchy. A classic illustration of this is the\nway that networking software is usually organised. Figure 6.5 shows a simple\nillustration of this for the OSI model, highlighting how each layer provides\nmore abstract operations by performing its tasks by using operations from\nthe layer beneath it.\nAs an example, when Layer 4 (Transport) splits a message into a series of\npackets, and ensures that these are delivered to the recipient, it does so by\n", "page": 107, "type": "text", "section": "Page 107"}
{"text": "Software Architecture\n91\ndrawing upon the services of Layer 3 (Network), to organise the route(s) by\nwhich the packets are delivered.\nApplication\nTransport\nSession\nPresentation\nPhysical\nData Link\nNetwork\nFIGURE 6.5: Layers pattern\nThe use of Layers makes it easy to iso-\nlate the e\ufb00ects that can arise from making\nchanges at the lower levels. A simple ex-\nample concerns a change in the underlying\nnetwork form. To move from using (say) an\nethernet implementation to using a slotted\nring as the network medium only involves\nchanges to the very lowest layers. The higher\nlayers have no knowledge of the nature of the\nactual transport mechanism being used.\nMany operating systems use a similar\nmodel (for example, Unix applications sit\nabove the \u2018shell\u2019, which in turn makes use\nof the system layers below it). Again, a dif-\nferent interface can be provided by simply\nchanging the shell, and hence a single com-\nputer can readily have a situation where dif-\nferent users are working with di\ufb00erent in-\nterfaces, but are still able to share \ufb01les and\nother resources when necessary.\nWhile clearly Layers is a particularly use-\nful pattern to use for \u2018system\u2019 software, in\nprinciple it is by no means restricted to such\napplications. However, it is likely that most\ndesigners will encounter this as a pattern\nthat is already established for a software system, and their concern will be\nto develop applications that conform to it.\n6.4\nEmpirical knowledge about architecture\nThe nature of software architecture makes it di\ufb03cult to perform empirical\nstudies, since for each application, the choice of a suitable architecture is rather\nentwined with the unique nature of the application itself. Hence systematic\nreviews in this area are relatively uncommon, and those that are available,\nmainly look at the \u2018robustness\u2019 of architectures when changes need to be\nmade.\nAn example of this is the systematic review by Williams & Carver (2010)\nthat focused upon assessing the impact of proposed changes to a system\u2019s\narchitecture. A further example is provided by Breivold, Crnkovic & Larsson\n", "page": 108, "type": "text", "section": "Page 108"}
{"text": "92\nSoftware Design: Creating Solutions for Ill-Structured Problems\n(2012), that looks at the e\ufb00ect of architecture upon software evolution, and\nat the di\ufb00erent approaches that have been proposed to help address this.\nA somewhat di\ufb00erent and interesting perspective is provided in the sys-\ntematic review by Shahin, Liang & Babar (2014). This examines some of the\nforms used for visualising software architecture, as well as di\ufb00erent elements\n(such as patterns), and the ways that these are used. They particularly ob-\nserved that these were often used to help with di\ufb00erent aspects of recovery\nof architectural knowledge about existing applications as well as to help with\nevolution.\nKey take-home points about software architecture\nThe concept of software architecture o\ufb00ers a high-level perspective upon\nthe way that a software application is structured and organised. Some key\nissues related to this include the following.\nSeparation of concerns. The major elements of a system will address dif-\nferent \u2018concerns\u2019 and choice of a suitable architecture will reduce the\nlikelihood of side-e\ufb00ects arising from interactions between the elements\nas well as providing a way to reduce future technical debt.\nComposition. The architecture of a system is concerned with how this is to\nbe composed from a (possibly diverse) set of elements.\nVocabulary. Architectural concepts provide a useful vocabulary that can be\nused to aid understanding and discussion related to the high-level struc-\nture of an application. This may also help identify how it might evolve\nin the future as well as what scope there is to reuse elements.\nCategorisation. A useful way to think of an architectural style is in terms of\nits components, the connectors that map the dependencies between the\ncomponents, and the context that describes how the elements execute\nand relate to each other.\nArchitectural patterns. These describe some commonly used ways to or-\nganise the top-level form of an application.\nEmpirical knowledge. Such knowledge is mainly concerned with the in-\nterplay between the choice of an architecture and the ease of making\nchanges to a system.\n", "page": 109, "type": "text", "section": "Page 109"}
{"text": "Chapter 7\nModelling Software Properties\n7.1\nWhat is a design model? .........................................\n93\n7.2\nRepresentations, perspectives and viewpoints ...................\n96\n7.2.1\nThe constructional viewpoint ...........................\n100\n7.2.2\nThe behavioural viewpoint ..............................\n101\n7.2.3\nThe functional viewpoint ................................\n101\n7.2.4\nThe data-modelling viewpoint ...........................\n102\n7.3\nDesign notations .................................................\n102\n7.3.1\nTextual description forms ...............................\n103\n7.3.2\nBox and line description forms ..........................\n103\n7.3.3\nMathematical notations .................................\n105\n7.4\nEmpirical knowledge related to viewpoint notations ............\n106\nKey take-home points about design modelling ..................\n107\nIn the previous chapter we considered how a software application might be\nstructured, using very abstract levels of description. This is because, at the\narchitectural level, the design models we create are largely concerned with\ndescribing how an application is to be organised as a set of major components.\nIn this chapter we look at how the attributes of software can be modelled\nat a more detailed level, although it is still very much an exercise in design\nabstraction. In particular, we concern ourselves with identifying the di\ufb00erent\ncharacteristics of software that we want to describe, because at this level of\nabstraction we need to think about many di\ufb00erent aspects of software.\nWe begin by examining the issue of what a model is, then consider some\nof the practicalities involved in developing a model. The rest of this chapter is\nthen largely concerned with what properties and attributes we need to model\nand some ideas about how these can be described.\n7.1\nWhat is a design model?\nIn Chapter 2 we introduced the idea of the design model as some form\nof abstract description for our ideas about how to \u2018solve\u2019 some sort of (ill-\nstructured) problem. The idea of using a model of the intended product to\n93\n", "page": 110, "type": "text", "section": "Page 110"}
{"text": "94\nSoftware Design: Creating Solutions for Ill-Structured Problems\nexplore (and record) design ideas is an old one, and was probably necessitated\nas the complexity of the \ufb01nal product increased. Pharaoh\u2019s pyramid designers\nmay not necessarily have needed to produce models, but certainly by the\nseventeenth century AD the form of such artifacts as sailing ships had become\nsu\ufb03ciently complex to warrant the production of quite elaborate and detailed\nmodels that could be used to indicate what the shipwrights were expected to\ncreate.\nUsing a model to guide construction\nSoftware development makes use of a number of di\ufb00erent forms of model,\nnot just design models. Modelling is often used to help explore and clarify\nthe requirements for an application. Requirements models are usually very\nabstract, related to the problem rather than the solution, and in some ways\nplay the same role as the models that architects produce to show how their\nbuildings will look and how they will \ufb01t into the landscape. We might also use\nmodels to help with such tasks as assessing risk in the development process,\nand of course, it is often necessary to use cost models to help with planning\nand managing actual development.\nAll of these are inter-related of course. A requirements model sets out much\nof the context and goals for a design model; and the design model provides\nsome of the context required for any modelling of risk or cost. However, for this\nchapter we will focus on design models\u2014while recognising that they in\ufb02uence,\nand are in\ufb02uenced by, other models.\nModels of physical artifacts tend to have two (related) characteristics. One\nis that they are likely to be created on a reduced scale, the other is the use\nof abstraction. A model is rarely complete in every detail. Usually it possesses\njust enough detail to show others what the designer intends, but omits issues\nthat are not necessary, perhaps because they are su\ufb03ciently \u2018standard\u2019 that\nthose responsible for construction/implementation will understand how they\nwill be provided in the \ufb01nal product.\nModelling is where software once again diverges from the norm. To start\nwith of course, software is invisible, making it di\ufb03cult to relate our models\nto the \ufb01nal product in the way that we can look at (say) a scale model of a\nsailing ship and envisage what the actual ship will be like. And for the same\n", "page": 111, "type": "text", "section": "Page 111"}
{"text": "Modelling Software Properties\n95\nreason, there tends to be no real sense of scale when we create software models.\nAnd because software is dynamic, we also have to capture our ideas about a\nnumber of quite di\ufb00erent attributes, making it di\ufb03cult to have a single model\nthat will show our ideas. Certainly though, abstraction is something that is\nimportant in software models\u2014an important element in the task of modelling\nsoftware is to leave out the detail that we don\u2019t need in order to understand\nwhat an application is to do and how it will do it.\nOf course, design engineers in other disciplines don\u2019t just concern them-\nselves with physical models, and indeed, mathematical models of such issues\nas stress and dynamic behaviour provide important abstractions for them.\nHowever, even then, their mathematical models will be related to the physical\nproperties of the intended system, as well as upon the laws of nature.\nThis is therefore a good point to clarify some of our terminology. The\nconcept of something exhibiting a particular property is quite important in\nmodelling (and also in measurement). We also make use of the term attribute\nin much the same sense, and indeed, the two terms are often considered to\nbe synonymous in everyday language. For our purposes though, it may often\nbe useful to make a distinction between the two terms, rather akin to that\nsometimes used in the context of measurement. So in this book we will use\nthese terms as follows.\nProperty. A general concept relating to some characteristic of software (ac-\ntual or desired). For example, we may describe an application as having\nthe property of being robust, or e\ufb03cient.\nAttribute. This is something that we can explicitly and directly model (and\nmeasure). For example, the average time to respond to an event, or the\nform of coupling occurring between two design elements.\nIn the context of modelling, this allows us to distinguish between what we can\nand cannot model directly. Design models largely describe or make reference\nto attributes\u2014whereas a model produced as part of a speci\ufb01cation would\nprobably largely refer to properties. So the distinction is useful in terms of\nclarifying what we can and cannot readily model.\nSo, how do we model software and its attributes (or properties)? Well, this\nwill be explored in detail in the following sections and the later chapters, but\nwe commonly use three forms of notation (often in combination).\n\u2022 Software designers make extensive use of diagrammatical notations. Of-\nten these are informal \u2018box and line\u2019 sketches used to help explore ideas.\nAt other times we draw rather more stylised diagrams to help explain\nideas to others. In this chapter we explore ideas about this type of no-\ntation to describe ideas about modelling.\n\u2022 More formal modelling sometimes makes use of mathematical notations\nto describe system properties and behaviour. While such models are less\nwell-suited than diagrams to exploring ideas, they are much better at\nsupporting reasoning about the consequences of design choices.\n", "page": 112, "type": "text", "section": "Page 112"}
{"text": "96\nSoftware Design: Creating Solutions for Ill-Structured Problems\n\u2022 Narrative descriptions using textual forms may also be useful, and while\nthey can be used in their own right, these are almost always needed to\nsupplement the other two forms.\nWe can use these models for all sorts of purposes, including exploring ideas;\nexplaining them to others; and checking them for completeness and consis-\ntency. And of course, as always with design, there are no \u2018right\u2019 and \u2018wrong\u2019\nchoices of notational form in any absolute sense.\n7.2\nRepresentations, perspectives and viewpoints\nAbstraction performs an essential role in the design process, allowing the\ndesigner to concentrate on those features of the design model that are most\nimportant at any particular stage of its development. The designer there-\nfore needs ways to represent abstract ideas about problem objects and design\nobjects, and about the di\ufb00erent relationships that will occur between them.\nWhile this is true in any design context, the invisible nature of software poses\nsome additional challenges, as observed earlier.\nWhen modelling, a representation is used to provide a particular abstract\ndescription of particular characteristics of the designer\u2019s ideas for an applica-\ntion, and is typically needed for such purposes as:\n\u2022 allowing the designer to express their ideas about their \u2018solution\u2019;\n\u2022 helping the designer to explain their ideas to others (such as customers,\nfellow designers, implementors, managers);\n\u2022 assisting the designer to check the design model for important features\nsuch as completeness and consistency.\nA representation, whatever its form, can help a designer to concentrate his\nor her attention upon those issues that are most important to them as the\nmodel evolves. It also provides a mechanism for reducing the extent of the\n\u2018cognitive load\u2019 involved in the process. Indeed, as Vessey & Conger (1994)\nhave observed: \u201chuman problem-solvers resort to various ways of e\ufb00ectively\nincreasing the capacity of short-term memory as well as using external memory\ndevices and/or techniques to support working memory\u201d. In this context, a\nrepresentation can be considered as a form of \u2018external memory device\u2019.\nTwo useful and related concepts are those of perspectives and viewpoints.\n\u2022 A perspective relates to a software development role, such as a manager,\nend-user, programmer. Each has their own set of interests and needs\nrelated to the design model.\n", "page": 113, "type": "text", "section": "Page 113"}
{"text": "Modelling Software Properties\n97\n\u2022 A viewpoint relates to a set of particular characteristics of a design\nmodel, which in turn re\ufb02ect some speci\ufb01c aspect of software (its con-\nstruction, the way it behaves when certain events occur etc.). We usu-\nally use speci\ufb01c representations (notations) to describe the design model\nfrom particular viewpoints.\nOur concern in this chapter is primarily with viewpoints, but it is worth point-\ning out here that the concepts of perspectives and viewpoints are not wholly\nindependent. A speci\ufb01c perspective of the design model can be presented using\na particular set of viewpoints and representations.\nArchitect's\ninternal\ndesign\nmodel\nPlan, elevation & end view\nHeating &\nventilation plan\nWiring diagram\nFIGURE 7.1: Examples of representations as realisations of viewpoints\nIn this chapter these terms are also used rather di\ufb00erently from the way\nthat they are used in requirements engineering, where a viewpoint may be used\nto describe a \u2018stakeholder\u2019 view of the design model (Finkelstein, Kramer, Nu-\nseibeh, Finkelstein & Goedicke 1992). In this book the concept of a viewpoint\nis more focused upon the design model, and with providing projections of its\nproperties outwards to users, whereas its use in the requirements context is\nmore concerned with a user\u2019s particular perception of the model. Arguably\nthis stems from the use of \u2018white box\u2019 role of models in software design, where\nthe role of the model is to describe the workings of the application, whereas\nthe model in requirements engineering is more of a \u2018black box\u2019, whereby we\ndescribe what a system is to do, rather than how it is to be done.\nIf we very brie\ufb02y return to the example of designing a house move, used\nin Chapter 2, examples of design viewpoints appropriate for this may include\nits physical layout, the organisation of electrical power, and heating and ven-\ntilation. These are all di\ufb00erent projections of the \u2018house model\u2019, as shown in\nFigure 7.1. Since each representation used to model a viewpoint has some\noverlap and dependency upon the other forms, (for example, heating and ven-\ntilation relates to the physical layout of the interior of the building) these can\n", "page": 114, "type": "text", "section": "Page 114"}
{"text": "98\nSoftware Design: Creating Solutions for Ill-Structured Problems\nreally be seen as forming projections of the model, and even for this physical\nsituation, there is a clear need to ensure consistency between them.\nDesign\nModel\nBehavioural forms\nFunctional forms\nConstructional forms\nData modelling forms\nFIGURE 7.2: Examples of representations as realisations of viewpoints\nIn Figure 7.2 we identify the four main viewpoints that we will use to\ncategorise design notations in this book. The attributes that each of these\nmodels can be described as follows.\n\u2022 Constructional forms are concerned with how the elements of the model\nare composed together to create the application, and hence model the\ndi\ufb00erent ways in which the elements are coupled and the resulting de-\npendencies. This is essentially a static projection from the design model.\n\u2022 Behavioural forms describe the causal links that connect events (inter-\nnal and external) and system responses. As a viewpoint it models the\ndynamic interactions arising from events that cause transitions between\nthe di\ufb00erent states of a system.\n\u2022 Functional forms describe the actions performed by a system or appli-\ncation. These may depend upon such aspects as information \ufb02ow, or the\nsequencing of actions, depending upon the nature of the system and its\narchitectural style.\n\u2022 Data-modelling forms are concerned with the di\ufb00erent data elements\nused in the system and the relationships that occur between them.\nWhat we need to remember is that this is a classi\ufb01cation scheme rather\nthan some fundamental characteristic of software. What the di\ufb00erent view-\npoints \u2018capture\u2019 is some of the di\ufb00erent characteristics of software, and hence\nof our ideas about the design model itself. And since each representation used\n", "page": 115, "type": "text", "section": "Page 115"}
{"text": "Modelling Software Properties\n99\nto describe a viewpoint describes a particular set of design attributes, there\nmay be some overlap between these, as shown symbolically in Figure 7.3,\nproviding some potential for checking consistency between viewpoints with\nrespect to the model itself.\nattribute8\nattribute4\nattribute3\nattribute2\nattribute1\nattribute7\nattribute6\nattribute5\nRepresentation 1\nRepresentation 2\nRepresentation 3\nFIGURE 7.3: Some attributes may appear in more than one representation\nWhat is more, these viewpoints can themselves be further classi\ufb01ed as\nbeing \u2018direct\u2019 viewpoints, in that they are created directly by the designer(s).\nWe can also identify viewpoints that may be described as being \u2018derived\u2019\nviewpoints, created by applying some form of transformation to the design\nmodel. The most obvious such form occurs when some form of interpreter\nis used to \u2018execute\u2019 the design model (usually a behavioural description of\nthe model), rather akin to the process of mental execution noted earlier and\ndescribed in (Adelson & Soloway 1985).\nWhile this scheme of classi\ufb01cation is quite practical for our purposes, it is\nby no means the only way that we can classify design descriptions. A widely-\ncited form that is used for describing object-oriented models is Kruchten\u2019s 4+1\nView that uses the labels: logical, process, development, physical + scenarios\n(Kruchten 1994). While less general-purpose than the scheme used here, there\nare some similarities, including the common recognition that some character-\nistics are not necessarily uniquely represented in one single viewpoint.\nIn the rest of this chapter we examine the characteristics of each viewpoint\nand identify the attributes of design elements that are modelled in these. In\nthe chapters that follow, we will then look at some examples of how these\nviewpoints are modelled for some of the major architectural styles.\n", "page": 116, "type": "text", "section": "Page 116"}
{"text": "100\nSoftware Design: Creating Solutions for Ill-Structured Problems\n7.2.1\nThe constructional viewpoint\nFIGURE 7.4: Construction\nand construction units\nConstructional descriptions are produced at\nvarious stages in the development of the design\nmodel. Plan-driven approaches used with call-\nand-return architectures will develop construc-\ntional models towards the end of the design pro-\ncess, whereas those used with object-oriented\nstyles as well as more dynamic forms of devel-\nopment such as the Agile forms may identify the\nmajor constructional elements at relatively early\nstages. And the choice of architectural style at\nan early stage of any development process es-\nsentially constrains the choices available to the\ndesigner. (Plan-driven methods tend to be or-\nganised around a speci\ufb01c architectural style, so\nadopting a particular plan-driven design approach also determines the choice\nof constructional form.) Constructional information is also dependent upon\nthe particular forms of packaging used in an architectural style (classes, sub-\nprograms, processes etc.) and how they interact.\nWhen thinking about how to actually construct software applications, and\nthe way that the di\ufb00erent elements interact, our ideas are likely to be con-\ncerned with coupling and the di\ufb00erent forms it can take within the organisa-\ntion of an application. Table 7.1 identi\ufb01es some of these forms, as well as what\nneeds to be described for each of them.\nTABLE 7.1: Some forms of coupling used in construction\nForm of\nDescription\nCoupling\nInvocation\nThe key attribute being modelled here is that of transfer\nof control, whether this be between sub-programs (call-and-\nreturn), methods, processes, objects, services or any other\npackaging form related to executable code.\nUses\nThis is a rather general relationship which might involve var-\nious forms of dependency: invocation, obtaining data, using\ndata types or some combination of these. The important as-\npect is that this is direct usage rather than through forms\nsuch as inheritance.\nInheritance\nInheritance is usually associated with an object-oriented\nstyle and is concerned with reuse and adaptation of some\nexisting attribute.\nData Flow\nThis requires that two elements (often processes) share\nknowledge about the form of some data exchange.\nData Sharing\nAs implied, the coupling involves knowledge of some common\ndata forms or data itself.\n", "page": 117, "type": "text", "section": "Page 117"}
{"text": "Modelling Software Properties\n101\nNotations used to model this viewpoint may well combine di\ufb00erent forms\nof coupling (such as uses and inheritance. (These two forms can also be con-\nsidered as being rather more abstract than the other three.)\nMore generally, this viewpoint is largely concerned with modelling static\nstructures rather than with any form of run-time behaviour. Even when the\nform modelled is something like invocation, the concern here is what is being\ninvoked, not when it is invoked. And as a result, when we look at some exam-\nples in the following chapters, we will \ufb01nd that these are heavily in\ufb02uenced\nby architectural style.\n7.2.2\nThe behavioural viewpoint\nThis viewpoint is concerned with\ncausal relationships, connecting \u2018events\u2019\nto \u2018responses\u2019 via any necessary condi-\ntions. The associated notations tend to\nbe far more abstract than those used\nfor construction as the events and tran-\nsitions may involve operations that are\nspread across a number of di\ufb00erent con-\nstructional elements.\nMany behavioural notations can be considered as examples of \ufb01nite-state\nmachines, being concerned with the transitions that occur between di\ufb00erent\nstates of an application (such as waiting, processing, generating output etc.),\nand the changes in context (events) that are required to make these transitions\noccur. And being concerned with dynamic relationships, these forms are useful\nwhen describing the attributes of a design model that are concerned with time\nin any way. However, not all aspects of timing can be handled with equal ease:\n\u2022 aspects concerned with sequencing of events can be described fairly well;\n\u2022 descriptions related to \ufb01xed-interval events are also fairly tractable;\n\u2022 the e\ufb00ects of timing constraints are di\ufb03cult to represent.\nBehavioural descriptions do not necessarily require that the design model\nhas been elaborated beyond being able to provide a \u2018black box\u2019 description of\na system, particularly when thinking about events in the abstract. However,\nthey can also be used for quite detailed modelling of how system elements will\nbe a\ufb00ected by events, both internal and external, and as such, this class of\nrepresentations is an important one.\n7.2.3\nThe functional viewpoint\nOne of the harder tasks for a designer is that of describing just what an\napplication does. It is de\ufb01nitely more challenging than describing how it is\n", "page": 118, "type": "text", "section": "Page 118"}
{"text": "102\nSoftware Design: Creating Solutions for Ill-Structured Problems\nmade up of software elements (construction) or how it will behave when some\nevent occurs. This is largely because this viewpoint is closest to the actual\npurpose of producing the application and hence is strongly related to the\n\u2018problem\u2019 it is seeking to address (booking cars, providing an auto-pilot for an\naircraft, monitoring a patient\u2019s blood pressure, etc.) and so involves a strong\ndomain element.\nHowever, this is also something that is likely\nto be described quite well in the requirements\nspeci\ufb01cation, although again, how it can be de-\nscribed may be quite challenging. So functional\ndescriptions of a design model are apt to be ex-\npressed in terms of algorithms, data manipula-\ntion, and other software-related activities.\nThis also highlights one of the challenges for\nsoftware designers. One of the viewpoints that\neveryone would like to be able to model is prob-\nably the hardest one to model! So, much of this has to be captured in the other\nviewpoints, making use of those characteristics where relevant attributes over-\nlap.\n7.2.4\nThe data-modelling viewpoint\nWhile the description of data structures need not be a very signi\ufb01cant issue\nwhen undertaking architectural design (apart from when we are developing\nsuch intrinsically data-centric applications as database management systems\nof course), it is often an important aspect for detailed design. Important at-\ntributes that may need to be part of the design model include type (both in\ncompounding data types to create new ones and in such mechanisms as in-\nheritance, used to create new classes), sequence (in terms of structures such\nas trees and lists), and form.\nFor some classes of problem, the choice of data structures is a central\none and cannot be easily divorced from the functional aspects. Like construc-\ntion, data-modelling is largely concerned with static relationships, and so can\nsometimes be modelled using similar or the same notations as those used for\nconstruction.\n7.3\nDesign notations\nHaving brie\ufb02y discussed what we want to be able to describe about a design\nmodel, the next question is how this might be done? As noted earlier,three\nforms commonly used for design representations are:\n", "page": 119, "type": "text", "section": "Page 119"}
{"text": "Modelling Software Properties\n103\n\u2022 text\n\u2022 \u2018box and line\u2019 diagrams\n\u2022 mathematical expressions\nOf course, these are not mutually exclusive, and indeed, neither of the latter\nforms is likely to be of much use without a supporting textual component.\n7.3.1\nTextual description forms\nText is widely used as a means of summarising information, both when\nsketching and also when producing more formal descriptions. Ordered lists,\ntables, and highlight boxes, as used throughout this book, provide a ready\nmeans of presenting information. Two problems with using text on its own to\ndescribe aspects of a design are as follows.\n\u2022 Any structure that is implicit in the information can easily be obscured,\nunless it can be highlighted using lists, tables or boxes. Sub-headings\nand indentation can help to show structure, but may be less e\ufb00ective\nover long blocks of text.\n\u2022 Natural-language descriptions can easily be ambiguous, and structuring\ntext so as to avoid ambiguity can lead to the use of long and complex\nstructures.\nText is really most e\ufb00ective when used in small blocks and tables. We will\nuse some examples of these in the next chapters, but it is also worth noting\nthat the SSADM (structured systems analysis and design method) approach\nto plan-driven design is one that makes e\ufb00ective use of text through the use\nof standard pro-formas to record information about certain design decisions\n(Longworth 1992). (SSADM was developed to meet the needs of local and na-\ntional government agencies. Its designers recognised that these were organisa-\ntions where sta\ufb00were regularly transferred between projects and departments,\nand hence that design rationale could easily be lost when this occurred. So\nin specifying its procedures they took care to include the means of recording\nthese. We discuss SSADM further in Chapter 13.)\n7.3.2\nBox and line description forms\nWe have already seen various examples of box and line forms, and there\nwill be many more in the chapters that follow this one. As with text, diagrams\ndo bene\ufb01t from simplicity of form, and diagrams that contain a large number\nof symbols may be di\ufb03cult to comprehend. Box and line diagrams are easily\nsketched on a whiteboard or on paper, but of course, because of the invisibil-\nity of software they lack any ready visual link between their form and their\nmeaning. Curiously, despite a long history of using such forms for describing\n", "page": 120, "type": "text", "section": "Page 120"}
{"text": "104\nSoftware Design: Creating Solutions for Ill-Structured Problems\nsoftware, there would appear to be little or no research into their form and\nuse.\nMany widely used forms have a relatively small number of symbols, possi-\nbly re\ufb02ecting the issues underlying the \u2018magical number seven plus or minus\ntwo\u2019 discussed in Chapter 3. More abstract notations tend to have fewer sym-\nbols too.\nFor most users, diagrams are probably the most e\ufb00ective way of provid-\ning a clear summary of ideas about the abstract concepts and relationships\ninvolved in developing a design model. However, we should remember that\nthis is not guaranteed, and a poor diagram is no more helpful than a block of\nunstructured and ungrammatical text. Like text, diagrams have both a syntax\n(\u2018how we express an idea\u2019) and a semantics (\u2018what it means\u2019) and these need\nto be used correctly if ideas are to be conveyed to others. However, this should\nnot be over-emphasised, especially at the sketching phase of model develop-\nment. Diagrams being used to develop ideas often have very informal syntax\nand semantics, possibly being created as they are drawn, and these aspects\nonly become more important when we need to record ideas for others.\nIndeed, and sometimes frustratingly for a tool-creating culture such as\nsoftware engineering, this does limit the usefulness of software tools that can\nbe used to create diagrams. Because these tools often tend to enforce syntactic\nrules (or at least, don\u2019t necessarily permit free use of the notation), their most\nuseful role is probably one of record-keeping rather than diagram development.\nFIGURE 7.5: Hierarchy in diagrams\nA useful property of some of the more formal diagrammatical notations\nis that of a hierarchical organisation, shown schematically in Figure 7.5. This\noccurs where one or more forms of \u2018diagram element\u2019 can themselves be de-\nscribed in an expanded diagram of the same form. A hierarchical organisation\no\ufb00ers the advantage that diagrams can be \u2018layered\u2019 into levels of abstraction,\n", "page": 121, "type": "text", "section": "Page 121"}
{"text": "Modelling Software Properties\n105\navoiding large and complicated diagrams and so aiding comprehension. Again\nthough, this is probably of limited value when sketching, and mainly useful\nwhen creating diagrams using tools.\nTable 7.2 summarises the details of some well-known diagrammatical no-\ntations. Most of them are ones that we will encounter in the following chapters\nas we look at how to model some widely-used implementation forms.\nTABLE 7.2: A selection of box and line notations\nRepresentation\nViewpoints\nCharacteristics modelled\nData-Flow\nDia-\ngram (DFD)\nFunctional\nInformation \ufb02ow, dependency of operations\non other operations, relations with data\nstores.\nEntity-\nRelationship\nDiagram (ERD)\nData\nmod-\nelling\nStatic relationships between data entities.\nState\nTransition\nDiagram (STD)\nBehavioural\nState-machine model of an entity or system.\n.\nStatechart\nBehavioural\nSystem-wide state model, including paral-\nlelism (orthogonality), hierarchy and ab-\nstraction.\nJackson\nStruc-\nture Diagram\nFunctional,\nBehavioural,\nData\nMod-\nelling\nForms of sequencing employed for opera-\ntions, actions and data entities.\nStructure Chart\nConstructional\nInvocation hierarchy between subprograms.\nClass Diagram\nConstructional\nCoupling between classes and objects.\nUse\nCase\nDia-\ngram\nBehavioural,\nFunctional\nInteractions between an application and\nother \u2018actors\u2019.\nActivity Diagram\nBehavioural,\nFunctional\nSynchronisation and coordination between\nthe actions of an application.\nSequence\nDia-\ngram\nBehavioural\nMessage-passing between elements and in-\nteraction protocols.\n7.3.3\nMathematical notations\nMathematics (or at least, mathematical notation) o\ufb00ers scope to combine\nabstraction with a lack of ambiguity. Various notations for use in specifying\nthe properties of software have been proposed (a good account of the evolution\nof these forms, and the claims for some of them, is provided in the review by\nShapiro (1997)). These formal description techniques or FDTs have had some\nsuccess, particularly where there is a need to ensure the robustness of safety-\ncritical systems, preferably via rigorous proof mechanisms. Probably the best-\nknown formalism is the Z speci\ufb01cation language (Spivey 1998). There is a brief\ndiscussion of this in Chapter 18.\n", "page": 122, "type": "text", "section": "Page 122"}
{"text": "106\nSoftware Design: Creating Solutions for Ill-Structured Problems\nFDTs have particular strengths in describing system behaviour, as well as\nin handling some of the issues of time dependency. They can also be supported\nby tools that help with checking for such things as completeness. However,\ntheir use does require some training, as well as some familiarity with discrete\nmathematics, and so are best described in more specialist texts.\n7.4\nEmpirical knowledge related to viewpoint notations\nThe rather abstract nature of the material of this chapter means that\nthere are really no directly relevant empirical studies, although there are\nsome studies of speci\ufb01c notations or forms that we will cover in later chap-\nters. However, this is a good point to mention a conceptual tool that can\nbe useful when empirically evaluating the usefulness of notations\u2014cognitive\ndimensions, sometimes also termed cognitive dimensions of notations (Green\n& Petre 1996, Blackwell & Green 2003). This is a set of qualitative measures\nthat can be used to assess di\ufb00erent aspects of what is usually termed \u2018infor-\nmation representation\u2019, which of course includes those forms used to provide\nthe description of a design model, with the purpose of the dimensions being to\nprovide a set of \u2018discussion tools\u2019 for evaluation. Here we limit our description\nto the original set of 14 dimensions described in (Green & Petre 1996) (the\nsystematic review by Hadhrawi, Blackwell & Church (2017) provides a useful\nsummary of some of the key papers describing cognitive dimensions). Table\n7.3 identi\ufb01es the dimensions and provides a summary of their meanings. While\nthese are apt to be couched in terms of HCI (Human Computer Interaction),\nthey clearly also have something useful to o\ufb00er to design models in general.\nHere, we brie\ufb02y examine some simple examples of particular dimensions,\nand their application to the process of modelling.\nThe dimension of hidden dependencies is one that can be observed when\nmodelling some forms of architecture, and can re\ufb02ect a lack of clear encapsu-\nlation of design elements. This can be seen when we model \u2018call-and-return\u2019\nstructures. While our diagrams may indicate which elements are invoked by\na particular element, and the details of any parameters (arguments) used to\nconvey information between them, they may omit details of \u2018global\u2019 variables\nthat are also used to share information, and that can a\ufb00ect the way that the\nmodel operates.\nThe wide variety of software architectural styles can make it di\ufb03cult to\navoid some degree of premature commitment when designing software appli-\ncations. The choice of architectural style often needs to be made early in the\nprocess, and the need to work with other software applications can also in\ufb02u-\nence the choice of style. This in turn can then a\ufb00ect the order in which we\nneed to make further decisions.\n", "page": 123, "type": "text", "section": "Page 123"}
{"text": "Modelling Software Properties\n107\nTABLE 7.3: The cognitive dimensions\nDimension\nInterpretation\nAbstraction\nTypes and availability of abstraction mechanisms\nHidden dependencies\nImportant links between entities are not visible\nPremature commitment\nConstraints on the order of doing things\nSecondary notation\nExtra information provided via means other than for-\nmal syntax\nViscosity\nResistance to change\nVisibility\nAbility to view components easily\nCloseness of mapping\nCloseness of representation to domain\nConsistency\nSimilar semantics are expressed in similar syntactic\nforms\nDi\ufb00useness\nVerbosity of language\nError-proneness\nNotation invites mistakes\nHard mental operations\nHigh demand on cognitive resources\nProgressive evaluation\nWork-to-date can be checked at any time\nProvisionality\nDegree of commitment to actions or marks\nRole-expressiveness\nThe purpose of a component is readily inferred\nThe CCC and premature commitment\nThe concept of premature commitment resonates well with the idea\nof technical debt. In Chapter 1 we observed that we might model the\ninformation about the cars using a database or using a set of objects.\nThis is just the sort of architectural choice referred to above\u2014and the\nconsequences for other parts of the design model need to be considered\ncarefully before making a \ufb01nal choice.\nArguably some design notations are prone to di\ufb00useness (we will see this in\nthe next chapter) in the sense that the notations are overloaded with symbols\nor notational variations. This puts a greater cognitive demand upon the reader,\nwho needs to remember what a diamond in the middle of a line means, or what\nthe di\ufb00erence is between a continuous line and a dashed one.\nThis is very much an evaluation framework that can be applied (and has\nbeen) to design notations as well as to HCI design.\nKey take-home points about design modelling\nModelling involves creating an abstract description that re\ufb02ects the in-\ntended properties of a software application in a form that is visible, and that\ndescribes its di\ufb00erent attributes.\n", "page": 124, "type": "text", "section": "Page 124"}
{"text": "108\nSoftware Design: Creating Solutions for Ill-Structured Problems\nDesign models. Software is usually modelled by using some combination of\ndiagrams, text and formal mathematical notations. Each of these has its\nparticular strengths and limitations, and text in particular is often used\nto supplement the use of diagrams and mathematical forms.\nViewpoints. These e\ufb00ectively form \u2018projections\u2019 of the design model, de-\nscribing speci\ufb01c sets of attributes, and are realised through design nota-\ntions. Constructional, behavioural, functional and data-modelling view-\npoints form a useful and practical set of categories for the di\ufb00erent at-\ntributes.\nCognitive dimensions. These provide a useful set of concepts for evaluating\nthe form of particular notations, and their limitations.\n", "page": 125, "type": "text", "section": "Page 125"}
{"text": "Chapter 8\nSketching Design Models\n8.1\nWhy do designers sketch? ........................................\n109\n8.2\nSketching: developing informal models ..........................\n110\n8.3\nCharacterising the design elements ..............................\n112\n8.3.1\nSoftware design as an ISP ...............................\n112\n8.3.2\nSketching initial models .................................\n113\n8.4\nEmpirical knowledge about the use of sketching ................\n116\nKey take-home points about sketching ..........................\n117\nHaving considered how we can model di\ufb00erent properties and attributes of\nsoftware, in the three chapters that follow this one we bring together ideas\nabout architectural style and modelling to consider how the elements of an\napplication can be modelled. However, before doing so, we divert slightly to\nconsider the issue of sketching.\nThe role of this short chapter is to distinguish between the way that many\ntextbooks present the form of a design model, and the way that it is often\nproduced by designers. Modelling can itself be viewed as an ill-structured\nproblem, and in particular there are no right or wrong ways to describe a\nmodel. There are de\ufb01nitely times when we need a set of diagrams that conform\nclosely to well-established rules of syntax and semantics, but there are also\nmany times when something informal may quite e\ufb00ectively meet our needs.\nBoth are useful, the question is mainly when to use one or the other.\n8.1\nWhy do designers sketch?\nDesigners often produce \u2018rough\u2019 (in the sense of informal) sketches of their\nideas about design models to help them \u2018externalise their thoughts\u2019 (Petre\n& van der Hoek 2016). There are many reasons why designers use sketching\nto rough out their ideas. Sketching helps them with thinking through their\nideas, choosing between options, explaining their ideas to others, simulating\nexecution of an application, and generally exploring the problem space, as well\nas performing various other design-related tasks. So sketches can be used for\nexploration, re\ufb02ection and assessment, checking for completeness, and to assist\n109\n", "page": 126, "type": "text", "section": "Page 126"}
{"text": "110\nSoftware Design: Creating Solutions for Ill-Structured Problems\ncollaboration with others. And sketches allow these things to be done quickly,\npossibly \u2018on the spot\u2019, without needing to generate formal design documents\u2014\nindeed, in many ways, the use of sketches complements agile development in\navoiding formal document-driven practices.\nIn this book we are mainly concerned with the use of sketches for describ-\ning design models, although some of the other roles, especially re\ufb02ection and\nassessment, also play a part in design. We also need to recognise that these dif-\nferent roles are interdependent\u2014for example, deciding between design choices\nmight need some exploration of the problem space to clarify requirements,\nor the use of mental execution to assess how each option will perform under\ndi\ufb00erent conditions.\nSo, while we do emphasise the use of sketching in this book, our use of it\nis by no means completely representative of the many ways in which it can\nbe employed during software development. (For more examples of these, see\nthe discussion in the introduction to the study by Mangano, Toza, Petre &\nvan der Hoek (2015).) And in this part of the book, we are mainly concerned\nwith how our sketches can be used to think about the di\ufb00erent properties\nrequired from the design elements themselves.\n8.2\nSketching: developing informal models\nIn Chapter 4, we noted that one of the characteristics that distinguished\nexpert designers was that they sketched (Petre & van der Hoek 2016).\nAnd that is why, when introducing the City Car Club at the start of the\nbook, we also observed that the illustrations related to the CCC would\nusually make use of informal sketches, rather than being in the form of\nneatly produced diagrams. Sketching is what designers do, but despite\nthat, learning to sketch is something that is rarely part of any curriculum.\nSketching is what designers do\nSo, why do designers sketch? Well, chie\ufb02y\nto ensure that they get the design model\nright, or at least, as right as they can within\nthe context of their understanding of the\nproblem and its context. This is what mat-\nters, not the production of neat diagrams,\nuseful though these might be at a later\nstage (Petre 2013). (Much the same thing\noccurs when an author is producing a novel,\nthey focus on the plot and the writing, not\non producing a beautiful example of word-\nprocessing.) And working with sketches that\nare easily changed does emphasise that the\n", "page": 127, "type": "text", "section": "Page 127"}
{"text": "Sketching Design Models\n111\ndesign process is one based upon the dynamic and opportunistic evolution of\nideas about the design model.\nOne thing that sketching a design model (or part of one) does is to loosen\nthe constraints of syntax. If a designer wants to sketch out an idea based on\n(say) using a particular set of classes and objects, and chooses to use ovals\nto represent classes while simply labelling the arcs between these to indicate\nwhat form of coupling is being employed, then if it helps the designer work\nout their ideas, doing this is \ufb01ne. And it may even be quite acceptable for\nthem to use such diagrams to discuss their ideas with others. In a sketch it\nusually doesn\u2019t matter what shape is being used for a particular item\u2014and\nthe same sketch may be used to represent a variety of attributes.\nSketches may well be accompanied by textual notes (these are often essen-\ntial) and also by more structured forms of note such as lists, as was observed\nin the study of expert designers led by van der Hoek & Petre (2014). Extensive\nuse of lists was also noted in a later study by Mangano et al. (2015), where it\nwas noted that lists were often used in preference to diagrammatical notations\nthat could present a more complete picture of the designer\u2019s ideas.\nHowever, if our sketches do use an informal syntax, there is a need to ensure\nthat the meaning of it is retained in some way, usually by means of annotation.\nThe value of sketching lies in developing and talking through ideas about a\ndesign model, the value of syntax lies in helping us to understand those ideas\nas expressed through the design model. So if the syntax is informal or in a\nnon-standard form, the form being used does need to be explained in some\nway. (There is an assumption here that sketches, although they are informal,\nare not throw-away items. Indeed, since they embody the history of the way\nthat a design has evolved\u2014including any ideas explored and then discarded\n(and the reasons why)\u2014there is an argument that they should be preserved\nin some way.)\nAnother bene\ufb01t of sketching is that it also helps overcome cognitive limi-\ntations. Miller\u2019s \u2018Magical Number Seven\u2019 that we discussed in Chapter 3 may\nnot directly relate to this issue, but the idea of helping to manage the cog-\nnitive load imposed by developing a design model that it incorporates does.\nIt simply isn\u2019t practical to hold a complete design in one\u2019s head unless it is\nvery small, but a sketch may well be enough to help the designer recall their\nintentions about di\ufb00erent elements, as well as to be reminded of earlier deci-\nsions. And such a sketch may well provide support for \u2018mental execution\u2019 and\nfor checking a design for completeness.\nIn the rest of this chapter we address the question of what features of\na design model should (or might) be sketched. The following chapters then\ndescribe some more \u2018formal\u2019 notations, but fairly informally!\n", "page": 128, "type": "text", "section": "Page 128"}
{"text": "112\nSoftware Design: Creating Solutions for Ill-Structured Problems\n8.3\nCharacterising the design elements\nThe choice of architectural style plays an important role in determining\nmuch of what the designer wants to model. In particular, it determines the\nforms of \u2018packaging\u2019 used with particular styles, and the mechanisms that the\ndi\ufb00erent elements making up an application will use to communicate with\neach other. So not surprisingly, we \ufb01nd that the way that the constructional\nand data-modelling viewpoints are organised will be very strongly in\ufb02uenced\nby architectural style.\nWhen we consider the behavioural viewpoint, this is much less the case,\nalthough not entirely so. Behavioural descriptions tend to be rather \u2018black\nbox\u2019, and hence are less concerned with mechanisms than with e\ufb00ects. And to\nsome extent this is also true for the functional viewpoint, where issues related\nto what is to be done are of more concern than how it is to be achieved.\nAnd there are other forms of interaction too. Where design elements are\nloosely coupled, the designer may need to consider how their interactions are\nto be synchronised. While we will not explicitly address real time aspects in\nthis book, for some systems these are of critical importance, although acting\nlargely as an external constraint upon how a model is realised rather than\ndetermining the form of the model itself. Again, this is where sketching (along\nwith note-making) may be preferable to complex syntax, at least for forming\ninitial ideas.\n8.3.1\nSoftware design as an ISP\nFigure 8.1 is a re-interpretation of part of a \ufb01gure that we encountered\nin Chapter 1 that described the process of design as an ISP. (To keep the\ndiagram from becoming too cluttered, not all lines have been included for the\ndata modelling viewpoint.) Now that we have an explicit viewpoint model,\nwe can use this to be more speci\ufb01c about the form of the design model used\nto represent a software application. However, we should also note that there\nmay be other elements of the design included in the model and also that we\nmight use more than one diagrammatical form when modelling a particular\nviewpoint.\nAs a simple illustration of this interconnectedness of the model, consider\nthe following scenario from the CCC.\n", "page": 129, "type": "text", "section": "Page 129"}
{"text": "Sketching Design Models\n113\nproblem\nspace\nproblem \nView 1\nproblem \nview 2\nproblem \nview 3\nfunctional\nmodel\nbehavioural\nmodel\nconstruction\nmodel\nexternal design\nknowledge and problem\nexpertise used to create\nthe model elements\nexternal design\nknowledge and problem\nexpertise used to create\nthe model elements\nproblem \nview 4\ndata\nmodel\nElements of\nThe design model\nFIGURE 8.1: Software design as an ISP\nThe CCC needs a time-out\nIn developing the behavioural model, the designer(s) realise the need\nto have some form of \u2018timeout\u2019 event, so that if a booked car is not\nclaimed for use within a given period (one that is long enough to allow\nthe user to locate the car and access it), then the booking will be\ncancelled. This then requires that the functional model be changed to\nincorporate the setting and clearing of a timer, and that performing\nthese tasks needs to be allocated to some elements of the constructional\nmodel.\n8.3.2\nSketching initial models\nBefore looking at some of the di\ufb00erent modelling notations and how they\nare employed, we should return to this chapter\u2019s theme of sketching. Sketches\ncan often provide a preliminary form of design model, used to clarify ideas\nas well as to form the basis for more \u2018formal\u2019 descriptions of the di\ufb00erent\n", "page": 130, "type": "text", "section": "Page 130"}
{"text": "114\nSoftware Design: Creating Solutions for Ill-Structured Problems\nviewpoints. And of course, since such sketches may well never be elaborated\nmore formally, they may also constitute all or part of the design model too.\nFIGURE 8.2: A very early sketch for the CCC\nAn important characteristic of many such sketches is that they are\n\u2018architecture-neutral\u2019. If we look at the example in Figure 8.2 of the very\npreliminary sketch for the CCC that we met earlier, we can see that in this\nvery early phase of thinking, ideas are open about what sort of elements\nthe shapes represent from an operational perspective. Beyond the high-level\nabstractions, they could well be (combinations of) objects, processes, sub-\nprograms, . . . What matters is that the design elements are intended to work\ntogether to process some form(s) of input and perform such tasks as making\nbookings.\nFurther sketches can then be used to create user stories, whereby various\nscenarios of use are used to \u2018execute\u2019 the design model. These stories can\naddress such tasks such as making a reservation, \ufb01nding a car etc., and may\nlater form the basis for more formal \u2018story boards\u2019 (these are discussed later).\nDoing so allows the designer to also build up lists of issues that will need to\nbe considered when getting into more detail about the elements, and these\nlists also form part of the early design model.\nSketches and lists can also be used to help the designer clarify their ideas\nabout some item. Figure 8.3 shows how the designer might use the model in\nFigure 8.2 to help them think through issues related to the process of booking\nand using a car. Note particularly that the ideas do not necessarily come in a\nneat order: having thought through the main steps, the designer then starts\nto ask questions (such as \u2018how do we \ufb01nd a car we have booked?\u2019).\n", "page": 131, "type": "text", "section": "Page 131"}
{"text": "Sketching Design Models\n115\nFIGURE 8.3: Listing ideas about the model\nAnd while this may not appear as architecture-neutral as all that (implic-\nitly, it already looks like a client-server model), it is important to remember\nthat there might be other ways of creating such a system. While it might seem\nunlikely, the CCC could instal small booths in the streets that users could use\nto make bookings instead of using mobile phones.\nThe sketch in Figure 8.4 below summarises some of the things that char-\nacterise the use of sketches when used for modelling design solutions. It may\nbe useful to keep these points in mind when reading through the following\nchapters. As already observed, these forms are very likely to be the even-\ntual outcome from sketches, not something that we start with. And of course,\nthese are \u2018advice\u2019 rather than \u2018rules\u2019 for sketching, since the whole point about\nsketching is that there are no rules!\nThe following chapters examine a variety of di\ufb00erent modelling forms. We\nbegin by looking at those forms commonly developed for describing processes,\ngo on to look at the rather more complex world of object-oriented modelling\nand then take a rather briefer look at how we can model components and\nsoftware services. However, the divisions between these are certainly not set\nin stone. Rather as design sketches can often be architecture-neutral, so we\ncan often use notations in a context that is quite di\ufb00erent to the one for which\nit was developed, as we will see when we look at software services.\n", "page": 132, "type": "text", "section": "Page 132"}
{"text": "116\nSoftware Design: Creating Solutions for Ill-Structured Problems\nFIGURE 8.4: Advice about sketching\n8.4\nEmpirical knowledge about the use of sketching\nThe use of sketching is something that is of interest to a number of research\ncommunities, particularly those concerned with the intersection between com-\nputing and the \u2018soft skills\u2019 used to study human behaviour.\nSketching plays quite an important role in the book on designer behaviour\nfrom Petre & van der Hoek (2016). And the more formal study from the same\nauthors (acting as editors) provided in van der Hoek & Petre (2014) contains\na number of papers that consider issues related to sketching.\nThe paper by Mangano et al. (2015) provides an excellent discussion of\nthe di\ufb00erent roles of sketching in its introduction, and also provides a valuable\nbibliography in its references. Given the lack of an authoritative systematic\nreview on this topic at the time of writing, this paper probably o\ufb00ers one of\nthe best overviews available.\nIt is worth noting that, while there have been some useful laboratory-based\nstudies in recent years, generating much of the source material referenced\nabove, there is a distinct shortage of observational studies, and longitudinal\ncase studies in particular. That isn\u2019t to imply that the laboratory studies\nhave less value, and indeed, researchers have taken care to establish that what\noccurs is typical of designers\u2019 experiences. However, it may well be that longer-\nterm observational studies could uncover new and richer seams of knowledge\nabout this fascinating topic.\n", "page": 133, "type": "text", "section": "Page 133"}
{"text": "Sketching Design Models\n117\nKey take-home points about sketching\nThe informal nature of sketches means that there are no rules! However,\nhere are some potentially useful suggestions about performing sketching of\ndesign models.\nSyntax and semantics. These should be treated lightly\u2014a sketch is there\nto help formulate ideas, and (possibly) to help communicate those ideas\nto others. So words can be used to replace syntax and semantics when\ninterpreting a sketch.\nNotes. These should be used freely, and use of more \u2018structured\u2019 forms such\nas lists and tables too.\nUser stories. These can help with mental execution and can themselves be\nsketched (these latter sketches may then be the basis for the \u2018story\nboards\u2019 we discuss in a later chapter).\nRecording. Keep sketches (ideally, date them too) so that they can form\npart of the design history, particularly where they incorporate design\ndecisions. The rationale for the latter is easily lost, and preserving that\ndesign knowledge can be important for future evolution of an applica-\ntion.\n", "page": 134, "type": "text", "section": "Page 134"}
{"text": "Chapter 9\nModelling Software Processes\n9.1\nCharacteristics of software processes ............................\n119\n9.2\nModelling function: the data-\ufb02ow diagram (DFD) ..............\n121\n9.3\nModelling behaviour: the state transition diagram (STD) and\nthe state transition table (STT) .................................\n126\n9.4\nModelling data: the entity-relationship diagram (ERD) .........\n130\n9.5\nModelling construction: the structure chart .....................\n134\n9.6\nEmpirical knowledge about modelling processes ................\n136\nKey take-home points about modelling processes ...............\n137\nThere are many needs that can well be met by applications that are organised\nas processes. So, having considered how we can describe di\ufb00erent properties\nand attributes of software, both formally and informally, we now bring to-\ngether ideas about architectural style and modelling to consider how we can\nmodel the characteristics of an application that is to be implemented as a\nprocess.\nThis chapter provides a fairly generic summary of how to model the di\ufb00er-\nent aspects of this relatively simple form of software element, since processes\ncan be organised and implemented in di\ufb00erent ways, and can be realised in a\nrange of architectural styles. Indeed, an important thing to remember is that\na distinctive characteristic of software is that a \u2018one size \ufb01ts all\u2019 approach is\nde\ufb01nitely inappropriate, and that the choice of modelling forms to use needs\nto be adapted to the particular form of ISP being addressed.\n9.1\nCharacteristics of software processes\nIn order to model software processes, it helps to have a fairly clear idea\nof just what is meant by a \u2018process\u2019. From the perspective of an operating\nsystem, a process can be considered as being an executable block of code and\nassociated data, that is created from some user-owned software application\nand is executed as a single thread of control. This interpretation can be seen\nas being closely related to the way that the underlying computer operates,\n119\n", "page": 136, "type": "text", "section": "Page 136"}
{"text": "120\nSoftware Design: Creating Solutions for Ill-Structured Problems\nand so historically, was a form widely used in early computing applications,\nand is still widely used today.\nAt its most simple, and most closely related to the structures of the un-\nderlying processor, this can be implemented by using a call-and-return archi-\ntectural style. This interpretation also \ufb01ts quite well with such architectural\nforms as communicating-processes, where an application might be formed by\nusing multiple processes, perhaps operating in a pipe-and-\ufb01lter manner, with\neach performing its task and then passing the outcomes on to the next one.\nHowever, since the individual processes in a communicating process structure\nmay well be implemented by using call-and-return, we will focus on modelling\nthis type of process in the rest of this chapter.\nThe key point about a process is that it has a single thread of control.\nExecution of a process begins with the \ufb01rst instruction, and follows a single\nsequence or path through the instructions. That sequence may be di\ufb00erent\neach time it executes of course, depending on data and other factors, but for\nthe \u2018main\u2019 program element, and for any sub-programs, execution will always\nbegin at the \ufb01rst statement.\nFigure 9.1 shows a very simple illustration of this for a program made\nup from a main body and two sub-programs (A and B). On this occasion,\nsub-program A is invoked twice, the second time exiting from an intermediate\npoint, with the thread of control, shown as a dashed line, forming a single\npath.\nStart execution\nEnd execution\nProcess\nSub-program A\nSub-program B\nSub-program A\ncall\nreturn\nFIGURE 9.1: Simple illustration of a single thread of control\n", "page": 137, "type": "text", "section": "Page 137"}
{"text": "Modelling Software Processes\n121\nSo, how can we model the way that this is organised in the abstract?\nThe functional viewpoint can be used to describe the task that the process is\nperforming, and the constructional viewpoint can be used to indicate how the\ntasks and sub-tasks involved are organised, as well as any issues related to data\naccess. Additionally, the behavioural viewpoint may also aid with modelling\nhow the process interacts with the external world, and the data modelling\nviewpoint can be used where there are important relationships in the data\nthat may have an in\ufb02uence upon the structure of the process.\nThe issue of data organisation may be rather implementation-speci\ufb01c. For\nmany programming languages permanent data storage can only be provided\nwhere variables are declared in the \u2018main\u2019 body of the program, with variables\ndeclared in the sub-programs only being created when that sub-program is\nexecuting. This means that knowledge about the structure, format and values\nof any data involved will be global in nature and shared among the elements\nof a process.\nA disadvantage of this sharing of knowledge about data is that it forms a\ntechnical debt that can impede later evolution of an application. This issue was\ndemonstrated by David Parnas (1972), with his ideas later being extended in\n(Parnas 1979). His crucial insight that systems constructed around informa-\ntion hiding, whereby the detailed form of data elements was only known to a\nfew key parts of a system, made it easier to change software was a very im-\nportant one, and one that underpinned the emergence of the object-oriented\nparadigm. (Of course, there is a trade-o\ufb00, in that using this approach can be\nexpected to result in a more complex set of structures for the organisation of\nthe process, in order to maintain this concealment of detail.)\nWhile information-hiding is associated with the object-oriented paradigm\nand the concept of encapsulation, it is worth noting that in (Parnas 1972)\nthe example solution was presented as a top-down design for a process. So\nconstructing single-threaded processes around information hiding is certainly\npossible, but few procedural programming languages really provide explicit\nsupport for its use.\n9.2\nModelling function: the data-\ufb02ow diagram (DFD)\nThe design of processes commonly begins with the functional viewpoint,\nsince this \ufb01ts well with the idea of a single thread of control that involves\nspecifying what the process is to do. Modelling the functional aspects of a\nprocess has a domain-oriented element and hence has clear links to require-\nments speci\ufb01cation activities. One way of describing function is to do so in\nterms of the way that di\ufb00erent actions performed by the process interact with\nthe various forms of information (data) that form a necessary part of the task\nof an application. Hence, what is usually termed the data-\ufb02ow perspective,\n", "page": 138, "type": "text", "section": "Page 138"}
{"text": "122\nSoftware Design: Creating Solutions for Ill-Structured Problems\nmixing actions and data, is one that has provided a highly e\ufb00ective way to\ndescribe the functional viewpoint for many di\ufb00erent domains.\nThe data-\ufb02ow approach to modelling function probably long pre-dates\nthe use of digital technology, and it is thought such forms may well have\nbeen used in the 1920s to model the way that teams of workers in businesses\nwere organised when performing their tasks (Page-Jones 1988). This may or\nmay not have been the case (the evidence seems to be largely folklore), but\nthe point remains that data-\ufb02ow forms can be used to model many data-\ndriven activities performed by people (such as processing insurance claims,\nor assembling \ufb02at-pack furniture) just as e\ufb00ectively as they can be used for\nmodelling the activities performed by software and their interactions with\ndata.\nThe name might be thought to imply that a DFD is primarily concerned\nwith the data-modelling viewpoint, but the real issue here is describing the\noperation of a system from the perspective of the transfer of information,\nrather than being concerned about its form. DFDs are not really concerned\nwith modelling the form of the data, but the fact that they are concerned\nabout how it is used does suggest that they do incorporate some element of\nthe data-modelling viewpoint.\nWhen we look at plan-driven approaches to creating design models in\nChapter 13, we will see that DFDs formed a popular starting point for many\nearly approaches, ultimately mapping on to call-and-return implementations\n(Wieringa 1998). However, that doesn\u2019t mean that they can\u2019t be used with\nother architectural forms or development strategies (for example, they \ufb01t quite\nwell with service-oriented architectures). In particular, where an application\nis strongly data-centric, they have the bene\ufb01ts of being:\n\u2022 easy to sketch and comprehend (so, handy for describing \u2018user stories\u2019);\n\u2022 useful for clarifying what an application should do, and identifying any\ndependencies upon other processes or information that this may involve.\nDFDs can also be drawn with a range of degrees of formality. The \u2018bubble\u2019\nform we use here, as popularised by Tom De Marco (1978) is relatively informal\nand easy to sketch. This is partly because it also makes good use of di\ufb00erent\nshapes to di\ufb00erentiate between the elements making up a diagram (Moody\n2009). In contrast the syntax employed for DFDs in the SSADM (structured\nsystems development and analysis method) (Longworth 1992), is rather more\nformal and \u2018documentation-oriented\u2019 (see Chapter 14).\nWhile DFDs are often thought of as being used to describe complete appli-\ncations, there is really no reason why they should not be used more selectively\nto help clarify and understand elements of an application or its requirements.\nRegardless of the scope of a DFD, the top level of this is normally referred\nto as the context diagram, consisting of a single \u2018bubble\u2019 linked to a set of\nexternal sources and sinks of information. This is illustrated in Figure 9.2,\nwhich shows a context diagram for the operation of withdrawing cash from a\n\u2018hole-in-the-wall\u2019 dispenser.\n", "page": 139, "type": "text", "section": "Page 139"}
{"text": "Modelling Software Processes\n123\nCash\nDispenser\nCard\nreader\nCustomer\nCash\nHoppers\nBank Records\nmakes requests; \ngets reports\nstatus reports;\ndispense \ncommands\nrequests status;\nupdates account\nprovides card\ndetails\nFIGURE 9.2: The context diagram for a cash withdrawal\nThis illustrates the four main symbols used in a DFD: the circle or \u2018bubble\u2019\ndenoting an operation; an arc indicating data \ufb02ow (usually labelled with the\nform of data involved); parallel bars to show the use of some form of data\nstore; and a box used to indicate the involvement of an external source or sink\nof information.\nTurning now to the CCC, the box below shows the \ufb01rst steps in modelling\na client request to book a car.\nReserving a car\u2014the context diagram\nThe \ufb01gure below is something of a mix between a formal context di-\nagram and a sketch. The focus in this \ufb01rst cut at a context diagram\nis on determining the information that is needed, with less emphasis\nupon its actual source. Having identi\ufb01ed what information is needed,\nit is then possible to begin thinking about how it will be acquired, as\nwell as what will need to be output.\n", "page": 140, "type": "text", "section": "Page 140"}
{"text": "124\nSoftware Design: Creating Solutions for Ill-Structured Problems\nIn expanding the context diagram to produce a more detailed and com-\nprehensive model, we need to ensure that the next level of diagram will use\nthe same inputs and outputs (of course, in the spirit of ISPs, it might be\nthat in thinking about this, the designer realises that the context diagram\ndoesn\u2019t cover all issues). Figure 9.3 provides an expanded DFD for the pro-\ncess of booking a car. Note that control issues are not described, so where, as\nin Bubble 5 reserve car, there might be two possible outcomes, depending\non whether or not the chosen car has been booked out to someone else while\nthe user is making their choice, we just draw all possible outcomes and use\nthe text in the bubble to indicate that a choice occurs.\nExperts focus on the essence. PvdH #37\nFIGURE 9.3: An expanded DFD for booking a car\n(There is also the possibility that no car is available. This option can\nbe considered as being included under confirm to customer, but it is poor\n", "page": 141, "type": "text", "section": "Page 141"}
{"text": "Modelling Software Processes\n125\npractice to make such actions cover compound issues. So there should probably\nbe another exit bubble to cope explicitly with the possibility that either no\ncars are available in the vicinity, or that there are no cars available by the\ntime that the customer has made a choice\u2014the reader might like to extend\nthe diagram to handle this.)\nA strength of DFDs is that they are intrinsically hierarchical. We can\ntake one bubble (for example, 3. Identify available cars) and expand\nthis as a further, more detailed DFD. The bubbles in this new diagram will\nbe numbered as 3.1, 3.2 etc. Being able to do this helps with managing the\ncognitive load of thinking about function, since the designer only needs to\nconsider a limited set of actions at any point. At the same time, the resulting\n\u2018tree\u2019 of diagrams aids navigation around the design model at di\ufb00erent levels\nof detail.\nExperts solve simpler problems \ufb01rst. PvdH #2\nWhen developing a DFD, it is useful to start by modelling the \u2018physi-\ncal\u2019 world (in our case, cars and customers) and then later seek to describe\nthis more abstractly in terms of system functions as we move on to consider\nmapping the model on to software elements. (The corresponding DFDs are\nreferred to as \u2018physical DFDs\u2019 and \u2018logical DFDs\u2019 respectively.) And as a \ufb01nal\ncomment upon creating DFDs for the present, it is worth observing that while\nlayout can be a bit of a challenge (as with any such diagram), the same philos-\nophy should apply as when sketching in general. Don\u2019t worry if the diagram\nhas things like crossing \ufb02ow lines\u2014if the diagram does become too messy and\nthis begins to obscure the ideas it incorporates, it may be worth redrawing it,\nbut otherwise, leave this task until later.\nFigure 9.3 emphasises the issue of there being a single thread of control.\nFor any booking action there will be a single path through the DFD. The\nDFD can also be used with scenarios of use (Ratcli\ufb00e & Budgen 2001, Rat-\ncli\ufb00e & Budgen 2005) that de\ufb01ne the conditions for speci\ufb01c execution paths,\nand which can also be combined with user stories both for developing and\nvalidating the DFD.\nDFDs are easy to sketch, and as in the examples above, they do not nec-\nessarily need to be large and complex. They also provide a tried and tested\nway of thinking about the functions of a process. However, they implicitly\nassume the widespread availability of knowledge about the data, and so are\nless suited to modelling the encapsulation of data needed with object-oriented\narchitectures.\n", "page": 142, "type": "text", "section": "Page 142"}
{"text": "126\nSoftware Design: Creating Solutions for Ill-Structured Problems\n9.3\nModelling behaviour: the state transition diagram\n(STD) and the state transition table (STT)\nThe idea of state is quite a familiar one. As an everyday example, we\nthink of ourselves as being in a sleeping state when we are asleep, and\nin an awake state when we are not sleeping. And there are events causing\ntransitions between these that are familiar to us, such as that caused by an\nalarm clock, or listening to a dull speaker in a warm room! We might also\nidentify some other related states such as day-dreaming or dozing, which\ncan be considered as being sub-states of a major state (in this case awake).\nThis is shown as a simple model in Figure 9.4.\nFIGURE 9.4: An everyday state model\nWithin computing, some classes of problem (and solution) can usefully be\ndescribed and modelled by treating them as a \u2018\ufb01nite-state machine\u2019. Such a\nmodel can be considered as one that describes a running application as being\nin one of a \ufb01nite set of possible states, with external (and internal) events\nproviding the triggers that can lead to transitions occurring between those\nstates.\nA process (as well as a data element or object) in a computer \ufb01ts this\nquite well. In a formal sense, the \u2018state\u2019 of a process at any point can be\nfully described in terms of the contents of any variables that it uses, and the\n\u2018program counter\u2019 that determines which instruction is to be executed next,\nalthough we usually prefer to use rather more abstract descriptions of state.\nAnd using a \ufb01nite-state form of description to think about the properties of a\nprocess enables us to model the \u2018rules\u2019 which govern its behaviour. Indeed, an\nimportant aspect of such models is that they not only describe the transitions\nthat are allowed to occur, but also those that should not be able to happen.\n", "page": 143, "type": "text", "section": "Page 143"}
{"text": "Modelling Software Processes\n127\nAnd of course, as a general constraint, an entity can only be in one state at\nany time.\nWe have already seen an example of state modelling when describing the\ndi\ufb00erent states that one of the cars owned by CCC can be in. A car can\nbe available, reserved, or unavailable. This is quite a simple model, and\ndoesn\u2019t really allow us to describe some of the situations that might arise, such\nas when a car is unavailable because it is damaged, or needs servicing. While\nthat can be considered as being unavailable as far as modelling customer\nactivities is concerned, it isn\u2019t really su\ufb03cient to meet all of the needs of the\nCCC. (And, as we saw when considering the DFD for booking a car, what\nshould happen when two customers are o\ufb00ered the same car, when it is near\nto both of them?)\nFIGURE 9.5: An extended state model for a car as an STD\nFigure 9.5 shows an example of a state transition diagram that provides\na slightly more comprehensive model that describes the di\ufb00erent states of a\ncar. It uses the notation developed by Ward & Mellor (1985) in which there\nare four principal components.\n", "page": 144, "type": "text", "section": "Page 144"}
{"text": "128\nSoftware Design: Creating Solutions for Ill-Structured Problems\n\u2022 A state represents an externally observable mode of behaviour for some\nentity, and is represented by a box which is labelled to indicate that\nbehaviour.\n\u2022 A transition is described by an arrow, identifying a \u2018legal\u2019 change of state\nthat can occur within the entity.\n\u2022 The transition condition that identi\ufb01es the condition(s) that can lead to\na transition are written next to the arrow, above the line.\n\u2022 The transition action is written by the arrow, but below the line, and\ndescribes any actions that may occur as a result of the transition. There\nmay be several of these, and they might occur in a sequence or simulta-\nneously.\nThis model has two states that are additional to the original set, re\ufb02ecting\nthe possibilities that at the end of a session a car may require maintenance\n(perhaps because a routine service is due, or simply because the fuel level is\ntoo low); and that it might have been left outside of the area covered by the\nCCC, and require retrieval. Both of the new states can be considered as being\nforms of unavailable, a point we will return to later.\nWe have modelled the car as an STD in this instance, but could equally\nwell model something \u2018active\u2019 such as an application or process. The value of\nusing state modelling is that it creates a behavioural model that can be used\nto complement the functional model provided by using a form such as a DFD.\nFor example, a state model can help with clarifying the \u2018rules\u2019 that determine\nwhich choices can be made when the process executes. There are no hard and\nfast rules about how and when to use an STD when modelling processes. It\nmay be useful to begin by creating a very abstract \u2018system-wide\u2019 STD to help\nthinking about the functional tasks that the process needs to perform. Or\nit may be helpful at a later stage to use an STD to focus ideas about how\nsome aspect of the application needs to behave (such as the example above of\nmodelling the car).\nModelling the behaviour of a process (or more likely, speci\ufb01c elements of\nit) in this way provides both a means of augmenting the design model as well\nproviding a means of performing consistency checking that all options have\nbeen considered. Essentially it is supplementary, since it doesn\u2019t usually lend\nitself to helping with developing the constructional model in the way that\noccurs with a DFD (we discuss this more fully in Chapter 13). In particular,\nSTDs are not hierarchical in form and so for practical reasons, they are likely\nto be most e\ufb00ective when used to model elements of an application\u2019s task.\nExperts test across representations. PvdH #54\nFigure 9.6 provides a further example showing a rather more complex (but\nstill incomplete) model, in this case for the behaviour of an aircraft forming\n", "page": 145, "type": "text", "section": "Page 145"}
{"text": "Modelling Software Processes\n129\nin flight\nstacked\nlanding approach\non runway\non ground\nSTACK\njoin at set\nposition\nCLEARED \nTO LAND\nselect path;\nadjust flaps;\nlower\nundercarriage\nCLEARED TO LAND\nselect path;\nadjust flaps;\nlower undercarriage\nCANCEL\nLANDING\nclimb to\nset height\nTAKE OFF\nlift undercarriage;\nset course;\nclimb to set height\nTOUCH DOWN\nreverse thrust;\nbrake\nPARK\ntaxi to stand\nCANCEL TAKEOFF\nclose throttle\nbrake\nturn off runway\nCLEARED FOR TAKEOFF\nline up on runway;\nrelease brake;\nopen throttles\nFIGURE 9.6: An example of an STD modelling aircraft behaviour\npart of an air tra\ufb03c control system. The short arrow at the top indicates the\ninitial state (when the aircraft \ufb01rst enters the airspace and is detected by the\nprimary radar). There are two sources of complexity here: one is the number\nof actions that an aircraft might take (including \ufb02ying through the airspace\nand onwards, being stacked etc.) and the other is the number of operations\n(actions) performed in each transition (this is simpli\ufb01ed here of course).\nWhile STDs provide a useful visual description of how entities in a model\nchange their state, and the operations that are involved in those changes, as\nwell as being easily sketched, the lack of a hierarchical decomposition means\nthat they can rapidly become inconveniently complex in form. An alternative,\nbut less visual, way of presenting this information is to use a table, known\nas a state transition table or STT. A common convention for these is to plot\nthe set of states down the left-hand column, and then the set of events as the\ncolumn headers for the remaining columns. Entries in the table can describe\nboth the actions to be performed and also the \ufb01nal state that results when a\nparticular event occurs for a given initial state.\nAs an example, the model in Figure 9.5 is shown in tabular form in Table\n9.1. While a state transition table provides essentially the same model as an\nSTD (or can be used to do so), it can more easily be used where it is necessary\n", "page": 146, "type": "text", "section": "Page 146"}
{"text": "130\nSoftware Design: Creating Solutions for Ill-Structured Problems\nTABLE 9.1: An STT for the model of a car\nMake\nEnd of\nEntry key\n20 minute\nbooking\nsession\nused\ntime-out\nAvailable\nRecord\nthe\nbooking;\nstart 20 min\ntimer; change\nto\nreserved\nstatus\nReserved\nRefuse\nbook-\ning\nCancel book-\ning\nand\nre-\nturn to avail-\nable status\nRecord\nstart\ntime\nof\nses-\nsion\nand\nlo-\ncation; change\nto unavailable\nstatus\nNotify\nuser\nof\ncancelled\nbooking;\nchange\nto\navailable\nUnavailable\nRefuse\nbook-\ning\nRecord\nend\ntime and loca-\ntion;\nchange\nto\navailable\nmode\nto handle issues of scale, or of many possible transitions between a relatively\nsmall number of states.\nAdditionally, the issues of veri\ufb01cation and validation can be more system-\natically addressed through analysis of an STT (\u2018are we building the system\nright\u2019 and \u2018are we building the right system\u2019) (Boehm 1981). An STT makes\nexplicit those situations where we do not expect there to be a response to a\nspeci\ufb01c event, since these correspond to an empty cell, and even as simple\nan act as checking and justifying all empty entries can be a useful form of\nanalysis. In particular, when there is a need to discuss these with the \u2018cus-\ntomer\u2019, tabulation may be easier to use than diagrams\u2014software engineers\ndraw diagrams all the time, but others might be less comfortable with their\nuse.\n9.4\nModelling\ndata:\nthe\nentity-relationship\ndiagram\n(ERD)\nThe data-modelling viewpoint also plays a rather subsidiary role when\nmodelling processes, except of course, when a process is an element in an\napplication that has an overall data-centric style. A form that is widely\nfor modelling the relationships that exist between static data elements in\n", "page": 147, "type": "text", "section": "Page 147"}
{"text": "Modelling Software Processes\n131\na speci\ufb01cation model or a design model is the entity-relationship diagram\n(ERD). While the entity-relationship concept has provided an essential foun-\ndation for the development of the models that underpin many database sys-\ntems, it can help with modelling detailed data models for less data-centric\napplications too (Page-Jones 1988, Stevens 1991). As we will see in the next\nchapter, the form of the ERD has also provided useful ideas for modelling\nobject relationships.\nAs with all of the notations covered in this chapter (and elsewhere) there\nare various, largely syntactic, variations in the way that ERDs are presented\nvisually. However, many forms seem to have been derived from the pioneering\nnotation devised by Peter Chen (1976). Here we concentrate on the essential\nelements, avoiding the more detailed nuances of the form.\nEntity\nAttribute\nRelationship\nFIGURE 9.7: The basic entity-relationship notation\nFigure 9.7 shows the three principal symbols that are used in ERDs, to-\ngether with their meanings (the symbols for entities and relationships are\nfairly universal). These entities are de\ufb01ned as follows:\n\u2022 entities are real-world \u2018objects\u2019 that have common properties;\n\u2022 a relationship is a class of elementary facts that relates two or more\nentities;\n\u2022 attributes are classes of values that represent atomic properties of either\nentities or relationships (the attributes of entities are apt to be more\nreadily recognised than those of relationships, as can be seen from the\nexamples).\nWe might usefully note that the ERD, like the DFD, makes good use of visual\ndi\ufb00erences to clearly distinguish between the symbols.\nThe nature of an entity will, of course, vary with the level of abstraction in-\nvolved within a design model. Entities may also be connected by more than one\ntype of relationship. (For example, the entities student and teacher might\nbe connected by both of the relationships attends-class-of and examines.)\nAlso, attributes may be composite, with higher-level attributes being decom-\nposed into lower-level attributes. (As an example of this, the abstract attribute\ncourse-module might be decomposed into module-number, module-title\nand learning-level.)\n", "page": 148, "type": "text", "section": "Page 148"}
{"text": "132\nSoftware Design: Creating Solutions for Ill-Structured Problems\nFIGURE 9.8: Some entity-relationship links in the CCC\nRelationships are also classi\ufb01ed by their \u2018n-ary\u2019 properties. Binary rela-\ntionships link two entities. An example of a binary relation is the relationship\n\u2018reserves\u2019 that will exist between the entities CCC member and car (it isn\u2019t\nphysically possible to drive more than one car at any moment!). Figure 9.8\nshows some simple relationships that exist in the CCC. Relationships may\nalso be \u2018one to many\u2019 (1 to n) and \u2018many to many\u2019 (m to n). Examples of\nthese relationships are:\n\u2022 car (of order 1) selected from the set of cars (entity of order n) pro-\nvided in a city\n\u2022 authors (n) having written books (m)\n(In the latter case, an author may have written many books, and a book may\nhave multiple authors.) The e\ufb00ect of the n-ary property is to set bounds upon\nthe cardinality of the set of values that are permitted by the relationship.\nThe development of an ERD typically involves performing an analysis\nof speci\ufb01cation or design documents, and classifying the terms in these as\nentities, relationships or attributes. The resulting list then provides the basis\nfor developing an ERD.\nFigure 9.9 provides an ERD model for the entities that might be involved\nin an air tra\ufb03c control system (following on from the example in the previ-\nous section). This example can be considered as being quite design-related,\nand provides supplementary information about the factors that need to be\nconsidered in the eventual design model. The relationship between aircraft\nand runway also provides a simple illustration of a point that was made ear-\nlier, concerning the possible existence of multiple relationships between two\nentities.\n", "page": 149, "type": "text", "section": "Page 149"}
{"text": "Modelling Software Processes\n133\nFIGURE 9.9: An ERD relating some elements of an air tra\ufb03c control system\nFigure 9.9 does also highlight the bene\ufb01t of using visually distinctive\nshapes. Even though this is drawn by hand to emphasise the sketching is-\nsue discussed earlier, the symbol shapes are easily recognised.\nAlthough ERDs are widely used for developing the schema used in rela-\ntional database modelling, as we can see from this example, we can also make\nuse of ERDs to provide supplementary elements of a process model. This is\nparticularly relevant where the process is concerned with managing resources\nas in the case of air tra\ufb03c control\u2014and to a lesser degree, in the CCC.\nAs with the case of STDs, it may be useful to develop ERDs at di\ufb00erent\nstages of designing an application. A fairly abstract model, such as that in\nFigure 9.9 might usefully be formulated early in the design process, and might\nalso help clarify requirements (understanding of the IST). At other times, an\nERD may be used to clarify the rules that determine how some element of the\nproblem is to be used and changed.\n", "page": 150, "type": "text", "section": "Page 150"}
{"text": "134\nSoftware Design: Creating Solutions for Ill-Structured Problems\nExperts use notations as lenses, rather than straitjackets. PvdH #21\n9.5\nModelling construction: the structure chart\nWe address the question of describing the structure of a process last, since\nthe constructional viewpoint is commonly used to describe the outcome from\nmodelling processes.\nThe structure chart provides a simple visual description of the hierarchy\nof modules making up a process. In a call-and-return architecture, the hi-\nerarchy concerned is one that is based on invocation, whereby higher level\nsub-programs invoke the services of others at a lower level. Structure charts\noriginated in research performed at IBM to understand the problems that\nhad been encountered in developing the OS/360 operating system, which in\nmany ways was the \ufb01rst real attempt to develop large-scale software. One of\nthese problems was that of understanding the complex structure of the code,\nand the structure chart was one of the forms suggested as a means of aiding\nunderstanding by visualising how the code was organised (Stevens et al. 1974).\nThe structure chart uses a tree-like notation to describe the hierarchy of\nsub-programs, and is sometimes described as a call graph. In terms of coupling,\nit describes a dependency based upon control, although some information\nabout data coupling is usually included (there are a number of ways to do\nthis). It uses a small set of symbols, namely:\n\u2022 the box, which denotes a sub-program;\n\u2022 the arc, which denotes invocation;\n\u2022 some form of notation for the parameters, this might use small \u2018couples\u2019,\nwhich are arrows drawn at the side of the arc, or a table listing the\nparameters for each sub-program.\nOne advantage of using a table for the parameters is that this can also be\nused to list the global variables (usually forming part of the main body) that\neach sub-program uses. (When discussing the idea of cognitive dimensions\nin Chapter 7 the presence of global variables was identi\ufb01ed as a potential\nproblem of hidden dependencies, since global variables were not easily shown\non a diagram). Making this data coupling explicit is useful in itself, and the\nuse of a table also avoids having the diagram cluttered with detail. Figure\n9.10 shows a simple example that uses this form and also illustrates some of\nthe layout conventions commonly used.\nLayout conventions help visualise structure, although they can get tricky\nwith larger trees. The conventions used here include the following.\n", "page": 151, "type": "text", "section": "Page 151"}
{"text": "Modelling Software Processes\n135\nmain body\nmatch\nnode\nadd element\nto tree\ntraverse\ntree\nget next\nelement\nprint\nstring\ncreate\nnode\ninsert\nnode\nread next\ntoken\nsubprogram      in            out \ninsert_node       n:node  \nprint_string        s:string\nmatch_node      n:node    m: match status\nFIGURE 9.10: Simple illustration of a structure chart\n\u2022 Sub-programs are grouped on levels, and each one is drawn below the\nlevel of the lowest calling unit. In the example, print string() is\ndrawn at the lowest level, because it is called from both main() and\nalso traverse tree(), which is on a level below main().\n\u2022 Double bars at the sides of a box (using print string() as the exam-\nple again) indicates where the designer is intending to use a standard\n\u2018library\u2019 component.\n\u2022 The use of recursion can be indicated by a closed invocation arc, as in\nthe example of match node.\nWhile there may be no explicit convention about left to right ordering of sub-\nprograms, there may well be an implicit one. Structure charts are often drawn\nwith input activities on the left, and output activities on the right, which\nprobably does help with understanding of a diagram.\nBecause the structure chart describes an invocation hierarchy, it is implic-\nitly hierarchical in form, and so in principle at least, any box in the diagram\ncould be expanded using the same form. However, for moderate-sized appli-\ncations at least, this is normally only likely to occur for the lowest level, as\nshown here for read next token().\nThat said, given that some sub-programs are present purely for \u2018house-\nkeeping\u2019 roles such as initialisation, rather than playing a role in the main\nfunction of the process, it may be useful to simply abstract the description of\n", "page": 152, "type": "text", "section": "Page 152"}
{"text": "136\nSoftware Design: Creating Solutions for Ill-Structured Problems\nthese as a single box (perhaps labelled as \u2018initialisation activities\u2019), particularly\nas they will usually only be invoked when the process starts. Doing so makes\nit possible to concentrate on those sub-programs that are involved with the\nmain purpose of the application.\nExperts draw what they need and no more. PvdH #26\nThe structure chart does provide a relatively low level of abstraction from\nthe \ufb01nal implementation of a solution. Because of this, tools do exist for\nreverse engineering such diagrams from code, so providing a useful tool for the\nmaintainer. However, such tools will not readily \u2018group\u2019 sub-programs that are\ninvolved in performing a speci\ufb01c task, so layout may present a problem when\nanalysing large applications with many sub-programs.\n9.6\nEmpirical knowledge about modelling processes\nThere are few empirical studies that explicitly address topics related to\nthe modelling of single-thread processes, and the notations employed for this.\nSome studies do compare forms like the ERD with object-oriented notations\n(usually favouring the ERD notation) and these are discussed in the next\nchapter. Indeed, ERDs, and the di\ufb00erent notations used for them, have formed\nthe basis for comparative studies such as that described in (Purchase, Welland,\nMcGill & Colpoys 2004).\nOne paper of relevance here is that by Moody (2009) which examines visual\nnotations used in software engineering. One observation from this paper is that\n\u201cmost SE notations use a perceptually limited repertoire of shapes\u201d. The De\nMarco form of DFD we examined in Section 9.2 is cited as an example of design\nexcellence from this perspective. There is also some discussion of the \u2018Principle\nof Cognitive Integration\u2019, which relates to bringing together information from\ndi\ufb00erent diagrams (both diagrams of the same form and also diagrams of\ndi\ufb00erent forms). Interestingly, DFDs again demonstrate some good properties\nhere, unlike the notations associated with the UML that we discuss in the\nnext chapter.\nIndeed, Moody\u2019s observation that \u201cSE visual notations are currently de-\nsigned without explicit design rationale\u201d and that some older notations are\n\u201cbetter designed than more recent ones\u201d is a rather telling comment on the\nset of diagrammatical notations that together form a major design tool for\nsoftware engineering.\n", "page": 153, "type": "text", "section": "Page 153"}
{"text": "Modelling Software Processes\n137\nKey take-home points about modelling processes\nModelling the attributes of processes uses a range of di\ufb00erent forms to\naddress the main viewpoints for each type of design element.\nDesign models. Modelling of single-thread processes largely uses notations\nthat describe the functional and constructional viewpoints, although\nthese can usefully be augmented by behavioural and data modelling no-\ntations. However, the latter are used in a supplementary role, being\nessentially unsuited to developing complete models.\nNotational forms. While the DFD (in the De Marco format) makes good\nuse of visual discrimination between di\ufb00erent types of element, other no-\ntations tend to mainly use boxes and are dependent upon supplementary\ntextual information.\nModel integration. There is little scope to integrate design model informa-\ntion across the notations representing di\ufb00erent viewpoints.\nTabular notations. While diagrams o\ufb00er visual expressiveness, they have\nlimited ability to handle large-scale cognitive issues. For some notations\nthis may be aided by having a format that makes it possible to utilise\nhierarchy of diagram elements, but where this is lacking (as in the ex-\nample of STDs) it may be useful to employ a tabular form to describe\nrelationships in the model. Tabular forms also provide good support for\nchecking a model for completeness and consistency.\n", "page": 154, "type": "text", "section": "Page 154"}
{"text": "Chapter 10\nModelling Objects and Classes\n10.1\nCharacteristics of objects and classes ............................\n140\n10.1.1\nThe notion of an object .................................\n141\n10.1.2\nObjects and classes ......................................\n145\n10.2\nRelationships between objects ...................................\n150\n10.3\nConceptual issues for object modelling ..........................\n153\n10.4\nObject modelling: the issue of notations .........................\n156\n10.5\nModelling construction: the class diagram .......................\n157\n10.5.1\nDistinguishing classes from objects ......................\n158\n10.5.2\nClass relationships .......................................\n159\n10.6\nModelling behaviour: the statechart and the message sequence\ndiagram ..........................................................\n161\n10.6.1\nThe statechart ...........................................\n161\n10.6.2\nThe message sequence diagram ..........................\n164\n10.7\nModelling function: the activity diagram ........................\n167\n10.8\nUse cases .........................................................\n168\n10.9\nEmpirical knowledge about modelling objects and classes ......\n172\n10.9.1\nThe object model ........................................\n173\n10.9.2\nObject modelling notations ..............................\n173\n10.9.3\nObject-oriented metrics ..................................\n174\nKey take-home points about modelling objects and classes .....\n174\nThe object paradigm is well-established as a major architectural form and it is\none that is widely employed for developing software applications across a wide\nrange of domains and that is supported by many programming languages.\nWhile undoubtedly a very versatile form for constructing software applica-\ntions, objects (and the associated classes) are quite complex structures, and\nmuch more complex than the single-threaded processes that were the topic for\nthe previous chapter. And not only are they more complex in their structure,\nthere are also many di\ufb00erent forms of relationship (coupling) that can occur\nbetween objects, adding to the challenges that they present for modelling.\nAs a further factor that may need to be considered when modelling object-\noriented structures, objects can also be realised in di\ufb00erent ways, and this\noccurs with programming languages as well as run-time systems. For exam-\nple, Java uses a di\ufb00erent object model to that used by C++. In particular,\nJava only allows the use of single inheritance (inheriting from only one class),\nwhereas C++ permits an object to inherit from more than one class. In this\n139\n", "page": 156, "type": "text", "section": "Page 156"}
{"text": "140\nSoftware Design: Creating Solutions for Ill-Structured Problems\nchapter we take a fairly generic approach to modelling objects, but in practice\nthis may be constrained when it is necessary to map the design model on to\na particular form of implementation.\nThe chapter therefore begins by examining the general characteristics of\nobjects and classes (and the distinctions between them), in order to provide\na basis for the sections that follow. An awareness of these characteristics, and\nhow they can be employed, provides an important foundation for considering\nhow they can be modelled. Following that, we examine the di\ufb00erent relation-\nships that are encompassed by the concept of coupling between objects, and\nthen go on to look at some of the ways that we can describe and model these\nrelationships between objects and classes.\n10.1\nCharacteristics of objects and classes\nIn order to model software objects we need to have a set of clear ideas about\nwhat makes up the object paradigm. Unfortunately, clarity has not always been\na quality associated with the object-oriented paradigm. Indeed, the words of\nTim Rentsch (1982) could be viewed as having been quite prophetic:\n\u201cMy guess is that object-oriented programming will be in the\n1980s what structured programming was in the 1970s. Everyone\nwill be in favour of it. Every manufacturer will promote his prod-\nucts as supporting it. Every manager will pay lip service to it.\nEvery programmer will practice it (di\ufb00erently). And no one will\nknow just what it is.\u201d\n(Of course, this extended well be-\nyond the 1980s, and we could substi-\ntute a whole list of terms or phrases\nin place of \u2018object-orientated\u2019, in-\ncluding agile development, software\ndesign patterns, global software de-\nvelopment, model driven develop-\nment, cloud etc. What Rentsch was\nreally observing was the way that\ndi\ufb00erent forms of software develop-\nment practice have in turn been seen\nas \u2018silver bullets\u2019 (Brooks 1987).)\nUnfortunately, silver bullets don\u2019t\nmagically turn ISPs into WSPs, al-\nthough it can be argued that while\nobjects are unquestionably complex\nthings, they do provide the means to\nmodel the complexity inherent in software-based ISPs.\n", "page": 157, "type": "text", "section": "Page 157"}
{"text": "Modelling Objects and Classes\n141\nA good overview of the concept of an object was provided in Booch (1994),\nwhich includes a survey of historical issues associated with objects. The analy-\nsis by Taivalsaari (1993) used a rather di\ufb00erent framework and examined the\nnotion of an \u2018object\u2019 from \ufb01ve di\ufb00erent \u2018viewpoints\u2019: conceptual modelling;\nphilosophical; software engineering or data abstraction; implementation; and\nformal. For the purposes of this chapter however, a rather shorter description\nof the characteristics of objects (and classes) will be su\ufb03cient.\n10.1.1\nThe notion of an object\nWhen seeking to pin down the notion of what distinguishes an object, a\nuseful starting point may be to contrast the idea of an object with that of\nthe process that was the topic for the previous chapter. Processes are usually\nsingle-threaded, especially when implemented in a call-and-return style. While\nthey may exhibit state, this is rarely readily accessible outside of the process,\nand, for sub-programs any variables may be transient and only exist when\nthe sub-program is executing. There are variations on all of these of course\n(that\u2019s why we have so many programming languages and platforms), but\nfrom a modelling aspect, the process is a relatively simple element, and one\nthat is essentially \u2018action-oriented\u2019, with structures that place relatively little\nemphasis upon data or information.\nglobal\ndata\nlocal\ndata\ninvoke\ninvoke\nuses\nmethod\ncall\nsub-program B\nsub-program A\nobject X\nobject Y\ninternal\nmethod\nexternal methods\na) Structure of a process\nb) Structure of an object\nFIGURE 10.1: Processes versus objects\nFigure 10.1 provides a simple illustration of the distinction between the\nway a process is organised and the way that an object is organised. On the\nleft of the \ufb01gure, we have a process consisting of sub-programs that make use\n", "page": 158, "type": "text", "section": "Page 158"}
{"text": "142\nSoftware Design: Creating Solutions for Ill-Structured Problems\nof other sub-programs through invocation, and that can access global data\nstructures that are held in the main body of the program. On the right of the\n\ufb01gure, we have an object that provides multiple entry points to the resources\nit provides through di\ufb00erent external methods, that contains permanent en-\ncapsulated data structures, employs both external and internal methods, and\nthat can make use of other objects in a number of di\ufb00erent ways.\nAs we noted in the last chapter, the emphasis placed upon \u2018action\u2019 in pro-\ncesses was challenged by David Parnas (1972) with his ideas about informa-\ntion hiding. Objects incorporate this concept via an encapsulation mechanism\nthat makes it possible to create applications in which the detailed forms used\nto store and organise data elements are only known to a few key parts of a\nsystem.\nAs various ideas began to merge around the concept of objects in the 1980s,\nvarious e\ufb00orts were made to maintain consistency of concepts and terminol-\nogy. A useful contribution to this was made by a working group at Hewlett-\nPackard, for which the \ufb01ndings (in the form of a discussion of exactly what\nobjects are) were reported in (Snyder 1993). A little later, the emergence of the\nUni\ufb01ed Modeling Language (UML) provided a set of ideas about the nature\nof objects that were in\ufb02uenced by abstract modelling. Although originally the\nwork of the \u2018three amigos\u2019\n(Grady Booch, Ivar Jacobson and James Rum-\nbaugh), the UML and its evolution subsequently came under the umbrella\nof the Object Management Group1 (OMG), and at time of writing the latest\nspeci\ufb01cation of the UML is that provided in version 2.5.1 (2017). It is worth\nnoting that the OMG and those involved in the development of the UML\nare essentially \u2018computer industry\u2019 bodies, rather than the sort of grassroots\norganisations that have provided the motivation for Open Source Software\n(OSS) and design patterns. We will return to this issue in a later chapter.\nSo, we can regard an object as some form of software entity that performs\ncomputations and that has a local \u2018state\u2019 of some form that may be modi\ufb01ed\nby the computations. In particular, an object model:\n\u2022 is organised to provide services to other elements, rather than simply\nto perform actions, usually through a set of methods which are invoked\nfrom other objects, rather as sub-programs are invoked within processes;\n\u2022 enforces strict control of scope (encapsulation) to ensure that data and\noperations within an object are not directly available for use by other\nelements, and can only be accessed through the external mechanisms\nprovided by the object interface;\n\u2022 makes little or no use of \u2018global\u2019 data, such that any data used in an\napplication is stored within objects and normally can only be directly\naccessed by that object.\n.\n1www.omg.org\n", "page": 159, "type": "text", "section": "Page 159"}
{"text": "Modelling Objects and Classes\n143\ndata\n(state)\nmethods\n(behaviour)\nexternal\ninvocation\n(method calls)\ninstantiation\n(identity)\nencapsulation\ninternal\nexternal\nFIGURE 10.2: A simple illustration of object characteristics\nAn object also has a distinct identity that allows it to be distinguished\nfrom other objects having the same form. Hence when modelling objects, we\nneed to be able to represent ideas about state, behaviour and identity in some\nway. Figure 10.2 provides a simple illustration of the context and form of an\nobject.\nWe might also note that when modelling objects we will rarely need to\nmodel the use of global data and that the topological form of an application\nwill usually be that of a network of objects rather than a hierarchical \u2018tree\u2019.\n(Objects may have a hierarchy, in fact, they can have more than one, but\nnot quite in the same sense that we encountered with processes, where the\nhierarchy was usually one of invocation of functional elements.)\nMoving on from what an object is, to thinking about how we can model it\nwithin the design process, we can identify some key object characteristics as\nfollows.\nAbstraction This plays an important role in the design process as a whole.\nIt is concerned with describing the external perspective of an object\nin terms of its \u2018essential features\u2019. Abstraction provides a concise de-\nscription of an object, which can then be used to help reason about its\nbehaviour and about its relationships with other objects, without a need\nto possess any knowledge about its internal details.\nHence, when modelling objects, an essential property for any form of\n\u2018design object\u2019 is that it should be possible to identify its characteristics\n", "page": 160, "type": "text", "section": "Page 160"}
{"text": "144\nSoftware Design: Creating Solutions for Ill-Structured Problems\nin an abstract manner. Identifying the key abstractions needed for an\napplication and modelling their relationships is an important part of the\ndesign process.\nEncapsulation The concept of information hiding\nis realised through the\nability to conceal the details of an object\u2019s internal organisation and the\nways in which information is represented through some form of encap-\nsulation mechanism. Concealing the implementation details of an object\nmakes it much easier to make changes to them without this having side-\ne\ufb00ects within the rest of the application. Encapsulation is an important\nissue for detailed design and implementation, and when thinking about\nthis at a more abstract level the key question is to identify what should\nbe concealed? Encapsulation and abstraction are largely complementary\nconcepts.\nModularity This relates to the division of the overall architecture of an\napplication into major sub-units (which we can consider as being moti-\nvated by \u2018separation of concerns\u2019). In doing so, one important criterion\nto consider is the complexity of the interfaces between the modules,\nwhile another is the likely e\ufb00ects of evolution of the application over\ntime. For processes, the unit of modularity is the sub-program, which is\nlargely organised around function, with relatively little emphasis being\nplaced upon any relationships with data. In an object-oriented context\nwhere there are many forms of uses relationships, the choice of suitable\nmodules becomes rather more complex and multi-faceted. For example,\nobjects do not have a single thread of control, and it may be that the\ndesign of an application needs to allow di\ufb00erent methods to be invoked\nconcurrently, requiring that any consequent changes to variables be suit-\nably protected.\nThe choice of modules is also determined by how the application will\nevolve. Where possible, we should be seeking to isolate major design\ndecisions within separate modules, so that when changes do occur, they\nare largely isolated to a single module. We look at this later when we\ndiscuss the role of architectural patterns in Chapter 15.\nHierarchy As noted above, the object model is characterised by the presence\nof several di\ufb00erent forms of hierarchical structure. Within an object\nthat performs complex computations there is the possibility of having\na hierarchy of function, rather similar to that of processes, whereby\na complex task is sub-divided into small elements. There is also the\npossible use of a hierarchy based upon class structure, which is examined\nmore fully in the rest of this section. Finally, there is the extent to which\nthe interdependence of objects forms a hierarchy, usually referred to as\nthe uses relationship, and this is explored more fully in the section that\nfollows.\n", "page": 161, "type": "text", "section": "Page 161"}
{"text": "Modelling Objects and Classes\n145\nBefore we examine the idea of a class hierarchy, there are two other char-\nacteristics of objects that should be mentioned, since they can a\ufb00ect the mod-\nelling process. The \ufb01rst is that new objects can be created at any time\u2014and\nobviously, objects can be deleted too. This creates a dynamically changing\napplication structure, and is a particularly useful feature when a particular\nobject is mainly concerned with representing one item of a set of resources and\nwe want to add new items to the set. However, it also represents a new issue\nin terms of the ideas about design models that we have so far encountered,\nsince the equivalent feature for processes is limited to creating new list ele-\nments when using linked data structures. And a second, related characteristic,\nis that when a client issues a request to one object in a set of objects, it needs\nto be able to identify the object that should be the recipient (taking us back\nto the issue of objects having an identity).\n10.1.2\nObjects and classes\nClass\nclass data\nclass methods\nobject 'template'\nobject\ndata\nObject\nexternal methods\nFIGURE 10.3: Instantiating an object from its class\nViewed in terms of their implementation roles, a class speci\ufb01cation can\nbe regarded as a form of \u2018template\u2019 that can be used to create objects. The\nclass de\ufb01nes the state and behaviour attributes of an object, and when an\n", "page": 162, "type": "text", "section": "Page 162"}
{"text": "146\nSoftware Design: Creating Solutions for Ill-Structured Problems\nobject is created (instantiated) from a class, it acquires a set of variables and\nmethods for that class. It also acquires a unique identity. However, that is not\nall, for depending upon how the object model is implemented, the class itself\ncan provide some shared resources, visible to all of the objects derived from\nit. These may include class methods and class variables that do not form part\nof an object. For example, a class may keep a count of the objects created\nfrom it, using a class variable to store this, and employing class methods\nto increment/decrement the count. Figure 10.3 shows the class and object\nrelationship in a schematic form. The key issue here is that the class data is\nessentially \u2018in scope\u2019 to the object in the same way as any object data.\nAs an example, a simple form of this could be used in the CCC to limit\nthe number of customers allowed to request a car at any point in time. Each\n\u2018customer object\u2019 can be linked to the details of up to three \u2018car objects\u2019, to\nprovide the customer with a choice. However, it makes little sense to allow\nthe same car to be o\ufb00ered to many customers at the same time. One way to\nconstrain this would be for the \u2018customer class\u2019 to contain a counter and a\ncondition that constrains the number of customer objects created at any point\nin time to be (say) half of the number of available cars. When this limit is\nreached, no further customers would be allowed to request a car. (Of course\nthere would also need to be an accompanying mechanism to \u2018queue\u2019 requests\nfrom customers resulting in new customer objects.)\nThe hierarchy that is based upon class structure also leads us to consider\nthe concept of inheritance, by which the properties of an object can be derived\nfrom the properties of other objects, or more correctly, of other classes. The\nquestion of how important inheritance is for object-oriented design comes close\nto being a theological issue. In particular, it introduces an issue that we will\nreturn to later, as to whether (or when) the \u2018right\u2019 design abstraction that\nshould be used for modelling is the object or the class. So this is a good point\nto discuss the class/object relationship more fully.\nIn a programming language it is usually possible to create new data types\nfrom existing types, particularly by compounding these in some manner, or\nby de\ufb01ning a sub-range type. We can do much the same with classes, but\nthe associated inheritance mechanism used to create subclasses is much more\ncomplex than the forms needed for creating derived types, since it needs to\nincorporate not just static data relationships, but also behavioural qualities\n(methods).\nThe subclasses of a class will share common structures and common fea-\ntures of behaviour. As an example, a bank may provide customers with a\nchoice from many di\ufb00erent forms of account, each of which may have di\ufb00erent\nrules about how interest is calculated and paid, how charges are applied, the\nminimum balance required, overdraft rules and so on. However, all of these\nforms are clearly recognisable as being subclasses of some \u2018parent\u2019 class of\nbank account, and share some common information structures (characteris-\ntics), such as those used to describe:\n\u2022 the current balance\n", "page": 163, "type": "text", "section": "Page 163"}
{"text": "Modelling Objects and Classes\n147\n\u2022 the identity of the account holder\n\u2022 the date of creation for the account\nas well as some common operations, such as:\n\u2022 creation of a new account\n\u2022 addition of interest\n\u2022 making a deposit\n\u2022 withdrawal of part of the balance\nSo, for this example, the class of bank account will provide a description of\nthese common properties and behaviour, while the detailed form of a partic-\nular subclass of account will be structured around the rules applying to that\nsubclass. For design purposes, the designer therefore needs to concern them-\nselves with the abstractions involved in the class (bank account), and the\nsubclasses. Figure 10.4 illustrates these points.\nclass\nbank_account\ndeposit account\nwith annual\ninterest\ncurrent account\nwith no interest\ndeposit account\nwith monthly\ninterest\n'my current\naccount'\n'my current\naccount'\n'my current\naccount'\n'my current\naccount'\n'my current\naccount'\nsubclasses\ninstances\nclass\ninherited\ncharacteristics\nof bank_account\nactual bank\naccounts from\nthat subclass\nFIGURE 10.4: The inheritance hierarchy\nInheritance provides the mechanism by which subclasses acquire the gen-\neral properties of their parent class(es) (also known as superclasses). In our\nexample, any speci\ufb01c form of bank account will inherit the properties of bank\naccounts in general, but may have some features that only apply to that\n", "page": 164, "type": "text", "section": "Page 164"}
{"text": "148\nSoftware Design: Creating Solutions for Ill-Structured Problems\nsubclass (extended methods, additional methods, minimum balance etc.). So\ninheritance is an important constructional concept, and one that has been\nincorporated into many di\ufb00erent programming languages.\nThe form depicted in Figure 10.4 is based upon the use of single inheri-\ntance, whereby a class can only inherit the properties of one superclass. (Of\ncourse, that superclass may itself inherit from a higher superclass.) However,\nit is also possible to inherit from more than one superclass, forming multiple\ninheritance. Obviously this does add considerably to the potential complexity\ninvolved in keeping track of the inheritance relationships. Hence many pro-\ngramming languages, most notably Java, only permit the use of single inheri-\ntance. From the point of modelling design ideas, multiple inheritance certainly\nincreases the cognitive load involved, as well as adding to the technical debt\nby creating potential problems for future maintenance (Wood, Daly, Miller &\nRoper 1999).\nExperts prefer simple solutions. PvdH #1\nA mechanism often introduced alongside inheritance is that of polymor-\nphism. And like inheritance its use is apt to be associated with detailed design\ndecisions, although conceptually at least, the decision to employ polymor-\nphism could arise at any point. What it really relates to is the more \ufb02exible\noptions that objects provide with regard to binding time.\nWhen creating an application using a call-and-return form, the decision as\nto which sub-program is going to be called to perform some task is essentially\n\ufb01xed at the point when the code is written and compiled. The run-time process\nwill contain the linkage information for that speci\ufb01c choice of sub-program,\nand this cannot be modi\ufb01ed. So call-and-return architectures usually embody\nwhat we can regard as a static binding to particular sub-programs.\nFigure 10.5 illustrates a very simple example of what can happen in an\nobject-oriented system. In this example, there are three objects, designated\nX, Y and Z (which we can also assume are created from di\ufb00erent classes).\nThe block arrows indicate \u2018makes use of\u2019, so object X makes use of both other\nobjects, while object Z makes use of object Y. Each object provides a set of\nmethods that provide access to its encapsulated data. So, if object X needs\nto access data held by object Y, it might do so by using the methods Y.b()\nor Y.c() for that purpose. (Because objects have identity, it is a common\nconvention to refer to a method as object identi\ufb01er.method identi\ufb01er.)\nHowever, we might also note that object Z also provides a method b().\nSince this can be referenced as Z.b(), no confusion need arise. However, in an\nobject-oriented context, whenever object X makes a reference to the method\nb() with no object identi\ufb01er, we can expect that the context of that reference\nwill be used to determine whether the appropriate method to use is Y.b()\nor Z.b(). And the decision about the appropriate choice will be made auto-\nmatically and at run-time. This is because the bindings between objects are\n", "page": 165, "type": "text", "section": "Page 165"}
{"text": "Modelling Objects and Classes\n149\nObject_Z\nObject_Y\nObject_X\nd()\nb()\nc()\nb()\na()\nFIGURE 10.5: Dynamic binding and polymorphism\ncreated dynamically when the application executes, allowing the appropriate\nchoice to be made at that point.\nIt is this facility for selecting the appropriate method from a number of\nmethods with the same identi\ufb01er, but originating in di\ufb00erent classes, that is\ntermed polymorphism. (Strictly, although our example is couched in terms of\nobjects, the methods themselves are de\ufb01ned in the parent classes.). To return\nfor a moment to the earlier example of the bank account and its subclasses, we\nmight expect that all classes will provide a withdraw() method, but that the\ndetailed form of how this operates will be di\ufb00erent, according to the type of\naccount involved. So when this method is used in an application, the choice of\nwhich instantiation of withdraw() will be employed will depend upon the type\nof account provided as its argument. (This is also why we tend to associate\npolymorphism with inheritance, since inheritance provides a mechanism for\nexploiting this in an elegant manner.)\nWhat is important here though is not the mechanism of polymorphism\nitself, but the way that it highlights the use of dynamic binding, and the char-\nacteristic that methods belong to objects, rather than being a static binding.\nFrom a design perspective, it also o\ufb00ers a quite radically di\ufb00erent conceptual\nmodel.\nThe class-object relationship does complicate modelling and design in\nmany ways, and not just through the use of such mechanisms as inheritance\nand polymorphism. Initial modelling may well be more problem-related, sug-\ngesting that the emphasis at that stage is likely to be upon objects. However,\nlater stages of modelling, where constructional aspects become more impor-\ntant, may well use classes too.\n", "page": 166, "type": "text", "section": "Page 166"}
{"text": "150\nSoftware Design: Creating Solutions for Ill-Structured Problems\n10.2\nRelationships between objects\nIn the preceding section the emphasis was upon relationships that can\noccur between objects (and classes) that share attributes. In this section we\nexamine the relationships that can exist between objects that are unrelated,\nbut that need to work together in order to produce an application with the\nrequired behaviour and functionality.\nA useful way of thinking about these and other relationships is to consider\nthe di\ufb00erent relationships that have been found to provide useful measures\nthat can help with pro\ufb01ling the form of object-oriented applications. The set\nof six metrics identi\ufb01ed by Chidamber & Kemerer (1994) (usually abbreviated\nto C&K) are widely used to assess the structures of these, and have themselves\nbeen derived from consideration of the object model. The metrics, together\nwith their common acronyms are summarised in Table 10.1.\nTABLE 10.1: The Chidamber & Kemerer metrics\nMetric\nLabel\nDescription\nWeighted Methods per\nClass\nWMC\nThe sum of the \u2018complexity\u2019 values for all\nof the methods in a class.\nDepth\nof\nInheritance\nTree\nDIT\nA count of \u2018tree height\u2019 for ancestor classes.\nNumber of Children\nNOC\nThe number of subclasses that inherit from\nthe given class.\nCoupling\nbetween\nOb-\njects\nCBO\nThe number of couples that exist between\na class and other classes.\nResponse for a Class\nRFC\nA measure of the \u201cimmediate surroundings\nof a class\u201d.\nLack\nof\nCohesion\nin\nMethods\nLCOM\nThe number of methods in a class that do\nnot share attributes.\nThese metrics provide surrogate measures for some of the object-oriented\nconcepts (which inevitably are not easily measured directly). They are proba-\nbly most usefully used for comparison, both between the properties of di\ufb00erent\nclasses, and also for the way that the properties of a particular class change\nas a result of maintenance. As metrics they are often used to help identify the\nclasses that are considered to be most likely to contain faults. We discuss a\nsystematic review of their usefulness for identifying modules likely to contain\nfaults in Section 10.9, and for this section just provide brief comments that\nare based upon its \ufb01ndings (Radjenovi\u0107, Heri\u010dko, Torkar & \u017divkovi\u010d 2013).\nTwo of the metrics (DIT and NOC) really belong with the discussion of the\nprevious section, so we only need to comment here that while DIT probably\no\ufb00ers no signi\ufb01cant predictive ability for fault-proneness, NOC is in the group\nthat does have \u201csome ability to discriminate\u201d with regard to the e\ufb00ect of\n", "page": 167, "type": "text", "section": "Page 167"}
{"text": "Modelling Objects and Classes\n151\nchanges to a class. NOC does give some indication of the potential in\ufb02uence\nthat a class has on the design.\nTwo of the other metrics (WMC and LCOM) are calculated on a class\nbasis, but are still useful when comparing values for di\ufb00erent classes. Weighted\nMethods per Class (WMC) is calculated as:\nn\nX\ni=1\nci\nwhere ci is the complexity of method i. The choice of the complexity measure\nc is left to the user, and essentially the metric calculates the overall complexity\nof the class as a function of the complexities of the individual elements. One\nchoice for complexity is simply to set it to a value of 1, which produces a\ncount of the methods in the class. Other values that are used include Lines\nof Code (LoC) and McCabe\u2019s Cyclomatic Complexity (which is a measure of\nthe number of possible execution paths through a method). While WMC as\na metric is of less use for making comparisons with other objects and classes,\nresearch does suggest that an increase in WMC after changes are made to a\nclass is a good indicator of a possible increase in defects for that class.\nLack of Cohesion in Methods (LCOM) is based upon the idea that the\nelements of a class should be related to the purpose of the class, and hence\nshould share some attributes. In an earlier version of the metric de\ufb01nitions,\nthis was a count of methods that did not share variables, so that for a cohesive\nclass we would expect a value of 0. This was later re-de\ufb01ned as follows:\nX\n(pairswithnocommonattributes) \u2212\nX\n(pairswithcommonattributes)\nwhich addresses the same concept more clearly. (Note though the comment\nabout the validity of LCOM in the section on empirical evidence.)\nThe remaining two metrics are very much concerned with the interactions\nbetween objects (or classes).\nCoupling between Objects (CBO) is the count of the number of couples\nthat exist between a given class and other classes. Such a coupling is assumed\nto exist if one class uses methods or instance variables from another class,\nand an excessively high value of CBO is considered to be an indicator of poor\nmodular design as well as an impediment to reuse. Coupling can take a range\nof forms: invocation of a method, inheritance, copying the value of a variable.\nThe metric treats coupling as a two-way link, and so calculation of CBO needs\nto count both the classes that use a class and also those that it uses, as shown\nin the example of Figure 10.6.\nIn the example, the solid lines indicate that one object calls methods in\nanother (such as the line between class A and class B) while the dashed line\nbetween class A and class C indicates a di\ufb00erent form of coupling, such as\ninheritance (class C inheriting from class A).\nAs often, the empirical \ufb01ndings about the usefulness of CBO are rather\nmixed, but overall, it was found to have \u201cmoderate predictive ability\u201d with\n", "page": 168, "type": "text", "section": "Page 168"}
{"text": "152\nSoftware Design: Creating Solutions for Ill-Structured Problems\nclass B\nclass A\nclass D\nclass C\nCBO(A)=2\nCBO(B)=2\nCBO(C)=3\nCBO(D)=1\nFIGURE 10.6: Simple illustration of CBO measures\nregard to fault-proneness. Two useful observations from a design perspective\nare that:\n\u2022 the presence of one class having a high value of CBO, while others have\na CBO of 1, may indicate that a call-and-return design model has been\nmapped on to an object structure;\n\u2022 the presence of many classes with high CBO may indicate that the\nmodularity in the design model is too granular, and that the classes\nare too small, requiring that they have to make use of other classes in\norder to perform their tasks.\nResponse for a Class (RFC) is a measure that seeks to re\ufb02ect the in\ufb02uence\nof the \u201cimmediate surroundings of a class\u201d, in other words, the methods that it\nuses directly. The response set of a class is the set of methods that are accessed\nby the set of methods belonging to an object of that class (which may include\naccess to other methods within the class). This is a static measure, and so\nidenti\ufb01es the set of methods that might potentially be executed if a message\nis sent to one of the methods in an object of that class. It is de\ufb01ned as:\nX\n(localmethods) +\nX\n(methodscalledbylocalmethods)\nand Figure 10.7 shows a simple illustration of this.\nAs a measure, the larger the number of methods that can be invoked from\nan object, the greater will be its complexity in terms of the e\ufb00ort needed to\ncomprehend its operation, and of the level of understanding needed to test it.\n", "page": 169, "type": "text", "section": "Page 169"}
{"text": "Modelling Objects and Classes\n153\nx\nc\na\np\nq\nb\nClass A\nClass B\nClass C\n=1\nRFC(B) = (a, b, c) + (x, p, q) = 6\nFIGURE 10.7: Simple illustration of RFC measures\nThere is limited research into the value of RFC, but what is available does\nindicate that this measure may correlate well with the likely number of defects\nin the class.\nOf course, the things that we can measure (such as the C&K metrics)\nare not necessarily a guide to how we should design an application, and they\nare largely concerned with relatively static aspects of object relationships.\nHowever, the constructional viewpoint does play an important role in OO\nmodelling, and so the measures do give some indication of the sort of rela-\ntionships that we need to think about, and the issues that should perhaps be\nanticipated when producing a design model.\n10.3\nConceptual issues for object modelling\nFigure 10.8 summarises some of the main characteristics of objects that\nhave been mentioned in the preceding sections (obviously, they are not the\nonly ones). Here we brie\ufb02y look at the conceptual issues that are implied by\nthese when thinking about how we can model object-oriented designs.\nTo model a design solution with the goal of employing any particular\nform of implementation (in this case objects), the designer needs to possess\nnot only a good conceptualisation of the relevant architectural style, but also\nsome clear cognitive mappings that can be used to link ideas about the design\nmodel to the implementation constructs that characterise that style. For the\n", "page": 170, "type": "text", "section": "Page 170"}
{"text": "154\nSoftware Design: Creating Solutions for Ill-Structured Problems\nAn object...\n...embodies an abstraction that is meaningful\nto its clients\n...possesses a state, which can be inspected\nand changed through its methods\n...exhibits behaviour through its responses to\nexternal events\n...possesses an identity, since more than one\nobject may be created from a class\n...provides services (through methods) that\ncharacterise the abstraction, and that may\naccess or modify data within an object, and\nmay affect (use) other objects\n...is encapsulated so that clients cannot\ndirectly access data associated with an \nobject\n...provides services through the interfaces that\nit provides to clients\n...can have a common implementation so that\nobjects may share code (but usually not data)\nFIGURE 10.8: Key characteristics of an object\ncall-and-return style, the abstract model is one that is described in terms\nof statically linked sub-programs, with these having well-de\ufb01ned functional\nroles. The control and data topologies are also more or less the same, so that\nthe task of mapping a design model on to a given procedural programming\nlanguage is a relatively straightforward process. Likewise, the pipe-and-\ufb01lter\nstyle employs fairly simple architectural elements, and again, both control and\ndata topologies are closely linked, assisting with the eventual implementation.\nWhen employing the object-oriented style, the basic concepts used for for-\nmulating the abstract design model, as well as for mapping it on to some form\nof implementation, are somewhat more challenging. To take a simple exam-\nple, we noted earlier that observational studies of designers showed that they\noften \u2018mentally executed\u2019 their design models, to ensure that these exhibited\nthe intended behaviour. This is a relatively straightforward exercise with a de-\nsign model formulated using a style such as call-and-return, but a potentially\nmuch more complex task when realising a design using objects. The di\ufb00ering\ncontrol and data topologies, together with dynamic binding of methods and\nmultiple threads of execution within an object, all combine to make this more\nchallenging.\nExperts know how things work. PvdH #33\n", "page": 171, "type": "text", "section": "Page 171"}
{"text": "Modelling Objects and Classes\n155\nOne of the arguments sometimes made for adopting the object-oriented\nstyle is that it is more \u2018natural\u2019 than (say) call-and-return. Objects and their\ninteractions can be recognised in the everyday world, whereas call-and-return\nuses a model which more closely re\ufb02ects the workings of the computer itself.\nHence (so the argument goes), the process of analysis should involve identi-\nfying the objects in the problem domain, and then use the resulting model\nto help with deciding upon a set of corresponding \u2018solution objects\u2019. However,\nin practice this has not proved to be a particularly e\ufb00ective strategy, and as\nD\u00e9tienne (2002) observes:\n\u201cearly books on OO emphasised how easy it was to identify objects\nwhile later ones, often by the same authors, emphasise the di\ufb03culty\nof identifying them\u201d\nwhich rather undermines the case for \u2018naturalness\u2019 and for any modelling\nbased upon it. That said, D\u00e9tienne also notes that comparative studies have\ndemonstrated that:\n\u2022 object-oriented design tends to be faster and easier than the procedural\n(structured) design approaches discussed in Part III;\n\u2022 di\ufb00erent designers will produce solutions that are more similar when\nusing an object-oriented approach than when using other approaches;\nsuggesting that once the necessary levels of knowledge have been acquired by\nthe designer, the object-oriented style may have more to o\ufb00er.\nAn important issue here would appear to be the relatively steep learning\ncurve involved in learning about object-oriented design. Studies by Fichman\n& Kemerer (1997), Vessey & Conger (1994) and Sheetz & Tegarden (1996)\nall observed that inexperienced designers struggled to acquire and deploy the\nconcepts. In the study by Sheetz & Tegarden (1996), they speci\ufb01cally identi\ufb01ed\nthe following object-centred design issues as contributing to the problems by\nacting as sources of confusion for the inexperienced designer.\n\u2022 Organising the distribution of application functionality from the \u2018prob-\nlem space\u2019 across a set of objects. (In other words, identifying the ob-\njects.)\n\u2022 Using the existing class hierarchy.\n\u2022 Designing classes (including making use of inheritance).\n\u2022 Using polymorphism, where the semantics of methods with the same\nname may di\ufb00er.\n\u2022 Evaluating solutions (see earlier comment about mental execution).\n\u2022 Communication among objects.\n\u2022 Designing methods.\n", "page": 172, "type": "text", "section": "Page 172"}
{"text": "156\nSoftware Design: Creating Solutions for Ill-Structured Problems\nSome of this complexity relates largely to constructional issues, but much also\narises from the cognitive load that is imposed by the need to comprehend and\nmodel so many issues at each step in design. The latter aspect will become\nmore evident when we look at design processes in Part III. For the moment,\nwe will concentrate on how we might model object-oriented properties.\n10.4\nObject modelling: the issue of notations\nVarious forms of diagrammatical notation have been employed for mod-\nelling the di\ufb00erent properties of objects. The best known of these is probably\nthe UML (Rumbaugh, Jacobson & Booch 1999), mentioned earlier in the\nchapter. In his critique of the choices of visual notations used in modelling\nlanguages, Moody (2009) comments on the poor use of di\ufb00erent shapes in\nmany SE notations and observes that they \u201cuse a very limited repertoire of\nshapes, mostly rectangle variants\u201d and goes on to point out that rectangles\n\u201care the least e\ufb00ective shapes for human visual processing\u201d and that \u201ccurved,\n3D, and iconic shapes should be preferred\u201d.\nUnfortunately, most OO notations, and the\nUML in particular, make extensive use of rect-\nangles. Perhaps the one thing that we can say\nin their favour is that they are easily drawn on\na whiteboard (one of the problems with both\ncolour and icons is that they do present more of\na challenge to sketching skills).\nFor the purposes of the rest of this chapter,\nrectangles have been retained where an estab-\nlished notational form is being used, but di\ufb00er-\nent shapes have been used as far as possible.\nSimilarly, some examples have been sketched,\nfor the reasons explained in Chapter 8. Speci\ufb01c\nforms from the UML are used explicitly where\nthese have no obvious equivalents (for example, activity diagrams), but wher-\never possible, the following sections make use of fairly general forms of notation\nand syntax. It is worth noting that UML 2.0 uses a large set of diagrammat-\nical forms (13), with some overlaps. However, only a key subset of these is\ndescribed here and in later chapters!\n", "page": 173, "type": "text", "section": "Page 173"}
{"text": "Modelling Objects and Classes\n157\n10.5\nModelling construction: the class diagram\nThe constructional viewpoint tends to play a rather di\ufb00erent role for de-\nveloping design ideas for objects than the one that it takes when producing\ndesign models based upon processes. In the latter case design models tend to\nbe developed using the other viewpoints, and constructional forms are used\nat a relatively late stage in design (see Chapter 13). With the object model,\nthe constructional viewpoint may well be used throughout the design process,\nprobably because of the importance of identifying the key objects at an early\nstage. Early stages in design may use fairly simple descriptions of classes and\nobjects, with more elaborate forms being used for detailed design.\nTwo aspects complicate description when employing the constructional\nviewpoint. Firstly there is the need to distinguish between a class and an object\ncreated from that class. And secondly, the designer has the added complexity\nof needing to model a number of quite di\ufb00erent forms of uses relationship.\nThis certainly complicates the role for any diagrammatical notation since,\nwith relationships being \u2018connectors\u2019 between objects, it is likely to be more\ndi\ufb03cult to employ the sort of variety of visual shapes that can be adopted\nfor the elements of a diagram. Equally, to understand and use a model, it is\nimportant to be aware of the nature of a particular relationship.\nClasses themselves are usually modelled as rectangles. Early forms of OO\ndesign did use di\ufb00erent shapes (for example, in Robinson (1992) a box with\nrounded corners was used for Hierarchical Object-Oriented Design (HOOD)\nobjects. Since we spend a lot of time drawing objects when modelling, the\nchoice of a simple rectangle is probably a practical one to employ, and it is of\ncourse easy to sketch.\nclass name\nclass name\nclass name\nclass name\nlist of\nattributes\nlist of\nattributes\nlist of\noperations\nlist of\noperations\nFIGURE 10.9: The UML class notation\nThe UML has adopted the use of a box in its class diagram, and classes\ncan be represented using boxes with three compartments, two of which are\noptional. A class can simply be represented by a box containing the class name,\nwhich is probably su\ufb03cient when the class is \ufb01rst included in the model. The\ntwo optional compartments are the attributes, with the state of an object\nof the class at any time being determined by their values; and a list of the\noperations that the class provides through its methods. The resulting forms,\n", "page": 174, "type": "text", "section": "Page 174"}
{"text": "158\nSoftware Design: Creating Solutions for Ill-Structured Problems\nusing one, two or three compartments are shown in Figure 10.9. Since this is\nquite a \ufb02exible form, we will generally make use of it in the examples that\nfollow.\nExperts draw what they need and no more. PvdH #26\nWe might also note that the class diagram doubles up for the data-\nmodelling role, largely because objects incorporate both methods and data.\n10.5.1\nDistinguishing classes from objects\nAs explained earlier, the distinction between a class and an instantiation\n(object) created from that class can be quite important, particularly for those\nclasses that may be used to create many objects. However, classes may often\nbe used to create a single object, and so the distinction may well be one that\ncan be ignored for much of the process of design.\nHowever, since it can\u2019t be completely avoided, the question is then, how\nto make the distinction. The closeness of form between the two means that\nusing di\ufb00erent shapes is not really a practical way of making the distinction,\nand so this does tend to rely upon annotation. (Unfortunately, for the UML\nin particular, so do rather too many other features.)\nThe mechanism adopted in the UML is to give an object a name that is\nmade up of the name of the speci\ufb01c object, followed by a colon, with this\nthen being followed by the class name. The full name is then underlined, to\nemphasise that it is an object (this is particularly important with anonymous\nobjects, since they simply have a name made up of the class name, preceded\nby a colon). So an object name (in the top compartment) may look like:\nobjectName:Class\n(It is also common practice to use the camelCase style for the object name,\nwhich may also help to make the distinction between an object and a class.\nA camelCase identi\ufb01er is made up of several concatenated words, with all but\nthe \ufb01rst word beginning with an uppercase letter.)\nUnderlining is probably a pragmatic option and certainly preferable to\nmaking use of typographical features such as bold, italics or other forms that\nare not easily sketched on a whiteboard. Figure 10.10 provides a very simple\nexample of a class descriptor and an associated basic object descriptor. The\ncompartments for status information and the key methods have been included\nfor the example of the class descriptor, while the object descriptor just uses\nthe basic compartment containing the identi\ufb01er.\nThe UML provides many options for supplying detail about status and\noperations for both classes and objects, including information about types,\ninitial values and visibility. While possibly relevant for detailed design should\nit be required, these are unlikely to be useful while developing a design and\n", "page": 175, "type": "text", "section": "Page 175"}
{"text": "Modelling Objects and Classes\n159\nCar\nlocation\navailability\nfuel level\noffered\nreserve()\nrelease()\nbeginHire()\nendHire()\nselected:Car\nFIGURE 10.10: The UML class-object notations\nso are not addressed here. More details about these features can be obtained\nfrom specialist texts on OO modelling such as (Arlow & Neustadt 2005) or\n(Lunn 2003).\n10.5.2\nClass relationships\nIn order to make use of the class and object notations we need to be able\nto model the di\ufb00erent relationships that can occur between them. These are\ngenerally drawn as one or more object diagrams that represent the structure\nof an application at some point in time. At its most basic an object diagram\nforms a network model that describes the interactions between a set of objects,\nwhere these interactions chie\ufb02y consist of method calls. (The UML refers to\nthe links between classes as associations.)\nIn the same way that we employ the concept of arity with entity-\nrelationship diagrams, when modelling relationships between classes it may\nbe useful to indicate whether a relationship between two classes is on a one-\nto-one, one-to-many or many-to-many basis. The emphasis here is upon may.\nIf the application consists of a small number of objects, with only one object\nfrom each class, there is little point in cluttering up the model with informa-\ntion about the multiplicity of the relationship.\nAvailable Car\nCCC site\n1\n0..*\nAvailable Car\nCustomer search\n1..3\n0..*\nFIGURE 10.11: Use of class multiplicity annotation\nFigure 10.11 illustrates the use of multiplicity for two simple examples\nfrom the CCC. The upper one indicates that a CCC site (assuming that CCC\n", "page": 176, "type": "text", "section": "Page 176"}
{"text": "160\nSoftware Design: Creating Solutions for Ill-Structured Problems\nexpand their business to other cities) can have between zero and many cars\navailable. The lower one indicates that a car that is available can respond to\nany number of requests, but that the \u2018search object\u2019 for a customer may only\nselect up to three cars.\nHorri\ufb01ed purist\nThe UML has some less than inspiring no-\ntations for indicating di\ufb00erent forms of relation-\nship between classes. However, it also provides\nthe quite useful concept of a stereotype, which\ne\ufb00ectively allows a new modelling element to be\nintroduced that is based upon an existing one.\nStereotypes are created by placing the name of\nthe stereotype between guillemots (\u00ab...\u00bb) and us-\ning it to label the line indicating the relationship.\nAlthough it might horrify a UML purist, using\nstereotypes as a means of clarifying intended re-\nlationships, especially when sketching, may be\nmuch clearer than using the graphical symbols\nde\ufb01ned in the UML.\nWhen describing class\u2013instance relationships\nwe might therefore use the stereotype \u00abinstanti-\nate\u00bb. Another useful one is \u00abuse\u00bb (this one is so obvious that it can simply\nbe treated as a default). The role of \u00abcreate\u00bb is likewise obvious. Although\nnot advocated by the UML, it may also be useful to use stereotypes for other\nrelationships such as \u00abinherit\u00bb and \u00abaggregate\u00bb. Reducing the number and\ncomplexity of symbols is a useful step when dealing with objects and doing\nso in this way reduces the cognitive load. It also demonstrates that you don\u2019t\nhave to use the formal semantics of a notation, especially when sketching ideas.\nVan\nVehicle\nCar\nVan\nVehicle\nCar\n<<inherits>>\nFIGURE 10.12: UML class inheritance annotation versus using stereotypes\nFigure 10.12 shows the conventional UML notation for inheritance on the\nleft, and the use of a stereotype on the right. There is de\ufb01nitely an argument in\nfavour of using the stereotype for showing such a diagram to anyone unfamiliar\nwith the UML, as well as when sketching on a whiteboard. However, one thing\nthat can be harder to capture this way is the direction in which the \u2018\ufb02ow\u2019 of\ninheritance should be read (although many might \ufb01nd the UML notation\nconfusing anyway, in terms of the apparent \u2018\ufb02ow\u2019 implied by the triangle). So\n", "page": 177, "type": "text", "section": "Page 177"}
{"text": "Modelling Objects and Classes\n161\ncareful positioning of the indexstereotype stereotype or using an additional\narrowhead as shown here might sometimes be helpful.\nOther forms of association, including aggregation and composition can be\nused when modelling classes and objects. And of course, we can add polymor-\nphism and abstract classes to our use of inheritance. All of this explains why\nbooks on modelling with the UML tend to be large\u2014as classes and objects\nare much more complex design elements than processes. So, in fairness, while\nthe UML itself may often be cumbersome as a modelling tool, it is required\nto provide ways of modelling some potentially very complex structures.\n10.6\nModelling behaviour: the statechart and the mes-\nsage sequence diagram\nThe idea of state plays a much bigger role for objects than it does for\nprocesses, not least because the use of encapsulation means that an object is\nvery likely to contain persistent information related to its role and identity.\nAnd because an object can have many external methods, there can also be\nmany ways of accessing and modifying that state.\nObject modelling commonly makes use of two forms for modelling be-\nhaviour. The statechart (or \u2018state diagram\u2019) is used to model the way that the\nstate of some entity (which may be an object, or a subsystem, or a complete\napplication) is modi\ufb01ed by interaction with the events occurring in the ex-\nternal world. And the message sequence diagram, or message sequence graph\n(MSG) can be used to model the way that events are triggered and handled\nover time. Actually, sequence diagrams are not entirely about behaviour, they\ncan also be viewed as describing some aspects of function, highlighting the\nproblem with any simple classi\ufb01cation system! However, regardless of how we\nclassify them, sequence diagrams (or sequence graphs; both terms are used)\nrepresent a useful modelling tool for thinking about the interactions that occur\nbetween objects.\n10.6.1\nThe statechart\nLike the state transition diagram that was described in Section 9.3, the\nstatechart is concerned with describing the behaviour of a \u2018system\u2019 as a form\nof \ufb01nite-state automaton, or \ufb01nite-state machine. Used at the system level\nit can be a good way of modelling the behaviour of reactive applications,\nresponding to external events. Used at the object level, it can describe how\nan object responds to the requests created by its \u2018response set\u2019.\nThe statechart was devised by David Harel, and he has observed that\nit is based upon the more general mathematical concept of the higraph\n", "page": 178, "type": "text", "section": "Page 178"}
{"text": "162\nSoftware Design: Creating Solutions for Ill-Structured Problems\n(Harel 1987, Harel 1988). It provides a rather more \ufb02exible modelling form\nthan the STD, and in particular, it incorporates the facility for creating a hier-\narchy of abstractions. It also o\ufb00ers the facility to describe transitions that are\northogonal, in the sense that they can occur completely independently of each\nother, so making it possible to model transitions that can occur in parallel.\nAnd like the STD, it can be used to model the behaviour of a \u2018problem\u2019 (black\nbox) as well as of a \u2018solution\u2019 (white box). The UML has largely adopted the\nform of statechart devised by Harel (but of course, not quite).\nThe original paper (1987) provides an excellent tutorial on statecharts and\ntheir powers of description. In this, the author uses the functions of a digital\nwatch with two alarms to provide examples. Our examples here are somewhat\nless dramatic and extensive, but should provide essential ideas about how to\nuse this form.\nA state is denoted by a box with rounded corners, labelled with the name\n(identi\ufb01er) for the state in the top of the box. Hierarchy is represented by\nencapsulating states within states, and directed arcs are used to represent a\ntransition between states. The arcs are also labelled with a description of the\nevent that triggers that transition, and optionally, with a parenthesised con-\ndition. (Conditions are quite common in the real world. For example, it might\nnot be possible to engage a cruise control mechanism in a car\u2014representing\na change in its state\u2014while the car is accelerating.)\nengine off\nstart\nignition off\nengine running\nidling\nmove \nforward\nreverse\nselect\ngear\nbrake\nbrake\nengage\nFIGURE 10.13: A simple statechart describing driving a car\nFigure 10.13 uses a statechart to provide a very simple state model that\ndescribes the use of a car. At the top level it simply has two states that\nrepresent the car when the engine is o\ufb00and when it is running. The default\ninitial state is indicated by the short arrow with a black dot on the end.\nTransitions between these states are caused by pressing the starter (or waving\na card) and by turning the ignition o\ufb00. There are three sub-states when the\nengine is running. The initial state has the engine idling and no gear selected.\nTo change to going forward we select a gear, and to stop we brake (OK, there\nare other ways, but this is a simpli\ufb01ed diagram). Engaging reverse we have\nlabelled the transition as \u2018engage\u2019 to emphasise that there is usually only one\n", "page": 179, "type": "text", "section": "Page 179"}
{"text": "Modelling Objects and Classes\n163\nsuch gear, and again, stopping involves braking. And of course, there are no\ntransitions between going forwards and reverse (again, this might be possible,\nbut it is usually extremely unwise).\nThis is a very simple model that wouldn\u2019t even be recommended for one\u2019s\n\ufb01rst driving lesson (it doesn\u2019t allow for slowing down and accelerating when\nmoving forward as one example), but it is su\ufb03cient to show the essential ideas,\nand particularly the use of hierarchy.\ncruising\nin flight\nlanding\napproach\nstacked\non ground\nparked\ntaxiing\ntouch down\ntake-off\nFIGURE 10.14: A simple statechart describing an aircraft in an ATC system\nModelling watches and cars has the advantage that the events that cause\ntransitions between states are directly identi\ufb01able in terms of button presses\nor using a gear lever. Figure 10.14 reworks the example provided in Figure\n9.6, describing an air tra\ufb03c system, to use a statechart formalism. (Some of\nthe labels for the internal transitions have been omitted for clarity.)\nWhen comparing this with the STD used in Figure 9.6, we can see that\nwhile the descriptions of state, event and transition are common to both, the\nSTD provides a more detailed description in terms of the associated actions,\nwhile the statechart has more re\ufb01ned mechanisms for describing abstraction,\ndefaults and scale. The lack of hierarchy limits the STD to being used to de-\nscribe the behaviour of individual design elements, whereas the statechart can\nbe used to describe complete systems through a hierarchy of diagrams and\nstates. To some degree the strengths of the two forms are probably comple-\nmentary, with the STD perhaps being more suited to modelling descriptions\nof \u2018problems\u2019 and the statechart being better suited to describing detailed\n\u2018solutions\u2019.\nThe remaining major feature of the statechart that should be described\nhere is orthogonality. Our example here, shown in Figure 10.15, is rather more\nabstract in order to highlight the mechanisms involved.\n", "page": 180, "type": "text", "section": "Page 180"}
{"text": "164\nSoftware Design: Creating Solutions for Ill-Structured Problems\nA\nB\nC\nD\nE\na\nF\nH\nG\nb\na\nb(P)\nFIGURE 10.15: Describing orthogonality in the statechart formalism\nIn our example, state \u2018A\u2019 can be described as being a superstate of two or-\nthogonal states \u2018B\u2019 and \u2018C\u2019. These can in turn be described in terms of further\nstates \u2018D\u2019 to \u2018G\u2019 but the two states involve what are essentially independent\ngroupings. However, events may be common as can be seen from the descrip-\ntion of the transitions that occur in response to event \u2018a\u2019. Also, in describing\nA, note that we need to identify the default entry to both states \u2018B\u2019 and \u2018C\u2019\n(the inner states \u2018D\u2019 and \u2018F\u2019). There is also a conditional transition between\nstates \u2018F\u2019 and \u2018G\u2019, where an event \u2018b\u2019 will cause a transition only if condition\n\u2018P\u2019 is satis\ufb01ed.\nThe statechart is a powerful modelling tool for thinking about objects,\nand can also be used for modelling of executable use cases/scenarios (Harel &\nGery 1997). Again, it is easily sketched on a whiteboard or on paper.\n10.6.2\nThe message sequence diagram\nSequence diagrams have proved to be particularly useful with object-\noriented modelling. This is probably at least in part because they provide\na means of modelling the interactions between di\ufb00erent elements of a system,\nwhether these be objects, actors, remote processes, or client and server. Since\nessentially they model collaboration, in this case object collaboration, they\ncan be used with any architectural style that has loosely coupled elements.\nSequence diagrams can also be useful for modelling the interactions in-\nvolved in a use case (or more correctly, in a speci\ufb01c scenario). Use cases have\nproved to be a useful tool for modelling object-oriented systems, so this tends\nto reinforce the value that they have for this type of modelling. The UML\n(inevitably) incorporates sequence diagrams, describing their form as follows.\n\u201cA diagram that shows object interactions arranged in time se-\nquence. It shows the objects participating in an interaction and the\nsequence of messages exchanges\u201d (Rumbaugh et al. 1999).\n", "page": 181, "type": "text", "section": "Page 181"}
{"text": "Modelling Objects and Classes\n165\nA sequence diagram can be viewed as being a dynamic interpretation of\na class model. It is concerned with how and in what order those elements in\nthe class diagram interact, whereas the class diagram simply identi\ufb01es that\nthey do interact and collaborate. For this chapter at least, they have been\ncategorised with the behavioural viewpoint because they essentially deal with\ninteractions between objects (and really don\u2019t \ufb01t with any other viewpoint\neither). And like many behavioural forms, it is not hierarchical, and hence\ndoesn\u2019t cope particularly well with large-scale patterns of interaction between\nmany elements. And again, like other behavioural forms they can usefully be\nemployed to describe \u2018problems\u2019 as well as \u2018solutions\u2019.\nATM\ninterface\nBank\ncustomer\nBank\naccount\nBank\nvalidation\nInsert\ncard\ncheck\nvalid\ncard\nrequest PIN\nenter PIN\nPIN\ncheck\nvalid\nPIN\noffer\ntransactions\nselect\nwithdraw\namount\nauthorise\nvend cash\nreceive\nmoney\nFIGURE 10.16: A simple example of a sequence diagram\nThe organisation of a sequence diagram is dominated by the use of a time-\nline, which conventionally runs from the top of the page downwards. (Obvi-\nously, where there is a need to indicate the lapse of speci\ufb01c time intervals, such\na diagram might be drawn to scale on the vertical axis, but generally only the\nsequential organisation is described. Each processing element, usually a class\nor object, or possibly some other system \u2018actor\u2019 is allocated a column and\nmessages between them are shown as horizontal lines between the columns.\nWhile the UML provides a very extensive and detailed syntax for modelling\nwith sequence diagrams, it is worth noting that they are relatively easy to\nsketch and only need limited annotation. Indeed, they can be drawn with\n", "page": 182, "type": "text", "section": "Page 182"}
{"text": "166\nSoftware Design: Creating Solutions for Ill-Structured Problems\na quite minimal set of symbols. Figure 10.16 shows a simple example of a\nsequence diagram based upon drawing money from a \u2018hole-in-the-wall\u2019 bank\nmachine. This shows a strength of the notation, in that it is easy to discuss\nwhether or not this shows the \u2018right\u2019 distribution of tasks, or issues that have\nbeen omitted (such as what happens if the cash dispenser is empty). It also\ndemonstrates a limitation, in that any sequence diagram used to describe a\nsystem model or a design model tends to illustrate just one use case/scenario\n(Ratcli\ufb00e & Budgen 2001). (In this role it is known as an \u2018instance\u2019 form\nof sequence diagram. There is also a \u2018descriptor\u2019 form that can be used for\nsystems analysis and can be used for describing all possible scenarios. Since\nour main concern here is design, we focus on the instance form in this section.)\nCCC\nreservation\nsystem\nCCC\nmember\nCCC\nbilling\nsystem\nCCC\ncar\nSelect\ncar\nconfirm\nstill\navailable\nselectCar()\ncheck\ncode\nAccess\ncar\nsend keycode\nsend keycode\nenterCode()\nopen car\nrecord use\nFIGURE 10.17: Designing with a sequence diagram\nFigure 10.17 shows a sequence diagram being used in what is more of a\ndesign role, and being used to model how a CCC member will perform the\noperation of selecting and accessing a car. So now the elements at the top of\nthe time lines are classes (or objects) rather than external entities as in our\nprevious example.\nThis also re\ufb02ects a wider issue that the objects involved in this sequence\nmust be appropriately related in the corresponding class diagram. Maintaining\n", "page": 183, "type": "text", "section": "Page 183"}
{"text": "Modelling Objects and Classes\n167\nthis form of consistency is a challenge, particularly during more detailed design\nactivities.\n10.7\nModelling function: the activity diagram\nOne viewpoint where the UML does make a useful contribution to the\nset of notations is the functional viewpoint. UML activity diagrams can be\nused to model the way that a business operates and, like DFDs, can help\nwith analysing the needs of a problem. (There are no really good notations\nfor describing function when using objects. This is perhaps not surprising as\nunlike many processes, an object often doesn\u2019t have a single functional task.)\nIn particular, an activity diagram can be useful for modelling the type\nof \u2018coordinating\u2019 situation where a given computation cannot proceed until\ncertain conditions are met (for example, new data is available and a prior\ncomputation has completed). The diagram does model states, but these now\nrepresent the performance of actions, and the focus of interest is upon what\ntriggers transitions between the states. This emphasis upon action is why it\nhas been categorised as functional here. However, rather as with sequence\ndiagrams, an activity diagram can be viewed as providing a mix of functional\nand behavioural aspects in its description.\nSome key notational elements are as follows.\n\u2022 The activity, which is a task performed by the application and is shown\nas a named box with rounded sides.\n\u2022 A state, which can be viewed as being an activity where nothing happens.\n\u2022 A transition, where work \ufb02ows between activities, shown as an unlabelled\narrow. The lack of a label is because, unlike the case of a statechart,\nthe transitions arise from the actions of the activities themselves, not\nbecause of external events.\n\u2022 A decision, represented by a diamond, where a work\ufb02ow divides between\npossible branches. When used, it is then necessary to label the transitions\nto indicate which condition is employed for a particular route.\n\u2022 The synchronisation bar is a thick horizontal line that represents the\ncoordination of the activities. When all of the transitions into a bar\nare complete (the coordinating bit) then the outward transitions will be\n\u2018\ufb01red\u2019.\nEntry and exit from a diagram are shown respectively by a short arrow with\na \ufb01lled dot on its tail, and a \ufb01lled dot with a circle around it. There can only\n", "page": 184, "type": "text", "section": "Page 184"}
{"text": "168\nSoftware Design: Creating Solutions for Ill-Structured Problems\nFIGURE 10.18: An activity diagram describing booking a car\nbe one entry point, but there may be many exit points. This is illustrated in\nthe sketch of the CCC booking process shown in Figure 10.18.\nFigure 10.19 uses the bank teller machine example to illustrate the use\nof synchronisation bars. One shows division of transitions (where multiple\nactions occur after a coordinating action, termed a fork), the second where an\noperation can only proceed after two transitions have completed (a join).\n", "page": 185, "type": "text", "section": "Page 185"}
{"text": "Modelling Objects and Classes\n169\nprocess\ncard\nprocess\nrequest\nreturn\ncard\ncheck\naccount\nobtain\nrequest\ncard accepted\ncard\ndeclined\nissue cash\ninsufficient\nfunds\nFIGURE 10.19: An activity diagram using synchronisation bars\n10.8\nUse cases\nThis is a good point to discuss something that has been mentioned previ-\nously in this chapter, namely the idea of a use case.\nThe idea of the scenario describing a particular way that an application is\nused is one that has been employed informally over many years as a convenient\ndescription of, and way to think about, system behaviour. Ivar Jacobson made\na valuable contribution to design modelling when he generalised this idea\ninto that of a use case, formalising it as a tool for thinking about software\ndesign (Jacobson, Christerson, Jonsson & Overgaard 1992). Not surprisingly,\n", "page": 186, "type": "text", "section": "Page 186"}
{"text": "170\nSoftware Design: Creating Solutions for Ill-Structured Problems\nhis involvement in the formulation of the UML meant that use cases are a key\nelement of this too.\nWe can draw an analogy between the relationship between a use case and\na scenario and that of a program and a process executing on a computer. A\nprogram describes the rules for performing a set of possible actions, and a\nprocess comprises a particular instantiation of that program. Similarly, a use\ncase represents a set of possible interactions between an application and other\nactors (where these can be devices, people, other pieces of software etc.), while\na scenario will describe a particular sequence of these interactions.\n<< title >>\nUse case (title is used to indicate the activity\ncovered by this use case).\nActor (not necessarily a human) representing\na role in a use case.\nIndicates <<communication>> between actor\nand use case (the only form of link used\nbetween these two elements).\n<<generalisation>> that links the varieties of\na use case with the more general form.\n<<include>> or <<extend>> relationships\nbetween use cases where one use case\nmakes use of other use cases, labelled to\nindicate the particular form employed.\nFIGURE 10.20: Elements of a UML use case diagram\nA major attraction of employing use cases is the ability to document a\nset of user interactions with the application, and then to use the associated\nmessage sequences for a given system con\ufb01guration to guide the design of an\nobject model that will implement that application behaviour. Using a common\nabstraction to describe both behaviour and object model can help with the\ndesign modelling process.\nThe UML use case diagram expresses the idea of a use case at a fairly\nhigh level of abstraction. Figure 10.20 shows the basic elements of a use case\ndiagram. The use case itself is shown as an oval, and represents \u201ca logical\ndescription of a slice of system functionality\u201d (Rumbaugh et al. 1999). Actors\nare (perhaps confusingly at times) usually represented by stick \ufb01gures. Fi-\nnally, there are four kinds of relationship shown in the \ufb01gure, although two of\nthese share a single representational form and hence need to be labelled with\n", "page": 187, "type": "text", "section": "Page 187"}
{"text": "Modelling Objects and Classes\n171\na stereotype in order to distinguish them. As we should note, the use case\ndiagram is easy to sketch, and made even easier when designing because for\nmost purposes, we only need the use case, actor and communication symbols.\nLike other descriptive forms that are used with objects, the use case dia-\ngram is di\ufb03cult to classify using the viewpoints model. The use case is con-\ncerned with the interactions that occur between a system and its environment,\nand hence can have a behavioural aspect. But they are also concerned with the\ntasks that an application performs, and so have a functional aspect in their\nrole. (Since we can sometimes describe scenarios and use cases using message\nsequence diagrams, this mix is to be expected.)\nFigure 10.21 shows a simple use case diagram for part of the CCC, again\nrelating to the car reservation process.\nrequest\ncar\nselect and\nreserve car\nunlock\ncar\nend use\nof car\nCar Reservation\nCCC\ncustomer\nBilling\nsubsystem\nFIGURE 10.21: Example of a UML use case diagram\nIn this model, the process of reserving a car involves four use cases, one to\nhandle the initial request, another to negotiate the choice of a car, the third\nconcerned with the user opening the car and \ufb01nally depositing the car at the\nend of the session. The customer is an actor in all of these, while the billing\nsubsystem is only an actor participating in the last two (when the customer\nactually claims and uses the car).\nThe UML use case diagram itself is largely concerned with the identi\ufb01-\ncation of use cases and the set of actors acting as participants in these. The\nmeans of creating a detailed speci\ufb01cation of a use case is largely a matter of\nchoice. It might involve the use of sequence diagrams, and possibly of some\nform of textual speci\ufb01cation too. The latter might identify such aspects as\nthe participating actors, pre-conditions for the use case to occur, details of\n", "page": 188, "type": "text", "section": "Page 188"}
{"text": "172\nSoftware Design: Creating Solutions for Ill-Structured Problems\nactions involved and then post-conditions when the use case ends. Figure\n10.22 provides a simple example for one of the use cases in Figure 10.21.\nUSE CASE: Unlock car\nACTOR: CCC Customer, Billing Subsystem\nPRE-CONDITIONS:\n  Customer has selected car\n  Car is still available\n  Customer has received a PIN\n  Customer is near to car\nUSE CASE BODY:\n  1. User enters PIN in keypad or phone.\n  2. Car is unlocked by application.\n  3. Billing subsystem is notified of time, customer\n      ID, car ID and location.\n  4. Customer begins use of car.\nPOST-CONDITIONS:\n  Billing system starts record for session.\nFIGURE 10.22: Example of a UML use case\nThe Uni\ufb01ed Process (UP), described in Chapter 13, inevitably employs\nuse cases, and they have been widely employed formally and informally. Use\ncases can also be related to the concept of the user story as employed in\nagile software development (Jacobson, Spence & Kerr 2016). They are not\nparticularly dependent upon the use of an object-oriented architecture either,\nalthough they have made a particular contribution to applications of that\nform.\n10.9\nEmpirical knowledge about modelling objects and\nclasses\nThis is a large chapter, and so this section has been organised around three\nimportant aspects of object-orientation that are described here. The \ufb01rst is\nthe object model itself; the second is the di\ufb00erent notations used for the UML;\nand the third relates to metrics used with objects.\n", "page": 189, "type": "text", "section": "Page 189"}
{"text": "Modelling Objects and Classes\n173\n10.9.1\nThe object model\nWhile classes and objects have a long history in software development,\nstemming back to the 1960s, and have been employed widely for that pur-\npose, there is surprisingly little in the way of empirical studies related to\ndesigning applications using objects. A systematic mapping study examining\nthis (Bailey, Budgen, Turner, Kitchenham, Brereton & Linkman 2007) found\nonly 138 studies, with nearly half of these being concerned with metrics, 10\nwith the use of design patterns, and 19 with comparing the use of OO with\nnon-OO forms. The most widely-used form was the laboratory experiment\n(arguably not the most e\ufb00ective tool for studying long-term design issues)\nwith observational studies and case studies making up the form of empirical\nstudy for just under half of the papers found.\nWhat that mapping study did not include was what we term experience\npapers and material from the grey literature. It may well be that these are\nused very widely to record design experiences in an informal manner.\nPerhaps we should not be that surprised at the relatively small number of\nformal studies. There are even fewer studies looking at earlier forms of software\narchitecture such as call-and-return, and the nature of design is such that\nmaking simple comparisons (such as call-and-return versus object-oriented)\nis a fairly pointless exercise. Questions that are more useful are going to be\nthose relating to such issues as the relative ease of learning how to use di\ufb00erent\nmodelling forms (such as the study by (Vessey & Conger 1994), and guidance\nabout how to use the di\ufb00erent modelling approaches.\nThe systematic review by Tiwari & Gupta (2015) examines the evidence\nabout the di\ufb00erent roles performed by use cases. They found that use case\nspeci\ufb01cations were typically employed for two perspectives. The \ufb01rst was for\ndocumenting functional requirements, while the second was for generating the\nlower-level software artifacts, particularly through model transformation.\n10.9.2\nObject modelling notations\nEssentially, the only widely documented source of object modelling nota-\ntions is the UML. In addition to the analysis of visual notations by Moody\n(2009) which discusses many of the UML notations, there have been a number\nof studies looking at particular notations. The systematic review reported in\n(Budgen, Burn, Brereton, Kitchenham & Pretorius 2011) identi\ufb01ed 49 studies,\nwith metrics and comprehension being the two topics studied most extensively.\nMost studies were laboratory studies, with relatively few \u2018\ufb01eld\u2019 studies.\nThe subsequent survey by Petre (2013) also emphasised that the UML was\nnot widely used in practice, although it was sometimes used for documenta-\ntion. Of course, while the UML was not used formally, this does not rule out\nthe possibility that its forms did in\ufb02uence the informal notations used by\ndesigners.\n", "page": 190, "type": "text", "section": "Page 190"}
{"text": "174\nSoftware Design: Creating Solutions for Ill-Structured Problems\n10.9.3\nObject-oriented metrics\nThe systematic review by Radjenovi\u0107 et al. (2013) looked at the value of\ndi\ufb00erent metrics for software fault prediction. It found that the Chidamber &\nKemerer metrics were the most successful of the available OO metrics, with\nCBO, WMC and RFC being the most successful, while DIT and NOC were\nunreliable.\nWe might note here that from a measurement-theoretic perspective,\nLCOM is considered to be \u2018theoretically invalid\u2019 (Litz & Montazeri 1996),\nalthough from our perspective, it does identify a design property that may be\nimportant for objects. Kitchenham (2010) also observes that CBO is \u2018\ufb02awed\u2019\nbecause it treats \u201cforward and backward links as equivalent\u201d arguing that\nthese may not present equal di\ufb03culty of understanding, and hence have dif-\nferent in\ufb02uence upon likely faults. Again, from a design perspective, our main\nconcern is the existence of such links, rather than their role.\nKey take-home points about modelling objects and classes\nModelling the attributes of objects and classes uses a range of di\ufb00erent\nforms to address the main viewpoints for each type of design element.\nObjects are complex. The structures and properties of objects (and\nclasses) are much more complex than those of processes, necessitating\nthe use of more viewpoints together with the need to model a range of\nrelationships as well as the elements.\nClasses and objects. Both classes and objects are important design ele-\nments when developing design models\u2014and there is no \u2018right\u2019 abstrac-\ntion to employ for describing their properties in all circumstances. They\ncan also be di\ufb03cult to identify when creating the object model.\nRelationships can have many forms. This aspect of object modelling\ncan be challenging since there are many forms of relationship that can\noccur between objects, with properties that may need to be represented\nin di\ufb00erent ways.\nLearning to model objects is challenging. Studies suggest that object-\noriented modelling is harder to learn than the use of simpler forms such\nas processes.\nModelling objects needs a mix of notations. The di\ufb00erent characteris-\ntics require a mix of forms, and these also need to be kept consistent (a\npotentially useful role for tools).\n", "page": 191, "type": "text", "section": "Page 191"}
{"text": "Modelling Objects and Classes\n175\nObject notations make poor use of visual separation. Popular forms\nof diagrams, such as most of those used in the UML, tend to use a\nlimited set of shapes and symbols, and make excessive use of shapes\nsuch as oblongs. The range of possible relationships adds to this, as it\nis even harder to devise distinct visual forms for these.\n", "page": 192, "type": "text", "section": "Page 192"}
{"text": "Chapter 11\nModelling Software Components and\nServices\n11.1\nReuse .............................................................\n178\n11.2\nModelling software components ..................................\n180\n11.2.1\nComponent characteristics ..............................\n181\n11.2.2\nComponent frameworks .................................\n183\n11.2.3\nDesigning components ...................................\n185\n11.2.4\nCOTS ....................................................\n186\n11.3\nModelling software services ......................................\n187\n11.4\nEmpirical knowledge about modelling components and services\n190\n11.4.1\nEmpirical knowledge about components ................\n190\n11.4.2\nEmpirical knowledge about services .....................\n191\nKey take-home points about modelling components and services\n191\nThis chapter looks at two quite di\ufb00erent approaches to the idea of reusing\nsoftware that has been developed by others. The concept of the software com-\nponent has been around for many years\u2014indeed, the concept of reusable blocks\nof software was put forward at the inaugural Software Engineering conference\nin 1968 by Doug McIlroy. Building on this concept, Component-Based Soft-\nware Engineering (CBSE) has had the goal of enabling a software developer\nto be able to make use of pre-existing reusable \u2018chunks\u2019 of software in order\nto create (or \u2018compose\u2019) an application. In many ways the service paradigm\nrepresents an evolution of this idea. While it largely aims to do the same\nthing, the means of realising it is very di\ufb00erent. Here the software itself is\nprovided by third parties, and is hosted and executed elsewhere (typically in\nthe cloud) rather than being embedded within the application, enabling easy\nsubstitution of di\ufb00erent providers.\nEach of these technologies poses challenges regarding both about how to\ndesign the reusable elements themselves as well as how to design an application\nto make use of existing resources. For the moment though, we concentrate\non the forms those resources can take and how to model them, leaving the\nquestion of how to design applications around them until a later chapter.\nHowever, since reuse is so important for both, we begin by discussing its role\nand in\ufb02uence.\n177\n", "page": 194, "type": "text", "section": "Page 194"}
{"text": "178\nSoftware Design: Creating Solutions for Ill-Structured Problems\n11.1\nReuse\nFor other domains in which design performs an important role, the idea\nof reuse is fairly well established and takes a range of forms. It is sometimes\nassociated with the abstract reuse of design ideas and experiences, rather than\nof physical elements, and we will look at this aspect in Chapter 15 when we\nexamine how the concept of a pattern can be employed.\nWhere the manufacturing cycle is important, then it is also associated\nwith the interchangeability of physical components, not least because creating\n\u2018product lines\u2019 can help reduce the cost of the individual product1. Mechanical\nengineering in its many forms makes extensive use of components, as do the\nelectrical engineering and construction industries. In all of these, the use of\nstandardised units helps with manufacture and maintenance. Their use also\nchanges the nature of the design process by introducing the notion of compo-\nsition.\nOrganisational and other processes themselves can be reused too. We can\nsee this in the way that production lines in factories can be re-organised and\nre-purposed to create new products.\nSuccessful reuse of pre-existing elements is commonly based upon two im-\nportant characteristics.\n\u2022 The \ufb01rst is that the role of a reusable component is associated with\nsome well-de\ufb01ned functionality. Most physical components have very\nwell-de\ufb01ned roles (switch, pump, door handle, starter motor, etc.) mak-\ning it possible for the designer to select suitable items from a catalogue.\n\u2022 Secondly, the components themselves usually have well-de\ufb01ned inter-\nfaces, enabling ready composition with other components that meet the\nsame standard, as well as easy substitution of one manufacturer\u2019s com-\nponent with one from another maker. This can also help with identi\ufb01-\ncation of suitable ones in a catalogue. In manufacturing this can mean\nthat there may be several manufacturers who are able to provide a par-\nticular component (\u2018second sourcing\u2019), providing users with con\ufb01dence\nthat they will be able to obtain adequate supplies.\nThese are not accidental properties, but rather, they are ones that arise from\neconomic factors. These factors include the need to minimise the cost of fabri-\ncating an item; pressure to maintain a marketplace position; and the end-user\u2019s\nneed to protect their supply chain (here the end-user will be the manufacturer\nwho is making use of a given component in their own product). The adoption\n1One of the earliest examples of a product line is probably when Sir Marc Brunel (fa-\nther of Isambard Brunel) established his block-making machinery in Portsmouth dockyard\naround 1806. This introduced an important element of standardisation in the \ufb01tting out of\nsailing ships, which used large numbers of blocks as part of their rigging.\n", "page": 195, "type": "text", "section": "Page 195"}
{"text": "Modelling Software Components and Services\n179\nof interface standards may be motivated in a number of ways: one manufac-\nturer may be so dominant that their interface becomes widely accepted; an\nindustry (or professional body) may take on the role of de\ufb01ning the necessary\nstandards (as has happened widely with electrical connectors); or a group of\nmanufacturers may come together to agree on a common standard.\nReuse can be facilitated by the availability of catalogues of components.\nHowever, the way that such catalogues are used during the design process\nappears to be less well understood. Pugh (1991) provides an example of this\nin the domain of electronic engineering, in quoting from Cooke (1984).\n\u201cThe designer of electronic-based products has available an enor-\nmous range of basic building blocks of high or still increasing com-\nplexity. What he often does not have is either training or well-\nestablished conceptual tools for working out levels of sophistica-\ntion.\u201d\nSimilarly, in Pahl & Beitz (1996), a textbook that is widely cited as a repos-\nitory of engineering design knowledge, the discussion of \u2018design catalogues\u2019\nis almost entirely con\ufb01ned to consideration of how such a catalogue will be\nconstructed rather than how it might be used.\nIf we turn our attention to the reuse of software, we \ufb01nd that, despite the\nlack of a manufacturing phase, reuse of software components has had a long\nhistory of success in some areas. An often-cited example is the set of mathe-\nmatical and statistical functions provided in the NAG (Numerical Algorithms\nGroup) library that was \ufb01rst released in 1971. The set of functions and the\nprogramming languages supported has gradually expanded over the years, and\nthe routines it provides do of course meet our two criteria above, having well-\nde\ufb01ned functionality and well-de\ufb01ned interfaces. Other examples include user\ninterface packages such as tk and tools such as MATLAB R\n\u20ddthat provide an\nenvironment of \u2018components\u2019. Component models such as CORBA (Common\nObject Request Broker Architecture) have assisted further by de\ufb01ning inter-\nface standards to enable local and distributed components, possibly written\nusing di\ufb00erent programming languages, to work together.\nHowever, because software is so easily adapted and modi\ufb01ed, it would\nalso be true to say that examples of wide reuse, in the sense of embodying one\n", "page": 196, "type": "text", "section": "Page 196"}
{"text": "180\nSoftware Design: Creating Solutions for Ill-Structured Problems\nsoftware product within another, are relatively rare. Where they do occur then\nthere may be special factors that constrain this freedom. (Network protocols\nprovide a good example of this\u2014there is little point in producing unique\nnetwork protocols if you want your software to work with other applications.)\nIndeed, although the bene\ufb01ts of reuse are often extolled by software en-\ngineers (and vendors of software), for example, when considering the bene\ufb01ts\nof an architectural form such as the object model, attempts to incorporate\nit more fully into software development practices have not been widely suc-\ncessful. In the rest of this chapter we describe two approaches to software\ndevelopment that focus on reuse, and examine the issues associated with their\ncreation and use.\n11.2\nModelling software components\nThe idea of component-based software engineering (CBSE) began to attract\ngreater attention in the 1990s, and in some ways the concept of a component\nformed an evolution of the idea of the object. And, as with objects, ideas about\nprecisely what constitutes a component could be di\ufb03cult to pin down. Indeed,\nwhen writing an introduction to a special journal section on CBSE, Brown &\nWallnau (1998) observed (slightly tongues-in-cheeks), that:\n\u201cCBSE is a coherent engineering practice, but we haven\u2019t fully\nidenti\ufb01ed just what it is\u201d.\nNote though, the use of the word \u2018practice\u2019, as it could certainly be argued\nthat one of the motivations of research into CBSE was to seek something that\ncould be more tractably \u2018engineered\u2019 and composed together than objects.\nOne of the challenges of codifying CBSE was to determine just what a\ncomponent is. An early de\ufb01nition from Brown & Short (1997) very concisely\ndescribed a component as:\n\u201can independently deliverable set of reusable services\u201d.\nNote too that this de\ufb01nition made no explicit assumptions about architectural\nstyle\u2014so that a component could be realised as anything from an object to\nan operating system. The emphasis here is upon reuse (needing a clearly\nspeci\ufb01ed interface) and upon the idea of independent delivery. This second\naspect is important since it implies that a component should not be aware of its\ncontext, especially in terms of any embedded dependencies or the expectation\nof the presence of some shared resource. There is also the implication that a\ncomponent needs to be integrated with other components in order to provide\nthe overall system functionality. In other words, it is a part, rather than a\nwhole.\n", "page": 197, "type": "text", "section": "Page 197"}
{"text": "Modelling Software Components and Services\n181\nThe pioneering text on software components by Szyperski (1998) provided\na rather more extensive de\ufb01nition of what a component was considered to be.\n\u201ca unit of composition with contractually speci\ufb01ed interfaces and\nexplicit context dependencies only. A software component can be\ndeployed independently and is subject to third-party composition.\u201d\nWhile addressing the same properties as the more abstract de\ufb01nition provided\nby Brown and Short, this added the concept of black box reuse, required if it\nwas to be used by third parties.\nA slightly more evolved de\ufb01nition was that provided in Heineman & Coun-\ncill (2001), where a software component was de\ufb01ned as:\n\u201ca software element that conforms to a component model and can\nbe independently deployed and composed without modi\ufb01cation ac-\ncording to a composition standard\u201d\nThis de\ufb01nition is interesting because it separates out two further supporting\nconcepts, which are those of:\n\u2022 the component model that incorporates \u2018speci\ufb01c interaction and compo-\nsition standards\u2019; and\n\u2022 the composition standard, that \u2018de\ufb01nes how components can be com-\nposed\u2019 to create a larger structure.\nBoth of these are important concepts in terms of considering how we can design\nwith components, and also how components themselves should be designed in\norder to be usable. Indirectly, they also raise the question of architectural style,\nand the extent to which the process of composition may need to be con\ufb01ned\nto applications using an architectural style that conforms to the \u2018standard\u2019\nbeing used.\nNone of these de\ufb01nitions are really contradictory. Where they di\ufb00er is in\nthe level of abstraction required to express the ideas, and which of the many\naspects of a component they emphasise. It is worth noting that there may also\nbe business factors that in\ufb02uence the component model and its acceptance\n(Brereton & Budgen 2000) (a more business-focused view of CBSE is also\npresented in Brown (2000)).\nAnd as we will see when addressing the second topic of this chapter, the\nevolution of these de\ufb01nitions has distinct parallels with the emergence of the\nidea of a software service.\n11.2.1\nComponent characteristics\nOf course, not only have ideas about the nature of a component evolved\nsince the concept was \ufb01rst envisaged in 1968, the forms of components have\ntoo. As Crnkovic, Sta\ufb00ord & Szyperski (2011) observe:\n", "page": 198, "type": "text", "section": "Page 198"}
{"text": "182\nSoftware Design: Creating Solutions for Ill-Structured Problems\n\u201cStarting as elements of source code, such as routines, procedures,\nmethods or objects, they transformed to architectural units and\nready-to-execute blocks that are dynamically plugged into the run-\nning systems.\u201d\nIn discussing the idea of reuse, the two characteristics that were identi\ufb01ed\nas being essential for a component of any form were:\n\u2022 well-de\ufb01ned functionality\n\u2022 well-de\ufb01ned interfaces\nA further characteristic, which is probably implicit for non-software forms of\ncomponent, but which needs to be explicitly stated for software components\n(because of the nature of software) is that of independence. This avoidance of\nany context-speci\ufb01c dependencies follows on from the ideas above. In practice\nof course, some dependencies are di\ufb03cult to avoid, particularly where these\nrelated to issues such as architectural style, but where these do exist, they need\nto be made fully explicit. Figure 11.1 illustrates this set of characteristics.\nComponent\n(black box)\nInterface\nFunction\nDependencies\nFIGURE 11.1: Characteristics of a software component\nIf we look at other domains, we might note that there are often implicit\ncontext-speci\ufb01c dependencies. For example, the starter motor for a car will\ndepend upon the availability of an electrical supply with a speci\ufb01c voltage\nand power rating. However, software dependencies can be more subtle, and\nso to ensure that a software component can be treated as a black box as far\nas is reasonably possible, such dependencies need to be made explicit in the\nspeci\ufb01cation. (As an example of the need for this, and of the di\ufb03culty of\nensuring it is comprehensively achieved, see the analysis of the $500 million\nfailure of the Ariane 5 rocket in 1996 that is provided in J\u00e9z\u00e9quel & Meyer\n(1997).)\n", "page": 199, "type": "text", "section": "Page 199"}
{"text": "Modelling Software Components and Services\n183\nWe might note here that the UML component diagram is a very speci\ufb01c\ninterpretation of the concept and of little use in a CBSE context. Indeed,\nperhaps because the concept of a component lacks any association with a\nspeci\ufb01c architectural style, there are no diagrammatical forms that have been\nwidely used for modelling CBSE implementations.\nHowever, that said, many aspects of component use can be modelled using\nexisting notations. In particular, issues related to functional and behavioural\nmodelling can often be modelled using the forms commonly used with objects,\nsuch as activity diagrams, statecharts and sequence diagrams. What is not so\nreadily modelled is the constructional viewpoint, although for many purposes,\ncomponents can be modelled by adapting existing forms of class diagram.\n11.2.2\nComponent frameworks\nCommonality of architectural style does not guarantee that components\nof di\ufb00erent origins can be easily integrated to create an application. This is-\nsue, termed architectural mismatch was \ufb01rst identi\ufb01ed in the context of seek-\ning to compose an application by making use of existing objects (Garlan,\nAllen & Ockerbloom 1995). Attempts to create new applications from ob-\njects that had been created by di\ufb00erent sources revealed that these made dif-\nferent, and incompatible, assumptions about the way that the object model\nwas organised. When the original analysis was revisited in (Garlan, Allan &\nOckerbloom 2009), the authors concluded that the reuse of components still\nformed a challenge, and indeed, that while the expanded computing landscape\nhad reduced some of the earlier problems, it also introduced new ones.\nWhat sort of assumptions created the problems? In the original (1995)\nstudy there were four general categories of assumptions that could result in\nmismatch. These were:\n\u2022 the nature of the (other) components, including the control model;\n\u2022 the nature of the connectors and the protocols used;\n\u2022 the global architectural structure; and\n\u2022 the construction process.\nThere were also three aspects regarding the ways that components interact\nwhere assumptions could produce mismatch: the infrastructure; the appli-\ncation itself; and interactions between peer components. None of these were\nissues that are strictly matters of design, although they might constrain design\nchoices.\nThe later study identi\ufb01ed some changes that had altered the situation;\ngreater use of reusable infrastructure; use of standard interfaces such as web\nbrowsers; extensive use of open source software; and more sophisticated devel-\nopment environments. They also noted the emergence of architecturally spe-\ncialised design domains. However, this more distributed context introduced\n", "page": 200, "type": "text", "section": "Page 200"}
{"text": "184\nSoftware Design: Creating Solutions for Ill-Structured Problems\nsuch issues as trust between components; dynamic recon\ufb01guration of systems;\nsystem evolution; and technical debt in the form of being locked into a speci\ufb01c\narchitecture.\nThe idea of the framework as a means of imposing a common component\nmodel has formed an important element in the evolution of CBSE and of com-\nponents themselves. It has also helped to address many of the issues identi\ufb01ed\nabove. While early ideas, such as those illustrated in Figure 11.1 assumed that\ncomponents would be integrated to form monolithic software applications, the\nuse of frameworks has allowed for more loosely coupled and distributed use\nof components, while also providing the necessary protocols for interaction\nbetween components. Figure 11.2 illustrates this evolution.\nComponent  3\nComponent  2\nComponent  4\nComponent  1\na) Monolithic integration\nFramework Infrastructure\nComponent 1\nComponent 3\nComponent 2\nb) Integration via a Framework\nFIGURE 11.2: From monolithic construction to frameworks\nSo, what is a component framework? It can be summarised as being a set\nof formal de\ufb01nitions for the interfaces between components, where the def-\ninitions establish a set of protocols through which components will interact\nand cooperate within the given framework. In turn, these protocols may in-\nclude \u2018naming conventions\u2019 used for the methods in an object that provide\nparticular functions, the requirement to provide particular functions, and the\noperational procedures required for a component to declare itself available for\nuse, and for others to request its services.\nThere are many frameworks (of course). We have already mentioned\nCORBA, which is maintained by the OMG (Object Management Group) that\nwe encountered in the last chapter in the context of UML. CORBA has map-\nping to many implementation languages and the \u2018client\u2019 of an object can access\n", "page": 201, "type": "text", "section": "Page 201"}
{"text": "Modelling Software Components and Services\n185\nthat object only through the protocols of its published interface. There are a\nnumber of frameworks provided by commercial vendors, such as Microsoft\u2019s\n.NET and of course the open source frameworks, such as Apache Spark. There\nare also many frameworks aimed particularly at Web applications, with J2EE\nproviding an important Java-based example.\nFor the purposes of this chapter, the details of particular frameworks are\nof less importance, what matters is that they exist\u2014and that the choice of a\nframework has therefore become one of the design activities. And like other\ndesign activities, this is one that can involve complex trade-o\ufb00s between many\ndi\ufb00erent factors\u2014and inevitably, the choice creates a long-term technical debt.\n11.2.3\nDesigning components\nThe design of the actual components can be considered as having two\ngoals. The \ufb01rst of these is to achieve the three general component character-\nistics identi\ufb01ed earlier, in order to ensure that a component can be \u201cdeployed\nindependently\u201d. These require that a component:\n\u2022 possesses well-de\ufb01ned functionality;\n\u2022 provides a set of well-de\ufb01ned interfaces;\n\u2022 clearly speci\ufb01es any explicit dependencies.\nAnd over and above that is the second goal, of conforming to the standards\nof a particular component framework. This aspect is likely to be supported\nby a range of tools (depending on the choice of framework), even down to the\nnaming convention for any identi\ufb01ers that are to be used for externally-visible\nmethods.\nReturning to the question of functionality (a major motivation for creat-\ning components), designing components to be reusable does imply that the\ndesigner should strive to make the component as general as is reasonably pos-\nsible. This is not an argument to use an excess of \u2018bells & whistles\u2019 or a \u2018swiss\narmy knife\u2019 approach, indeed quite the opposite. Making a component do one\njob and do it well was an important philosophical underpinning for the Unix\noperating system when it was developed in the 1970s. Using simple tools that\nconnected together readily via standard mechanisms helped users create their\nown applications with only limited e\ufb00ort (or even programming knowledge).\nAnd as Unix continues to underpin much of our computing infrastructure, we\ncan reasonably assume this was a good principle to adopt elsewhere.\nExperts prefer solutions that they know work. PvdH #13\nThe paper by Crnkovic & Larsson (2002) provides an interesting case study\non component use. The authors examine the evolution of two components\n", "page": 202, "type": "text", "section": "Page 202"}
{"text": "186\nSoftware Design: Creating Solutions for Ill-Structured Problems\nwithin the application being studied (a control system package used for in-\ndustrial applications). While not speci\ufb01cally concerned with component devel-\nopment, this still examines how key component characteristics a\ufb00ect the two\nparticular aspects being studied: evolution of components across platforms and\nreplacement of proprietary components with industry-standard ones. And, al-\nthough the two components have relatively low-level roles (one can be consid-\nered as middleware, while the other is a class library), the general experiences\nmay well have wider generality.\nSome of the particular issues that the case study identi\ufb01es from the view-\npoint of designing individual components are as follows.\n\u2022 The bene\ufb01t of using larger components that are easy to reuse, in pref-\nerence to smaller ones that could be developed in-house.\n\u2022 The high cost of maintaining backward compatibility with early instal-\nlations (this arose largely because the application being studied was a\n\u2018product line\u2019 so creating additional technical debt).\n\u2022 The need to separate out those features of a component that depend\nupon platform interactions in order to assist with ease of change.\nIt is worth noting here that components can be relatively costly to create. In\nSzyperski (1998) it is suggested that developing a reusable component could\nrequire 3\u20134 times the resources needed for a \u2018non-component\u2019 implementation.\nHowever, since some of these additional costs arise from external factors such\nas evolutionary changes to the component framework, it is di\ufb03cult to predict\nthe additional overhead involved in using a component. However, it is worth\nnoting that unless there really is good scope to make reuse of components, or\nan application can be largely created using existing components with only a\nfew additional specialised ones being built, developing components may not\nmake economic sense. (A good example of where extensive use is made of\nexisting components is the common practice with web applications of making\nuse of component frameworks to build a user interface.)\n11.2.4\nCOTS\nCOTS stands for \u201cCommercial O\ufb00The Shelf\u201d. Use of COTS components\ncan be regarded as representing an extreme, in the sense that the end user\n(designer) or integrator has no control whatever over their form and properties,\nand no knowledge about their workings. So a COTS element is one that is\nquite expressly black box in its nature.\nHowever, in a software context, this view is probably something of an\nextreme position. As Carney & Long (2000) point out, what is usually termed\nCOTS software spans something of a range of forms, some of which are capable\nof some degree of parameterisation, and with the extent of any modi\ufb01cation\noften depending upon the \ufb01nancial and political \u2018clout\u2019 of the customer.\n", "page": 203, "type": "text", "section": "Page 203"}
{"text": "Modelling Software Components and Services\n187\nThe main issue with the use of COTS is really concerned with the inte-\ngration of such components, and so we leave further discussion of the use of\nsuch components for Chapter 16.\n11.3\nModelling software services\nAs described in the preceding section, and illustrated in Figure 11.2, con-\ncepts about how software components could be composed evolved with de-\nvelopments in technology. Early ideas about CBSE were centred upon using\ntightly coupled integration to form a monolithic application image that would\nexecute on a local computer. With time, this evolved to employing much more\nloosely coupled forms, using frameworks for interconnection, with the compo-\nnents possibly being distributed across a wide network. And although there\nwas always some expectation that components could be provided by third\nparties, with the NAG library being a good example, the use of more loosely\ncoupled environments introduced greater emphasis upon related issues of trust\nand dynamic recon\ufb01guration.\nFramework Infrastructure\nLooser Coupling\nMore\nDistributed\nService User\nFIGURE 11.3: The evolution from components to services\nThe concept of a software service can be viewed as representing the next\n", "page": 204, "type": "text", "section": "Page 204"}
{"text": "188\nSoftware Design: Creating Solutions for Ill-Structured Problems\nstep in that evolution of reusable software components. Indeed, one way of\nthinking about services is as remote components that are very loosely coupled,\nso that the application making use of them does not need to know anything\nabout how they are realised. This progression is illustrated in Figure 11.3.\nHere the service sources are shown as miniature \u2018clouds\u2019, and indeed, the idea\nof software services has been an important underpinning for the concept of a\ncloud.\nService technologies, in one form and an-\nother, emerged around the millennium, and\nthe di\ufb00erent practices of using services to\ncreate applications have resulted in a va-\nriety of descriptive terms such as Software\nas a Service, Service-Oriented Architecture\n(SOA), web services, as well as a large range\nof acronyms that describe the protocols used\nto support the various activities involved\n(Turner, Budgen & Brereton 2003). Services\nare usually accessed and delivered across the\nweb, often by third-party providers.\nService models focus upon separating the\npossession and ownership of software from its use. By delivering software\u2019s\nfunctionality as a set of distributed services that can if necessary be con\ufb01gured\nand bound at the time of delivery (ultra-late binding), provides a highly \ufb02exible\nstrategy. Of course, the end user still needs to have some form of application\nthat incorporates a set of business rules, but this can be fairly minimalist\nand only needs to specify what services are needed, not how they are to be\nprovided. Figure 11.4 shows two forms of service model. Model a) is one where\nthis is organised on a supply-led basis, using a pre-determined range of services\nfrom a remote provider (a step on from distributed components, but still using\na \ufb01xed pro\ufb01le). Model b) shows how this can be organised on a demand-led\nbasis, involving an additional integration layer.\nBasic service description, discovery, delivery and composition are largely\norganised using XML-based protocols.\nSOAP (Simple Object Access Protocol) provides a message format for com-\nmunicating with, and invoking, web-based services. (REST is also used,\nbut historically, SOAP was the main protocol employed with web ser-\nvices.)\nWSDL (Web Services Description Language) is used to describe a service in\nterms of its acceptable data types, methods, message format, transport\nprotocol and end-point uniform resource identi\ufb01er (URI).\nWhile these are largely su\ufb03cient for supply-led con\ufb01guration, the additional\nelements needed for managing demand-led service use require a set of addi-\ntional protocols to scope out the additional information required.\n", "page": 205, "type": "text", "section": "Page 205"}
{"text": "Modelling Software Components and Services\n189\nService transport layer\n(using forms such as \n.NET or J2EE)\nBusiness Rules\nService transport layer\n(using forms such as \n.NET or J2EE)\nBusiness Rules\nSupplier's software\napplication service\nService integration\nlayer\nService layer\n(applications created\non demand from\nsmaller services)\nPre-determined set\nof services\nDynamically selected\nset of services\na) Supply-led model\nb) Demand-led model\nFIGURE 11.4: Supply-led and demand-led service models\nFigure 11.5 shows the basic mechanics of service use. The service consumer\nmakes a request for a service. This may be a request for a speci\ufb01c service from a\nparticular provider, but if not, the request goes to some element that provides\nfor dynamic composition or orchestration of services (as in the diagram). This\nthen negotiates with one or more possible providers, depending on the business\nrules that are speci\ufb01ed, and then selects a particular service provider, which\nis then bound to the service user for this transaction. The actual service\nis then provided through the protocols embodied in that particular service\ndescription.\nThis is of course a fairly simple single transaction, and providing for a\nuser\u2019s need may well require that several services are composed together in\norder to perform a speci\ufb01c task. Note also that the same symbol has been\nused for both the service consumer and the service provider to emphasise that\na consumer can itself also be a provider.\nModelling both the realisation of a service, and also its use is clearly a\nfairly challenging issue. There are no speci\ufb01c service modelling notations, and\nlike components in general, most modelling appears to be performed by using\nexisting notations. Those provided by the UML can be useful (with the bene\ufb01t\nof having drawing tools available if required), as are DFDs (Anjum & Budgen\n2017).\nA particularly distinctive element in the process of service composition is\nthe presence of the business rules. Although these are normally a factor to be\nconsidered when designing applications, they are usually implicitly embodied\nin the design process (essentially forming an element of the design speci\ufb01ca-\ntion). However, when using software services, the business rules need to be\n", "page": 206, "type": "text", "section": "Page 206"}
{"text": "190\nSoftware Design: Creating Solutions for Ill-Structured Problems\nService\nConsumer\nService\nDescription\nService\nProvider\nService\nComposition\nselection\n& binding\nuse\nprovision\nrequest\nnegotiation\nBusiness\nRules\nFIGURE 11.5: The elements of service use\nmade explicit, since ensuring that the application conforms to these needs to\nbe a part of the dynamic composition process. Modelling these rules can add\na further challenging element when using a service model.\n11.4\nEmpirical knowledge about modelling components\nand services\nThe corpus of empirical studies related to both components and services is\nlimited. As with objects, attempting to perform meaningful empirical studies\nduring the emergent period for a technology, when the element being stud-\nied is not particularly well-de\ufb01ned is rather challenging. So, not surprisingly,\nthe available primary studies tend to be a mix of case studies, surveys and\nexperience reports.\n11.4.1\nEmpirical knowledge about components\nThe systematic mapping study by Vale, Crnkovic, de Almeida, da Mota\nSilviera Neto, Cavalcanti & de Lemos Meira (2016) looks at studies related to\nCBSE over the period 1984-2012. The authors analysed some 1231 primary\nstudies and examined the pro\ufb01le of research that these revealed for that period.\nNot surprisingly perhaps, they observed a decline in publication rates in the\n2010s, since as they noted \u201cCBSE has been integrated into other approaches,\n", "page": 207, "type": "text", "section": "Page 207"}
{"text": "Modelling Software Components and Services\n191\nsuch as service-oriented development, software product lines, and model-based\nengineering\u201d.\nThey noted that the main objectives for adopting CBSE tended to be\nnon-functional ones such as increasing productivity, saving on cost, improving\nquality etc. They noted that there were \u201cfew studies that measure the e\ufb00ort\ninvolved in building for reuse\u201d and suggest that industry experience is that\n\u201cbuilding reusable components on average requires three to \ufb01ve times more\ne\ufb00ort than building the same function but not building for reuse\u201d (similar to\nSzyperski\u2019s estimates).\nWhile the literature identi\ufb01ed more than 50 component models, with the\nfour most frequently addressed including CORBA. They also identi\ufb01ed a wide\nrange of domains in which CBSE has been applied and observed that the pro-\nvision of support for these \u201cexplains the large number of component models\u201d,\nwith these di\ufb00ering chie\ufb02y in term of being realised to meet the needs of a\ndomain, rather than in terms of basic principles.\n11.4.2\nEmpirical knowledge about services\nFew systematic reviews on the use of software services are available, and\nthose that are, tend to be looking at rather speci\ufb01c research issues rather than\nat questions about the e\ufb00ectiveness of services.\nKey take-home points about modelling components and\nservices\nModelling the attributes of software components and services uses a range\nof di\ufb00erent forms, but to date modelling has tended to use existing notations\nrather than develop any that are speci\ufb01c to these technologies..\nReuse. This forms a major motivation for the adoption of components,\nwhether close or loosely coupled.\nComponent characteristics. Components are characterised by having\nwell-de\ufb01ned functionality, accessed through well-de\ufb01ned interfaces, and\nwith any dependencies being made explicit. Ideally, a component has\nvery few (if any) dependencies, so aiding its composition within appli-\ncations.\nComponent frameworks. The use of frameworks helps address the need\nto publish the interfaces of components, as well as aid loose coupling\nbetween components, and the choice of a framework is an important\narchitectural decision.\n", "page": 208, "type": "text", "section": "Page 208"}
{"text": "192\nSoftware Design: Creating Solutions for Ill-Structured Problems\nSoftware services. Can be viewed as an evolution of components, whereby\nthe services themselves may be provided by third parties and are very\nloosely coupled to the application, allowing for late binding to particular\nproviders.\n", "page": 209, "type": "text", "section": "Page 209"}
{"text": "Part III\nDesign as a Verb:\nDesigning Software\n193\n", "page": 210, "type": "text", "section": "Page 210"}
{"text": "Chapter 12\nStructuring the Ill-Structured\n12.1\nChallenges in creating a design ..................................\n195\n12.2\nEvolution of knowledge transfer mechanisms ....................\n197\n12.3\nDesigning with others ............................................\n199\n12.4\nEmpirical knowledge about design creation .....................\n200\nKey take-home points about structuring \u2018solutions\u2019 to ISPs ....\n201\nHaving examined the nature of software and some of the characteristics of the\ndesign process in the \ufb01rst part of this book, and some of the ways that we\ncan describe these in the second part, in this third part we address the role of\n\u2018design as a verb\u2019 and the question of how software might be designed.\nWe might expect that, in the ideal, the design of software should be an\nopportunistic process, with design decisions being driven by the needs and\ncharacteristics of the required application. However, to do so well requires\nextensive experience and considerable ability from the designer(s). Given that\nsoftware is often more likely to be designed by less experienced and more\nimperfect beings, various design strategies and guidelines have been devised\nto assist them and to help organise the design process.\nThis chapter introduces these, and then the following chapters (among\nother things) look at some of them in rather more detail. A core theme\nthat runs throughout is that of how to exchange and share design knowl-\nedge, whether it be in terms of strategies for developing a design, or ways of\norganising the design elements. Indeed, given that providing knowledge trans-\nfer is one of the main goals of this book, this chapter can be considered as\nintroducing some key elements of what this can involve.\n12.1\nChallenges in creating a design\nThe di\ufb03culties involved in creating software applications and systems have\nlong been recognised by software developers, if not always by others. While\nother technologies related to computing such as hardware design have raced\nalong, rapidly gaining orders of magnitude in performance, while reducing\nsize and cost, the techniques employed for designing software appear to have\n195\n", "page": 212, "type": "text", "section": "Page 212"}
{"text": "196\nSoftware Design: Creating Solutions for Ill-Structured Problems\ninched along in a series of relatively small steps. Much of this of course stems\nfrom the ill-structured nature of software design, reinforced by some of the\ncharacteristics of software itself. As observed by Brooks (1987) the challenging\nproperties of software include the following.\n\u2022 Complexity. This is seen as being an essential property of software, in\nwhich no two parts are alike and an application may possess many states\nduring execution. This complexity is also arbitrary, being dependent\nupon the designer (and the model they create), rather than the problem.\n\u2022 Conformity. Software, being \u2018pliable\u2019, is expected to conform to the stan-\ndards imposed by other components, such as hardware, external bodies,\nor existing software.\n\u2022 Changeability. Software su\ufb00ers a constant need for evolution, partly be-\ncause of the apparent ease of making changes (and relatively poor tech-\nniques for costing them or recognising the technical debts they create).\n\u2022 Invisibility. As observed in the preceding chapters, any forms of repre-\nsentation used to describe software lacks any visual link that can pro-\nvide easily-absorbed descriptions of the relationships involved. This not\nonly constrains our ability to conceptualise the characteristics of an ap-\nplication, it also hinders communication among those involved in its\ndevelopment (including the customer)\nChallenges of software\nAn interesting question is whether or not these\nhave altered signi\ufb01cantly with time. Being intrin-\nsic properties of software itself, both complexity and\ninvisibility remain issues that are as challenging as\nthey were when Brooks was writing his analysis. Sys-\ntems remain complex and while design representa-\ntions have evolved to help cope with di\ufb00erent archi-\ntectures, the lack of any visual parallels remains one\nof their characteristics. And if anything, the other\ntwo properties have come to pose even greater chal-\nlenges. The connectivity of software systems (typ-\ni\ufb01ed by the \u2018internet of things\u2019) has increased and\nsoftware often needs to con\ufb01rm to standards that\nthemselves change and evolve. Indeed while complexity and invisibility are\nlargely intrinsic properties of software, both conformity and changeability are\nmore a\ufb00ected by extrinsic factors.\nSo these properties of software continue to form a set of constraints upon\nthe activities of designers as well as upon the form of the outcome from the\ndesign process. And they will all in\ufb02uence the design process, regardless of the\nscale, purpose and form of an application. In Chapter 4 we looked at some of\nthe knowledge that software designers may possess (or need to possess) as indi-\nviduals. In this chapter (and the following chapters) we are concerned with the\n", "page": 213, "type": "text", "section": "Page 213"}
{"text": "Structuring the Ill-Structured\n197\nways in which knowledge about designing software (knowledge schema) can be\nshared between experienced designers, and also transferred from experienced\ndesigners to those having less experience.\n12.2\nEvolution of knowledge transfer mechanisms\nSince the process of software design is an ISP, the very idea of teaching\nothers to design software would appear to be a contradiction. If the design of\nevery software application is both unique and also has many possible forms, we\nmight reasonably ask how we can usefully learn anything other than rather\ngeneral principles when it comes to acquiring design knowledge. However,\nwhile this may be true, it does ignore the fact that, at an abstract level software\napplications may also have many things in common. Our example of the CCC\nis focused upon booking the use of some form of resource, in this case cars.\nBut there are many other applications that book resources, whether these be\ntheatre seats, train travel, hotel rooms etc. Individually they will di\ufb00er, but\nthey will also possess many characteristics in common.\nThe same e\ufb00ect occurs when we consider architectural style. Here the com-\nmonality lies less in what the applications do, and more in the way that their\noperations are organised (call-and-return, pipe-and-\ufb01lter etc.). As it happens,\nthe earliest forms of knowledge transfer used with software design were essen-\ntially based upon this commonality of architectural form.\nFollowing a plan\nDeveloping a design (implicitly, developing a\ndesign model) can proceed in various ways. Early\napproaches assumed that the designer essentially\nbegan with a \u2018clean sheet\u2019 and a clear speci\ufb01-\ncation of what was needed. (We may smile at\nthis last assumption, but of course, many early\napplications such as payroll systems and appli-\ncations recording commercial transactions were\nrelatively well-de\ufb01ned and involved little or no\nuser interaction.) What we usually term plan-\ndriven design strategies could be used to create\nthese, essentially by treating the task of design-\ning software as though it were almost a form of WSP, and early forms did so\nby organising the design process as a sequence of \u2018steps\u2019 that involved:\n1. building a model of the requirements (essentially a \u2018system model\u2019) to\nprovide a speci\ufb01cation of what was required;\n2. mapping this on to the preferred architectural form (typically call-and-\nreturn or pipe-and-\ufb01lter) by allocating the tasks identi\ufb01ed in the previ-\nous step to speci\ufb01c elements;\n", "page": 214, "type": "text", "section": "Page 214"}
{"text": "198\nSoftware Design: Creating Solutions for Ill-Structured Problems\n3. re\ufb01ning the details of the elements and their interactions (such as the\nuse of parameters) to create the \ufb01nal design model.\nWe will look at such strategies, their strengths and limitations in Chapter\n13. In terms of the properties of software identi\ufb01ed above, they do provide\nsupport for addressing both complexity and invisibility, but are less readily\nable to incorporate ideas about conformity or changeability.\nEarly plan-driven approaches commonly employed a top-down strategy\nwith a clear sequence of actions, starting with a description of the system as a\nwhole and then developing a design model that describes the detailed design\nelements in a step by step manner. As noted above, this may well produce\ndesigns that lack \ufb02exibility and that can be di\ufb03cult to adapt and modify.\nOver the years various forms employing a more \u2018bottom-up\u2019 strategy emerged,\nculminating in the concept of agile development approaches. These aim to\nprovide better support for changeability (and to some extent for conformity)\nand are discussed in Chapter 14.\nAny form of knowledge transfer tends to depend upon some element of\ncommonality. Plan-driven thinking is largely centred upon commonality of ar-\nchitectural form (essentially implementation). If instead we seek to share ideas\nbased upon commonality of function, then this leads to the next development\nin design knowledge transfer.\nDuring the 1990s, as the use of objects and object-oriented thinking be-\ncame widely used, there was much greater interest in the idea of reuse of design\nknowledge at di\ufb00erent levels. Adelson & Soloway (1985) observed that design-\ners reused past experiences (what they termed \u2018labels for plans\u2019) and as the\ncorpus of software applications grew, the patterns concept emerged as a way\nof codifying useful forms. Whereas a designer was previously expected to be-\ngin with a \u2018clean sheet\u2019, basing key elements of a design upon well-established\nstructures or \u2018patterns\u2019 made it possible to draw upon the experiences of oth-\ners. Again, we look more fully at the ideas involved in Chapter 15, but one\nthing we can observe here is that one of the strengths of this approach is that\nit gives greater attention to changeability.\nThe adage that \u201cthere is no such thing as a free lunch\u201d does certainly hold\ntrue for when designing software. While plan-driven forms may produce design\nsolutions that are relatively constrained and prescriptive, they do provide quite\na lot of detailed guidance about how to develop them. Later (and \u2018lighter\u2019)\napproaches may help produce more adaptable and innovative designs, but\ntheir use does require greater creativity and skill, as we will see.\n", "page": 215, "type": "text", "section": "Page 215"}
{"text": "Structuring the Ill-Structured\n199\n12.3\nDesigning with others\nWhile the preceding sections (and chapters) have tended to emphasise the\nactivities of \u2018the designer\u2019, software is something that we often develop in col-\nlaboration with others. Given the nature of the design process, it is hardly\nsurprising that designing software as a team activity adds further complica-\ntions, some of them in the form of added constraints upon the form of the\nprocess, and hence also upon the form of the resulting product. (Of course,\none of the hazards of team design is that the number of major components of a\nsystem will end up being the same as the number of people in the design team!)\nTeam design\nIn (Brooks 1987), Fred Brooks Jr. observed\nthat, at that point in time, many of the very suc-\ncessful and \u2018exciting\u2019 software systems had been\nthe work of one or a few \u2018great designers\u2019. His\nexamples may now look a little dated (and sys-\ntems have got much larger, making it less likely\nfor them to be the work of one great designer),\nbut we might still usefully compare the \u2018clean\u2019\ndesign of Unix and its derivatives with operating\nsystems such as the Windows family.\nGiven that great designers are rarely available to help us, and that the\ntask of design may have to be shared in some way, we need to consider two\nissues when designing as a team.\n1. How to organise the tasks of the design task among the team, and how\nto determine how the di\ufb00erent elements will interact.\n2. How to integrate the individual contributions to the design, which may\nwell require a process of negotiation between the members of the team\nto resolve di\ufb00erent expectations about the overall design.\nThe \ufb01rst of these can be managed, at least in part, by ensuring that a suitably\nmodular view is taken of the overall design structure. Both will also be in\ufb02u-\nenced by the form of the design team, whether this be a hierarchical one (with\nsomeone being the \u2018chief designer\u2019) or a more collaborative one, as typi\ufb01ed by\nGerald Weinberg\u2019s concept of egoless programming (Weinberg 1971). The chief\nprogrammer model, proposed by Harlan Mills (1971) has the disadvantage of\nrequiring someone with clear authority and knowledge as team leader, so not\nsurprisingly, given the di\ufb03culty of \ufb01nding such people, current ideas such as\nagile development have tended to put more emphasis upon collaboration and\ncoordination among a set of peers forming a design team.\nResearchers have also sought to understand and model the psychological\nfactors that in\ufb02uence team behaviour when designing software (Curtis et al.\n1988, Curtis & Walz 1990). Relevant factors they have identi\ufb01ed include:\n", "page": 216, "type": "text", "section": "Page 216"}
{"text": "200\nSoftware Design: Creating Solutions for Ill-Structured Problems\n\u2022 the size of a team\u2014with some indication that a size of 10-12 members\nis probably an upper limit for productive working;\n\u2022 the large impact that may be exerted by a small subset of the team who\npossess superior application domain knowledge;\n\u2022 the in\ufb02uence of the way that an organisation operates\u2014with particular\nemphasis upon the need to maintain a bridge between the developers\nand the customer (Bano & Zowghi 2015).\nSo, operating as a design team requires the use of knowledge schema drawn\nfrom the domain of group psychology as well as technical knowledge about\nsoftware design. This is perhaps best summarised by the following quotation\nfrom Curtis & Walz (1990).\n\u201cProgramming in the large is, in part, a learning, negotiation, and\ncommunication process.\u201d\nWe will particularly return to this when we examine agile development ideas\nin Chapter 14.\nExperts prefer working with others. PvdH #7\n12.4\nEmpirical knowledge about design creation\nSince much of the material of this chapter refers to empirical knowledge\nabout how people and teams create designs, many of the relevant empirical\nstudies have already been discussed.\nOne topic not really elaborated though is that of opportunistic design ac-\ntivities. There are of course good reasons for this. If a process is opportunistic,\nthen its form is determined by the problem, and the way that designers begin\nto understand both the problem and ways in which it might be addressed.\nThat doesn\u2019t o\ufb00er much in the way of guidelines about how to employ an\nopportunistic strategy of course, as it doesn\u2019t lend itself to being generalised.\n(Unfortunately, this doesn\u2019t therefore \ufb01t well with van Aken\u2019s idea of design\nsciences that we encountered in Chapter 5, where the goal was to \u201cdevelop\nvalid and reliable knowledge to be used in designing solutions to problems\u201d\n(van Aken 2004).)\nTo highlight this, we brie\ufb02y examine some outcomes from the study of\nsoftware design that formed the basis of the book edited by van der Hoek &\nPetre (2014). This study was based upon recorded observations of a number of\npairs of software designers who were addressing a particular problem (creating\n", "page": 217, "type": "text", "section": "Page 217"}
{"text": "Structuring the Ill-Structured\n201\na simulation package for city tra\ufb03c management planning). The plot shown\nin 12.1 is based upon the qualitative analysis reported in Budgen (2014), and\nwas obtained by analysing the recorded utterances of one of the teams of\ndesigners and interpreting these to determine which viewpoint was the focus\nof attention at that point. In all, the utterances of three teams were analysed,\nand all were very di\ufb00erent.\n20\n40\n60\n80\n100\nTime (in minutes)\nReq Spec\nFunction\nBehaviour\nData Model\nConstruction\nViewpoints\nFIGURE 12.1: Example of viewpoint changes during design\nThe main point is that over a period of nearly two hours, as the two design-\ners in the team produced their design model, their modelling process ranged\nwidely between all four viewpoints, as well as spending some time revisiting\nthe original requirements speci\ufb01cation. This was very much an opportunistic\ndesign session, with the designers exploring di\ufb00erent aspects as their under-\nstanding unfolded, and helps to illustrate why such a process cannot readily\nbe generalised.\nKey take-home points about structuring \u2018solutions\u2019 to\nISPs\nSoftware design practices employ a range of strategies for addressing the\nill-structured nature of software applications and need to cope with some\nimportant factors.\nChallenging properties of software. In 1987 Fred Brooks Jr. identi\ufb01ed\nfour key challenges for the designer as arising from the complexity of\nsoftware, the need for conformity with other elements of a system, the\n", "page": 218, "type": "text", "section": "Page 218"}
{"text": "202\nSoftware Design: Creating Solutions for Ill-Structured Problems\nconstant need for change and the invisibility of software. Complexity\nand invisibility are largely intrinsic and have remained unchanged, but\nconformity and changeability are probably much bigger in\ufb02uences (and\nconstraints) than they were at the time that Brooks identi\ufb01ed their\ne\ufb00ects upon the design process.\nKnowledge transfer. Mechanisms for sharing knowledge about \u2018what\nworks\u2019 in particular situations have evolved over the years and their evo-\nlution is quite closely linked to the evolution of software architectural\nstyles. While plan-driven forms were (and still are) practicable for appli-\ncations employing call-and-return and similar architectural styles, later\nforms of architecture require more complex design models and hence\nmore complex processes are involved in developing these.\nDesign teams. Software is increasingly developed collaboratively within a\nteam, and so the design process needs to provide opportunities for in-\nteraction and coordination among team members.\n", "page": 219, "type": "text", "section": "Page 219"}
{"text": "Chapter 13\nPlan-Driven Software Design\n13.1\nWhat does plan-driven mean? ...................................\n204\n13.2\nDecompositional and compositional strategies ..................\n205\n13.2.1\nTop-down decomposition ................................\n206\n13.2.2\nCompositional design strategies .........................\n207\n13.3\nWhat do plan-driven methods provide? .........................\n208\n13.4\nSSA/SD: example of an early plan-driven form .................\n211\n13.4.1\nSSA/SD representation part\n............................\n212\n13.4.2\nSSA/SD process part ....................................\n212\n13.4.3\nSSA/SD heuristics .......................................\n214\n13.5\nSSADM: a designed design method ..............................\n214\n13.5.1\nSSADM representation part .............................\n215\n13.5.2\nSSADM process part ....................................\n217\n13.5.3\nSSADM heuristics .......................................\n218\n13.6\nPlan-driven design for object-oriented models ...................\n219\n13.6.1\nThe Fusion method ......................................\n219\nThe Fusion process ...............................................\n220\nThe Fusion notations .............................................\n223\nFusion\u2014some observations .......................................\n225\n13.6.2\nThe Uni\ufb01ed Process (UP) ...............................\n226\nThe UP phases ...................................................\n227\nThe UP work\ufb02ows ................................................\n229\nThe UP\u2014some observations .....................................\n232\n13.7\nEmpirical knowledge related to plan-driven design ..............\n233\nKey take-home points about plan-driven design practices ......\n235\nPlan-driven strategies were one of the earliest mechanisms devised for trans-\nferring knowledge about software design. Essentially, the relevant knowledge\nschema are organised in the form of a structured sequence of well-de\ufb01ned ac-\ntivities, with the activities themselves being performed in a form appropriate\nto the needs of a particular application.\nIn this chapter we examine the nature of plan-driven design strategies, and\nlook at some examples of the practices that they employ. As we will see, a\nsigni\ufb01cant limitation is that this form of strategy is less readily suited to being\nused with design solutions that are based upon more complex architectural\nstyles. However, this does not make plan-driven strategies irrelevant. In par-\nticular, one of their strengths lies in the way that they \u2018systematise\u2019 the design\n203\n", "page": 220, "type": "text", "section": "Page 220"}
{"text": "204\nSoftware Design: Creating Solutions for Ill-Structured Problems\nprocess. This means that ensuring the integrity of the overall design model\nduring later evolution of an application can be aided by a knowledge of the\noriginal method followed. Hence an understanding of their workings can be\nuseful, both as a source of design ideas, and also when seeking to understand\nand modify legacy systems and applications.\n13.1\nWhat does plan-driven mean?\nA simple, but often useful, way of transferring knowledge about how to\nperform a task is to write down a set of general rules that describe a sequence\nof actions that should be followed. This approach can be particularly e\ufb00ective\nwith non-creative tasks such as assembling an item of \ufb02at-pack furniture, but\nit can also be used to provide guidance for more creative activities.\nAs a very simple example, the (traditional) way that we make a pot of tea\ncould be performed by following the plan speci\ufb01ed below:\nBoil the kettle; warm the pot; add the tea to the pot; pour on boiling\nwater; wait for a short while; pour the tea into a cup.\nSuch a \u2018method\u2019 puts a strong emphasis on the ordering of actions. (If you\ndon\u2019t think so, try changing around any of the elements of the above example\nand see what results!) However, it provides little or no guidance about those\nquality-related issues that are more a matter of taste, such as:\n\u2022 how much tea to add\n\u2022 how long to wait for the tea to brew\nsince these are decisions based upon the personal preferences of the person\nmaking (or consuming) the tea as well as being dependent upon the type of tea.\nMaking tea\nBecause they can be considered as being equally\nessential to the success of the tea-making process, we\ncan reasonably assume that \u2018sequence\u2019 knowledge\u2019\nalone is insu\ufb03cient for even such a relatively simple\ntask, and that some form of \u2018domain knowledge\u2019 is\nalso required.\nCookery books provide a particularly good il-\nlustration of this. A recipe may provide details of\ncertain tasks that should be done, together with a\nschedule (or ordering) for doing them. When fol-\nlowed by a novice it can be hoped that this will\nresult in some degree of success, while the more accomplished and creative\nreader can interpret and adjust it to create more impressive e\ufb00ects. (Well,\nthat\u2019s the basic thinking anyway.)\n", "page": 221, "type": "text", "section": "Page 221"}
{"text": "Plan-Driven Software Design\n205\nWe can \ufb01nd many other examples in everyday life\u2014the instructions fol-\nlowed by a hobbyist to create a model steam engine; dress-making patterns,\na guide to planning a walk in the mountains etc. Taken together, these sug-\ngest that procedural guidance can also be an e\ufb00ective way of guiding others\nto perform creative tasks. However, in the \ufb01rst two examples the scope of\nthe creative element is constrained\u2014the recipe describes one particular dish,\nthe dress-making pattern produces a particular garment. In contrast though,\nprocedural guidance used to advise about planning a walk in the mountains\nwill necessarily be less prescriptive, since it needs to be adapted for routes of\ndi\ufb00erent lengths and di\ufb03culty, as well as factors such as those arising from\nthe size of a group etc. Hence the knowledge schema provided by such a form\nwill require the user to employ additional expertise and complementary forms\nof knowledge when doing the planning (which as we observed earlier, is a form\nof design activity).\nPlan-driven software design strategies have essentially adopted this model\nin order to provide guidance on designing software applications. The resulting\ndesign strategies have often been described as \u2018methods\u2019, implying a structured\nand procedural way of doing things.\nHowever, we do need to appreciate that when a plan-driven approach is\nadopted for use with more creative tasks, such as planning walks or designing\nsoftware, it is e\ufb00ectively operating at a higher level of abstraction than when\nused for describing how \ufb02at-packed furniture should be assembled. It is rather\nlike employing a meta-recipe approach to provide guidance on how to produce\na wide range of recipes, which requires much more creative input in order to\nadapt it to di\ufb00erent dishes. Hence, while a plan-driven approach can provide\ngood guidance for a task that involves a highly constrained degree of creativity,\nsuch as making tea (or co\ufb00ee), it will necessarily be much less prescriptive\nwhen individual design decisions need to be driven by the needs of the problem.\nUnderstandably perhaps, plan-driven software development is now often\nviewed as being mainly of historical interest. On the debit side, it does have two\nsigni\ufb01cant limitations: one is that it is implicitly tied to an overall \u2018waterfall\ndevelopment\u2019 context; the other is that it is more likely to be e\ufb00ective with less\ncomplex software architectures. On the positive side, many applications have\nbeen successfully developed using a plan-driven strategy; and some important\nconcepts (such as coupling) have emerged from its use. And of course, as\nmentioned earlier, an understanding of how such strategies are organised can\nhelp with preserving the integrity of the resulting design during maintenance.\n13.2\nDecompositional and compositional strategies\nWhile an opportunistic strategy may commonly be used by experienced\nsoftware designers (Visser & Hoc 1990), such an approach cannot readily be\n", "page": 222, "type": "text", "section": "Page 222"}
{"text": "206\nSoftware Design: Creating Solutions for Ill-Structured Problems\nincorporated into a plan-driven structure. Plan-driven methods therefore or-\nganise their guidance around one of two major problem-solving strategies.\n13.2.1\nTop-down decomposition\nDecomposition\nWhen early software applications were\nbeing developed, a common choice of ar-\nchitectural style was one of call-and-return,\nsince most implementation languages had\nfeatures that mapped closely to the struc-\nture of the underlying machine, aiding gen-\neration of e\ufb03cient code. Applications there-\nfore employed some form of \u2018main\u2019 program\nunit (often incorporating any permanent and\nglobal variables) and a set of sub-programs,\nwith these performing their tasks using local\nvariables that were only in scope while the\nsub-program was executing. So early think-\ning about design was focused upon how to\nmap application functionality on to such a structure.\nIn a pioneering paper, Niklaus Wirth (1971) proposed the use of a process\nin which the task to be performed by the overall problem was gradually de-\ncomposed into a set of smaller ones (termed stepwise re\ufb01nement). As envisaged\nby Wirth, both functionality and also data were to be re\ufb01ned in this way, and\nduly mapped on to the main program and sub-programs. Among the lessons\nthat he derived from this model were two that we might usefully note here.\n\u2022 The modular structure resulting from this process determines the ease\nwith which a program can later be adapted to meet changes in the\nrequirements or its context. Although this idea is demonstrated in his\npaper, the changes illustrated in his example were ones that largely\nextended the functionality involved in the original problem posed, and\nwe should note that the ideas about information hiding later expounded\nin Parnas (1972) provide a much more coherent strategy for determining\nthe choice of modular structure.\n\u2022 Each re\ufb01nement in the process of decomposition embodies a set of de-\nsign decisions that are based upon speci\ufb01c criteria. This re\ufb02ects the\nrecognition that, as we have already observed many times in this book,\ndesigning software is not an analytical process, with a need to assess\n(and re-assess) the in\ufb02uences of a range of factors at each design step.\nWirth\u2019s paper was undoubtedly a seminal one, but although his ideas were\ncentred upon the concept of modularity, his paper provided no criteria that a\ndesigner could employ to compare between possible choices of module struc-\nture (Shapiro 1997). However, the concept of module coupling introduced in\n", "page": 223, "type": "text", "section": "Page 223"}
{"text": "Plan-Driven Software Design\n207\n(Myers 1973), that later formed one of the underpinnings of the \u2018structured\ndesign\u2019 school of thinking (Stevens et al. 1974) that are examined later in\nthis chapter, did provide criteria that could be used to assist the process of\nstepwise re\ufb01nement, and so coupling became an underpinning concept used\nas part of this approach.\nMyers argued that the \u201cprimary goal in designing a modular program\nshould be to decompose the program in such a way that the modules are highly\nindependent from one another\u201d. He advocated the use of \u2018strong modules\u2019,\nwhich performed a single, well-de\ufb01ned function and he identi\ufb01ed some of the\nways in which coupling between modules could arise.\n13.2.2\nCompositional design strategies\nA rather di\ufb00erent, and often more challenging, way of creating a design\nis to use a compositional strategy. Whereas the decompositional approach\ntends to focus upon creating the structure of the resulting application around\nconsideration of its function, usually realised through by the operations that\nan application needs to perform, a compositional approach seeks to create\na design model that is formed from the descriptions of a set of distinctive\nentities or components that can be recognised in the problem, together with\ndescriptions of the relationships that link these entities. The nature of the\nentities and the relationships will vary with the method and the architectural\nstyle that is adopted. Indeed, whereas decompositional forms are e\ufb00ectively\nconstrained to producing design models using an architectural style such as\ncall-and-return, compositional strategies can be used to create design models\nfor a variety of architectural styles, including those using processes and objects.\nComposition\nEmploying a compositional approach is usu-\nally considered as being less intuitive than\nthe use of top-down decomposition (Vessey &\nConger 1994). In part this may be because of its\ngreater complexity, requiring a more mixed set\nof viewpoints for creating the design model, and\nalso because it provides more scope for oppor-\ntunistic decision making. However, it can be ar-\ngued that the use of this strategy is likely to lead\nto more consistent design solutions, regardless of\nwho is doing the design, since the design strategy aims to relate the structure\nof the \u2018solution\u2019 (design model) to that of the \u2018problem\u2019 rather than the struc-\nture of the underlying machine (D\u00e9tienne 2002). The process of compositional\ndesign also places an emphasis upon \u2018grouping\u2019 elements when elaborating the\ndesign model, where groupings can be based on criteria such as the di\ufb00erent\nforms of coupling, which again may be related closely to both the problem as\nspeci\ufb01ed in the requirements and the chosen architectural style.\n", "page": 224, "type": "text", "section": "Page 224"}
{"text": "208\nSoftware Design: Creating Solutions for Ill-Structured Problems\n13.3\nWhat do plan-driven methods provide?\nOne question we should ask at this point is why should anyone want to\nuse a plan-driven method? Probably far more software has been developed\nwithout using anything in the nature of a \u2018method\u2019 than through the use of\nsuch methods, so what bene\ufb01ts does their use confer? To answer this, we \ufb01rst\nneed to look at the mechanisms they employ in a little more detail.\nVessey & Conger (1994) suggested that the knowledge involved in following\na plan-driven strategy can be categorised into two forms:\n1. declarative knowledge, which describes the tasks that should be per-\nformed at each step in the process; and\n2. procedural knowledge, consisting of knowledge about how to employ a\ngiven \u2018method\u2019 in a particular situation.\nIn terms of our example of making tea, the declarative knowledge involved\nwould consist of an understanding of the tasks to be performed and of the\norder in which they should be performed, while procedural knowledge would\naddress such issues as how much tea to put in the pot and how much water\nto add in order to make tea for four people.\nDeclarative knowledge schemas can be codi\ufb01ed by providing a \u2018do this, then\ndo that, then follow this by doing...\u2019 form of description, whereas procedural\nknowledge schemas are more likely to be acquired from experience and best\ncodi\ufb01ed in the form of advice. Since we often express the declarative knowledge\nin what we might term a procedural form, by specifying the sequence of actions\nthat should be performed, this terminology can also be a little confusing. (And\nit is worth noting that in (D\u00e9tienne 2002) the terms declarative and procedural\nare used in yet another, slightly di\ufb00erent, way.)\nAs used for software design, plan-driven methods generally embody the\nrelevant design knowledge through the use of three main elements.\n\u2022 The representation part consists of a set of notations that can be used\nto describe (or model) both the characteristics of the original problem\nand also that of the intended \u2018solution\u2019 (the design model), using one or\nmore viewpoints and di\ufb00erent levels of abstraction.\n\u2022 The process part provides the declarative knowledge by describing the\nprocedures to be followed in developing the design model, and suggesting\nstrategies that can be used and adopted when making any design choices\ninvolved. Following this usually involves the designer in making one or\nmore transformations between the di\ufb00erent notations that comprise the\nrepresentation part.\n\u2022 A set of heuristics or clich\u00e9s provides guidelines on the ways in which\nthe activities de\ufb01ned in the process part can be organised or adapted for\n", "page": 225, "type": "text", "section": "Page 225"}
{"text": "Plan-Driven Software Design\n209\nparticular classes of problem. These may well be based upon experience\nof past use.\nIn terms of the classi\ufb01cation employed by Vessey & Conger (1994), the process\npart can be considered as embodying declarative knowledge, while heuristics\nprovide a means of supplying procedural knowledge. (The representation part\nis a vehicle for capturing knowledge about the design model rather than a\nmechanism for creating it.) We will use these three elements as a framework\nfor discussing how the examples of plan-driven forms discussed in the rest of\nthis chapter are structured.\nHowever, to return to the question posed at the start of this section, namely\nwhat bene\ufb01ts do users hope to obtain from using a \u2018systematic design method\u2019,\nit can be argued that some of the bene\ufb01ts are as follows.\n\u2022 The representation part of a design method provides an arti\ufb01cial frame-\nwork to help with thinking about an invisible set of elements. Portray-\ning ideas about something that is invisible is inevitably a challenging\nissue when designing software, and the representation part of a method\ndoes provide a syntax and semantics to aid this through the notations\nadopted.\n\u2022 Design methods can assist with managing some of the e\ufb00ects of scale\nand of the cognitive load this imposes, particularly where teams are\ninvolved. They do so by ensuring that consistent forms of description are\nused for sharing knowledge among a team. Recording design plans in a\nconsistent manner may well be important for future evolution (and while\nthey may not necessarily reduce the technical debt involved, they can at\nleast help with making it explicit). However, while design records may\nhelp a maintenance team to understand the intentions of the original\ndevelopers (Littman et al. 1987), as Parnas & Clements (1986) have\nobserved, such documentation may well be more helpful if it describes\nan \u2018idealised\u2019 process rather than the more opportunistic strategy that\nmay well have actually been followed, even for a plan-driven method.\n\u2022 As already noted, plan-driven methods act as a knowledge transfer mech-\nanism. Observational studies suggest that although experienced design-\ners may often work in an opportunistic manner, this practice may be less\nwell-formed and reliable when the designer is less familiar with a problem\nor its domain (Adelson & Soloway 1985, Guindon & Curtis 1988, Visser\n& Hoc 1990). So for the inexperienced designer, or the designer who is\nworking in an unfamiliar domain, the use of a systematic design method\nmay help with formulating and exploring a design model. Hence to some\nextent at least, method knowledge may provide a substitute for domain\nknowledge, where the latter is inadequate or lacking.\nFigure 13.1 is a revised form of the \u2018problem-solving\u2019 model that we originally\nsaw in Figure 1.1. Part (b) has been revised to show how a plan-based design\n", "page": 226, "type": "text", "section": "Page 226"}
{"text": "210\nSoftware Design: Creating Solutions for Ill-Structured Problems\nstrategy addresses the problem of \u2018solving\u2019 an ISP (and is much simpler than\nthe form described in Figure 1.1). We can also see that in some ways, the\nproblem-solving process in Figure 13.1(b) is much closer to the form in Figure\n13.1(a), which describes how we solve WSPs. Of course, this is rather idealised,\nsince iteration may well occur between the steps of a method, but nonetheless,\nthe design process involved is a much more constrained one.\nproblem\nspecification\nsolution\nprocedure\nsolution\nset of algorithmic\nrules to apply when\nsolving such problems\nset of algorithmic\nrules to apply when\nsolving such problems\na) Process for 'solving' a WSP\nproblem\nspace\nstep 1\nStep 2...\nStep n\npart\nsolution 1\npart\nsolution 2\npart\nsolution n\nsolution\nspace\nProcedural knowledge \nand problem expertise\nProcedural knowledge \nand problem expertise\nb) Plan-driven process for 'solving' an ISP\nDeclarative \nknowledge \nDeclarative \nknowledge \nFIGURE 13.1: Addressing an ISP using a plan-driven form\nHowever, while a systematic design method may help to structure the\nstrategy used to address an ISP, it cannot magically turn it into a WSP,\nand in particular, the designer\u2019s choices and decision-making will still need\nto be made on the basis of the problem being addressed. What a design\nmethod assists with, is guiding the designer about determining when it might\nbe appropriate to make those decisions.\nIt may be helpful here to return brie\ufb02y to the analogy of the recipe for\ncooking. A recipe describes the process that should be followed in order to\ncreate a particular dish, in much the same way as a software application may\nembody the algorithm needed to rank the positions of the nearest cars for\n", "page": 227, "type": "text", "section": "Page 227"}
{"text": "Plan-Driven Software Design\n211\nthe CCC. Designing software applications is therefore rather like designing\nrecipes, it requires the designer to possess insight into the problem domain;\nto be aware of the potential that is present in the various available materials;\nand to appreciate the bounds upon the software application (or cook) that will\nperform the task. So plan-driven (and other) design methods are essentially\nstrategic in their scope rather than prescriptive.\nExperts use design methods (selectively). PvdH #17\nThe rest of this chapter looks at some examples of plan-driven forms. Of\nnecessity the descriptions have to be brief (a full description for any of them\nmerits a book in itself). However, they should be su\ufb03cient to show how plan-\ndriven strategies have evolved and something of the way that they can help\nwith addressing the problem of designing software.\n13.4\nSSA/SD: example of an early plan-driven form\nThe structured systems analysis/structured design (SSA/SD) method in\nits various \ufb02avours provides a good example of an early plan-driven approach\nto design. It is one that evolved over a period when software applications were\ngetting larger and ideas about how to design software were in a rapid state\nof evolution. SSA/SD was by no means the only approach to software design\nbeing explored and documented in this period, but became quite a widely-\nused form, perhaps because it stemmed largely from work performed by IBM,\nwhich was then a leading organisation involved both in developing software\nand also researching into the associated issues. Various authors published\nbooks describing forms of SSA/SD (Gane & Sarsen 1979, Page-Jones 1988,\nConnor 1985), as well as variants such as real-time applications, covered in\nthe books by Hatley & Pirbhai (1988) and Ward & Mellor (1985). For this\nsection we will largely follow the form described by Page-Jones (1988).\nAs a design method, this one is really a composite of two separate but\nrelated techniques. Structured systems analysis is concerned with modelling\nthe problem-related characteristics of the application, making use of a set of\nrepresentation forms that can also be used for architectural design. Struc-\ntured design is then concerned with the \u2018solution\u2019-related aspects involved in\nproducing a design model.\nIn its early forms, the basic design strategy was a re\ufb01nement of top-down\ndesign, with the choices involved in the functional decomposition process be-\ning moderated and constrained by considerations of information \ufb02ow, and to\na lesser degree, of data structure. Subsequent variants adopted a more compo-\nsitional approach for the analysis stages, based upon such techniques as event\n", "page": 228, "type": "text", "section": "Page 228"}
{"text": "212\nSoftware Design: Creating Solutions for Ill-Structured Problems\npartitioning (Avison & Fitzgerald 1995). There were some later developments\nthat tried to adapt the approach to an object-oriented style, but these do not\nseem to have been adopted very widely, and apart from these, the evolution of\nSSA/SD forms e\ufb00ectively appears to have come to an end in the later 1980s\nat a time when ideas about software architecture were evolving rapidly.\nIn the rest of this section we brie\ufb02y examine the representation part, pro-\ncess part and some of the heuristics used in this method.\n13.4.1\nSSA/SD representation part\nThe two techniques make use of quite di\ufb00erent notations. The structured\nsystems analysis element primarily builds a problem model using data-\ufb02ow\ndiagrams or DFDs (see Section 9.2), while the structured design component\ncreates a design model around the use of structure charts (see Section 9.5).\nThe functional model created by using the DFDs can be augmented\nthrough the use of more detailed descriptions of the bubbles in the form of\n\u2018process speci\ufb01cations\u2019 or P-Specs, where these can be regarded as providing\na subsidiary functional viewpoint. A P-Spec is a textual description of the\nprimitive process represented by a bubble, summarising the process in terms\nof its title, input/output data \ufb02ows and the procedural tasks that it performs.\nAn additional element of the \u2018problem model\u2019 is a Data Dictionary. This\ncan be used to record the information content of data \ufb02ows, drawing together\ndescriptions of all of the data forms that are included in the DFDs, P-Specs\nand any other elements that might be used. In its initial form this should be\nhighly abstract and avoid focusing upon physical format (Page-Jones 1988).\nWhereas problem modelling can use a variety of supplementary forms (such\nas ERDs and state transition diagrams), the solution modelling part is con-\n\ufb01ned to using structure charts. As observed earlier, the structure chart is\na program-oriented form of description that maps on to the call-and-return\nstyle.\n13.4.2\nSSA/SD process part\nThe process embodied in this method can be regarded as an elaboration\nof the basic top-down approach based on functional decomposition, being\nextended by adding such elements as consideration of information \ufb02ow. A\nsimple description of the process is as follows.\n1. Construct an initial DFD (the context diagram) that provides a top-level\ndescription of the application in terms of a single bubble together with\na set of inputs and outputs.\n2. Elaborate the context diagram into a hierarchy of DFDs, and while doing\nthis, develop the accompanying data dictionary.\n", "page": 229, "type": "text", "section": "Page 229"}
{"text": "Plan-Driven Software Design\n213\na)\nb)\nc)\nd)\nFIGURE 13.2: A schematic model of the SSA/SD process\n3. Use transaction analysis to partition the DFD into tractable units that\neach describes a speci\ufb01c \u2018transaction\u2019.\n4. Perform a transform analysis upon each of the DFDs resulting from Step\n3, in order to produce a structure chart for the corresponding transac-\ntion.\n5. Merge the resulting structure charts to create the basic design model,\nre\ufb01ning them as necessary to address issues such as initialisation, error-\nhandling and other exceptions that are not part of the main operational\nactivities.\n", "page": 230, "type": "text", "section": "Page 230"}
{"text": "214\nSoftware Design: Creating Solutions for Ill-Structured Problems\nFigure 13.2 provides a schematic model of this process. In part a), we see\nthe complete system DFD produced from steps 1 and 2. Part b) shows the\nprocess of transaction analysis, with the DFD being partitioned into three\nsmaller DFDs that address speci\ufb01c tasks (the dashed lines show the divisions).\nIn part c), transform analysis has been used to create structure charts for the\nthree transactions, and then \ufb01nally in part d), these have been combined to\ncreate the complete design model for the application program. (This is very\nidealised, and we have assumed here that the functionality in each bubble can\nbe readily mapped on to a single sub-program.)\nEach of these steps involves what we might consider to be design activities\n(use of the term \u2018analysis\u2019 in this method can be a bit misleading). Steps 2-4\nform the core of the method, and as we might expect, while there is guidance\navailable about how to perform these tasks, actually mapping them on to a\nreal problem is a task \u2018left for the reader\u2019. Transform analysis in particular is\nwhere the design model becomes modi\ufb01ed, and while the emphasis upon data\nand function is retained, the logical model embodied in the DFDs is changed\ninto a \u2018physical\u2019 model that maps on to sub-programs.\n13.4.3\nSSA/SD heuristics\nHeuristics are often created when a particular design method is used on a\nset of broadly similar problems. This does not seem to have been the case with\nSSA/SD although a number of heuristics have become established to provide\nguidance on such tasks as creating a DFD, or performing a transform analysis.\nA technique that we should mention here is that of factoring, used to\nseparate out the functions of a module, where the operations of one module\nare contained within the structure of another. Factoring can be considered\nas a re\ufb02ective activity aimed at reducing the size of modules, clarifying their\nfeatures, avoiding duplication of operations and helping with reuse of design\nelements. Some of the tasks of Step 5 above are related to factoring and\ntogether they highlight the way that the use of such design methods may\nstill depend upon an additional design element in order to produce \u2018e\ufb03cient\u2019\ndesign models.\n13.5\nSSADM: a designed design method\nOur second example is a plan-driven design method that has rather di\ufb00er-\nent origins, and hence provides some interesting features. SSADM (structured\nsystems analysis and design method) was developed by Learmonth & Burchett\nManagement Systems on behalf of the UK government. It was intended to\nsupport the development and long-term maintenance of data-intensive sys-\n", "page": 231, "type": "text", "section": "Page 231"}
{"text": "Plan-Driven Software Design\n215\ntems since the use of these, and hence their systematic production, was seen\nas playing an important role for both central and local government agencies.\nPart of the rationale for commissioning such a development was the way\nthat public bodies in the UK are traditionally organised. In particular, central\nand local government agencies often move sta\ufb00to new posts on a regular\nbasis (the UK civil service has tended to favour the idea of the \u2018generalist\u2019\nover the \u2018specialist\u2019, and hence sta\ufb00development tends to require the gaining\nof wide experience). Where such roles involved the responsibility for software\ndevelopment, it was considered that regular change of sta\ufb00could (and did)\nlead to discontinuity in the way that the software applications were developed,\nand hence that using a mandated approach for their development would help\novercome this.\nSSADM Version 3 was the \ufb01rst stable version of the method, and was\nsupported by a small number of textbooks. This evolved into Version 4 in\nthe early 1990s, at which point the method was considered to be \u2018mature\u2019,\nand which appears to have marked the end of development for both SSADM\nand for the textbooks supporting it (Longworth 1992, Weaver, Lambrou &\nWalkley 2002). This period also coincided with the growing uptake of object-\noriented platforms, which would have been likely to compete as an alternative\nstrategy for use in government projects.\nCar\nBilling\nrecord\nMaintenance\nsession\nUser\nreservation\nUser query\n(availability)\nFIGURE 13.3: Example of an LDS\n13.5.1\nSSADM representation part\nThe forms adopted for SSADM largely reused established ideas and no-\ntations, albeit with some (sometimes rather confusing) renaming and rela-\nbelling. SSADM analysis and modelling practices address the following main\nviewpoints.\n", "page": 232, "type": "text", "section": "Page 232"}
{"text": "216\nSoftware Design: Creating Solutions for Ill-Structured Problems\n\u2022 Data relationships. These are modelled using the fairly conventional\nentity-relationship diagram, relabelled as a logical data structure (LDS),\nwith the modelling process being termed \u2018logical data modelling\u2019, or\nLDM.\n\u2022 Data \ufb02ow. This is modelled using a form of DFD, which is either de-\nveloped by transformation of an existing application or through decom-\nposition. However, these are more solution-oriented than the \u2018bubble\u2019\nforms used by De Marco and others for analysis.\n\u2022 Function and behaviour. Modelling of these viewpoints uses entity-life-\nhistory (ELH) diagrams that have the same form and syntax as a Jackson\nstructure diagram (Jackson 1975).\na\nCUSTOMER\nb\nCAR\nFinds nearest \nthree cars\n1.1\nLOCATE\nRecord details\nof customer\nand car\n1.3\nBILLING\nReserves\nchosen car\n1.2\nSELECT\nGenerate\naccess code\n1.4 ACCESS\nD1 Available cars\nrequest car\nlist of available cars\ndetails of \nnearest 3 cars\ndetails of \nnearest 3 cars\nchoice of car\nreserve car\ndetails of car\nand customer\nD2 Usage register\nrecord start\nof session\nauthorise\ncode\ncode\nFIGURE 13.4: Example of a DFD using SSADM notation\nFigures 13.3 to 13.5 provide examples of each of these forms. Within the\nJackson structure diagram notation, a \u2018plain\u2019 box signi\ufb01es a single action\nwithin a left-to-right sequence, a box with a star in a corner indicates iteration\nof the action (including the possibility of no action), and boxes with circles\nindicate selection between optional choices. For the latter, an unlabelled box\nindicates that one option might be \u2018do nothing\u2019. At any level of expansion of\n", "page": 233, "type": "text", "section": "Page 233"}
{"text": "Plan-Driven Software Design\n217\ncar\noperation\nremoved\nfrom use\nregistered\nas available\noperational\nuse\nrelease\nfrom service\nassign to\nbooking\nwithdraw\nfor service\nrelease\nfrom booking\n*\nFIGURE 13.5: Example of an entity-life-history diagram\nSSADM\nprocess\nPhase 2\nSystems\nAnalysis\nPhase 3\nSystems\nDesign\nPhase 1\nFeasibility\nStudy\n(No study)\nConduct\nstudy\nStage 3\nSelection\nof technical\nrequirements\nStage 2\nSpecification\nof \nrequirements\nStage 1\nAnalysis of\noperations\n& problems\nStage 6\nPhysical\ndesign\nStage 5\nProcess\ndesign\nStage 4\nData\ndesign\nFIGURE 13.6: The SSADM process part\na branch of the model, only one form (sequence, iteration, selection) can be\nused\u2014they cannot be mixed.\n13.5.2\nSSADM process part\nDeclarative knowledge is embedded into SSADM through a strongly hier-\narchical process, with three top level phases. The \ufb01rst (a feasibility study) is\noptional, and the other two phases each consist of three stages. The stages are\nfurther sub-divided into steps which in turn each encompass a set of one or\n", "page": 234, "type": "text", "section": "Page 234"}
{"text": "218\nSoftware Design: Creating Solutions for Ill-Structured Problems\nmore tasks. Figure 13.6 uses the Jackson structure diagram format to describe\nthe top levels of the process part.\nSSADM practice is very much focused upon the idea of producing a logical\ndesign for an application, and this is only mapped on to a physical design\nin the \ufb01nal stage. So, in principle at least, there is no strong coupling to a\nparticular architectural style. SSADM is also a very bureaucratic method,\nas might be expected from its origins and purpose. Figure 13.7 provides an\nexample of Step 320 (the \ufb01rst digit indicates which phase of the method\nthis concerns). Note in particular that there is also a strong emphasis upon\ndocumentation, which again has an important role in this method. However,\nwhen we examine empirical knowledge about plan-driven forms in Section 13.7\nwe will see that the procedures of SSADM can be, and have been, used in part\nwithout necessarily employing the complete method.\nInputs:\nOption Specifications from (step 310)\nRequired system specification (from stage 2)\nTasks:\n1. Prepare presentation plan\n2. Prepare presentations for each option\n3. Deliver presentations\n4. Provide assistance and advice for option\nselection\n5. Note decisions of users\nTechniques:\nUser option selection\nOutputs:\nNote of option decisions (to 330)\nOption specifications (to 330)\nFIGURE 13.7: Step 320: user selects from technical options\n13.5.3\nSSADM heuristics\nSSADM can be regarded as using rather formalised heuristics in a number\nof the steps, referring to these as techniques. There are 13 of these, and their\nmain role is to provide procedural knowledge that can be used to help develop\nthe diagrams, with SSADM placing heavy emphasis on the use of matrices for\nthis purpose. A matrix in this context is a grid or table that helps with iden-\ntifying links between elements, rather as the state transition table described\nin Section 9.3 can be used to develop state transition diagrams.\nHowever, these could also be regarded as providing declarative knowledge\nas well as procedural knowledge, although it can be argued that their use\naugments the SSADM process rather than forming a part of it. Figure 13.8\n", "page": 235, "type": "text", "section": "Page 235"}
{"text": "Plan-Driven Software Design\n219\nshows an entity-life-history matrix (ELH matrix) that can be used to help\nproduce the ELH diagram shown in Figure 13.5.\nEntities\nEvents\nseek nearby reserve\nstart\nrelease\nservice\nservice\ncars\ncar\nsession\ncar\nwithdrawal release\ncar\n*\n*\n*\n*\n*\ncustomer\n*\n*\n*\n*\nbooking system\n*\n*\n*\n*\nbilling system\n*\n*\nmaintainers\n*\n*\nFIGURE 13.8: Example ELH matrix\n13.6\nPlan-driven design for object-oriented models\nEarly thinking about how to design object-oriented systems not unnatu-\nrally sought to use experience from the approaches used to design applications\nthat used call-and-return and other forms of software architecture. Since plan-\ndriven forms were then the main established vehicle for knowledge transfer,\nit was not surprising that design \u2018methodologists\u2019 sought to extend the use of\nwhat was generally considered a generally e\ufb00ective approach. Indeed, many\n\u2018\ufb01rst-generation\u2019 OO design methods made varying degrees of use of existing\nideas and notations.\nHowever, while in principle, plan-driven approaches are a viable means\nof providing knowledge transfer about OO design, the greater complexity of\nthe OO model, when compared to architectural styles such as call-and-return,\nhas tended to result in a correspondingly greater complexity of structure for\nassociated plan-driven approaches.\nThis section examines two OO plan-driven methods (Fusion and the Uni-\n\ufb01ed Process). Both represent attempts to create a second-generation plan-\ndriven method by merging ideas from \ufb01rst-generation OO methods that were\nseen as e\ufb00ective. In many ways, the UP can also be considered as the point\nat which the use of a plan-driven form both achieved maximum complexity,\nand also started to morph into more agile forms.\n13.6.1\nThe Fusion method\nAs indicated above, Fusion can be viewed as being a \u2018second-generation\u2019\nOO method. Indeed the methodologists at the Hewlett-Packard Laborato-\nries in Bristol UK who developed Fusion described their goal as being to\n", "page": 236, "type": "text", "section": "Page 236"}
{"text": "220\nSoftware Design: Creating Solutions for Ill-Structured Problems\n\u201cintegrate the best aspects of several methods\u201d (Coleman, Arnold, Bodo\ufb00,\nDollin, Gilchrist, Hayes & Jeremes 1994). Among the problems intrinsic to\nan object-oriented approach that they identi\ufb01ed as drivers for their work, the\nmethod developers included the following.\nDi\ufb03culty with \ufb01nding the objects. They observed that \u201c\ufb01nding the\nright objects and classes in an object-oriented system is not easy\u201d.\nFunction-oriented methods being inappropriate. Their observation here\nwas that for OO applications, the traditional methods of analysis and\ndesign (that is, those based on data-\ufb02ow and function) \u201cno longer\nwork\u201d. Implicitly, the use of these was seen as a weakness of many\n\ufb01rst-generation approaches. In particular, they noted that \u201cfunctional\ndecompositions clash with the object structure of the implementation\u201d.\nWhile Fusion seems to have had some early success in terms of its adoption,\nit never seemed to acquire a solid base of users. The text by Coleman et al.\n(1994) remains the only readily available description of the methods, and\nseems to be mainly cited when authors are discussing OO methods. Wieringa\n(1998) did note that there had been some subsequent development of the\nmethod, but that these were not readily accessible, and so the description\nprovided here is that described in the 1994 version. Since the more distinctive\nelement of Fusion lies in the process part, we describe this \ufb01rst (there are no\nevident heuristics).\nThe Fusion process\nRe\ufb02ecting the need for more complex processes to address the more com-\nplex architectural style created by the use of objects, the Fusion process has no\nfewer than eight distinct steps. Four of these are classi\ufb01ed as analysis (black\nbox modelling) while the other four are white box design steps. Continuity\nthrough the overall process is provided through the use of a data dictionary,\nwhich is intended to act as \u201ca central repository of de\ufb01nitions of terms and\nconcepts\u201d. Arguably, this is the one element that is most evidently (and sensi-\nbly) carried over from earlier structured design practices. The eight steps are\nshown in Figure 13.9, and can then be summarised as follows.\n1. Develop the object model. While the task of this step is identi\ufb01ed as\nidentifying a set of candidate classes, relationships and attributes, the\nmethod does not specify how this should be done. The outcomes are a\nset of entries in the data dictionary, plus a set of diagrams making up\nan initial object model for the system as a whole, together with its en-\nvironment. Advice on conducting this step includes using brainstorming\nand noun-verb analysis1.\n1Noun-verb analysis was used in some \ufb01rst-generation OO methods. It involves producing\na written description of a \u2018rough\u2019 design solution and then identifying candidate objects from\nnouns and candidate operators from the associated verbs.\n", "page": 237, "type": "text", "section": "Page 237"}
{"text": "Plan-Driven Software Design\n221\nRequirements\nDocument\n(Analysis)\nStep 1\nDevelop object\nmodel\nAdded system\noperations\nBehaviour\nadded to model\nInitial\nobject model\nStep 4\nCheck analysis\nmodels\nStep 2\nDetermine system\ninterface\nStep 3\nDevelop interface\nmodel\nModel revised\nas needed\nAdded temporal\naspects\nProvide system\nfunctionality\nStep 5\nDevelop object\ninteraction graphs\nStep 7\nDevelop class\ndescriptions\nStep 6\nDevelop visibility\ngraphs\nDetailed class\nmodel\nAdded abstract\nclasses\n(final model)\nStep 8\nDevelop inheritance\ngraphs\n(Design)\nFIGURE 13.9: The Fusion design process\nIn addition to identifying candidate classes, relationships and attributes,\nthis process should also identify any invariants and record their details\nin the data dictionary. For our purposes an invariant is some form of\nconstraint upon the overall state of the system.\n2. Determine the system interface. The model from step 1 is essentially\na static one, and this step extends it to describe the dynamic behaviour\nof the system as a whole. In doing so, it also clari\ufb01es the system bounds\nby determining what is, and what is not, included in the system itself.\nThe core concept here is that of the event, with the designer being en-\ncouraged to think of how the system is to respond to external events as\nwell as to consider what events will be generated in response to these.\n", "page": 238, "type": "text", "section": "Page 238"}
{"text": "222\nSoftware Design: Creating Solutions for Ill-Structured Problems\nThe approach suggested is to consider a set of scenarios of use, mod-\nelled as timeline diagrams (essentially message sequence diagrams, as de-\nscribed in Section 10.6), extending the data dictionary to include these\nscenarios.\n3. Development of the interface model. The \ufb01rst element of this in-\nvolves creating a set of use cases that generalise the scenarios from the\nprevious step (termed life-cycle expressions). These are then used as the\nbasis for the \u2018operational model\u2019 that de\ufb01nes the semantics (meaning)\nfor each system operation, expressed in terms of informal pre-condition\nand post-condition speci\ufb01cations. Overall, this provides a functional de-\nscription of the system.\n4. Check the analysis models. This step is intended to ensure complete-\nness and consistency in the (still black-box) model, rather than extend-\ning it in any way. Completeness is largely a matter of cross-referencing\nwith the requirements speci\ufb01cation (a limitation of plan-driven mod-\nels is that they implicitly require a requirements speci\ufb01cation as their\nstarting point). Consistency is concerned with ensuring that the di\ufb00er-\nent viewpoint models from the previous steps (which we can categorise\nas being constructional, behavioural and functional) as well as the in-\nvariants represent the same overall design model. This can be partly\nachieved by using scenarios to trace event paths through objects.\n5. Develop object interaction graphs. The \ufb01rst step categorised as be-\ning \u2018design\u2019 is used to describe the designer\u2019s intentions about how the\nobjects will interact at run-time to provide the required functionality.\nThis involves creating an object interaction graph for each system oper-\nation, and in doing so, making decisions about message passing between\nobjects and any resulting state changes.\nOne of the elements also clari\ufb01ed in this step is the point at which objects\nshould be created from the classes. (Although the descriptions tend to\nbe couched in terms of objects, since these are the executable elements\nof the eventual system model, the model itself is really described in\nterms of classes\u2014while recognising that many classes will only lead to\nthe creation of a single object.)\nA question here is whether the set of objects used in this step is essen-\ntially that created in Step 1? The answer to this is \u2018yes\u2019, as the objects\ninvolved are de\ufb01ned as design objects that are derived from the analysis\nobjects. So these are still relatively high-level elements that may later\nneed to be expanded or re\ufb01ned.\nEach object interaction graph has a single controller object which has a\nmessage entering from outside of the particular set of objects involved\nin the operation, and also one or more collaborator objects that make\nup the rest of the set. There are two important design decisions here:\n", "page": 239, "type": "text", "section": "Page 239"}
{"text": "Plan-Driven Software Design\n223\none is identifying the controller, while the second is the possible need to\nintroduce new objects (classes) to provide the required functionality.\n6. Develop visibility graphs. These are used to describe the other classes\nthat a class needs to reference, as well as the forms of reference to be\nused, and their lifetimes (whether the knowledge should persist through\nthe life of the system, or be more transitory).\nThis temporal aspect is an important (and distinctive) feature of this\nFusion step. However, at this point, the in\ufb02uence of time is largely con-\n\ufb01ned to its in\ufb02uence upon the constructional aspects.\n7. Develop class descriptions. This step involves drawing together the\noriginal object model with the outcomes from the previous two steps\nto produce class descriptions that specify the following characteristics\nfor each object.\n\u2022 The methods and their parameters (derived from the object inter-\naction graphs and object visibility graphs).\n\u2022 The data attributes (from the object model and the data dictio-\nnary).\n\u2022 The object attributes (largely from the object visibility graph for\nthe relevant class).\n\u2022 The inheritance dependencies.\nThere are clearly quite a lot of decisions related to di\ufb00erent forms of\nuses relationships in this step, and it is really the \ufb01rst time that inher-\nitance structures are signi\ufb01cantly involved (although there is provision\nfor identifying these when creating the original object model in Step 1).\n8. Develop inheritance graphs. While the previous step was concerned\nwith ideas about specialisation through inheritance derived from the\noriginal object model, this step is concerned with identifying new ab-\nstract superclasses. In particular, the designer is encouraged to look at\nthe relationships between the classes developed in Step 7 and identify\ncommon abstractions.\nWhile some elements of Fusion are relatively loosely structured, such as the\nmodel building in Step 1, which can be expected to be strongly problem-\ndriven, the subsequent steps provide quite good guidance on re\ufb01ning this.\nFusion does make good use of diagrammatical notations to develop the func-\ntional and behavioural viewpoints and also to ensure consistency between the\ndi\ufb00erent viewpoints.\nThe Fusion notations\nFusion makes quite extensive use of box-and-line notations, although with\na much less complex variety of forms than is used in the UML. The syntax is\nalso less detailed than that of the UML.\n", "page": 240, "type": "text", "section": "Page 240"}
{"text": "224\nSoftware Design: Creating Solutions for Ill-Structured Problems\nClass name\nattribute\nAggregate class\nClass 3\nClass 2\nClass 1 C\nname\nClass\n(a) Object Model\nRole 1\nRole 2\nThis example shows aggregation and\nRelationship. C represents the cardinality\nof the aggregation. Can also use to model\nclass generalisation (subtyping inheritance).\n(b) Object interaction graph\nObject name: class\nObject\nObject 1: class 1\nsystem operation()\n(Controller object)\nObject 3: class 3\nObject 2: class 2\n(Collaborator objects)\nMessage 1 (parameter list)\nMessage 2 (parameter list)\nClass name\nattribute\nClass\n(d) Inheritance graph\nSuperclass\nSubclass 1\nSubclass 2\nSubclass 3\n(c) Object visibility graph\nClass (client)\nServer object\nClass name\nName: class\nClass A\nObject 1: class B\nExample of 'server lifetime unbound'\n(Lifetime of the server object is not bound to\nThe lifetime of the class that is accessing it)\nFIGURE 13.10: Some Fusion notation forms\nLike other OO methods and the UML, the construction viewpoint employs\na class diagram (termed the object model that has strong similarities to the\nERD notation described in Section 9.4. A simple example of this is shown in\nFigure 13.10(a).\nClass behaviour makes use of textual descriptions. Informally, in (Coleman\net al. 1994) there are examples that describe scenarios by using a form similar\nto the UML message sequence diagram that we described in Section 10.6.\nIn the later, more detailed stages of model development, functionality is\ndescribed by using object interaction graphs to describe the way that objects\ncollaborate. A graph is created for each system operation. Figure 13.10(b)\nshows an example of this form, which does di\ufb00er rather from other notations\nencountered so far.\n", "page": 241, "type": "text", "section": "Page 241"}
{"text": "Plan-Driven Software Design\n225\nThe second form of notation that can perhaps be considered as being spe-\nci\ufb01c to Fusion is the object visibility graph, shown in Figure 13.10(c). This is\nused to describe the \u2018reference structure of classes in the system\u2019, identify-\ning the objects that class instances need to access and the forms that these\nreferences should take (including their permanency or otherwise). In e\ufb00ect,\nthis notation is intended to describe encapsulation, and hence can be regarded\nas providing a data-modelling viewpoint.\nFinally, Fusion makes use of a relatively conventional inheritance graph,\nwhich again, provides support for modelling of the constructional viewpoint.\nAn example of this is provided in Figure 13.10(d).\nFusion\u2014some observations\nThe description above, brief as it is, should be su\ufb03cient to allow us to\nmake a number of observations about the use of plan-driven approaches to\ncreate an object-oriented model.\n1. Fusion employs a quite complex four-viewpoint model at a relatively\nearly stage in the design process, particularly when compared to the\nsimpler models employed by SSA/SD in the early stages.\n2. The process throughout is largely one of re\ufb01nement and elaboration,\npossibly because of the more complex design model, rather than involv-\ning any element of transformation between viewpoints (a key element of\nSSA/SD).\n3. The basic set of candidate objects (a major design decision) is largely\ndetermined at the very start of the process. A bene\ufb01t of this is that\nthe design options are thereby constrained from an early point, while a\ndisadvantage is that it is then necessary to get the \u2018right\u2019 object model\nestablished very early in the process. For less experienced designers, this\ncan be a signi\ufb01cant challenge.\n4. The characteristics described by the constructional viewpoint play a\nmuch more \u2018up front\u2019 role than in more traditional plan-driven ap-\nproaches.\n5. While the concept of inheritance is integrated into Fusion, it is restricted\nto appearing very early (seeking to recognise domain-based opportuni-\nties) or much later, looking for constructionally-based opportunities.\nIn terms of the characteristics of the object model, it can be argued that\nFusion does provide support for all of the major ones: abstraction, modular-\nity, encapsulation, and hierarchy. Fusion also handles the often quite di\ufb03cult\ndistinction between the class and the object quite e\ufb00ectively. When consid-\nering static and abstract issues, and specifying general characteristics, then\nthe emphasis is rightly upon the class. When considering system behaviour,\nas well as temporal and dynamic characteristics, then the object is probably\n", "page": 242, "type": "text", "section": "Page 242"}
{"text": "226\nSoftware Design: Creating Solutions for Ill-Structured Problems\nthe better abstraction to employ. As a method, it does keep these distinct,\nand encourages the designer to use whichever is the more appropriate in the\nspeci\ufb01c steps.\nFusion therefore demonstrates that the use of a fairly \u2018traditional\u2019 form\nof plan-driven approach appears to be feasible when designing object-oriented\nsystems. However, key decisions about the choice of objects need to be made at\na very early stage. Indeed, this need to identify key elements early is probably\na disadvantage of all plan-driven approaches, regardless of the architectural\nstyle employed.\n13.6.2\nThe Uni\ufb01ed Process (UP)\nThe Uni\ufb01ed Process (UP) stems from the work of the \u2018three amigos\u2019: Grady\nBooch, James Rumbaugh and Ivar Jacobson. It draws strongly upon early\nwork by Jacobson at Ericsson, and his later development of the Objectory\n(Object Factory) method. The UP also exists in more commercial forms, with\nthe best known of these being the Rational Uni\ufb01ed Process (RUP).\nThe authoritative text on the UP is Jacobson, Booch & Rumbaugh (1999).\nTwo other widely-cited sources are by Kruchten (2004) and Arlow & Neustadt\n(2005). Perhaps because the UP is closely associated with the UML, there are\nalso various texts on combinations with other forms, such as design patterns,\ndescribed in Larman (2004).\nWhile, like Fusion, the UP represents a merging of ideas from many\nsources, it di\ufb00ers from Fusion in two signi\ufb01cant ways.\n1. The sources for the UP have included some of the most popular of the\navailable object-oriented methods and notations, as observed by Johnson\n& Hardgrave (1999).\n2. The resulting process structure is much less sequential than that em-\nployed in Fusion. Its form comes much closer to RAD (Rapid Applica-\ntion Development) methods such as DSDM (described in Chapter 14)\nthat represent something of an interim form between plan-driven and\nagile approaches.\nA consequence of the \ufb01rst di\ufb00erence is that the association with the UML has\nmeant that it uses forms that are, at least in part, more familiar to users. The\nconsequence of the second is that it can probably be regarded as something of a\n\u2018bridge\u2019 between plan-driven and agile ideas. While still more structured than\nagile forms, it is nonetheless more iterative in terms of the processes involved\nthan those employed by plan-driven forms. Taken together, these may at least\npartly explain why the UP has continued to be of interest into the 2000s,\nwhile Fusion has largely receded into the shadows. (This is not a comment\nor assessment about relative technical excellence, more an observation that\nthe form of the UP has probably \ufb01tted better with the way that ideas about\nsoftware development have evolved.)\n", "page": 243, "type": "text", "section": "Page 243"}
{"text": "Plan-Driven Software Design\n227\nThe process of the UP is organised in a far less linear form than conven-\ntional plan-based methods, although of course there is an overall \ufb02ow from\nbeginning to end of the process. The main elements are as follows.\n\u2022 Four project-based phases of development (inception, elaboration, con-\nstruction, transition) that each completes a major milestone in a project.\n\u2022 Each phase is organised as a set of one or more iterations or \u2018mini-\nprojects\u2019.\n\u2022 Each iteration cycle involves a set of activities associated with \ufb01ve\ntechnically-focused work\ufb02ows (requirements, analysis, design, implemen-\ntation, test). The extent to which the activities concerned with each\nwork\ufb02ow are involved will be di\ufb00erent for each phase.\nFigure 13.11 is an attempt to model this fairly complex process. In partic-\nular, the work\ufb02ow balance associated with each phase has been shown as a\nhistogram (the relative heights of the bars should not be taken too literally;\nthese are meant to be indicative). We begin with a brief look at the roles of\neach phase, and then discuss the activities of the work\ufb02ows. Some aspects are\nomitted: the iterations are really a project-speci\ufb01c element; and we concen-\ntrate on design-related activities, which means that we say little about the\nimplementation and testing work\ufb02ows.\nInception\nElaboration\nTransition\nConstruction\nPhase\nLife-cycle\nobjectives\nInitial\n operational \ncapacity\nProduct\nrelease\nLife-cycle\narchitecture\nMilestone\nIteration\nWorkflow\nbalance\nR\nA\nD\nI\nT\nR\nA\nD\nI\nT\nR\nA\nD\nI\nT\nR\nA\nD\nI\nT\nFIGURE 13.11: Organisation of the Uni\ufb01ed Process\nThe UP phases\nThe phases are very project-driven and create a framework that emphasises\nthe strong user links and iterative practices that characterise the UP (and that\ncharacterise the agile forms that we examine in the next chapter).\n", "page": 244, "type": "text", "section": "Page 244"}
{"text": "228\nSoftware Design: Creating Solutions for Ill-Structured Problems\n1. Inception. This phase is primarily concerned with project planning ac-\ntivities. However, we might note that establishing the feasibility of a\nproject may lead to the creation of one or more exploratory prototypes.\nThe milestone for this phase, life cycle objectives is largely concerned\nwith the eventual deliverables for the phase (documents, models, proto-\ntypes), but does include a candidate architecture, representing the initial\narchitectural design for the eventual application.\nThe milestone documents should also include:\n\u2022 an initial domain-based class model;\n\u2022 a set of domain-based use cases;\n\u2022 initial analysis and design models.\nAlthough iteration is implicit, the normal expectation is that this phase\nshould require only a single cycle. We might also note the use of use\ncases, a very distinctive feature of the UP and one that has been elabo-\nrated in later developments.\n2. Elaboration. From a design perspective, this is a much more signi\ufb01cant\nphase. Its purpose is to create the architectural baseline (top-level de-\nsign) that will underpin further development. In doing so, there is the\nexpectation of producing further use cases, as well as addressing ques-\ntions about quality factors, including those related to performance.\nThe milestone for this phase, the life cycle architecture is a partial work-\ning system. The UP documentation does emphasise that this is not an\nexploratory prototype, although it can be argued that it is fairly close\nto being an evolutionary prototype. The resulting set of models will\ninclude:\n\u2022 static domain-based class models;\n\u2022 a fuller set of use cases;\n\u2022 analysis models (both static and dynamic);\n\u2022 static and dynamic architectural design models.\nThe emphasis upon model-building and the need to ensure consistency\nbetween them, means that some degree of iteration is likely to be needed.\n3. Construction. Despite the name, this phase still involves some design\nactivity. The initial operational capacity milestone corresponds to the\ndelivery of a beta version of the application. Hence its goals include:\n\u2022 completion of any requirements elicitation or analysis tasks;\n\u2022 completion of models.\nClearly, the detailed physical design tasks form an essential element of\nthis.\n", "page": 245, "type": "text", "section": "Page 245"}
{"text": "Plan-Driven Software Design\n229\n4. Transition. The purpose of this phase is to lead to the \ufb01nal milestone\nof product release. Hence it is unlikely to lead to any design activities\nunless a need for these was revealed when exercising the beta version\nproduced in the preceding phase.\nThe UP work\ufb02ows\nA characteristic of plan-driven design methods that may by now be fairly\nobvious is that terms such as \u2018construction\u2019 or \u2018implementation\u2019 can mean\nquite di\ufb00erent things when used by methodologists, and in particular, may\ninvolve signi\ufb01cant design activities. For that reason we will look at all \ufb01ve\nwork\ufb02ows, although only with regard to the design issues that are involved in\neach one.\n1. Requirements work\ufb02ow. This work\ufb02ow relies extensively on the use of\nuse case modelling. Not only is the use case a rather distinctive charac-\nteristic of the UP, but a use case also has the advantage of being able\nto record both functional and non-functional attributes. The primary\nrole of a use case diagram is to identify the boundaries of a use case, as\nshown in the example of Figure 13.12. The detailed speci\ufb01cation of a use\ncase is not a part of the UML model, and designers often use text-based\ntemplates, although other forms such as message sequence diagrams can\nalso be used (Ratcli\ufb00e & Budgen 2001, Ratcli\ufb00e & Budgen 2005). Most\nbooks on the UML do discuss this issue, and there is a good introduction\nto use case modelling in (Arlow & Neustadt 2005).\nOne of the bene\ufb01ts of employing use cases is that they provide a good\nmechanism for veri\ufb01cation of a design model against requirements. A\nscenario derived from a use case can provide a walk-through mechanism\nthat directly links the two stages of development. Use cases also provide\na framework for the analysis work\ufb02ow.\n2. Analysis work\ufb02ow. The UP interprets \u2018analysis\u2019 in the conventional\n\u2018black box\u2019 sense of producing a model that describes what an appli-\ncation is to do, but not how it will be done. As always, the distinction\nbetween analysis and design is not completely clear-cut. The objectives\nof this work\ufb02ow are to produce analysis classes that model elements (ob-\njects) in the problem domain and to generate use case realisations that\nshow how the analysis classes interact in order to create the behaviour\nrequired for a given use case.\nAs always, identifying the analysis classes remains a challenging prob-\nlem. In the case of the UP this is supported through the use cases, as\neach use case can be separately analysed to identify both the analysis\nclasses and the way that they collaborate. The task of identifying the\nclasses still remains though, and relatively long-established techniques\n", "page": 246, "type": "text", "section": "Page 246"}
{"text": "230\nSoftware Design: Creating Solutions for Ill-Structured Problems\nIdentify\navailable cars\nAccess car\nSelect car\nLeave car\nCar use\nsession\nClub\nmember\nCar\nrecords\nAccounts\nrecords\n(subsystem boundary)\n(actor)\n(use case)\nFIGURE 13.12: Simple example of a use case diagram\nsuch as noun-verb analysis and CRC brainstorming (class-responsibility-\ncollaborator is described in (Beck & Cunningham 1989)) can be used.\nThe output from this work\ufb02ow can be modelled by using a range of\nUML notational forms, including:\n\u2022 class diagrams to model the static properties of the relationships\nbetween objects (uses, inheritance);\n\u2022 collaboration diagrams and message sequence diagrams to model\nthe dynamic aspects of the relationships between objects.\nFor a given use case, collaboration diagrams provide a static model of the\nrelationships between objects\u2014describing which elements are involved,\nand how\u2014rather than the when aspects (the actual interaction) that\nare described in forms such as message sequence diagrams. In particu-\nlar, an interaction can only occur between objects within the context\nof a collaboration. Collaboration diagrams can be used to model class\ncollaborations (the descriptor form) and object collaborations (the in-\nstance form). An example of a simple use case from the CCC, described\nusing a common tabular form, and the associated collaboration diagram\nis shown in Figure 13.13 (some detail has been omitted for clarity).\n", "page": 247, "type": "text", "section": "Page 247"}
{"text": "Plan-Driven Software Design\n231\nUse Case: Reserve Car\nID: CCC_14\nActors: Customer\nPreconditions: Customer has \nReceived details of nearby cars.\n Flow of Events:\n 1. Customer selects car from list.\n 2. Reservation Manager object sends\n 'reserve' message to selected car.\n 3. Reservation Manager generates\n 'unlock' code and sends to customer.\nPostconditions: Status of car is\nchanged to 'reserved'.\nUnique identifier\nUse case name\nSystem state before\nuse case can begin\nActors involved\nSystem state at\nend of use case\nSteps of the\nuse case\n:ReservationManager\nselectCar(carID)\ncode\nCustomerID: code\nCarID: status (new)\nCustomer\n<<create>>\n<<update>>\nFIGURE 13.13: A UML use case and associated collaboration diagram\nThe UML package notation can be used to group analysis classes and use\ncase realisations as analysis packages. Since packages can also contain\nother packages, the analysis model can itself be considered as being a\npackage. A key role of this notation is to help keep track of the analysis\nelements, with the overall analysis architecture being de\ufb01ned by the\nhigh-level analysis packages.\n3. Design work\ufb02ow This forms a major element of both the elaboration and\nconstruction phases and is intended to provide the white box description\nof how the black box model from the analysis work\ufb02ow is to be achieved.\nMany of the activities are similar to those described for Fusion: identi-\nfying design objects; when to create objects from the static classes; and\nthe persistence, or lifetime, of objects. Another consideration for this\n", "page": 248, "type": "text", "section": "Page 248"}
{"text": "232\nSoftware Design: Creating Solutions for Ill-Structured Problems\nwork\ufb02ow is the more structural question of how to employ the inheri-\ntance mechanism. And once again, the package mechanism can be used\nto manage the outcomes, although the term subsystem is now used in\nplace of package to indicate that more detail is provided.\nUse cases are expected to provide a linking thread between analysis and\ndesign and may themselves need to be elaborated further.\nThe UP design work\ufb02ow therefore addresses many detailed issues con-\ncerned with developing the design classes and their interfaces. Perhaps\nthe main change in the modelling involved, apart from elaboration of de-\ntail, is the development of behavioural viewpoint models, largely through\nUML statecharts, which also helps address the issues of object creation\nand persistence.\nAs with Fusion, the white box design tasks of the UP are largely con-\ncerned with elaborating detail and ensuring consistency between the\ndi\ufb00erent parts of the design model. Most of the key architectural deci-\nsions have already been made as part of the analysis work\ufb02ow, although\nobviously this can be revised by the activities of the design work\ufb02ow\nif necessary. In that sense, like Fusion, the key structural decisions are\nmade early in the process re\ufb02ecting the more compositional approaches\nemployed by these object-oriented methods.\n4. Implementation work\ufb02ow. This is primarily concerned with producing\nexecutable code, with the main design elements being con\ufb01ned to the\ndecisions involved in translating the design model to actual implemen-\ntation. Overall, this phase is not expected to form an active part of the\ndesign task.\n5. Test work\ufb02ow. As might be expected, this involves no explicit design\nactivities beyond any required in response to the testing outputs.\nThe UP\u2014some observations\nThe UP design process has a much more complex structure than the other\nmethods examined in this chapter, including Fusion. The interweaving of de-\nvelopment phases and work\ufb02ows produces a much more complex process than\nthe more linear forms of the other design methods we have examined, and as\nsuch forms a much more challenging management task.\nA key element of the UP, and one that particularly distinguishes it,\nis the use case. This concept provides a valuable framework that provides\nmanageable-sized analysis tasks; a thread through requirements, analysis, and\ndesign; and a mechanism that not only partitions the tasks for these work-\n\ufb02ows, but also provides the means of being able to cross-check for consistency\nand correctness. In many ways the more complex UP process model would\nprobably be impractical without the unifying theme of the use case.\n", "page": 249, "type": "text", "section": "Page 249"}
{"text": "Plan-Driven Software Design\n233\n13.7\nEmpirical knowledge related to plan-driven design\nThe use of plan-driven design methods is perhaps more associated with\nthe ideas of advocacy than those of rigorous empirical assessment. In the early\ndays at least, design methodologists tended to be codifying their experiences (a\nquite reasonable approach to knowledge transfer in the circumstances) rather\nthan exploring their limitations. There are a number of possible explanations\nfor the lack of useful empirical knowledge about design methods, including\nthe following.\n\u2022 By their nature, design methods both evolve and are intended to be\nadapted to meet di\ufb00erent needs. This means that any attempt at eval-\nuation of the processes involved usually lacks a widely-established and\nwell-de\ufb01ned \u2018baseline design method\u2019 to study.\n\u2022 Software development (at least before the emergence of open source soft-\nware) was largely conducted by commercial organisations\u2014and knowl-\nedge about how it was done may well have been considered as being of\ntoo much value to allow for open publication.\n\u2022 As we have observed, the development of ideas about design methods\nrather \u2018tailed o\ufb00\u2019 in the 1990s. However, this was also the period in which\ninterest in empirical research about software engineering was beginning\nto become more established, and so researchers were perhaps less likely\nto view design methods as a topic of interest.\nThe most appropriate form of empirical study to use in studying plan-\ndriven design development is probably the case study, since the subject matter\nneeds \ufb01eld studies with relatively long-term data collection, and there are also\nlikely to be many variables of interest. Unfortunately, these are challenging\nto perform for such a topic, and examples do appear to be lacking in the\nliterature. Nor do there seem to be any useful observation studies.\nAn alternative form for collecting information about experience with de-\nsign processes is the survey, and while these may collect data that can be\nconsidered as more \u2018shallow\u2019 for these purposes, a survey does o\ufb00er scope to\ncollect and aggregate user experiences. Such a survey was conducted by Ed-\nwards, Thompson & Smith (1989) to look at the use of SSADM, and other\nsurveys have been conducted to address questions about object-oriented meth-\nods. In the rest of this section we examine their \ufb01ndings and observations\nabout the use of plan-driven approaches (there were other \ufb01ndings, but here\nwe concentrate on the methodological aspects).\nKnowledge about SSADM. The survey by Edwards et al. was related to\nVersion 3 of SSADM, and was conducted on an organisational basis. Re-\nquests were sent to 310 organisations in industry and in local and central\n", "page": 250, "type": "text", "section": "Page 250"}
{"text": "234\nSoftware Design: Creating Solutions for Ill-Structured Problems\ngovernment organisations, from which they obtained 117 responses, with\n72 (23%) of these being usable. (Given that anything above 10% is re-\ngarded as being a good response rate for a survey, the researchers did\nwell.) At the time when they conducted their survey, projects tended to\nbe using programming languages such as COBOL and many were also\nconcerned with database management systems. For the responses, team\nsizes involved ranged from teams with fewer than 10 up to ones with\nover 200 developers.\nThe survey revealed that SSADM was rarely used in full, with developers\nbeing selective about when to make use of it. In particular, it was noted\nthat, while responses tended to be positive:\n\u2022 the techniques were generally found to be e\ufb00ective, but were time-\nconsuming to employ;\n\u2022 the entity-life-history diagram presented most problems for devel-\nopers when modelling and was the form of notation most frequently\nomitted;\n\u2022 the physical design step was the most challenging, perhaps in part\nbecause the method provided little in the way of detailed guidance\nabout how to perform this for a particular platform.\nKnowledge about OO design. The survey conducted by Johnson & Hard-\ngrave (1999) used two groups of participants: experienced developers and\ntrainees. Also, its focus was upon their attitudes and preferences with re-\nspect to object-oriented methods and tools, rather than upon the forms\nof the speci\ufb01c methods.\nSeparate survey forms were used for the two groups, and the sample\nincluded 102 experienced designers and 58 trainees. Since the survey\nwas conducted on-line, there are some methodological issues regarding\nsampling and representativeness, as the authors do acknowledge.\nThe authors also observe that the degree of comparison (between meth-\nods) that could be achieved was limited. This was chie\ufb02y because \u201ca\ntheory explaining attitudes and behaviour toward, and use of OOAD\nmethods does not currently exist\u201d. Hence they argue that the survey\no\ufb00ered an inductive approach that would \u201cuse facts to develop general\nconclusions\u201d and lay some of the groundwork for the development of\nsuch a theory.\nIn terms of comparisons, the survey was chie\ufb02y concerned with the de-\ngree of training provided for developers, their familiarity with, and pref-\nerence between, di\ufb00erent object-oriented methods, and their attitudes\ntowards them.\nThe methods covered by the survey were chie\ufb02y what we might term\nas \u2018\ufb01rst generation\u2019 design methods, although the set of methods did\n", "page": 251, "type": "text", "section": "Page 251"}
{"text": "Plan-Driven Software Design\n235\ninclude Fusion as well as the three methods that were subsequently\nbrought together in the Uni\ufb01ed Process. Their \ufb01ndings included the\nfollowing.\n\u2022 A relatively large proportion of time was spent on analysis and\ndesign of objects, relative to the time spent on coding and testing\nwhen compared with \u2018normal\u2019 expectations for software develop-\nment. It was thought that this might be because creating the de-\nsign for an object was more time-consuming than the equivalent\ntask for other architectural styles.\n\u2022 Adopting object-oriented methods involved a steep learning curve\n(although the respondents did regard this overhead as useful once\nthe knowledge had been acquired). This is consistent with an earlier\nstudy on the overheads of learning analysis and design for di\ufb00erent\nforms of software architecture (Vessey & Conger 1994), which also\nobserved that OO concepts could be challenging to use.\n\u2022 The limited expectations that respondents showed about code\nreuse. Here the authors observed that \u201cone of the most adver-\ntised bene\ufb01ts of OO is reuse, yet developers rated this lower than\ntrainees\u201d. Their conclusion was that \u201cthis is perhaps a case of\ntrainees believing the hype about reuse and developers actually\nrealising the di\ufb03culty in creating reusable code\u201d.\nOverall, the survey did \ufb01nd high levels of satisfaction with object-\noriented methods, both for analysis and design. However, as the authors\ndid caution, this might have partly been an artifact caused by the self-\nselection of participants, since those with a positive view of OO might\nbe more likely to have responded to the invitation to participate.\nUnfortunately, there are no later surveys that can be readily identi\ufb01ed\nin the literature, probably because the use of plan-driven methods with OO\ne\ufb00ectively \u2018ran out of steam\u2019 with the development of the Uni\ufb01ed Process. The\nsystematic mapping study described in Bailey et al. (2007) found relatively\nlimited empirical research into the object paradigm as a whole, with most\nemphasis being upon studies involving metrics,\nKey take-home points about plan-driven design practices\nKnowledge transfer. Plan-driven design practices provide method knowl-\nedge as the means of organising the design process, with this acting as a\nsubstitute for domain knowledge where appropriate. The process itself\nis usually organised as a sequence of \u2018analysis and design\u2019 steps that\n", "page": 252, "type": "text", "section": "Page 252"}
{"text": "236\nSoftware Design: Creating Solutions for Ill-Structured Problems\nprovide a solution modelling process for an ISP that is more akin to\nthat for a WSP.\nDesign input. Although plan-driven forms provide a structure that can help\norganise the design process, it is important to appreciate that the design\ndecisions made within this are still ones that are based upon the needs of\nthe application. Using a plan-driven approach requires that the designer\npossesses method knowledge, an understanding of the problem, and an\nappreciation of relevant design criteria.\nPlan-driven design strategies. These usually consist of a mix of a repre-\nsentation part; a process part; and a set of heuristics used to help adapt\na strategy or method to a particular type of problem. The process part\nincorporates declarative knowledge about how the design task should be\norganised as a set of steps. The heuristics provide procedural knowledge\nabout how to employ the method for a particular type of problem.\nContext. Plan-driven methods implicitly assume a \u2018waterfall-like\u2019 develop-\nment context. This is chie\ufb02y because they build their initial analysis\nmodels around the elements of the requirements speci\ufb01cation. While\nthis doesn\u2019t preclude making later changes to the model, the assump-\ntion is that the requirements speci\ufb01cation is a comprehensive description\nof the design goals.\nArchitectural form. Earlier plan-driven methods were concerned with rel-\natively simple architectural styles such as call-and-return, where the de-\npendencies (coupling) between design elements used only a limited set of\nforms. Use of plan-driven approaches has proved more challenging with\nsuch styles as the object-oriented model, where there are many forms of\ninteraction that can occur between the elements of a design.\nE\ufb00ectiveness. There are few empirical studies available to provide any in-\nsight into this. One bene\ufb01t of using a systematic plan-driven approach\nis that it helps constrain the structure of the resulting design model,\nwhich in turn may assist with later evolution of the model. Perhaps one\nof the main disadvantages of the plan-driven approach is that it can be\nbureaucratic, with a signi\ufb01cant overhead of documentation\u2014although\nas in the case of SSADM, that may be considered as a bene\ufb01t.\n", "page": 253, "type": "text", "section": "Page 253"}
{"text": "Chapter 14\nIncremental Design in Agile\nSoftware Development\n14.1\nUsing software prototypes .......................................\n238\n14.2\nIncremental development and the spiral model ..................\n241\n14.3\nRAD: the DSDM method ........................................\n243\n14.3.1\nThe DSDM principles ...................................\n244\n14.3.2\nThe DSDM process ......................................\n247\n14.4\nThe agile manifesto ..............................................\n249\n14.5\nExtreme programming (XP) .....................................\n250\n14.6\nAgile development: Scrum .......................................\n253\n14.7\nRefactoring .......................................................\n255\n14.8\nEmpirical knowledge about design in agile development ........\n257\n14.8.1\nEmpirical knowledge about DSDM\n.....................\n258\n14.8.2\nEmpirical knowledge about agile methods ..............\n258\n14.8.3\nEmpirical knowledge about refactoring .................\n259\nKey take-home points about designing in an agile context ......\n259\nIn the previous chapter we examined the use of plan-driven design approaches\nand noted some of the limitations of this form\u2014in particular, the need to have\navailable a fairly complete speci\ufb01cation of the functional and non-functional\nrequirements for intended application at the beginning of the design process.\nGiven that much of software development is, and always has been, concerned\nwith developing new and innovative applications, the di\ufb03culty of being able to\nspecify a complete set of requirements at the outset of a project is self-evident.\nIn practice, for most applications, the evolution of requirements and the\ndevelopment of a design tend to be intertwined and to play complementary\nroles in enhancing understanding just what the application needs to do. A\nrecognition of this interplay therefore led to various e\ufb00orts being made to \ufb01nd\nways to \u2018systematise\u2019 this process.\nIn this chapter, we \ufb01rst look at some early ideas about how to support this\ninterplay, and then at the ideas that came together under the Agile Manifesto.\nNot all of the ideas discussed, particularly in the \ufb01rst sections, are usually\nconsidered as being \u2018agile\u2019. However, they most de\ufb01nitely are not plan-driven\neither, and so \ufb01t well with the ideas of this chapter. As far as possible, we\nfocus upon the speci\ufb01c issues related to software design, but, as we noted with\nthe Uni\ufb01ed Process, when we move away from \u2018waterfall thinking\u2019 about the\n237\n", "page": 254, "type": "text", "section": "Page 254"}
{"text": "238\nSoftware Design: Creating Solutions for Ill-Structured Problems\nrole of design, it becomes much harder to compartmentalise its contribution\nto the process as a whole.\n14.1\nUsing software prototypes\nAs observed above, a major limitation of a linear development process such\nas a plan-driven one, is the need to identify exactly what is needed from an\napplication at the very beginning of the process. There are many reasons why\nthis is largely impractical: those commissioning the application (who may be\nthe developers of course) do not have a comprehensive picture of what it will\ndo; the picture that they do have may need to change between starting and\n\ufb01nishing development because of a growing understanding; and there may be\nmany uncertainties and possible omissions in the understanding of what is\nrequired.\nIn other engineering domains, such a situation is often resolved by the\nconstruction of some form of prototype which can be used to investigate both\nwhat is needed, and how it might be delivered. The same idea can be used\nwith software, although the ease with which software can be changed can make\nits role and use rather di\ufb00erent. For more traditional branches of engineering,\na prototype is usually regarded as a \u2018\ufb01rst of kind\u2019, or takes the form of a\nmodel that can be realised on a (reduced) scale. In automotive engineering,\na prototype of a car is de\ufb01nitely a \ufb01rst of kind (and sometimes the last too),\nwhile scale modelling may well be used with complex civil engineering projects.\n(As an example, the engineers constructing the Thames Barrier down-river\nfrom London built a scale model of their intended structures in the nearby\nmarshes.)\nAnalogous roles for prototypes are not easily found in software develop-\nment, where there is no manufacturing cycle and no real equivalent to scale\nmodelling. Indeed, for software it is quite possible that the prototype will ac-\ntually become the product in due course, which would make no sense for our\nexamples from other branches of engineering. However, while the form of a\nprototype might be di\ufb00erent for software, the reasons for creating prototypes\nare very similar to those found in other disciplines. Prototypes are constructed\nin order to explore ideas about the requirements and design of an application\nmore completely than would be possible by other means (such as modelling).\nA useful categorisation of major prototyping forms as used with software\nwas produced by Floyd (1984), and this recognised three principal roles for a\nprototype.\n1. Evolutionary. This is the form that is closest to the idea of incremen-\ntal development of an application. The software is changed gradually\nby changing the requirements speci\ufb01cation as experience is gained with\n", "page": 255, "type": "text", "section": "Page 255"}
{"text": "Incremental Design in Agile Software Development\n239\nusing the application, and changing the application to \ufb01t those changes.\nIn this form, prototyping is used to develop a product and the prototype\ngradually evolves into the \u2018end\u2019 product.\nOne bene\ufb01t of this strategy is that it allows a product to be made avail-\nable quickly where the market or other factors mean that this is needed\nurgently. It can then be re\ufb01ned through subsequent releases (Cusumano\n& Selby 1989).\n2. Experimental. In this role, the purpose of the prototype is to assist with\nevaluating a possible design model for all or part of an application, by\ndeveloping a \u2018quick build\u2019 in advance of a more complete design and\nimplementation. The prototype can be used to assess such aspects as a\nuser interface or an algorithm, and may well be built using tools that\nproduce an implementation that is quite di\ufb00erent to the form intended.\nSuch a prototype is de\ufb01nitely intended as a throw-away item.\n3. Exploratory. Such a prototype is usually used to help clarify user re-\nquirements and perhaps to investigate how using the application might\nchange the way that users work within an organisation. In this role, it\ncan act as a form of partial feasibility study, focusing on the issues of\ninterest alone, and again, such a prototype is really a throw-away item.\nWhatever the purpose, a prototype can provide a useful intermediate step\ntowards addressing an ISP. The experimental and exploratory forms can be\nviewed as simplifying the elements of the problem (whereas a plan-driven ap-\nproach seeks to simplify the process), while the evolutionary approach struc-\ntures the way that the interactions in Figure 1.1 are managed. This is illus-\ntrated in Figure 14.1.\nThe idea of prototyping, and of evolutionary prototyping in particular,\n\ufb01ts in well with the concept of an emergent organisation. An emergent organ-\nisation is one that is \u201cin a state of continual process change, never arriving,\nalways in transition\u201d (Truex, Baskerville & Klein 1999). Where the software\nit uses needs to re\ufb02ect this characteristic, then prototyping can help explore\nwhat the needs of an application are as well as how it can be created.\nThat all said, the adoption of a prototyping approach does not o\ufb00er any\nparticular guidance about how the development of a design should occur.\nWhat it does imply, is that the design process does not take place in a single\nstep, but is organised on an incremental basis.\nFrom a designer\u2019s perspective, prototyping does not necessarily involve\ngenerating code. This is particularly the case for human-computer interac-\ntion (HCI) elements of a system (sometimes referred to as interaction design)\n(Sharp, Preece & Rogers 2019), where mock-ups of screens might be employed\nto help gauge responses from potential users.\nWithin design more generally, a non-code form of prototyping that is often\nuseful is the story-board. Story-boards can be used for eliciting requirements\n", "page": 256, "type": "text", "section": "Page 256"}
{"text": "240\nSoftware Design: Creating Solutions for Ill-Structured Problems\nproblem\nspace\npart\nproblem 1\npart\nproblem 2\npart\nproblem n\npart\nsolution 1\npart\nsolution 2\npart\nsolution n\nrevised\nproblem\nspace\npart\nproblem 1\npart\nproblem 2\npart\nproblem n\npart\nsolution 1\npart\nsolution 2\npart\nsolution n\nsolution\nspace\nprototype\nenhanced understanding\nfrom the prototype\nFIGURE 14.1: Use of an evolutionary prototype\nas well as for design, and provide a pictorial overview of a process. Story-\nboards can provide useful support for design reviews. These, conducted both\nwith other team members as well as with end-users and customers, can form a\nvaluable element of incremental design, as they can convey system behaviour\nwithout needing to go into technical detail. (And with the bene\ufb01t that a story-\nboard does not easily become an evolutionary prototype!). The story-board\ncan also be used in conjunction with the idea of the use case discussed in the\ncontext of the Uni\ufb01ed Process, both for developing and also for recording the\ndetails of a use case. Figure 14.2 shows a simple example of the use of a story-\nboard when developing the CCC software. In practice this would probably\nbe sketched if it is being used within a design team, although it may well be\nturned into a more elegant presentation for a customer.\nExperts prototype concepts. PvdH #55\n", "page": 257, "type": "text", "section": "Page 257"}
{"text": "Incremental Design in Agile Software Development\n241\n(a)\n(b)\n(c)\n(d)\nCCC member requests\ndetails of where the\nnearest (3) available\ncars are located.\nx\nx\nx\nResource management\nobject checks through\nlist of available cars and\nidentifies nearest three.\nResource\nManagement\ncar\ncar\ncar\nUser is presented with details\nof the locations of the nearest \nthree available cars.\nAccess code\ncar\nMember chooses a car, access \ncode is generated and given a\ntime-stamp, then it is sent to user \nand chosen car.\nFIGURE 14.2: An example of a simple story-board\n14.2\nIncremental development and the spiral model\nIncremental development can be viewed as o\ufb00ering a way of making the\ndesign process more \ufb02exible than plan-driven approaches, which achieve their\ngoals chie\ufb02y by turning the process into a highly structured procedure.\nIndeed, while plan-driven forms seek to \u2018organise\u2019 the design of solutions\nto ill-structured problems so that the process is closer to the sort of process\nused for well-structured problems, the incremental forms described in the rest\nof this chapter take a rather di\ufb00erent approach. Incremental strategies use a\nrepeated application of the form modelled in Figure 14.1. This accepts that we\nare seeking a solution to an ISP, but breaks up the process of developing the\nsolution into \u2018chunks\u2019, with each chunk being completed in a separate phase. As\nwith plan-driven forms, the goal of doing so is to simplify the design process,\nbut now the design process is essentially opportunistic and needs to address\na number of viewpoints in each increment.\nThe way that the \u2018chunking\u2019 is organised di\ufb00ers for each of the approaches\nthat we examine in the following sections. In DSDM the stages are organised\naround development activities, whereas for XP they are organised (di\ufb00erently)\naround the functionality of the application. The main issue is that by progress-\n", "page": 258, "type": "text", "section": "Page 258"}
{"text": "242\nSoftware Design: Creating Solutions for Ill-Structured Problems\ning in this way, the development team can periodically re-assess the ISP being\ntackled based on understanding gained in the preceding stages.\nFrom a design perspective, this represents something of the inevitable\ntrade-o\ufb00. Plan-driven forms tend to become overly complex when used with\nother than relatively simple architectural styles. Equally, many key decisions\nare made early in the development process, when the nature of the intended\napplication is still incompletely understood. However, plan-driven strategies\ndo provide a (relatively clear) path to the end goals. Incremental design pro-\nvides greater \ufb02exibility, but some decisions still need to be made early on (such\nas architectural form) and it may be harder to keep a sense of direction towards\na solution. This may be more challenging for larger projects (Boehm 2002, El-\nbanna & Sarker 2016), and there are questions of the skills needed for design-\ning in such a context and the e\ufb00ectiveness of agile development for knowledge\ntransfer about design skills (Jacobson, Spence & Seidewitz 2016).\nOne of the earliest attempts at breaking away from the perceived rigidity\nof plan-driven forms was the spiral model devised by Barry Boehm (1988).\nIn many ways, Boehm\u2019s spiral model was quite \u2018visionary\u2019, and it explicitly\nassumed the use of prototyping in an incremental process by which the design\nmodel was developed through a set of incremental stages. At each stage in\ndevelopment the next set of developments for the design model were planned\nin terms of:\n\u2022 the objectives for that particular stage;\n\u2022 the options and constraints that were to be explored;\n\u2022 evaluation of the risks involved in choosing between the options;\n\u2022 formulating a plan for the stage, which might involve developing a new\nprototype or involve other activities, according to the conclusions of the\nrisk analysis.\nWithin the context of a prototyping strategy, perhaps the most important\nelement to highlight from this list of actions is that of risk assessment, since\nthis links back to the very reason why such an approach might be needed.\nIn particular, given that one of the risks implicit in the use of prototyping\nis that the sense of \u2018direction\u2019 might become lost, the spiral model o\ufb00ered a\nmechanism for monitoring and controlling the development process.\nIncremental design is an approach that is less commonly encountered in\nother forms of engineering design. As a technique it is unlikely to \ufb01nd much\nfavour with civil engineers (\u201cafter we have built the central span of the bridge,\nwe\u2019ll work out how to construct the approaches\u201d), any more than with other\nengineering disciplines such as chemical or electrical engineering. This is not\nto argue that it is not a valid engineering approach, given su\ufb03cient planning\nand control, but rather that it is an approach that only makes sense when used\nwith a medium such as software where there is no manufacturing stage, and\nwithin the type of dynamically changing context often met in software-based\n", "page": 259, "type": "text", "section": "Page 259"}
{"text": "Incremental Design in Agile Software Development\n243\nbusiness use and in the emergent organisations that are made possible through\nthe use of software applications. It is also widely employed for development\nof open source software (OSS) as discussed in Chapter 18.\nExperts design throughout the creation of software. PvdH #22\nAgree basic\nrequirements\nImplement \nand test\nfinal system\nDevelop\narchitectural\ndesign\nPrototype,\ntest and\nevaluate\nPartial detailed\ndesign\nFIGURE 14.3: Pro\ufb01le of an incremental development process\nOne issue that can easily become blurred where incremental development\nis employed is the distinction between design and implementation. An incre-\nmental approach is likely to involve some interleaving of design stages with\nimplementation and evaluation. However, the design stages are likely to be\nmore concerned with \u2018detailed design\u2019 issues, occurring within a context es-\ntablished by a set of architectural design decisions made early on. Figure 14.3\nillustrates this point schematically, and in the next section we will see that\nour example of DSDM broadly conforms to this form of structure.\nValuable and in\ufb02uential though the spiral model was, in itself it didn\u2019t\no\ufb00er any very strong procedural or declarative guidance about how develop-\nment, and design in particular, should be organised as a set of \u2018chunks\u2019. This\nwas addressed in the later development of thinking about rapid application\ndevelopment or RAD.\n14.3\nRAD: the DSDM method\nRAD, or rapid application development can be considered as describing\na process of development that is essentially a structured form of incremental\ndevelopment. RAD has attractions for developing commercial applications and\n", "page": 260, "type": "text", "section": "Page 260"}
{"text": "244\nSoftware Design: Creating Solutions for Ill-Structured Problems\nwas widely popularised by the many works from James Martin. Approaches\nbased upon RAD can be viewed as \ufb01tting in between plan-driven methods\nand more lightweight agile forms.\nOur example of a RAD development process is the dynamic systems\ndevelopment method, generally known as DSDM. This originated in 1994,\nmanaged by the \u2018not-for-pro\ufb01t\u2019 DSDM Consortium (the associated trade-\nmark being formed by reversing the second \u2018D\u2019 character). In 2016 this be-\ncame the \u2018Agile Business Consortium\u2019, a change which highlights the direc-\ntion of travel that DSDM represented in terms of the evolution of RAD.\nRapid Application De-\nvelopment\nThe main textbook available that addresses DSDM\nis (Stapleton 2002), although the consortium has\nproduced quite extensive documentation in the form\nof on-line material. This documentation also links\nDSDM to other approaches such as the UP and ag-\nile development practices (as we might expect).\nStrictly speaking, DSDM is almost entirely con-\ncerned with managing and controlling the RAD pro-\ncess and makes no assumptions about design strat-\negy, architecture or any of the other factors that\ncharacterised plan-driven methods. This is not to\nsay that these issues are ignored in the DSDM pro-\ncess, simply that DSDM practices make no assump-\ntions about their particular form. (Indeed, it is pos-\nsible to employ DSDM for non-software development\nprojects, although obviously we will not pursue that aspect here!)\nThroughout the DSDM process, there are two distinctive elements that\nemerge very strongly:\n\u2022 the roles, responsibilities and activities that people perform;\n\u2022 the e\ufb00ects of business needs upon design decisions.\nSince we can regard DSDM as representing a transition stage in thinking\nabout software development practice (rather than providing speci\ufb01c thinking\nabout design itself), we will examine its features fairly brie\ufb02y, although again,\nwe will put most of our emphasis upon those aspects that can be considered as\nbeing related to \u2018analysis and design\u2019. We will \ufb01rst look at the principles that\nunderpin DSDM, since these provide the rationale for its particular structure\nand practices. After that we will examine how the principles are interpreted\nwithin the DSDM development cycle.\n14.3.1\nThe DSDM principles\nThere are nine principles, which in many ways look forward to the Agile\nManifesto that we describe in the next section.\n", "page": 261, "type": "text", "section": "Page 261"}
{"text": "Incremental Design in Agile Software Development\n245\n1. Active user involvement is imperative. DSDM identi\ufb01es a number of\nsuch roles such as the ambassador, who \u201cguides the developers in their\nactivities to ensure that the solution being developed will accurately\nmeet the needs of the business\u201d; and the advisor, who is tasked with\nrepresenting a particular user view.\n2. DSDM teams must be empowered to make decisions. This is a corollary\nto the \ufb01rst principle, since active user involvement is incompatible with\nthe need to obtain decisions from higher-level project management.\n3. Focus is on frequent delivery of products. DSDM favours managing in-\ncrements on the basis of the \u2018product\u2019 (including documentation) over\nincrements of the \u2018activities\u2019 themselves, with an emphasis upon allo-\ncating \ufb01xed periods of time for performing various activities.\n4. Fitness for business purpose is the essential criterion for acceptance of\ndeliverables. DSDM takes the view that delivery within the required time\nperiod is of paramount importance, and that once the functionality has\nbeen established, the structure of the software can be re-engineered as\nnecessary. (This can be seen as down-playing the role of design.)\n5. Iterative and incremental development is necessary to converge on an\naccurate business solution. The key issue here is that iteration needs\nto be part of the organisation\u2019s procurement strategy, with the aim of\nachieving continuous improvement in the software through its use.\n6. All changes during development are reversible. DSDM accepts that the\npossible need to backtrack to an earlier state (of the design model) is in-\nherent in incremental design. Hence con\ufb01guration control is an essential\nand all-pervasive element of the development context.\n7. Requirements are baselined at a high level. Unlike plan-driven forms,\nDSDM is mainly concerned with freezing requirements at a high level\n(which in turn relates to the need to choose an architecture), and allow-\ning more detailed aspects to evolve as necessary.\n8. Testing is integrated throughout the life-cycle. This is a major departure\nfrom plan-driven thinking, which tends to consider testing as a post-\nimplementation element, but again looks forward to ideas about agile\ndevelopment.\n9. A collaborative and co-operative approach between all stakeholders is\nessential. Involving the stakeholders in the development process implies\nthe need for \u2018lightweight\u2019 change control procedures, allowing for short-\nterm redirection of a project through consensus.\nA distinctive feature of the philosophy, and one that strongly in\ufb02uences\nthe process, is that of time. In a plan-driven context, the functionality that an\n", "page": 262, "type": "text", "section": "Page 262"}
{"text": "246\nSoftware Design: Creating Solutions for Ill-Structured Problems\nTime\nFunctionality\nResources\na) DSDM: fix time &\nresources, vary the\nfunctionality delivered\nb) Plan-driven: fix the\nfunctionality, & vary the\ntime and resources.\nFIGURE 14.4: Varying the design constraints (time, functionality and re-\nsources)\napplication is expected to provide, embodied in the requirements speci\ufb01cation,\nis \ufb01xed, with the time and resources needed to achieve this being varied as\nnecessary. But in the DSDM context this is inverted, time and resources are\nconsidered as \ufb01xed during a cycle, and the deliverable functionality is allowed\nto change, as illustrated schematically in Figure 14.4.\nObviously this philosophy is one that rather constrains the scope for using\nDSDM. No-one would advocate its use for developing avionics software (\u201cwe\ndidn\u2019t have time to complete the module that allows the landing gear to be\nlowered, but go ahead with the test \ufb02ight anyway\u201d). On the other hand, where\nbeing \ufb01rst to market is important, some limitations in an application might\nbe more acceptable if agreed by developer and end-user.\nAn important concept in DSDM is that of timeboxing. This is a process\n\u201cby which de\ufb01ned objectives are reached at a pre-determined and immovable\ndate through continuous prioritisation and \ufb02exing of requirements using the\nMoSCoW rules\u201d (Stapleton 1999). (Note that timeboxing is a process, rather\nthan some form of object, although the DSDM literature does then refer to\nindividual \u2018timeboxes\u2019\u2014and it is di\ufb03cult not to do so!) A timebox is normally\nexpected to last between two and four weeks. The MoSCoW rules used to\nprioritise requirements are summarised in Table 14.1. In essence the role of\ntimeboxing is to ensure that a project team has a clear focus and deadline at\nany point in time and to manage the \ufb01xed-time aspect by providing guidance\non the acceptable degree of functionality that an increment should have. In\n", "page": 263, "type": "text", "section": "Page 263"}
{"text": "Incremental Design in Agile Software Development\n247\nplanning a timebox the recommendation is that about 60% of e\ufb00ort should be\ndirected towards implemented \u2018must have\u2019 requirements, with the remaining\n40% split between \u2018should\u2019 and \u2018could\u2019 haves. This means that if it proves\nimpossible to achieve all of the goals within a timebox, there should still\nbe enough resource and time to ensure that the \u2018must have\u2019 elements are\ndelivered.\nTABLE 14.1: The MoSCoW Rules for prioritisation\nRule\nInterpretation\nMust have\nThose requirements that are fundamental to the\nsystem, such that it will be inoperable if they are\nnot met.\nShould have\nImportant requirements that would be manda-\ntory if more time were available, but for which\nsome sort of work-around can be achieved in the\nshort term.\nCould have\nRequirements that can safely be left out of the\ncurrent deliverable, being desirable but not es-\nsential.\nWant\nto\nhave\nbut\nwon\u2019t have this time\nRequirements that are on the waiting list for the\nfuture.\nOf course, assigning requirements to categories can be quite a di\ufb03cult\nprocess, and this is where the emphasis that DSDM places upon a collaborative\napproach to development is important. Team members who insist that all of\ntheir requirements are clearly in the \u2018must have\u2019 category are unlikely to make\nuseful contributions to this process!\n14.3.2\nThe DSDM process\nThe DSDM process is generally described as being a framework made up\nfrom \ufb01ve phases, and provides little that can be considered as prescriptive.\nFigure 14.5 provides a simple model of this. In many ways this is an elaboration\nof the model shown in Figure 14.3 for incremental development, although the\nfeedback involved in iteration is rather more complex. The description here\nfocuses chie\ufb02y on the impact that this model has upon the design process.\nFeasibility study. This phase is meant to be kept short, and should deliver\na feasibility report, together with an outline plan for development that\nprovides more detail. One option is to develop a feasibility prototype that\ncan be viewed as largely exploratory (and of course, need not actually\ninvolve writing software if a form such as story-boarding is used). From\na design perspective this is likely to explore possible architectural forms,\nrather than provide anything more detailed.\n", "page": 264, "type": "text", "section": "Page 264"}
{"text": "248\nSoftware Design: Creating Solutions for Ill-Structured Problems\nFeasibility\nstudy\nImplementation\nBusiness\nstudy\nFunctional\nmodel\niteration\nDesign and\nbuild iteration\nAgree\nplan\nIdentify\nfunctional\nprototype\nCreate\nfunctional\nprototype\nReview\nprototype\nAgree\nplan\nIdentify\ndesign\nprototype\nCreate\ndesign\nprototype\nReview\ndesign\nprototype\nReview\nbusiness\nImplement\nTrain\nusers\nUser approval\n& guidelines\nFIGURE 14.5: The DSDM development process\nBusiness study. This again is intended to be of short duration and to be\nhighly collaborative. It leads to what we can consider as being the \ufb01rst\nreal design decisions, embodied in the system architecture de\ufb01nition.\nThis identi\ufb01es both the architectural style to be employed and also the\nmain elements of the system architecture.\nFunctional model iteration. This is really the element that concentrates\non black box modelling of what the application is to do within the given\nbusiness context. So this phase does emphasise modelling of business\nneeds, without going into detail about such non-functional aspects as\nsecurity and performance. The main outputs are models such as class\nmodels and data models and functional prototypes that are expected to\nbe more or less complete in terms of their user interface, along with\nsome basic degree of functionality.\nDesign and build iteration. This is the phase where the detailed decisions\nabout implementation are made. The main output produced is still clas-\nsi\ufb01ed as being a prototype although it may well incorporate the key\nfunctionality of the application. This phase produces a mix of white box\nmodels and actual code and incorporates a strong element of testing.\nImplementation. The emphasis here is less upon developing the software as\ngetting it into productive use, including collaboratively addressing any\nneeds for training material and documentation.\n", "page": 265, "type": "text", "section": "Page 265"}
{"text": "Incremental Design in Agile Software Development\n249\nSo, what are the distinctive features of DSDM, viewing it particularly as a\nexemplar of RAD practices? These include an emphasis upon management and\ncontrol (essential in any form of incremental development); strong emphasis\nupon user involvement throughout the process; \ufb01xing of delivery time and\nvarying of deliverable functionality (timeboxing); the non-prescriptive view of\napplication architectural style; and the extensive use of prototyping.\nAs an incremental process, DSDM organises the \u2018chunking\u2019 of the develop-\nment (and design) process around fairly classical lines of black box modelling\nfollowed by white box modelling. And like the agile approaches that we ex-\namine in the rest of this chapter, DSDM links its procedures closely into the\nbusiness processes related to an application. In contrast, for plan-driven forms,\nthe in\ufb02uence of the business aspect is largely con\ufb01ned to requirements elic-\nitation and system modelling, with later stages being much more concerned\nabout software structures.\n14.4\nThe agile manifesto\nObviously the trend towards more iterative and \ufb02exible approaches\nto development didn\u2019t end with RAD, and a number of other incre-\nmental development practices were emerging through the late nineties.\nAgile development\nIn 2001 this led an in\ufb02uential group of 17 method-\nologists to agree upon what has come to be termed\nthe Agile Manifesto. In essence, this states a set of\nvalues that they believe are embedded in \u2018agile soft-\nware development\u2019. The manifesto is shown in Figure\n14.6.\nIn many ways the manifesto was a culmination\nof various attempts to move to more \ufb02exible ways of\ndeveloping software, not the beginning of it. Indeed,\nas we noted earlier, Barry Boehm (2002) argued that\nneither agile nor plan-driven approaches have all of\nthe answers. Indeed, agile development still needs\nstructures if it is to avoid becoming a \u2018code and \ufb01x\u2019 approach and in the next\ntwo sections we examine two quite di\ufb00erent examples of agile forms (and many\nwould consider DSDM to be an agile development form too).\n", "page": 266, "type": "text", "section": "Page 266"}
{"text": "250\nSoftware Design: Creating Solutions for Ill-Structured Problems\nWe are uncovering better ways of developing software\nby doing it and helping others do it. Through this work\nwe have come to value:\nIndividuals and interactions over processes and tools\nWorking software over comprehensive documentation\nCustomer collaboration over contract negotiation\nResponding to change over following a plan\nThat is, while there is value in the items on the right, we\nvalue the items on the left more.\nFIGURE 14.6: The Agile Manifesto\n14.5\nExtreme programming (XP)\nExtreme programming, commonly abbreviated to XP, was devised by\nKent Beck, one of the leading agile methodologists. He described XP as \u201ca\nlight-weight methodology for small-to-medium-sized teams developing soft-\nware in the face of vague or rapidly changing requirements\u201d (Beck 2000).\nAnd his argument for including \u2018extreme\u2019 in the name was that \u201cXP takes\ncommonsense principles and practices to extreme levels\u201d.\nLike the other approaches in this chapter, it relies upon an evolutionary\nand incremental design process rather than a \ufb01xed set of development activi-\nties. Indeed, part of the \ufb02exibility of agile approaches is that they can adapt\nto the needs of the problem, allowing the development team to focus on the\nkey issues, whether these be architectural design, testing etc. And as Boehm\n(2002) has observed, agile methods such as XP do involve quite a lot of plan-\nning (and re-planning), although the emphasis for agile tends to lie in the\nplanning itself rather than the generation of documented plans.\nXP is quite well documented, perhaps in part because it has a stronger\n\u2018technical\u2019 element than many other agile methods that tend to put greater\nemphasis upon managing processes. One thing is certain though, it does not\nlend itself to being described using the same framework that was employed\nfor describing plan-driven methods (representation, process, heuristics)!\nXP is usually characterised as being based upon \ufb01ve values and twelve\npractices that are underpinned by the values. The values themselves are fairly\nhigh-level concepts: communication; feedback; simplicity; courage and respect.\n", "page": 267, "type": "text", "section": "Page 267"}
{"text": "Incremental Design in Agile Software Development\n251\nIndeed, just the names of these indicate the strong people-\ufb02avoured aspect\nof agile. We observed in Part I that the idea of software engineering as a\n\u2018social discipline\u2019 only emerged as the discipline grew in maturity. Indeed, it\ncan be argued that agile methods take a much more rounded view of software\nengineering and software development than plan-driven approaches because\nof this recognition that development is indeed a social process as well as a\ntechnical one.\nTo understand their role, it is probably best to look at the twelve practices,\nand how they are in\ufb02uenced by the values. Once again though, we focus at-\ntention mainly upon the ways that the practices in\ufb02uence the role of software\ndesign in XP.\n1. The planning game. Like other agile methods, XP is iterative, and at\nthe start of each iteration the team and the customer undertake a \u2018plan-\nning game\u2019, seeking to capture user stories on a set of \u2018story cards\u2019.\nThere are some obvious similarities to use cases of course.\nThe basic idea is that the customer provides a set of user stories that\nrepresent a piece of application functionality (so really, these are smaller\nthan a use case). Ideally a user story can be captured in a few sentences,\nalong with any non-functional implications, and can then form the basis\nfor resource estimation (people, time, money). Each story also forms the\nbasis for an associated test set (more about this later).\n2. Small releases. The XP philosophy is to produce frequent releases, with\neach forming a small advance on previous ones\u2014usually advancing by\nimplementing more user stories.\n3. Metaphor. This is an important design aspect, mapping user stories on\nto the classes and objects needed to achieve the required functionality.\n4. Simple design. The philosophy here is clear. A design should avoid un-\nnecessary \u2018bells & whistles\u2019, and when considering changing any design\nelement or creating new ones, the question to ask should be \u201cdoes the\ncustomer really need this feature?\u201d.\n5. Test-\ufb01rst programming. The (unit) tests should be written before writ-\ning the actual code and testing should be a continuous process.\n6. Refactoring. This is a re\ufb02ective element that involves restructuring the\ncode without changing its functionality. The aim is to simplify the code\nso that as the design evolves it is kept as simple as possible.\n7. Pair programming. All code is written by two programmers who work\nas a team at a single computer, discussing their work as they go.\n8. Continuous integration. Code is integrated into the evolving applica-\ntion as often as possible, and after passing unit tests.\n", "page": 268, "type": "text", "section": "Page 268"}
{"text": "252\nSoftware Design: Creating Solutions for Ill-Structured Problems\n9. Collective ownership. The code of the application is owned by all, and\nany member of the team may make changes to it when they feel it\nnecessary.\n10. On-site customer. The customer works with the team to answer ques-\ntions, perform acceptance tests, and monitor progress.\n11. 40-hour week. Iterations should be organised so that overtime is not\nneeded, on the basis that tired developers make mistakes.\n12. Open workspace. Developers share workspace and use shared coding\nstandards, following clearly-de\ufb01ned conventions for such aspects as iden-\nti\ufb01ers, layout etc.\nInteresting as these are (and there are few that would be likely to appear\nin a plan-driven method), as observed above, our main concern here is how\nthese in\ufb02uence the process of design. Indeed, one thing we might note is that\nthere are no particular assumptions in the practices about architectural style\nor the detailed form that the implementation will take.\nSo, based upon the values and practices described above, we can identify a\nnumber of characteristics that can be considered to form the design strategy of\nXP. As might be expected these are much more concerned with principles that\ndesign activities should follow, rather than the exact form that the activity\nshould take. Indeed, as one measure of the nature of \u2018agility\u2019, it is impractical\nto try to draw a process model for XP.\n\u2022 The KISS principle. The idea of \u2018keep it simple stupid\u2019 is to remind de-\nsigners to avoid over-complicating the design model. Implicitly of course,\ncomplicated structures create technical debt and make future changes\nmore di\ufb03cult. In an agile context, where those future changes are hap-\npening as part of the development process, this is particularly important.\nSo a simple design minimises the set of classes and methods, avoids du-\nplication of logic, and avoids unnecessary items\u2013while of course, meeting\nthe criterion of \u2018\ufb01tness for purpose\u2019.\n\u2022 Use CRC cards. We encountered the use of class-responsibility-\ncollaborator cards in the previous chapter when looking at the Uni\ufb01ed\nProcess. They are a valuable way of documenting a design, providing a\nplace to note design issues, and also helping to identify where an element\nis becoming overly complicated.\n\u2022 Use \u2018spike\u2019 solutions to reduce risk. A spike solution can be regarded as a\nform of exploratory prototype, and is used where the team need to decide\nhow to proceed with a particular element of the system that is proving to\nbe complex. By building a \u201cquick and narrow implementation\u201d (P\ufb02eeger\n& Atlee 2010) the team can obtain valuable feedback about the design\noptions.\n", "page": 269, "type": "text", "section": "Page 269"}
{"text": "Incremental Design in Agile Software Development\n253\n\u2022 Have a metaphor. This is really a description of the application that\nthe project aims to produce. In some ways it is similar to the idea of\nthe architectural pattern that we discuss in the next chapter, providing\na simple message that describes the overarching form of the application\nand maps its key features on to software structures.\n\u2022 Refactor. After adding a factor to the code, the team should look to\nsee if this can be simpli\ufb01ed. This complements the goal of keeping the\ndesign as simple as possible (the KISS principle).\nAn important point here is that while the XP literature tends to refer to\n\u2018code\u2019, there is absolutely no reason why the design should not be modelled\nwith diagrams when the team thinks this will help. The emphasis in XP upon\ndeveloping through a series of small increments does not present an obstacle\nto doing this either, provided we remember that sketches are probably the\nappropriate form to use.\nViewed as an incremental development process, XP \u2018chunks\u2019 the incre-\nments based on application functionality rather than on performing speci\ufb01c\ndevelopment activities (in principle, each iteration may involve combinations\nof all of the \u2018classical\u2019 activities).\n14.6\nAgile development: Scrum\nOur second example provides a rather di\ufb00erent example of agile thinking,\nwith much greater focus upon the processes rather than the technical issues\nof producing a design.\nThe basic ideas underpinning Scrum date from the mid-1990s. (The name\nisn\u2019t an acronym, and refers to the way that team members in a game of\nrugby huddle together when they are trying to advance.) Two key references\nare (Schwaber & Beedle 2002) and (Schwaber 2004)1. The original motivation\nappears to be the question that Ken Schwaber asked about software devel-\nopment: \u201cwhy do the de\ufb01ned processes of the CMM (Capability Maturity\nModel) not measurably deliver?\u201d. Without digressing too much from our fo-\ncus on design, we should note that the CMM is primarily concerned with\nassessing how dependable an organisation\u2019s development processes are\u2014with\na strong emphasis upon the idea of learning from previous projects. Schwaber\nrecognised that development processes were dealing with ISPs (whereas the\nCMM implicitly treats them as WSPs by assuming that such experiences are\ntransferable) and that developers needed to accept change rather than expect\npredictability.\n1A short de\ufb01nitive (downloadable) guide from the developers of Scrum is available at\nhttps://www.scrum.org/resources/scrum-guide\n", "page": 270, "type": "text", "section": "Page 270"}
{"text": "254\nSoftware Design: Creating Solutions for Ill-Structured Problems\nScrum is largely focused on the development process rather than on par-\nticular practices (in contrast to XP) and aims to provide:\n\u2022 an agile process to manage and control development;\n\u2022 a wrapper for existing engineering practices;\n\u2022 a team-based approach to incremental development;\n\u2022 control for the chaos of con\ufb02icting interests and needs.\nIt has some similarities with DSDM and in particular, it extends the idea of\ntime-boxing and uses it to control almost all of the activities.\nAs a result, the process is iterative and incremental, and is centred upon\ntime-boxed development cycles termed sprints. It begins with a vision of the\nsystem, a baseline plan of likely cost, and some time-frames, with the vi-\nsion possibly stated in market terms rather than technical (product) ones. An\nimportant concept in Scrum is the product backlog. This is a list of the func-\ntional and non-functional requirements that are needed to deliver the vision.\nThe product backlog is:\n\u2022 prioritised to ensure that high-value elements get a high priority;\n\u2022 divided into a set of proposed releases (with each release being generated\nfrom a sprint);\n\u2022 changed to re\ufb02ect the way that the business needs evolve.\nCreating and managing the backlog is a major task in Scrum.\nAs noted above, the time-box is a major tool for Scrum and time-boxes are\nused to organise most of the major activities of Scrum. We examine some key\nones here.\nRelease planning meeting. E\ufb00ectively, a release is a deliverable increment\nof an application. The planning meeting seeks to establish a plan and\ngoals for the development team and the rest of the organisation, which\nmay well be based upon user stories. It may involve some element of de-\nsign activity concerned with architectural issues and their consequences.\nThe resulting release plan establishes the goal of a release, identi\ufb01es pri-\norities, risks and the functionality intended for the release.\nSprints. Each sprint creates a new internal increment of the product, and\nwhen enough increments have been created and accumulated for the\nproduct to be of value, it is released. A sprint usually involves an iter-\nation that occurs within a time-box lasting one month (obviously this\ncan be varied, but if so, it is likely to be less than one month rather than\nmore). If necessary, to maintain the time-box the team may decide to\nreduce the functionality or scope of the product. Equally, if things are\ngoing well, they may be able to implement additional elements from the\nproduct backlog. The sprint is the core organisational element of Scrum.\n", "page": 271, "type": "text", "section": "Page 271"}
{"text": "Incremental Design in Agile Software Development\n255\nSprint planning meetings. Assuming that the sprint will last for one\nmonth, the time-box allocated for this meeting is eight hours. Part of\nthis time is spent on prioritising the product backlog, and this is then\nused to craft a sprint goal. Again, we might expect that this will involve\nsome thinking about design, but given time constraints this is unlikely to\nproduce a detailed design model in any form (although it might extend\nan existing one).\nSprint reviews. This has a time-box of four hours (assuming a one-month\nsprint). Among other things it provides input to the next sprint planning\nmeeting and (possibly) considers questions about design choices.\nSprint retrospectives. This is a meeting allocated a three-hour time-box\naimed at reviewing the process of the preceding sprint and looking for\npossible actionable improvements.\nThe daily scrum. A team meeting with a \ufb01fteen-minute time-box that re-\nviews what has been accomplished since the last meeting and plans for\nthe day\u2019s work.\nClearly, the management and control of time-boxing is a really important\nelement of Scrum, and much of the guidance available tends to be focused\nupon this and upon the di\ufb00erent roles that team members may have.\nScrum can be considered as being architecture-agnostic. The process is\ncompletely separated from the software architecture (in complete contrast to\nplan-driven forms) and should be usable with a wide range of architectural\nstyles. Indeed, it simply assumes that the team have the necessary experi-\nence to produce the necessary design ideas, implicitly by some opportunistic\nprocess. We say a little more about this in the next section.\nFinally, there is the question of how the incremental process is \u2018chunked\u2019.\nFor Scrum this is a combination of application functionality and time. Tech-\nnical factors have little or no in\ufb02uence on the way that sprints are organised.\n14.7\nRefactoring\nRefactoring is the process of modifying the internal structure of source\ncode with the aim of improving its organisation, while preserving the external\nbehaviour. There may be various reasons why the code needs to be improved,\nbut refactoring is something that should help reduce technical debt, aid with\nidentifying reusable elements and generally improve such aspects as readabil-\nity, coupling and cohesion.\nThe need for refactoring is apt to arise from the piecemeal manner in which\na design may evolve using agile practices such as XP and Scrum. It is also\n", "page": 272, "type": "text", "section": "Page 272"}
{"text": "256\nSoftware Design: Creating Solutions for Ill-Structured Problems\nimportant that refactoring does not introduce defects into the code, and this\nis where the emphasis upon testing that is often found in agile practices is\nimportant. The code to be refactored should have passed all of the necessary\ntests before it is refactored, and should pass them again afterwards. (There\nis of course no reason in principle why refactoring should not be undertaken\nwith designs produced from plan-driven methods, but these tend not to place\nsuch emphasis upon the early deployment of unit testing regimes.)\nIn the classic work on refactoring, Fowler (1999), the author observes that\nthis is the opposite of what we conventionally expect to do. Normal practice\nis to produce a design model and then turn this into code, but with refac-\ntoring, the aim is to take bad design or coding, and rework it to produce\na good design. So now, rather than developing our understanding through\nentwined evolution of requirements and design, we are looking at re\ufb01ning a\ndesign through entwined design and code.\nRefactoring is really an essential adjunct to the use of agile strategies.\nDuring agile development, the design model evolves slowly (and opportunisti-\ncally) through the lifetime of the project, rather than being developed before\nimplementation begins. And if it is to evolve successfully, the design elements\nneed to be structured in such a way that they too can evolve and be changed.\nOn the positive side, refactoring does also provide the opportunity to make\ngood use of relationships such as inheritance and mechanisms such as polymor-\nphism. We observed in the previous chapter that these presented challenges\nfor plan-driven object-oriented methods, and we will see in the next chapter\nthat design patterns tend to make limited use of these forms. And of course,\nthese are very code-oriented mechanisms, and ones that are not easily incor-\nporated into design models. Using a more re\ufb02ective approach by refactoring\na design may therefore o\ufb00er a way to make good use of them.\nSo, what sort of activities does refactoring involve? Here we very brie\ufb02y\nlook at what is involved in a few of these. For more details about these and\nother forms, see Fowler (1999).\nExtract method. This involves decomposing long and complex methods by\nidentifying blocks of code within them that can be used to form the\nbasis of an independent method, which ideally, might then be reusable.\nMove method. This is where a method is encapsulated as part of an object\nbut it would be more appropriate for it to be part of another object,\nperhaps because its main task involves modifying the variables of this\nsecond object.\nReplace array with object. This typically occurs where the elements of\nan array may have di\ufb00erent roles and purposes (which is rather con-\ntradictory to the idea of how we use an array, but is how we may end\nup using one). Essentially what we create is a data object with a set\nof methods for manipulating the di\ufb00erent elements (rather like the \u2018car\nobject\u2019 proposed for the CCC).\n", "page": 273, "type": "text", "section": "Page 273"}
{"text": "Incremental Design in Agile Software Development\n257\nRefactoring may be performed for other reasons of course, with performance\nbeing one example of a possible motivation. Identifying candidate classes for\nreorganisation may also be based upon the use of code metrics, and upon\nconsideration of such issues as code smells, a topic that we address in the next\nchapter.\nOf course, refactoring also requires time and e\ufb00ort, which may be di\ufb03cult\nto spare in a project, particularly as refactoring is something that we perform\nwith code that is working correctly. Here again, we encounter the trade-o\ufb00\nbetween time spent on performing restructuring in order to make future de-\nvelopment activities easier, and the need for a team to deliver code. In a survey\nby (Tempero, Gorschek & Angelis 2017) examining what might impede devel-\nopers from refactoring, the authors observe that \u201cthe decision to refactor is\nultimately a business decision\u201d, reinforcing the view that refactoring is really\nnot a design issue alone.\nSo, from the perspective of the software designer, refactoring can be viewed\nas \u2018design adjustment\u2019 rather than \u2018design modi\ufb01cation\u2019. It involves reorganis-\ning the design elements, while retaining the functionality and behaviour of the\ndesign. So it can be regarded as purely a\ufb00ecting the design from the construc-\ntional viewpoint with the goal of improving largely non-functional aspects of\nthe design model.\n14.8\nEmpirical knowledge about design in agile develop-\nment\nThis chapter (and the previous one) cover some quite di\ufb00erent forms of\ndevelopment life-cycle and there is an interesting review and summary of many\nof these in Ruparelia (2010) (an article that is described as a \u2018history column\u2019).\nWhile there is relatively little empirical knowledge for plan-driven forms,\nthe agile concept emerged at more or less the same time that empirical studies\nwere becoming \ufb01rmly established in software engineering. As a result, there is\nwhat might sometimes seem to be an endless stream of evaluation frameworks\nfor comparing methods and of empirical studies related to various aspects of\ntheir use, adoption, adaptation, etc. This section is not a systematic review\nof knowledge about agile development (Kitchenham et al. 2015); rather it\nis a selection of a few studies that can be thought of as examples, or that\nparticularly address issues highlighted in the previous sections.\nSo, here we concentrate on evaluations that involve some element of as-\nsessment of how far a method provides guidance about design. Because they\nare better de\ufb01ned and quite widely used, this is also largely structured around\nthe evaluation of DSDM, XP and Scrum. Indeed, it is worth observing that\nwhile none of the approaches covered in this chapter provides much detailed\n", "page": 274, "type": "text", "section": "Page 274"}
{"text": "258\nSoftware Design: Creating Solutions for Ill-Structured Problems\nguidance about \u2018design as a verb\u2019, the amount of guidance provided about the\ndesign process can be considered to taper o\ufb00as we go through the methods,\nwith Scrum providing little or no guidance at all about how a design might\nbe developed.\n14.8.1\nEmpirical knowledge about DSDM\nThere appear to be few studies that focus upon DSDM although it does\nappear in a number of studies that compare di\ufb00erent agile methods in some\nway, such as that by Qumer & Henderson-Sellers (2008). In particular, there\nappears to have been little research addressing design explicitly, although a\nuseful survey to examine the e\ufb00ectiveness of user participation in DSDM was\nperformed by Barrow & Mayhew (2000). In this, the authors observed that\n\u201cThere was total agreement among respondents that consensus between par-\nticipant stakeholders was the basis of participation in the approach, and the\nlikelihood of such consensus being possible through co-operation and collabo-\nration between stakeholders during development was deemed to be very high\n(in fact there were no views to the contrary)\u201d.\n14.8.2\nEmpirical knowledge about agile methods\nSince many empirical studies compare and contrast between di\ufb00erent agile\nmethods, this section covers both XP and Scrum.\nAn early systematic review of studies of agile methods by Dyb\u00e5 & Dings\u00f8yr\n(2008) noted that at that point in time, most of the primary studies available\nwere of XP. While providing a useful review of the bene\ufb01ts and limitations of\nagile methods, the topics covered in the primary studies were largely focused\non themes related to social and organisational aspects, or on the adoption of\nagile practices.\nLater systematic reviews seem to have mainly focused on answering ques-\ntions about speci\ufb01c aspects of using agile methods, but these do not seem to\nhave investigated much about how design is managed (beyond looking at quite\nspeci\ufb01c forms such as user-centred design). The mapping study by Diebold &\nDahlem (2014) examined use of agile methods in industry, \ufb01nding that (like\nthe \ufb01ndings from the empirical study of SSADM discussed in the previous\nchapter) few agile methods are used in their entirety. Their study examined\n68 projects and analysed these for their use of 18 agile practices that were\nlargely derived from DSDM, XP and Scrum. They also looked at whether a\npractice was used \u2018out of the box\u2019 or adapted in some way. The six practices\nthat were used most widely were: time boxing; planning meeting; learning\nloop; evolving and hierarchical speci\ufb01cation; daily discussion; and product vi-\nsion. All were essentially \u2018management\u2019 aspects, which re\ufb02ects the emphasis\nof agile development.\nGiven a lack of speci\ufb01c studies of design, it is helpful to look at studies that\nhave investigated the risks implicit in using agile forms to see how far design\n", "page": 275, "type": "text", "section": "Page 275"}
{"text": "Incremental Design in Agile Software Development\n259\nissues arise there. An interesting study by Elbanna & Sarker (2016) surveyed\nthe adoption of agile practices in some 28 organisations spanning a wide range\nof business sectors. The risk associated with development and deployment that\nwas mentioned most often (23 organisations) was the accumulation of technical\ndebt. The authors observe that \u201cdebt can quickly accumulate owing to the\nneed to signi\ufb01cantly reduce development time, adhere to strict time boxing,\nand constantly deliver functional requirements for business use\u201d. As a result,\nsoftware becomes more complex and di\ufb03cult to maintain. Nearly as important\nwas the separation of development and IT teams within an organisation (21\norganisations). Not only are working practices for the two types of team very\ndi\ufb00erent, but the need for the project team\u2019s product to work in a speci\ufb01c\noperational environment forms an additional constraint, which may not be\nadequately recognised.\n14.8.3\nEmpirical knowledge about refactoring\nThe role and importance of refactoring has led to a number of empirical\nstudies. The study by Tempero et al. (2017) was mentioned in Section 14.7,\nand examined factors that might impede the process of refactoring.\nThe study by Chen, Xiao, Wang, Osterweil & Li (2016) provides the results\nfrom a survey of agile software developers with 105 respondents who had a\nwide range of roles. The results showed diverse views about the tasks involved\nand planning for refactoring, in\ufb02uenced by a respondent\u2019s roles and also the\ntype of applications being developed. In particular it was noted that while\nteams do careful planning for many aspects of agile development, \u201cplanning\nfor refactoring is not done nearly so carefully\u201d.\nKey take-home points about designing in an agile context\nIncremental and agile development practices are largely concerned with\nhow the process of software development is organised and hence provide rela-\ntively few lessons about design explicitly.\nEvolution of the design model. In contrast to plan-driven forms, incre-\nmental and agile development practices and methods do not try to sim-\nplify the process of \u2018solving\u2019 an ISP by organising this as though it were\na WSP. Instead, they sub-divide (\u2018chunk\u2019) the process into a series of\nsteps with the aim of simplifying and structuring the design process\nthrough the use of smaller and less complex goals for each increment.\nThe way in which the sub-division into incremental steps is organised\nforms a key characteristic of a particular method.\n", "page": 276, "type": "text", "section": "Page 276"}
{"text": "260\nSoftware Design: Creating Solutions for Ill-Structured Problems\n\u2022 DSDM organises the increments around fairly a classical develop-\nment model (black box model leading to white box model) and the\nuse of time-boxing within that.\n\u2022 XP organises the increments around fairly small additions to ap-\nplication functionality.\n\u2022 Scrum uses a mix of application functionality bounded by strict\ntime-boxing.\nNone of them is concerned with speci\ufb01c architectural styles and the\nassociated practices are largely concerned with team management.\nRefactoring. This involves reorganising the constructional aspects of the\ndesign model while retaining the behavioural and functional aspects. It\ncan be viewed as providing a mechanism that helps re\ufb01ne the e\ufb00ects of\npiece-meal evolution of the design model.\nTransfer of design knowledge.\nNone of the agile methods examined in\nthis chapter provided any speci\ufb01c mechanisms by which experience could\nbe transferred between experienced and less experienced designers. How-\never, this might be misleading, since agile forms place a high value upon\nmentoring, as well as the use of team meetings and the sharing of infor-\nmation.\n", "page": 277, "type": "text", "section": "Page 277"}
{"text": "Chapter 15\nDesigning with Patterns\n15.1\nPatterns as a mechanism for knowledge transfer ................\n262\n15.2\nArchitectural patterns ...........................................\n265\n15.2.1\nModel-view-controller (MVC) ...........................\n266\n15.2.2\nLayers ....................................................\n268\n15.2.3\nBroker\n...................................................\n270\n15.3\nDesign patterns ..................................................\n271\n15.3.1\nProxy (207) ..............................................\n275\n15.3.2\nObserver (293) ...........................................\n278\n15.3.3\nAbstract Factory(87) ....................................\n281\n15.4\nOther uses of patterns ...........................................\n283\n15.4.1\nSoftware service patterns ................................\n283\n15.4.2\nDesign anti-patterns and code smells ...................\n284\n15.5\nDesigning with patterns ..........................................\n286\n15.6\nEmpirical knowledge about designing with patterns ............\n288\nKey take-home points about designing with patterns ...........\n290\nSo far, in this third part of the book, we have been largely concerned with\ndesign approaches that involve following procedures (methods) to create ap-\nplications. In this chapter we consider a quite di\ufb00erent way of producing a\ndesign (or part of a design), by reusing abstract ideas about design structures\nthat have been found to work well by others. In a way, it makes use of forms\nthat could be considered as being more related to \u2018design as a noun\u2019 in order\nto support the activities of \u2018design as a verb\u2019!\nReuse of experience comes in various forms, and the idea of designing an\napplication by reusing some form of pattern has attracted a lot of attention\nsince the 1990s. Patterns o\ufb00er another way of codifying experience about\ndesign, and of transferring it to others\u2014although there are those who consider\nthat they provide a knowledge transfer mechanism that is more appropriate\nto experienced designers than beginners.\nThe pattern concept can be employed at di\ufb00erent levels of abstraction, and\nwith di\ufb00erent architectural styles, and although it is usually associated with\nobject-oriented development, it is by no means restricted to being used with\nsuch architectures. However, as with all mechanisms for transferring design\nknowledge, patterns provide no automatic guarantee of success, and do require\ncare in use.\n261\n", "page": 278, "type": "text", "section": "Page 278"}
{"text": "262\nSoftware Design: Creating Solutions for Ill-Structured Problems\n15.1\nPatterns as a mechanism for knowledge transfer\nThe concept of the design pattern is one that originated in another dis-\ncipline, and is rooted in the work of the architect Christopher Alexander\n(Alexander et al. 1977). He has described it in the following words.\n\u201cEach pattern describes a problem which occurs over and over\nagain in our environment, and then describes the core of the solu-\ntion to that problem, in such a way that you can use this solution\na million times over, without ever doing it the same way twice.\u201d\nAs a simple example, we could have a pattern for building a school. The\nproblem that it addresses is a generic one (to support the process of educating\nchildren and young adults), and the format of teachers and classes is more or\nless universal. However support for this might be realised in many di\ufb00erent,\nbut related, ways, with the di\ufb00erences between them re\ufb02ecting such issues as\neducational structures, age group, climate etc.\nWhile the \u2018school pattern\u2019 describes how something might be structured,\nthere are other familiar patterns that describe how things behave. Bus services\nprovide an example of a behavioural pattern with easily-recognised compo-\nnents (bus stations, stops, routes, timetables etc.). Catching a bus in an unfa-\nmiliar place might involve local variations, such as where to board, and when\nand how to pay, but the idea is a familiar one that usually requires little\nexplanation.\nBuild-a-pyramid pattern\nUsed in the context of design, a pattern\ncan provide a generic solution to some prob-\nlem which recurs in various forms, and which\nitself may be sub-part of a larger problem.\nA pattern can help a designer gain under-\nstanding of the characteristics of a particu-\nlar problem as well as providing a strategy\nfor addressing it. If it is well documented,\nit should also provide some ideas about the\ncontext where it might arise, as well as of any\npossible consequences (usually in the form of\ntechnical debt) that might be incurred when using that pattern.\nIn some ways, the idea of the pattern comes much closer to embodying the\ntraditional master/apprentice model for transfer of knowledge and expertise\nthan forms such as plan-driven design methods can hope to achieve. Although\ndesign methods also address ways of \ufb01nding solutions, patterns educate about\nproblems too, and the recognition of these is an important part of learning\nabout design, and one that is not always easy to achieve without some form of\nguidance. Patterns also provide scope for providing peer-to-peer exchange of\ndesign knowledge in manageable \u2018chunks\u2019, in a form that matches the observed\n", "page": 279, "type": "text", "section": "Page 279"}
{"text": "Designing with Patterns\n263\npractices of designers. One of the characteristics of expert designer behaviour\nthat was observed in the pioneering study by Adelson & Soloway (1985) was\nthe employment of \u2018labels for plans\u2019, whereby a designer would recognise and\n\u2018label\u2019 a sub-problem that they knew how to address, leaving them free to\nconcentrate on the less familiar aspects of a problem. Implicitly, they intended\nto reuse a \u2018pattern\u2019 that they had employed previously. In the context of design\npatterns, this labelling also has a role, by providing a useful vocabulary that\nallows designers to share ideas.\nArchitectural\npatterns\nDesign\npatterns\nIdioms\ndo {\n\u2026\nwhile {...}\nFIGURE 15.1: Patterns at di\ufb00erent levels of abstraction\nThe design pattern concept is not restricted in its use to \u2018detailed design\u2019\nactivities. At the programming level it is generally referred to as an idiom\n(Coplien 1997) and at an architectural level, the concept of the architectural\npattern is well established (Buschmann et al. 1996, Bass et al. 2013). While\nwe will not examine idioms in any detail in this chapter, we will examine\nthe forms and uses of both \u2018design\u2019 and \u2018architectural\u2019 patterns. Figure 15.1\nillustrates their roles.\nIt is important to appreciate that a pattern is not a reusable piece of soft-\nware. (That would be termed a framework (Fayad & Schmidt 1997).) Rather,\na pattern is a form of conceptual knowledge schema (D\u00e9tienne 2002), forming\na piece of generalised design knowledge that has been extrapolated from expe-\nrience. In particular, it describes how all or part of a design solution (model)\nis organised. In practice, patterns are:\n\u2022 more concerned with forms of coupling between elements that are based\non using composition rather than inheritance;\n", "page": 280, "type": "text", "section": "Page 280"}
{"text": "264\nSoftware Design: Creating Solutions for Ill-Structured Problems\n\u2022 represent a way of sharing the collective experiences of skilled designers\n(knowledge transfer);\n\u2022 are categorised in terms of some abstract (and recurring) design issue,\nproviding a description (pattern) for how this might be addressed.\nSo, in terms of the way that we address an ISP, how does the use of patterns\nin\ufb02uence the overall design process? Basically, the use of patterns can reduce\nthe opportunistic nature of the interactions that occur during design. Patterns\nimpose an element of structure upon the design model which might relate to\nbehavioural or constructional constraints, as illustrated in Figure 15.2. (We\nmay also recognise patterns in the problem space which will in\ufb02uence how we\napproach the design process, but this aspect is omitted from the diagram.)\nproblem\nspace\npart\nproblem 1\npart\nproblem 2\npart\nproblem n\npart\nsolution 1\npart\nsolution 2\npart\nsolution n\nsolution\nspace\npattern\nknowledge\nFIGURE 15.2: How patterns in\ufb02uence \u2018solving\u2019 an ISP\nTo end this introductory section, we look at a simple example from the\nCCC, not with the aim of providing speci\ufb01c solutions at this point, but rather\nwith the aim of recognising that building an application that manages its\nprocesses may well draw upon experience with other applications.\n", "page": 281, "type": "text", "section": "Page 281"}
{"text": "Designing with Patterns\n265\nPatterns in the CCC\nThe organisation and operation of the CCC has some characteristic\n\u2018patterns\u2019 that we can see in many other applications. Some examples\nare listed below.\n\u2022 The core business of the CCC involves managing resources that\nare used by members, who reserve and book cars. This is char-\nacteristic of very many other applications such as car rental; the\ntraditional \u2018lending library\u2019 providing short-term access to books,\nmusic etc.; theatre bookings; and \ufb01shing clubs. All of these man-\nage some form of \u2018resource\u2019 that is used by clients.\n\u2022 The billing process is common to very many applications, based\non membership details, car use and member \u2018credit\u2019.\n\u2022 The reservation process is likewise familiar in many ways. Book-\ning theatre seats, train journeys and the like, may involve select-\ning preferences from a \ufb01xed set of choices about time, seating\netc.\nSo, we may already have some ideas about how these aspects could be\nmanaged in the CCC application.\n15.2\nArchitectural patterns\nLooking at the examples from the CCC at the end of the preceding section,\none of the patterns that we could recognise in this is what could be termed the\n\u2018renting a resource\u2019 pattern. While this is concerned with the function of the\napplication (and patterns occur in requirements speci\ufb01cations too of course),\nit describes a high level pattern that is concerned with the overall behaviour\nof the application.\nWhen we turn to the role of design in meeting such a need, the most\nabstract form of pattern that we encounter is the architectural pattern that\nprovides the outline form of the overall system architecture\n(Buschmann\net al. 1996, Bass et al. 2013). In Chapter 6 we brie\ufb02y examined these from\nthe perspective of architecture, while here we consider their role as patterns.\nThe main concern of such a pattern is to describe the overall organisation of a\nsoftware application\u2014in particular, how the sub-systems should be structured\nand what the relationships between these should be. \u2018Organisation\u2019 in this\ncontext may relate both to static issues of con\ufb01guration, as well as to run-\ntime behaviour for the interactions between the elements.\n", "page": 282, "type": "text", "section": "Page 282"}
{"text": "266\nSoftware Design: Creating Solutions for Ill-Structured Problems\nAs with other patterns, the basic description of an architectural pattern\nneeds to address the following three factors.\n\u2022 The context within which some recurring situation occurs. Examples of\nthis might be the need to decouple elements of an application, or to\nincorporate the ability to dynamically update information sources while\na system is operating.\n\u2022 The problem, which is related to the issues that the context may present\nfor software development.\n\u2022 A solution that addresses the needs of the problem in a suitably general\nway. This may be described in terms of the type of element making up\nthe application, the forms of interaction between elements, the topology\nof the elements, and the likely constraints and trade-o\ufb00s involved.\nArchitectural patterns have some synergy with ideas about architectural\nstyle although they are not necessarily restricted to being realised using a par-\nticular style. In principle at least, any architectural style can be employed with\na pattern providing that the form of the elements can provide the necessary\nstructures and that their interactions can be organised to \ufb01t the pattern.\nPerhaps because of the large-scale perspective involved, the set of archi-\ntectural patterns is much smaller than that of design patterns discussed in\nthe next section. However, as with all patterns (and styles) they do provide\na useful vocabulary for the designer who is wishing to exchange ideas or ex-\nplore options. In the rest of this section we brie\ufb02y examine three examples of\narchitectural patterns. (A much more detailed and analytical explanation of\na useful catalogue of architectural patterns is provided in (Bass et al. 2013).)\n15.2.1\nModel-view-controller (MVC)\nThe model-view-controller pattern describes a widely-used form of organ-\nisation that is employed for many applications that involve some degree of\ninteraction with end-users. Here, the context is one of needing to decouple\nsome form of information store (the \u2018model\u2019) from the way that it is shown to\ndi\ufb00erent users and viewed on di\ufb00erent devices (the \u2018views\u2019). The problem is\nhow to achieve this decoupling while also keeping the application responsive\nto user actions. To achieve this, MVC divides such an application into three\ntypes of element.\n\u2022 The model incorporates the core functionality and associated data for\nthe application.\n\u2022 A view provides information about the model to the user, presented in a\nparticular way. There may well be multiple views, corresponding to the\nneeds of di\ufb00erent types of user, or to the need to present information in\ndi\ufb00erent ways. It also interprets and communicates user actions to the\ncontroller.\n", "page": 283, "type": "text", "section": "Page 283"}
{"text": "Designing with Patterns\n267\n\u2022 Controllers handle user input. Each view has an associated controller\nthat responds to any choices made through the use of relevant forms of\ninput (keyboard, mouse, touchscreen,. . . ).\nController\n(interacts with user,\nperforms commands)\nModel\n(stores the data\nIncluding rules)\nView\n(displays the model\nfor the user)\nActions\nPresentation\nDomain\nInput presentation\nchoices\nUser actions\nQuery model\nstate\nNotify of change\nof model state\nManipulates the\nmodel, invoking \nmethods in its API\nto change state\nFIGURE 15.3: The model-view-controller pattern\nFigure 15.3 shows this schematically (note that there are many forms of\nvisual description for MVC). Note that both views and controllers send re-\nquests to the model, but that the model does not send out any requests, and\nit only provides responses through the view. Requests sent by a controller do\nnot create a direct response, instead they cause the model to be modi\ufb01ed,\nand the corresponding view to be noti\ufb01ed that the state of the model has\nbeen modi\ufb01ed. The application may also directly change the model (with no\nuser interaction) of course, and again, when this occurs the views are noti\ufb01ed.\nThe view can then request details of the revised model (or part-model) and\ndisplay it to the user in response to their input (the mechanism for doing this\nis provided by the Observer design pattern described in the next section.\nThe important characteristic of MVC is the decoupling of the internal\nmodel from the associated interactions with the user (separation of concerns).\nWe can recognise this pattern as describing many familiar but di\ufb00erent, in-\nteractive applications. Word processors, spreadsheets, web browsers etc. all\n\ufb01t this model. Decoupling the \u2018knowledge store\u2019 from the way that it is pre-\nsented, as well as from the di\ufb00erent forms of interaction, makes it possible\nto implement the application so that it can be used on di\ufb00erent operating\nsystems or with a range of devices.\nFigure 15.4 shows a sketch of how MVC might be used with the CCC\napplication. This is really a rather \u2018behavioural\u2019 sketch, where the designer is\nthinking out how the MVC model will handle the situation where a customer\nmakes a booking. The booking results in a modi\ufb01cation to the record set for\n", "page": 284, "type": "text", "section": "Page 284"}
{"text": "268\nSoftware Design: Creating Solutions for Ill-Structured Problems\nFIGURE 15.4: An MVC interpretation of the CCC application\nthe cars (the chosen car is no longer available to other customers), and it has\nsome consequent e\ufb00ects upon the di\ufb00erent views (such as the symbol for that\ncar on the city map changing colour).\n15.2.2\nLayers\nThe Layers pattern addresses a context where di\ufb00erent elements of the soft-\nware need to be developed and to evolve separately, requiring that interaction\nbetween them should be kept to a minimum. This means that the resulting\nsoftware is likely to be portable and can readily be modi\ufb01ed to meet new\nneeds. Essentially, Layers represents a very strati\ufb01ed approach to addressing\nthe issue of \u2018separation of concerns\u2019. When using Layers, the solution adopted\nis to group those elements that provide a particular service into a \u2018layer\u2019, with\nthe layers being organised in a hierarchy, so that the layers providing higher\nlevels of abstraction depend on lower ones, but not vice-versa.\nWhile Layers may not be used as universally as MVC, it does provide the\nstructuring for some very important software applications, with networking\nand operating systems being key examples of where this pattern is particularly\nuseful. Figure 15.5 illustrates the use of Layers to implement the OSI model\nused in computer networking.\n", "page": 285, "type": "text", "section": "Page 285"}
{"text": "Designing with Patterns\n269\nApplication\nlayer\nPresentation\nlayer\nTransport\nlayer\nSession\nlayer\nNetwork\nlayer\nData Link\nlayer\nPhysical\nlayer\nProtocols for common activities\nStructures information and\nadds semantics\nDialog control and synchronisation\nBreaks messages into packages\nand ensures delivery\nSelects a route\nDetects and corrects error in\nbit sequences\nTransmits bits\nFIGURE 15.5: A layers example: open systems interconnection model\nThe OSI model is probably quite an extreme example in terms of the\nnumber of layers employed. At a minimum, there need only be two layers. For\nLayers to be used appropriately, it is necessary that:\n\u2022 any dependencies are unidirectional (each layer depends only upon the\nlayer \u2018below\u2019);\n\u2022 a layer will normally only use the layer immediately below it (exceptions\nare possible but are better avoided);\n\u2022 a layer should embody some particular role or functionality, and ide-\nally making modi\ufb01cations or adaptations to the application should only\na\ufb00ect one layer.\nImplicitly too, the use of Layers may impose a run-time overhead, since there\nmay be many method (sub-program) calls involved in communicating between\nthe upper layers and the bottom-most layer, which is where the required action\nis eventually performed.\n", "page": 286, "type": "text", "section": "Page 286"}
{"text": "270\nSoftware Design: Creating Solutions for Ill-Structured Problems\n15.2.3\nBroker\nIn everyday life, the role of a broker is to act as a \u2018trusted intermediary\u2019\nwho can provide some form of expertise to help with choosing a service that we\nneed. The idea of \u2018insurance broker\u2019 and \u2018mortgage broker\u2019 remain relevant,\neven in an era of internet shopping (and many web sites claim to o\ufb00er the\nservices of a broker). We turn to a broker so that we can draw upon their\nexpert domain knowledge to determine which provider is likely to be best\nsuited to our needs.\nThe same can occur in a software context, particularly in the context of\nservice-oriented architectures. In this context we have clients (which them-\nselves may be providing services to others) and servers and these need to be\nmatched so that clients obtain the most appropriate service for any request\n(Bennett, Layzell, Budgen, Brereton, Macaulay & Munro 2000).\nBroker\nServers\nClients\nFIGURE 15.6: A simple broker architecture\nWhen using a broker architecture for software, the client sends requests to\nthe broker, the broker seeks out and uses the most appropriate service, and\nthen returns the outcomes to the client. This involves a dynamic binding for\neach request (or set of requests), which is managed by the broker so that the\nclient may well not be aware of which server provided the necessary response.\nFigure 15.6 shows this schematically. The broker architecture is commonly\nassociated with platforms for distributed service provision such as .NET and\nEnterprise Java Beans (EJB). This is because the broker pattern is particularly\n", "page": 287, "type": "text", "section": "Page 287"}
{"text": "Designing with Patterns\n271\nuseful in a dynamic environment, where the set of service providers (which\nmay include \u2018information services\u2019) and their availability may be subject to\nregular change, as may well occur with distributed systems.\nUse of a broker does add a run-time overhead in exchange for this de-\ncoupling, and incorporating security needs can add further to this (Turner,\nBrereton & Budgen 2006). The broker itself needs to be secure (and hence\ntrustworthy) and also any requests and responses must be transmitted se-\ncurely. Equally, a broker does provide a robust run-time environment since\nthe broker is able to make substitutions for a server that has failed, or that\nmay have become available.\n15.3\nDesign patterns\nDesign patterns address smaller and more detailed pieces of an overall de-\nsign than architectural patterns and have been adopted particularly widely in\nthe object-oriented context. As we noted when looking at plan-driven ap-\nproaches to design, this form of \u2018design method\u2019 tends to become overly-\ncomplex when used with objects, and design patterns, rightly or wrongly,\nhave been seen as one way of overcoming the problem by reusing \u2018proven\u2019\nsolutions to speci\ufb01c aspects of an ISP.\nObjects o\ufb00er a useful form of design element that can form one of the\ncomponents of a pattern. As we noted in Chapter 10, an object:\n\u2022 possesses a state, which is encapsulated within the object and can be\ninspected and changed through its methods;\n\u2022 exhibits behaviour through its responses to external events;\n\u2022 possesses an identity, since more than one object may be created from\na class.\nObjects are also capable of using static and dynamic binding (valuable for\npatterns) and can be coupled to other objects using a number of di\ufb00erent\nmechanisms. One thing that we might note though, as already mentioned,\nis that design patterns tend to make use of aggregations of objects rather\nthan employing inheritance. Employing inheritance remains a design chal-\nlenge, much as it did for plan-driven design methods, and opportunities to\nemploy inheritance may still need to be identi\ufb01ed through techniques such as\nrefactoring.\nFor our purposes, the important features of an object are that it provides\nan abstraction of some aspect of the design model, that it incorporates en-\ncapsulation of state information, and that it provides externally accessible\nmethods.\n", "page": 288, "type": "text", "section": "Page 288"}
{"text": "272\nSoftware Design: Creating Solutions for Ill-Structured Problems\nWhile design patterns provide some \u2018part-solutions\u2019, a really major reason\nfor using these, and one that is quite di\ufb00erent from the purpose of architectural\npatterns, is that they are intended to be used to address those aspects of a\ndesign that are most likely to undergo change. Much of the rationale behind\ndi\ufb00erent patterns is to isolate such elements in the design model with the\ngoal of reducing the impact of future evolution. This is something that we will\nparticularly examine when we look at some examples of patterns. It also means\nthat patterns often seek to employ loose coupling to provide the necessary\n\ufb02exibility.\nA text that helped popularise the idea of the design pattern is the pioneer-\ning book from the \u2018Gang of Four\u2019 (often abbreviated to GoF in the patterns\nliterature):\nErich Gamma, Richard Helm, Ralph Johnson and John Vlissides\n(1995). Their book provides a catalogue of 23 design patterns and helped\nestablish ideas about pattern classi\ufb01cation and description. Valuable though\nthis is, it is not really a tutorial about patterns, and a text such as Head First\nDesign Patterns by Bates, Sierra, Freeman & Robson (2009) provides a much\neasier (if sometimes rather eccentric) way of learning about the design pattern\nconcept and about some major patterns.\nDesign patterns have attracted a strong and involved user community, and\na major resource providing various forms of knowledge about design patterns\nis provided by the web site at www. hillside.net. This on-line resource provides\ndetails of many patterns, as well as links to other books and tutorials.\nThe adoption of a pattern within the design of an application does repre-\nsent an important long-term decision (which of course, implies an element of\ntechnical debt). Where an application evolves through time, one of the risks\nis that the changes to the objects mean that a pattern may decay, or that\nits presence might even impede unforeseen forms of change. There isn\u2019t much\nthat can be done about the latter (or they wouldn\u2019t be unforeseen), but the\nissue of decay is one that designers need to consider when making changes.\nTwo useful concepts related to pattern decay are those of grime and rot,\nthat are used to describe the corruption of a pattern that can occur when\nchanges are made to the objects involved in the pattern (Izurieta & Bieman\n2007, Feitosa, Avgeriou, Ampatzoglou & Nakagawa 2017). Pattern grime is the\n\u201cdegradation of design pattern instance due to buildup of unrelated artifacts\nin pattern instances\u201d and in essence involves material being added to the\nclasses and objects of a pattern that are not directly related to the purpose\nof the pattern. Pattern rot, which is less common, is the \u201cdeterioration of the\nstructural or functional integrity\u201d of the elements making up a pattern. The\npresence of grime and rot may mean that a pattern cannot support changes\nto the application in the way that was originally envisaged when the decision\nwas made to adopt that pattern.\nPatterns can take a variety of forms, and the GoF classi\ufb01ed patterns along\ntwo \u2018axes\u2019, as illustrated in Figure 15.7, which were as follows.\n1. The purpose of the pattern. Its purpose describes what a pattern is used\nfor, and is usually described as being one of the following three types.\n", "page": 289, "type": "text", "section": "Page 289"}
{"text": "Designing with Patterns\n273\nCreational\nStructural\nBehavioural\nClass\nObject\nScope\nPurpose\nFIGURE 15.7: Pattern classi\ufb01cation scheme used by the \u2018Gang of Four\u2019\n\u2022 creational patterns are concerned with occasions where objects need\nto be created in order to achieve the purpose of the pattern;\n\u2022 structural patterns address the way in which the constituent classes\nor objects are composed;\n\u2022 behavioural patterns describe the ways that classes or objects inter-\nact, and how responsibilities for di\ufb00erent aspects of the pattern\u2019s\npurpose are allocated between them.\n2. The scope of the pattern. This describes whether the pattern is primarily\none that addresses the use of classes or the use of objects (where we can\nregard a class as being a form of \u2018template\u2019 from which one or more\ninstantiating objects are realised). Most patterns deal with objects, and\nso we concentrate on looking at examples of these.\nIn terms of the viewpoints model, creational and structural patterns are es-\nsentially ones for which the organisation of the pattern is associated with\nthe constructional viewpoint. And obviously, the organisation of behavioural\npatterns is associated with the behavioural viewpoint.\nWhile we use the framework shown in Figure 15.7 here, it is worth noting\nthat others have employed other ways of categorising patterns. Although in\nBuschmann et al. (1996) the main focus is on architectural patterns, there is\nalso some discussion of a number of design patterns. They categorise these\nusing a set of role-based headings (structural decomposition, organisation of\nwork, access control, management and communication).\nThe remaining question to address, before looking at some examples of\npatterns, is how to describe a pattern. The books by Gamma et al. (1995)\nand Buschmann et al. (1996) use slightly di\ufb00erent templates for this. The\nfollowing template is something of a merging of these (and others) to try and\n", "page": 290, "type": "text", "section": "Page 290"}
{"text": "274\nSoftware Design: Creating Solutions for Ill-Structured Problems\ncapture all of the issues that need to be documented, and one that we use in\nthe following subsections.\nName. This is used to identify a pattern and (ideally) to indicate the essence\nof what it does.\nAlso known as. Rather pragmatically most catalogues of patterns do recog-\nnise that they may be categorised using di\ufb00erent identi\ufb01ers in other\ncontexts.\nProblem. This is the design \u2018problem\u2019 that the pattern is intended to ad-\ndress.\nSolution. This outlines the way in which the pattern addresses the problem,\nand explains any design principles that underpin the solution.\nExample. Provides a real-world example of the problem and of the pattern-\nbased solution.\nApplicability. Describes the situation in which the problem might arise and\nwhere it may be appropriate to employ the pattern, possibly including\nhints for recognising such situations.\nStructure. Provides a detailed description of the organisation of the solution\nusually employing diagrammatic forms to model both the behavioural\nand the constructional viewpoints.\nImplementation. A set of guidelines for implementing the patterns, noting\nany possible pitfalls that might arise.\nKnown uses. A set of examples from existing systems.\nRelated Patterns. (Also known as See Also.) Patterns that address similar\nproblems or that complement this one in some way.\nConsequences. Design trade-o\ufb00s that might need to be made when employ-\ning the pattern, as well as any constraints its use might impose and\npossible forms of technical debt that it might incur.\nThe choice of patterns described in the following subsections is based upon\nthose GoF patterns that were identi\ufb01ed as being most useful in the survey of\npattern experts described by Zhang & Budgen (2013). (This survey is dis-\ncussed more fully in the section on empirical evidence.) And as a \ufb01nal com-\nment, when discussing GoF patterns it is common practice to identify the\npage number where the description of the pattern begins, and this practice\nhas been followed here.\n", "page": 291, "type": "text", "section": "Page 291"}
{"text": "Designing with Patterns\n275\n15.3.1\nProxy (207)\nThe role of a proxy can be undertaken\nin various ways as part of everyday life,\nwhen someone acts \u2018on behalf of\u2019 another\nperson for some purpose. A common ex-\nample is in voting, where someone un-\nable to go and take part in a ballot will\nappoint another person to act as their\nproxy and cast their vote for them. This\npattern employs the same concept, and\ninvolves one object acting on behalf of another object.\nThe GoF classify this pattern as being Object Structural whereas\nBuschmann et al. describe it as being Access Control. Using the template\noutlined above this is described as follows.\nName. Proxy\nAlso known as. Surrogate\nProblem. Proxy addresses the problem where direct provision of access to\nan actual object requires to be moderated in some way. This may be\nbecause access represents a signi\ufb01cant overhead of some form (time,\nspace) or because di\ufb00erent types of client may require or be entitled to\ndi\ufb00erent levels of access.\nSolution. This is to provide a representative of the object and let the client\nobject communicate with this proxy rather than with the actual object.\nThe proxy provides the same interface as the actual object and ensures\ncorrect access to it, while possibly performing additional tasks such as\nenforcing access protection rules.\nExample. The GoF provides the example of an object representing a com-\nplex image when used in a word processor. Rather than incurring the\noverhead of loading a (potentially) large graphical object it may be pos-\nsible to employ a much simpler proxy that ensures that key properties\n(such as position and boundaries) are correctly represented in the screen\nimage. With more widespread access to electronic data sources, a more\ncommon example today is probably the protection proxy form, in which\nthe proxy is used to control the level of access that users may be per-\nmitted to have to an object or to information. For example, in the case\nof access to Electronic Health Records (EHR), a doctor is likely to have\nfuller access than (say) a nurse, and an administrator might have quite\nlimited access that is restricted solely to demographic information.\nApplicability. Proxy can also be employed to control access to relatively\ncomplex objects, which may be in a di\ufb00erent space (remote proxy);\nwith minimising overheads, as in the case of the word processor and\n", "page": 292, "type": "text", "section": "Page 292"}
{"text": "276\nSoftware Design: Creating Solutions for Ill-Structured Problems\nimage (virtual proxy); and controlling di\ufb00erent access rights (protection\nproxy).\nStructure. Figure 15.8 illustrates the idea of proxy using a class diagram.\nNormally, requests from the client will be serviced by the methods of\nthe proxy, relaying these on to the original object only when necessary.\nFigure 15.9 uses a sequence diagram to illustrate the operation of virtual\nproxy (or alternatively this could be viewed as an example of protection\nproxy, with the \ufb01rst request being refused for lack of access permission).\nClient\nProxy object\nservice_1()\nservice_2()\nReal object\nservice_1()\nservice_2()\nFIGURE 15.8: Class diagram for the proxy design pattern\nImplementation. Since this is not relevant to the theme of the book, we\nomit this element.\nKnown uses. Both the GoF and Buschmann et al. provide examples, with\nthe latter being more extensive and varied and also relating more\nstrongly to internet-based forms of implementation, where this pattern\nis quite widely employed.\nRelated patterns. The Adapter (139) and Decorator (175) patterns are also\nconcerned with issues related to interfaces.\nConsequences. Obviously, the use of proxy creates an overhead by adding a\nlevel of indirection when accessing potentially quite important objects.\nAs an initial example of a design pattern, proxy illustrates a number of\nthe points made above about patterns in general. It is compositional in form,\naddressing what is very much a sub-problem for any design, relatively simple\nin its structure, and provides quite loose coupling that may help with future\nchanges. It is also a pattern where ideas from \u2018conventional\u2019 coding and the in-\nternet in its various forms coincide, showing how the concept behind a pattern\ncan apply across quite a wide range of roles and forms.\n", "page": 293, "type": "text", "section": "Page 293"}
{"text": "Designing with Patterns\n277\nClient\nReal\nobject\nProxy\nobject\nClient requests service_1\nProxy responds directly\nto the request\nClient requests service_2\nservice_1()\nservice_2()\nservice_2()\nProxy relays request to\nreal object to service\nthis request\nFIGURE 15.9: Sequence diagram for the proxy design pattern\nThe proxy pattern in the CCC\nAn obvious role for the proxy pattern within the CCC is to provide a\nprotection proxy role for access to car objects. There are a number of\nroles in the overall CCC organisation that need access to car objects,\nbut for di\ufb00erent purposes. Customers need access for bookings, the\nmaintenance team need access to monitor the state of a car and to be\nable to withdraw it from use if necessary, the billing system may need\nfurther access to details of journeys and so on.\nWhile it would be possible to build this into the car object itself, it\nwould then mean that the car object would require knowledge about\nsuch roles, which in themselves, have no direct relevance to its function.\nSo, following the principle of separation of concerns, it is better to use\na proxy as the means of embodying the knowledge about who may\naccess what. It also aids future evolution of the application, which\nmight create new roles, or roles that are specialisations of existing\nroles. Such developments would then only a\ufb00ect the proxy object.\n", "page": 294, "type": "text", "section": "Page 294"}
{"text": "278\nSoftware Design: Creating Solutions for Ill-Structured Problems\n15.3.2\nObserver (293)\nObserver is a well-known and widely-used pat-\ntern and is categorised as being object behavioural\nby the GoF. It embodies the concept of a publish-\nsubscribe relationship between the design elements.\nThe pattern as described by the GoF is fairly ba-\nsic, omitting various \u2018housekeeping\u2019 issues, and the\ndescription provided here likewise concentrates on\nthe core model, while indicating where additional\naspects need to be considered for implementation.\nName. Observer\nAlso known as. Dependents, Publish-Subscribe\nProblem. A common side-e\ufb00ect of organising a software system as a set of\nco-operating objects is the need to maintain consistency between re-\nlated objects, while avoiding overly-tight coupling that may constrain\nperformance as well as reduce the scope for reuse.\nSolution. This involves creating a \u2018publish-subscribe\u2019 relationship between\nthe subject and the observers. Whenever the subject undergoes a change\nof state it noti\ufb01es the observers that this has occurred, and they can\nthen query the subject in order to synchronise with it and obtain any\nupdated values.\nExample. A simple example is that of a spreadsheet. When the data in a\ncell or group of cells is changed, any graphs, pie-charts or the like that\nare using that data will also need to be redrawn. Here the spreadsheet\ncell is the subject, and the objects that are responsible for drawing the\ncharts and graphs are the observers.\nApplicability. This form of relationship occurs widely wherever objects are\nworking together to perform some task, and where an object needs to\nbe able to notify other objects about changes without any knowledge\nabout those objects.\nStructure. Figure 15.10 illustrates the idea of observer using a class diagram.\nAn interface is used to implement the subject-observer relationship and\nthis is then implemented by the concrete subject and observers. Ob-\nservers register with the subject to receive calls to update() from the\nsubject. On receiving an update() message it is then the task of the ob-\nserver to use some form of getState() to check if the change a\ufb00ects it\n(since observers may be interested in di\ufb00erent aspects of the state, they\nmay use di\ufb00erent versions of getState()). Figure 15.11 uses a sequence\ndiagram to illustrate the operation of observer.\nImplementation. Again, this element is omitted here.\n", "page": 295, "type": "text", "section": "Page 295"}
{"text": "Designing with Patterns\n279\n<<interface>>\nSubject\n<<interface>>\nObserver\nregisterObserver()\nremoveObserver()\nnotifyObservers()\nupdate()\nConcreteSubject\nConcreteObserver\nregisterObserver(){...}\nremoveObserver(){...}\nnotifyObservers(){...}\nsetState()\ngetState_1()\n\u2026\ngetState_n()\nUpdate(){...}\n/* other observer\nmethods unrelated\nto this pattern */\nchange\nnotification\nchange\nnotification\nresponse\nto change\nresponse\nto change\nFIGURE 15.10: Class diagram for the observer design pattern\nKnown uses. Observer is a very widely used pattern. The example above of\nthe spreadsheet is just one of many. Another well-known one is within\nthe MVC architectural pattern, where the model acts as a subject, and\nthe views act as observers, being noti\ufb01ed when changes are made to the\nmodel.\nRelated patterns. Publish-Subscribe, Mediator.\nConsequences. While Observer provides loose coupling that makes it possi-\nble to vary subjects and observers independently, and to add observers\nwithout needing to modify the subject or other observers, there are some\n\u2018housekeeping\u2019 issues that need to be considered. These include:\n\u2022 a subject does need to keep track of the observers;\n\u2022 if an observer is observing more than one subject then it is necessary\nto extend the update() method so that the observer is able to know\nwhich subject has provided the noti\ufb01cation;\n\u2022 if a subject is deleted then it is necessary to notify all of its observers\nto avoid dangling references.\nThe model shown in Figure 15.10 describes the very basic operation (largely\nignoring the housekeeping issues above). Even so, this is a relatively simple\nas well as e\ufb00ective pattern (it was the pattern that was most highly valued in\nthe survey by Zhang & Budgen (2013)).\n", "page": 296, "type": "text", "section": "Page 296"}
{"text": "280\nSoftware Design: Creating Solutions for Ill-Structured Problems\nConcreteSubject\nConcreteObserver_2\nConcreteObserver_1\nsetState()\nupdate()\nnotifyObservers()\ngetState_1()\ngetState_2()\nupdate()\nFIGURE 15.11: Sequence diagram for the observer design pattern\nThe Observer pattern in the CCC\nOne of the most obvious roles for the Observer pattern is to help mon-\nitor the status and use of car objects. When a car object changes its\nstatus (such as becoming available), then it can \u2018publish\u2019 that change of\nstate, and any subscribers can take note. Di\ufb00erent subscribers likely to\nbe interested in car states will include club members seeking a nearby\ncar, the maintenance team, and the billing system.\nWhen seeking a car, a club member may become an observer for sev-\neral cars. But once the member has selected one, then the appropriate\nbooking object needs to remove itself from the list of subscribers to\nany other cars in order to avoid \u2018dangling references\u2019.\n", "page": 297, "type": "text", "section": "Page 297"}
{"text": "Designing with Patterns\n281\n15.3.3\nAbstract Factory(87)\nThe Abstract Factory provides an exam-\nple of an object creational pattern that ad-\ndresses a problem that probably is a bit more\nlimited in scope than those of the previous\ntwo examples, although the problem itself\nis an important one. The aim of this pat-\ntern is to make a \u2018client\u2019 class independent\nof the speci\ufb01c set of objects that may need to\nbe created for it to perform its task (decou-\npling it from them), where there is a choice\nof classes that can be instantiated. The decision about which class to instan-\ntiate is deferred to runtime, when a speci\ufb01c concrete factory class is used to\ncreate the objects.\nName. Abstract Factory\nAlso known as. Kit\nProblem. This pattern addresses the need to achieve portability of an appli-\ncation across environments. A common role is to enable an application\n(the \u2018client\u2019) to be used on a range of platforms that provide di\ufb00erent\nforms of \u2018look and feel\u2019 user interaction.\nSolution. The abstract factory de\ufb01nes an interface for creating each basic\nform of widget used in interaction (such as scroll bars, radio buttons\netc.). Clients perform operations to obtain a new instance of a widget,\nbut are not aware which concrete class is being used.\nExample. The widgets will usually form a user interaction toolkit that sup-\nports multiple standards for such widgets as scroll bars, buttons etc.\nApplicability. The roles for this pattern address situations where either:\n\u2022 a system needs to be independent of the way in which its products\nare created, composed and represented; or\n\u2022 a system may be con\ufb01gured locally, using just one form from a\nfamily of products.\nStructure. Figure 15.12 illustrates the idea of abstract factory using a class\ndiagram. The client uses the abstract factory when it is compiled and\nthen at run-time it is linked to an actual (concrete) factory. So if Con-\ncreteFactory1 is selected, that class will provide ProductA and ProductB\nfor use by the client. (Of course, the interfaces that these must conform\nto are speci\ufb01ed by the abstract factory.)\nImplementation. Again, we omit this element.\n", "page": 298, "type": "text", "section": "Page 298"}
{"text": "282\nSoftware Design: Creating Solutions for Ill-Structured Problems\nAbstractFactory\nCreateProductA()\nCreateProductB()\nClient\nConcreteFactory1\nAbstractProductA\nCreateProductA()\nCreateProductB()\nRequest creation of ProductA\nRequest creation of ProductA\nCreates a concrete product\nwith specific characteristics\nCreates a concrete product\nwith specific characteristics\nConcreteFactory2\nCreateProductA()\nCreateProductB()\nProductA2\nProductA1\nInteraction with ProductA\nInteraction with ProductA\nFIGURE 15.12: Class diagram for the abstract factory design pattern\nKnown uses. Abstract factory isolates clients from the responsibility and\nprocess of creating product objects, the client manipulates the instances\nthrough their abstract interfaces and hence remains unaware of the par-\nticular implementation.\nRelated patterns. Prototype\nConsequences. While the abstract factory can be easily extended to in-\nclude new members of a product family (for example, a new form of\nuser interface), adding new products to the set provided by the factory\nis not easy, because the pattern de\ufb01nes a \ufb01xed set of products. So adding\n(say) a variant form of radio buttons would require modifying the ab-\nstract factory and recreating all of the concrete factories. In that sense,\nusing abstract factory does create a form of technical debt through the\nconstraints this creates.\nAbstract factory meets a quite speci\ufb01c need and is generally considered to do\nit well. However, apart from the example of di\ufb00erent user interfaces it is not\nas likely to be so widely used as the previous two examples.\n", "page": 299, "type": "text", "section": "Page 299"}
{"text": "Designing with Patterns\n283\n15.4\nOther uses of patterns\nThis section addresses two rather di\ufb00erent pattern-related issues. The \ufb01rst\nis to brie\ufb02y examine an example of how design patterns can be used with\nanother architectural style (SOA), while the second involves looking at how\npatterns can be employed to describe experiences of what doesn\u2019t work.\n15.4.1\nSoftware service patterns\nSoftware service concepts were described in Chapter 11. While compo-\nnents (which can be considered as the precursors of services) do not seem to\nhave attracted much interest from the patterns community, software services\nhave presented a topic of greater interest, and indeed, patterns may well be a\nparticularly e\ufb00ective way of adapting the service concept to user needs.\nAt the architectural pattern level, Bass et al. (2013) consider that the\nservice-oriented architectural pattern describes the use by service consumers\nof distributed services o\ufb00ered by service providers. Essentially this pattern\ndescribes the use of services in the form described in Chapter 11. It identi\ufb01es\nthe need for a service to publish details of what is provided, and also to ad-\ndress quality issues through the use of service-level agreements (SLAs), which\nre\ufb02ects the strong business element often associated with the use of the service\nmodel.\nApplication\nService 1\nprovider\nService 2\nprovider\nService 3\nprovider\nService 4\nprovider\nService\ninterface\nSOAP call\nFIGURE 15.13: A very simple SOA pattern\n", "page": 300, "type": "text", "section": "Page 300"}
{"text": "284\nSoftware Design: Creating Solutions for Ill-Structured Problems\nTopologically, this architectural pattern can be expected to possess a \u2018star\u2019\ncon\ufb01guration. A simple example is provided in Figure 15.13. In this example\nthe external service providers are essentially \u2018\ufb01xed\u2019 and some form of \u2018ser-\nvice broker\u2019 or \u2018orchestration server\u2019 could well be included to allow greater\n\ufb02exibility of the choice of providers and con\ufb01guration.\nAt the more detailed level (akin to the GoF patterns), a number of books\nhave documented a wide range of patterns. A major source is the text by\nErl (2009). While some patterns are derived from the object-oriented pattern\nset, most appear to be unique to the service context. Service patterns are\ncomplicated by a number of factors, including the existence of di\ufb00erent service\nframeworks, the dynamic (self-adapting) nature of many service applications,\nand the lack of standard notations.\n15.4.2\nDesign anti-patterns and code smells\nIdeas about software reuse, which is a key motivation for employing de-\nsign patterns, has understandably focused upon \ufb01nding ways to reuse good\nexperiences. But of course, a designer\u2019s knowledge schema may well include\nexperiences that were unsuccessful too, and these also need to be remembered\nso that they can be avoided in the future. So, not surprisingly, although less\nwell-codi\ufb01ed than the concept of the design pattern, this has led to the concept\nof the design anti-pattern.\nIn a very readable, if rather tongue-in-cheek, paper, John Long (2001)\nprovides some examples of \u201cobvious, but wrong, solutions to recurring prob-\nlems\u201d, putting particular emphasis upon the processes involved in choosing to\nuse them. Indeed, the anti-patterns literature does tend to put more emphasis\nupon the reasons why wrong solutions are adopted, rather than on the spe-\nci\ufb01c form of the wrong solutions themselves (Brown, Malveau, McCormick &\nMowbray 1998).\nThis emphasis is quite understandable, since technical solutions are rarely\ncompletely wrong in themselves, although a particular solution may well be\nthe wrong one to adopt in a particular context. So, while the literature on\ndesign patterns emphasises solution structures, although recognising the in-\n\ufb02uence of context and motivation, the anti-patterns literature focuses mainly\non motivation.\nFor our purposes, the main message here is that reuse of a design model\n(or in the case of patterns, of part of a design model) is not automatically\n\u201ca good thing\u201d. What has proved successful in one situation may not always\nwork in another.\nHowever, while anti-patterns are in some ways something of an evolution-\nary dead end, they can be considered as a form of antecedent for the much\nmore widely adopted idea of code smells. The term \u2018code smell\u2019 is generally\nattributed to Kent Beck, and in the absence of a formal de\ufb01nition (the concept\ndoes have a subjective element arising from context), the description provided\nin Fowler (1999) is quite widely used. In this, a code smell is considered as\n", "page": 301, "type": "text", "section": "Page 301"}
{"text": "Designing with Patterns\n285\nbeing a structural weakness that indicates a deeper \ufb02aw, and that needs to\nbe removed from the source code through the use of refactoring in order to\nimprove the maintainability of the software. (While the term does provide an\nunquestionably evocative description of the sort of issue involved, it is prob-\nably better not used when explaining refactoring plans to project managers,\ncustomers etc.)\nAs the term indicates, code smells are likely to be recognised during im-\nplementation, although some may well be detectable in advance of that. Here\nwe brie\ufb02y look at some examples.\nGod Class. A God Class \u201crefers to those classes that tend to centralise the\nintelligence of the system. An instance of a god class performs most of\nthe work, delegating only minor details to a set of trivial classes and\nusing the data from other classes\u201d (Lanza & Marinescu 2006). A God\nClass may well make frequent access to the data of foreign classes and its\nrole violates the object-oriented design principle that each class should\nonly have one responsibility. God Classes also tend to be very large,\na\ufb00ecting ease of comprehension. Because of its role, it is anticipated\nthat such a class will be changed frequently during maintenance, and\nhence more likely to include errors.\nHowever, the study by Olbrich, Cruzes & Sj\u00f8berg (2010), looking at the\nevolution of three OSS applications does demonstrate that it may well\nbe that the use of a God Class is a quite reasonable way to organise\nsome forms of application, provided that its size is not extreme. This\nemphasises the point made above that the identi\ufb01cation of relevant code\nsmells may well be subjective and contextual.\nData Class. Such a class has data \ufb01elds, together with methods for changing\nand inspecting these, but plays no role in the operational purposes of the\napplication. Its lack of a behavioural role weakens the object-oriented\nstructures and at the worst it may simply be a mechanism for including\nglobal data. As observed in (Fowler 1999) this may be an acceptable\nform for a class to have during initial development, but at some point\nit should take on the role of a \u2018grownup\u2019.\nCode Duplication. Duplication of code can arise in more or less any ar-\nchitectural style (for example, it can easily arise in the lower levels\nof a call-and-return structure). Duplication can lead to problems with\nmaintenance, particularly where only one instance is changed, creating\ninconsistencies. Fowler (1999) suggests some techniques to employ for\nrefactoring when this is detected.\nLooking at these examples, although they may (partly at least) arise from\ndesign decisions, their characteristics relate strongly to code. Hence it may\nbe more di\ufb03cult to identify these in a design model (the God Class perhaps\nexcepted).\n", "page": 302, "type": "text", "section": "Page 302"}
{"text": "286\nSoftware Design: Creating Solutions for Ill-Structured Problems\nWhere code smells do have a useful role is when identifying the need for\npossible refactoring. As discussed in Section 14.7, refactoring involves reor-\nganisation of the code from a constructional perspective, while retaining its\nfunction and behaviour, in order to help with the future evolution of an ap-\nplication. Code smells can help with prioritising the need for such change in\nthe design. They may also provide a motivation for refactoring that is related\nto the design model itself, although they still have a strong link to the actual\ncode structures.\n15.5\nDesigning with patterns\nHaving reviewed various examples of the pattern concept, the next obvious\nquestion to ask is \u201chow do we use design patterns to solve design problems?\u201d.\nIn this section we discuss some issues related to pattern use.\nMany of the books that describe design patterns, such as those by Gamma\net al. (1995) and Buschmann et al. (1996) are very much structured as cata-\nlogues of patterns. And later texts such as Bates et al. (2009) focus largely on\nthe issues of how to implement patterns. Important as both of these are, par-\nticularly for documenting patterns, they still leave our initial question unan-\nswered. Unfortunately, rather as a gardening catalogue, full of glorious colour\npictures of healthy, thriving plants, provides little real aid with the task of\nplanning a new garden\u2014although it may tell us which plants like shade and\nhow tall they will grow\u2014so it is apt to be with design patterns. Possession of\na catalogue provides a source of ideas; it provides information that can help\nwith planning and anticipating possible consequences, but the task of working\nout how to use its contents is still a creative activity.\n(Actually, the analogy with planning a garden is quite a good one, at\nleast, if you like gardens, since gardens do evolve and exhibit behaviour, even\nif over much longer periods of time than we expect with software. Trees grow\nand shade di\ufb00erent parts of the garden, some plants take time to become\nestablished but then take over adjacent sections unless controlled. So, like the\nsoftware designer, the gardener\u2019s planning requires an ability to envisage some\nfuture state, while having inadequate control over both the conditions and the\nquality of materials that they need to use to achieve that state.)\nHow then do we use catalogues of design patterns, whether in books or\non-line? Well, the GoF advice is very much along the lines that patterns need\nto be learned, and that by studying patterns the designer will acquire both\ninsight into how and why the pattern works as well as enough familiarity\nwith it to be able to recognise those situations where it can be used to e\ufb00ect.\nDesigners are also advised to follow the following two principles.\n\u2022 Program to an interface, not an implementation. What this means is\nthat a client object should not be aware of the identity of the actual\n", "page": 303, "type": "text", "section": "Page 303"}
{"text": "Designing with Patterns\n287\nobject that is used to service a particular request, so long as its form\nand behaviour conform to the interface speci\ufb01cation.\n\u2022 Favour object composition over class inheritance. This is not to deny the\nvalue of inheritance as a mechanism for reuse, but rather that it should\nnot be over-used.\nThis implies that the minimum conditions for the successful use of patterns\nrequire that a designer should:\n\u2022 acquire a \u2018vocabulary\u2019 of design patterns;\n\u2022 be able to recognise where a particular pattern could provide a useful\nsolution;\n\u2022 have an understanding of how to realise the pattern within that context.\nGiven that there are now hundreds of documented patterns (the book by\nGamma et al. (1995) documented only 23 of them), these are quite challenging\nrequirements, especially given that the question of which patterns are the ones\nthat are most valuable to learn (\ufb01rst) is not easily answered.\nThe strategy advocated by Buschmann et al. (1996) is rather di\ufb00erent,\nalthough the basic conditions for when it is appropriate to employ a pattern\nare the same. They advise classifying a given problem in the same way that\nthe patterns themselves are classi\ufb01ed, as a step towards being able to identify\npotentially useful patterns. Their basic process is as follows.\n1. Specify the problem, and if possible, any sub-problems involved.\n2. Determine the category of pattern that is appropriate to the design\nactivity being performed (that is, architectural or design patterns).\n3. Determine the problem category appropriate to the problem.\n4. Compare the problem description with the available set of patterns in\nthe catalogue that \ufb01t that problem description.\n5. Consider the bene\ufb01ts and liabilities (assess the design trade-o\ufb00s and\npossible technical debt that will be incurred by using the pattern). Of\ncourse, this may also need to include the possibility that there is no\nexisting tried and tested pattern for the given problem.\n6. Select the pattern variant that best \ufb01ts the problem and o\ufb00ers most\nbene\ufb01ts.\nSince their strategy includes architectural styles as well as design patterns and\nidioms, the above process can be considered as fairly comprehensive, and in\nprinciple at least, avoids the need to learn a growing catalogue of patterns. We\nmight also note that it has a distinctively top-down decompositional aspect,\n", "page": 304, "type": "text", "section": "Page 304"}
{"text": "288\nSoftware Design: Creating Solutions for Ill-Structured Problems\nwhich is perhaps unexpected, given that patterns are essentially a composi-\ntional concept. Perhaps the main practical limitation is that pattern docu-\nmentation has tended to follow the structure adopted by the GoF.\nIf we go back to the model of pattern use represented by Figure 15.2, an\nobvious question is how to recognise the opportunity to use a pattern. We\nshould not assume that there is always going to be a suitable pattern when\nusing a process such as the one above. Indeed, trying to force all problems\ninto a \u2018pattern framework\u2019 is likely to produce exactly the opposite of what it\nintended. So step 5 in the above process is an important one, and the designer\nmay well need to be able to recognise when there is no \u2018ready-made\u2019 pattern\nthat \ufb01ts a given problem. A key thing here is recognising that a particular\ndesign problem is likely to have been encountered in enough situations to be\nlikely to have resulted in someone creating a pattern for it. Again, this is\nwhere the more experienced designer is likely to have an advantage.\nThe process recommended by the GoF carries within it a self-limiting as-\npect that is clearly di\ufb03cult to overcome. This arises from the way that, as\nmore patterns are identi\ufb01ed and added to the corpus of pattern knowledge,\nso the ability of the individual designer to learn all of these becomes an ever-\nincreasing challenge. What is needed is some agreed way of indexing patterns,\nor at least agreement about what constitutes a core set of patterns that ev-\neryone might be expected to learn. Neither of these has really emerged, and\nin their absence, the process recommended by Buschmann et al. would seem\nto cope better with the nature of ISPs.\n15.6\nEmpirical knowledge about designing with patterns\nWhile the design patterns community has contributed some very valuable\ninsight into how we can reuse design ideas, this has not always been quite\nas balanced as might be desired. Enthusiasts continue to write patterns and\nencourage others to do the same; there are conferences on patterns (usually la-\nbelled as xxxPLoP, where PLoP stands for \u2018Pattern Languages of Programs\u2019);\nand a journal (TPLoP of course). What has been less evident is any enthu-\nsiasm for winnowing out the less useful patterns and evaluating the concept\nin general. Patterns are unquestionably a useful concept, but as with all con-\ncepts employed for design, it is important to obtain an understanding of their\nlimitations too.\nThis section almost entirely describes studies related to object-oriented\ndesign patterns. There is very little empirical research into architectural pat-\nterns (perhaps not entirely surprising) or into the use of design patterns with\nother architectural styles.\nZhang & Budgen (2012) conducted a systematic review into what was\nknown about design patterns. They found a small number of empirical studies\n", "page": 305, "type": "text", "section": "Page 305"}
{"text": "Designing with Patterns\n289\n(mainly small-scale experiments) and a number of \u2018experience papers\u2019, with\nthat by Wendor\ufb00(2001) being particularly insightful. All of the patterns stud-\nied were either directly taken from the GoF or were close derivatives. They\nconcluded that: \u201cwe could not identify \ufb01rm support for any of the claims made\nfor patterns in general, although there was some support for the usefulness\nof patterns in providing a framework for maintenance, and some qualitative\nindication that they do not help novices learn about design\u201d. However, the\nstrength of evidence for the overall \ufb01ndings from the study was limited by\nthe small number of primary studies and the way that these used a spread\nof di\ufb00erent patterns, with\nComposite, Observer and Visitor being the only\npatterns that had been addressed by more than two or three primary studies.\nThis study was followed up with two surveys. The \ufb01rst was a quantitative\nsurvey of the usefulness of the 23 GoF patterns, using the authors of pattern\npapers as the sampling frame (Zhang & Budgen 2013), and then was aug-\nmented by a more qualitative survey (using the same sampling frame), seeking\nexplanations for some of the results (Zhang, Budgen & Drummond 2012). As\nwith almost any survey undertaken in software engineering, it is extremely\ndi\ufb03cult to determine to what degree the sampling frame used could be con-\nsidered as being representative of pattern users as a whole.\nFrom the \ufb01rst survey, the most highly rated patterns were Observer, Com-\nposite and Abstract Factory, and there was also a substantial group that were\nnot considered to be useful (most notably, Memento). There was also con-\nsiderable ambivalence about Singleton, which was investigated further in the\nsecond survey. The Singleton pattern is a creational pattern that \u201censures a\nclass only has one instance\u201d, with a single global access point. (A good exam-\nple of a situation where the use of this might be appropriate is for a spooler\nclass responsible for managing output to a printer.) The qualitative survey\nrevealed that a signi\ufb01cant number of users were concerned that Singleton was\neasily mis-used to provide global variables, and that its use also increased\ncoupling. So, while it could be useful for limited roles, the potential disadvan-\ntages in terms of introducing undesirable features into a design model were\nsuch that they felt it better to avoid its use1.\nWhile there have been quite comprehensive studies of research trends re-\nlated to the use of design patterns, such as Mayvan, Rasoolzadegan & Yazdi\n(2017), (which found that pattern development, pattern mining, and pattern\nusage were the most active research topics in the \ufb01eld of design patterns),\nthere appear to have been relatively few studies related to any form of eval-\nuation of the patterns themselves. Given how much patterns are valued by\nquite a wide community (and lack of research does not imply lack of value),\nthis lack of critical analysis is disappointing.\nThis situation is even more marked for the use of software service patterns.\nAlthough there is no lack of tutorial material, there seem to have been few\nstudies that assessed the usefulness of this class of patterns.\n1For these reasons, this has not been used as one of our examples of patterns.\n", "page": 306, "type": "text", "section": "Page 306"}
{"text": "290\nSoftware Design: Creating Solutions for Ill-Structured Problems\nIf we turn brie\ufb02y to the anti-pattern context, then we \ufb01nd that, despite\nthe issues of context and di\ufb03culty of de\ufb01nition, there have been many studies\non the use of code smells. An example of such a study is that by Palomba,\nBavota, Penta, Fasano, Oliveto & Lucia (2018), and it is worth noting that\nthis, like many others in this area, largely draws upon data from open source\nprojects. However, these studies do not appear to o\ufb00er any very conclusive\nviews on the usefulness of code smells, and rarely provide any systematic\nform of evaluation. Some of the cause of this may be the in\ufb02uence of context\nas a confounding factor, as noted by Olbrich et al. (2010).\nKey take-home points about designing with patterns\nDesign patterns provide a useful and valued means of codifying and ex-\nchanging information about design structures (large and small) that have been\nfound to be e\ufb00ective by software designers.\nA pattern describes both a \u2018design problem\u2019 and a generic solution to that\nproblem that can be reused over and over again in many di\ufb00erent ways.\nLabelling of patterns aids with knowledge transfer and reuse.\nPatterns are more concerned with coupling through composition than with\ninheritance. They generally aim to provide loose coupling between design\nelements so as to aid the \u2018evolution\u2019 of a design model.\nArchitectural patterns describe ways of structuring applications to \ufb01t par-\nticular characteristics of their role.\nDesign patterns provide \u2018part-solutions\u2019 for elements of a design model,\nsimplifying the process of \u2018solving\u2019 an ISP by providing a way of organ-\nising speci\ufb01c aspects of the design model.\nPatterns are used for di\ufb00erent aspects of the design model. Creational and\nstructural patterns are organised around the constructional viewpoint,\nwhile behavioural patterns structure the design within the behavioural\nviewpoint.\nPatterns can be used with any architectural style (in principle) but have\nlargely evolved for the object-oriented architectural style where there is\na large community of pattern enthusiasts.\nThe design process when making use of design patterns is an informal one\nwith only quite limited guidance about the recognition and use of pat-\nterns being available to help the designer.\n", "page": 307, "type": "text", "section": "Page 307"}
{"text": "Designing with Patterns\n291\nEmpirical knowledge about the usefulness of design patterns and architec-\ntural patterns is limited. However, it is clear that some patterns (most\nnotably Observer, Composite and Abstract Factory) are valued by ex-\nperienced designers. There is some evidence that the use of patterns is\nunlikely to provide help for less experienced designers.\n", "page": 308, "type": "text", "section": "Page 308"}
{"text": "Chapter 16\nDesigning with Components and\nServices\n16.1\nModular design ...................................................\n293\n16.2\nDesigning with components ......................................\n294\n16.3\nDesigning with software services .................................\n298\n16.4\nEmpirical knowledge about modular design .....................\n302\nKey take-home points about designing with components and\nservices ...........................................................\n302\nIn Chapter 11 we looked at component technology and the concept of the\nsoftware service. Our concern there was to describe their forms and to consider\nthe properties of components and services that were of importance from the\nperspective of how they might be modelled.\nThis chapter looks at how components and services can be composed to\ncreate applications, and some factors that we might need to consider when\ndesigning with such elements.\n16.1\nModular design\nChapter 11 addressed the question of how to design components, both in\nthe form of \u2018local\u2019 software components, and also software services (which of\ncourse, can be viewed as being a form of \u2018remote\u2019 component). In this chapter\nwe brie\ufb02y discuss the question of producing designs for building applications\nthat make use of both components and services.\nThe two forms have much in common as well as some di\ufb00erences when it\ncomes to producing a design. They particularly share a \u2018plug-and-play\u2019 phi-\nlosophy, arising from the widespread use of dynamic binding when composing\nan application from existing elements, hence the reference above to the idea\nof \u2018modular\u2019 design. And despite the importance of reuse in software devel-\nopment as a whole, in neither case are there any well-established practices to\nassist with formulating an overall design model around the concept of reuse.\nIndeed, up to this point, the ideas about creating software applications pre-\nsented in Part III have essentially assumed a \u2018bespoke\u2019 development process,\n293\n", "page": 310, "type": "text", "section": "Page 310"}
{"text": "294\nSoftware Design: Creating Solutions for Ill-Structured Problems\nwith the elements making up each application (or product line) largely being\ndi\ufb00erent and unique. So, while the development of ideas about component-\nbased software engineering (CBSE) could build upon experiences with using\nobjects, those experiences provided little opportunity for accumulating and\nformalising declarative and procedural knowledge about modular design.\nHowever, when creating applications from existing components and ser-\nvices, some aspects of incremental design may well be adapted for this pur-\npose, because both forms provide scope for the use of prototyping, particularly\nexploratory and evolutionary prototyping. Exploratory prototyping allows the\ndesigner to investigate the use of di\ufb00erent component combinations while de-\nveloping an application, while evolutionary prototyping may provide an over-\narching development context in which the application emerges from a series\nof intermediate forms.\nThe use of prototyping rather than the development of more structured\ndesign models may however create limited opportunity for providing knowl-\nedge transfer that has been derived from experience of composing components.\nThis is because, although components and services are implicitly well-suited\nto the use of a compositional strategy, the major in\ufb02uence upon design deci-\nsions is likely to be the identi\ufb01cation of what modules are available from the\ncomponent catalogue rather than design strategy.\n16.2\nDesigning with components\nAs noted above, there is very little guidance available about how to de-\nvelop a design by using components. This is true even for a well-established\narchitectural form such as JavaBeans, the component architecture used with\nthe Java platform. The component composition process itself is further com-\nplicated by the way that components can be used to perform what we might\nterm horizontal roles within a system (whereby the overall functionality of the\napplication is distributed between them), and also vertical roles in which they\nprovide \u2018layers\u2019 of services through component frameworks such as CORBA\nand .NET. The latter role essentially corresponds to the use of a Layers ar-\nchitectural pattern. This is illustrated in Figure 16.1.\nOur concern here is primarily about how the design choices related to \u2018hori-\nzontal\u2019 structuring are to be made, on the basis that these provide the detailed\ndesign, whereas the \u2018vertical\u2019 structuring provides an architectural design. But\nof course, as always, the two cannot be regarded as entirely separate.\nWhere the aim is to develop an application by reusing existing compo-\nnents, then in selecting a set of components that can be composed to make\nup the overall functionality of a system, there are two distinct strategies that\nmight be employed. (These can be viewed as forming extremes of course, and\ncomposition may well be undertaken using a mix of these.)\n", "page": 311, "type": "text", "section": "Page 311"}
{"text": "Designing with Components and Services\n295\nHorizontal integration to\nprovide system functionality\nfrom a set of components\n(at each level).\nVertical integration to provide a\nlayered set of services (lower\nlevels may be monolithic,\nrather than component-based).\nFIGURE 16.1: Horizontal and vertical integration of components\n\u2022 Identify the general needs of the application problem, and search for a\nset of components that collectively match that functionality, and seek\nto construct the design (and implicitly, the application) by aggregating\nthese in some way. (This can be termed as an element \ufb01rst strategy.)\n\u2022 Decompose the application problem into well-de\ufb01ned sub-problems that\naddress speci\ufb01c tasks and then seek a set of components that will \ufb01t\nthe needs of the individual sub-problems. (This can be termed as a\nframework \ufb01rst strategy.)\nSome small empirical studies that investigated the extent to which either strat-\negy was adopted, and with what level of success, are described in (Pohthong\n& Budgen 2000) and (Pohthong & Budgen 2001). These used a rather con-\nstrained component context (Unix processes), and as might have been ex-\npected, for much of the time the participants worked opportunistically, ad-\njusting the choice of strategy as the solution evolved. However, for less expe-\nrienced designers, the use of an element \ufb01rst strategy did appear to be more\nlikely to result in a working solution. It was thought that this might be partly\nbecause identifying the available components might provide better assistance\nwith creating a conceptual model of how the overall application might work.\nReusing existing components with an opportunistic strategy makes it pos-\nsible to make good use of exploratory prototyping. When the option to develop\ncomponents rather than simply reuse existing ones is added to this (what we\nmight term a \u2018buy or build\u2019 strategy) then the design decisions become even\n", "page": 312, "type": "text", "section": "Page 312"}
{"text": "296\nSoftware Design: Creating Solutions for Ill-Structured Problems\nIntegrated system\nIntegrated system\nIntegrated system\nIntegrated system\na) Overlapping functionality\nSystem functionality\nb) Missing functionality\nc) Redundant functionality\nd) Architectural mismatch\nFIGURE 16.2: Illustrations of some of the problems that might arise in com-\nponent integration\nmore complex. As indicated in Chapter 11, it is necessary to factor in the\nknowledge that the cost of developing components for reuse is around four\ntimes greater than direct development. Given these issues, we can conclude\nthat simple strategies are unlikely to work for many applications, and that\nthe complexity of component-based design can only really be addressed by an\nopportunistic strategy.\nIn composing a system from a set of components, particularly when work-\ning opportunistically, a designer needs to be able to model and predict their\naggregate behaviour and functionality. In doing this, the designer also needs\nto identify the potential for the occurrence of any of the issues shown schemat-\nically in Figure 16.2. These problems can be classi\ufb01ed as follows.\na) Overlapping functionality. This occurs where two or more components\nare able to perform a particular application function. The designer\u2019s task\nis to determine which one should perform the task, and how to ensure\nthat only that component performs it. From a design point of view it is\nde\ufb01nitely undesirable to have the same function performed by di\ufb00erent\nelements (possibly with di\ufb00erent limits or ranges), and this also creates\na problem for system maintenance and evolution.\nb) Missing functionality. The problem arises when the total set of func-\ntions provided by the components chosen to make up the application is\n", "page": 313, "type": "text", "section": "Page 313"}
{"text": "Designing with Components and Services\n297\nless than what is needed. The solution is fairly simple, either \ufb01nd an-\nother component or (possibly) create one. So this should be a short-term\nissue with no longer-term technical debt associated with it.\nc) Redundant functionality. Components may well provide services over\nand above those that form the basis for choosing those particular compo-\nnents. This is particularly so for large components. The designer needs to\nchoose between incorporating the added functionality in some way (with\npossible undesirable consequences) or, preferably, \ufb01nding some way to\nexclude the unwanted functions.\nd) Architectural mismatch. This issue was discussed in Chapter 11, and\narises when there are mismatches between the expectations that each\ncomponent makes about its context. The study by Yakimovich, Bieman\n& Basili (1999) provides examples of how architectural mismatch can\narise from inconsistencies in:\n\u2022 component packaging\u2014where components may be constructed as\nlinkable elements that need to be integrated into an executable\nimage, or as independent elements, that may be scheduled inde-\npendently;\n\u2022 type of control\u2014concerning the way that control is organised and\ntransferred between components, and whether this is managed cen-\ntrally within an application or concurrently (such as through an\nevent-driven mechanism);\n\u2022 type of information \ufb02ow\u2014whether organised as control \ufb02ow\nthrough method calls, data \ufb02ow through shared memory, or in a\nmixed format;\n\u2022 synchronisation between components\u2014referring to whether a com-\nponent can \u2018block\u2019 the execution of other components (syn-\nchronous), or can continue to run regardless (asynchronous);\n\u2022 binding time\u2014referring to when the components are attached to\nconnectors, which may occur at compilation, link-editing, run-time\netc.\nWhat should be clear from this is that while component-based development\no\ufb00ers potential to bring together components from a variety of sources and\nin a range of forms, it is probably wisest to employ only components that\nconform to a single architectural style. This doesn\u2019t prevent the \ufb01rst three\nproblems arising, but these are likely to be much more tractable than coping\nwith architectural mismatch.\nThe systematic mapping study by Vale et al. (2016) identi\ufb01ed some im-\nportant gaps in CBSE knowledge, while recognising that some of these were\ncompounded by the diversity of CBSE forms and application areas. Gaps of\nparticular relevance to design included a lack of experience reports about use\n", "page": 314, "type": "text", "section": "Page 314"}
{"text": "298\nSoftware Design: Creating Solutions for Ill-Structured Problems\nof CBSE in practice, a lack of clear concepts about CBSE in practice, and\na lack of CBSE tool support. CBSE tools do exist but appear to be largely\nconcerned with implementation rather with activities such as modelling.\nTo complete our discussion of designing with components we look at how\ncomponents might be used to compose the software needed to support the\nbusiness of the CCC.\nModular implementation for the CCC\nMost of the operations of the CCC are those that will be common to\nmany businesses that provide resources on a temporary basis, whether\nit be car rental, hire of sca\ufb00olding, use of hotel meeting rooms etc.\nA CBSE implementation might therefore expect to \ufb01nd modules that\ncan handle its needs as regards accounting for use, keeping records of\ncars and customers. (Of course, as we have already observed, it will be\nbetter if these all conform to the same component architecture.)\nBuilding the user interface app, to be used on mobile phones, can again\nuse fairly low-level components such as buttons, boxes etc., and one\nbene\ufb01t of using a suitable component platform is that these should be\nportable across di\ufb00erent platforms.\nWhat is less likely to be \u2018o\ufb00the shelf\u2019 is the rather important element\nof reservation. Locating nearby cars and calculating their distance from\nthe customer and then ranking these in some way may be rather less\nreadily available, although some of the elements needed for GPS loca-\ntion may well be so.\nWhether to adopt this strategy also depends upon issues such as trust\n(of components built by others), con\ufb01dence in their continued avail-\nability (and evolution). As with all issues associated with ISPs there\nis no one answer of course.\n16.3\nDesigning with software services\nWith any new implementation technology paradigm, there is an inevitable\nlag between it becoming available and the accumulation of relevant knowl-\nedge schema about how to design applications using it. And for more complex\nforms, such as objects, components and services, there is also a need to es-\ntablish a consistent context for their use, usually in the form of some sort of\nframework.\nThe basic service model, often described as Software as a Service separates\npossession and ownership of software from its use by employing remote service\nproviders to deliver services \u2018on demand\u2019 (Turner et al. 2003, Budgen, Brereton\n& Turner 2004). It is this paradigm that underpins the concept of the cloud,\n", "page": 315, "type": "text", "section": "Page 315"}
{"text": "Designing with Components and Services\n299\nwhereby the user of a service needs to have no detailed knowledge of how\nit is provided. Indeed, the use of software services depends upon the use of\nbusiness modelling at least as much as more \u2018technological\u2019 design modelling.\nDesigning for very basic use of the SaaS model then requires little more\nthan using the pattern shown in Figure 15.13, possibly adding an element of\norchestration to aid with selecting services.\nBeyond that, the lack of clear de\ufb01nitions of what exactly is meant by such\nterms as Service Oriented Architecture becomes quite a problem. A systematic\nmapping study performed to identify what exactly was considered to comprise\nan SOA found that of 921 studies referring to SOA, only 98 provided explicit\nde\ufb01nitions of what the authors considered this to consist of (Anjum & Budgen\n2012). Where de\ufb01nitions did exist, they di\ufb00ered in such aspects as the level\nof abstraction and the assumed context (consumer, provider, developer).\nIntegrating the terms that were used to describe SOA in those studies\nthat did provide some form of de\ufb01nition produced a set of characteristics\nthat could be considered to provide a pro\ufb01le of SOA (and which have no\nparticular con\ufb02icts or inconsistencies). And hence, these can be considered as\nfactors that need to be considered when designing an application that is to be\nrealised using service forms, and that should ideally be provided by a service\nframework. (Of course, the application may itself be providing a service.) In\nbrief, these characteristics are as follows.\n\u2022 Architecture. This relates to the overall organisation of an application\nin terms of the ways that the di\ufb00erent services interact. Implicitly, these\ninteractions are usually through SOAP, although REST is also used.\n\u2022 Binding Time. This refers to the time at which a particular service (and\nhence the service provider) is selected by an application. Some services\nmay be bound when the application is composed, since their use may\nbe intrinsic to its purpose, while others may well be bound dynamically\non demand.\n\u2022 Capability. This relates to the purpose of an application or service,\nviewed from the perspective of the service consumer. The emphasis here\nlies upon the functional viewpoint, as services are essentially stateless in\nnature, providing limited scope to use behavioural modelling in any way.\n\u2022 Composition. This relates to the speci\ufb01c con\ufb01guration of services em-\nployed to meet the needs of the end-user (often termed orchestration,\nparticularly in a dynamic context). Composition is e\ufb00ectively a realisa-\ntion of the design model.\n\u2022 Contracts. Because the use of services is likely to involve third parties\nas suppliers, it is common for a service provider to o\ufb00er a Service-Level\nAgreement that speci\ufb01es the terms and conditions under which a service\nwill be provided and used. And of course, this may have to be managed\n", "page": 316, "type": "text", "section": "Page 316"}
{"text": "300\nSoftware Design: Creating Solutions for Ill-Structured Problems\ndynamically (one of the more challenging aspects of the service model)\nunless such contracts are negotiated in advance of use.\n\u2022 Delivery. Essentially this is the operational aspect by which a service\nprovides the agreed service functionality.\n\u2022 Distributed Sources. Services can be delivered locally as well as from\nremote sources, but this aspect is particularly concerned with delivery\nacross a network (implicitly, the web).\n\u2022 Identity. This is essentially the description of a particular service and\nthe ways that it can be accessed.\n\u2022 Interoperability. This relates to the service framework and the way that\nservices can be deployed within this, including the possibility that the\nend-user has no knowledge about the location or provider of a particular\nservice, and indeed, that such a service may be provided by di\ufb00erent\nsources each time it is requested.\n\u2022 Packaging. A constructional issue concerning the creation of services so\nas to ensure that a service both provides the required functionality, and\nalso the appropriate interface.\nWhile all of these are factors that in\ufb02uence design of an application in some\nway, not all of them will necessarily be a direct in\ufb02uence. Characteristics such\nas packaging and identity are primarily ones that are determined or speci\ufb01ed\nby the service provider, and hence likely to be an indirect in\ufb02uence. Others\nsuch as orchestration, binding time and capability are likely to be of much\nmore immediate importance when con\ufb01guring an application to use services.\nFigure 16.3 shows how these characteristics map on to the main elements of\nthe service paradigm, by annotating the model provided in Figure 11.5.\nDevelopment of SOA applications is apt to employ a complex mix of busi-\nness and technological modelling. As noted in the last chapter, the use of de-\nsign patterns has been advocated for more detailed modelling needs (Erl 2009).\nThere has also been some interest in using what are more or less plan-driven\nforms of approach such as the SOA method (SOAM) proposed in (O\ufb00ermann\n& Bub 2009). (There is some discussion of di\ufb00erent methods in (Anjum &\nBudgen 2017).) Modelling would appear to be largely dependent upon the use\nof UML class and component diagrams.\nIn many ways, designing SOA applications can be considered as being\nan indirect form of design. Rather than explicitly determining things like\ncon\ufb01guration of elements, the SOA designer is more concerned with writing\na set of rules for the dynamic orchestration of the services. And these roles\nare not only concerned with basic service properties, but also with things like\nService-Level Agreements that are con\ufb01rmed or re-negotiated at run time, as\nwell as security.\n", "page": 317, "type": "text", "section": "Page 317"}
{"text": "Designing with Components and Services\n301\nService\nConsumer\nService\nDescription\nService\nProvider\nService\nComposition\nselection\n& binding\nuse\nprovision\nrequest\nnegotiation\nBusiness\nRules\ncapability\ncapability\ndelivery\ndelivery\ncontracts\ncontracts\nidentity\ndistributed sources\npackaging\narchitecture\nbinding time\ncomposition\narchitecture\nidentity\ninteroperability\nFIGURE 16.3: SOA characteristics mapped on to the service model\nOne question that arises when designing around the use of SOA is the\nextent to which relevant commercial service provision exists? (A similar issue\narises with component-based design, but once a component has been found, its\nuse is less dependent upon the external provider.) As with the use of physical\nservices, adoption of this model does involve an element of risk in that a service\nprovider may cease to trade. Hence employing a service model does implicitly\nrequire the availability of multiple providers for a given service. Many of the\npapers describing and discussing use of services do tend to be focused on quite\nspeci\ufb01c application areas, which may help the emergence of a provider market,\npossibly related to the use of cloud services.\nTo complete our discussion of the use of software services in this section,\nwe again turn to the needs of the CCC and consider how this might make use\nof a service model, including services provided by external providers. For the\npurposes of this discussion, we assume that some of the more \u2018general purpose\u2019\nservices needed are readily available from external sources.\n", "page": 318, "type": "text", "section": "Page 318"}
{"text": "302\nSoftware Design: Creating Solutions for Ill-Structured Problems\nSoftware service implementation for the CCC?\nWe can model the customer\u2019s use of the CCC as being provided by\na set of distinct user-facing services: seeking available cars; making a\nreservation; accessing the chosen car. However, all, or most, of these\nwill need to be provided by a \u2018bespoke\u2019 service provider since they are\nspeci\ufb01c to the needs of the CCC. Of course it is also possible that\nthis specialist service provision may be based within the CCC system.\nThere is no reason why \u2018local\u2019 and \u2018general\u2019 services should not be used\ntogether as long as they conform to the same service model. (Making\na reservation is more likely to be available as a general service.)\nThe backend functionality may well be able to use a number of ser-\nvices that are su\ufb03ciently widely used that it is likely that they can be\nprovided by multiple service providers. This may include such tasks\nas identifying where the cars are in the streets (GPS locations), as\nwell as for accounting and billing functions, with security clearly being\nimportant for the latter.\n16.4\nEmpirical knowledge about modular design\nThe diversity and emerging nature of the technologies covered in this chap-\nter pose something of a challenge for empirical studies. We have already identi-\n\ufb01ed the systematic mapping study by Vale et al. (2016) as looking at research\nactivities in CBSE. At time of writing, there is no obvious equivalent study\naddressing the use of software service technologies.\nKey take-home points about designing with components\nand services\nIf we view components and software services as being evolutionary stages\nin modular design of software, we can identify the following lessons about their\nuse.\nDesign models. Modular design can make use of many of the modelling\nforms already developed for object-oriented development, possibly aug-\nmented by forms such as DFDs where the \u2018\ufb02ow\u2019 nature of service models\nrequire such a form.\n", "page": 319, "type": "text", "section": "Page 319"}
{"text": "Designing with Components and Services\n303\nDesign by composition. The emphasis placed upon reuse means that the\nmain design activity is centred upon composition of pre-existing ele-\nments. This in turn changes many of the supporting activities, which\nnow involve such tasks as \ufb01nding modules, negotiating terms of use,\nand addressing the question of interfacing between modules from di\ufb00er-\nent sources.\nBusiness models. One reason for using modular forms is to be able to\nrapidly assemble software to meet business needs, particularly where\nthese may involve applying application-speci\ufb01c \u2018rules\u2019 to the way that\nfairly standard tasks are performed. So business modelling explicitly\nplays a much more important role in the use of these technologies than\nmay be the case for other forms.\n", "page": 320, "type": "text", "section": "Page 320"}
{"text": "Chapter 17\nHow Good Is My Design?\n17.1\nQuality assessment ...............................................\n306\n17.1.1\nThe \u2018ilities\u2019 ...............................................\n307\n17.1.2\nDesign metrics ...........................................\n308\n17.2\nReviews and walkthroughs .......................................\n311\n17.3\nRefactoring of designs ............................................\n313\n17.4\nEmpirical knowledge about quality assessment ..................\n313\nKey take-home points about assessing design quality ...........\n314\nAfter looking at di\ufb00erent ways of producing and describing design ideas in the\npreceding chapters of Part III, this chapter now considers some of the ways\nthat we can re\ufb02ect upon and assess the quality of a particular design.\nSo, why do we need to do this? Well, at the very beginning of this book,\nin explaining why software development was an example of an ill-structured\nproblem, and describing what this meant, there were two characteristics of\nISPs that were described there that are particularly relevant to this chapter.\n\u2022 There is no ultimate test for a solution to an ISP, by which the designer\nor design team can determine that they have produced a design model\nthat fully meets the customer\u2019s needs.\n\u2022 There is no stopping rule that enables the designer(s) to know that the\ncurrent version of the design model is as good as it is going to get and\nthat there is little point in re\ufb01ning it further.\nThese two characteristics are re\ufb02ected in much of the material covered in the\nthird part of this book. Whether considering plan-driven development, agile\ndevelopment, use of patterns or just plain opportunistic design activities, we\nhave no means of knowing when our design activities should stop. And while\nwe might cope with these characteristics by considering our goal to be one\nof satis\ufb01cing, by aiming to produce a design that is \u2018good enough\u2019, there are\nno readily available measures that can tell us whether or not that has been\nachieved either.\nThis chapter therefore takes a brief look at three (related) issues. Firstly,\nwe consider the question of what concepts and measures we might use to assess\ndesign quality. Secondly, we look at a technique that can be used to help make\nsuch an assessment. Thirdly, we brie\ufb02y describe what might we then do if it\nis obvious that changes are needed.\n305\n", "page": 322, "type": "text", "section": "Page 322"}
{"text": "306\nSoftware Design: Creating Solutions for Ill-Structured Problems\nIt is also worth putting the material of this chapter into perspective with\nregard to the material covered earlier in Chapter 5. There the aspect of concern\nwas more one of assessing what we might term the \u2018human and social\u2019 aspects\nof software design\u2014that is, examining the ways that people design things,\nand the manner in which end-users deploy the products. This chapter is more\nconcerned with the design models that form the outcomes of designing, and\nthe quality measures that can be employed to assess their form and structure.\nHence it has a more \u2018technology-centric\u2019 focus.\n17.1\nQuality assessment\nThe concept of quality is of course something of a subjective one. If a\ngroup of friends have enjoyed eating a curry together, they might still come\nout with quite di\ufb00erent opinions of its quality. One who only occasionally eats\nAsian food might consider it to have been very good; another who greatly\nlikes Asian food might think it was \u2018good but a bit bland\u2019; while a third who\ndoesn\u2019t really like spicy dishes may feel it wasn\u2019t to their taste. And of course,\nassuming that they are not actually eating this in Asia, yet another, who has\nextensive knowledge of Asian cookery, might consider it to have been rather\nbelow the standard to be expected in Asia. And at the same time, as all of\nthe group will have eaten everything that was put before them, the curry can\nbe considered to have satis\ufb01ced their needs.\nSo concepts of quality can have a strong contex-\ntual aspect, and also be di\ufb03cult to quantify (as in\nthe example of the curry).\nFor software design too, the issue of quality can\nbe di\ufb03cult to quantify. One approach is to employ\nsome quantitative measures (such as those used for\nobject-oriented design that were described in Chap-\nter 10) and then to interpret these within the con-\ntext and needs of a particular software development\nproject.\nSo, if we are to do that, our \ufb01rst question is to\ndetermine what constitutes characteristics that re-\n\ufb02ect \u2018good\u2019 quality in a design model? In Chapter 4 we identi\ufb01ed some design\nprinciples that are generally considered to characterise a good design.\n\u2022 Fitness for purpose. This comes as close as we can hope to providing\nthe ultimate test for an ISP, but of course, is not something that we can\neasily quantify or indeed, assess systematically.\n\u2022 Separation of concerns. This can be considered as providing an assess-\nment of the \u2018modular\u2019 organisation of a design.\n", "page": 323, "type": "text", "section": "Page 323"}
{"text": "How Good Is My Design?\n307\n\u2022 Minimum coupling. For any application, the di\ufb00erent elements need to\ninteract in order to perform the necessary tasks, and coupling determines\nhow they interact (statically and dynamically).\n\u2022 Maximum cohesion. Like coupling, the idea of cohesion re\ufb02ects our ex-\npectation that the compartmentalisation of the system elements provides\nelements that are relatively self-contained.\n\u2022 Information hiding. Relates to knowledge used by the application and\nhow this is shared between the elements, such that each element can\nonly access the knowledge that is relevant to its role.\nInformation hiding\nWhile these are important software design prin-\nciples, they very much embody ideas about how a de-\nsign model should be organised, strongly in\ufb02uenced\nby the idea that a design is likely to evolve and to\nbe adapted.\nA rather di\ufb00erent perspective, and one that is\nequally important, is to think about the role and\nfunctioning of an application. The group of quality\nfactors that we associate with this are often referred\nto as the ilities (because most of them end with \u2018il-\nity\u2019), and we brie\ufb02y consider some of these below.\n17.1.1\nThe \u2018ilities\u2019\nThere are many ilities, with the emphasis placed upon particular factors\nbeing dependent upon the purpose of the application being developed. Here,\nthe discussion is con\ufb01ned to a group that can be considered to be fairly widely\napplicable: reliability; e\ufb03ciency; maintainability; and usability. Other, rather\nmore specialised ones include: testability; portability; and reusability.\nReliability. This factor is essentially concerned with the dynamic charac-\nteristics of the eventual application, and so involves making predictions\nabout behavioural issues. From a design perspective, assessing this in-\nvolves determining whether the eventual application will be:\n\u2022 complete, in the sense of being able to react correctly to all combi-\nnations of events and system states;\n\u2022 consistent, in that its behaviour will be as expected and repeatable,\nregardless of how busy the application might be;\n\u2022 robust when faced with component failure or similar con\ufb02icts (this is\nusually referred to as being graceful degradation)\u2014for the example\nof the CCC, this might require that it copes with a situation where\nthe customer is unable to unlock the selected car, despite having\nthe correct code.\n", "page": 324, "type": "text", "section": "Page 324"}
{"text": "308\nSoftware Design: Creating Solutions for Ill-Structured Problems\nThis factor is a key one for safety-critical systems, which may use repli-\ncated hardware and software to minimise the risk of component failure,\nbut it is also important for those applications that have an element of\nuser interaction.\nE\ufb03ciency. This can be measured through an application\u2019s use of resources,\nparticularly where these need to be shared. Depending upon context,\nthe relevant resources may include processor time, storage, network use\netc., and this multi-variate aspect does make it di\ufb03cult to assess.\nThere are also trade-o\ufb00s involved between these. As an example,\neconomising on memory use might result in an increase on processor\nload. Where resources are constrained it can be important to try and\nmake some assessment of the likely e\ufb00ects of particular design choices,\nalthough \ufb01ne-tuning may be better left to the implementation phase.\nMaintainability. The lifetime of a software artifact, whether it be a compo-\nnent or an application or a platform will probably be quite long. Plan-\nning for possible change is therefore something that should in\ufb02uence\ndesign decisions.\nThis factor strongly re\ufb02ects the characteristic of separation of concerns.\nThe problem is to determine what the likely evolutionary pathways may\nbe. It may be important to be clear about the assumptions that an\napplication makes about its context and use, and to query these in the\nlight of di\ufb00erent possible scenarios of evolution.\nUsability. There are many things that can in\ufb02uence the usability of an arti-\nfact (Norman 2002). However, for software, the user-interaction, or HCI\n(Human Computer Interaction) elements tend to predominate and may\nwell in\ufb02uence other design decisions too. The set of measures provided\nby the cognitive dimensions framework is widely considered as being a\nuseful way of thinking about usability (Green & Petre 1996), and the\nconcept of interaction design has helped focus attention on the nature\nof software use (Sharp et al. 2019).\nThe cognitive dimensions framework can be considered as providing a set of\nqualitative measures that can be used to assess a design (not just from the\nHCI aspect either). We now look at ways in which we might use quantitative\nmeasures, and the forms that they might take.\n17.1.2\nDesign metrics\nUnfortunately, neither the general design characteristics nor the \u2018ilities\u2019\ncan be measured directly, which is where the use of quantitative software\nmetrics may assist by providing some surrogate measures. (Of course, we can\nuse qualitative metrics too, particularly for assessing such factors as usability,\nbut deriving values for these is apt to be quite a time-consuming task.)\n", "page": 325, "type": "text", "section": "Page 325"}
{"text": "How Good Is My Design?\n309\nWe encountered some examples of metrics in Chapter 10 and this may be\na useful place to examine their role and form a bit more fully. Measurement\nscience di\ufb00erentiates between an attribute, which we associate with some el-\nement (in this case, of design), and a metric, which will have a value in the\nform of a speci\ufb01c number and an associated unit of measurement. And for a\ngiven metric, as we say in Chapter 10, we need to have some form of counting\nrules that are applied in order to derive its value. Indeed, Fenton & Bieman\n(2014) have observed that \u201cmeasurement is concerned with capturing infor-\nmation about attributes of entities\u201d. So, our next need is to determine how\nideas about quality can use metrics and measurements.\nFigure 17.1 shows a simple view of the mapping that links quality concepts\nthrough to actual counts.\nCounts taken from\nrepresentations\nQuality factors\n(properties)\nMeasurable\ncharacteristic\nQuality criteria\nRole\nExamples\nQuality concepts\nAssociated\nsystem attributes\nMetric definition\n(counting rules)\nSeparation of\nconcerns;\nMaintainability;\nUsability\nModularity;\nCompleteness\nCoupling Between\nObjects (CBO);\nInformation Flow\nOperationalisation\nof metric\nCounting links;\nCounting objects;\netc.\nFIGURE 17.1: Linking quality concept to measurements\nUnfortunately, none of the mappings between the elements of this are par-\nticularly easy to de\ufb01ne. The desirable design characteristics are quite abstract,\nas are the attributes. Finding measures for an invisible and complex media\nsuch as software can be quite challenging, and so each of the things that we\ncan actually measure usually comes down to counting tokens. For code met-\nrics, the tokens are usually syntactic elements, for design metrics, they tend\nto be diagrammatical elements. So what we can count is not always what we\nwould like to be able to count! And of course, we are limited to counts of static\n", "page": 326, "type": "text", "section": "Page 326"}
{"text": "310\nSoftware Design: Creating Solutions for Ill-Structured Problems\nrelationships, although we know that software has quite important dynamic\nproperties.\nSo, counting the number of objects, components, sub-programs and the\ncoupling links between these is probably the best we can do when looking at\na design model. (We saw this in Chapter 10 when reviewing the Chidamber\nand Kemerer metrics.) Having relatively \u2018formal\u2019 models that are documented\nusing (say) UML notations may help, but quite a lot can be done just by\nlooking at sketches too. And there are other things that are related to the\ndesign model that can also be measured, such as the number of times the\ndesign of a particular sub-system of an application has been modi\ufb01ed.\nBefore discussing what we might do with such knowledge, it is worth noting\nthat there are two types of metric that are both commonly used in software\nengineering (Hughes 2000).\n\u2022 Actionable metrics are those that relate to things we can control. We can\nreact to the values obtained from using such a metric by making changes\nto our design. If we are counting the arguments of methods as part of\na metric, we can make changes if we \ufb01nd a particular method seem to\nhave too many arguments for its purpose. At a more abstract level, we\ncan make changes if we \ufb01nd that a particular class has particularly high\ncounts for coupling measures (when compared with the other classes in\nthe design model).\n\u2022 Informational metrics tell us about things that can be measured and that\nare important to us, but that we cannot in\ufb02uence directly. One example\nof this is \u2018module churn\u2019, which occurs where the number of revisions\nto the design (or code) of each module is counted over a period of time,\nand we observe that a particular element may have been modi\ufb01ed many\ntimes. This churn is a consequence of design activities, but usually we\nwouldn\u2019t want to use it to control them!\nMany design metrics fall into the category of actionable metrics, since after\nall, they are usually relating to an application that has yet to be built.\nAnd as a last point about metrics, we should note that complexity is not\nan attribute in its own right. It is incorrect to refer to the \u2018complexity of\nobject D\u2019, because there are many measures that might be applied to that\nobject. Rather, complexity can be viewed as a threshold value for a particular\nmeasure\u2014so that we consider anything above that value to be complex. As\nan example, we might argue that an object with more than (say) 12 external\nmethods will potentially be \u2018complex\u2019 to use, because the developers may need\nto keep checking which methods are the ones they need.\nAnd even then there are further pitfalls with the concept of complexity.\nSuch a threshold value is not absolute, it may di\ufb00er between applications and\ndesigns. And sometimes, a particular object will have a value that is above\nour chosen threshold value because of its role. The need to interpret the values\nof any metrics and decide whether or not they are appropriate, then leads us\non to our next topic.\n", "page": 327, "type": "text", "section": "Page 327"}
{"text": "How Good Is My Design?\n311\n17.2\nReviews and walkthroughs\nA technique that has proved itself useful in assessing design structure and\nlikely behaviour is the design review or walkthrough, also sometimes termed\nan inspection although that term is more commonly used when assessing code\nrather than designs. The use of reviews dates from very early in the evolution\nof software engineering (Fagan 1976), and a set of basic rules for conducting\ndesign reviews has been assembled from experience (Yourdon & Constantine\n1979, Weinberg & Freedman 1987, Parnas & Weiss 1987).\nThere are actually two forms of review that are in common use. The\ntechnical review is concerned with assessing the quality of a design, and is\nthe form of interest to us in this section. The management review addresses\nsuch issues as project deadlines and schedule. Indeed, one of the challenges of\nreview-driven agile approaches such as Scrum is keeping these issues distinct\n(and of course, they are not independent, which also needs to be recognised).\nTechnical reviews can include the\nuse of forms of \u2018mental execution\u2019 of\nthe design model with the aid of use\ncases and scenarios and so can help\nwith assessing dynamic attributes as\nwell as static ones. The sources cited\nabove provide some valuable guide-\nlines on how such reviews need to be\nconducted so as to meet their aims\nand not become diverted to issues that are more properly the domain of the\nmanagement review. (One reason why these guidelines remain relevant is that\nthey are really \u2018social\u2019 processes, and hence their e\ufb00ectiveness is unin\ufb02uenced\nby such factors as architectural style.) And it is important that the review\ndoes not become an assessment of the design team, rather than of the design\nitself.\nEven with the input of metric values, a design review cannot provide any\nwell-quanti\ufb01ed measures of \u2018quality\u2019. However, the review is where such con-\ncepts as complexity thresholds may be agreed (since there are no absolutes).\nWith their aid it can help to identify weaknesses in a design, or aspects that\nmight potentially form weaknesses as details are elaborated or when evolu-\ntionary changes occur in the future. It therefore provides a means of assessing\npotential technical debt. Of course we can rarely avoid having some technical\ndebts; what matters is how much we have and the form it takes. In particular,\nif carefully planned and organised (and recorded) a review brings together\nthose people who have both the domain knowledge and the technical knowl-\nedge to be able to make realistic projections from the available information\nabout the design model.\n", "page": 328, "type": "text", "section": "Page 328"}
{"text": "312\nSoftware Design: Creating Solutions for Ill-Structured Problems\nParnas & Weiss (1987) have suggested that there are eight requirements\nthat a \u2018good\u2019 design should meet.\n1. Well structured: being consistent with principles such as information-\nhiding and separation of concerns.\n2. Simple: to the extent of being \u2018as simple as possible, but no simpler\u2019.\n3. E\ufb03cient: providing functions that can be computed using the available\nresources.\n4. Adequate: su\ufb03cient to meet the stated requirements.\n5. Flexible: being able to accommodate likely changes in the requirements,\nhowever these are likely to arise.\n6. Practical: with module interfaces providing the required functionality,\nneither more nor less.\n7. Implementable: with current (and chosen) software and hardware tech-\nnologies.\n8. Standardised: using well-de\ufb01ned and familiar notation for any documen-\ntation.\nThe last point is particularly relevant given that as we have observed, designers\noften employ informal notations. However, the key issue is that any notations\nused should at least be readily explained and interpreted. A set of hand-drawn\nsequence diagrams may be su\ufb03cient to explore scenarios without the need to\nfollow exact UML syntax.\nA systematic review looking at the use of metrics by industry during agile\nsoftware development by Kupiainen, M\u00e4ntyl\u00e4 & Itkonen (2015) made some\nobservations of how such reviews could use metrics. In particular the review\nreinforced the view that the targets of measurement should be the product\nand the process, but not the people. They also observed the following.\n\u2022 Documentation produced by a project should not be the object of mea-\nsurement, and the focus of attention should be the product and its fea-\ntures.\n\u2022 Using metrics can be a positive motivator for a team, and can change\nthe way that people behave by determining the set of issues that they\npay attention to.\n\u2022 For agile development, teams used metrics in a similar way to how they\nwere employed with plan-driven projects, using them to support sprint\nand project planning, sprint and progress tracking, understanding and\nimproving quality, and \ufb01xing problems with software processes.\n", "page": 329, "type": "text", "section": "Page 329"}
{"text": "How Good Is My Design?\n313\nAn important ground-rule for a design review is that it should concentrate\non reviewing the design and not attempt to \ufb01x any issues that are identi\ufb01ed.\nIn the next section we therefore look at what we might do next, following a\nreview.\n17.3\nRefactoring of designs\nThe idea of refactoring was introduced in Section 14.7, and as explained\nin Section 15.4, the need to perform refactoring is often motivated by the\npresence of code smells (Fowler 1999). The discussion in both of these sections\nwas focused largely upon code, rather than design, as this is often where\nthe relevant structural weaknesses are identi\ufb01ed. However, many of the code\nsmells originate in design weaknesses and there is scope to identify their likely\npresence during a design review. Of course, this isn\u2019t always the case, and the\nidea of code duplication is an obvious example of a problem that is less likely\nto be identi\ufb01ed during design.\nRefactoring can occur before that though, based upon the design model,\nand is one way of addressing the issues identi\ufb01ed in a design review. Clearly,\nsome issues such as those associated with duplication are unlikely to be \ufb02ushed\nout by a review. However, the need for redistribution of functionality across\ndesign elements (objects, components) and reorganisation of communication\nmodels are possible outcomes, along with the possible creation of new design\nelements.\nWhat this points to is the need to document and record the outcomes\nof a review with care. One possible option here is to use video-recording,\nwith the agreement of all participants, so that issues do not get lost and any\nwhiteboard-based discussions are captured. And of course, after a post-review\nrefactoring of the design (if such changes are necessary), it may be useful to\nrepeat the review, or part of it, using the same review team.\n17.4\nEmpirical knowledge about quality assessment\nEmpirical studies that are relevant to this chapter are chie\ufb02y those look-\ning at the use of metrics in assessing quality as well as those examining the\ne\ufb00ectiveness of code reviews and ways of improving their e\ufb03ciency. (Design\nreviews do not appear to have been very extensively studied, perhaps because\nof the di\ufb03culty of \ufb01nding enough experienced participants.) Earlier we men-\ntioned the systematic review by Kupiainen et al. (2015) and its \ufb01ndings. Here\n", "page": 330, "type": "text", "section": "Page 330"}
{"text": "314\nSoftware Design: Creating Solutions for Ill-Structured Problems\nwe identify a small number of further studies that use di\ufb00erent approaches for\nthe purpose of evaluation.\nSoftware metrics can be used inappropriately as well as being a useful tool,\nand before adopting any metrics it may well be worth reading the book by\nFenton & Bieman (2014) and the invited review paper by Kitchenham (2010).\nAnother interesting study is that by Jabangwe, Borstler, Smite & Wohlin\n(2015) which looks at the link between object-oriented metrics and quality\nattributes. Reinforcing our observations about OO metrics in Chapter 10,\nthis review did note that measures for complexity, cohesion, coupling and size\ncorresponded better with reliability and maintainability than the inheritance\nmeasures.\nThe study reported in Bosu, Greiler & Bird (2015) is based on interviews\nwith sta\ufb00at Microsoft and provides some useful recommendations for improv-\ning the practice of reviews. The e\ufb00ect of using light-weight tool-based review\npractices is reviewed in McIntosh, Kamei, Adams & Hassan (2016) using three\nlarge open-source repositories in a case study design. Again, the \ufb01ndings of\nthis study reinforce the value of well-conducted reviews.\nKey take-home points about assessing design quality\nAssessing design quality poses some challenges, not least because our inter-\npretation of quality may be in\ufb02uenced by such factors as domain, technologies\netc. However, there are some useful general points worth making here.\nQuality measures. A design will have many di\ufb00erent quality attributes,\nusually related to the ilities, and with the emphasis placed on each\nattribute being largely dependent upon the nature of the application.\nMetrics that directly measure features that are directly related to these\nattributes are generally impractical and it may be necessary for a team\nto decide on their own counting rules when making measurements re-\nlated to a design model.\nDesign reviews. The use of formal or informal design reviews provides an\nopportunity to make project-speci\ufb01c interpretation of any metric values\nobtained, as well as to assess the general structure of a design model. It\nis important that the outcomes from a review are carefully recorded.\nDesign refactoring. This can be performed as part of the outcome from\na review, but there is little guidance available about how to perform\nrefactoring at the design level.\n", "page": 331, "type": "text", "section": "Page 331"}
{"text": "Chapter 18\nAnd What About...\n18.1\nOpen source software (OSS) .....................................\n315\n18.2\nFormal description techniques (FDTs) ...........................\n317\n18.3\nModel driven engineering (MDE) ................................\n321\n18.4\nAnd the rest. . .\n..................................................\n322\nThis last chapter provides a brief summary of some of the topics that this\nbook does not cover. These are some quite important in\ufb02uences upon software\ndesign that either don\u2019t really \ufb01t into the narrative of this book, or that don\u2019t\ncontribute quite enough to the theme of emerging software design knowledge\nto be included. And inevitably, there will also be some topics that don\u2019t appear\nhere that others may feel should do.\nThe structure of this chapter is a little di\ufb00erent too, in that the discussion\nof empirical knowledge is embedded in the sections, rather than appearing\nin a separate section. There is also no \ufb01nal \u2018take home\u2019 section, since the\ndescriptions are really too short to merit this.\n18.1\nOpen source software (OSS)\nThis has had occasional mention in the preceding chapters. One descrip-\ntion for the way that open source software (OSS) is developed is that this is a\nreactive development process, whereby a particular application evolves largely\nin response to what its developers perceive as being needed. It can also be\nviewed as being a form of incremental development. Either way, it has be-\ncome a major source of software that is used worldwide for an ever-increasing\nnumber of applications. For most users, the most important characteristic is\nusually that it is free to download and use, but for some the availability of the\nsource code and the freedom to change it opens up important opportunities.\nThe rami\ufb01cations of OSS can be somewhat theological in nature, but most\nwould consider that its roots lie back in the pioneering work of Richard Stall-\nman\u2019s Free Software Foundation and the GNU project (a recursive de\ufb01ni-\ntion of GNU is \u2018GNU\u2019s Not Unix\u2019!). Two factors accelerated its emergence\nin the 1990s: one was when the Linux operating system kernel came together\nwith GNU to provide a widely distributed free operating system for personal\n315\n", "page": 332, "type": "text", "section": "Page 332"}
{"text": "316\nSoftware Design: Creating Solutions for Ill-Structured Problems\ncomputers; and the other was the emergence of the world-wide web as a plat-\nform for ready distribution and downloading of software applications. The\nestablishment of the sourceforge1 web site as a trusted platform for hosting\nand distributing open source software has also provided an important element\nof con\ufb01dence for users.\nOur interest here however, does not lie in the complexities and philosophies\nof OSS de\ufb01nitions, licensing etc., or in the ever-growing corpus of widely used\napplications, but in the way that such software is developed. A relatively early\nstudy by Wu & Lin (2001) suggested that while the development process\nusually adopted by OSS projects was incremental, it also took a form that\nwas very di\ufb00erent to the way that this type of development process was used\nin more \u2018conventional\u2019 development practices. In particular, they observed\nthat projects could work in a great variety of ways, ranging from the use of\nhighly democratic processes for making decisions through to a \u2018dictatorship\u2019\nmodel.\nThe key characteristic that they identi\ufb01ed lay in the organisation of the de-\nvelopment process, and particularly the massive coordination e\ufb00ort required,\nrather than in the development steps themselves. Instead of the ideas from\na small number of decision-makers (designers) directing the e\ufb00orts of many\ndevelopers, the open source model involves one or a team of co-ordinators\ndrawing together the ideas of many participants. Inevitably, simple model\ndoes not come near to describing all of the variations. Many projects have\nbegun with a single developer (as did Linux) and it was the later extension\nand evolution that was in\ufb02uenced by the many.\nOSS development tends to make exten-\nsive use of code reviews, although because\nteams may well be globally distributed, these\nare not necessarily in the form described in\nChapter 17. OSS projects can also demon-\nstrate quite complex social structures that\ngo well beyond the relatively simple forms\noutlined above. And joining such a project\ncan be a complex process in terms of the\ngroup dynamics involved, as is illustrated by\nthe systematic review reported by (Steinmacher et al. 2015).\nWith the potential to involve so many contributors, open source develop-\nment requires quite comprehensive support for change management (examples\nof tools include git and subversion, but new ones continue to emerge). The\ncomprehensive and detailed records related to open source projects readily\navailable from these code management systems makes them a valuable re-\nsource for empirical studies. However, the use of OSS data may also form a\nsource of bias for their \ufb01ndings where these relate to the processes involved\nin design and development.\n1www.sourceforge.net\n", "page": 333, "type": "text", "section": "Page 333"}
{"text": "And What About...\n317\nSo, in terms of contribution to design knowledge, OSS has broadened our\nunderstanding of how to organise potentially large and distributed teams, as\nwell as encouraging automation of change records. It has certainly demon-\nstrated the bene\ufb01ts of having many pairs of eyes scrutinising design ideas\ntoo.\n18.2\nFormal description techniques (FDTs)\nThe notations discussed in the previous chapters have largely been both\ndiagrammatical and systematic, with most of them lacking formal mathemat-\nical underpinning (the main exception being the statechart). And as noted,\nthe advantage of diagrams is that they can be easily modi\ufb01ed and can be used\ninformally\u2014re\ufb02ecting the way that many designers work.\nWhile informal syntax and semantics may be useful when exploring ways\nof addressing an ISP, the lack of rigour can present problems for such tasks as\nveri\ufb01cation. And for design problems that fall into such categories as safety-\ncritical, or that are concerned with \ufb01nancial transactions, an inability to for-\nmally and rigorously check for correctness and completeness is a signi\ufb01cant\ndisadvantage. Most of us, when travelling on an aircraft that is using \u2018\ufb02y\nby wire\u2019 technology to manage the control surfaces, would like to think that\nthe software used for this purpose had undergone very thorough and com-\nprehensive examination and assessment to ensure correct functioning in all\nsituations!\nFrom the early days of software engineering, researchers have therefore\ntried to harness the powers of mathematical notation to aid with modelling\nsuch activities as software speci\ufb01cation, design and testing. Unfortunately,\nwhile mathematical rigour may be achievable when solving many forms of\nWSP, the characteristics of ISPs make it di\ufb03cult to employ mathematical\nreasoning very widely, particularly in a context that exhibits the combined\ncharacteristics of ISPs and of software that we discussed in Chapter 1. So\nalthough the resulting formal description techniques (FDTs) are sometimes\nreferred to as formal methods, in practice they tend to have very powerful\nrepresentation parts while providing very little guidance on how to use them\nfor design.\nWhile FDTs can be used almost anywhere in the software development\nprocess and life-cycle, the roles for which they are particularly well suited are:\n\u2022 specifying system properties for requirements speci\ufb01cation (black box) ;\nand\n\u2022 specifying the detailed form of a design model in the detailed design\nstages (white box).\n", "page": 334, "type": "text", "section": "Page 334"}
{"text": "318\nSoftware Design: Creating Solutions for Ill-Structured Problems\nIn addition, their use does require some mathematical training and the\namount of time needed for their use may create a substantial overhead, even\nwith the support of tools. The variety of notations used, and their relative\nunfamiliarity, may also have made them less attractive to project managers.\nIncorporating ideas about software architecture has also proved to be chal-\nlenging.\nIn a fairly early study of their use, Hall (1990) observed that, despite\nvarious limitations upon how and where they could be deployed, FDTs had\nbeen used on a reasonably large number of real projects, particularly those\nwith safety-critical features. However, they also seemed to have been most\nsuccessful when used on key elements of applications, rather than when being\nused to develop the complete application.\nLittle seems to have changed since then. FDTs have become part of the\nsoftware engineer\u2019s toolbox, albeit a rather specialised part, to be used as and\nwhen appropriate. Researchers have also emphasised the use of \u2018lightweight\u2019\nforms, seeking to use the power of mathematics where it can be most use-\nful. However, there is little evidence that industry has embraced their use\nvery widely, and indeed, they do sit awkwardly alongside ideas such as agile\ndevelopment.\nThis section provides a very brief introduction to one of the best-known\nmodel-based speci\ufb01cation forms, the Z language (pronounced as \u2018zed\u2019). When\ncreating a model-based speci\ufb01cation, the speci\ufb01er uses various mathematical\nforms to construct a \u2018model\u2019 of the application and then uses this to help\nreason about its properties and behaviour.\nZ was created by J-R Abrial in the Programming Research Group at the\nUniversity of Oxford, underwent major development in the 1980s, becoming\nestablished in the 1990s. The text by Spivey (1998) is widely regarded as\nproviding the authoritative de\ufb01nition, but many other, more introductory,\ntexts are also available. An \u2018object\u2019 version of the formalism is described in\nSmith (2000).\nZ exhibits an unfortunate characteristic that typi\ufb01es many formal speci-\n\ufb01cation forms, which is the use of mathematical symbols that are not easily\nreproduced in everyday typefaces. (In fairness, most are quite easily drawn on\na whiteboard.) The only real process involved in its use is one of re\ufb01nement.\nThe basic vocabulary of Z is based upon three elements: sets, set operations\nand logic, each with their own notational features.\nSets. A set is a collection of elements (or set members), in which no sense\nof ordering of elements is involved. In Z, there are some pre-de\ufb01ned set\ntypes, such as Z, the set of all integers; and N, the set of all natural\nnumbers (positive integers and zero). In addition, the user may specify\ntheir own set types, and for many problems is likely to want to do so.\nThe convention is to employ all upper case italic letters for the identi\ufb01er\nof a set type, with set members being described in text or enumerated.\n", "page": 335, "type": "text", "section": "Page 335"}
{"text": "And What About...\n319\nExamples are:\n[CCCCARS]the set of all cars available for use by CCC members\n[RUNWAY ] ::== main | north | west\nThe \ufb01rst example is self-evident, while the second tells us that an airport\nhas three runways. As in this example, the variables are in lower case.\nSet operations. These are largely as would be expected. Two that may be\nless familiar are the use of # that returns the number of elements in the\nset, and P for the powerset of a set (the set of all subsets of that set).\nLogic. Operations and relations in a speci\ufb01cation are usually expressed by\nusing the standard operators of predicate logic. The logical operators\ncan then be combined with the set elements and used to describe char-\nacteristic rules a\ufb00ecting a set, usually in the general form of:\ndeclaration | predicate \u2022 expression\nwhere the declaration introduces the variables of concern to the rule;\nthe predicate constrains their values; and the expression describes the\nresulting set of values.\nA key component of Z is the schema. The role of this is to describe a system\noperation, and it is usually drawn as an open box that has three elements:\n\u2022 the schema name;\n\u2022 the signature, that introduces any variables and assigns them to set\ntheoretic types;\n\u2022 the predicates that form the state invariants, describing how the elements\nof the signature are related and constrain the operation, and that are\ndescribed in terms of preconditions and postconditions.\nA very simple example of a schema that is related to the activities of the CCC\nis provided below.\nReserveCar\ndrivers, drivers\u2032 : P CCCMEMBER\nd? : CCCMEMBER\n#drivers < #CCCCARS\nd? /\n\u2208drivers\ndrivers\u2032 = drivers \u222a{d?}\n#drivers\u2032 \u2264#CCCCARS\nHere, the elements used are:\n", "page": 336, "type": "text", "section": "Page 336"}
{"text": "320\nSoftware Design: Creating Solutions for Ill-Structured Problems\n\u2022 the name of the schema, which is ReserveCar;\n\u2022 the signature that describes the \u2018before\u2019 and \u2018after\u2019 states of the set of\ndrivers (CCC members who are currently using a CCC car), with the\nconvention being that the primed identi\ufb01er denotes the state of the set\nafter the operation; while the variable d? is a variable used for an input\nthat is required as part of the schema;\n\u2022 the predicate describes the operations required to reserve a car, which\nare as follows:\n\u2013 \ufb01rstly, the number of drivers should be fewer than the number of\ncars available (precondition 1);\n\u2013 the new driver should not already be driving a car (and hence is\nnot in the set of existing drivers) (precondition 2);\n\u2013 the new set of drivers will be comprised of the original set together\nwith the new driver (postcondition 1);\n\u2013 the number of drivers after the operation must now be either less\nthan the number of available cars, or equal to it (postcondition 2)\nOne advantage of this type of formal speci\ufb01cation is that we can readily reason\nabout it, and clearly there are some shortcomings we can identify fairly quickly.\nIn particular, the set of cars implicitly includes all of the cars available at the\nsite. But of course, some may be unavailable for other reasons, such as being\nserviced, and so we should probably use a subset of \u2018active\u2019 cars, together with\nanother schema that keeps that subset up to date.\nFrom a design perspective, Z probably does not particularly assist with\nthe problems of producing a design solution for an ISP, beyond helping to\nmanage completeness and consistency. In many ways it can make more of a\ncontribution to the issue of clarifying the needs that an application needs to\nmeet (that is, the speci\ufb01cation). One of the characteristics of an ISP is the\nlack of a de\ufb01nitive speci\ufb01cation, and while Z might not be able to address all\nthe aspects of that lack, it can help with clari\ufb01cation.\nFew empirical studies appear to have been performed on the use of FDTs,\nparticularly with regard to their use in industry. This in turn makes it di\ufb03cult\nto assess what features of their use are particularly valued by those who adopt\nthem. However, the survey of use reported in Woodcock, Larsen, Bicarregui\n& Fitzgerald (2009) does provide some interesting illustrations of the use of\nformal techniques in industry as well as reviewing the domains where there\nhas been adoption. As might be expected, many of the examples do fall into\nwhat might be termed as domains requiring \u2018high-integrity software\u2019.\n", "page": 337, "type": "text", "section": "Page 337"}
{"text": "And What About...\n321\n18.3\nModel driven engineering (MDE)\nModel-driven engineering (MDE) shares some characteristics with the\nFDTs discussed in the previous section. In particular, it would seem that\na condition for successful adoption may well be for it to contribute to part of\na project, rather than be used for the whole of it.\nIn Part II of this book, we focused strongly on the issue of producing\ndesign models, whether these were relatively informal ones, largely based on\nsketches, or more formalised, such as those using the UML notations. MDE is\nfocused on making use of such models for automating various tasks, such\nas the generation of code, but also such issues as evolution and testing.\nAs noted by Schmidt (2006) MDE has built upon\nearlier technologies, such as CASE (Computer As-\nsisted Software Engineering), and in the process has\nmoved from using more generalised tools to more\nspecialised ones such as domain-speci\ufb01c modelling\nlanguages (DSMLs), and generators that can create\nsource code or simulations, observing that:\n\u201cinstead\nof\ngeneral-purpose\nnotations\nthat rarely express application domain\nconcepts and design intent, DSMLs can\nbe tailored via metamodeling to precisely\nmatch the domains semantics and syn-\ntax\u201d\nMDE can also be employed with the UML as the modelling language, and the\nOMG (Object Management Group) provides and supports standards for this.\nThe use of MDE does appear to have been the subject of more critical\nanalysis than FDTs, with examples such as the relatively early systematic\nreview from Mohagheghi & Dehlen (2008), looking at the use of MDE in\nindustry. At that point in time they did note the lack of suitably mature tools,\nand observed that they found \u201creports of improvements in software quality\nand of both productivity gains and losses, but these reports were mainly from\nsmall-scale studies\u201d.\nA later survey by Whittle, Hutchinson & Rounce\ufb01eld (2014) found quite\nwidespread use of MDE, and observes that \u201cmany of the lessons point to the\nfact that social and organisational factors are at least as important in deter-\nmining success as technical ones\u201d. They also note that: \u201cthe companies who\nsuccessfully applied MDE largely did so by creating or using languages speci\ufb01-\ncally developed for their domain, rather than using general-purpose languages\nsuch as UML\u201d. An interesting conclusion is that the real bene\ufb01ts to a company\ndidn\u2019t stem from things like code generation but \u201cin the support that MDE\n", "page": 338, "type": "text", "section": "Page 338"}
{"text": "322\nSoftware Design: Creating Solutions for Ill-Structured Problems\nprovides in documenting a good software architecture\u201d. One of the tips that\nthey o\ufb00er for successful use of MDE is to \u201ckeep domains tight and narrow\u201d,\nsuggesting that it is easier to create DSMLs for \u201cnarrow, tight domains\u201d,\nrather than attempting to use MDE for broad areas of application. (There\nare some parallels with FDTs here, where success seems to have often been\nassociated with quite narrow (but important) domains such as telecoms.)\nAnd, where Moody (2009) criticises the visual aspects of the UML, from\nan MDE perspective Whittle et al. (2014) observe that:\n\u201cUML 2.0, for example, a major revision of the UML standard,\ndidn\u2019t re\ufb02ect the literature on empirical studies of software mod-\nelling or software design studies. Consequently, current approaches\nforce developers and organisations to operate in a way that \ufb01ts the\napproach instead of making the approach \ufb01t the people.\u201d\nSo from the perspective of this book, MDE does have some bene\ufb01ts when\nused appropriately, particularly with regard to helping with understanding\nand development of architectural features. Rather as FDTs require some fa-\nmiliarity with mathematical formalisms, successful use of MDE does need\ndomain knowledge, but it is interesting to note that Whittle et al. (2014) also\nobserve that the models themselves need not necessarily be formal ones, at\nleast in the early stages of developing a design.\n18.4\nAnd the rest. . .\nThis book began with a discussion of the challenges posed by ill-structured\nproblems such as those encountered during software development. The focus\nthroughout this edition has been on the contribution that di\ufb00erent techniques\nand forms make to addressing these challenges. And not only do ISPs have no\nstopping rule, a book like this doesn\u2019t either. There are many more approaches\nto modelling and designing software than those covered in the existing chap-\nters, and many variations that arise too.\nThis last chapter has looked brie\ufb02y at a small selection of some of the other\ntechniques that software engineers have devised for modelling and designing\nsoftware, over and above those covered in the main chapters. If your favourite\ntechnique has been omitted or overlooked, my apologies.\nAnd of course, vast numbers of software systems are developed without\nmaking use of formal modelling or of any form of systematic design process\n(not that these are always developed well of course). What matters though\nis that anyone seeking to design software applications should have a good\nunderstanding of the medium and of the purposes of the application they\n", "page": 339, "type": "text", "section": "Page 339"}
{"text": "And What About...\n323\nare developing. And acquiring the relevant knowledge schema needs an un-\nderstanding of the topics covered here, regardless of how they are eventually\nemployed. . .\n", "page": 340, "type": "text", "section": "Page 340"}
{"text": "Bibliography\nAdelson, B. & Soloway, E. (1985), \u2018The role of domain experience in software\ndesign\u2019, IEEE Transactions on Software Engineering 11(11), 1351\u20131360.\nAkin, O. (1990), \u2018Necessary conditions for design expertise and creativity\u2019,\nDesign Studies 11(2), 107\u2013113.\nAlexander, C., Ishikawa, S., Silverstein, M., Jacobson, M., Fiksdahl-King, I.\n& Angel, S. (1977), A Pattern Language, Oxford University Press.\nAli, M. S., Babar, M. A., Chen, L. & Stol, K.-J. (2010), \u2018A systematic review\nof comparative evidence of aspect-oriented programming\u2019, Information\nand Software Technology 52(9), 871 \u2013 887.\nAllman, E. (2012), \u2018Managing technical debt\u2019, Commun. ACM 55(5), 50\u201355.\nURL: http://doi.acm.org/10.1145/2160718.2160733\nAnjum, M. & Budgen, D. (2012), A mapping study of the de\ufb01nitions used\nfor Service Oriented Architecture, in \u2018Proceedings of EASE 2012\u2019, IET\nPress, pp. 57\u201361.\nAnjum, M. & Budgen, D. (2017), \u2018An investigation of modelling and design\nfor software service applications\u2019, PLoS ONE 12(5), e0176936.\nArlow, J. & Neustadt, I. (2005), UML 2 and the Uni\ufb01ed Process: Practical\nObject-Oriented Analysis and Design, 2nd edn, Addison-Wesley.\nAvison, D. E. & Fitzgerald, G. (1995), Information Systems Development:\nMethodologies, Techniques and Tools, 2nd edn, McGraw-Hill.\nBailey, J., Budgen, D., Turner, M., Kitchenham, B., Brereton, P. & Linkman,\nS. (2007), Evidence relating to Object-Oriented software design: A survey,\nin \u2018Proceedings of First International Symposium on Empirical Software\nEngineering and Measurement (ESEM)\u2019, pp. 482\u2013484.\nBano, M. & Zowghi, D. (2015), \u2018A systematic review on the relationship\nbetween user involvement and system success\u2019, Information & Software\nTechnology 58(148-169).\nBarrow, P. D. M. & Mayhew, P. J. (2000), \u2018Investigating principles of stake-\nholder evaluation in a modern (is) development approach\u2019, Journal of\nSystems & Software 52(2-3), 95\u2013103.\n325\n", "page": 342, "type": "text", "section": "Page 342"}
{"text": "326\nBibliography\nBass, L., Clements, P. & Kazman, R. (2013), Software Architecture in Practice,\n3rd edn, Pearson.\nBates, B., Sierra, K., Freeman, E. & Robson, E. (2009), Head First Design\nPatterns, O\u2019Reilly.\nBeck, K. (2000), Extreme Programming Explained: Embrace Change, Addison-\nWesley.\nBeck, K. & Cunningham, W. (1989), \u2018A laboratory for teaching object-oriented\nthinking\u2019, ACM SIGPLAN Notices 24(10), 1\u20136.\nBennett, K. H. & Rajlich, V. T. (2000), Software maintenance and evolution:\nA roadmap, in \u2018Proceedings of the Conference on the Future of Software\nEngineering\u2019, ICSE \u201900, ACM, New York, NY, USA, pp. 73\u201387.\nURL: http://doi.acm.org/10.1145/336512.336534\nBennett, K., Layzell, P., Budgen, D., Brereton, P., Macaulay, L. & Munro,\nM. (2000), Service-based software: The future for \ufb02exible software, in\n\u2018Proceedings of Seventh Asia-Paci\ufb01c Software Engineering Conference\u2019,\nIEEE Computer Society Press, pp. 214\u2013221.\nBlackwell, A. & Green, T. (2003), Notational systems\u2014the cognitive dimen-\nsions of notations framework, in J. M. Carroll, ed., \u2018HCI Models, Theo-\nries, and Frameworks: Toward a Multidisciplinary Science\u2019, Morgan Kauf-\nman, chapter 5.\nBoehm, B. W. (1981), Software Engineering Economics, Prentice-Hall.\nBoehm, B. W. (1988), \u2018A spiral model of software development and enhance-\nment\u2019, IEEE Computer 21(5), 61\u201372.\nBoehm, B. W. (2002), \u2018Get ready for agile methods, with care\u2019, IEEE Com-\nputer 35(1).\nBooch, G. (1994), Object-Oriented Analysis and Design with Applications, 2nd\nedn, Benjamin Cummings.\nBosu, A., Greiler, M. & Bird, C. (2015), Characteristics of useful code reviews:\nAn empirical study at Microsoft, in \u201812th IEEE/ACM Working Confer-\nence on Mining Software Repositories\u2019, IEEE Computer Society Press,\npp. 1\u201311.\nBreivold, H. P., Crnkovic, I. & Larsson, M. (2012), \u2018A systematic review of\nsoftware architecture evolution research\u2019, Information & Software Tech-\nnology 54, 16\u201340.\nBrereton, P. & Budgen, D. (2000), \u2018Component based systems: A classi\ufb01cation\nof issues\u2019, IEEE Computer 33(11), 54\u201362.\n", "page": 343, "type": "text", "section": "Page 343"}
{"text": "Bibliography\n327\nBrooks, F. P. (1987), \u2018No silver bullet: Essences and accidents of software\nengineering\u2019, IEEE Computer 20(4), 10\u201319.\nBrooks, F. P. (1988), Grasping reality through illusion \u2013 interactive graphics\nserving science, in \u2018Proceedings of the ACM SIGCHI Conference\u2019, pp. 1\u2013\n11.\nBrown, A. W. (2000), Large-Scale Component-Based Development, Prentice-\nHall.\nBrown, A. W. & Short, K. (1997), On components and objects: the foundations\nof component-based development, in \u2018Proceedings of 5th International\nSymposium on Assessment of Software Tools and Technologies\u2019, IEEE\nComputer Society Press, pp. 112\u2013121.\nBrown, A. W. & Wallnau, K. C. (1998), \u2018The current state of cbse\u2019, IEEE\nSoftware 15(5), 37\u201346.\nBrown, W. J., Malveau, R. C., McCormick, H. W. & Mowbray, T. J. (1998),\nAntipatterns: Refactoring Software, Architectures, and Projects in Crisis,\nWiley.\nBudgen, D. (2014), Software Designers in Action: A Human-Centric Look at\nDesign Work, Chapman & Hall, chapter 12.\nBudgen, D., Brereton, P., Drummond, S. & Williams, N. (2018), \u2018Reporting\nsystematic reviews: Some lessons from a tertiary study\u2019, Information and\nSoftware Technology 95, 62 \u2013 74.\nBudgen, D., Brereton, P. & Turner, M. (2004), Codifying a Service Archi-\ntectural Style, in \u2018Proceedings 28th International Computer Software &\nApplications Conference - COMPSAC\u2019, IEEE Computer Society Press,\npp. 16\u201322.\nBudgen, D., Brereton, P., Williams, N. & Drummond, S. (2018), \u2018The contri-\nbution that empirical studies performed in industry make to the \ufb01ndings\nof systematic reviews: A tertiary study\u2019, Information and Software Tech-\nnology 94, 234 \u2013 244.\nBudgen, D., Brereton, P., Williams, N. & Drummond, S. (2020), \u2018What sup-\nport do systematic reviews provide for evidence-informed teaching about\nsoftware engineering practice?\u2019, e-Informatica 14(1), 7\u201360.\nBudgen, D., Burn, A., Brereton, P., Kitchenham, B. & Pretorius, R. (2011),\n\u2018Empirical evidence about the UML: A systematic literature review\u2019, Soft-\nware \u2014 Practice and Experience 41(4), 363\u2013392.\nBuschmann, F., Meunier, R., Rohnert, H., Sommerlad, P. & Stal, M. (1996),\nPattern-Oriented Software Architecture, Wiley.\n", "page": 344, "type": "text", "section": "Page 344"}
{"text": "328\nBibliography\nCarney, D. & Long, F. (2000), \u2018What do you mean by COTS? Finally, a useful\nanswer\u2019, IEEE Software 17(2), 83\u201386.\nChen, J., Xiao, J., Wang, Q., Osterweil, L. J. & Li, M. (2016), \u2018Perspectives on\nrefactoring planning and practice: An empirical study\u2019, Empirical Soft-\nware Engineering 21, 1397\u20131436.\nChen, P. P. (1976), \u2018The entity-relationship model: Toward a uni\ufb01ed view of\ndata\u2019, ACM Transactions on Database Systems 1(1), 9\u201337.\nChidamber, S. R. & Kemerer, C. F. (1994), \u2018A metrics suite for object oriented\ndesign\u2019, IEEE Transactions on Software Engineering 20(6), 476\u2013493.\nColeman, D., Arnold, P., Bodo\ufb00, S., Dollin, C., Gilchrist, H., Hayes, F. &\nJeremes, P. (1994), Object-Oriented Development: The Fusion Method,\nPrentice-Hall.\nConnor, D. (1985), Information System Speci\ufb01cation and Design Road Map,\nPrentice-Hall.\nCooke, P. (1984), \u2018Electronic design warning\u2019, Engineering Design 9(6), 8.\nCoplien, J. O. (1997), \u2018Idioms and patterns as architectural literature\u2019, IEEE\nSoftware 14(1), 36\u201342.\nCrnkovic, I. & Larsson, M. (2002), \u2018Challenges of component-based develop-\nment\u2019, Journal of Systems & Software 61(3), 201\u2013212.\nCrnkovic, I., Sta\ufb00ord, J. & Szyperski, C. (2011), \u2018Software components beyond\nprogramming: From routines to services\u2019, IEEE Software 28(3), 22\u201326.\nCunningham, W. (1992), The WyCash portfolio management system, in \u2018Ad-\ndendum to the Proceedings on Object-oriented Programming Systems,\nLanguages, and Applications (Addendum)\u2019, OOPSLA \u201992, ACM, New\nYork, NY, USA, pp. 29\u201330.\nCurtis, B., Krasner, H. & Iscoe, N. (1988), \u2018A \ufb01eld study of the software design\nprocess for large systems\u2019, Communications of the ACM 31(11), 1268\u2013\n1287.\nCurtis, B. & Walz, D. (1990), The psychology of programming in the large:\nTeam and organizational behaviour, in \u2018Psychology of Programming\u2019,\nAcademic Press, pp. 253\u2013270.\nCusumano, M. A. & Selby, R. W. (1989), \u2018How Microsoft builds software\u2019,\nCommunications of the ACM 40(6), 53\u201361.\nDe Marco, T. (1978), Structured Analysis and System Speci\ufb01cation, Yourdon\nPress.\n", "page": 345, "type": "text", "section": "Page 345"}
{"text": "Bibliography\n329\nD\u00e9tienne, F. (2002), Software Design \u2013 Cognitive Aspects, Springer Practi-\ntioner Series.\nDiebold, P. & Dahlem, M. (2014), Agile practices in practice\u2014a mapping\nstudy, in \u2018Proceedings 18th Conference on Evaluation & Assessment in\nSoftware Engineering (EASE 2017)\u2019, ACM Press.\nDyb\u00e5, T. & Dings\u00f8yr, T. (2008), \u2018Empirical studies of agile software develop-\nment: A systematic review\u2019, Information & Software Technology 50, 833\u2013\n859.\nEdwards, H. M., Thompson, J. B. & Smith, P. (1989), \u2018Results of survey of use\nof SSADM in commercial and government sectors in United Kingdom\u2019,\nInformation & Software Technology 31(1), 21\u201328.\nElbanna, A. & Sarker, S. (2016), \u2018The risks of agile software development:\nLearning from adopters\u2019, IEEE Software 33(5), 72\u201379.\nEricsson, K. & Simon, H. (1993), Protocol Analysis: Verbal Reports as Data,\nMIT Press.\nErl, T. (2009), SOA Design Patterns, Prentice Hall.\nFagan, M. (1976), \u2018Advances in software inspections\u2019, IEEE Transactions on\nSoftware Engineering 12(7), 744\u2013751.\nFayad, M. E. & Schmidt, D. E. (1997), \u2018Object-oriented application frame-\nworks\u2019, Communications of the ACM 40(10), 32\u201338.\nFeitosa, D., Avgeriou, P., Ampatzoglou, A. & Nakagawa, E. Y. (2017), The\nevolution of design pattern grime: An industrial case study, in \u2018Proceed-\nings PROFES 2017 International Conference on Product-Focused Soft-\nware Process Improvement\u2019.\nFenton, N. E. & Bieman, J. M. (2014), Software Metrics: A Rigorous and\nPractical Approach, CRC Press.\nFichman, R. G. & Kemerer, C. F. (1997), \u2018Object technology and reuse:\nLessons from early adopters\u2019, IEEE Computer 30(10), 47\u201359.\nFink, A. (2003), The Survey Handbook, 2nd edn, Sage Books. Volume 1 of the\nSurvey Kit.\nFinkelstein, A., Kramer, J., Nuseibeh, B., Finkelstein, L. & Goedicke, M.\n(1992), \u2018Viewpoints: A framework for integrating multiple perspectives\nin system development\u2019, Int. Journal of Software Eng. and Knowledge\nEng. 2(1), 31\u201357.\nFloyd, C. (1984), A systematic look at prototyping, in R. Budde, K. Kuh-\nlenkamp, I. Mathiassen & H. Zullighoven, eds, \u2018Approaches to Prototyp-\ning\u2019, Springer-Verlag, pp. 1\u201318.\n", "page": 346, "type": "text", "section": "Page 346"}
{"text": "330\nBibliography\nFowler, M. (1999), Refactoring: Improving the Design of Existing Code,\nAddison-Wesley.\nGamma, E., Helm, R., Johnson, R. & Vlissides, J. (1995), Design Patterns:\nElements of Reusable Object-Oriented Software, Addison-Wesley.\nGane, C. & Sarsen, T. (1979), Structured Systems Analysis: Tools and Tech-\nniques, Prentice-Hall.\nGarlan, D., Allan, R. & Ockerbloom, J. (2009), \u2018Architectural mismatch: Why\nreuse is still so hard\u2019, IEEE Software 26(4), 66\u201369.\nGarlan, D., Allen, R. & Ockerbloom, J. (1995), \u2018Architectural mismatch: Why\nreuse is so hard\u2019, IEEE Software 12(6), 17\u201326.\nGarlan, D. & Perry, D. E. (1995), \u2018Introduction to the Special Issue on Soft-\nware Architecture\u2019, IEEE Transactions on Software Engineering 21, 269\u2013\n274.\nGreen, T. R. G. & Petre, M. (1996), \u2018Usability analysis of visual programming\nenvironments: A \u2018cognitive dimensions\u2019 framework\u2019, Journal of Visual\nLanguages and Computing 7, 131\u2013174.\nGuindon, R. & Curtis, B. (1988), Control of cognitive processes during soft-\nware design: What tools are needed?, in \u2018Proceedings of CHI\u201988\u2019, ACM\nPress, pp. 263\u2013268.\nHadhrawi, M., Blackwell, A. & Church, L. (2017), A systematic literature\nreview of cognitive dimensions, in L. Church & F. Hermans, eds, \u2018Pro-\nceedings of 28th PPIG Annual Workshop\u2019, Psychology of Programming\nInterest Group, pp. 1\u201312.\nHall, A. (1990), \u2018Seven myths of formal methods\u2019, IEEE Software 7(5), 11\u201319.\nHannay, J., Dyb\u00e5, T., Arisholm, E. & Sj\u00f8berg, D. (2009), \u2018The e\ufb00ectiveness of\npair programming. A meta-analysis\u2019, Information & Software Technology\n51(7), 1110\u20131122.\nHarel, D. (1987), \u2018Statecharts: A visual formalism for complex systems\u2019, Sci-\nence of Computer Programming 8, 231\u2013274.\nHarel, D. (1988), \u2018On visual formalisms\u2019, Communications of the ACM\n31(5), 514\u2013530.\nHarel, D. & Gery, E. (1997), \u2018Executable object modelling with statecharts\u2019,\nIEEE Computer 30(7), 31\u201342.\nHatley, D. J. & Pirbhai, I. (1988), Strategies for Real-Time System Speci\ufb01ca-\ntion, Dorset House.\n", "page": 347, "type": "text", "section": "Page 347"}
{"text": "Bibliography\n331\nHayes-Roth, B. & Hayes-Roth, F. (1979), \u2018A cognitive model of planning\u2019,\nCognitive Science 3(4), 275\u2013310.\nHeineman, G. T. & Councill, W. T. (2001), Component-Based Software En-\ngineering: Putting the Pieces Together, Addison-Wesley.\nHughes, B. (2000), Practical Software Measurement, McGraw Hill.\nIzurieta, C. & Bieman, J. M. (2007), How software designs decay: A pilot study\nof pattern evolution, in \u2018Proceedings of Empirical Software Engineering\n& Measurement, 2007\u2019.\nJabangwe, R., Borstler, J., Smite, D. & Wohlin, C. (2015), \u2018Empirical evi-\ndence on the link between object-oriented measures and external quality\nattributes: A systematic literature review\u2019, Empirical Software Engineer-\ning 20, 640\u2013693.\nJackson, M. A. (1975), Principles of Program Design, Academic Press.\nJacobson, I., Booch, G. & Rumbaugh, J. (1999), The Uni\ufb01ed Software Devel-\nopment Process, Addison-Wesley.\nJacobson, I., Christerson, M., Jonsson, P. & Overgaard, G. (1992), Object-\nOriented Software Engineering: A Use Case Driven Approach, Addison-\nWesley.\nJacobson, I., Spence, I. & Kerr, B. (2016), \u2018Use-Case 2.0\u2019, Communications of\nthe ACM 59(5), 61\u201369.\nJacobson, I., Spence, I. & Seidewitz, E. (2016), \u2018Industrial-scale agile\u2014from\ncraft to engineering\u2019, Communications of the ACM 59(12), 63\u201371.\nJ\u00e9z\u00e9quel, J.-M. & Meyer, B. (1997), \u2018Design by contract: The lessons of Ari-\nane\u2019, IEEE Computer 30(1), 129\u2013130.\nJohnson, R. A. & Hardgrave, W. C. (1999), \u2018Object-oriented methods: Current\npractices and attributes\u2019, Journal of Systems & Software 48(1), 5\u201312.\nJones, J. C. (1970), Design Methods: Seeds of Human Futures, Wiley-\nInterscience.\nKitchenham, B. (2010), \u2018What\u2019s up with software metrics? \u2013 a preliminary\nmapping study\u2019, Journal of Systems & Software 83, 37\u201351.\nKitchenham, B. A., Budgen, D. & Brereton, P. (2015), Evidence-Based Soft-\nware Engineering and Systematic Reviews, Innovations in Software En-\ngineering and Software Development, CRC Press.\nKruchten, P. (2004), The Rational Uni\ufb01ed Process: An Introduction, 3rd edn,\nAddison-Wesley.\n", "page": 348, "type": "text", "section": "Page 348"}
{"text": "332\nBibliography\nKruchten, P. B. (1994), \u2018The 4+1 view model of architecture\u2019, IEEE Software\n12(6), 42\u201350.\nKupiainen, E., M\u00e4ntyl\u00e4, M. V. & Itkonen, J. (2015), \u2018Using metrics in agile and\nlean software development \u2013 a systematic literature review of industrial\nstudies\u2019, Information & Software Technology 62, 143\u2013163.\nLanza, M. & Marinescu, R. (2006), Object-Oriented Metrics in Practice,\nSpringer.\nLarman, C. (2004), Applying UML and Patterns: An Introduction to Object-\nOriented Analysis and Design and Iterative Development, 3rd edn, Pren-\ntice Hall.\nle Goues, C., Jaspan, C., Ozkaya, I., Shaw, M. & Stolee, K. T. (2018), \u2018Bridg-\ning the gap: From research to practical advice\u2019, IEEE Software 35(5), 50\u2013\n57.\nLittman, D. C., Pinto, J., Letovsky, S. & Soloway, E. (1987), \u2018Mental models\nand software maintenance\u2019, Journal of Systems & Software 7, 351\u2013355.\nLitz, M. & Montazeri, B. (1996), \u2018Chidamber and kemerer\u2019s metrics suite: A\nmeasurement theory perspective\u2019, IEEE Transactions on Software Engi-\nneering 22(4), 267\u2013271.\nLong, J. (2001), \u2018Software reuse antipatterns\u2019, ACM Software Engineering\nNotes 26(4), 68\u201376.\nLongworth, G. (1992), Introducing SSADM Version 4, Blackwell Publishing.\nLunn, K. (2003), Software Development with UML, Palgrave Macmillan.\nMangano, N., Toza, T. D. L., Petre, M. & van der Hoek, A. (2015), \u2018How soft-\nware designers interact with sketches at the whiteboard\u2019, IEEE Transac-\ntions on Software Engineering 41(2), 135\u2013156.\nMayvan, B. B., Rasoolzadegan, A. & Yazdi, Z. G. (2017), \u2018The state of the\nart on design patterns: A systematic mapping of the literature\u2019, Journal\nof Systems & Software 125, 93\u2013118.\nMcIntosh, S., Kamei, Y., Adams, B. & Hassan, A. E. (2016), \u2018An empirical\nstudy of the impact of modern code review practices on software quallity\u2019,\nEmpirical Software Engineering 21, 2145\u20132189.\nMiller, G. A. (1956), \u2018The magical number seven, plus or minus two: Some lim-\nits on our capacity for processing information\u2019, The Psychological Review\n63(2), 81\u201397.\nMills, H. (1971), Chief programmer teams, principles, and procedures, Tech-\nnical report, IBM Federal Systems Division.\n", "page": 349, "type": "text", "section": "Page 349"}
{"text": "Bibliography\n333\nMohagheghi, P. & Conradi, R. (2007), \u2018Quality, productivity and economic\nbene\ufb01ts of software reuse: A review of industrial studies\u2019, Empirical Soft-\nware Engineering 12, 471\u2013516.\nMohagheghi, P. & Dehlen, V. (2008), Where is the proof? \u2013 a review of ex-\nperiences from applying MDE in industry, in \u2018ECMDA-FA, LNCS 5095\u2019,\nSpringer, pp. 432\u2013443.\nMoody, D. L. (2009), \u2018The \u201cphysics\u201d of notations: Toward a scienti\ufb01c basis for\nconstructing visual notations in software engineering\u2019, IEEE Transactions\non Software Engineering 35(6), 756\u2013779.\nMyers, G. J. (1973), \u2018Characteristics of composite design\u2019, Datamation\n19(9), 100\u2013102.\nNorman, D. A. (2002), The Design of Everyday Things, Basic Books.\nO\ufb00ermann, P. & Bub, U. (2009), Empirical comparison of methods for in-\nformation systems development according to SOA, in \u2018Proceedings 17th\nEuropean Conference on Information Systems (ECIS 2009)\u2019, pp. 1\u201313.\nOlbrich, S. M., Cruzes, D. S. & Sj\u00f8berg, D. I. K. (2010), Are all code smells\nharmful? A study of god classes and brain classes in the evolution of three\nopen source systems, in \u2018Proceedings of 26th International Conference on\nSoftware Maintenance\u2019, IEEE Computer Society Press.\nOwen, S., Budgen, D. & Brereton, P. (2006), \u2018Protocol analysis: A neglected\npractice\u2019, Communications of the ACM 49, 117\u2013122.\nOzkaya, M. (2017), \u2018Do the informal and formal software modeling notations\nsatisfy practitioners for software architecture modeling\u2019, Information &\nSoftware Technology 95, 15\u201333.\nPage-Jones, M. (1988), The Practical Guide to Structured Systems Design,\n2nd edn, Prentice-Hall.\nPahl, G. & Beitz, W. (1996), Engineering Design: A Systematic Approach,\n2nd edn, Springer-Verlag.\nPalomba, F., Bavota, G., Penta, M. D., Fasano, F., Oliveto, R. & Lucia,\nA. D. (2018), \u2018On the di\ufb00useness and the impact on maintainability of\ncode smells: A large scale empirical investigation\u2019, Empirical Software\nEngineering 23, 1188\u20131221.\nParnas, D. L. (1972), \u2018On the criteria to be used in decomposing systems into\nmodules\u2019, Communications of the ACM 15(12), 1053\u20131058.\nParnas, D. L. (1979), \u2018Designing software for ease of extension and contrac-\ntion\u2019, IEEE Transactions on Software Engineering 5(2), 128\u2013137.\n", "page": 350, "type": "text", "section": "Page 350"}
{"text": "334\nBibliography\nParnas, D. L. & Clements, P. C. (1986), \u2018A rational design process: How and\nwhy to fake it\u2019, IEEE Transactions on Software Engineering 12(2), 251\u2013\n257.\nParnas, D. L. & Weiss, D. M. (1987), \u2018Active design reviews: Principles and\npractices\u2019, Journal of Systems & Software 7, 259\u2013265.\nPerry, D. E. & Wolf, A. L. (1992), \u2018Foundations for the study of software\narchitecture\u2019, ACM Software Engineering Notes 17(4), 40\u201352.\nPeters, L. & Tripp, L. (1976), \u2018Is software design \u2018wicked\u2019 too?\u2019, Datamation\n22(5), 127.\nPetre, M. (2013), UML in practice, in \u2018Proceedings of the 2013 International\nConference on Software Engineering (ICSE)\u2019, IEEE Computer Society\nPress, pp. 722\u2013731.\nPetre, M. & van der Hoek, A. (2016), Software Design Decoded: 66 Ways\nExperts Think, The MIT Press.\nP\ufb02eeger, S. L. & Atlee, J. M. (2010), Software Engineering: Theory and Prac-\ntice, 4th edn, Pearson.\nPohthong, A. & Budgen, D. (2000), Accessing software component documen-\ntation during design: An observational study, in \u2018Proceedings of Seventh\nAsia-Paci\ufb01c Software Engineering Conference\u2019, IEEE Computer Society\nPress, pp. 196\u2013203.\nPohthong, A. & Budgen, D. (2001), \u2018Reuse strategies in software development:\nAn empirical study\u2019, Information & Software Technology 43(9), 561\u2013575.\nPugh, S. (1991), Total Design: Integrated Methods for Successful Product En-\ngineering, Addison-Wesley.\nPurchase, H. C., Welland, R., McGill, M. & Colpoys, L. (2004), \u2018Compre-\nhension of diagram syntax: An empirical study of entity relationship no-\ntations\u2019, International Journal of Human-Computer Studies 61(2), 187\u2013\n203.\nQumer, A. & Henderson-Sellers, B. (2008), \u2018An evaluation of the degree of\nagility in six agile methods and its applicability for method engineering\u2019,\nInformation & Software Technology 50, 280\u2013295.\nRadjenovi\u0107, D., Heri\u010dko, M., Torkar, R. & \u017divkovi\u010d, A. (2013), \u2018Software fault\nprediction metrics: A systematic literature review\u2019, Information & Soft-\nware Technology 55, 1397\u20131418.\nRatcli\ufb00e, M. & Budgen, D. (2001), \u2018The application of use case de\ufb01ni-\ntions in system design speci\ufb01cation\u2019, Information & Software Technology\n43(6), 365\u2013386.\n", "page": 351, "type": "text", "section": "Page 351"}
{"text": "Bibliography\n335\nRatcli\ufb00e, M. & Budgen, D. (2005), \u2018The application of use cases in systems\nanalysis and design speci\ufb01cation\u2019, Information & Software Technology\n47, 623\u2013641.\nRentsch, T. (1982), \u2018Object-oriented programming\u2019, ACM SIGPLAN Notices\n17(9), 51\u201357.\nRittel, H. & Webber, M. (1984), Planning problems are wicked problems, in\nN. Cross, ed., \u2018Developments in Design Methodology\u2019, Wiley, pp. 135\u2013\n144.\nRobinson, P. J. (1992), Hierarchical Object-Oriented Design, Prentice-Hall.\nRumbaugh, J., Jacobson, I. & Booch, G. (1999), The Uni\ufb01ed Modeling Lan-\nguage Reference Manual, Addison-Wesley.\nRuneson, P., H\u00f6st, M., Rainer, A. & Regnell, B. (2012), Case Study Research\nin Software Engineering: Guidelines and Examples, Wiley.\nRuparelia, N. (2010), \u2018Software Development Lifecycle Models\u2019, ACM SigSoft\nSoftware Engineering Notes 35(3), 8\u201313.\nSchmidt, D. C. (2006), \u2018Model-driven engineering\u2019, IEEE Computer 39(2), 25\u2013\n31.\nSchwaber, K. (2004), Agile Project Management with Scrum, Microsoft Press.\nSchwaber, K. & Beedle, M. (2002), Agile Software Development with Scrum,\nPrentice Hall.\nShadish, W., Cook, T. & Campbell, D. (2002), Experimental and Quasi-\nExperimental Design for Generalized Causal Inference, Houghton Mi\ufb04in\nCo.\nShahin, M., Liang, P. & Babar, M. A. (2014), \u2018A systematic review of software\narchitecture visualization techniques\u2019, Information & Software Technol-\nogy 94, 161\u2013185.\nShapiro, S. (1997), \u2018Splitting the di\ufb00erence: The historical necessity of synthe-\nsis in software engineering\u2019, IEEE Annals of the History of Computing\n19(1), 20\u201354.\nSharp, H., Preece, J. & Rogers, Y. (2019), Interaction Design: Beyond Human-\nComputer Interaction, 5th edn, John Wiley & Sons.\nShaw, M. & Clements, P. C. (1997), A \ufb01eld guide to boxology: Preliminary\nclassi\ufb01cation of architectural styles for software systems, in \u2018Proceedings\nCOMPSAC\u201997\u2019, IEEE Computer Society Press, pp. 6\u201313.\nShaw, M. & Garlan, D. (1996), Software Architecture: Perspectives on an\nEmerging Discipline, Prentice Hall.\n", "page": 352, "type": "text", "section": "Page 352"}
{"text": "336\nBibliography\nSheetz, S. D. & Tegarden, D. P. (1996), \u2018Perceptual complexity of object\noriented systems: A student view\u2019, Object Oriented Systems 3(4), 165\u2013\n195.\nSimon, H. A. (1973), \u2018The structure of ill-structured problems\u2019, Arti\ufb01cial In-\ntelligence 4, 181\u2013201.\nSj\u00f8berg, D., Hannay, J., Hansen, O., Kampenes, V., Karahasanovic, A.,\nLiborg, N. & Rekdal, A. (2005), \u2018A survey of controlled experiments\nin software engineering\u2019, IEEE Transactions on Software Engineering\n31(9), 733\u2013753.\nSmith, G. (2000), The Object-Z Speci\ufb01cation Language, Springer.\nSnyder, A. (1993), \u2018The essence of objects: Concepts and terms\u2019, IEEE Soft-\nware 10(1), 31\u201342.\nSpivey, J. M. (1998), The Z notation: A reference manual, Technical report,\nProgramming Research Group, University of Oxford.\nStapleton, J., ed. (1999), Dynamic Systems Development Method (Version 3),\nTesseract Publishing.\nStapleton, J., ed. (2002), DSDM: Business Focused Development, Addison-\nWesley.\nSteinmacher, I., Silva, M. A. G., Gerosa, M. A. & Redmiles, D. F. (2015), \u2018A\nsystematic literature review on the barriers faced by newcomers to open\nsource software projects\u2019, Information & Software Technology 59(67-85).\nStevens, W. P. (1991), Software Design: Concepts and Methods, Prentice-Hall.\nStevens, W. P., Myers, G. J. & Constantine, L. L. (1974), \u2018Structured design\u2019,\nIBM Systems Journal 13(115-139).\nSzyperski, C. (1998), Component Software: Beyond Object-Oriented Program-\nming, Addison-Wesley.\nTaivalsaari, A. (1993), \u2018On the notion of object\u2019, Journal of Systems & Soft-\nware 21(1), 3\u201316.\nTempero, E., Gorschek, T. & Angelis, L. (2017), \u2018Barriers to refactoring\u2019,\nCommunications of the ACM 60(10), 54\u201361.\nTiwari, S. & Gupta, A. (2015), \u2018A systematic literature review of use case\nspeci\ufb01cations research\u2019, Information & Software Technology 67, 128\u2013158.\nTomayko, J. (1996), Carnegie Mellon\u2019s Software Development Studio: A \ufb01ve\nyear retrospective, in \u2018Proceedings of 9th Conference on Software Engi-\nneering Education\u2019, IEEE Computer Society Press, pp. 119\u2013129.\n", "page": 353, "type": "text", "section": "Page 353"}
{"text": "Bibliography\n337\nTruex, D., Baskerville, R. & Klein, H. (1999), \u2018Growing systems in emergent\norganisations\u2019, Communications of the ACM 42(8), 117\u2013123.\nTurner, M., Brereton, P. & Budgen, D. (2006), \u2018Service-enabled access control\nfor distributed data\u2019, IEE Proceedings \u2013 Software 153, 24\u201330. Special\nSection on RBAC.\nTurner, M., Budgen, D. & Brereton, P. (2003), \u2018Turning software into a ser-\nvice\u2019, IEEE Computer 36(10), 38\u201344.\nVale, T., Crnkovic, I., de Almeida, E. S., da Mota Silviera Neto, P. A., Cav-\nalcanti, Y. a. C. & de Lemos Meira, S. R. (2016), \u2018Twenty-eight years of\ncomponent-based software engineering\u2019, Journal of Systems & Software\n111, 128\u2013148.\nvan Aken, J. E. (2004), \u2018Management research based on the paradigm of the\ndesign sciences: The quest for \ufb01eld-tested and grounded technological\nrules\u2019, Journal of Management Studies 41(2), 219\u2013246.\nvan der Hoek, A. & Petre, M. (2014), Software Designers in Action: A Human-\nCentric Look at Design Work, CRC Press.\nvan Vliet, H. & Tang, A. (2016), \u2018Decision making in software architecture\u2019,\nJournal of Systems & Software 17(638-644).\nVessey, I. & Conger, S. (1994), \u2018Requirements speci\ufb01cation: Learning object,\nprocess and data methodologies\u2019, Communications of the ACM 37, 102\u2013\n113.\nVisser, W. & Hoc, J.-M. (1990), Expert software design strategies, in J.-M.\nHoc, T. Green, R. Samur\u00e7ay & D. Gilmore, eds, \u2018Psychology of Program-\nming\u2019, Academic Press, pp. 235\u2013249.\nWard, P. T. & Mellor, S. J. (1985), Structured Development for Real-Time\nSystems, Yourdon Press.\nWeaver, P. L., Lambrou, N. & Walkley, M. (2002), Practical Business Sys-\ntems Development Using SSADM: A Complete Tutorial Guide, 3rd edn,\nPearson Education.\nWeinberg, G. M. (1971), The Psychology of Computer Programming, Van Nos-\ntrand Reinhold.\nWeinberg, G. M. & Freedman, D. P. (1987), \u2018Reviews, walkthroughs and in-\nspections\u2019, IEEE Transactions on Software Engineering 10(1), 68\u201372.\nWendor\ufb00, P. (2001), Assessment of design patterns during software reengineer-\ning: Lessons learned from a large commercial project, in \u2018Proceedings of\n5th European Conference on Software Maintenance and Reengineering\n(CSMR\u201901)\u2019, IEEE Computer Society Press, pp. 77\u201384.\n", "page": 354, "type": "text", "section": "Page 354"}
{"text": "338\nBibliography\nWhittle, J., Hutchinson, J. & Rounce\ufb01eld, M. (2014), \u2018The state of practice\nin model-driven engineering\u2019, IEEE Software 31(3), 7985.\nWieringa, R. (1998), \u2018A survey of structured and object-oriented software spec-\ni\ufb01cation methods and techniques\u2019, ACM Computing Surveys 30(4), 459\u2013\n527.\nWilliams, B. J. & Carver, J. C. (2010), \u2018Characterizing software architec-\nture changes: A systematic review\u2019, Information & Software Technology\n52(1), 31\u201351.\nWirth, N. (1971), \u2018Program development by stepwise re\ufb01nement\u2019, Communi-\ncations of the ACM 14(4), 221\u2013227.\nWood, M., Daly, J., Miller, J. & Roper, M. (1999), \u2018Multi-method research: An\nempirical investigation of object-oriented technology\u2019, Journal of Systems\n& Software 48, 13\u201326.\nWoodcock, J., Larsen, P. G., Bicarregui, J. & Fitzgerald, J. (2009), \u2018Formal\nmethods: Practice and experience\u2019, ACM Computing Surveys 41(4), 1\u2013\n36.\nWu, M.-W. & Lin, Y.-D. (2001), \u2018Open source software development: An\noverview\u2019, IEEE Computer 34(6), 33\u201338.\nYakimovich, D., Bieman, J. M. & Basili, V. R. (1999), Software architecture\nclassi\ufb01cation for estimating the cost of COTS integration, in \u2018Proceed-\nings of 21st International Conference on Software Engineering (ICSE\u201999)\u2019,\nIEEE Computer Society Press, pp. 296\u2013302.\nYin, R. K. (2014), Case Study Research: Design & Methods, 5th edn, Sage\nPublications Ltd.\nYourdon, E. & Constantine, L. L. (1979), Structured Design, Prentice-Hall.\nZhang, C. & Budgen, D. (2012), \u2018What do we know about the e\ufb00ectiveness of\nsoftware design patterns?\u2019, IEEE Transactions on Software Engineering\n38(5), 1213\u20131231.\nZhang, C. & Budgen, D. (2013), \u2018A survey of experienced user perceptions\nabout design patterns\u2019, Information & Software Technology 55(5), 822\u2013\n835.\nZhang, C., Budgen, D. & Drummond, S. (2012), Using a follow-on survey\nto investigate why use of the Visitor, Singleton and Facade design pat-\nterns is controversial?, in \u2018Proceedings 6th International Symposium on\nEmpirical Software Engineering and Measurement (ESEM)\u2019, ACM Press,\npp. 79\u201388.\n", "page": 355, "type": "text", "section": "Page 355"}
{"text": "Index\n.NET, 185, 270, 294\n4+1, 99\nAbrial, J-R, 318\nabstraction, 32, 33, 40, 94\u201396, 143,\n225\nactivity, 167\nactivity diagram, 105, 167, 183\nAdelson, B., 33, 44, 62, 88, 99, 198,\n209, 263\nADL, see architecture description\nlanguage\nagile development, 11, 71, 198, 199,\n226, 237, 244, 249, 253, 255,\n256, 258, 259, 312, 318\nagile manifesto, 237, 249\nAkin, O., 46\nAlexander, C., 87, 262\nAli, M.S., 71\nAllman, E., 10\nAnjum, M., 189, 299, 300\nApache Spark, 185\narchitectural\ndecision, 232\ndesign, 211, 294\nevolution, 92\nmismatch, 183, 297\npattern, 144, 265\npattern\nlayers, 294\nservice broker, 284\nvisualisation, 92\narchitectural pattern, 77, 87, 88, 92,\n253, 263, 266, 287, 288, 290\narchitectural pattern\nbroker, 88, 270, 271\nlayers, 88, 90, 91, 268, 269\nmodel-view-controller, 88, 89,\n266, 267\npipes-and-\ufb01lters, 88\nre\ufb02ection, 88\narchitectural style, 34, 77, 79\u201385, 88,\n92, 100, 106, 112, 119, 153,\n164, 180\u2013182, 197, 202, 203,\n206, 218, 220, 242, 248, 252,\n260, 261, 266, 287, 290\narchitectural style\ncall-and-return, 81, 83, 84, 120,\n122, 134, 206, 207, 219, 236\nclient-server, 84, 85\ncommunicating-processes, 120\ndata-centred repository, 81, 84,\n85\ndata-\ufb02ow, 81\ndata-sharing, 81\ninteracting processes, 81\npipe-and-\ufb01lter, 82, 83, 120\narchitecture, 77\u201385, 87\u201392, 144, 212,\n228\narchitecture\nas vocabulary, 78, 92\narchitecture description language, 80\nArlow, J., 159, 226, 229\nAvison, D.E., 212\nBailey, J., 173, 235\nBano, M., 200\nBarrow, P.D.M., 258\nBass, L., 81, 265, 266, 283\nBates, B., 272, 286\nBeck, K., 230, 250, 284\nBennett, K.H., 10, 270\nbinding\ndynamic, 149, 154, 270, 271, 293\n339\n", "page": 356, "type": "text", "section": "Page 356"}
{"text": "340\nIndex\nstatic, 148, 149, 271\ntime, 148, 297\nblack box, 97, 101, 162, 181, 182,\n222, 229, 249, 317\nBlackwell, A., 106\nBoehm, B.W., 130, 242, 249\nBooch, G., 141, 142, 226\nBosu, A., 314\nbox and line, 95, 103\nbox plot, 62\nBreivold, H.P., 92\nBrereton, P., 181\nBrooks, F.P. Jr., 50, 56, 140, 196,\n199, 201\nBrown, A.W., 180, 181\nBrown, W.J., 284\nBrunel, I.K., 39, 54\nBrunel, M., 178\nBudgen, D., 67, 69, 70, 72, 173, 201\nBuschmann, F., 87, 88, 263, 265,\n273, 275, 276, 286, 288\nbusiness modelling, 299, 300, 303\ncamelCase, 158\ncapability maturity model, 253\nCarney, D., 186\ncase study, 67, 69, 233\ncase study\ndescriptive, 68\nexplanatory, 68\nexploratory, 68\nproposition, 68, 69\ncausal relationships, 101\nCBSE, see component-based\nsoftware engineering\nChen, J., 259\nChen, P., 131\nChidamber, S.R., 150, 174, 310\nchief programmer, 199\nclass, see also object, 139, 140, 145,\n146, 157, 158, 172, 222, 225,\n273\nclass\ndescription, 223\nhierarchy, 145\ninheritance, 147, 148, 287\nmethod, 146\nmodel, 228\nsubclass, 146, 147\nsuperclass, 147, 148\nuses, 151\nvariable, 146\nclass diagram, 105, 166, 230\nclass-responsibility-collaborator, 230,\n252\ncloud, 177, 188, 298, 301\nCMM, see capability maturity model\ncode smell, 257, 286\ncognitive\ncapacity, 31, 32\nload, 32, 96, 111, 125, 148, 156,\n209\nmapping, 153\ncognitive dimensions, 106, 108, 134,\n308\ncohesion, 52, 307\nColeman, D., 220\ncollaboration diagram, 230\ncommon object request broker\narchitecture, 179, 184, 191,\n294\ncommunication, 20, 21, 37, 38, 40, 45\ncomponent, 177, 178, 180, 183, 185,\n191, 293, 294, 297, 302\ncomponent\narchitecture, 294, 298\ncatalogue, 178, 179, 294\ncharacteristics, 181, 182\ncomposition, 177, 178, 180, 181,\n183, 187, 293, 294, 296, 298\ncomposition\nelement \ufb01rst, 295\nframework \ufb01rst, 295\ncomposition standard, 181\ncontrol \ufb02ow, 297\nCOTS, 186\ndependency, 185, 191\nevolution, 186\nframework, 183\u2013186, 191\n", "page": 357, "type": "text", "section": "Page 357"}
{"text": "Index\n341\nfunctionality, 178, 179, 182, 185,\n191\nindependence, 180, 182\ninformation \ufb02ow, 297\nintegration, 180, 184\ninteraction, 183, 184, 186\ninteraction protocols, 184\ninterface, 178, 179, 182, 185, 191\nmodel, 179, 181\npackaging, 297\nrecon\ufb01guration, 184\nsynchronisation, 297\ntrust, 184\ncomponent-based software\nengineering, 177, 180, 183,\n184, 187, 190, 294, 297, 298,\n302\ncompositional strategy, 207, 294\nconfounding factor, 63\nConnor, D., 211\ncontext diagram, 122\u2013124, 212\ncontrol group, 61\nCooke, P., 179\nCoplien, J.O., 263\nCORBA, see common object request\nbroker architecture\ncost model, 94\ncoupling, 51, 78, 82, 100, 134, 151,\n205, 207, 236, 263, 307\ncoupling\ndata \ufb02ow, 100\ndata sharing, 100\ninheritance, 100\u2013102, 256\ninvocation, 100, 101\nloose, 272, 276, 279, 290\nuses, 100, 101, 144, 223\nCRC, see class-responsibility-\ncollaborator\ncreativity, 20\nCrnkovic, I., 181, 185\nCunningham, W., 10\nCurtis, B., 45, 66, 199, 200\nCusumano, M.A., 239\nD\u00e9tienne, F., 56, 155, 207, 208, 263\nda Vinci, L., 54\ndata dictionary, 212, 220, 223\ndata-\ufb02ow diagram, 105, 121\u2013125,\n127, 128, 136, 137, 189, 212,\n216, 302\nDe Marco, T., 122, 136\ndependent variable, 61, 62\ndesign\nagile, 100\nanti-pattern, 284, 290\napprentice, 262\nas a noun, 261\nas a verb, 261\nas adaptation, 15\u201317, 47, 87\nas noun, 12, 17\nas planning, 14\u201317, 27, 45\nas social process, 251, 306, 311,\n316, 321\nas styling, 14\u201317\nas verb, 13, 17, 195\nattribute, 99, 101, 102, 131\naudit, 36\nbottom-up, 198\nby composition, 302\nchoice, 294\ncode smell, 284, 285, 290, 313\nconstraint, 259\ndecision, 206, 242, 294, 295\ndocumentation, 36, 218, 313\nevolution, 256, 260, 307\nheuristic, 55, 208, 214, 218\nincremental, 237, 239, 240, 242,\n243, 250, 259\ninvariant, 221\nknowledge, 155, 195, 315\nlogical, 214, 218\nmethod, 205, 209, 233\nmetrics, 309\nmodel, 26, 28, 29, 32\u201336, 38, 40,\n48\u201350, 93\u201397, 101, 102, 106,\n107, 109\u2013111, 113, 114, 125,\n137, 145, 153, 157, 170, 197,\n198, 201, 204, 207, 213, 263,\n264, 284, 285, 294, 299, 302,\n305, 306, 311, 313, 317\n", "page": 358, "type": "text", "section": "Page 358"}
{"text": "342\nIndex\nnote-making, 117\npattern, 178, 198, 261\u2013263, 271,\n274, 283, 286\u2013288, 290, 300\npattern\nabstract factory, 281, 282,\n289, 291\nbehavioural, 262, 273\ncomposite, 289, 291\ncreational, 273, 290\ngrime, 272\nmemento, 289\nobserver, 278, 279, 289, 291\nprotection proxy, 275\u2013277\nproxy, 275, 276\nremote proxy, 275\nrot, 272\nservice-oriented, 283\nsingleton, 289\nsoftware service, 283, 284\nstructural, 273, 290\nvirtual proxy, 276\nvisitor, 289\nvocabulary, 263, 266\nphysical, 214, 218, 228, 234\nplan, 12, 13\nplan-based, 209\nplan-driven, 12, 100, 122, 197,\n198, 203\u2013209, 211\u2013214, 219,\n222, 224\u2013237, 239, 241, 244,\n271\nprinciple, 306, 307\nprocess, 134, 208, 258\nquality, 305, 306, 314\nrationale, 35, 36, 40\nrecords, 117\nrefactoring, 313, 314\nrepresentation, 102, 196, 208,\n209, 212\nreview, 240, 311, 314\nschema, 56, 58\nsciences, 200\nsimulation, 44, 57\nsketches, 48, 57, 103, 105,\n109\u2013116, 122, 125, 133, 156,\n164, 253\nteam, 199, 200, 202\nthinking, 13, 15\u201317, 27\ntop-down, 198, 206, 211, 212\ntrade-o\ufb00, 242\nvalidation, 130\nveri\ufb01cation, 229\nviewpoints, 108\nwalk-through, 35, 229\nincremental, 294\nveri\ufb01cation, 130\nDFD, see data-\ufb02ow diagram\ndiagram\nhierarchy, 104, 125, 128, 129,\n135, 137, 162, 163, 165\nsemantics, 104\nsyntax, 104\ndiagrammatical notations, 95\nDiebold, P., 258\ndi\ufb00useness, 107\ndomain knowledge, 39, 41, 204\nDSDM, 226, 241, 243\u2013247, 249, 254,\n257, 258, 260\nDSDM\nphase, 247\nprinciples, 244, 245\nstakeholders, 245\nDyb\u00e5, T., 258\ndynamic systems development\nmethod, see DSDM\nEBSE, see evidence-based software\nengineering\nEdwards, H.M., 233\nElbanna, A., 242, 259\nemergent organisation, 239, 243\nempirical knowledge, 59, 63, 70\u201373,\n136, 172, 190, 200, 233\u2013235,\n257, 258, 288, 291, 302, 313,\n315\nempirical study, 59, 63\u201365, 72, 236,\n316, 320, 322\nencapsulation, see information hiding\nenterprise java beans, 270\nentity-life-history diagram, 216, 234\nentity-life-history matrix, 219\n", "page": 359, "type": "text", "section": "Page 359"}
{"text": "Index\n343\nentity-relationship diagram, 105,\n130\u2013133, 159, 216\nERD, see entity-relationship diagram\nEricsson, K.A., 66\nErl, T., 87, 284, 300\nevent, 126, 161, 163, 221\nevent partitioning, 211\nevidence-based software engineering,\n69\nevolution, 78, 79, 88, 204, 209, 268,\n272, 277, 285, 296, 298\nexperience paper, 173\nexperience report, 64\nexperiment, 60, 62, 66\u201368\nexperimental group, 61\nexperimental treatment, 61\nexpert designers, 43\u201345, 47, 55\nextreme programming, see XP\nfactoring, 214\nFagan, M., 311\nFayad, M.E., 263\nFDT, see formal description\ntechnique\nfeasibility study, 217, 239, 247\nfeature interaction, 21\nFeitosa, H., 272\nFenton, N.E., 309, 314\nFichman, R.G., 155\n\ufb01eld study, 64, 69, 173\n\ufb01nite-state machine, 101, 126, 161\nFinkelstein, A., 97\n\ufb01tness for purpose, 35, 40, 49, 252,\n306\nFloyd, C., 238\nformal description technique, 105,\n317, 318, 320\nformal description technique\nmodel-based, 318\nZ, 318\u2013320\nZ\npostcondition, 319, 320\nprecondition, 319, 320\npredicate, 319, 320\nschema, 319\nsignature, 319\nFowler, M., 256, 284, 285, 313\nFusion, 219\u2013226, 231, 232, 235\nGamma, E., 87, 272, 273, 286, 287\nGane, C., 211\nGarlan, D., 78, 183\nGNU, 315\ngod class, 285\nGoF, 272, 274\u2013276, 286, 288, 289\ngraceful degradation, 307\nGreen, T.R.G., 106, 308\nGuindon, R., 209\nHadhrawi, M., 106\nHall, A., 318\nHannay, J., 71\nHarel, D., 161, 162, 164\nHatley, D.J, 211\nHayes-Roth, B., 45\nHCI, 14, 106, 239, 308\nHeineman, G.T., 181\nHelm, R., 272\nhidden dependencies, 106, 134\nHOOD, 157\nHughes, R., 310\nhuman-computer interaction, see\nHCI\nhypothesis, 66\nhypothesis\nalternate, 66\nIBM, 211\nidiom, 263\nilities, 49, 307, 308, 314\nIll-Structured Problem, 8, 9, 17,\n21\u201325, 29, 35, 46, 49, 54, 62,\n93, 109, 112, 119, 124, 140,\n195\u2013197, 201, 210, 236, 239,\n241, 253, 259, 264, 271, 288,\n290, 298, 305, 317, 320, 322\nincremental development, 238, 241,\n243, 247, 249, 253, 315, 316\ninformation hiding, 52, 84, 89, 121,\n142, 144, 206, 307, 312\ninheritance, see coupling\n", "page": 360, "type": "text", "section": "Page 360"}
{"text": "344\nIndex\ninteraction design, 14, 239\ninternet of things, 10, 196\ninterpretivist philosophy, 60, 68\ninterview, 65\ninterview\nsemi-structured, 65\nISP, see Ill-Structured Problem\nIzurieta, C., 272\nJ2EE, 185\nJ\u00e9z\u00e9quel, J-M, 182\nJabangwe, R., 314\nJackson structure diagram, 105, 216,\n218\nJacobson, I., 142, 169, 172, 226, 242\nJava, 294\nJohnson, R., 272\nJohnson, R.A., 226, 234\nJones, C.J., 24\u201326\nKitchenham, B.A., 56, 64, 69, 174,\n257, 314\nknowledge\ndeclarative, 208, 209, 217, 218,\n236, 243, 294\ndomain, 209, 235, 311\nmethod, 209, 235\nprocedural, 208, 209, 218, 236,\n243, 294\nschema, 197, 203, 205, 263, 298,\n323\ntechnical, 311\ntransfer, 87, 195, 197, 198,\n202\u2013204, 209, 219, 233, 235,\n242, 260\u2013262, 264, 294\nKruchten, P.B., 99, 226\nKupiainen, E., 312, 313\nlabels for plans, 44, 45, 87, 198, 263\nlaboratory study, 64, 66, 116, 173\nLanza, M., 285\nLarman, C., 226\nle Goues, C., 56\nlegacy software, 204\nLinux, 315, 316\nLittman, D.C., 36, 209\nLitz, M., 174\nlogical data modelling, 216\nlogical data structure, 216\nLong, J., 284\nLongworth, G., 103, 122, 215\nLunn, K., 159\nmagical number seven, 31, 104, 111\nMangano, N., 110, 111, 116\nMartin, J., 244\nmathematical model, 95\nmathematical notation, 105, 317\nMayvan, B.B., 289\nMcCabe, T., 151\nMcIlroy, D., 177\nMcIntosh, S., 314\nMDE, see model driven engineering\nmeasurement, 59\u201363, 72, 95\nmeasurement\nattribute, 309\nerror, 60, 62\nmental execution, 44, 48, 49, 99, 110,\n111, 154, 311\nmental model, 44, 57\nmessage sequence diagram, see\nsequence diagram\nmethod, see object\nmetric\nactionable, 310\nCBO, 150\u2013152, 174\ncomplexity, 310\ncounting rule, 309\ncyclomatic complexity, 151\nDIT, 150\ninformational, 310\nLCOM, 150, 151\nlines of code, 151\nNOC, 150, 151\nquantitative, 306\nRFC, 150, 152, 153, 174\nthreshold value, 310\nWMC, 150, 151, 174\nmetrics, 150, 172, 174, 235, 257, 311\nMiller, G.A., 31, 111\nMills, H.D., 199\n", "page": 361, "type": "text", "section": "Page 361"}
{"text": "Index\n345\nmodel driven engineering, 321, 322\nmodularity, 144, 206, 207, 225\nMohagheghi, P., 71, 321\nMoody, D.L., 32, 122, 136, 156, 173,\n322\nMoSCoW rules, 246, 247\nMSG, see sequence diagram\nMVC, see architectural pattern\n(model-view-controller)\nMyers, G.J., 207\nn-ary property, 132\nnon-functional properties, 34\nnon-functional requirements, 49\nnormal distribution, 60, 62\nNorman, D., 20, 308\nnoun-verb analysis, 220, 230\nobject, 139\u2013141, 143\u2013145, 153, 157,\n169, 172, 180, 225, 273\nobject\nanonymous, 158\nattribute, 157, 223\nbehaviour, 143, 161, 224, 271\ncharacteristics, 140, 174, 225\nclass relationship, 158, 174\nconstruction, 157\ncoupling, 139, 140\ncreation, 145, 146, 158, 222\ndesign, 235\ndesign method, 219\nencapsulation, 142, 144, 161, 225\nhierarchy, 143, 144, 155, 225\nidentity, 143, 145, 148, 271\ninheritance, 146, 155, 225, 256,\n271\ninteraction, 159, 165\nmethod, 142, 149, 151, 152, 157,\n159\nmodel, 139, 142\u2013144, 153\u2013157,\n172, 174, 183, 219, 220, 225,\n234\nnotation, 156, 175\nparadigm, 139, 140\npolymorphism, 148, 149, 155,\n161, 256\nrelationship, 139, 150, 174\nstate, 157, 161, 271\nuses, 157\nobject inheritance graph, 223, 225\nobject interaction graph, 222\u2013224\nobject interaction graph\ncontroller object, 222\nobject management group, 142, 184\nobject visibility graph, 223, 225\nObjectory, 226\nobservational study, 62, 68, 116\nO\ufb00ermann, P., 300\nOlbrich, S.M., 285, 290\nOMG, see object management group\nopen source software, 37, 142, 185,\n243, 285, 315, 316\nopportunistic strategy, 45, 54, 57,\n195, 200, 201, 205, 209, 241,\n264, 295, 296\nordinal measurement scale, 66\northogonality, 163\nOSI model, 268\nOSS, see open source software\nOwen, S., 66\nOzkaya, M., 81\np-spec, 212\nPage-Jones, M., 122, 131, 211, 212\nPahl, G., 179\nPalomba, F., 290\nParnas, D.L., 36, 52, 121, 206, 209,\n311, 312\npattern book, 54\nPerry, D.E., 80\nperspective, 96, 97\nPeters, L.J., 22\nPetre, M., 43, 47, 109, 110, 116, 173\nP\ufb02eeger, S.L., 252\nplug-and-play, 293\nPohthong, A., 295\npositivist philosophy, 60, 67, 68\nPreece, J., 239\npremature commitment, 106\nprimary study, 69, 70\nproduct line, 178, 186\n", "page": 362, "type": "text", "section": "Page 362"}
{"text": "346\nIndex\nprotocol analysis, 66\nprototype, 238, 239, 242, 248, 249,\n294\nprototype\nevolutionary, 238, 240, 294\nexperimental, 239\nexploratory, 228, 239, 247, 252,\n294, 295\nfunctional, 248\npublish-subscribe, 278\nPugh, S., 179\nPurchase, H.C., 136\nqualitative study, 64\u201366, 70, 72, 201\nquantitative study, 64, 66, 70, 72\nquasi-experiment, 62, 66, 67\nQumer, A., 258\nRAD, see rapid application\ndevelopment\nRadjenovi\u0107, D., 150, 174\nRandomised Controlled Trial, 61, 62,\n66, 70\nrapid application development, 226,\n243, 249\nRatcli\ufb00e, M., 125, 166, 229\nratio measurement scale, 67\nRational Uni\ufb01ed Process, 226\nRCT, see Randomised Controlled\nTrial\nreactive development, 315\nrefactoring, 251, 253, 255\u2013257, 259,\n260, 271, 285, 286\nRentsch, T., 140\nrepresentation, 96, 97\nrequirements\nelicitation, 228, 239\nevolution, 256\nmodel, 94, 197\nspeci\ufb01cation, 34, 38, 102, 121,\n197, 222, 237, 238, 317\nresearch\ndescription-driven, 71, 72\ndesign sciences, 71, 72\nresearch protocol, 65, 69, 72\nreuse, 21, 44, 45, 53, 54, 57, 78, 83,\n84, 177\u2013183, 191, 235, 261,\n284, 293, 295\nrisk, 94, 301\nrisk assessment, 242\nRittel, H.J., 22\nRobinson, P.J., 157\nRumbaugh, J., 142, 156, 164, 170,\n226\nRuneson, P., 67\nRUP, see Rational Uni\ufb01ed Process\nRuparelia, N., 257\nsafety-critical, 308, 317, 318\nsatis\ufb01cing, 54, 58, 305, 306\nscale, 94, 238\nscenario, 164, 169, 170, 222, 224, 311\nSchwaber, K., 253\nscrum, 253, 255, 257, 258, 260, 311\nscrum\nproduct backlog, 254\nrelease, 254\nsprint, 254\nsecondary study, 69\nSellar, W.C, 22\nseparation of concerns, 50, 51, 78, 82,\n83, 88, 89, 92, 144, 267,\n268, 277, 306, 308, 312\nsequence diagram, 105, 161, 164\u2013166,\n171, 183, 222, 224, 230\nservice\nparadigm, 177\nservice composition, 293\nservice-level agreement, 283, 299, 300\nservice-oriented architecture, 188,\n270, 299\nShadish, W.R., 62\nShahin, M., 92\nShapiro, S., 44, 54, 105, 206\nSharp, H., 308\nShaw, M., 78, 80\u201382\nSheetz, S.D, 155\nshells of knowledge, 56\nsilver bullet, 140\nSimon, H., 7, 54\n", "page": 363, "type": "text", "section": "Page 363"}
{"text": "Index\n347\nsimple object access protocol, 188\nsingle inheritance, 139, 148\nSj\u00f8berg, D.A.G., 67\nsketching, see design sketches\nSmith, G., 318\nSOA, see service-oriented\narchitecture\nSOAP, see simple object access\nprotocol, 299\nsoftware\nattribute, 95\ncomplexity, 196\nevolution, 10, 196\ninvisibility, 94, 196\nmaintenance, 10\nprocess, 119\u2013121, 126, 130, 137,\n141\nproperty, 95, 201\nsoftware as a service, 188, 298, 299\nsoftware service, 181, 187, 188, 191,\n192, 293, 298, 301, 302\nsoftware service\narchitecture, 299\nbinding time, 299, 300\nconsumer, 189, 299\ndelivery, 300\ndescription, 189\ndeveloper, 299\norchestration, 299, 300\nprovider, 189, 299, 301, 302\nstateless, 299\nsoftware service models, 188\nsoftware service pattern, 289\nsourceforge, 316\nspiral model, 241\u2013243\nSpivey, J.M., 105, 318\nSSADM, 103, 122, 214\u2013218, 233, 234,\n236, 258\nStallman, R.M., 315\nStapleton, J., 244, 246\nstate, 126\u2013128, 141, 143, 162, 167\nstate\nmodel, 128, 162\ntransition, 126, 128, 129, 162,\n163, 167, 168\nstate transition diagram, 105,\n127\u2013129, 161, 163, 218\nstate transition table, 129, 218\nstatechart, 105, 161, 162, 164, 183,\n232\nSTD, see state transition diagram\nSteinmacher, I., 37, 316\nstepwise re\ufb01nement, 206, 207\nstereotype, 160, 171\nStevens, W.P., 51, 131, 134, 207\nstopping rule, 22, 305, 322\nstory-board, 239, 247\nstructure chart, 105, 134\u2013136, 212,\n213\nstructured design, 211, 212\nstructured systems analysis, 211, 212\nSTT, see state transition table\nsuperclass, 223\nsurvey, 66, 67, 233, 234, 259, 289\nsynchronisation bar, 167, 168\nSynder, A., 142\nsystematic review, 69\u201373, 91\nSzyperski, C., 181, 186, 191\nTaivalsaari, A., 141\ntechnical debt, 10, 11, 17, 36, 40, 79,\n88, 107, 121, 148, 184\u2013186,\n196, 209, 252, 255, 259, 262,\n272, 297, 311\nTempero, E., 257, 259\nthink-aloud, 66\ntimebox, 246, 247, 249, 254, 255,\n258\u2013260\ntimeline, 165\nTiwari, S., 173\nTomayko, J.E., 53\ntop-down strategy, 287\ntransaction analysis, 213, 214\ntransform analysis, 213, 214\ntransition\naction, 128, 129\ncondition, 128\ntriangulation, 68\nTruex, D., 239\ntrust, 298\n", "page": 364, "type": "text", "section": "Page 364"}
{"text": "348\nIndex\nTurner, M., 188, 271, 298\nUML, 136, 142, 156\u2013158, 160, 162,\n164, 165, 167, 170, 173, 175,\n183, 189, 226, 230, 231, 312,\n321, 322\nUni\ufb01ed Modeling Language, see\nUML\nUni\ufb01ed Process, 172, 219, 226\u2013232,\n235, 244\nUnix, 185, 199, 295\nUP, see Uni\ufb01ed Process\nuse case, 164, 169, 170, 172, 173, 222,\n228\u2013231, 240, 311\nuse case\nactor, 170, 171\nuse case diagram, 105, 170, 171\nuser stories, 114, 117, 122, 172, 251,\n254\nuses, see coupling\nVale, T., 297, 302\nvan Aken, J.E., 71, 200\nvan der Hoek, A., 47, 111, 116, 200\nvan Vliet, H., 54, 55, 79\nVane, T., 190\nVessey, I., 55, 155, 173, 207\u2013209, 235\nviewpoint, 96, 97, 99, 171, 174, 201,\n207, 225, 241\nviewpoint\nconstruction, 260\nbehaviour, 98, 101, 121, 126,\n165, 232, 264, 273\nconstruction, 98, 100, 121, 134,\n148, 153, 157, 183, 225, 264,\n273, 286\ndata-modelling, 98, 102, 121,\n130, 158\nfunction, 98, 101, 121, 167, 299\nmodel, 222\nVisser, W., 45, 205, 209\nVlissides, J., 272\nWard, P.T., 127, 211\nwaterfall model, 37, 205, 236, 237\nWeaver, P.L., 215\nweb service, 188\nweb services description language,\n188\nWeinberg, G.M., 199, 311\nWell-Structured Problem, 7, 9, 21,\n24, 28, 54, 197, 210, 241,\n253, 259, 317\nWendor\ufb00, P., 289\nwhite box, 97, 162, 232, 248, 249, 317\nWhittle, J., 321, 322\nwicked problem, 22\nWieringa, R., 122, 220\nWilliams, B.J., 91\nWirth, N., 206\nWood, M., 148\nWoodcock, J., 320\nwork\ufb02ow, 229, 231, 232\nWren, C., 53\nWSDL, see web services description\nlanguage\nWSP, see Well-Structured Problem\nWu, M-W., 316\nXP, 241, 250\u2013253, 255, 257, 258, 260\nXP\nmetaphor, 251, 253\nplanning game, 251\npractice, 250, 252\nvalue, 250, 252\nYakimovich, D., 297\nYin, R.K., 68\nYourdon, E., 311\nZ, see formal description technique\nZhang, C., 71, 274, 288, 289\n", "page": 365, "type": "text", "section": "Page 365"}
