{"text": "Creational Patterns\nAbstract Factory (87) Provide an interface \nfor creating families of related or dependent\nobjects without specifying their concrete classes.\nBuilder (97) Separate the construction of a complex object from its representation so\nthat the same construction process can create different representations.\nFactory Method (107) Define an interface for creating an object, but let subclasses de-\ncide which class to instantiate. Factory Method lets a class defer instantiation to\nsubclasses.\nPrototype (117) Specify the kinds of objects \nto create using a prototypical instance, and\ncreate new objects by copying this prototype.\nSingleton (127) Ensure a class only has one instance, and provide a global point of\naccess to it.\nStructural Patterns\nAdapter (139) Convert the interface of a class into another interface clients expect.\nAdapter lets classes work together that couldn't otherwise because of incompat-\nible interfaces.\nBridge (151) Decouple an abstraction from its implementation so that the two can \nvary\nindependently.\nComposite (163) Compose objects into tree structures to represent part-whole hierar-\nchies. Composite lets clients treat individual objects and compositions of objects\nuniformly.\nDecorator (175) Attach \nadditional responsibilities to an object dynamically. \nDecorators\nprovide a flexible alternative to subclassing for extending functionality.\nFacade (185) Provide a unified interface to a set of interfaces in a subsystem. Facade\ndefines a higher-level interface that makes the subsystem easier to use.\nFlyweight (195) Use sharing to support large numbers of fine-grained objects effi-\nciently.\nProxy (207) Provide a surrogate or placeholder for another object to control access to\nit.\n", "page": 2, "type": "text", "section": "Page 2"}
{"text": "Behavioral Patterns\nChain of Responsibility (223) Avoid coupling the sender of a request to its receiver by\ngiving more than one object a chance to handle the request. Chain the receiving\nobjects and pass the request along the chain until an object handles it.\nCommand (233) Encapsulate a request as an object, thereby letting you parameter-\nize clients with different requests, queue or log requests, and support undoable \noperations.\nInterpreter (243) Given a language, define a represention for its grammar along with\nan interpreter that uses the representation to interpret sentences in the language.\nIterator (257) Provide a way to access the elements of an aggregate object sequentially\nwithout exposing its underlying representation.\nMediator (273) Define an object that encapsulates how a set of objects interact. Me-\ndiator promotes loose coupling by keeping objects from referring to each other\nexplicitly, and it lets you vary their interaction independently.\nMemento (283) Without violating encapsulation, capture and externalize an object's\ninternal state so that the object can be restored to this state later.\nObserver (293) Define a one-to-many dependency between objects so that when one\nobject changes state, all its dependents are notified and updated automatically.\nState (305) Allow an object to alter its behavior when its internal state changes. The\nobject will appear to change its class.\nStrategy (315) Define a family of algorithms, encapsulate each one, and make them\ninterchangeable. Strategy lets the algorithm vary independently from clients that\nuse it.\nTemplate Method (325) Define the skeleton of an algorithm in an operation, deferring\nsome steps to subclasses. Template Method lets subclasses redefine certain steps\nof an algorithm without changing the algorithm's structure.\nVisitor (331) Represent an operation to be performed on the elements of an object\nstructure. Visitor lets you define a new operation without changing the classes of\nthe elements on which it operates.\n", "page": 3, "type": "text", "section": "Page 3"}
{"text": "This page intentionally left blank \n", "page": 4, "type": "text", "section": "Page 4"}
{"text": "Design Patterns\n", "page": 5, "type": "text", "section": "Page 5"}
{"text": "Addison-Wesley Professional Computing Series\nBrian W. Kernighan, Consulting Editor\nMatthew H. Austern, Generic Programming and the STL: Using and Extending the C++ Standard Template Library\nDavid R. Butenhof, Programming with POSIX\u00ae Threads \nBrent Callaghan, NFS Illustrated \nTom Cargill, C++ Programming Style \nWilliam R. Ches \nwick \n/Steven M. Bellovin/Aviel D. Rubin, Firewalls and Internet Security, Second Edition: Repelling\nthe Wily Hacker\nDavid A. Curry, UNIX\u00ae System Security: A Guide for Users and System Administrators \nStephen C. Dewhurst, C++ Gotchas: \nAvoiding Common Problems in Coding and Design \nDan Farmer/Wietse Venema, Forensic Discovery \nErich Gamma/Richard Helm/Ralph Johnson/John Vlissides, Design Patterns: Elements of Reusable Object-\nOriented Software\nErich Gamma/Richard Helm/Ralph Johnson/John Vlissides, Design Patterns CD: Elements of Reusable Object-\nOriented Software\nPeter Haggar, Practical Java\"\" Programming Language Guide \nDavid R. Hanson, C Interfaces and Implementations: Techniques for Creating Reusable Software \nMark Harrison/Michael McLennan, Effective Tcl/Tk Programming: Writing Better Programs with Tcl and Tk \nMichi Henning/Steve Vinoski, Advanced CORBA\u00ae Programming with \nC++ \nBrian W. Kernighan/Rob Pike, The Practice of Programming \nS. Keshav, An Engineering Approach to Computer Networking: ATM Networks, the Internet, and the Telephone Network \nJohn Lakos, Large-Scale C++ Software Design \nScott Meyers, Effective C++ CD: 85 Specific Ways to Improve Your Programs and Designs \nScott Meyers, Effective C++, Third Edition: 55 Specific Ways to Improve Your Programs and Designs \nScott Meyers, More Effective C++: 35 New Ways to Improve Your Programs and Designs \nScott Meyers, Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library \nRobert B. Murray, C++ Strategies and Tactics \nDavid R. Musser/Gillmer J. Derge/Atul Saini, STL Tutorial and Reference Guide, Second Edition:\nC++ Programming with the Standard Template Library\nJohn K. Ousterhout, Tel and the Tk Toolkit \nCraig Partridge, Gigabit Networking \nRadia Perlman, Interconnections, Second Edition: Bridges, Routers, Switches, and Internetworking Protocols \nStephen A. Rago, UNIX\u00ae System V Network Programming \nEric S. Raymond, The Art of UNIX Programming \nMarc J. Rochkind, Advanced UNIX Programming, Second Edition \nCurt Schimmel, UNIX\u00ae Systems for Modern Architectures: \nSymmetric Multiprocessing and Caching for Kernel Programmers\nW. Richard Stevens, TCP/IP Illustrated, Volume 1: The Protocols \nW. Richard Stevens, TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP, and the UNIX\u00ae\nDomain Protocols\nW. Richard Stevens/Bill Fenner/Andrew M. Rudoff, UNIX Network Programming Volume 1, Third Edition: The \nSockets Networking API\nW. Richard Stevens/Stephen A. Rago, Advanced Programming in the UNIX\u00ae Environment, Second Edition\nW. Richard Stevens/Gary R. Wright, TCP/IP Illustrated Volumes 1-3 Boxed Set \nJohn Viega/Gary McGraw, \nBuilding Secure Software: How to Avoid Security Problems the Right Way \nGary R. Wright/W. Richard Stevens, TCP/IP Illustrated, Volume 2: The Implementation \nRuixi Yuan/W. \nTimothy Strayer, Virtual Private Networks: Technologies and Solutions\nVisit www.awprofessional.com/series/professionalcomputing for more information \nabout these titles.\n", "page": 6, "type": "text", "section": "Page 6"}
{"text": "Design Patterns\nElements of Reusable Object-Oriented Software\nErich Gamma\nRichard Helm\nRalph Johnson\nJohn Vlissides\nBoston \u2022 San Francisco \u2022 New York \u2022 Toronto \u2022 Montreal\nLondon \u2022 Munich \u2022 Paris \u2022 Madrid \nCapetown \u2022 Sidney \u2022 Tokyo \u2022 Singapore \u2022 Mexico City\n", "page": 7, "type": "text", "section": "Page 7"}
{"text": "Material from A Pattern Language: Towns/Buildings/Construction by Christopher Alexander,\ncopyright \u00a9 1977 by Christopher Alexander is reprinted by permission of Oxford University\nPress, Inc.\nMany of the designations used by manufacturers and sellers to distinguish their products are claimed as\ntrademarks. Where those designations appear in this book, and we were aware of a trademark claim, the\ndesignations have been printed in initial capital letters or in all capitals.\nThe author and publisher have taken care in the preparation of this book, but make no expressed or\nimplied warranty of any kind and assume no responsibility for errors or omissions. No liability is\nassumed for incidental or consequential damages in connection with or arising out of the use of the\ninformation or programs contained herein.\nThe publisher offers discounts on this book when ordered in quantity for special sales. For more informa-\ntion, please contact:\nPearson Education Corporate Sales Division\n201 W. 103rd Street \nIndianapolis, IN 46290 \n(800) 428-5331\ncorpsales@pearsoned.com\nVisit AW on the Web: www.awprofessional.com\nLibrary of Congress Cataloging-in-Publication Data\nDesign Patterns : elements of reusable object-oriented software / Erich Gamma ... [et al.]. \np. cm.\u2014(Addison-Wesley professional computing series)\nIncludes bibliographical references and index.\nISBN 0-201-63361-2\n1. Object-oriented programming (Computer science) 2. Computer software\u2014Reusability.\nI. Gamma, Erich. II. Series.\nQA76.64.D47 1994\n005.1'2-dc20 \n94-34264\nCIP\nCopyright \u00a9 1995 by Addison-Wesley\nAll rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or\ntransmitted, in any form, or by any means, electronic, mechanical, photocopying, recording, or other-\nwise, without the prior consent of the publisher. Printed in the United States of America. Published\nsimultaneously in Canada.\nCover art \u00a9 M.C. Escher/Cordon Art - Baarn - Holland. All rights reserved.\nISBN 0-201-63361-2\nText printed in the United States on recycled paper at Courier Westford in Westford, Massachusetts.\n37th Printing \nMarch 2009\n", "page": 8, "type": "text", "section": "Page 8"}
{"text": "To Karin\n\u2014E.G. \nTo Sylvie\n\u2014R.H.\nTo Faith\n-R.J.\nTo Dru Ann and Matthew\nJoshua 24:15b\n\u2014J.v.\n", "page": 9, "type": "text", "section": "Page 9"}
{"text": "Praise for Design Patterns: Elements of Reusable\nObject-Oriented Software\n\"This is one of the best written and wonderfully insightful books that I have read in a great long while...this\nbook establishes the legitimacy of patterns in the best way: not by argument but by example.\"\n\u2014 Stan Lippman, C++ Report\n\"...this new book by Gamma, Helm, Johnson, and Vlissides promises to have an important and lasting\nimpact on the discipline of software design. Because Design Patterns bills itself as being concerned with\nobject-oriented software alone, I fear that software developers outside the object community may ignore it.\nThis would be a shame. This book has something for everyone who designs software. All software design-\ners use patterns; understanding better the reusable abstractions of our work can only make us better at it.\"\n\u2014 Tom DeMarco, IEEE Software\n\"Overall, I think this book represents an extremely valuable and unique contribution to the field because\nit captures a wealth of object-oriented design experience in a compact and reusable form. This book is\ncertainly one that I shall turn to often in search of powerful object-oriented design ideas; after all, that's\nwhat reuse is all about, isn't it?\"\n\u2014 Sanjiv Gossain, Journal of Object-Oriented Programming\n\"This much-anticipated book lives up to its full year of advance buzz. The metaphor is of an architect's\npattern book filled with time-tested, usable designs. The authors have chosen 23 patterns from decades of\nobject-oriented experience. The brilliance of the book lies in the discipline represented by that number.\nGive a copy of Design Patterns to every good programmer you know who wants to be better.\"\n\u2014 Larry O'Brien, Software Development\n\"The simple fact of the matter is that patterns have the potential to permanently alter the software\nengineering field, catapulting it into the realm of true elegant design. Of the books to date on this subject,\nDesign Patterns is far and away the best. It is a book to be read, studied, internalized, and loved. The book\nwill forever change the way you view software.\"\n\u2014 Steve Bilow, Journal of Object-Oriented Programming\n\"Design Patterns is a powerful book. After a modest investment of time with it, most C++ programmers\nwill be able to start applying its \"patterns\" to produce better software. This book delivers intellectual\nleverage: concrete tools that help us think and express ourselves more effectively. It may fundamentally\nchange the way you think about programming.\n\u2014 Tom Cargill, C++ Report\n", "page": 10, "type": "text", "section": "Page 10"}
{"text": "Contents\nPreface \nxi\nForeword \nxiii\nGuide to Readers \nxv\n1 Introduction \n1\n1.1 What Is a Design Pattern? \n2\n1.2 Design Patterns in Smalltalk MVC \n4\n1.3 Describing Design Patterns \n6\n1.4 The Catalog of Design Patterns \n8\n1.5 Organizing the Catalog \n9\n1.6 How Design Patterns Solve Design Problems \n11\n1.7 How to Select a Design Pattern \n28\n1.8 How to Use a Design Pattern \n29\n2 A Case Study: Designing a Document Editor \n33\n2.1 Design Problems \n33\n2.2 Document Structure \n35\n2.3 Formatting \n40\n2.4 Embellishing the User Interface . \n43\n2.5 Supporting Multiple Look-and-Feel Standards \n47\n2.6 Supporting Multiple Window Systems \n51\n2.7 User Operations \ni \n58\n2.8 Spelling Checking and Hyphenation \n64\nvii\n", "page": 11, "type": "text", "section": "Page 11"}
{"text": "viii \nCONTENTS\n2.9 Summary \n76\nDesign Pattern Catalog \n79\n3 Creational \nPatterns \n81\nAbstract Factory \n87\nBuilder \n97\nFactory Method \n107\nPrototype \n117 \nSingleton \n127\nDiscussion of Creational Patterns \n135\n4 Structural Patterns \n137\nAdapter \n139\nBridge \n151\nComposite \n163\nDecorator \n175\nFacade \n185\nFlyweight \n195 \nProxy \n207\nDiscussion of Structural Patterns \n219\n5 Behavioral Patterns \n221\nChain of Responsibility \n223\nCommand \n233\nInterpreter \n243\nIterator \n257\nMediator \n273\nMemento \n283 \nObserver \n293\nState \n305\nStrategy \n315\n", "page": 12, "type": "text", "section": "Page 12"}
{"text": "CONTENTS \nix\nTemplate Method \n325\nVisitor \n331\nDiscussion of Behavioral Patterns \n345\n6 Conclusion \n351\n6.1 What to Expect from Design Patterns \n351\n6.2 A Brief History \n355\n6.3 The Pattern Community \n356\n6.4 An Invitation \n358\n6.5 A Parting Thought \n358\nA Glossary \n359\nB Guide to Notation \n363\nB.I Class Diagram \n363\nB.2 Object Diagram \n364\nB.3 Interaction Diagram \n366\nC Foundation Classes \n369\nC.1 List \n369\nC.2 Iterator \n372\nC.3 Listlterator \n372\nC.4 Point \n373\nC.5 Rect \n374\nBibliography \n375\nIndex \n383\n", "page": 13, "type": "text", "section": "Page 13"}
{"text": "This page intentionally left blank \n", "page": 14, "type": "text", "section": "Page 14"}
{"text": "Preface\nThis book isn't an introduction to object-oriented technology or design. Many books\nalready do a good job of that. This book assumes you are reasonably proficient in at least\none object-oriented programming language, and you should have some experience in\nobject-oriented design as well. You definitely shouldn't have to rush to the nearest\ndictionary the moment we mention \"types\" and \"polymorphism,\" or \"interface\" as\nopposed to \"implementation\" inheritance.\nOn the other hand, this isn't an advanced technical treatise either. It's a book of design\npatterns that describes simple and elegant solutions to specific problems in object-\noriented software design. Design patterns capture solutions that have developed and\nevolved over time. Hence they aren't the designs people tend to generate initially. They\nreflect untold redesign and receding as developers have struggled for greater reuse \nand flexibility in their software. Design patterns capture these solutions in a succinct\nand easily applied form.\nThe design patterns require neither unusual language features nor amazing program-\nming tricks with which to astound your friends and managers. All can be implemented \nin standard object-oriented languages, though they might take a little more work than\nad hoc \nsolutions. But the extra effort invariably pays dividends in increased flexibility\nand reusability.\nOnce you understand the design patterns and have had an \"Aha!\" (and not just a\n\"Huh?\") experience with them, you won't ever think about object-oriented design in\nthe same way. You'll have insights that can make your own designs more flexible,\nmodular, reusable, and understandable\u2014which is why you're interested in object-\noriented technology in the first place, right?\nA word of warning and encouragement: Don't worry if you don't understand this\nbook completely on the first reading. We didn't understand it all on the first writing!\nRemember that this isn't a book to read once and put on a shelf. We \nhope you'll find\nyourself referring to it again and again for design insights and for inspiration.\nThis book has had a long gestation. It has seen four countries, three of its authors'\nmarriages, and the birth of two (unrelated) offspring. Many people have had a part\nin its development. Special thanks are due Bruce Anderson, Kent Beck, and Andre\nWeinand for their inspiration and advice. We also thank those who reviewed drafts\nXI\n", "page": 15, "type": "text", "section": "Page 15"}
{"text": "xii \nPREFACE\nof the manuscript: Roger Bielefeld, Grady Booch, Tom Cargill, Marshall Cline, Ralph\nHyre, Brian Kernighan, Thomas Laliberty, Mark Lorenz, Arthur Riel, Doug Schmidt,\nClovis Tondo, Steve Vinoski, and Rebecca Wirfs-Brock. We are also grateful to the\nteam at Addison-Wesley for their help and patience: Kate Habib, Tiffany Moore, Lisa\nRaffaele, Pradeepa Siva, and John Wait. Special thanks to Carl Kessler, Danny Sabbah,\nand Mark Wegman at IBM \nResearch for their unflagging support of this work.\nLast but certainly not least, we thank everyone on the Internet and points beyond who\ncommented on versions of the patterns, offered encouraging words, and told us that\nwhat we were doing was worthwhile. These people include but are not limited to \nJon Avotins, Steve Berczuk, \nJulian Berdych, Matthias Bohlen, John Brant, Allan Clarke,\nPaul Chisholm, Jens Coldewey, Dave Collins, Jim \nCoplien, Don Dwiggins, Gabriele Elia,\nDoug Felt, Brian Foote, Denis Fortin, Ward Harold, Hermann Hueni, Nayeem Islam,\nBikramjit Kalra, Paul Keefer, Thomas Kofler, Doug Lea, \nDan LaLiberte, James Long,\nAnn Louise Luu, Pundi Madhavan, Brian Marick, Robert Martin, Dave McComb, Carl\nMcConnell, Christine Mingins, Hanspeter Mossenbock, Eric Newton, Marianne Ozkan,\nRoxsan Payette, Larry Podmolik, George Radin, Sita Ramakrishnan, Russ Ramirez,\nAlexander Ran, \nDirk Riehle, Bryan Rosenburg, Aamod Sane, Duri Schmidt, Robert\nSeidl, Xin Shu, \nand Bill \nWalker.\nWe don't consider this collection of design patterns complete and static; it's more a\nrecording of our current thoughts on design. We welcome comments on it, whether\ncriticisms of our examples, references and known uses we've missed, or design \npat-\nterns we should have included. You can write us care of Addison-Wesley, or send\nelectronic mail to design-patterns@cs.uiuc. edu. You can also obtain softcopy \nfor the code in the Sample Code sections by sending the message \"send design pattern\nsource\" to design-patterns-sourceics. uiuc. edu. \nAnd \nnow \nthere's a Web page\nat http://st-www.cs.uiuc.edu/users/patterns/DPBook/DPBook.html for\nlate-breaking information and updates.\nMountain View, California \nE.G.\nMontreal, Quebec \nR.H.\nUrbana, Illinois \nR.J.\nHawthorne, New York \nJ.V.\nAugust 1994\n", "page": 16, "type": "text", "section": "Page 16"}
{"text": "Foreword\nAll well-structured object-oriented architectures are full of patterns. Indeed, one of the\nways that I measure the quality of an object-oriented system is to judge whether or\nnot its developers have paid careful attention to the common collaborations among its\nobjects. Focusing on such mechanisms during a system's development can yield an\narchitecture that is smaller, simpler, and far more understandable than if these patterns\nare ignored.\nThe importance of patterns in crafting complex systems has been long recognized in\nother disciplines. In particular, Christopher Alexander and his colleagues were perhaps\nthe first to propose the idea of using a pattern language to architect buildings and cities.\nHis ideas and the contributions of others have now taken root in the object-oriented\nsoftware community. In short, the concept of the design pattern in software provides a\nkey to helping developers leverage the expertise of other skilled architects.\nIn this book, Erich Gamma, \nRichard Helm, Ralph \nJohnson, and John \nVlissides introduce\nthe principles of design patterns and then offer a catalog of such patterns. Thus, this\nbook makes two important contributions. First, it shows the role that patterns can play\nin architecting complex systems. Second, it provides a very pragmatic reference to a set\nof well-engineered patterns that the practicing developer can apply to crafting his or\nher own specific applications.\nI'm honored to have had the opportunity to work directly with some of the authors of\nthis book in architectural design efforts. I have learned much from them, and I suspect\nthat in reading this book, you will also.\nGrady Booch\nChief Scientist, Rational \nSoftware Corporation\nxm\n", "page": 17, "type": "text", "section": "Page 17"}
{"text": "This page intentionally left blank \n", "page": 18, "type": "text", "section": "Page 18"}
{"text": "Guide to Readers\nThis book has two main parts. The first part (Chapters 1 and 2) describes what design\npatterns are and how they help you design object-oriented software. \nIt includes a design\ncase study that demonstrates how design patterns apply in practice. The second part\nof the book (Chapters 3,4, and 5) is a catalog of the actual design patterns.\nThe catalog makes up the majority of the book. Its chapters divide the design patterns\ninto three types: creational, structural, and behavioral. You can use the catalog hi several\nways. You \ncan read the catalog from start to finish, or you can just browse from pattern \nto pattern. Another approach is to study one of the chapters. That will help you see\nhow closely related patterns distinguish themselves.\nYou can use the references between the patterns as a logical route through the catalog.\nThis approach will give you insight into how patterns relate to each other, how they can\nbe combined with other patterns, and which patterns work well together. Figure 1.1\n(page 12) \ndepicts these references graphically.\nYet another way to read the catalog is to use a more problem-directed approach. Skip\nto Section 1.6 (page 24) to read about some common problems hi designing reusable\nobject-oriented software; then read the patterns that address these problems. Some\npeople read the catalog through first and then use a problem-directed approach to\napply the patterns to their projects.\nIf you aren't an experienced object-oriented designer, then start with the simplest and\nmost common patterns:\n\u2022 Abstract Factory (page 87) \n\u2022 Factory Method (107)\n\u2022 Adapter (139) \n\u2022 Observer (293)\n\u2022 Composite (163) \n\u2022 Strategy (315)\n\u2022 Decorator (175) \n\u2022 Template Method (325)\nIt's hard to find an object-oriented system that doesn't use at least a couple of these\npatterns, and large systems use nearly all of them. This subset will help you understand\ndesign patterns in particular and good object-oriented design in general.\nxv\n", "page": 19, "type": "text", "section": "Page 19"}
{"text": "This page intentionally left blank \n", "page": 20, "type": "text", "section": "Page 20"}
{"text": "Chapter 1\nIntroduction\nDesigning object-oriented software is hard, and designing reusable object-oriented soft-\nware is even harder. You must find pertinent objects, factor them into classes at the\nright granularity, define class interfaces and inheritance hierarchies, and establish key\nrelationships among them. Your design should be specific to the problem at hand but\nalso general enough to address future problems and requirements. You also want to\navoid redesign, or at least minimize it. Experienced object-oriented designers will tell\nyou that a reusable and flexible design is difficult if not impossible to get \"right\" the first\ntime. Before a design is finished, they usually try to reuse it several times, modifying it\neach time.\nYet experienced object-oriented designers do make good designs. Meanwhile new\ndesigners are overwhelmed by the options available and tend to fall back on non-\nobject-oriented techniques they've used before. It takes a long time for novices to learn\nwhat good object-oriented design is all about. Experienced designers evidently know\nsomething inexperienced ones don't. What is it?\nOne thing expert designers know not to do is solve every problem from first principles.\nRather, they reuse solutions that have worked for them in the past. When they find a\ngood solution, they use it again and again. Such experience is part of what makes them \nexperts. Consequently, you'll find recurring patterns of classes and communicating\nobjects in many object-oriented systems. These patterns solve specific design problems\nand make object-oriented designs more flexible, elegant, and ultimately reusable. They\nhelp designers reuse successful designs by basing new designs on prior experience.\nA designer who is familiar with such patterns can apply them immediately to design\nproblems without having to rediscover them.\nAn analogy will help illustrate the point. Novelists and playwrights rarely design\ntheir plots from scratch. Instead, they follow patterns like \"Tragically Flawed Hero\"\n(Macbeth, Hamlet, etc.) or \"The Romantic \nNovel\" (countless romance novels). In the\nsame way, \nobject-oriented designers follow patterns like \"represent states with objects\"\n1\n", "page": 21, "type": "text", "section": "Page 21"}
{"text": "2 \nINTRODUCTION \nCHAPTER 1\nand \"decorate objects so you can easily add/remove features.\" Once you know the\npattern, a lot of design decisions follow automatically.\nWe all know the value of design experience. How many times have you had design deja-\nvu\u2014that feeling that you've solved a problem before \nbut not knowing exactly where or\nhow? If you could remember the details of the previous problem and how you solved\nit, then you could reuse the experience instead of rediscovering it. However, we don't\ndo a good job of recording experience in software design for others to use.\nThe purpose of this book is to record experience in designing object-oriented software as\ndesign patterns. Each design pattern systematically names, explains, and evaluates an\nimportant and recurring design in object-oriented systems. Our goal is to capture design\nexperience in a form that people can use effectively. To this end we have documented\nsome of the most important design patterns and present them as a catalog.\nDesign patterns make it easier to reuse successful designs and architectures. Expressing\nproven techniques as design patterns makes them more accessible to developers of\nnew systems. Design patterns help you choose design alternatives that make a system\nreusable and avoid alternatives that compromise reusability. Design patterns can even\nimprove the documentation and maintenance of existing systems by furnishing an\nexplicit specification of class and object interactions and their underlying intent. Put\nsimply, design patterns help a designer get a design \"right\" faster.\nNone of the design patterns in this book describes new or unproven designs. We have\nincluded only designs that have been applied more than once in different systems. Most\nof these designs have never been documented before. They are either part of the folklore\nof the object-oriented community or are elements of some successful object-oriented\nsystems\u2014neither of which is easy for novice designers to learn from. So although these\ndesigns aren't new, we capture them in a new and accessible way: as a catalog of design\npatterns having a consistent format.\nDespite the book's size, the design patterns in it capture only a fraction of what an expert\nmight know. It doesn't have any patterns dealing with concurrency or distributed pro-\ngramming or real-time programming. It doesn't have any application domain-specific\npatterns. It doesn't tell you how to build user interfaces, how to write device drivers,\nor how to use an object-oriented database. Each of these areas has its own patterns, and\nit would be worthwhile for someone to catalog those too.\n1.1 What Is a Design Pattern?\nChristopher Alexander says, \"Each pattern describes a problem which occurs over and\nover again in our environment, and then describes the core of the solution to that\nproblem, in such a way that you can use this solution a million times over, without ever\ndoing it the same way twice\" [AIS+77, page x}. Even though Alexander was talking\nabout patterns in buildings and towns, what he says is true about object-oriented design\npatterns. Our solutions are expressed in terms of objects \nand interfaces instead of walls\n", "page": 22, "type": "text", "section": "Page 22"}
{"text": "SECTION 1.1 \nWHAT IS A DESIGN PATTERN? \n3\nand doors, but at the core of both kinds of patterns is a solution to a problem in a\ncontext.\nIn general, a pattern has four essential elements:\n1. The pattern name is a handle we can use to describe a design problem, its so-\nlutions, and consequences in a word or two. Naming a pattern immediately\nincreases our design vocabulary. It lets us design at a higher level of abstraction.\nHaving a vocabulary for patterns lets us talk about them with our colleagues,\nin our documentation, and even to ourselves. It makes it easier to think about\ndesigns and to communicate them and their trade-offs to others. Finding good \nnames has been one of the hardest parts of developing our catalog.\n2. The \nproblem describes when to apply the pattern. It explains the problem and its\ncontext. It might describe specific design problems such as how to represent algo-\nrithms as objects. It might describe class or object structures that are symptomatic\nof an inflexible design. Sometimes the problem will include a list of conditions\nthat must be met before it makes sense to apply the pattern.\n3. The \nsolution describes the elements that make up the design, their relationships,\nresponsibilities, and collaborations. The solution doesn't describe a particular\nconcrete design or implementation, because a pattern is like a template that can\nbe applied in many different situations. Instead, the pattern provides an abstract\ndescription of a design problem and how a general arrangement of elements\n(classes and objects in our case) solves it.\n4. The consequences are the results and trade-offs of applying the pattern. Though\nconsequences are often unvoiced when we describe design decisions, they are\ncritical for evaluating design alternatives and for understanding the costs and\nbenefits of applying the pattern.\nThe consequences for software often concern space and time trade-offs. They\nmay address language and implementation issues as well. Since reuse is often a\nfactor in object-oriented design, the consequences of a pattern include its impact\non a system's flexibility, extensibility, or portability. Listing these consequences\nexplicitly helps you understand and evaluate them.\nPoint of view affects one's interpretation of what is and isn't a pattern. One person's\npattern can be another person's primitive building block. For \nthis book we have \nconcen-\ntrated on patterns at a certain level of abstraction. Design patterns are not about designs\nsuch as linked lists and hash tables that can be encoded in classes and reused as is. Nor\nare they complex, domain-specific designs for an entire application or subsystem. The\ndesign patterns in this book are descriptions of communicating objects and classes that are\ncustomized to solve a general design problem in a particular context.\nA design pattern names, abstracts, and identifies the key aspects of a common design\nstructure that make it useful for creating a reusable object-oriented design. The design\npattern identifies the participating classes and instances, their roles and collaborations,\n", "page": 23, "type": "text", "section": "Page 23"}
{"text": "4 \nINTRODUCTION \nCHAPTER 1\nand the distribution of responsibilities. Each design pattern focuses on a particular\nobject-oriented design problem or issue. It describes when it applies, whether it can be\napplied in view of other design constraints, and the consequences and trade-offs of its\nuse. Since we must eventually implement our designs, a design pattern also provides\nsample C++ and (sometimes) \nSmalltalk code to illustrate an implementation.\nAlthough design patterns describe object-oriented designs, they are based on practical\nsolutions that have been implemented in mainstream object-oriented programming\nlanguages like Smalltalk \nand C++ rather than procedural languages (Pascal, C, Ada) or\nmore dynamic object-oriented languages (CLOS, Dylan, Self). We chose Smalltalk and\nC++ for pragmatic reasons: Our day-to-day experience has been in these languages,\nand they are increasingly popular.\nThe choice of programming language is important because it influences one's point\nof view. Our patterns assume Smalltalk/C++-level language features, and that choice \ndetermines what can and cannot be implemented easily. If we assumed procedural\nlanguages, we might have included design patterns called \"Inheritance,\" \"Encapsu-\nlation,\" and \"Polymorphism.\" Similarly, some of our patterns are supported directly\nby the less common object-oriented languages. CLOS has multi-methods, for example,\nwhich lessen the need for a pattern such as Visitor (page 331). In fact, there are enough\ndifferences between Smalltalk and C++ to mean that some patterns can be expressed\nmore easily in one language than the other. (See Iterator (257) \nfor an example.)\n1.2 Design Patterns in Smalltalk MVC\nThe Model/View/Controller (MVC) triad of classes [KP88] is used to build user inter-\nfaces in Smalltalk-80. Looking at the design patterns inside MVC should help you see\nwhat we mean by the term \"pattern.\"\nMVC consists of three kinds of objects. The Model is the application object, the View is\nits screen presentation, and the Controller defines the way the user interface reacts to\nuser input. Before MVC, user interface designs tended to lump these objects together.\nMVC decouples them to increase flexibility and reuse.\nMVC decouples views and models by establishing a subscribe/notify protocol between\nthem. A view must ensure that its appearance reflects the state of the model. Whenever\nthe model's data changes, the model notifies views that depend on it. In response, each\nview gets an opportunity to update itself. This approach lets you attach multiple views\nto a model to provide different presentations. You \ncan also create new views for a model\nwithout rewriting it.\nThe following diagram shows a model and three views. (We've left out the controllers\nfor simplicity.) \nThe model contains some data values, and the views defining a spread-\nsheet, histogram, and pie chart display these data in various ways. The model commu-\nnicates with its views when its values change, and the views communicate with the\nmodel to access these values.\n", "page": 24, "type": "text", "section": "Page 24"}
{"text": "SECTION 1.2\nDESIGN PATTERNS IN SMALLTALK MVC \n5\nmodel\nTaken at face value, this example \nreflects a design that decouples views from models. \nBut\nthe design is applicable to a more general problem: decoupling objects so that changes\nto one can affect any number of others without requiring the changed object to know \ndetails of the others. This more general design is described by the Observer (page 293)\ndesign pattern.\nAnother feature of MVC is that views can be nested. For example, a control panel of\nbuttons might be implemented as a complex view containing nested button views. The\nuser interface for an object inspector can consist of nested views that may be reused in\na debugger. MVC supports nested views with the CompositeView class, a subclass of\nView. CompositeView objects act just like View objects; a composite view can be used\nwherever a view can be used, but it also contains and manages nested views.\nAgain, we could think of this as a design that lets us treat a composite view just like\nwe treat one of its components. But the design is applicable to a more general problem,\nwhich occurs whenever we want to group objects and treat the group like an individual\nobject. This more general design is described by the Composite (163) design pattern. It\nlets you create a class hierarchy in which some subclasses define primitive objects (e.g.,\nButton) and other classes define composite objects (CompositeView) that assemble the\nprimitives into more complex objects.\nMVC also lets you change the way a view responds to user input without changing its\nvisual presentation. You might want to change the way it responds to the keyboard, for\nexample, or have it use a pop-up menu instead of command keys. MVC encapsulates\nthe response mechanism in a Controller object. There is a class hierarchy of controllers,\nmaking it easy to create a new controller as a variation on an existing one.\n", "page": 25, "type": "text", "section": "Page 25"}
{"text": "6 \nINTRODUCTION \nCHAPTER 1\nA view uses an instance of a Controller subclass to implement a particular response\nstrategy; to implement a different strategy, simply replace the instance with a different\nkind of controller. It's even possible to change a view's controller at run-time to let the\nview change the way it responds to user input. For example, a view can be disabled so\nthat it doesn't accept input simply by giving it a controller that ignores input events.\nThe View-Controller relationship is an example of the Strategy (315) design pattern.\nA Strategy is an object that represents an algorithm. It's useful when you want to\nreplace the algorithm either statically or dynamically, when you have a lot of variants\nof the algorithm, or when the algorithm has complex data structures that you want to\nencapsulate.\nMVC uses other design patterns, such as Factory Method (107) to specify the default\ncontroller class for a view and Decorator (175) to add scrolling to a view. But the\nmain relationships in MVC \nare given by the Observer, Composite, and Strategy design\npatterns.\n1.3 Describing Design Patterns\nHow do we describe design patterns? Graphical \nnotations, while important and useful,\naren't sufficient. They simply capture the end product of the design process as rela-\ntionships between classes and objects. To reuse the design, we must also record the\ndecisions, alternatives, and trade-offs that led to it. Concrete examples are important \ntoo, because they help you see the design in action.\nWe describe design patterns using a consistent format. Each pattern is divided into\nsections according to the following template. The template lends a uniform structure\nto the information, \nmaking design patterns easier to learn, compare, and use.\nPattern Name and Classification\nThe pattern's name conveys the essence of the pattern succinctly. A good name\nis vital, because it will become part of your design vocabulary. The pattern's\nclassification reflects the scheme we introduce in Section 1.5.\nIntent\nA short statement that answers the following questions: What does the design\npattern do? What is its rationale and intent? What particular design issue or\nproblem does it address?\nAlso Known As\nOther well-known names for the pattern, if any.\nMotivation\nA scenario that illustrates a design problem and how the class and object structures\n", "page": 26, "type": "text", "section": "Page 26"}
{"text": "SECTION 1.3 \nDESCRIBING DESIGN PATTERNS \n7\nin the pattern solve the problem. The scenario will help you understand the more\nabstract description of the pattern that follows.\nApplicability\nWhat are the situations in which the design pattern can be applied? What are\nexamples of poor designs that the pattern can address? How can you recognize\nthese situations?\nStructure\nA graphical representation of the classes in the pattern using a notation based\non the Object Modeling Technique (OMT) [RBP+91]. We also use interaction di-\nagrams [JCJO92, Boo94] to illustrate sequences of requests and collaborations\nbetween objects. Appendix B \ndescribes these notations in detail.\nParticipants\nThe classes and/or objects participating in the design pattern and their responsi-\nbilities.\nCollaborations\nHow the participants collaborate to carry out their responsibilities.\nConsequences\nHow does the pattern support its objectives? What are the trade-offs and results\nof using the pattern? What aspect of system structure does it let you vary inde-\npendently?\nImplementation\nWhat pitfalls, hints, or techniques should you be aware of when implementing\nthe pattern? Are there language-specific issues?\nSample Code\nCode fragments that illustrate how you might implement the pattern in C++ or\nSmalltalk.\nKnown Uses\nExamples of the pattern found in real systems. We include at least two examples\nfrom different domains.\nRelated Patterns\nWhat design patterns are closely related to this one? What are the important\ndifferences? With which other patterns should this one be used?\nThe appendices provide background information that will help you understand the pat-\nterns and the discussions surrounding them. Appendix A is a glossary of terminology\n", "page": 27, "type": "text", "section": "Page 27"}
{"text": "8 \nINTRODUCTION \nCHAPTER 1\nwe use. We've already mentioned Appendix B, which presents the various notations.\nWe'll also describe aspects of the notations as we introduce them in the upcoming\ndiscussions. Finally, Appendix C contains source code for the foundation classes we\nuse in code samples.\n1.4 The Catalog of Design Patterns\nThe catalog \nbeginning on page 79 \ncontains 23 design patterns. Their names and intents\nare listed next to give you an overview. The number in parentheses after each pattern\nname gives the page number for the pattern (a convention we follow throughout the\nbook).\nAbstract Factory (87) Provide an interface for creating families of related or dependent\nobjects without specifying their concrete classes.\nAdapter (139) Convert the interface of a class into another interface clients expect.\nAdapter lets classes work together that couldn't otherwise because of incompat-\nible \ninterfaces.\nBridge (151) Decouple an abstraction from its implementation so that the two can vary\nindependently.\nBuilder (97) Separate the construction of a complex object from its representation so\nthat the same construction process can create different representations.\nChain of Responsibility (223) Avoid coupling the sender of a request to its receiver by\ngiving more than one object a chance to handle the request. Chain the receiving\nobjects and pass the request along the chain until an object handles it.\nCommand (233) Encapsulate a request as an object, thereby letting you parameter-\nize clients with different requests, queue or log requests, and support undoable\noperations.\nComposite (163) Compose objects into tree structures to represent part-whole hierar-\nchies. Composite lets clients treat individual objects and compositions of objects\nuniformly.\nDecorator (175) Attach \nadditional responsibilities to an object dynamically. Decorators\nprovide a flexible alternative to subclassing for extending functionality.\nFacade (185) Provide a unified interface to a set of interfaces in a subsystem. Facade\ndefines a higher-level interface that makes the subsystem easier to use.\nFactory Method (107) Define an interface for creating an object, but let subclasses de-\ncide which class to instantiate. Factory Method lets a class defer instantiation to\nsubclasses.\n", "page": 28, "type": "text", "section": "Page 28"}
{"text": "SECTION 1.5 \nORGANIZING THE CATALOG \n9\nFlyweight (195) Use sharing to support large numbers of fine-grained objects effi-\nciently.\nInterpreter (243) Given a language, define a represention for its grammar along with\nan interpreter that uses the representation to interpret sentences in the language.\nIterator (257) Provide a way to access the elements of an aggregate object sequentially\nwithout exposing its underlying representation.\nMediator (273) Define an object that encapsulates how a set of objects interact. Me-\ndiator promotes loose coupling by keeping objects from referring to each other\nexplicitly, and it lets you vary their interaction independently.\nMemento (283) Without violating encapsulation, capture and externalize an object's\ninternal state so that the object can be restored to this state later.\nObserver (293) Define a one-to-many dependency between objects so that when one\nobject changes state, all its dependents are notified and updated automatically.\nPrototype (117) Specify the kinds of objects \nto create using a prototypical instance, and\ncreate new objects \nby copying this prototype.\nProxy (207) Provide a surrogate or placeholder for another object to control access to\nit.\nSingleton (127) Ensure a class only has one instance, and provide a global point of\naccess to it.\nState (305) Allow an object to alter its behavior when its internal state changes. The\nobject will appear to change its class.\nStrategy (315) Define a family of algorithms, encapsulate each one, and make them\ninterchangeable. Strategy lets the algorithm vary independently from clients that\nuse it.\nTemplate Method (325) Define the skeleton of an algorithm in an operation, deferring\nsome steps to subclasses. Template \nMethod lets subclasses redefine certain steps\nof an algorithm without changing the algorithm's structure.\nVisitor (331) Represent an operation to be performed on the elements of an object\nstructure. Visitor \nlets you define a new operation without changing the classes of \nthe elements on which it operates.\n1.5 Organizing the Catalog\nDesign patterns vary in their granularity and level of abstraction. Because there are\nmany design patterns, we need a way to organize them. This section classifies design\npatterns so that we can refer to families of related patterns. The classification helps you\n", "page": 29, "type": "text", "section": "Page 29"}
{"text": "10\nINTRODUCTION\nCHAPTER 1\nScope\nClass\nObject\nPurpose\nCreational\nFactory Method (107)\nAbstract Factory (87)\nBuilder (97)\nPrototype (117)\nSingleton (127)\nStructural\nAdapter (class) (139)\nAdapter (object) (139)\nBridge (151)\nComposite (163)\nDecorator (175)\nFacade (185)\nFlyweight (195)\nProxy (207)\nBehavioral\nInterpreter (243)\nTemplate Method (325)\nChain of Responsibility (223)\nCommand (233)\nIterator (257)\nMediator (273)\nMemento (283)\nObserver (293)\nState (305)\nStrategy (315)\nVisitor (331)\nTable 1.1: Design pattern space\nlearn the patterns in the catalog faster, and it can direct efforts to find new patterns as\nwell.\nWe classify design patterns by two criteria (Table 1.1). The first criterion, called purpose,\nreflects what a pattern does. Patterns can have either creational, structural, or \nbehav-\nioral purpose. Creational patterns concern the process of object creation. Structural\npatterns deal with the composition of classes or objects. Behavioral patterns character-\nize the ways in which classes or objects interact and distribute responsibility.\nThe second criterion, called scope, specifies whether the pattern applies primarily to\nclasses or to objects. Class patterns deal with relationships between classes and their\nsubclasses. These relationships are established through inheritance, so they are static\u2014\nfixed at compile-time. Object patterns deal with object relationships, which can be\nchanged at run-time and are more dynamic. Almost all patterns use inheritance to\nsome extent. So the only patterns labeled \"class patterns\" are those that focus on class\nrelationships. Note that most patterns are in the Object scope.\nCreational class patterns defer some part of object creation to subclasses, while Cre-\national object patterns defer it to another object. The Structural class patterns use\ninheritance to compose classes, while the Structural object patterns describe ways to\nassemble objects. The Behavioral class patterns use inheritance to describe algorithms\nand flow of control, whereas the Behavioral object patterns describe how a group of\nobjects cooperate to perform a task that no single object can carry out alone.\nThere are other ways to organize the patterns. Some patterns are often used together. \nFor \nexample, Composite is often used with Iterator or Visitor. Some patterns are alternatives:\nPrototype is often an alternative to Abstract Factory. Some patterns result in similar\ndesigns even though the patterns have different intents. For example, the structure\ndiagrams of Composite and Decorator are similar.\n", "page": 30, "type": "text", "section": "Page 30"}
{"text": "SECTION 1.6 \nHOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS \n11\nYet another way to organize design patterns is according to how they reference each\nother in their \"Related Patterns\" sections. Figure 1.1 \ndepicts these relationships graph-\nically.\nClearly there are many ways to organize design patterns. Having multiple ways of\nthinking about patterns will deepen your insight into what they do, how they compare,\nand when to apply them.\n1.6 How Design Patterns Solve Design Problems\nDesign patterns solve many of the day-to-day problems object-oriented designers face,\nand in many different ways. Here are several of these problems and how design patterns \nsolve them.\nFinding Appropriate Objects\nObject-oriented programs are made up of objects. An object packages both data and\nthe procedures that operate on that data. The procedures are typically called methods\nor operations. An object performs an operation when it receives a request (or message)\nfrom a client.\nRequests are the only way to get an object to execute an operation. Operations are\nthe only way to change an object's internal data. Because of these restrictions, the\nobject's internal state is said to be encapsulated; it cannot be accessed directly, and its\nrepresentation is invisible from outside the object.\nThe hard part about object-oriented design is decomposing a system into objects. The\ntask is difficult because many factors come \ninto play: encapsulation, granularity, depen-\ndency, flexibility, performance, evolution, reusability, and on and on. They all \ninfluence\nthe decomposition, often in conflicting ways.\nObject-oriented design methodologies favor many different approaches. You \ncan write\na problem statement, single out the nouns and verbs, and create corresponding classes\nand operations. Or you can focus on the collaborations and responsibilities in your\nsystem. Or you can \nmodel the real world and translate the objects found during analysis\ninto design. There will always be disagreement on which approach is best.\nMany objects in a design come from the analysis model. But object-oriented designs\noften end up with classes that have no counterparts in the real world. Some of these are\nlow-level classes like arrays. Others are much higher-level. For example, the Compos-\nite (163) pattern introduces an abstraction for treating objects uniformly that doesn't\nhave a physical counterpart. Strict modeling of the real world leads to a system that\nreflects today's realities but not necessarily tomorrow's. The abstractions that emerge \nduring design are key to making a design \nflexible.\n", "page": 31, "type": "text", "section": "Page 31"}
{"text": "12 \nINTRODUCTION\nCHAPTER 1\nFigure 1.1: Design pattern relationships\n", "page": 32, "type": "text", "section": "Page 32"}
{"text": "SECTION 1.6 \nHOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS \n13\nDesign patterns help you identify less-obvious abstractions and the objects that can\ncapture them. For example, objects that represent a process or algorithm don't occur\nin nature, yet they are a crucial part of flexible designs. The Strategy (315) pattern\ndescribes how to implement interchangeable families of algorithms. The State (305)\npattern represents each state of an entity as an object. These objects are seldom found\nduring analysis or even the early stages of design; they're discovered later in the course\nof making a design more flexible and reusable.\nDetermining Object Granularity\nObjects can vary tremendously in size and number. They can represent everything\ndown to the hardware or all the way up to entire applications. How do we decide what\nshould be an object?\nDesign patterns address this issue as well. The Facade (185) pattern describes how to\nrepresent complete subsystems as objects, and the Flyweight (195) pattern describes\nhow to support huge numbers of objects at the finest granularities. Other design pat-\nterns describe specific ways of decomposing an object into smaller objects. \nAbstract\nFactory (87) and Builder (97) yield objects \nwhose only responsibilities are creating \nother\nobjects. Visitor (331) and Command (233) yield objects whose only responsibilities are\nto implement a request on another object or group of \nobjects.\nSpecifying Object Interfaces\nEvery operation declared by an object specifies the operation's name, the objects it\ntakes as parameters, and the operation's return value. This is known as the operation's\nsignature. The set of all signatures defined by an object's operations is called the\ninterface to the object. An object's interface characterizes the complete set of requests\nthat can be sent to the object. Any request that matches a signature in the object's\ninterface may be sent to the object.\nA type is a name used to denote a particular interface. We \nspeak of an object as having\nthe type \"Window\" if it accepts all requests for the operations defined in the interface\nnamed \"Window.\" An object may have many types, and widely different objects can\nshare a type. Part of an object's interface may be characterized by one type, and other\nparts by other types. Two objects of the same type need only share parts of their\ninterfaces. Interfaces can contain other interfaces as subsets. We say that a type is a \nsubtype of another if its interface contains the interface of its supertype. Often we\nspeak of a subtype inheriting the interface of its supertype.\nInterfaces are fundamental in object-oriented systems. Objects are known only through\ntheir interfaces. There is no way to know anything about an object or to ask it to do\nanything without going through its interface. An object's interface says nothing about \nits implementation\u2014different objects are free to implement requests differently. That\n", "page": 33, "type": "text", "section": "Page 33"}
{"text": "14 \nINTRODUCTION \nCHAPTER 1\nmeans two objects having completely different implementations can have identical\ninterfaces.\nWhen a request is sent to an object, the particular operation that's performed depends on\nboth the request and the receiving object. Different objects that support identical requests\nmay have different implementations of the operations that fulfill these requests. The\nrun-time association of a request to an object and one of its operations is known as\ndynamic binding.\nDynamic binding means that issuing a request doesn't commit you to a particular\nimplementation until run-time. Consequently, you can write programs that expect an\nobject with a particular interface, knowing that any object that has the correct interface\nwill accept the request. Moreover, dynamic binding lets you substitute objects that\nhave identical interfaces for each other at run-time. This substitutability is known as\npolymorphism, and it's a key concept in object-oriented systems. It lets a client object\nmake few assumptions about other objects beyond supporting a particular interface.\nPolymorphism simplifies the definitions of clients, decouples objects from each other,\nand lets them vary their relationships to each other at run-time.\nDesign patterns help you define interfaces by identifying their key elements and the\nkinds of data that get sent across an interface. A design pattern might also tell you what\nnot to put in the interface. The Memento (283) pattern is a good example. It describes\nhow to encapsulate and save the internal state of an object so that the object can be\nrestored to that state later. The pattern stipulates that Memento objects must define two\ninterfaces: a restricted one that lets clients hold and copy mementos, and a privileged \none that only the original object can use to store and retrieve state in the memento.\nDesign patterns also specify relationships between interfaces. In particular, they often\nrequire some classes to have similar interfaces, \nor they place constraints on the interfaces\nof some classes. For example, both Decorator (175) and Proxy (207) \nrequire the interfaces\nof Decorator and Proxy objects to be identical to the decorated and proxied objects. In\nVisitor (331), the Visitor interface must reflect all classes of objects that visitors can visit.\nSpecifying Object Implementations\nSo far we've said little about how we actually define an object. An object's imple-\nmentation is defined by its class. The class specifies the object's internal data and\nrepresentation and defines the operations the object can perform.\nOur OMT-based notation (summarized in Appendix B) depicts a class as a rectangle\nwith the class name in bold. Operations appear in normal type below the class name.\nAny data that the class defines comes after the operations. Lines separate the class name\nfrom the operations and the operations from the data:\n", "page": 34, "type": "text", "section": "Page 34"}
{"text": "SECTION 1.6\nHOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS\n15\nReturn types \nand instance variable types are optional, since we don't assume a statically\ntyped implementation language.\nObjects are created by instantiating a class. The object is said to be an instance of the\nclass. The process of instantiating a class allocates storage for the object's internal data\n(made up of instance variables) and associates the operations with these data. Many\nsimilar instances of an object can be created by instantiating a class.\nA dashed arrowhead line indicates a class that instantiates objects of another class. The\narrow points to the class of the instantiated objects.\nNew classes can be defined in terms of existing classes using class inheritance. When\na subclass inherits from a parent class, it includes the definitions of all the data and\noperations that the parent class defines. Objects that are instances of the subclass will\ncontain all data defined by the subclass and its parent classes, and they'll be able to\nperform all operations defined by this subclass and its parents. We indicate the subclass\nrelationship with a vertical line and a triangle:\nAn abstract class is one whose main purpose is to define a common interface for its\nsubclasses. An abstract class will defer some or all of its implementation to operations\ndefined in subclasses; hence an abstract class cannot be instantiated. The operations\nthat an abstract class declares but doesn't implement are called abstract operations.\nClasses that aren't abstract are called concrete classes.\n", "page": 35, "type": "text", "section": "Page 35"}
{"text": "16\nINTRODUCTION\nCHAFTER 1\nSubclasses can refine and redefine behaviors of their parent classes. More specifically, \na\nclass may override an operation defined by its parent class. Overriding gives subclasses\na chance to handle requests instead of their parent classes. Class inheritance lets you\ndefine classes simply by extending other classes, making it easy to define families \nof\nobjects having related functionality.\nThe names of abstract classes appear in slanted type to distinguish them from concrete\nclasses. Slanted type is also used to denote abstract operations. A diagram may include\npseudocode for an operation's implementation; if so, the code will appear in a dog-\neared box connected by a dashed line to the operation it implements.\nA mixin class is a class that's intended to provide an optional interface or functionality\nto other classes. It's similar to an abstract class in that it's not intended to be instantiated.\nMixin classes require multiple inheritance:\nClass versus Interface \nInheritance\nIt's important to understand the difference between an object's class and its type.\nAn object's class defines how the object is implemented. The class defines the object's\ninternal state and the implementation of its operations. In contrast, an object's type\nonly refers to its interface\u2014the set of requests to which it can respond. An object can\nhave many types, and objects of different classes can have the same type.\n", "page": 36, "type": "text", "section": "Page 36"}
{"text": "SECTION 1.6 \nHOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS \n17\nOf course, there's a close relationship between class and type. Because a class defines\nthe operations an object can perform, it also defines the object's type. When we say\nthat an object is an instance of a class, we imply that the object supports the interface\ndefined by the class.\nLanguages like C++ and Eiffel use classes to specify both an object's type and its imple-\nmentation. Smalltalk programs do not declare the types of variables; consequently, the\ncompiler does not check that the types of objects assigned to a variable are subtypes of\nthe variable's type. Sending a message requires checking that the class of the receiver\nimplements the message, but it doesn't require checking that the receiver is an instance\nof a particular class.\nIt's also important to understand the difference between class inheritance and interface\ninheritance (or subtyping). Class inheritance defines an object's implementation in\nterms of another object's implementation. In short, it's a mechanism for code and\nrepresentation sharing. In contrast, interface inheritance (or subtyping) describes when\nan object can be used in place of another.\nIt's easy to confuse these two concepts, because many languages don't make the dis-\ntinction explicit. In languages like C++ and Eiffel, inheritance means both interface\nand implementation inheritance. The standard way to inherit an interface in C++ is \nto inherit publicly from a class that has (pure) virtual member functions. Pure inter-\nface inheritance can be approximated in C++ by inheriting publicly from pure abstract\nclasses. Pure implementation or class inheritance can be approximated with private\ninheritance. In Smalltalk, inheritance means just implementation inheritance. You \ncan\nassign instances of any class to a variable as long as those instances support the opera-\ntion performed on the value of the variable.\nAlthough most programming languages don't support the distinction between inter-\nface and implementation inheritance, people make the distinction in practice. Smalltalk\nprogrammers usually act as if subclasses were subtypes (though there are some well-\nknown exceptions [Coo92]); C++ programmers manipulate objects through types de-\nfined by abstract classes.\nMany of the design patterns depend on this distinction. For example, objects \nin a Chain\nof Responsibility (223) must have a common type, but usually they don't share a com-\nmon implementation. In the Composite (163) pattern, Component defines a common\ninterface, but Composite often defines a common implementation. Command (233),\nObserver (293), State (305), and Strategy (315) are often implemented with abstract\nclasses that are pure interfaces.\nProgramming to an Interface, not an Implementation\nClass inheritance is basically just a mechanism for extending an application's function-\nality by reusing functionality in parent classes. It lets you define a new kind of object\nrapidly in terms of an old one. It lets you get new implementations almost for free,\ninheriting most of what you need from existing classes.\n", "page": 37, "type": "text", "section": "Page 37"}
{"text": "18 \nINTRODUCTION \nCHAPTER 1\nHowever, implementation reuse is only half the story. Inheritance's ability to define\nfamilies of objects with identical interfaces (usually by inheriting from an abstract \nclass)\nis also important. Why? Because polymorphism depends on it.\nWhen inheritance is used carefully (some will say properly), all classes derived from\nan abstract class will share its interface. This implies that a subclass merely adds or\noverrides operations and does not hide operations of the parent class. All subclasses\ncan then respond to the requests in the interface of this abstract class, making them all\nsubtypes of the abstract \nclass.\nThere are two benefits to manipulating objects solely in terms of the interface defined\nby abstract classes:\n1. Clients remain unaware of the specific types of objects they use, as long as the\nobjects adhere to the interface that clients expect.\n2. Clients remain unaware of the classes that implement these objects. \nClients only\nknow about the abstract class(es) defining the interface.\nThis so greatly reduces implementation dependencies between subsystems that it leads\nto the following principle of reusable object-oriented design:\nProgram to an interface, not an \nimplementation.\nDon't declare variables to be instances of particular concrete classes. Instead, commit\nonly to an interface defined by an abstract class. You will find this to be a common\ntheme of the design patterns in this book.\nYou have to instantiate concrete classes (that is, specify a particular implementation)\nsomewhere in your system, of course, and the creational patterns (Abstract Factory (87),\nBuilder (97), Factory \nMethod (107), \nPrototype (117), and Singleton (127)) let you do just\nthat. By abstracting the process of object creation, these patterns give you different\nways to associate an interface with its implementation transparently at instantiation.\nCreational patterns ensure that your system is written in terms of interfaces, not imple-\nmentations.\nPutting Reuse Mechanisms to Work\nMost people can understand concepts like objects, interfaces, \nclasses, and inheritance.\nThe challenge lies in applying them to build flexible, reusable software, and design\npatterns can show you how.\nInheritance versus \nComposition\nThe two most common techniques for reusing functionality in object-oriented systems\nare class inheritance and object composition. \nAs we've explained, class inheritance lets\n", "page": 38, "type": "text", "section": "Page 38"}
{"text": "SECTION 1.6 \nHOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS \n19\nyou define the implementation of one class in terms of another's. Reuse \nby subclassing\nis often referred to as white-box reuse. The term \"white-box\" refers to visibility: With\ninheritance, the internals of parent classes are often visible to subclasses.\nObject composition is an alternative to class inheritance. Here, new functionality is\nobtained by assembling or composing objects to get more complex functionality. Object\ncomposition requires that the objects being composed have well-defined interfaces.\nThis style of reuse is called black-box reuse, because no internal details of objects are\nvisible. Objects appear only as \"black boxes.\"\nInheritance and composition each have their advantages and disadvantages. Class\ninheritance is defined statically at compile-time and is straightforward to use, since\nit's supported directly by the programming language. Class inheritance also makes it\neasier to modify the implementation being reused. When a subclass overrides some\nbut not all operations, it can affect the operations it inherits as well, assuming they call\nthe overridden operations.\nBut class inheritance has some disadvantages, too. First, you can't change the imple-\nmentations inherited from parent classes at run-time, because inheritance is defined\nat compile-time. Second, and generally worse, parent classes often define at least part\nof their subclasses' physical representation. Because inheritance exposes a subclass to\ndetails of its parent's implementation, it's often said that \"inheritance breaks encap-\nsulation\" [Sny86]. The implementation of a subclass becomes so bound up with the\nimplementation of its parent class that any change in the parent's implementation will\nforce the subclass to change.\nImplementation dependencies can cause problems when you're trying to reuse a sub-\nclass. Should any aspect of the inherited implementation not be appropriate for new\nproblem domains, the parent class must be rewritten or replaced by something more \nappropriate. This dependency limits flexibility and ultimately reusability. One cure\nfor this is to inherit only from abstract classes, since they usually provide little or no\nimplementation.\nObject composition is defined dynamically at run-time through objects acquiring refer-\nences to other objects. Composition requires objects to respect each others' interfaces,\nwhich in turn requires carefully designed interfaces that don't stop you from using\none object with many others. But there is a payoff. Because objects are accessed solely\nthrough their interfaces, we don't break encapsulation. Any object can be replaced at\nrun-time by another as long as it has the same type. Moreover, because an object's im-\nplementation will be written in terms of object interfaces, there are substantially fewer\nimplementation dependencies.\nObject composition has another effect on system design. Favoring object composition\nover class inheritance helps you keep each class encapsulated and focused on one task.\nYour classes and class hierarchies will remain small and will be less likely to grow into\nunmanageable monsters. On the other hand, a design based on object composition will\nhave more objects (if fewer classes), and the system's behavior will depend on their\ninterrelationships instead of being defined in one class.\n", "page": 39, "type": "text", "section": "Page 39"}
{"text": "20\nINTRODUCTION\nCHAPTER 1\nThat leads us to our second principle of object-oriented design:\nFavor object composition over class inheritance.\nIdeally, you shouldn't have to create new components to achieve reuse. You should\nbe able to get all the functionality you need just by assembling existing components\nthrough object composition. But this is rarely the case, because the set of available\ncomponents is never quite rich enough in practice. Reuse \nby inheritance makes it easier\nto make new components that can be composed with old ones. Inheritance and object\ncomposition thus work together.\nNevertheless, our experience is that designers overuse inheritance as a reuse technique,\nand designs are often made more reusable (and simpler) by depending more on ob-\nject composition. You'll see object composition applied again and again in the design\npatterns.\nDelegation\nDelegation is a way of making composition as powerful for reuse as inheri-\ntance [Lie86, JZ911. In delegation, two objects are involved in handling a request: a\nreceiving object delegates operations to its delegate. This is analogous to subclasses\ndeferring requests to parent classes. But with inheritance, an inherited operation can\nalways refer to the receiving object through the this member variable in C++ and \nsel f in Smalltalk. To \nachieve the same effect with delegation, the receiver passes itself\nto the delegate to let the delegated operation refer to the receiver.\nFor example, instead of making class Window a subclass of Rectangle (because win-\ndows happen to be rectangular), the Window class might reuse the behavior of \nRectan-\ngle by keeping a Rectangle instance variable and delegating Rectangle-specific behavior\nto it. In other words, instead of a Window being a Rectangle, it would have a Rectangle.\nWindow must now forward requests to its Rectangle \ninstance explicitly, whereas before\nit would have inherited those operations.\nThe following diagram depicts the Window class delegating its Area operation to a\nRectangle instance.\n", "page": 40, "type": "text", "section": "Page 40"}
{"text": "SECTION 1.6 \nHOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS \n21\nA plain arrowhead line indicates that a class keeps a reference to an instance of another\nclass. The reference has an optional name, \"rectangle\" in this case.\nThe main advantage of delegation is that it makes it easy to compose behaviors at\nrun-time and to change the way they're composed. Our window can become circular\nat run-time simply by replacing its Rectangle \ninstance with a Circle instance, assuming\nRectangle and Circle have the same type.\nDelegation has a disadvantage it shares with other techniques that make software \nmore\nflexible through object composition: Dynamic, highly parameterized software is harder \nto understand than more static software. There are also run-time inefficiencies, but the\nhuman inefficiencies are more important in the long run. Delegation is a good design\nchoice only when it simplifies more than it complicates. It isn't easy to give rules that\ntell you exactly \nwhen to use delegation, because how effective it will be depends on the\ncontext and on how much experience you have with it. Delegation works best when \nit's used in highly stylized ways\u2014that is, in standard patterns.\nSeveral design patterns use delegation. The State (305), \nStrategy (315), and Visitor \n(331)\npatterns depend on it. In the State pattern, an object delegates requests to a State object\nthat represents its current state. In the Strategy pattern, an object delegates a specific\nrequest to an object that represents a strategy for carrying out the request. An object will\nonly have one state, but it can have many strategies for different requests. The purpose\nof both patterns is to change the behavior of an object by changing the objects to which\nit delegates requests. In Visitor, the operation that gets performed on each element of\nan object structure is always delegated to the Visitor object.\nOther patterns use delegation less heavily. Mediator (273) \nintroduces an object to medi-\nate communication \nbetween other objects. Sometimes the Mediator object implements\noperations simply by forwarding them to the other objects; other times it passes along\na reference to itself and thus uses true delegation. Chain of Responsibility (223) handles\nrequests by forwarding them from one object to another along a chain of objects. Some-\ntimes this request carries with it a reference to the original object receiving the request,\nin which case the pattern is using delegation. Bridge (151) decouples an abstraction\nfrom its implementation. If the abstraction and a particular implementation are closely\nmatched, then the abstraction may simply delegate operations to that implementation.\nDelegation is an extreme example of object composition. It shows that you can always\nreplace inheritance with object composition as a mechanism for code reuse.\nInheritance versus Parameterized Types\nAnother (not strictly object-oriented) technique for reusing functionality is through\nparameterized types, also known as generics (Ada, Eiffel) and templates (C++). This\ntechnique lets you define a type without specifying all the other types it uses. The\nunspecified types are supplied as parameters at the point of use. For example, a List\nclass can be parameterized by the type of elements it contains. To declare a list of\nintegers, you supply the type \"integer\" as a parameter to the List parameterized type.\n", "page": 41, "type": "text", "section": "Page 41"}
{"text": "22 \nINTRODUCTION \nCHAPTER I\nTo declare a list of String objects, you supply the \"String\" type as a parameter. The\nlanguage implementation will create a customized version of the List class template for\neach type of element.\nParameterized types give us a third way (in addition to class inheritance and object\ncomposition) to compose behavior in object-oriented systems. Many designs can be\nimplemented using any of these three techniques. To \nparameterize a sorting routine by\nthe operation it uses to compare elements, we could make the comparison\n1. an operation implemented by subclasses (an application of Template\nMethod (325)),\n2. the responsibility of an object that's passed to the sorting routine (Strategy (315)),\nor\n3. an argument of a C++ template or Ada generic that specifies the name of the\nfunction to call to compare the elements.\nThere are important differences between these techniques. Object composition lets you\nchange the behavior being composed at run-time, but it also requires indirection and can\nbe less efficient. Inheritance lets you provide default implementations for operations\nand lets subclasses override them. Parameterized types let you change the types that a\nclass can use. But neither inheritance nor parameterized types can change at run-time.\nWhich approach is best depends on your design and implementation constraints.\nNone of the patterns in this book concerns parameterized types, though we use them\non occasion to customize a pattern's C++ implementation. Parameterized types aren't\nneeded at all in a language like Smalltalk that doesn't have compile-time type checking.\nRelating Run-Time and Compile-Time Structures\nAn object-oriented program's run-time structure often bears little resemblance to its\ncode structure. The code structure is frozen at compile-time; it consists of classes in\nfixed inheritance relationships. A program's run-time structure consists of rapidly\nchanging networks of communicating objects. In fact, the two structures are largely\nindependent. Trying to understand one from the other is like trying to understand the\ndynamism of living ecosystems from the static taxonomy of plants and animals, and\nvice versa.\nConsider the distinction between object aggregation and acquaintance and how dif-\nferently they manifest themselves at compile- and run-times. Aggregation implies that \none object owns or is responsible for another object. Generally we speak of an object\nhaving or being part of \nanother object. Aggregation implies that an aggregate object and\nits owner have identical lifetimes.\nAcquaintance implies that an object merely knows of another object. Sometimes ac-\nquaintance is called \"association\" or the \"using\" relationship. Acquainted objects may\n", "page": 42, "type": "text", "section": "Page 42"}
{"text": "SECTION 1.6 \nHOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS \n23\nrequest operations of each other, but they aren't responsible for each other. Acquain-\ntance is a weaker relationship than aggregation and suggests much looser coupling\nbetween objects.\nIn our diagrams, a plain arrowhead line denotes acquaintance. An arrowhead line with\na diamond at its base denotes aggregation:\nIt's easy to confuse aggregation and acquaintance, because they are often implemented\nin the same way. In Smalltalk, all variables are references to other objects. There's\nno distinction in the programming language between aggregation and acquaintance.\nIn C++, aggregation can be implemented by defining member variables that are real\ninstances, but it's more common to define them as pointers or references to instances.\nAcquaintance is implemented with pointers and references as well.\nUltimately, acquaintance and aggregation are determined more by intent than by ex-\nplicit language mechanisms. The distinction may be hard to see in the compile-time\nstructure, but it's significant. Aggregation relationships tend to be fewer and more\npermanent than acquaintance. Acquaintances, in contrast, are made and remade more\nfrequently, sometimes existing only for the duration of an operation. Acquaintances are\nmore dynamic as well, making them more difficult to discern in the source code.\nWith such disparity between a program's run-time and compile-time structures, it's\nclear that code won't reveal everything about how a system will work. The system's\nrun-time structure must be imposed more by the designer than the language. The \nrelationships between objects and their types must be designed with great care, because\nthey determine how good or bad the run-time structure is.\nMany design patterns (in particular those that have object scope) capture the distinction\nbetween compile-time and run-time structures explicitly. Composite (163) and Decora-\ntor (175) are especially useful for building complex run-time structures. Observer (293)\ninvolves run-time structures that are often hard to understand unless you know the\npattern. Chain of Responsibility (223) also results in communication patterns that in-\nheritance doesn't reveal. In general, the run-time structures aren't clear from the code\nuntil you understand the patterns.\nDesigning for Change\nThe key to maximizing reuse lies in anticipating new requirements and changes to ex-\nisting requirements, and in designing your systems so that they can evolve accordingly.\nTo design the system so that it's robust to such changes, you must consider how the\nsystem might need to change over its lifetime. A design that doesn't take change\ninto account risks major redesign in the future. Those changes might involve class\n", "page": 43, "type": "text", "section": "Page 43"}
{"text": "24 \nINTRODUCTION \nCHAPTER 1\nredefinition and reimplementation, client modification, and retesting. Redesign affects\nmany parts of the software system, and unanticipated changes are invariably expensive.\nDesign patterns help you avoid this by ensuring that a system can change in specific\nways. Each design pattern lets some aspect of system structure vary independently of\nother aspects, thereby making a system more robust to a particular kind of change.\nHere are some common causes of redesign along with the design pattern(s) that address\nthem:\n1. Creating an object by specifying a class explicitly. Specifying a class name when\nyou create an object commits you to a particular implementation instead of a\nparticular interface. This commitment can complicate future changes. To \navoid it,\ncreate objects \nindirectly.\nDesign patterns: Abstract Factory (87), \nFactory Method (107), Prototype (117).\n2. Dependence on specific operations. When you specify a particular operation, you\ncommit to one way of satisfying a request. By \navoiding hard-coded requests, you\nmake it easier to change the way a request gets satisfied both at compile-time and\nat run-time.\nDesign patterns: Chain of Responsibility (223), Command (233).\n3. Dependence on hardware and software platform. External operating system interfaces\nand application programming interfaces (APIs) are different on different hard-\nware and software platforms. Software that depends on a particular platform will\nbe harder to port to other platforms. It may even be difficult to keep it up to date\non its native platform. It's important therefore to design your system to limit its\nplatform dependencies.\nDesign patterns: Abstract Factory (87), Bridge (151).\n4. Dependence on object representations or implementations. Clients that know how an\nobject is represented, stored, located, or implemented might need to be changed\nwhen the object changes. Hiding this information from clients keeps changes\nfrom cascading.\nDesign patterns: Abstract Factory (87), \nBridge (151), Memento (283), \nProxy (207).\n5. Algorithmic dependencies. Algorithms are often extended, optimized, and replaced\nduring development and reuse. Objects that depend on an algorithm will have\nto change when the algorithm changes. Therefore algorithms that are likely to\nchange should be isolated.\nDesign patterns: Builder (97), Iterator (257), Strategy (315), Template\nMethod (325), Visitor (331).\n6. Tight coupling. Classes that are tightly coupled are hard to reuse in isolation, since\nthey depend on each other. Tight coupling leads to monolithic systems, where\nyou can't change or remove a class without understanding and changing many\n", "page": 44, "type": "text", "section": "Page 44"}
{"text": "SECTION 1.6 \nHOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS \n25\nother classes. The system becomes a dense mass that's hard to learn, port, and\nmaintain.\nLoose coupling increases the probability that a class can be reused by itself and\nthat a system can be learned, ported, modified, and extended more easily. Design\npatterns use techniques such as abstract coupling and layering to promote loosely\ncoupled systems.\nDesign patterns: Abstract \nFactory (87), Bridge (151), \nChain of Responsibility (223),\nCommand (233), Facade (185), Mediator (273), Observer (293).\n7. Extending functionality by subclassing. Customizing an object by subclassing often\nisn't easy. Every new class has a fixed implementation overhead (initialization,\nfinalization, etc.). Defining a subclass also requires an in-depth understanding of\nthe parent class. For example, overriding one operation might require overriding\nanother. An overridden operation might be required to call an inherited operation.\nAnd subclassing can lead to an explosion of classes, because you might have to\nintroduce many new subclasses for even a simple extension.\nObject composition in general and delegation in particular provide flexible alter-\nnatives to inheritance for combining behavior. New functionality can be added to\nan application by composing existing objects \nin new ways rather than by defining\nnew subclasses of existing classes. On the other hand, heavy use of object com-\nposition can make designs harder to understand. Many design patterns produce\ndesigns in which you can introduce customized functionality just by defining one\nsubclass and composing its instances with existing ones.\nDesign patterns: Bridge (151), Chain of Responsibility (223), Composite (163),\nDecorator (175), Observer (293), \nStrategy (315).\n8. Inability to alter classes conveniently. Sometimes you have to modify a class that\ncan't be modified conveniently. Perhaps you need the source code and don't have\nit (as may be the case with a commercial class library). Or maybe any change\nwould require modifying lots of existing subclasses. Design patterns offer ways\nto modify classes in such circumstances.\nDesign patterns: Adapter (139), Decorator (175), Visitor \n(331).\nThese examples reflect the flexibility that design patterns can help you build into\nyour software. How crucial such flexibility is depends on the kind of software you're\nbuilding. Let's look at the role design patterns play in the development of three broad\nclasses of software: application programs, toolkits, and frameworks.\nApplication Programs\nIf you're building an application program such as a document editor or spreadsheet,\nthen internal reuse, maintainability, and extension are high priorities. Internal reuse\nensures that you don't design and implement any more than you have to. Design\n", "page": 45, "type": "text", "section": "Page 45"}
{"text": "26 \nINTRODUCTION \nCHAPTER 1\npatterns that reduce dependencies can increase internal reuse. Looser coupling boosts\nthe likelihood that one class of object can cooperate with several others. For example,\nwhen you eliminate dependencies on specific operations by isolating and encapsulating\neach operation, you make it easier to reuse an operation in different contexts. The same\nthing can happen when you remove algorithmic and representational dependencies\ntoo.\nDesign patterns also make an application more maintainable \nwhen they're used to limit\nplatform dependencies and to layer a system. They enhance extensibility by showing\nyou how to extend class hierarchies and how to exploit object composition. Reduced\ncoupling also enhances extensibility. Extending a class in isolation is easier if the class \ndoesn't depend on lots of other classes.\nToolkits\nOften an application will incorporate classes from one or more libraries of predefined\nclasses called toolkits. A toolkit is a set of related and reusable classes designed to pro-\nvide useful, general-purpose functionality. An example of a toolkit is a set of collection\nclasses for lists, associative tables, stacks, and the like. The C++ I/O stream library is\nanother example. Toolkits don't impose a particular design on your application; they\njust provide functionality that can help your application do its job. They let you as\nan implementer avoid receding common functionality. Toolkits emphasize code reuse.\nThey are the object-oriented equivalent of subroutine libraries.\nToolkit design is arguably harder than application design, because toolkits have to\nwork in many applications to be useful. Moreover, the toolkit writer isn't in a position\nto know what those applications will be or their special needs. That makes it all the\nmore important to avoid assumptions and dependencies that can limit the toolkit's\nflexibility and consequently its applicability and effectiveness.\nFrameworks\nA framework is a set of cooperating classes that make up a reusable design for a specific\nclass of software [Deu89, JF88]. For example, a framework can be geared toward build-\ning graphical editors for different domains like artistic drawing, music composition,\nand mechanical CAD [VL90, Joh92]. Another framework can help you build compilers\nfor different programming languages and target machines [JML92]. Yet \nanother might\nhelp you build financial modeling applications [BE93]. You \ncustomize a framework to\na particular application by creating application-specific subclasses of abstract classes\nfrom the framework.\nThe framework dictates the architecture of your application. It will define the over-\nall structure, its partitioning into classes and objects, the key responsibilities thereof,\nhow the classes and objects collaborate, and the thread of control. A framework prede-\nfines these design parameters so that you, the application designer/implementer, can\n", "page": 46, "type": "text", "section": "Page 46"}
{"text": "SECTION 1.6 \nHOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS \n27\nconcentrate on the specifics of your application. The framework captures the design\ndecisions that are common to its application domain. Frameworks thus emphasize de-\nsign reuse over code reuse, though a framework will usually include concrete subclasses\nyou can put to work immediately.\nReuse on this level leads to an inversion of control between the application and the\nsoftware on which it's based. When you use a toolkit (or a conventional subroutine\nlibrary for that matter), you write the main body of the application and call the code\nyou want to reuse. When you use a framework, you reuse the main body and write\nthe code it calls. You'll have to write operations with particular names and calling\nconventions, but that reduces the design decisions you have to make.\nNot only can you build applications faster as a result, but the applications have similar\nstructures. They are easier to maintain, and they seem more consistent to their users.\nOn the other hand, you lose some creative freedom, since many design decisions have\nbeen made for you.\nIf applications are hard to design, and toolkits are harder, then frameworks are hardest\nof all. A framework designer gambles that one architecture will work for all applications\nin the domain. Any substantive change to the framework's design would reduce its \nbenefits considerably, since the framework's main contribution to an application is\nthe architecture it defines. Therefore it's imperative to design the framework to be as\nflexible and extensible as possible.\nFurthermore, because applications are so dependent on the framework for their de-\nsign, they are particularly sensitive to changes in framework interfaces. As a frame-\nwork evolves, applications have to evolve with it. That makes loose coupling all the\nmore important; otherwise even a minor change to the framework will have major\nrepercussions.\nThe design issues just discussed are most critical to framework design. A framework\nthat addresses them using design patterns is far more likely to achieve high levels of\ndesign and code reuse than one that doesn't. Mature frameworks usually incorporate\nseveral design patterns. The patterns help make the framework's architecture suitable\nto many different applications without redesign.\nAn added benefit comes when the framework is documented with the design patterns\nit uses [BJ94]. People who know the patterns gain insight into the framework faster.\nEven people who don't know the patterns can benefit from the structure they lend to\nthe framework's documentation. Enhancing documentation is important for all types\nof software, but it's particularly important for frameworks. Frameworks often pose a\nsteep learning curve that must be overcome before they're useful. While design patterns\nmight not flatten the learning curve entirely, they can make it less steep by making key\nelements of the framework's design more explicit.\nBecause patterns and frameworks have some similarities, people often wonder how or\neven if they differ. They are different in three major ways:\n", "page": 47, "type": "text", "section": "Page 47"}
{"text": "28 \nINTRODUCTION \nCHAPTER 1\n1. Design patterns are more abstract than frameworks. Frameworks can be embodied\nin code, but only examples of patterns can be embodied in code. A strength of\nframeworks is that they can be written down in programming languages and not\nonly studied but executed and reused directly. In contrast, the design patterns in\nthis book have to be implemented each time they're used. Design patterns also\nexplain the intent, trade-offs, and consequences of a design.\n2. Design patterns are smaller architectural elements than frameworks. A typical frame-\nwork contains several design patterns, but the reverse is never true.\n3. Design patterns are less specialized than frameworks. Frameworks always have a\nparticular application domain. A graphical editor framework might be used in\na factory simulation, but it won't be mistaken for a simulation framework. In\ncontrast, the design patterns in this catalog can be used in nearly any kind of ap-\nplication. While more specialized design patterns than ours are certainly possible\n(say, design patterns for distributed systems or concurrent programming), even\nthese wouldn't dictate an application architecture like a framework would.\nFrameworks are becoming increasingly common and important. They are the way that\nobject-oriented systems achieve the most reuse. Larger object-oriented applications will\nend up consisting of layers of frameworks that cooperate with each other. Most of the\ndesign and code in the application will come from or be influenced by the frameworks\nit uses.\n1.7 How to Select a Design Pattern\nWith more than 20 \ndesign patterns in the catalog \nto choose from, it might be hard to find\nthe one that addresses a particular design problem, especially if the catalog is new and\nunfamiliar to you. Here are several different approaches to finding the design pattern\nthat's right for your problem:\n\u2022 Consider how design patterns solve design problems. Section 1.6 discusses how design\npatterns help you find appropriate objects, determine object granularity, specify\nobject interfaces, and several other ways in which design patterns solve design\nproblems. Referring to these discussions can help guide your search for the right\npattern.\n\u2022 Scan Intent sections. Section 1.4 (page 8) \nlists the Intent sections from all the patterns\nin the catalog. Read through each pattern's intent to find one or more that sound\nrelevant to your problem. You can use the classification scheme presented in\nTable 1.1 (page 10) \nto narrow your search.\n\u2022 Study how patterns interrelate. Figure 1.1 (page 12) shows relationships between\ndesign patterns graphically. Studying these relationships can help direct you to\nthe right pattern or group of patterns.\n", "page": 48, "type": "text", "section": "Page 48"}
{"text": "SECTION 1.8 \nHOW TO USE A DESIGN PATTERN \n29\n\u2022 Study patterns of like purpose. The catalog (page 79) has three chapters, one for\ncreational patterns, another for structural patterns, and a third for behavioral\npatterns. Each chapter starts off with introductory comments on the patterns and\nconcludes with a section that compares and contrasts them. These sections give\nyou insight into the similarities and differences between patterns of like purpose.\n\u2022 Examine a cause of redesign. Look at the causes of redesign starting on page 24 to\nsee if your problem involves one or more of them. Then look at the patterns that\nhelp you avoid the causes of redesign.\n\u2022 Consider what should be variable in your design. This approach is the opposite of\nfocusing on the causes of redesign. Instead of considering what might force a\nchange to a design, consider what you want to be able to change without redesign.\nThe focus here is on encapsulating the concept that varies, a theme of many design\npatterns. Table 1.2 lists the design aspect(s) that design patterns let you vary\nindependently, thereby letting you change them without redesign.\n1.8 How to Use a Design Pattern\nOnce you've picked a design pattern, how do you use it? \nHere's a step-by-step approach\nto applying a design pattern effectively:\n1. Read the pattern once through for an overview. Pay particular attention to the Applic-\nability and Consequences sections to ensure the pattern is right for your problem.\n2. Go back and study the Structure, Participants, and Collaborations sections. Make sure\nyou understand the classes and objects in the pattern and how they relate to one\nanother.\n3. Look at the Sample Code section to see a concrete example of the pattern in code. Studying\nthe code helps you learn how to implement the pattern.\n4. Choose names for pattern participants that are meaningful in the application context.\nThe names for participants in design patterns are usually too abstract to appear\ndirectly in an application. Nevertheless, it's useful to incorporate the participant \nname into the name that appears in the application. That helps make the pattern\nmore explicit in the implementation. For example, if you use the Strategy pattern\nfor a text compositing algorithm, then you might have classes \nSimpleLayoutStrat-\negy or TeXLayoutStrategy.\n5. Define the classes. Declare their interfaces, establish their inheritance relationships,\nand define the instance variables that represent data and object references. Identify\nexisting classes in your application that the pattern will affect, and modify them\naccordingly.\n", "page": 49, "type": "text", "section": "Page 49"}
{"text": "30\nINTRODUCTION\nCHAPTER 1\nPurpose\nCreational\nStructural\nBehavioral\nDesign Pattern\nAbstract Factory \n(87)\nBuilder \n(97)\nFactory Method (107)\nPrototype (117)\nSingleton (127) \nAdapter (139)\nBridge (151)\nComposite (163)\nDecorator (175)\nFacade (185)\nFlyweight (195)\nProxy (207)\nChain of Responsibility (223)\nCommand (233)\nInterpreter (243)\nIterator (257)\nMediator (273)\nMemento (283)\nObserver (293)\nState (305)\nStrategy (315)\nTemplate Method (325)\nVisitor (331)\nAspect(s) That Can Vary\nfamilies of product objects \nhow a composite object gets created\nsubclass of object that is instantiated \nclass of object that is instantiated \nthe sole instance of a class \ninterface to an object \nimplementation of an object \nstructure and composition of an object\nresponsibilities of an object \nwithout subclassing \ninterface to a subsystem \nstorage costs of objects \nhow an object is accessed; its location \nobject that can fulfill a request \nwhen and how a request is fulfilled\ngrammar and interpretation of a language\nhow an aggregate's elements are accessed, \ntraversed \nhow and which objects interact with \neach other \nwhat private information is stored outside \nan object, and when \nnumber of objects \nthat depend on another \nobject; how the dependent objects stay \nup to date \nstates of an object \nan algorithm \nsteps of an algorithm \noperations that can be applied to object(s)\nwithout changing their class(es)\nTable 1.2: Design aspects that design patterns let you vary\n", "page": 50, "type": "text", "section": "Page 50"}
{"text": "SECTION 1.8 \nHOW TO USE A DESIGN PATTERN \n31\n6. Define application-specific names for operations in the pattern. Here again, the names\ngenerally depend on the application. Use the responsibilities and collaborations\nassociated with each operation as a guide. Also, be consistent in your naming\nconventions. For example, you might use the \"Create-\" prefix consistently to\ndenote a factory method.\n7. Implement the operations to carry out the responsibilities and collaborations in the pattern.\nThe Implementation section offers hints to guide you in the implementation. \nThe\nexamples in the Sample Code section can help as well.\nThese are just guidelines to get you started. Over time you'll develop your own way of\nworking with design patterns.\nNo discussion of how to use design patterns would be complete without a few words\non how not to use them. Design patterns should not be applied indiscriminately. Often\nthey achieve flexibility and variability by introducing additional levels of indirection,\nand that can complicate \na design and/or cost you some performance. A design pattern\nshould only be applied when the flexibility it affords is actually needed. The Conse-\nquences sections are most helpful when evaluating a pattern's benefits and liabilities.\n", "page": 51, "type": "text", "section": "Page 51"}
{"text": "This page intentionally left blank \n", "page": 52, "type": "text", "section": "Page 52"}
{"text": "Chapter 2\nA Case Study: \nDesigning a Document Editor\nThis chapter presents a case study in the design of a \"What-You-See-Is-What-You-Get\"\n(or \"WYSIWYG\") document editor called Lexi.1 We'll see how design patterns capture\nsolutions to design problems in Lexi and applications like it. By the end of this chapter\nyou will have gained experience with eight patterns, learning them by example.\nFigure 2.1 depicts Lexi's user interface. A WYSIWYG representation of the document\noccupies the large rectangular area in the center. The document can mix text and\ngraphics freely in a variety of formatting styles. Surrounding the document are the\nusual pull-down menus and scroll bars, plus a collection of page icons for jumping to\na particular page in the document.\n2.1 Design Problems\nWe will examine seven problems in Lexi's design:\n1. Document structure. The choice of internal representation for the document affects\nnearly every aspect of Lexi's design. All editing, formatting, displaying, and\ntextual analysis will require traversing the representation. The way we organize\nthis information will impact the design of the rest of the application.\n2. Formatting. How does Lexi actually arrange text and graphics into lines and\ncolumns? What objects are responsible for carrying out different formatting poli-\ncies? How do these policies interact with the document's internal representation?\n1 \nLexi's design is based on Doc, a text editing application developed by Calder [CL92]. \n33\n", "page": 53, "type": "text", "section": "Page 53"}
{"text": "34\nA CASE STUDY: DESIGNING A DOCUMENT EDITOR\nCHAPTER 2\nFigure 2.1: Lexi's user interface\n", "page": 54, "type": "text", "section": "Page 54"}
{"text": "SECTION 2.2 \nDOCUMENT STRUCTURE \n35\n3. Embellishing the user interface. Lexi's user interface includes scroll bars, borders,\nand drop shadows that embellish the WYSIWYG document interface. Such em-\nbellishments are likely to change as Lexi's user interface evolves. Hence it's im-\nportant to be able to add and remove embellishments easily without affecting the\nrest of the application.\n4. Supporting multiple look-and-feel standards. Lexi should adapt easily to different\nlook-and-feel standards such as Motif and Presentation Manager (PM) without\nmajor modification.\n5. Supporting multiple window systems. Different look-and-feel standards are usually\nimplemented on different window systems. Lexi's design should be as indepen-\ndent of the window system as possible.\n6. User operations. Users control Lexi through various user interfaces, including but-\ntons and pull-down menus. The functionality behind these interfaces is scattered\nthroughout the objects in the application. The challenge here is to provide a uni-\nform mechanism both for accessing this scattered functionality and for undoing\nits effects.\n7. Spelling checking and hyphenation. How does Lexi support analytical operations\nsuch as checking for misspelled words and determining hyphenation points?\nHow can we minimize the number of classes we have to modify to add a new\nanalytical operation?\nWe discuss these design problems in the sections that follow. Each problem has an\nassociated set of goals plus constraints on how we achieve those goals. We \nexplain the\ngoals and constraints in detail before proposing a specific solution. The problem and \nits solution will illustrate one or more design patterns. The discussion for each problem\nwill culminate in a brief introduction to the relevant patterns.\n2.2 Document Structure\nA document is ultimately just an arrangement of basic graphical elements such as char-\nacters, lines, polygons, and other shapes. These elements capture the total information\ncontent of the document. Yet an author often views these elements not in graphical\nterms but in terms of the document's physical structure\u2014lines, columns, figures, ta-\nbles, and other substructures.2 In turn, these substructures have substructures of their\nown, and so on.\nLexi's user interface should let users manipulate these substructures directly. For ex-\nample, a user should be able to treat a diagram as a unit rather than as a collection \nof\n2 Authors often view the document in terms of its logical structure as well, that is, in terms of sentences,\nparagraphs, sections, subsections, and chapters. To keep this example simple, our internal representation \nwon't store information about the logical structure explicitly. But the design solution we describe works\nequally well for representing such information.\n", "page": 55, "type": "text", "section": "Page 55"}
{"text": "36 \nA CASE \nSTUDY- DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nindividual graphical primitives. The user should be able to refer to a table as a whole,\nnot as an unstructured mass of text and graphics. That helps make the interface simple\nand intuitive. To give Lexi's implementation similar qualities, we'll choose an internal\nrepresentation that matches the document's physical structure.\nIn particular, the internal representation should support the following:\n\u2022 Maintaining the document's physical structure, that is, the arrangement of text\nand graphics into lines, columns, tables, etc.\n\u2022 Generating and presenting the document visually.\n\u2022 Mapping positions on the display to elements in the internal representation. This\nlets Lexi determine what the user is referring to when he points to something in\nthe visual representation.\nIn addition to these goals are some constraints. First, we should treat text and graphics\nuniformly. The application's interface lets the user embed text within graphics freely\nand vice versa. We should avoid treating graphics as a special case of text or text\nas a special case of graphics; otherwise we'll end up with redundant formatting and\nmanipulation mechanisms. One set of mechanisms should suffice for both text and\ngraphics.\nSecond, our implementation shouldn't have to distinguish between single elements and\ngroups of elements in the internal representation. Lexi should be able to treat simple\nand complex elements uniformly, thereby allowing arbitrarily complex documents. The \ntenth element in line five of column two, for instance, could be a single character or an\nintricate diagram with many subelements. As long as we know this element can draw\nitself and specify its dimensions, its complexity has no bearing on how and where it\nshould appear on the page.\nOpposing the second constraint, however, is the need to analyze the text for such things\nas spelling errors and potential hyphenation points. Often we don't care whether the\nelement of a line is a simple or complex object. But sometimes an analysis depends on\nthe objects being analyzed. It makes little sense, for example, to check the spelling of a\npolygon or to hyphenate it. The internal representation's design should take this and\nother potentially conflicting constraints into \naccount.\nRecursive Composition\nA common way to represent hierarchically structured information is through a tech-\nnique called recursive composition, which entails building increasingly complex ele-\nments out of simpler ones. Recursive composition gives us a way to compose a docu-\nment out of simple graphical elements. As a first step, we can tile a set of characters\nand graphics from left to right to form a line in the document. Then multiple lines\ncan be arranged to form a column, multiple columns can form a page, and so on (see\nFigure \n2.2).\n", "page": 56, "type": "text", "section": "Page 56"}
{"text": "SECTION 2.2\nDOCUMENT STRUCTURE \n37\nFigure 2.3: Object structure for recursive composition of text and graphics\nFgure 2.2: Recusive coposition of text and graphics\n", "page": 57, "type": "text", "section": "Page 57"}
{"text": "38\nA CASE STUDY- DESIGNING A DOCUMENT EDITOR\nCHAPTER 2\nFigure 2.4: Partial Glyph class hierarchy\nWe can represent this physical structure by devoting an object to each important ele-\nment. That includes not just the visible elements like the characters and graphics but \nthe invisible, structural elements as well\u2014the lines and the column. The result is the\nobject structure shown in Figure 2.3.\nBy using an object for each character and graphical element in the document, we\npromote flexibility at the finest levels of Lexi's design. We can treat text and graphics\nuniformly with respect to how they are drawn, formatted, and embedded within each\nother. We can extend Lexi to support new character sets without disturbing other\nfunctionality. Lexi's object structure mimics the document's physical structure.\nThis approach has two important implications. The first is obvious: The objects need\ncorresponding classes. The second implication, which maybe less obvious, is that these \nclasses must have compatible interfaces, \nbecause we want to treat the objects uniformly.\nThe way to make interfaces compatible in a language like C++ is to relate the classes\nthrough inheritance.\nGlyphs\nWe'll define a Glyph abstract class for all objects that can appear in a document\nstructure.3 Its subclasses define both primitive graphical elements (like characters and\n3 \nCalder was the first to use the term \"glyph\" in this context [CL90]. Most contemporary document editors\ndon't use an object for every character, presumably for efficiency reasons. Calder demonstrated that this\n", "page": 58, "type": "text", "section": "Page 58"}
{"text": "SECTION 2.2\nDOCUMENT STRUCTURE\n39\nResponsibility\nappearance\nhit detection\nstructure\nOperations\nvirtual \nvirtual \nvirtual \nvirtual \nvirtual \nvirtual \nvirtual\nvoid Draw (Window* ) \nvoid Bounds (Rect&) \nbool Intersects (const Point&)\nvoid Insert (Glyph* , \nvoid Remove (Glyph*)\nGlyph* Child(int)\nGlyph* Parent ( )\nint)\nTable 2.1: Basic glyph interface\nimages) and structural elements (like rows and columns). Figure 2.4 \ndepicts a represen-\ntative part of the Glyph class hierarchy, and Table 2.1 presents the basic glyph interface\nin more detail using C++ notation.4\nGlyphs have three basic responsibilities. They know (1) how to draw themselves, (2)\nwhat space they occupy, and (3) \ntheir children and parent.\nGlyph subclasses redefine the Draw operation to render themselves onto a window.\nThey are passed a reference to a Window object in the call to Draw. The Window class\ndefines graphics operations for rendering text and basic shapes in a window on the\nscreen. A Rectangle \nsubclass of Glyph might redefine Draw as follows:\nvoid Rectangle::Draw (Window* w) {\nw->DrawRect (_xO, _yO, _xl, __yl);\n}\nwhere _xO, _y 0, _xl, and _y \n1 are data members of Rectangle that define two opposing\ncorners of the rectangle. DrawRect is the Window operation that makes the rectangle \nappear on the screen.\nA parent glyph often needs to know how much space a child glyph occupies, for\nexample, to arrange it and other glyphs in a line so that none overlaps (as shown in\nFigure 2.2). \nThe Bounds operation returns the rectangular area that the glyph occupies.\nIt returns the opposite corners of the smallest rectangle that contains the glyph. Glyph\nsubclasses redefine this operation to return the rectangular area in which they draw.\nThe Intersects operation returns whether a specified point intersects the glyph.\nWhenever the user clicks somewhere in the document, Lexi calls this operation to\ndetermine which glyph or glyph structure is under the mouse. The Rectangle class\nredefines this operation to compute the intersection of the rectangle and the given\npoint.\napproach is feasible in his thesis [Cal93]. Our glyphs are less sophisticated than his in that we have restricted\nours to strict hierarchies for simplicity. \nCalder's glyphs can be shared to reduce storage costs, thereby forming\ndirected-acyclic graph structures. We can apply the Flyweight (195) \npattern to get the same effect, but we'll \nleave that as an exercise for the reader.\n4 The interface we describe here is purposely minimal to keep the discussion simple. A complete interface\nwould include operations for managing graphical attributes such as color, font, and coordinate transforma-\ntions, plus operations for more sophisticated child management.\n", "page": 59, "type": "text", "section": "Page 59"}
{"text": "40 \nA CASE STUDY- DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nBecause glyphs can have children, we need a common interface to add, remove, and\naccess those children. For example, a Row's children are the glyphs it arranges into a\nrow. The Insert operation inserts a glyph at a position specified by an integer index.5\nThe Remove operation removes a specified glyph if it is indeed a child.\nThe Child operation returns the child (if any) at the given index. Glyphs like Row\nthat can have children should use Child internally instead of accessing the child data\nstructure directly. That way you won't have to modify operations like Draw that iterate\nthrough the children when you change the data structure from, say, \nan array to a linked\nlist. Similarly, \nParent provides a standard interface to the glyph's parent, if any. \nGlyphs \nin Lexi store a reference to their parent, and their Parent operation simply returns this\nreference.\nComposite Pattern\nRecursive composition is good for more than just documents. We \ncan use it to represent\nany potentially complex, hierarchical structure. The Composite (163) pattern captures\nthe essence of recursive composition in object-oriented terms. Now would be a good\ntime to turn to that pattern and study it, referring back to this scenario as needed.\n2.3 Formatting\nWe've settled on a way to represent the document's physical structure. Next, we need\nto figure out how to construct a particular physical structure, one that corresponds to a\nproperly formatted document. Representation and formatting are distinct: The ability\nto capture the document's physical structure doesn't tell us how to arrive at a particular\nstructure. This responsibility rests mostly on Lexi. It must break text into lines, lines into\ncolumns, and so \non, taking into account the user's higher-level desires. For example, the\nuser might want to vary margin widths, indentation, and tabulation; single or double\nspace; and probably many other formatting constraints.6 Lexi's formatting algorithm\nmust take all of these into account.\nBy the way, we'll restrict \"formatting\" to mean breaking a collection of glyphs into\nlines. In fact, we'll use the terms \"formatting\" and \"linebreaking\" interchangeably.\nThe techniques we'll discuss apply equally well to breaking lines into columns and to\nbreaking columns into pages.\nBAn integer index is probably not the best way to specify a glyph's children, depending on the data \nstructure the glyph uses. If it stores its children in a linked list, then a pointer into the list would be more\nefficient. We'll see a better solution to the indexing problem in Section 2.8, when we discuss document\nanalysis.\n6 The user will have even more to say about the document's logical structure\u2014the sentences, paragraphs,\nsections, chapters, and so forth. The physical structure is less interesting by comparison. Most people don't \ncare where the linebreaks in a paragraph occur as long as the paragraph is formatted properly. The same\nis true for formatting columns and pages. Thus users end up specifying only high-level constraints on the\nphysical structure, leaving Lexi to do the hard work of satisfying them.\n", "page": 60, "type": "text", "section": "Page 60"}
{"text": "SECTION 2.3 \nFORMATTING \n41\nResponsibility\nwhat to format\nwhen to format\nOperations \nvoid SetComposition (Composition* )\nvirtual void Compose ( )\nTable 2.2: Basic compositor interface\nEncapsulating the Formatting Algorithm\nThe formatting process, with all its constraints and details, isn't easy to automate.\nThere are many approaches to the problem, and people have come up with a variety\nof formatting algorithms with different strengths and weaknesses. Because Lexi is a\nWYSIWYG editor, an important trade-off to consider is the balance between formatting\nquality and formatting speed. We want generally good response from the editor with-\nout sacrificing how good the document looks. This trade-off is subject to many factors,\nnot all of which can be ascertained at compile-time. For example, the user might tol-\nerate slightly slower response in exchange for better formatting. \nThat trade-off might\nmake an entirely different formatting algorithm more appropriate than the current\none. Another, more implementation-driven trade-off balances formatting speed and\nstorage requirements: It may be possible to decrease formatting \ntime by caching more\ninformation.\nBecause formatting algorithms tend to be complex, it's also desirable to keep them well-\ncontained or\u2014better yet\u2014completely independent of the document structure. Ideally\nwe could add a new kind of Glyph subclass without regard to the formatting algorithm.\nConversely, adding a new formatting algorithm shouldn't require modifying existing\nglyphs.\nThese characteristics suggest we should design Lexi so that it's easy to change the\nformatting algorithm at least at compile-time, if not at run-time as well. We can isolate\nthe algorithm and make it easily replaceable at the same time by encapsulating it\nin an object. More specifically, we'll define a separate class hierarchy for objects that\nencapsulate formatting algorithms. The root of the hierarchy will define an interface\nthat supports a wide range of formatting \nalgorithms, and each subclass will implement\nthe interface to carry out a particular algorithm. Then we can \nintroduce a Glyph subclass\nthat will structure its children automatically using a given algorithm object.\nCompositor and \nComposition\nWe'll define a Compositor class for objects that can encapsulate a formatting algorithm.\nThe interface (Table 2.2) \nlets the compositor know what glyphs to format and when to do\nthe formatting. \nThe glyphs it formats are the children of a special Glyph subclass called\nComposition. A composition gets an instance of a Compositor subclass (specialized\nfor a particular linebreaking algorithm) \nwhen it is created, and it tells the compositor to\nCompose its glyphs when necessary, for example, when the user changes a document.\nFigure 2.5 \ndepicts the relationships between the Composition and Compositor classes.\n", "page": 61, "type": "text", "section": "Page 61"}
{"text": "42\nA CASE \nSTUDY- DESIGNING A DOCUMENT EDITOR\nCHAPTER 2\nFigure 2.5: Composition and Compositor class relationships\nAn unformatted Composition object contains only the visible glyphs that make up\nthe document's basic content. It doesn't contain glyphs that determine the document's\nphysical structure, such as Row and Column. The composition is in this state just after\nit's created and initialized with the glyphs it should format. When the composition\nneeds formatting, it calls its compositor's Compose operation. The compositor in turn\niterates through the composition's children and inserts new Row and Column glyphs\naccording to its linebreaking algorithm.7 Figure 2.6 \nshows the resulting object structure.\nGlyphs that the compositor created and inserted into the object structure appear with \ngray backgrounds in the figure.\nEach Compositor subclass can implement a different linebreaking algorithm. For ex-\nample, a SimpleCompositor might do a quick pass without regard for such esoterica\nas the document's \"color.\" Good color means having an even distribution of text and\nwhitespace. A TeXCompositor would implement the full Tj?X algorithm [Knu84], which\ntakes things like color into account in exchange for longer formatting times.\nThe Compositor-Composition class split ensures a strong separation between code\nthat supports the document's physical structure and the code for different formatting \nalgorithms. We can add new Compositor subclasses without touching the glyph classes,\nand vice versa. In fact, we can change the linebreaking algorithm at run-time by adding\na single SetCompositor operation to Composition's basic glyph interface.\nStrategy Pattern\nEncapsulating an algorithm in an object is the intent of the Strategy (315) pattern.\nThe key participants in the pattern are Strategy objects (which encapsulate different\nalgorithms) and the context in which they operate. Compositors are strategies; they en-\n7 The compositor must get the character codes of Character glyphs in order to compute the linebreaks.\nIn Section 2.8 we'll see how to get this information polymorphically without adding a \ncharacter-specific \noperation to the Glyph interface.\n", "page": 62, "type": "text", "section": "Page 62"}
{"text": "SECTION 2.4 \nEMBELLISHING THE USER INTERFACE \n43\nFigure 2.6: Object structure reflecting compositor-directed linebreaking\ncapsulate different formatting algorithms. A composition is the context for a compositor\nstrategy.\nThe key to applying the Strategy pattern is designing interfaces for the strategy and\nits context that are general enough to support a range of algorithms. You shouldn't\nhave to change the strategy or context interface to support a new algorithm. In our\nexample, the basic Glyph interface's support for child access, insertion, and removal is\ngeneral enough to let Compositor subclasses change the document's physical structure,\nregardless of the algorithm they use to do it. Likewise, the Compositor interface gives\ncompositions whatever they need to initiate formatting.\n2.4 Embellishing the User Interface\nWe consider two embellishments in Lexi's user interface. The first adds a border around\nthe text editing area to demarcate the page of text. The second adds scroll bars that let\nthe user view different parts of the page. To make it easy to add and remove these\nembellishments (especially at run-time), we shouldn't use inheritance to add them\nto the user interface. We achieve the most flexibility if other user interface objects\ndon't even know the embellishments are there. That will let us add and remove the\nembellishments without changing other classes.\nTransparent Enclosure\nFrom a programming point of view, embellishing the user interface involves extending\nexisting code. Using inheritance to do such extension precludes rearranging embellish-\n", "page": 63, "type": "text", "section": "Page 63"}
{"text": "44 \nA CASE STUDY: DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nments at run-time, but an equally serious problem is the explosion of classes that can\nresult from an inheritance-based approach.\nWe could add a border to Composition by subclassing it to yield a BorderedComposi-\ntion class. Or we could add a scrolling interface in the same way to yield a Scrollable-\nComposition. If we want both scroll bars and a border, we might produce a Bordered-\nScrollableComposition, and so forth. In the extreme, we end up with a class for every\npossible combination of embellishments, a solution that quickly becomes unworkable\nas the variety of embellishments grows.\nObject composition offers a potentially more workable and flexible extension mecha-\nnism. But what objects do we compose? Since we know we're embellishing an existing\nglyph, we could make the embellishment itself an object (say, an instance of class Bor-\nder). That gives us two candidates for composition, the glyph and the border. The next\nstep is to decide who composes whom. We could have the border contain the glyph,\nwhich makes sense given that the border will surround the glyph on the screen. Or\nwe could do the opposite\u2014put the border into the glyph\u2014but then we must make\nmodifications to the corresponding Glyph subclass to make it aware of the border. Our\nfirst choice, composing the glyph in the border, keeps the border-drawing code entirely\nin the Border class, leaving other classes alone.\nWhat does the Border class look like? The fact that borders have an appearance suggests\nthey should actually be glyphs; that is, Border should be a subclass of Glyph. But\nthere's a more compelling reason for doing this: Clients shouldn't care whether glyphs\nhave borders or not. They should treat glyphs uniformly. When clients tell a plain, \nunbordered glyph to draw itself, it should do so without embellishment. If that glyph\nis composed in a border, clients shouldn't have to treat the border containing the glyph\nany differently; they just tell it to draw itself as they told the plain glyph before. This\nimplies that the Border interface matches the Glyph interface. We subclass Border from\nGlyph to guarantee this relationship.\nAll this leads us to the concept of transparent enclosure, which combines the notions\nof (1) single-child (or single-component) composition and (2) compatible interfaces.\nClients generally can't tell whether they're dealing with the component or its enclosure\n(i.e., the child's parent), especially if the enclosure simply delegates all its operations to\nits component. But the enclosure can also augment the component's behavior by doing\nwork of its own before and/or after delegating an operation. The enclosure can also \neffectively add state to the component. We'll see how next.\nMonoglyph\nWe can apply the concept of transparent enclosure to all glyphs that embellish other\nglyphs. To make this concept concrete, we'll define a subclass of Glyph called Mono-\nGlyph to serve as an abstract class for \"embellishment glyphs,\" like Border (see Fig-\nure 2.7). MonoGlyph stores a reference to a component and forwards all requests to it.\n", "page": 64, "type": "text", "section": "Page 64"}
{"text": "SECTION 2.4\nEMBELLISHING THE USER INTERFACE\n45\nFigure 2.7: MonoGlyph class relationships\nThat makes MonoGlyph totally transparent to clients by default. For example, Mono-\nGlyph implements the Draw operation like this:\nvoid MonoGlyph::Draw (Window* w) {\n_component->Draw(w);\n}\nMonoGlyph subclasses reimplement at least one of these forwarding opera-\ntions. Border: : Draw, for instance, first invokes the parent class operation\nMonoGlyph: : Draw on the component to let the component do its part\u2014that is, draw\neverything but the border. Then Border: : Draw draws the border by calling a private\noperation called DrawBorder, \nthe details of which we'll omit:\nvoid Border::Draw (Window* w) { \nMonoGlyph::Draw(w); \nDrawBorder(w);\n}\nNotice how Border: : Draw effectively extends the parent class operation to draw the\nborder. This is in contrast to merely replacing the parent class operation, which would \nomit the call to MonoGlyph: : Draw.\nAnother MonoGlyph subclass appears in Figure 2.7. Scroller is a MonoGlyph that\ndraws its component in different locations based on the positions of two scroll bars,\nwhich it adds as embellishments. When Scroller draws its component, it tells the graph-\nics system to clip to its bounds. Clipping parts of the component that are scrolled out\nof view keeps them from appearing on the screen.\nNow we have all the pieces we need to add a border and a scrolling interface to Lexi's\ntext editing area. We \ncompose the existing Composition instance in a Scroller instance\nto add the scrolling interface, and we compose that in a Border instance. The resulting\nobject structure appears in Figure 2.8.\n", "page": 65, "type": "text", "section": "Page 65"}
{"text": "46 \nA CASE STUDY- DESIGNING A DOCUMENT EDITOR\nCHAPTER 2\nFigure 2.8: Embellished object structure\n", "page": 66, "type": "text", "section": "Page 66"}
{"text": "SECTION 2.5 \nSUPPORTING MULTIPLE LOOK-AND-FEEL STANDARDS \n47\nNote that we can reverse the order of composition, putting the bordered composition\ninto the Scroller instance. In that case the border would be scrolled along with the text,\nwhich may or may not be desirable. The point is, transparent enclosure makes it easy to\nexperiment with different alternatives, and it keeps clients free of embellishment code.\nNote also how the border composes one glyph, not two or more. This is unlike compo-\nsitions we've defined so far, in which parent objects were allowed to have arbitrarily\nmany children. Here, putting a border around something implies that \"something\" is\nsingular. We \ncould assign a meaning to embellishing more than one object at a time, but\nthen we'd have to mix many kinds of composition in with the notion of embellishment:\nrow embellishment, column embellishment, and so forth. That won't help us, since we\nalready have classes to do those kinds of compositions. So it's better to use existing\nclasses for composition and add new classes to embellish the result. Keeping embell-\nishment independent of other kinds of composition both simplifies the embellishment\nclasses and reduces their number. It also keeps us from replicating existing composition\nfunctionality.\nThe Decorator (175) pattern captures class and object relationships that support em-\nbellishment by transparent enclosure. The term \"embellishment\" actually has broader\nmeaning than what we've considered here. In the Decorator pattern, embellishment\nrefers to anything that adds responsibilities to an object. We can think for example of\nembellishing an abstract syntax tree with semantic actions, a finite state automaton\nwith new transitions, or a network of persistent objects with attribute tags. Decorator\ngeneralizes the approach we've used in Lexi to make it more widely applicable.\n2.5 Supporting Multiple Look-and-Feel \nStandards\nAchieving portability across hardware and software platforms is a major problem in\nsystem design. Retargeting Lexi to a new platform shouldn't require a major overhaul,\nor it wouldn't be worth retargeting. We \nshould make porting as easy as possible.\nOne obstacle to portability is the diversity of look-and-feel standards, which are in-\ntended to enforce uniformity between applications. These standards define guidelines\nfor how applications appear and react to the user. While existing standards aren't that\ndifferent from each other, people certainly won't confuse one for the other\u2014Motif ap-\nplications don't look and feel exactly like their counterparts on other platforms, and\nvice versa. An application that runs on more than one platform must conform to the\nuser interface style guide on each platform.\nOur design goals are to make Lexi conform to multiple existing look-and-feel standards\nand to make it easy to add support for new standards as they (invariably) \nemerge. We\nDecorator Pattern\n", "page": 67, "type": "text", "section": "Page 67"}
{"text": "48 \nA CASE STUDY: DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nalso want our design to support the ultimate in flexibility: changing Lexi's look and\nfeel at run-time.\nAbstracting Object Creation\nEverything we see and interact with in Lexi's user interface is a glyph composed in\nother, invisible glyphs like Row and Column. The invisible glyphs compose visible\nones like Button and Character and lay them out properly. Style guides have much\nto say about the look and feel of so-called \"widgets,\" another term for visible glyphs\nlike buttons, scroll bars, and menus that act as controlling elements in a user interface.\nWidgets might use simpler glyphs such as characters, circles, rectangles, and polygons\nto present data.\nWe'll assume we have two sets of widget glyph classes with which to implement\nmultiple look-and-feel standards:\n1. A set of abstract Glyph subclasses for each category of widget glyph. For ex-\nample, an abstract class ScrollBar will augment the basic glyph interface to add\ngeneral scrolling operations; Button is an abstract class that adds button-oriented \noperations; and so on.\n2. A set of concrete subclasses for each abstract subclass that implement different\nlook-and-feel standards. For example, ScrollBar might have Motif \nScrollBar and \nPMScrollBar subclasses that implement Motif and Presentation Manager-style\nscroll bars, respectively.\nLexi must distinguish between widget glyphs for different look-and-feel styles. For\nexample, when Lexi needs to put a button in its interface, it must instantiate a Glyph\nsubclass for the right style of button (MotifButton, PMButton, \nMacButton, etc.).\nIt's clear that Lexi's implementation can't do this directly, say, using a constructor call\nin C++. That would hard-code the button of a particular style, making it impossible\nto select the style at run-time. We'd also have to track down and change every such\nconstructor call to port Lexi to another platform. \nAnd buttons are only one of a variety\nof widgets in Lexi's user interface. Littering our code with constructor calls to specific\nlook-and-feel classes yields a maintenance nightmare\u2014miss just one, and you could\nend up with a Motif menu in the middle of your Mac application.\nLexi needs a way to determine the look-and-feel \nstandard that's being targeted in order\nto create the appropriate widgets. Not only must we avoid making explicit constructor\ncalls; we must also be able to replace an entire widget set easily. We can achieve both\nby abstracting the process of object creation. An example will illustrate what we mean.\n", "page": 68, "type": "text", "section": "Page 68"}
{"text": "SECTION 2.5 \nSUPPORTING MULTIPLE LOOK-AND-FEEL STANDARDS \n49\nFactories and Product Classes\nNormally we might create an instance of a Motif scroll bar glyph with the following\nC++ code:\nScrollBar* sb = new MotifScrollBar;\nThis is the kind of code to avoid if you want to minimize Lexi's look-and-feel depen-\ndencies. But suppose we initialize sb as follows:\nScrollBar* sb = guiFactory->CreateScrollBar();\nwhere guiFactory is an instance of a MotifFactory class. CreateScrollBar returns\na new instance of the proper ScrollBar subclass for the look and feel desired, Motif in this\ncase. As far as clients are concerned, the effect is the same as calling the MotifScrollBar \nconstructor directly. But there's a crucial difference: There's no longer anything in the\ncode that mentions Motif by name. The guiFactory object abstracts the process of\ncreating not just Motif scroll bars but scroll bars for any look-and-feel standard. And\nguiFactory isn't limited to producing scroll bars. It can manufacture a full range of\nwidget glyphs, including scroll bars, buttons, entry fields, menus, and so forth.\nAll this is possible because MotifFactory is a subclass of GUIFactory, an abstract class\nthat defines a general interface for creating widget glyphs. It includes operations like\nCreateScrollBar and CreateButton for instantiating different kinds of widget\nglyphs. Subclasses of GUIFactory \nimplement these operations to return glyphs such\nas MotifScrollBar and PMButton that implement a particular look and feel. Figure 2.9\nshows the resulting class hierarchy for guiFactory objects.\nWe say that factories create product objects. Moreover, the products that a factory\nproduces are related to one another; in this case, the products are all widgets for the\nsame look and feel. Figure 2.10 shows some of the product classes needed to make\nfactories work for widget glyphs.\nThe last question we have to answer is, Where does the GUIFactory instance come\nfrom? The answer is, Anywhere that's convenient. The variable guiFactory could\nbe a global, a static member of a well-known class, or even a local variable if the\nentire user interface is created within one class or function. There's even a design\npattern, Singleton (127), \nfor managing well-known, one-of-a-kind objects like this. The\nimportant thing, though, is to initialize guiFactory at a point in the program before\nit's ever used to create widgets but after it's \nclear which look and feel is desired.\nIf the look and feel is known at compile-time, then guiFactory can be initialized with\na simple assignment of a new factory instance at the beginning of the program:\nGUIFactory* guiFactory = new MotifFactory;\nIf the user can specify the look and feel with a string name at startup time, then the\ncode to create the factory might be\n", "page": 69, "type": "text", "section": "Page 69"}
{"text": "50 \nA CASE STUDY- DESIGNING A DOCUMENT EDITOR\nCHAPTER 2\nFigure 2.10: Abstract product classes and concrete subclasses\nFgure 2.9: GUFactory class hierarchy\n", "page": 70, "type": "text", "section": "Page 70"}
{"text": "SECTION 2.6 \nSUPPORTING MULTIPLE WINDOW SYSTEMS \n51\nGUIFactory* guiFactory; \nconst char* styleName = getenv(\"LOOK_AND_FEEL\");\n// user or environment supplies this at startup\nif (strcmp(styleName, \"Motif\") = = 0 ) {\nguiFactory = new MotifFactory;\n} else if (strcmp(styleName, \"Presentation_Manager\") == 0) {\nguiFactory - new PMFactory;\n} else \n{ \nguiFactory = new DefaultGUIFactory;\n}\nThere are more sophisticated ways to select the factory at run-time. For example, you\ncould maintain a registry that maps strings to factory objects. That lets you register\ninstances of new factory subclasses without modifying existing code, as the preceding\napproach requires. And you don't have to link all platform-specific factories into the\napplication. That's important, because it might not be possible to link a MotifFactory\non a platform that doesn't support Motif.\nBut the point is that once we've configured the application with the right factory\nobject, its look and feel is set from then on. If we change our minds, we can reinitialize\nguiFactory with a factory for a different look and feel and then reconstruct the\ninterface. Regardless of how and when we decide to initialize guiFactory, we know\nthat once we do, the application can create the appropriate look and feel without\nmodification.\nAbstract Factory Pattern\nFactories and products are the key participants in the Abstract Factory (87) \npattern. This\npattern captures how to create families of related product objects \nwithout instantiating\nclasses directly. It's most appropriate when the number and general kinds of product\nobjects stay constant, and there are differences in specific product families. We choose\nbetween families by instantiating a particular concrete factory and using it consistently\nto create products thereafter. \nWe can also swap entire families of products by replacing\nthe concrete factory with an instance of a different one. The Abstract Factory pattern's\nemphasis on families of products distinguishes it from other creational patterns, which\ninvolve only one kind of product object.\n2.6 Supporting Multiple Window Systems\nLook and feel is just one of many portability issues. Another is the windowing en-\nvironment in which Lexi runs. A platform's window system creates the illusion of\nmultiple overlapping windows on a bitmapped display. It manages screen space for\n", "page": 71, "type": "text", "section": "Page 71"}
{"text": "52 \nA CASE STUDY- DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nwindows and routes input to them from the keyboard and mouse. Several important\nand largely incompatible window systems exist today (e.g., Macintosh, Presentation\nManager, Windows, X). We'd like Lexi to run on as many of them as possible for \nexactly\nthe same reasons we support multiple look-and-feel standards.\nCan We Use an Abstract Factory?\nAt first glance this may look like another opportunity to apply the Abstract Factory\npattern. But the constraints for window system portability differ significantly from\nthose for look-and-feel independence.\nIn applying the Abstract Factory pattern, we assumed we would define the concrete\nwidget glyph classes for each look-and-feel \nstandard. That meant we could derive each\nconcrete product for a particular standard (e.g., MotifScrollBar and MacScrollBar) from\nan abstract product class (e.g., ScrollBar). But suppose we already have several class\nhierarchies from different vendors, one for each look-and-feel standard. Of course, it's\nhighly unlikely these hierarchies are compatible in any way. Hence we won't have a\ncommon abstract \nproduct class for each kind of widget (ScrollBar, Button, \nMenu, etc.)\u2014\nand the Abstract Factory pattern won't work without those crucial classes. We have\nto make the different widget hierarchies adhere to a common set of abstract product\ninterfaces. Only then could we declare the Create. . . operations properly in our\nabstract factory's interface.\nWe solved this problem for widgets by developing our own abstract and concrete prod-\nuct classes. Now we're faced with a similar problem when we try to make Lexi work\non existing window systems; namely, different window systems have incompatible\nprogramming interfaces. Things are a bit tougher this time, though, because we can't\nafford to implement our own nonstandard window system.\nBut there's a saving grace. Like look-and-feel standards, window system interfaces\naren't radically different from one another, because all window systems do generally\nthe same thing. We need a uniform set of windowing abstractions that lets us take\ndifferent window system implementations and slide any one of them under a common\ninterface.\nEncapsulating Implementation Dependencies\nIn Section 2.2 we introduced a Window class for displaying a glyph or glyph structure\non the display. We didn't specify the window system that this object worked with,\nbecause the truth is that it doesn't come from any particular window system. The\nWindow class encapsulates the things windows tend to do across window systems:\n\u2022 They provide operations for drawing basic geometric shapes.\n\u2022 They can iconify and de-iconify themselves.\n", "page": 72, "type": "text", "section": "Page 72"}
{"text": "SECTION 2.6\nSUPPORTING MULTIPLE WINDOW SYSTEMS\n53\nResponsibility\nwindow \nmanagement\ngraphics\nOperations\nvirtual \nvirtual \nvirtual \nvirtual \nvirtual\nvirtual\nvirtual\nvirtual\nvirtual\nvoid Redraw \n()\nvoid Raise \n()\nvoid Lower \n( \n)\nvoid Iconify \n( \n)\nvoid DeiconifyO\nvoid DrawLine \n(...)\nvoid DrawRect \n(...) \nvoid DrawPolygon \n(...)\nvoid DrawText \n(...)\nTable 2.3: Window class interface\n\u2022 They can \nresize themselves.\n\u2022 They can (re)draw their contents on demand, for example, when they are de-\niconified or when an overlapped and obscured portion of their screen space is\nexposed.\nThe Window class must span the functionality of windows from different window\nsystems. Let's consider two extreme philosophies:\n1. Intersection of functionality. The Window class interface provides only functionality\nthat's common to all window systems. The problem with this approach is that our\nWindow interface winds up being only as powerful as the least capable window \nsystem. We can't take advantage of more advanced features even if most (but not\nall) window systems support them.\n2. Union of functionality. Create an interface that incorporates the capabilities of all\nexisting systems. The trouble here is that the resulting interface may well be huge\nand incoherent. Besides, we'll have to change it (and Lexi, which depends on it)\nanytime a vendor revises its window system interface.\nNeither extreme is a viable solution, so our design will fall somewhere between the\ntwo. The Window class will provide a convenient interface that supports the most\npopular windowing features. Because \nLexi \nwill deal with this class directly, the Window\nclass must also support the things Lexi knows about, namely, glyphs. That means\nWindow's interface must include a basic set of graphics operations that lets glyphs\ndraw themselves in the window. Table 2.3 gives a sampling of the operations in the\nWindow class interface.\nWindow is an abstract class. Concrete subclasses of Window support the different kinds\nof windows that users deal with. For example, application windows, icons, and warning\ndialogs are all windows, but they have somewhat different behaviors. So \nwe can define\nsubclasses like Application \nWindow, Icon \nWindow, and DialogWindow to capture these\n", "page": 73, "type": "text", "section": "Page 73"}
{"text": "54 \nA CASE \nSTUDY- DESIGNING A DOCUMENT EDITOR\nCHAPTER 2\ndifferences. The resulting class hierarchy gives applications like Lexi a uniform and\nintuitive windowing abstraction, one that doesn't depend on any particular vendor's\nwindow system:\nNow that we've defined a window interface for Lexi to work with, where does the\nreal platform-specific window come in? If we're not implementing our own window\nsystem, then at some point our window abstraction must be implemented in terms of \nwhat the target window system provides. So where does that implementation live?\nOne approach is to implement multiple versions of the Window class and its subclasses,\none version for each windowing platform. We'd have to choose the version to use when\nwe build Lexi for a given platform. But imagine the maintenance headaches we'd\nhave keeping track of multiple classes, all named \"Window\" but each implemented\non a different window system. Alternatively, we could create implementation-specific\nsubclasses of each class in the Window hierarchy\u2014and end up with another subclass\nexplosion problem like the one we had trying to add embellishments. Both of these\nalternatives have another drawback: Neither gives us the flexibility to change the\nwindow system we use after we've compiled the program. So we'll have to keep\nseveral different executables around as well.\nNeither alternative is very appealing, but what else can we do? The same thing we\ndid for formatting and embellishment, namely, encapsulate the concept that varies. What\nvaries in this case is the window system implementation. If we encapsulate a window\nsystem's functionality in an object, then we can implement our Window class and\nsubclasses in terms of that object's interface. Moreover, if that interface can serve all\nthe window systems we're interested in, then we won't have to change Window or\nany of its subclasses to support different window systems. We can configure window\nobjects to the window system we want simply by passing them the right window\nsystem-encapsulating object. We can even configure the window at run-time.\n", "page": 74, "type": "text", "section": "Page 74"}
{"text": "SECTION 2.6\nSUPPORTING MULTIPLE WINDOW SYSTEMS\n55\nWindow and Windowlmp\nWe'll define a separate Windowlmp class hierarchy in which to hide different window\nsystem implementations. Windowlmp is an abstract class for objects that encapsulate\nwindow system-dependent code. To make Lexi work on a particular window sys-\ntem, we configure each window object with an instance of a Windowlmp subclass for\nthat system. The following diagram shows the relationship between the Window and\nWindowlmp hierarchies:\nBy hiding the implementations in Windowlmp classes, we avoid polluting the Window\nclasses with window system dependencies, which keeps the Window class hierarchy\ncomparatively small and stable. Meanwhile we can easily extend the implementation\nhierarchy to support new window systems.\nWindowlmp Subclasses\nSubclasses of Windowlmp convert requests into window system-specific operations.\nConsider the example we used in Section 2.2. We defined the Rectangle : : Draw in\nterms of the DrawRect operation on the Window instance:\nvoid Rectangle::Draw (Window* w) {\nw->DrawRect(_xO, _yO, _xl, _yl);\n}\nThe default implementation of DrawRect uses the abstract operation for drawing\nrectangles declared by Windowlmp:\nvoid Window::DrawRect (\nCoord xO, Coord yO, Coord xl, Coord yl\n) {\n_imp->DeviceRect(xO, yO, xl, yl);\n}\n", "page": 75, "type": "text", "section": "Page 75"}
{"text": "56 \nA CASE STUDY: DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nwhere _imp is a member \nvariable of Window that stores the Windowlmp \nwith which the\nWindow is configured. The window implementation is defined by the instance of the\nWindowlmp subclass that _imp points to. For an XWindowImp (that is, a Windowlmp\nsubclass for the X Window System), the DeviceRect's implementation might look\nlike\nvoid XWindowImp::DeviceRect ( \nCoord xO, Coord yO, Coord xl, Coord yl\n) \n{\nint x = round(min(xO, x l ) ) ; \nint y = round(min(yO, y l ) ) ; \nint w = round(abs(xO - x l ) ) ; \nint h = round(abs(yO - yl) ) \n;\nXDrawRectangle(_dpy, _winid, _gc, x, y, w, h) ;\n}\nDeviceRect is defined like this because XDrawRectangle (the X interface \nfor draw-\ning a rectangle) defines a rectangle in terms of its lower left corner, its width, and its\nheight. DeviceRect must compute these values from those supplied. First it \nascertains\nthe lower left corner (since (xO, yO) might be any one of the rectangle's four corners)\nand then calculates the width and height.\nPMWindowImp (a subclass of Windowlmp for Presentation Manager) would define\nDeviceRect differently:\nvoid PMWindowImp::DeviceRect (\nCoord xO, Coord yO, Coord xl, Coord yl\n) {\nCoord left = minfxO, \nxl);\nCoord right = max(xO, xl);\nCoord bottom = min(yO, \nyl);\nCoord top = max(yO, \nyl);\nPPOINTL point[4];\npoint[0].x = left; \npoint[0].y = \ntop;\npoint[l].x = right; \npoint[1].y = \ntop;\npoint[2].x = right; \npoint[2].y = \nbottom;\npoint[3].x = left; \npoint[3].y = bottom;\nif ( \n(GpiBeginPath(_hps, 1L) == false) I I\n(GpiSetCurrentPosition(_hps, &point[3]) = = false) I I\n(GpiPolyLine(_hps, 4L, point) == GPI_ERROR) \nI\nI\n(GpiEndPath(_hps) == false)\n) \n{ \n// report error\n} else \n{\nGpiStrokePath(_hps, 1L, OL);\n}\n}\n", "page": 76, "type": "text", "section": "Page 76"}
{"text": "SECTION 2.6 \nSUPPORTING MULTIPLE WINDOW SYSTEMS \n57\nWhy is this so different from the X version? Well, PM doesn't have an operation for\ndrawing rectangles explicitly as X does. Instead, PM has a more general interface for\nspecifying vertices of multisegment shapes (called a path) and for outlining or filling\nthe area they enclose.\nPM's implementation of DeviceRect is obviously quite different from X's, but that\ndoesn't matter. Windowlmp hides variations in window system interfaces behind a\npotentially large but stable interface. That lets Window subclass writers focus on the\nwindow abstraction \nand not on window system details. It also lets us add support for\nnew window systems without disturbing the Window classes.\nConfiguring Windows with Windowlmps\nA key issue we haven't addressed is how a window gets configured with the proper\nWindowlmp subclass in the first place. Stated another way, when does _imp get ini-\ntialized, and who knows what window system (and consequently which Windowlmp\nsubclass) is in use? The window will need some kind of Windowlmp before it can do\nanything interesting.\nThere are several possibilities, but we'll focus on one that uses the Abstract Factory \n(87)\npattern. We can define an abstract factory class WindowSystemFactory that provides\nan interface for creating different kinds of window system-dependent implementation\nobjects:\nclass WindowSystemFactory {\npublic:\nvirtual Windowlmp* CreateWindowImp() = 0;\nvirtual Colorlmp* CreateColorlmp() = 0; \nvirtual Fontlmp* CreateFontlmp() = 0;\n// a \"Create...\" operation for all window system resources\n};\nNow we can define a concrete factory for each window system:\nclass PMWindowSystemFactory : public WindowSystemFactory {\nvirtual Windowlmp* CreateWindowImp() \n{ return new PMWindowImp; } \n// . . \n.\n};\nclass XWindowSystemFactory : \npublic WindowSystemFactory {\nvirtual Windowlmp* CreateWindowImp()\n{ return new XWindowImp; }\n// . . .\n};\nThe Window base class constructor can use the WindowSystemFactory \ninterface to\ninitialize the _imp member with the Windowlmp that's right for the window system:\n", "page": 77, "type": "text", "section": "Page 77"}
{"text": "58 \nA CASE STUDY: DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nWindow: :Window ( ) {\n_imp = windowSystemFactory->CreateWindowImp();\n}\nThe windowSystemFactory variable is a well-known instance of a WindowSystem-\nFactory subclass, akin to the well-known guiFactory variable defining the look and\nfeel. The windowSystemFactory variable can be initialized in the same way.\nBridge Pattern\nThe Windowlmp class defines an interface to common window system facilities, but\nits design is driven by different constraints than Window's interface. Application pro-\ngrammers won't deal with Windowimp's interface directly; they only deal with Win-\ndow objects. So Windowlmp's interface needn't match the application programmer's\nview of the world, as was our concern in the design of the Window class hierarchy\nand interface. Windowlmp's interface can more closely reflect what window systems\nactually provide, warts and all. It can be biased toward either an intersection or a union\nof functionality approach, whichever suits the target window systems best.\nThe important thing to realize is that Window's interface caters to the applications\nprogrammer, while Windowlmp caters to window systems. Separating windowing\nfunctionality into Window and Windowlmp hierarchies lets us implement and special-\nize these interfaces independently. Objects from these hierarchies cooperate to let Lexi \nwork without modification on multiple window systems.\nThe relationship between Window and Windowlmp is an example of the Bridge (151)\npattern. The intent behind Bridge is to allow separate class hierarchies to work together\neven as they evolve independently. Our design criteria led us to create two separate\nclass hierarchies, one that supports the logical notion of windows, and another for\ncapturing different implementations of windows. The Bridge pattern lets us maintain\nand enhance our logical windowing abstractions without touching window system-\ndependent code, and vice versa.\n2.7 User Operations\nSome of Lexi's functionality is available through the document's WYSIWYG represen-\ntation. You \nenter and delete text, move the insertion point, and select ranges of text by\npointing, clicking, and typing directly in the document. Other functionality is accessed \nindirectly through user operations in Lexi's pull-down menus, buttons, and keyboard\naccelerators. The functionality includes operations for\n\u2022 creating a new document,\n\u2022 opening, saving, and printing an existing document,\n", "page": 78, "type": "text", "section": "Page 78"}
{"text": "SECTION 2.7 \nUSER OPERATIONS \n59\n\u2022 cutting selected text out of the document and pasting it back in,\n\u2022 changing the font and style of selected text,\n\u2022 changing the formatting of text, such as its alignment and justification,\n\u2022 quitting the application,\n\u2022 and on and on.\nLexi provides different user interfaces for these operations. But we don't want to\nassociate a particular user operation with a particular user interface, because we may\nwant multiple user interfaces to the same operation (you can turn the page using either\na page button or a menu operation, for example). We may also want to change the\ninterface in the future.\nFurthermore, these operations are implemented in many different classes. We \nas imple-\nmentors want to access their functionality without creating a lot of dependencies be-\ntween implementation and user interface classes. Otherwise we'll end up with a tightly\ncoupled implementation, which will be harder to understand, extend, and maintain.\nTo further complicate matters, we want Lexi to support undo and redo8 of most but\nnot all its functionality. Specifically, we want to be able to undo document-modifying\noperations like delete, with which a user can destroy lots of data inadvertently. But we\nshouldn't try to undo an operation like saving a drawing or quitting the application.\nThese operations should have no effect on the undo process. We also don't want an\narbitrary limit on the number of levels of undo and redo.\nIt's clear that support for user operations permeates the application. The challenge is\nto come up with a simple and extensible mechanism that satisfies all of these needs.\nEncapsulating a Request\nFrom our perspective as designers, a pull-down menu is just another kind of glyph that\ncontains other glyphs. What distinguishes pull-down menus from other glyphs that\nhave children is that most glyphs in menus do some work in response to an up-click.\nLet's assume that these work-performing glyphs are instances of a Glyph subclass\ncalled Menultem and that they do their work in response to a request from a client.9\nCarrying out the request might involve an operation on one object, or many operations\non many objects, or something in between.\nWe could define a subclass of Menultem for every user operation and then hard-code\neach subclass to carry out the request. But that's not really right; we don't need a\nsubclass of Menultem for each request any more than we need a subclass for each text\n8 That is, redoing an operation \nthat was just undone.\n9 Conceptually, the client is Lexi's user, but in reality it's another object (such as an event dispatcher) that\nmanages inputs from the user.\n", "page": 79, "type": "text", "section": "Page 79"}
{"text": "60 \nA CASE STUDY: DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nstring in a pull-down menu. Moreover, this approach couples the request to a particular\nuser interface, making it hard to fulfill the request through a different user interface.\nTo illustrate, suppose you could advance to the last page in the document both through\na Menultem in a pull-down menu and by pressing a page icon at the bottom of Lexi's\ninterface (which might be more convenient for short documents). If we associate the\nrequest with a Menultem through inheritance, then we must do the same for the page\nicon and any other kind of widget that might issue such a request. That can give rise\nto a number of classes approaching the product of the number of widget types and the\nnumber of requests.\nWhat's missing is a mechanism that lets us parameterize menu items by the request\nthey should fulfill. That way we avoid a proliferation of subclasses and allow for greater\nflexibility at run-time. We could parameterize Menultem with a function to call, but\nthat's not a complete solution for at least three reasons:\n1. It doesn't address the undo/redo problem.\n2. It's hard to associate state with a function. For example, a function that changes\nthe font needs to know which font.\n3. Functions are hard to extend, and it's hard to reuse parts of them.\nThese reasons suggest that we should parameterize Menultems with an object, not a\nfunction. Then we can use inheritance to extend and reuse the request's implementation.\nWe also have a place to store state and implement undo/redo functionality. Here we \nhave another example of encapsulating the concept that varies, in this case a request.\nWe'll encapsulate each request in a command object.\nCommand Class and Subclasses\nFirst we define a Command abstract class to provide an interface for issuing a request.\nThe basic interface consists of a single abstract operation called \"Execute.\" Subclasses\nof Command implement Execute in different ways to fulfill different requests. Some\nsubclasses may delegate part or all of the work to other objects. Other subclasses may be\nin a position to fulfill the request entirely on their own (see Figure 2.11). To \nthe requester,\nhowever, a Command object is a Command object\u2014they are treated uniformly.\nNow Menultem can store a Command object that encapsulates a request (Figure 2.12).\nWe give each menu item object an instance of the Command subclass that's suitable\nfor that menu item, just as we specify the text to appear in the menu item. When a user\nchooses a particular menu item, the Menultem simply calls Execute on its Command\nobject to carry out the request. Note that buttons and other widgets can use commands\nin the same way menu items do.\n", "page": 80, "type": "text", "section": "Page 80"}
{"text": "SECTION 2.7\nUSER OPERATIONS \n61\nFigure 2.11: Partial Command class hierarchy\nFigure 2.12: Menultem-Command relationship\n", "page": 81, "type": "text", "section": "Page 81"}
{"text": "62 \nA CASE STUDY: DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nUndoability\nUndo/redo is an important capability in interactive applications. To undo and redo\ncommands, we add an Unexecute operation to Command's interface. Unexecute re-\nverses the effects of a preceding Execute operation using whatever undo information\nExecute stored. In the case of a FontCommand, for example, the Execute operation\nwould store the range of text affected by the font change along with the original font(s).\nFontCommand's Unexecute operation would restore the range of text to its original\nfont(s).\nSometimes undoability must be determined at run-time. A request to change the font\nof a selection does nothing if the text already appears in that font. Suppose the user\nselects some text and then requests a spurious font change. What should be the result\nof a subsequent undo request? Should a meaningless change cause the undo request to\ndo something equally meaningless? Probably not. If the user repeats the spurious font\nchange several times, he shouldn't have to perform exactly the same number of undo\noperations to get back to the last meaningful operation. If the net effect of executing a\ncommand was nothing, then there's no need for a corresponding undo request.\nSo to determine if a command is undoable, we add an abstract Reversible operation\nto the Command interface. Reversible returns a Boolean \nvalue. Subclasses can \nredefine\nthis operation to return true or false based on run-time criteria.\nCommand History\nThe final step in supporting arbitrary-level undo and redo is to define a command\nhistory, or list of commands that have been executed (or unexecuted, if some commands\nhave been undone). Conceptually, the command history looks like this:\nEach circle represents a Command object. In this case the user has issued four com-\nmands. The leftmost command was issued first, followed by the second-leftmost, and\nso on until the most recently issued command, which is rightmost. The line marked\n\"present\" keeps track of the most recently executed (and unexecuted) command.\nTo undo the last command, we simply call Unexecute on the most recent command:\n", "page": 82, "type": "text", "section": "Page 82"}
{"text": "SECTION 2.7\nUSER OPERATIONS\n63\nAfter unexecuting the command, we move the \"present\" line one command to the left.\nIf the user chooses undo again, the next-most recently issued command will be undone\nin the same way, and we're left in the state depicted here:\nYou can see that by simply repeating this procedure we get multiple levels of undo.\nThe number of levels is limited only by the length of the command history.\nTo redo a command that's just been undone, we do the same thing in reverse. Com-\nmands to the right of the present line are commands that may be redone in the future.\nTo redo the last undone command, we call Execute on the command to the right of the\npresent line:\nThen we advance the present line so that a subsequent redo will call redo on the\nfollowing command in the future.\n", "page": 83, "type": "text", "section": "Page 83"}
{"text": "64 \nA CASE STUDY: DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nOf course, if the subsequent operation is not another redo but an undo, then the\ncommand to the left of the present line will be undone. Thus the user can effectively go\nback and forth in time as needed to recover from errors.\nCommand Pattern\nLexi's commands are an application of the Command (233) pattern, which describes\nhow to encapsulate a request. The Command pattern prescribes a uniform interface\nfor issuing requests that lets you configure clients to handle different requests. The\ninterface shields clients from the request's implementation. A command may delegate \nall, part, or none of the request's implementation to other objects. This is perfect for\napplications like Lexi that must provide centralized access to functionality scattered\nthroughout the application. The pattern also discusses undo and redo mechanisms\nbuilt on the basic Command interface.\n2.8 Spelling Checking and Hyphenation\nThe last design problem involves textual analysis, specifically checking for misspellings\nand introducing hyphenation points where needed for good formatting.\nThe constraints here are similar to those we had for the formatting design problem in\nSection 2.3. As was the case for linebreaking strategies, there's more than one way to\ncheck spelling and compute hyphenation points. So \nhere too we want to support multi-\nple algorithms. A diverse set of algorithms can provide a choice of space/time/quality\ntrade-offs. We should make it easy to add new algorithms as well.\nWe also want to avoid wiring this functionality into the document structure. This goal is\neven more important here than it was in the formatting case, because spelling checking\nand hyphenation are just two of potentially many kinds of analyses we may want\nLexi to support. Inevitably we'll want to expand Lexi's analytical abilities over time.\nWe might add searching, word counting, a calculation facility for adding up tabular\nvalues, grammar checking, and so forth. But we don't want to change the Glyph class\nand all its subclasses every time we introduce new functionality of this sort.\n", "page": 84, "type": "text", "section": "Page 84"}
{"text": "SECTION 2.8 \nSPELLING CHECKING AND HYPHENATION \n65\nThere are actually two pieces to this puzzle: (1) accessing the information to be analyzed,\nwhich we have scattered over the glyphs in the document structure, and (2) doing the\nanalysis. We'll look at these two pieces separately.\nAccessing Scattered Information\nMany kinds of analysis require examining the text character by character. The text we\nneed to analyze is scattered throughout a hierarchical structure of glyph objects. To\nexamine text in such a structure, we need an access mechanism that has knowledge\nabout the data structures in which objects are stored. Some glyphs might store their\nchildren in linked lists, others might use arrays, and still others might use more esoteric\ndata structures. Our access mechanism must be able to handle all of these possibilities.\nAn added complication is that different analyses access information in different ways.\nMost analyses will traverse the text from beginning to end. But some do the opposite\u2014a\nreverse search, for example, needs to progress through the text backward rather than\nforward. Evaluating algebraic expressions could require an inorder traversal.\nSo our access mechanism must accommodate differing data structures, and we must\nsupport different kinds of traversals, such as preorder, postorder, and inorder.\nEncapsulating Access and Traversal\nRight now our glyph interface uses an integer index to let clients refer to children.\nAlthough that might be reasonable for glyph classes that store their children in an\narray, it may be inefficient for glyphs that use a linked list. An important role of the \nglyph abstraction is to hide the data structure in which children are stored. That way\nwe can change the data structure a glyph class uses without affecting other classes.\nTherefore only the glyph can know the data structure it uses. A corollary is that the\nglyph interface shouldn't be biased toward one data structure or another. It shouldn't\nbe better suited to arrays than to linked lists, for example, as it is now.\nWe can solve this problem and support several different kinds of traversals at the\nsame time. We can put multiple access and traversal capabilities directly in the glyph\nclasses and provide a way to choose among them, perhaps by supplying an enumerated\nconstant as a parameter. The classes pass this parameter around during a traversal to\nensure they're all doing the same kind of traversal. They have to pass around any\ninformation they've accumulated during traversal.\nWe might add the following abstract operations to Glyph's interface to support this\napproach:\n", "page": 85, "type": "text", "section": "Page 85"}
{"text": "66 \nA CASE STUDY: DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nvoid First(Traversal kind)\nvoid Next() \nbool IsDone()\nGlyph* GetCurrent() \nvoid Insert(Glyph*)\nOperations First, Next, and IsDone control the traversal. First initializes the\ntraversal. It takes the kind of traversal as a parameter of type Traversal, an enu-\nmerated constant with values such as CHILDREN (to traverse the glyph's immediate\nchildren only), PREORDER (to traverse the entire structure in preorder), POSTORDER,\nand INORDER. Next advances to the next glyph in the traversal, and IsDone reports\nwhether the traversal is over or not. GetCurrent replaces the Child operation; it\naccesses the current glyph in the traversal. Insert replaces the old operation; it inserts\nthe given glyph at the current position.\nAn analysis would use the following C++ code to do a preorder traversal of a glyph\nstructure rooted at g:\nGlyph* g;\nfor \n(g->First(PREORDER) ; !g->IsDone() ; g->Next() ) { \nGlyph* current = g->GetCurrent();\n// do some analysis\n}\nNotice that we've banished the integer index from the glyph interface. There's no longer\nanything that biases the interface toward one kind of collection or another. We've also\nsaved clients from having to implement common kinds of traversals themselves.\nBut this approach still has problems. For one thing, it can't support new traversals\nwithout either extending the set of enumerated values or adding new operations.\nSay we wanted to have a variation on preorder traversal that automatically skips non-\ntextual glyphs. We'd have to change the Traversal enumeration to include something\nlike TEXTUAL-PREORDER.\nWe'd like to avoid changing existing declarations. Putting the traversal mechanism en-\ntirely in the Glyph class hierarchy makes it hard to modify or extend without changing\nlots of classes. It's also difficult to reuse the. mechanism to traverse other kinds of object\nstructures. And we can't have more than one traversal in progress on a structure.\nOnce again, a better solution is to encapsulate the concept that varies, in this case the\naccess and traversal mechanisms. We can introduce a class of objects called iterators\nwhose sole purpose is to define different sets of these mechanisms. We can use inher-\nitance to let us access different data structures uniformly and support new kinds of\ntraversals as well. And we won't have to change glyph interfaces or disturb existing\nglyph implementations to do it.\n", "page": 86, "type": "text", "section": "Page 86"}
{"text": "SECTION 2.8\nSPELLING CHECKING AND HYPHENATION \n67\nFigure 2.13: Iterator class and subclasses\nIterator Class and Subclasses\nWe'll use an abstract class called Iterator to define a general interface for access and \ntra-\nversal. Concrete subclasses like Arraylterator and Listlterator implement the interface \nto provide access to arrays and lists, while Preorderlterator, Postorderlterator, and the\nlike implement different traversals on specific structures. Each Iterator subclass has a\nreference to the structure it traverses. Subclass instances are initialized with this refer-\nence when they are created. Figure 2.13 illustrates the Iterator class along with several\nsubclasses. Notice that we've added a Createlterator abstract operation to the Glyph\nclass interface to support iterators.\nThe Iterator interface provides operations First, Next, and IsDone for controlling the\ntraversal. The Listlterator class implements First to point to the first element in the list,\nand Next advances the iterator to the next item in the list. IsDone returns whether or\nnot the list pointer points beyond the last element in the list. Currentltem dereferences\nthe iterator to return the glyph it points to. An Arraylterator class would do similar\nthings but on an array of glyphs.\nNow we can access the children of a glyph structure without knowing its representa-\ntion:\n", "page": 87, "type": "text", "section": "Page 87"}
{"text": "68 \nA CASE STUDY- DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nGlyph* g;\nIterator<Glyph*>* i = g->Create!terator();\nfor (i->First() ; !i->IsDone ( ) ; i->Next()) { \nGlyph* child = i->Current!tem();\n// do something with current child\n}\nCreatelterator returns a Nulllterator instance by default. A Nulllterator is a degenerate\niterator for glyphs that have no children, that is, leaf glyphs. Nulllterator's IsDone\noperation always returns true.\nA glyph subclass that has children will override Createlterator to return an instance\nof a different Iterator subclass. Which subclass depends on the structure that stores the\nchildren. If the Row subclass of Glyph stores its children in a list .children, then its\nCreatelterator operation would look like this:\nIterator<Glyph*>* Row::CreateIterator () {\nreturn new ListIterator<Glyph*>(_children);\n}\nIterators for preorder and inorder traversals implement their traversals in terms of\nglyph-specific iterators. The iterators for these traversals are supplied the root glyph in\nthe structure they traverse. They call Createlterator on the glyphs in the structure and\nuse a stack to keep track of the resulting iterators.\nFor example, class Preorder It erat or gets the iterator from the \nroot glyph, initializes\nit to point to its first element, and then pushes it onto the stack:\nvoid Preorderlterator::First () \n{ \nIterator<Glyph*>* i = _root->Create!terator();\nif (i) \n{\ni->First();\n..iterators .RemoveAll ( ) ;\n_iterators.Push ( i ) ;\n}\n}\nCur \nrent 11 em \nwould simply call Cur \nrent 11 em \non the iterator at the top of the stack:\n", "page": 88, "type": "text", "section": "Page 88"}
{"text": "SECTION 2.8 \nSPELLING CHECKING AND HYPHENATION \n69\nGlyph* Preorderlterator::Currentltem () \nconst {\nreturn\n_iterators.Size() > 0 ?\n_iterators.Top()->CurrentItem() : \n0;\n}\nThe Next operation gets the top iterator on the stack and asks its current item to\ncreate an iterator, in an effort to descend the glyph structure as far as possible (this\nis a preorder traversal, after all). \nNext sets the new iterator to the first item in the\ntraversal and pushes it on the stack. Then Next tests the latest iterator; if its IsDone \noperation returns true, then we've finished traversing the current subtree (or leaf) in the\ntraversal. In that case, Next pops the top iterator off the stack and repeats this process\nuntil it finds the next incomplete traversal, if there is one; if not, then we have finished\ntraversing the structure.\nvoid Preorderlterator: .-Next () { \nIterator<Glyph*>* i =\n_iterators.Top()->CurrentItem()->CreateIterator();\ni->First();\n_iterators.Push(i) ;\nwhile (\n_iterators.Size() > 0 && _iterators.Top()->IsDone()\n) \n{\ndelete _iterators.Pop();\n_iterators.Top()->Next();\n}\nNotice how the Iterator class hierarchy lets us add new kinds of traversals without\nmodifying glyph classes\u2014we simply subclass Iterator and add a new traversal as\nwe have with Preorderlterator. Glyph subclasses use the same interface to give\nclients access to their children without revealing the underlying data structure they\nuse to store them. Because iterators store their own copy of the state of a traversal,\nwe can carry on multiple traversals simultaneously, even on the same structure. And\nthough our traversals have been over glyph structures in this example, there's no\nreason we can't parameterize a class like Preorderlterator by the type of object in\nthe structure. We'd use templates to do that in C++. \nThen we can reuse the machinery\nin Preorderlterator to traverse other structures.\nIterator Pattern\nThe Iterator (257) \npattern captures these techniques for supporting access and traversal\nover object structures. It's applicable not only to composite structures but to collections\nas well. It abstracts the traversal algorithm and shields clients from the internal structure\n", "page": 89, "type": "text", "section": "Page 89"}
{"text": "70 \nA CASE STUDY: DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nof the objects they traverse. \nThe Iterator pattern illustrates once more how encapsulating\nthe concept that varies helps us gain flexibility and reusability. Even so, the problem of\niteration has surprising depth, and the Iterator pattern covers many more nuances and\ntrade-offs than we've considered here.\nTraversal versus Traversal Actions\nNow that we have a way of traversing the glyph structure, we need to check the spelling\nand do the hyphenation. Both analyses involve accumulating information during the\ntraversal.\nFirst we have to decide where to put the responsibility for analysis. We could put it in the\nIterator classes, thereby making analysis an integral part of traversal. But we get more\nflexibility and potential for reuse if we distinguish between the traversal and the actions\nperformed during traversal. That's because different analyses often require the same\nkind of traversal. Hence we can reuse the same set of iterators for different analyses. For\nexample, preorder traversal is common to many analyses, including spelling checking,\nhyphenation, forward search, and word count.\nSo analysis and traversal should be separate. Where else can we put the responsibility\nfor analysis? We know there are many kinds of analyses we might want to do. Each\nanalysis will do different things at different points in the traversal. Some glyphs are\nmore significant than others depending on the kind of analysis. If we're checking\nspelling or hyphenating, we want to consider character glyphs and not graphical ones\nlike lines and bitmapped images. If we're making color separations, we'd want to\nconsider visible glyphs and not invisible ones. Inevitably, different analyses will analyze\ndifferent glyphs.\nTherefore a given analysis must be able to distinguish different kinds of glyphs. An\nobvious approach is to put the analytical capability into the glyph classes themselves.\nFor each analysis we can add one or more abstract operations to the Glyph class and\nhave subclasses implement them in accordance with the role they play in the analysis.\nBut the trouble with that approach is that we'll have to change every glyph class\nwhenever we add a new kind of analysis. We can ease this problem in some cases:\nIf only a few classes participate in the analysis, or if most classes do the analysis the\nsame way, then we can supply a default implementation for the abstract operation in\nthe Glyph class. The default operation would cover the common case. Thus we'd limit\nchanges to just the Glyph class and those subclasses that deviate from the norm.\nYet even if a default implementation reduces the number of changes, an insidious\nproblem remains: Glyph's interface expands with every new analytical \ncapability. \nOver\ntime the analytical operations will start to obscure the basic Glyph interface. It becomes\nhard to see that a glyph's main purpose is to define and structure objects that have\nappearance and shape\u2014that interface gets lost in the noise.\n", "page": 90, "type": "text", "section": "Page 90"}
{"text": "SECTION 2.8\nSPELLING CHECKING AND \nHYPHENATION\n71\nEncapsulating the Analysis\nFrom all indications, we need to encapsulate the analysis in a separate object, much like\nwe've done many times before. We could put the machinery for a given analysis into\nits own class. We \ncould use an instance of this class in conjunction with an appropriate\niterator. The iterator would \"carry\" the instance to each glyph in the structure. The\nanalysis object could then perform a piece of the analysis at each point in the traversal.\nThe \nanalyzer accumulates information of interest (characters in this case) as the traversal\nproceeds:\nThe fundamental question with this approach is how the analysis object distinguishes\ndifferent kinds of glyphs without resorting to type tests or downcasts. We don't want\na SpellingChecker class to include (pseudo)code like\nvoid SpellingChecker::Check (Glyph* glyph) {\nCharacter* c;\nRow* r; \nImage* i;\nif \n(c = dynamic_cast<Character*>(glyph)) {\n// analyze the character\n} else if \n(r = dynamic_cast<Row*>(glyph)) {\n// prepare to analyze r's children\n", "page": 91, "type": "text", "section": "Page 91"}
{"text": "72 \nA CASE STUDY: DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\n} else if (i = dynamic_cast<Image*>(glyph)) {\n// do nothing\n}\n}\nThis code is pretty ugly. It relies on fairly esoteric capabilities like type-safe casts. It's\nhard to extend as well. We'll have to remember to change the body of this function\nwhenever we change the Glyph class hierarchy. In fact, this is the kind of code that\nobject-oriented languages were intended to eliminate.\nWe want to avoid such a brute-force \napproach, but how? Let's consider what happens\nwhen we add the following abstract operation to the Glyph class:\nvoid CheckMe(SpellingChecker&)\nWe define CheckMe in every Glyph subclass as follows:\nvoid GlyphSubclass::CheckMe (SpellingCheckerk checker) {\nchecker.CheckGlyphSubclass(this);\n}\nwhere GlyphSubclass would be replaced by the name of the glyph subclass. Note\nthat when CheckMe is called, the specific Glyph subclass is known\u2014after all, we're \nin one of its operations. In turn, the SpellingChecker class interface includes an\noperation like CheckGlyphSubclass for every Glyph subclass10:\nclass SpellingChecker {\npublic:\nSpellingChecker();\nvirtual void CheckCharacter(Character*);\nvirtual void CheckRow(Row*); \nvirtual void Checklmage(Image*);\n// ... and so forth\nList<char*>& GetMisspellings();\nprotected: \nvirtual bool IsMisspelled(const char*);\nprivate: \nchar _currentWord[MAX_WORD_SIZE];\nList<char*> _misspellings;\n};\nSpellingChecker's checking operation for Character glyphs might look some-\nthing like this:\n10 We could use function overloading to give each of these member functions the same name, since their\nparameters already differentiate them. \nWe've \ngiven them different names here to emphasize their differences, \nespecially when they're called.\n", "page": 92, "type": "text", "section": "Page 92"}
{"text": "SECTION 2.8 \nSPELLING CHECKING AND HYPHENATION \n73\nvoid SpellingChecker::CheckCharacter (Character* c) \n{\nconst char ch = c->GetCharCode();\nif (isalpha(ch)) { \n// append alphabetic character to _currentWord\n} else { \n//we hit a nonalphabetic character\nif (IsMisspelled(_currentWord)) { \n// add _currentWord to _misspellings \n_misspellings.Append(strdup(_currentWord));\n}\n_currentWord[0] = ' \\ 0 ' ;\n// reset _currentWord to check next word\n}\n}\nNotice we've defined a special GetCharCode operation on just the Character class.\nThe spelling checker can deal with subclass-specific operations without resorting to\ntype tests or casts\u2014it lets us treat objects specially.\nCheckCharacter accumulates alphabetic characters into the _currentWord buffer.\nWhen it encounters a nonalphabetic character, such as an underscore, it uses the\nIsMisspelled operation to check the spelling of the word in _currentWord.n If\nthe word is misspelled, then CheckCharacter adds the word to the list of misspelled\nwords. Then it must clear out the _currentWord buffer to ready it for the next word.\nWhen the traversal is over, you can retrieve the list of misspelled words with the \nGetMisspellings operation.\nNow we can traverse the glyph structure, calling CheckMe on each glyph with\nthe spelling checker as an argument. This effectively identifies each glyph to the\nSpellingChecker and prompts the checker to do the next increment in the spelling\ncheck.\nSpellingChecker SpellingChecker;\nComposition* c;\n// . . .\nGlyph* g;\nPreorderlterator i(c);\n11 IsMisspelled implements the spelling algorithm, which we won't detail here because we've made\nit independent of Lexi's design. We can support different algorithms by subclassing SpellingChecker;\nalternatively, we can apply the Strategy (315) pattern (as we did for formatting in Section 2.3) to support\ndifferent spelling checking algorithms.\n", "page": 93, "type": "text", "section": "Page 93"}
{"text": "74 \nA CASE STUDY- DESIGNING A DOCUMENT EDITOR\nCHAPTER 2\nfor (i. \nFirst \n(); ! \ni \n. \nIsDone \n() \n; i.NextO) {\ng = i.Currentltem();\ng->CheckMe(spellingChecker);\n}\nThe following interaction diagram illustrates how Character glyphs and the\nSpell ingChecker object work together:\nThis approach works for finding spelling errors, but how does it help us sup-\nport multiple kinds of analysis? It looks like we have to add an operation like\nCheckMe (Spel 1 ingChecker &) to Glyph and its subclasses whenever we add a new\nkind of analysis. That's true if we insist on an independent class for every analysis. But\nthere's no reason why we can't give all analysis classes the same interface. Doing so\nlets us use them polymorphically. That means we can replace analysis-specific oper-\nations like CheckMe (SpellingChecker&) with an analysis-independent operation\nthat takes a more general parameter.\nVisitor Class and Subclasses\nWe'll use the term visitor to refer generally to classes of objects that \"visit\" other\nobjects during a traversal and do something appropriate.12 In this case we can define a\nVisitor class that defines an abstract interface for visiting glyphs in a structure.\n12 \"Visit\" is just a slightly more general term for \"analyze.\" It foreshadows the terminology we use in the\ndesign pattern we're leading to.\n", "page": 94, "type": "text", "section": "Page 94"}
{"text": "SECTION 2.8 \nSPELLING CHECKING AND HYPHENATION \n75\nclass Visitor {\npublic:\nvirtual void VisitCharacter(Character*) { \n}\nvirtual void VisitRow(Row*) { \n} \nvirtual void VisitImage(Image*) { \n}\n// ... and so forth\nConcrete subclasses of Visitor perform different analyses. For example, we\ncould have a SpellingCheckingVisitor subclass for checking spelling, and\na HyphenationVisitor subclass for hyphenation. SpellingCheckingVisitor\nwould be implemented exactly as we implemented Spel \n1 ingChecker above, except\nthe operation names would reflect the more general Visitor interface. For example,\nCheckCharacter would be called VisitCharacter.\nSince CheckMe isn't appropriate for visitors that don't check anything, we'll give it\na more general name: Accept. Its argument must also change to take a Visitor&,\nreflecting the fact that it can accept any visitor. Now adding a new analysis requires\njust defining a new subclass of visitor\u2014we don't have to touch any of the glyph\nclasses. We support all future analyses by adding this one operation to Glyph and its\nsubclasses.\nWe've already seen how spelling checking works. We use a similar approach\nin HyphenationVisitor to accumulate text. But once HyphenationVisitor's\nVisitCharacter operation has assembled an entire word, it works a little differ-\nently. Instead of checking the word for misspelling, it applies a hyphenation algorithm\nto determine the potential hyphenation points in the word, if any. Then at each hyphen-\nation point, it inserts a discretionary glyph into the composition. Discretionary glyphs\nare instances of Discretionary, a subclass of Glyph.\nA discretionary glyph has one of two possible appearances depending on whether or\nnot it is the last character on a line. If it's the last character, then the discretionary looks\nlike a hyphen; if it's not at the end of a line, then the discretionary has no appearance\nwhatsoever. The discretionary checks its parent (a Row object) to see if it is the last child.\nThe discretionary makes this check whenever it's called on to draw itself or calculate\nits boundaries. The formatting strategy treats discretionaries the same as whitespace,\nmaking them candidates for ending a line. The following diagram shows how an\nembedded discretionary can appear.\n", "page": 95, "type": "text", "section": "Page 95"}
{"text": "76 \nA CASE STUDY: DESIGNING A DOCUMENT EDITOR \nCHAPTER 2\nVisitor Pattern\nWhat we've described here is an application of the Visitor (331) pattern. The Visitor\nclass and its subclasses described earlier are the key participants in the pattern. The\nVisitor pattern captures the technique we've used to allow an open-ended number of\nanalyses of glyph structures without having to change the glyph classes themselves.\nAnother nice feature of visitors is that they can be applied not just to composites like\nour glyph structures but to any object structure. That includes sets, lists, even directed-\nacyclic graphs. Furthermore, the classes that a visitor can visit needn't be related to\neach other through a common parent class. That means visitors can work across class \nhierarchies.\nAn important question to ask yourself before applying the Visitor \npattern is, Which \nclass\nhierarchies change most often? The pattern is most suitable when you want to be able\nto do a variety of different things to objects that have a stable class structure. Adding\na new kind of visitor requires no change to that class structure, which is especially\nimportant when the class structure is large. But whenever you add a subclass to the\nstructure, you'll also have to update all your visitor interfaces to include a Visit. . .\noperation for that subclass. In our example that means adding a new Glyph subclass\ncalled Foo will require changing Visitor and all \nits subclasses to include aVisitFoo\noperation. But given our design constraints, we're much more likely to add a new kind\nof analysis to Lexi than a new kind of Glyph. So the Visitor pattern is well-suited to our \nneeds.\n2.9 Summary\nWe've applied eight different patterns to Lexi's design:\n1. Composite (163) to represent the document's physical structure,\n2. Strategy (315) to allow different formatting algorithms,\n", "page": 96, "type": "text", "section": "Page 96"}
{"text": "SECTION 2.9 \nSUMMARY \n77\n3. Decorator (175) for embellishing the user interface,\n4. Abstract Factory (87) \nfor supporting multiple look-and-feel standards,\n5. Bridge (151) to allow multiple windowing platforms,\n6. Command (233) for undoable user operations,\n7. Iterator (257) \nfor accessing and traversing object structures, and\n8. Visitor (331) for allowing an open-ended number of analytical capabilities without\ncomplicating the document structure's implementation.\nNone of these design issues is limited to document editing applications like Lexi.\nIndeed, most nontrivial applications will have occasion to use many of these pat-\nterns, though perhaps to do different things. A financial analysis application might use\nComposite to define investment portfolios made up of subportfolios and accounts of\ndifferent sorts. A compiler might use the Strategy pattern to allow different register\nallocation schemes for different target machines. Applications with a graphical user\ninterface will probably apply at least Decorator and Command just as we have here.\nWhile we've covered several major problems in Lexi's design, there are lots of others\nwe haven't discussed. Then again, this book describes more than just the eight patterns\nwe've used here. So as you study the remaining patterns, think about how you might\nuse each one in Lexi. Or better yet, think about using them in your own designs!\n", "page": 97, "type": "text", "section": "Page 97"}
{"text": "This page intentionally left blank \n", "page": 98, "type": "text", "section": "Page 98"}
{"text": "Design Pattern Catalog\n79\n", "page": 99, "type": "text", "section": "Page 99"}
{"text": "This page intentionally left blank \n", "page": 100, "type": "text", "section": "Page 100"}
{"text": "Chapter 3\nCreational Patterns\nCreational design patterns abstract the instantiation process. They help make a system\nindependent of how its objects are created, composed, and represented. A class cre-\national pattern uses inheritance to vary the class that's instantiated, whereas an object\ncreational pattern will delegate instantiation to another object.\nCreational patterns become important as systems evolve to depend more on object\ncomposition than class inheritance. As that happens, emphasis shifts away from hard-\ncoding a fixed set of behaviors toward defining a smaller set of fundamental behaviors\nthat can be composed into any number of more complex ones. Thus creating objects\nwith particular behaviors requires more than simply instantiating a class.\nThere are two recurring themes in these patterns. First, they all encapsulate knowledge\nabout which concrete classes the system uses. Second, they hide how instances of these\nclasses are created and put together. All the system at large knows about the objects is\ntheir interfaces as defined by abstract classes. Consequently, the creational patterns give\nyou a lot of flexibility in what gets created, who creates it, how it gets created, and when. \nThey let you configure a system with \"product\" objects that vary widely in structure\nand functionality. Configuration can be static (that is, specified at compile-time) or\ndynamic (at run-time).\nSometimes creational patterns are competitors. For example, there are cases when either\nPrototype (117) or Abstract Factory (87) could be used profitably. At other times they\nare complementary: Builder (97) \ncan use one of the other patterns to implement which\ncomponents get built. Prototype (117) can use Singleton (127) \nin its implementation.\nBecause the creational patterns are closely related, we'll study all five of them together\nto highlight their similarities and differences. We'll also use a common example\u2014\nbuilding a maze for a computer game\u2014to illustrate their implementations. The maze\nand the game will vary slightly from pattern to pattern. Sometimes the game will be\nsimply to find your way out of a maze; in that case the player will probably only have\na local view of the maze. Sometimes mazes contain problems to solve and dangers to\n81\n", "page": 101, "type": "text", "section": "Page 101"}
{"text": "82\nCREATIONAL PATTERNS\nCHAPTER 3\novercome, and these games may provide a map of the part of the maze that has been\nexplored.\nWe'll ignore many details of what can be in a maze and whether a maze game has a\nsingle or multiple players. Instead, we'll just focus on how mazes get created. We define \na maze as a set of rooms. A room knows its neighbors; possible neighbors are another\nroom, a wall, or a door to another room.\nThe classes Room, Door, and Wall define the components of the maze used in all our\nexamples. We define only the parts of these classes that are important for creating a\nmaze. We'll ignore players, operations for displaying and wandering around in a maze,\nand other important functionality that isn't relevant to building the maze.\nThe following diagram shows the relationships between these classes:\nEach room has four sides. We use an enumeration Direct! on in C++ implementations\nto specify the north, south, east, and west sides of a room:\nenum Direction {North, South, East, West};\nThe Smalltalk implementations use corresponding symbols to represent these direc-\ntions.\nThe class MapSite is the common abstract class for all the components of a maze.\nTo simplify the example, MapSite defines only one operation, Enter. Its meaning\ndepends on what you're entering. If you enter a room, then your location changes. If\nyou try to enter a door, then one of two things happen: If the door is open, you go into\nthe next room. If the door is closed, then you hurt your nose.\nclass MapSite {\npublic:\nvirtual void Enter()\nEnter provides a simple basis for more sophisticated game operations. For example, if\nyou are in a room and say \"Go East,\" the game can simply determine which MapSite\nis immediately to the east and then call Enter on it. The subclass-specific Enter\n", "page": 102, "type": "text", "section": "Page 102"}
{"text": "CREATIONAL PATTERNS \n83\noperation will figure out whether your location changed or your nose got hurt. In a real\ngame, Enter could take the player object that's moving about as an argument.\nRoom is the concrete subclass of MapSite that defines the key relationships between\ncomponents in the maze. It maintains references to other MapSite objects and stores a \nroom number. The number will identify rooms in the maze.\nclass Room : public MapSite {\npublic:\nRoom(int roomNo);\nMapSite* GetSide(Direction) const;\nvoid SetSide(Direction, MapSite*);\nvirtual void Enter();\nprivate: \nMapSite* _sides[4];\nint _roomNumber;\n};\nThe following classes represent the wall or door that occurs on each side of a room.\nclass Wall : \npublic MapSite {\npublic:\nWallO \n;\nvirtual void Enter();\n};\nclass Door : \npublic MapSite {\npublic:\nDoor(Room* = 0, Room* = 0);\nvirtual void Enter();\nRoom* OtherSideFrom(Room*);\nprivate: \nRoom* _rooml;\nRoom* _room2;\nbool _isOpen;\n};\nWe need to know about more than just the parts of a maze. We'll also define a Maze\nclass to represent a collection of rooms. Maze can also find a particular room given a\nroom number using its RoomNo operation.\n", "page": 103, "type": "text", "section": "Page 103"}
{"text": "84 \nCREATIONAL PATTERNS \nCHAPTER 3\nclass Maze {\npublic:\nMaze();\nvoid AddRoom(Room* \n) ;\nRoom* RoomNo(int) const;\nprivate:\n// . . .\n};\nRoomNo could do a look-up using a linear search, a hash table, or even a simple array.\nBut we won't worry about such details here. Instead, we'll focus on how to specify the \ncomponents of a maze object.\nAnother class we define is MazeGame, which creates the maze. One straightforward\nway to create a maze is with a series of operations that add components to a maze\nand then interconnect them. For \nexample, the following member function will create a\nmaze consisting of two rooms with a door between them:\nMaze* MazeGame::CreateMaze () \n{\nMaze* aMaze = new Maze;\nRoom* rl = new Room(l);\nRoom* r2 = new Room \n(2);\nDoor* theDoor = new Door(rl, r2);\naMaze->AddRoom(rl);\naMaze->AddRoom(r2);\nrl->SetSide(North, new Wall);\nrl->SetSide(East, theDoor);\nrl->SetSide(South, new Wall);\nrl->SetSide(West, new Wall);\nr2->SetSide(North, new Wall);\nr2->SetSide(East, new \nWall); \nr2->SetSide(South, new Wall);\nr2->SetSide(West, theDoor);\nreturn aMaze;\n}\nThis function is pretty complicated, considering that all it does is create a maze with\ntwo rooms. There are obvious ways to make it simpler. For example, the Room con-\nstructor could initialize the sides with walls ahead of time. But that just moves the\ncode somewhere else. The real problem with this member function isn't its size but its\ninflexibility. It hard-codes the maze layout. Changing the layout means changing this\nmember function, either by overriding it\u2014which means reimplementing the whole\nthing\u2014or by changing parts of it\u2014which is error-prone and doesn't promote reuse.\n", "page": 104, "type": "text", "section": "Page 104"}
{"text": "CREATIONAL PATTERNS \n85\nThe creational patterns show how to make this design more flexible, not necessarily\nsmaller. In particular, they will make it easy to change the classes that define the\ncomponents of a maze.\nSuppose you wanted to reuse an existing maze layout for a new game containing (of\nall things) enchanted mazes. The enchanted maze game has new kinds of components,\nlike DoorNeedingSpell, a door that can be locked and opened subsequently only\nwith a spell; and EnchantedRoom, a room that can have unconventional items in it,\nlike magic keys or spells. How can you change CreateMaze easily so that it creates\nmazes with these new classes of \nobjects?\nIn this case, the biggest barrier to change lies in hard-coding the classes that get instan-\ntiated. The creational patterns provide different ways to remove explicit references to\nconcrete classes from code that needs to instantiate them:\n\u2022 If CreateMaze calls virtual functions instead of constructor calls to create the\nrooms, walls, and doors it requires, then you can change the classes that get\ninstantiated by making a subclass of MazeGame and redefining those virtual\nfunctions. This approach is an example of the Factory Method (107) \npattern.\n\u2022 If CreateMaze is passed an object as a parameter to use to create rooms, walls,\nand doors, then you can change the classes of rooms, walls, and doors by passing\na different parameter. This is an example of the Abstract Factory (87) pattern.\n\u2022 IfCreateMazeis passed an object that can \ncreate a new maze in its entirety using\noperations for adding rooms, doors, and walls to the maze it builds, then you can\nuse inheritance to change parts of the maze or the way the maze is built. This is\nan example of the Builder (97) \npattern.\n\u2022 If CreateMaze is parameterized by various prototypical room, door, and wall\nobjects, which it then copies and adds to the maze, then you can change the\nmaze's composition by replacing these prototypical objects with different ones.\nThis is an example of the Prototype (117) pattern.\nThe remaining creational pattern, Singleton (127), can ensure there's only one maze\nper game and that all game objects have ready access to it\u2014without resorting to global\nvariables or functions. Singleton also makes it easy to extend or replace the maze\nwithout touching existing code.\n", "page": 105, "type": "text", "section": "Page 105"}
{"text": "This page intentionally left blank \n", "page": 106, "type": "text", "section": "Page 106"}
{"text": "ABSTRACT FACTORY \n87\nABSTRACT FACTORY\nObject Creational\nIntent\nProvide an interface for creating families of related or dependent objects without\nspecifying their concrete classes.\nAlso Known As\nKit\nMotivation\nConsider a user interface toolkit that supports multiple look-and-feel standards,\nsuch as Motif and Presentation Manager. Different look-and-feels define different\nappearances and behaviors for user interface \"widgets\" like scroll bars, windows,\nand buttons. To be portable across look-and-feel standards, an application should\nnot hard-code its widgets for a particular look and feel. Instantiating look-and-\nf \neel-specific classes of widgets throughout the application makes it hard to change\nthe look and feel later.\nWe can solve this problem by defining an abstract WidgetFactory class that de-\nclares an interface for creating each basic kind of widget. There's also an abstract \nclass for each kind of widget, and concrete subclasses implement widgets for\nspecific look-and-feel \nstandards. WidgetFactory's interface has an operation that \nreturns a new widget object for each abstract widget class. Clients call these oper-\nations to obtain widget instances, but clients aren't aware of the concrete classes\nthey're using. Thus clients stay independent of the prevailing look and feel.\n", "page": 107, "type": "text", "section": "Page 107"}
{"text": "88\nCREATIONAL PATTERNS\nCHAPTER 3\nThere is a concrete subclass of WidgetFactory for each look-and-feel standard.\nEach subclass implements the operations to create the appropriate widget for the\nlook and feel. For example, the CreateScrollBar operation on the MotifWidgetFac-\ntory instantiates and returns a Motif scroll bar, while the corresponding operation\non the PMWidgetFactory returns a scroll bar for Presentation Manager. Clients\ncreate widgets solely through the WidgetFactory interface and have no knowl-\nedge of the classes that implement widgets for a particular look and feel. In other \nwords, clients only have to commit to an interface defined by an abstract class,\nnot a particular concrete class.\nA WidgetFactory \nalso enforces \ndependencies between the concrete \nwidget classes.\nA Motif scroll bar should be used with a Motif button and a Motif text editor, and\nthat constraint is enforced automatically as a consequence of using a MotifWid-\ngetFactory.\nApplicability\nUse the Abstract Factory pattern when\n\u2022 a system should be independent of how its products are created, composed,\nand represented.\n\u2022 a system should be configured with one of multiple families of products.\n\u2022 a family of related product objects is designed to be used together, and you\nneed to enforce this constraint.\n\u2022 you want to provide a class library of products, and you want to reveal just\ntheir interfaces, \nnot their implementations.\nStructure\n", "page": 108, "type": "text", "section": "Page 108"}
{"text": "ABSTRACT FACTORY \n89\nParticipants\n\u2022 AbstractFactory (WidgetFactory)\n- declares an interface for operations that create abstract product objects.\n\u2022 ConcreteFactory (MotifWidgetFactory, PMWidgetFactory)\n- implements the operations to create concrete product objects.\n\u2022 AbstractProduct (Window, ScrollBar)\n- declares an interface \nfor a type of product object.\n\u2022 ConcreteProduct (MotifWindow, MotifScrollBar)\n- defines a product object \nto \nbe \ncreated by the corresponding concrete factory.\n- implements the \nAbstractProduct interface.\n\u2022 Client\n- uses only interfaces declared by AbstractFactory and AbstractProduct\nclasses.\nCollaborations\n\u2022 Normally a single instance of a ConcreteFactory class is created at run-time.\nThis concrete factory creates product objects having a particular implementa-\ntion. To \ncreate different product objects, clients should use a different concrete \nfactory.\n\u2022 AbstractFactory defers creation of product objects to its ConcreteFactory sub-\nclass.\nConsequences\nThe Abstract Factory pattern has the following benefits and liabilities:\n1. It isolates concrete classes. The Abstract Factory pattern helps you control the\nclasses of objects that an application creates. Because a factory encapsulates\nthe responsibility and the process of creating product objects, \nit isolates clients\nfrom implementation classes. Clients manipulate instances through their\nabstract interfaces. Product class names are isolated in the implementation\nof the concrete factory; they do not appear in client code.\n2. It makes exchanging product families easy. The class of a concrete factory appears\nonly once in an application\u2014that is, where it's instantiated. This makes it\neasy to change the concrete factory an application uses. It can use different\nproduct configurations simply by changing the concrete factory. Because an \nabstract factory creates a complete family of products, the whole product\nfamily changes at once. In our user interface example, we can switch from\nMotif widgets to Presentation Manager widgets simply by switching the\ncorresponding factory objects and recreating the interface.\n", "page": 109, "type": "text", "section": "Page 109"}
{"text": "90 \nCREATIONAL PATTERNS \nCHAPTER 3\n3. It promotes consistency among products. When product objects in a family are\ndesigned to work together, it's important that an application use objects from\nonly one family at a time. AbstractFactory makes this easy to enforce.\n4. Supporting new kinds of products is difficult. Extending abstract factories to\nproduce new kinds of Products isn't easy. \nThat's because the AbstractFactory\ninterface fixes the set of products that can be created. Supporting new kinds \nof\nproducts requires extending the factory interface, which involves changing\nthe AbstractFactory class and all of its subclasses. We \ndiscuss one solution to\nthis problem in the Implementation section.\nImplementation\nHere are some useful techniques for implementing the Abstract Factory pattern.\n1. Factories as singletons. An application typically needs only one instance of a\nConcreteFactory per product family. So it's usually best implemented as a\nSingleton (127).\n2. Creating the products. AbstractFactory only declares an interface for creating\nproducts. It's up to ConcreteProduct subclasses to actually create them. The\nmost common way to do this is to define a factory method (see Factory\nMethod (107)) for each product. A concrete factory will specify its products\nby overriding the factory method for each. While this implementation is\nsimple, it requires a new concrete factory subclass for each product family, \neven if the product families differ only slightly.\nIf many product families are possible, the concrete factory can be imple-\nmented using the Prototype (117) pattern. The concrete factory is initialized\nwith a prototypical instance of each product in the family, and it creates a new\nproduct by cloning its prototype. The Prototype-based approach eliminates\nthe need for a new concrete factory class for each new product family.\nHere's a way to implement a Prototype-based factory in Smalltalk. The\nconcrete factory stores the prototypes to be cloned in a dictionary called\npartCatalog. The method make: retrieves the prototype and clones it:\nmake: partName\n(partCatalog at: partName) copy\nThe concrete factory has a method for adding parts to the catalog.\naddPart: partTemplate named: partName\npartCatalog at: partName put: partTemplate\nPrototypes are added to the factory by identifying them with a symbol:\naFactory addPart: aPrototype named: #ACMEWidget\nA variation on the Prototype-based approach is possible in languages that\ntreat classes as first-class objects (Smalltalk \nand Objective \nC, for example). You\n", "page": 110, "type": "text", "section": "Page 110"}
{"text": "ABSTRACT FACTORY \n91\ncan think of a class in these languages as a degenerate factory that creates\nonly one kind of product. You can store classes inside a concrete factory\nthat create the various concrete products in variables, much like prototypes.\nThese classes create new instances on behalf of the concrete factory. You\ndefine a new factory by initializing an instance of a concrete factory with\nclasses of products rather than by subclassing. This approach takes advantage\nof language characteristics, whereas the pure Prototype-based approach is\nlanguage-independent.\nLike the Prototype-based factory in Smalltalk just discussed, the class-based\nversion will have a single instance variable partCatalog, which is a dictio-\nnary whose key is the name of the part. Instead of storing prototypes to be\ncloned, partCatalog stores the classes of the products. The method make:\nnow looks like this:\nmake: partName \n(partCatalog at: partName) new\n3. Defining extensible factories. AbstractFactory usually defines a different op-\neration for each kind of product it can produce. The kinds of products are\nencoded in the operation signatures. Adding a new kind of product requires\nchanging the AbstractFactory interface and all the classes that depend on it.\nA more flexible but less safe design is to add a parameter to operations that\ncreate objects. This parameter specifies the kind of object to be created. It\ncould be a class identifier, an integer, a string, or anything else that identifies\nthe kind of product. In fact with this approach, AbstractFactory only needs\na single \"Make\" operation with a parameter indicating the kind of object\nto create. This is the technique used in the Prototype- and the class-based\nabstract factories discussed earlier.\nThis variation is easier to use in a dynamically typed language like Smalltalk\nthan in a statically typed language like C++. You \ncan use it in C++ only when\nall objects have the same abstract base class or when the product objects can\nbe safely coerced to the correct type by the client that requested them. The\nimplementation section of Factory Method (107) shows how to implement\nsuch parameterized operations in \nC++.\nBut even when no coercion is needed, an inherent problem remains: All\nproducts are returned to the client with the same abstract interface as given\nby the return type. The client will not be able to differentiate or make safe\nassumptions about the class of a product. If clients need to perform subclass-\nspecific operations, they won't be accessible through the abstract interface.\nAlthough the client could perform a downcast (e.g., with dynamic-cast in\nC++), that's not always feasible or safe, because the downcast can fail. This\nis the classic trade-off for a highly flexible and extensible interface.\n", "page": 111, "type": "text", "section": "Page 111"}
{"text": "92 \nCREATIONAL PATTERNS \nCHAPTER 3\nSample Code\nWe'll apply the Abstract Factory pattern to creating the mazes we discussed at the\nbeginning of this chapter.\nClass MazeFac \ntory can create components of mazes. It \nbuilds rooms, walls, and\ndoors between rooms. It might be used by a program that reads plans for mazes\nfrom a file and builds the corresponding maze. Or it might be used by a program \nthat builds mazes randomly. Programs that build mazes take a Maze \nFactory as\nan argument so that the programmer can specify the classes of rooms, walls, and\ndoors to construct.\nclass MazeFactory {\npublic:\nMazeFactory();\nvirtual Maze* MakeMazeO const\n{ return new Maze; }\nvirtual Wall* MakeWall() const\n{ return new \nWall; } \nvirtual Room* MakeRoom(int n) const\n{ return new Room(n); } \nvirtual Door* MakeDoor(Room* rl, Room* r2) const\n{ return new Door(rl, r2); }\nRecall that the member function CreateMaze (page 84) builds a small maze\nconsisting of two rooms with a door between them. CreateMaze hard-codes the\nclass names, making it difficult to create mazes with different components.\nHere's a version of CreateMaze that remedies that shortcoming by taking a\nMazeFactory as a \nparameter:\nMaze* MazeGame::CreateMaze (MazeFactoryk factory) {\nMaze* aMaze = factory.MakeMaze();\nRoom* rl = factory.MakeRoom(1);\nRoom* r2 = factory.MakeRoom(2);\nDoor* aDoor = factory.MakeDoor(rl, r2);\naMaze->AddRoom(rl);\naMaze->AddRoom(r2);\nrl->SetSide(North, factory.MakeWall());\nrl->SetSide(East, aDoor);\nrl->SetSide(South, factory.MakeWall() \n) ;\nrl->SetSide(West, factory.MakeWall());\n", "page": 112, "type": "text", "section": "Page 112"}
{"text": "ABSTRACT FACTORY \n93\nr2->SetSide(North, factory.MakeWall());\nr2->SetSide(East, factory.MakeWall());\nr2->SetSide(South, factory.MakeWall());\nr2->SetSide(West, aDoor);\nreturn aMaze;\n}\nWe can create Enchant edMazeFactory, a factory for enchanted mazes, by sub-\nclassing MazeFactory. EnchantedMazeFactory will override different mem-\nber functions and return different subclasses of Room, Wai 1, etc.\nclass EnchantedMazeFactory : \npublic MazeFactory {\npublic:\nEnchantedMazeFactory();\nvirtual Room* MakeRoom(int n) const \n{ return new EnchantedRoom(n, CastSpell()); }\nvirtual Door* MakeDoor(Room* rl, Room* r2) const\n{ return new DoorNeedingSpell(rl, r2) \n; \n}\nprotected:\nSpell* CastSpell() const;\n};\nNow suppose we want to make a maze game in which a room can have a bomb\nset in it. If the bomb goes off, it will damage the walls (at least). We can make a \nsubclass of Room keep track of whether the room has a bomb in it and whether the\nbomb has gone off. We'll also need a subclass of Wai 1 to keep track of the damage \ndone to the wall. We'll call these classes RoomWithABomb and BombedWall.\nThe last class we'll define is BombedMazeFactory, a subclass of MazeFactory\nthat ensures walls are of class BombedWall and rooms are of class\nRoomWithABomb. BombedMazeFactory \nonly needs to override two functions:\nWall* BombedMazeFactory::MakeWall () \nconst {\nreturn new BombedWall;\n}\nRoom* BombedMazeFactory::MakeRoom(int n) const {\nreturn new RoomWithABomb(n);\n}\nTo build a simple maze that can contain bombs, we simply call Great eMaze with\na BombedMazeFactory.\nMazeGame game;\nBombedMazeFactory factory;\ngame.CreateMaze \n( \nfactory) ,\u2022\n", "page": 113, "type": "text", "section": "Page 113"}
{"text": "94 \nCREATIONAL PATTERNS \nCHAPTER 3\nCreateMaze can take an instance of EnchantedMazeFactory just as well to\nbuild enchanted mazes.\nNotice that the MazeFactory is just a collection of factory methods. This is the\nmost common way to implement the Abstract Factory pattern. Also note that\nMazeFactory is not an abstract class; thus it acts as both the AbstractFactory \nand\nthe ConcreteFactory. This is another common implementation for simple applica-\ntions of the Abstract \nFactory \npattern. Because the MazeFactory is a concrete class\nconsisting entirely of factory methods, it's easy to make a new MazeFactory by\nmaking a subclass and overriding the operations that need to change.\nCreateMaze used the SetSide operation on rooms to specify their sides. If it\ncreates rooms with a BombedMazeFactory, then the maze will be made up of\nRoomWithABomb objects with BombedWall sides. If RoomWithABomb had to\naccess a subclass-specific member of BombedWall, then it would have to cast a\nreference to its walls from Wall* to BombedWall*. This downcasting is safe as\nlong as the argument is in fact a BombedWall, which is guaranteed to be true if\nwalls are built solely with a BombedMazeFactory.\nDynamically typed languages such as Smalltalk don't require downcasting, of\ncourse, but they might produce run-time errors if they encounter a Wall where\nthey expect a subclass of Wa \n11. Using Abstract \nFactory \nto build walls helps prevent\nthese run-time errors by ensuring that only certain kinds of walls can be created.\nLet's consider a Smalltalk version of MazeFactory, one with a single make\noperation that takes the kind of object to make as a parameter. Moreover, the\nconcrete factory stores the classes of the products it creates.\nFirst, we'll write an equivalent of CreateMaze in Smalltalk:\nCreateMaze: aFactory \n| rooml room2 aDoor \n| \nrooml := (aFactory make: #room) number: 1. \nroom2 := (aFactory make: #room) number: 2. \naDoor := (aFactory make: #door) from: rooml to: room2.\nrooml atSide: \nttnorth \nput: (aFactory make: #wall).\nrooml atSide: #east put: aDoor. \nrooml atSide: \nttsouth \nput: (aFactory make: #wall).\nrooml atSide: \nttwest \nput: (aFactory make: #wall). \nroom2 atSide: #north put: (aFactory make: #wall).\nroom2 atSide: #east put: (aFactory make: #wall). \nroom2 atSide: \nttsouth \nput: (aFactory make: #wall).\nroom2 atSide: \nftwest \nput: aDoor. \n~ Maze new addRoom: rooml; addRoom: room2; yourself\nAs we discussed in the Implementation section, MazeFactory needs only a single\ninstance variable partCatalog to provide a dictionary whose key is the class \nof\nthe component. Also recall how we implemented the make: method:\nmake: partName\n(partCatalog at: partName) new\n", "page": 114, "type": "text", "section": "Page 114"}
{"text": "ABSTRACT FACTORY \n95\nNow we can create aMazeFactory and use it to implement createMaze. We'll\ncreate the factory using a method createMazeFactory of class MazeGame.\ncreateMazeFactory \n\" (MazeFactory new \naddPart: Wall named: #wall;\naddPart: Room named: #room;\naddPart: Door named: #door;\nyourself)\nA BombedMazeFactory or EnchantedMazeFactory is created by associating\ndifferent classes with the keys. For example, an EnchantedMazeFactory could\nbe created like this:\ncreateMazeFactory \n(MazeFactory new \naddPart: Wall named: \nttwall; \naddPart: EnchantedRoom named: #room;\naddPart: DoorNeedingSpell named: #door;\nyourself)\nKnown Uses\nInterviews uses the \"Kit\" suffix [Lin92] to denote AbstractFactory \nclasses. It de-\nfines WidgetKit and DialogKit abstract factories for generating look-and-feel-\nspecific user interface objects. Interviews also includes a LayoutKit that generates\ndifferent composition objects depending on the layout desired. For example, a\nlayout that is conceptually horizontal may require different composition objects\ndepending on the document's orientation (portrait or landscape).\nET++ [WGM88] uses the Abstract Factory pattern to achieve portability across\ndifferent window systems (X Windows and SunView, for example). The Win-\ndowSystem abstract \nbase class defines the interface for creating objects \nthat repre-\nsent window system resources (MakeWindow, MakeFont, MakeColor, for exam-\nple). Concrete subclasses implement the interfaces for a specific window system.\nAt run-time, ET++ creates an instance of a concrete WindowSystem subclass that\ncreates concrete system resource objects.\nRelated Patterns\nAbstractFactory classes are often implemented with factory methods (Factory\nMethod (107)), but they can also be implemented using Prototype (117).\nA concrete factory is often a singleton (Singleton (127)).\n", "page": 115, "type": "text", "section": "Page 115"}
{"text": "This page intentionally left blank \n", "page": 116, "type": "text", "section": "Page 116"}
{"text": "BUILDER \n97\nBUILDER\nObject Creational\nIntent\nSeparate the construction of a complex object from its representation so that the\nsame construction process can create different representations.\nMotivation\nA reader for the RTF \n(Rich Text Format) \ndocument exchange format should be able\nto convert RTF \nto many text formats. The reader might convert RTF documents\ninto plain ASCII text or into a text widget that can be edited interactively. The\nproblem, however, is that the number of possible conversions is open-ended. So\nit should be easy to add a new conversion without modifying the reader.\nA solution is to configure the RTFReader class with a TextConverter object that\nconverts RTF to another textual representation. As the RTFReader parses the \nRTF\ndocument, it uses the TextConverter to perform the conversion. Whenever the\nRTFReader recognizes an RTF \ntoken (either plain text or an RTF \ncontrol word), it\nissues a request to the TextConverter to convert the token. TextConverter \nobjects\nare responsible both for performing the data conversion and for representing the\ntoken in a particular format.\nSubclasses of TextConverter specialize in different conversions and formats. For\nexample, an ASCIIConverter ignores requests to convert anything except plain \ntext. A TeXConverter, on the other hand, will implement operations for all requests\nin order to produce a Tp^X representation that captures all the stylistic information\nin the text. A TextWidgetConverter will produce a complex user interface \nobject\nthat lets the user see and edit the text.\n", "page": 117, "type": "text", "section": "Page 117"}
{"text": "98\nCREATIONAL PATTERNS\nCHAPTER 3\nEach kind of converter class takes the mechanism for creating and assembling a\ncomplex object and puts it behind an abstract interface. \nThe converter is separate\nfrom the reader, which is responsible for parsing an RTF \ndocument.\nThe Builder pattern captures all these relationships. Each converter class is called\na builder in the pattern, and the reader is called the director. Applied to this\nexample, the Builder pattern separates the algorithm for interpreting a textual\nformat (that is, the parser for RTF \ndocuments) from how a converted format gets\ncreated and represented. This lets us reuse the RTFReader's parsing algorithm\nto create different text representations from RTF documents\u2014just configure the\nRTFReader with different subclasses of \nTextConverter.\nApplicability\nUse the Builder pattern when\n\u2022 the algorithm for creating a complex object should be independent of the\nparts that make up the object and how they're assembled.\n\u2022 the construction process must allow different representations for the object\nthat's constructed.\nStructure\nParticipants\n\u2022 Builder (TextConverter)\n- specifies an abstract interface for creating parts of a Product object.\n", "page": 118, "type": "text", "section": "Page 118"}
{"text": "BUILDER\n99\n\u2022 ConcreteBuilder (ASCIIConverter, TeXConverter, TextWidgetConverter)\n- constructs and assembles parts of the \nproduct by implementing the \nBuilder\ninterface.\n- defines and keeps track of the representation it creates.\n- provides an interface for retrieving the product (e.g., GetASCIIText, Get-\nText \nWidget).\n\u2022 Director (RTFReader)\n- constructs an object using the Builder \ninterface.\n\u2022 Product (ASCIIText, TeXText, TextWidget)\n- represents the complex object under construction. ConcreteBuilder builds\nthe product's internal representation and defines the process by which it's\nassembled.\n- includes classes that define the constituent parts, including interfaces for\nassembling the parts into the final result.\nCollaborations\n\u2022 The client creates the Director object and configures it with the desired Builder\nobject.\n\u2022\nDirector notifies the builder whenever a part of the product should be built.\n\u2022\nBuilder handles requests from the director and adds parts to the product.\n\u2022\nThe \nclient retrieves the product from the builder.\nThe following \ninteraction diagram illustrates how Builder and Director cooperate\nwith a client.\n", "page": 119, "type": "text", "section": "Page 119"}
{"text": "100 \nCREATIONAL PATTERNS \nCHAPTER 3\nConsequences\nHere are key consequences of the Builder pattern:\n1. It lets you vary a product's internal representation. The Builder object provides\nthe director with an abstract interface for constructing the product. The in-\nterface lets the builder hide the representation and internal structure of the\nproduct. It also hides how the product gets assembled. Because the product\nis constructed through an abstract interface, all you have to do to change the\nproduct's internal representation is define a new kind of builder.\n2. It isolates code for construction and representation. The Builder pattern improves\nmodularity by encapsulating the way a complex object is constructed and\nrepresented. Clients needn't know anything about the classes that define the\nproduct's internal structure; such classes don't appear in Builder's interface.\nEach ConcreteBuilder contains all the code to create and assemble a partic-\nular kind of product. The code is written once; then different Directors can\nreuse it to build Product variants from the same set of parts. In the earlier\nRTF example, we could define a reader for a format other than RTF, say,\nan SGMLReader, and use the same TextConverters to generate ASCIIText,\nTeXText, and TextWidget renditions of SGML documents.\n3. It gives you finer control over the construction process. Unlike creational pat-\nterns that construct products in one shot, the Builder pattern constructs the\nproduct step by step under the director's control. Only when the product\nis finished does the director retrieve it from the builder. Hence the Builder\ninterface reflects the process of constructing the product more than other cre-\national patterns. This gives you finer control over the construction process\nand consequently the internal structure of the resulting product.\nImplementation\nTypically there's an abstract Builder class that defines an operation for each com-\nponent that a director may ask it to create. The operations do nothing by default.\nA ConcreteBuilder class overrides operations for components it's interested in\ncreating.\nHere are other implementation issues to consider:\n1. Assembly and construction interface. Builders construct their products in step-\nby-step fashion. Therefore the Builder class interface must be general enough\nto allow the construction of products for all kinds of concrete builders.\nA key design issue concerns the model for the construction and assembly\nprocess. A model where the results of construction requests are simply ap-\npended to the product is usually sufficient. In the RTF \nexample, the builder\nconverts and appends the next token to the text it has converted so \nfar.\nBut sometimes you might need access to parts of the product constructed\nearlier. In the Maze \nexample we present in the Sample Code, the \nMazeBuilder\n", "page": 120, "type": "text", "section": "Page 120"}
{"text": "BUILDER \n101\ninterface lets you add a door between existing rooms. Tree structures such\nas parse trees that are built bottom-up are another example. In that case,\nthe builder would return child nodes to the director, which then would pass\nthem back to the builder to build the parent nodes.\n2. Why no abstract class \nfor products? In the common case, the products produced\nby the concrete builders differ so greatly in their representation that there\nis little to gain from giving different products a common parent class. In\nthe RTF example, the ASCIIText and the TextWidget objects are unlikely to\nhave a common interface, nor do they need one. Because the client usually\nconfigures the director with the proper concrete builder, the client is in a\nposition to know which concrete subclass of Builder is in use and can handle\nits products accordingly.\n3. Empty methods as default in Builder. In C++, the build methods are intention-\nally not declared pure virtual member functions. They're defined as empty\nmethods instead, letting clients override only the operations they're inter-\nested in.\nSample Code\nWe'll define a variant of the CreateMaze member function (page 84) \nthat takes a\nbuilder of class MazeBuilder as an argument.\nThe MazeBuilder class defines the following interface for building mazes:\nclass MazeBuilder {\npublic:\nvirtual void BuildMazeO { \n} \nvirtual void BuildRoom(int room) { \n} \nvirtual void BuildDoor(int roomFrom, \nint roomTo) { \n}\nvirtual Maze* GetMaze() { \nreturn 0; }\nprotected:\nMazeBuilder();\n};\nThis interface can create three things: (1) the maze, (2) rooms with a particular\nroom number, and (3) doors between numbered rooms. The GetMaze operation\nreturns the maze to the client. Subclasses of MazeBuilder will override this\noperation to return the maze that they build.\nAll the \nmaze-building operations of Ma z \ne \nBu i 1 de \nr do nothing by default. They're\nnot declared pure virtual to let derived classes override only those methods in\nwhich they're interested.\nGiven the MazeBuilder interface, we can change the CreateMaze member\nfunction to take this builder as a parameter.\n", "page": 121, "type": "text", "section": "Page 121"}
{"text": "102 \nCREATIONAL PATTERNS \nCHAPTER 3\nMaze* MazeGame::CreateMaze (MazeBuilder& builder) {\nbuilder.BuildMaze();\nbuilder.BuildRoom(1);\nbuiIder.BuiIdRoom(2);\nbuilder.BuildDoor(1, 2);\nreturn builder.GetMaze();\n}\nCompare this version of CreateMaze with the original. Notice how the builder\nhides the internal representation of the Maze\u2014that is, the classes that define \nrooms, doors, and walls\u2014and how these parts are assembled to complete the\nfinal maze. Someone might guess that there are classes for representing rooms\nand doors, but there is no hint of one for walls. This makes it easier to change the\nway a maze is represented, since none of the clients of Maze \nBui Ider has to be\nchanged.\nLike the other creational patterns, the Builder pattern encapsulates how ob-\njects get created, in this case through the interface defined by MazeBuilder.\nThat means we can reuse MazeBuilder to build different kinds of mazes. The\nCreateComplexMaze operation gives an example:\nMaze* MazeGame::CreateComplexMaze (MazeBuilder& builder) {\nbuiIder.BuiIdRoom(1);\n// . . .\nbuiIder.BuiIdRoom(1001);\nreturn builder.GetMaze();\n}\nNote that MazeBuilder does not create mazes itself; its main purpose is just to\ndefine an interface for creating mazes. It \ndefines empty implementations primarily\nfor convenience. Subclasses of MazeBuilder do the actual work.\nThe subclass StandardMazeBuilder is an implementation that builds simple\nmazes. It keeps track of the maze it's building in the variable _currentMaze.\nclass StandardMazeBuilder : \npublic MazeBuilder {\npublic:\nStandardMazeBuilder();\nvirtual void BuildMaze();\nvirtual void BuildRoom(int);\nvirtual void BuildDoor(int, int);\nvirtual Maze* GetMaze (),-\nprivate:\nDirection CommonWall(Room*, Room*);\nMaze* _currentMaze;\n};\n", "page": 122, "type": "text", "section": "Page 122"}
{"text": "BUILDER \n103\nCommonWall is a utility operation that determines the direction of the common\nwall between two rooms.\nThe StandardMazeBuilder constructor simply initializes _currentMaze.\nStandardMazeBuilder::StandardMazeBuilder () {\n_currentMaze = 0;\n}\nBuildMaze instantiates a Maze that other operations will assemble and eventu-\nally return to the client (with GetMaze).\nvoid StandardMazeBuilder::BuildMaze () \n{\n_currentMaze = new Maze;\n}\nMaze* StandardMazeBuilder::GetMaze () \n{\nreturn _currentMaze;\n}\nThe BuildRoom operation creates a room and builds the walls around it:\nvoid StandardMazeBuilder::BuildRoom (int n) {\nif (!_currentMaze->RoomNo(n)) {\nRoom* room - new Room(n);\n_currentMaze->AddRoom(room);\nroom->SetSide(North, new Wall);\nroom->SetSide(South, new Wall);\nroom->SetSide(East, new Wall);\nroom->SetSide(West, new Wall);\n}\n}\nTo build a door between two rooms, StandardMazeBuilder looks up both\nrooms in the maze and finds their adjoining wall:\nvoid StandardMazeBuilder:rBuildDoor (int nl, int n2) {\nRoom* rl = _currentMaze->RoomNo(nl);\nRoom* r2 = _currentMaze->RoomNo(n2);\nDoor* d = new Door(rl, r2);\nrl->SetSide(CommonWall(rl,r2), d);\nr2->SetSide(CommonWall(r2,rl), d);\n}\nClients can \nnow use CreateMaze in conjunction with StandardMazeBuilder\nto create a maze:\n", "page": 123, "type": "text", "section": "Page 123"}
{"text": "104 \nCREATIONAL PATTERNS \nCHAPTER 3\nMaze* maze;\nMazeGame game;\nStandardMazeBuilder builder;\ngame.CreateMaze(builder);\nmaze = builder.GetMaze();\nWe could have put all the StandardMazeBuilder operations in Maze and let\neach Maze build itself. But making Maze smaller makes it easier to understand\nand modify, and StandardMazeBuilder is easy to separate from Maze. Most\nimportantly, separating the two lets you have a variety of MazeBuilders, each\nusing different classes for rooms, walls, and doors.\nA more exotic MazeBuilder is CountingMazeBuilder. This builder doesn't\ncreate a maze at all; it just counts the different kinds of components that would\nhave been created.\nclass CountingMazeBuilder : \npublic MazeBuilder {\npublic:\nCountingMazeBuilder();\nvirtual void BuildMaze(); \nvirtual void BuildRoom(int); \nvirtual void BuildDoor(int, int);\nvirtual void AddWall(int, Direction);\nvoid GetCounts(int&, int&) const;\nprivate:\nint _doors;\nint _rooms;\n};\nThe constructor initializes the counters, and the overridden MazeBuilder oper-\nations increment them accordingly.\nCountingMazeBuilder::CountingMazeBuilder () \n{\n_rooms = _doors = 0;\n}\nvoid CountingMazeBuilder::BuildRoom (int) \n{\n_rooms++;\n}\nvoid CountingMazeBuilder::BuildDoor (int, \nint) \n{\n_doors++;\n}\nvoid CountingMazeBuilder::GetCounts (\nint& rooms, int& doors\n) const { \nrooms = _rooms;\ndoors = _doors;\n}\n", "page": 124, "type": "text", "section": "Page 124"}
{"text": "BUILDER \n105\nHere's how a client might use a Count ingMazeBuilder:\nint rooms, doors;\nMazeGame game;\nCountingMazeBuilder builder;\ngame.CreateMaze(builder);\nbuilder.GetCounts(rooms, doors);\ncout \n\u00ab \"The \nmaze has \" \n\u00ab rooms \n\u00ab \" rooms and \n\" \n\u00ab doors \n\u00ab \" doors\" \n\u00ab endl;\nKnown Uses\nThe RTF converter application is from ET++ [WGM88]. Its text building block\nuses a builder to process text stored in the RTF format.\nBuilder is a common pattern in Smalltalk-80 [Par90]:\n\u2022 The Parser class in the compiler subsystem is a Director that takes a Pro-\ngramNodeBuilder object as an argument. A Parser object notifies its Pro-\ngramNodeBuilder object each time it recognizes a syntactic construct. When\nthe parser is done, it asks the builder for the parse tree it built and returns it\nto the client.\n\u2022 ClassBuilder is a builder that Classes use to create subclasses for themselves.\nIn this case a Class is both the Director and the Product.\n\u2022 ByteCodeStream is a builder that creates a compiled method as a byte ar-\nray. ByteCodeStream is a nonstandard use of the Builder pattern, because \nthe complex object it builds is encoded as a byte array, not as a normal\nSmalltalk object. But the interface to ByteCodeStream is typical of a builder,\nand it would be easy to replace ByteCodeStream with a different class that\nrepresented programs as a composite object.\nThe Service Configurator framework from the Adaptive Communications Envi-\nronment uses a builder to construct network service components that are linked\ninto a server at run-time [SS94]. The components are described with a config-\nuration language that's parsed by an LALR(l) parser. The semantic actions of\nthe parser perform operations on the builder that add information to the service\ncomponent. In this case, the parser is the Director.\nRelated Patterns\nAbstract Factory (87) is similar to Builder in that it too may construct complex\nobjects. The primary difference is that the Builder pattern focuses on constructing a\ncomplex object step by step. Abstract Factory's emphasis is on families of product\nobjects (either simple or complex). Builder returns the product as a final step,\n", "page": 125, "type": "text", "section": "Page 125"}
{"text": "106 \nCREATIONAL PATTERNS \nCHAPTER 3\nbut as far as the Abstract Factory pattern is concerned, the product gets returned\nimmediately.\nA Composite (163) \nis what the builder often builds.\n", "page": 126, "type": "text", "section": "Page 126"}
{"text": "FACTORY METHOD \n107\nFACTORY METHOD\nClass Creational\nIntent\nDefine an interface for creating an object, but let subclasses decide which class to\ninstantiate. Factory Method lets a class defer instantiation to subclasses.\nAlso Known As\nVirtual Constructor\nMotivation\nFrameworks use abstract classes to define and maintain relationships between\nobjects. A framework is often responsible for creating these objects as well.\nConsider a framework for applications that can present multiple documents to\nthe user. Two key abstractions in this framework are the classes Application and\nDocument. Both classes are abstract, and clients have to subclass them to realize\ntheir application-specific implementations. To create a drawing application, for\nexample, we define the classes DrawingApplication and DrawingDocument. The\nApplication class is responsible for managing Documents and will create them as\nrequired\u2014when the user selects Open or New from a menu, for example.\nBecause the particular Document subclass to instantiate is application-specific, the\nApplication class can't predict the subclass of Document to instantiate\u2014the Ap-\nplication class only knows when a new document should be created, not what kind \nof Document to create. This creates a dilemma: The framework must instantiate\nclasses, but it only knows about abstract classes, which it cannot instantiate.\nThe Factory Method pattern offers a solution. It encapsulates the knowledge\nof which Document subclass to create and moves this knowledge out of the\nframework.\n", "page": 127, "type": "text", "section": "Page 127"}
{"text": "108\nCREATIONAL PATTERNS\nCHAPTER 3\nApplication subclasses redefine an abstract CreateDocument operation on Appli-\ncation to return the appropriate Document subclass. Once an Application sub-\nclass is instantiated, it can then instantiate application-specific Documents with-\nout knowing their class. We call CreateDocument a factory method because it's\nresponsible for \"manufacturing\" an object.\nApplicability\nUse the Factory Method pattern when\n\u2022 a class can't anticipate the class of objects it must create.\n\u2022 a class wants its subclasses to specify the objects it creates.\n\u2022 classes delegate responsibility to one of several helper subclasses, and you\nwant to localize the knowledge of which helper subclass is the delegate.\nStructure\nParticipants\nProduct (Document)\n- defines the interface of objects the factory method creates.\nConcreteProduct (MyDocument)\n- implements the \nProduct interface.\nCreator (Application)\n- declares the factory method, which returns an object of type Product. Cre-\nator may also define a default implementation of the factory method that\nreturns a default ConcreteProduct object.\n- may call the factory method to create a Product object.\n", "page": 128, "type": "text", "section": "Page 128"}
{"text": "FACTORY METHOD \n109\n\u2022 ConcreteCreator (MyApplication)\n- overrides the factory method to return an instance of a ConcreteProduct.\nCollaborations\n\u2022 Creator relies on its subclasses to define the factory method so that it returns\nan instance of the appropriate ConcreteProduct.\nConsequences\nFactory methods eliminate the need to bind application-specific classes into your\ncode. The code only deals with the Product interface; therefore it can work with\nany user-defined ConcreteProduct classes.\nA potential disadvantage of factory methods is that clients might have to subclass\nthe Creator class just to create a particular ConcreteProduct object. Subclassing is\nfine when the client has to subclass the Creator class anyway, but otherwise the\nclient now must deal with another point of evolution.\nHere are two additional consequences of the Factory Method pattern:\n1. Provides hooks for subclasses. Creating objects inside a class with a factory\nmethod is always more flexible than creating an object directly. Factory\nMethod gives subclasses a hook for providing an extended version of an \nobject.\nIn the Document example, the Document class could define a factory method\ncalled CreateFileDialog that creates a default file dialog object for opening an\nexisting document. A Document subclass can define an application-specific\nfile dialog by overriding this factory method. In this case the factory method\nis not abstract but provides a reasonable default implementation.\n2. Connects parallel class hierarchies. In the examples we've considered so far, the\nfactory method is only called by Creators. But this doesn't have to be the\ncase; clients can find factory methods useful, especially in the case of parallel\nclass hierarchies.\nParallel class hierarchies result when a class delegates some of its responsibil-\nities to a separate class. Consider graphical figures that can be manipulated\ninteractively; that is, they can be stretched, moved, or rotated using the\nmouse. Implementing such interactions isn't always easy. It often requires\nstoring and updating information that records the state of the manipulation\nat a given time. This state is needed only during manipulation; therefore\nit needn't be kept in the figure object. Moreover, different figures behave\ndifferently when the user manipulates them. For example, stretching a line\nfigure might have the effect of moving an endpoint, whereas stretching a text\nfigure may change its line spacing.\nWith these constraints, it's better to use a separate Manipulator object that\nimplements the interaction and keeps track \nof any manipulation-specific \nstate\n", "page": 129, "type": "text", "section": "Page 129"}
{"text": "110\nCREATIONAL PATTERNS\nCHAPTER 3\nthat's needed. Different figures will use different Manipulator subclasses to\nhandle particular interactions. The resulting Manipulator class hierarchy\nparallels (at least partially) the Figure class hierarchy:\nThe Figure class provides a CreateManipulator factory method that lets\nclients create a Figure's corresponding Manipulator. Figure subclasses over-\nride this method to return an instance of the Manipulator subclass that's right\nfor them. Alternatively, the Figure class may implement CreateManipulator \nto return a default Manipulator instance, and Figure subclasses may simply\ninherit that default. The Figure classes that do so need no corresponding\nManipulator subclass\u2014hence the hierarchies are only partially parallel.\nNotice how the factory method defines the connection between the two class\nhierarchies. It localizes knowledge of which classes belong together.\nImplementation\nConsider the following issues when applying the Factory Method pattern:\n1. Two major varieties. The two main variations of the Factory \nMethod pattern are\n(1) the case when the Creator class is an abstract class and does not provide\nan implementation for the factory method it declares, and (2) \nthe case when\nthe Creator is a concrete class and provides a default implementation for\nthe factory method. It's also possible to have an abstract class that defines a\ndefault implementation, but this is less common.\nThe first case requires subclasses to define an implementation,because there's\nno reasonable default. It gets around the dilemma of having to instantiate\nunforeseeable classes. In the second case, the concrete Creator uses the fac-\ntory method primarily for flexibility. It's following a rule that says, \"Create\nobjects in a separate operation so that subclasses can override the way they're\ncreated.\" This rule ensures that designers of subclasses can change the class\nof objects their parent class instantiates if necessary.\n2. Parameterized factory methods. Another variation on the pattern lets the fac-\ntory method create multiple kinds of products. The factory method takes a\n", "page": 130, "type": "text", "section": "Page 130"}
{"text": "FACTORY METHOD \n111\nparameter that identifies the kind of object to create. All objects the factory\nmethod creates will share the Product interface. In the Document example,\nApplication might support different kinds of Documents. You pass Create-\nDocument an extra parameter to specify the kind of document to create.\nThe Unidraw graphical editing framework [VL90] uses this approach for\nreconstructing objects saved on disk. Unidraw defines aCreator class with a\nfactory method Create that takes a class identifier as an argument. The class\nidentifier specifies the class to instantiate. When Unidraw saves an object to\ndisk, it writes out the class identifier first and then its instance variables.\nWhen it reconstructs the object from disk, it reads the class identifier first.\nOnce the class identifier is read, the framework calls Create, passing the\nidentifier as the parameter. Create looks up the constructor for the corre-\nsponding class and uses it to instantiate the object. Last, Create calls the \nobject's Read operation, which reads the remaining information on the disk\nand initializes the object's instance variables.\nA parameterized factory method has the following general form, where\nMyProduct and YourProduct are subclasses of Product:\nclass Creator {\npublic:\nvirtual Product* Create(Productld);\n};\nProduct* Creator::Create (Productld id) \n{ \nif (id == MINE) return new MyProduct;\nif (id == YOURS) return new YourProduct;\n// repeat for remaining products...\nreturn 0;\n}\nOverriding a parameterized factory method lets you easily and selectively\nextend or change the products that a Creator produces. You can introduce\nnew identifiers for new kinds of products, or you can associate existing\nidentifiers with different products.\nFor example, a subclass MyCreator could swap MyProduct and YourProd-\nuct and support a new TheirProduct subclass:\nProduct* MyCreator::Create (Productld id) \n{\nif (id == YOURS) return new MyProduct;\nif (id == MINE) \nreturn new YourProduct;\n// N.B.: switched YOURS and MINE\nif (id == THEIRS) return new TheirProduct;\nreturn Creator::Create(id); // called if all others fail\n}\nNotice that the last thing this operation does is call Create on the parent\nclass. That's because MyCreator : : \nCreate handles only YOURS, MINE, and\n", "page": 131, "type": "text", "section": "Page 131"}
{"text": "112 \nCREATIONAL PATTERNS \nCHAPTER 3\nTHEIRS differently than the parent class. It isn't interested in other classes.\nHence MyCreator extends the kinds of products created, and it defers re-\nsponsibility for creating all but a few products to its parent.\n3. Language-specific variants and issues. Different languages lend themselves to\nother interesting variations and caveats.\nSmalltalk programs often use a method that returns the class of the object\nto be instantiated. A Creator factory method can use this value to create\na product, and a ConcreteCreator may store or even compute this value.\nThe result is an even later binding for the type of ConcreteProduct to be\ninstantiated.\nA Smalltalk \nversion of the Document example \ncan define a documentClass\nmethod on Application. The documentClass method returns the\nproper Document class for instantiating documents. The implementation of\ndocumentClass in MyApplication returns the MyDocument class. Thus\nin class Application we have\nclientMethod\ndocument := self documentClass \nnew.\ndocumentClass \nself subclassResponsibility\nIn class MyApplication we have\ndocumentClass\n~ MyDocument\nwhich returns the class MyDocument to be instantiated to Application.\nAn even more flexible approach akin to parameterized factory methods is to \nstore the class to be created as a class variable of Application. That way\nyou don't have to subclass Application to vary the product.\nFactory methods in C++ are always virtual functions and are often pure \nvir-\ntual. Just be careful not to call factory methods in the Creator's constructor\u2014\nthe factory method in the ConcreteCreator \nwon't be available yet.\nYou can avoid this by being careful to access products solely through acces-\nsor operations that create the product on demand. Instead of creating the\nconcrete product in the constructor, the constructor merely initializes it to 0.\nThe accessor returns the product. But first it checks to make sure the product\nexists, and if it doesn't, the accessor creates it. This technique is sometimes\ncalled lazy initialization. The following code shows a typical implementa-\ntion:\n", "page": 132, "type": "text", "section": "Page 132"}
{"text": "FACTORY METHOD \n113\nclass Creator {\npublic:\nProduct* GetProduct();\nprotected:\nvirtual Product* CreateProduct();\nprivate:\nProduct* _product;\n};\nProduct* Creator::GetProduct () \n{\nif (_product = = 0 ) {\n_product = CreateProduct();\n}\nreturn _product;\n}\n4. Using templates to avoid subclassing. As we've mentioned, another potential\nproblem with factory methods is that they might force you to subclass just\nto create the appropriate Product objects. Another way to get around this in\nC++ is to provide a template subclass of Creator that's parameterized by the\nProduct class:\nclass Creator {\npublic:\nvirtual Product* CreateProduct() = 0 \n;\n};\ntemplate <class TheProduct> \nclass StandardCreator: public Creator {\npublic:\nvirtual Product* CreateProduct();\n};\ntemplate <class TheProduct>\nProduct* StandardCreator<TheProduct>::CreateProduct () \n{\nreturn new TheProduct;\n}\nWith this template, the client supplies just the product class\u2014no subclassing\nof Creator is required.\nclass MyProduct : \npublic Product {\npublic:\nMyProduct();\n// . . .\n};\nStandardCreator<MyProduct> myCreator;\n5. Naming conventions. \nIt's good practice to use naming conventions that make\nit clear you're using factory methods. For example, the MacApp Macintosh\napplication framework [App89] always declares the abstract operation that\ndefines the factory method as Class* DoMakeClass ( ) , where Class is\nthe Product class.\n", "page": 133, "type": "text", "section": "Page 133"}
{"text": "114 \nCREATIONAL PATTERNS \nCHAPTER 3\nSample Code\nThe function CreateMaze (page 84) builds and returns a maze. One problem\nwith this function is that it hard-codes the classes of maze, rooms, doors, and\nwalls. We'll introduce factory methods to let subclasses choose these components.\nFirst we'll define factory methods in Maz eGame for creating the maze, room, wall,\nand door objects:\nclass MazeGame {\npublic:\nMaze* CreateMaze();\n// factory methods:\nvirtual Maze* MakeMaze() const\n{ return new \nMaze; } \nvirtual Room* MakeRoom(int n) const\n{ return new Room(n); }\nvirtual Wall* MakeWall() const\n{ return new \nWall; } \nvirtual Door* MakeDoor(Room* rl, Room* r2) const\n{ return new Door(rl, r2); }\nEach factory method returns a maze component of a given type. MazeGame pro-\nvides default implementations that return the simplest kinds of maze, rooms,\nwalls, and doors.\nNow we can rewrite CreateMaze to use these factory methods:\nMaze* MazeGame::CreateMaze () \n{\nMaze* aMaze = MakeMaze (),-\nRoom* rl = MakeRoom \n(1) ,\n-\nRoom* r2 = MakeRoom(2);\nDoor* theDoor = MakeDoor(rl, r2);\naMaze->AddRoom(rl);\naMaze->AddRoom(r2);\nrl->SetSide(North, MakeWall());\nrl->SetSide(East, theDoor); \nrl->SetSide(South, MakeWall());\nrl->SetSide(West, MakeWall());\nr2->SetSide(North, MakeWall());\nr2->SetSide(East, MakeWall());\nr2->SetSide(South, MakeWall());\nr2->SetSide(West, theDoor);\n", "page": 134, "type": "text", "section": "Page 134"}
{"text": "FACTORY METHOD \n115\nreturn aMaze;\n}\nDifferent games can subclass Ma z eGame to specialize parts of the maze. Ma z \neGame\nsubclasses can redefine some or all of the factory methods to specify variations\nin products. For example, a BombedMazeGame can redefine the Room and Wall\nproducts to return the bombed varieties:\nclass BombedMazeGame : \npublic MazeGame {\npublic:\nBombedMazeGame();\nvirtual Wall* MakeWall() const\n{ return new \nBombedWall; \n}\nvirtual Room* MakeRoom(int n) const\n{ return new \nRoomWithABomb(n); }\n};\nAn Enchant edMaz eGame variant might be defined like this:\nclass EnchantedMazeGame : \npublic MazeGame {\npublic:\nEnchantedMazeGame();\nvirtual Room* MakeRoom(int n) const\n{ return new EnchantedRoom(n, CastSpell()); }\nvirtual Door* MakeDoor(Room* rl, Room* r2) const\n{ return new \nDoorNeedingSpell(rl, r2); } \nprotected:\nSpell* CastSpell() const;\n};\nKnown Uses\nFactory methods pervade toolkits and frameworks. The preceding document ex-\nample is a typical use in MacApp and ET++ [WGM88]. The manipulator example\nis from Unidraw.\nClass View in the Smalltalk-80 Model/View/Controller framework has a method\ndefaultController that creates a controller, and this might appear to be a factory\nmethod [Par90]. But subclasses of View specify the class of their default controller\nby defining defaultControllerClass, which returns the class from which default-\nController creates instances. So defaultControllerClass is the real factory method,\ntKat is, the method that subclasses should override.\nA more esoteric example in Smalltalk-80 \nis the factory method parserClass defined\nby Behavior (a superclass of all objects representing classes). This enables a class\n", "page": 135, "type": "text", "section": "Page 135"}
{"text": "116 \nCREATIONAL PATTERNS \nCHAPTER 3\nto use a customized parser for its source code. For example, a client can define\na class SQLParser to analyze the source code of a class with embedded SQL\nstatements. The Behavior class implements parserClass to return the standard\nSmalltalk Parser class. A class that includes embedded SQL \nstatements overrides\nthis method (as a class method) and returns the SQLParser class.\nThe Orbix ORB \nsystem from IONA Technologies [ION94] \nuses Factory Method to\ngenerate an appropriate type of proxy (see Proxy (207)) when an object requests a\nreference to a remote object. Factory Method makes it easy to replace the default\nproxy with one that uses client-side caching, for example.\nRelated Patterns\nAbstract Factory (87) \nis often implemented with factory methods. The Motivation\nexample in the Abstract Factory pattern illustrates Factory Method as well.\nFactory methods are usually called within Template Methods (325). In the docu-\nment example above, NewDocument is a template method.\nPrototypes (117) don't require subclassing Creator. However, they often require\nan Initialize operation on the Product class. Creator uses Initialize to initialize the\nobject. Factory Method doesn't require such an operation.\n", "page": 136, "type": "text", "section": "Page 136"}
{"text": "PROTOTYPE \n117\nPROTOTYPE \nObject Creational\nIntent\nSpecify the kinds of objects to create using a prototypical instance, and create new\nobjects by copying this prototype.\nMotivation\nYou could build an editor for music scores by customizing a general framework\nfor graphical editors and adding new objects that represent notes, rests, and\nstaves. The editor framework may have a palette of tools for adding these music\nobjects to the score. The palette would also include tools for selecting, moving,\nand otherwise manipulating music objects. Users will click on the quarter-note\ntool and use it to add quarter notes to the score. Or they can use the move tool to\nmove a note up or down on the staff, thereby changing its pitch.\nLet's assume the framework provides an abstract Graphic class for graphical com-\nponents, like notes and staves. Moreover, it'll provide an abstract Tool class for\ndefining tools like those in the palette. The framework also predefines a Graphic-\nTool subclass for tools that create instances of graphical objects and add them to\nthe document.\nBut GraphicTool presents a problem to the framework designer. The classes for\nnotes and staves are specific to our application, but the GraphicTool class belongs\nto the framework. GraphicTool \ndoesn't know how to create instances of our music\nclasses to add to the score. We could subclass GraphicTool \nfor each kind of music\nobject, but that would produce lots of subclasses that differ only in the kind of\nmusic object they instantiate. We \nknow object composition is a flexible alternative\nto subclassing. The question is, how can the framework use it to parameterize\ninstances of GraphicTool by the class of Graphic they're supposed to create?\nThe solution lies in making GraphicTool create a new Graphic by copying or\n\"cloning\" an instance of a Graphic subclass. We call this instance a prototype.\nGraphicTool is parameterized by the prototype it should clone and add to the\ndocument. If all Graphic subclasses support a Clone operation, then the Graphic-\nTool can clone any kind of Graphic.\nSo in our music editor, each tool for creating a music object is an instance of\nGraphicTool that's initialized with a different prototype. Each GraphicTool in-\nstance will produce a music object by cloning its prototype and adding the clone\nto the score.\n", "page": 137, "type": "text", "section": "Page 137"}
{"text": "118\nCREATIONAL PATTERNS\nCHAPTER 3\nWe can use the Prototype pattern to reduce the number of classes even further.\nWe have separate classes for whole notes and half notes, but that's probably\nunnecessary. Instead they could be instances of the same class initialized with\ndifferent bitmaps and durations. A tool for creating whole notes becomes just a\nGraphicTool whose prototype is a MusicalNote initialized to be a whole note. This\ncan reduce the number of classes in the system dramatically. It also makes it easier\nto add a new kind of note to the music editor.\nApplicability\nUse the Prototype pattern when a system should be independent of how its\nproducts are created, composed, and represented; and\n\u2022 when the classes to instantiate are specified at run-time, for example, by\ndynamic loading; or\n\u2022 to avoid building a class hierarchy of factories that parallels the class hierar-\nchy of products; or\n\u2022 when instances of a class can have one of only a few different combinations\nof state. It may be more convenient to install a corresponding number of\nprototypes and clone them rather than instantiating the class manually, each\ntime with the appropriate state.\n", "page": 138, "type": "text", "section": "Page 138"}
{"text": "PROTOTYPE \n119\nStructure\nParticipants\n\u2022 Prototype (Graphic)\n- declares an interface for cloning itself.\n\u2022 ConcretePrototype (Staff, WholeNote, HalfNote)\n- implements an operation for cloning itself.\n\u2022 Client (GraphicTool)\n- creates a new object by asking a prototype to clone itself.\nCollaborations\n\u2022 A client asks a prototype to clone itself.\nConsequences\nPrototype has many of the same consequences that Abstract Factory (87) and\nBuilder (97) have: It hides the concrete product classes from the client, thereby\nreducing the number of names clients know about. Moreover, these patterns let a\nclient work with application-specific classes without modification.\nAdditional benefits of the Prototype pattern are listed below.\n1. Adding and removing products at run-time. Prototypes let you incorporate a\nnew concrete product class into a system simply by registering a prototyp-\nical instance with the client. That's a bit more flexible than other creational\npatterns, because a client can install and remove prototypes at run-time.\n2. Specifying new objects by varying values. Highly dynamic systems let you de-\nfine new behavior through object composition\u2014by specifying values for an\n", "page": 139, "type": "text", "section": "Page 139"}
{"text": "120 \nCREATIONAL PATTERNS \nCHAPTER 3\nobject's variables, for example\u2014and not by defining new classes. You ef-\nfectively define new kinds of objects by instantiating existing classes and\nregistering the instances as prototypes of client objects. A client can exhibit\nnew behavior by delegating responsibility to the prototype.\nThis kind of design lets users define new \"classes\" without programming.\nIn fact, cloning a prototype is similar to instantiating a class. The Prototype\npattern can greatly \nreduce the number of classes a system needs. In our music\neditor, one GraphicTool class can create a limitless variety of music objects.\n3. Specifying new objects by varying structure. Many applications build objects\nfrom parts and subparts. Editors for circuit design, for example, build cir-\ncuits out of subcircuits.1 For convenience, such applications often let you\ninstantiate complex, user-defined structures, say, to use a specific subcircuit\nagain and again.\nThe Prototype pattern supports this as well. We \nsimply add this subcircuit as\na prototype to the palette of available circuit elements. As long as the com-\nposite circuit object implements Clone as a deep copy, circuits with different\nstructures can be prototypes.\n4. Reduced subclassing. Factory Method (107) \noften produces a hierarchy of Cre-\nator classes that parallels the product class hierarchy. The Prototype pattern\nlets you clone a prototype instead of asking a factory method to make a new\nobject. Hence you don't need a Creator class hierarchy at all. This benefit\napplies primarily to languages like C++ that don't treat classes as \nfirst-class \nobjects. Languages that do, like Smalltalk and Objective C, derive less bene-\nfit, since you can always use a class object as a creator. Class objects already\nact like prototypes in these languages.\n5. Configuring an application with classes dynamically. Some run-time environ-\nments let you load classes into an application dynamically. The Prototype\npattern is the key to exploiting such facilities in a language like \nC++.\nAn application that wants to create instances of a dynamically loaded class\nwon't be able to reference its constructor statically. Instead, \nthe run-time envi-\nronment creates an instance of each class automatically \nwhen it's loaded, and\nit registers the instance with a prototype manager (see the Implementation\nsection). Then the application can ask the prototype manager for instances of\nnewly loaded classes, classes that weren't linked with the program originally.\nThe ET++ application framework [WGM88] has a run-time system that uses\nthis scheme.\nThe main liability of the Prototype pattern is that each subclass of Prototype must\nimplement the Clone operation, which may be difficult. For example, adding\nClone is difficult when the classes under consideration already exist. Implement-\ning Clone can be difficult when their internals include objects that don't support\ncopying or have circular references.\n1Such applications reflect the Composite (163) \nand Decorator (175) patterns.\n", "page": 140, "type": "text", "section": "Page 140"}
{"text": "PROTOTYPE \n121\nImplementation\nPrototype is particularly useful with static languages like C++, where classes are\nnot objects, and little or no type information is available at run-time. It's less\nimportant in languages like Smalltalk or Objective C that provide what amounts \nto a prototype (i.e., a class object) for creating instances of each class. This pattern is\nbuilt into prototype-based languages like Self [US87], in which all object creation\nhappens by cloning a prototype.\nConsider the following issues when implementing prototypes:\n1. Using a prototype manager. When the number of prototypes in a system isn't\nfixed (that is, they can be created and destroyed dynamically), keep a registry\nof available prototypes. Clients won't manage prototypes themselves but will\nstore and retrieve them from the registry. A client will ask the registry for a \nprototype before cloning it. We call this registry a prototype manager.\nA prototype manager is an associative store that returns the prototype match-\ning a given key. It has operations for registering a prototype under a key and\nfor unregistering it. Clients can change or even browse through the registry\nat run-time. This lets clients extend and take inventory on the system without\nwriting code.\n2. Implementing the Clone operation. The hardest part of the Prototype pattern\nis implementing the Clone operation correctly. It's particularly tricky when\nobject structures contain circular references.\nMost languages provide some support for cloning objects. For example,\nSmalltalk provides an implementation of copy that's inherited by all sub-\nclasses of Object. C++ provides a copy constructor. But these facilities don't \nsolve the \"shallow copy versus deep copy\" problem [GR83]. That is, does\ncloning an object in turn clone its instance variables, or do the clone and\noriginal just share the variables?\nA shallow copy is simple and often sufficient, and that's what Smalltalk\nprovides by default. The default copy constructor in C++ does a member-\nwise copy, which means pointers will be shared between the copy and the\noriginal. But cloning prototypes with complex structures usually requires a\ndeep copy, because the clone and the original must be independent. Therefore\nyou must ensure that the clone's components are clones of the prototype's \ncomponents. Cloning forces you to decide what if anything will be shared.\nIf objects in the system provide Save and Load operations, then you can use\nthem to provide a default implementation of Clone simply by saving the\nobject and loading it back immediately. The Save operation saves the object\ninto a memory buffer, and Load creates a duplicate by reconstructing the\nobject from the buffer.\n3. Initializing clones. While some clients are perfectly happy with the clone as\nis, others will want to initialize some or all of its internal state to values\n", "page": 141, "type": "text", "section": "Page 141"}
{"text": "122 \nCREATIONAL PATTERNS \nCHAPTER 3\nof their choosing. You generally can't pass these values in the Clone oper-\nation, because their number will vary between classes of prototypes. Some\nprototypes might need multiple initialization parameters; others won't need\nany. Passing parameters in the Clone operation precludes a uniform cloning\ninterface.\nIt might be the case that your prototype classes already define operations for\n(re)setting key pieces of state. If so, clients may use these operations immedi-\nately after cloning. If not, then you may have to introduce an Initialize\noperation (see the Sample Code section) that takes initialization parame-\nters as arguments and sets the clone's internal state accordingly. Beware of\ndeep-copying Clone operations\u2014the copies may have to be deleted (either\nexplicitly or within Initialize) before you reinitialize them.\nSample Code\nWe'll define a MazePrototypeFactory subclass of the MazeFactory class\n(page 92). MazePrototypeFactory will be initialized with prototypes of the\nobjects it will create so that we don't have to subclass it just to change the classes\nof walls or rooms it creates.\nMazePrototypeFactory augments the MazeFactory interface with a con-\nstructor that takes the prototypes as arguments:\nclass MazePrototypeFactory : \npublic MazeFactory {\npublic:\nMazePrototypeFactory (Maze*, Wall*, Room*, Door*),-\nvirtual Maze* MakeMaze() const; \nvirtual Room* MakeRoom(int) const; \nvirtual Wall* MakeWall() const; \nvirtual Door* MakeDoor(Room*, Room*) const;\nprivate:\nMaze* _prototypeMaze;\nRoom* _prototypeRoom; \nWall* _prototypeWall; \nDoor* _prototypeDoor;\nThe new constructor simply initializes its prototypes:\nMazePrototypeFactory::MazePrototypeFactory \n(\nMaze* m, Wall* w, Room* r, Door* d\n) \n{\n_prototypeMaze = m;\n_prototypeWall = w; \n__prototypeRoom = r;\n_prototypeDoor = d;\n}\n", "page": 142, "type": "text", "section": "Page 142"}
{"text": "PROTOTYPE \n123\nThe member functions for creating walls, rooms, and doors are similar: Each\nclones a prototype and then initializes it. Here are the definitions of MakeWall\nand \nMakeDoor:\nWall* MazePrototypeFactory::MakeWall () \nconst {\nreturn _prototypeWall->Clone();\n}\nDoor* MazePrototypeFactory::MakeDoor (Room* rl, Room *r2) const { \nDoor* door = _prototypeDoor->Clone();\ndoor->Initialize(rl, r2); \nreturn door;\n}\nWe can use MazePrototypeFactory to create a prototypical or default maze\njust by initializing it with prototypes of basic maze components:\nMa \nz \neGame game;\nMazePrototypeFactory simpleMazeFactory( \nnew Maze, new Wall, new Room, new Door\nMaze* maze = game.CreateMaze(simpleMazeFactory);\nTo change the type of maze, we initialize MazePrototypeFactory with a dif-\nferent set of prototypes. The following call creates a maze with a BombedDoor\nand a RoomWithABomb:\nMazePrototypeFactory bombedMazeFactory(\nnew Maze, new BombedWall, \nnew RoomWithABomb, new Door\n) \n;\nAn object that can be used as a prototype, such as an instance of Wall, must\nsupport the Clone operation. It must also have a copy constructor for cloning. It\nmay also need a separate operation for reinitializing internal state. We'll add the\nInitialize operation to Door to let clients initialize the clone's rooms.\nCompare the following definition of Door to the one on page 83:\nclass Door : \npublic MapSite {\npublic:\nDoor();\nDoor(const Door&);\nvirtual void Initialize(Room*, Room*);\nvirtual Door* Clone() const;\n", "page": 143, "type": "text", "section": "Page 143"}
{"text": "124 \nCREATIONAL PATTERNS \nCHAPTER 3\nvirtual void Enter();\nRoom* OtherSideFrom(Room*);\nprivate: \nRoom* _rooml;\nRoom* _room2;\n};\nDoor::Door (const Door& other) { \n_rooml - other._rooml;\n_room2 = other._room2;\n}\nvoid Door::Initialize (Room* rl, Room* r2) { \n_rooml = rl;\n_room2 = r2;\n}\nDoor* Door::Clone () \nconst {\nreturn new Door(*this);\n}\nThe BombedWa \n11 subclass must override C1 one and implement a corresponding\ncopy constructor.\nclass BombedWall : \npublic Wall {\npublic:\nBombedWall();\nBombedWall(const BombedWa11&);\nvirtual Wall* Clone() const;\nbool HasBomb();\nprivate: \nbool _bomb;\n};\nBombedWall::BombedWall (const BombedWallk other) : \nWall(other) {\n_bomb = other._bomb;\n}\nWall* BombedWall::Clone () \nconst {\nreturn new BombedWall(*this);\n}\nAlthough BombedWall: : \nClone returns a Wall*, its implementation returns a\npointer to a new instance of a subclass, that is, a BombedWa \n11 *. We define C1 one\nlike this in the base class to ensure that clients that clone the prototype don't have\nto know about their concrete subclasses. Clients should never need to downcast\nthe return value of Clone to the desired type.\nIn Smalltalk, you can reuse the standard copy method inherited from Object\nto clone any MapSite. You can use MazeFactory to produce the prototypes\n", "page": 144, "type": "text", "section": "Page 144"}
{"text": "PROTOTYPE \n125\nyou'll need; for example, you can create a room by supplying the name #room.\nThe MazeFactory has a dictionary that maps names to prototypes. Its make:\nmethod looks like this:\nmake: partName \n(partCatalog at: partName) copy\nGiven appropriate methods for initializing the MazeFactory with prototypes,\nyou could create a simple maze with the following code:\nCreateMaze \non: (MazeFactory new\nwith: Door new named: \nttdoor;\nwith: Wall new named: \nttwall;\nwith: Room new named: \nttroom; \nyourself)\nwhere the definition of the on: class method for CreateMaze would be\non: aFactory \nI rooml room2 I \nrooml := (aFactory make: ttroom) location: 1@1. \nroom2 := (aFactory make: ttroom) location: 2@1. \ndoor := (aFactory make: #door) from: rooml to: room2.\nrooml \nat \nSide:\natSide:\natSide:\natSide:\nroom2\natSide: \natSide:\natSide:\natSide \n:\nMaze new\naddRoom \n:\naddRoom \n:\nyourseli\nttnorth\n#east \n#south\n#west\n#north\ntteast\nttsouth\nttwest\n: rooml\n: room2\nput :\nput \n:\nput\nput \n:\nput\nput \n:\nput\nput \n:\n: (aFactory\ndoor;\n: (aFactory\n(aFactory\n: (aFactory\n(aFactory \n: (aFactory\ndoor \n.\nmake:\nmake \n:\nmake \n:\nmake \n:\nmake \n:\nmake \n:\n: \nttwall)\n: \nttwall)\nttwall) .\n: \nttwall)\n#wall) ;\n: \nttwall)\nKnown Uses\nPerhaps the first example of the Prototype pattern was in Ivan \nSutherland's \nSketch-\npad system [Sut63]. The first widely known application of the pattern in an object-\noriented language was in ThingLab, where users could form a composite object\nand then promote it to a prototype by installing it in a library of reusable ob-\njects [Bor81]. Goldberg and Robson mention prototypes as a pattern [GR831, but\nCoplien [Cop92] gives a much more complete description. He describes idioms\nrelated to the Prototype pattern for C++ and gives many examples and variations.\nEtgdb is a debugger front-end based on ET++ that provides a point-and-click\ninterface to different line-oriented debuggers. Each debugger has a correspond-\ning Debugger \nAdaptor subclass. For example, Gdb \nAdaptor adapts etgdb to the\n", "page": 145, "type": "text", "section": "Page 145"}
{"text": "126 \nCREATIONAL PATTERNS \nCHAPTERS\ncommand syntax of GNU gdb, while SunDbxAdaptor adapts etgdb to Sun's dbx\ndebugger. Etgdb does not have a set of Debugger \nAdaptor classes hard-coded into\nit. Instead, it reads the name of the adaptor to use from an environment vari-\nable, looks for a prototype with the specified name in a global table, and then\nclones the prototype. New debuggers can be added to etgdb by linking it with the\nDebuggerAdaptor that works for that debugger.\nThe \"interaction technique library\" in Mode \nComposer stores prototypes of objects\nthat support various interaction techniques [Sha90]. Any interaction technique\ncreated by the Mode Composer can be used as a prototype by placing it in this\nlibrary. The Prototype pattern lets Mode Composer support an unlimited set of\ninteraction techniques.\nThe music editor example discussed earlier is based on the Unidraw drawing\nframework [VL90].\nRelated Patterns\nPrototype and Abstract Factory (87) \nare competing patterns in some ways, as we\ndiscuss at the end of this chapter. They can also be used together, however. An\nAbstract Factory might store a set of prototypes from which to clone and return\nproduct objects.\nDesigns that make heavy use of the Composite (163) \nand Decorator (175) \npatterns\noften can benefit from Prototype as well.\n", "page": 146, "type": "text", "section": "Page 146"}
{"text": "SINGLETON \n127\nSINGLETON\nObject Creational\nIntent\nEnsure a class only has one instance, and provide a global point of access to it.\nMotivation\nIt's important for some classes to have exactly one instance. Although there can be\nmany printers in a system, there should be only one printer spooler. There should\nbe only one file system and one window manager. A digital filter will have one\nA/D converter. An accounting system will be dedicated to serving one company.\nHow do we ensure that a class has only one instance and that the instance is easily\naccessible? A global variable makes an object accessible, but it doesn't keep you\nfrom instantiating multiple objects.\nA better solution is to make the class itself responsible for keeping track of its sole\ninstance. The class can ensure that no other instance can be created (by intercepting\nrequests to create new objects), and it can provide a way to access the instance.\nThis is the Singleton pattern.\nApplicability\nUse the Singleton pattern when\n\u2022 there must be exactly one instance of a class, and it must be accessible to\nclients from a well-known access point.\n\u2022 when the sole instance should be extensible by subclassing, and clients\nshould be able to use an extended instance without modifying their code.\nStructure\n", "page": 147, "type": "text", "section": "Page 147"}
{"text": "128 \nCREATIONAL PATTERNS \nCHAPTER 3\nParticipants\n\u2022 Singleton\n- defines an Instance operation that lets clients access its unique instance.\nInstance is a class operation (that is, a class method in Smalltalk and a static\nmember function in C++).\n- may \nbe responsible for creating its own \nunique instance.\nCollaborations\n\u2022 Clients access a Singleton instance solely through Singleton's Instance opera-\ntion.\nConsequences\nThe Singleton pattern has several benefits:\n1. Controlled access to sole instance. Because the Singleton class encapsulates its\nsole instance, it can have strict control over how and when clients access it.\n2. Reduced name space. The Singleton pattern is an improvement over global\nvariables. It avoids polluting the name space with global variables that store\nsole instances.\n3. Permits refinement of operations and representation. The Singleton class may be\nsubclassed, and it's easy to configure an application with an instance of this\nextended class. You can configure the application with an instance of the\nclass you need at run-time.\n4. Permits a variable \nnumber of instances. The pattern makes it easy to change your\nmind and allow more than one instance of the Singleton class. Moreover,\nyou can use the same approach to control the number of instances that\nthe application uses. Only the operation that grants access to the Singleton \ninstance needs to change.\n5. More flexible than class operations. Another way to package a singleton's func-\ntionality is to use class operations (that is, static member functions in C++ or\nclass methods in Smalltalk). But both of these language techniques make it\nhard to change a design to allow more than one instance of a class. Moreover,\nstatic member functions in C++ \nare never virtual, so subclasses can't override\nthem polymorphically.\nImplementation\nHere are implementation issues to consider when using the Singleton pattern:\n1. Ensuring a unique instance. The Singleton pattern makes the sole instance a\nnormal instance of a class, but that class is written so that only one instance\n", "page": 148, "type": "text", "section": "Page 148"}
{"text": "SINGLETON \n129\ncan ever be created. A common way to do this is to hide the operation that\ncreates the instance behind a class operation (that is, either a static member\nfunction or a class method) that guarantees only one instance is created. This\noperation has access to the variable that holds the unique instance, and it\nensures the variable is initialized with the unique instance before returning\nits value. This approach ensures that a singleton is created and initialized\nbefore its first use.\nYou can define the class operation in C++ with a static member function\nInstance of the Singleton class. Single \nton also defines a static member\nvariable -instance that contains a pointer to its unique instance.\nThe Singleton class is declared as\nclass Singleton {\npublic:\nstatic Singleton* Instance();\nprotected:\nSingleton();\nprivate:\nstatic Singleton* _instance;\n};\nThe corresponding implementation is\nSingleton* Singleton::_instance = 0;\nSingleton* Singleton::Instance () \n{\nif (_instance == 0) {\n_instance = new Singleton;\n}\nreturn _instance;\n}\nClients access the singleton exclusively through the Instance member func-\ntion. The variable -instance is initialized to 0, and the static member func-\ntion Instance returns its value, initializing it with the unique instance if it\nis 0. Instance uses lazy initialization; the value it returns isn't created and\nstored until it's first accessed.\nNotice that the constructor is protected. A client that tries to instantiate\nSingleton directly will get an error at compile-time. This ensures that only\none instance can ever get created.\nMoreover, since the -instance is a pointer to a Singleton object, the\nInstance member function can assign a pointer to a subclass of Single-\nton to this variable. We'll give an example of this in the Sample Code.\nThere's another thing to note about the C++ implementation. It isn't enough\nto define the singleton as a global or static object and then rely on automatic\ninitialization. There are three reasons for this:\n(a) We can't guarantee that only one instance of a static object will ever be\ndeclared.\n", "page": 149, "type": "text", "section": "Page 149"}
{"text": "130 \nCREATIONAL PATTERNS \nCHAPTER 3\n(b) We might not have enough information to instantiate every singleton\nat static initialization time. A singleton might require values that are\ncomputed later in the program's execution.\n(c) C++ doesn't define the order in which constructors for global objects are\ncalled across translation units [ES90]. This means that no dependencies\ncan exist between singletons; if any do, then errors are inevitable.\nAn added (albeit small) liability of the global/static object approach is that\nit forces all singletons to be created whether they are used or not. \nUsing a\nstatic member function avoids all of these problems.\nIn Smalltalk, the function that returns the unique instance is implemented\nas a class method on the Singleton class. To ensure that only one instance is\ncreated, override the new operation. The resulting Singleton class might have\nthe following two class methods, where Solelnstanceisa class variable\nthat is not used anywhere else:\nnew\nself error: 'cannot create new object'\ndefault \nSolelnstance isNil ifTrue: [Solelnstance := super new].\nSolelnstance\n2. Subclassing the Singleton class. The main issue is not so much defining the\nsubclass but installing its unique instance so that clients will be able to use \nit. In essence, the variable that refers to the singleton instance must get\ninitialized with an instance of the subclass. The simplest technique is to \ndetermine which singleton you want to use in the Singleton's Instance\noperation. An example in the Sample Code shows how to implement this\ntechnique with environment variables.\nAnother way to choose the subclass of Singleton is to take the implementation\nof Instance out of the parent class (e.g., MazeFactory) and put it in the\nsubclass. That lets a C++ programmer decide the class of singleton at link-\ntime (e.g., by linking in an object file containing a different implementation)\nbut keeps it hidden from the clients of the singleton.\nThe link approach fixes the choice of singleton class at link-time, which\nmakes it hard to choose the singleton class at run-time. Using conditional\nstatements to determine the subclass is more flexible, but it hard-wires the\nset of possible Singleton classes. Neither approach is flexible enough in all\ncases.\nA more flexible approach uses a registry of singletons. Instead of having\nInstance define the set of possible Singleton classes, the Singleton classes\ncan register their singleton instance by name in a well-known registry.\nThe registry maps between string names and singletons. When Instance\nneeds a singleton, it consults the registry, asking for the singleton by name.\n", "page": 150, "type": "text", "section": "Page 150"}
{"text": "SINGLETON \n131\nThe registry looks up the corresponding singleton (if it exists) and returns it.\nThis approach frees Instance from knowing all possible Singleton classes\nor instances. All it requires is a common interface for all Singleton classes\nthat includes operations for the registry:\nclass Singleton {\npublic:\nstatic void Register(const char* name, Singleton*);\nstatic Singleton* Instance();\nprotected: \nstatic Singleton* Lookup(const char* name);\nprivate: \nstatic Singleton* _instance; \nstatic List<NameSingletonPair>* _registry;\n};\nRegister registers the Singleton instance under the given name. To keep\nthe registry simple, we'll have it store a list of Names \ningle \ntonPair objects.\nEach NameSingletonPair maps a name to a singleton. The Lookup op-\neration finds a singleton given its name. We'll assume that an environment\nvariable specifies the name of the singleton desired.\nSingleton* Singleton::Instance () {\nif (_instance = = 0 ) {\nconst char* singletonName = getenv(\"SINGLETON\");\n// user or environment supplies this at startup\n_instance = Lookup(singletonName); \n// Lookup returns 0 if there's no such singleton\n} \nreturn _instance;\n}\nWhere do Singleton classes register themselves? One possibility is in their\nconstructor. For example, a MyS \ningle \nton subclass could do the following:\nMySingleton::MySingleton() \n{\n// . \n. .\nSingleton::Register(\"MySingleton\", this);\n}\nOf course, the constructor won't get called unless someone instantiates the\nclass, which echoes the problem the Singleton pattern is trying to solve!\nWe can get around this problem in C++ by defining a static instance of\nMySingleton. For example, we can define\nstatic MySingleton theSingleton;\nin the file that contains MyS ingle \nton's implementation.\nNo longer is the Singleton class responsible for creating the singleton. Instead,\nits primary responsibility is to make the singleton object of choice accessible\n", "page": 151, "type": "text", "section": "Page 151"}
{"text": "132 \nCREATIONAL PATTERNS \nCHAPTER 3\nin the system. The static object approach still has a potential drawback\u2014\nnamely that instances of all possible Singleton subclasses must be created, or\nelse they won't get registered.\nSample Code\nSuppose we define a MazeFactory class for building mazes as described on\npage 92. MazeFactory defines an interface for building different parts of a maze.\nSubclasses can redefine the operations to return instances of specialized product\nclasses, like BombedWall objects instead of plain Wall objects.\nWhat's relevant here is that the Maze application needs only one instance of\na maze factory, and that instance should be available to code that builds any \npart of the maze. This is where the Singleton pattern comes in. By making the\nMazeFactory a singleton, we make the maze object globally accessible without\nresorting to global variables.\nFor simplicity, let's assume we'll never subclass MazeFactory. (We'll consider\nthe alternative in a moment.) We make it a Singleton class in C++ \nby adding a static\nInstance operation and a static -instance member to hold the one and only\ninstance. We \nmust also protect the constructor to prevent accidental instantiation,\nwhich might lead to more than one instance.\nclass MazeFactory \n{\npublic:\nstatic MazeFactory* Instance();\n// existing interface goes here\nprotected:\nMazeFactory();\nprivate:\nstatic MazeFactory* \n_instance;\n};\nThe corresponding implementation is\nMazeFactory* MazeFactory::_instance = 0;\nMazeFactory* MazeFactory::Instance () {\nif (_instance = = 0 ) {\n_instance = new MazeFactory;\n}\nreturn _instance;\n}\nNow let's consider what happens when there are \nsubclasses of Ma z \neFac \nt ory, and\nthe application must decide which one to use. We'll select the kind of maze through\nan environment variable and add code that instantiates \nthe proper MazeFactory\nsubclass based on the environment variable's value. The Instance operation is\na good place to put this code, because it already instantiates MazeFactory:\n", "page": 152, "type": "text", "section": "Page 152"}
{"text": "SINGLETON \n133\nMazeFactory* MazeFactory::Instance () {\nif (_instance = = 0 ) {\nconst char* mazeStyle - getenv(\"MAZESTYLE\");\nif (strcmp(mazeStyle, \"bombed\") == 0) {\n_instance = new BombedMazeFactory;\n} else if (strcmp(mazeStyle, \"enchanted\") == 0) { \n_instance = new EnchantedMazeFactory;\n// ... other possible subclasses\n} else { \n// \ndefault\n_instance = new MazeFactory;\n}\n} \nreturn _instance;\n}\nNote that Instance must be modified whenever you define a new subclass of\nMazeFactory. That might not be a problem in this application, but it might be\nfor abstract factories defined in a framework.\nA possible solution would be to use the registry approach described in the Imple-\nmentation section. Dynamic linking could be useful here as well\u2014it would keep\nthe application from having to load all the subclasses that are not used.\nKnown Uses\nAn example of the Singleton pattern in Smalltalk-80 [Par90] is the set of changes to\nthe code, which is ChangeSet current. A more subtle example is the relation-\nship between classes and their metaclasses. A metaclass is the class of a class, and\neach metaclass has one instance. Metaclasses do not have names (except indirectly\nthrough their sole instance), but they keep track of their sole instance and will not\nnormally create another.\nThe Interviews user interface toolkit [LCI+92] uses the Singleton pattern to access\nthe unique instance of its Session and WidgetKit classes, among others. Session\ndefines the application's main event dispatch loop, stores the user's database of\nstylistic preferences, and manages connections to one or more physical displays.\nWidgetKit is an Abstract Factory (87) \nfor defining the look and feel of user interface\nwidgets. The WidgetKit: : instance ( ) operation determines the particular\nWidgetKit subclass that's instantiated based on an environment variable that\nSession defines. A similar operation on Session determines whether monochrome\nor color displays are supported and configures the singleton Session instance\naccordingly.\n", "page": 153, "type": "text", "section": "Page 153"}
{"text": "134 \nCREATIONAL PATTERNS \nCHAPTER 3\nRelated \nPatterns\nMany patterns can be implemented using the Singleton pattern. See Abstract\nFactory (87), Builder (97), and Prototype (117).\n", "page": 154, "type": "text", "section": "Page 154"}
{"text": "DISCUSSION OF CREATIONAL PATTERNS \n135\nDiscussion of Creational Patterns\nThere are two common ways to parameterize a system by the classes of objects it\ncreates. One way is to subclass the class that creates the objects; this corresponds to\nusing the Factory Method (107) pattern. The main drawback of this approach is that it \ncan require creating a new subclass just to change the class of the product. Such changes\ncan cascade. For example, when the product creator is itself created by a factory method,\nthen you have to override its creator as well.\nThe other way to parameterize a system relies more on object composition: Define an\nobject that's responsible for knowing the class of the product objects, and make it a\nparameter of the system. This is a key aspect of the Abstract Factory (87), Builder \n(97),\nand Prototype (117) patterns. All three involve creating a new \"factory object\" whose\nresponsibility is to create product objects. Abstract Factory has the factory object pro-\nducing objects of several classes. Builder has the factory object building a complex \nproduct incrementally using a correspondingly complex protocol. Prototype has the\nfactory object building a product by copying a prototype object. In this case, the factory\nobject and the prototype are the same object, because the prototype is responsible for\nreturning the product.\nConsider the drawing editor framework described in the Prototype pattern. There are\nseveral ways to parameterize a GraphicTool \nby the class of product:\n\u2022 By applying the Factory Method pattern, a subclass of GraphicTool \nwill be created\nfor each subclass of Graphic in the palette. GraphicTool will have a NewGraphic\noperation that each GraphicTool subclass will redefine.\n\u2022 By applying the Abstract Factory pattern, there will be a class hierarchy of Graph-\nicsFactories, one for each Graphic subclass. Each factory creates just one product\nin this case: CircleFactory will create Circles, LineFactory will create Lines, and\nso on. A GraphicTool \nwill be parameterized with a factory for creating the appro-\npriate kind of Graphics.\n\u2022 By \napplying the Prototype pattern, each subclass of Graphics will implement the\nClone operation, and a GraphicTool will be parameterized with a prototype of\nthe Graphic it creates.\nWhich pattern is best depends on many factors. In our drawing editor framework, the\nFactory Method pattern is easiest to use at first. It's easy to define a new subclass of\nGraphicTool, and the instances of GraphicTool are created only when the palette is\ndefined. The main disadvantage here is that GraphicTool subclasses proliferate, and\nnone of them does very much.\nAbstract Factory doesn't offer much of an improvement, because it requires an equally\nlarge GraphicsFactory class hierarchy. Abstract Factory would be preferable to Factory\nMethod only if there were already a GraphicsFactory class hierarchy\u2014either because\nthe compiler provides it automatically (as in Smalltalk or Objective C) or because it's\nneeded in another part of the system.\n", "page": 155, "type": "text", "section": "Page 155"}
{"text": "136 \nCREATIONAL PATTERNS \nCHAPTER 3\nOverall, the Prototype pattern is probably the best for the drawing editor framework,\nbecause it only requires implementing a Clone operation on each Graphics class. That\nreduces the number of classes, and Clone can be used for purposes other than pure\ninstantiation (e.g., a Duplicate menu operation).\nFactory Method makes a design more customizable and only a little more complicated.\nOther design patterns require new classes, whereas Factory \nMethod only requires a new\noperation. People often use Factory Method as the standard way to create objects, but it\nisn't necessary when the class that's instantiated never changes or when instantiation\ntakes place in an operation that subclasses can easily override, such as an initialization\noperation.\nDesigns that use Abstract Factory, Prototype, or Builder are even more flexible than\nthose that use Factory Method, but they're also more complex. Often, designs start out\nusing Factory Method and evolve toward the other creational patterns as the designer\ndiscovers where more flexibility is needed. Knowing many design patterns gives you\nmore choices when trading off one design criterion against another.\n", "page": 156, "type": "text", "section": "Page 156"}
{"text": "Chapter 4\nStructural Patterns\nStructural patterns are concerned with how classes and objects are composed to form\nlarger structures. Structural class patterns use inheritance to compose interfaces or im-\nplementations. As a simple example, consider how multiple inheritance mixes two or\nmore classes into one. The result is a class that combines the properties of its parent\nclasses. This pattern is particularly useful for making independently developed class\nlibraries work together. Another example is the class form of the Adapter (139) pat-\ntern. In general, an adapter makes one interface (the adaptee's) conform to another,\nthereby providing a uniform abstraction of different interfaces. A class adapter accom-\nplishes this by inheriting privately from an adaptee class. The adapter then expresses\nits interface in terms of the adaptee's.\nRather than composing interfaces or implementations, structural object patterns de-\nscribe ways to compose objects to realize new functionality. The added flexibility of\nobject composition comes from the ability to change the composition at run-time, which\nis impossible with static class composition.\nComposite (163) is an example of a structural object pattern. It describes how to build\na class hierarchy made up of classes for two kinds of objects: primitive and composite.\nThe composite objects let you compose primitive and other composite objects into\narbitrarily complex structures. In the Proxy (207) \npattern, a proxy acts as a convenient\nsurrogate or placeholder for another object. A proxy can be used in many ways. It can\nact as a local representative for an object in a remote address space. It can represent\na large object that should be loaded on demand. It might protect access to a sensitive\nobject. Proxies provide a level of indirection to specific properties of objects. Hence they\ncan restrict, enhance, or alter these properties.\nThe Flyweight (195) pattern defines a structure for sharing objects. Objects are shared\nfor at least two reasons: efficiency and consistency. Flyweight focuses on sharing for\nspace efficiency. Applications that use lots of objects must pay careful attention to\nthe cost of each object. Substantial savings can be had by sharing objects instead of\nreplicating them. But objects can be shared only if they don't define context-dependent\n137\n", "page": 157, "type": "text", "section": "Page 157"}
{"text": "138 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nstate. Flyweight objects have no such state. Any additional information they need to\nperform their task is passed to them when needed. With no context-dependent state,\nFlyweight objects may be shared freely.\nWhereas Flyweight shows how to make lots of little objects, Facade (185) shows how\nto make a single object represent an entire subsystem. A facade is a representative for a\nset of objects. The facade carries out its responsibilities by forwarding messages to the\nobjects it represents. The Bridge (151) pattern separates an object's abstraction from its\nimplementation so that you can vary them independently.\nDecorator (175) describes how to add responsibilities to objects dynamically. \nDecorator\nis a structural pattern that composes objects \nrecursively to allow an open-ended number\nof additional responsibilities. For example, a Decorator object containing a user interface\ncomponent can add a decoration like a border or shadow to the component, or it can\nadd functionality like scrolling and zooming. We can add two decorations simply by\nnesting one Decorator object within another, and so on for additional decorations. To \naccomplish this, each Decorator object must conform to the interface of its component\nand must forward messages to it. The Decorator can do its job (such as drawing a\nborder around the component) either before or after forwarding a message.\nMany structural patterns are related to some degree. We'll discuss these relationships\nat the end of the chapter.\n", "page": 158, "type": "text", "section": "Page 158"}
{"text": "ADAPTED \n139\nADAPTER \nClass, Object Structural\nIntent\nConvert the interface of a class into another interface clients expect. Adapter lets\nclasses work together that couldn't otherwise because of incompatible \ninterfaces.\nAlso Known As\nWrapper\nMotivation\nSometimes a toolkit class that's designed for reuse isn't reusable only because its\ninterface doesn't match the domain-specific interface an application requires.\nConsider for example a drawing editor that lets users draw and arrange graphical\nelements (lines, polygons, text, etc.) into pictures and diagrams. The drawing\neditor's key abstraction is the graphical object, which has an editable shape and\ncan draw itself. The interface for graphical objects is defined by an abstract class\ncalled Shape. The editor defines a subclass of Shape for each kind of graphical\nobject: a LineShape class for lines, a PolygonShape class for polygons, and so\nforth.\nClasses for elementary geometric shapes like LineShape and PolygonShape are\nrather easy to implement, because their drawing and editing capabilities are \ninherently limited. But a TextShape subclass that can display and edit text is\nconsiderably more difficult to implement, since even basic text editing involves\ncomplicated screen update and buffer management. Meanwhile, an off-the-shelf\nuser interface toolkit might already provide a sophisticated TextView class for\ndisplaying and editing text. Ideally we'd like to reuse TextView to implement\nTextShape, but the toolkit wasn't designed with Shape classes in mind. So we\ncan't use TextView and Shape objects \ninterchangeably.\nHow can existing and unrelated classes like TextView work in an application that\nexpects classes with a different and incompatible interface? We could change the\nTextView class so that it conforms to the Shape interface, but that isn't an option\nunless we have the toolkit's source code. Even if we did, it wouldn't make sense to\nchange TextView; the toolkit shouldn't have to adopt domain-specific \ninterfaces\njust to make one application work.\nInstead, we could define TextShape so that it adapts the TextView interface to\nShape's. We can do this in one of two ways: (1) by inheriting Shape's interface\nand Text \nView's implementation or (2) by composing a TextView instance within\na TextShape \nand implementing TextShape \nin terms of Text \nView's interface. These\n", "page": 159, "type": "text", "section": "Page 159"}
{"text": "140 \nSTRUCTURAL PATTERNS\nCHAPTER 4\ntwo approaches correspond to the class and object versions of the Adapter pattern.\nWe call TextShape an adapter.\nThis diagram illustrates the object adapter case. It shows how BoundingBox re-\nquests, declared in class Shape, are converted to GetExtent requests defined in\nText \nView. Since TextShape adapts Text \nView to the Shape interface, the drawing\neditor can reuse the otherwise incompatible Text \nView class.\nOften the adapter is responsible for functionality the adapted class doesn't pro-\nvide. The diagram shows how an adapter can fulfill such responsibilities. The\nuser should be able to \"drag\" every Shape object to a new location interactively,\nbut Text \nView isn't designed to do that. TextShape \ncan add this missing function-\nality by implementing Shape's CreateManipulator operation, which returns an \ninstance of the appropriate Manipulator subclass.\nManipulator is an abstract class for objects that know how to animate a Shape in\nresponse to user input, like dragging the shape to a new location. There are sub-\nclasses of Manipulator for different shapes; TextManipulator, \nfor example, is the\ncorresponding subclass for TextShape. By returning a TextManipulator instance,\nTextShape adds the functionality that Text \nView lacks but Shape requires.\nApplicability\nUse the Adapter pattern when\n\u2022 you want to use an existing class, and its interface does not match the one\nyou need.\n\u2022 you want to create a reusable class that cooperates with unrelated or \nunfore-\nseen classes, that is, classes that don't necessarily have compatible interfaces.\n\u2022 (object adapter only) you need to use several existing subclasses, but it's un-\npractical to adapt their interface by subclassing every one. An object adapter\ncan adapt the interface of its parent class.\n", "page": 160, "type": "text", "section": "Page 160"}
{"text": "ADAPTER \n141\nStructure\nA class adapter uses multiple inheritance to adapt one interface to another:\nAn object adapter relies on object composition:\nParticipants\n\u2022 Target (Shape)\n- defines the domain-specific interface that Client uses.\n\u2022 Client (DrawingEditor)\n- collaborates with objects conforming to the Target interface.\n\u2022 Adaptec (TextView)\n- defines an existing interface that needs adapting.\n\u2022 Adapter (TextShape)\n- adapts the interface of Adaptec to the Target interface.\nCollaborations\n\u2022 Clients call operations on an Adapter instance. In turn, the adapter calls\nAdaptec operations that carry out the request.\n", "page": 161, "type": "text", "section": "Page 161"}
{"text": "142 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nConsequences\nClass and object adapters have different trade-offs. A class adapter\n\u2022 adapts Adaptee to Target by committing to a concrete Adaptee class. As a\nconsequence, a class adapter won't work when we want to adapt a class \nand\nall its subclasses.\n\u2022 lets Adapter override some of Adaptee's \nbehavior, since Adapter is a subclass\nof Adaptee.\n\u2022 introduces only one object, and no additional pointer indirection is needed\nto get to the adaptee.\nAn object adapter\n\u2022 lets a single Adapter work with many Adaptees\u2014that is, the Adaptee itself\nand all of its subclasses (if any). The Adapter can also add functionality to\nall Adaptees at once.\n\u2022 makes it harder to override Adaptee behavior. It will require subclassing\nAdaptee and making Adapter refer to the subclass rather than the Adaptee\nitself.\nHere are other issues to consider when using the Adapter pattern:\n1. How much adapting does Adapter do \n? \nAdapters vary in the amount of work they\ndo to adapt Adaptee to the Target interface. There is a spectrum of possible\nwork, from simple interface conversion\u2014for example, changing the names \nof\noperations\u2014to supporting an entirely different set of operations. The amount\nof work Adapter does depends on how similar the Target interface is to\nAdaptee's.\n2. Pluggable adapters. A class is more reusable when you minimize the assump-\ntions other classes must make to use it. By \nbuilding interface adaptation into\na class, you eliminate the assumption that other classes see the same inter-\nface. Put another way, interface adaptation lets us incorporate our class into\nexisting systems that might expect different interfaces to the class. Object-\nWorks\\Smalltalk [Par90] uses the term pluggable adapter to describe classes\nwith built-in interface adaptation.\nConsider a TreeDisplay widget that can display tree structures graphically.\nIf this were a special-purpose widget for use in just one application, then\nwe might require the objects that it displays to have a specific interface; that \nis, all must descend from a Tree abstract class. But if we wanted to make\nTreeDisplay more reusable (say we wanted to make it part of a toolkit of\nuseful widgets), then that requirement would be unreasonable. Applications\nwill define their own classes for tree structures. They shouldn't be forced\nto use our Tree abstract class. Different tree structures will have different\ninterfaces.\n", "page": 162, "type": "text", "section": "Page 162"}
{"text": "ADAPTED \n143\nIn a directory hierarchy, for example, children might be accessed with a\nGetSubdirectories operation, whereas in an inheritance hierarchy, the corre-\nsponding operation might be called GetSubclasses. A reusable TreeDisplay\nwidget must be able to display both kinds of hierarchies even if they use\ndifferent interfaces. In other words, the TreeDisplay should have interface \nadaptation built into it.\nWe'll look at different ways to build interface adaptation into classes in the\nImplementation section.\n3. Using two-way adapters to provide transparency. A potential problem with\nadapters is that they aren't transparent to all clients. An adapted object no\nlonger conforms to the Adaptec interface, so it can't be used as is wherever\nan Adaptec object can. Two-way adapters can provide such transparency. \nSpecifically, they're useful when two different clients need to view an object\ndifferently.\nConsider the two-way adapter that integrates Unidraw, a graphical edi-\ntor framework [VL90], and QOCA, a constraint-solving toolkit [HHMV92].\nBoth systems have classes that represent variables explicitly: Unidraw has\nState \nVariable, and QOCA has ConstraintVariable. To make Unidraw work\nwith QOCA, ConstraintVariable must be adapted to State \nVariable; to let\nQOCA propagate solutions to Unidraw, State \nVariable must be adapted to\nConstraintVariable.\nThe solution involves a two-way class adapter ConstraintStateVariable, a\nsubclass of both State \nVariable and ConstraintVariable, that adapts the two\ninterfaces to each other. Multiple inheritance is a viable solution in this case\nbecause the interfaces of the adapted classes are substantially different. The\ntwo-way class adapter conforms to both of the adapted classes and can work \nin either system.\nImplementation\nAlthough the implementation of Adapter is usually straightforward, here are\nsome issues to keep in mind:\n", "page": 163, "type": "text", "section": "Page 163"}
{"text": "144\nSTRUCTURAL PATTERNS\nCHAPTER 4\n1. Implementing class adapters in C++. In a C++ implementation of a class adapter,\nAdapter would inherit publicly from Target and privately from Adaptec.\nThus Adapter would be a subtype of Target but not of Adaptec.\n2. Pluggable adapters. Let's look at three ways to implement pluggable adapters\nfor the TreeDisplay widget described earlier, which can lay out and display\na hierarchical structure automatically.\nThe first step, which is common to all three of the implementations discussed\nhere, is to find a \"narrow\" interface for Adaptec, that is, the smallest subset\nof operations that lets us do the adaptation. A narrow interface consisting of\nonly a couple of operations is easier to adapt than an interface with dozens\nof operations. For TreeDisplay, the adaptee is any hierarchical structure. A\nminimalist interface might include two operations, one that defines how to\npresent a node in the hierarchical structure graphically, and another that\nretrieves the node's children.\nThe narrow interface leads to three implementation approaches:\n(a) Using abstract operations. Define corresponding abstract operations for the\nnarrow Adaptee interface in the TreeDisplay class. Subclasses must im-\nplement the abstract operations and adapt the hierarchically structured\nobject. For example, a DirectoryTreeDisplay subclass will implement\nthese operations by accessing the directory structure.\nDirectoryTreeDisplay specializes the narrow interface so that it can dis-\nplay directory structures made up of FileSystemEntity objects.\n(b) Using delegate objects. In this approach, TreeDisplay forwards \nrequests for\naccessing the hierarchical structure to a delegate object. TreeDisplay \ncan\nuse a different adaptation strategy by substituting a different delegate.\nFor example, suppose there exists a DirectoryBrowser that uses a Tree-\nDisplay. DirectoryBrowser might make a good delegate for adapting\nTreeDisplay to the hierarchical directory structure. In dynamically typed\nlanguages like Smalltalk or Objective C, this approach only requires an\ninterface for registering the delegate with the adapter. Then TreeDisplay\n", "page": 164, "type": "text", "section": "Page 164"}
{"text": "ADAPTED \n145\nsimply forwards the requests to the delegate. NEXTSTEP [Add94] uses\nthis approach heavily to reduce subclassing.\nStatically typed languages like C++ require an explicit interface defin-\nition for the delegate. We can specify such an interface by putting the\nnarrow interface that TreeDisplay requires into an abstract \nTreeAcces-\nsorDelegate class. Then we can mix this interface into the delegate of\nour choice\u2014DirectoryBrowser in this case\u2014using inheritance. We use\nsingle inheritance if the DirectoryBrowser has no existing parent class,\nmultiple inheritance if it does. Mixing classes together like this is eas-\nier than introducing a new TreeDisplay subclass and implementing its\noperations individually.\n(c) Parameterized adapters. The usual way to support pluggable adapters in\nSmalltalk is to parameterize an adapter with one or more blocks. The\nblock construct supports adaptation without subclassing. A block can\nadapt a request, and the adapter can store a block for each individual\nrequest. In our example, this means TreeDisplay stores one block for\nconverting a node into a GraphicNode and another block for accessing\na node's children.\nFor example, to create TreeDisplay on a directory hierarchy, we write\ndirectoryDisplay := \n(TreeDisplay on: \ntreeRoot) \ngetChildrenBlock:\n[mode | \nnode getSubdirectories]\ncreateGraphicNodeBlock:\n[:node | \nnode createGraphicNode].\nIf you're building interface adaptation into a class, this approach offers\na convenient alternative to subclassing.\n", "page": 165, "type": "text", "section": "Page 165"}
{"text": "146 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nSample Code\nWe'll give a brief sketch of the implementation of class and object adapters for the\nMotivation example beginning with the classes Shape and Text \nView.\nclass Shape {\npublic:\nShape(); \nvirtual void BoundingBox(\nPoint& bottomLeft, Point& topRight \n) const; \nvirtual Manipulator* CreateManipulator() const;\nclass TextView {\npublic:\nTextView(); \nvoid GetOrigin(Coordk x, Coord& y) const; \nvoid GetExtent(Coordk width, Coord& height) const;\nvirtual bool IsEmptyO const;\n};\nShape assumes a bounding box defined by its opposing corners. In contrast,\nTextView is defined by an origin, height, and width. Shape also defines a\nCreateManipulator operation for creating a Manipulator object, which\nknows how to animate a shape when the user manipulates it.1 TextView has\nno equivalent operation. The class Text Shape is an adapter between these dif-\nferent interfaces.\nA class adapter uses multiple inheritance to adapt interfaces. The key to class\nadapters is to use one inheritance branch to inherit the interface and another\nbranch to inherit the implementation. The usual way to make this distinction in\nC++ is to inherit the interface publicly and inherit the implementation privately.\nWe'll use this convention to define the Text Shape adapter.\nclass TextShape : \npublic Shape, private TextView {\npublic:\nTextShape();\nvirtual void BoundingBox(\nPointk bottomLeft, \nPoint& topRight \n) const; \nvirtual bool IsEmptyO const; \nvirtual Manipulator* CreateManipulator() const;\nThe BoundingBox operation converts Textview's interface to conform to\nShape's.\n1 \nCreateManipulator is an example \nof a Factory Method (107).\n", "page": 166, "type": "text", "section": "Page 166"}
{"text": "ADAPTER \n147\nvoid TextShape::BoundingBox (\nPoint& bottomLeft, Point& topRight\n) const {\nCoord bottom, left, \nwidth, height;\nGetOrigin(bottom, left);\nGetExtent(width, height);\nbottomLeft = Point(bottom, left); \ntopRight = Point(bottom + height, left + width);\nThe I sEmpty operation demonstrates the direct forwarding of requests common\nin adapter implementations:\nbool TextShape::IsEmpty () \nconst {\nreturn TextView::IsEmpty();\n}\nFinally, we define CreateManipulator (which isn't supported by TextView)\nfrom scratch. Assume we've already implemented a TextManipulator class\nthat supports manipulation of a TextShape.\nManipulator* TextShape::CreateManipulator () const {\nreturn new TextManipulator(this);\n}\nThe object \nadapter \nuses object \ncomposition to combine classes with different inter-\nfaces. In \nthis approach, the adapter \nText Shape maintains a pointer to Text \nVi ew.\nclass TextShape : \npublic Shape {\npublic:\nTextShape(TextView*);\nvirtual void BoundingBox(\nPoint& bottomLeft, Point& topRight \n) const; \nvirtual bool IsEmpty() const; \nvirtual Manipulator* CreateManipulator() const;\nprivate:\nTextView* _text;\n};\nTextShape must initialize the pointer to the TextView instance, and it does so\nin the constructor. It must also call operations on its TextView object whenever\nits own operations are called. In this example, assume that the client creates the\nTextView object and passes it to the TextShape constructor:\nTextShape::TextShape (TextView* t) {\n_text = t;\n}\n", "page": 167, "type": "text", "section": "Page 167"}
{"text": "148 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nvoid TextShape::BoundingBox \n(\nPoint& bottomLeft, Points topRight\n) const {\nCoord bottom, left, width, height;\n_text->GetOrigin(bottom, left);\n__text->GetExtent \n(width, height) \n;\nbottomLeft = Point(bottom, left); \ntopRight = Point(bottom + height, left + width);\n}\nbool TextShape::IsEmpty () \nconst {\nreturn _text->IsEmpty();\n}\nCreateManipu la tor's implementation doesn't change from the class adapter\nversion, since it's implemented from scratch and doesn't reuse any existing\nText \nView functionality.\nManipulator* TextShape::CreateManipulator () const {\nreturn new TextManipulator(this);\n}\nCompare this code to the class adapter case. The object adapter requires a little\nmore effort to write, but it's more flexible. For example, the object adapter version\nof TextShape will work equally well with subclasses of Text \nView\u2014the client\nsimply passes an instance of a Text View subclass to the TextShape constructor.\nKnown Uses\nThe Motivation example comes from ET++Draw, a drawing application based on \nET++ [WGM88]. ET++Draw reuses the ET++ classes for text editing by using a\nTextShape adapter class.\nInterviews 2.6 defines an Interactor abstract class for user interface elements such\nas scroll bars, buttons, and menus [VL88]. It also defines a Graphic abstract class\nfor structured graphic objects such as lines, circles, polygons, and splines. Both\nInteractors and Graphics have graphical appearances, but they have different \ninterfaces and implementations (they share no common parent class) and are\ntherefore incompatible\u2014you can't embed a structured graphic object in, say, a\ndialog box directly.\nInstead, Interviews 2.6 \ndefines an object adapter called GraphicBlock, a subclass \nof\nInteractor that contains a Graphic instance. The GraphicBlock \nadapts the interface\nof the Graphic class to that of Interactor. \nThe GraphicBlock \nlets a Graphic instance\nbe displayed, scrolled, and zoomed within an Interactor structure.\nPluggable adapters are common in ObjectWorks\\Smalltalk [Par90]. Standard\nSmalltalk defines a ValueModel class for views that display a single value. Val-\nueModel defines a value, value: interface for accessing the value. These are\n", "page": 168, "type": "text", "section": "Page 168"}
{"text": "ADAPTER \n149\nabstract methods. Application writers access the value with more domain-specific\nnames like width and width:, but they shouldn't have to subclass ValueModel\nto adapt such application-specific names to the ValueModel interface.\nInstead, ObjectWorks\\Smalltalk includes a subclass of ValueModel called Plug-\ngableAdaptor. A PluggableAdaptor object adapts other objects to the ValueModel\ninterface (value, value:). It can be parameterized with blocks for getting and\nsetting the desired value. PluggableAdaptor uses these blocks internally to im-\nplement the value, value: interface. PluggableAdaptor also lets you pass in\nthe selector names (e.g., width, width:) directly for syntactic convenience. It\nconverts these selectors into the corresponding blocks automatically.\nAnother example from ObjectWorks\\Smalltalk is the TableAdaptor class. A\nTableAdaptor can adapt a sequence of objects to a tabular presentation. The table\ndisplays one object per row. The client parameterizes TableAdaptor with the set\nof messages that a table can use to get the column values from an object.\nSome classes in NeXT's AppKit [Add94] use delegate objects to perform interface\nadaptation. An example is the NXBrowser \nclass that can display hierarchical lists\nof data. NXBrowser uses a delegate object for accessing and adapting the data.\nMeyer's \"Marriage of Convenience\" [Mey88] is a form of class adapter. Meyer\ndescribes how a FixedStack class adapts the implementation of an Array class to\nthe interface of a Stack class. The result is a stack containing a fixed number of\nentries.\nRelated Patterns\nBridge (151) has a structure similar to an object adapter, but Bridge has a different\nintent: It is meant to separate an interface from its implementation so that they can\nbe varied easily and independently. An adapter is meant to change the interface\nof an existing object.\nDecorator (175) enhances another object without changing its interface. A deco-\nrator is thus more transparent to the application than an adapter is. As a conse-\n", "page": 169, "type": "text", "section": "Page 169"}
{"text": "150 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nquence, Decorator \nsupports recursive composition, which isn't possible with pure\nadapters.\nProxy (207) \ndefines a representative or surrogate for another object and does not\nchange its interface.\n", "page": 170, "type": "text", "section": "Page 170"}
{"text": "BRIDGE \n151\nBRIDGE \nObject Structural\nIntent\nDecouple an abstraction from its implementation so that the two can vary inde-\npendently.\nAlso Known As\nHandle/Body\nMotivation\nWhen an abstraction can have one of several possible implementations, the usual\nway to accommodate them is to use inheritance. An abstract class defines the in-\nterface to the abstraction, and concrete subclasses implement it in different ways.\nBut this approach isn't always flexible enough. Inheritance binds an implemen-\ntation to the abstraction permanently, which makes it difficult to modify, extend,\nand reuse abstractions and implementations independently.\nConsider the implementation of a portable Window abstraction in a user interface\ntoolkit. This abstraction should enable us to write applications that work on both\nthe X \nWindow System and IBM's Presentation Manager (PM), for example. Using\ninheritance, we could define an abstract class Window and subclasses XWindow \nand PMWindow that implement the Window interface for the different platforms.\nBut this approach has two drawbacks:\n1. It's inconvenient to extend the Window abstraction to cover different kinds\nof windows or new platforms. \nImagine an Icon \nWindow subclass of Window\nthat specializes the Window abstraction for icons. To \nsupport Icon \nWindows\nfor both platforms, we have to implement two new classes, XlconWindow\nand PMIconWindow. Worse, we'll have to define two classes for every kind\nof window. Supporting a third platform requires yet another new Window\nsubclass for every kind of window.\n", "page": 171, "type": "text", "section": "Page 171"}
{"text": "152\nSTRUCTURAL PATTERNS\nCHAPTER 4\n2. It makes client code platform-dependent. Whenever a client creates a win-\ndow, it instantiates a concrete class that has a specific implementation. For\nexample, creating an XWindow object binds the Window abstraction to the\nX Window implementation, which makes the client code dependent on the\nX Window implementation. This, in turn, makes it harder to port the client\ncode to other \nplatforms.\nClients should be able to create a window without committing to a con-\ncrete implementation. Only the window implementation should depend on\nthe platform on which the application runs. Therefore client code should\ninstantiate windows without mentioning specific platforms.\nThe Bridge \npattern addresses these problems by putting the Window abstraction\nand its implementation in separate class hierarchies. There is one class hierarchy\nfor window interfaces (Window, \nIconWindow, TransientWindow) and a separate\nhierarchy for platform-specific window implementations, with Windowlmp as its\nroot. The XWindowImp subclass, for example, provides an implementation based\non the X Window System.\nAll operations on Window subclasses are implemented in terms of abstract oper-\nations from the Windowlmp interface. This decouples the window abstractions\nfrom the various platform-specific implementations. We refer to the relationship\nbetween Window and Windowlmp as a bridge, because it bridges the abstraction\nand its implementation, letting them vary independently.\n", "page": 172, "type": "text", "section": "Page 172"}
{"text": "BRIDGE \n153\nApplicability\nUse the Bridge pattern when\n\u2022 you want to avoid a permanent binding between an abstraction and its \nim-\nplementation. This might be the case, for example, when the implementation\nmust be selected or switched at run-time.\n\u2022 both the abstractions and their implementations should be extensible by\nsubclassing. In this case, the Bridge pattern lets you combine the different\nabstractions and implementations and extend them independently.\n\u2022 changes in the implementation of an abstraction should have no impact on\nclients; that is, their code should not have to be recompiled.\n\u2022 (C++) you want to \nhide the \nimplementation of an abstraction completely from\nclients. In C++ the representation of a class is visible in the class interface.\n\u2022 you have a proliferation of classes as shown earlier in the first Motivation\ndiagram. Such a class hierarchy indicates the need for splitting an object into\ntwo parts. Rumbaugh uses the term \"nested generalizations\" [RBP+91] to\nrefer to such class hierarchies.\n\u2022 you \nwant to share an implementation among multiple objects (perhaps using\nreference counting), and this fact should be hidden from the client. A simple\nexample is Coplien's String class [Cop92], in which multiple objects can share\nthe same string representation (StringRep).\nStructure\n", "page": 173, "type": "text", "section": "Page 173"}
{"text": "154 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nParticipants\n\u2022 Abstraction (Window)\n- defines the \nabstraction's interface.\n- maintains a reference to an object of type Implementor.\n\u2022 RefmedAbstraction (IconWindow)\n- Extends the interface defined by \nAbstraction.\n\u2022 Implementor (Windowlmp)\n- defines the interface for implementation classes. This interface doesn't\nhave to correspond exactly to Abstraction's interface; \nin fact the two inter-\nfaces can be quite different. Typically the Implementor interface provides\nonly primitive operations, and Abstraction defines higher-level operations\nbased on these primitives.\n\u2022 Concretelmplementor (XWindowImp, PMWindowImp)\n- implements the Implementor interface and defines its concrete implemen-\ntation.\nCollaborations\n\u2022 Abstraction forwards client requests to its Implementor object.\nConsequences\nThe Bridge pattern has the following consequences:\n1. Decoupling interface and implementation. An implementation is not bound per-\nmanently to an interface. The implementation of an abstraction can be config-\nured at run-time. It's even possible for an object to change its implementation\nat run-time.\nDecoupling Abstraction and Implementor also eliminates compile-time\ndependencies on the implementation. Changing an implementation class\ndoesn't require recompiling the Abstraction class and its clients. This prop-\nerty is essential when you must ensure binary compatibility between differ-\nent versions of a class library.\nFurthermore, this decoupling encourages layering that can lead to a better-\nstructured system. The high-level part of a system only has to know about\nAbstraction and Implementor.\n2. Improved extensibility. You can extend the Abstraction and Implementor hier-\narchies independently.\n3. Hiding implementation details from clients. You can shield clients from imple-\nmentation details, like the sharing of implementor objects and the accompa-\nnying reference count mechanism (if \nany).\n", "page": 174, "type": "text", "section": "Page 174"}
{"text": "BRIDGE \n155\nImplementation\nConsider the following implementation issues when applying the Bridge pattern:\n1. Only one Implementor. In situations where there's only one implementation,\ncreating an abstract Implementor class isn't necessary. This is a degenerate\ncase of the Bridge pattern; there's a one-to-one relationship between Ab-\nstraction and Implementor. Nevertheless, this separation is still useful when\na change in the implementation of a class must not affect its existing clients\u2014\nthat is, they shouldn't have to be recompiled, just relinked.\nCarolan [Car89] uses the term \"Cheshire Cat\" to describe this separation. In\nC++, the class interface of the Implementor class can be defined in a private\nheader file that isn't provided to clients. This lets you hide an implementation \nof a class completely from its clients.\n2. Creating the right Implementor object. How, when, and where do you decide\nwhich Implementor class to instantiate when there's more than one?\nIf Abstraction knows about all Concretelmplementor classes, then it can\ninstantiate one of them in its constructor; it can decide between them based\non parameters passed to its constructor. If, for example, a collection class\nsupports multiple implementations, the decision can be based on the size of\nthe collection. A linked list implementation can be used for small collections\nand a hash table for larger ones.\nAnother approach is to choose a default implementation initially and change\nit later according to usage. For example, if the collection grows bigger than\na certain threshold, then it switches its implementation to one that's more\nappropriate for a large number of items.\nIt's also possible to delegate the decision to another object altogether. In\nthe Window/Windowlmp example, we can introduce a factory object (see\nAbstract Factory (87)) whose sole duty is to encapsulate platform-specifics.\nThe factory knows what kind of Windowlmp object to create for the platform\nin use; a Window simply asks it for a Windowlmp, and it returns the right\nkind. A benefit of this approach is that Abstraction is not coupled directly to\nany of the Implementor classes.\n3. Sharing implementors. Coplien illustrates how the Handle/Body idiom in \nC++\ncan be used to share implementations among several objects [Cop92]. The\nBody stores a reference count that the Handle class increments and decre-\nments. The code for assigning handles with shared bodies has the following\ngeneral form:\n", "page": 175, "type": "text", "section": "Page 175"}
{"text": "156 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nHandle& Handle::operator= (const Handle& other) {\nother._body->Ref(); \n_body->Unref();\nif (_body->RefCount() == 0) {\ndelete _body;\n} \n_body = other._body;\nreturn *this;\n4. Using multiple inheritance. You can use multiple inheritance in C++ to combine\nan interface \nwith its implementation [Mar91]. For \nexample, a class can inherit \npublicly from Abstraction and privately from a Concretelmplementor. But\nbecause this approach relies on static \ninheritance, it binds an implementation\npermanently to its interface. Therefore you can't implement a true Bridge\nwith multiple inheritance\u2014at least not in \nC++.\nSample Code\nThe following C++ code implements the Window/Windowlmp example from the\nMotivation section. The Window class defines the window abstraction for client\napplications:\nclass Window {\npublic:\nWindow(View* contents);\n/\n'\n/ requests handled by window\nvirtual void DrawContents();\nvirtual void Open();\nvirtual void Close();\nvirtual void IconifyO;\nvirtual void Deiconify();\n// requests forwarded to implementation\nvirtual void SetOrigin(const Points at);\nvirtual void SetExtent(const Point& extent);\nvirtual void Raise(); \nvirtual void Lower();\nvirtual void DrawLine(const Point&, const Point&);\nvirtual void DrawRect(const Point&, const Point&);\nvirtual void DrawPolygon(const Point[], int n);\nvirtual void DrawText(const char*, const Point&);\nprotected:\nWindowlmp* GetWindowImp();\nView* GetViewO;\n", "page": 176, "type": "text", "section": "Page 176"}
{"text": "BRIDGE \n157\nprivate:\nWindowlmp* _imp;\nView* _contents; // the window's contents\n};\nWindow maintains a reference to a Windowlmp, the abstract class that declares an\ninterface to the underlying windowing system.\nclass Windowlmp \n{\npublic:\nvirtual void ImpTop() = 0; \nvirtual void ImpBottom() = 0; \nvirtual void ImpSetExtent(const Point&) = 0; \nvirtual void ImpSetOrigin(const Point&) = 0;\nvirtual void DeviceRect(Coord, Coord, Coord, Coord) = 0 \n;\nvirtual void DeviceText(const char*, Coord, Coord) = 0;\nvirtual void DeviceBitmap(const char*, Coord, Coord) = 0; \n// lots more functions for drawing on windows...\nprotected:\nWindowlmp();\n};\nSubclasses of Window define the different kinds of windows the application might\nuse, such as application windows, icons, transient windows for dialogs, floating\npalettes of tools, and so on.\nFor example, Applicat ionWindowwill implement DrawContents to draw the\nView instance it stores:\nclass ApplicationWindow : \npublic Window {\npublic:\n// . . . \nvirtual void DrawContents();\n};\nvoid ApplicationWindow::DrawContents () \n{\nGetView()->DrawOn(this);\n}\nIconWindow stores the name of a bitmap for the icon it displays...\nclass IconWindow : \npublic Window {\npublic:\n// . . . \nvirtual void DrawContents();\nprivate: \nconst char* _bitmapName;\n};\n...and it implements DrawContents to draw the bitmap on the window:\n", "page": 177, "type": "text", "section": "Page 177"}
{"text": "158 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nvoid IconWindow::DrawContents() \n{ \nWindowlmp* imp - GetWindowImp();\nif (imp != 0) {\nimp->DeviceBitmap(_bitmapName, 0.0, 0.0);\n}\n}\nMany other variations of Window are possible. A TransientWindow may need\nto communicate \nwith the window that created it during the dialog; hence it keeps \na\nreference to that \nwindow. A Pa \n1 e \n1\n1 eWindow always \nfloats \nabove other windows.\nAn IconDockWindowholds IconWindows and arranges them neatly.\nWindow operations are defined in terms of the Windowlmp interface. For example,\nDrawRec \nt extracts four coordinates from its \ntwo Point parameters before calling\nthe Windowlmp operation that draws the rectangle in the window:\nvoid Window::DrawRect (const Points pi, const Point& p2) {\nWindowlmp* imp = GetWindowImp();\nimp->DeviceRect(pl.X() \n, \npl.YO, p2.X(), \np2.Y(\u00bb;\n}\nConcrete subclasses of Windowlmp support different window systems. The\nXWindowImp subclass supports the X \nWindow System:\nclass XWindowImp : \npublic Windowlmp {\npublic:\nXWindowImp () ,\n-\nvirtual void DeviceRect(Coord, Coord, Coord, Coord);\n// remainder of public interface...\nprivate:\n// lots of X window system-specific state, including:\nDisplay* _dpy;\nDrawable _winid; // \nwindow id \nGC _gc; \n// \nwindow graphic context\n};\nFor Presentation Manager (PM), we define a PMWindowlmp class:\nclass PMWindowlmp : \npublic Windowlmp {\npublic:\nPMWindowlmp(); \nvirtual void DeviceRect(Coord, Coord, Coord, Coord);\n// remainder of public interface...\nprivate:\n// lots of PM window system-specific state, including:\nHPS _hps;\n};\nThese subclasses implement Windowlmp operations in terms of window system\nprimitives. For example, DeviceRect is implemented for X \nas follows:\n", "page": 178, "type": "text", "section": "Page 178"}
{"text": "BRIDGE \n159\nvoid XWindowImp::DeviceRect (\nCoord xO, Coord yO, Coord xl, Coord yl\n) \n{\nint x = round(min(xO, xl)); \nint y = round(min(yO, yl)); \nint w = round(abs(xO - xl)); \nint h = round(abs(yO - \nyl));\nXDrawRectangle(_dpy, _winid, _gc, x, y, w, h);\n}\nThe PM implementation might look like this:\nvoid PMWindowImp::DeviceRect \n(\nCoord xO, Coord yO, Coord xl, Coord yl\n) {\nCoord left = min(xO, xl) \n;\nCoord right = max(xO, xl);\nCoord bottom = min(yO, yl) \n;\nCoord top = maxfyO, yl) ;\nPPOINTL point[4];\npoint[0].x = left;\npoint[0].y = top;\npoint[l].x = right;\npoint[1].y = top;\npoint[2].x = right;\npoint[2].y = \nbottom;\npoint[3].x = left;\npoint[3].y = bottom;\nif ( \n(GpiBeginPath(_hps, 1L) == false) |\n|\n(GpiSetCurrentPosition(_hps, &point[3]) == false)\n(GpiPolyLine(_hps, 4L, point) == GPI_ERROR) || \n(GpiEndPath(_hps) == false)\n) { \n// report error\n} else \n{\nGpiStrokePath(_hps, 1L, OL);\n}\nHow does a window obtain an instance of the right Windowlmp subclass? We'll\nassume Window has that responsibility in this example. Its GetWindowImp op-\neration gets the right instance from an abstract factory (see Abstract Factory (87))\nthat effectively encapsulates all window system specifics.\nWindowlmp* Window::GetWindowImp () \n{\nif (_imp = = 0 ) {\n_imp = WindowSystemFactory::Instance()->MakeWindowImp();\n}\nreturn _imp;\n}\n", "page": 179, "type": "text", "section": "Page 179"}
{"text": "160 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nWindowSystemFactory: : Instance ( ) returns an abstract factory that manu-\nfactures all window system-specific objects. For simplicity, we've made it a Sin-\ngleton (127) \nand have let the Window class access the factory directly.\nKnown Uses\nThe Window example above comes from ET++ [WGM88]. In ET++, Windowlmp\nis called \"WindowPort\" and has subclasses such as XWindowPort \nand SunWin-\ndowPort. The Window object creates its corresponding Implementor object by\nrequesting it from an abstract factory called \"WindowSystem.\" WindowSystem\nprovides an interface for creating platform-specific objects such as fonts, cursors,\nbitmaps, and so forth.\nThe ET++ Window/WindowPort design extends the Bridge pattern in that the\nWindowPort also keeps a reference back to the Window. The WindowPort im-\nplementor class uses this reference to notify Window about \nWindowPort-specific\nevents: the arrival of input events, window resizes, etc.\nBoth Coplien [Cop92] and Stroustrup [Str91] mention Handle classes and give\nsome examples. Their examples emphasize memory management issues like shar-\ning string representations and support for variable-sized objects. \nOur focus is more\non supporting independent extension of both an abstraction and its implementa-\ntion.\nlibg++ [Lea88] defines \nclasses that implement common data structures, such as Set,\nLinkedSet, HashSet, LinkedList, and HashTable. Set \nis an abstract class that defines\na set abstraction, while LinkedList and HashTable are concrete implementors\nfor a linked list and a hash table, respectively. LinkedSet and HashSet are Set\nimplementors that bridge between Set and their concrete counterparts \nLinkedList\nand HashTable. This is an example of a degenerate bridge, because there's no\nabstract Implementor class.\nNeXT's AppKit [Add94] uses the Bridge pattern in the implementation and dis-\nplay of graphical images. An image can be represented in several different ways.\nThe optimal display of an image depends on the properties of a display device,\nspecifically its color capabilities and its resolution. Without help from AppKit,\ndevelopers would have to determine which implementation to use under various\ncircumstances in every application.\nTo relieve developers of this responsibility, AppKit provides an NXIm-\nage/NXImageRep bridge. NXImage defines the interface for handling images.\nThe implementation of images is defined in a separate NXImageRep class hi-\nerarchy having subclasses such as NXEPSImageRep, NXCachedlmageRep, and\nNXBitMapImageRep. NXImage maintains a reference to one or more NXIm-\nageRep objects. If there is more than one image implementation, then NXImage\nselects the most appropriate one for the current display device. NXImage \nis even\ncapable of converting one implementation to another if necessary. The interesting\n", "page": 180, "type": "text", "section": "Page 180"}
{"text": "BRIDGE \n161\naspect of this Bridge variant is that NXImage can store more than one NXIrn-\nageRep implementation at a time.\nRelated Patterns\nAn Abstract Factory (87) \ncan create and configure a particular \nBridge.\nThe Adapter (139) pattern is geared toward making unrelated classes work to-\ngether. It is usually applied to systems after they're designed. Bridge, on the other\nhand, is used up-front in a design to let abstractions and implementations vary\nindependently.\n", "page": 181, "type": "text", "section": "Page 181"}
{"text": "This page intentionally left blank \n", "page": 182, "type": "text", "section": "Page 182"}
{"text": "COMPOSITE \n163\nCOMPOSITE\nObject Structural\nIntent\nCompose objects into tree structures to represent part-whole hierarchies. Com-\nposite lets clients treat individual objects and compositions of objects uniformly.\nMotivation\nGraphics applications like drawing editors and schematic capture systems let\nusers build complex diagrams out of simple components. The user can group\ncomponents to form larger components, which in turn can be grouped to form still\nlarger components. A simple implementation could define classes for graphical\nprimitives such as Text and Lines plus other classes that act as containers for these\nprimitives.\nBut there's a problem with this approach: Code that uses these classes must treat\nprimitive and container objects differently, even if most of the time the user treats\nthem identically. Having to distinguish these objects makes the application more\ncomplex. The Composite pattern describes how to use recursive composition so\nthat clients don't have to make this distinction.\nThe key to the Composite pattern is an abstract class that represents both primi-\ntives and their containers. For the graphics system, this class is Graphic. Graphic\ndeclares operations like Draw that are specific to graphical objects. It also declares\noperations that all composite objects share, such as operations for accessing and \nmanaging its children.\n", "page": 183, "type": "text", "section": "Page 183"}
{"text": "164\nSTRUCTURAL PATTERNS\nCHAPTER 4\nThe subclasses Line, Rectangle, and Text (see preceding class diagram) define\nprimitive graphical objects. These classes implement Draw to draw lines, rectan-\ngles, and text, respectively. Since primitive graphics have no child graphics, none\nof these subclasses implements child-related operations.\nThe Picture class defines an aggregate of Graphic objects. Picture implements\nDraw to call Draw on its children, and it implements child-related operations ac-\ncordingly. Because \nthe Picture interface \nconforms to the Graphic interface, Picture\nobjects can compose other Pictures recursively.\nThe following diagram shows a typical composite object structure of recursively\ncomposed Graphic \nobjects:\nApplicability\nUse the Composite pattern when\n\u2022 you want to represent part-whole hierarchies of \nobjects.\n\u2022 you want clients to be able to ignore the difference between compositions of\nobjects and individual objects. Clients will treat all objects in the composite\nstructure uniformly.\nStructure\n", "page": 184, "type": "text", "section": "Page 184"}
{"text": "COMPOSITE \n165\nA typical Composite object structure might look like this:\nParticipants\n\u2022 Component (Graphic)\n-\ndeclares the interface for objects in the composition.\n-\nimplements default behavior for the interface common to all classes, as\nappropriate.\n-\ndeclares an interface for accessing and managing its child components.\n- (optional) defines an interface for accessing a component's parent in the\nrecursive structure, and implements it if that's appropriate.\n\u2022 Leaf (Rectangle, Line, Text, etc.)\n- represents leaf objects in the composition. A leaf has no children.\n- defines behavior for primitive objects in the composition.\n\u2022 Composite (Picture)\n-\ndefines behavior for components having children.\n-\nstores child components.\n-\nimplements child-related operations in the \nComponent interface.\n\u2022 Client\n- manipulates objects \nin the composition through the Component interface.\nCollaborations\n\u2022 Clients use the Component class interface to interact with objects in the com-\nposite structure. If the recipient is a Leaf, then the request is handled directly.\nIf the recipient is a Composite, then it usually forwards requests to its child\ncomponents, possibly performing additional operations before and/or after\nforwarding.\n", "page": 185, "type": "text", "section": "Page 185"}
{"text": "166 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nConsequences\nThe Composite pattern\n\u2022 defines class hierarchies consisting of primitive objects and composite ob-\njects. Primitive objects can be composed into more complex objects, which in\nturn can be composed, and so on recursively. Wherever client code expects a\nprimitive object, it can also take a composite object.\n\u2022 makes the client simple. Clients can treat composite structures and indi-\nvidual objects uniformly. Clients normally don't know (and shouldn't care)\nwhether they're dealing with a leaf or a composite component. This simplifies\nclient code, because it avoids having to write tag-and-case-statement-style\nfunctions over the classes that define the composition.\n\u2022 makes it easier to add new kinds of components. Newly defined Composite\nor Leaf subclasses work automatically with existing structures and client\ncode. Clients don't have to be changed for new Component classes.\n\u2022 can make your design overly general. The disadvantage of making it easy\nto add new components is that it makes it harder to restrict the components\nof a composite. Sometimes you want a composite to have only certain com-\nponents. With Composite, you can't rely on the type system to enforce those\nconstraints for you. You'll \nhave to use run-time checks instead.\nImplementation\nThere are many issues to consider when implementing the Composite pattern:\n1. Explicit parent references. Maintaining references from child components to\ntheir parent can simplify the traversal and management of a composite struc-\nture. The parent reference simplifies moving up the structure and deleting\na component. Parent references also help support the Chain of Responsibil-\nity (223) pattern.\nThe usual place to define the parent reference is in the Component class.\nLeaf and Composite classes can inherit the reference and the operations that\nmanage it.\nWith parent references, \nit's essential to maintain the invariant that all children\nof a composite have as their parent the composite that in turn has them as\nchildren. The easiest way to ensure this is to change a component's parent\nonly when it's being added or removed from a composite. If this can be\nimplemented once in the Add and Remove operations of the Composite\nclass, then it can be inherited by all the subclasses, and the invariant will be\nmaintained automatically.\n2. Sharing components. It's often useful to share components, for example, to\nreduce storage requirements. But \nwhen a component can have no more than\none parent, sharing components becomes difficult.\n", "page": 186, "type": "text", "section": "Page 186"}
{"text": "COMPOSITE \n167\nA possible solution is for children to store multiple parents. But that can lead\nto ambiguities as a request propagates up the structure. The Flyweight \n(195)\npattern shows how to rework a design to avoid storing parents altogether. It\nworks in cases where children can avoid sending parent requests by exter-\nnalizing some or all of their state.\n3. Maximizing the Component interface. One of the goals of the Composite pattern\nis to make clients unaware of the specific Leaf or Composite classes they're\nusing. To \nattain this goal, the Component class should define as many com-\nmon operations for Composite and Leaf classes as possible. The Component\nclass usually provides default implementations for these operations, and\nLeaf and Composite subclasses will override them.\nHowever, this goal will sometimes conflict with the principle of class hierar-\nchy design that says a class should only define operations that are meaningful \nto its subclasses. There are many operations that Component supports that\ndon't seem to make sense for Leaf classes. How can Component provide a\ndefault implementation for them?\nSometimes a little creativity shows how an operation that would appear to\nmake sense only for Composites can be implemented for all Components by\nmoving it to the Component class. For example, the interface for accessing\nchildren is a fundamental part of a Composite class but not necessarily Leaf\nclasses. But if we view a Leaf as a Component that never has children, then we\ncan define a default operation for child access in the Component class that\nnever returns any children. Leaf classes can use the default implementation,\nbut Composite classes will reimplement it to return their children.\nThe child management operations are more troublesome and are discussed\nin the next item.\n4. Declaring the child management operations. Although the Composite class imple-\nments the Add and Remove operations for managing children, an important\nissue in the Composite pattern is which classes declare these operations in the\nComposite class hierarchy. Should we declare these operations in the Com-\nponent and make them meaningful for Leaf classes, or should we declare\nand define them only in Composite and its subclasses?\nThe decision involves a trade-off between safety and transparency:\n\u2022 Defining the child management interface at the root of the class \nhierarchy\ngives you transparency, because you can treat all components uniformly.\nIt costs you safety, however, because clients may try to do meaningless\nthings like add and remove objects from leaves.\n\u2022 Defining child management in the Composite class gives you safety,\nbecause any attempt to add or remove objects from leaves will be caught\nat compile-time in a statically typed language like C++. But you lose\ntransparency, because leaves and composites have different interfaces.\n", "page": 187, "type": "text", "section": "Page 187"}
{"text": "168 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nWe have emphasized transparency over safety in this pattern. If you opt for\nsafety, then at times you may lose type information and have to convert a\ncomponent into a composite. How can you do this without resorting to a\ntype-unsafe cast?\nOne approach is to declare an operation Composite* GetComposite ( ) in\nthe Component class. Component provides a default operation that returns\na null pointer. The Composite class redefines this operation to return itself\nthrough the \nthis pointer:\nclass \nComposite;\nclass Component {\npublic:\n//. \n. . \nvirtual Composite* \nGetComposite() { \nreturn 0; }\n};\nclass Composite : \npublic Component {\npublic:\nvoid Add(Component*);\n// . . .\nvirtual Composite* GetComposite() { \nreturn this; \n}\n};\nclass Leaf : \npublic Component {\n// . . .\n};\nGetComposite lets you query a component to see if it's a composite. You\ncan perform Add and Remove safely on the composite it returns.\nComposite* aComposite = new Composite;\nLeaf* aLeaf = new Leaf;\nComponent \n* aComponent;\nComposite* test;\naComponent = \naComposite; \nif (test = aComponent->GetComposite()) {\ntest->Add(new Leaf);\n}\naComponent = aLeaf ,\n-\nif (test = aComponent->GetComposite()) {\ntest->Add(new Leaf); // will not add leaf\n}\nSimilar tests for a Composite can be done using the C++ dynamic-cast\nconstruct.\nOf course, the problem here is that we don't treat all components uniformly. \nWe have to revert to testing for different types before taking the appropriate\naction.\n", "page": 188, "type": "text", "section": "Page 188"}
{"text": "COMPOSITE \n169\nThe only way to provide transparency is to define default Add and Remove\noperations in Component. That creates a new problem: There's no way to im-\nplement Component: : \nAdd \nwithout introducing the possibility of it failing.\nYou could make it do nothing, but that ignores an important consideration;\nthat is, an attempt to add something to a leaf probably indicates a bug. In\nthat case, the Add operation produces garbage. You could make it delete its\nargument, but that might not be what clients expect.\nUsually it's better to make Add and Remove fail by default (perhaps by\nraising an exception) if the component isn't allowed to have children or if\nthe argument of Remove isn't a child of the component, respectively.\nAnother alternative is to change the meaning of \"remove\" slightly. If\nthe component maintains a parent reference, then we could redefine \nComponent: : \nRemove to remove itself from its parent. However, there still\nisn't a meaningful interpretation for a corresponding Add.\n5. Should Component implement a list of Components? You might be tempted to\ndefine the set of children as an instance variable in the Component class\nwhere the child access and management operations are declared. But putting\nthe child pointer in the base class incurs a space penalty for every leaf, even\nthough a leaf never has children. This is worthwhile only if there are \nrelatively\nfew children in the structure.\n6. Child ordering. Many designs specify an ordering on the children of Com-\nposite. In the earlier Graphics example, ordering may reflect front-to-back\nordering. If Composites represent parse trees, then compound statements\ncan be instances of a Composite whose children must be ordered to reflect\nthe program.\nWhen child ordering is an issue, you must design child access and man-\nagement interfaces carefully to manage the sequence of children. The Itera-\ntor (257) \npattern can guide you in this.\n7. Caching to improve performance. If you need to traverse or search compositions\nfrequently, the Composite class can cache traversal or search information\nabout its children. The Composite can cache actual results or just \ninformation\nthat lets it short-circuit the traversal or search. For example, the Picture class\nfrom the Motivation example could cache the bounding box of its children.\nDuring drawing or selection, this cached bounding box lets the Picture avoid\ndrawing or searching when its children aren't visible in the current window.\nChanges to a component will require invalidating the caches of its parents.\nThis works best when components know their parents. So if you're using\ncaching, you need to define an interface for telling composites that their\ncaches are invalid.\n8. Who should delete components? In languages without garbage collection, it's\nusually best to make a Composite responsible for deleting its children when\nit's destroyed. An exception to this rule is when Leaf objects are immutable\nand thus can be shared.\n", "page": 189, "type": "text", "section": "Page 189"}
{"text": "170 \nSTRUCTURAL PATTERNS \nCHAPTER 4\n9. What's the best data structure for storing components? Composites may use a\nvariety of data structures to store their children, including linked lists, trees,\narrays, and hash tables. The choice of data structure depends (as always) on\nefficiency. In fact, it isn't even necessary to use a general-purpose data struc-\nture at all. Sometimes composites have a variable for each child, although\nthis requires each subclass of Composite to implement its own management\ninterface. See Interpreter (243) \nfor an example.\nSample Code\nEquipment such as computers and stereo components are often organized into\npart-whole or containment hierarchies. For example, a chassis can contain drives\nand planar boards, a bus can contain cards, and a cabinet can contain chassis,\nbuses, and so forth. Such structures can be modeled naturally with the Composite\npattern.\nEquipment class defines an interface for all equipment in the part-whole hierar-\nchy.\nclass Equipment {\npublic:\nvirtual \"Equipment();\nconst char* Name() { \nreturn _name; }\nvirtual Watt Power(); \nvirtual Currency NetPrice();\nvirtual Currency \nDiscountPrice();\nvirtual void Add(Equipment*); \nvirtual void Remove(Equipment*); \nvirtual Iterator<Equipment*>* Createlterator();\nprotected:\nEquipment(const char*);\nprivate:\nconst char* _name;\n};\nEquipment declares operations that return the attributes of a piece of equipment,\nlike its power consumption and cost. Subclasses implement these operations for\nspecific kinds of equipment. Equipment also declares a Createlterator op-\neration that returns an Iterator (see Appendix C) for accessing its parts. The\ndefault implementation for this operation returns a Nulllterator, which iterates\nover the empty set.\nSubclasses of Equipment might include Leaf classes that represent disk drives,\nintegrated circuits, and switches:\n", "page": 190, "type": "text", "section": "Page 190"}
{"text": "COMPOSITE \n171\nclass FloppyDisk : \npublic Equipment {\npublic:\nFloppyDisk(const char*);\nvirtual \"FloppyDisk();\nvirtual Watt Power(); \nvirtual Currency NetPrice();\nvirtual Currency DiscountPrice();\n};\nCompos \niteEquipment is the base class for equipment that contains \nother equip-\nment. It's also a subclass of Equipment.\nclass CompositeEquipment : \npublic Equipment {\npublic:\nvirtual ~CompositeEquipment();\nvirtual Watt Power(); \nvirtual Currency NetPrice(); \nvirtual Currency DiscountPrice();\nvirtual void Add(Equipment*); \nvirtual void Remove(Equipment*); \nvirtual Iterator<Equipment*>* Createlterator();\nprotected:\nCompositeEquipment(const char*);\nprivate:\nList<Equipment*> _equipment;\n};\nCompos iteEquipment defines the operations for accessing and managing\nsubequipment. The operations Add and Remove insert and delete equip-\nment from the list of equipment stored in the .equipment member. The\noperation Createlterator returns an iterator (specifically, an instance of\nListlterator) that will traverse this list.\nA default implementation of \nNetPrice might use Createlterator to sum the\nnet prices of the subequipment2:\nCurrency CompositeEquipment::NetPrice () \n{\nIterator<Equipment*>* i = Createlterator();\nCurrency total = 0;\nfor (i->First(); !i->IsDone(); i->Next()) {\ntotal += i->Current!tem()->NetPrice();\n} \ndelete i;\nreturn total;\n}\n2 It's easy to forget to delete the iterator \nonce you're done with it. The Iterator \npattern shows how to guard\nagainst such bugs on page 266.\n", "page": 191, "type": "text", "section": "Page 191"}
{"text": "172 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nNow we can \nrepresent a computer chassis as a subclass of Compos i teEquipment\ncalled Chassis. Chassis inherits the child-related operations from Com-\npos \niteEquipment.\nclass Chassis : \npublic CompositeEquipment {\npublic:\nChassis(const char*);\nvirtual \"Chassis();\nvirtual Watt Power(); \nvirtual Currency NetPrice();\nvirtual Currency DiscountPrice();\n};\nWe can define other equipment containers such as Cabinet and Bus in a similar\nway. That gives us everything we need to assemble equipment into a (pretty\nsimple) personal computer:\nCabinet* cabinet = new Cabinet(\"PC Cabinet\");\nChassis* chassis = new Chassis(\"PC Chassis\");\ncabinet->Add(chassis);\nBus* bus = new Bus(\"MCA Bus\");\nbus->Add(new Card(\"16Mbs Token Ring\"));\nchassis->Add(bus); \nchassis->Add(new FloppyDisk(\"3.Bin Floppy\"));\ncout \n\u00ab \"The net \nprice \nis \" \n\u00ab chassis->NetPrice() \n\u00ab \nendl;\nKnown Uses\nExamples of the Composite pattern can be found in almost all object-oriented\nsystems. The original View class of Smalltalk Model/View/Controller [KP88]\nwas a Composite, and nearly every user interface toolkit or framework has fol-\nlowed in its steps, including ET++ (with its VObjects [WGM88]) and Interviews\n(Styles [LCI+92], Graphics [VL88], and Glyphs [CL90]). It's interesting to note\nthat the original View of Model/View/Controller had a set of subviews; in other\nwords, View was both the Component class and the Composite class. Release \n4.0\nof Smalltalk-80 revised Model/View/Controller with a VisualComponent class\nthat has subclasses View and Composite \nView.\nThe RTL Smalltalk compiler framework [JML92] uses the Composite pattern ex-\ntensively. RTLExpression is a Component class for parse trees. It has subclasses, \nsuch as BinaryExpression, that contain child RTLExpression objects. \nThese classes\ndefine a composite structure for parse trees. RegisterTransfer is the Component\nclass for a program's intermediate Single Static Assignment (SSA) form. Leaf\nsubclasses of RegisterTransfer define different static assignments such as\n", "page": 192, "type": "text", "section": "Page 192"}
{"text": "COMPOSITE \n173\n\u2022 primitive assignments that perform an operation on two registers and assign\nthe result to a third;\n\u2022 an assignment with a source register but no destination register, which indi-\ncates that the register is used after a routine returns; and\n\u2022 an assignment with a destination register but no source, which indicates that\nthe register is assigned before the routine starts.\nAnother subclass, RegisterTransferSet, is a Composite class for representing as-\nsignments that change several registers at once.\nAnother example of this pattern occurs in the financial domain, where a portfolio\naggregates individual assets. You can support complex aggregations of assets by\nimplementing a portfolio as a Composite that conforms to the interface of an\nindividual asset [BE93].\nThe Command (233) pattern describes how Command objects can be composed\nand sequenced with a MacroCommand Composite class.\nRelated Patterns\nOften the component-parent link is used for a Chain of Responsibility (223).\nDecorator (175) is often used with Composite. When decorators and composites\nare used together, they will usually have a common parent class. So decorators\nwill have to support the Component interface with operations like Add, Remove,\nand GetChild.\nFlyweight (195) lets you share components, but they can no longer refer to their\nparents.\nIterator (257) \ncan be used to traverse composites.\nVisitor (331) localizes \noperations and behavior that would otherwise be distributed\nacross Composite and Leaf classes.\n", "page": 193, "type": "text", "section": "Page 193"}
{"text": "This page intentionally left blank \n", "page": 194, "type": "text", "section": "Page 194"}
{"text": "DECORATOR \n175\nDECORATOR\nObject Structural\nIntent\nAttach additional responsibilities to an object dynamically. Decorators provide a\nflexible alternative to subclassing for extending functionality.\nAlso Known As\nWrapper\nMotivation\nSometimes we want to add responsibilities to individual objects, not to an entire\nclass. A graphical user interface toolkit, for example, should let you add properties\nlike borders or behaviors like scrolling to any user interface component.\nOne way to add responsibilities is with inheritance. Inheriting a border from\nanother class puts a border around every subclass instance. This is inflexible,\nhowever, because the choice of border is made statically. A client can't control\nhow and when to decorate the component with a border.\nA more flexible approach is to enclose the component in another object that adds\nthe border. The enclosing object is called a decorator. The decorator conforms to \nthe interface of the component it decorates so that its presence is transparent to the\ncomponent's clients. The decorator forwards requests to the component and may \nperform additional actions (such as drawing a border) before or after forwarding.\nTransparency lets you nest decorators recursively, thereby allowing an unlimited\nnumber of added responsibilities.\n", "page": 195, "type": "text", "section": "Page 195"}
{"text": "176\nSTRUCTURAL PATTERNS\nCHAPTER 4\nFor example, suppose we have a Text \nView object that displays text in a window.\nText \nView has no scroll bars by default, because we might not always need them.\nWhen we do, we can use a ScrollDecorator to add them. Suppose we also want to\nadd a thick black border around the Text \nView. We can use a BorderDecorator to\nadd this as well. We \nsimply compose the decorators with the Text \nView to produce \nthe desired result.\nThe following object diagram shows how to compose a Text \nView object with \nBorderDecorator and ScrollDecorator objects to produce a bordered, scrollable\ntext view:\nThe ScrollDecorator and BorderDecorator classes are subclasses of Decorator, an\nabstract class for visual components that decorate other visual components.\nVisualComponent is the abstract class for visual objects. It defines their drawing\nand event handling interface. Note how the Decorator class simply forwards\ndraw requests to its component, and how Decorator subclasses can extend this\noperation.\nDecorator subclasses are free to add operations for specific functionality. For ex-\nample, ScrollDecorator's ScrollTo operation lets other objects scroll the interface\nif they know there happens to be a ScrollDecorator object in the interface. The\nimportant aspect of this pattern is that it lets decorators appear anywhere a Vi-\nsualComponent can. That way clients generally can't tell the difference between\n", "page": 196, "type": "text", "section": "Page 196"}
{"text": "DECORATOR \n177\na decorated component and an undecorated one, and so they don't depend at all\non the decoration.\nApplicability\nUse Decorator\n\u2022 to add responsibilities to individual objects dynamically and transparently,\nthat is, without affecting other objects.\n\u2022 for responsibilities that can be withdrawn.\n\u2022 when extension by subclassing is impractical. Sometimes a large number\nof independent extensions are possible and would produce an explosion of\nsubclasses to support every combination. Or a class definition maybe hidden\nor otherwise unavailable for subclassing.\nStructure\nParticipants\n\u2022 Component (VisualComponent)\n- defines the interface for objects that can have responsibilities added to\nthem dynamically.\n\u2022 ConcreteComponent (TextView)\n- defines an object to which additional responsibilities can \nbe attached.\n\u2022 Decorator\n- maintains a reference to a Component object and defines an interface that\nconforms to Component's interface.\n", "page": 197, "type": "text", "section": "Page 197"}
{"text": "178 \nSTRUCTURAL PATTERNS \nCHAPTER 4\n\u2022 ConcreteDecorator (BorderDecorator, ScrollDecorator)\n- adds responsibilities to \nthe \ncomponent.\nCollaborations\n\u2022 Decorator forwards requests to its Component object. It may optionally per-\nform additional operations before and after forwarding the request.\nConsequences\nThe Decorator pattern has at least two key benefits and two liabilities:\n1. More flexibility than static inheritance. The Decorator pattern provides a more\nflexible way to add responsibilities to objects than can be had with static\n(multiple) inheritance. With decorators, responsibilities can be added and\nremoved at run-time simply by attaching and detaching them. In contrast,\ninheritance requires creating a new class for each additional responsibil-\nity (e.g., BorderedScrollableTextView, BorderedTextView). This gives rise to\nmany classes and increases the complexity of a system. Furthermore, provid-\ning different Decorator classes for a specific Component class lets you mix\nand match responsibilities.\nDecorators also make it easy to add a property twice. For example, to give\na Text \nView a double border, simply attach two BorderDecorators. Inheriting \nfrom a Border class twice is error-prone at best.\n2. Avoids feature-laden classes high up in the hierarchy. Decorator offers a pay-\nas-you-go approach to adding responsibilities. Instead of trying to support\nall foreseeable features in a complex, customizable class, you can define\na simple class and add functionality incrementally with Decorator objects.\nFunctionality can be composed from simple pieces. As a result, an application\nneedn't pay for features it doesn't use. It's also easy to define new kinds of\nDecorators independently from the classes of objects they extend, even for\nunforeseen extensions. Extending a complex class tends to expose details\nunrelated to the responsibilities you're adding.\n3. A decorator and its component aren't identical. A decorator acts as a transparent\nenclosure. But from an object identity point of view, a decorated component\nis not identical to the component itself. Hence you shouldn't rely on object\nidentity when you use decorators.\n4. Lots of little objects. A design that uses Decorator often results in systems\ncomposed of lots of little objects that all look alike. The objects differ only\nin the way they are interconnected, not in their class or in the value of\ntheir variables. Although these systems are easy to customize by those who\nunderstand them, they can be hard to learn and debug.\n", "page": 198, "type": "text", "section": "Page 198"}
{"text": "DECORATOR \n179\nImplementation\nSeveral issues should be considered when applying the Decorator pattern:\n1. Interface conformance. A decorator object's interface must conform to the inter-\nface of the component it decorates. ConcreteDecorator \nclasses must therefore\ninherit from a common class (at least in \nC++).\n2. Omitting the abstract Decorator class. There's no need to define an abstract\nDecorator class when you only need to add one responsibility. That's often\nthe case when you're dealing with an existing class hierarchy rather than\ndesigning a new one. In that case, you can merge Decorator's responsibility\nfor forwarding requests to the component into the \nConcreteDecorator.\n3. Keeping Component classes lightweight. To ensure a conforming \ninterface, com-\nponents and decorators must descend from a common Component class.\nIt's important to keep this common class lightweight; that is, it should fo-\ncus on defining an interface, not on storing data. The definition of the data\nrepresentation should be deferred to subclasses; otherwise the complexity\nof the Component class might make the decorators too heavyweight to use\nin quantity. Putting a lot of functionality into Component also increases the\nprobability that concrete subclasses will pay for features they don't need.\n4. Changing the skin of an object versus changing its guts. We can think of a deco-\nrator as a skin over an object that changes its behavior. An alternative is to\nchange the object's guts. The Strategy (315) pattern is a good example of a\npattern for changing the guts.\nStrategies are a better choice in situations where the Component class is\nintrinsically heavyweight, thereby making the Decorator pattern too costly\nto apply. \nIn the Strategy \npattern, the component forwards some of its behavior\nto a separate strategy object. The Strategy pattern lets us alter or extend the\ncomponent's functionality by replacing the strategy object.\nFor example, we can support different border styles by having the component\ndefer border-drawing to a separate Border object. The Border object is a\nStrategy object that encapsulates a border-drawing strategy. By extending\nthe number of strategies from just one to an open-ended list, we achieve the\nsame effect as nesting decorators \nrecursively.\nIn MacApp 3.0 [App89] and Bedrock [Sym93a], for example, graphical com-\nponents (called \"views\") maintain a list of \"adorner\" objects that can attach\nadditional adornments like borders to a view component. If a view has any\nadorners attached, then it gives them a chance to draw additional embellish-\nments. MacApp and Bedrock must use this approach because the View class\nis heavyweight. It would be too expensive to use a full-fledged View just to\nadd a border.\nSince the Decorator pattern only changes a component from the outside, the\ncomponent doesn't have to know anything about its decorators; that is, the\ndecorators are transparent to the component:\n", "page": 199, "type": "text", "section": "Page 199"}
{"text": "180 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nWith strategies, the component itself knows about possible extensions. So it\nhas to reference and maintain the corresponding strategies:\nThe Strategy-based approach might require modifying the component to\naccommodate new extensions. On the other hand, a strategy can have its\nown specialized interface, \nwhereas a decorator's interface must conform to\nthe component's. A strategy for rendering a border, for example, need only\ndefine the interface for rendering a border (DrawBorder, GetWidth, etc.),\nwhich means that the strategy can be lightweight even if the Component\nclass is heavyweight.\nMacApp and Bedrock use this approach for more than just adorning views.\nThey also use it to augment the event-handling behavior of objects. In both\nsystems, a view maintains a list of \"behavior\" objects that can modify and\nintercept events. The view gives each of the registered behavior objects a\nchance to handle the event before nonregistered behaviors, effectively over-\nriding them. You \ncan decorate a view with special keyboard-handling sup-\nport, for example, \nby registering a behavior object that intercepts and handles\nkey events.\nSample Code\nThe following code shows how to implement user interface decorators in C++.\nWe'll assume there's a Component class called VisualComponent.\nclass VisualComponent \n{\npublic:\nVisualComponent();\nvirtual void Draw();\nvirtual void Resize();\n// . . .\n};\n", "page": 200, "type": "text", "section": "Page 200"}
{"text": "DECORATOR \n181\nWe define a subclass of VisualComponent called Decorator, which we'll sub-\nclass to obtain different decorations.\nclass Decorator : \npublic VisualComponent {\npublic:\nDecorator(VisualComponent*);\nvirtual void Draw();\nvirtual void Resize();\n// . \n. \n-\nprivate:\nVisualComponent* _component;\n};\nDecorator decorates the VisualComponent referenced by the -component\ninstance variable, which is initialized in the constructor. For each operation in\nVisualComponent's interface, Decorator defines a default implementation\nthat passes the request on to -component:\nvoid Decorator::Draw () {\n_component->Draw();\n}\nvoid Decorator::Resize () {\n_component->Resize();\n}\nSubclasses of Decorator define specific decorations. For example, the class\nBorderDecorator adds a border to its enclosing component. Border-\nDecorator is a subclass of Decorator that overrides the Draw operation to\ndraw the border. BorderDecorator also defines a private DrawBorder helper\noperation that does the drawing. The subclass inherits all other operation imple-\nmentations from Decorator.\nclass BorderDecorator : \npublic Decorator {\npublic:\nBorderDecorator(VisualComponent*, int borderWidth);\nvirtual void Draw();\nprivate:\nvoid DrawBorder(int);\nprivate:\nint _width;\n};\nvoid BorderDecorator::Draw () \n{\nDecorator::Draw();\nDrawBorder(_width);\n}\n", "page": 201, "type": "text", "section": "Page 201"}
{"text": "182 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nA similar implementation would follow for ScrollDecorator and Drop-\nShadowDecorator, which would add scrolling and drop shadow capabilities\nto a visual component.\nNow we can compose instances of these classes to provide different decorations.\nThe following code illustrates how we can use decorators to create a bordered\nscrollable Text \nView.\nFirst, we need a way to put a visual component into a window object. We'll assume\nour Window class provides a SetContents operation for this purpose:\nvoid Window::SetContents (VisualComponent* contents) {\n// . \n- \n.\n}\nNow we can create the text view and a window to put it in:\nWindow* window = new Window;\nTextView* textView = new TextView;\nTextView is a VisualComponent, which lets us put it into the \nwindow:\nwindow->SetContents(textView);\nBut we want a bordered and scrollable TextView. So \nwe decorate it accordingly\nbefore putting it in the window.\nwindow->SetContents( \nnew BorderDecorator(\nnew ScrollDecorator(textView), \n1\nBecause Window accesses its contents through the VisualComponent interface,\nit's unaware of the decorator's presence. You, \nas the client, can still keep track \nof\nthe text view if you have to interact with it directly, for example, when you need\nto invoke operations that aren't part of the VisualComponent interface. Clients\nthat rely on the component's identity should refer to it directly as well.\nKnown Uses\nMany object-oriented user interface toolkits use decorators to add graphi-\ncal embellishments to widgets. Examples include Interviews [LVC89, LCI+92],\nET++ [WGM88], and the ObjectWorks\\Smalltalk \nclass library [Par90]. More ex-\notic applications of Decorator are the DebuggingGlyph from Interviews and the\nPassivityWrapper from ParcPlace Smalltalk. A DebuggingGlyph prints out de-\nbugging information before and after it forwards a layout request to its compo-\nnent. This trace \ninformation can be used to analyze and debug the layout behavior\n", "page": 202, "type": "text", "section": "Page 202"}
{"text": "DECORATOR\n183\nof objects in a complex composition. The Passivity \nWrapper can enable or disable\nuser interactions with the component.\nBut the Decorator \npattern is \nby no means limited to graphical user interfaces, as the\nfollowing example (based on the ET++ streaming classes [WGM88]) illustrates.\nStreams are a fundamental \nabstraction in most I/O facilities. A stream can provide\nan interface for converting objects into a sequence of bytes or characters. That\nlets us transcribe an object to a file or to a string in memory for retrieval later. A\nstraightforward way to do this is to define an abstract \nStream class with subclasses\nMemoryStream and FileStream. But suppose we also want to be able to do the\nfollowing:\n\u2022 Compress the stream data using different compression algorithms (run-\nlength encoding, Lempel-Ziv, etc.).\n\u2022 Reduce the stream data to 7-bit ASCII characters so that it can \nbe transmitted\nover an ASCII communication channel.\nThe Decorator pattern gives us an elegant way to add these responsibilities to\nstreams. The diagram below shows one solution to the problem:\nThe Stream abstract \nclass maintains an internal buffer and provides operations for\nstoring data onto the stream (Putlnt, \nPutString). Whenever the buffer is full, Stream\ncalls the abstract operation HandleBufferFull, which does the actual \ndata transfer.\nThe FileStream version of this operation overrides this operation to transfer the\nbuffer to a file.\nThe key class here is StreamDecorator, which maintains a reference to a com-\nponent stream and forwards requests to it. StreamDecorator subclasses override\nHandleBufferFull and perform additional actions before calling StreamDecora-\ntor's HandleBufferFull operation.\n", "page": 203, "type": "text", "section": "Page 203"}
{"text": "184 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nFor example, the CompressingStream subclass compresses the data, and the\nASCII7Stream converts the data into 7-bit ASCII. Now, to create a FileStream\nthat compresses its data and converts the compressed binary data to 7-bit ASCII,\nwe decorate a FileStream with a CompressingStream and an ASCII7Stream:\nStream* aStream = new CompressingStream(\nnew ASCII7Stream(\nnew FileStream(\"aFileName\")\n)\n) \n;\naStream->Put!nt(12);\naStream->PutString(\"aString\");\nRelated Patterns\nAdapter (139): A decorator is different from an adapter in that a decorator only\nchanges an object's \nresponsibilities, not its interface; \nan adapter will give an object\na completely new interface.\nComposite (163): \nA decorator can be viewed as a degenerate composite with only\none component. However, a decorator adds additional responsibilities\u2014it isn't\nintended for object aggregation.\nStrategy (315): A decorator lets you change the skin of an object; a strategy lets\nyou change the guts. These are two alternative ways of changing an object.\n", "page": 204, "type": "text", "section": "Page 204"}
{"text": "FACADE \n185\nFACADE\nObject Structural\nIntent\nProvide a unified interface to a set of interfaces in a subsystem. Facade defines a\nhigher-level interface that makes the subsystem easier to use.\nMotivation\nStructuring a system into subsystems helps reduce complexity. \nA common design\ngoal is to minimize the communication and dependencies between subsystems.\nOne way to achieve this goal is to introduce a facade object that provides a single,\nsimplified interface to the more general facilities of a subsystem.\nConsider for example a programming environment that gives applications access\nto its compiler subsystem. This subsystem contains classes such as Scanner, Parser,\nProgramNode, BytecodeStream, and ProgramNodeBuilder that implement the\ncompiler. Some specialized applications might need to access these classes directly.\nBut most clients of a compiler generally don't care about details like parsing and\ncode generation; they merely want to compile some code. For them, the powerful\nbut low-level interfaces in the compiler subsystem only complicate their task.\nTo provide a higher-level interface that can shield clients from these classes, the\ncompiler subsystem also includes a Compiler class. This class defines a unified\ninterface to the compiler's functionality. The Compiler class acts as a facade: It\noffers clients a single, simple interface to the compiler subsystem. It glues together\nthe classes that implement compiler functionality without hiding them \ncompletely.\nThe compiler facade makes life easier for most programmers without hiding the\nlower-level functionality from the few that need it.\n", "page": 205, "type": "text", "section": "Page 205"}
{"text": "186\nSTRUCTURAL PATTERNS\nCHAPTER 4\nApplicability\nUse the Facade pattern when\n\u2022 you want to provide a simple interface to a complex subsystem. Subsystems\noften get more complex as they evolve. Most patterns, when applied, result\nin more and smaller classes. This makes the subsystem more reusable and\neasier to customize, but it also becomes harder to use for clients that don't\nneed to customize it. A facade can provide a simple default view of the\nsubsystem that is good enough for most clients. Only clients needing more\ncustomizability will need to look beyond the facade.\n\u2022 there are \nmany dependencies between clients and the implementation classes\nof an abstraction. Introduce a facade to decouple the subsystem from clients\nand other subsystems, thereby promoting subsystem independence and\nportability.\n\u2022 you want to layer your subsystems. Use a facade to define an entry point to\neach subsystem level. If subsystems are dependent, then you can simplify\nthe dependencies between them by making them communicate with each \nother solely through their facades.\n", "page": 206, "type": "text", "section": "Page 206"}
{"text": "FACADE \n187\nStructure\nParticipants\n\u2022 Facade (Compiler)\n- knows which subsystem classes are responsible for a request.\n- delegates client requests to appropriate subsystem objects.\n\u2022 subsystem classes (Scanner, Parser, ProgramNode, etc.)\n-\nimplement subsystem functionality.\n-\nhandle work assigned by the Facade object.\n-\nhave no knowledge of the facade; that is, they keep no references to it.\nCollaborations\n\u2022 Clients communicate \nwith the subsystem by sending requests to Facade, which\nforwards them to the appropriate subsystem object(s). Although the subsystem\nobjects perform the actual work, the facade may have to do work of its own to\ntranslate its interface to subsystem interfaces.\n\u2022 Clients that use the facade don't have to access its subsystem objects directly.\nConsequences\nThe Facade pattern offers the following benefits:\n1. It shields clients from subsystem components, thereby reducing the number\nof objects that clients deal with and making the subsystem easier to use.\n2. It promotes weak coupling between the subsystem and its clients. Often the\ncomponents in a subsystem are strongly coupled. Weak coupling lets you\nvary the components of the subsystem without affecting its clients. Facades\n", "page": 207, "type": "text", "section": "Page 207"}
{"text": "188 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nhelp layer a system and the dependencies between objects. They can elimi-\nnate complex \nor circular \ndependencies. This can be an important consequence\nwhen the client and the subsystem are implemented independently.\nReducing compilation dependencies is vital in large software systems. \nYou\nwant to save time by minimizing recompilation when subsystem classes\nchange. Reducing compilation dependencies with facades can limit the re-\ncompilation needed for a small change in an important subsystem. A facade\ncan also simplify porting systems to other platforms, because it's less likely\nthat building one subsystem requires building all others.\n3. It doesn't prevent applications from using subsystem classes if they need to.\nThus you can choose between ease of use and generality.\nImplementation\nConsider the following issues when implementing a facade:\n1. Reducing client-subsystem coupling. The coupling between clients and the sub-\nsystem can be reduced even further by making Facade an abstract class\nwith concrete subclasses for different implementations of a subsystem. Then\nclients can communicate with the subsystem through the interface of the ab-\nstract Facade class. This abstract coupling keeps clients from knowing which\nimplementation of a subsystem is used.\nAn alternative to subclassing is to configure a Facade object with different\nsubsystem objects. To customize the facade, simply replace one or more of\nits subsystem objects.\n2. Public versus private subsystem classes. A subsystem is analogous to a class in\nthat both have interfaces, \nand both encapsulate something\u2014a class encapsu-\nlates state and operations, while a subsystem encapsulates classes. And just\nas it's useful to think of the public and private interface of a class, we can\nthink of the public and private interface of a subsystem.\nThe public interface to a subsystem consists of classes that all clients can\naccess; the private interface is just for subsystem extenders. The Facade class\nis part of the public interface, of course, but it's not the only part. Other \nsubsystem classes are usually public as well. For example, the classes Parser\nand Scanner in the compiler subsystem are part of the public interface.\nMaking subsystem classes private would be useful, but few object-oriented\nlanguages support it. Both C++ and Smalltalk \ntraditionally have had a global\nname space for classes. Recently, however, the C++ standardization commit-\ntee added name spaces to the language [Str94], which will let you expose \njust\nthe public subsystem classes.\nSample Code\nLet's take a closer look at how to put a facade on a compiler subsystem.\n", "page": 208, "type": "text", "section": "Page 208"}
{"text": "FACADE \n189\nThe compiler subsystem defines a BytecodeStream class that implements a stream\nof Bytecode objects. A Bytecode object encapsulates a bytecode, which can\nspecify machine instructions. The subsystem also defines a Token class for objects\nthat encapsulate tokens in the programming language.\nThe Scanner class takes a stream of characters and produces a stream of tokens,\none token at a time.\nclass Scanner {\npublic:\nScanner(istream&);\nvirtual \"Scanner();\nvirtual Token& Scan();\nprivate:\nistream& _inputStream;\n};\nThe class Parser uses a ProgramNodeBuilder to construct a parse tree from a\nScanner's tokens.\nclass Parser {\npublic:\nParser(); \nvirtual \"Parser();\nvirtual void Parse(Scanners, ProgramNodeBuilder&);\n};\nParser calls back on ProgramNodeBuilder to build the parse tree incremen-\ntally. These classes interact according to the Builder (97) \npattern.\nclass ProgramNodeBuilder {\npublic:\nProgramNodeBuilder();\nvirtual ProgramNode* NewVariable(\nconst char* variableName\n) const;\nvirtual ProgramNode* NewAssignment(\nProgramNode* variable, ProgramNode* expression\n) const;\nvirtual ProgramNode* NewReturnStatement(\nProgramNode* value\n) const;\nvirtual ProgramNode* NewCondition( \nProgramNode* condition, \nProgramNode* truePart, ProgramNode* falsePart\n) const;\n// . . .\n", "page": 209, "type": "text", "section": "Page 209"}
{"text": "190 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nProgramNode* GetRootNode();\nprivate:\nProgramNode* _node;\n};\nThe parse tree is made up of instances of ProgramNode subclasses such as\nStatement \nNode, ExpressionNode, and so forth. The ProgramNode hierarchy\nis an example of the Composite (163) pattern. ProgramNode defines an interface\nfor manipulating the program node and its children, if any.\nclass ProgramNode {\npublic:\n// program node manipulation \nvirtual void GetSourcePosition(int& line, int& index); \n// . . .\n// child manipulation \nvirtual void Add(ProgramNode*);\nvirtual void Remove(ProgramNode*); \n// . . .\nvirtual void Traverse(CodeGenerator&);\nprotected:\nProgramNode();\n};\nThe Traverse operation takes a CodeGenerator object. ProgramNode sub-\nclasses use this object to generate machine code in the form of Bytecode objects\non a BytecodeS \ntream. The class CodeGenerator is a visitor (see Visitor (331)).\nclass CodeGenerator {\npublic:\nvirtual void Visit(StatementNode*);\nvirtual void Visit(ExpressionNode*);\n// . \n. \n.\nprotected:\nCodeGenerator(BytecodeStream&);\nprotected:\nBytecodeStreamk _output;\n};\nCodeGenerator has subclasses, for example, StackMachineCodeGenerator\nand RISCCodeGenerator, that generate machine code for different hardware\narchitectures.\nEach subclass of ProgramNode implements Traverse to call Traverse on its\nchild ProgramNode objects. In turn, each child does the same for its children, and\nso on recursively. For example, ExpressionNode defines Traverse as follows:\n", "page": 210, "type": "text", "section": "Page 210"}
{"text": "FACADE \n191\nvoid ExpressionNode::Traverse (CodeGenerator& eg) {\neg.Visit(this);\nListIterator<PrograinNode*> i \n(_children) \n;\nfor (i. \nFirst \n(); ! \ni \n. \nIsDone \n() \n; i.NextO) {\ni.Currentltem()->Traverse(eg);\n}\nThe classes we've discussed so far make up the compiler subsystem. Now we'll in-\ntroduce a Compiler class, a facade that puts all these pieces together. Compiler\nprovides a simple interface for compiling source and generating code for a par-\nticular machine.\nclass Compiler {\npublic:\nCompiler();\nvirtual void Compile(istream&, BytecodeStream&);\n};\nvoid Compiler::Compile ( \nistream& input, BytecodeStreamk output\n) { \nScanner scanner(input);\nProgramNodeBuilder builder;\nParser parser;\nparser.Parse(scanner, builder);\nRISCCodeGenerator generator(output);\nProgramNode* parseTree = builder.GetRootNode();\nparseTree->Traverse(generator);\nThis implementation hard-codes the type of code generator to use so that program-\nmers aren't required to specify the target architecture. That might be reasonable \nif\nthere's only ever one target architecture. \nIf that's not the case, then we might want\nto change the Compiler constructor to take a CodeGenerator parameter. Then\nprogrammers can specify the generator to use when they instantiate Compiler.\nThe compiler facade can parameterize other participants such as Scanner and\nProgramNodeBuilder as well, which adds flexibility, but it also detracts from\nthe Facade pattern's mission, which is to simplify the interface for the common\ncase.\nKnown Uses\nThe compiler example in the Sample Code section was inspired by the Object-\nWorks\\Smalltalk compiler system [Par90].\n", "page": 211, "type": "text", "section": "Page 211"}
{"text": "192\nSTRUCTURAL PATTERNS\nCHAPTER 4\nIn the ET++ application framework [WGM88], an application can have built-in\nbrowsing tools for inspecting its objects at run-time. These browsing tools are\nimplemented in a separate subsystem that includes a Facade class called \"Pro-\ngrammingEnvironment.\" This facade defines operations such as InspectObject\nand InspectClass for accessing the browsers.\nAn ET++ application can also forgo built-in browsing support. In that case, Pro-\ngrammingEnvironment implements these requests as null operations; that is, they \ndo nothing. Only the ETProgrammingEnvironment subclass implements these re-\nquests with operations that display the corresponding browsers. The application\nhas no knowledge of whether a browsing environment is available or not; there's\nabstract coupling between the application and the browsing subsystem.\nThe Choices operating system [CIRM93] uses facades to compose many frame-\nworks into one. The key abstractions in Choices are processes, storage, and ad-\ndress spaces. For each of these abstractions there is a corresponding subsystem,\nimplemented as a framework, that supports porting Choices to a variety of dif-\nferent hardware platforms. Two of these subsystems have a \"representative\" (i.e.,\nfacade). These representatives are FileSystemlnterface (storage) and Domain (ad-\ndress spaces).\nFor example, the virtual memory framework has Domain as its facade. A Domain\nrepresents an address space. It provides a mapping between virtual addresses\nand offsets into memory objects, files, or backing store. The main operations on\nDomain support adding a memory object at a particular address, removing a \nmemory object, and handling a page fault.\nAs the preceding diagram shows, the virtual memory subsystem uses the follow-\ning components internally:\n", "page": 212, "type": "text", "section": "Page 212"}
{"text": "FACADE \n193\n\u2022 MemoryObject represents a data store.\n\u2022 MemoryObjectCache caches the data of MemoryObjects in physical memory.\nMemoryObjectCache is actually a Strategy (315) that localizes the caching\npolicy.\n\u2022 AddressTranslation encapsulates the address translation hardware.\nThe RepairFault operation is called whenever a page fault interrupt occurs. The\nDomain finds the memory object at the address causing the fault and delegates the\nRepairFault operation to the cache associated with that memory object. Domains\ncan be customized by changing their components.\nRelated Patterns\nAbstract Factory (87) \ncan be used with Facade to provide an interface \nfor creating\nsubsystem objects in a subsystem-independent way. Abstract Factory can also be\nused as an alternative to Facade to hide platform-specific classes.\nMediator (273) is similar to Facade in that it abstracts functionality of existing\nclasses. However, Mediator's purpose is to abstract arbitrary communication be-\ntween colleague objects, often centralizing functionality that doesn't belong in\nany one of them. A mediator's colleagues are aware of and communicate with the\nmediator instead of communicating with each other directly. In contrast, a facade\nmerely abstracts the interface to subsystem objects to make them easier to use; it\ndoesn't define new functionality, and subsystem classes don't know about it.\nUsually only one Facade object is required. Thus Facade objects are often Single-\ntons (127).\n", "page": 213, "type": "text", "section": "Page 213"}
{"text": "This page intentionally left blank \n", "page": 214, "type": "text", "section": "Page 214"}
{"text": "FLYWEIGHT \n195\nFLYWEIGHT\nObject Structural\nIntent\nUse sharing to support large numbers of fine-grained objects efficiently.\nMotivation\nSome applications could benefit from using objects throughout their design, but\na naive implementation would be prohibitively expensive.\nFor example, most document editor implementations have text formatting and\nediting facilities that are modularized to some extent. Object-oriented document\neditors typically use objects to represent embedded elements like tables and fig-\nures. However, they usually stop short of using an object for each character in the\ndocument, even though doing so would promote flexibility at the finest levels in\nthe application. Characters and embedded elements could then be treated uni-\nformly with respect to how they are drawn and formatted. The application could\nbe extended to support new character sets without disturbing other functionality.\nThe application's object structure could mimic the document's physical structure.\nThe following diagram shows how a document editor can use objects to represent\ncharacters.\nThe drawback of such a design is its cost. Even moderate-sized documents may\nrequire hundreds of thousands of character objects, which will consume lots of\nmemory and may incur unacceptable run-time overhead. The Flyweight pattern\ndescribes how to share objects to allow their use at fine granularities without\nprohibitive cost.\n", "page": 215, "type": "text", "section": "Page 215"}
{"text": "196 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nA flyweight is a shared object that can be used in multiple contexts simultaneously.\nThe flyweight acts as an independent object in each context\u2014it's indistinguish-\nable from an instance of the object that's not shared. Flyweights cannot make\nassumptions about the context in which they operate. The key concept here is the\ndistinction between intrinsic and extrinsic state. Intrinsic state is stored in the\nflyweight; it consists of information that's independent of the flyweight's context,\nthereby making it sharable. Extrinsic state depends on and varies with the fly-\nweight's context and therefore can't be shared. Client objects are responsible for\npassing extrinsic state to the flyweight when it needs it.\nFlyweights model concepts or entities that are normally too plentiful to represent\nwith objects. \nFor example, a document editor can create a flyweight for each letter\nof the alphabet. Each flyweight stores a character code, but its coordinate position\nin the document and its typographic style can be determined from the text layout\nalgorithms and formatting commands in effect wherever the character appears.\nThe character code is intrinsic state, while the other information is extrinsic.\nLogically there is an object for every occurrence of a given character in the docu-\nment:\nPhysically, however, there is one shared flyweight object per character, and it\nappears in different contexts in the document structure. Each occurrence of a par-\nticular character object refers to the same instance in the shared pool of flyweight\nobjects:\n", "page": 216, "type": "text", "section": "Page 216"}
{"text": "FLYWEIGHT \n197\nThe class structure for these objects is shown next. Glyph is the abstract class for\ngraphical objects, some of which may be flyweights. Operations that may depend\non extrinsic state have it passed to them as a parameter. For example, Draw and\nIntersects must know which context the glyph is in before they can do their job.\nA flyweight representing the letter \"a\" only stores the corresponding character\ncode; it doesn't need to store its location or font. Clients supply the context-\ndependent information that the flyweight needs to draw itself. For example, a\nRow glyph knows where its children should draw themselves so that they are\ntiled horizontally. Thus it can pass each child its location in the draw request.\nBecause the number of different character objects is far less than the number of\ncharacters in the document, the total number of objects is substantially less than\nwhat a naive implementation would use. A document in which all characters ap-\npear in the same font and color will allocate on the order of 100 \ncharacter \nobjects\n(roughly the size of the ASCII character set) regardless of the document's length.\nAnd since most documents use no more than 10 different font-color combina-\ntions, this number won't grow appreciably in practice. An object abstraction thus\nbecomes practical for individual characters.\nApplicability\nThe Flyweight pattern's effectiveness depends heavily on how and where it's\nused. Apply the Flyweight pattern when all of the following are true:\n\u2022 An application uses a large number of objects.\n\u2022 Storage costs are high because of the sheer quantity of \nobjects.\n\u2022 Most object state can \nbe made extrinsic.\n\u2022 Many groups of objects may be replaced by relatively few shared objects\nonce extrinsic state is removed.\n\u2022 The application doesn't depend on object identity. Since flyweight objects\nmay be shared, identity tests \nwill return true for conceptually distinct objects.\n", "page": 217, "type": "text", "section": "Page 217"}
{"text": "198 \nSTRUCTURAL PATTERNS\nStructure\nCHAPTER 4\nParticipants\nFlyweight (Glyph)\n- declares an interface through which flyweights can receive and act on\nextrinsic state.\n", "page": 218, "type": "text", "section": "Page 218"}
{"text": "FLYWEIGHT \n199\n\u2022 ConcreteFlyweight (Character)\n- implements the Flyweight interface and adds storage for intrinsic state,\nif any. A ConcreteFlyweight object must be sharable. Any state it stores\nmust be intrinsic; that is, it must be independent of the ConcreteFlyweight\nobject's context.\n\u2022 UnsharedConcreteFlyweight (Row, Column)\n- not all Flyweight subclasses need to be shared. The Flyweight interface\nenables sharing; it doesn't enforce it. It's common for UnsharedConcrete-\nFlyweight objects to have ConcreteFlyweight objects as children at some\nlevel in the flyweight object structure (as the Row and Column classes\nhave).\n\u2022 FlyweightFactory\n- creates and manages flyweight objects.\n- ensures that flyweights are shared properly. When a client requests a \nfly-\nweight, the FlyweightFactory object \nsupplies an existing instance or creates\none, if none exists.\n\u2022 Client\n- maintains a reference to flyweight(s).\n- computes or stores the extrinsic state of flyweight(s).\nCollaborations\n\u2022 State that a flyweight needs to function must be characterized as either intrinsic\nor extrinsic. Intrinsic state is stored in the ConcreteFlyweight object; extrinsic\nstate is stored or computed by Client objects. Clients pass this state to the\nflyweight when they invoke its operations.\n\u2022 Clients should not instantiate ConcreteFlyweights directly. \nClients must obtain\nConcreteFlyweight objects exclusively from the FlyweightFactory object to\nensure they are shared properly.\nConsequences\nFlyweights may introduce run-time costs associated with transferring, finding,\nand/or computing extrinsic state, especially if it was formerly stored as intrinsic\nstate. However, such costs are offset by space savings, which increase as more\nflyweights are shared.\nStorage savings are a function of several factors:\n\u2022 the reduction in the total number of instances that comes from sharing\n\u2022 the amount of intrinsic state per object\n", "page": 219, "type": "text", "section": "Page 219"}
{"text": "200 \nSTRUCTURAL PATTERNS \nCHAPTER 4\n\u2022 whether extrinsic state is computed or stored.\nThe more flyweights are shared, the greater the storage savings. The savings\nincrease with the amount of shared state. The greatest savings occur when the\nobjects use substantial quantities of both intrinsic and extrinsic state, and the\nextrinsic state can be computed rather than stored. Then you save on storage in\ntwo ways: Sharing reduces the cost of intrinsic state, and you trade extrinsic state\nfor computation time.\nThe Flyweight pattern is often combined with the Composite (163) pattern to\nrepresent a hierarchical structure as a graph with shared leaf nodes. A consequence\nof sharing is that flyweight leaf nodes cannot store a pointer to their parent. Rather,\nthe parent pointer is passed to the flyweight as part of its extrinsic state. This has\na major impact on how the objects in the hierarchy communicate with each other.\nImplementation\nConsider the following issues when implementing the Flyweight pattern:\n1. Removing extrinsic state. The pattern's applicability is determined largely by\nhow easy it is to identify extrinsic state and remove it from shared objects.\nRemoving extrinsic state won't help reduce storage costs if there are as many\ndifferent kinds of extrinsic state as there are objects before sharing. Ideally,\nextrinsic state can be computed from a separate object structure, one with far\nsmaller storage requirements.\nIn our document editor, for example, we can store a map of typographic\ninformation in a separate structure rather than store the font and type style\nwith each character object. The map keeps track of runs of characters with\nthe same typographic attributes. When a character draws itself, it receives\nits typographic attributes as a side-effect of the draw traversal. Because doc-\numents normally use just a few different fonts and styles, storing this infor-\nmation externally to each character object is far more efficient than storing it \ninternally.\n2. Managing shared objects. Because \nobjects are shared, clients shouldn't instanti-\nate them directly. FlyweightFactory lets clients locate a particular flyweight.\nFlyweightFactory objects often use an associative store to let clients look up\nflyweights of interest. For example, the flyweight factory in the document\neditor example can keep a table of flyweights indexed by character \ncodes. The\nmanager returns the proper flyweight given its code, creating the flyweight \nif it does not already exist.\nSharability also implies some form of reference counting or garbage \ncollection\nto reclaim a flyweight's storage when it's \nno longer needed. However, neither\nis necessary if the number of flyweights is fixed and small (e.g., flyweights\nfor the ASCII character set). In that case, the flyweights are worth keeping\naround permanently.\n", "page": 220, "type": "text", "section": "Page 220"}
{"text": "FLYWEIGHT \n201\nSample Code\nReturning to our document formatter example, we can define a Glyph base class\nfor flyweight graphical objects. Logically, glyphs are Composites (see Compos-\nite (163)) that have graphical attributes and can draw themselves. Here we focus on\njust the font attribute, but the same approach can be used for any other graphical\nattributes a glyph might have.\nclass Glyph {\npublic:\nvirtual ~Glyph();\nvirtual void Draw(Window*, GlyphContext&);\nvirtual void SetFont(Font*, GlyphContextk);\nvirtual Font* GetFont(GlyphContext&);\nvirtual void First(GlyphContext&);\nvirtual void Next(GlyphContext&);\nvirtual bool IsDone(GlyphContext&);\nvirtual Glyph* Current(GlyphContextk);\nvirtual void Insert(Glyph*, GlyphContext&);\nvirtual void Remove(GlyphContextk);\nprotected:\nGlyph();\n};\nThe Character subclass just stores a character code:\nclass Character : \npublic Glyph {\npublic:\nCharacter(char);\nvirtual void Draw(Window*, GlyphContext&);\nprivate:\nchar _charcode;\n};\nTo keep from allocating space for a font attribute in every glyph, we'll store\nthe attribute extrinsically in a GlyphContext object. GlyphContext acts as a\nrepository of extrinsic state. It maintains a compact mapping between a glyph and\nits font (and any other graphical attributes it might have) in different contexts. \nAny operation that needs to know the glyph's font in a given context will have\na GlyphContext instance passed to it as a parameter. The operation can then\nquery the GlyphContext for the font in that context. The context depends on\nthe glyph's location in the glyph structure. Therefore Glyph's child iteration\nand manipulation operations must update the GlyphContext whenever they're\nused.\n", "page": 221, "type": "text", "section": "Page 221"}
{"text": "202\nSTRUCTURAL PATTERNS\nCHAPTER 4\nclass GlyphContext {\npublic:\nGlyphContext(); \nvirtual ~GlyphContext();\nvirtual void Next(int step = 1);\nvirtual void Insert(int quantity = 1);\nvirtual Font* GetFont{); \nvirtual void SetFont(Font*, int span = 1);\nprivate: \nint _index; \nBTree* _fonts;\n};\nGlyphContext must be kept informed of the current position in the glyph struc-\nture during traversal. GlyphContext: : \nNext increments .index as \nthe \ntraversal\nproceeds. Glyph subclasses that have children (e.g., Row \nand Column) must im-\nplement Next so that it calls GlyphCont ext: : \nNext at each point in the traversal.\nGlyphContext: : \nGetFont uses the index as a key into a BTree structure that\nstores the glyph-to-font \nmapping. Each node in the tree is labeled with the length\nof the string for which it gives font information. Leaves in the tree point to a font,\nwhile interior nodes break the string into substrings, one for each child.\nConsider the following excerpt from a glyph composition:\nThe BTree structure for font information might look like\n", "page": 222, "type": "text", "section": "Page 222"}
{"text": "FLYWEIGHT \n203\nInterior nodes define ranges of glyph indices. BTr \nee is updated in response to font\nchanges and whenever glyphs are added to or removed from the glyph structure.\nFor example, assuming we're at index 102 in the traversal, the following code sets\nthe font of each character in the word \"expect\" to that of the surrounding text\n(that is, times 12, an instance of Font for 12-point Times Roman):\nGlyphContext gc;\nFont* times!2 = new Font(\"Times-Roman-12\");\nFont* timesltalic!2 = new Font(\"Times-Italic-12\");\n// \n- . .\ngc.SetFont(timesl2, 6);\nThe new BTree structure (with changes shown in black) looks like\n", "page": 223, "type": "text", "section": "Page 223"}
{"text": "204 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nSuppose we add the word \"don't \" (including a trailing space) in 12-point Times\nItalic before \"expect.\" The following code informs the gc of this event, assuming\nit is still at index 102:\ngc.Insert(6);\ngc.SetFont(timesltalic!2, 6);\nThe BTree structure \nbecomes\nWhen the GlyphContext is queried for the font of the current glyph, it descends\nthe BTree, adding up indices as it goes until it finds the font for the current\nindex. Because \nthe frequency of font changes is relatively low, the tree stays small\nrelative to the size of the glyph structure. This keeps storage costs down without\nan inordinate increase in look-up time.3\nThe last object we need is a FlyweightFactory that creates glyphs and ensures\nthey're shared properly. Class GlyphFac \ntory instantiates Character and other \nkinds of glyphs. We \nonly share Character objects; \ncomposite glyphs are far less\nplentiful, and their important state (i.e., their children) is intrinsic anyway.\nconst int NCHARCODES = \n128;\nclass GlyphFactory {\npublic:\nGlyphFactory(); \nvirtual ~GlyphFactory \n() \n;\n3 \nLook-up time in this scheme is proportional to the font change frequency. \nWorst-case performance occurs\nwhen a font change occurs on every character, but that's unusual in practice.\n", "page": 224, "type": "text", "section": "Page 224"}
{"text": "FLYWEIGHT \n205\nvirtual Character* CreateCharacter(char);\nvirtual Row* CreateRow(); \nvirtual Column* CreateColumn();\n// . . .\nprivate:\nCharacter* _character[NCHARCODES];\n};\nThe .character array contains pointers to Character glyphs indexed by char-\nacter code. The array is initialized to zero in the constructor.\nGlyphFactory::GlyphFactory () \n{ \nfor (int \ni = 0; i < NCHARCODES; ++i) \n{\n_character[i] = 0;\n}\n}\nCreateCharacter looks up a character in the character glyph in the array, and it\nreturns the corresponding glyph if it exists. If it doesn't, then CreateCharacter\ncreates the glyph, puts it in the array, and returns it:\nCharacter* GlyphFactory::CreateCharacter (char c) \n{\nif (!_character[c]) {\n_character[c] = new Character(c);\n}\nreturn _character[c];\n}\nThe other operations simply instantiate a new object each time they're called,\nsince noncharacter glyphs won't be shared:\nRow* GlyphFactory::CreateRow () \n{\nreturn new \nRow;\n}\nColumn* GlyphFactory::CreateColumn () {\nreturn new Column;\n}\nWe could omit these operations and let clients instantiate unshared glyphs directly.\nHowever, if we decide to make these glyphs sharable later, we'll have to change\nclient code that creates them.\nKnown Uses\nThe concept of flyweight objects was first described and explored as a design\ntechnique in Interviews 3.0 [CL90]. Its developers built a powerful document\neditor called Doc as a proof of concept [CL92]. Doc uses glyph objects to repre-\nsent each character in the document. The editor builds one Glyph instance for\n", "page": 225, "type": "text", "section": "Page 225"}
{"text": "206 \nSTRUCTURAL PATTERNS \nCHAPTER 4\neach character in a particular style (which defines its graphical attributes); hence\na character's intrinsic state consists of the character code and its style informa-\ntion (an index into a style table).4 That means only position is extrinsic, making\nDoc fast. Documents are represented by a class Document, which also acts as the\nFlyweightFactory. Measurements on Doc have shown that sharing flyweight \nchar-\nacters is quite effective. In a typical case, a document containing 180,000 \ncharacters\nrequired allocation of only 480 character objects.\nET++ [WGM88] uses flyweights to support look-and-feel independence.5 The\nlook-and-feel standard affects the layout of user interface elements (e.g., scroll\nbars, buttons, menus\u2014known collectively as \"widgets\") and their decorations\n(e.g., shadows, beveling). A widget delegates all its layout and drawing behavior\nto a separate Layout object. Changing the Layout object changes the look and feel,\neven at run-time.\nFor each widget class there is a corresponding Layout class (e.g., ScrollbarLayout,\nMenubarLayout, etc.). An obvious problem with this approach is that using sep-\narate layout objects doubles the number of user interface objects: For each user\ninterface object there is an additional Layout object. To avoid this overhead, Lay-\nout objects are implemented as flyweights. They make good flyweights because\nthey deal mostly with defining behavior, and it's easy to pass them what little\nextrinsic state they need to lay out or draw an object.\nThe Layout objects are created and managed by Look objects. The Look class is\nan Abstract Factory (87) that retrieves a specific Layout object with operations \nlike GetButtonLayout, GetMenuBarLayout, and so forth. For each look-and-feel\nstandard there is a corresponding Look subclass (e.g., MotifLook, OpenLook) that\nsupplies the appropriate Layout \nobjects.\nBy the way, Layout objects are essentially strategies (see Strategy (315)). They are\nan example of a strategy object implemented as a flyweight.\nRelated Patterns\nThe Flyweight pattern is often combined with the Composite (163) pattern to\nimplement a logically hierarchical structure in terms of a directed-acyclic graph\nwith shared leaf nodes.\nIt's often best to implement State (305) and Strategy (315) objects as flyweights.\n4 In the Sample Code given earlier, style information is made extrinsic, leaving the character code as the\nonly intrinsic state.\n5 See Abstract Factory (87) for another approach to look-and-feel independence.\n", "page": 226, "type": "text", "section": "Page 226"}
{"text": "PROXY \n207\nPROXY \nObject Structural\nIntent\nProvide a surrogate or placeholder for another object to control access to it.\nAlso Known As\nSurrogate\nMotivation\nOne reason for controlling access to an object is to defer the full cost of its creation\nand initialization until we actually need to use it. Consider a document editor\nthat can embed graphical objects \nin a document. Some graphical objects, like large\nraster images, can be expensive to create. But opening a document should be fast,\nso we should avoid creating all the expensive objects at once when the document\nis opened. This isn't necessary anyway, because not all of these objects will be\nvisible in the document at the same time.\nThese constraints would suggest creating each expensive object on demand, which\nin this case occurs when an image becomes visible. But what do we put in the\ndocument in place of the image? And how can we hide the fact that the image is\ncreated on demand so that we don't complicate \nthe editor's implementation? \nThis\noptimization shouldn't impact the rendering and formatting code, for example.\nThe solution is to use another object, an image proxy, that acts as a stand-in for\nthe real image. The proxy acts \njust like the image and takes care of instantiating it\nwhen it's required.\nThe image proxy creates the real image only when the document editor asks it\nto display itself by invoking its Draw operation. The proxy forwards subsequent\nrequests directly to the image. It must therefore keep a reference to the image after\ncreating it.\nLet's assume that images are stored in separate files. In this case we can use the\nfile name as the reference to the real object. The proxy also stores its extent, that\n", "page": 227, "type": "text", "section": "Page 227"}
{"text": "208\nSTRUCTURAL PATTERNS\nCHAPTER 4\nis, its width and height. The extent lets the proxy respond to requests for its size\nfrom the formatter without actually instantiating the image.\nThe following class diagram illustrates this example in more detail.\nThe document editor accesses embedded images through the interface defined by\nthe abstract Graphic class. ImageProxy is a class for images that are created on\ndemand. ImageProxy maintains the file name as a reference to the image on disk. \nThe file name is passed as an argument to the ImageProxy \nconstructor.\nImageProxy also stores the bounding box of the image and a reference to the\nreal Image instance. This reference won't be valid until the proxy instantiates\nthe real image. The Draw operation makes sure the image is instantiated before\nforwarding it the request. GetExtent \nforwards the request to the image only if it's\ninstantiated; otherwise ImageProxy returns the extent it stores.\nApplicability\nProxy is applicable whenever there is a need for a more versatile or sophisticated\nreference to an object than a simple pointer. Here are several common situations\nin which the Proxy pattern is applicable:\n1. A remote proxy provides a local representative for an object in a different\naddress space. NEXTSTEP [Add94] \nuses the class NXProxy for this purpose.\nCoplien [Cop92] calls this kind of proxy an \"Ambassador.\"\n2. A virtual proxy creates expensive objects on demand. The ImageProxy de-\nscribed in the Motivation is an example of such a \nproxy.\n3. A protection proxy controls access to the original object. Protection proxies\nare useful when objects should have different access rights. For example,\n", "page": 228, "type": "text", "section": "Page 228"}
{"text": "PROXY \n209\nKernelProxies in the Choices operating system [CIRM93] provide protected\naccess to operating system objects.\n4. A smart reference is a replacement for a bare pointer that performs additional\nactions when an object is accessed. Typical \nuses include\n\u2022 counting the number of references to the real object so that it can be\nfreed automatically when there are no more references (also called smart \npointers [Ede92]).\n\u2022 loading a persistent object into memory when it's first referenced.\n\u2022 checking that the real object is locked before it's accessed to ensure that\nno other object can change it.\nStructure\nParticipants\n\u2022 Proxy (ImageProxy)\n-\nmaintains a reference that lets the proxy access the real subject. Proxy may\nrefer to a Subject if the RealSubject and Subject interfaces are the same.\n-\nprovides an interface identical to Subject's so that a proxy can by substi-\ntuted for the real subject.\n-\ncontrols access to the real subject and may be responsible for creating and\ndeleting it.\n", "page": 229, "type": "text", "section": "Page 229"}
{"text": "210 \nSTRUCTURAL PATTERNS \nCHAPTER 4\n- other responsibilities depend on the kind of \nproxy:\n\u2022 remote proxies are responsible for encoding a request and its arguments\nand for sending the encoded request to the real subject in a different\naddress space.\n\u2022 virtual proxies may cache additional information about the real subject\nso that they can postpone accessing it. For example, the ImageProxy\nfrom the Motivation caches the real image's extent.\n\u2022 protection proxies check that the caller has the access permissions re-\nquired to perform a request.\n\u2022 Subject (Graphic)\n- defines the common interface for RealSubject and Proxy so that a Proxy\ncan be used anywhere a RealSubject is expected.\n\u2022 RealSubject (Image)\n- defines the real object that the proxy represents.\nCollaborations\n\u2022 Proxy forwards requests to RealSubject when appropriate, depending on the\nkind of proxy.\nConsequences\nThe Proxy pattern introduces a level of indirection when accessing an object. The\nadditional indirection has many uses, depending on the kind of proxy:\n1. A remote proxy can hide the fact that an object resides in a different address\nspace.\n2. A virtual proxy can perform optimizations such as creating an object on\ndemand.\n3. Both protection proxies and smart references allow additional housekeeping\ntasks when an object is accessed.\nThere's another optimization that the Proxy pattern can hide from the client. It's\ncalled copy-on-write, \nand it's related to creation on demand. Copying a large and\ncomplicated object can be an expensive operation. If the copy is never modified,\nthen there's no need to incur this cost. By using a proxy to postpone the copying\nprocess, we ensure that we pay the price of copying the object only if it's modified.\nTo make copy-on-write work, the subject must be reference counted. Copying the\nproxy will do nothing more than increment this reference count. Only when the\nclient requests an operation that modifies the subject \ndoes the proxy actually copy\nit. In that case the proxy must also decrement the subject's reference count. When\nthe reference count goes to zero, the subject gets deleted.\n", "page": 230, "type": "text", "section": "Page 230"}
{"text": "PROXY \n211\nCopy-on-write can reduce the cost of copying heavyweight subjects significantly.\nImplementation\nThe Proxy pattern can exploit the following language features:\n1. Overloading the member access operator in C++. C++ supports overloading\noperator->, the member access operator. Overloading this operator lets\nyou perform additional work whenever an object is dereferenced. This can\nbe helpful for implementing some kinds of proxy; the proxy behaves just like\na pointer.\nThe following example illustrates how to use this technique to implement a\nvirtual proxy called ImagePtr.\nclass Image; \nextern Image* LoadAnlmageFile(const char*);\n// external function\nclass ImagePtr {\npublic:\nImagePtr(const char* imageFile);\nvirtual \"ImagePtr();\nvirtual Image* operator->();\nvirtual Image& operator*();\nprivate:\nImage* Loadlmage();\nprivate:\nImage \n* \n_image; \nconst char* _imageFile;\n};\nImagePtr::ImagePtr (const char* thelmageFile) { \n_imageFile = thelmageFile;\n_image = 0;\n}\nImage* ImagePtr::Loadlmage () {\nif (_image ==0) {\n_image = LoadAnlmageFile(_imageFile);\n} \nreturn _image;\n}\nThe overloaded -> and * operators use Loadlmage to return _image to\ncallers (loading it if necessary).\nImage* ImagePtr::operator-> () \n{\nreturn Loadlmage();\n}\nImage& ImagePtr::operator* () \n{\nreturn *LoadImage();\n}\n", "page": 231, "type": "text", "section": "Page 231"}
{"text": "212 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nThis approach lets you call Image operations through ImagePtr objects\nwithout going to the trouble of making the operations part of the ImagePtr\ninterface:\nImagePtr image = ImagePtr(\"anlmageFileName\");\nimage->Draw(Point(50, 100));\n// (image.operator->())->Draw(Point(50, 100))\nNotice how the image proxy acts like a pointer, but it's not declared to be a\npointer to an Image. That means you can't use it exactly like a real pointer to\nan Image. Hence clients must treat Image and ImagePtr objects differently\nin this approach.\nOverloading the member access operator isn't a good solution for every kind\nof proxy. Some proxies need to know precisely which operation is called, and\noverloading the member access operator doesn't work in those cases.\nConsider the virtual proxy example in the Motivation. The image should\nbe loaded at a specific time\u2014namely when the Draw operation is called\u2014\nand not whenever the image is referenced. Overloading the access operator\ndoesn't allow this distinction. In that case we must manually implement each\nproxy operation that forwards the request to the subject.\nThese operations are usually very similar to each other, as the Sample Code\ndemonstrates. Typically all operations verify that the request is legal, that\nthe original object exists, etc., before forwarding the request to the subject.\nIt's tedious to write this code again and again. So it's common to use a\npreprocessor to generate it automatically.\n2. Using doesNotUnderstand in Smalltalk. Smalltalk provides a hook that\nyou can use to support automatic forwarding of requests. Smalltalk calls\ndoesNotUnderstand: aMessage when a client sends a message to a\nreceiver that has no corresponding method. The Proxy class can redefine\ndoesNotUnderstand so that the message is forwarded to its subject.\nTo ensure that a request is forwarded to the subject and not just absorbed\nby the proxy silently, you can define a Proxy class that doesn't understand\nany messages. Smalltalk lets you do this by defining Proxy as a class with no\nsuperclass.6\nThe main disadvantage of doesNotUnderstand: is that most Smalltalk\nsystems have a few special messages that are handled directly by the virtual\nmachine, and these do not cause the usual method look-up. The only one\nthat's usually implemented in Object (and so can affect proxies) is the identity\noperation ==.\nIf you're going to use doesNotUnderstand: to implement Proxy, then\nyou must design around this problem. You can't expect identity on prox-\nies to mean identity on their real subjects. An added disadvantage is that\n6 The implementation of distributed objects in NEXTSTEP [Add94] (specifically, the class NXProxy) uses\nthis technique. \nThe implementation redefines forward, the equivalent hook in NEXTSTEP.\n", "page": 232, "type": "text", "section": "Page 232"}
{"text": "PROXY \n213\ndoesNotUnderstand: was developed for error handling, not for building\nproxies, and so it's generally not very fast.\n3. Proxy doesn't always have to know the type of real subject. If a Proxy class can\ndeal with its subject solely through an abstract interface, then there's no\nneed to make a Proxy class for each RealSubject class; the proxy can deal\nwith all RealSubject \nclasses uniformly. But if Proxies are going to instantiate\nRealSubjects (such as in a virtual proxy), then they have to know the concrete\nclass.\nAnother implementation issue involves how to refer to the subject before it's\ninstantiated. Some proxies have to refer to their subject whether it's on disk or\nin memory. That means they must use some form of address space-independent \nobject identifiers. We used a file name for this purpose in the Motivation.\nSample Code\nThe following \ncode implements two kinds of proxy: the virtual proxy described in\nthe Motivation section, and a proxy implemented with doesNotUnders \ntand: 7\n1. A virtual proxy. The Graphic class defines the interface for graphical objects:\nclass Graphic {\npublic:\nvirtual \"Graphic();\nvirtual void Draw(const Point& at) = 0;\nvirtual void HandleMouse(Event& event) = 0;\nvirtual const Point& GetExtent() = 0;\nvirtual void Load(istream& from) = 0;\nvirtual void Save(ostream& to) = 0;\nprotected:\nGraphic();\n};\nThe Image class implements the Graphic interface to display image files.\nImage overrides HandleMouse to let users resize the image \ninteractively.\nclass Image : \npublic Graphic {\npublic:\nImage(const char* file); // loads image from a file\nvirtual ~Image();\nvirtual void Draw(const Point& at);\nvirtual void HandleMouse(Event& event);\nvirtual const Points GetExtent();\n7Iterator (257) describes another kind of proxy on page 266.\n", "page": 233, "type": "text", "section": "Page 233"}
{"text": "214 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nvirtual void Load(istream& from);\nvirtual void Save(ostream& to);\nprivate:\n// . \n. \n.\n};\nImageProxy has the same interface as Image:\nclass ImageProxy : \npublic Graphic {\npublic:\nImageProxy(const char* imageFile);\nvirtual ~ImageProxy();\nvirtual void Draw(const Point& at);\nvirtual void HandleMouse(Event& event);\nvirtual const Point& GetExtent();\nvirtual void Load(istream& from);\nvirtual void Save(ostream& to);\nprotected:\nImage* Getlmage();\nprivate:\nImage* _image;\nPoint _extent;\nchar* _fileName;\n};\nThe constructor saves a local copy of the name of the file that stores the\nimage, and it initializes -extent and -image:\nImageProxy::ImageProxy (const char* fileName) { \n_fileName = strdup(fileName); \n_extent = Point::Zero; // don't know extent yet\n_image = 0;\n}\nImage* ImageProxy::Getlmage() \n{\nif (_image ==0) {\n_image - \nnew Image(_fileName);\n}\nreturn _image;\n}\nThe implementation of GetExtent returns the cached extent if possible;\notherwise the image is loaded from the file. Draw loads the image, and\nHandleMouse forwards the event to the real image.\nconst Point& ImageProxy::GetExtent () \n{\nif (_extent == Point::Zero) {\n_extent = Getlmage()->GetExtent();\n}\nreturn _extent;\n}\n", "page": 234, "type": "text", "section": "Page 234"}
{"text": "PROXY \n215\nvoid ImageProxy::Draw (const Point& at) {\nGetImage()->Draw(at);\n}\nvoid ImageProxy::HandleMouse (Event& event) {\nGetlmage()->HandleMouse(event);\n}\nThe Save operation saves the cached image extent and the image file name\nto a stream. Load retrieves this information and initializes the corresponding\nmembers.\nvoid ImageProxy::Save (ostream& to) \n{\nto \n\u00ab \n_extent \n\u00ab \n_fileName;\n}\nvoid ImageProxy::Load (istream& from) {\nfrom \n\u00bb \n_extent \n\u00bb \n_fileName;\n}\nFinally, suppose we have a class TextDocument that can contain \nGraphic\nobjects:\nclass TextDocument {\npublic:\nTextDocument();\nvoid Insert(Graphic*);\n// . \n. \n.\n};\nWe can insert an ImageProxy into a text document \nlike this:\nTextDocument* text = new TextDocument;\n// . \n- \n.\ntext->Insert(new ImageProxy(\"anlmageFileName\"));\n2. Proxies that use doesNotUnderstand. You can make generic proxies in\nSmalltalk by defining classes whose superclass is nil8 and defining the\ndoesNotUnderstand: method \nto handle \nmessages.\nThe following \nmethod \nassumes the proxy has a real Sub \nj ect method \nthat\nreturns its real subject. In the case of ImageProxy, this method would check\nto see if the the Image had been created, create it if necessary, and finally\nreturn it. It \nuses perform: withArgument s : to perform the message \nbeing\ntrapped on the real subject.\ndoesNotUnderstand: aMessage \n~ self realSubject \nperform: aMessage selector\nwithArguments: aMessage arguments\n8 Almost all classes ultimately have Object as their superclass. Hence this is the same as saying \"defining\na class that doesn't have Object as its superclass.\"\n", "page": 235, "type": "text", "section": "Page 235"}
{"text": "216 \nSTRUCTURAL PATTERNS \nCHAPTER 4\nThe argument to doesNotUnderstand: is an instance of Message that\nrepresents the message not understood by the proxy. So the proxy responds\nto all messages by making sure that the real subject exists before forwarding\nthe message to it.\nOne of the advantages of doesNotUnderstand: is it can perform arbitrary\nprocessing. For example, we could produce a protection proxy by specifying\na set legalMessages of messages to accept and then giving the proxy the\nfollowing method:\ndoesNotUnderstand: aMessage \n(legalMessages includes: aMessage \nselector) \nifTrue: [self realSubject\nperform: aMessage selector\nwithArguments: aMessage arguments]\nifFalse: [self error: 'Illegal operator']\nThis method checks to see that a message is legal before forwarding it to\nthe real subject. If it isn't legal, then it will send error: to the proxy, which\nwill result in an infinite loop of errors unless the proxy defines error:.\nConsequently, the definition of error: should be copied from class Object\nalong with any methods it uses.\nKnown Uses\nThe virtual \nproxy example \nin the Motivation \nsection is from the ET++ text building\nblock classes.\nNEXTSTEP [Add94] uses proxies (instances of class NXProxy) \nas local represen-\ntatives for objects that may be distributed. A server creates proxies for remote\nobjects when clients request them. On receiving a message, the proxy encodes it\nalong with its arguments and then forwards the encoded message to the remote\nsubject. Similarly, the subject encodes any return results and sends them back to\nthe NXProxy object.\nMcCullough [McC87] discusses using proxies in Smalltalk to access remote ob-\njects. Pascoe [Pas86] describes how to provide side-effects on method calls and\naccess control with \"Encapsulators.\"\nRelated Patterns\nAdapter (139): An adapter provides a different interface to the object it adapts.\nIn contrast, a proxy provides the same interface as its subject. However, a proxy\nused for access protection might refuse to perform an operation that the subject\nwill perform, so its interface may be effectively a subset of the subject's.\nDecorator (175): Although decorators can have similar implementations as prox-\nies, decorators have a different purpose. A decorator adds one or more responsi-\nbilities to an object, whereas a proxy controls access to an object.\n", "page": 236, "type": "text", "section": "Page 236"}
{"text": "PROXY \n217\nProxies vary in the degree to which they are implemented like a decorator. A\nprotection proxy might be implemented exactly like a decorator. On the other\nhand, a remote proxy will not contain a direct reference to its real subject but only\nan indirect reference, such as \"host ID and local address on host.\" A virtual proxy\nwill start off with an indirect reference such as a file name but will eventually\nobtain and use a direct reference.\n", "page": 237, "type": "text", "section": "Page 237"}
{"text": "This page intentionally left blank \n", "page": 238, "type": "text", "section": "Page 238"}
{"text": "DISCUSSION OF STRUCTURAL PATTERNS \n219\nDiscussion of Structural Patterns\nYou may have noticed similarities between the structural patterns, especially in their\nparticipants and collaborations. This is so probably because structural patterns rely on\nthe same small set of language mechanisms for structuring code and objects: single\nand multiple inheritance for class-based patterns, and object composition for object\npatterns. But the similarities belie the different intents among these patterns. In this\nsection we compare and contrast groups of structural patterns to give you a feel for\ntheir relative merits.\nAdapter versus Bridge\nThe Adapter (139) and Bridge (151) patterns have some common attributes. Both pro-\nmote flexibility by providing a level of indirection to another object. Both involve\nforwarding requests to this object from an interface other than its own.\nThe key difference between these patterns lies in their intents. Adapter focuses on\nresolving incompatibilities between two existing interfaces. It doesn't focus on how\nthose interfaces are implemented, nor does it consider how they might evolve inde-\npendently. It's a way of making two independently designed classes work together\nwithout reimplementing one or the other. Bridge, on the other hand, bridges an ab-\nstraction and its (potentially numerous) implementations. It provides a stable interface\nto clients even as it lets you vary the classes that implement it. It also accommodates\nnew implementations as the system evolves.\nAs a result of these differences, Adapter and Bridge are often used at different points\nin the software lifecycle. An adapter often becomes necessary when you discover that\ntwo incompatible classes should work together, generally to avoid replicating code. The\ncoupling is unforeseen. In contrast, the user of a bridge understands up-front that an\nabstraction must have several implementations, and both may evolve independently.\nThe Adapter pattern makes things work after they're designed; Bridge makes them\nwork before they are. That doesn't mean Adapter is somehow inferior to Bridge; each\npattern merely addresses a different problem.\nYou might think of a facade (see Facade (185)) as an adapter to a set of other objects. \nBut\nthat interpretation overlooks the fact that a facade defines a new interface, whereas an\nadapter reuses an old interface. Remember \nthat an adapter makes two existing interfaces\nwork together as opposed to defining an entirely new one.\nComposite versus Decorator \nversus Proxy\nComposite (163) \nand Decorator (175) have similar structure diagrams, reflecting the fact\nthat both rely on recursive composition to organize an open-ended number of objects.\nThis commonality might tempt you to think of a decorator object as a degenerate\n", "page": 239, "type": "text", "section": "Page 239"}
{"text": "220 \nSTRUCTURAL PATTERNS \nCHAPTER 4\ncomposite, but that misses the point of the Decorator pattern. The similarity ends at\nrecursive composition, again because of differing intents.\nDecorator is designed to let you add responsibilities to objects without subclassing. It\navoids the explosion of subclasses that can arise from trying to cover every combination\nof responsibilities statically. Composite has a different intent. It focuses on structuring\nclasses so that many related objects can be treated uniformly, and multiple objects can\nbe treated as one. Its focus is not on embellishment but on representation.\nThese intents are distinct but complementary. \nConsequently, the Composite and Deco-\nrator patterns are often used in concert. Both lead to the kind of design in which you can \nbuild applications just by plugging objects together without defining any new classes.\nThere will be an abstract class with some subclasses that are composites, some that are\ndecorators, and some that implement the fundamental building blocks of the system.\nIn this case, both composites and decorators will have a common interface. From the\npoint of view of the Decorator pattern, a composite is a ConcreteComponent. From the \npoint of view of the Composite pattern, a decorator is a Leaf. Of course, they don't have\nto be used together and, as we have seen, their intents are quite different.\nAnother pattern with a structure similar to Decorator's is Proxy (207). Both patterns\ndescribe how to provide a level of indirection to an object, and the implementations of\nboth the proxy and decorator object keep a reference to another object to which they\nforward requests. Once again, however, they are intended for different purposes.\nLike Decorator, the Proxy pattern composes an object and provides an identical in-\nterface to clients. Unlike Decorator, the Proxy pattern is not concerned with attaching\nor detaching properties dynamically, and it's not designed for recursive composition.\nIts intent is to provide a stand-in for a subject when it's inconvenient or undesirable\nto access the subject directly because, for example, it lives on a remote machine, has\nrestricted access, or is persistent.\nIn the Proxy \npattern, the subject \ndefines the key functionality, and the proxy provides (or\nrefuses) access to it. In Decorator, the component provides only part of the functionality,\nand one or more decorators furnish the rest. Decorator addresses the situation where an\nobject's total functionality can't be determined at compile time, at least not conveniently.\nThat open-endedness makes recursive composition an essential part of Decorator. That\nisn't the case in Proxy, because Proxy focuses on one relationship\u2014between the proxy\nand its subject\u2014and that relationship can be expressed statically.\nThese differences are significant because they capture solutions to specific recurring\nproblems in object-oriented design. But that doesn't mean these patterns can't be com-\nbined. You might envision a proxy-decorator that adds functionality to a proxy, or\na decorator-proxy that embellishes a remote object. Although such hybrids might be\nuseful (we don't have real examples handy), they are divisible into patterns that are\nuseful.\n", "page": 240, "type": "text", "section": "Page 240"}
{"text": "Chapter 5\nBehavioral Patterns\nBehavioral patterns are concerned with algorithms and the assignment of responsibili-\nties between objects. Behavioral patterns describe not just patterns of objects or classes\nbut also the patterns of communication between them. These patterns characterize\ncomplex control flow that's difficult to follow at run-time. They shift your focus away\nfrom flow of control to let you concentrate \njust on the way objects are interconnected.\nBehavioral class patterns use inheritance to distribute behavior between classes. This\nchapter includes two such patterns. Template Method (325) is the simpler and more\ncommon of the two. A template method is an abstract definition of an algorithm. It\ndefines the algorithm step by step. Each step invokes either an abstract operation or\na primitive operation. A subclass fleshes out the algorithm by defining the abstract\noperations. The other behavioral class pattern is Interpreter (243), which represents\na grammar as a class hierarchy and implements an interpreter as an operation on\ninstances of these classes.\nBehavioral object patterns use object composition rather than inheritance. Some de-\nscribe how a group of peer objects cooperate to perform a task that no single object\ncan carry out by itself. An important issue here is how peer objects know about each\nother. Peers could maintain explicit references to each other, but that would increase\ntheir coupling. In the extreme, every object would know about every other. The Me-\ndiator (273) pattern avoids this by introducing a mediator object between peers. The\nmediator provides the indirection needed for loose coupling.\nChain of Responsibility (223) provides even looser coupling. It lets you send requests to\nan object implicitly through a chain of candidate objects. Any candidate may fulfill the\nrequest depending on run-time conditions. The number of candidates is open-ended,\nand you can select which candidates participate in the chain at run-time.\nThe Observer (293) \npattern defines and maintains a dependency between objects. The\nclassic example of Observer is in Smalltalk Model/View/Controller, where all views\nof the model are notified whenever the model's state changes.\n221\n", "page": 241, "type": "text", "section": "Page 241"}
{"text": "222 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nOther behavioral object patterns are concerned with encapsulating behavior in an object\nand delegating requests to it. The Strategy (315) pattern encapsulates an algorithm in\nan object. Strategy makes it easy to specify and change the algorithm an object uses.\nThe Command (233) \npattern encapsulates a request in an object so that it can be passed\nas a parameter, stored on a history list, or manipulated in other ways. The State \n(305)\npattern encapsulates the states of an object so that the object can change its behavior\nwhen its state object changes. Visitor (331) encapsulates behavior that would otherwise\nbe distributed across classes, and Iterator (257) abstracts \nthe way you access and traverse\nobjects in an aggregate.\n", "page": 242, "type": "text", "section": "Page 242"}
{"text": "CHAIN OF RESPONSIBILITY \n223\nCHAIN OF RESPONSIBILITY \nobject Behavioral\nIntent\nAvoid coupling the sender of a request to its receiver by giving more than one\nobject a chance to handle the request. Chain the receiving objects and pass the\nrequest along the chain until an object handles it.\nMotivation\nConsider a context-sensitive help facility for a graphical user interface. The user\ncan obtain help information on any part of the interface just by clicking on it.\nThe help that's provided depends on the part of the interface that's selected and\nits context; for example, a button widget in a dialog box might have different\nhelp information than a similar button in the main window. If no specific help\ninformation exists for that part of the interface, then the help system should\ndisplay a more general help message about the immediate context\u2014the dialog\nbox as a whole, for example.\nHence it's natural to organize help information according to its generality\u2014from\nthe most specific to the most general. Furthermore, it's clear that a help request\nis handled by one of several user interface objects; which one depends on the\ncontext and how specific the available help is.\nThe problem here is that the object that ultimately provides the help isn't known\nexplicitly to the object (e.g., the button) that initiates the help request. What we\nneed is a way to decouple the button that initiates the help request from the objects\nthat might provide help information. The Chain of Responsibility pattern defines\nhow that happens.\nThe idea of this pattern is to decouple senders and receivers by giving multiple\nobjects a chance to handle a request. The request gets passed along a chain of\nobjects until one of them handles it.\nspecific \ngeneral\n", "page": 243, "type": "text", "section": "Page 243"}
{"text": "224\nBEHAVIORAL PATTERNS\nCHAPTER 5\nThe first object in the chain receives the request and either handles it or forwards\nit to the next candidate on the chain, which does likewise. The object that made\nthe request has no explicit knowledge of who will handle it\u2014we say the request\nhas an implicit receiver.\nLet's assume the user clicks for help on a button widget marked \"Print.\" The\nbutton is contained in an instance of PrintDialog, which knows the application\nobject it belongs to (see preceding object diagram). The following interaction\ndiagram illustrates how the help request gets forwarded along the chain:\nIn this case, neither aPrintButton \nnor aPrintDialog \nhandles the request; it stops at\nanApplication, which can handle it or ignore it. The client that issued the request\nhas no direct reference to the object that ultimately fulfills it.\nTo forward the request along the chain, and to ensure receivers remain implicit,\neach object on the chain shares a common interface for handling requests and for\naccessing its successor on the chain. For example, the help system might define\na HelpHandler class with a corresponding HandleHelp operation. HelpHandler\ncan be the parent class for candidate object classes, or it can be defined as a mixin\nclass. Then classes that want to handle help requests can make HelpHandler a\nparent:\n", "page": 244, "type": "text", "section": "Page 244"}
{"text": "CHAIN OF RESPONSIBILITY \n225\nThe Button, Dialog, and Application classes use HelpHandler operations to handle\nhelp requests. HelpHandler's HandleHelp operation forwards the request to the\nsuccessor by default. Subclasses can override this operation to provide help under\nthe right circumstances; otherwise they can use the default implementation to\nforward the request.\nApplicability\nUse Chain of Responsibility when\n\u2022 more than one object may handle a request, and the handler isn't known a\npriori. The handler should be ascertained \nautomatically.\n\u2022 you want to issue a request to one of several objects without specifying the\nreceiver explicitly.\n\u2022 the set of objects that can handle a request should be specified \ndynamically.\nStructure\nA typical object structure might look like this:\nParticipants\n\u2022 Handler (HelpHandler)\n- defines an interface for handling requests.\n- (optional) implements the successor link.\n", "page": 245, "type": "text", "section": "Page 245"}
{"text": "226 \nBEHAVIORAL PATTERNS \nCHAPTER 5\n\u2022 ConcreteHandler (PrintButton, PrintDialog)\n-\nhandles requests it is responsible for.\n-\ncan \naccess its successor.\n-\nif the ConcreteHandler can handle the request, it does so; otherwise it\nforwards the request to its successor.\n\u2022 Client\n- initiates the request to a ConcreteHandler object on the chain.\nCollaborations\n\u2022 When a client issues a request, the request propagates along the chain until a\nConcreteHandler object takes responsibility for handling it.\nConsequences\nChain of Responsibility has the following benefits and liabilities:\n1. Reduced coupling. The pattern frees an object from knowing which other\nobject handles a request. An object only has to know that a request will be\nhandled \"appropriately.\" Both the receiver and the sender have no explicit\nknowledge of each other, and an object in the chain doesn't have to know\nabout the chain's structure.\nAs a result, Chain of Responsibility can simplify object interconnections.\nInstead of objects maintaining references to all candidate receivers, they\nkeep a single reference to their successor.\n2. Added flexibility in assigning responsibilities to objects. Chain of Responsibility \ngives you added flexibility in distributing responsibilities among objects.\nYou can add or change responsibilities for handling a request by adding\nto or otherwise changing the chain at run-time. You can combine this with\nsubclassing to specialize handlers statically.\n3. Receipt isn't guaranteed. Since a request has no explicit receiver, there's no\nguarantee it'll be handled\u2014the request can fall off the end of the chain without\never being handled. A request can also go unhandled when the chain is not\nconfigured properly.\nImplementation\nHere are implementation issues to consider in Chain of Responsibility:\n1. Implementing the successor chain. There are two possible ways to implement\nthe successor chain:\n(a) Define new links (usually in the Handler, but ConcreteHandlers could\ndefine them instead).\n", "page": 246, "type": "text", "section": "Page 246"}
{"text": "CHAIN OF RESPONSIBILITY \n227\n(b) Use existing links.\nOur examples so far define new links, but often you can use existing object\nreferences to form the successor chain. For example, parent references in a\npart-whole hierarchy can define a part's successor. A widget structure might\nalready have such links. Composite (163) \ndiscusses parent references in more\ndetail.\nUsing existing links works well when the links support the chain you need.\nIt saves you from defining links explicitly, and it saves space. But if the\nstructure doesn't reflect the chain of responsibility your application requires,\nthen you'll have to define redundant links.\n2. Connecting successors. If there are no preexisting references for defining a\nchain, then you'll have to introduce them yourself. In that case, the Handler\nnot only defines the interface for the requests but usually maintains the\nsuccessor as well. That lets the handler provide a default implementation \nof HandleRequest that forwards the request to the successor (if any). If a\nConcreteHandler subclass isn't interested in the request, it doesn't have to\noverride the forwarding operation, since its default implementation forwards\nunconditionally.\nHere's a HelpHandler base class that maintains a successor link:\nclass HelpHandler {\npublic:\nHelpHandler(HelpHandler* s) : \n_successor(s) { \n}\nvirtual void HandleHelp();\nprivate:\nHelpHandler* _successor;\n};\nvoid HelpHandler::HandleHelp () \n{\nif (_successor) {\n_successor->HandleHelp();\n}\n}\n3. Representing requests. Different options are available \nfor representing requests.\nIn the simplest form, the request is a hard-coded operation invocation, as in\nthe case of HandleHelp. This is convenient and safe, but you can forward\nonly the fixed set of requests that the Handler class defines.\nAn alternative is to use a single handler function that takes a request code\n(e.g., an integer constant or a string) as parameter. This supports an open-\nended set of requests. The only requirement is that the sender and receiver\nagree on how the request should be encoded.\nThis approach is more flexible, but it requires conditional statements for\ndispatching the request based on its code. Moreover, there's no type-safe\nway to pass parameters, so they must be packed and unpacked manually.\nObviously this is less safe than invoking an operation directly.\n", "page": 247, "type": "text", "section": "Page 247"}
{"text": "228 \nBEHAVIORAL PATTERNS \nCHAPTERS\nTo address the parameter-passing problem, we can use separate request\nobjects that bundle request parameters. A Request class can represent re-\nquests explicitly, and new kinds of requests can be defined by subclassing.\nSubclasses can define different parameters. Handlers must know the kind\nof request (that is, which Request subclass they're using) to access these\nparameters.\nTo identify the request, Request can define an accessor function that returns\nan identifier for the class. Alternatively, the receiver can use run-time type\ninformation if the implementation languages supports it.\nHere is a sketch of a dispatch function that uses request objects to identify\nrequests. A GetKind operation defined in the base Request class identifies\nthe kind of request:\nvoid Handler::HandleRequest (Request* theRequest) {\nswitch (theRequest->GetKind()) \n{ \ncase Help:\n// cast argument to appropriate type\nHandleHelp((HelpRequest*) theRequest);\nbreak;\ncase Print: \nHandlePrint((PrintRequest*) theRequest);\n// . \n. \n.\nbreak;\ndefault: \n// . \n. \n.\nbreak;\n}\n}\nSubclasses can extend the dispatch by overriding HandleRequest. The\nsubclass handles only the requests in which it's interested; other requests\nare forwarded to the parent class. In this way, subclasses effectively ex-\ntend (rather than override) the HandleRequest operation. For example, \nhere's how an ExtendedHandler subclass extends Handler's version of\nHandleRequest:\nclass ExtendedHandler : \npublic Handler {\npublic:\nvirtual void HandleRequest(Request* theRequest);\n// . \n. \n.\n};\nvoid ExtendedHandler::HandleRequest (Request* theRequest) {\nswitch (theRequest->GetKind()) \n{ \ncase Preview:\n// handle the Preview request\nbreak;\n", "page": 248, "type": "text", "section": "Page 248"}
{"text": "CHAIN OF RESPONSIBILITY \n229\ndefault:\n// let Handler handle other requests\nHandler::HandleRequest(theRequest);\n}\n4. Automatic forwarding in Smalltalk. You can use the doesNotUnderstand\nmechanism in Smalltalk to forward requests. Messages that have\nno corresponding methods are trapped in the implementation of\ndoesNotUnderstand, which can be overridden to forward the message\nto an object's successor. Thus it isn't necessary to implement forwarding\nmanually; the class handles only the request in which it's interested, and it\nrelies on doesNotUnderstand to forward all others.\nSample Code\nThe following example illustrates how a chain of responsibility can handle re-\nquests for an on-line help system like the one described earlier. The help request\nis an explicit operation. We'll use existing parent references in the widget hier-\narchy to propagate requests between widgets in the chain, and we'll define a\nreference in the Handler class to propagate \nhelp requests between nonwidgets in\nthe chain.\nThe HelpHandler class defines the interface for handling help requests. It main-\ntains a help topic (which is empty by default) and keeps a reference to its successor\non the chain \nof help handlers. The key operation is HandleHelp, which subclasses\noverride. HasHelp is a convenience operation for checking whether there is an\nassociated help topic.\ntypedef int Topic; \nconst Topic NO_HELP_TOPIC = -1;\nclass HelpHandler {\npublic:\nHelpHandler(HelpHandler* = 0, Topic = NO_HELP_TOPIC);\nvirtual bool HasHelp(); \nvirtual void SetHandler(HelpHandler*, Topic);\nvirtual void HandleHelp();\nprivate:\nHelpHandler* _successor;\nTopic _topic;\n};\nHelpHandler::HelpHandler (\nHelpHandler* h, Topic t \n) : \n_successor(h), _topic(t) { \n}\nbool HelpHandler::HasHelp () \n{\nreturn _topic != NO_HELP_TOPIC;\n}\n", "page": 249, "type": "text", "section": "Page 249"}
{"text": "230 \nBEHAVIORAL PATTERNS \nCHAPTERS\nvoid HelpHandler::HandleHelp () \n{\nif (_successor != 0) {\n_successor->HandleHelp();\n}\n}\nAll widgets are subclasses of the Widget abstract class. Widget is a subclass of\nHelpHandler, since all user interface elements can have help associated with\nthem. (We could have used a mixin-based implementation just as well.)\nclass Widget : \npublic HelpHandler {\nprotected:\nWidget(Widget* parent, Topic t = \nNO_HELP_TOPIC);\nprivate:\nWidget* _parent;\n};\nWidget::Widget (Widget* w, Topic t) : \nHelpHandler(w, t) {\n_parent = w;\n}\nIn our example, a button is the first handler on the chain. The Button class is a\nsubclass of Widget. The Button constructor takes two parameters: a reference\nto its enclosing widget and the help topic.\nclass Button : \npublic Widget {\npublic:\nButton(Widget* d, Topic t = NO_HELP_TOPIC);\nvirtual void HandleHelp(); \n// Widget operations that Button overrides...\n};\nButton's version of HandleHelp first tests to see if there is a help topic for\nbuttons. If the developer hasn't defined one, then the request gets forwarded to\nthe successor using the HandleHelp operation in HelpHandler. If there is a\nhelp topic, then the button displays it, and the search ends.\nButton::Button (Widget* h, Topic t) : \nWidgetfh, t) { \n}\nvoid Button::HandleHelp () \n{\nif (HasHelpO) {\n// offer help on the button\n} else {\nHelpHandler::HandleHelp();\n}\n}\nDialog implements a similar scheme, except that its successor is not a widget\nbut any help handler. In our application this successor will be an instance of\nApplication.\n", "page": 250, "type": "text", "section": "Page 250"}
{"text": "CHAIN OF RESPONSIBILITY \n231\nclass Dialog : \npublic Widget {\npublic:\nDialog(HelpHandler* h, Topic t = NO_HELP_TOPIC);\nvirtual void HandleHelp();\n// Widget operations that Dialog overrides...\n// . \n. \n.\n};\nDialog::Dialog (HelpHandler* h, Topic t) : \nWidget(O) \n{\nSetHandler(h, t);\n}\nvoid Dialog::HandleHelp () \n{\nif (HasHelpO \n) \n{\n// offer help on the dialog\n} else \n{\nHelpHandler::HandleHelp();\n}\n}\nAt the end of the chain is an instance of Application. The application is not\na widget, so Application is subclassed directly from HelpHandler. When a \nhelp request propagates to this level, the application can supply information on\nthe application in general, or it can offer a list of different help topics:\nclass Application : \npublic HelpHandler {\npublic:\nApplication(Topic t) : \nHelpHandler(0, t) { \n}\nvirtual void HandleHelp(); \n// application-specific operations...\n};\nvoid Application::HandleHelp () \n{\n// show a list of help topics\n}\nThe following code creates and connects these objects. Here the dialog concerns\nprinting, and so the objects have printing-related topics assigned.\nconst Topic PRINT_TOPIC - 1 \n; \nconst Topic PAPER_ORIENTATION_TOPIC = 2;\nconst Topic APPLICATION_TOPIC = 3;\nApplication* application = new Application(APPLICATION_TOPIC);\nDialog* dialog = new Dialog(application, PRINT_TOPIC);\nButton* button = new Button(dialog, PAPER_ORIENTATION_TOPIC);\nWe can invoke the help request by calling Handl eHe Ip on any object \non the chain.\nTo start the search at the button object, just call HandleHelp on it:\n", "page": 251, "type": "text", "section": "Page 251"}
{"text": "232 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nbutton->HandleHelp();\nIn this case, the button will handle the request immediately. Note that any\nHelpHandler class could be made the successor of Dialog. Moreover, its suc-\ncessor could be changed dynamically. So \nno matter where a dialog is used, you'll\nget the proper context-dependent help information for it.\nKnown Uses\nSeveral class libraries use the Chain of Responsibility pattern to handle user\nevents. They use different names for the Handler class, but the idea is the same:\nWhen the user clicks the mouse or presses a key, an event gets generated and\npassed along the chain. MacApp [App89] and ET++ [WGM88] call it \"Event-\nHandler,\" Symantec's TCL library [Sym93b] calls it \"Bureaucrat,\" and NeXT's\nAppKit [Add94] uses the name \"Responder.\"\nThe Unidraw framework for graphical editors defines Command objects that\nencapsulate requests to Component and Component \nView objects [VL90]. Com-\nmands are requests in the sense that a component or component view may in-\nterpret a command to perform an operation. This corresponds to the \"requests\nas objects\" approach described in Implementation. Components and component\nviews may be structured hierarchically. A component or a component view may\nforward command interpretation to its parent, which may in turn forward it to its\nparent, and so on, thereby forming a chain of responsibility.\nET++ uses Chain of Responsibility to handle graphical update. A graphical object\ncalls the InvalidateRect operation whenever it must update a part of its appear-\nance. A graphical object can't handle InvalidateRect by itself, because it doesn't\nknow enough about its context. For example, a graphical object can be enclosed\nin objects like Scrollers or Zoomers that transform its coordinate system. That \nmeans the object might be scrolled or zoomed so that it's partially out of view.\nTherefore the default implementation of InvalidateRect forwards the request to\nthe enclosing container object. The last object in the forwarding chain is a Window\ninstance. By the time Window receives the request, the invalidation rectangle is\nguaranteed to be transformed properly. The Window handles InvalidateRect by\nnotifying the window system interface and requesting an update.\nRelated Patterns\nChain of Responsibility is often applied in conjunction with Composite (163).\nThere, a component's parent can act as its successor.\n", "page": 252, "type": "text", "section": "Page 252"}
{"text": "COMMAND \n233\nCOMMAND\nObject Behavioral\nIntent\nEncapsulate a request as an object, thereby letting you parameterize clients with\ndifferent requests, queue or log requests, and support undoable operations.\nAlso Known As\nAction, \nTransaction\nMotivation\nSometimes it's necessary to issue requests to objects without knowing anything\nabout the operation being requested or the receiver of the request. For example,\nuser interface toolkits include objects like buttons and menus that carry out a\nrequest in response to user input. But the toolkit can't implement the request\nexplicitly in the button or menu, because only applications that use the toolkit\nknow what should be done on which object. As toolkit designers we have no way\nof knowing the receiver of the request or the operations that will carry it out.\nThe Command pattern lets toolkit objects make requests of unspecified applica-\ntion objects by turning the request itself into an object. This object can be stored\nand passed around like other objects. The key to this pattern is an abstract Com-\nmand class, which declares an interface for executing operations. In the simplest\nform this interface includes an abstract Execute operation. Concrete Command\nsubclasses specify a receiver-action pair by storing the receiver as an instance\nvariable and by implementing Execute to invoke the request. The receiver has the\nknowledge required to carry out the request.\nMenus can be implemented easily with Command objects. Each choice in a Menu\nis an instance of a Menultem class. An Application class creates these menus and\n", "page": 253, "type": "text", "section": "Page 253"}
{"text": "234\nBEHAVIORAL PATTERNS\nCHAPTER 5\ntheir menu items along with the rest of the user interface. The Application class\nalso keeps track of Document objects that a user has opened.\nThe application configures each Menultem with an instance of a concrete Com-\nmand subclass. When the user selects a Menultem, the Menultem calls Execute\non its command, and Execute carries out the operation. Menultems don't know\nwhich subclass of Command they use. Command subclasses store the receiver of\nthe request and invoke one or more operations on the receiver.\nFor example, PasteCommand supports pasting text from the clipboard into a\nDocument. PasteCommand's receiver is the Document object it is supplied upon\ninstantiation. The Execute operation invokes Paste on the receiving Document.\nOpenCommand's Execute operation is different: it prompts the user for a docu-\nment name, creates a corresponding Document object, adds the document to the\nreceiving application, and opens the document.\nSometimes a Menultem needs to execute a sequence of commands. For example, a\nMenultem for centering a page at normal size could be constructed from a Cen-\nterDocumentCommand object and a NormalSizeCommand object. Because it's\ncommon to string commands together in this way, we can define a MacroCom-\nmand class to allow a Menultem to execute an open-ended number of commands.\n", "page": 254, "type": "text", "section": "Page 254"}
{"text": "COMMAND \n235\nMacroCommand is a concrete Command subclass that simply executes a sequence\nof Commands. MacroCommand has no explicit receiver, because the commands\nit sequences define their own receiver.\nIn each of these examples, notice how the Command pattern decouples the object\nthat invokes the operation from the one having the knowledge to perform it. This\ngives us a lot of flexibility in designing our user interface. An application can\nprovide both a menu and a push button interface to a feature just by making\nthe menu and the push button share an instance of the same concrete Command\nsubclass. We can replace commands dynamically, which would be useful for\nimplementing context-sensitive menus. We \ncan also support command scripting\nby composing commands into larger ones. All of this is possible because the object\nthat issues a request only needs to know how to issue it; it doesn't need to know\nhow the request will be carried out.\nApplicability\nUse the Command pattern when you want to\n\u2022 parameterize objects by an action to perform, as Menultem objects did above.\nYou can express such parameterization in a procedural language with a\ncallback function, that is, a function that's registered somewhere to be called\nat a later point. Commands are an object-oriented replacement for callbacks.\n\u2022 specify, queue, and execute requests at different times. A Command object\ncan have a lifetime independent of the original request. If the receiver of a\nrequest can be represented in an address space-independent way, then you\ncan transfer a command object for the request to a different process and fulfill\nthe request there.\n\u2022 support undo. The Command's Execute operation can store state for revers-\ning its effects in the command itself. The Command interface must have an\nadded Unexecute operation that reverses the effects of a previous call to Ex-\n", "page": 255, "type": "text", "section": "Page 255"}
{"text": "236\nBEHAVIORAL PATTERNS\nCHAPTER 5\necute. Executed commands are stored in a history list. Unlimited-level undo\nand redo is achieved by traversing this list backwards and forwards calling\nUnexecute and Execute, respectively.\n\u2022 support logging changes so that they can be reapplied in case of a system\ncrash. By augmenting the Command interface with load and store opera-\ntions, you can keep a persistent log of changes. Recovering from a crash\ninvolves reloading logged commands from disk and reexecuting them with\nthe Execute operation.\n\u2022 structure a system around high-level operations built on primitives opera-\ntions. Such a structure is common in information \nsystems that support trans-\nactions. A transaction encapsulates a set of changes to data. The Command\npattern offers a way to model transactions. Commands have a common in-\nterface, letting you invoke all transactions the same way. The pattern also\nmakes it easy to extend the system with new transactions.\nStructure\nParticipants\n\u2022 Command\n- declares an interface for executing an operation.\n\u2022 ConcreteCommand (PasteCommand, OpenCommand)\n- defines a binding between a Receiver object and an action.\n- implements Execute by invoking the corresponding operation(s) on \nRe-\nceiver.\n\u2022 Client (Application)\n- creates a ConcreteCommand object and sets its receiver.\n\u2022 Invoker (Menultem)\n- asks the command to carry out \nthe request.\n", "page": 256, "type": "text", "section": "Page 256"}
{"text": "COMMAND \n237\n\u2022 Receiver (Document, \nApplication)\n- knows how to perform the operations associated with carrying out a re-\nquest. Any class may serve as a Receiver.\nCollaborations\n\u2022 The client creates a ConcreteCommand object and specifies its receiver.\n\u2022 An Invoker object stores the ConcreteCommand object.\n\u2022 The invoker issues a request by calling Execute on the command. When com-\nmands are undoable, ConcreteCommand stores state for undoing the com-\nmand prior to invoking Execute.\n\u2022 The ConcreteCommand object invokes operations on its receiver to carry out\nthe request.\nThe following diagram shows the interactions between these objects. It illustrates\nhow Command decouples the invoker from the receiver (and the request it carries\nout).\nConsequences\nThe Command pattern has the following consequences:\n1. Command decouples the object that invokes the operation from the one that\nknows how to perform it.\n2. Commands are first-class objects. They can be manipulated and extended\nlike any other object.\n3. You \ncan assemble commands into a composite command. An example is the\nMacroCommand class described earlier. In general, composite commands \nare an instance of the Composite (163) pattern.\n4. It's easy to add new Commands, because you don't have to change existing\nclasses.\n", "page": 257, "type": "text", "section": "Page 257"}
{"text": "238 \nBEHAVIORAL PATTERNS \nCHAPTERS\nImplementation\nConsider the following issues when implementing the Command pattern:\n1. How intelligent should a command be? A command can have a wide range of\nabilities. At one extreme it merely defines a binding between a receiver and\nthe actions that carry out the request. At the other extreme it implements\neverything itself without delegating to a receiver at all. The latter extreme is\nuseful when you want to define commands that are independent of existing\nclasses, when no suitable receiver exists, or when a command knows its\nreceiver implicitly. For example, a command that creates another application\nwindow may be just as capable of creating the window as any other object.\nSomewhere in between these extremes are commands that have enough\nknowledge to find their receiver dynamically.\n2. Supporting undo and redo. Commands can support undo and redo capabilities\nif they provide a way to reverse their execution (e.g., an Unexecute or Undo\noperation). A ConcreteCommand class might need to store additional state\nto do so. This state can include\n\u2022 the Receiver object, which actually carries out operations in response to\nthe request,\n\u2022 the arguments to the operation performed on the receiver, and\n\u2022 any original values in the receiver that can change as a result of handling\nthe request. The receiver must provide operations that let the command\nreturn the receiver to its prior state.\nTo support one level of undo, an application needs to store only the com-\nmand that was executed last. For multiple-level undo and redo, the applica-\ntion needs a history list of commands that have been executed, where the\nmaximum length of the list determines the number of undo/redo levels. The\nhistory list stores sequences of commands that have been executed. Travers-\ning backward through the list and reverse-executing commands cancels their\neffect; traversing forward and executing commands reexecutes them.\nAn undoable command might have to be copied before it can be placed\non the history list. That's because the command object that carried out the\noriginal request, say, from a Menultem, will perform other requests at later\ntimes. Copying is required to distinguish different invocations of the same\ncommand if its state can vary across invocations.\nFor example, a DeleteCommand that deletes selected objects must store dif-\nferent sets of objects each time it's executed. Therefore the DeleteCommand\nobject must be copied following execution, and the copy is placed on the his-\ntory list. If the command's state never changes on execution, then copying is\nnot required\u2014only a reference to the command need be placed on the history\nlist. Commands that must be copied before being placed on the history list\nact as prototypes (see Prototype (117)).\n", "page": 258, "type": "text", "section": "Page 258"}
{"text": "COMMAND \n239\n3. Avoiding error accumulation in the undo process. Hysteresis can be a problem in\nensuring a reliable, semantics-preserving undo/redo mechanism. Errors \ncan\naccumulate as commands are executed, unexecuted, and reexecuted repeat-\nedly so that an application's state eventually diverges from original values.\nIt may be necessary therefore to store more information in the command to\nensure that objects are restored to their original state. The Memento (283) pat-\ntern can be applied to give the command access to this information without\nexposing the internals of other objects.\n4. Using C++ templates. For commands that (1) aren't undoable and (2) don't\nrequire arguments, we can use C++ templates to avoid creating a Command\nsubclass for every kind of action and receiver. We show how to do this in the\nSample Code section.\nSample Code\nThe C++ code shown here sketches the implementation of the Command classes\nin the Motivation section. We'll define OpenCommand, PasteCommand, and\nMacroCommand. First the abstract Command class:\nclass Command {\npublic:\nvirtual \"Command();\nvirtual void Execute() = 0;\nprotected:\nCommand();\n};\nOpenCommand opens a document whose name is supplied by the user. An\nOpenCommand must be passed an Application object in its constructor.\nAskUser is an implementation routine that prompts the user for the name of\nthe document to open.\nclass OpenCommand : \npublic Command {\npublic:\nOpenCommand(Application*);\nvirtual void Execute();\nprotected:\nvirtual const char* AskUser();\nprivate:\nApplication* _application;\nchar* _response;\n};\nOpenCommand::OpenCommand (Application* \na) \n{\n_application = a;\n}\n", "page": 259, "type": "text", "section": "Page 259"}
{"text": "240 \nBEHAVIORAL PATTERNS \nCHAPTERS\nvoid OpenCommand::Execute () {\nconst char* name = AskUser();\nif (name != 0) { \nDocument* document = new Document(name);\n_application->Add(document);\ndocument->0pen();\n}\nA Pas teCoiranand must be passed a Document object as its receiver. \nThe \nreceiver\nis given as a parameter \nto PasteCommand's \nconstructor.\nclass PasteCommand : \npublic Command {\npublic:\nPas \nteCommand(Document \n*);\nvirtual void Execute();\nprivate:\nDocument* _document;\n};\nPasteCommand::PasteCommand (Document* doc) {\n_document = doc;\n}\nvoid PasteCommand::Execute () {\n_document->Paste();\n}\nFor simple commands that aren't undoable and don't require arguments, we\ncan use a class template to parameterize the command's receiver. We'll define\na template subclass SimpleCommand for such commands. SimpleCommand is\nparameterized by the Receiver type and maintains a binding between a receiver\nobject and an action stored as a pointer to a member function.\ntemplate <class Receiver> \nclass SimpleCommand : \npublic Command { \npublic:\ntypedef void (Receiver::* Action)();\nSimpleCommand(Receiver* r, Action a) :\n_receiver(r), _action(a) { \n}\nvirtual void Execute();\nprivate:\nAction _action;\nReceiver* _receiver;\n};\nThe constructor stores the receiver and the action in the corresponding instance\nvariables. Execute simply applies the action to the receiver.\n", "page": 260, "type": "text", "section": "Page 260"}
{"text": "COMMAND \n241\ntemplate <class Receiver> \nvoid SimpleCommand<Receiver>::Execute () {\n(_receiver->*_action)();\n}\nTo create a command that calls Action on an instance of class MyClass, a client\nsimply writes\nMyClass* receiver = new MyClass;\n// . . .\nCommand* aCommand =\nnew SimpleCommand<MyClass>(receiver, &MyClass::Action);\n// . . .\naCommand->Execute() ;\nKeep in mind that this solution only works for simple commands. More complex\ncommands that keep track of not only their receivers but also arguments and/or\nundo state require a Command subclass.\nA MacroCommandmanages a sequence of subcommands and provides operations\nfor adding and removing subcommands. No explicit \nreceiver is required, \nbecause\nthe subcommands already define their receiver.\nclass MacroCommand : \npublic Command {\npublic:\nMacroCommand(); \nvirtual \"MacroCommand();\nvirtual void Add(Command*);\nvirtual void Remove(Command*);\nvirtual void Execute();\nprivate:\nList<Command*>* _cmds;\n};\nThe key to the MacroCommand is its Execute member function. This traverses\nall the subcommands and performs Execute on each of them.\nvoid MacroCommand::Execute () {\nListIterator<Command*> i(_cmds);\nfor (i. \nFirst \n(); ! \ni \n. \nIsDone \n() \n; i.NextO) {\nCommand* c = i.Currentltem();\nc->Execute();\n}\nNote that should the MacroCommand implement an Unexecute operation, then\nits subcommands must be unexecuted in reverse order relative to Execute's im-\nplementation.\nFinally, MacroCommand must provide operations to manage its subcommands.\nThe MacroCommand is also responsible for deleting its subcommands.\n", "page": 261, "type": "text", "section": "Page 261"}
{"text": "242 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nvoid MacroCommand::Add (Command* c) \n{\n_cmds->Append(c) ;\n}\nvoid MacroCommand::Remove (Command* c) \n{\n_cmds->Remove(c);\n}\nKnown Uses\nPerhaps the first example of the Command pattern appears in a paper by\nLieberman [Lie85]. MacApp [App89] popularized the notion of commands for\nimplementing undoable operations. ET++ [WGM88], Interviews [LCI+92], and\nUnidraw [VL90] also define classes that follow the Command pattern. Interviews\ndefines an Action abstract class that provides command functionality. It also de-\nfines an ActionCallback template, parameterized by action method, that can in-\nstantiate command subclasses automatically.\nThe THINK class library [Sym93b] also uses commands to support undoable\nactions. Commands in THINK are called \"Tasks.\" Task objects are passed along a\nChain of Responsibility (223) \nfor consumption.\nUnidraw's command objects are unique in that they can behave like messages. A\nUnidraw command may be sent to another object for interpretation, and the result\nof the interpration varies with the receiving object. Moreover, the receiver may\ndelegate the interpretation to another object, typically the receiver's parent in a \nlarger structure as in a Chain of Responsibility. The receiver of a Unidraw com-\nmand is thus computed rather than stored. Unidraw's interpretation mechanism\ndepends on run-time type information.\nCoplien describes how to implement functors, objects that are functions, in\nC++ [Cop92]. He achieves a degree of transparency in their use by overload-\ning the function call operator (operator ( ) ) . The Command pattern is different;\nits focus is on maintaining a binding between a receiver and a function (i.e., action),\nnot just maintaining a function.\nRelated Patterns\nA Composite (163) can be used to implement MacroCommands.\nA Memento (283) can keep state the command requires to undo its effect.\nA command that must be copied before being placed on the history list acts as a\nPrototype (117).\n", "page": 262, "type": "text", "section": "Page 262"}
{"text": "INTERPRETER \n243\nINTERPRETER \nciass Behavioral\nIntent\nGiven a language, define a represention for its grammar along with an interpreter\nthat uses the representation to interpret sentences in the language.\nMotivation\nIf a particular kind of problem occurs often enough, then it might be worthwhile\nto express instances of the problem as sentences in a simple language. Then you\ncan build an interpreter that solves the problem by interpreting these sentences.\nFor example, searching for strings that match a pattern is a common problem.\nRegular expressions are a standard language for specifying patterns of strings.\nRather than building custom algorithms to match each pattern against strings,\nsearch algorithms could interpret a regular expression that specifies a set of strings\nto match.\nThe Interpreter pattern describes how to define a grammar for simple languages,\nrepresent sentences in the language, and interpret these sentences. In this example,\nthe pattern describes how to define a grammar for regular expressions, represent\na particular regular expression, and how to interpret that regular expression.\nSuppose the following grammar defines the regular expressions:\nexpression ::= literal | \nalternation | \nsequence | \nrepetition \n|\n'(' expression ')' \nalternation ::- \nexpression '\n|\n' expression \nsequence ::- expression '\n&\n' expression \nrepetition ::= expression '*' \nliteral ::- 'a' \\ \n'b' | \n'c' \n| \n... \n{ 'a' | \n'b' \n| \n'c' \n| ... \n}*\nThe symbol expression is the start symbol, and literal is a terminal symbol\ndefining simple words\nThe Interpreter pattern uses a class to represent each grammar rule. Symbols on\nthe right-hand side of the rule are instance variables of these classes. The \ngrammar\nabove is represented by five classes: an abstract class RegularExpression \nand its\nfour subclasses LiteralExpression, AlternationExpression, SequenceExpression,\nand RepetitionExpression. The last three classes define variables that hold subex-\npressions.\n", "page": 263, "type": "text", "section": "Page 263"}
{"text": "244\nBEHAVIORAL PATTERNS\nCHAPTER 5\nEvery regular expression defined by this grammar is represented by an abstract\nsyntax tree made up of instances of these classes. For example, the abstract syntax\ntree\nrepresents the regular expression\nraining & (dogs | \ncats) \n*\nWe can create an interpreter for these regular expressions by defining the Interpret\noperation on each subclass of RegularExpression. Interpret takes as an argument\nthe context in which to interpret the expression. The context contains the input\nstring and information on how much of it has been matched so far. Each subclass\nof RegularExpression implements Interpret to match the next part of the input\nstring based on the current context. For example,\n", "page": 264, "type": "text", "section": "Page 264"}
{"text": "INTERPRETER\n245\n\u2022 LiteralExpression \nwill check if the input matches the literal it defines,\n\u2022 AlternationExpression will check if the input matches any of its alternatives,\n\u2022 RepetitionExpression will check if the input has multiple copies of expression\nit repeats,\nand so on.\nApplicability\nUse the Interpreter pattern when there is a language to interpret, and you can\nrepresent statements in the language as abstract syntax trees. The Interpreter\npattern works best when\n\u2022 the grammar is simple. For complex grammars, the class hierarchy for the\ngrammar becomes large and unmanageable. Tools such as parser generators\nare a better alternative in such cases. They can interpret expressions without\nbuilding abstract syntax trees, which can save space and possibly time.\n\u2022 efficiency is not a critical concern. The most efficient interpreters are usually\nnot implemented by interpreting parse trees directly but by first translating\nthem into another form. For example, regular expressions are often trans-\nformed into state machines. But even then, the translator can be implemented\nby the Interpreter pattern, so the pattern is still applicable.\nStructure\nParticipants\n\u2022 AbstractExpression (RegularExpression)\n- declares an abstract Interpret operation that is common to all nodes in the\nabstract syntax tree.\n", "page": 265, "type": "text", "section": "Page 265"}
{"text": "246 \nBEHAVIORAL PATTERNS \nCHAPTER 5\n\u2022 TerminalExpression (LiteralExpression)\n-\nimplements an Interpret operation associated with terminal symbols in the\ngrammar.\n-\nan instance is required for every terminal symbol in a sentence.\n\u2022 NonterminalExpression (AlternationExpression, RepetitionExpression, Se-\nquenceExpressions)\n- one such class is required for every rule R ::= R\\R^ \u2022 \n\u2022. \nRn in the grammar.\n- maintains instance variables of type AbstractExpression for each of the\nsymbols RI through Rn.\n-\nimplements an Interpret operation for nonterminal symbols in the gram-\nmar. Interpret typically calls itself recursively on the variables representing\nRI through Jin.\n\u2022 Context\n- contains information that's global to \nthe \ninterpreter.\n\u2022 Client\n-\nbuilds (or is given) an abstract syntax tree representing a particular sen-\ntence in the language that the grammar defines. The abstract syntax tree is\nassembled from instances of the NonterminalExpression and TerminalEx-\npression classes.\n-\ninvokes the Interpret operation.\nCollaborations\n\u2022 The client builds (or is given) the sentence as an abstract syntax tree of Nonter-\nminalExpression and TerminalExpression instances. Then the client initializes\nthe context and invokes the Interpret operation.\n\u2022 Each NonterminalExpression node defines Interpret in terms of Interpret on\neach subexpression. The Interpret operation of each TerminalExpression de-\nfines the base case in the recursion.\n\u2022 The Interpret operations at each node use the context to store and access the\nstate of the interpreter.\nConsequences\nThe Interpreter pattern has the following benefits and liabilities:\n1. It's easy to change and extend the grammar. Because the pattern uses classes \nto represent grammar rules, you can use inheritance to change or extend\nthe grammar. Existing expressions can be modified incrementally, and new \nexpressions can be defined as variations on old ones.\n", "page": 266, "type": "text", "section": "Page 266"}
{"text": "INTERPRETER \n247\n2. Implementing the grammar is easy, too. \nClasses defining nodes in the abstract\nsyntax tree have similar implementations. These classes are easy to write, and\noften their generation can be automated with a compiler or parser generator.\n3. Complex grammars are \nhard to maintain. The Interpreter pattern defines at least\none class for every rule in the grammar (grammar rules defined using BNF\nmay require multiple classes). Hence grammars containing many rules can\nbe hard to manage and maintain. Other design patterns can be applied to\nmitigate the problem (see Implementation). But when the grammar is very\ncomplex, other techniques such as parser or compiler generators are more\nappropriate.\n4. Adding new ways to interpret expressions. The Interpreter pattern makes it\neasier to evaluate an expression in a new way. For example, you can support\npretty printing or type-checking an expression by defining a new operation\non the expression classes. If you keep creating new ways of interpreting an\nexpression, then consider using the Visitor (331) pattern to avoid changing\nthe grammar classes.\nImplementation\nThe Interpreter and Composite (163) patterns share many implementation issues.\nThe following issues are specific to Interpreter:\n1. Creating the \nabstract syntax tree. The Interpreter pattern doesn't explain how to\ncreate an abstract syntax tree. In other words, it doesn't address parsing. The\nabstract syntax tree can be created by a table-driven parser, by a hand-crafted\n(usually recursive descent) parser, or directly by the client.\n2. Defining the Interpret operation. You don't have to define the Interpret oper-\nation in the expression classes. If it's common to create a new interpreter,\nthen it's better to use the Visitor (331) pattern to put Interpret in a separate\n\"visitor\" object. For example, a grammar for a programming language will\nhave many operations on abstract syntax trees, such as as type-checking, op-\ntimization, code generation, and so on. It will be more likely to use a visitor\nto avoid defining these operations on every grammar class.\n3. Sharing terminal symbols with the \nFlyweight pattern. \nGrammars whose sentences\ncontain many occurrences of a terminal symbol might benefit from sharing\na single copy of that symbol. Grammars for computer programs are good\nexamples\u2014each program variable will appear in many places throughout the\ncode. In the Motivation example, a sentence can have the terminal symbol\ndog (modeled by the LiteralExpression class) appearing many times.\nTerminal nodes generally don't store information about their position in the\nabstract syntax tree. Parent nodes pass them whatever context they need\nduring interpretation. Hence there is a distinction between shared (intrinsic)\nstate and passed-in (extrinsic) state, and the Flyweight (195) \npattern applies.\n", "page": 267, "type": "text", "section": "Page 267"}
{"text": "248 \nBEHAVIORAL PATTERNS \nCHAPTERS\nFor example, each instance of LiteralExpression for dog receives a context\ncontaining the substring matched so far. And every such LiteralExpression\ndoes the same thing in its Interpret operation\u2014it checks whether the next\npart of the input contains a dog\u2014no matter where the instance appears in\nthe tree.\nSample Code\nHere are two examples. The first is a complete example in Smalltalk for checking\nwhether a sequence matches a regular expression. The second is a C++ program\nfor evaluating Boolean expressions.\nThe regular expression matcher tests whether a string is in the language defined\nby the regular expression. The regular expression is defined by the following\ngrammar:\nexpression ::= literal | \nalternation | \nsequence | \nrepetition \n|\n'(' expression ')' \nalternation ::= expression \n']' expression \nsequence ::= expression '\n&\n' expression \nrepetition ::- expression 'repeat' \nliteral ::= 'a' | \n'b' \n| \n'c' | \n... \n{ \n'a' | \n'b' \n| \n'c' | \n... }*\nThis grammar is a slight modification of the Motivation example. We changed\nthe concrete syntax of regular expressions a little, because symbol \"*\" can't be\na postfix operation in Smalltalk. So we use repeat instead. For example, the\nregular expression\n(('dog ' | 'cat ' ) repeat & 'weather')\nmatches the input string \"dog dog cat weather\".\nTo implement the matcher, we define the five classes described on\npage 243. The class SequenceExpression has instance variables expres-\nsion! and expression2 for its children in the abstract syntax tree.\nAlternationExpression stores its alternatives in the instance variables\nalternativel and alternative2, while RepetitionExpressionholds the\nexpression it repeats in its repetition instance variable. LiteralExpression has\na components instance variable that holds a list of objects (probably \ncharacters).\nThese represent the literal string that must match the input sequence.\nThe match: operation implements an interpreter for the regular expression.\nEach of the classes defining the abstract syntax tree implements this operation. It\ntakes input State as an argument representing the current state of the matching\nprocess, having read part of the input string.\nThis current state is characterized by a set of input streams representing the set\nof inputs that the regular expression could have accepted so far. (This is roughly\nequivalent to recording all states that the equivalent finite state automata would\nbe in, having recognized the input stream to this point).\n", "page": 268, "type": "text", "section": "Page 268"}
{"text": "INTERPRETER \n249\nThe current state is most important to the repeat operation. For example, if the\nregular expression were\n'a' repeat\nthen the interpreter \ncould match \"a\", \"aa\", \"aaa\", and so on. If it were\n'a' repeat & 'be'\nthen it could match \"abc\", \"aabc\", \"aaabc\", and so on. But if the regular ex-\npression were\n'a' repeat & 'abc'\nthen matching the \ninput \"aabc\" against the \nsubexpression \"' a' repeat\" would\nyield two input streams, one having matched one character \nof the input, and the\nother having matched two characters. Only the stream that has accepted one\ncharacter will match the remaining \"abc\".\nNow we consider the definitions of match: for each class defining the regu-\nlar expression. The definition for SequenceExpression matches each of its\nsubexpressions in sequence. Usually it will eliminate input streams from its\ninputState.\nmatch: \ninputState \n\" expression2 match: (expressionl match: inputState).\nAn AlternationExpression will return a state that consists of the\nunion of states from either alternative. The definition of match: for\nAlternationExpression is\nmatch: inputState \nI finalState \nI \nfinalState := alternativel match: inputState.\nfinalState addAll: (alternative2 match: inputState).\n~ finalState\nThe mat ch: operation for \nRepet i t i \nonExpre \ns \ns \ni \non \ntries to \nfind \nas \nmany states\nthat could match as possible:\nmatch: inputState \nI aState finalState I \naState := inputState.\nfinalState := inputState \ncopy. \n[aState isEmpty]\nwhileFalse: \n[aState := repetition \nmatch: \naState. \nfinalState addAll: aState].\n\" \nfinalState\n", "page": 269, "type": "text", "section": "Page 269"}
{"text": "250 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nIts output state usually contains more states than its input state, because\na RepetitionExpression can match one, two, or many occurrences of\nrepetition on the input state. The output states represent all these possibil-\nities, allowing subsequent elements of the regular expression to decide which\nstate is the correct \none.\nFinally, the definition of match: for LiteralExpression tries to match its\ncomponents against each possible input stream. It keeps only those input streams \nthat have a match:\nmatch: inputState \n| finalState \ntStream \n| \nfinalState := Set \nnew.\ninputState\ndo: \n[:stream | \ntStream := \nstream copy.\n(tStream nextAvailable:\ncomponents size\n) = components \nifTrue: [finalState \nadd: \ntStream]\n] \n.\n\" finalState\nThe nextAvailable: message advances the input stream. This is the only\nmatch: operation that advances the stream. Notice how the state that's returned\ncontains a copy of the input stream, thereby ensuring that matching a literal\nnever changes the input stream. This is important because each alternative of an \nAlternationExpression should see identical copies of the input stream.\nNow that we've defined the classes that make up an abstract syntax tree, we can\ndescribe how to build it. Rather than write a parser for regular expressions, we'll\ndefine some operations on the RegularExpression \nclasses so that evaluating\na Smalltalk expression will produce an abstract syntax tree for the corresponding\nregular expression. That lets us use the built-in Smalltalk compiler as if it were a\nparser for regular expressions.\nTo build the abstract syntax tree, we'll need to define \" | \", \"repeat\", and \"&\"\nas operations on RegularExpression. These operations are defined in class\nRegularExpression like this:\n& aNode\n\" SequenceExpression new \nexpressionl: self expression2: aNode asRExp\nrepeat\nRepetitionExpression new repetition: \nself\n", "page": 270, "type": "text", "section": "Page 270"}
{"text": "INTERPRETER \n251\n| aNode\nAlternationExpression new \nalternativel: self alternative2: aNode asRExp\nasRExp \n~ self\nThe asRExp operation will convert literals into RegularExpressions. These\noperations are defined in class String:\n& aNode\nSequenceExpression new \nexpressionl: self asRExp expression2: aNode asRExp\nrepeat\nRepetitionExpression new repetition: self\n| aNode\nAlternationExpression new \nalternativel: self asRExp alternative2: aNode asRExp\nasRExp\nLiteralExpression new components: self\nIf we defined these operations higher up in the class hierarchy (Sequenceable-\nCollection in Smalltalk-80, IndexedCollection in Smalltalk/V), then they\nwould also be defined for classes such as \nArray and Order \nedCo \n11 \nact ion. This\nwould let regular expressions match sequences of any kind of object.\nThe second example is a system for manipulating and evaluating Boolean expres-\nsions implemented in C++. \nThe terminal symbols in this language are Boolean\nvariables, that is, \nthe constants true and false. Nonterminal symbols represent\nexpressions containing the operators and, or, and not. The grammar is defined\nas follows1:\nBooleanExp ::= VariableExp | \nConstant | \nOrExp | \nAndExp | \nNotExp \n|\n'(' BooleanExp ')'\nAndExp ::- BooleanExp \n'and' BooleanExp \nOrExp ::= BooleanExp \n'or' BooleanExp \nNotExp ::= 'not' BooleanExp \nConstant ::= 'true' | 'false'\nVariableExp ::= \n'A' j \n'B' \n| \n... \n| \n'X' | \n'Y' \n| \n'Z'\nWe define two operations on Boolean \nexpressions. The first, Evaluate, evaluates\na Boolean \nexpression in a context that assigns a true or false value to each variable.\nThe second operation, Replace, produces a new Boolean \nexpression by replacing\na variable with an expression. Replace shows how the Interpreter pattern can\nbe used for more than just evaluating expressions. In this case, it manipulates the\nexpression itself.\n1 \nFor simplicity, we ignore operator precedence and assume it's the responsibility of whichever object\nconstructs the syntax tree.\n", "page": 271, "type": "text", "section": "Page 271"}
{"text": "252 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nWe give details of just the BooleanExp, VariableExp, and AndExp classes\nhere. Classes OrExp and NotExp are similar to AndExp. The Constant class\nrepresents the Boolean \nconstants.\nBooleanExp defines the interface for all classes \nthat define a Boolean expression:\nclass BooleanExp {\npublic:\nBooleanExp(); \nvirtual \"BooleanExp();\nvirtual bool Evaluate(Contexts) = 0; \nvirtual BooleanExp* Replace(const char*, BooleanExpS) - 0;\nvirtual BooleanExp* CopyO const = 0;\n};\nThe class Context defines a mapping \nfrom variables to Boolean values, which \nwe\nrepresent with the C++ \nconstants true and false. Context has the following\ninterface:\nclass Context {\npublic:\nbool Lookup(const char*) const;\nvoid Assign(VariableExp*, bool);\n};\nA VariableExp represents a named variable:\nclass VariableExp : \npublic BooleanExp {\npublic:\nVariableExp(const char*);\nvirtual \"VariableExp();\nvirtual bool Evaluate(Contexts); \nvirtual BooleanExp* Replace(const char*, BooleanExpS);\nvirtual BooleanExp* Copy() const;\nprivate: \nchar \n* \n_name;\n};\nThe constructor takes the variable's \nname as an \nargument:\nVariableExp::VariableExp (const char* name) {\n_name = strdup(name);\n}\nEvaluating a variable returns its value \nin the current context.\nbool VariableExp::Evaluate (Contexts aContext) {\nreturn aContext.Lookup(_name);\n}\n", "page": 272, "type": "text", "section": "Page 272"}
{"text": "INTERPRETER \n253\nCopying a variable returns a new VariableExp:\nBooleanExp* VariableExp::Copy () \nconst {\nreturn new VariableExp(_name);\n}\nTo replace a variable with an expression, we check to see if the variable has the\nsame name as the one it is passed as an argument:\nBooleanExp* VariableExp::Replace \n(\nconst char* name, BooleanExp& exp\n) \n{\nif (strcmp(name, _name) = = 0 ) {\nreturn exp.Copy();\n} else { \nreturn new VariableExp(_name);\n}\n}\nAn AndExp represents an expression made by ANDing two Boolean expressions\ntogether.\nclass AndExp : \npublic BooleanExp {\npublic:\nAndExp(BooleanExp*, BooleanExp*);\nvirtual ~AndExp();\nvirtual bool Evaluate(Contexts); \nvirtual BooleanExp* Replace(const char*, BooleanExp&);\nvirtual BooleanExp* CopyO const;\nprivate:\nBooleanExp* _operandl;\nBooleanExp* _operand2;\n};\nAndExp::AndExp (BooleanExp* opl, BooleanExp* op2) {\n_operandl = opl;\n_operand2 = op2;\n}\nEvaluating an AndExp evaluates its operands and returns the logical \"and\" of the\nresults.\nbool AndExp::Evaluate (Contexts aContext) {\nreturn\n_operandl->Evaluate(aContext) &&\n_operand2->Evaluate(aContext);\n}\nAn AndExp implements Copy and Replace by making recursive calls on its\noperands:\n", "page": 273, "type": "text", "section": "Page 273"}
{"text": "254 \nBEHAVIORAL PATTERNS \nCHAPTERS\nBooleanExp* AndExp::Copy () const {\nreturn\nnew AndExp(_operandl->Copy(), _operand2->Copy());\n}\nBooleanExp* AndExp::Replace (const char* name, BooleanExp& \nexp) \n{\nreturn\nnew AndExp( \n_operandl->Replace(name, exp),\n_operand2->Replace(name, \nexp)\n) ;\n}\nNow we can define the Boolean expression\n(true and x) or (y and (not x ) )\nand evaluate it for a given assignment of true or false to the variables x and\ny:\nBooleanExp* expression;\nContext context;\nVariableExp* x = new VariableExp(\"X\");\nVariableExp* y - \nnew \nVariableExp(\"Y\");\nexpression = new OrExp( \nnew AndExp(new Constant(true), x), \nnew AndExp(y, new NotExp(x))\n) ;\ncontext.Assign(x, false);\ncontext.Assign(y, true);\nbool result = expression->Evaluate(context);\nThe expression evaluates to true for this assignment to x and y. We can evaluate\nthe expression with a different assignment to the variables simply by changing\nthe context.\nFinally, we can replace the variable y with a new expression and then reevaluate\nit:\nVariableExp* z = new VariableExp(\"Z\");\nNotExp not_z(z);\nBooleanExp* replacement = expression->Replace(\"Y\", not_z);\ncontext.Assign(z, true);\nresult = replacement->Evaluate(context);\nThis example illustrates an important point about the Interpreter pattern: many\nkinds of operations can \"interpret\" a sentence. Of the three operations defined\n", "page": 274, "type": "text", "section": "Page 274"}
{"text": "INTERPRETER \n255\nfor BooleanExp, Evaluate fits our idea of what an interpreter should do most\nclosely\u2014that is, it interprets a program or expression and returns a simple result.\nHowever, Replace can be viewed as an interpreter as well. It's an interpreter\nwhose context is the name of the variable \nbeing replaced along with the expression\nthat replaces it, and whose result is a new expression. Even Copy can be thought\nof as an interpreter with an empty context. It may seem a little strange to consider\nReplace and Copy to be interpreters, because these are just basic operations\non trees. The examples in Visitor (331) illustrate how all three operations can be\nrefactored into a separate \"interpreter\" visitor, thus showing that the similarity is\ndeep.\nThe Interpreter pattern is more than just an operation distributed over a class\nhierarchy that uses the Composite (163) pattern. We consider Evaluate an in-\nterpreter because we think of the BooleanExp class hierarchy as representing a\nlanguage. Given a similar class hierarchy for representing automotive part assem-\nblies, it's unlikely we'd consider operations like Weight and Copy as interpreters \neven though they are distributed over a class hierarchy that uses the Compos-\nite pattern\u2014we just don't think of automotive parts as a language. It's a matter\nof perspective; if we started publishing grammars of automotive parts, then we\ncould consider operations on those parts to be ways of interpreting the language.\nKnown Uses\nThe Interpreter pattern is widely used in compilers implemented with object-\noriented languages, as the Smalltalk compilers are. SPECTalk uses the pattern to\ninterpret descriptions of input file formats [Sza92]. The QOCA constraint-solving\ntoolkit uses it to evaluate constraints [HHMV92].\nConsidered in its most general form (i.e., an operation distributed over a class\nhierarchy based on the Composite pattern), nearly every use of the Composite\npattern will also contain the Interpreter pattern. But \nthe Interpreter pattern should\nbe reserved for those cases in which you want to think of the class hierarchy as\ndefining a language.\nRelated Patterns\nComposite (163): \nThe abstract syntax tree is an instance of the Composite pattern.\nFlyweight (195) shows how to share terminal symbols within the abstract syntax\ntree.\nIterator (257): The interpreter can use an Iterator to traverse the structure.\nVisitor (331) can be used to maintain the behavior in each node in the abstract\nsyntax tree in one class.\n", "page": 275, "type": "text", "section": "Page 275"}
{"text": "This page intentionally left blank \n", "page": 276, "type": "text", "section": "Page 276"}
{"text": "ITERATOR \n257\nITERATOR\nObject Behavioral\nIntent\nProvide a way to access the elements of an aggregate object sequentially without\nexposing its underlying representation.\nAlso Known As\nCursor\nMotivation\nAn aggregate object such as a list should give you a way to access its elements\nwithout exposing its internal structure. Moreover, you might want to traverse the\nlist in different ways, depending on what you want to accomplish. But you prob-\nably don't want to bloat the List interface with operations for different traversals,\neven if you could anticipate the ones you will need. You \nmight also need to have\nmore than one traversal pending on the same list.\nThe Iterator pattern lets you do all this. The key idea in this pattern is to take the\nresponsibility for access and traversal out of the list object and put it into an iterator\nobject. The Iterator class defines an interface for accessing the list's elements. An\niterator object is responsible for keeping track of the current element; that is, it\nknows which elements have been traversed already.\nFor example, a List class would call for a Listlterator with the following \nrelation-\nship between them:\nBefore you can instantiate Listlterator, you must supply the List to traverse. Once\nyou have the Listlterator instance, you can access the list's elements sequentially.\nThe Currentltem operation returns the current element in the list, First initializes\nthe current element to the first element, Next advances the current element to\nthe next element, and IsDone tests whether we've advanced beyond the last\nelement\u2014that is, we're finished with the traversal.\n", "page": 277, "type": "text", "section": "Page 277"}
{"text": "258\nBEHAVIORAL PATTERNS\nCHAPTER 5\nSeparating the traversal mechanism from the List object lets us define iterators\nfor different traversal policies without enumerating them in the List interface. For\nexample, FilteringListlterator might provide access only to those elements that\nsatisfy specific filtering constraints.\nNotice that the iterator and the list are coupled, and the client must know that\nit is a list that's traversed as opposed to some other aggregate structure. Hence\nthe client commits to a particular aggregate structure. It would be better if we\ncould change the aggregate class without changing client code. We \ncan do this by\ngeneralizing the iterator concept to support polymorphic iteration.\nAs an example, let's assume that we also have a SkipList implementation of a\nlist. A skiplist [Pug90] is a probabilistic data structure with characteristics similar\nto balanced trees. We want to be able to write code that works for both List and\nSkipList objects.\nWe define an AbstractList \nclass that provides a common interface for manipulating\nlists. Similarly, we need an abstract Iterator class that defines a common iteration\ninterface. Then we can define concrete Iterator subclasses for the different list\nimplementations. As a result, the iteration mechanism becomes independent of\nconcrete aggregate classes.\nThe remaining problem is how to create the iterator. Since we want to write code\nthat's independent of the concrete List subclasses, we cannot simply instantiate\na specific class. Instead, we make the list objects responsible for creating their\ncorresponding iterator. This requires an operation like Createlterator through\nwhich clients request an iterator object.\nCreatelterator is an example of a factory method (see Factory Method (107)). We\nuse it here to let a client ask a list object for the appropriate iterator. The Factory\nMethod approach give rise to two class hierarchies, one for lists and another for\niterators. The Createlterator factory method \"connects\" the two hierarchies.\n", "page": 278, "type": "text", "section": "Page 278"}
{"text": "ITERATOR \n259\nApplicability\nUse the Iterator pattern\n\u2022 to access an aggregate object's contents without exposing its internal repre-\nsentation.\n\u2022 to support multiple traversals of aggregate objects.\n\u2022 to provide a uniform interface for traversing different aggregate structures\n(that is, to support polymorphic iteration).\nStructure\nParticipants\n\u2022 Iterator\n- defines an interface for accessing and traversing elements.\n\u2022 Concretelterator\n- implements the \nIterator interface.\n- keeps track of the current position in the traversal of the aggregate.\n\u2022 Aggregate\n- defines an interface for creating an Iterator object.\n\u2022 ConcreteAggregate\n- implements the Iterator creation interface to return an instance of the\nproper Concretelterator.\n", "page": 279, "type": "text", "section": "Page 279"}
{"text": "260 \nBEHAVIORAL PATTERNS \nCHAPTERS\nCollaborations\n\u2022 A Concretelterator keeps track of the current object in the aggregate and can\ncompute the succeeding object in the traversal.\nConsequences\nThe Iterator pattern has three important consequences:\n1. It supports variations in the traversal of an aggregate. Complex aggregates may\nbe traversed in many ways. For example, code generation and semantic\nchecking involve traversing parse trees. Code generation may traverse the\nparse tree inorder or preorder. Iterators make it easy to change the traversal\nalgorithm: Just replace the iterator instance with a different one. You \ncan also\ndefine Iterator subclasses to support new traversals.\n2. Iterators simplify the Aggregate interface. Iterator's traversal interface obviates\nthe need for a similar interface in Aggregate, thereby simplifying the aggre-\ngate's interface.\n3. More than one traversal can be pending on an aggregate. An iterator keeps track\nof its own traversal state. Therefore you can have more than one traversal in\nprogress at once.\nImplementation\nIterator has many implementation variants and alternatives. Some important ones\nfollow. The trade-offs often depend on the control structures your language pro-\nvides. Some languages (CLU [LG86], for example) even support this pattern di-\nrectly.\n1. Who controls the iteration? A fundamental issue is deciding which party con-\ntrols the iteration, the iterator or the client that uses the iterator. When the\nclient controls the iteration, the iterator is called an external iterator, and\nwhen the iterator controls it, the iterator is an internal iterator.2 Clients that\nuse an external iterator must advance the traversal and request the next el-\nement explicitly from the iterator. In contrast, the client hands an internal\niterator an operation to perform, and the iterator applies that operation to\nevery element in the aggregate.\nExternal iterators are more \nflexible \nthan internal iterators. It's easy to compare\ntwo collections for equality with an external iterator, for example, but it's\npractically impossible with internal iterators. Internal iterators are especially\nweak in a language like C++ that does not provide anonymous functions,\nclosures, or continuations like Smalltalk and CLOS. But on the other hand,\n2Booch refers to external and internal iterators as active and passive iterators, respectively [Boo94]. The\nterms \"active\" and \"passive\" describe the role of the client, not the level of activity in the iterator.\n", "page": 280, "type": "text", "section": "Page 280"}
{"text": "ITERATOR \n261\ninternal iterators are easier to use, because they define the iteration logic for\nyou.\n2. Who defines the traversal algorithm? The iterator is not the only place where the\ntraversal algorithm can be defined. The aggregate might define the traversal\nalgorithm and use the iterator to store just the state of the iteration. We call\nthis kind of iterator a cursor, since it merely points to the current position in \nthe aggregate. A client will invoke the Next operation on the aggregate with\nthe cursor as an argument, and the Next operation will change the state of\nthe cursor.3\nIf the iterator is responsible for the traversal algorithm, then it's easy to use\ndifferent iteration algorithms on the same aggregate, and it can also be easier\nto reuse the same algorithm on different aggregates. On the other hand,\nthe traversal algorithm might need to access the private variables of the\naggregate. If so, putting the traversal algorithm in the iterator violates the\nencapsulation of the aggregate.\n3. How robust is the iterator? It can be dangerous to modify an aggregate while\nyou're traversing it. If elements are added or deleted from the aggregate,\nyou might end up accessing an element twice or missing it completely. A\nsimple solution is to copy the aggregate and traverse the copy, but that's too\nexpensive to do in general.\nA robust iterator ensures that insertions and removals won't interfere with\ntraversal, and it does it without copying the aggregate. There are many ways\nto implement robust iterators. Most rely on registering the iterator with the\naggregate. On insertion or removal, the aggregate either adjusts the internal\nstate of iterators it has produced, or it maintains information internally to\nensure proper traversal.\nKofler provides a good discussion of how robust iterators are implemented\nin ET++ [Kof93]. Murray discusses the implementation of robust iterators\nfor the USL StandardComponents' List class [Mur93].\n4. Additional Iterator operations. The minimal interface to Iterator consists of\nthe operations First, Next, IsDone, and Currentltem.4 Some additional op-\nerations might prove useful. For example, ordered aggregates can have a\nPrevious operation that positions the iterator to the previous element. A\nSkipTo operation is useful for sorted or indexed collections. SkipTo positions\nthe iterator to an object matching specific criteria.\n5. Using polymorphic iterators in C++. Polymorphic iterators have their cost. They\nrequire the iterator object to be allocated dynamically by a factory method.\nHence they should be used only when there's a need for polymorphism.\nOtherwise use concrete iterators, which can be allocated on the stack.\n3 \nCursors are a simple example of the Memento (283) pattern and share many of its implementation issues.\n4 We \ncan make this interface even smaller by merging Next, IsDone, and Currentltem into a single operation\nthat advances to the next object and returns it. If the traversal is finished, then this operation returns a special \nvalue (0, for instance) that marks the end of the iteration.\n", "page": 281, "type": "text", "section": "Page 281"}
{"text": "262 \nBEHAVIORAL PATTERNS \nCHAPTERS\nPolymorphic iterators have another drawback: the client is responsible for\ndeleting them. This is error-prone, because it's easy to forget to free a heap-\nallocated iterator object when you're finished with it. That's especially likely\nwhen there are multiple exit points in an operation. And if an exception is\ntriggered, the iterator object will never be freed.\nThe Proxy (207) pattern provides a remedy. We can use a stack-allocated\nproxy as a stand-in for the real iterator. The proxy deletes the iterator in\nits destructor. Thus when the proxy goes out of scope, the real iterator will\nget deallocated along with it. The proxy ensures proper cleanup, even in\nthe face of exceptions. This is an application of the well-known C++ tech-\nnique \"resource allocation is initialization\" [ES90]. The Sample Code gives\nan example.\n6. Iterators may have privileged access. An iterator can be viewed as an extension\nof the aggregate that created it. The iterator and the aggregate are tightly cou-\npled. We can express this close relationship in C++ by making the iterator a\nfriend of its aggregate. Then you don't need to define aggregate operations\nwhose sole purpose is to let iterators implement traversal efficiently.\nHowever, such privileged access can make defining new traversals difficult,\nsince it'll require changing the aggregate interface to add another friend.\nTo avoid this problem, the Iterator class can include protected operations\nfor accessing important but publicly unavailable members of the aggregate.\nIterator subclasses (and only Iterator subclasses) may use these protected\noperations to gain privileged access to the aggregate.\n7. Iterators for composites. External iterators can be difficult to implement over\nrecursive aggregate structures like those in the Composite (163) pattern, be-\ncause a position in the structure may span many levels of nested aggregates.\nTherefore an external iterator has to store a path through the Composite to\nkeep track of the current object. Sometimes it's easier just to use an internal\niterator. It can record the current position simply by calling itself recursively,\nthereby storing the path implicitly in the call stack.\nIf the nodes in a Composite have an interface for moving from a node to\nits siblings, parents, and children, then a cursor-based iterator may offer a\nbetter alternative. The cursor only needs to keep track of the current node; it\ncan rely on the node interface to traverse the Composite.\nComposites often need to be traversed in more than one way. Preorder,\npostorder, inorder, and breadth-first traversals are common. \nYou \ncan support\neach kind of traversal with a different class of iterator.\n8. Null iterators. A Nulllterator is a degenerate iterator that's helpful for han-\ndling boundary conditions. By definition, a Nulllterator is always done with\ntraversal; that is, its IsDone operation always evaluates to true.\nNulllterator can make traversing tree-structured aggregates (like Compos-\nites) easier. At each point in the traversal, we ask the current element for\nan iterator for its children. Aggregate elements return a concrete iterator\n", "page": 282, "type": "text", "section": "Page 282"}
{"text": "ITERATOR \n263\nas usual. But leaf elements return an instance of Nulllterator. That lets us\nimplement traversal over the entire structure in a uniform way.\nSample Code\nWe'll look at the implementation of a simple List class, which is part of our\nfoundation library (Appendix C). We'll show two Iterator implementations, one\nfor traversing the List in front-to-back order, and another for traversing back-to-\nfront (the \nfoundation library supports only the first one). Then we show how to\nuse these iterators and how to avoid committing to a particular implementation. \nAfter that, we change the design to make sure iterators get deleted properly.\nThe last example illustrates an internal iterator and compares it to its external\ncounterpart.\n1. List and Iterator interfaces. First let's look at the part of the List interface that's\nrelevant to implementing iterators. Refer to Appendix C for the full interface.\ntemplate <class \nItem>\nclass List { \npublic:\nList(long size = DEFAULT_LIST_CAPACITY);\nlong Count() \nconst;\nItem& Get(long index) const;\n// . \n. .\n};\nThe List class provides a reasonably efficient way to support iteration\nthrough its public interface. It's \nsufficient to implement both traversals. So\nthere's no need to give iterators privileged access to the underlying data\nstructure; that is, the iterator classes are not friends of List. To \nenable trans-\nparent use of the different traversals we define an abstract Iterator class,\nwhich defines the iterator interface.\ntemplate <class Item>\nclass Iterator \n{ \npublic:\nvirtual void First() = 0; \nvirtual void \nNext() = 0; \nvirtual bool IsDoneO const = 0;\nvirtual Item Currentltem() const = 0;\nprotected:\nIterator();\n};\n2. Iterator subclass implementations. Listlterator is a subclass of Iterator.\n", "page": 283, "type": "text", "section": "Page 283"}
{"text": "264 \nBEHAVIORAL PATTERNS \nCHAPTER 5\ntemplate <class Item> \nclass Listlterator : \npublic Iterator<Item> {\npublic:\nListlterator(const List<Item>* aList);\nvirtual void First(); \nvirtual void Next(); \nvirtual bool IsDoneO const; \nvirtual Item Currentltem() const;\nprivate: \nconst List<Item>* _list;\nlong _current;\n};\nThe implementation of Li \ns \nt Iterator is \nstraightforward. It \nstores the \nList\nalong with an index .current into the list:\ntemplate <class Item>\nListlterator<ltem>::Listlterator \n(\nconst List<Item>* aList \n) : \n_list(aList), _current(0) {\n}\nFirst positions the iterator to the first element:\ntemplate <class Item> \nvoid Listlterator<ltem>::First () \n{\n_current = 0;\n}\nNext advances the current element:\ntemplate <class Item> \nvoid Listlterator<ltem>::Next () \n{\n_current++;\n}\nIsDone checks whether the index refers to an element within the List:\ntemplate <class Item> \nbool Listlterator<ltem>::IsDone () \nconst {\nreturn _current >= _list->Count();\n}\nFinally, Current \nI \ntern returns the item at the current index. If the iteration\nhas already terminated, then we throw an IteratorOutOf Bounds excep-\ntion:\ntemplate <class Item>\nItem Listlterator<ltem>::CurrentItem () \nconst {\nif (IsDone()) { \nthrow IteratorOutOfBounds;\n} \nreturn _list->Get(_current);\n}\n", "page": 284, "type": "text", "section": "Page 284"}
{"text": "ITERATOR \n265\nThe implementation of ReverseListlterator is identical, except its Fir st op-\neration positions .current to the end of the list, and Next decrements\n.current toward the \nfirst \nitem.\n3. Using the iterators. Let's assume we have a List of Employee objects,\nand we would like to print all the contained employees. The Employee\nclass supports this with a Print operation. To print the list, we define a\nPrintEmployees operation that takes an iterator as an argument. It uses\nthe iterator to traverse and print the list.\nvoid PrintEmployees (Iterator<Employee*>& i) {\nfor (i. \nFirst \n(); ! \ni \n. \nIsDone \n() \n; i.NextO) {\ni.Currentltem()->Print();\n}\n}\nSince we have iterators \nfor both back-to-front and front-to-back traversals,\nwe can reuse this operation to print the employees in both orders.\nList<Employee*>* employees;\n// . \n. \n.\nListIterator<Employee*> forward(employees);\nReverseListIterator<Employee*> backward(employees);\nPrintEmployees(forward);\nPrintEmployees(backward);\n4. Avoiding commitment to a specific list implementation. Let's consider how a\nskiplist variation of List would affect our iteration code. A SkipList\nsubclass of List must provide a SkipList Iterator that imple-\nments the Iterator interface. Internally, the SkipListlterator has \nto keep more than just an index to do the iteration efficiently. But\nsince SkipListlterator conforms to the Iterator interface, the\nPrint Emp \n1 oy \ne \ne \ns operation can also be used when the employees are stored\nin a SkipList object.\nSkipList<Employee*>* employees;\n// . . .\nSkipListIterator<Employee*> iterator(employees);\nPrintEmployees(iterator);\nAlthough this approach works, it would be better \nif we didn't have to \ncommit\nto a specific List implementation, namely SkipList. We \ncan introduce an\nAbstractList class to standardize the list interface for different list imple-\nmentations. List and SkipList become subclasses of AbstractList.\nTo enable polymorphic iteration, AbstractList defines a factory method\nCreatelterator, which subclasses override to return \ntheir corresponding\niterator:\n", "page": 285, "type": "text", "section": "Page 285"}
{"text": "266 \nBEHAVIORAL PATTERNS \nCHAPTER 5\ntemplate <class Item>\nclass AbstractList { \npublic:\nvirtual Iterator<Item>* Createlterator() const = 0;\n// . \n. \n.\n};\nAn alternative would be to define a general mixin class Traversable that\ndefines the interface for creating an iterator. Aggregate classes can mix in\nTraversable to support polymorphic iteration.\nList overrides Createlterator to return a Listlterator object:\ntemplate <class Item>\nIterator<Item>* List<Item>::CreateIterator () \nconst {\nreturn new Listlterator<ltem>(this);\n}\nNow we're in a position to write the code for printing the employees inde-\npendent of a concrete representation.\n//we know only that we have an \nAbstractList\nAbstractList<Employee*>* employees; \n// . . .\nIterator<Employee*>* iterator = employees->Create!terator();\nPrintEmployees(*iterator); \ndelete iterator;\n5. Making sure iterators get deleted. Notice that Createlterator returns a\nnewly allocated iterator object. We're responsible for deleting it. If we forget,\nthen we've created a storage leak. To make life easier for clients, we'll provide\nan 11 \neratorPtr that acts as a proxy for an iterator. It takes care of cleaning\nup the Iterator object when it goes out of scope.\niteratorPtr is always allocated on the stack.5 C++ automatically takes\ncare of calling its destructor, which deletes the real iterator. IteratorPtr\noverloads both operator-> and operator* in such a way that an \nIteratorPtr can be treated just like a pointer to an iterator. The mem-\nbers of IteratorPtr are all implemented inline; thus they can incur no\noverhead.\ntemplate <class Item>\nclass IteratorPtr {\npublic:\nIteratorPtr(Iterator<Item>* i): _i(i) { }\n\"IteratorPtr() { delete _i; }\n5 You can ensure this at compile-time just by declaring private new and delete operators. An accompa-\nnying implementation isn't needed.\n", "page": 286, "type": "text", "section": "Page 286"}
{"text": "ITERATOR \n267\nIterator<Item>* operator->() { \nreturn _i; }\nIterator<Item>& operator*() { \nreturn *_i; }\nprivate: \n// disallow copy and assignment to avoid\n// multiple deletions of _i:\nIteratorPtr(const IteratorPtr&);\nIteratorPtr& operator=(const IteratorPtr&);\nprivate:\nIterator<Item>* _i;\n};\nIteratorPtr lets us simplify our \nprinting code:\nAbstractList<Employee*>* employees;\n// . . .\nIteratorPtr<Employee*> iterator(employees->Create!terator());\nPrintEmployees(*iterator);\n6. An internal Listlterator. As a final example, let's look at a possible implementa-\ntion of an internal or passive Listlterator class. Here the iterator controls\nthe iteration, and it applies an operation to each element.\nThe issue in this case is how to parameterize the iterator with the operation\nwe want to perform on each element. C++ does not support anonymous\nfunctions or closures that other languages provide for this task. There are at \nleast two options: (1) Pass in a pointer to a function (global or static), or (2)\nrely on subclassing. In the first case, the iterator calls the operation passed\nto it at each point in the iteration. In the second case, the iterator calls an\noperation that a subclass overrides to enact specific behavior.\nNeither option is perfect. Often you want to accumulate state during the\niteration, and functions aren't well-suited to that; we would have to use\nstatic variables to remember the state. An Iterator subclass provides us\nwith a convenient place to store the accumulated state, like in an instance\nvariable. But creating a subclass for every different traversal is more work.\nHere's a sketch of the second option, which uses subclassing. We call the\ninternal iterator a ListTraverser.\ntemplate <class Item>\nclass ListTraverser {\npublic:\nListTraverser(List<Item>* aList) ;\nbool Traverse();\nprotected: \nvirtual bool Processltem(const Item&) = 0;\nprivate:\nListlterator<ltem> _iterator;\n};\nListTraverser takes a List instance as a parameter. Internally it uses an\nexternal Listlterator to do the traversal. Traverse starts the traversal\n", "page": 287, "type": "text", "section": "Page 287"}
{"text": "268 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nand calls Process I tern for each item. The internal iterator can choose to\nterminate a traversal by returning false from Processltem. Traverse\nreturns whether the traversal terminated prematurely.\ntemplate <class Item>\nListTraverser<Item>::ListTraverser \n(\nList<Item>* aList \n) : \n_iterator(aList) { \n}\ntemplate <class Item> \nbool ListTraverser<Item>::Traverse () \n{\nbool result = false;\nfor ( \n_iterator.First();\n!_iterator.IsDone();\n_iterator.Next()\n) {\nresult = Processltem(_iterator.Currentltem());\nif (result == false) {\nbreak;\n}\n}\nreturn result;\nLet's use a ListTraverser to print the first 10 employees from our em-\nployee list. To do it we have to subclass ListTraverser and override\nProcessltem. We count the number of printed employees in a _count\ninstance variable.\nclass PrintNEmployees : \npublic ListTraverser<Employee*> {\npublic:\nPrintNEmployees(List<Employee*>* aList, int n) : \nListTraverser<Employee*>(aList),\n_total(n), _count(0) { \n}\nprotected: \nbool Processltem(Employee* const&);\nprivate: \nint _total;\nint _count;\n};\nbool PrintNEmployees::Processltem (Employee* const& e) { \n_count++; \ne->Print(); \nreturn _count < \n_total;\n}\nHere's how PrintNEmployees prints the first 10 employees on the list:\n", "page": 288, "type": "text", "section": "Page 288"}
{"text": "ITERATOR \n269\nList<Employee*>* \nemployees;\n// . . .\nPrintNEmployees pa(employees, 10)\npa.Traverse();\nNote how the client doesn't specify the iteration loop. The entire iteration\nlogic can be reused. This is the primary benefit of an internal iterator. It's \na\nbit more work than an external iterator, though, because we have to define a\nnew class. Contrast this with using an external iterator:\nListIterator<Employee*> i(employees);\nint count = 0;\nfor (i. \nFirst \n(); ! \ni \n. \nIsDone \n() \n; i.NextO) {\ncount++;\ni.Currentltem()->Print();\nif (count >= 10) {\nbreak;\n}\n}\nInternal iterators can encapsulate different kinds of iteration. For example,\nFilteringListTraverser encapsulates an iteration that processes only \nitems that satisfy a test:\ntemplate <class \nItem> \nclass FilteringListTraverser \n{ \npublic:\nFilteringListTraverser(List<Item>* aList);\nbool Traverse();\nprotected: \nvirtual bool Processltem(const Item&) - 0; \nvirtual bool Testltem(const Item&) = 0;\nprivate:\nListlterator<ltem> _iterator;\n};\nThis interface is the same as ListTraverser's except for an added\nTest I tern member function that defines the test. Subclasses override \nTe s \n111 em to specify the test.\nTraverse decides to continue the traversal based on the outcome of the test:\ntemplate <class Item> \nvoid FilteringListTraverser<Item>::Traverse () \n{\nbool result = false;\nfor ( \n_iterator.First();\n!_iterator.IsDone();\n_iterator.Next()\n) \n{\nif (Testltem(_iterator.Currentltem())) { \nresult = Processltem(_iterator.Currentltem());\n", "page": 289, "type": "text", "section": "Page 289"}
{"text": "270 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nif (result == false) {\nbreak;\n}\n}\n} \nreturn result;\n}\nA variant of this class could define Traverse to return if at least one item\nsatisfies the test.6\nKnown Uses\nIterators are common in object-oriented systems. Most collection class libraries\noffer iterators in one form or another.\nHere's an example from the Booch components [Boo94], a popular collection\nclass library. It provides both a fixed size (bounded) and dynamically growing\n(unbounded) implementation of a queue. The queue interface is defined by an\nabstract Queue class. To support polymorphic iteration over the different queue\nimplementations, the queue iterator is implemented in the terms of the abstract\nQueue class interface. This variation has the advantage that you don't need a\nfactory method to ask the queue implementations for their appropriate iterator.\nHowever, it requires the interface of the abstract Queue class to be powerful\nenough to implement the iterator efficiently.\nIterators don't have to be defined as explicitly in Smalltalk. \nThe standard collection\nclasses (Bag, Set, Dictionary, OrderedCollection, String, etc.) define an internal\niterator method do:, which takes a block (i.e., closure) as an argument. Each\nelement in the collection is bound to the local variable in the block; then the block\nis executed. Smalltalk also includes a set of Stream classes that support an iterator-\nlike interface. ReadStream is essentially an Iterator, and it can act as an external\niterator for all the sequential collections. There are no standard external iterators\nfor nonsequential collections such as Set and Dictionary.\nPolymorphic iterators and the cleanup Proxy described earlier are provided by\nthe ET++ container classes [WGM88]. The Unidraw graphical editing framework\nclasses use cursor-based iterators [VL90].\nObjectWindows 2.0 [Bor94] provides a class hierarchy of iterators for containers.\nYou can iterate over different container types in the same way. \nThe ObjectWindow\niteration syntax relies on overloading the postincrement operator ++ to advance\nthe iteration.\nRelated Patterns\nComposite (163): Iterators are often applied to recursive structures such as Com-\nposites.\n6The Traverse operation in these examples is a Template Method (325) with primitive operations\nTestltemand Processltem.\n", "page": 290, "type": "text", "section": "Page 290"}
{"text": "ITERATOR \n271\nFactory Method (107): \nPolymorphic iterators rely on factory methods to instantiate\nthe appropriate Iterator subclass.\nMemento (283) is often used in conjunction with the Iterator pattern. An iterator\ncan use a memento to capture the state of an iteration. The iterator stores the\nmemento internally.\n", "page": 291, "type": "text", "section": "Page 291"}
{"text": "This page intentionally left blank \n", "page": 292, "type": "text", "section": "Page 292"}
{"text": "MEDIATOR \n273\nMEDIATOR\nObject Behavioral\nIntent\nDefine an object that encapsulates how a set of objects interact. Mediator promotes\nloose coupling by keeping objects from referring to each other explicitly, and it\nlets you vary their interaction independently.\nMotivation\nObject-oriented design encourages the distribution of behavior among objects.\nSuch distribution can result in an object structure with many connections between\nobjects; in the worst case, every object ends up knowing about every other.\nThough partitioning a system into many objects generally enhances reusability,\nproliferating interconnections tend to reduce it again. Lots of interconnections\nmake it less likely that an object can work without the support of others\u2014the\nsystem acts as though it were monolithic. Moreover, it can be difficult to change\nthe system's behavior in any significant way, since behavior is distributed among\nmany objects. As a result, you may be forced to define many subclasses to cus-\ntomize the system's behavior.\nAs an example, consider the implementation of dialog boxes in a graphical user\ninterface. A dialog box uses a window to present a collection of widgets such as\nbuttons, menus, and entry fields, as shown here:\n", "page": 293, "type": "text", "section": "Page 293"}
{"text": "274\nBEHAVIORAL PATTERNS\nCHAPTER 5\nOften there are dependencies between the widgets in the dialog. For example,\na button gets disabled when a certain entry field is empty. Selecting an entry\nin a list of choices called a list box might change the contents of an entry field.\nConversely typing text into the entry field might automatically select one or more\ncorresponding entries in the list box. Once text appears in the entry field, other\nbuttons may become enabled that let the user do something with the text, such as\nchanging or deleting the thing to which it refers.\nDifferent dialog boxes will have different dependencies between widgets. So even\nthough dialogs display the same kinds of widgets, they can't simply reuse stock\nwidget classes; they have to be customized to reflect dialog-specific dependencies.\nCustomizing them individually by subclassing will be tedious, since many classes\nare involved.\nYou can avoid these problems by encapsulating collective behavior in a separate\nmediator object. A mediator is responsible for controlling and coordinating the\ninteractions of a group of objects. The mediator serves as an intermediary that\nkeeps objects in the group from referring to each other explicitly. The objects only\nknow the mediator, thereby reducing the number of interconnections.\nFor example, FontDialogDirector can be the mediator between the widgets in\na dialog box. A FontDialogDirector object knows the widgets in a dialog and\ncoordinates their interaction. It acts as a hub of communication for widgets:\nThe following interaction diagram illustrates how the objects cooperate to handle\na change in a list box's selection:\n", "page": 294, "type": "text", "section": "Page 294"}
{"text": "MEDIATOR \n275\nHere's the succession of events by which a list box's selection passes to an entry\nfield:\n1. The list box tells its director that it's changed.\n2. The director gets the selection from the list box.\n3. The director passes the selection to the entry field.\n4. Now that the entry field contains some text, the director enables button(s)\nfor initiating an action (e.g., \"demibold,\" \"oblique\").\nNote how the director mediates between the list box and the entry field. Widgets\ncommunicate with each other only indirectly, through the director. They don't\nhave to know about each other; all they know is the director. \nFurthermore, \nbecause\nthe behavior is localized in one class, it can be changed or replaced by extending\nor replacing that class.\nHere's how the FontDialogDirector abstraction can be integrated into a class\nlibrary:\n", "page": 295, "type": "text", "section": "Page 295"}
{"text": "276\nBEHAVIORAL PATTERNS\nCHAPTER 5\nDialogDirector is an abstract class that defines the overall behavior of a dia-\nlog. Clients call the ShowDialog operation to display the dialog on the screen.\nCreateWidgets is an abstract operation for creating the widgets of a dialog. Wid-\ngetChanged is another abstract operation; widgets call it to inform their director\nthat they have changed. DialogDirector subclasses override CreateWidgets to cre-\nate the proper widgets, and they override WidgetChanged to handle the changes.\nApplicability\nUse the Mediator pattern when\n\u2022 a set of objects communicate \nin well-defined but complex ways. The resulting\ninterdependencies are unstructured and difficult to understand.\n\u2022 reusing an object is difficult because it refers to and communicates with many\nother objects.\n\u2022 a behavior that's distributed between several classes should be customizable\nwithout a lot of subclassing.\nStructure\nA typical object structure might look like this:\n", "page": 296, "type": "text", "section": "Page 296"}
{"text": "MEDIATOR \n277\nParticipants\n\u2022 Mediator (DialogDirector)\n- defines an interface for communicating with Colleague objects.\n\u2022 ConcreteMediator (FontDialogDirector)\n- implements cooperative behavior by coordinating Colleague objects.\n- knows and \nmaintains its \ncolleagues.\n\u2022 Colleague classes (ListBox, EntryField)\n- each Colleague class knows its Mediator object.\n- each colleague communicates with its mediator whenever it would have\notherwise communicated with another colleague.\nCollaborations\n\u2022 Colleagues send and receive requests from a Mediator object. The mediator\nimplements the cooperative behavior by routing requests between the appro-\npriate colleague(s).\nConsequences\nThe Mediator pattern has the following \nbenefits and drawbacks:\n1. It limits subclassing. A mediator localizes behavior that otherwise would be\ndistributed among several objects. Changing this behavior requires subclass-\ning Mediator only; Colleague classes can be reused as is.\n2. It decouples colleagues. A mediator promotes loose coupling between col-\nleagues. You can vary and reuse Colleague and Mediator classes indepen-\ndently.\n3. It simplifies object protocols. A mediator replaces many-to-many interactions\nwith one-to-many interactions \nbetween the mediator and its colleagues. One-\nto-many relationships are easier to understand, maintain, and extend.\n4. It abstracts how objects cooperate. Making mediation an independent concept\nand encapsulating it in an object lets you focus on how objects interact apart\nfrom their individual behavior. That can help clarify how objects interact in\na system.\n5. It centralizes control. The Mediator pattern trades complexity of interaction\nfor complexity in the mediator. Because a mediator encapsulates protocols,\nit can become more complex than any individual colleague. This can make\nthe mediator itself a monolith that's hard to maintain.\n", "page": 297, "type": "text", "section": "Page 297"}
{"text": "278 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nImplementation\nThe following implementation issues are relevant to the Mediator pattern:\n1. Omitting the abstract Mediator class. There's no need to define an abstract\nMediator class when colleagues work with only one mediator. The abstract\ncoupling that the Mediator class provides lets colleagues work with different\nMediator subclasses, and vice versa.\n2. Colleague-Mediator communication. Colleagues have to communicate with\ntheir mediator when an event of interest occurs. One approach is to im-\nplement the Mediator as an Observer using the Observer (293) \npattern. Col-\nleague classes act as Subjects, sending notifications to the mediator whenever\nthey change state. The mediator responds by propagating the effects of the\nchange to other colleagues.\nAnother approach defines a specialized notification interface in Mediator\nthat lets colleagues be more direct in their communication. Smalltalk/V for\nWindows uses a form of delegation: When communicating with the media-\ntor, a colleague passes itself as an argument, allowing the mediator to identify\nthe sender. The Sample Code uses this approach, and the Smalltalk/V im-\nplementation is discussed further in the Known Uses.\nSample Code\nWe'll use a DialogDirector to implement the font dialog box shown in the Moti-\nvation. The abstract class DialogDirector defines the interface for directors.\nclass DialogDirector \n{\npublic:\nvirtual \"DialogDirector();\nvirtual void ShowDialog(); \nvirtual void WidgetChanged(Widget*) = 0;\nprotected:\nDialogDirector(); \nvirtual void \nCreateWidgets() = 0;\n};\nWidget is the abstract base class for widgets. A widget knows its director.\nclass Widget \n{\npublic:\nWidget(DialogDirector*);\nvirtual void Changed();\nvirtual void HandleMouse(MouseEvent& event);\n// . \n. \n.\nprivate:\nDialogDirector* _director;\n};\n", "page": 298, "type": "text", "section": "Page 298"}
{"text": "MEDIATOR \n279\nChanged calls the director's WidgetChanged operation. Widgets call\nWidgetChanged on their director to inform it of a significant event.\nvoid Widget::Changed () {\n_director->WidgetChanged(this);\n}\nSubclasses of DialogDirector override WidgetChanged to affect the ap-\npropriate widgets. The widget passes a reference to itself as an argument\nto WidgetChanged to let the director identify the widget that changed.\nDialogDirector subclasses redefine the CreateWidgets pure virtual to con-\nstruct the widgets in the dialog.\nThe ListBox, EntryField, and Button are subclasses of Widget for special-\nized user interface elements. ListBox provides a GetSelection operation to\nget the current selection, and Entry \nFie \nId's Set Text operation puts new text\ninto the field.\nclass ListBox : \npublic Widget {\npublic:\nListBox(DialogDirector*);\nvirtual const char* GetSelection(); \nvirtual void SetList(List<char*>* listltems); \nvirtual void HandleMouse(MouseEvent& event);\n// . . .\n};\nclass EntryField : \npublic Widget {\npublic:\nEntryField(DialogDirector*);\nvirtual void SetText(const char* text);\nvirtual const char* GetText(); \nvirtual void HandleMouse(MouseEvent& event);\nButton is a simple widget that calls Changed whenever it's pressed. This gets\ndone in its implementation of HandleMouse:\nclass Button : \npublic Widget {\npublic:\nButton(DialogDirector*) ;\nvirtual void SetText(const char* text);\nvirtual void HandleMouse(MouseEvent& event);\n// . . .\n};\n", "page": 299, "type": "text", "section": "Page 299"}
{"text": "280 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nvoid Button::HandleMouse (MouseEventk event) { \n// . . .\nChanged();\n}\nThe FontDialogDirector class mediates between widgets in the dialog \nbox.\nFontDialogDirector is a subclass of DialogDirector:\nclass FontDialogDirector : \npublic DialogDirector {\npublic:\nFontDialogDirector(); \nvirtual \"FontDialogDirector(); \nvirtual void WidgetChanged(Widget*);\nprotected: \nvirtual void CreateWidgets();\nprivate: \nButton* _ok;\nButton* _cancel;\nListBox* _fontList; \nEntryField* _fontName;\n};\nFontDialogDirector keeps track of the widgets it displays. It redefines\nCreateWidgets to create the widgets and initialize its references to them:\nvoid FontDialogDirector::CreateWidgets () \n{ \n_ok = new Button(this); \n_cancel = new Button(this);\n_fontList = new ListBox(this);\n_fontName = new EntryField(this);\n// fill the listBox with the available font names\n// assemble the widgets in the dialog\n}\nWidgetChanged ensures that the widgets work together properly:\nvoid FontDialogDirector::WidgetChanged (\nWidget* theChangedWidget\n) \n{\nif (theChangedWidget == _fontList) { \n_fontName->SetText(_fontList->GetSelection());\n} else if (theChangedWidget == \n_ok) \n{ \n// apply font change and dismiss dialog\n// . . .\n", "page": 300, "type": "text", "section": "Page 300"}
{"text": "MEDIATOR \n281\n} else if (theChangedWidget == _cancel) { \n// dismiss dialog\nThe complexity of Widget Changed increases proportionally with the complexity\nof the dialog. Large dialogs are undesirable for other reasons, of course, but\nmediator complexity might mitigate the pattern's benefits in other applications.\nKnown Uses\nBoth ET++ [WGM88] and the THINK C class library [Sym93b] use director-like\nobjects in dialogs as mediators between widgets.\nThe application architecture of Smalltalk/V for Windows is based on a media-\ntor structure [LaL94]. In that environment, an application consists of a Window\ncontaining a set of panes. The library contains several predefined Pane objects;\nexamples include TextPane, ListBox, Button, and so on. These panes can be used\nwithout subclassing. An application developer only subclasses from ViewMan-\nager, a class that's responsible for doing inter-pane coordination. ViewManager is\nthe Mediator, and each pane only knows its view manager, which is considered\nthe \"owner\" of the pane. Panes don't refer to each other directly.\nThe following object diagram shows a snapshot of an application at run-time:\nSmalltalk/V uses an event mechanism for Pane-ViewManager communication. \nA\npane generates an event when it wants to get information from the mediator or \nwhen it wants to inform the mediator that something significant happened. An\nevent defines a symbol (e.g., #select) that identifies the event. To handle the\nevent, the view manager registers a method selector with the pane. This selector\nis the event's handler; it will be invoked whenever the event occurs.\n", "page": 301, "type": "text", "section": "Page 301"}
{"text": "282 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nThe following code excerpt shows how a ListPane object gets created inside a\nViewManager subclass and how ViewManager registers an event handler for the\n#select event:\nself addSubpane: (ListPane new \npaneName: 'myListPane'; \nowner: self; \nwhen: #select perform: \nttlistSelect:).\nAnother application of the Mediator pattern is in coordinating complex updates.\nAn example is the ChangeManager class mentioned in Observer (293). Change-\nManager mediates between subjects and observers to avoid redundant updates.\nWhen an object changes, it notifies the ChangeManager, which in turn coordinates\nthe update by notifying the object's dependents.\nA similar application appears in the Unidraw drawing framework [VL90] and uses\na class called CSolver to enforce connectivity constraints between \"connectors.\"\nObjects in graphical editors can appear to stick to one another in different ways.\nConnectors are useful in applications that maintain connectivity automatically,\nlike diagram editors and circuit design systems. CSolver is a mediator between\nconnectors. It solves the connectivity constraints and updates the connectors'\npositions to reflect them.\nRelated Patterns\nFacade (185) differs from Mediator in that it abstracts a subsystem of objects\nto provide a more convenient interface. Its protocol is unidirectional; that is,\nFacade objects make requests of the subsystem classes but not vice versa. In\ncontrast, Mediator enables cooperative behavior that colleague objects don't or\ncan't provide, and the protocol is multidirectional.\nColleagues can communicate with the mediator using the Observer (293) pattern.\n", "page": 302, "type": "text", "section": "Page 302"}
{"text": "MEMENTO \n283\nMEMENTO\nObject Behavioral\nIntent\nWithout violating encapsulation, capture and externalize an object's internal state\nso that the object can be restored to this state later.\nAlso Known As\nToken\nMotivation\nSometimes it's necessary to record the internal state of an object. This is required\nwhen implementing checkpoints and undo mechanisms that let users back out of\ntentative operations or recover from errors. You must save state information some-\nwhere so that you can restore objects to their previous states. But objects normally\nencapsulate some or all of their state, making it inaccessible to other objects and\nimpossible to save externally. Exposing this state would violate encapsulation,\nwhich can compromise the application's reliability and extensibility.\nConsider for example a graphical editor that supports connectivity between ob-\njects. A user can connect two rectangles with a line, and the rectangles stay con-\nnected when the user moves either of them. The editor ensures that the line\nstretches to maintain the connection.\nA well-known way to maintain connectivity relationships between objects is with\na constraint-solving system. We \ncan encapsulate this functionality in a Constraint-\nSolver object. ConstraintSolver records connections as they are made and gener-\nates mathematical equations that describe them. It solves these equations when-\never the user makes a connection or otherwise modifies the diagram. Constraint-\nSolver uses the results of its calculations to rearrange the graphics so that they\nmaintain the proper connections.\nSupporting undo in this application isn't as easy as it may seem. An obvious way\nto undo a move operation is to store the original distance moved and move the\n", "page": 303, "type": "text", "section": "Page 303"}
{"text": "284\nBEHAVIORAL PATTERNS\nCHAPTER 5\nobject back an equivalent distance. However, this does not guarantee all objects\nwill appear where they did before. Suppose there is some slack in the connec-\ntion. In that case, simply moving the rectangle back to its original location won't\nnecessarily achieve the desired effect.\nIn general, the ConstraintSolver's public interface might be insufficient to allow\nprecise reversal of its effects on other objects. The undo mechanism must work\nmore closely with ConstraintSolver to reestablish previous state, but we should\nalso avoid exposing the ConstraintSolver's internals to the undo mechanism.\nWe can solve this problem with the Memento pattern. A memento is an object\nthat stores a snapshot of the internal state of another object\u2014the memento's\noriginator. The undo mechanism will request a memento from the originator\nwhen it needs to checkpoint the originator's state. The originator initializes the\nmemento with information \nthat characterizes its current state. Only the originator\ncan store and retrieve information from the memento\u2014the memento is \"opaque\" \nto other objects.\nIn the graphical editor example just discussed, the ConstraintSolver can act as an\noriginator. The following sequence of events characterizes the undo process:\n1. The editor requests a memento from the ConstraintSolver as a side-effect of\nthe move operation.\n2. The ConstraintSolver creates and returns a memento, an instance of a class\nSolverState in this case. A SolverState memento contains data structures that\ndescribe the current state of the ConstraintSolver's internal equations and\nvariables.\n3. Later when the user undoes the move operation, the editor gives the Solver-\nState back to the ConstraintSolver.\n4. Based on the information in the SolverState, the ConstraintSolver changes\nits internal structures to return its equations and variables to their exact\nprevious state.\nThis arrangement lets the ConstraintSolver entrust other objects with the infor-\nmation it needs to revert to a previous state without exposing its internal structure\nand representations.\n", "page": 304, "type": "text", "section": "Page 304"}
{"text": "MEMENTO \n285\nApplicability\nUse the Memento pattern when\n\u2022 a snapshot of (some portion of) an object's state must be saved so that it can\nbe restored to that state later, and\n\u2022 a direct interface to obtaining the state would expose implementation details\nand break the object's encapsulation.\nStructure\nParticipants\n\u2022 Memento (SolverState)\n- stores internal state of the Originator object. The memento may store as\nmuch or as little of the originator's internal state as necessary at its origi-\nnator's discretion.\n- protects against access by objects other than the originator. Mementos\nhave effectively two interfaces. Caretaker sees a narrow interface to the\nMemento\u2014it can only pass the memento to other objects. Originator, in\ncontrast, sees a wide interface, one that lets it access all the data necessary to\nrestore itself to its previous state. Ideally, only the originator that produced\nthe memento would be permitted to access the memento's internal state.\n\u2022 Originator (ConstraintSolver)\n- creates a memento containing a snapshot of its current internal state.\n- uses the memento to restore its internal state.\n\u2022 Caretaker (undo mechanism)\n- is responsible for the memento's safekeeping.\n- never operates on or examines the contents of a memento.\n", "page": 305, "type": "text", "section": "Page 305"}
{"text": "286\nBEHAVIORAL \nPATTERNS\nCHAPTERS\nCollaborations\n\u2022 A caretaker requests a memento from an originator, holds it for a time, and\npasses it back to the originator, as the following interaction diagram illustrates:\nSometimes the caretaker won't pass the memento back to the originator, be-\ncause the originator might never need to revert to an earlier state.\n\u2022 Mementos are passive. Only the originator that created a memento will assign\nor retrieve its state.\nConsequences\nThe Memento pattern has several consequences:\n1. Preserving encapsulation boundaries. Memento avoids exposing information\nthat only an originator should manage but that must be stored nevertheless\noutside the originator. The pattern shields other objects from potentially\ncomplex Originator internals, thereby preserving encapsulation boundaries.\n2. It simplifies Originator. In other encapsulation-preserving designs, Originator\nkeeps the versions of internal state that clients have requested. That puts\nall the storage management burden on Originator. Having clients manage\nthe state they ask for simplifies Originator and keeps clients from having to\nnotify originators when they're done.\n3. Using mementos might be \nexpensive. Mementos might incur considerable over-\nhead if Originator must copy large amounts of information to store in the\nmemento or if clients create and return mementos to the originator often\nenough. Unless encapsulating and restoring Originator state is cheap, the\npattern might not be appropriate. See the discussion of incrementality in the\nImplementation section.\n4. Defining narrow and wide interfaces. It may be difficult in some languages to\nensure that only the originator can access the memento's state.\n5. Hidden costs in caring for mementos. A caretaker is responsible for deleting the\nmementos it cares for. However, the caretaker has no idea how much state is\n", "page": 306, "type": "text", "section": "Page 306"}
{"text": "MEMENTO \n287\nin the memento. Hence an otherwise lightweight caretaker might incur large\nstorage costs when it stores mementos.\nImplementation\nHere are two issues to consider when implementing the Memento pattern:\n1. Language support. Mementos have two interfaces: a wide one for originators\nand a narrow one for other objects. Ideally the implementation language\nwill support two levels of static protection. C++ lets you do this by making \nthe Originator a friend of Memento and making Memento's wide interface\nprivate. Only the narrow interface should be declared public. For example:\nclass State;\nclass Originator {\npublic:\nMemento* CreateMemento(); \nvoid SetMemento(const Memento*);\n// . . .\nprivate:\nState* _state; \n// internal data structures\n// . . .\n};\nclass Memento {\npublic:\n// narrow public interface\nvirtual ~Memento();\nprivate:\n// private members accessible only to Originator\nfriend class Originator;\nMemento();\nvoid SetState(State*);\nState* GetStateO \n; \n// . . .\nprivate:\nState* _state;\n// . \n- \n.\n};\n2. Storing incremental changes. When mementos get created and passed back to\ntheir originator in a predictable sequence, then Memento can save just the\nincremental change to the originator's internal state.\nFor example, undoable commands in a history list can use mementos to en-\nsure that commands are restored to their exact state when they're undone\n(see Command (233)). The history list defines a specific order in which com-\nmands can be undone and redone. That means mementos can store just the\nincremental change that a command makes rather than the full state of every\nobject they affect. In the Motivation example given earlier, the constraint\nsolver can store only those internal structures that change to keep the line\n", "page": 307, "type": "text", "section": "Page 307"}
{"text": "288 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nconnecting the rectangles, as opposed to storing the absolute positions of\nthese objects.\nSample Code\nThe C++ code given here illustrates the ConstraintSolver example discussed ear-\nlier. We \nuse MoveCommand objects (see Command (233)) to (un)do the translation\nof a graphical object from one position to another. The graphical editor calls the\ncommand's Execute operation to move a graphical object and Unexecute to\nundo the move. The command stores its target, the distance moved, and an in-\nstance of ConstraintSolverMemento, a memento containing state from the\nconstraint solver.\nclass Graphic; \n// base class for graphical objects in the graphical editor\nclass MoveCommand {\npublic:\nMoveCommand(Graphic* target, const Point& delta);\nvoid Execute(); \nvoid Unexecute();\nprivate: \nConstraintSolverMemento* _state;\nPoint _delta;\nGraphic* _target;\n};\nThe connection constraints are established by the class ConstraintSolver.\nIts key member function is Solve, which solves the constraints registered with\nthe AddConstraint operation. To support undo, ConstraintSolver's state\ncan be externalized with CreateMemento into a ConstraintSolverMemento\ninstance. The constraint solver can be returned to a previous state by calling\nSetMemento. ConstraintSolver is a Singleton (127).\nclass ConstraintSolver {\npublic:\nstatic ConstraintSolver* Instance();\nvoid Solve(); \nvoid AddConstraint(\nGraphic* startConnection, Graphic* endConnection\n) ; \nvoid RemoveConstraint(\nGraphic* startConnection, Graphic* endConnection\n) ;\n", "page": 308, "type": "text", "section": "Page 308"}
{"text": "MEMENTO \n289\nConstraintSolverMemento* CreateMemento();\nvoid SetMemento(ConstraintSolverMemento*);\nprivate: \n// nontrivial state and operations for enforcing\n// connectivity semantics\n};\nclass ConstraintSolverMemento {\npublic:\nvirtual \"ConstraintSolverMemento();\nprivate:\nfriend class ConstraintSolver;\nConstraintSolverMemento();\n// private constraint solver state\n};\nGiven these interfaces, we can implementMoveConunand members Execute and\nUnexecute as follows:\nvoid MoveCommand::Execute () { \nConstraintSolver* solver = ConstraintSolver::Instance();\n_state = solver->CreateMemento(); // create a memento\n_target->Move(_delta); \nsolver->Solve();\n}\nvoid MoveCommand::Unexecute () { \nConstraintSolver* solver = ConstraintSolver::Instance();\n_target->Move(-_delta); \nsolver->SetMemento(_state); // restore solver state \nsolver->Solve();\n}\nExecute acquires a Constraint SolverMemento memento before it moves the\ngraphic. Unexecute moves the graphic back, sets the constraint solver's state to\nthe previous state, and finally tells the constraint solver to solve the constraints.\nKnown Uses\nThe preceding sample code is based on Unidraw's support for connectivity\nthrough its CSolver class [VL901.\nCollections in Dylan [App92] provide an iteration interface that reflects the Me-\nmento pattern. Dylan's collections have the notion of a \"state\" object, which is a\nmemento that represents the state of the iteration. Each collection can represent\nthe current state of the iteration in any way it chooses; the representation is com-\npletely hidden from clients. The Dylan iteration approach might be translated to\nC++ as follows:\n", "page": 309, "type": "text", "section": "Page 309"}
{"text": "290 \nBEHAVIORAL PATTERNS \nCHAPTER 5\ntemplate <class Item>\nclass Collection \n{\npublic:\nCollection();\nIterationState* CreatelnitialState(); \nvoid Next(IterationState*); \nbool IsDone(const IterationState*) \nconst;\nItem Currentltem(const IterationState*) const;\nIterationState* Copy(const IterationState*) const;\nvoid Append(const Item&);\nvoid Remove(const Item&);\n// . . .\n};\nCreatelnitialState returns an initialized IterationState object for the\ncollection. Next advances the state object to the next position in the iteration;\nit effectively increments the iteration index. Is \nDone returns true if Next has\nadvanced beyond the last element in the collection. Currentltem dereferences\nthe state object and returns the element in the collection to which it refers. Copy\nreturns a copy of the given state object. This is useful for marking a point in an\niteration.\nGiven a class ItemType, we can iterate over a collection of its instances as\nfollows7:\nclass ItemType \n{\npublic:\nvoid Process();\n// . . .\n};\nCollection<ItemType*> \naCollection;\nIterationState* state;\nstate - aCollection.CreatelnitialState();\nwhile (laCollection.IsDone(state)) {\naCollection.CurrentItern(state)->Process();\naCollection.Next(state);\n} \ndelete state;\nThe memento-based iteration interface has two interesting benefits:\n1. More than one state can work on the same collection. (The same is true of the\nIterator (257) pattern.)\n7Note that our example deletes the state object at the end of the iteration. But delete won't get called if\nProcessltem throws an exception, thus creating garbage. This is a problem in C++ but not in Dylan, which \nhas garbage collection. We \ndiscuss a solution to this problem on page 266.\n", "page": 310, "type": "text", "section": "Page 310"}
{"text": "MEMENTO \n291\n2. It doesn't require breaking a collection's encapsulation to support iteration.\nThe memento is only interpreted by the collection itself; no one else has access\nto it. \nOther approaches to iteration require breaking encapsulation by making\niterator classes Mends of their collection classes (see \nIterator (257)). The\nsituation is reversed in the memento-based implementation: Collection\nis a friend of the iteratorState.\nThe QOCA constraint-solving toolkit stores incremental information in memen-\ntos [HHMV92]. Clients can obtain a memento that characterizes the current so-\nlution to a system of constraints. The memento contains only those constraint\nvariables that have changed since the last solution. Usually only a small subset\nof the solver's variables changes for each new solution. This subset is enough\nto return the solver to the preceding solution; reverting to earlier solutions re-\nquires restoring mementos from the intervening solutions. Hence you can't set\nmementos in any order; QOCA relies on a history mechanism to revert to earlier\nsolutions.\nRelated Patterns\nCommand (233): Commands can use mementos to maintain state for undoable\noperations.\nIterator (257): Mementos can be used for iteration as described earlier.\n", "page": 311, "type": "text", "section": "Page 311"}
{"text": "This page intentionally left blank \n", "page": 312, "type": "text", "section": "Page 312"}
{"text": "OBSERVER \n293\nOBSERVER\nObject Behavioral\nIntent\nDefine a one-to-many dependency between objects so that when one object\nchanges state, all its dependents are notified and updated automatically.\nAlso Known As\nDependents, Publish-Subscribe\nMotivation\nA common side-effect of partitioning a system into a collection of cooperating\nclasses is the need to maintain consistency between related objects. You don't\nwant to achieve consistency by making the classes tightly coupled, because that\nreduces their reusability.\nFor example, many graphical user interface toolkits separate the presentational\naspects of the user interface from the underlying application data [KP88, LVC89,\nP+ 88, WGM88]. Classes defining application data and presentations can be reused\nindependently. They can work together, too. Both a spreadsheet object and bar\nchart object can depict information in the same application data object using\ndifferent presentations. The spreadsheet and the bar chart don't know about each \nother, thereby letting you reuse only the one you need. But they behave as though\nthey do. When the user changes the information in the spreadsheet, the bar chart\nreflects the changes immediately, and vice versa.\n", "page": 313, "type": "text", "section": "Page 313"}
{"text": "294\nBEHAVIORAL PATTERNS\nCHAPTER 5\nThis behavior implies that the spreadsheet and bar chart are dependent on the\ndata object and therefore should be notified of any change in its state. And there's\nno reason to limit the number of dependent objects to two; there may be any\nnumber of different user interfaces \nto the same data.\nThe Observer pattern describes how to establish these relationships. The key\nobjects in this pattern are subject and observer. A subject may have any number\nof dependent observers. \nAll observers are notified whenever the subject undergoes\na change in state. In response, each observer will query the subject to synchronize\nits state with the subject's state.\nThis kind of interaction is also known as publish-subscribe. The subject is the\npublisher of notifications. It sends out these notifications without having to know\nwho its observers are. Any number of observers can subscribe to receive \nnotifica-\ntions.\nApplicability\nUse the Observer pattern in any of the following situations:\n\u2022 When an abstraction has two aspects, one dependent on the other. Encapsu-\nlating these aspects in separate objects lets you vary and reuse them inde-\npendently.\n\u2022 When a change to one object requires changing others, and you don't know\nhow many objects need to be changed.\n\u2022 When an object should be able to notify other objects without making as-\nsumptions about who these objects are. In other words, you don't want these \nobjects tightly coupled.\nStructure\n", "page": 314, "type": "text", "section": "Page 314"}
{"text": "OBSERVER \n295\nParticipants\n\u2022 Subject\n- knows its observers. Any number of Observer objects may observe a sub-\nject.\n- provides an interface for attaching and detaching Observer objects.\n\u2022 Observer\n- defines an updating interface for objects that should be notified of \nchanges\nin a subject.\n\u2022 ConcreteSubject\n- stores state of interest to ConcreteObserver objects.\n- sends a notification to its observers when its state changes.\n\u2022 ConcreteObserver\n- maintains a reference to a ConcreteSubject object.\n- stores state that should stay consistent with the subject's.\n- implements the Observer updating interface to keep its state consistent\nwith the subject's.\nCollaborations\n\u2022 ConcreteSubject notifies its observers whenever a change occurs that could\nmake its observers' state inconsistent with its own.\n\u2022 After being informed of a change in the concrete subject, a ConcreteObserver\nobject may query the subject for information. ConcreteObserver uses this in-\nformation to reconcile its state with that of the subject.\nThe following interaction diagram illustrates the collaborations between a\nsubject and two observers:\n", "page": 315, "type": "text", "section": "Page 315"}
{"text": "296 \nBEHAVIORAL PATTERNS \nCHAPTERS\nNote how the Observer object that initiates the change request postpones its\nupdate until it gets a notification from the subject. Notify is not always called\nby the subject. It can be called by an observer or by another kind of object\nentirely. The Implementation section discusses some common variations.\nConsequences\nThe Observer pattern lets you vary subjects and observers independently. You\ncan reuse subjects \nwithout reusing their observers, and vice versa. It lets you add\nobservers without modifying the subject or other observers.\nFurther benefits and liabilities of the Observer pattern include the following:\n1. Abstract coupling between Subject and Observer. All a subject knows is that it\nhas a list of observers, each conforming to the simple interface of the abstract\nObserver class. The subject doesn't know the concrete class of any observer.\nThus the coupling between subjects and observers is abstract and minimal.\nBecause Subject and Observer aren't tightly coupled, they can belong to\ndifferent layers of abstraction in a system. A lower-level subject can com-\nmunicate and inform a higher-level observer, thereby keeping the system's\nlayering intact. If Subject and Observer are lumped together, then the result-\ning object must either span two layers (and violate the layering), or it must be\nforced to live in one layer or the other (which might compromise the layering\nabstraction).\n2. Support for broadcast communication. Unlike an ordinary request, the notifi-\ncation that a subject sends needn't specify its receiver. The notification is\nbroadcast automatically to all interested objects that subscribed to it. The\nsubject doesn't care how many interested objects exist; its only responsibil-\nity is to notify its observers. This gives you the freedom to add and remove \nobservers at any time. It's up to the observer to handle or ignore a notification.\n3. Unexpected updates. Because observers have no knowledge of each other's\npresence, they can be blind to the ultimate cost of changing the subject. A\nseemingly innocuous operation on the subject may cause a cascade of updates \nto observers and their dependent objects. Moreover, dependency criteria that\naren't well-defined or maintained usually lead to spurious updates, which\ncan be hard to track down.\nThis problem is aggravated by the fact that the simple update protocol pro-\nvides no details on what changed in the subject. Without additional protocol\nto help observers discover what changed, they may be forced to work hard\nto deduce the changes.\nImplementation\nSeveral issues related to the implementation of the dependency mechanism are\ndiscussed in this section.\n", "page": 316, "type": "text", "section": "Page 316"}
{"text": "OBSERVER \n297\n1. Mapping subjects to their observers. The simplest way for a subject to keep\ntrack of the observers it should notify is to store references to them explicitly\nin the subject. However, such storage may be too expensive when there are\nmany subjects and few observers. One solution is to trade space for time by\nusing an associative look-up (e.g., a hash table) to maintain the subject-to-\nobserver mapping. Thus a subject with no observers does not incur storage\noverhead. On the other hand, this approach increases the cost of accessing\nthe observers.\n2. Observing more than one subject. It might make sense in some situations for\nan observer to depend on more than one subject. \nFor example, a spreadsheet\nmay depend on more than one data source. It's necessary to extend the\nUpdate interface in such cases to let the observer know which subject is\nsending the notification. The subject can simply pass itself as a parameter\nin the Update operation, thereby letting the observer know which subject to\nexamine.\n3. Who triggers the update? The subject and its observers rely on the notification\nmechanism to stay consistent. But what object actually calls Notify to trigger\nthe update? Here are two options:\n(a) Have state-setting operations on Subject call Notify after they change\nthe subject's state. The advantage of this approach is that clients don't \nhave to remember to call Notify on the subject. The disadvantage is that\nseveral consecutive operations will cause several consecutive updates,\nwhich may be inefficient.\n(b) Make clients responsible for calling Notify at the right time. The advan-\ntage here is that the client can wait to trigger the update until after a series\nof state changes has been made, thereby avoiding needless intermediate\nupdates. The disadvantage is that clients have an added responsibility\nto trigger the update. That makes errors more likely, since clients might\nforget to call Notify.\n4. Dangling references to deleted subjects. Deleting a subject should not produce\ndangling references in its observers. One way to avoid dangling references\nis to make the subject notify its observers as it is deleted so that they can\nreset their reference to it. In general, simply deleting the observers is not an\noption, because other objects may reference them, or they may be observing\nother subjects as well.\n5. Making sure Subject state is self-consistent before notification. It's important to\nmake sure Subject state is self-consistent before calling Notify, because ob-\nservers query the subject for its current state in the course of updating their\nown state.\nThis self-consistency rule is easy to violate unintentionally when Subject\nsubclass operations call inherited operations. For example, the notification in\n", "page": 317, "type": "text", "section": "Page 317"}
{"text": "298 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nthe following code sequence is trigged when the subject is in an inconsistent\nstate:\nvoid MySubject::Operation (int \nnewValue) \n{\nBaseClassSubject::Operation(newValue);\n// trigger notification\n_my!nstVar += \nnewValue;\n// update subclass \nstate (too \nlate!)\n}\nYou can avoid this pitfall by sending notifications from template methods\n(Template Method (325)) in abstract Subject classes. Define a primitive op-\neration for subclasses to override, and make Notify the last operation in the\ntemplate method, which will ensure that the object is self-consistent when\nsubclasses override Subject operations.\nvoid Text::Cut (TextRange r) \n{ \nReplaceRange(r); \n// redefined in \nsubclasses\nNotify();\n}\nBy the way, it's always a good idea to document which Subject operations\ntrigger notifications.\n6. Avoiding observer-specific update protocols: the push and pull models. Implemen-\ntations of the Observer pattern often have the subject broadcast additional\ninformation about the change. The subject passes this information as an\nargument to Update. The amount of information may vary widely.\nAt one extreme, which we call the push model, the subject sends observers\ndetailed information about the change, whether they want it or not. At the\nother extreme is the pull model; the subject sends nothing but the most\nminimal notification, \nand observers ask for details explicitly \nthereafter.\nThe pull model emphasizes the subject's ignorance of its observers, whereas\nthe push model assumes subjects know something about their observers'\nneeds. The push model might make observers less reusable, because Subject\nclasses make assumptions about Observer classes that might not always be\ntrue. On the other hand, the pull model may be inefficient, because Observer\nclasses must ascertain what changed without help from the Subject.\n7. Specifying modifications of interest explicitly. You can improve update efficiency\nby extending the subject's registration interface to allow registering observers\nonly for specific events of interest. When such an event occurs, the subject\ninforms only those observers that have registered interest in that event. One\nway to support this uses the notion of aspects for Subject objects. \nTo \nregister\ninterest in particular events, observers are attached to their subjects using\nvoid Subject::Attach(Observer*, Aspects interest);\n", "page": 318, "type": "text", "section": "Page 318"}
{"text": "OBSERVER \n299\nwhere interest specifies the event of interest. At notification time, the\nsubject supplies the changed aspect to its observers as a parameter to the\nUpdate operation. For example:\nvoid Observer::Update(Subject*, Aspect& interest);\nEncapsulating complex update semantics. When the dependency relationship\nbetween subjects and observers is particularly complex, an object that main-\ntains these relationships might be required. We \ncall such an object a Change-\nManager. Its purpose is to minimize the work required to make observers\nreflect a change in their subject. For example, if an operation involves changes\nto several interdependent subjects, you might have to ensure that their ob-\nservers are notified only after all the subjects have been modified to avoid\nnotifying observers more than once.\nChangeManager has three responsibilities:\n(a) It maps a subject to its observers and provides an interface to maintain\nthis mapping. This eliminates the need for subjects \nto maintain \nreferences\nto their observers and vice versa.\n(b) It defines a particular update strategy.\n(c) It updates all dependent observers at the request of a subject.\nThe following diagram depicts a simple ChangeManager-based implemen-\ntation of the Observer pattern. There are two specialized ChangeManagers.\nSimpleChangeManager is naive in that it always updates all observers of each\nsubject. In contrast, DAGChangeManager \nhandles directed-acyclic graphs of\ndependencies between subjects and their observers. A DAGChangeManager\nis preferable to a SimpleChangeManager when an observer observes more\nthan one subject. In that case, a change in two or more subjects might cause\nredundant updates. The DAGChangeManager ensures the observer receives\njust one update. SimpleChangeManager is fine when multiple updates aren't\nan issue.\n", "page": 319, "type": "text", "section": "Page 319"}
{"text": "300\nBEHAVIORAL PATTERNS\nCHAPTER 5\nChangeManager is an instance of the Mediator (273) \npattern. In general there\nis only one ChangeManager, and it is known globally. The Singleton (127)\npattern would be useful here.\n9. Combining the Subject and Observer classes. Class libraries written in languages \nthat lack multiple inheritance (like Smalltalk) \ngenerally don't define separate\nSubject and Observer classes but combine their interfaces in one class. That\nlets you define an object that acts as both a subject and an observer without\nmultiple inheritance. In Smalltalk, for example, the Subject and Observer\ninterfaces are defined in the root class Object, making them available to all\nclasses.\nSample Code\nAn abstract class defines the Observer interface:\nclass \nSubject;\nclass Observer \n{\npublic:\nvirtual \"Observer(); \nvirtual void \nUpdate(Subject* theChangedSubject) = 0;\nprotected:\nObserver();\nThis implementation supports multiple subjects for each observer. The sub-\nject passed to the Update operation lets the observer determine which subject\nchanged when it observes more than one.\nSimilarly, an abstract class defines the Subject interface:\n", "page": 320, "type": "text", "section": "Page 320"}
{"text": "OBSERVER \n301\nclass Subject \n{\npublic:\nvirtual ~Subject();\nvirtual void Attach(Observer*);\nvirtual void Detach(Observer*);\nvirtual void Notify();\nprotected:\nSubject();\nprivate:\nList<Observer*> *_observers;\n};\nvoid Subject:-.Attach (Observer* o) {\n_observers->Append(o);\n}\nvoid Subject::Detach (Observer* o) \n{\n_observers->Remove(o);\n}\nvoid Subject::Notify () \n{ \nListIterator<Observer*> i(_observers);\nfor (i. \nFirst \n(); ! \ni \n. \nIsDone () \n; i.NextO) {\ni.Currentltem()->Update(this);\n}\n}\nClockTimer is a concrete subject for storing and maintaining the time of day.\nIt notifies its observers every second. ClockTimer provides the interface for\nretrieving individual time units such as the hour, minute, and second.\nclass ClockTimer : \npublic Subject {\npublic:\nClockTimer();\nvirtual int GetHour();\nvirtual int GetMinute();\nvirtual int GetSecond();\nvoid Tick();\n};\nThe Tick operation gets called by an internal timer at regular intervals to provide\nan accurate time base. Tick updates the ClockTimer's internal state and calls \nNot i fy to inform observers of the change:\nvoid ClockTimer::Tick () { \n// update internal time-keeping state\n// . . .\nNotify();\n}\n", "page": 321, "type": "text", "section": "Page 321"}
{"text": "302 \nBEHAVIORAL PATTERNS \nCHAPTERS\nNow we can define a class DigitalClock that displays the time. It inherits its\ngraphical functionality from a Widget class provided by a user interface toolkit.\nThe Observer interface is mixed into the DigitalClock interface by inheriting\nfrom Observer.\nclass DigitalClock: public Widget, public Observer {\npublic:\nDigitalClock(ClockTimer*);\nvirtual \"DigitalClock();\nvirtual void Update(Subject*); \n// overrides Observer operation\nvirtual void Draw(); \n// overrides Widget operation; \n// defines how to draw the digital clock\nprivate:\nClockTimer* _subject;\n};\nDigitalClock::DigitalClock (ClockTimer* s) \n{ \n_subject = s;\n_subject->Attach(this);\n}\nDigitalClock::~DigitalClock () \n{\n_subject->Detach(this);\n}\nBefore the Update operation draws the clock face, it checks to make sure the\nnotifying subject is the clock's subject:\nvoid DigitalClock::Update (Subject* theChangedSubject) \n{\nif (theChangedSubject == \n_subject) {\nDraw();\n}\n}\nvoid DigitalClock::Draw () { \n// get the new values from the subject\nint hour = _subject->GetHour(); \nint minute = _subject->GetMinute();\n// \netc.\n// draw the digital clock\n}\nAn AnalogClock class can be defined in the same way.\n", "page": 322, "type": "text", "section": "Page 322"}
{"text": "OBSERVER \n303\nclass AnalogClock : \npublic Widget, public Observer {\npublic:\nAnalogClock(ClockTimer*);\nvirtual void Update(Subject*); \nvirtual void Draw();\n// . . .\nThe following code creates an AnalogClock and aDigitalClock that always\nshow the same time:\nClockTimer* timer = new ClockTimer;\nAnalogClock* analogClock = new AnalogClock(timer);\nDigitalClock* digitalClock = new DigitalClock(timer);\nWhenever the timer ticks, the two clocks will be updated and will redisplay\nthemselves appropriately.\nKnown Uses\nThe first and perhaps best-known example of the Observer pattern appears in\nSmalltalk Model/View/Controller (MVC), the user interface framework in the\nSmalltalk environment [KP88]. MVCs Model class plays the role of Subject, while\nView is the base class for observers. Smalltalk, ET++ [WGM881, and the THINK\nclass library [Sym93b] provide a general dependency mechanism by putting Sub-\nject and Observer interfaces in the parent class for all other classes in the system.\nOther user interface toolkits that employ this pattern are Interviews [LVC89],\nthe Andrew Toolkit [P+88], and Unidraw [VL90]. Interviews defines Observer \nand Observable (for subjects) classes explicitly. Andrew calls them \"view\" and\n\"data object,\" respectively. Unidraw splits graphical editor objects into View \n(for\nobservers) and Subject parts.\nRelated Patterns\nMediator (273): By \nencapsulating complex update semantics, the \nChangeManager\nacts as mediator between subjects and observers.\nSingleton (127): The ChangeManager may use the Singleton pattern to make it\nunique and globally accessible.\n", "page": 323, "type": "text", "section": "Page 323"}
{"text": "This page intentionally left blank \n", "page": 324, "type": "text", "section": "Page 324"}
{"text": "STATE \n305\nSTATE\nObject Behavioral\nIntent\nAllow an object to alter its behavior when its internal state changes. The object\nwill appear to change its class.\nAlso Known As\nObjects for States\nMotivation\nConsider a class TCPConnection that represents a network connection. A TCP-\nConnection object can be in one of several different states: Established, Listening,\nClosed. When a TCPConnection object receives requests from other objects, it\nresponds differently depending on its current state. For example, the effect of an\nOpen request depends on whether the connection is in its Closed state or its Estab-\nlished state. The State pattern describes how TCPConnection can exhibit different\nbehavior in each state.\nThe key idea in this pattern is to introduce an abstract class called TCPState\nto represent the states of the network connection. The TCPState class declares\nan interface common to all classes that represent different operational states. \nSubclasses of TCPState \nimplement state-specific behavior. For example, the classes\nTCPEstablished and TCPClosed implement behavior particular to the Established\nand Closed states of TCPConnection.\nThe class TCPConnection maintains a state object (an instance of a subclass of\nTCPState) that represents the current state of the TCP connection. The class \n", "page": 325, "type": "text", "section": "Page 325"}
{"text": "306\nBEHAVIORAL PATTERNS\nCHAPTER 5\nConnection delegates all state-specific requests to this state object. TCPConnection\nuses its TCPState subclass instance to perform operations particular to the state\nof the connection.\nWhenever the connection changes state, the TCPConnection object changes the\nstate object it uses. \nWhen the connection goes from established to closed, for exam-\nple, TCPConnection will replace its TCPEstablished instance with a TCPClosed\ninstance.\nApplicability\nUse the State pattern in either of the following cases:\n\u2022 An object's behavior depends on its state, and it must change its behavior at\nrun-time depending on that state.\n\u2022 Operations have large, multipart conditional statements that depend on the\nobject's state. This state is usually represented by one or more enumerated\nconstants. Often, several operations will contain this same conditional struc-\nture. The State pattern puts each branch of the conditional in a separate class.\nThis lets you treat the object's state as an object in its own right that can vary\nindependently from other objects.\nStructure\nParticipants\n\u2022 Context (TCPConnection)\n-\ndefines the interface of interest to clients.\n-\nmaintains an instance of a ConcreteState subclass that defines the current\nstate.\n\u2022 State (TCPState)\n- defines an interface for encapsulating the behavior associated with a par-\nticular state of the Context.\n", "page": 326, "type": "text", "section": "Page 326"}
{"text": "STATE \n307\n\u2022 ConcreteState subclasses (TCPEstablished, \nTCPListen, TCPClosed)\n- each subclass implements a behavior associated with a state of \nthe \nContext.\nCollaborations\n\u2022 Context delegates state-specific requests to the current ConcreteState object.\n\u2022 A context may pass itself as an argument to the State object handling the\nrequest. This lets the State object access the context if necessary.\n\u2022 Context is \nthe primary interface for clients. Clients can configure a context with\nState objects. Once a context is configured, its clients don't have to deal with\nthe State objects directly.\n\u2022 Either Context or the ConcreteState subclasses can \ndecide which state succeeds\nanother and under what circumstances.\nConsequences\nThe State pattern has the following consequences:\n1. It localizes state-specific behavior and partitions behavior for different states. The\nState pattern puts all behavior associated with a particular state into one\nobject. Because all state-specific code lives in a State subclass, new states and\ntransitions can be added easily by defining new subclasses.\nAn alternative is to use data values to define internal states and have Con-\ntext operations check the data explicitly. But then we'd have look-alike con-\nditional or case statements scattered throughout Context's implementation.\nAdding a new state could require changing several operations, which com-\nplicates maintenance.\nThe State pattern avoids this problem but might introduce another, because\nthe pattern distributes behavior for different states across several State sub-\nclasses. This increases the number of classes and is less compact than a single\nclass. But such distribution is actually good if there are many states, which\nwould otherwise necessitate large conditional statements.\nLike long procedures, large conditional statements are undesirable. They're\nmonolithic and tend to make the code less explicit, which in turn makes \nthem difficult to modify and extend. The State pattern offers a better way to\nstructure state-specific code. The logic that determines the state transitions\ndoesn't reside in monolithic if or switch statements but instead is parti-\ntioned between the State subclasses. Encapsulating each state transition and\naction in a class elevates the idea of an execution state to full object status.\nThat imposes structure on the code and makes its intent clearer.\n2. It makes state transitions explicit. When an object defines its current state solely\nin terms of internal data values, its state transitions have no explicit repre-\nsentation; they only show up as assignments to some variables. Introduc-\ning separate objects for different states makes the transitions more explicit.\n", "page": 327, "type": "text", "section": "Page 327"}
{"text": "308 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nAlso, State objects can protect the Context from inconsistent internal states,\nbecause state transitions are atomic from the Context's perspective\u2014they\nhappen by rebinding one variable (the Context's State object variable), not\nseveral [dCLF93].\n3. State objects can be shared. If State objects have no instance variables\u2014that is,\nthe state they represent is encoded entirely in their type\u2014then contexts can\nshare a State object. When states are shared in this way, they are essentially\nflyweights (see Flyweight (195)) with no intrinsic state, only behavior.\nImplementation\nThe State pattern raises a variety of implementation issues:\n1. Who defines the state transitions? The State pattern does not specify which\nparticipant defines the criteria for state transitions. If the criteria are fixed,\nthen they can be implemented entirely in the Context. It is generally more\nflexible and appropriate, however, to let the State subclasses themselves\nspecify their successor state and when to make the transition. This requires\nadding an interface to the Context that lets State objects set the Context's\ncurrent state explicitly.\nDecentralizing the transition logic in this way makes it easy to modify or\nextend the logic by defining new State subclasses. A disadvantage of de-\ncentralization is that one State subclass will have knowledge of at least one \nother, which introduces implementation dependencies between subclasses.\n2. A table-based alternative. In C++ Programming Style [Car921, Cargill describes\nanother way to impose structure on state-driven code: He uses tables to map\ninputs to state transitions. For each state, a table maps every possible input\nto a succeeding state. In effect, this approach converts conditional code (and\nvirtual functions, in the case of the State pattern) into a table look-up.\nThe main advantage of tables is their regularity: \nYou \ncan change the transition\ncriteria by modifying data instead of changing program code. There are some\ndisadvantages, however:\n\u2022 A table look-up is often less efficient than a (virtual) function call.\n\u2022 Putting transition logic into a uniform, tabular format makes the transi-\ntion criteria less explicit and therefore harder to understand.\n\u2022 It's usually difficult to add actions to accompany the state transitions.\nThe table-driven approach captures the states and their transitions, but it \nmust be augmented to perform arbitrary computation on each transition.\nThe key difference between table-driven state machines and the State pattern\ncan be summed up like this: The State pattern models state-specific behavior,\nwhereas the table-driven approach focuses on defining state transitions.\n", "page": 328, "type": "text", "section": "Page 328"}
{"text": "STATE \n309\n3. Creating and destroying State objects. A common implementation trade-off\nworth considering is whether (1) to create State objects only when they are\nneeded and destroy them thereafter versus (2) creating them ahead of time\nand never destroying them.\nThe first choice is preferable when the states that will be entered aren't\nknown at run-time, and contexts change state infrequently. This approach\navoids creating objects that won't be used, which is important if the State\nobjects store a lot of information. The second approach is better when state\nchanges occur rapidly, in which case you want to avoid destroying states,\nbecause they may be needed again shortly. Instantiation costs are paid once\nup-front, and there are no destruction costs at all. This approach might be\ninconvenient, though, because the Context must keep references to all states\nthat might be entered.\n4. Using dynamic inheritance. Changing the behavior for a particular request\ncould be accomplished by changing the object's class at run-time, but this\nis not possible in most object-oriented programming languages. Exceptions\ninclude Self [US87] and other delegation-based languages that provide such\na mechanism and hence support the State pattern directly. Objects in Self\ncan delegate operations to other objects to achieve a form of dynamic inher-\nitance. Changing the delegation target at run-time effectively changes the\ninheritance structure. This mechanism lets objects change their behavior and\namounts to changing their class.\nSample Code\nThe following example gives the C++ code for the TCP connection example de-\nscribed in the Motivation section. This example is a simplified version of the\nTCP protocol; it doesn't describe the complete protocol or all the states of TCP\nconnections.8\nFirst, we define the class TCPConnec t ion, which provides an interface for trans-\nmitting data and handles requests to change state.\nclass TCPOctetStream;\nclass TCPState;\nclass TCPConnection {\npublic:\nTCPConnectionO \n;\nvoid ActiveOpen();\nvoid PassiveOpen();\nvoid Close();\n8 This example is based on the TCP \nconnection protocol described by Lynch and Rose [LR93].\n", "page": 329, "type": "text", "section": "Page 329"}
{"text": "310 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nvoid Send(); \nvoid Acknowledge(); \nvoid Synchronize();\nvoid ProcessOctet(TCPOctetStream*);\nprivate:\nfriend class TCPState; \nvoid ChangeState(TCPState*);\nprivate:\nTCPState* _state;\n};\nTCPConnection keeps an instance of the TCPState class in the _state mem-\nber variable. The class TCPState duplicates the state-changing interface of\nTCPConnection. Each TCPState operation takes a TCPConnection \ninstance\nas a parameter, letting TCPState access data from TCPConnection and change\nthe connection's state.\nclass TCPState {\npublic:\nvirtual void Transmit(TCPConnection*, TCPOctetStream*);\nvirtual void ActiveOpen(TCPConnection*); \nvirtual void PassiveOpen(TCPConnection*); \nvirtual void Close(TCPConnection*); \nvirtual void Synchronize(TCPConnection*); \nvirtual void Acknowledge(TCPConnection*); \nvirtual void Send(TCPConnection*);\nprotected: \nvoid ChangeState(TCPConnection*, TCPState*);\n};\nTCPConnection delegates all state-specific requests to its TCPState instance\n_state. TCPConnection also provides an operation for changing this \nvariable\nto a new TCPState. The \nconstructor for TCPConnect ion initializes \nthe object to\nthe TCPClosed state (defined later).\nTCPConnection::TCPConnection () \n{\n_state = TCPClosed::Instance();\n}\nvoid TCPConnection::ChangeState (TCPState* s) \n{\n_state = s;\n}\nvoid TCPConnection::ActiveOpen () \n{\n_state->ActiveOpen(this);\n}\nvoid TCPConnection::PassiveOpen () \n{\n_state->PassiveOpen(this);\n}\n", "page": 330, "type": "text", "section": "Page 330"}
{"text": "STATE \n311\nvoid TCPConnection::Close () \n{\n_state->Close(this); \n\u2022 \n}\nvoid TCPConnection::Acknowledge () \n{\n_s \ntate->Acknowledge(this);\n}\nvoid TCPConnection::Synchronize () \n{\n_state->Synchronize(this);\n}\nTOPS \nt \nate implements default behavior for all requests delegated to it. It can\nalso change the state of a TCPConnection with the ChangeState operation.\nTCPState is declared a friend of TCPConnection to give it privileged access to\nthis operation.\nvoid TCPState::Transmit (TCPConnection*, TCPOctetStream*) { \n}\nvoid TCPState::ActiveOpen (TCPConnection*) { \n} \nvoid TCPState::PassiveOpen (TCPConnection*) { \n} \nvoid TCPState::Close (TCPConnection*) { \n} \nvoid TCPState::Synchronize (TCPConnection*) { \n}\nvoid TCPState::ChangeState (TCPConnection* t, TCPState* s) {\nt->ChangeState(s);\n}\nSubclasses of TCPState implement state-specific behavior. A TCP connec-\ntion can be in many states: Established, Listening, Closed, etc., and there's a\nsubclass of TCPState for each state. We'll discuss three subclasses in detail:\nTCPEstablished, \nTCPListen, \nand \nTCPClosed.\nclass TCPEstablished : \npublic TCPState {\npublic:\nstatic TCPState* Instance();\nvirtual void Transmit(TCPConnection*, TCPOctetStream*);\nvirtual void Close(TCPConnection*);\n};\nclass TCPListen : \npublic TCPState \n{\npublic:\nstatic TCPState* Instance();\nvirtual void Send(TCPConnection*);\n// . \n. \n.\n};\n", "page": 331, "type": "text", "section": "Page 331"}
{"text": "312 \nBEHAVIORAL PATTERNS \nCHAPTERS\nclass TCPClosed : \npublic TCPState \n{\npublic:\nstatic TCPState* Instance();\nvirtual void \nActiveOpen(TCPConnection*);\nvirtual void PassiveOpen(TCPConnection*);\n// . . .\n};\nTCPState subclasses maintain no local state, so they can be shared, and only one\ninstance of each is required. The unique instance of each TCPState subclass is\nobtained by the static Instance operation.9\nEach TCPState subclass implements state-specific behavior for valid requests in\nthe state:\nvoid TCPClosed::ActiveOpen (TCPConnection* t) { \n// send SYN, receive SYN, ACK, etc.\nChangeState(t, TCPEstablished::Instance() \n) ;\n}\nvoid TCPClosed::PassiveOpen (TCPConnection* t) \n{\nChangeState(t, TCPListen::Instance());\n}\nvoid TCPEstablished::Close (TCPConnection* t) { \n// send PIN, receive ACK of FIN\nChangeState(t, TCPListen::Instance());\n}\nvoid TCPEstablished::Transmit \n(\nTCPConnection* t, TCPOctetStream* \no\n) {\nt->ProcessOctet(o);\n}\nvoid TCPListen::Send (TCPConnection* t) \n{\n// send SYN, receive SYN, ACK, \netc.\nChangeState(t, TCPEstablished::Instance());\n}\nAfter performing state-specific work, these operations call the ChangeState\noperation to change the state of the TCPConnection. TCPConnection itself\ndoesn't know a thing about the TCP connection protocol; it's the TCPState\nsubclasses that define each state transition and action in \nTCP.\n9This makes each TCPState subclass a Singleton (see Singleton (127)).\n", "page": 332, "type": "text", "section": "Page 332"}
{"text": "STATE \n313\nKnown Uses\nJohnson and Zweig [JZ91] characterize \nthe State \npattern and its application \nto \nTCP\nconnection protocols.\nMost popular interactive drawing programs provide \"tools\" for performing op-\nerations by direct manipulation. For example, a line-drawing tool lets a user click\nand drag to create a new line. A selection tool lets the user select shapes. There's\nusually a palette of such tools to choose from. The user thinks of this activity as\npicking up a tool and wielding it, but in reality the editor's behavior changes \nwith the current tool: When a drawing tool is active we create shapes; when the\nselection tool is active we select shapes; and so forth. We \ncan use the State pattern\nto change the editor's behavior depending on the current tool.\nWe can define an abstract Tool class from which to define subclasses that imple-\nment tool-specific \nbehavior. The drawing editor maintains a current Tool object\nand delegates requests to it. It replaces this object when the user chooses a new\ntool, causing the behavior of the drawing editor to change accordingly.\nThis technique is used in both the HotDraw [Joh92] \nand Unidraw [VL90] drawing\neditor frameworks. It allows clients to define new kinds of tools easily. \nIn \nHotDraw, \nthe DrawingController class forwards the requests to the current Tool object. In\nUnidraw, the corresponding classes are Viewer and Tool. The following class\ndiagram sketches the Tool and DrawingController interfaces:\nCoplien's Envelope-Letter idiom [Cop92] is related to State. Envelope-Letter is\na technique for changing an object's class at run-time. The State pattern is more\nspecific, focusing on how to deal with an object whose behavior depends on its\nstate.\nRelated Patterns\nThe Flyweight (195) pattern explains when and how State objects can be shared.\nState objects are often Singletons (127).\n", "page": 333, "type": "text", "section": "Page 333"}
{"text": "This page intentionally left blank \n", "page": 334, "type": "text", "section": "Page 334"}
{"text": "STRATEGY \n315\nSTRATEGY\nObject Behavioral\nIntent\nDefine a family of algorithms, encapsulate each one, and make them interchange-\nable. Strategy lets the algorithm vary independently from clients that use it.\nAlso Known As\nPolicy\nMotivation\nMany algorithms exist for breaking a stream of text into lines. Hard-wiring all such\nalgorithms into the classes that require them isn't desirable for several reasons:\n\u2022 Clients that need linebreaking get more complex if they include the line-\nbreaking code. That makes clients bigger and harder to maintain, especially\nif they support multiple linebreaking algorithms.\n\u2022 Different algorithms will be appropriate at different times. We \ndon't want to\nsupport multiple linebreaking algorithms if we don't use them all.\n\u2022 It's difficult to add new algorithms and vary existing ones when linebreaking\nis an integral part of a client.\nWe can avoid these problems by defining classes that encapsulate different line-\nbreaking algorithms. An algorithm that's encapsulated in this way is called a\nstrategy.\nSuppose a Composition class is responsible for maintaining and updating the\nlinebreaks of text displayed in a text viewer. Linebreaking strategies aren't im-\nplemented by the class Composition. Instead, they are implemented separately\nby subclasses of the abstract Compositor class. Compositor subclasses implement\ndifferent strategies:\n", "page": 335, "type": "text", "section": "Page 335"}
{"text": "316\nBEHAVIORAL PATTERNS\nCHAPTER 5\n\u2022 SimpleCompositor implements a simple strategy that determines linebreaks\none at a time.\n\u2022 TeXCompositor implements the TgX algorithm for finding linebreaks. This\nstrategy tries to optimize linebreaks globally, that is, one paragraph at a time.\n\u2022 ArrayCompositor implements a strategy that selects breaks so that each row\nhas a fixed number of items. It's useful for breaking a collection of icons into\nrows, for example.\nA Composition maintains a reference to a Compositor object. Whenever a Compo-\nsition reformats its text, it forwards this responsibility to its Compositor object. The \nclient of Composition specifies which Compositor should be used by installing\nthe Compositor it desires into the Composition.\nApplicability\nUse the Strategy pattern when\n\u2022 many related classes differ only in their behavior. Strategies provide a way\nto configure a class with one of many behaviors.\n\u2022 you need different variants of an algorithm. For example, you might de-\nfine algorithms reflecting different space/time trade-offs. Strategies can be\nused when these variants are implemented as a class hierarchy of algo-\nrithms [HO87].\n\u2022 an algorithm uses data that clients shouldn't know about. Use the Strategy\npattern to avoid exposing complex, algorithm-specific data structures.\n\u2022 a class defines many behaviors, and these appear as multiple conditional\nstatements in its operations. Instead of many conditionals, move related\nconditional branches into their own Strategy class.\nStructure\n", "page": 336, "type": "text", "section": "Page 336"}
{"text": "STRATEGY \n317\nParticipants\n\u2022 Strategy (Compositor)\n- declares an interface common to all supported algorithms. Context uses\nthis interface to call the algorithm defined by a ConcreteStrategy.\n\u2022 ConcreteStrategy (SimpleCompositor, TeXCompositor, \nArrayCompositor)\n- implements the algorithm using the Strategy interface.\n\u2022 Context (Composition)\n-\nis configured with a ConcreteStrategy object.\n-\nmaintains a reference to a Strategy object.\n-\nmay define an interface that lets Strategy access its data.\nCollaborations\n\u2022 Strategy and Context interact to implement the chosen algorithm. A context\nmay pass all data required by the algorithm to the strategy when the algorithm\nis called. Alternatively, the context can pass itself as an argument to Strategy\noperations. That lets the strategy call back on the context as required.\n\u2022 A context forwards requests from its clients to its strategy. Clients usually\ncreate and pass a ConcreteStrategy object to the context; thereafter, clients\ninteract with the context \nexclusively. \nThere is often a family of ConcreteStrategy\nclasses for a client to choose from.\nConsequences\nThe Strategy pattern has the following benefits and drawbacks:\n1. Families of related algorithms. Hierarchies of Strategy classes define a family of\nalgorithms or behaviors for contexts to reuse. Inheritance can help factor out\ncommon functionality of the algorithms.\n2. An alternative to subclassing. Inheritance offers another way to support a\nvariety of algorithms or behaviors. You can subclass a Context class directly\nto give it different behaviors. But this hard-wires the behavior into Context. It\nmixes the algorithm implementation with Context's, making Context harder\nto understand, maintain, and extend. And you can't vary the algorithm\ndynamically. You \nwind up with many related classes whose only difference\nis the algorithm or behavior they employ. Encapsulating the algorithm in\nseparate Strategy classes lets you vary the algorithm independently of its\ncontext, making it easier to switch, understand, and extend.\n3. Strategies eliminate conditional statements. The Strategy pattern offers an alter-\nnative to conditional statements for selecting desired behavior. When differ-\nent behaviors are lumped into one class, it's hard to avoid using conditional\n", "page": 337, "type": "text", "section": "Page 337"}
{"text": "318 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nstatements to select the right behavior. Encapsulating the behavior in sepa-\nrate Strategy classes eliminates these conditional statements.\nFor example, without strategies, the code for breaking text into lines could\nlook like\nvoid Composition::Repair () \n{\nswitch (_breakingStrategy) \n{\ncase SimpleStrategy:\nComposeWithSimpleCompositor();\nbreak;\ncase TeXStrategy: \nComposeWithTeXCompositor();\nbreak;\n// . . .\n}\n// merge results with existing composition, if necessary\n}\nThe Strategy pattern eliminates this case statement by delegating the line-\nbreaking task to a Strategy object:\nvoid Composition::Repair () {\n_compositor->Compose(); \n// merge results with existing composition, if necessary\n}\nCode containing many conditional statements often indicates the need to\napply the Strategy pattern.\n4. A choice of implementations. Strategies can provide different implementations\nof the same behavior. The client can choose among strategies with different\ntime and space trade-offs.\n5. Clients must be aware of different Strategies. The pattern has a potential draw-\nback in that a client must understand how Strategies differ before it can\nselect the appropriate one. Clients might be exposed to implementation is-\nsues. Therefore you should use the Strategy pattern only when the variation\nin behavior is relevant to clients.\n6. Communication overhead between Strategy and Context. The Strategy interface\nis shared by all ConcreteStrategy classes whether the algorithms they imple-\nment are trivial or complex. Hence it's likely that some ConcreteStrategies\nwon't use all the information passed to them through this interface; simple\nConcreteStrategies may use none of it! That means there will be times when\nthe context creates and initializes parameters that never get used. If this is\nan issue, then you'll need tighter coupling between Strategy and Context.\n7. Increased number of objects. Strategies increase the number of objects in an\napplication. Sometimes you can reduce this overhead by implementing\nstrategies as stateless objects that contexts can share. Any residual state is\nmaintained by the context, which passes it in each request to the Strategy\n", "page": 338, "type": "text", "section": "Page 338"}
{"text": "STRATEGY \n319\nobject. Shared strategies should not maintain state across invocations. The\nFlyweight (195) pattern describes this approach in more detail.\nImplementation\nConsider the following implementation issues:\n1. Defining the Strategy and Context interfaces. The Strategy and Context interfaces\nmust give a ConcreteStrategy efficient access to any data it needs from a\ncontext, and vice versa.\nOne approach is to have Context pass data in parameters to Strategy\noperations\u2014in other words, take the data to the strategy. This keeps Strategy\nand Context decoupled. On the other hand, Context might pass data the\nStrategy doesn't need.\nAnother technique has a context pass itself as an argument, and the strategy\nrequests data from the context explicitly. \nAlternatively, the strategy can store\na reference to its context, eliminating the need to pass anything at all. \nEither\nway, the strategy can request exactly what it needs. But now Context must\ndefine a more elaborate interface to its data, which couples Strategy and \nContext more closely.\nThe needs of the particular algorithm and its data requirements will deter-\nmine the best technique.\n2. Strategies as template parameters. In C++ templates can be used to configure\na class with a strategy. This technique is only applicable if (1) the Strategy\ncan be selected at compile-time, and (2) it does not have to be changed at \nrun-time. In this case, the class to be configured (e.g., Context) is defined\nas a template class that has a Strategy class as a parameter:\ntemplate <class AStrategy>\nclass Context {\nvoid Operation() { \ntheStrategy.DoAlgorithm(); }\n// . . .\nprivate:\nAStrategy theStrategy;\n};\nThe class is then configured with a Strategy class when it's instantiated:\nclass MyStrategy {\npublic:\nvoid DoAlgorithm();\n};\nContext<MyStrategy> aContext;\nWith templates, there's no need to define an abstract class that defines the\ninterface to the Strategy. Using Strategy as a template parameter also\nlets you bind a Strategy to its Context statically, which can increase\nefficiency.\n", "page": 339, "type": "text", "section": "Page 339"}
{"text": "320 \nBEHAVIORAL PATTERNS \nCHAPTERS\n3. Making Strategy objects optional. The Context class may be simplified if it's\nmeaningful not to have a Strategy object. Context checks to see if it has\na Strategy object before accessing it. If there is one, then Context uses it\nnormally. If there isn't a strategy, then Context carries out default behavior.\nThe benefit of this approach is that clients don't have to deal with Strategy \nobjects at all unless they don't like the default behavior.\nSample Code\nWe'll give the high-level code for the Motivation example, which is based on the\nimplementation of Composition and Compositor classes in Interviews [LCI+92].\nThe Composition class maintains a collection of Component instances, which\nrepresent text and graphical elements in a document. A composition arranges \ncomponent objects into lines using an instance of a Compositor subclass, which\nencapsulates a linebreaking strategy. Each component has an associated natural\nsize, stretchability, and shrinkability. The stretchability defines how much the\ncomponent can grow beyond its natural size; shrinkability is how much it can\nshrink. The composition passes these values to a compositor, which uses them to\ndetermine the best location for linebreaks.\nclass Composition {\npublic:\nComposition(Compositor*);\nvoid Repair();\nprivate:\nCompositor* _compositor;\nComponent* _components;\n// the list of components \nint _componentCount;\n// the number of components \nint _lineWidth;\n// the Composition's line width\nint* _lineBreaks;\n// the position of linebreaks\n// in components \nint _lineCount;\n// the number of lines\nWhen a new layout is required, the composition asks its compositor to determine\nwhere to place linebreaks. The composition passes the compositor three arrays\nthat define natural sizes, stretchabilities, and shrinkabilities of the components. It\nalso passes the number of components, how wide the line is, and an array that\nthe compositor fills with the position of each linebreak. The compositor returns\nthe number of calculated breaks.\nThe Compositor interface lets the composition pass the compositor all the infor-\nmation it needs. This is an example of \"taking the data to the strategy\":\n", "page": 340, "type": "text", "section": "Page 340"}
{"text": "STRATEGY \n321\nclass Compositor {\npublic:\nvirtual int Compose( \nCoord natural[], Coord stretch[], Coord shrinkf],\nint componentCount, int lineWidth, int breaks[]\n) = 0;\nprotected:\nCompositor();\n};\nNote that Compositor is an abstract class. Concrete subclasses define specific\nlinebreaking strategies.\nThe composition calls its compositor in its Repair operation. Repair first initial-\nizes arrays with the natural size, stretchability, and shrinkability of each compo-\nnent (the details of which we omit for brevity). Then it calls on the compositor to\nobtain the linebreaks and finally lays out the components according to the breaks\n(also omitted):\nvoid Composition::Repair () \n{\nCoord* natural;\nCoord* stretchability; \nCoord* shrinkability; \nint componentCount;\nint* breaks;\n// prepare the arrays with the desired component sizes\n// . \n. \n.\n// determine where the breaks are:\nint breakCount; \nbreakCount - _compositor->Compose(\nnatural, stretchability, shrinkability,\ncomponentCount, _lineWidth, breaks\n) \n;\n// lay out components according to breaks\n// . \n. \n.\nNow let's look at the Compositor subclasses. SimpleCompositor examines\ncomponents a line at a time to determine where breaks should go:\nclass SimpleCompositor : \npublic Compositor {\npublic:\nSimpleCompositor \n() ,\n-\nvirtual int Compose(\nCoord natural[], Coord stretch[], Coord shrink[],\nint componentCount, int lineWidth, int breaks[]\n", "page": 341, "type": "text", "section": "Page 341"}
{"text": "322 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nTeXCompositor uses a more global strategy. It examines a paragraph at a time,\ntaking into account the components' size and stretchability. It also tries to give\nan even \"color\" to the paragraph by minimizing the whitespace between compo-\nnents.\nclass TeXCompositor \n: \npublic Compositor {\npublic:\nTeXCompositor();\nvirtual int Compose( \nCoord natural[], Coord stretch[], Coord shrinkf],\nint componentCount, int lineWidth, int breaks[]\nArrayCompositor breaks the components into lines at regular intervals.\nclass ArrayCompositor \n: \npublic Compositor \n{\npublic:\nArrayCompositor(int interval);\nvirtual int Compose( \nCoord natural[], Coord stretchf], Coord shrink[], \nint componentCount, int lineWidth, int breaks[]\n) ; \n// . . .\nThese classes don't use all the information passed in Compose. SimpleCom-\npositor ignores the stretchability of the components, taking only their nat-\nural widths into account. TeXCompositor uses all the information passed to it,\nwhereas ArrayCompositor ignores everything.\nTo instantiate Compos it ion, you pass it the compositor you want to use:\nComposition* quick = new Composition(new SimpleCompositor);\nComposition* slick - new Composition(new TeXCompositor);\nComposition* iconic = new Composition(new ArrayCompositor(100));\nCompositor's interface is carefully designed to support all layout algorithms\nthat subclasses might implement. You \ndon't want to have to change this \ninterface\nwith every new subclass, because that will require changing existing subclasses.\nIn general, the Strategy and Context interfaces determine how well the pattern\nachieves its intent.\nKnown Uses\nBoth ET++ [WGM88] and Interviews use strategies to encapsulate different line-\nbreaking algorithms as we've described.\n", "page": 342, "type": "text", "section": "Page 342"}
{"text": "STRATEGY \n323\nIn the RTL System for compiler code optimization [JML92], strategies define differ-\nent register allocation schemes (RegisterAllocator) \nand instruction set scheduling\npolicies (RISCscheduler, \nCISCscheduler). This provides flexibility in targeting the\noptimizer for different machine architectures.\nThe ET++SwapsManager calculation engine framework computes prices for dif-\nferent financial instruments [EG92]. Its key abstractions are Instrument and Yield-\nCurve. Different instruments are implemented as subclasses of Instrument. \nYield-\nCurve calculates discount factors, which determine the present value of future\ncash flows. Both of these classes delegate some behavior to Strategy objects. The\nframework provides a family of ConcreteStrategy classes for generating cash\nflows, valuing swaps, and calculating discount factors. You can create new cal-\nculation engines by configuring Instrument and YieldCurve with the different\nConcreteStrategy objects. This approach supports mixing and matching existing\nStrategy implementations as well as defining new ones.\nThe Booch components [BV90] use strategies as template arguments. The Booch\ncollection classes support three different kinds of memory allocation strategies:\nmanaged (allocation out of a pool), controlled (allocations/deallocations are pro-\ntected by locks), \nand unmanaged (the normal memory allocator). These strategies\nare passed as template arguments to a collection class when it's instantiated. For\nexample, an UnboundedCollection that uses the unmanaged strategy is instanti-\nated as UnboundedCollection<MyItemType*, Unmanaged>.\nRApp is a system for integrated circuit layout [GA89, AG90]. RApp must lay out\nand route wires that connect subsystems on the circuit. Routing algorithms in\nRApp are defined as subclasses of an abstract Router class. Router is a Strategy\nclass.\nBorland's Object \nWindows [Bor94] uses strategies in dialogs boxes to ensure that\nthe user enters valid data. For example, numbers might have to be in a certain\nrange, and a numeric entry field should accept only digits. Validating that a string\nis correct can require a table look-up.\nObjectWindows uses Validator objects to encapsulate validation strategies. Val-\nidators are examples of Strategy objects. Data entry fields delegate the validation\nstrategy to an optional Validator object. The client attaches a validator to a field\nif validation is required (an example of an optional strategy). When the dialog is\nclosed, the entry fields ask their validators to validate the data. The class library\nprovides validators for common cases, such as a Range \nValidator for numbers.\nNew client-specific validation strategies can be defined easily by subclassing the\nValidator class.\nRelated Patterns\nFlyweight (195): Strategy objects often make good flyweights.\n", "page": 343, "type": "text", "section": "Page 343"}
{"text": "This page intentionally left blank \n", "page": 344, "type": "text", "section": "Page 344"}
{"text": "TEMPLATE METHOD \n325\nTEMPLATE METHOD\nClass Behavioral\nIntent\nDefine the skeleton of an algorithm in an operation, deferring some steps to\nsubclasses. Template Method lets subclasses redefine certain steps of an algorithm\nwithout changing the algorithm's structure.\nMotivation\nConsider an application framework that provides Application and Document\nclasses. The \nApplication class is responsible for opening existing documents stored\nin an external format, such as a file. A Document object represents the information\nin a document once it's read from the file.\nApplications built with the framework can subclass Application and Document to\nsuit specific needs. For example, a drawing application defines Draw \nApplication\nand DrawDocument subclasses; a spreadsheet application defines Spreadsheet-\nApplication and SpreadsheetDocument subclasses.\nThe abstract Application class defines the algorithm for opening and reading a\ndocument in its OpenDocument operation:\nvoid Application::OpenDocument (const char^\nif (!CanOpenDocument(name)) {\n// cannot handle this document\nreturn;\n}\nname) {\n", "page": 345, "type": "text", "section": "Page 345"}
{"text": "326 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nDocument* doc = DoCreateDocument();\nif (doc) \n{ \n_docs->AddDocument(doc);\nAboutToOpenDocument(doc);\ndoc->Open();\ndoc->DoRead();\n}\n}\nOpenDocument defines each step for opening a document. It checks if the docu-\nment can be opened, creates the application-specific Document object, adds it to\nits set of documents, and reads the Document from a file.\nWe call OpenDocument a template method. A template method defines an algo-\nrithm in terms of abstract operations that subclasses override to provide concrete\nbehavior. Application subclasses define the steps of the algorithm that check if\nthe document can be opened (CanOpenDocument) and that create the Document\n(DoCreateDocument). Document classes define the step that reads the document\n(DoRead). The template method also defines an operation that lets Application\nsubclasses know when the document is about to be opened (AboutToOpenDocu-\nment), in case they care.\nBy defining some of the steps of an algorithm using abstract operations, the tem-\nplate method fixes their ordering, but it lets Application and Document subclasses\nvary those steps to suit their needs.\nApplicability\nThe Template Method pattern should be used\n\u2022 to implement the invariant parts of an algorithm once and leave it up to\nsubclasses to implement the behavior that can vary.\n\u2022 when common behavior among subclasses should be factored and localized\nin a common class to avoid code duplication. This is a good example of\n\"refactoring to generalize\" as described by Opdyke and Johnson [OJ93].\nYou first identify the differences in the existing code and then separate the\ndifferences into new operations. Finally, you replace the differing code with\na template method that calls one of these new operations.\n\u2022 to control subclasses extensions. You can define a template method that calls\n\"hook\" operations (see Consequences) at specific points, thereby permitting \nextensions only at those points.\n", "page": 346, "type": "text", "section": "Page 346"}
{"text": "Strurture\nTEMPLATE METHOD \n327\nParticipants\n\u2022 AbstractClass (Application)\n- defines abstract primitive operations that concrete subclasses define to\nimplement steps of an algorithm.\n- implements a template method defining the skeleton of an algorithm. The\ntemplate method calls primitive operations as well as operations defined\nin AbstractClass or those of other objects.\n\u2022 ConcreteClass (MyApplication)\n- implements the primitive operations to carry out subclass-specific steps \nof\nthe algorithm.\nCollaborations\n\u2022 ConcreteClass relies on AbstractClass to implement the invariant steps of the\nalgorithm.\nConsequences\nTemplate methods are a fundamental technique for code reuse. They are partic-\nularly important in class libraries, because they are the means for factoring out\ncommon behavior in library classes.\nTemplate methods lead to an inverted control structure that's sometimes referred\nto as \"the Hollywood principle,\" that is, \"Don't call us, we'll call you\" [Swe85].\nThis refers to how a parent class calls the operations of a subclass and not the\nother way around.\nTemplate methods call the following kinds of operations:\n\u2022 concrete operations (either on the ConcreteClass or on client classes);\n", "page": 347, "type": "text", "section": "Page 347"}
{"text": "328 \nBEHAVIORAL PATTERNS \nCHAPTER 5\n\u2022 concrete AbstractClass operations (i.e., operations that are generally useful\nto subclasses);\n\u2022 primitive operations (i.e., abstract operations);\n\u2022 factory methods (see Factory Method (107)); and\n\u2022 hook operations, which provide default behavior that subclasses can extend\nif necessary. A hook operation often does nothing by default.\nIt's important for template methods to specify which operations are hooks (may\nbe overridden) and which are abstract operations (must be overridden). To reuse\nan abstract class effectively, subclass writers must understand which operations\nare designed for overriding.\nA subclass can extend a parent class operation's behavior by overriding the oper-\nation and calling the parent operation explicitly:\nvoid DerivedClass::Operation () \n{\nParentClass::Operation(); \n// DerivedClass extended behavior\n}\nUnfortunately, it's easy to forget to call the inherited operation. We \ncan transform\nsuch an operation into a template method to give the parent control over how\nsubclasses extend it. The idea is to call a hook operation from a template method\nin the parent class. Then subclasses can then override this hook operation:\nvoid ParentClass::Operation () \n{\n// ParentClass behavior \nHookOperation();\n}\nHookOperation does \nnothing \nin \nParentClass:\nvoid ParentClass::HookOperation () \n{ \n}\nSubclasses override HookOperation to extend its behavior:\nvoid DerivedClass::HookOperation () {\n// derived class extension \n}\nImplementation\nThree implementation issues are worth noting:\n1. Using C++ \naccess control. In C++, the primitive operations that a template\nmethod calls can be declared protected members. This ensures that they\nare only called by the template method. Primitive operations that must be\n", "page": 348, "type": "text", "section": "Page 348"}
{"text": "TEMPLATE METHOD \n329\noverridden are declared pure virtual. The template method itself should not\nbe overridden; therefore you can make the template method a nonvirtual\nmember function.\n2. Minimizing primitive operations. An important goal in designing template\nmethods is to minimize the number of primitive operations that a subclass\nmust override to flesh out the algorithm. The more operations that need\noverriding, the more tedious things get for clients.\n3. Naming conventions. You can identify the operations that should be overrid-\nden by adding a prefix to their names. For example, the MacApp framework \nfor Macintosh applications [App89] prefixes template method names with\n\"Do-\": \"DoCreateDocument\", \"DoRead\", and so forth.\nSample Code\nThe following C++ example shows how a parent class can enforce an invariant for\nits subclasses. The example comes from NeXT's AppKit [Add94]. Consider a class\nView that supports drawing on the screen. View enforces the invariant that its\nsubclasses can draw into a view only after it becomes the \"focus,\" which requires\ncertain drawing state (for example, colors and fonts) to be set up properly.\nWe can use a Display template method to set up this state. View defines two\nconcrete operations, SetFocus and ResetFocus, that set up and clean up the\ndrawing state, respectively. View's DoDisplay hook operation performs the ac-\ntual drawing. Display calls SetFocus before DoDisplay to setup the drawing\nstate; Display calls ResetFocus afterwards to release the drawing state.\nvoid View::Display () \n{ \nSetFocus();\nDoDisplay(); \nResetFocus();\n}\nTo maintain the invariant, the view's clients always call Display, and View\nsubclasses always override DoDisplay.\nDoDisplay does nothing in View:\nvoid View::DoDisplay () \n{ \n}\nSubclasses override it to add their specific drawing behavior:\nvoid MyView::DoDisplay () \n{\n// render the view's contents\n}\nKnown Uses\nTemplate methods are so fundamental that they can be found in almost every\n", "page": 349, "type": "text", "section": "Page 349"}
{"text": "330 \nBEHAVIORAL PATTERNS \nCHAPTERS\nabstract class. Wirfs-Brock et al. [WBWW90, WBJ90] provide a good overview\nand discussion of template methods.\nRelated Patterns\nFactory Methods (107) are often called by template methods. In the Motivation\nexample, the factory method DoCreateDocument is called by the template method\nOpenDocument.\nStrategy (315): Template methods use inheritance to vary part of an algorithm.\nStrategies use delegation to vary the entire algorithm.\n", "page": 350, "type": "text", "section": "Page 350"}
{"text": "VISITOR \n331\nVISITOR\nObject Behavioral\nIntent\nRepresent an operation to be performed on the elements of an object structure. \nVis-\nitor lets you define a new operation without changing the classes of the elements\non which it operates.\nMotivation\nConsider a compiler that represents programs as abstract syntax trees. It will need\nto perform operations on abstract syntax trees for \"static semantic\" analyses like\nchecking that all variables are defined. It will also need to generate code. So \nit might\ndefine operations for type-checking, code optimization, flow analysis, checking\nfor variables being assigned values before they're used, and so on. Moreover,\nwe could use the abstract syntax trees for pretty-printing, program restructuring,\ncode instrumentation, and computing various metrics of a program.\nMost of these operations will need to treat nodes that represent assignment state-\nments differently from nodes that represent variables or arithmetic expressions.\nHence there will be one class for assignment statements, another for variable\naccesses, another for arithmetic expressions, and so on. The set of node classes\ndepends on the language being compiled, of course, but it doesn't change much\nfor a given language.\nThis diagram shows part of the Node class hierarchy. The problem here is that\ndistributing all these operations across the various node classes leads to a system\nthat's hard to understand, maintain, and change. It will be confusing to have type-\nchecking code mixed with pretty-printing code or flow analysis code. Moreover,\nadding a new operation usually requires recompiling all of these classes. It would\n", "page": 351, "type": "text", "section": "Page 351"}
{"text": "332\nBEHAVIORAL PATTERNS\nCHAPTER 5\nbe better if each new operation could be added separately, and the node classes\nwere independent of the operations that apply to them.\nWe can have both by packaging related operations from each class in a separate\nobject, called a visitor, and passing it to elements of the abstract syntax tree as it's\ntraversed. When an element \"accepts\" the visitor, it sends a request to the visitor\nthat encodes the element's class. It also includes the element as an argument. The\nvisitor will then execute the operation for that element\u2014the operation that used\nto be in the class of the element.\nFor example, a compiler that didn't use visitors might type-check a procedure\nby calling the TypeCheck operation on its abstract syntax tree. Each of the nodes\nwould implement TypeCheck by calling TypeCheck on its components (see the\npreceding class diagram). If the compiler type-checked a procedure using visitors,\nthen it would create a TypeCheckingVisitor object and call the Accept operation\non the abstract syntax tree with that object as an argument. Each of the nodes\nwould implement Accept by calling back on the visitor: an assignment node\ncalls VisitAssignment operation on the visitor, while a variable reference calls\nVisitVariableReference. What used to be the TypeCheck operation in class Assign-\nmentNode is now the VisitAssignment operation on \nTypeCheckingVisitor.\nTo make visitors work for more than just type-checking, we need an abstract parent\nclass NodeVisitor for all visitors of an abstract syntax tree. NodeVisitor must\ndeclare an operation for each node class. An application that needs to compute\nprogram metrics will define new subclasses of NodeVisitor and will no longer \nneed to add application-specific code to the node classes. The Visitor pattern\nencapsulates the operations for each compilation phase in a Visitor associated\nwith that phase.\n", "page": 352, "type": "text", "section": "Page 352"}
{"text": "VISITOR \n333\nWith the Visitor pattern, you define two class hierarchies: one for the elements\nbeing operated on (the Node hierarchy) and one for the visitors that define op-\nerations on the elements (the Node \nVisitor hierarchy). You \ncreate a new operation\nby adding a new subclass to the visitor class hierarchy. As long as the grammar\nthat the compiler accepts doesn't change (that is, we don't have to add new Node \nsubclasses), we can add new functionality simply by defining new Node \nVisitor\nsubclasses.\nApplicability\nUse the Visitor pattern when\n\u2022 an object structure contains many classes of objects \nwith differing interfaces,\nand you want to perform operations on these objects that depend on their\nconcrete classes.\n\u2022 many distinct and unrelated operations need to be performed on objects in \nan\nobject structure, and you want to avoid \"polluting\" their classes with these\noperations. Visitor \nlets you keep related operations together by defining \nthem\nin one class. When the object structure is shared by many applications, use\nVisitor to put operations in just those applications that need them.\n\u2022 the classes defining the object structure rarely change, but you often want\nto define new operations over the structure. Changing the object structure\nclasses requires redefining the interface to all visitors, which is potentially\ncostly. If the object structure classes change often, then it's probably better to\ndefine the operations in those classes.\n", "page": 353, "type": "text", "section": "Page 353"}
{"text": "334 \nBEHAVIORAL PATTERNS\nStructure\nCHAPTER 5\nParticipants\n\u2022 Visitor (NodeVisitor)\n- declares a Visit operation for each class of ConcreteElement in the object\nstructure. The \noperation's name and signature identifies the class that sends\nthe Visit request to the visitor. That lets the visitor determine the concrete\nclass of the element being visited. Then the visitor can access the element\ndirectly through its particular interface.\n\u2022 Concrete \nVisitor (TypeCheckingVisitor)\n- implements each operation declared by Visitor. Each \noperation implements\na fragment of the algorithm defined for the corresponding class of object\nin the structure. ConcreteVisitor provides the context for the algorithm\nand stores its local state. This state often accumulates results during the\ntraversal of the structure.\n\u2022 Element (Node)\n- defines an Accept operation that takes a visitor as an argument.\n", "page": 354, "type": "text", "section": "Page 354"}
{"text": "VISITOR \n335\n\u2022 ConcreteElement (AssignmentNode,VariableRefNode)\n- implements an Accept operation that takes a visitor as an argument.\n\u2022 ObjectStructure (Program)\n- can enumerate its elements.\n- may provide a high-level interface to allow the visitor to visit its elements.\n- may either be a composite (see Composite (163)) or a collection such as a\nlist or a set.\nCollaborations\n\u2022 A client that uses the Visitor pattern must create a ConcreteVisitor object and\nthen traverse the object structure, visiting each element with the visitor.\n\u2022 When an element is visited, it calls the Visitor operation that corresponds to\nits class. The element supplies itself as an argument to this operation to let the\nvisitor access its state, if necessary.\nThe following interaction diagram illustrates the collaborations between an\nobject structure, a visitor, and two elements:\nConsequences\nSome of the benefits and liabilities of the Visitor pattern are as follows:\n1. Visitor makes adding new operations easy. Visitors \nmake it easy to add operations\nthat depend on the components of complex objects. You can define a new\noperation over an object structure simply by adding a new visitor. In contrast,\nif you spread functionality over many classes, then you must change each\nclass to define a new operation.\n2. A visitor gathers related operations and separates unrelated ones. Related behav-\nior isn't spread over the classes defining the object structure; it's localized\nin a visitor. Unrelated sets of behavior are partitioned in their own visitor\n", "page": 355, "type": "text", "section": "Page 355"}
{"text": "336 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nsubclasses. That simplifies both the classes defining the elements and the al-\ngorithms defined in the visitors. Any algorithm-specific data structures can\nbe hidden in the visitor.\n3. Adding new ConcreteElement classes is hard. The Visitor pattern makes it hard\nto add new subclasses of Element. Each new ConcreteElement gives rise to\na new abstract operation on Visitor and a corresponding implementation\nin every ConcreteVisitor class. Sometimes a default implementation can be\nprovided in Visitor that can be inherited by most of the Concrete \nVisitors, but\nthis is the exception rather than the rule.\nSo the key consideration in applying the Visitor pattern is whether you are\nmostly likely to change the algorithm applied over an object structure or\nthe classes of objects that make up the structure. The Visitor class hierarchy\ncan be difficult to maintain when new ConcreteElement classes are added\nfrequently. In such cases, it's probably easier just to define operations on the\nclasses that make up the structure. If the Element class hierarchy is stable,\nbut you are continually adding operations or changing algorithms, then the\nVisitor pattern will help you manage the changes.\n4. Visiting across class hierarchies. An iterator (see Iterator (257)) can visit the\nobjects in a structure as it traverses them by calling their operations. But an\niterator can't work across object structures with different types of elements.\nFor example, the Iterator interface defined on page 263 \ncan access only objects\nof type Item:\ntemplate <class Item>\nclass Iterator {\n// . \n. \n.\nItem Currentltem() const;\n};\nThis implies that all elements the iterator can visit have a common parent\nclass Item.\nVisitor does not have this restriction. It can visit objects that don't have a\ncommon parent class. You can add any type of object to a Visitor interface.\nFor example, in\nclass Visitor {\npublic:\n// . . . \nvoid VisitMyType(MyType*);\nvoid VisitYourType(YourType*);\n};\nMyType and YourType do not have to be related through inheritance at all.\n5. Accumulating state. Visitors can accumulate state as they visit each element\nin the object structure. Without a visitor, this state would be passed as extra\narguments to the operations that perform the traversal, or they might appear\nas global variables.\n", "page": 356, "type": "text", "section": "Page 356"}
{"text": "VISITOR \n337\n6. Breaking encapsulation. Visitor's approach assumes that the ConcreteElement\ninterface is powerful enough to let visitors do their job. As a result, the pattern\noften forces you to provide public operations that access an element's internal\nstate, which may compromise its encapsulation.\nImplementation\nEach object structure will have an associated Visitor class. This abstract visitor\nclass declares a VisitConcreteElement operation for each class of ConcreteEle-\nment defining the object structure. Each Visit operation on the Visitor declares\nits argument to be a particular ConcreteElement, allowing the Visitor to access \nthe interface of the ConcreteElement directly. Concrete \nVisitor classes override\neach Visit operation to implement visitor-specific behavior for the corresponding\nConcreteElement class.\nThe Visitor class would be declared like this in C++:\nclass Visitor {\npublic:\nvirtual void VisitElementA(ElementA*);\nvirtual void VisitElementB(ElementB*);\n// and so on for other concrete elements\nprotected:\nVisitor();\n};\nEach class of ConcreteElement implements an Accept operation that calls the\nmatching Visit. . . operation on the visitor for that ConcreteElement. Thus the \noperation that ends up getting called depends on both the class of the element\nand the class of the visitor.10\nThe concrete elements are declared as\nclass Element {\npublic:\nvirtual ~Element(); \nvirtual void Accept(Visitors) = 0;\nprotected:\nElement();\n};\n10 We could use function overloading to give these operations the same simple name, like Visit, since\nthe operations are already differentiated by the parameter they're passed. There are pros and cons to such \noverloading. On the one hand, it reinforces the fact that each operation involves the same analysis, albeit on\na different argument. On the other hand, that might make what's going on at the call site less obvious to\nsomeone reading the code. It really boils down to whether you believe function overloading is good or not.\n", "page": 357, "type": "text", "section": "Page 357"}
{"text": "338 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nclass ElementA : \npublic Element {\npublic:\nElementA(); \nvirtual void Accept(Visitor& v) { \nv.VisitElementA(this); }\n};\nclass Elements : \npublic Element {\npublic:\nElements(); \nvirtual void Accept(Visitors v) { \nv.VisitElementB(this); }\n};\nA CompositeElement class might implement Accept like this:\nclass CompositeElement : \npublic Element {\npublic:\nvirtual void Accept(Visitor^);\nprivate:\nList<Element.*>* __children;\n};\nvoid CompositeElement::Accept (Visitork v) {\nListIterator<Element*> i(_children);\nfor (i. \nFirst \n(); 1 \ni \n. \nIsDone \n() \n; i.NextO) {\ni.Currentltem()->Accept(v);\n}\nv.VisitCompositeElement(this);\n}\nHere are two other implementation issues that arise when you apply the Visitor\npattern:\n1. Double dispatch. Effectively, the Visitor pattern lets you add operations to\nclasses without changing them. Visitor achieves this by using a technique\ncalled double-dispatch. It's a well-known technique. In fact, some program-\nming languages support it directly (CLOS, for example). Languages like C++\nand Smalltalk support single-dispatch.\nIn single-dispatch languages, two criteria determine which operation will\nfulfill a request: the name of the request and the type of receiver. For ex-\nample, the operation that a GenerateCode request will call depends on the\ntype of node object you ask. In C++, \ncalling Generat eCode on an instance \nof\nVariableRef Node will call VariableRef Node: : GenerateCode (which\ngenerates code for a variable reference). Calling GenerateCode on an\nAssignmentNode will call AssignmentNode: : \nGenerateCode (which\nwill generate code for an assignment). The operation that gets executed\ndepends both on the kind of request and the type of the receiver.\n\"Double-dispatch\" simply means the operation that gets executed depends\non the kind of request and the types of two receivers. Accept is a double-\ndispatch operation. Its meaning depends on two types: the Visitor's and the\n", "page": 358, "type": "text", "section": "Page 358"}
{"text": "VISITOR \n339\nElement's. Double-dispatching lets visitors request different operations on\neach class of element.11\nThis is the key to the Visitor pattern: The operation that gets executed de-\npends on both the type of Visitor and the type of Element it visits. Instead of\nbinding operations statically into the Element interface, you can consolidate\nthe operations in a Visitor and use Accept to do the binding at run-time. \nEx-\ntending the Element interface amounts to defining one new Visitor subclass\nrather than many new Element subclasses.\n2. Who is responsible for traversing the object structure? A visitor must visit each\nelement of the object structure. The question is, how does it get there? We \ncan\nput responsibility for traversal in any of three places: in the object structure,\nin the visitor, or in a separate iterator object (see Iterator (257)).\nOften the object structure is responsible for iteration. A collection will simply\niterate over its elements, calling the Accept operation on each. A composite\nwill commonly traverse itself by having each Accept operation traverse the\nelement's children and call Accept on each of them recursively.\nAnother solution is to use an iterator to visit the elements. In C++, \nyou could\nuse either an internal or external iterator, depending on what is available\nand what is most efficient. In Smalltalk, you usually use an internal iterator\nusing do: and a block. Since internal iterators are implemented by the object\nstructure, using an internal iterator is a lot like making the object structure\nresponsible for iteration. The main difference is that an internal iterator will\nnot cause double-dispatching\u2014it will call an operation on the visitor with\nan element as an argument as opposed to calling an operation on the element\nwith the visitor as an argument. But it's easy to use the Visitor pattern with \nan internal iterator if the operation on the visitor simply calls the operation\non the element without recursing.\nYou could even put the traversal algorithm in the visitor, although you'll end\nup duplicating the traversal code in each Concrete \nVisitor for each aggregate\nConcreteElement. The main reason to put the traversal strategy in the visitor\nis to implement a particularly complex traversal, one that depends on the\nresults of the operations on the object structure. We'll give an example of\nsuch a case in the Sample Code.\nSample Code\nBecause visitors are usually associated with composites, we'll use the Equipment\nclasses defined in the Sample Code of Composite (163) to illustrate the Visitor\npattern. We will use Visitor to define operations for computing the inventory of\nmaterials and the total cost for a piece of equipment. The Equipment classes are\n11 \nIf we can have double-dispatch, then why not triple or quadruple, or any other number? Actually, double-\ndispatch is just a special case of multiple dispatch, in which the operation is chosen based on any number \nof types. (CLOS actually supports multiple dispatch.) Languages that support double- or multiple dispatch\nlessen the need for the Visitor pattern.\n", "page": 359, "type": "text", "section": "Page 359"}
{"text": "340 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nso simple that using Visitor isn't really necessary, but they make it easy to see\nwhat's involved in implementing the pattern.\nHere again is the Equipment class from Composite (163). We've augmented it\nwith an Accept operation to let it work with a visitor.\nclass Equipment {\npublic:\nvirtual ~Equipment();\nconst char* Name() { \nreturn _name; }\nvirtual Watt Power(); \nvirtual Currency NetPrice();\nvirtual Currency DiscountPrice();\nvirtual void Accept(EquipmentVisitork);\nprotected:\nEquipment(const char*);\nprivate:\nconst char* _name;\n};\nThe Equipment operations return the attributes of a piece of equipment, such as\nits power consumption and cost. Subclasses redefine these operations appropri-\nately for specific types of equipment (e.g., a chassis, drives, and planar boards).\nThe abstract class for all visitors of equipment has a virtual function for each\nsubclass of equipment, as shown next. All of the virtual functions do nothing by\ndefault.\nclass EquipmentVisitor {\npublic:\nvirtual ~EquipmentVisitor();\nvirtual void VisitFloppyDisk(FloppyDisk*);\nvirtual void VisitCard(Card*); \nvirtual void VisitChassis(Chassis*);\nvirtual void VisitBus(Bus*);\n// and so on for other concrete subclasses of Equipment\nprotected:\ntquipmentvisitor();\n};\nEquipment subclasses define Accept in basically the same way: It calls the\nEquipmentVisitor operation that corresponds to the class that received the\nAccept request, like this:\nvoid FloppyDisk::Accept (EquipmentVisitork visitor) {\nvisitor.VisitFloppyDisk(this);\n}\n", "page": 360, "type": "text", "section": "Page 360"}
{"text": "VISITOR \n341\nEquipment that contains other equipment (in particular, subclasses of Com-\npositeEquipment in the Composite pattern) implements Accept by iterating\nover its children and calling Accept on each of them. Then it calls the Visit\noperation as usual. For example, Chassis : : \nAccept could traverse all the parts\nin the chassis as follows:\nvoid Chassis::Accept (EquipmentVisitor& visitor) {\nfor (\nListIterator<Equipment*> i(_parts);\n!i.IsDone();\ni.Next()\n) {\ni.Currentltem()->Accept(visitor);\n}\nvisitor.VisitChassis(this);\n}\nSubclasses of EquipmentVisitor define particular algorithms over the equip-\nment structure. The Pr \ni c \ningVi \ns i t \nor computes the cost of \nthe equipment struc-\nture. It computes the net price of all simple equipment (e.g., floppies) and the\ndiscount price of all composite equipment (e.g., chassis and buses).\nclass PricingVisitor : \npublic EquipmentVisitor \n{\npublic:\nPricingVisitor();\nCurrency& GetTotalPrice();\nvirtual void VisitFloppyDisk(FloppyDisk*);\nvirtual void VisitCard(Card*); \nvirtual void VisitChassis(Chassis*);\nvirtual void VisitBus(Bus*); \n// . . .\nprivate:\nCurrency _total;\n};\nvoid PricingVisitor::VisitFloppyDisk (FloppyDisk* e) \n{\n_total += e->NetPrice();\n}\nvoid PricingVisitor::VisitChassis (Chassis* e) \n{\n_total +- e->DiscountPrice();\n}\nPricingVisitor will compute the total cost of all nodes in the equipment\nstructure. Note that PricingVisitor chooses the appropriate pricing policy\nfor a class of equipment by dispatching to the corresponding member function.\nWhat's more, we can change the pricing policy of an equipment structure just by\nchanging the PricingVisitor class.\n", "page": 361, "type": "text", "section": "Page 361"}
{"text": "342 \nBEHAVIORAL PATTERNS \nCHAPTERS\nWe can define a visitor for computing inventory like this:\nclass Inventory-Visitor : \npublic EquipmentVisitor {\npublic:\nInventoryVisitor();\nInventory^ Getlnventory();\nvirtual void VisitFloppyDisk(FloppyDisk*);\nvirtual void VisitCard(Card*); \nvirtual void VisitChassis(Chassis*);\nvirtual void VisitBus(Bus*); \n// . \n. \n.\nprivate:\nInventory _inventory;\n};\nThe InventoryVisitor accumulates the totals for each type of equipment in\nthe object structure. InventoryVisitor uses an Inventory class that defines\nan interface for adding equipment (which we won't bother defining here).\nvoid InventoryVisitor::VisitFloppyDisk (FloppyDisk* e) \n{\n_inventory.Accumulate(e);\n}\nvoid InventoryVisitor::VisitChassis (Chassis* e) {\n_inventory.Accumulate(e);\n}\nHere's how we can use an InventoryVisitor on an equipment structure:\nEquipment* component;\nInventoryVisitor visitor;\ncomponent->Accept(visitor);\ncout \n\u00ab \"Inventory \"\n\u00ab component->Name() \n\u00ab visitor.Getlnventory();\nNow we'll show how to implement the Smalltalk example from the Interpreter\npattern (see page 248) with the Visitor pattern. Like the previous example, this\none is so small that Visitor probably won't buy us much, but it provides a good\nillustration of how to use the pattern. Further, it illustrates a situation in which\niteration is the visitor's responsibility.\nThe object structure (regular expressions) is made of four classes, and all of\nthem have an accept: method that takes the visitor as an argument. In class\nSequenceExpression, the accept: method is\n", "page": 362, "type": "text", "section": "Page 362"}
{"text": "VISITOR \n343\naccept: aVisitor \naVisitor visitSequence: self\nIn class RepeatExpression, the accept: method sends the visitRepeat:\nmessage. In class AlternationExpression, it sends the visitAlterna-\ntion: message. In class Literal-Expression, it sends the visitLiteral:\nmessage.\nThe four classes also must have accessing functions that the visitor can \nuse.\nFor SequenceExpression these are expressionl and expression2; for\nAlternationExpression these are alternativel and alternative2; for\nRepeat Express \nion it is \nrepet \nit ion; and for Lit eralExpress ion these \nare\ncomponents.\nThe Concrete \nVisitor class is REMatchingVisitor. It is responsible for the tra-\nversal because its traversal algorithm is irregular. The biggest irregularity is\nthat a RepeatExpression will repeatedly traverse its component. The class\nREMatchingVisitor has an instance variable inputState. Its methods are\nessentially the same as the match: methods of the expression classes in the In-\nterpreter pattern except they replace the argument named inputState with the\nexpression node being matched. However, they still return the set of streams that\nthe expression would match to identify the current state.\nvisitSequence: sequenceExp \ninputState := sequenceExp expressionl accept: self.\nsequenceExp expression2 accept: self.\nvisitRepeat: repeatExp \n! finalState I \nfinalState := inputState \ncopy.\n[inputState isEmpty]\nwhileFalse:\n[inputState := repeatExp repetition \naccept: self.\nfinalState addAll: inputState].\n\" \nfinalState\nvisitAlternation: \nalternateExp\nI finalState \noriginalState I \noriginalState := \ninputState. \nfinalState := alternateExp alternativel accept: self.\ninputState := originalState. \nfinalState addAll: (alternateExp \nalternative2 \naccept: self).\n~ finalState\n", "page": 363, "type": "text", "section": "Page 363"}
{"text": "344 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nvisitLiteral: literalExp\nI finalState tStream I \nfinalState := Set new.\ninputState\ndo: \n[:stream I tStream := stream copy.\n(tStream nextAvailable:\nliteralExp components size\n) = literalExp components \nifTrue: [finalState add: tStream]\n] .\n\" finalState\nKnown Uses\nThe Smalltalk-80 compiler has a Visitor class called ProgramNodeEnumerator.\nIt's used primarily for algorithms that analyze source code. It isn't used for code\ngeneration or pretty-printing, although it could be.\nIRIS Inventor [Str931 is a toolkit for developing 3-D \ngraphics applications. Inventor\nrepresents a three-dimensional scene as a hierarchy of nodes, each representing\neither a geometric object or an attribute of one. Operations like rendering a scene\nor mapping an input event require traversing this hierarchy in different ways.\nInventor does this using visitors called \"actions.\" There are different visitors for\nrendering, event handling, searching, filing, and determining bounding boxes.\nTo make adding new nodes easier, Inventor implements a double-dispatch scheme\nfor C++. \nThe scheme relies on run-time type information and a two-dimensional\ntable in which rows represent visitors and columns represent node classes. The\ncells store a pointer to the function bound to the visitor and node class.\nMark Linton coined the term \"Visitor\" in the X Consortium's Fresco Application\nToolkit specification [LP93].\nRelated Patterns\nComposite (163): Visitors \ncan be used to apply an operation over an object structure\ndefined by the Composite pattern.\nInterpreter (243): Visitor may be applied to do the interpretation.\n", "page": 364, "type": "text", "section": "Page 364"}
{"text": "DISCUSSION OF BEHAVIORAL PATTERNS \n345\nDiscussion of Behavioral Patterns\nEncapsulating Variation\nEncapsulating variation is a theme of many behavioral patterns. When an aspect of\na program changes frequently, these patterns define an object that encapsulates that\naspect. Then other parts of the program can collaborate with the object whenever they\ndepend on that aspect. The patterns usually define an abstract class that describes the\nencapsulating object, and the pattern derives its name from that object.12 For example,\n\u2022 a Strategy object encapsulates an algorithm (Strategy (315)),\n\u2022 a State object encapsulates a state-dependent behavior (State (305)),\n\u2022 a Mediator object encapsulates the protocol between objects (Mediator (273)), and\n\u2022 an Iterator object encapsulates the way you access and traverse the components\nof an aggregate object (Iterator (257)).\nThese patterns describe aspects of a program that are likely to change. Most patterns\nhave two kinds of objects: \nthe new object(s) that encapsulate the aspect, and the existing\nobject(s) that use the new ones. Usually the functionality of new objects would be an\nintegral part of the existing objects were it not for the pattern. For example, code for\na Strategy would probably be wired into the strategy's Context, and code for a State\nwould be implemented directly in the state's Context.\nBut not all object behavioral patterns partition functionality like this. For example,\nChain of Responsibility (223) deals with an arbitrary number of objects (i.e., a chain),\nall of which may already exist in the system.\nChain of Responsibility illustrates another difference in behavioral patterns: Not all\ndefine static communication relationships between classes. Chain of Responsibility\nprescribes communication between an open-ended number of objects. Other patterns\ninvolve objects that are passed around as arguments.\nObjects as Arguments\nSeveral patterns introduce an object that's always used as an argument. One of these\nis Visitor (331). A Visitor object is the argument to a polymorphic Accept operation on\nthe objects it visits. The visitor is never considered a part of those objects, even though\nthe conventional alternative to the pattern is to distribute Visitor code across the object\nstructure classes.\n12 This theme runs through other kinds of patterns, too. Abstract Factory (87), Builder (97), and Proto-\ntype (117) all encapsulate knowledge about how objects are created. Decorator (175) encapsulates responsi-\nbility that can be added to an object. Bridge (151) separates an abstraction from its implementation, letting\nthem vary independently.\n", "page": 365, "type": "text", "section": "Page 365"}
{"text": "346 \nBEHAVIORAL PATTERNS \nCHAPTER 5\nOther patterns define objects that act as magic tokens to be passed around and invoked\nat a later time. Both Command (233) and Memento (283) fall into this category. In\nCommand, the token represents a request; in Memento, it represents the internal state\nof an object at a particular time. In both cases, the token can have a complex internal\nrepresentation, but the client is never aware of it. But even here there are differences. \nPolymorphism is important in the Command pattern, because executing the Command\nobject is a polymorphic operation. In contrast, the Memento interface is so narrow that\na memento can only be passed as a value. So it's likely to present no polymorphic\noperations at all to its clients.\nShould Communication be Encapsulated or Distributed?\nMediator (273) and Observer (293) are competing patterns. The difference between\nthem is that Observer distributes communication by introducing Observer and Subject\nobjects, whereas a Mediator object encapsulates the communication between other\nobjects.\nIn the Observer pattern, there is no single object that encapsulates a constraint. Instead,\nthe Observer and the Subject must cooperate to maintain the constraint. Communica-\ntion patterns are determined by the way observers and subjects are interconnected: a\nsingle subject usually has many observers, and sometimes the observer of one subject is\na subject of another observer. The Mediator pattern centralizes rather than distributes.\nIt places the responsibility for maintaining a constraint squarely in the mediator.\nWe've found it easier to make reusable Observers and Subjects than to make reusable\nMediators. The Observer pattern promotes partitioning and loose coupling between\nObserver and Subject, and that leads to finer-grained classes that are more apt to be \nreused.\nOn the other hand, it's easier to understand the flow of communication in Mediator\nthan in Observer. Observers and subjects are usually connected shortly after they're\ncreated, and it's hard to see how they are connected later in the program. If you know\nthe Observer pattern, then you understand that the way observers and subjects are\nconnected is important, and you also know what connections to look for. \nHowever, the\nindirection that Observer introduces will still make a system harder to understand.\nObservers in Smalltalk can be parameterized with messages to access the Subject state,\nand so they are even more reusable than they are in C++. This makes Observer more\nattractive than Mediator in Smalltalk. Thus a Smalltalk programmer will often use\nObserver where a C++ programmer would use Mediator.\nDecoupling Senders and Receivers\nWhen collaborating objects refer to each other directly, they become dependent on\neach other, and that can have an adverse impact on the layering and reusability of a\n", "page": 366, "type": "text", "section": "Page 366"}
{"text": "DISCUSSION OF BEHAVIORAL PATTERNS \n347\nsystem. Command, Observer, Mediator, and Chain of Responsibility address how you\ncan decouple senders and receivers, but with different trade-offs.\nThe Command pattern supports decoupling by using a Command object to define the\nbinding between a sender and receiver:\nThe Command object provides a simple interface for issuing the request (that is, the\nExecute operation). Defining the sender-receiver connection in a separate object lets\nthe sender work with different receivers. It keeps the sender decoupled from the re-\nceivers, making senders easy to reuse. Moreover, you can reuse the Command object\nto parameterize a receiver with different senders. The Command pattern nominally\nrequires a subclass for each sender-receiver connection, although the pattern describes\nimplementation techniques that avoid subclassing.\nThe Observer pattern decouples senders (subjects) from receivers (observers) \nby defin-\ning an interface for signaling changes in subjects. Observer defines a looser sender-\nreceiver binding than Command, since a subject may have multiple observers, and\ntheir number can vary at run-time.\nThe Subject and Observer interfaces in the Observer pattern are designed for commu-\nnicating changes. Therefore the Observer pattern is best for decoupling objects when\nthere are data dependencies between them.\nThe Mediator pattern decouples objects by having them refer to each other indirectly\nthrough a Mediator object.\n", "page": 367, "type": "text", "section": "Page 367"}
{"text": "348\nBEHAVIORAL PATTERNS\nCHAPTER 5\nA Mediator object routes requests between Colleague objects and centralizes their com-\nmunication. Consequently, colleagues can only talk to each other through the Mediator\ninterface. Because this interface is fixed, the Mediator might have to implement its\nown dispatching scheme for added flexibility. Requests can be encoded and arguments\npacked in such a way that colleagues can request an open-ended set of operations.\nThe Mediator pattern can reduce subclassing in a system, because it centralizes com-\nmunication behavior in one class instead of distributing it among subclasses. However,\nad hoc \ndispatching schemes often decrease type safety.\nFinally, the Chain of Responsibility pattern decouples the sender from the receiver by\npassing the request along a chain of potential receivers:\nSince the interface between senders and receivers is fixed, Chain of Responsibility\nmay also require a custom dispatching scheme. Hence it has the same type-safety\ndrawbacks as Mediator. Chain of Responsibility is a good way to decouple the sender\nand the receiver if the chain is already part of the system's structure, and one of several\nobjects may be in a position to handle the request. Moreover, the pattern offers added\nflexibility in that the chain can be changed or extended easily.\n", "page": 368, "type": "text", "section": "Page 368"}
{"text": "DISCUSSION OF BEHAVIORAL PATTERNS \n349\nSummary\nWith few exceptions, behavioral design patterns complement and reinforce each other.\nA class in a chain of responsibility, for example, will probably include at least one ap-\nplication of Template \nMethod (325). The template method can use primitive operations\nto determine whether the object should handle the request and to choose the object to\nforward to. The chain can use the Command pattern to represent requests as objects.\nInterpreter (243) can use the State pattern to define parsing contexts. An iterator can\ntraverse an aggregate, and a visitor can apply an operation to each element in the\naggregate.\nBehavioral patterns work well with other patterns, too. For example, a system that uses\nthe Composite (163) \npattern might use a visitor to perform operations on components \nof\nthe composition. It could use Chain of Responsibility to let components access global\nproperties through their parent. It could also use Decorator (175) to override these\nproperties on parts of the composition. It could use the Observer pattern to tie one\nobject structure to another and the State pattern to let a component change its behavior\nas its state changes. The composition itself might be created using the approach in\nBuilder (97), and it might be treated as a Prototype (117) by some other part of the\nsystem.\nWell-designed object-oriented systems are just like this\u2014they have multiple patterns\nembedded in them\u2014but not because their designers necessarily thought in these terms.\nComposition at the pattern level rather than the class or object levels lets us achieve the\nsame synergy with greater ease.\n", "page": 369, "type": "text", "section": "Page 369"}
{"text": "This page intentionally left blank \n", "page": 370, "type": "text", "section": "Page 370"}
{"text": "Chapter 6\nConclusion\nIt's possible to argue that this book hasn't accomplished much. After all, it doesn't\npresent any algorithms or programming techniques that haven't been used before.\nIt doesn't give a rigorous method for designing systems, nor does it develop a new\ntheory of design\u2014it just documents existing designs. You \ncould conclude that it makes\na reasonable tutorial, perhaps, but it certainly can't offer much to an experienced object-\noriented designer.\nWe hope you think differently. Cataloging design patterns is important. It gives us\nstandard names and definitions for the techniques we use. If we don't study design\npatterns in software, we won't be able to improve them, and it'll be harder to come up\nwith new ones.\nThis book is only a start. It contains some of the most common design patterns that\nexpert object-oriented designers use, and yet people hear and learn about them solely\nby word of mouth or by studying existing systems. Early drafts of the book prompted\nother people to write down the design patterns they use, and it should prompt even\nmore in its current form. We hope this will mark the start of a movement to document\nthe expertise of software practitioners.\nThis chapter discusses the impact we think design patterns will have, how they are\nrelated to other work in design, and how you can get involved in finding and cataloging\npatterns.\n6.1 What to Expect from Design Patterns\nHere are several ways in which the design patterns in this book can affect the way you\ndesign object-oriented software, based on our day-to-day experience with them.\n351\n", "page": 371, "type": "text", "section": "Page 371"}
{"text": "352 \nCONCLUSION \nCHAPTER 6\nA Common Design Vocabulary\nStudies of expert programmers for conventional languages have shown that knowledge\nand experience isn't organized simply around syntax but in larger conceptual structures\nsuch as algorithms, data structures and idioms [AS85, Cop92, Cur89, SS86], and plans\nfor fulfilling a particular goal [SE84]. Designers probably don't think about the notation\nthey're using for recording the design as much as they try to match the current design\nsituation against plans, algorithms, data structures, and idioms they have learned in\nthe past.\nComputer scientists name and catalog algorithms and data structures, but we don't\noften name other kinds of patterns. Design patterns provide a common vocabulary for\ndesigners to use to communicate, document, and explore design alternatives. Design\npatterns make a system seem less complex by letting you talk about it at a higher level\nof abstraction than that of a design notation or programming language. Design patterns\nraise the level at which you design and discuss design with your colleagues.\nOnce you've absorbed the design patterns in this book, your design vocabulary will\nalmost certainly change. You will speak directly in terms of the names of the design\npatterns. You'll find yourself saying things like, \"Let's use an Observer here,\" or, \"Let's\nmake a Strategy out of these classes.\"\nA Documentation and Learning Aid\nKnowing the design patterns in this book makes it easier to understand existing sys-\ntems. Most large object-oriented systems use these design patterns. People learning \nobject-oriented programming often complain that the systems they're working with\nuse inheritance in convoluted ways and that it's difficult to follow the flow of control.\nIn large part this is because they do not understand the design patterns in the sys-\ntem. Learning these design patterns will help you understand existing object-oriented\nsystems.\nThese design patterns can also make you a better designer. They provide solutions\nto common problems. If you work with object-oriented systems long enough, you'll\nprobably learn these design patterns on your own. But reading the book will help you\nlearn them much faster. Learning these patterns will help a novice act more like an\nexpert.\nMoreover, describing a system in terms of the design patterns that it uses will make it\na lot easier to understand. Otherwise, people will have to reverse-engineer the design\nto unearth the patterns it uses. Having a common vocabulary means you don't have\nto describe the whole design pattern; you can just name it and expect your reader to\nknow it. A reader who doesn't know the patterns will have to look them up at first, but\nthat's still easier than reverse-engineering.\nWe use these patterns in our own designs, and we've found them invaluable. Yet \nwe\nuse the patterns in arguably naive ways. We use them to pick names for classes, to\n", "page": 372, "type": "text", "section": "Page 372"}
{"text": "SECTION 6.1 \nWHAT TO EXPECT FROM DESIGN PATTERNS \n353\nthink about and teach good design, and to describe designs in terms of the sequence\nof design patterns we applied [BJ94]. It's easy to imagine more sophisticated ways of\nusing patterns, such as pattern-based CASE tools or hypertext documents. But patterns\nare a big help even without sophisticated tools.\nAn Adjunct to Existing Methods\nObject-oriented design methods are supposed to promote good design, to teach new\ndesigners how to design well, and to standardize the way designs are developed. A\ndesign method typically defines a set of notations (usually graphical) for modeling\nvarious aspects of a design, along with a set of rules that govern how and when to use\neach notation. Design methods usually describe problems that occur in a design, how\nto resolve them, and how to evaluate design. But they haven't been able to capture the\nexperience of expert designers.\nWe believe our design patterns are an important piece that's been missing from object-\noriented design methods. The design patterns show how to use primitive techniques\nsuch as objects, inheritance, and polymorphism. They show how to parameterize a \nsystem with an algorithm, a behavior, a state, or the kind of objects it's supposed to\ncreate. Design patterns provide a way to describe more of the \"why\" of a design and\nnot just record the results of your decisions. The Applicability, Consequences, and\nImplementation sections of the design patterns help guide you in the decisions you\nhave to make.\nDesign patterns are especially useful in turning an analysis model into an implementa-\ntion model. Despite many claims that promise a smooth transition from object-oriented\nanalysis to design, in practice the transition is anything but smooth. A flexible and \nreusable design will contain objects that aren't in the analysis model. The program-\nming language and class libraries you use affect the design. Analysis models often\nmust be redesigned to make them reusable. Many of the design patterns in the catalog\naddress these issues, which is why we call them design patterns.\nA full-fledged design method requires more kinds of patterns than just design patterns.\nThere can also be analysis patterns, user interface design patterns, or performance-\ntuning patterns. But the design patterns are an essential part, one that's been missing\nuntil now.\nA Target for Refactoring\nOne of the problems in developing reusable software is that it often has to be reorga-\nnized or refactored [OJ90]. Design patterns help you determine how to reorganize a\ndesign, and they can reduce the amount of refactoring you need to do later.\nThe lifecycle of object-oriented software has several phases. Brian Foote identifies these\nphases as the prototyping, expansionary, and consolidating phases [Foo92].\n", "page": 373, "type": "text", "section": "Page 373"}
{"text": "354 \nCONCLUSION \nCHAPTER 6\nThe prototyping phase is a flurry of activity as the software is brought to life through\nrapid prototyping and incremental changes, until it meets an initial set of requirements\nand reaches adolescence. At this point, the software usually consists of class hierarchies\nthat closely reflect entities in the initial problem domain. The main kind of reuse is\nwhite-box reuse by inheritance.\nOnce the software has reached adolescence and is put into service, its evolution is\ngoverned by two conflicting needs: (1) the software must satisfy more requirements,\nand (2) \nthe software must be more reusable. New requirements usually add new classes\nand operations and perhaps whole class hierarchies. The software goes through an \nexpansionary phase to meet new requirements. This can't continue for long, however.\nEventually the software will become too inflexible and arthritic for further change.\nThe class hierarchies will no longer match any problem domain. Instead they'll reflect\nmany problem domains, and classes will define many unrelated operations and instance\nvariables.\nTo continue to evolve, the software must be reorganized in a process known as refactor-\ning. This is the phase in which frameworks often emerge. Refactoring involves tearing\napart classes into special- and general-purpose components, moving operations up or\ndown the class hierarchy, and rationalizing the interfaces of classes. This consolidation\nphase produces many new kinds of objects, often by decomposing existing objects\nand using object composition instead of inheritance. Hence black-box reuse replaces\nwhite-box reuse. The continual need to satisfy more requirements along with the need\nfor more reuse propels object-oriented software through repeated phases of expansion\nand consolidation\u2014expansion as new requirements are satisfied, and consolidation as\nthe software becomes more general.\nThis cycle is unavoidable. But good designers are aware of the changes that can prompt\nrefactorings. Good designers also know class and object structures that can help avoid\nrefactorings\u2014their designs are robust in the face of requirement changes. A thorough\nrequirements analysis will highlight those requirements that are likely to change during\nthe life of the software, and a good design will be robust to them.\nOur design patterns capture many of the structures that result from refactoring. Using\nthese patterns early in the life of a design prevents later refactorings. But even if you\n", "page": 374, "type": "text", "section": "Page 374"}
{"text": "SECTION 62 \nA BRIEF HISTORY \n355\ndon't see \nhow to apply a pattern until after you've \nbuilt your system, \nthe pattern can \nstill\nshow you how to change it. Design patterns thus provide targets for your refactorings.\n6.2 A Brief History\nThe catalog began as a part of Erich's Ph.D. thesis [Gam91, Gam92]. Roughly half of\nthe current patterns were in his thesis. By \nOOPSLA '91 it was officially an independent\ncatalog, and Richard had joined Erich to work on it. John started working on it soon\nthereafter. By \nOOPSLA '92, Ralph had joined the group. We worked hard to make the\ncatalog fit for publication at ECOOP '93, but soon we realized that a 90-page paper was\nnot going to be accepted. So we summarized the catalog and submitted the summary,\nwhich was accepted. We \ndecided to turn the catalog into a book shortly thereafter.\nOur names for the patterns have changed a little along the way. \"Wrapper\" became\n\"Decorator,\" \"Glue\" became \"Facade,\" \"Solitaire\" became \"Singleton,\" and \"Walker\"\nbecame \"Visitor.\" A couple of patterns got dropped because they didn't seem important\nenough. But otherwise the set of patterns in the catalog has changed little since the end\nof 1992. The patterns themselves, however, have evolved tremendously.\nIn fact, noticing that something is a pattern is the easy part. All four of us are actively\nworking on building object-oriented systems, and we've found that it's easy to spot\npatterns when you look at enough systems. But finding patterns is much easier than\ndescribing them.\nIf you build systems and then reflect on what you build, you will see patterns in what\nyou do. But it's hard to describe patterns so that people who don't know them will\nunderstand them and realize why they are important. Experts \nimmediately recognized \nthe value of the catalog in its early stages. But the only ones who could understand the\npatterns were those who had already used them.\nSince one of the main purposes of the book was to teach object-oriented design to new\ndesigners, we knew we had to improve the catalog. We expanded the average size of\na pattern from less than 2 to more than 10 pages by including a detailed motivating\nexample and sample code. We also started examining the trade-offs and the various\nways of implementing the pattern. This made the patterns easier to learn.\nAnother important change over the past year has been a greater emphasis on the\nproblem that a pattern solves. It's easiest to see a pattern as a solution, as a technique\nthat can be adapted and reused. It's harder to see when it is appropriate\u2014to characterize\nthe problems it solves and the context in which it's the best solution. In general, it's\neasier to see what someone is doing than to know why, \nand the \"why\" for a pattern is the\nproblem it solves. Knowing the purpose of a pattern is important too, because it helps\nus choose patterns to apply. It also helps us understand the design of existing systems.\nA pattern author must determine and characterize the problem that the pattern solves,\neven if you have to do it after you've discovered its solution.\n", "page": 375, "type": "text", "section": "Page 375"}
{"text": "356 \nCONCLUSION \nCHAPTER 6\n6.3 The Pattern Community\nWe aren't the only ones interested in writing books that catalog the patterns experts\nuse. We \nare a part of a larger community interested in patterns in general and software-\nrelated patterns in particular. Christopher Alexander is the architect who first studied\npatterns in buildings and communities and developed a \"pattern language\" for gener-\nating them. His work has inspired us time and again. So it's fitting and worthwhile to\ncompare our work to his. Then we'll look at others' work in software-related patterns.\nAlexander's Pattern Languages\nThere are many ways in which our work is like Alexander's. Both are based on ob-\nserving existing systems and looking for patterns in them. Both have templates for\ndescribing patterns (although our templates are quite different). Both rely on natural\nlanguage and lots of examples to describe patterns rather than formal languages, and\nboth give rationales for each pattern.\nBut there are just as many ways in which our works are different:\n1. People have been making buildings for thousands of years, and there are many\nclassic examples to draw upon. We have been making software systems for a\nrelatively short time, and few are considered classics.\n2. Alexander gives an order in which his patterns should be used; we have not.\n3. Alexander's patterns emphasize the problems they address, whereas design pat-\nterns describe the solutions in more detail.\n4. Alexander claims his patterns will generate complete buildings. We \ndo not claim\nthat our patterns will generate complete programs.\nWhen Alexander claims you can design a house simply by applying his patterns one\nafter another, he has goals similar to those of object-oriented design methodologists who\ngive step-by-step rules for design. Alexander doesn't deny the need for creativity; some\nof his patterns require understanding the living habits of the people who will use the\nbuilding, and his belief in the \"poetry\" of design implies a level of expertise beyond the\npattern language itself.1 But his description of how patterns generate designs implies\nthat a pattern language can make the design process deterministic and repeatable.\nThe Alexandrian point of view has helped us focus on design trade-offs\u2014the different\n\"forces\" that help shape a design. His influence made us work harder to understand\nthe applicability and consequences of our patterns. It also kept us from worrying about\ndefining a formal representation of patterns. Although such a representation might\nmake automating patterns possible, at this stage it's more important to explore the \nspace of design patterns than to formalize it.\n1 \nSee \"The poetry of the language\" [AIS+ 77].\n", "page": 376, "type": "text", "section": "Page 376"}
{"text": "SECTION 6.3 \nTHE PATTERN COMMUNITY \n357\nFrom Alexander's point of view, the patterns in this book do not form a pattern lan-\nguage. Given the variety of software systems that people build, it's hard to see how\nwe could provide a \"complete\" set of patterns, one that offers step-by-step instructions\nfor designing an application. We can do that for certain classes of applications, such as\nreport-writing or making a forms-entry system. But our catalog is just a collection \nof\nrelated patterns; we can't pretend it's a pattern language.\nIn fact, we think it's unlikely that there will ever be a complete pattern language for\nsoftware. But it's certainly possible to make one that is more complete. Additions would\nhave to include frameworks and how to use them [Joh92], patterns for user interface de-\nsign [BJ94], analysis patterns [Coa921, and all the other aspects of developing software.\nDesign patterns are just a part of a larger pattern language for software.\nPatterns in Software\nOur first collective experience in the study of software architecture was at an\nOOPSLA '91 workshop led by Bruce Anderson. The workshop was dedicated to de-\nveloping a handbook for software architects. (Judging from this book, we suspect\n\"architecture encyclopedia\" will be a more appropriate name than \"architecture hand-\nbook.\") That first workshop has led to a series of meetings, the most recent of which\nbeing the first conference on Pattern Languages of Programs held in August 1994. \nThis\nhas created a community of people interested in documenting software expertise.\nOf course, others have had this goal as well. Donald Knuth's The Art of Computer Pro-\ngramming [Knu73] was one of the first attempts to catalog software knowledge, though\nhe focused on describing algorithms. Even so, the task proved too great to finish. The\nGraphics Gems series [Gla90, Arv91, Kir92] is another catalog of design knowledge, \nthough it too tends to focus on algorithms. The Domain Specific Software Architecture\nprogram sponsored by the U.S. Department of Defense [GM92] concentrates on gather-\ning architectural information. The knowledge-based software engineering community\ntries to represent software-related knowledge in general. There are many other groups\nwith goals at least a little like ours.\nJames Coplien's Advanced C++: Programming Styles and Idioms [Cop92] has influenced\nus, too. The patterns in his book tend to be more C++-specific than our design patterns,\nand his book contains lots of lower-level patterns as well. But there is some overlap,\nas we point out in our patterns. Jim has been active in the pattern community. He's\ncurrently working on patterns that describe people's roles in software development\norganizations.\nThere are a lot of other places in which to find descriptions of patterns. Kent Beck was\none of the first people in the software community to advocate Christopher Alexander's\nwork. In 1993 he started writing a column in The Smalltalk Report on Smalltalk patterns.\nPeter Coad has also been collecting patterns for some time. His paper on patterns seems \nto us to contain mostly analysis patterns [Coa92]; we haven't seen his latest patterns,\nthough we know he is still working on them. We've heard of several books on patterns\n", "page": 377, "type": "text", "section": "Page 377"}
{"text": "358 \nCONCLUSION \nCHAPTER 6\nthat are in the works, but we haven't seen any of them, either. All we can do is let\nyou know they're coming. One of these books will be from the Pattern Languages of\nPrograms conference.\n6.4 An Invitation\nWhat can you do if you are interested in patterns? First, use them and look for other\npatterns that fit the way you design. A lot of books and articles about patterns will be\ncoming out in the next few years, so there will be plenty of sources for new patterns.\nDevelop your vocabulary of patterns, and use it. Use it when you talk with other people\nabout your designs. Use it when you think and write about them.\nSecond, be a critical consumer. The design pattern catalog is the result of hard work, not\njust ours but that of dozens of reviewers who gave us feedback. If you spot a problem\nor believe more explanation is needed, contact us. The same goes for any other catalog\nof patterns: Give the authors feedback! One of the great things about patterns is that\nthey move design decisions out of the realm of vague intuition. They let authors be\nexplicit about the trade-offs they make. This makes it easier to see what is wrong with\ntheir patterns and to argue with them. Take advantage of that.\nThird, look for patterns you use, and write them down. Make them a part of your\ndocumentation. Show them to other people. You \ndon't have to be in a research lab to\nfind patterns. In fact, finding relevant patterns is nearly impossible if you don't have \npractical experience. Feel free to write your own catalog of patterns...but make sure\nsomeone else helps you beat them into shape!\n6.5 A Parting Thought\nThe best designs will use many design patterns that dovetail and intertwine to produce\na greater whole. As Christopher Alexander says:\nIt is possible to make buildings by stringing together patterns, in a rather\nloose way. A building made like this, is an assembly of patterns. It is not\ndense. It is not profound. But it is also possible to put patterns together\nin such a way that many patterns overlap in the same physical space: the\nbuilding is very dense; it has many meanings captured in a small space; and\nthrough this density, it becomes profound.\nA Pattern Language [AIS+77, page xli]\n", "page": 378, "type": "text", "section": "Page 378"}
{"text": "Appendix A\nGlossary\nabstract class A class whose primary purpose is to define an interface. An abstract\nclass defers some or all of its implementation to subclasses. An abstract class\ncannot be instantiated.\nabstract coupling Given a class A that maintains a reference to an abstract class B,\nclass A is said to be abstractly coupled to B. We call this abstract coupling because\nA refers to a type of object, not a concrete object.\nabstract operation An operation that declares a signature but doesn't implement it. In\nC++, an abstract operation corresponds to a pure virtual member function.\nacquaintance relationship A class that refers to another class has an acquaintance with\nthat class.\naggregate object An object that's composed of subobjects. The subobjects are called\nthe aggregate's parts, and the aggregate is responsible for them.\naggregation relationship The relationship of an aggregate object to its parts. A class\ndefines this relationship for its instances (e.g., aggregate objects).\nblack-box reuse A style of reuse based on object composition. Composed objects reveal\nno internal details to each other and are thus analogous to \"black boxes.\"\nclass A class defines an object's interface and implementation. It specifies the object's\ninternal representation and defines the operations the object can perform.\nclass diagram A diagram that depicts classes, their internal structure and operations,\nand the static relationships between them.\nclass operation An operation targeted to a class and not to an individual object. In \nC++, class operations are are called static member functions.\nconcrete class A class having no abstract operations. It can be instantiated.\n359\n", "page": 379, "type": "text", "section": "Page 379"}
{"text": "360 \nGLOSSARY \nAPPENDIX A\nconstructor In C++, an operation that is automatically invoked to initialize new in-\nstances.\ncoupling The degree to which software components depend on each other.\ndelegation An implementation mechanism in which an object forwards or delegates a\nrequest to another object. The delegate carries out the request on behalf of the\noriginal object.\ndesign pattern A design pattern systematically \nnames, motivates, and explains a gen-\neral design that addresses a recurring design problem in object-oriented systems.\nIt describes the problem, the solution, when to apply the solution, and its con-\nsequences. It also gives implementation hints and examples. The solution is a\ngeneral arrangement of objects and classes that solve the problem. The solution\nis customized and implemented to solve the problem in a particular context.\ndestructor In C++, \nan operation that is automatically \ninvoked to finalize an object that\nis about to be deleted.\ndynamic binding The run-time association of a request to an object and one of its\noperations. In C++, \nonly virtual functions are dynamically bound.\nencapsulation The result of hiding a representation and implementation in an object.\nThe representation is not visible and cannot be accessed directly from outside the\nobject. Operations are the only way to access and modify an object's representa-\ntion.\nframework A set of cooperating classes that makes up a reusable design for a specific\nclass of software. A framework provides architectural guidance by partitioning\nthe design into abstract classes and defining their responsibilities and collabo-\nrations. A developer customizes the framework to a particular application by \nsubclassing and composing instances of framework classes.\nfriend class In C++, \na class that has the same access rights to the operations and data\nof a class as that class itself.\ninheritance A \nrelationship that defines one entity in terms of another. Class inheritance\ndefines a new class in terms of one or more parent classes. The new class inherits its\ninterface and implementation from its parents. The new class is called a subclass\nor (in C++) a derived class. Class inheritance combines interface inheritance\nand implementation inheritance. Interface inheritance defines a new interface\nin terms of one or more existing interfaces. \nImplementation inheritance defines a\nnew implementation in terms of one or more existing implementations.\ninstance variable A piece of data that defines part of an object's representation. C++\nuses the term data member.\ninteraction diagram A diagram that shows the flow of requests between objects.\n", "page": 380, "type": "text", "section": "Page 380"}
{"text": "361\ninterface The set of all signatures defined by an object's operations. The interface\ndescribes the set of requests to which an object can respond.\nmetaclass Classes are objects in Smalltalk. A metaclass is the class of a class object.\nmixin class A class designed to be combined with other classes through inheritance. \nMixin classes are usually abstract.\nobject A run-time entity that packages both data and the procedures that operate on\nthat data.\nobject composition Assembling or composing objects to get more complex behavior.\nobject diagram A diagram that depicts a particular object structure at run-time.\nobject reference A value that identifies another object.\noperation An object's data can be manipulated only by its operations. An object per-\nforms an operation when it receives a request. In C++, operations are called\nmember functions. Smalltalk uses the term method.\noverriding Redefining an operation (inherited from a parent class) in a subclass.\nparameterized type A type that leaves some constituent types unspecified. The un-\nspecified types are supplied as parameters at the point of use. In C++, parame-\nterized types are called templates.\nparent class The class from which another class inherits. Synonyms are superclass\n(Smalltalk), base class (C++), and ancestor class.\npolymorphism The ability to substitute objects of matching interface for one another\nat run-time.\nprivate inheritance In C++, \na class inherited solely for its implementation.\nprotocol Extends the concept of an interface to include the allowable sequences of\nrequests.\nreceiver The target object of a request.\nrequest An object performs an operation when it receives a corresponding request\nfrom another object. A common synonym for request is message.\nsignature An operation's signature defines its name, parameters, and return value.\nsubclass A class that inherits from another class. In C++, a subclass is called a derived\nclass.\nsubsystem An independent group of classes that collaborate to fulfill a set of respon-\nsibilities.\n", "page": 381, "type": "text", "section": "Page 381"}
{"text": "362 \nGLOSSARY \nAPPENDIX A\nsubtype A type is a subtype of another if its interface contains the interface of the other\ntype.\nsupertype The parent type from which a type inherits.\ntoolkit A collection of classes that provides useful functionality but does not define\nthe design of an application.\ntype The name of a particular interface.\nwhite-box reuse A style of reuse based on class inheritance. A subclass reuses the in-\nterface and implementation of its parent class, but it may have access to otherwise\nprivate aspects of its parent.\n", "page": 382, "type": "text", "section": "Page 382"}
{"text": "Appendix B\nGuide to \nNotation\nWe use diagrams throughout the book to illustrate important ideas. Some diagrams are\ninformal, like a screen shot of a dialog box or a schematic showing a tree of objects.\nBut the design patterns in particular use more formal notations to denote relationships\nand interactions between classes and objects. This appendix describes these notations\nin detail.\nWe use three different diagrammatic notations:\n1. A class diagram depicts classes, their structure, and the static relationships be-\ntween them.\n2. An object diagram \ndepicts a particular object structure at run-time.\n3. An interaction diagram shows the flow of requests between objects.\nEach design pattern includes at least one class diagram. The other notations are used\nas needed to supplement the discussion. The class and object diagrams are based on\nOMT (Object Modeling Technique) [RBP+91, Rum941.1 The interaction diagrams are\ntaken from Objectory [JCJO92] and the Booch method [Boo94]. These notations are\nsummarized on the inside back cover of the book.\nB.I Class \nDiagram\nFigure B.I \na shows the OMT \nnotation for abstract and concrete classes. A class is denoted\nby a box with the class name in bold type at the top. The key operations of the class\nappear below the class name. Any instance variables appear below the operations.\n1 OMT \nuses the term \"object diagram\" to refer to class diagrams. We \nuse \"object diagram\" exclusively to\nrefer to diagrams of object structures.\n363\n", "page": 383, "type": "text", "section": "Page 383"}
{"text": "364 \nGUIDE TO NOTATION \nAPPENDIX B\nType information is optional; we use the C++ convention, which puts the type name\nbefore the name of the operation (to signify the return type), instance variable, or actual\nparameter. Slanted type indicates that the class or operation is abstract.\nIn some design patterns it's helpful to see where client classes reference Participant\nclasses. When a pattern includes a Client class as one of its participants (meaning\nthe client has a responsibility in the pattern), the Client appears as an ordinary class.\nThis is true in Flyweight (195), for example. When the pattern does not include a\nClient participant (i.e., clients have no responsibilities in the pattern), but including it\nnevertheless clarifies which pattern participants interact with clients, then the Client\nclass is shown in gray, as shown in Figure B.lb. An example is Proxy (207). A gray Client\nalso makes it clear that we haven't accidentally omitted the Client from the Participants\ndiscussion.\nFigure B.lc shows various relationships between classes. The OMT notation for class\ninheritance is a triangle connecting a subclass (LineShape in the figure) to its parent\nclass (Shape). An object reference representing a part-of or aggregation relationship is\nindicated by an arrowheaded line with a diamond at the base. The arrow points to\nthe class that is aggregated (e.g., Shape). An arrowheaded line without the diamond\ndenotes acquaintance (e.g., a LineShape keeps a reference to a Color object, which other\nshapes may share). A name for the reference may appear near the base to distinguish\nit from other references.2\nAnother useful thing to show is which classes instantiate which others. We use a\ndashed arrowheaded line to indicate this, since OMT \ndoesn't support it. We \ncall this the \n\"creates\" relationship. The arrow points to the class that's instantiated. In Figure B.lc,\nCreationTool creates LineShape objects.\nOMT also defines a filled circle to mean \"more than one.\" When the circle appears at\nthe head of a reference, it means multiple objects are being referenced or aggregated.\nFigure B.lc shows that Drawing aggregates multiple objects of type Shape.\nFinally, we've augmented OMT with pseudocode annotations to let us sketch the im-\nplementations of operations. Figure B.ld shows the pseudocode annotation for the\nDraw operation on the Drawing class.\nB.2 Object Diagram\nAn object diagram shows instances exclusively. It provides a snapshot of the objects in a\ndesign pattern. The objects are named \"aSomething\", where Something is the class of the\nobject. Our symbol for an object (modified slightly from standard OMT) is a rounded\n2 OMT \nalso defines associations between classes, which appear as plain lines between class \nboxes. Associ-\nations are bidirectional. Although associations are appropriate \nduring analysis, we feel they're too high-level \nfor expressing the relationships in design patterns, simply because associations must be mapped down to\nobject references or pointers during design. Object references are intrinsically directed and are therefore\nbetter suited to the relationships that concern us. For example, Drawing knows about Shapes, but the Shapes\ndon't know about the Drawing they're in. You can't express this relationship with associations alone.\n", "page": 384, "type": "text", "section": "Page 384"}
{"text": "SECTION B.2\nOBJECT DIAGRAM \n365\nFigure B.1: Class diagram notation\n", "page": 385, "type": "text", "section": "Page 385"}
{"text": "366 \nGUIDE TO NOTATION\nAPPENDIX B\nbox with a line separating the object name from any object references. Arrows indicate\nthe object referenced. Figure B.2 \nshows an example.\nB.3 Interaction Diagram\nAn interaction diagram shows the order in which requests between objects \nget executed.\nFigure B.3 is an interaction diagram that shows how a shape gets added to a drawing.\nTime flows from top to bottom in an interaction diagram. A solid vertical line indicates\nthe lifetime of a particular object. The naming convention for objects is the same as for\nobject diagrams\u2014the class name prefixed by the letter \"a\" (e.g., aShape). If the object\ndoesn't get instantiated until after the beginning of time as recorded in the diagram,\nthen its vertical line appears dashed until the point of creation.\nA vertical rectangle shows that an object is active; that is, it is handling a request. The\noperation can send requests to other objects; \nthese are indicated with a horizontal arrow\npointing to the receiving object. The name of the request is shown above the arrow. A\nrequest to create an object is shown with a dashed arrowheaded line. A request to the\nsending object itself points back to the sender.\nFigure B.3: Interaction diagram notation\n", "page": 386, "type": "text", "section": "Page 386"}
{"text": "SECTION B.3 \nINTERACTION DIAGRAM \n367\nFigure B.3 shows that the first request is from aCreationTool to create aLineShape. Later,\naLineShape is Added to aDrawing, which prompts aDrawing to send a Refresh request\nto itself. Note that aDrawing sends a Draw request to aLineShape as part of the Refresh\noperation.\n", "page": 387, "type": "text", "section": "Page 387"}
{"text": "This page intentionally left blank \n", "page": 388, "type": "text", "section": "Page 388"}
{"text": "Appendix C\nFoundation Classes\nThis appendix documents the foundation classes we use in the C++ sample code of\nseveral design patterns. We've intentionally kept the classes simple and minimal. \nWe\ndescribe the following classes:\n\u2022 List, an ordered list of objects.\n\u2022 Iterator, the interface for accessing an aggregate's objects in a sequence.\n\u2022 List Iterator, an iterator for traversing a List.\n\u2022 Point, a two-dimensional point.\n\u2022 Rect, an axis-aligned rectangle.\nSome newer C++ standard types may not be available on all compilers. In particular, \nif\nyour compiler doesn't define bool, then define it manually as\ntypedef int bool;\nconst int true = 1; \nconst int false = 0;\nC.1 List\nThe List class template provides a basic container for storing an ordered list of objects.\nList stores elements by value, which means it works for built-in types as well as class \ninstances. For example, Li st<int> declares a list of ints. But \nmost of the patterns use\nL \ni \ns \nt to store pointers to objects, as \nin L \ni s \nt < G \nlyph * >. That way List can be used for\nheterogeneous lists.\n369\n", "page": 389, "type": "text", "section": "Page 389"}
{"text": "370 \nFOUNDATION CLASSES \nAPPENDIX C\nFor convenience, List also provides synonyms for stack operations, which make code\nthat uses List for stacks more explicit without defining another class.\ntemplate <class Item>\nclass List { \npublic:\nList(long size = DEFAULT_LIST_CAPACITY);\nList(List&); \n~ L i s t ( ) ;\nList& operator=(const List&);\nlong Count() const;\nItem& Get(long index) const;\nItem& First() const;\nItem& Last() const; \nbool Includes(const Item&) const;\nvoid Append(const Item&);\nvoid Prepend(const Item&);\nvoid Remove(const Item&);\nvoid RemoveLast() ; \nvoid RemoveFirst() ; \nvoid RemoveAll();\nItem& Top() const; \nvoid Push(const Item&); \nItem& Pop();\n};\nThe following \nsections describe these operations in greater detail.\nConstruction, Destruction, Initialization, and Assignment\nList(long size) \ninitializes the list. The size parameter is a hint for the initial number of elements.\nList(List&) \noverrides the default copy constructor so that member data are initialized prop-\nerly.\n~ L i s t ( )\nfrees the list's internal data structures but not the elements in the list. The class is\nnot designed for subclassing; therefore the destructor isn't virtual.\nList& operator^(const List&) \nimplements the assignment operation to assign member data properly.\n", "page": 390, "type": "text", "section": "Page 390"}
{"text": "SECTION C.I \nLIST \n371\nAccessing\nThese operations provide basic access to the list's elements.\nlong Count() const\nreturns the number of objects in the list.\nItemSc Get \n(long index) const\nreturns the object at the given index.\nItem& First() const \nreturns the first object in the list.\nItem& Last() const \nreturns the last object in the list.\nAdding\nvoid Append(const Item&) \nadds the argument to the list, making it the last element.\nvoid Prepend(const Item&) \nadds the argument to the list, making it the first element.\nRemoving\nvoid Remove(const Item&) \nremoves the given element from the list. This operation requires that the type of\nelements in the list supports the == operator for comparison.\nvoid RemoveFirst() \nremoves the first element from the list.\nvoid RemoveLast() \nremoves the last element from the list.\nvoid RemoveAll()\nremoves all elements from the list.\n", "page": 391, "type": "text", "section": "Page 391"}
{"text": "372 \nFOUNDATION CLASSES \nAPPENDIX C\nStack Interface\nItem& Top() const \nreturns the top element (when the List is viewed as a stack).\nvoid Push(const Item&) \npushes the element onto the stack.\nItem& Pop() \npops the top element from the stack.\nC.2 Iterator\nIterator is an abstract class that defines a traversal interface for aggregates.\ntemplate <class Item>\nclass Iterator {\npublic:\nvirtual void First() - 0; \nvirtual void Next() = 0; \nvirtual bool IsDoneO const = 0;\nvirtual Item Currentltem() const = 0;\nprotected:\nIterator();\n};\nThe operations do the following:\nvirtual void First() \npositions the iterator to the first object in the aggregate.\nvirtual void Next() \npositions the iterator to the next object in the sequence.\nvirtual bool IsDone() const \nreturns true when there are no more objects in the sequence.\nvirtual Item Currentltem() const \nreturns the object at the current position in the sequence.\nC.3 Listlterator\nListlterator implements the Iterator interface to traverse List objects. Its con-\nstructor takes a list to traverse as an argument.\n", "page": 392, "type": "text", "section": "Page 392"}
{"text": "SECTION \nCA\nPOINT\n373\ntemplate <class Item> \nclass Listlterator : \npublic Iterators \nItem> {\npublic:\nListlterator(const List<Item>* aList);\nvirtual void First(); \nvirtual void Next(); \nvirtual bool IsDone() const;\nvirtual Item Currentltem() const;\nC.4 Point\nPoint represents \na \npoint \nin \na \ntwo-dimensional \nCartesian coordinate space. \nPoint\nsupports \nsome \nminimal \nvector \narithmetic. \nThe \ncoordinates \nof \na \nPoint \nare \ndefined \nas\ntypedef float Coord;\nPoint's \noperations \nare \nself-explanatory.\nclass Point {\npublic:\nstatic const Point Zero;\nPoint(Coord x = 0.0, Coord y = 0.0);\nCoord X() const; void X(Coord x) ;\nCoord Y() const; void Y(Coord y) ;\nfriend Point operator+(const Point&, const Point&);\nfriend Point operator-(const Point&, const Point&); \nfriend Point operator*(const Point&, const Point&);\nfriend Point operator/(const Point&, const Point&);\nPoint& operator+=(const Point&);\nPoint& operator-=(const Point&);\nPoint& operator*=(const Point&);\nPoint& operator/^(const Point&);\nPoint operator-();\nfriend bool operator==(const Point&, const Point&);\nfriend bool operator!=(const Point&, const Point&);\nfriend ostream& operator\u00ab(ostream&, const Point&);\nfriend istream& operator\u00bb \n(istream&, Point&) ;\nThe static \nmember \nZero \nrepresents \nPoint \n(0, 0).\n", "page": 393, "type": "text", "section": "Page 393"}
{"text": "374 \nFOUNDATION CLASSES \nAPPENDIX C\nC5 Rect\nRect \nrepresents an \naxis-aligned \nrectangle. \nA Rect \nis \ndefined by \nan \norigin \npoint and\nan \nextent \n(that \nis, \nwidth \nand height). \nThe Rect \noperations \nare \nself-explanatory.\nclass Rect {\npublic:\nstatic const Rect Zero;\nRect(Coord x, Coord y, Coord w, Coord h);\nRect(const Point& origin, const Point& extent);\nCoord Width() const;\nvoid Width(Coord);\nCoord Height() const;\nvoid Height(Coord);\nCoord Left() const;\nvoid Left(Coord);\nCoord Bottom() const;\nvoid Bottom(Coord);\nPoint& Origin() const; void Origin(const Point&);\nPoint& Extent() const; void Extent(const Point&);\nvoid MoveTo(const Point&);\nvoid MoveBy(const Point&);\nbool IsEmptyO const; \nbool Contains(const Point&) const;\n};\nThe static \nmember \nZero \nis \nequivalent \nto \nthe \nrectangle\nRect(Point(0, 0), Point(0, 0));\n", "page": 394, "type": "text", "section": "Page 394"}
{"text": "Bibliography\n[Add94] Addison-Wesley, Reading, MA. NEXTSTEP General Reference: Release 3, \nVolumes 1 and 2,1994.\n[AG90] D.B. Anderson and S. Gossain. Hierarchy evolution and the software\nlifecycle. In TOOLS '90 Conference Proceedings, pages 41-50, Paris, June\n1990. Prentice Hall.\n[AIS+ 771 Christopher Alexander, \nSara Ishikawa, Murray Silverstein, Max Jacobson,\nIngrid Fiksdahl-King, and Shlomo Angel. A Pattern Language. Oxford\nUniversity Press, New York, 1977.\n[App891 Apple Computer, Inc., Cupertino, CA. Macintosh Programmers Workshop \nPascal 3.0 Reference, 1989.\n[App921 Apple Computer, Inc., Cupertino, CA. Dylan. An object-oriented dynamic\nlanguage, 1992.\n[Arv911 James Arvo. Graphics Gems II. Academic Press, Boston, MA, 1991.\n[AS851 B. Adelson and E. Soloway. The role of domain experience in software\ndesign. IEEE Transactions on Software Engineering, 11(11):1351-1360,1985.\n[BE931 Andreas Birrer and Thomas Eggenschwiler. Frameworks in the financial\nengineering domain: An experience report. In European Conference on\nObject-Oriented Programming, pages 21-35, Kaiserslautern, Germany, \nJuly\n1993. Springer-Verlag.\n[BJ94] Kent Beck and Ralph \nJohnson. Patterns generate architectures. In European\nConference on Object-Oriented Programming, pages 139-149, Bologna, Italy,\nJuly 1994. Springer-Verlag.\n[Boo94] Grady Booch. Object-Oriented Analysis and Design with Applications. Ben-\njamin/Cummings, Redwood City, CA, 1994. Second Edition.\n[BorSl] A. Borning. \nThe programming language aspects of ThingLab\u2014a\nconstraint-oriented simulation laboratory. ACM Transactions on Program-\nming Languages and Systems, 3(4):343-387, October 1981.\n375\n", "page": 395, "type": "text", "section": "Page 395"}
{"text": "376 \nBIBLIOGRAPHY\n[Bor94] Borland International, Inc., Scotts Valley, CA. A Technical Comparison of \nBorland ObjectWindows 2.0 and Microsoft MFC 2.5,1994.\n[BV90] Grady Booch and Michael Vilot. The design of the C++ Booch compo-\nnents. In Object-Oriented Programming Systems, Languages, and Applications\nConference Proceedings, pages 1-11, Ottawa, Canada, October 1990. ACM\nPress.\n[Cal93] Paul R. Calder. Building User Interfaces with Lightweight Objects. PhD thesis, \nStanford University, 1993.\n[Car89] J. Carolan. Constructing bullet-proof classes. In Proceedings C++ at Work \n'89. SIGS Publications, 1989.\n[Car92] Tom Cargill. C++ Programming Style. Addison-Wesley, Reading, MA, 1992.\n[CIRM93] Roy H. Campbell, Nayeem Islam, David Raila, and Peter Madeany. De-\nsigning and implementing Choices: An object-oriented system in C++. \nCommunications of the ACM, 36(9):117-126, September 1993.\n[CL901 Paul R. Calder and Mark A. Linton. Glyphs: Flyweight objects for user\ninterfaces. In ACM User Interface Software Technologies Conference, pages\n92-101, Snowbird, UT, October 1990.\n[CL92] Paul R. Calder and Mark A. Linton. The object-oriented implementation\nof a document editor. In Object-Oriented Programming Systems, Languages,\nand Applications Conference Proceedings, pages 154-165, Vancouver, British\nColumbia, Canada, October 1992. ACM Press.\n[Coa921 Peter Coad. Object-oriented patterns. \nCommunications of the ACM, \n35(9):152-159, September 1992.\n[Coo92] William R. Cook. Interfaces and specifications for the Smalltalk-80 col-\nlection classes. In Object-Oriented Programming Systems, Languages, and\nApplications Conference Proceedings, \npages 1-15, Vancouver, \nBritish Colum-\nbia, Canada, October 1992. ACM Press.\n[Cop92] James O. Coplien. Advanced C++ Programming Styles and Idioms. Addison-\nWesley, Reading, MA, 1992.\n[Cur89] Bill Curtis. Cognitive issues in reusing software artifacts. In Ted J. \nBigger-\nstaff and Alan J. Perlis, editors, Software Reusability, Volume II: Applications\nand Experience, pages 269-287. Addison-Wesley, Reading, MA, 1989.\n[dCLF93] Dennis de Champeaux, Doug Lea, and Penelope Faure. Object-Oriented \nSystem Development. Addison-Wesley, Reading, MA, 1993.\n[Deu89] L. Peter Deutsch. Design reuse and frameworks in the Smalltalk-80 sys-\ntem. In Ted J. Biggerstaff and Alan J. Perlis, editors, Software Reusability,\nVolume II: Applications and Experience, \npages \n57-71. \nAddison-Wesley, Read-\ning, MA, 1989.\n", "page": 396, "type": "text", "section": "Page 396"}
{"text": "BIBLIOGRAPHY \n377\n[Ede92] D. R. Edelson. Smart pointers: They're smart, but they're not pointers. In\nProceedings of the 1992 USENIX C++ Conference, pages 1-19, Portland, OR,\nAugust 1992. USENIX Association.\n[EG92] Thomas Eggenschwiler and Erich Gamma. The \nET++SwapsManager:\nUsing object technology in the financial engineering domain. In Object-\nOriented Programming Systems, Languages, and Applications Conference Pro-\nceedings, pages 166-178, Vancouver, British Columbia, Canada, October\n1992. ACM Press.\n[ES90] Margaret A. Ellis and Bjarne Stroustrup. The Annotated C++ Reference \nManual. Addison-Wesley, Reading, MA, 1990.\n[Foo92l Brian Foote. A fractal model of the lifecycles of reusable objects. OOP-\nSLA '92 Workshop on Reuse, October 1992. Vancouver, British Columbia,\nCanada.\n[GA89] S. Gossain and D.B. Anderson. Designing a class hierarchy for domain\nrepresentation and reusability. In TOOLS '89 Conference Proceedings, pages \n201-210, CNIT Paris\u2014La Defense, France, November 1989. Prentice Hall.\n[Gam911 Erich Gamma. Object-Oriented Software Development based on ET++: Design\nPatterns, Class Library, Tools (in German). PhD thesis, University of Zurich\nInstitutfiir Informatik, 1991.\n[Gam92] Erich Gamma. Object-Oriented Software Development based on ET++: Design \nPatterns, Class Library, Tools (in German). Springer-Verlag, Berlin, 1992.\n[Gla90] Andrew Glassner. Graphics Gems. Academic Press, Boston, MA, 1990.\n[GM92] M. Graham and E. Mettala. The Domain-Specific Software Architecture\nProgram. In Proceedings of DARPA Software Technology Conference, \n1992,\npages 204-210, April 1992. Also published in CrossTalk, The Journal of\nDefense Software Engineering, pages 19-21,32, October 1992.\n[GR83] Adele J. Goldberg and David Robson. Smalltalk-80: The Language and Its \nImplementation. Addison-Wesley, Reading, MA, 1983.\n[HHMV92] Richard Helm, Tien Huynh, Kim Marriott, and John Vlissides. An object-\noriented architecture for constraint-based graphical editing. In Proceedings\nof the Third Eurographics Workshop on Object-Oriented Graphics, pages 1-22,\nChampery, Switzerland, October 1992. Also available as IBM Research\nDivision Technical \nReport RC 18524 (79392).\n[HO87] Daniel C. Halbert and Patrick D. O'Brien. Object-oriented development. \nIEEE Software, 4(5):71-79, September 1987.\n[ION94] IONA Technologies, Ltd., Dublin, Ireland. Programmer's Guide for Orbix, \nVersion 1.2,1994.\n", "page": 397, "type": "text", "section": "Page 397"}
{"text": "378 \nBIBLIOGRAPHY\n[JCJO92] Ivar Jacobson, Magnus Christerson, Patrik Jonsson, and Gunnar Over-\ngaard. Object-Oriented Software Engineering\u2014A Use Case Driven Approach.\nAddison-Wesley, Wokingham, England, 1992.\n[JF88] Ralph E. Johnson and Brian Foote. Designing reusable classes. Journal of \nObject-Oriented Programming, l(2):22-35June/July 1988.\n[JML92] Ralph E. Johnson, Carl McConnell, and J. Michael Lake. The RTL system:\nA framework for code optimization. In Robert Giegerich and Susan L.\nGraham, editors, Code Generation\u2014Concepts, Tools, Techniques. \nProceedings\nof the International Workshop on Code Generation, pages 255-274, Dagstuhl,\nGermany, 1992. Springer-Verlag.\n[Joh92] Ralph Johnson. Documenting frameworks using patterns. In Object-\nOriented Programming Systems, Languages, and Applications Conference Pro-\nceedings, pages 63-76, Vancouver, British \nColumbia, Canada, October 1992.\nACM Press.\n[JZ91] Ralph E. Johnson and Jonathan Zweig. Delegation in C++. Journal of \nObject-Oriented Programming, 4(11):22-35, November 1991.\n[Kir92] David Kirk. Graphics Gems III. Harcourt, Brace, Jovanovich, Boston, MA, \n1992.\n[Knu73] Donald E. Knuth. The Art of Computer Programming, Volumes 1, 2, and 3. \nAddison-Wesley, Reading, MA, 1973.\n[Knu84] Donald E. Knuth. The TEXbook. Addison-Wesley, Reading, MA, 1984.\n[Kof93] Thomas Kofler. Robust iterators in ET++. Structured Programming, 14:62-\n85, March 1993.\n[KP88] Glenn E. Krasner and Stephen T. Pope. A cookbook for using the model-\nview controller user interface paradigm in Smalltalk-80. Journal of Object-\nOriented Programming, l(3):26-49, August/September 1988.\n[LaL94] Wilf LaLonde. Discovering Smalltalk. Benjamin/Cummings, Redwood \nCity, CA, 1994.\n[LCI+92] Mark Linton, Paul Calder, John Interrante, Steven Tang, and John Vlis-\nsides. Interviews Reference Manual. CSL, Stanford University, 3.1 edition,\n1992.\n[Lea88] Doug Lea. libg++, \nthe GNU C++ library. In Proceedings of the 1988 USENIX\nC++ Conference, pages 243-256, Denver, CO, October 1988. USENIX Asso-\nciation.\n[LG86] Barbara Liskov and John Guttag. Abstraction and Specification in Program \nDevelopment. McGraw-Hill, New York, 1986.\n", "page": 398, "type": "text", "section": "Page 398"}
{"text": "BIBLIOGRAPHY \n379\n[Lie85] Henry Lieberman. There's more to menu systems than meets the screen.\nIn SIGGRAPH Computer Graphics, pages 181-189, San Francisco, CA, July\n1985.\n[Lie86] Henry Lieberman. Using prototypical objects to implement shared be-\nhavior in object-oriented systems. In Object-Oriented Programming Sys-\ntems, Languages, and Applications Conference Proceedings, pages 214-223,\nPortland, OR, November 1986.\n[Lin92] Mark A. Linton. Encapsulating a C++ library. In Proceedings of the 1992\nUSENIX C++ Conference, pages 57-66, Portland, OR, August 1992. ACM\nPress.\n[LP93] Mark Linton and Chuck Price. Building distributed user interfaces with\nFresco. In Proceedings of the 7th X Technical Conference, pages 77-87, Boston,\nMA, January 1993.\n[LR93] Daniel C. Lynch \nand Marshall T. Rose. Internet System Handbook. Addison-\nWesley, Reading, MA, 1993.\n[LVC89] Mark A. Linton, John M. Vlissides, and Paul R. Calder. Composing user\ninterfaces with Interviews. Computer, 22(2):8-22, February 1989.\n[Mar91] Bruce Martin. The separation of interface and implementation in C++. In\nProceedings of the 1991 USLNIX C++ Conference, pages 51-63, Washington,\nD.C., April 1991. USENIX Association.\n[McC87] Paul McCullough. Transparent forwarding: First steps. In Object-Oriented\nProgramming Systems, Languages, and Applications Conference Proceedings, \npages 331-341, Orlando, FL, October 1987. ACM Press.\n[Mey88] Bertrand Meyer. Object-Oriented Software Construction. Series in Computer \nScience. Prentice Hall, Englewood Cliffs, NJ, 1988.\n[Mur931 Robert B. Murray. C++ Strategies and Tactics. Addison-Wesley, Reading, \nMA, 1993.\n[OJ90] William F. Opdyke and Ralph E. Johnson. Refactoring: An aid in de-\nsigning application frameworks and evolving object-oriented systems. In\nSOOPPA Conference Proceedings, pages 145-161, Marist College, Pough-\nkeepsie, NY, \nSeptember 1990. ACM Press.\n[OJ93] William F. \nOpdyke and Ralph E. Johnson. Creating abstract superclasses\nby refactoring. In Proceedings of the 21st Annual Computer Science Conference\n(ACM CSC '93), pages 66-73, Indianapolis, IN, February 1993.\n[P+88] Andrew J. Palay et al. The Andrew Toolkit: An overview. In Proceedings\nof the 1988 Winter USENIX Technical Conference, pages 9-21, Dallas, TX,\nFebruary 1988. USENIX Association.\n", "page": 399, "type": "text", "section": "Page 399"}
{"text": "380 \nBIBLIOGRAPHY\n[Par90] ParcPlace Systems, Mountain View, CA. ObjectWorks\\Smalltalk Release 4 \nUsers Guide, 1990.\n[Pas86] Geoffrey A. Pascoe. \nEncapsulators: A new software paradigm in\nSmalltalk-80. In Object-Oriented Programming Systems, Languages, and Ap-'\nplications Conference Proceedings, pages 341-346, Portland, OR, October\n1986. ACM Press.\n[Pug90] William Pugh. Skiplists: A probabilistic alternative to balanced trees. \nCommunications of the ACM, 33(6):668-676, June 1990.\n[RBP+91] James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy,\nand William Lorenson. Object-Oriented Modeling and Design. Prentice\nHall, Englewood Cliffs, NJ, 1991.\n[Rum94] James Rumbaugh. The life of an object model: How the object model\nchanges during development. Journal of Object-Oriented Programming,\n7(l):24-32, March/April 1994.\n[SE84] Elliot Soloway and Kate Ehrlich. Empirical studies of programming\nknowledge. IEEE Transactions on Software Engineering, 10(5)595-609, Sep-\ntember 1984.\n[Sha90] Yen-Ping \nShan. MoDE: \nA UIMS for Smalltalk. In ACM OOPSLA/ECOOP\n'90 Conference Proceedings, \npages 258-268, Ottawa, \nOntario, Canada, Octo-\nber 1990. ACM Press.\n[Sny86] Alan Snyder. Encapsulation and inheritance in object-oriented languages.\nIn Object-Oriented Programming Systems, Languages, and Applications Confer-\nence Proceedings, pages 38-45, Portland, OR, November 1986. ACM Press.\n[SS86] James C. Spohrer and Elliot Soloway. Novice mistakes: Are the folk wis-\ndoms correct? Communications of the ACM, 29(7):624-632, July 1986.\n[SS94] Douglas C. Schmidt and Tatsuya Suda. The Service Configurator Frame-\nwork: An extensible architecture for dynamically configuring concurrent,\nmulti-service network daemons. In Proceeding of the Second International\nWorkshop on Configurable Distributed Systems, pages 190-201, Pittsburgh,\nPA, March 1994. IEEE Computer Society.\n[Str91] Bjarne Stroustrup. The C++ Programming Language. Addison-Wesley, \nReading, MA, 1991. Second Edition.\n[Str93] Paul S. Strauss. IRIS Inventor, a 3D graphics toolkit. In Object-Oriented\nProgramming Systems, Languages, and Applications Conference Proceedings,\npages 192-200, Washington, D.C., September 1993. ACM Press.\n[Str94] Bjarne Stroustrup. The Design and Evolution of C++. Addison-Wesley, \nReading, MA, 1994.\n", "page": 400, "type": "text", "section": "Page 400"}
{"text": "BIBLIOGRAPHY \n381\n[Sut63] I.E. Sutherland. Sketchpad: A Man-Machine Graphical Communication Sys-\ntem. PhD thesis, MIT, 1963.\n[Swe85] Richard E. Sweet. The Mesa programming environment. SIGPLAN No-\ntices, 20(7):216-229, July 1985.\n[Sym93a] Symantec Corporation, Cupertino, CA. Bedrock Developer's Architecture \nKit, 1993.\n[Sym93b] Symantec Corporation, Cupertino, CA. THINK Class Library Guide, 1993.\n[Sza92] Duane Szafron. SPECTalk: An object-oriented data specification language.\nIn Technology of Object-Oriented Languages and Systems (TOOLS 8), pages\n123-138, Santa Barbara, CA, August 1992. Prentice Hall.\n[US87] David Ungar and Randall B. Smith. Self: The power of simplicity. In\nObject-Oriented Programming Systems, Languages, and Applications Confer-\nence Proceedings, \npages 227-242, Orlando, FL, October 1987. ACM Press.\n[VL88] John M. Vlissides and Mark A. Linton. Applying object-oriented design\nto structured graphics. In Proceedings of the 1988 USENIX C++ Conference,\npages 81-94, Denver, CO, October 1988. USENIX Association.\n[VL90] John M. Vlissides and Mark A. Linton. Unidraw: A framework for build-\ning domain-specific graphical editors. ACM Transactions on Information\nSystems, 8(3):237-268, July 1990.\n[WBJ90] Rebecca Wirfs-Brock and Ralph E. Johnson. A survey of current research\nin object-oriented design. Communications of the ACM, 33(9): \n104-124,1990.\n[WBWW90] Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener. Designing \nObject-Oriented Software. Prentice Hall, Englewood Cliffs, NJ, 1990.\n[WGM88] Andre Weinand, Erich Gamma, and Rudolf Marty. ET++\u2014An object-\noriented application framework in C++. In Object-Oriented Programming\nSystems, Languages, and Applications Conference Proceedings, pages 46-57,\nSan Diego, CA, September 1988. ACM Press.\n", "page": 401, "type": "text", "section": "Page 401"}
{"text": "This page intentionally left blank \n", "page": 402, "type": "text", "section": "Page 402"}
{"text": "Index\nNames of design patterns appear in small capitals: e.g., ADAPTER. Page numbers in bold\nindicate the definition of a term. Numbers in italics indicate a diagram for the term.\nLetters after a diagram's page number indicate the kind of diagram: a \"c\" denotes a\nclass diagram, an \"i\" denotes an interaction diagram, and an \"o\" denotes an object\ndiagram. For example, 88co means that a class and object diagram appears on page 88.\nabstract class 15,16c, 359,364, 365c\nabstract coupling, see \ncoupling, abstract\nin OBSERVER 296\nABSTRACT FACTORY 87\nextensibility of 91 \nin catalog summary 8 \nLexi's use of 51 \nused to configure a subsystem 193\nAbstract Factory \nparticipant of ABSTRACT FACTORY 88c, 89\nabstract operation, see \noperation, abstract\nuse to implement ADAPTER 144\nabstract syntax tree 244,251,331\nclass structure for 244c, 331c\nconstructing in Smalltalk 250\nobject structure for 2440\nAbstractExpression \nparticipant of INTERPRETER 245c, 245\nAbstraction \nparticipant of BRIDGE 153c, 154\nAbstractProduct \nparticipant of ABSTRACT FACTORY 88c, 89\naccumulating state 336\nacquaintance 22,359\nC++, defined in 23 \ncompared with aggregation 23\nSmalltalk, defined in 23\nAction, see COMMAND\nactive iterator, see \niterator, active\nAda 4, 21 \nAdaptee\nparticipant of ADAPTER 141,141c\nADAPTER 139\ncompared with BRIDGE 161,219\ncompared with DECORATOR 184\ncompared with PROXY 216 \nin catalog summary 8\nAdapter \nparticipant of ADAPTER 141,141c\nadapter 140 \nclass adapter 141,141c \nobject adapter 141,141c\nparameterized 145 \npluggable, see \npluggable adapter\ntwo-way 143,143c\nadorner 179\nAggregate\nparticipant of ITERATOR 259,259c\naggregate object 257 \naggregation 22, 359\nC++, defined in 23 \ncompared with acquaintance 23\nnotation for 23 \nSmalltalk, defined in 23\nAlexander, Christopher xiii, \n2,356,358\n383\nA\n", "page": 403, "type": "text", "section": "Page 403"}
{"text": "384 \nINDEX\nalgorithm \navoiding dependence on 24\ndefining steps of 326\nfamily of 317 \nskeleton 327\nAlternationExpression 244co, \n343\nimplemented in Smalltalk 249\naluminum alloy 76\nAmbassador, see also PROXY\nC++idiom 208\nAnalogClock 303\nanalysis object model\ntransforming to design object model 353\nancestor class 361, see also class, parent\nAnderson, Bruce xi, 357 \nAndExp 253 \nAndrew Toolkit\nuse of OBSERVER 303 \nApplication 107,107c, 223o, 224ci, 231,325,325c\napplication programs 25\nApplicationWindow 53,54c, 55c, 157,233c, 234c\nArrayCompositor 42c, 315,315c, \n322\nASCII7Stream 183,183c \naspect of an object 298 \nAssignmentNode 333c \nassociations, see also acquaintance, aggregation\ninOMT 364\nBoolean\nexpression 251\nvariable 254\nBooleanExp 252 \nBorder 44,45c, 46o\nBorderDecorator 176o, 176c, 180\nBRIDGE 151\ncompared with ADAPTER 219\nconfigured by ABSTRACT FACTORY 155\nin catalog summary 8 \nLexi's use of 58 \nuse of delegation in 21\nbridge 152 \nbroadcast communication 296 \nBUILDER 97\ncompared with ABSTRACT FACTORY 105,\n135 \ncompared with PROTOTYPE 135\nin catalog summary 8 \nuse in compiler example 189\nBuilder \nparticipant of BUILDER 98, 98c\nBureaucrat 232, see also CHAIN OF RESPONSIBIL-\nITY \nButton 50c, 223of 224ci, 229,279\n6\nBTree 202 \nbase class, see \nclass, parent\nBeck, Kent xi, 357\nBedrock\nuse of DECORATOR 179,180\nbehavioral pattern 10,221\ncomparison between class and object\nscope 221\ndiscussion 345 \nblack-box reuse, see \nreuse, black-box\nblock, Smalltalk 270 \nBNFform 247\nexamples of 243,248,251\nBombedMazeFactory 93\nBombedMazeGame 115\nBombedWall 93,94,124\nBooch Components\nuse of ITERATOR 270\nuse of STRATEGY 323\nBooch, Grady xiii, 260\nBooch method 363\nC 4 \nCalder, Paul 33,38\ncallback function 235\nCaretaker\nparticipant of MEMENTO 285,285c, \n286i\nCargill, Tom 308 \nCHAIN OF RESPONSIBILITY 223\ncombined with COMPOSITE 166,232\ncompared with MEDIATOR 348\ncompared with OBSERVER 348\ndefined by parent references 166,232\nin catalog summary 8 \nuse of delegation in 21\nChangeManager 282,299,300c\nCharacter 38,38c \ncharacter\nrepresented as object 38,195-196\nCheshire Cat 155 \nChoices operating system\nuse of FACADE 192\nuse of PROXY 209\nclass 14,359 \nabstract, see \nabstract class\nadapter, see \nadapter, class\nC\n", "page": 404, "type": "text", "section": "Page 404"}
{"text": "INDEX \n385\ncompared with type 16\nconcrete, see \nconcrete class\nderived 360 \nfriend, see \nfriend class\ninability to alter 24\ninheritance, see inheritance\ninstance 15 \nlibrary, see \ntoolkit \nmixin, see \nmixin class\nnotation for 15,363\nparent 15,361 \nsubclass 15 \ntemplate, see \ntemplate\nclass diagram 363,365c, 359\nclass hierarchy\nadding operations to 356 \nconnecting parallel 109,258 \nexplosion 25,43,151,177 \nminimizing size of 113,120,177,277,317,\n348 \nvisiting multiple 336\nclass operation 359 \nalternatives provided by SINGLETON 128\nClient \nparticipant of ABSTRACT FACTORY 88c, 89\nparticipant of ADAPTER 141,141c\nparticipant of BUILDER 98,98c, 99i\nparticipant of CHAIN OF\nRESPONSIBILITY 225d, 226,348i\nparticipant of COMMAND 236,236c, 237z\nparticipant of COMPOSITE 164c, 165\nparticipant of FLYWEIGHT 198c, 199\nparticipant of INTERPRETER 245c, 246\nparticipant of PROTOTYPE 119,119c\nclient 11 \nisolating concrete classes from 89\nClockTimer 302\nclone operation 117\nused in PROTOTYPE 117\nimplementing 121\ncloned object 117\ninitializing 121\nCLOS 4,260, 338\nclosure 260,267\nCoad, Peter 357\ncode structure\nrun-time versus compile-time 23\nCodeGenerationVisitor 332c\nColleague\ncommunicating with Mediator 278,282\nparticipant of MEDIATOR 276co, 277, 348i\nCOMMAND 233 \ncombined with MEMENTO 239,287\ncombined with PROTOTYPE 238\nin catalog summary 8\nuse in Lexi 64\nCommand 60, 61 c, 233,233c, 239\nconfigured in Menultem 61 \nhistory of 62 \nparticipant of COMMAND 236,236c, 237z,\n347i\ncommand\nC++ idiom, see functor \ncopying before execution 238 \nhistory, see \nhistory list \nimplemented through C++ templates 239,\n240\nintelligence of 238\ncommon vocabulary 352\ncommunication\nencapsulated or distributed 346\nbetween Strategy and Context 318\nbetween Visitor and Element 337\ncompilation dependencies\nreducing using FACADE 188\nCompiler 185,186c, \n191\ncompiler\nexample in FACADE 185,186c, 188\nimplemented using VISITOR 331\nSmalltalk, see \nRTL \nSmalltalk compiler\nComponent \nparticipant of COMPOSITE 164c, 165,168\nparticipant of DECORATOR 177,177 \nc\nCOMPOSITE 163 \ncaching children of 169 \nchild management 167 \ncombined with INTERPRETER 255 \ncombined with ITERATOR 262\ncombined with VISITOR 339\ncompared with DECORATOR 219-220\ncompared with INTERPRETER 247\ndata structure for 169,170 \nin catalog summary 8 \ninterface of 167 \nLexi's use of 40 \nparent references 166 \nsharing components 166 \nuse in Model/View/Controller 5\nComposite \nparticipant of COMPOSITE 164c, 165,165o,\n168\nCompositeEquipment 171\nComposition 41,42c, 315,315c, 320\ncomposition, see object composition\nCompositor 41,42,315,315c, 321\ninterface 41\nCompressingStream 183c, 184\n", "page": 405, "type": "text", "section": "Page 405"}
{"text": "386 \nINDEX\nconcrete class, 15,359 \navoiding specification of 24\nisolating clients from 89\nConcreteAggregate \nparticipant of ITERATOR 259,259c\nConcreteBuilder \nparticipant of BUILDER 98c, 99, 99i\nConcreteCommand \nparticipant of COMMAND 236,236c, 238\nConcreteComponent \nparticipant of DECORATOR 177,177c\nConcreteDecorator \nparticipant of DECORATOR 277c, 178\nConcreteElement \nparticipant of VISITOR 334,334c, 335i\nConcreteFactory \nparticipant of ABSTRACT FACTORY 89\nConcreteFlyweight \nparticipant of FLYWEIGHT 198co, 199\nConcreteHandler\nparticipant of CHAIN OF\nRESPONSIBILITY 225c, 226\nConcretelmplementor\nparticipant of BRIDGE 153c, 154\nConcretelterator\nparticipant of ITERATOR 259,259c\nConcreteObserver\nparticipant of OBSERVER 294c, 295,295i\nConcreteProduct\nparticipant of ABSTRACT FACTORY 88, 89\nparticipant of FACTORY METHOD 108,108c\nConcretePrototype \nparticipant of PROTOTYPE 119,119c\nConcreteState \nparticipant of STATE 307,307c\nConcreteStrategy \nparticipant of STRATEGY 316c, 316\nConcreteSubject \nparticipant of OBSERVER 294c, 295,295?\nConcrete \nVisitor \nparticipant 334, 334c, 335*\nconditional statements \navoiding using STATE 307\navoiding using STRATEGY 317\nconsolidation phase of lifecycle 353\nconstraint solving 282,283\nsee also ThingLab, QOCA\nConstraintSolver 283-284, 288\nconstructor 360 \nContext 252\nparticipant of INTERPRETER 245c, 246\nparticipant of STATE 306, 306c\nparticipant of STRATEGY 316c, 316\ncontrol flow \nencapsulating, see MEDIATOR\ninversion of 27\nCoplien, James 125,153,160,242,313,357\ncopy\ndeep 121 \non write 210\nshallow 121\nCountingMazeBuilder 104\ncoupling 360\nabstract 188,278,296, \n359 \nloose 24,26, 277,347, see \nalso decoupling\nreducing 24,187,188,223,226 \ntight 24\nCreateMaze operation 84 \nABSTRACT FACTORY variant (C++) 92\nABSTRACT FACTORY variant (Smalltalk) 94\nBUILDER variant 102 \nFACTORY METHOD variant 114\nPROTOTYPE variant (Smalltalk) 123,125\ncreational pattern 10,81\ndiscussion of 135\nCreator \nparticipant of FACTORY METHOD 108,108c\nimplementation of 1\n1\n1\n, 113\nCursor, see ITERATOR\ncursor, see \niterator, cursor\nD\ndata member 360\nDebuggingGlyph 182\nDECORATOR 175\ncompared with ADAPTER 175,184\ncompared with COMPOSITE 44,173, 219-\n220 \ncompared with PROXY 216,219-220\ncompared with STRATEGY 179 \nin catalog summary 8 \nLexi's use of 45c, 46o, 47\nlightweight versus heavyweight 179\nDecorator 276,180 \nparticipant of DECORATOR 177,177c, 180o\ndecorator 175 \ndecoupling, see \nalso coupling, loose\ninterface and implementation 154\nsenders and receivers 346\ndeep copy, see \ncopy, deep\ndelegate 20,144\ndelegation 20, 278,360\ncompared with inheritance 20-21\n", "page": 406, "type": "text", "section": "Page 406"}
{"text": "INDEX \n387\nimplementing pluggable adapters\nwith 144\npatterns that rely on 21\ndependency 293\nmanaging complex 299\nDependents, see OBSERVER\nderived class, see \nclass, derived\ndesign\ndeja-vu 2 \ndensity 358 \ndocumenting with patterns 27,352\nfor change 23 \npoetry of 356 \nfor reuse 23\ndesign object model 353\ndesign pattern 360\nadjunct to design methodology 353\naspects of design varied by 30\nbenefits 351 \ncatalog summary 8 \ncatalog template 6 \nclassification 10 \ncompared with frameworks 28\ndiagram of relationships 12\ndocumenting designs with 27,352\nessential elements 3 \nfinding 355 \nhistory of 355 \nhow to use 29 \npurpose 10 \nrefactoring with 353 \nscope 10 \nselection of 28 \ntable of 10\ndestructor 360\nensuring iterator's is called 266\nDialog 223,231\nDialogDirector 274o, 275cz, 278\nDialogWindow 53,54c, 55c\nDigitalClock 302 \nDirector\nparticipant of BUILDER 98c, 99, 99i\nDirectoryBrowser 144,144c, 145c\ndiscretionary glyph 75 \ndispatch\ndouble 338\nmultiple 339\nsingle 338\nDoc 205, see also Lexi \nDocument 107,107c, 233c, 234,234c, 325,325c\ndocument\ncolor 42, 322\nformatting 40\nlogical structure 40\nphysical structure 35\ndocumenting design with patterns 27, 352\ndoesNotUnderstand message\nused to implement CHAIN \nOF\nRESPONSIBILITY 229 \nused to implement PROXY 212,215\nDomain 192,192c\nDoor 82c,83\nextensions for PROTOTYPE 123\ndouble-dispatch, see \ndispatch, double\ndowncast 91 \nDylan 4\nuse of MEMENTO 289\ndynamic binding 14,360\ndynamic inheritance 309\ndynamic_cast in C++ 91,168\ne-mail address \nreaching the authors xii\nEiffel 17, 21\nElement\nparticipant of VISITOR 334,334c\nencapsulation 11,360\nbreaking with inheritance 19 \nbreaking with VISITOR 337 \npreserving boundaries of 286 \nof algorithms, see STRATEGY \nof complex update semantics, 299, see also\nChangeManager \nof concept that varies 29,54 \nof document analysis and traversal 71 \nof protocol between objects, see MEDIATOR\nof how objects are created, see ABSTRACT\nFACTORY, BUILDER, PROTOTYPE\nof traversal, see ITERATOR \nof requests 59, see also COMMAND\nof state-specific behavior, see STATE\nEnchantedMazeFactory 93\nenvelope-letter idiom 313\nEquipment 170,340\nEquipmentVisitor 341\nerror accumulation\navoiding during undo/redo 239\nET++\nuse of ABSTRACT FACTORY 95 \nuse of ADAPTER 126,148 \nuse of BRIDGE 160 \nuse of BUILDER 105 \nuse of CHAIN OF RESPONSIBILITY 232\nE\n", "page": 407, "type": "text", "section": "Page 407"}
{"text": "388 \nINDEX\nuse of COMPOSITE 172 \nuse of COMMAND 242 \nuse of DECORATOR 182,183\nuse of FACADE 192 \nuse of FACTORY METHOD 115\nuse of FLYWEIGHT 206 \nuse of ITERATOR 261 \nuse of MEDIATOR 281 \nuse of OBSERVER 303 \nuse of PROTOTYPE 120,125\nuse of PROXY 216 \nuse of STRATEGY 322-323\nET++SwapsManager \nuse of STRATEGY 323\nETgdb 125 \nexpansion phase of lifecycle 353,354\nexplosion, see \nclass hierarchy, explosion\nExtendedHandler 228 \nexternal iterator, see \niterator, external\nextrinsic state, see \nstate, extrinsic\nframework 26,360 \ncompared with design patterns 28\ndocumenting with patterns 27\ngraphical editor 117 \nsee Bedrock \nsee Choices \nsee ET++ \nsee HotDraw \nsee MacApp \nsee NEXTSTEP \nsee NeXT AppKit \nsee RApp \nsee RTL Smalltalk compiler \nsee Unidraw \ntrade-offs associated with 27\nFresco 344\nfriend class 360\nused to grant Iterator privileged access to\ncollection 262\nused to support Memento 287\nfunctor 242 \nfuture cash flow 323\nF\nFACADE 185 \ncompared with MEDIATOR 193,282\nin catalog summary 8 \nuse in Choices 192\nFacade \nparticipant of FACADE 185c, 187,187c\nfacade 185 \nFACTORY METHOD 107\nin catalog summary 8\nlanguage-specific variants 112\nparameterized with product identifier 110\nused to implement ABSTRACT FACTORY 90,\n91,110 \nused to create an iterator 258\nFileStream 183,183c\nFLYWEIGHT 195\ncombined with COMPOSITE 167,200\ncombined with INTERPRETER 247\ncombined with STATE 308 \nin catalog summary 9 \nLexi's use of 39 \nparticipant of FLYWEIGHT 198,198co\nflyweight 196,196o\nmanaging shared 200\nFlyweightFactory 204 \nparticipant of FLYWEIGHT 198co, 199\nFontDialogDirector 274,274o, 275cf\nFoote, Brian 353 \nforwarding requests 229\nG\ngdb 126 \ngenerics 21 \nGlyph 38,38c, 42c, 430,45c, 46o, 50c, 54c, 67c\nimplemented as a flyweight 201-204\ninterface 39 \ninterface for traversal 66\nGlue, see FACADE\nGlyphArraylterator 67,67c\nGNU gdb 126 \ngrammar 243\nmaintaining complex 247\nGraphic 163c, 208c, 213\nGraphicTool Il7,118c\nguaranteed receipt of request 226\nGUIFactory 49,50c, 51\nH\nHamlet 1 \nHandle/Body, see also BRIDGE\nC++idiom 155,160\nHandler\nparticipant of CHAIN OF \nRESPONSIBILITY 225,225cz, 348i\n", "page": 408, "type": "text", "section": "Page 408"}
{"text": "INDEX \n389\nhardware platform\nisolating application from 24\nhelp\ncontext-sensitive 223\non-line 223\nHelpHandler 224,224c, 227,229\nhistory list 62-64,238\ncopying commands onto 238\nHollywood principle 327 \nhook operation 326,328\nin ABSTRACT FACTORY 109 \nin FACTORY METHOD 109 \nin PROXY 212 \nin TEMPLATE METHOD 326,328\nHotDraw \nuse of STATE 313\nhub of communication 274\nhyphenation 64\nI\nIconWindow 53,54c, 151-152,151c, \n157\nImage 207o, 208c, 213 \nImageProxy 207o,208c \nImplementor\nparticipant of BRIDGE 153c, 154\nimplicit receiver, see \nreceiver, implicit\nincremental changes 287\ninheritance 15,360\nC++, defined in 17 \nclass versus interface 16 \ncombined with polymorphism 18\ncompared with object composition 18,178\ncompared with parameterized types 21\ndynamic 309 \nEiffel, defined in 17 \nimplementation 17, \n360 \ninterface 17,360 \nmixin, see \nmixin class \nnotation for 15,364, 365c \nproper use of 18 \nreuse through 18 \nSmalltalk, defined in 17\ninorder traversal, see \ntraversal, inorder\ninstance, see \nalso class, instance\nensuring uniqueness, see SINGLETON\nvariable 15,360\ninstantiation 15 \nabstracting process of 48 \nnotation for 15, 364, 365c\nintegrated circuit 323\ninteraction diagram 7, \n366 \nin BUILDER 99? \nin CHAIN OF RESPONSIBILITY 224z, 348i\nin COMMAND 237z, 347i \nin MEDIATOR 274i, 348i \nin MEMENTO 286i \nin OBSERVER 295i, 347i \nin VISITOR 335z \nLexi's Visitor 74i\ninterface 13 \nbenefits of programming to 18 \nbloat 257 \nconversion, see ADAPTER \nfor iteration 262 \ninheritance 13,17 \nnarrow versus wide in MEMENTO 285\nspecifying in C++ 17 \nsimplifying subsystems, see FACADE\ninternal iterator, see \niterator, internal\nINTERPRETER 243\ncombined with COMPOSITE 255\ncombined with VISITOR 247,255 \nin catalog summary 9\nInterviews \nuse of ABSTRACT FACTORY 95\nuse of ADAPTER 148 \nuse of COMMAND 242 \nuse of COMPOSITE 172 \nuse of DECORATOR 182 \nuse of FLYWEIGHT 205 \nuse of OBSERVER 303 \nuse of SINGLETON 133 \nuse of STRATEGY 320,322-323\nintrinsic state, see \nstate, intrinsic\ninversion of control flow 27\ninvitation 358 \nInvoker\nparticipant of COMMAND 236,236c, 237z,\n347i\nIRIS Inventor\nuse of VISITOR 344\nITERATOR 257\ncombined with COMPOSITE 362\ncombined with VISITOR 339\ncompared with VISITOR 336 \nin catalog summary 9 \nuse in Lexi 69\nIterator 67, 67c, 258c, 263,372\nparticipant of ITERATOR 259,259c\niterator 66, 257,339 \naccess to aggregate 262\nactive 260 \nalternative to in Smalltalk 270\ncontrolling 260\n", "page": 409, "type": "text", "section": "Page 409"}
{"text": "390\nINDEX \ncursor 261 \nensuring deletion of 266 \nexternal 260,339,269 \ninterface to 261,263 \ninternal 260,267,339, see also ListTraverser\nnull 262, see also Nulllterator \nover recursive structures 262\nparameterized with an operation 267\npassive 260 \npolymorphic 258,261,265 \nprivileged access to Aggregate 262 \nrobust 261\nM\nK\nKit, see also ABSTRACT FACTORY\nin Inter \nViews 95\nKnuth, Donald 357\nL\nlazy initialization 112\nLeaf\nparticipant of COMPOSITE 164c, 165,1650,\n168 \nLempel-Ziv compression 183\nLexi 33\ndocument structure 35 \ndocument traversal and analysis 64\nlook-and-feel standards 47\nmultiple window systems 51 \nuser interface 33, 34 \nuser operations 58\nlibg++ \nuse of BRIDGE 160\nlifecycle of software 353, 354 \nLinton, Mark 344 \nList 257,257c, 258c, 263,369 \nlist box 274 \nlist traversal 257 \nListBox 274o, 275ci, 279 \nListlterator 67, 257,257c, 258c, 264,372\nListTraverser 267 \nLiteralExpression 244co, 344\nimplemented in Smalltalk 250\nlook-and-feel standards 87\nsupport in Lexi 35,47\nMacApp \nuse of CHAIN OF RESPONSIBILITY 232\nuse of COMMAND 242 \nuse of DECORATOR 179,180 \nuse of FACTORY METHOD 113,115\nMacbeth 1 \nMacFactory 50c \nMacintosh 48, 52\nMacroCommand 235,235c, 241\nmagic token 346\nManipulator 109, llOc\nMapSite 82, 82c \nMarriage of Convenience 149\nMaze S2c,84 \nMazeBuider 101\nMazeFactory 92\nas singleton 133\nMazeGame 84,114\nMazePrototypeFactory 122\nMEDIATOR 273\ncombined with OBSERVER 299\ncompared with CHAIN OF\nRESPONSIBILITY 348\ncompared with FACADE 282\ncompared with OBSERVER 346,348 \nin catalog summary 9 \nuse of delegation in 21\nMediator \ncommunicating with Colleague 278, \n282\nparticipant of MEDIATOR 276co, 277,348i\nomitting abstract class of 278\nmediator 274 \nmember function 361, see \nalso operation\nMEMENTO 283\nin catalog summary 9\nMemento\ncombined with COMMAND 239,287\nparticipant of MEMENTO 285,285c, 286i\nmemento 284 \ncosts associated with 286\nlanguage support for 287\nMemoryStream 183\nMenu 50c,233c\nmenu 233\nconfiguring 60, 234\npull-down 58\nMenultem 59, 61c, 233,233c\nmetaclass 133,361 \nmethod 361, see also operation\nMicrosoft Windows 52 \nmixin class 16,16c, 361\n", "page": 410, "type": "text", "section": "Page 410"}
{"text": "INDEX \n391\nModel/View/Controller 4,5 \nuse of COMPOSITE 5,172 \nuse of FACTORY METHOD 115\nuse of OBSERVER 5,303 \nuse of STRATEGY 6\nMonoGlyph 44,45c \nMotif 35,47,48,49,51, 87\nMotifFactory 49, 50c \nmultiple dispatch, see \ndispatch, multiple\nmultiple inheritance, see \nalso mixin class\nused to implement class adapter 141\nused to implement BRIDGE 156\nMVC, see Model/View/Controller\nMeyer, Bertrand 149\nN\nnaming conventions 29,31 \nFACTORY METHOD 31,113\nTEMPLATE METHOD 329\nVISITOR 337\nNeXT AppKit \nuse of ADAPTER 149 \nuse of BRIDGE 160 \nuse of CHAIN OF RESPONSIBILITY 232\nuse of TEMPLATE METHOD 329\nNEXTSTEP \nuse of ADAPTER 145 \nuse of PROXY 208,212,216\nNode 333c\nNodeVisitor 332c \nnonterminal symbol 246\nNonTerminalExpression\nparticipant of INTERPRETER 245c, 246\nnotification 294 \nnull iterator, see \niterator, null\nNulllterator 67c, 67-68,262 \nNXProxy 208, 212\no\nobject 11,361 \nadapter, see \nadapter, object\nacquaintance 22 \naggregation 22 \nas argument to request 345 \naspect of 298 \navoiding dependence on implementation\nof 24 \ncomposition, see \nobject composition\nfinding 11 \ngranularity of 13, see also FLYWEIGHT\nguts 179 \nreference 361 \nshared, see FLYWEIGHT \nskin 179 \nspecifying implementation of 14\nspecifying interface to 13\nobject composition 18, 361 \ncompared with inheritance 18-20\ncompared with parameterized types 22\nreuse through 19\nobject diagram 364,361 \nObjects for States, see STATE \nObject Modeling Technique 7,14,363,364\nObjective C 90,120,121,135,144\nObjectory 363 \nObjectWindows\nuse of ITERATOR 270\nuse of STRATEGY 323\nObjectWorksXSmalltalk, see also Smalltalk\nuse of ADAPTER 148-149 \nuse of DECORATOR 182 \nuse of FACADE 191\nOBSERVER 293 \ncombined with MEDIATOR 278,282\ncompared with CHAIN \nOF\nRESPONSIBILITY 346,348\ncompared with MEDIATOR 346,348\nin Model/View/Controller 5 \nin catalog summary 8 \nlimiting unexpected updates in 296\nObserver 300 \ncombining with Subject 300\nparticipant of OBSERVER 294c, 295,295i,\n300c, 347i \nOMT, see \nObject Modeling Technique\noperation 11,361\nabstract 15,359 \nadding to classes 335 \navoiding dependence on specific 24\nclass, see \nclass operation \nconcrete 327 \ndispatch, see dispatch \nhook, see \nhook operation\noverriding 16 \nprimitive 327,329\nOrbix \nuse of FACTORY METHOD 116\nOriginator \nparticipant of MEMENTO 285,285c, 286i\noriginator 284\n", "page": 411, "type": "text", "section": "Page 411"}
{"text": "392 \nINDEX\noverloading \nused to implement PROXY 211\nused to implement VISITOR 72, 337\nparameterized types 21, 361, see also template\ncompared with inheritance 22\ncompared with composition 22\nparent class, see \nclass, parent\nparent references\ndefined in COMPOSITE 166\nparser 247 \npart-whole, see \nrecursive composition\nsee also aggregation \nPascal 4 \npassive iterator, see \niterator, passive\nPassivityWrapper 182 \npath\nspecifying multi-segment shapes 57\npattern language 356 \nPattern Languages of Programs 357\npattern matching 243 \npersistence 209 \nPicture 163c, 164o \nPLoP, see \nPattern Languages of Programs \npluggable adapter 142\nimplementation of 144-145,144c, 145c,\n148,149c \nPMFactory 50c \nPMIconWindow 151,151c\nPMWindow 151,151c\nPMWindowImp 152,152c, 158-159\nPoint 373 \nPolicy, see STRATEGY \npolymorphic iteration 258\nimplementing in C++ 261\npolymorphism 14, 361\nused with inheritance 18 \npostorder traversal, see \ntraversal, postorder\npreorder traversal, see traversal, preorder\nPreorderlterator 67\nmember functions 68-69 \nPresentation Manager 35,48,52,56,57, 87,151,\n158 \nPricingVisitor 341 \nPrintDialog 223o,224i \nprivate inheritance 361, see also inheritance,\nimplementation\nProduct\nparticipant of BUILDER 98c, 99\nparticipant of FACTORY METHOD 108,108c\nproduct objects 49 \nchanging at run-time 119\ncreating in ABSTRACT FACTORY 90\nexchanging 89 \nfamily of 87 \nvarying representation of 100\nprotection proxy, see \nproxy, protection\nprotocol 361 \nPROTOTYPE 117\ncompared with ABSTRACT FACTORY 126,\n135 \ncombined with COMMAND 238\ncompared with FACTORY METHOD 116,120\nin catalog summary 9 \nparticipant of PROTOTYPE 119,119c \nused to implement ABSTRACT FACTORY 90\nprototype 117 \nprototype manager 121\nprototyping phase of lifecycle 353\nPROXY 207\ncombined with ITERATOR 262\ncompared with DECORATOR 220\nin catalog summary 9\nProxy \nparticipant of PROXY 209co, 209\nproxy 207 \nprotection 208,210\nremote 208,210\nvirtual 208,210\npseudocode 16,16c, 365c\nPublish-Subscribe, see OBSERVER \npull model 298 \npull-down menu, see menu, pull-down\npurpose of design pattern, see \ndesign pattern,\npurpose\npush model 298\nQ\nQOCA \nuse of ADAPTER 143\nuse of INTERPRETER 255\nuse of MEMENTO 291\nR\nRApp \nuse of STRATEGY 323\nRealSubject \nparticipant of PROXY 209co, 210\n", "page": 412, "type": "text", "section": "Page 412"}
{"text": "INDEX \n393\nReceiver \nparticipant of COMMAND 236,236c, 237i,\n238\nreceiver 361\ndecoupling from sender 346\nimplicit 224\nRect 374 \nRectangle 20,20c \nrecursive composition 36, see also COMPOSITE\niteration over 262 \nof document structure 36 \nof graphic elements 163 \nof part-whole structures 164\nredesign, causes of 24\nredo, see undo/redo\nrefactoring 326,353\nreference counting 210\nRefinedAbstraction\nparticipant of BRIDGE 153c, 154\nregular expression 243\nrepresenting in Smalltalk 248\nRegularExpression 244c \nremote proxy, see \nproxy, remote\nRepetitionExpression 244co, 343\nimplemented in Smalltalk 249\nrequest 11,361\nautomatic forwarding of 229\nencapsulation of 59, see also COMMAND\nguaranteed receipt of 226\nrepresenting 227 \nsequencing 234\nResponder 232\nreuse\nblack-box 19,354,359 \nby composition 19 \nby parameterized types 21\nby subclassing 19 \ncode 26 \ndesigning for 24-25\nframeworks 26 \ninternal 25 \nmaximizing 23 \nof implementation 18\ntoolkits 26 \nwhite-box 19,354,362\nRich Text Format 97 \nrobust iterator, see \niterator, robust\nRoom 82c,83 \nRTF, see Rich Text Format\nRTFReader 97, 97c \nRTL Smalltalk \ncompiler\nuse of COMPOSITE 172\nuse of STRATEGY 323\nS\nscope of design pattern, see \ndesign pattern,\nscope\nScrollbar 50c\nScrollDecorator 17 \n60,17 \n6c\nScroller 45,46o \nSelf 4,121,309 \nsender\ndecoupling from receiver 346\nSequenceExpression 244co, 343\nimplemented in Smalltalk 249\nsequencing requests 234 \nshallow copy, see \ncopy, shallow \nShape 139,140c, \n146 \nshrinkability 320 \nsignature 13,361 \nSimpleCompositor 42,42c, 315, 315c, 321\nsingle static assignment form, SSA 172\nsingle-dispatch, see \ndispatch, single \nSINGLETON 127\nC++ implementation 129,131 \nin catalog summary 9 \nregistry of 130 \nsubclassing 130 \nused to implement ABSTRACT FACTORY 90\nSingleton \nparticipant of SINGLETON 127c, 128\nSketchpad 125 \nSkipList 258c,265 \nskiplist 258 \nSmalltalk-80, see also Object \nWorks \n\\Smalltalk,\nSmalltalk/V \nuse of BUILDER 105 \nuse of COMPOSITE 172 \nuse of FACTORY METHOD 115\nuse of INTERPRETER 251 \nuse of ITERATOR 270 \nuse of OBSERVER 303 \nuse of SINGLETON 133 \nuse of VISITOR 344\nSmalltalk/V \nuse of INTERPRETER 251\nuse of MEDIATOR 278,281\nsmart pointers 209\nsmart references 209\nsoftware platform\nisolating application from 24\nSolitaire, see SINGLETON\nSolverState 283-284 \nSPECTalk\nuse of INTERPRETER 255\nspelling checking 64\n", "page": 413, "type": "text", "section": "Page 413"}
{"text": "394 \nINDEX\nSpellingChecker 71-73\nSpellingCheckerVisitor 75\nStandardMazeBuilder 103\nSTATE 305\nC++ idiom for, see \nenvelope-letter idiom\nin catalog summary 9 \nuse of delegation in 21\nState\nparticipant of STATE 306,306c\nstate\naccumulating during traversal 336\navoiding inconsistent 308\nextrinsic 196 \nincremental changes to 287\nintrinsic 196 \nsharing 308, see also FLYWEIGHT\nstate transitions\natomic 308\ndefining 308\ntable-driven 308\nSTRATEGY 315 \ncompared with DECORATOR 179\nin catalog summary 8 \nLexi's use of 42 \nuse in Choices 193 \nuse in Model/View/Controller 6\nuse of delegation in 21\nStrategy 180o \nmaking optional 320 \nparticipant of STRATEGY 316c, 316\nstrategy 315 \nStream 183,183c\nStreamDecorator 183,183c\nstretchability 320\nStroustrup, Bjarne 160\nstructural pattern 10,137\ncomparison between class and object\nscope 137\ndiscussion of 219\nsubclass, see \nclass, subclass \nsubclassing\nextending functionality by 24\nSubject 301\navoiding dangling references to 297\ncombining with Observer 300\nparticipant of OBSERVER 294c, 295,295i,\n300c, 347i \nparticipant of PROXY 209co, 210\nsubject 294 \nmapping to observers 297\nobserving more than one 297\nsubsystem 361 \nsimplifying interface to, see FACADE\nsubtype, see \ntype, subtype\nsuccessor 224 \nconnecting in chain 227\nimplementing chain of 225\nsuperclass 361, see also class, parent\nsupertype, see \ntype, supertype\nSurrogate, see PROXY \nSutherland, Ivan 125 \nswaps 323\nT\nTarget \nparticipant of ADAPTER 141,141c\nTCP protocol 309 \nTCPConnection 305,305c, 309\nTCPState 305,305c,310 \ntemplate 21, see also parameterized types\nused to implement COMMAND 239 \nused to implement \nFACTORY METHOD 113\nused to implement STRATEGY 319,323\nTEMPLATE METHOD 325 \ncalling Factory Methods 116 \nin catalog summary 9 \nnaming conventions for 329\nused to implement ITERATOR 270\ntemplate method 326\nterminal symbol 246\nshared using FLYWEIGHT 247\nTerminalExpression\nparticipant of INTERPRETER 245c, 246\nTgX 42,97,316\nTeXCompositor 42c, 315,315c, \n322\nTextShape 139,140c, 146,147\nTextView\nuse in ADAPTER 139,140c, \n146\nuse in DECORATOR 176c, 1760\nThingLab 125\nTHINK\nuse of COMMAND 242\nuse of OBSERVER 303\nToken, see MEMENTO\nTool 117,118c, 313,313c\ntoolkit 26,233,362\nsee Andrew \nsee Booch Components\nsee Fresco \nsee Interviews \nsee IRIS Inventor \nsee Object Windows \nsee QOCA \nsee THINK\nTransaction, see COMMAND\n", "page": 414, "type": "text", "section": "Page 414"}
{"text": "transaction 236 \ntransparent enclosure 43, see also DECORATOR\ntraversal of aggregate objects, see also ITERATOR\nacross class hierarchies 336 \nassigning responsibility for in VISITOR 339\ninorder, preorder, postorder 262\nTreeAccessor \nDelegate 145,145c\nTreeDisplay 142,144,144c, 145c\ntwo-way adapter, see adapter, two-way\ntype 13\ncompared with class 16\nC++, definition in 17\nEiffel, definition in 17\nSmalltalk, definition in 17\nsubtype 13 \nsupertype 13\ntype-checking 332 \nto identify requests at run-time 228\nsee also dynamic_cast\nTypeCheckingVisitor 332c\nU\nundo/redo 59-60, 62-64,235,238,283,287\navoiding error accumulation during 239\nUnidraw \nuse of ADAPTER 143 \nuse of CHAIN OF RESPONSIBILITY 232\nuse of COMMAND 232,242 \nuse of FACTORY METHOD 111 \nuse of ITERATOR 270 \nuse of MEDIATOR 282 \nuse of MEMENTO 289 \nuse of OBSERVER 303 \nuse of PROTOTYPE 126 \nuse of STATE 313\nUnsharedConcreteFlyweight\nparticipant of FLYWEIGHT 199\nupdates \nencapsulating complex 299\nlimiting unexpected 296\nprotocol for in OBSERVER 296\ntriggering 297\nINDEX \n395\nVirtual Constructor, see FACTORY METHOD\nvirtual memory framework 192 \nvirtual proxy, see \nproxy, virtual \nVISITOR 331\ncombined with INTERPRETER 247,255\nin catalog summary 9 \ninteraction diagram for Lexi 74 \nuse in Lexi 76 \nuse in compiler example 190,331\nuse of delegation in 21\nVisitor 75,337 \nparticipant of VISITOR 334,334c\nvisitor 74,332\nVisualComponent 176,17 \n6c, 180\nvocabulary, defining common 352\nW\nWall 82c, 83 \nwhite-box reuse, see \nreuse, white-box\nWidget 224c, 230,275c, 278 \nwidget 48, 87\nGlyph hierarchy 50\nWidgetFactory 87 \nWindow 20c, 39, 54c, 55c, 152,156\nconfiguring with Windowlmp 57-58\ninterface 53\nwindow systems 35\nsupport in Lexi 51\nWindowlmp 55,55c, 152,152c, \n157\nsubclasses 55\nWindows, see \nMicrosoft Windows\nWindowSystemFactory 57\nWrapper, see ADAPTER, DECORATOR\nWYSIWYG 33\nX\nX Window System 52, 56,57,151,158\nXlconWindow 151,151c \nXWindow 151,151c \nXWindowImp 152,152c, 158\nV\nValidator 323\nVariableExp 252\nVariableRefNode 333c\nViewManager 281, 281o\n", "page": 415, "type": "text", "section": "Page 415"}
{"text": "Interaction Diagram Notation\nObject Diagram Notation\nClass Diagram Notation\n", "page": 416, "type": "text", "section": "Page 416"}
