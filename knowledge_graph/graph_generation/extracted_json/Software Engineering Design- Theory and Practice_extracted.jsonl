{"text": "Software\nEngineering\nDesign\nTheory and Practice\nCarlos E. Otero\nwww.allitebooks.com\n", "page": 1, "type": "text", "section": "Page 1"}
{"text": "www.allitebooks.com\n", "page": 2, "type": "text", "section": "Page 2"}
{"text": "Software\nEngineering\nDesign\nTheory and Practice\nwww.allitebooks.com\n", "page": 3, "type": "text", "section": "Page 3"}
{"text": "Titles in the \nAuerbach Series on Applied Software Engineering\nPhillip A. Laplante, Pennsylvania State University, Series Editor\nSoftware Engineering Design: Theory and Practice\nCarlos E. Otero  \n978-1-4398-5168-5\nEthics in IT Outsourcing\nTandy Gold \n978-1-4398-5062-6\nThe ScrumMaster Study Guide \nJames Schiel\n978-1-4398-5991-9\nAntipatterns: Managing Software Organizations and People,  \nSecond Edition\nColin J. Neill, Philip A. Laplante, and Joanna F\n. DeFranco\n978-1-4398-6186-8\nEnterprise-Scale Agile Software Development\nJames Schiel\n978-1-4398-0321-9\nRequirements Engineering for Software and Systems\nPhillip A. Laplante\n978-1-4200-6467-4 \nBuilding Software: A Practioner\u2019s Guide\nNikhilesh Krishnamurthy and Amitabh Saran\n978-0-8493-7303-9\nGlobal Software Development Handbook\nRaghvinder Sangwan, Matthew Bass, Neel Mullick, Daniel J. Paulish, \nand Juergen Kazmeier\n978-0-8493-9384-6\nSoftware Engineering Quality Practices\nRonald Kirk Kandt\n978-0-8493-4633-0\nwww.allitebooks.com\n", "page": 4, "type": "text", "section": "Page 4"}
{"text": "Software\nEngineering\nDesign\nTheory and Practice\nCarlos E. Otero\nwww.allitebooks.com\n", "page": 5, "type": "text", "section": "Page 5"}
{"text": "CRC Press\nTaylor & Francis Group\n6000 Broken Sound Parkway NW, Suite 300\nBoca Raton, FL 33487-2742\n\u00a9 2012 by Taylor & Francis Group, LLC\nCRC Press is an imprint of Taylor & Francis Group, an Informa business\nNo claim to original U.S. Government works\nVersion Date: 20120511\nInternational Standard Book Number-13: 978-1-4665-6586-9 (eBook - PDF)\nThis book contains information obtained from authentic and highly regarded sources. Reasonable efforts have been \nmade to publish reliable data and information, but the author and publisher cannot assume responsibility for the valid-\nity of all materials or the consequences of their use. The authors and publishers have attempted to trace the copyright \nholders of all material reproduced in this publication and apologize to copyright holders if permission to publish in this \nform has not been obtained. If any copyright material has not been acknowledged please write and let us know so we may \nrectify in any future reprint.\nExcept as permitted under U.S. Copyright Law, no part of this book may be reprinted, reproduced, transmitted, or uti-\nlized in any form by any electronic, mechanical, or other means, now known or hereafter invented, including photocopy-\ning, microfilming, and recording, or in any information storage or retrieval system, without written permission from the \npublishers.\nFor permission to photocopy or use material electronically from this work, please access www.copyright.com (http://\nwww.copyright.com/) or contact the Copyright Clearance Center, Inc. (CCC), 222 Rosewood Drive, Danvers, MA 01923, \n978-750-8400. CCC is a not-for-profit organization that provides licenses and registration for a variety of users. For \norganizations that have been granted a photocopy license by the CCC, a separate system of payment has been arranged.\nTrademark Notice: Product or corporate names may be trademarks or registered trademarks, and are used only for \nidentification and explanation without intent to infringe.\nVisit the Taylor & Francis Web site at\nhttp://www.taylorandfrancis.com\nand the CRC Press Web site at\nhttp://www.crcpress.com\nwww.allitebooks.com\n", "page": 6, "type": "text", "section": "Page 6"}
{"text": "This book is dedicated to my wife, Kelly, \nchildren\u00a0Allison, Amanda, Michael, and Ashley, \nand\u00a0parents\u00a0Angel L. Otero and Lydia E. Rivera.\nwww.allitebooks.com\n", "page": 7, "type": "text", "section": "Page 7"}
{"text": "www.allitebooks.com\n", "page": 8, "type": "text", "section": "Page 8"}
{"text": "vii\nContents\nPreface........................................................................................................................... xvii\nAcknowledgments..........................................................................................................xix\nAbout the Author.\n...........................................................................................................xxi\nChapter 1\t Introduction to Software Engineering Design.\n...........................................1\nChapter Objectives................................................................................................... 1\nConceptual Overview.............................................................................................. 1\nEngineering Design.\n................................................................................................. 2\nEngineering Problem Solving.\n................................................................................ 3\nInitial State.\n........................................................................................................... 4\nOperational State................................................................................................. 4\nThinking about the Problem......................................................................... 5\nProblem Solution............................................................................................ 6\nGoal State.............................................................................................................. 6\nSoftware Engineering Design................................................................................. 9\nWhy Study Software Engineering Design?......................................................... 10\nReasons for Studying Software Design in Product Development.............. 10\nReasons for Studying Software Design in Project Management................ 11\nSoftware Design Challenges.\n................................................................................. 11\nDesign Challenge 1: Requirements Volatility................................................ 12\nDesign Challenge 2: Process............................................................................ 12\nDesign Challenge 3: Technology..................................................................... 12\nDesign Challenge 4: Ethical and Professional Practices.............................. 13\nDesign Challenge 5: Managing Design Influences....................................... 13\nStakeholders.\n.................................................................................................. 14\nDevelopment Organization\u2019s Structure..................................................... 14\nContext of Software Design.................................................................................. 15\nSoftware Design Process.\n....................................................................................... 17\nSoftware Architecture....................................................................................... 18\nDetailed Design.\n................................................................................................. 19\nInterface Design............................................................................................ 19\nComponent Design.\n......................................................................................20\nConstruction Design.........................................................................................20\nHuman\u2013Computer Interface Design.\n............................................................. 21\nSoftware Design Documentation.................................................................... 21\nSoftware Design Management......................................................................... 21\nwww.allitebooks.com\n", "page": 9, "type": "text", "section": "Page 9"}
{"text": "viii\u2002 \u2022\u2002 Contents\nRoles of the Software Designer............................................................................. 22\nSystems Engineer............................................................................................... 23\nSoftware Architect............................................................................................. 23\nComponent Designer........................................................................................ 23\nSoftware Design Fundamentals.\n........................................................................... 24\nGeneral Software Design Principles............................................................... 24\nModularization............................................................................................. 25\nAbstraction.................................................................................................... 25\nEncapsulation................................................................................................ 26\nCoupling.\n........................................................................................................ 27\nCohesion.\n........................................................................................................ 28\nSeparation of Interface and Implementation............................................ 29\nCompleteness and Sufficiency.\n.................................................................... 30\nPractical Software Design Considerations.\n.................................................... 30\nDesign for Minimizing Complexity.\n.......................................................... 31\nDesign for Change........................................................................................ 31\nSoftware Design Strategies............................................................................... 31\nStructured Design.\n........................................................................................ 31\nObject-Oriented Design............................................................................... 32\nChapter Summary.................................................................................................. 32\nReview Questions................................................................................................... 33\nReferences................................................................................................................34\nChapter 2\t Software Design with Unified\u00a0Modeling Language.................................35\nChapter Objectives................................................................................................. 35\nConceptual Overview............................................................................................ 35\nWhat Is UML?.\n........................................................................................................ 36\nWhy Study UML?................................................................................................... 37\nThe UML\u2019s Fundamentals..................................................................................... 37\nStructural Modeling.\n..............................................................................................40\nComponent Diagrams...........................................................................................40\nLogical versus Physical Components.\n.............................................................42\nClass Diagrams....................................................................................................... 43\nClasses................................................................................................................. 43\nName Compartment....................................................................................44\nAttribute Compartment.\n..............................................................................44\nOperation Compartment.\n............................................................................ 45\nRelationships......................................................................................................46\nDependency................................................................................................... 47\nAssociation.\n.................................................................................................... 47\nAggregation...................................................................................................48\nComposition..................................................................................................48\nwww.allitebooks.com\n", "page": 10, "type": "text", "section": "Page 10"}
{"text": "Contents\u2002 \u2022\u2002 ix\nGeneralization............................................................................................... 49\nRealization..................................................................................................... 50\nDeployment Diagrams.\n.......................................................................................... 53\nBehavioral Modeling.\n............................................................................................. 55\nUse Case Diagrams................................................................................................ 55\nInteraction Diagrams.\n............................................................................................ 57\nCommunication Diagrams.............................................................................. 58\nSequence Diagrams........................................................................................... 59\nConcurrency in Interaction Diagrams........................................................... 59\nChapter Summary.................................................................................................. 63\nReview Questions................................................................................................... 63\nChapter Exercises...................................................................................................64\nReferences................................................................................................................ 65\nChapter 3\t Principles of Software Architecture.\n..........................................................67\nChapter Objectives................................................................................................. 67\nConceptual Overview............................................................................................ 67\nWhat Is Software Architecture?...........................................................................68\nWhy Study Software Architecture?..................................................................... 70\nKey Tasks in Architectural Design...................................................................... 70\nIdentifying Stakeholders\u2019 Concerns.\n............................................................... 71\nIdentifying Appropriate Architectural Views............................................... 71\nIdentifying Architectural Styles and Patterns............................................... 71\nIdentifying System Interfaces.......................................................................... 72\nIdentifying Impact of Architectural Decisions in Organization................ 72\nImpact on Customer Base.\n........................................................................... 73\nImpact on Budget and Schedule................................................................. 73\nImpact from Resource Availability.............................................................74\nIdentifying the System\u2019s Major Components and Interfaces.......................74\nEvaluating and Validating the Architecture.\n..................................................74\nIntroducing Policies for Design Synchronicity............................................. 75\nProblem Solving in Software Architecture......................................................... 76\nInputs.\n.................................................................................................................. 77\nConstraints......................................................................................................... 77\nOutputs............................................................................................................... 77\nSoftware Architecture Process............................................................................. 78\nUnderstand and Evaluate Requirements.\n............................................................ 79\nElicitation.\n........................................................................................................... 79\nRequirement Sources.\n................................................................................... 79\nElicitation Techniques.................................................................................. 81\nAnalysis............................................................................................................... 82\n", "page": 11, "type": "text", "section": "Page 11"}
{"text": "x\u2002 \u2022\u2002 Contents\nSpecification and Validation............................................................................84\nSpecific.\n........................................................................................................... 85\nCorrect.\n........................................................................................................... 86\nComplete........................................................................................................ 86\nConsistent...................................................................................................... 87\nAttainable.\n...................................................................................................... 87\nVerifiable........................................................................................................ 88\nDesigning the Architecture.\n.................................................................................. 88\nThe 4 + 1 View Model....................................................................................... 89\nUser View....................................................................................................... 89\nProcess View.\n.................................................................................................90\nPhysical View.\n................................................................................................90\nDevelopment View.\n....................................................................................... 91\nLogical View.................................................................................................. 91\nComponents and Connectors.......................................................................... 92\nDesigning Logical Architectural Elements Using Data Flows.\n................... 92\nDesigning Logical Architectural Elements Using Styles and Patterns...... 93\nDesigning the Process Architecture............................................................... 93\nProcesses........................................................................................................ 93\nThreads........................................................................................................... 94\nEvaluating the Architecture.\n............................................................................... 103\nChapter Summary................................................................................................ 104\nReview Questions................................................................................................. 105\nChapter Exercises................................................................................................. 106\nReferences.............................................................................................................. 106\nChapter 4\t Patterns and Styles in Software Architecture......................................... 107\nChapter Objectives............................................................................................... 107\nConceptual Overview.......................................................................................... 107\nArchitectural Styles and Patterns...................................................................... 108\nHistory of Architectural Styles and Patterns.\n.............................................. 108\nArchitectural Pattern Classification............................................................. 109\nData-Centered Systems.\n........................................................................................111\nBlackboard Pattern...........................................................................................111\nData Flow Systems.\n................................................................................................116\nPipe and Filter Pattern.....................................................................................116\nDistributed Systems.............................................................................................120\nClient\u2013Server Pattern......................................................................................120\nBroker Pattern.................................................................................................. 122\nInteractive Systems.\n.............................................................................................. 127\nModel\u2013View\u2013Controller Pattern.\n.................................................................. 127\n", "page": 12, "type": "text", "section": "Page 12"}
{"text": "Contents\u2002 \u2022\u2002 xi\nHierarchical Systems.\n........................................................................................... 131\nMain Program and Subroutine.\n..................................................................... 131\nLayered Pattern................................................................................................ 133\nChapter Summary................................................................................................ 136\nReview Questions................................................................................................. 136\nChapter Exercises................................................................................................. 137\nReferences.............................................................................................................. 137\nChapter 5\t Principles of Detailed Design.\n.................................................................. 139\nChapter Objectives............................................................................................... 139\nConceptual Overview.......................................................................................... 139\nWhat Is Detailed Design?.\n................................................................................... 140\nKey Tasks in Detailed Design............................................................................. 142\nDetailed Design Process...................................................................................... 142\nUnderstanding the Architecture and Requirements.\n...................................... 143\nCreating Detailed Designs.................................................................................. 144\nInterface Design............................................................................................... 144\nExternal Interface Design.......................................................................... 144\nInternal Interface Design.\n.......................................................................... 145\nGraphical User Interface Design.............................................................. 145\nDesigning Internal Structure of Components.\n............................................ 145\nClasses.......................................................................................................... 146\nInterfaces, Types, Subtypes, Dynamic Binding, and Polymorphism.... 147\nObjects.......................................................................................................... 148\nDesign Principles for Internal Component Design.................................... 149\nOpen\u2013Closed Principle.............................................................................. 149\nLiskov Substitution Principle.................................................................... 156\nInterface Segregation Principle................................................................. 157\nProgramming Styles in Detailed Design.\n..................................................... 159\nFunction Names.\n......................................................................................... 160\nVariable Names........................................................................................... 162\nModeling Internal Behavior of Components.\n.............................................. 164\nDesign Components Using Design Patterns............................................... 166\nArchitectural versus Design Patterns...................................................... 167\nClassification of Design Patterns.............................................................. 167\nDocumenting Design Patterns.\n................................................................. 168\nDocument the Software Design......................................................................... 169\nInterface Control Document.\n......................................................................... 171\nSoftware Version Document.......................................................................... 172\nMonitor and Control Implementation.............................................................. 173\nChapter Summary................................................................................................ 173\nReview Questions..................................................................................................174\n", "page": 13, "type": "text", "section": "Page 13"}
{"text": "xii\u2002 \u2022\u2002 Contents\nChapter Exercises................................................................................................. 175\nReferences.............................................................................................................. 175\nChapter 6\t Creational Design Patterns in Detailed Design...................................... 177\nChapter Objectives............................................................................................... 177\nConceptual Overview.......................................................................................... 177\nCreational Design Patterns................................................................................. 178\nAbstract Factory................................................................................................... 178\nProblem............................................................................................................. 179\nStructure........................................................................................................... 179\nImplementation.\n................................................................................................181\nBenefits.............................................................................................................. 188\nFactory Method.................................................................................................... 188\nProblem............................................................................................................. 189\nStructure........................................................................................................... 189\nImplementation.\n............................................................................................... 191\nBenefits.............................................................................................................. 192\nBuilder.\n................................................................................................................... 193\nProblem............................................................................................................. 195\nStructure........................................................................................................... 195\nImplementation.\n............................................................................................... 197\nBenefits.............................................................................................................. 197\nPrototype............................................................................................................... 201\nProblem............................................................................................................. 201\nStructure...........................................................................................................204\nImplementation.\n...............................................................................................205\nBenefits..............................................................................................................207\nSingleton................................................................................................................207\nProblem.............................................................................................................208\nStructure...........................................................................................................208\nImplementation.\n...............................................................................................209\nBenefits...............................................................................................................211\nChapter Summary.................................................................................................211\nReview Questions..................................................................................................211\nChapter Exercises................................................................................................. 212\nReference.\n................................................................................................................214\nChapter 7\t Structural and Behavioral\u00a0Patterns in Detailed Design.\n........................ 215\nChapter Objectives............................................................................................... 215\nConceptual Overview.......................................................................................... 215\nStructural Design Patterns.\n..................................................................................216\n", "page": 14, "type": "text", "section": "Page 14"}
{"text": "Contents\u2002 \u2022\u2002 xiii\nAdapter...................................................................................................................216\nProblem............................................................................................................. 217\nStructure........................................................................................................... 219\nImplementation.\n............................................................................................... 219\nBenefits.............................................................................................................. 221\nComposite.\n.............................................................................................................223\nProblem.............................................................................................................224\nStructure...........................................................................................................225\nImplementation.\n...............................................................................................227\nBenefits.............................................................................................................. 231\nFacade.\n.................................................................................................................... 232\nProblem.............................................................................................................234\nStructure........................................................................................................... 235\nImplementation.\n............................................................................................... 237\nBenefits..............................................................................................................238\nBehavioral Design Patterns.\n................................................................................238\nIterator.\n...................................................................................................................238\nProblem............................................................................................................. 239\nStructure........................................................................................................... 241\nImplementation.\n...............................................................................................245\nBenefits.............................................................................................................. 251\nObserver.\n................................................................................................................ 252\nProblem............................................................................................................. 252\nStructure........................................................................................................... 252\nImplementation.\n...............................................................................................254\nBenefits..............................................................................................................254\nChapter Summary................................................................................................256\nReview Questions.................................................................................................256\nChapter Exercises................................................................................................. 257\nReference.\n...............................................................................................................258\nChapter 8\t Principles of Construction Design.\n.......................................................... 259\nChapter Objectives............................................................................................... 259\nConceptual Overview.......................................................................................... 259\nWhat Is Construction Design?........................................................................... 259\nWhy Study Construction Design?.....................................................................260\nBehavioral Construction Design.\n....................................................................... 261\nFlow-Based Designs.\n........................................................................................ 261\nState-Based Designs.\n........................................................................................262\nTable-Based Designs.\n.......................................................................................264\nLimited-Entry Decision Table...................................................................266\nExtended-Entry Decision Table................................................................268\n", "page": 15, "type": "text", "section": "Page 15"}
{"text": "xiv\u2002 \u2022\u2002 Contents\nMixed-Entry Decision Table..................................................................... 270\nTable-Based Construction......................................................................... 270\nProgramming Design Language................................................................... 271\nSoftware Construction Using Styles.................................................................. 274\nFormatting Conventions................................................................................ 275\nIndentation.................................................................................................. 276\nBrace Placement.......................................................................................... 278\nNaming Conventions...................................................................................... 279\nDocumentation Conventions.\n........................................................................282\nDocumenting Files.....................................................................................282\nDocumenting Functions............................................................................282\nMinimizing Complexity in Construction Design...........................................283\nQuality Evaluation of Construction Design.\n....................................................284\nPeer Reviews.....................................................................................................285\nUnit Testing......................................................................................................286\nCyclomatic Complexity..................................................................................286\nChapter Summary................................................................................................290\nReview Questions.................................................................................................290\nChapter Exercises................................................................................................. 291\nReferences..............................................................................................................292\nChapter 9\t Human\u2013Computer Interface Design....................................................... 293\nJacob Somervell\nChapter Objectives............................................................................................... 293\nConceptual Overview.......................................................................................... 293\nWhat Is Human\u2013Computer Interface Design?................................................294\nWhy Study Human\u2013Computer Interface Design?..........................................294\nGeneral HCI Design Principles..........................................................................297\nHuman\u2013Computer Interface Design Methods................................................299\nGetting Started.\n................................................................................................299\nFidelity in Prototypes.\n.....................................................................................300\nMetaphors......................................................................................................... 301\nGestalt Principles.............................................................................................303\nReusing Earlier Designs.\n.................................................................................305\nEvaluation of HCI Quality..................................................................................305\nUsability Testing..............................................................................................305\nAnalytic Testing.\n..............................................................................................306\nEmpirical Testing.\n............................................................................................307\nChapter Summary................................................................................................309\nReview Questions.................................................................................................309\nChapter Exercises.................................................................................................309\nReferences...............................................................................................................310\n", "page": 16, "type": "text", "section": "Page 16"}
{"text": "Contents\u2002 \u2022\u2002 xv\nChapter 10\tSoftware Design Management, Leadership, and Ethics......................... 311\nLuis Daniel Otero\nChapter Objectives................................................................................................311\nConceptual Overview...........................................................................................311\nWhat Is Software Design Management?........................................................... 312\nWhy Study Design Management?...................................................................... 312\nThe Concept of Quality....................................................................................... 312\nDesign Management Framework....................................................................... 313\nPlanning Design Efforts.......................................................................................314\nScoping.............................................................................................................. 315\nWork Breakdown Structure...................................................................... 315\nBudgeting......................................................................................................316\nOrganizing.\n........................................................................................................317\nLinear Responsibility Chart.......................................................................318\nScheduling with Gantt Charts and Network Diagrams.\n........................318\nProbability of Time to Completion.......................................................... 322\nEstablish Change Control Policy.\n..................................................................324\nImplementation Phase......................................................................................... 325\nEarned Value Management............................................................................ 326\nTermination Stage................................................................................................ 329\nLeading the Design Effort................................................................................... 329\nPersonality Traits and Leadership.\n................................................................ 329\nPersonality Dimensions.................................................................................. 329\nTraits of Effective Leaders.............................................................................. 330\nEthical Leadership........................................................................................... 330\nPower..................................................................................................................331\nKey Leadership Skills........................................................................................... 332\nCommunication Skills.................................................................................... 332\nNetworking Skills............................................................................................ 333\nMotivation Skills.\n............................................................................................. 333\nNegotiation Skills............................................................................................ 334\nEthics in Software Design................................................................................... 335\nPublic and Product Principles....................................................................... 335\nJudgment Principle.......................................................................................... 336\nManagement Principle.................................................................................... 336\nChapter Summary................................................................................................ 336\nReview Questions................................................................................................. 338\nChapter Exercises................................................................................................. 339\nReferences..............................................................................................................340\n", "page": 17, "type": "text", "section": "Page 17"}
{"text": "xvii\nThis book is the result of an effort that I began in 2010 at the University of Virginia\u2019s \nCollege at Wise to create a course in software engineering design consistent with the 2004 \nIEEE/ACM curriculum guidelines for undergraduate programs in software engineering \n(SE). In a broad context, the recommended topics for undergraduate SE programs include \ndesign concepts, design strategies, architectural design, detailed design, human\u2013computer \ninterface design, and design evaluation. As a former industry practitioner, I learned first-\nhand the difference between hearing or \u201clearning\u201d about these topics and developing the \nnecessary skills to apply them in a way that adds value to some development team, pro-\ngram, project, or business. With that in mind, I set out to compile material that I could \nuse (from previous industry experience) to help students become proficient in design-\ning software-intensive systems. Throughout the process, many of the original examples \nconsidered dry or hard to follow by students were replaced with new problem domains \n(e.g.,\u00a0 gaming\u00ad\n systems) that helped students assimilate the concepts better. Because of \nthe \u201chands-on\u201d approach required to master these concepts, the teaching style evolved \nto emphasize both theory and practice. The theory portion was used to present accept-\nable general design principles or a body of design principles to explain successful software \n\u00ad\nsystems\u2019 designs. The practice portion provided the avenue for transforming design theory \ninto skills that can be employed directly to real-life industrial settings. The knowledge \nand experience gained from these efforts have been captured in this textbook, which can \nbe useful for both industry practitioners and students in software engineering, computer \n\u00ad\nscience, and information technology programs.\nINTRODUCTION\nThis book provides an introduction to the essential concepts employed by software engi-\nneers who design large-scale, software-intensive systems in a professional environment. \nIt\u00a0bridges the gap between industry and academia by providing students with a comprehen-\nsive view of software design using industry-proven concepts for designing \u00ad\ncomplex software \nsystems. Its unique blend of theory and practice provides both students and industry prac-\ntitioners with key concepts that are immediately relevant to today\u2019s software designers. The \nbook contains examples, review questions, and chapter exercises carefully selected to bring \nreal-world problems into a classroom environment. More importantly, it\u00a0incorporates an \neffective learn-by-doing approach that allows students to transform design theory into the \nskills required to design complex software systems. The book starts by providing a general \noverview of software design, including the fundamentals of software design, the importance \nof studying software design, and different practical concepts used for designing software.\nPreface\n", "page": 19, "type": "text", "section": "Page 19"}
{"text": "xviii\u2002 \u2022\u2002 Preface\nAs part of the introductory material, the software engineering process is covered briefly \nto provide the context in which software design takes place and a formal top-down design \nprocess is presented. The top-down approach consists of several design phases and activi-\nties that occur at varied levels of detail/abstraction, including the software architecture, \ndetailed design, and construction design. As part of the top-down approach, detailed \ncoverage of applied architectural, creational, structural, and behavioral design patterns is \nprovided and a collection of standards and guidelines for structuring high-quality code \nis presented. The book also provides techniques for evaluating software design quality at \ndifferent stages and much needed coverage of management and engineering leadership \nfor software designers. This provides software engineers with the necessary management, \n\u00ad\nethical, and leadership knowledge required to build products for the public domain. The \nbook also provides coverage of the software design document and other forms of documen-\ntation important during the design of software systems. Collectively, the book comprehen-\nsively introduces students and practitioners to software engineering design and provides \nthe knowledge required to emerge and succeed as tomorrow\u2019s professional design leaders.\nUSE AS A TEXTBOOK\nThe textbook provides a comprehensive (sophomore-level) introduction to required con-\ncepts in software design. When used as textbook, instructors are encouraged to visit the \ntextbook website to download slides, the solutions manual, and other exercises developed \nas part of the ongoing effort to improve education in software engineering design. The \nmaterial presented in the book\u2019s 10 chapters can be easily extended to 16 weeks, espe-\ncially when covering the topics of design patterns. A recommended approach includes \nconducting microdesign reviews, where students (or student groups) design, implement, \nand present\u00ad\n their work regularly, while other students evaluate, critique, and provide \npeer-review comments. Because of the nature of the topics covered, students are expected \nto meet the following prerequisites:\n\u2022\t Introduction to Programming (with object-oriented language)\n\u2022\t Data Structures and Algorithms\n\u2022\t Introduction to Software Engineering\nUltimately, the most important feature of software designs is their applicability to build \nsoftware; therefore, the course should require students to implement a large portion of \nthe designs created as part of the course. A recommended approach (when possible) is to \nadopt a unified modeling language (UML) modeling tool capable of forward and reverse \nengineering and use the textbook as a guide for creating and assigning design problems \ncentered around the topics discussed throughout the book, since they are essential to all \nsoftware engineering students from ABET-accredited programs.\nwww.allitebooks.com\n", "page": 20, "type": "text", "section": "Page 20"}
{"text": "xix\nMany people have contributed to this effort in one way or another. First, I would like to \nthank Dr. Jacob Somervell from the University of Virginia\u2019s College at Wise, and Dr.\u00a0Luis \nDaniel Otero from Florida Institute of Technology for providing the material for Chapters \n9 and 10, respectively. Your work made the overall product complete, and many \u00ad\nstudents \nand practitioners will benefit from your contributions. I also thank Dr. Ira Weissberger \nfrom Harris Corporation for his contribution on the section on software design docu-\nmentation in Chapter 5 and Stefan Joe-Yen from Northrop Grumman Corporation for his \ncontribution to the architectural patterns chapter. I would also like to thank the reviewers \nand staff at Taylor & Francis\u2014in particular John Wyzalek\u2014for their help throughout this \nlong process. Finally, and most importantly, I thank my wife, Kelly, and children Allison, \nAmanda, Michael, and Ashley, for their sacrifices, patience, and support.\nAcknowledgments\n", "page": 21, "type": "text", "section": "Page 21"}
{"text": "xxi\nCarlos E. Otero, PhD, is assistant professor in the College of Technology and Innovation \nat the University of South Florida Polytechnic (USFP). Prior to joining USFP, Dr. Otero \nworked as assistant professor of software engineering in the Department of Mathematics \nand Computer Science at the University of Virginia\u2019s College at Wise, where he created \nthe software engineering design course for Virginia\u2019s first and (at the time of writing) only \nABET-accredited BS in software engineering.\nPrior to his academic career, Dr. Otero spent 11 years in the private industry, where \nhe worked as design and development engineer in a wide variety of military computer \n\u00ad\nsystems, including satellite communications systems, command and control systems, \nwireless security systems, and unmanned aerial vehicle systems. Currently, he continues \nto consult with industry in the areas of requirements engineering, software systems design \nand development, quality assurance, and mobile systems engineering.\nDr. Otero received his BS in computer science, MS in software engineering, MS in \u00ad\nsystems \nengineering, and PhD in computer engineering from Florida Institute of Technology in \nMelbourne. He has published over 25 technical publications in \u00ad\nscientific peer-reviewed \njournals and conferences proceedings. He is a senior member of the IEEE, a\u00a0science \u00ad\nadvisor \nfor the National Aeronautics and Space Administration (NASA) DEVELOP program, an \nactive professional member of the Association for Computing Machinery (ACM), and a \nmember of several journal editorial boards in technology and engineering.\nAbout the Author\n", "page": 23, "type": "text", "section": "Page 23"}
{"text": "1\n1\nIntroduction to Software \nEngineering Design\nCHAPTER OBJECTIVES\n\u2022\t Understand software design from the engineering perspective\n\u2022\t Understand the importance of software design in developing com-\nplex products\n\u2022\t Understand the issues that make software design challenging\n\u2022\t Understand the software design process and differentiate between \nits activities\n\u2022\t Become familiar with software design principles, considerations, and \nstrategies\nCONCEPTUAL OVERVIEW\nSoftware design is an indispensable phase of the software engineering pro-\ncess for creating and evaluating software models that guide the construc-\ntion effort for developing high-quality software systems on time and within \nbudget. Conceptually, design is the process of transforming functional and \nnonfunctional requirements into models that describe the technical solution \nbefore construction begins. To achieve this, the concept of software design, \nits activities, and tasks must be well understood so that a problem-solving \nframework for designing quality into software products can be established. \nIn today\u2019s modern software systems, there are numerous design principles, \nprocesses, strategies, and other factors affecting how designers execute the \nsoftware design phase. When equipped with the proper design foundation \nknowledge, an understanding of the designer\u2019s roles and responsibilities \n", "page": 25, "type": "text", "section": "Page 25"}
{"text": "2\u2002 \u2022\u2002 Software Engineering Design\ufeff\ncan be acquired, allowing designers to become effective in designing large-scale software \nsystems under a wide variety of challenging conditions. This chapter presents the funda-\nmental concepts of software engineering design, within context, and provides the motiva-\ntion for the rest of the book.\nENGINEERING DESIGN\nDesign is an integral part of every engineering discipline. Airplanes, bridges, buildings, \nelectronic devices, cars, and many other products of similar complexity are all designed. \nIn civil engineering, designs are used to specify detailed plans for developing physical and \nnaturally built environments, such as bridges, roads, canals, dams, and buildings. In elec-\ntrical engineering, designs are used to capture, evaluate, and specify the detailed qualita-\ntive and quantitative description of solutions for telecommunication systems, electrical \nsystems, and electronic devices. In mechanical engineering, designs are used for analyzing, \nevaluating, and specifying technical features required to construct machines and tools, \nsuch as industrial equipment, heating and cooling systems, aircrafts, robots, and medical \ndevices. In all other engineering disciplines, design provides a systematic approach for \ncreating products that meet their intended functions and users\u2019 expectations. Formally, \nDym\u00a0and Little (2008, p. 6) define engineering design as\nA systematic, intelligent process in which designers generate, evaluate and specify designs for \ndevices, systems or processes whose form(s) and function(s) achieve clients\u2019 objectives and \nusers\u2019 needs while satisfying a specified set of constraints.\nDesign is a lengthy and complex process requiring significant investments in time and \neffort. So why conduct design in engineering disciplines? There are many possible answers \nto this question, stemming from simple common sense to more complicated ones involv-\ning professional, ethical, social, and legal implications. From the commonsense perspec-\ntive, products of such complexity are hard to create, are costly to change, and, when built \ncarelessly or incorrectly, can significantly impact human life. When working toward the \ncreation of complex products, teams must organize in a disciplined manner, and a sys-\ntematic approach needs to be employed to carefully ensure that products are built to meet \ntheir specifications. Consider the construction of a bridge that spans over a body of water \nand is required to support a particular weight, to maintain access to watercrafts navigating \nunderneath, to withstand expected wind speeds, and to provide other features such as side-\nwalks\u2014all while being bound by a schedule and budget. The successful construction of such \na bridge is a nontrivial task and requires years of experience, formal education, and large \nteams collaborating together to achieve the construction goals. If constructed incorrectly\u00ad\n, \nreconstructing the bridge can skyrocket from its original construction cost; worse yet, \nif defects are undetected, the bridge could collapse, resulting in the catastrophic loss of \nhuman life. Similar to the construction of the bridge, teams engineering other products, \n", "page": 26, "type": "text", "section": "Page 26"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 3\nsuch as airplanes, watercrafts, medical devices, and safety-critical software \u00ad\nsystems, share \ncomparable challenges, and failure of these products can also result in \u00ad\ncatastrophic events. \nIn an engineering environment, before product construction begins, the design of prod-\nucts needs to be carefully and extensively planned, evaluated, verified, and validated to \nensure the product\u2019s success. This is mainly achieved through design.\nENGINEERING PROBLEM SOLVING\nThroughout the design process, designers are constantly engaging in problem-solving activ-\nities that are fundamental to all modern engineering projects. In a broad sense, engineers \ncan be characterized as specialized problem solvers. Their work requires them to identify, \nevaluate, and propose solutions to complex problems (in particular domains) under tight \nproject constraints. In some situations, engineers tackle problems that have never been \nsolved before, creating challenges to meet not only functional aspects of products but also \ntheir established schedule and budget. Before engaging in more concrete design topics, a \nformal discussion on problem solving is necessary to identify fundamental concepts that \nare well understood by successful designers; these serve as basis for establishing a holistic \nproblem solving framework that can be employed any time during design.\nTo become a good designer, engineers must be good problem solvers. This may require \nyears of experience solving problems in a particular domain. In many cases, experience \nallows engineers to reuse already proven solutions across separate but similar problems. \nIn other cases, where unsolved problems are encountered, designers are required to \n\u201cthink\u00a0out of the box\u201d and carefully craft a systematic approach for solving the problem in \nan acceptable manner, which may require problem classification, identification of the solu-\ntion approach and type of adequate solution, and identifying the overall strategy for reach-\ning its solution. In a general sense, problem solving during design occurs in three different \nstates (Plotnik and Kouyoumdjian 2010):\n\u2022\t Initial state\n\u2022\t Operation state\n\u2022\t Goal state\nThrough these states, designers employ several techniques and strategies to create a \nlandscape suitable for problem solving. The initial state is where problems are formulated \nand interpreted. In some cases, achieving full understanding of the problem is a problem \nitself. Once problems are well understood, designers move to the operational state, where \nthinking about the problem occurs and viable solutions come to light. Once an appropri-\nate solution is identified, evaluated, and validated, designers move to the goal state, where \na final solution to the problem is found, marking the end of the problem-solving process.\n", "page": 27, "type": "text", "section": "Page 27"}
{"text": "4\u2002 \u2022\u2002 Software Engineering Design\ufeff\nInitial State\nDesign problems are not all the same; they vary in size, complexity, and, based on these \ncharacteristics, the amount of time and effort required for their solution. In some cases, it \nquickly becomes evident that certain problems are harder to solve than others. When this \ndetermination is made, the strategy for the solution approach is adjusted to account for \nthe additional complexity. Being able to differentiate between types of problem is crucial \nin helping designers account for the amount of effort, time, and risk associated with the \nsolution approach. Therefore, an important problem-solving skill involves identifying and \nclassifying the type of problem encountered, which includes well-defined, ill-defined, and \nwicked problems, as presented in Table\u00a01.1 (Giachetti 2010).\nWell-defined problems have clear defined goals and their constraints are well under-\nstood. This makes scoping the problem, proposing a solution approach, and arriving at \nthe solution easier than with other types of problems, such as ill-defined and wicked \nproblems. Ill-defined problems are problems where the mere interpretation of the prob-\nlem is a problem itself; they are ambiguous with undefined goals and require more time \nand effort to clarify and interpret the problem to arrive at a solution. In some cases, with \nadditional effort, ill-defined problems can be transformed into well-defined problems. \nFinally, wicked problems are problems where no single problem formulation exists. There \nmay be many acceptable formulations of the problem and no definite solutions, and solu-\ntions are not deemed correct or incorrect but good or bad (Giachetti 2010). In\u00a0many cases, \nwicked problems can lead to contradictive goals that need additional resolution before the \nproblem solving can occur. When contradictive goals are present, providing a solution \nto one part of the problem results in the inability of solving other parts of the problem. \nIn these types of problem, optimal solutions are hard to find, requiring additional strug-\ngle and collaborative brainstorming. Also, evaluation of alternative designs may require \nadvanced techniques to determine the best course of action, which tends to require more \ntime. In many cases, the solution to wicked problems is not known until after the problem \nis solved.\nOperational State\nThe operational state of problem solving is where thinking about the problem solution \ntakes place. It requires employing multiple techniques for problem solving such as using \nmetaphors, decomposing problems into smaller, less complex problems (i.e., divide and \nconquer), reusing solutions (e.g., patterns), and so forth. In all of the techniques, designers \nTABLE\u00a01.1\nProblem Classification\nProblem\nDescription\nWell-defined\nProblem with clear goals and known constraints\nIll-defined\nProblem with undefined or ambiguous goals and unknown constraints\nWicked\nProblem with no definite solution; not understood until after the formulation of its solution\n", "page": 28, "type": "text", "section": "Page 28"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 5\nare expected to exhibit a \u201cthink outside the box\u201d mentality to be able to solve complex \nproblems. This requires shifting the mental model from a conventional approach to uncon-\nventional methodology where solutions to complex problems may arise from thinking in \nways that deviate from conventional wisdom. For example, consider the popular nine-dot \npuzzle illustrated in Figure\u00a01.1 (Kershaw and Ohlsson 2004).\nThe requirements for solving the nine-dot puzzle problem are as follows:\n\t\n1.\tDraw four straight lines to connect all dots.\n\t\n2.\tThe pencil cannot be lifted from the paper once the line-drawing process begins.\n\t\n3.\tNo lines can be retraced.\nBefore moving on, think about this problem and attempt to provide a solution. At first, \nthis may seem difficult because of the tendency of fixing the mental process to operate on \nthe assumption that lines should begin and end on a dot. This functional fixedness limits \nthe ability to find solutions based on objects having a different function from their usual \nones (Plotnik and Kouyoumdjian 2010). In the case of the nine-dot puzzle, for some, func-\ntional fixedness makes it awkward or even impossible to propose solutions that involve lines \ngoing past the dots, which is what is required to solve this problem. To increase the chance \nof overcoming functional fixedness, problems need to be attempted several times and con-\nsidered from many different viewpoints and unusual angles (Plotnik and Kouyoumdjian). \nOvercoming functional fixedness is critical for designers attempting to provide solutions \nat the operational state of problem solving.\nThinking about the Problem\nDifferent types of thinking take place when finding solutions to problems. For example, \nwhen learning about a problem for the first time, problem solvers may begin by asking \nquestions, which allows them to think about many different alternative solutions; as the \nproblem-solving process moves forward, problem solvers can begin narrowing down the \npossibilities and think about the single best solution to the problem. These types of think-\ning are known as convergent thinking and divergent thinking (Table 1.2).\nBoth convergent and divergent thinking have significant roles in solving engineering \nproblems. In many cases, problem solvers begin using divergent thinking with different \nlevels of abstraction, and each level provides finer-grained solutions to the problem until \nconvergent thinking can be employed to solve it.\nFIGURE 1.1\nThe nine-dot puzzle.\n", "page": 29, "type": "text", "section": "Page 29"}
{"text": "6\u2002 \u2022\u2002 Software Engineering Design\ufeff\nProblem Solution\nIn many cases, determining the type of solution required for a given problem can reduce \nwasted time and effort spent in attempting to find a single, optimal solution. In such cases, \ndesigners can elect to seek approximate solutions\u2014as opposed to optimal solutions\u2014that \nare appropriate and acceptable for meeting project constraints. Determining the type of \nsolution for a given problem can reduce time and budget required for building the system. \nTwo types of solutions are algorithms and heuristics, as presented in Table\u00a01.3.\nAlgorithms are step-by-step procedures for finding the correct solution to given prob-\nlems. Algorithms do not normally involve subjective decisions or rely on intuition or \n\u00ad\ncreativity to find solutions (Brassard and Bratley 1995). For some types of problems, using \nalgorithms to find solutions can be unrealistic, especially in time-driven, practical engi-\nneering problems. In these cases, heuristics provide a realistic approach for finding good \napproximations of the solution. In some cases, heuristics can lead to optimal solutions; in \nothers, they can lead to solutions that are far from optimal or no solution at all (Brassard \nand Bratley 1995). Algorithms and heuristics are both used heavily in the design of engi-\nneering systems and determining their appropriateness for solving particular problems is \nessential to meeting other project demands.\nGoal State\nThe goal state represents the final state of problem solving. It is where adequate solutions \nto given problems are determined. For many engineering problems, reaching the goal state \nis a nontrivial task that requires careful attention to all important aspects of the problem. \nThe concepts of initial, operational, and goal state can be fused together to create a holistic \nproblem-solving framework adequate to solving engineering problems at all stages of the \ndevelopment effort. The approach consists of the following tasks:\n\u2022\t Interpret problem\n\u2022\t Evaluate constraints\n\u2022\t Collaborative brainstorming\nTABLE\u00a01.2\nTypes of Thinking\nType\nDescription\nConvergent thinking\nType of thinking that seeks to find one single solution to a problem\nDivergent thinking\nType of thinking that seeks to find multiple solutions to a problem\nTABLE\u00a01.3\nTypes of Problem Solution\nProblem\nDescription\nAlgorithm\nFixed set of rules that lead to the solution of a problem\nHeuristic\nRules of thumb (or procedure) that may or may not lead to the solution of a problem\nwww.allitebooks.com\n", "page": 30, "type": "text", "section": "Page 30"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 7\n\u2022\t Synthesize possibilities\n\u2022\t Evaluate solution\n\u2022\t Implement solution\nThe first task of the problem-solving approach involves interpreting the problem. This \nis where problem information is received and processed; problem classification is identi-\nfied (e.g., well-defined, ill-defined) and activities are performed to formulate the problem. \nInterpreting the problem is a task performed during the initial state of problem solving. \nDuring the initial state, identification of stakeholders\u2014persons, groups, or organizations \nthat have direct or indirect stake in the problem and its solution\u2014is essential. Once the \nproblem is formulated, the evaluate constraints task is used to identify external problem con-\nstraints, which are negotiated, integrated, and used to set the bounds on the solution land-\nscape. Once the problem and constraints are well understood, collaborative \u00ad\nbrainstorming \ncan begin among problem solvers and stakeholders. During collaborative brainstorming, \nproblem solvers use mostly divergent thinking to come up with alternative solutions that \nmay bring to light new knowledge, which can trigger a transition back to the problem inter-\npretation task. Once a set of acceptable solutions is identified, problem solvers synthesize \npossibilities to form the acceptable proposed solution to the problem. During this task, prob-\nlem solvers shift from divergent thinking to convergent thinking to propose the best-known \nsolution to the problem. The solution is shared and evaluated by everyone involved in the \nproblem-solving process. Flaws in the solution may trigger a transition back to the collab-\norative brainstorming task; otherwise, implementation begins. Collaborative brainstorming, \nsynthesize possibilities, and evaluate solutions are all tasks performed as part of the opera-\ntional state of problem solving. During implementation, the proposed solution is executed \nuntil the problem is solved, which is a task performed during the goal state of problem solv-\ning. Together, these tasks are combined with other problem variables to provide a holistic \napproach to problem solving (Harrell, Ghosh, and Bowden 2004), as presented in Figure\u00a01.2.\nAs seen in the figure, inputs are items that require processing during problem solving. \nInputs come from many different sources and are interpreted and formulated for particu-\nlar problems. They drive all activities by specifying the overarching need that promotes \nthe execution of the problem-solving tasks. Constraints are external properties that come \ninherent with any problem and limit the solution approach. Outputs are the expected \noutcome in problem solving. In many engineering projects, merely coming up with the \nsolution to a given problem is not enough, since the solution needs to be documented, \nformatted, decorated, specified in graphical model format, or placed under configuration \nmanagement. Outputs coming out of the problem-solving process need to meet the appro-\npriate standards as defined by the developing organization. The development organization \nmay also set standards for activities, controls, and resources, which all impact problem \nsolving. These variables are presented in Table\u00a01.4.\nActivities are internal tasks determined by the development organization that must be \nfollowed when solving problems. These are intended to help manage the problem-solving \napproach and may include review activities at different stages of problem solving, includ-\ning preliminary and detailed stages, status reports, and documentation, which all impact the \n", "page": 31, "type": "text", "section": "Page 31"}
{"text": "8\u2002 \u2022\u2002 Software Engineering Design\ufeff\ntime required to solve the problem. Controls, on the other hand, are internal constraints set by \nthe development organization that limit the possible solutions so that they align well with the \norganizational goals and current practices. These controls can dictate when and where prob-\nlem solving takes place, selection of strategies, permitted tools, personnel allowed to engage in \nproblem solving, and measures for quality control. Finally, resources are the means by which \nactivities are performed, which include people, software, and hardware, and their availability, \nwhich all impact problem solving. Together, all of these variables mix together to define the \nproblem-solving landscape, which must be considered when tackling engineering problems.\nSkill Development 1.1: Using the Holistic Approach in Problem Solving\nUse and document all the steps of the holistic problem-solving approach presented in \nFigure\u00a01.2 to solve the following problem. If possible, do this exercise as a team. The \nproblem specification is as follows: there are six equal matches; connect each match to \nform four equilateral triangles. When done, explain how functional fixedness played a \nrole in preventing you from arriving at the solution to this problem. \nTABLE\u00a01.4\nProblem-Solving Process Variables\nPhase\nDescription\nActivities\nOne or more tasks identified and required to solve the problem\nResources\nMeans by which activities are performed\nControls\nInternal properties of the organization that place bounds on the solution, or the solution process, \nfor the problem\nEvaluate\nConstraints \nSynthesize\nPossibilities\nInterpret\nProblem\nEvaluate \nInputs \nConstraints \nOutputs \nCollaborative\nBrainstorming\nImplement \nGeneric Design Problem \nResources \nActivities \nControls \nFIGURE 1.2\nHolistic approach to problem solving.\n", "page": 32, "type": "text", "section": "Page 32"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 9\nSOFTWARE ENGINEERING DESIGN\nIn the previous sections, design was introduced as a systematic and intelligent process for \ngenerating, evaluating, and specifying designs for devices, systems, or processes. To support \nthis process, the problem-solving skill was identified as an essential ingredient for design-\ning complex products. These discussions provided a general perspective on the impor-\ntance of these concepts in the engineering profession. As in other engineering disciplines, \ndesign and problem-solving are crucial to the development of professional, large-scale, \nsoftware systems. Software systems are highly complex, difficult to create, costly to change, \nand\u2014depending on the software product\u2014critical to human safety. Similarly to other \nengineering disciplines, designs in software engineering are used to identify, evaluate, and \nspecify the structural and behavioral characteristics of software systems that adhere to \nsome specification. Software designs provide blueprints that capture how software systems \nmeet their required functions and how they are shaped to meet their intended quality. \nFormally, software engineering design is defined as\n(1) The process of identifying, evaluating, validating, and specifying the architectural, detailed, \nand construction models required to build software that meets its intended functional and non-\nfunctional requirements; and (2) the result of such process.\nThe term software design is used interchangeably in practice as a means to describe both \nthe process and product of software design. From a process perspective, software design is \nused to identify the phase, activities, tasks, and interrelationship between them required \nto model software\u2019s structure and behavior before construction begins. From a product \ndevelopment perspective, software design is used to identify the design artifacts that result \nfrom the identified phase, activities, and tasks; therefore, these products by themselves, or \ncollectively, are referred to as software design. Design products vary according to several \nfactors, including design perspective, language, purpose, and their capabilities for evalu-\nation and analysis. For example, designs can be in architectural form, using architectural \nnotations targeted for specific stakeholders. These types of design can be presented using \nblock diagrams, Unified Modeling Language (UML) diagrams, or other descriptive form \nof black-box design documentation. In other cases, design can be in detailed form, where \na more white-box representation of the system is used to model structural and behavioral \naspects. These can include software models that contain class diagrams, object diagrams, \nsequence diagrams, or activity diagrams. Other design products include models that rep-\nresent interfaces, data, or user interface designs. Due to the many ways software design is \nused in practice, a common pitfall in software engineering projects is to associate design \nwith a particular type of design artifact, therefore neglecting other forms of design or the \nactivities required to create complete and correct software designs. Collectively, both pro-\ncess and products, including all variety of design products, are considered software design \nand are essential in most professional software projects.\n", "page": 33, "type": "text", "section": "Page 33"}
{"text": "10\u2002 \u2022\u2002 Software Engineering Design\ufeff\nWHY STUDY SOFTWARE ENGINEERING DESIGN?\nOn February 25, 1991, a software error on the Patriot missile defense system operating \nduring operation Desert Storm caused it to fail to track and intercept an incoming Scud, \nwhich resulted in the death of 28 Americans (GAO, 1992). In 1996, a software error caused \nthe Ariane 501 satellite launch to fail catastrophically, resulting in a direct cost of approx-\nimately $370 million (Dowson 1997). The software error that caused Ariane 501 to fail \ncould be attributed to its software design. Similarly, the literature is swamped with many \nexamples of disastrous results of software-based products. The reason for many of these \ndisasters is that developing high-quality software on time and within budget is a daunting \ntask. From the outset, the landscape for software development projects is plagued with a \nvariety of challenges that increase complexity in software projects. Software design plays \nan integral part in managing the complexity and the challenges encountered in any soft-\nware development effort.\nDuring the software design phase, the system is decomposed to allow optimum develop-\nment of the software; requirements are mapped to conceptual models of the operational \nsoftware; roles are assigned to software teams on the same or remote sites; well-known \ninterfaces for software components are created; quality attributes are addressed and \nincorporated into the design of the system; the user interface is created; the software\u2019s \ncapability is analyzed; function and variable names are identified; design documentation \ngoals are established; and the foundation for the rest of the software engineering life cycle \nis established. Given its impact on the creation and management of software products, \n\u00ad\nmastering software design becomes essential to successfully engineer software products. \nThe reasons for studying software engineering design can be described using a product \ndevelopment perspective and a project management perspective.\nReasons for Studying Software Design in Product Development\nFrom the product development view, studying software design is important because \ndesigns form the foundation for all other software construction activities. Software designs \nallow software engineers to create models that represent the structure and behavior of \nthe software system. Through these models, the main components and their interconnec-\ntion for the solution are identified. Characteristics of quality code, such as modularization, \ncohesiveness, and coupling, are all born in the design phase. For complex tasks, abstrac-\ntions and encapsulation are used in software design as means to provide a systematic \napproach for problem solving. In addition, software designs are reusable; therefore, they \ncan be applied to different projects to provide ready-made solutions to common problems. \nSoftware design also provides the means to evaluate and incorporate the quality attributes \nnecessary for software systems. Therefore, issues such as performance, usability, portabil-\nity, and security can all be addressed early on in the development project. These benefits \nare carried over to all other subsequent phases of the software development life cycle and \nhave direct impact on the implementation, testing, and maintenance phase.\n", "page": 34, "type": "text", "section": "Page 34"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 11\nReasons for Studying Software Design in Project Management\nManaging software projects characterized by changing requirements, tight schedules, cost \nconstraints, and high expectations for software quality is tough. Among these, require-\nment changes are common drivers for all other project characteristics. This means that, \nas requirements change, projects should expect some impact in their cost, schedule, and \nquality. In some cases, requirement changes can easily translate to extended schedules \nand increased cost; in others, where schedules are not extended, requirement changes \ntranslate to decreased software quality. Good software design can minimize (or counter) \nthe effects of requirements volatility in managing software projects. From the manage-\nment\u2019s point of view, software design is important because it helps accommodate changes \nto the requirements or system updates, therefore minimizing impact on schedule, cost, \nand quality. In\u00a0addition, good software design increases efficiency in human resource \nallocation tasks. By decomposing the software into independent units, resources can be \nassigned to software components so that they can be built in parallel in the same or dif-\nferent construction sites, therefore having significant impact on software schedules and \ncost. By compartmentalizing the design, the effects of unwanted employment attrition \n(i.e.,\u00a0employees leaving the company) can also be minimized, since new employees need \nonly to take on the individual design component assigned to that employee. Good soft-\nware designs provide an efficient mapping of customer requirements to software solu-\ntions, therefore facilitating requirements tracing throughout the design. Having a strong \ngrasp on software design helps management abstract project tasks and acquire better \nappreciation of the work to be done. Overall, having a strong grasp in software design \nhelps management improve the project planning, organization, staffing, and tracking and \nprovide overall guidance for the project.\nSOFTWARE DESIGN CHALLENGES\nToday, the software design phase has evolved from an ad hoc and sometimes overlooked \nphase to an essential phase of the development life cycle. Furthermore, the increasing com-\nplexity of today\u2019s systems has created a set of particular challenges that makes it hard for soft-\nware engineers to meet the continuous customer demand for higher software quality. These \nchallenges have prompted software engineers to pay closer attention to the design process \nto better understand, apply, and promulgate well known design principles, processes, and \nprofessional practices to overcome these challenges. Some of the major challenges include \nrequirements volatility, design process, quality issues (e.g., performance, usability, secu-\nrity), distributed software development, efficient allocation of human resources to devel-\nopment tasks, limited budgets, unreasonable expectations and schedules, fast-changing \ntechnology, and accurate transformation from software requirement to a software product. \nA brief discussion of these challenges is presented next.\n", "page": 35, "type": "text", "section": "Page 35"}
{"text": "12\u2002 \u2022\u2002 Software Engineering Design\ufeff\nDesign Challenge 1: Requirements Volatility\nA major reason for the complexity of software projects is the constant change of require-\nments. When designed properly, software can be modified or extended easily; however, when \ndesigned poorly, modifying software can become overwhelming and lead to all sorts of com-\nplex problems. Unlike the development of computer hardware, bridges, houses, or mechanical \nparts, software\u2019s very own nature allows itself to change to provide different or new function-\nality to systems. This same trait that makes software so desirable is what makes it also so com-\nplex. Although much effort is put into the requirements phase to ensure that requirements are \ncomplete and consistent, that is rarely the case; leaving the software design phase as the most \ninfluential one when it comes to minimizing the effects of new or changing requirements. \nRequirements volatility is challenging because they impact future or current development \nefforts. This forces designers to create designs that provide solutions to problems at a given \nstate while also anticipating changes and accommodating them with minimal effort. This \nrequires designers to have a strong understanding of the principles of software design and \ndevelop skills to manage complexity and change in software development.\nDesign Challenge 2: Process\nSoftware engineering is a process-oriented field. Software processes allow engineers to \norganize the steps required to develop software solutions with schedule and cost constraints. \nTherefore, at the core of every software development company, there should be a sound, \nwell-understood, and consistent process for software development. Processes can also be devel-\noped and customized for particular phases of the software engineering life cycle. In the design \nphase, software processes involve a broad set of activities and tasks that bridge the gap between \nrequirements and construction while adhering to a set of project-specific (or company-specific) \nconstraints. These activities include common ones, such as architectural and detailed design, \nas well as other supporting activities. These supporting activities include establishing a design \nreview process, defining design quality evaluation criteria, evaluating design reuse, estab-\nlishing design change management and version control procedures, adopting design tools, \nand allocating resources. In many cases, a company\u2019s design process is not well established, \nis poorly understood, or is approached with minimalistic expectations that ignore aspects \nthat are essential to executing a successful design phase. Focusing design efforts on creating \n\u00ad\nindependent software products, such as a simple class diagram or user interface, while ignoring \nother design activities may create complexities later on during system\u2019s test and maintenance. \nThe design process is challenging because essential design process activities are often over-\nlooked, done in an ad hoc manner, or simply not done at all. In many cases, a well-established \nand well carried out design process serves an indication of future project\u2019s success.\nDesign Challenge 3: Technology\nSoftware is meant to be everywhere. From health-care systems and education to defense \nand everyday ubiquitous devices, software is required to operate on a massive and always \n", "page": 36, "type": "text", "section": "Page 36"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 13\nevolving technology landscape. Besides the operating environment, the technology for \ndesigning and implementing today\u2019s software systems continues to evolve to provide \nimproved capabilities. Examples of these include modeling languages and tools, program-\nming languages, development environments, design patterns, and design strategies. As \nnew technologies emerge, software engineers are required to assimilate and employ them \nall at the same time. In some cases, emerging technologies do not completely replace old \nones. Some software systems are required to interoperate with old legacy systems designed \nwith older design methodologies. This results in software designers employing different \ndesign methodologies and technologies, all on the same software system. In other cases, \ndesign models need to be derived from existing code, modified, and made interopera-\nble with newer technologies. This technology-driven aspect of the design phase creates a \ndemand for capable software designers that can assimilate new technology quickly and \neffectively to succeed at designing software. The technology aspect of software design is \nchallenging because it is fast and ever-changing; therefore, designers must keep abreast of \nthe latest advances and become proficient in the application of these advancements while \nmaintaining rooted in legacy technology.\nDesign Challenge 4: Ethical and Professional Practices\nDesigners create blueprints that drive the construction of the software. During this cre-\nation process, designers are required to determine how design decisions affect the environ-\nment and the people that use the software. In many cases, the software development process \nis traditionally carried out under tight schedule constraints. Inherently, all phases of the \ndevelopment life cycle suffer from this, including the design phase. This creates external \npressures that can lead designers to deviate from the normal design approach to meet these \ndemands, which can have catastrophic consequences. No matter how tight deadlines are, \nhow much animosity exists within the design team, or how much other external/personal \nfactors are brought into the design phase, software designers must exhibit strong ethical \nand professional practices to ensure that the systems they build are of highest quality and \nthat all design considerations are properly evaluated. In many cases, this requires design-\ners to exert strong leadership skills to influence and negotiate with stakeholders, motivate \nthe design team, and lead the design process to accomplish the project\u2019s goals. Designers \nare also responsible for enforcing ethical guidelines during the design process; evaluating \nthe social impacts of their designs in the public domain or in safety-critical systems; and \nto follow the appropriate professional practices to ensure success in the overall system. The \n\u00ad\nethical and professional practices aspect of software design are challenging because design-\ners are constantly faced with numerous pressures from stakeholders that influence \u00ad\ndesigners\u2019 \n\u00ad\ndecisions, most of which have consequences of social, ethical, or professional nature.\nDesign Challenge 5: Managing Design Influences\nDesigns are shaped by many different influences from stakeholders, the development orga-\nnization, and other factors. These influences can have cyclical effects between the system \n", "page": 37, "type": "text", "section": "Page 37"}
{"text": "14\u2002 \u2022\u2002 Software Engineering Design\ufeff\nand its external influences, such that external factors affect the development of the system \nand the system affects its external factors (Bass, Clements, and Kazman 2003). Managing \nthese influences is essential for maximizing the quality of systems and their related influ-\nence on future business opportunities. Of specific importance are design influences that \ncome from the system stakeholders and its developing organization.\nStakeholders\nDesigning software is a nondeterministic activity. If given the same task to different \ndesigners, different solutions will be proposed, each of them being perfectly acceptable \n(McConnell 2004). Now add to the mix the multitude of influences that come from dif-\nferent stakeholders, and you can easily get a variety of design alternatives for meeting a \nvariety of stakeholders\u2019 concerns, all conflicting with each other. This creates a challenge \nwhen trading off design alternatives that meet all stakeholders concerns. Making such \ndesign trade-offs is difficult, especially on large-scale design efforts. Consider a project \nwith multiple customers, each with conflicting goals affecting design decisions. In such \nprojects, creating a design that sacrifices some desired customer capability but provides \nother desired properties, such as quick time-to-market, reliability, or lower cost, can lead \nto the development of a high-quality system that maintains acceptable levels of satisfaction \namong stakeholders. This is an example of how stakeholders affect design decision, and the \ndesign, in turn, influences the stakeholder goals (Bass et al. 2003). Managing \u00ad\nstakeholders\u2019 \ninfluences is challenging because it requires designers to exert a high-level of communica-\ntion, negotiation, and technical skills to ensure that design decisions are made to accom-\nmodate all concerns without negatively affecting the project.\nDevelopment Organization\u2019s Structure\nThe development organization\u2019s structure influences the development of software prod-\nucts, in particular, the design of those products. As example, consider the case of distrib-\nuted software engineering. In today\u2019s global market, more and more cases of distributed \nsoftware development are taking place. A wide variety of reasons exist for developing soft-\nware at different sites. Consider companies that have sites in multiple states, where various \nlevels of domain expertise are found at different sites. Or consider the case of software \nengineers resigning, creating a gap in the development team that is hard to fill with local \nresources. Finally, consider companies that simply want to reduce cost by hiring software \nengineers from different countries. These and many other reasons exist for having devel-\nopment across site boundaries. In each of these cases, the structure of the development\u2019s \norganization makes it complicated to, for example, coordinate design efforts, evaluate and \ndiscuss design alternatives, conduct peer reviews, and manage version control. In these \ncases, designers need to consider not only technical aspects of the design but also the dis-\ntribution of employees, organizational goals, resource availability, and so forth. Designs \nthat support integration of distributed expertise across sites can introduce capabilities for \nbuilding new software products that could not be engineered otherwise. This in turn can \n", "page": 38, "type": "text", "section": "Page 38"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 15\ninfluence the developing organization to target new areas of businesses, therefore allowing \nthe software design to influence its business goals. Managing the influences of the develop-\nment organization is challenging because it requires designers to span out of the technical \ndomain to have a keen interest on the organization as a whole.\nCONTEXT OF SOFTWARE DESIGN\nIn today\u2019s modern software systems, software design plays a key role in the development of \nsoftware products; however, it is only one phase of the complete software engineering life \ncycle. To understand how design fits within the whole software engineering process, it is \nnecessary to provide the appropriate context so that clear distinctions can be made between \nthe different life cycle phases and an appreciation of the importance of software design \nactivities and tasks can be acquired. For this reason, an overview of software engineering \nand its life cycle is required. Software engineering is defined by the IEEE (1990, p. 67) as\n(1) The application of a systematic, disciplined, quantifiable approach to the development, \noperation, and maintenance of software; that is, the application of engineering to software. \n(2) The study of approaches as in (1). \nThe fundamental software engineering life cycle phases include requirements, design, \nconstruction, test, and maintenance, as presented in Table\u00a01.5.\nThe requirements phase is where stakeholders are identified and customer needs, wants, \nand the (often overlooked) nonfunctional requirements are determined (Laplante 2009). \nDuring this phase, requirements are analyzed in their raw form to address issues such as \nrequirements that don\u2019t make sense, contradict each other, or are incomplete, vague, or \njust wrong (Laplante 2009); requirements are classified and prioritized; and the specifica-\ntion of the software system, which typically results in the production of a document, or \nits electronic equivalent is reviewed and validated (Abran, Moore, Bourque, and Dupuis \nTABLE\u00a01.5\nFundamental Software Engineering Phases\nPhase\nDescription\nRequirements\nInitial stage in the software development life cycle where requirements are elicited, analyzed, \nspecified, and validated\nDesign\nThe requirement\u2019s specification is used to create the software design, which includes its \narchitecture and detailed design\nConstruction\nRelies on the requirements\u2019 specification, the software architecture, and detailed design to \nimplement the solution using a programming language; a great deal of design can also \noccur at this phase\nTest\nEnsures that the software behaves correctly and that it meets the specified requirements\nMaintenance\nModifies software after delivery to correct faults, improve performance, or adapt it for a \ndifferent environment\n", "page": 39, "type": "text", "section": "Page 39"}
{"text": "16\u2002 \u2022\u2002 Software Engineering Design\ufeff\n2005). Once the requirements for the system are specified, designing the system takes \nplace, which is the main topic of this book.\nThe construction phase begins once the design phase has been executed and all require-\nments can be traced to a section of the software design models. The construction phase is \nwhere designs are implemented using the programming language of choice. In this phase, \ncode is generated according to a style guide. In addition, the code is unit tested, debugged, \nand peer-reviewed; programming errors are detected, tracked, and resolved; code is man-\naged by using change management and version control software; and, finally, code is pre-\npared for delivery using a predefined set of conventions for formatting. The construction \nphase is tightly related to the design phase and in some cases (typically on smaller projects) \nthe line dividing both phases can be hard to identify. There are several reasons for this, \nthe main one being that detailed designs can be directly translated to code; therefore, soft-\nware engineers tend to design and code at the same time. In other cases, where design and \nconstruction are clearly delineated by the process, it is common for some construction \ntasks, such as identifying appropriate class, function, and variable names, to be performed \nduring detailed design. Finally, because many discoveries made well into the construction \nphase give rise to functionality that requires design work, engineers must iterate back and \nforth between construction and design activities. Once all the design artifacts are imple-\nmented with programming and all assigned requirements can be validated through execu-\ntion of code during unit testing, the construction phase is complete.\nThe testing phase is typically the final step before the software goes out the door. The\u00a0main \npurpose of the testing phase is to verify and validate the software to ensure that it meets \nthe predefined functions and level of quality defined in the software requirement\u2019s phase. \nFormally, the IEEE (1990, p. 76) defines testing as\n(1) The process of operating a system or component under specified conditions, observing or \nrecording the results, and making an evaluation of some aspect of the system or component. \n(2) The process of analyzing a software item to detect the differences between existing and \nrequired conditions (that is, bugs) and to evaluate the features of the software item.\nThe software testing phase serves as a gateway between product development and product \nrelease. Therefore, verification and validation efforts need to be made to ensure that the soft-\nware meets the specification and the integrity of the software can be assured under normal \nand harsh conditions. It is important to note that no desired quality attribute can be verified \nduring testing if it hasn\u2019t been designed into the product first. Therefore, even though test-\ning is typically credited for ensuring product quality, design is fundamental in supporting a \nsuccessful testing phase. Once software is delivered, the maintenance phase begins to imple-\nment corrections, adaptations, or improvements to the software. Corrections are typically \nmade on a smaller scale to rectify faulty behavior or output of the software. These typically \ndo not require design work. However, for adaptations or improvements, design work may \nbe required to accommodate the changes. Together, all phases of the software engineering \nlife cycle work together to define the functions that the software must provide, to transform \nthese functions into technical solutions, to implement those solutions, and to validate their \nimplementation and ensure the quality of the system throughout future versions.\nwww.allitebooks.com\n", "page": 40, "type": "text", "section": "Page 40"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 17\nSOFTWARE DESIGN PROCESS\nIn the previous section, the design phase was briefly mentioned as a means for determin-\ning its place within the software engineering process. However, as it will be seen, the design \nphase incorporates many activities and tasks conducted by different teams and typically \nmanaged by personnel other than designers. This requires a formal process to ensure that the \ndesign phase is conducted properly and that it addresses all the concerns identified for the \nsoftware system being built. Many processes exist to carry out phases, activities, and tasks \nthroughout the software engineering life cycle, including the unified process (UP), Scrum, \nand the dynamic systems development method (DSDM) (Pressman 2010). What follows is \na discussion on the software design process in terms of the fundamental activities and tasks \nrequired to build software products. These activities and tasks are essential and typically built \ninto other formal processes such as the ones already mentioned. The hope is that by plac-\ning more emphasis on the fundamental activities and tasks and less on particular process \napproaches readers can obtain a more concise and understandable coverage of the topic.\nIn today\u2019s professional software engineering landscape, software engineers are being \nasked to build larger and more complex software systems in the same or different sites. \nTherefore, both design processes and artifacts are increasing in complexity. This means that \nit is not enough to know how to model structural and behavioral aspects of the system in \nthe design phase, but it is also essential that software designers know about the particular \nprocess (e.g.,\u00a0UP, Scrum) required to manage, create, and control software design activities. \nSommerville (2010) defines a software process as a set of activities that lead to the production \nof a software product. Similarly, a software design process is a set of activities and controls \nthat specify how resources work together for the production of software design artifacts. \nThe software engineering body of knowledge identifies two major activities for software \ndesign: software architecture and detailed design (Abran et al. 2005). These are the essential \nactivities for managing the complexity involved in developing large-scale software systems. \nHowever, numerous other important activities are required for supporting the creation of \narchitectural and detailed designs. Therefore, when planning and identifying an appropri-\nate software design process, the effort required for these activities needs to be considered. \nIn addition, because of the emphasis that some forms of design place on construction, the \ndetailed design activity process can be modified to explicitly present the construction design \nactivity that addresses design issues encountered during the construction phase. With this \nin mind, a holistic approach to software design, which includes architecture, detailed and \nconstruction design, management, and documentation, is presented in Figure\u00a01.3.\nAs seen in the figure, software architecture is the first activity conducted in the design \nprocess. Architectural designs are elaborated through detailed designs, which are further \nelaborated through construction designs. All of these design activities need to be docu-\nmented, and the process for design and documentation needs to be managed. Figure\u00a01.3 \nalso presents a necessary differentiation between the software design phase and the distri-\nbution of its activities throughout the software engineering life cycle. In some cases, the \narchitectural design activities can begin during the analysis activity of the requirements \n", "page": 41, "type": "text", "section": "Page 41"}
{"text": "18\u2002 \u2022\u2002 Software Engineering Design\ufeff\nphase and span through the design phase; in others, it begins after the requirements are \nspecified and validated. In a similar fashion, the detailed design activity can start at the \nproject\u2019s design phase and span through the software construction phase. These scenarios \nare highly project dependent; therefore, following to a strict waterfall-like process for soft-\nware development is impractical for all but the simplest software applications.\nSoftware Architecture\nThe software architecture activity corresponds to a macrodesign approach for creating \n\u00ad\nmodels that depict the quality and function of the software system. It provides black-box \nmodels used to evaluate the system\u2019s projected capabilities as well as its expected quality, \nall from multiple perspectives. Therefore, architectural designs allow different \u00ad\nstakeholders, \nwith different backgrounds and expertise, to evaluate the design and ensure that the software \nSoftware Design \nManagement \nDocumentation \nDetailed Design:\nInterface Design\nComponent Design\nConstruction Design:\nFlow-Based Design\nTable-Based Design\nSoftware\nRequirements\nSoftware\nConstruction\nSoftware Architecture:\nArchitectural Views\nArchitectural Patterns\n\u2026\n\u2026\nH\nC\nI\nD\nE\nS\nI\nG\nN\n\u2026\nSoftware Design Process\nDesign Activities in Software\nEngineering Process\nSoftware\nRequirements\nArchitectural\nDesign\nArchitectural\n& Detailed\nDesign\nDetailed &\nConstruction\nDesign\nSoftware\nDesign\nSoftware\nConstruction\nFIGURE 1.3\nThe software design process and design activities during the SWE process.\n", "page": 42, "type": "text", "section": "Page 42"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 19\narchitecture is addressing their concerns. For example, from the systems engineering per-\nspective, architectural designs can provide information about the physical deployment of \nthe system, including subsystems located at different locations, the artifacts executing in \nthe subsystems, and how the system as a whole communicates. From the configuration \nmanagement perspective, architectural designs can provide information about the hier-\narchy of files in the file system and how these files are interconnected to build and deploy \nthe software system. From the software engineering perspective, different architectural \ndesigns can help decompose the software and define the major structural components of \nthe system, identify interfaces between the components, map the requirements to them, \nevaluate concurrency issues, and provide overall insight into the design solution. A major \nbenefit of architectural designs is their capacity to evaluate high-level concerns from stake-\nholders that deal mostly with nonfunctional requirements (e.g., performance, usability, \nsecurity). For these purposes, architectural designs serve as important communication, \nreasoning, and analysis tools that support the development and growth of the systems \n(Bass et al. 2003). Software architecture lays the foundation for all subsequent work in the \nsoftware engineering life cycle.\nDetailed Design\nThe detailed design step begins after the software architecture is specified, reviewed, and \ndeemed sufficiently complete for detailed design to begin. The detailed design activity \nbuilds on the software architecture to provide white-box design elements of the \u00ad\nstructure \nand behavior of the software system and in many cases is the last major effort before \n\u00ad\nsoftware construction begins. Detailed design is the activity that deals with refining the \nsoftware architecture to reach a point where the software design, including architecture \nand detailed design, is deemed sufficiently complete for construction to begin. Whereas the \nsoftware architecture places a major emphasis on quality (nonfunctional requirements), \nthe detailed design activity places a major focus on addressing functional requirements of \nthe system. In object-oriented systems, the detailed design activity is where components \nare refined into one or more classes, interfaces are realized, relationships between classes \nare specified, class functions and variable names are created, design patterns are identified \nand applied, and, if applicable, design tools are configured for code generation. Two major \ntasks of the detailed design activity are interface design and component design.\nInterface Design\nInterface design refers to the design activity that deals with specification of interfaces \nbetween components in the design (Sommerville 2010). Interface design can be focused \non specifying the interfaces used internally within software components or externally \nacross software components. In both cases, interfaces provide a standardized way for spec-\nifying how services are accessed and provided by software components. Interface design \nallows subsystems to be designed independently and in parallel; therefore, it is typically \none of the first tasks performed as part of the detailed design. Other forms of interface \n", "page": 43, "type": "text", "section": "Page 43"}
{"text": "20\u2002 \u2022\u2002 Software Engineering Design\ufeff\ndesign specify communication between systems, for example, custom binary or Extensible \nMarkup Language (XML) messaging specifications used for communication between two \nor more subsystems through the network.\nComponent Design\nDuring architecture, the software system is decomposed into logical components that \nabstract required system functions. During detailed design, these logical components are \nrefined and their interactions are modeled to verify the validity of their structural compo-\nsition. The execution of the detailed design activity requires a shift from the macrodesign \napproach to the microdesign approach to further decompose and refine system components \ninto one or more fine-grained elements, functions, and data variables required for support-\ning the internal structure and behavior of components that meet assigned roles during the \nsoftware architecture activity. Component design refers to modeling the internal\u00a0structure\u00ad\n \nand behavior of components\u2014which includes the internal structure of both logical and \nphysical components\u2014identified during the software architecture phase. During this \nactivity\u00ad\n, fine-grained components are derived from the architecture, and their internal \nstructure and behavior are designed. Components are not limited to object-oriented \n\u00ad\nsystems; therefore, component designs can be realized in many ways. In\u00a0object-oriented \nsystems, the internal structure of components is typically modeled using UML through \none or more diagrams, including class and sequence diagrams. When modeling the inter-\nnal structure of components, several design principles, heuristics, and patterns are used to \ncreate and evaluate component designs.\nConstruction Design\nThe idea of the detailed design activity is to get as close to the solution as possible without \nbeginning the construction phase. In many cases, in object-oriented systems, this amounts \nto identifying classes, their attributes and functions, and interrelationships with other \nclasses. These tasks are done while abstracting and deferring details of implementation to \nthe construction phase. In some cases, however, implementing complex software functions \nidentified during the detailed design activity requires additional design work to ensure they \nwork properly and maintain the quality standards sought during the software architecture \nactivities. In these cases, construction design is necessary. Construction design is not a new \nconcept. Many other authors have proposed it as an important design activity. For example, \nMcConnell (2004) specifies five levels of software design; one of them, being at the lowest \nlevel, deals with internal routine design. Similarly, Fox (2006) identifies a form of low-level \ndesign that fills the gap between detailed design and programming and deals with issues \nsuch as operation specification, including operation name, parameter types, and return \ntypes among others. Other authors, such as Meyers (2005), have highlighted the impor-\ntance of designing code at low levels, during construction. Construction design is the last \ndesign activity\u2014typically conducted during the construction phase\u2014required to support \nthe \u00ad\nsystem\u2019s quality attributes, such as performance, maintainability, and testability.\n", "page": 44, "type": "text", "section": "Page 44"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 21\nHuman\u2013Computer Interface Design\nThe human\u2013computer Interface (HCI) design activity is where general principles are applied \nto optimize the interface between humans and computers. Visual designs have a major role \non the success or failure of software systems. Systems that meet functional requirements \nbut that are not usable cannot succeed. The HCI design activity can be executed in paral-\nlel to the software architecture or detailed design activities. In some cases, HCI design is \nconsidered an architectural task, while in others it is considered a detailed design task. \nRegardless of where HCI design fits within design processes adopted by specific organiza-\ntions, it is a major design activitiy that requires careful attention. The major concerns of \nthe HCI designs may include the evaluation and use of modes, navigation, visual designs, \nresponse time and feedback, and design modalities, such as forms and menu-driven. HCI \ndesigns directly influence the quality of any system and are essential to understanding and \naddressing the factors that affect the overall usability of the system. Many design principles \nand evaluation techniques exist to succesfully design user interfaces.\nSoftware Design Documentation\nSimilar to the specification activity of the requirements phase, software design documen-\ntation, also known as software design description (SDD), plays a big role in professional, \nlarge-scale, or software-intensive systems. Its importance is specified by the IEEE (1998, \np.\u00a0iii) as follows:\nSDDs play a pivotal role in the development and maintenance of software systems. During \nits lifetime, a given design description is used by project managers, quality assurance staff, \n\u00ad\nconfiguration managers, software designers, programmers, testers, and maintainers. Each \nof these users has unique needs, both in terms of required design information and optimal \norganization of that information. Hence, a design description must contain all the design \n\u00ad\ninformation needed by those users.\nSDD should include the necessary information that properly captures the design of \nthe system. As part of this activity, other issues such as tools for generating design docu-\nments, validation, and configuration management must be addressed. The software design \n\u00ad\ndocumentation activity typically begins at the design phase and continues throughout the \n\u00ad\nlifetime of the software system.\nSoftware Design Management\nManagement plays a big role in software engineering projects. Griffin (2010, p. 5) defines \n\u00ad\nmanagement as\nA set of activities (including planning and decision making, organizing, leading, and con-\ntrolling) directed at an organization\u2019s resources (human, financial, physical, and informa-\ntion), with the aim of achieving organizational goals in an efficient and effective manner.\n", "page": 45, "type": "text", "section": "Page 45"}
{"text": "22\u2002 \u2022\u2002 Software Engineering Design\ufeff\nIn the design phase, management refers to the set of activities required to efficiently \u00ad\ncreate \nand implement quality design artifacts, within schedule and budget constraints. This definition \nencompasses a broad set of activities that are particular to specific organizations. However, at \nthe core of every organization\u2019s management activities, quality is a focal point. The quality\u00ad\n of \nsoftware designs can be assessed in various ways. From the management\u2019s perspective, quality \nof software designs can be evaluated in terms of cost and scheduling. From the engineering \npoint of view, quality in designs can be evaluated using a set of well-known design principles \nas well as modeling and evaluating the quality attributes that the software must exhibit, which \nare specified via nonfunctional, quality requirements. From the configuration management\u2019s \nperspective, design quality can be achieved through change management processes that con-\ntrol how designs are created, modified, and improved. In\u00a0large-scale software projects, soft-\nware design management is essential to plan, organize, staff, track, and lead the activities \nrequired to carry out successfully the software architecture and detailed design steps.\nROLES OF THE SOFTWARE DESIGNER\nFrom the discussions provided so far, it should be evident that designers are not all equal. \nIn many design efforts, designers have different roles, with different titles and responsibili-\nties that focus on specific design problems of the software system. There are many factors \nin place that determine the designer\u2019s role, including an engineer\u2019s work preference, expe-\nrience, and capabilities. When studying software design, it is important to understand \nhow these roles differ, the type of work performed, and capabilities required to perform \nthe activities required of each role. In some cases, software designers are heavily involved \nin the requirements and construction phases; therefore, they must have expertise not \nonly in design but also in requirements engineering and software construction. In other \ncases, a clear organizational delineation exists, allowing designers to focus on their area \nof \u00ad\nexpertise. A\u00a0list of typical designer roles is presented in Table\u00a01.6 (Giachetti 2010).\nTABLE\u00a01.6\nTypical Roles in Software Design\nDesigner\nDescription\nEnterprise architect\nDesigns the enterprise\u2019s strategy, processes, information, and organizational \nstructure\nSoftware architect\nDesigns software systems using a black-box modeling approach; concern is placed \non the external properties of software components that determine the system\u2019s \nquality and support the further design of functional requirements\nComponent designer\nFocuses on designing the internal structure of software components identified \nduring the software architecture phase; has strong programming skills\nUser Interface designer\nDesigns the software\u2019s user interface; skilled in determining ways that increase \nusability of the system\nSystem engineer\nDesigns systems using a holistic approach, which include designing how software \nand hardware collaborate to achieve the system\u2019s goals\n", "page": 46, "type": "text", "section": "Page 46"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 23\nSystems Engineer\nThe systems engineer designs the overall development process of systems as a whole, \nincluding processes for development of both the software and hardware that are part of the \nsystem. As a specialization of system engineering, software systems engineers design soft-\nware at the system level; in many cases, the work performed by software systems engineers \nis similar to that of a software architect. Systems engineers work closely with customers to \nprovide a holistic view of systems, their interfaces, and the distribution of requirements \nto subsystems. Software systems engineers are typically experts in the problem domain, \nand, depending on the type of system (e.g., embedded, web), they also develop expertise \non other nonsoftware-related parts, such as hardware, communications, and avionics. This \nis essential at all phases of the software development process, since they must be able to \ncommunicate with other engineering disciplines, such as electrical, mechanical, and civil. \nIn this role, designers have typically accumulated experience in other design roles, such as \nsoftware architecture, component design, and in some cases construction. In addition to \ntechnical skills, systems engineers are required to have strong leadership skills to ensure \nthe successful system development.\nSoftware Architect\nThe software architect is in charge of designing the software architecture. Software architects \ncan be found under a wide variety of titles, such as software lead, senior software engineer, \nor principal software engineer. Regardless of the title, software architects have extensive \nexperience architecting systems that meet their intended requirements. Experience is typi-\ncally acquired while moving up through the ranks, from software programmer all the way \nup to software architect. Software architects have strong leadership skills and are required \nto be skilled in initiation, communication, and negotiation. They also need to have a keen \nunderstanding of the developing organization to determine ways software systems can \ninfluence the organizational business goals and increase new business ventures leveraged \nfrom existing architectures. Other skills beneficial to software architects include project \nmanagement skills.\nComponent Designer\nComponent designers are highly noticeable during detailed and construction designs, \nsince they are typically the ones constructing the software. Therefore, they have strong \nprogramming skills and a strong foundation in design principles. For object-oriented com-\nponent designers, strong object-oriented skills including knowledge of design patterns are \nessential. Component designers create both static and dynamic models of the software \nsystem at levels appropriate to drive \u00ad\nconstruction; these include (when applicable) UML \nclass diagrams and sequence diagrams. They have deep knowledge and understanding of \nthe software requirements assigned to them; they are knowledgeable about other tools that \nsupport the design and development effort, such as modeling tools, integrated development \n", "page": 47, "type": "text", "section": "Page 47"}
{"text": "24\u2002 \u2022\u2002 Software Engineering Design\ufeff\nenvironments, forward and reverse \u00ad\nengineering, and configuration management. When \ndesigning at the component level, component designers have a full understanding of style \nguides for the project, since they dictate \u00ad\nnaming, spacing, and commenting conventions \nand other aspects that shape the structure of code. Component designers devise construc-\ntion designs as needed and are proficient at creating effective unit tests that verify the \nquality of their product developed. Finally, component designers need to be comfort-\nable scheduling and conducting peer reviews and accepting feedback and evaluating it \n\u00ad\nobjectively to improve their designs.\nSOFTWARE DESIGN FUNDAMENTALS\nWithin the design process, many principles, considerations, and strategies help designers \nexecute the software design process in an effective and consistent manner. For the most \npart, these help designers manage and simplify problems, consider the impacts of their \nproposed solutions, and establish a foundation for decision making during design. In this \ncontext, design principles refer to knowledge matter that has been found effective through-\nout the years in multiple projects on different domains. Design principles are applicable on \nmost design projects; therefore, their use is expected to help achieve high-quality designs. \nOn the other hand, design considerations are recommendations that help designers in the \ndesign process; they may or may not be followed. Finally, design strategies consist of tacti-\ncal approaches in which design principles and considerations can be employed to drive the \ndesign process. These concepts are further discussed in the next sections.\nGeneral Software Design Principles\nThroughout the history of software engineering, many design principles have emerged \nto become fundamental drivers for decision making during the software design process. \nThese design principles are used as a basis for reasoning and serve as justification for almost \nall design decisions. They also provide designers with a foundation from which other more \nsophisticated design methods can be applied (Pressman 2010). These principles are not \nspecific to any particular design strategy (e.g., object oriented) or process, so they are fun-\ndamental to all software design efforts and can be applied during architectural, detailed, \nand construction designs. The principles include (Abran et al. 2005):\n\u2022\t Modularization\n\u2022\t Abstraction\n\u2022\t Encapsulation\n\u2022\t Coupling and cohesion\n\u2022\t Separation of interface and implementation\n\u2022\t Sufficiency and completeness\n", "page": 48, "type": "text", "section": "Page 48"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 25\nModularization\nModularization is one of the most important (and perhaps oversimplified) design prin-\nciples in software design. Modularity allows software systems to be manageable at all levels \nof the development life cycle. That is, the work products of the requirements, design, con-\nstruction, and testing efforts can all be modularized to efficiently carry out the operations. \nIn\u00a0the design phase, modularization is the principle that drives the continuous decompo-\nsition of the software system until fine-grained components are created. Modularization \nplays a key role during all design activities, including software architecture and detailed \nand construction design; when applied effectively, it provides a roadmap for software \ndevelopment starting from coarse-grained components that are further modularized into \nfine-grained components directly related to code. If applied properly, modularization can \nlead to designs that are easier to understand, resulting in systems that are easier to develop \nand \u00ad\nmaintain. Efficient modularization can be achieved by following and applying the \nprinciples of abstraction and encapsulation. With proper modularization, software systems \ncan be decomposed into modules that allow the system\u2019s complexity to be manageable and \nallow the system to be efficiently built, maintained, and reused.\nAbstraction\nWhile the principle of modularization specifies what needs to be done, the principle of \nabstraction provides the guidance as to how it should be done. Modularizing systems in \nan ad hoc manner leads to designs that are incoherent, hard to understand, and hard to \nmaintain. To modularize intelligently, a thorough understanding of abstraction is required \n(Liskov and Guttag 2010). Abstraction is the principle that deals with creating conceptual \nentities required to facilitate problem solving by focusing on essential characteristics of \nentities\u2014in their active context\u2014while deferring unnecessary details. When abstraction \nis applied, the level of detail required to think about a problem is adjusted to productively \nmodularize a system; this allows for the creation of coherent entities that can be used to \nrepresent their possible variations in the problem\u2019s context and domain. The principle of \nabstraction can be applied iteratively at multiple levels during the design phase. At the soft-\nware architecture level, abstraction helps during the identification of software components \nand their interfaces. At the detailed design phase, abstraction helps identify the entities, \nfunctions, and interfaces required to realize the component\u2019s provided services. At the \nconstruction level, abstraction helps in the further design of functions identified during \ndetailed design. In all of these, abstraction is used to facilitate problem-solving by defer-\nring details to later stages. The principle of abstraction can be classified as (Pressman 2010):\n\u2022\t Procedural abstraction\n\u2022\t Data abstraction\nProcedural abstraction is a specific type of abstraction that simplifies behavioral \n\u00ad\noperations containing a sequence of steps or other procedural abstractions. For example, \n", "page": 49, "type": "text", "section": "Page 49"}
{"text": "26\u2002 \u2022\u2002 Software Engineering Design\ufeff\nconsider a client\u2013server application in which the client sends data to the server through \nthe Internet. In this case, the Send procedural abstraction can be used to denote a series \nof operations, for example, retrieving the server\u2019s information (e.g., Internet Protocol [IP] \naddress, port number), opening a connection, sending the message, and closing the con-\nnection. On the other hand, data abstraction is used to simplify the structural composition \nof data objects. Using the previous example, the Message data abstraction can be used to \nrepresent various messages with different attributes, such as the message\u2019s ID, content, and \nformat. The definition of all of these properties can be deferred to later stages. Abstraction \nis fundamental for managing complexity in all activities of the software design phase.\nSkill Development 1.2: The Abstraction Principle\nThe world is full of abstractions; without abstractions, communicating with our peers \nwould be much more difficult. As an exercise, look for the nearest rectangular object \nthat contains a knob and (maybe) a keyhole; if the object is blocking an entrance, \nchange the state of the object so that it no longer blocks the entrance. Summarize this \nscenario by coming up with two abstractions: one data and the other procedural to \nincrease communication with peers. When done, create a list of four other abstractions \nthat surround you, and provide an abstraction as well as the detailed object description \nthat would be required if the abstraction is not used. Ensure that there are two data \nabstractions and two procedural abstractions. \nEncapsulation\nIn previous sections, modularization is presented as principle for decomposing mono-\nlithic systems into manageable units. While abstraction provides the principle for guid-\ning the decomposition of the systems based on behavior and data, encapsulation provides \nthe principle for enhancing the efficiency of the collaboration among modularized units. \nEncapsulation is the principle that deals with providing access to the services of concep-\ntual entities (e.g., modules, components) by exposing only the information that is essential \nto carry out such services while hiding details of how the services are carried out. While \nabstraction is employed to find conceptual entities, encapsulation enforces that abstracted \nentities communicate between each other using a \u201cneed to know only\u201d basis. When evalu-\nated this way, the abstraction design principle helps create the modules and the encapsula-\ntion design principle enforces efficient communication between them. These principles are \nall essential in achieving efficient modularization. The relationship among modulariza-\ntion, abstraction, and encapsulation is presented in Figure\u00a01.4. As seen, after the principle \nof abstraction is applied, the encapsulation principle is used to hide irrelevant details from \nthe abstraction. In Figure\u00a01.4, the shaded region corresponds to information that is irrel-\nevant to other modules, while the white region corresponds to access points that modules \ncan use to interoperate.\nwww.allitebooks.com\n", "page": 50, "type": "text", "section": "Page 50"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 27\nCoupling\nSimilar to abstraction and encapsulation, coupling and cohesion are design principles that lead \nto efficient module creation by emphasizing on the degree of dependency and belonging of \nmodules, respectively. Formally, the IEEE (1990, p. 22) defines coupling as\nThe manner and degree of interdependence between software modules. \nLike all other design principles discussed so far, coupling can be applied during software \narchitecture, detailed design, and construction design to measure the degree of depen-\ndency of design units, such as an architectural subsystem, a class in a detailed design\u2019s \nclass diagram, or a function in code. In other words, the coupling principle can be used \nto determine how much an architectural subsystem depends on other architectural sub\u00ad\nsystems, how much a class depends on other classes, and how much a function depends on \nother functions. When measuring coupling, the number of dependencies between design \nunits does not tell the whole story, since the nature of the dependencies plays an impor-\ntant role in decision making. For example, design units can depend on well-defined and \nstable interfaces, common data structures, and internal structure of other design units. \nIt\u00a0is not hard to support the idea that dependencies on well-defined and stable interfaces \nare less troublesome than dependencies on the internal structure of other design units. \nThree common types of coupling are\n\u2022\t Content coupling\n\u2022\t Common coupling\n\u2022\t Data coupling\nContent coupling represents the most severe type of coupling, since it refers to modules that \nmodify and rely on the internal details of other modules. Common coupling refers to depen-\ndencies based on a common access area, such as a global variable (IEEE 1990). When this \noccurs, changes to the global data area causes changes in all dependent modules. This type \nof coupling results in lesser severity than content coupling; however, it shares many of the \nundesired effects as content coupling. Finally, data coupling refers to the type of dependency \nAbstraction\nModularization \nEncapsulation\nMonolithic\nSystem\nModularized\nSystem \nFIGURE 1.4\nThe modularization, abstraction, and encapsulation principles.\n", "page": 51, "type": "text", "section": "Page 51"}
{"text": "28\u2002 \u2022\u2002 Software Engineering Design\ufeff\nin which design units communicate with each other only through a set of data parameters. \nUnlike content coupling, data coupling does not depend on the internals of other design \nunits, and unlike common coupling it provides more control over the form of dependency. \nWhen dependency between modules relies on data parameters that are globally inaccessible, \ndesign units are shielded from undesired changes to the data by other design units. In all \ncases, a high degree of coupling gives rise to negative side effects. For example, as coupling \nincreases, reusability and manageability of the design units decrease since errors or changes \nto the independent unit propagate to all dependent units. In\u00a0other cases, when coupling \nincreases, so does the complexity of managing and maintaining design units. Other types \nof coupling include control coupling, hybrid coupling\u00ad\n, and pathological\u00ad\n coupling (IEEE 1990).\nCohesion\nWhile coupling gives insight to a design unit\u2019s degree of dependency, cohesion provides \ninsight into its strengths. The IEEE (1990, p. 17) defines cohesion as\nThe manner and degree to which the tasks performed by a single software module are related \nto one another.\nCohesion measures how well design units are put together for achieving a particular \npurpose and can be classified based on the measurement approach as\n\u2022\t Functional cohesion\n\u2022\t Procedural (or sequential) cohesion\n\u2022\t Temporal cohesion\n\u2022\t Communication cohesion\nFunctional cohesion measures a design unit\u2019s strength by the degree to which its tasks, \noperations, or subunits all contribute to perform a single function. When the function \nto be performed has a single logical meaning, functional cohesion can be seen as a form \nof logical cohesion. A highly functionally cohesive module is one whose internal details \nwork toward achieving the same function. Functional cohesion is the most typical type \nof cohesion. Procedural cohesion measures the strength of a design unit by the degree to \nwhich its tasks work procedurally (in steps) to achieve the unit\u2019s purpose. Therefore, func-\ntional and procedural cohesion are not mutually exclusive; that is, modules can exhibit \nboth high functional and procedural cohesion. Temporal cohesion measures strength by \nthe degree to which all tasks in a design unit are performed at specific times. Consider \na design unit responsible for carrying out the initialization of a system. This unit may \nbe responsible for performing a power-on self-test that may include memory tests, file \nsystem\u00ad\n checks, and communication checks. These are all different functions but need to be \n\u00ad\nexecuted at the same time during initialization; therefore, the unit is temporally cohesive. \nFinally, \u00ad\ncommunication cohesion measures a unit\u2019s strength by the degree to which its tasks \nproduce\u00ad\n or consume the same data.\n", "page": 52, "type": "text", "section": "Page 52"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 29\nCohesion provides an important principle that measures how much design units that are \ngrouped together actually belong together based on different criteria. Cohesion can also \nbe seen at different levels of the design process. During the software architecture activity, \nlogical and communication cohesive modules are typical, whereas, during the detailed \nand construction design activities, functional, procedural, and temporal cohesiveness are \nmore expected. In all cases, highly cohesive modules increase reusability. An example of \nthe cohesion and coupling principles is presented in Figure\u00a01.5. As seen in the top part \nof the figure, Module 1 performs three unrelated different tasks (i.e., Task 1, Task\u00a02, and \nTask 3), each requiring three independent subtasks. For example, Task 1 requires three \ndifferent subtasks, denoted by the labels Task 1.1, Task 1.2, and Task 1.3. As seen, Module\u00a01 \nhas dependencies to nine different unrelated tasks, which can translate to a high degree \nof coupling and low degree of cohesion. The bottom part of Figure\u00a01.5 shows how the \nsystem is decomposed into three more cohesive units, each with lower coupling than \nthe original approach. In this case, the system is transformed to a modular system with \nhigher \u00ad\ncohesiveness and lower coupling. With this transformation, Module 1 now has five \ndependencies and stronger functional cohesion. Modules 2 and 3 have lower coupling than \nModule 1 (both in its original and improve form) and are highly cohesive.\nSeparation of Interface and Implementation\nThe principle of separation of interface and implementation deals with creating modules \nin such way that a stable interface is identified and separated from its implementation. \nThis design principle should not be confused with encapsulation. During encapsulation, \nModule 1 \nTask 1.1 \nTask 1.2 \nTask 1.3 \nTask 2.1 \nTask 2.2 \nTask 2.3 \nTask 3.1 \nTask 3.2 \nTask 3.3 \nModule 2 \nModule 3  \nModule 1 \nTask 1.1 \nTask 1.2\nTask 1.3 \nTask 2.1 \nTask 2.2 \nTask 2.3\nTask 3.1 \nTask 3.2 \nTask 3.3 \nFIGURE 1.5\nExample of principles of coupling and cohesion.\n", "page": 53, "type": "text", "section": "Page 53"}
{"text": "30\u2002 \u2022\u2002 Software Engineering Design\ufeff\ninterfaces are created to provide public access to services provided by the design unit while \nhiding unnecessary details, which include implementation. While encapsulation dictates \nhiding the details of implementation, the principle of separation dictates their separation, so \nthat different implementation of the same interface can be swapped to provide modified or \nnew behavior. Figure\u00a01.6 presents these concepts.\nAs seen, the bottom design units have separated interfaces; therefore, varied implemen-\ntations can be employed without changes to a unit\u2019s interface and, subsequently, to depen-\ndent units. There are many benefits from this principle, including increased extensibility, \nreusability, and maintainability. Since implementation is compartmentalized, new capa-\nbilities can be added simply by including a new variation of the implementation without \nchanges to old implementations. Also, in this way specific implementations can be reused.\nCompleteness and Sufficiency\nThe principles of completeness and sufficiency deal with efficient module creation. \nCompleteness is a characteristic that measures how well design units provide the required \nservices to achieve their intent. For example, during the detailed design activity, a commu-\nnication class can be considered complete for a particular application if it provides services \nfor establishing and terminating connections, sending and receiving messages. Missing \nany of these services would render the class incomplete. On the other hand, sufficiency \nmeasures how well design units are at providing only the services that are sufficient for \nachieving their intent. Consider the same communication class, which can include services \nfor logging statistics, visualization of network activity, or any other capability applicable \nto the communication task. Although these capabilities enhance the class\u2019 service list, the \nclass is considered sufficient by providing the required services of opening/terminating \nconnections, sending, and receiving messages. That is, these sets of services are sufficient \nto achieve the unit\u2019s required functions, nothing more and nothing less.\nPractical Software Design Considerations\nDesign principles are well-known throughout the software engineering community and \nare applied in one way or another in most projects. However, other considerations need to \nSegregation of Interface\nand Implementation\nEncapsulation\nFIGURE 1.6\nPrinciple of segregation of interface and implementation.\n", "page": 54, "type": "text", "section": "Page 54"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 31\nbe made to provide the appropriate context in which these principles can be successfully \napplied for developing high-quality software systems. These considerations are discussed \nin the next sections.\nDesign for Minimizing Complexity\nDesign is about minimizing complexity. Every decision that is made during the design phase \nmust take into account reducing complexity (McConnell 2004). In fact, the majority of design \nprinciples (e.g., modularization, abstraction, encapsulation) are meant to reduce complexity \nin one way or another. By doing this, details of the problem solution can be pushed further \ndown the process, where they can be appropriately handled. As another example, consider \nHCI design: it is all about reducing complexity for the user. Finally, code design is about \nreducing complexity for other developers maintaining the software. As rule of thumb, when \nfaced with competing design options, always choose the one that minimizes complexity.\nDesign for Change\nAs stated before, software will change; therefore, design with extension in mind. There are \nnumerous reasons for this; for example, customers who like the software may want to extend \nits functionalities. On the other hand, customers who are discontent with the \u00ad\nsoftware may \nwant to replace or remove functionality. In other cases, hardware changes may trigger a \nsoftware change; advances in communications may cause software to change; or, simply, \nnewer, better software technology becomes available triggering a change of \u00ad\nsoftware that \nintroduces no new functionality but a more maintainable development technology that \nis supported by current practices. In any case, software will change; therefore, its very \nown nature requires software designers to plan for the future. A variety of \u00ad\ntechniques is \n\u00ad\navailable during the detailed design phase to achieve this.\nSoftware Design Strategies\nThroughout the years, a wide variety of strategies for designing software has been \u00ad\nproposed. \nSome of these include structured design, object-oriented design, aspect-oriented design, \ndata component-based design, and data structure-based design. Two popular strategies are \ndiscussed in the following sections.\nStructured Design\nIn a broad context, structured design refers to any disciplined functional design approach \nwhere software systems are decomposed into independent, single-purpose modules, using \nan iterative top-down approach. The main focus of structured design is on the functions \nthat systems need to provide, the decomposition of these functions, and the creation of \nmodules that incorporate these functions. Structured design approaches are typically \nemployed after structured analysis, where the main purpose is to derive a structure chart \n", "page": 55, "type": "text", "section": "Page 55"}
{"text": "32\u2002 \u2022\u2002 Software Engineering Design\ufeff\n(i.e., software architecture) from data flow diagrams. Structured design introduced many \nbenefits; for instance, by decomposing the system into independent, single-purpose \nmodules\u00ad\n, programs were simpler to understand, manage, code, debug, and reuse (Stevens \n1981). However, structured design does not address the issues of data abstraction and infor-\nmation hiding and \u201cis largely inappropriate for use with object-based and object-oriented \nprogramming languages\u201d (Booch 1994, p. 22).\nObject-Oriented Design\nUnlike structured design, which focuses on functional decomposition of systems, \nobject-oriented design focuses on object decomposition. Formally, the IEEE (1990, p. 51) \ndefines object-oriented design as\nA design strategy in which a system or component is expressed in terms of objects and \n\u00ad\nconnections between those objects.\nObjects provide numerous capabilities that make them desirable for efficiently designing \nsoftware systems. For example, objects are capable of maintaining state information and \nprovide services that can be used independently or relative to the object\u2019s state. Therefore, \nthey are naturally good building blocks for creating good abstractions. Object-oriented \ndesigns also provide capabilities for inheritance and polymorphism, which provide vari-\nous advantages when designing complex and large-scale software systems. Inheritance \nallows designers to create families of objects capable of reusing each other\u2019s interfaces or \ninterfaces with implementations. While inheritance allows objects to inherit interfaces \nand implementations, polymorphism allows objects to change the behavior of inherited \ninterfaces\u00ad\n. Numerous design methods based on objects have been proposed. Today, the UP \nprovides a popular framework for object-oriented software engineering using UML.\nCHAPTER SUMMARY\nDesigns in software engineering are used to identify, evaluate, and specify the structural \nand behavioral characteristics of software systems that adhere to some specification. \nSoftware designs provide blueprints that capture how software systems meet their required \nfunctions and how they are shaped to meet their intended quality. Formally, software engi-\nneering design is defined as the process of identifying, evaluating, validating, and specify-\ning the architectural, detailed, and construction models required to build software that \nmeets its intended functional and nonfunctional requirements and the result of such a pro-\ncess. The\u00a0term software design is used interchangeably in practice as means to describe \nboth the process and product of software design. Throughout the design process, designers \nare constantly engaging in problem-solving activities that are fundamental to all modern \nengineering projects; therefore, they can be characterized as specialized problem solvers. \n", "page": 56, "type": "text", "section": "Page 56"}
{"text": "Introduction to Software Engineering Design\u2002 \u2022\u2002 33\nTo ensure that all problem considerations are incorporated when solving design problems, \na holistic\u00ad\n problem-solving approach must be adopted, including all relevant concerns. \nSoftware design provides numerous advantages from both product development and pro-\ncess; however, many challenges must be considered and addressed before software designs \ncan lead to complete and sufficient software models. In today\u2019s modern software systems, \nnumerous design principles, processes, strategies, and other factors affect how designers \n\u00ad\nexecute the software design phase. When equipped with the proper design foundation \nknowledge, an understanding of the designer\u2019s roles and responsibilities can be acquired; \nallowing \u00ad\ndesigners to become effective in designing large-scale software systems under a \nwide variety of challenging conditions.\nREVIEW QUESTIONS\n\t\n1.\tWhat is software engineering design, and why is it important?\n\t\n2.\tWhat are the three states of problem solving? Describe each and explain how they \napply to design problems?\n\t\n3.\tWhat are two types of thinking employed during problem solving? Provide an \n\u00ad\nexample of how they are applied to design problems.\n\t\n4.\tWhat is the difference between well-defined, ill-defined, and wicked problems and \nhow these problems can affect software design?\n\t\n5.\tWhat is the difference between an algorithm and a heuristic? Give examples of how \nboth approaches can be applied during the design phase?\n\t\n6.\tWhat is the holistic approach to problem solving? Explain.\n\t\n7.\tHow does design fits within the software engineering life cycle? Explain.\n\t\n8.\tWhat are the major activities of the software design phase, and how do they differ \nfrom one another?\n\t\n9.\tList and explain the challenges faced in software design.\n\t 10.\tWhy is important to emphasize on documentation and management activities \n\u00ad\nduring design?\n\t 11.\tCompare and contrast the following: interface design, user interface design, and \n\u00ad\nconstruction design.\n\t 12.\tWhat are the different roles of software designers? How do they differ?\n\t 13.\tExplain the difference between procedural and data abstraction.\n\t 14.\tWhat is content coupling, and how does it differ from other forms of coupling?\n\t 15.\tExplain in detail the concept of cohesion.\n\t 16.\tWhat do completeness and sufficiency mean?\n\t 17.\tWhat is the difference among the principles of modularization, abstraction, encapsu-\nlation, and separation of interface and implementation? Provide an example of each.\n\t 18.\tCompare and contrast the structured design strategy with the object-oriented design \nstrategy.\n", "page": 57, "type": "text", "section": "Page 57"}
{"text": "34\u2002 \u2022\u2002 Software Engineering Design\ufeff\nREFERENCES\nAbran, Alain, James W. Moore, Pierre Bourque, and Robert Dupuis. Guide to the Software Engineering Body of \nKnowledge\u20142004 Version\u2014SWEBOK. Los Alamitos, CA: IEEE Computer Society Press, 2005.\nBass, Len, Paul Clements, and Rick Kazman. Software Architecture in Practice, 2d ed. Boston: Addison-Wesley, \n2003.\nBooch, Grady. Object-Oriented Analysis and Design with Applications, 2d ed. Santa Clara, CA: Addison-Wesley, \n1994.\nBrassard, Gilles, and Paul Bratley. Fundamentals of Algorithmics. Upper Saddle River, NJ: Prentice Hall, 1995.\nDowson, Mark. \u201cThe Ariane 5 Software Failure.\n\u201d ACM SIGSOFT Software Engineering Notes, March 1997.\nDym, Clive L., and Patrick Little. Engineering Design: A Project-Based Introduction. Hoboken, NJ: Wiley, 2008.\nFox, Christopher. Introduction to Software Engineering Design: Processes, Principles, and Patterns with UML2. \nBoston: Addison Wesley, 2006.\nGiachetti, Ronald E. Design of Enterprise Systems: Theory, Architecture, and Methods. Boca Raton, FL; CRC\u00a0Press, \n2010.\nGriffin, Ricky W. Management, 10th ed. Mayfield Hts, Ohio: South-Western College Pub, 2010.\nHarrell, C., Biman K. Ghosh, and Royce O. Bowden. Simulation Using Promodel. New York: McGraw-Hill, 2004.\nIEEE. \u201cIEEE Recommended Practice for Software Design Descriptions.\u201d 1998. http://ieeexplore.ieee.org/xpl/\nfreeabs_all.jsp?arnumber=741934.\nIEEE. \u201cIEEE Standard Glossary of Software Engineering Terminology.\u201d IEEE, 1990. http://ieeexplore.ieee.org/\nxpl/freeabs_all.jsp?arnumber=159342.\nIEEE/ACM. Software Engineering 2004. August 23, 2004. Available at: http://sites.computer.org/ccse/\nSE2004Volume.pdf (accessed September 22, 2010).\nKershaw, T. C., and S. Ohlsson. \u201cMultiple Causes of Difficulty in Insight: The Case of the Nine-Dot Problem.\u201d \nJournal of Experimental Psychology: Learning, Memory, and Cognition 30:3\u201315, 2004.\nLaplante, Phillip A. Requirements Engineering for Software and Systems. Boca Raton, FL: Auerbach Publications, \n2009.\nLiskov, Barbara, and John Guttag. Program Development in Java: Abstraction, Specification, and Object-Oriented \nDesign. Boston: Addison-Wesley, 2000.\nMcConnell, Steve. Code Complete, 2d ed. Redmond, WA: Microsoft Press, 2004.\nMeyers, Scott. Effective C++: 55 Ways to Improve Your Programs and Designs, 3d ed. Boston: Addison-Wesley, \n2005.\nU.S. General Accounting Office. (GAO). Patriot Missile Defense: Software Problem Led to System Failure at \nDhahran, Saudi Arabia. Washington, DC: U.S. Government Accountability Office, 1992.\nPlotnik, Rod, and Haig Kouyoumdjian. Introduction to Psychology, 9th ed. Wadsworth Publishing, 2010.\nPressman, Roger S. Software Engineering: A Practitioner\u2019s Approach, 7th ed. Belmont, CA: McGraw-Hill, 2010.\nSommerville, Ian. Software Engineering, 9th ed. Boston: Addison Wesley, 2010.\nStevens, Wayne P. Using Structured Design: How to Make Programs Simple, Changeable, Flexible and Reusable. \nHoboken, NJ: John Wiley & Sons, 1981.\n", "page": 58, "type": "text", "section": "Page 58"}
{"text": "35\n2\nSoftware Design with \nUnified\u00a0Modeling Language\nCHAPTER OBJECTIVES\n\u2022\t Understand the role and importance of Unified Modeling Language \n(UML) in software design\n\u2022\t Become familiar with UML\u2019s common structural and behavioral \ndiagrams\n\u2022\t Understand the relationship between structural UML models and code\n\u2022\t Understand how to model concurrency with UML\nCONCEPTUAL OVERVIEW\nCommunication is an essential, critical skill for engineers. Throughout a \nproject\u2019s life cycle, software engineers spend a great deal of time and effort \ncommunicating with stakeholders, among themselves, and with the com-\nputer via programming languages. By unifying the communication lan-\nguage, so that it is appropriate for stakeholders, software engineers, and \ntranslation to programming languages, a more efficient design process can \nbe executed and better framing of design problem and their solutions can be \nachieved to account for all intricacies that are present throughout the design \nprocess. Unified Modeling Language (UML) provides the mechanisms for \ncreating detailed models that portray a system\u2019s design. By providing a visu-\nalization method for complex design concepts, communication is enhanced \nat all phases of the software development life cycle. This chapter presents the \nfundamental concepts of UML to establish a common frame of reference for \ndiscussing important design concepts throughout the rest of the book.\n", "page": 59, "type": "text", "section": "Page 59"}
{"text": "36\u2002 \u2022\u2002 Software Engineering Design\ufeff\nWHAT IS UML?\nThe Unified Modeling Language is a visual language with an extensive set of features \nappropriate for designing software systems across a broad set of application domains. It is \nthe result of years of collaborative work spent in devising a unified approach for modeling \nsoftware systems. The first efforts focused on unifying three popular modeling methods: \nthe Booch method (devised by Grady Booch); the object-oriented software engineering \n(OOSE) method (devised by Ivar Jacobson); and the object modeling technique (OMT) \nmethod (devised by James Rumbaugh). The goals of this unification project were specified \nby Booch, Rumbaugh, and Jacobson (2005, p. xvii) as follows:\n\t\n1.\tTo model systems, from concept to executable artifact, using object-oriented \ntechniques\n\t\n2.\tTo address the issues of scale inherent in complex, mission-critical systems\n\t\n3.\tTo create a modeling language usable by both humans and machines\nThe development of early UML versions generated interest among the software engi-\nneering community, resulting in the creation of UML consortium supported by numerous \ninfluential organizations, such as Microsoft, IBM, Oracle, and Rational. This collaboration \nresulted in UML 1.0, which after revisions was adopted by the Object Management Group \n(OMG) in 1997 as UML 1.1 (Booch et al. 2005). Since then, UML has evolved through \nmany versions that improve capabilities for efficient analysis, design, and implementation \nof software systems of varying complexity. In 2005, a major revision of UML 1 was pro-\nposed and adopted by the OMG as UML 2.0. At the time of writing, UML 2.3 provides \nthe latest specification (UML 2.3 Superstructure 2010). Formally, UML can be defined as a \nvisual language for specifying, analyzing, and documenting design elements essential for \nmodeling and building software system. To provide an organized methodology for creat-\ning models that address different stakeholders\u2019 concerns, UML defines different modeling \ndiagrams and provides a classification scheme that delineates clearly between the static \nand dynamic nature of software systems, as seen in Table\u00a02.1.\nEvery diagram in UML belongs to one of the classes presented in Table\u00a02.1. Throughout \nthe rest of the chapter, UML diagrams fundamental for modeling systems from both struc-\ntural and behavioral perspectives are presented, and their capabilities for addressing issues \nof different concerns from different levels of abstractions are examined.\nTABLE\u00a02.1\nClassification of UML Diagrams\nClassification\nDescription\nStructural\nConcerned with capturing and specifying static elements and their interrelationships \nrequired for supporting the solution to a given problem, within a given context\nBehavioral\nConcerned with capturing and specifying the dynamic behavior and the inherent complexities \npresent in the behavioral aspects of software systems\nwww.allitebooks.com\n", "page": 60, "type": "text", "section": "Page 60"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 37\nWHY STUDY UML?\nUML 2.3 provides 14 different types of diagrams that can be used for modeling structural \nand behavioral aspects of software systems. Since software systems vary across a large set \nof application domains, not all 14 diagrams are required or used in any given project. For \nexample, real-time systems may employ the use of UML timing, state, and communica-\ntion diagrams to model behavior and real-time constraints related to real-time systems. \nDistributed systems may employ sequence diagrams for modeling time-ordered sequence \nof operations among components and deployment diagrams for modeling distributed \naspects of the systems. Finally, object-oriented systems\u2014which can also be distributed or \nreal-time systems\u2014may rely heavily on class and object diagrams to model class hierar-\nchies and particular instances of their interaction. Even though not all diagrams are used \nin system modeling efforts, it is important to identify a common set of diagrams that pro-\nvide appropriate avenues for model\u00ad\ning essential activities during the software development \nprocess. Therefore, the study of UML becomes important so that the modeling capabilities \nof particular diagrams are well understood and applied in practical efforts. The two main \nreasons for studying UML include\n\u2022\t The UML enhances system analysis and specification.\n\u2022\t The UML enhances communication.\nModeling software is essential to developing high-quality, large-scale, and software-\u00ad\nintensive systems. The UML is important because it provides well-known and widely \naccepted means for modeling complex systems. Through UML, a common approach can \nbe used for analyzing, evaluating, and specifying systems at all levels of abstraction during \nrequirements, design, and construction. After systems are specified at one level of abstraction \nusing UML, the models are transferred downstream for subsequent, finer-grained analy\u00ad\nsis, evaluation, and specification. This process continues until the software is constructed \nand ready for testing and verification. Throughout this process, UML is the main tool \nfor transferring knowledge and enhancing communication among stakeholders, including \ncustomers, designers (i.e., architects, component, and construction), \u00ad\nprogrammers, and \nmanagers. By providing the means for visualizing complex system concepts, it becomes \neasier to reason about the problem at hand, therefore increasing communication during \nthe problem-solving process. The UML\u2019s visualization capabilities enhance communica-\ntion greatly throughout, especially when creating documentation deliverables, such as the \nsoftware design document, which lives long after the development effort is complete.\nTHE UML\u2019S FUNDAMENTALS\nThe UML is an extensible and flexible language that can be used to model almost any aspect \nof today\u2019s modern software systems. Given the rich set of modeling features provided by \n", "page": 61, "type": "text", "section": "Page 61"}
{"text": "38\u2002 \u2022\u2002 Software Engineering Design\ufeff\nUML, its application can become confusing at times, resulting in model inconsistencies \nthat can hinder communication during the development effort. The built-in flexibility in \nUML is essential for modeling systems with disparate capabilities; therefore, understand-\ning its fundamental building blocks is necessary for employing the built-in flexibility to \nmodel a wide variety of software systems. The UML building blocks are grouped as follows:\n\u2022\t Classifiers\n\u2022\t Relationships\n\u2022\t Enhancing features\nClassifiers are structural things that represent conceptual or physical elements of a model \n(Booch et al. 2005). They are typically the main elements of UML models, and each type of \nUML diagram has a specific type of classifiers so that not all classifiers are relevant to all \nUML diagrams. A list of common UML classifiers is presented in Table\u00a02.2.\nClassifiers provide designers the capability of defining the structure for achieving some \ndesired system feature. This capability allows designers to visualize the structural design \nof systems, provide analysis, and make design improvements, all at design time. Structural \ndesigns are good for evaluating logical relationships in software design; however, they are \nlimited when it comes to evaluating the system\u2019s behavioral aspects\u2014that is, modeling \nand evaluating the manifestation and behavioral aspects of classifiers once the system is \nexecuted. For this purpose, UML provides techniques for representing almost all classi-\nfiers as manifested entities. For example, structural classes can be modeled as behavioral \n(executing) objects; the behavior of active classes can be modeled using active objects; \ncomponents can be modeled as component instances; use cases can be modeled as use \ncase executions; and nodes can be modeled as node instances (Booch et al. 2005). The \nTABLE\u00a02.2\nUML 2.3 Common Classifiers\nClassifier\nDescription\nUse case\nClassifier used to model a single required system behavior; represented with icons of \nelliptical shape\nComponent\nRepresents a modular and replaceable part of the system; modeled using a box with the \nkeyword <<component>> and optional component icon on the top right corner\nClass\nClassifier used to model a type in terms of operations, attributes, relationships, and other \nsemantics; modeled with a rectangular box\nActive class\nClassifier used to model a class that owns an independent flow of execution and can initiate \ncontrol activity; modeled as a class with double lines on each side\nInterface\nClassifier that models the set of operations that specify the services provided by a class or \ncomponent; represented as stereotyped classes or using the ball-and-socket notation\nNode\nClassifier used to model a physical element (e.g., computer), its processing capabilities, and \nother semantics; modeled using a cube\nArtifact\nClassifier that models a physical deployable information element (e.g., .exe, .dll, script, etc.); \nmodeled using a rectangle with the keyword <<artifact>>\n", "page": 62, "type": "text", "section": "Page 62"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 39\nusefulness of modeling classifiers (and their behavioral counterparts) is maximized when \ndefining and visualizing the interconnections that exist among them. A list of UML com-\nmon relationship types is presented in Table\u00a02.3.\nThe UML is required to provide enough flexibility to allow designers to enhance and \nevolve the fundamental building blocks so that they become appropriate for modeling par-\nticular systems. Therefore, it provides the means for enhancing and extending classifiers, \nbehavioral manifestations, and relationships through common extension mechanisms. \nThese extension mechanisms allow designers to redefine UML elements so that they can \nrepresent domain-specific concepts. Also, extension mechanisms allow detailed design \ninformation to be captured and specified in the models. The common mechanisms for \nenhancing UML are presented in Table\u00a02.4.\nTogether, classifiers, relationships, and enhancement mechanisms provide powerful \n\u00ad\nconstructs for evaluating both structural and behavioral design elements that interact and \ncollaborate with each other, provide the means for evaluating design alternatives, and \n\u00ad\nprovide the sufficient information to build the software system.\nTABLE\u00a02.3\nCommon Types of UML Relationships\nRelationship\nDescription\nDependency\nDashed line (typically directed with a stick arrow) used to model the relationship between \ntwo UML elements indicating that changes to one element affect the other\nAssociation\nLine used to model the relationship between two UML elements indicating that a connection \nexists between associated instances at run time; associations can be directed using a stick \narrow\nGeneralization\nLine with a hollow arrowhead used to model the relationship between two UML elements \nindicating that one element (i.e., the child) inherits features from another (i.e., the parent)\nRealization\nRelationship between two UML elements indicating that one element realizes a specified \ninterface; modeled using a dashed line with hollow arrowhead\nTABLE\u00a02.4\nCommon UML Mechanisms for Enhancement\nMechanism\nDescription\nNotes\nMechanism for adding descriptive information to UML elements and diagrams; modeled \nusing a rectangle with a dog-eared corner and can be connected to a design element using a \ndashed line\nStereotypes\nMechanism for extending UML by adding information that gives existing UML element a \ndifferent meaning, therefore creating a semantically different element for modeling \napplication-specific concepts; modeled as existing UML elements with the <<stereotype>> \nmechanism (e.g., <<subsystem>>)\nTagged Values\nMechanism for adding new properties to a stereotype; modeled by adding the tagged value in \nthe form of property = value to existing stereotyped UML elements (e.g., data rate = 5\u00a0Mbps)\nConstraints\nMechanism for specifying constraints to design elements; associated with specific design \nelements in the form of {constraint description} (e.g., {secure line})\n", "page": 63, "type": "text", "section": "Page 63"}
{"text": "40\u2002 \u2022\u2002 Software Engineering Design\ufeff\nSTRUCTURAL MODELING\nStructural modeling is concerned with capturing and specifying structural elements and \ninterrelationships required for supporting the solution to a given problem, within a given \ncontext. Structural models are static in nature, since they model structure and not behav-\nior; therefore, they provide the main avenues for evaluating design decisions that directly \nsupport functional requirements as well as desired quality attributes, such as modularity, \nportability, and maintainability. A list of common UML structural diagrams is presented \nin Table\u00a02.5.\nOther structural diagrams include composite structure and profile diagrams. As seen, each \nstructural diagram addresses a particular system concern; therefore, the set of classifiers \nand relationship employed varies from diagram to diagram. Understanding the capabilities \nand goals of each structural diagram is important for determining the selection of effective \nconstructs that are appropriate at particular levels of abstraction during system design.\nCOMPONENT DIAGRAMS\nA component represents a modular part of a system that encapsulates its contents and \nwhose manifestation is replaceable within its environment (UML 2.3 Superstructure 2010). \nFor this reason, component diagrams can be used to decompose systems and represent \ntheir structural architecture, from a logical perspective. Components can be modeled \nusing an external black-box view or internal white-box view. With the black-box view, \ncomponents encapsulate their internal structure; therefore, collaboration with other com-\nponents is achieved through well-defined interfaces. These interfaces can be classified as \nprovided or required interfaces. Provided interfaces are used by other external components \nto interact with the component providing the interface. Required interfaces are those the \nTABLE\u00a02.5\nUML 2.3 Structural Diagrams\nDiagram\nDescription\nComponent\nHigh-level; used to model the software as group of components connected to each other \nthrough well-defined interfaces and thus said to be replaceable within its context\nClass\nUsed to model software as a set of classes, including their operations, attributes, and \ntheir\u00a0mutual relationships\nObject \nUsed to model an instant snapshot of the life of an object during execution, including \nits\u00a0state and attribute values\nDeployment \nUsed to model the physical realization of software systems, including physical nodes \nwhere software is deployed, interfaces between nodes, software artifacts executing on \nnodes, and the manifestation of software components within the software artifacts\nPackage Diagram\nDiagram used to model the division of software as a set of packages, including the \nrelationships between packages\n", "page": 64, "type": "text", "section": "Page 64"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 41\ncomponents need to realize a component\u2019s function. Modeling component interfaces in \nUML can be achieved using two distinct notations: the ball-and-socket notation or the \ndependency and realization relationships, as seen in Figure\u00a02.1.\nFigure\u00a0 2.1 shows the basic component relationships and examples of component \ndiagrams\u00ad\n. As seen, the basic notations for modeling components are components, assembly \nconnectors, and provided/required interfaces. The notations presented in Figure\u00a02.1 are used \nto model components using an external, black-box view; however, components can also \nbe designed using an internal, white-box view, not presented in Figure\u00a02.1. When using \nComponent Relationships\nProvided Interface\n<<component>>\nComponentA\nRequired Interface\n<<assembly>>\nDependency\nDependency\nRealization\nRealization\n<<component>>\nComponentA\n<<component>>\nComponentA\n<<component>>\nComponentA\n<<component>>\nComponentA\n<<component>>\nComponentA\n<<component>>\nComponentA\n<<component>>\nComponentA\n<<component>>\nComponentB\n<<component>>\nComponentB\n<<interface>>\nInterfaceB\n<<interface>>\nInterfaceB\nClassA\nIRequired\nIRequired\nIProvided\nIProvided\nPort 2\nPort 1\nPorts and Delegates\n<<delegate>>\n<<delegate>>\n<<component>>\nComponentB\n<<component>>\nClientCollectionSystem\n<<component>>\nSensorManager\nIClientData\nIClientData\nISchedule\nISchedule\nPort 2\nPort 1\nSample Component Diagram\n<<delegate>>\nISensorControl\nIVideoControl\n<<delegate>>\n<<component>>\nClientManager\n<<component>>\nVideoManager\nFIGURE 2.1\nOverview of UML component diagram.\n", "page": 65, "type": "text", "section": "Page 65"}
{"text": "42\u2002 \u2022\u2002 Software Engineering Design\ufeff\nthe black-box approach, components use the ports and delegates concepts to model how \ncomponents interact with other (external) components and how the responsibility for real-\nizing external requests are delegated throughout parts of components. As seen, ports are \nused to model access points for allowing the external environment to access the compo-\nnents\u2019 \u00ad\nservices and for allowing components to interact with their  external environment. \nDelegation connectors are used to model the link between the external provided inter-\nfaces of a component to the realization of those interfaces internally within the component \n(UML 2.3 Superstructure 2010). Similarly, delegation connectors model the link between \ninternally required interfaces to ports requiring the interface from external components.\nFigure\u00a02.1 presents a design element for devising a logical representation for the software \narchitecture of a sensor collection system. The system includes a client collection node \nthat is decomposed into ClientManager, SensorManager, and VideoManager. The \u00ad\nclient \n\u00ad\nsubsystem requires a collection schedule, which provides the information necessary for \nactivating sensor and video nodes to begin collection. The client subsystem makes this \ninformation available to other nodes upon request. As seen, the ClientManager component \nrequires a collection schedule, which is delegated to Port 2; this interface requires external \ncomponents to provide the collection schedule using the ISchedule interface. In\u00a0addition, \nthe ClientCollectionSystem component provides status information to external components \nvia Port 1 using the IClientData interface. The responsibility of realizing the IClientData \ninterface to provide status data is delegated to the ClientManager component so that all \nrequests received at Port 1 can be handled by the target component.\nLogical versus Physical Components\nThe UML 2.3 Superstructure Specification supports the specification of both logical and \nphysical components and describes them as substitutable units that can be replaced at \ndesign time or run time (UML 2.3 Superstructure 2010). This, combined with the previous \nusage (in UML 1.x) of components, creates confusion among designers. Although UML 1.x \nand UML 2.x components can look the same in UML, the context in which they are used \nshould make the distinction between physical and logical components evident. For this \nreason, a thorough discussion is needed.\nLogical components are used from a logical perspective, while physical components \nare used from a deployment perspective, which in UML 2.0 can be modeled as artifacts. \nLogical components are components that can be replaced at design time. For example, \nthe internal structure of a software system may be composed of three logical components: \nthe UI component, the business logic component, and the database component. Each \nof these has well-known interfaces that allow them to be replaceable at design time. By \n\u00ad\nhaving well-known interfaces, the internal design of components (e.g., the UI \u00ad\ncomponent) \nbecomes irrelevant to other external components (e.g., the business logic component). \nLogical \u00ad\ncomponents specify the decomposed structure of software; they exist in the \u00ad\ncontext \nof the \u00ad\nlogical design of the software system.\nOn the other hand, physical components are components that exist within the context \nof deployment; they are distinctively different from logical components in that they are \n", "page": 66, "type": "text", "section": "Page 66"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 43\nindependently deployable units that reside on their own and provide services to other \nphysical components or software applications. They provide stable interfaces that allows \nthem to be replaceable at run time, for example, JavaBean components, EJB components, \nand .NET components, which can be deployed independently through a jar file, ear file, \nand DLL file, respectively (Qian, Qian, Fu, Tao, Xu, and Diaz-Herrera 2009).\nUsing components to denote logical units (as opposed to physical units) is new to UML\u00a02.0; \ntherefore, they provide modeling features that are specially fitting for designing logical ele-\nments of the software architecture. In previous versions of UML, components were reserved \nexclusively for modeling physical entities deployable within a system and replaceable at run \ntime. Now, UML supports the specification of both logical and physical components, together \nwith the artifacts that implement them and the nodes on which they are executed (UML 2.3 \nSuperstructure 2010). This new paradigm allows designers to model physical deployment \naspects of components using the artifact classifier deployed on a node (Booch et al. 2007).\nCLASS DIAGRAMS\nClass diagrams exist at a lower level of abstractions than component diagrams. That is, whereas \ncomponent diagrams serve well to modularize the system, they do not have a direct translation \nfrom model to code. Class diagrams have direct translation to object-oriented programming \nlanguages. In simple terms, class diagrams are models consisting of classes and relationships \nbetween classes necessary to achieve a system\u2019s functionality. Therefore, whether a detailed \nclass diagram is made or not, the resulting object-oriented code will always reflect some class \ndesign. This characteristic of class designs results in a two-way relationship between class \n\u00ad\ndiagrams and code, which allows designers to generate code from class diagrams (i.e.,\u00a0code \ngeneration or forward engineering) or to generate class diagrams from code (i.e., reverse \nengineering). This makes class diagrams the most powerful tool for component designers to \nmodel the design characteristics of object-oriented software before the construction phase.\nClass diagrams vary in complexity, ranging from diagrams with a few classes with \n\u00ad\nsimple relationships to diagrams with many classes interconnected via elegant and effi-\ncient relationships. Class diagrams are perhaps the most important UML diagrams for \nobject-oriented component designers. To effectively model object-oriented software, \ndesigners need to have an understanding of the basic class constructs, relationships, and \nthe direct mapping that result from model to code.\nClasses\nA class is the specification of a type, nothing more, nothing less. For a class to be useful to \nsoftware programs, objects of that class need to be instantiated during the program\u2019s execu-\ntion. Instantiation is the process of manifesting a class in the computer\u2019s memory. A single \nclass specification can be manifested in the computer\u2019s memory during program execution \nas multiple objects, their specific values for each having operations and relationships with \n", "page": 67, "type": "text", "section": "Page 67"}
{"text": "44\u2002 \u2022\u2002 Software Engineering Design\ufeff\nother objects. Classes are the building blocks of object-oriented systems; therefore, being \nable to model classes in an efficient and reusable way is essential. In UML, a class is mod-\neled with a rectangular shape with three main compartments, namely, the name, attribute, \nand operation compartments.\nName Compartment\nThe name compartment is reserved for the class name and its stereotype. A class name is \na string value that uniquely identifies a class from other classes in the system. Class names \ncan be qualified to show the package that they belong to in the form of Owner::ClassName, \nwhere Owner refers to the package that owns the class and ClassName refers to the class \nname. UML classes can be enhanced to convey more information by using stereotypes. \nStereotypes are displayed above the class name using the format <<stereotype>>. Commonly \nused stereotypes for classes include the <<interface>> and <<utility>> \u00ad\nstereotypes. The \n<<interface>> stereotype is used to model interfaces, which specify the services of a class. \nThe <<utility>> stereotype is used to model a class that has no instances but instead repre-\nsents a named collection of class-scoped (i.e., static) attributes and operations.\nAttribute Compartment\nAttributes are named properties used to specify the information required by objects to carry \nout their intended function or to represent the object modeled by the class. The attribute \ncompartment is reserved for specifying the class attributes, including their name, type, and \nother properties, such as visibility and scope. Attribute names, similar to class names, are \nstring values that uniquely identify one attribute from all other attributes. The attribute type \nspecifies the type of data appropriate for the attribute, for example, integer, string, or double. \nTypically, the attribute compartment is used to specify primitive types, whereas attributes \nthat result as consequence of relationships with user-defined types are kept from the attri-\nbute compartment; these are modeled using the appropriate UML relationship with a label \ncontaining the attribute\u2019s name. The attribute\u2019s visibility specifies policies on how attributes \nare accessed by clients. In UML, visibility can be set to the types represented in Table 2.6.\nThe scope of an attribute can be specified to be class-specific (i.e., static) or object-specific, \nwhich allows each individual object to have individual copies that help keep track of attri-\nbute values independently.\nTABLE\u00a02.6\nCommon Visibility Types in Class Diagrams\nVisibility\nSymbol\nDescription\nPublic\n+\nAllows access to external clients\nPrivate\n\u2013\nHides private members or operations from external clients\nProtected\n#\nAllows access internally within the class and to derived classes\nPackage\n~\nAllows access to entities within the same package\n", "page": 68, "type": "text", "section": "Page 68"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 45\nOperation Compartment\nOperations are services provided by classes. The operation compartment is reserved for \nspecifying the class operations, including their name, return type, parameters, and other \nproperties, such as visibility, scope, type (e.g., abstract), and constraints, as seen in\u00a0Figure\u00a02.2.\nThe class concept is easier to understand for most programmers, since it directly maps \nto code in object-oriented languages. An important aspect of modeling software with class \ndiagrams is the understanding of how classes modeled in the design translate to code. \n<<Class Stereotype>>\nClassName\n<<interface>>\nAbstractClass\n+interfaceMethod(): void\n\u2013attribute: int\n+operation1(): void\n\u2013operation2(): void\n+publicAttribute: int\n\u2013privateMethod(param: int): void\n#protectedMethod(): int\n+abstractMethod(): void\n+publicStaticMethod(): void\nClass Structure\nClass Diagram\nRelationships\nSample Class Diagram\nClassA\nDependency\nClassB\nClassA\nAssociation\nClassB\nClassA Directed Association ClassB\nClassA\nAggregation\nClassB\nClassA\nComposition\nClassB\nClassA\nGeneralization\nClassB\nClassA\nRealization\nClassB\nPartClassA\nConcreteClass\n+interfaceMethod(): void\nWholeClass\nDerivedClass\nPartClassD\nIndependentClass\nSampleClass\nBaseClass\n\u2013pConcrete\n\u2013pPartA\n\u2013objectD\nFIGURE 2.2\nOverview of class diagram.\n", "page": 69, "type": "text", "section": "Page 69"}
{"text": "46\u2002 \u2022\u2002 Software Engineering Design\ufeff\nUML, as a universal language, provides the appropriate mechanisms to allow designers to \nmodel almost any aspect of modern object-oriented programming languages. Therefore, \nwhen modeling UML classes, it is important to understand what decisions made at design \ntime result in code. As an example, consider Listing 2.1, which presents C++ code for the \nSampleClass designed in the Sample Class Diagram section of Figure\u00a02.2.\nAs seen, generation of code from UML SampleClass results in the manifestation of UML \nclass as code; both versions (i.e., code and UML class drawing) of the SampleClass design \nelement convey identical information. The same UML class can be used to generate code in \nother programming languages as well. For example, Listing 2.2 presents the manifestation \nof UML SampleClass class design using the Java programming language.\nRelationships\nClasses that do not collaborate with each other may not accomplish much. Therefore, \ndepicting the relationships among classes is an essential part of class diagrams. UML rela-\ntionships can be used to model the connection between UML classes in a class \u00ad\ndiagram. \nThe UML relationships identified in Table\u00a02.3 can all be used in class diagrams to pro-\nvide connections appropriate to model relationships found in object-oriented systems. \nSimilar to the modeling of classes, it is essential for designers to understand how UML \nrelationships translate to code. Since UML is programming language-agnostic, some of the \nrelationships that have different meanings in the modeling domain will \u00ad\ntranslate with no \ndifference in the code domain.\nListing 2.1: C++ Code Generated from SampleClass Designed in Figure\u00a02.2\nclass SampleClass {\npublic:\n\t // Methods in this section are made public.\n\t void operation1() {\n\t \t // Code here.\n\t }\nprivate:\n\t // Methods and attributes in this section are made private.\n\t void operation2() {\n\t \t // Code here\n\t }\n\t // Private attribute.\n\t int attribute;\n};\nwww.allitebooks.com\n", "page": 70, "type": "text", "section": "Page 70"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 47\nDependency\nIn a class diagram, the dependency relationship, rendered as a dashed line and stick arrow, \nis used to model the relationship between two UML classes. Dependency models the rela-\ntionship that indicates that changes to one class affect the other. In C++, dependency rela-\ntionship may translate to a #include statement, as seen in Listing 2.3.\nAssociation\nAssociations are structural relationships; that is, they affect the structure of UML classes. \nIn a class diagram, associations are modeled with solid lines connecting two classes, as seen \nin Figure\u00a02.2 from BaseClass to SampleClass. This structural relationship indicates \nthat a connection exists between associated instances at run time. Associations are bidirec-\ntional by default. When using bidirectional associations, classes on each end of the associa-\ntion are structurally modified to provide navigation to their associated classes, providing \nListing 2.2: Java Code Generated from SampleClass Designed in Figure\u00a02.2\nclass SampleClass {\n\t // Public method.\n\t public void operation1() {\n\t }\n\t // Private method.\n\t private void operation2() {\n\t }\n\t // Private attribute.\n\t private int attribute;\n}\nListing 2.3: C++ Code Generated for UML Dependency Relationship\n// The dependency relationship can result in code as a #include.\n#include \u201cIndependentClass.h\u201d\nclass DependentClass {\n\t // Other attributes.\n\t // Other operations.\n};\n", "page": 71, "type": "text", "section": "Page 71"}
{"text": "48\u2002 \u2022\u2002 Software Engineering Design\ufeff\nobjects of one type ability to navigate to objects of another type and vice versa. Navigation \ncan be limited to one-way by modeling the association relationship with a directional \narrow. When this is the case, only the structure of one class is modified to provide navi-\ngational capabilities to the other. In C++, the structural modification resulting from using \nassociations is presented in Listing 2.4. As seen, the association from WholeClass and \nConcreteClass may translate to a pointer type.\nAggregation\nAggregation is a specialized form of association to denote a whole\u2013part relationship. That is, \naggregation can be seen as association with special semantics for modeling that one object \nis part of another. This added semantic is purely conceptual, and its use is constrained to \ndesign time; that is, forward-engineered aggregation relationships may translate to code in \nthe same way that associations are translated. Therefore, aggregation is used to increase the \ncommunication language at design time. Aggregation is modeled using an association line \nwith a hollow diamond at one end. Similar to association, aggregation can be made direc-\ntional, as seen in Figure\u00a02.2. When aggregation is used, the class connected to the diamond \npart of the aggregation arrow is said to be the whole, and the one connected to the arrow is \nthe part. As seen in Listing 2.4, aggregation may not be differentiable from association in \ncode, since both associations and aggregation can translate the same way in code.\nComposition\nObject composition is a specialized form of aggregation used to model ownership rela-\ntionship. Similar to aggregation, object composition models a whole\u2013part relationship; \nListing 2.4: C++ Code Generated for UML Association Relationship\n#include \u201cPartClassA.h\u201d\n#include \u201cConcreteClass.h\u201d\nclass WholeClass {\n\t // Code here...\nprivate:\n\t // Association relationship.\n\t ConcreteClass* pConcrete;\n\t // Aggregation relationship.\n\t PartClassA* pPartA;\n};\n", "page": 72, "type": "text", "section": "Page 72"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 49\nhowever, unlike aggregation, composition provides deeper semantics to indicate that the \nlifetime of the part is owned by the whole. Therefore, when the whole object goes out of \nscope, so does the part. In UML, object composition is modeled similarly to aggregation, \nbut instead of using a hollow diamond a solid diamond is used. In code, object composition \ncan be manifested in different ways. For example, Listing 2.5 presents the forward engi-\nneering (using C++) of some designed EventLogger class, which is used to log events \nin a system.\nAs seen, the EventLogger will own at run time an instance of the File class; there-\nfore, once the EventLogger goes out of scope, so will the instance of the File class. \nThis relationship can be translated differently in C++, via pointers. Listing 2.6 presents \nthe forward engineering of the EventLogger class with a different manifestation of the \nobject composition relationship.\nAs seen, object composition is achieved using a different approach that creates and \ndestroys the _file object. It is important to emphasize once again that UML is a flexible \nlanguage; therefore, forward engineering of UML models can be realized differently by dif-\nferent tools and different programming languages. For example, association, aggregation, \nand object composition can all look different in other object-oriented languages, such as \nJava and C#, which have no pointer notation.\nGeneralization\nGeneralization is a relationship that denotes inheritance; that is, one (child) class inher-\nits the structure and behavior of another (parent) class. Child classes can reuse services \nprovided by parent classes, override these services, or add entirely new ones. In class \n\u00ad\ndiagrams, generalization is modeled using a solid line with a hollow arrowhead connecting \ntwo classes, as seen in Figure\u00a02.2. Generalization always translates to code as inheritance, \nas seen in Listing 2.7.\nListing 2.5: C++ Code Generated for UML Composition Relationship\n// Object composition requires this dependency.\n#include \u201cFile.h\u201d\nclass EventLogger {\n\t // Code here...\nprivate:\n\t //The Object Composition Relationship.\n\t File _file;\n};\n", "page": 73, "type": "text", "section": "Page 73"}
{"text": "50\u2002 \u2022\u2002 Software Engineering Design\ufeff\nRealization\nWhereas generalization allows classes to inherit a parent\u2019s class interface and behavior, \nrealization allows classes to inherit the interface. Realization is used to model a contract \nrelationship in which one class specifies an interface contract and another buys into that \ncontract. When realization is used, classes that realize interfaces are required by contract \nto provide implementations for those interfaces before objects of those classes can be \ninstantiated. In UML, realization is modeled using a dashed line with a hollow arrowhead \nListing 2.6: C++ Code Generated for UML Composition Relationship\n#include \u201cFile.h\u201d\nclass EventLogger {\n\t // Constructor.\n\t EventLogger() {\n\t \t // Instantiate the message object during initialization.\n\t \t _file = new File;\n\t }\n\t // Destructor.\n\t ~EventLogger() {\n\t \t // Because of UML composition relationship, once the this object\n\t \t // goes out of scope, so does the _file object.\n\t \t delete _file;\n\t }\nprivate:\n\t // Object composition via pointers.\n\t File* _file;\n};\nListing 2.7: C++ Implementation for UML Generalization Relationship\n#include \u201cBaseClass.h\u201d\n// Generalization results in inheritance.\nclass DerivedClass : public BaseClass {\n\t // Code here...\n};\n", "page": 74, "type": "text", "section": "Page 74"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 51\nconnecting two classes. In code, realization can translate in different ways depending on \nthe target programming language; however, the semantics remain the same. In the code \ncontext, an interface is the collection of public methods that define the services provided \nby class. In C++, interfaces are created using pure virtual methods as seen in Listing 2.8. \nAs seen, the Gps class is made up of two pure virtual methods, which means that objects \nof the Gps class cannot be instantiated; the Gps class is typically referred to as an interface \nto define a common set of services, in this case, global positioning system (GPS) services.\nSimilar to all other relationships discussed so far, the realization relationship trans-\nlates different in different languages. In C++, the realization relationship translates iden-\ntical to the generalization relationship. As seen in Listing 2.9, the forward engineering \nListing 2.8: C++ Code Generation for Interfaces\nclass Gps {\npublic:\n\t // The interface method to obtain latitude information.\n\t virtual double getLatitude() = 0;\n\t // The start interface method.\n\t virtual double getLongitude() = 0;\n};\nListing 2.9: C++ Implementation for UML Realization Relationship\n#include \u201cGps.h\u201d\n// SimulatedGps realizes the Gps interface.\nclass SimulatedGps : public Gps {\npublic:\n\t // The interface method to obtain latitude information.\n\t double getLatitude() {\n\t \t // Generate a sample latitude and return.\n\t }\n\t // The interface method to obtain longitude information.\n\t double getLongitude() {\n\t \t // Generate a sample longitude and return.\n\t }\n};\n", "page": 75, "type": "text", "section": "Page 75"}
{"text": "52\u2002 \u2022\u2002 Software Engineering Design\ufeff\nof the SimulatedGps class results in inheritance with provided methods for both \ninterface\u00a0methods.\nGps services can be realized by different Gps classes differently; for example, one \nderived Gps class (e.g., HardwareGps) may realize the Gps interface by providing code \nthat interfaces with specific hardware to obtain actual readings for latitude and longi-\ntude. Another derived Gps class (e.g., SimulatedGps) can realize the Gps interface by \nproviding code that simulates latitude and longitude readings in case the Gps hardware \nis not available. By designing such framework (i.e., Gps interface, HardwareGps, and \nSimulatedGps) \u00ad\nclients can create their designs relying on using the Gps interface; by \nrelying on a well-defined interface, objects of type HardwareGps or SimulatedGps \ncan be swapped without ever having to change the client code.\nInterfaces and the realization relationship are so essential to object-oriented systems that \nmodern languages include keywords to support this relationship. In Java, the forward engi-\nneering of the Gps interface translates to an interface, as seen in Listing 2.10.\nThe forward engineering of the realization relationship in Java results in a class \nthat implements and interface. Listing 2.11 presents the forward engineering of the \n\u00ad\nrealization relationship for the SimulatedGps class in Java.\nListing 2.10: Java Code Generated for Interfaces\ninterface Gps {\n\t // The interface method to obtain latitude information.\n\t public double getLatitude();\n\t // The interface method to obtain longitude information.\n\t public double getLongitude();\n}\nListing 2.11: Java Code Generated for UML Realization Relationship\nclass SimulatedGps implements Gps {\n\t // The interface method to obtain latitude information.\n\t public double getLatitude() {\n\t \t // Generate a sample latitude and return.\n\t }\n\t // The start interface method.\n\t public double getLongitude() {\n\t \t // Generate a sample longitude and return.\n\t }\n}\n", "page": 76, "type": "text", "section": "Page 76"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 53\nSkill Development 2.1: Modeling Structure with Class Diagrams\nUsing pencil and paper, create the class diagram that models the following relation-\nships. Class B inherits from class A. Class B is directionally associated with class F and \nhas a special whole\u2013part relationship with class C, so that when B goes out of scope, \nso does C. Class B has another whole\u2013part relationship with class D, which depends \non interface E. When class B goes out of scope, D remains active as an object during \nrun time. Both classes G and H realize the E interface. When done, replace the class \nnames A, B, C, D, E, F, G, and H with names that represent types appropriate for these \nrelationships. Discuss your results with your peers.\nDEPLOYMENT DIAGRAMS\nDeployment diagrams are structural diagrams used to model the physical realization \nof software systems. They provide the means for visualizing the environment in which \nsoftware executes and how different entities communicate with each other to achieve the \n\u00ad\nsystems\u2019 functions. Deployment diagrams provide a static holistic view of the software \nsystem, from the deployment perspective, by providing avenues for modeling and speci-\nfication of the physical nodes, software artifacts, and the interrelationship among them.\nA node is a computational resource that host software artifacts for execution (UML 2.3 \nSuperstructure 2010). In UML, nodes are named classifiers modeled as a cube. Nodes can be \nassociated with other nodes to model the communication path between them; these com-\nmunication paths can be enhanced with stereotypes, multiplicity, and other adornments \nto further specify their properties and constraints. For example, in Figure\u00a02.3, communi-\ncation paths are enhanced by specifying the communication protocol (e.g., Transmission \nControl Protocol/Internet Protocol [TCP/IP], Universal Serial Bus [USB], and ZigBee).\nIn addition, multiplicity is used to model the number of elements connected to other \n\u00ad\nelements. As seen, there is a plurality of sensor nodes connected to the embedded \u00ad\nclient \ncomputer via the ZigBee wireless protocol. This deployment diagram also models the \noptional use of mobile devices in the system; that is, the embedded client computer may \nor may not have mobile devices interfacing to it. Nodes can also be modeled as hosts by \nincluding the components that execute in the node and their manifestation as artifacts.\nArtifacts are used to model physical units of information that form part of the software \nsystem, such as binary executable files, configuration files, and scripts. Artifacts are \u00ad\nmodeled \nusing the <<artifact>> keyword and can be related to nodes, components, and other arti-\nfacts using the dependency relationship, as seen in Figure\u00a02.3. Artifacts that collaborate with \nother artifacts can be modeled using the dependency relationship. To model the deployment \nrelationship, artifacts are connected to nodes using the dependency relationship with the \n<<deploy>> stereotype. When connected this way, it is said that the artifact is deployed on \nthe node connected to the other end of the dependency relationship. When necessary, the \n", "page": 77, "type": "text", "section": "Page 77"}
{"text": "54\u2002 \u2022\u2002 Software Engineering Design\ufeff\nmanifestation of components (designed in component diagrams) on a target node can be \nmodeled using the dependency relationship from the artifact to the component with the \n<<manifest>> stereotype.\nTogether, the concepts of nodes, relationships, and artifacts can be used to create deploy-\nment diagrams that include the physical nodes where software is deployed, communica-\ntion paths between nodes, software artifacts executing on nodes, and the manifestation of \nsoftware components within the software artifacts, as seen in Figure\u00a02.3.\nNodeA\nSensorNode\nWireless 3G Card\nMobilePhone\nDatabaseServer\nEmbeddedClientComputer\nVideoNode\nNodeB\n<<artifact>>\nArtifactA\nAssociation\nDeployment Diagram Relationships\n<<deploy>>\n<<manifest>>\n<<manifest>>\n<<deploy>>\n<<manifest>>\n<<TCP/IP>>\n<<ZigBee>>\n<<USB>>\n1\n1\n1\n1\n<<TCP/IP>>\n<<TCP/IP>>\n0..*\n1\n<<artifact>>\nClientCollectionSystem.exe\n<<TCP/IP>>\n1..*\n1..*\n1\n1\n1\n1\nDependency\nNodeB\n<<artifact>>\nArtifactA\n<<component>>\nComponentA\n<<component>>\nClientCollectionSystem\n<<component>>\nServerMonitorSystem\nApplicationServer\n<<artifact>>\nMonitorSystem.exe\n<<artifact>>\nArtifactA\n<<artifact>>\nArtifactB\nSample Deployment Diagram\nFIGURE 2.3\nOverview of UML deployment diagram.\n", "page": 78, "type": "text", "section": "Page 78"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 55\nBEHAVIORAL MODELING\nStructural modeling is essential to evaluate, characterize, and visualize the structural \ndesign of software systems from various perspectives. These static diagrams provide good \navenues for analyzing properties that are the direct result of structural designs, such as \ntheir ability to meet functional requirements, reusability, and maintainability; however\u00ad\n, \nthey are not adequate for modeling the inherent complexities present in the behavioral \naspects of software systems. For this reason, behavioral diagrams are necessary to models \nand \u00ad\nspecify the dynamic aspects and evaluate the quality attributes related to the system \nbehavior. To\u00a0this end, UML provides several diagrams that can be used to model impor-\ntant \u00ad\nbehavioral aspects of software. These are presented in Table\u00a02.7.\nTable\u00a02.7 does not present an exhaustive list of UML behavioral diagrams. However, these \ndiagrams can be used to model almost any behavioral aspect of modern software \u00ad\nsystems, \nand their use is ubiquitous in practical development efforts. Therefore, their understanding \nand applicability must be well understood. Other diagrams, such as timing and interaction \noverview diagrams, are not covered here.\nUSE CASE DIAGRAMS\nUse case diagrams are behavioral diagrams used to capture, specify, and visualize required \nsystem behavior. The main elements of use case diagrams are actors, use cases, and the \nrelationships connecting them together. Actors are entities used to model users or other \nsystems that interact with the system being modeled (i.e., the subject); that is, operators \nusing the system, sensors providing information, and a client computer in a client\u2013server \nsystem can all be modeled as actors. Use cases are entities used in use case diagrams to \nTABLE\u00a02.7\nUML 2.3 Behavioral Diagrams\nDiagram\nDescription\nUse case diagram\nUsed to capture, specify, and visualize required system behavior (i.e., requirements)\nSequence diagram\nUsed to capture, specify, and visualize system interactions with emphasis on the \ntime-order sequence of messages exchanged\nCommunication diagram\nUsed to capture, specify, and visualize system interactions with emphasis on the \nstructural order of entities participating in the message exchange\nState machine diagram\nUsed to capture, specify, and visualize system behavior as a set of discrete states \nand the transitions between them\nActivity diagram\nUsed to capture, specify, and visualize system behavior; provide mechanisms for \nmodeling that includes conditional statements, repetition, concurrency, and \nparallel execution and thus can be used at many different levels of abstraction, \nfrom modeling business work flows to code\n", "page": 79, "type": "text", "section": "Page 79"}
{"text": "56\u2002 \u2022\u2002 Software Engineering Design\ufeff\nspecify the required behavior of a system. Therefore, they provide the means necessary to \ncapture, model, and visualize the requirements of a system.\nUse case modeling provides an avenue for presenting a holistic view of the system to \nbe designed and increasing communication among stakeholders before more detailed \napproaches to design can begin. For example, Figure\u00a0 2.4 presents a use case diagram \nfor a client\u2013server system. The system interacts with both an operator and server and is \nrequired to provide the operator with the capability for searching for a product, updating \nthe product\u00ad\n, displaying the location of the product, and receiving notifications from the \nserver. In addition, the client system is required to check for software updates. Collectively, \nthese use cases, together with the actors and relationships, capture the requirements of the \nActor\nOperator\nUse Case A\nUse Case A\nUse Case A\nSearch Product\nUse Case B\nUse Case B\nUse Case B\nUse Case B\nCommon Use Case Diagram Relationships\nUse Case Diagram\nClient System\nAssociation\n<<include>>\n<<extend>>\nGeneralization\nUpdate Product\nUpdate Software\nDisplay Location\nReceive Noti\ufb01cation\nServer\nFIGURE 2.4\nSample UML use case diagram and common relationships.\n", "page": 80, "type": "text", "section": "Page 80"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 57\nsystem and provide a context for the development of the client system. In UML, use cases \nare modeled using a named ellipsis and actors as stick figures, as seen in Figure\u00a02.4.\nAs seen, the association relationship is used to model the link between actors and use \ncases; however, other relationships, such as <<include>>, <<extend>>, and generalization, \ncan be used to include, extend, and generalize, respectively, other use cases. In addition, \na system boundary is used to delineate the boundaries of the client system within context \nof other relevant actors. Use case diagrams provide a valuable means for establishing a \nframework for eliciting requirements, identifying major system functions, and specifying \nthe context of the subject being modeled.\nSkill Development 2.2: Modeling Behavior with Use Cases\nConsider what you think the five most important functions that your home personal \ncomputer system needs to provide. Using pencil and paper, create a use case diagram \nthat depicts the personal computer system, its five major functions, and the interaction \nbetween you and the computing system. For one of the created use cases, create a list of \ndetailed steps that you think the computer needs to do internally to achieve the speci-\nfied behavior.\nINTERACTION DIAGRAMS\nInteraction diagrams exist at lower levels of abstraction than use case diagrams and can \nbe used extensively during the complete life cycle of software projects. At the architectural \n(system) level, interaction diagrams can be used for modeling interactions among software \ncomponents; during detailed design, they provide interaction modeling capabilities among \nobjects at run time; and at the construction level they can be used to model collaborative \nalgorithms that include conditional and repetition structures, such as loops. Interaction \ndiagrams are popular because they provide avenues for modeling complex interactions \namong software units together with the messages exchanged and the type of the exchange. \nBy modeling the interactions required to realize a particular system function, designers \ncan determine if current structural diagrams are adequate to support the system; this gives \ndesigners the ability to model interactions for which the capability of the structural design \nto meet its functional and quality requirements may be in question. In these cases, inter\u00ad\naction diagrams can serve as validation tool before construction can begin. In many situa-\ntions, interaction diagrams can reveal many important issues related to the overall quality \nof the system (e.g., performance). Two types of interaction diagrams are\n\u2022\t Communication diagrams\n\u2022\t Sequence diagrams\n", "page": 81, "type": "text", "section": "Page 81"}
{"text": "58\u2002 \u2022\u2002 Software Engineering Design\ufeff\nCommunication Diagrams\nCommunication diagrams are behavioral diagram used to capture, specify, evaluate, and \nvisualize system interactions with emphasis on the structural order of entities participating \nin the message exchange. When using communication diagrams, entities can be modeled \nas objects representing instances of classes or as roles representing prototypical instances of \nother entities, such as classes and components (Booch et al. 2005). Both objects and roles \ncan be connected to model the exchange of messages using links or connectors, respectively\u00ad\n. \nAs\u00a0seen in Figure\u00a02.5, a role is modeled using a named box (similar to a class) without under-\nlining the role\u2019s type. In addition, roles can be named or anonymous, as seen in Figure 2.5. \nOn the other hand, objects are modeled using similar notation, but the name of the object \nis underlined. In many practical situations, designers are interested in modeling how roles \ninteract with each other to model a system behavior and not on how individual objects \ninteract. For these situations, roles provide the appropriate modeling entity. When using \nroles for modeling behavior, they can be connected using a solid \u00ad\nconnector line to represent \n: FileSystemMgr\ndb : EventLogger\nsynchronous message\nCommunication Modeling\nObject-Based Communication\n: FileSystemMgr\ndb : EventLogger\nasynchonous message\nfs : FileSystemMgr\nel : EventLogger\nsynchronous message\nfs : FileSystemMgr\ncm : CommMgr\n1 : put(msg)\n2 : decodeMsg()\n4 : format(fast)\n3 : log(received,msgId)\n5 : log(success)\nam : AppMgr\nel : EventLogger\nfs : FileSystemMgr\nel : EventLogger\nasynchronous message\nFIGURE 2.5\nSample UML communication diagram.\n", "page": 82, "type": "text", "section": "Page 82"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 59\na prototypical connection between roles. Similarly, when using objects, their connection \nis made using links, which represent an instance of an association\u00ad\n (Booch et\u00a0 al. 2005). \nConnectors and links look exactly alike and differ only semantically.\nTo model the message exchanges in communication diagrams, messages in the form of \narrows are used. Two common types of messages include synchronous and asynchronous \nmessages. Synchronous messages\u2014modeled using a solid arrowhead\u2014are used to model \ninteractions in which both sender and receiver work in lock-step to achieve an operation. \nAsynchronous messages\u2014modeled using a stick arrow\u2014model interactions that are car-\nried out by receivers independently from the sender. That is, upon sending an asynchro-\nnous message, the sender continues working while the receiver carries out the message \nrequest. The main elements present in communication diagrams, together with sample \nobject-based communication diagram design, are presented in Figure\u00a02.5.\nThe communication diagram presented in Figure\u00a02.5 models a system receiving a message \nto initiate a file system format. As seen, the \u201ccm\u201d object sends a message to the application \nmanager object \u201cam,\u201d which decodes the message, logs the receipt of the message by sending \na message to the event logger object \u201cel,\u201d and initiates a format by sending a message to the \nfile system manager object \u201cfs.\u201d Once finished formatting the file system the \u201cfs\u201d object logs \nan event. All messaging in the communication is done synchronously using links.\nSequence Diagrams\nSequence diagrams are behavioral diagrams used to capture, specify, and visualize system \ninteractions with emphasis on the time-order sequence of messages exchanged. Sequence \ndiagrams are closely related to communication diagrams. Therefore, many of the modeling \ntechniques are the same; that is, sequence diagrams include objects, roles, synchronous, \nand asynchronous messages. Sequence diagrams put emphasis on the time order of mes-\nsages by introducing a lifeline and activation bar. Lifelines are modeled with the object/role \nconnected to a vertical dashed line that represents the lifetime of the object/role. Typically, \nobjects/roles in a sequence diagram are aligned from left to right, depending on the order \nin which messages are sent. Once a message is sent, the activation bar is rendered on \nthe object\u2019s lifeline to model the relative processing time that results from the message \nexchange. Asynchronous and synchronous messaging are modeled similar to communica-\ntion diagrams, and return messages can be modeled using a dashed line with a stick arrow. \nFigure\u00a02.6 presents an equivalent sequence diagram for the formatting operation modeled \nwith a communication diagram in Figure\u00a02.5.\nConcurrency in Interaction Diagrams\nIn previous sections, the discussion on messaging in interaction diagrams eluded the topic \nof concurrency. When using the synchronous mode of communication, an implication is \nnot made as to the presence of independent flows of execution; however, the same is not \ntrue for asynchronous communications. As explained before, the asynchronous mode of \ncommunication provides the ability to model independent flows of execution, since the \n", "page": 83, "type": "text", "section": "Page 83"}
{"text": "60\u2002 \u2022\u2002 Software Engineering Design\ufeff\nsender of an asynchronous message continues on executing while the receiver carries out \nthe work requested. Typically, independent flows of executions are manifested as \u00ad\nmultiple \nprocesses or threads. When applications are multiprocessed or multithreaded, concurrency \nissues arise when they execute in parallel (or pseudo-parallel) with each other. Therefore, \nit\u00a0is important to model concurrent design issues so that their impacts are well understood \nbefore construction begins.\nConcurrent designs require designers to decompose applications into multiple processes \nor threads to meet performance (e.g., usability, throughput) requirements. Processes can \nexecute concurrently with other processes, while threads can execute concurrently with \nother threads (within the same process). The importance of modeling concurrent designs up \nfront is often overlooked in many design efforts; that is, too much concurrency can end up \ndegrading the systems while insufficient concurrency results in decreased systems through-\nput (Booch et al. 2005). Developing these systems requires skills typically acquired through \n: Operator\n1 : asyncMessage\nobjectA : ClassA\nobjectB : ClassB\n2 : selfMessage()\n3 : syncMessage()\n5 : returnMessage\n4 : syncMessage()\nGeneral Sequence Diagram\nApplied Sequence Diagram\n1 : put(msg)\n7 : return status\nam : AppMgr\ncm : CommMgr\nel : EventLogger\nfs: FileSystemMgr\n2 : msgId := decodeMsg()\n3 : log(received,msgId)\n4 : format(fast)\n6 : return status\n5 : log(success)\nFIGURE 2.6\nUML sequence diagram.\n", "page": 84, "type": "text", "section": "Page 84"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 61\nexperience; therefore, novice designers are encouraged to create concurrency models and \nwhen possible to have more experienced personnel review them.\nUML provides the necessary mechanisms to model independent flows of controls, such as \nprocesses or threads, using the concept of an active object within sequence and communica-\ntion diagrams. Active objects are represented in UML as an instance of an active class with \ncertain concurrency semantics to aid in the synchronization of interactions among inde-\npendent flows (Booch et al. 2005). Models that include active objects can be used to reason \nabout quality\u00ad\n issues that deal with concurrency, communication, and synchronization. An \n\u00ad\nexample of a concurrent system is presented in Figure\u00a02.7 using a communication diagram.\nIn this diagram, objects are modeled as active objects by adding double lines to the left \nand right side of the object\u2019s rectangle. This denotes independent flows of execution and \nability to initiate control activity. The model is also enhanced by using the location tagged \nvalue to specify the location of the running processes.\n3 : powerOn()\n4 : powerOn()\n5 : forwardStatus()\n6 : postResults( )\n1 : SystemOn( )\nInterprocess Communication\nActive Object\n<<process>>\nsystemMgr : SystemManager\n<<stereotype>>\nactiveObject : ActiveClass\ntaggedValue = value\n<<process>>\nserverMgr : SystemManager\nlocation = server\n<<process>>\nmanager : SiteManager\nlocation = client laptop\n<<process>>\nnodeOne : SensorNode\nlocation = sensor node\n<<process>>\nnodeTwo : SensorNode\nlocation = sensor node\nlocation = client PC\n2 : forwardCommand()\nFIGURE 2.7\nSample UML interprocess communication.\n", "page": 85, "type": "text", "section": "Page 85"}
{"text": "62\u2002 \u2022\u2002 Software Engineering Design\ufeff\nThe model in Figure\u00a02.7 relies on active objects, asynchronous and synchronous mes-\nsages, to properly model the interprocess operations in a multiprocess distributed system. \nAs seen, the system is composed of five processes executing in different locations, namely, \nthe client PC, server, client laptop, and embedded sensor nodes. The model uses asynchro-\nnous messages, from the client PC to the server and from the server to the client laptop, to \ncommunicate to initiate a power on sequence of the embedded sensor nodes. This makes \nsense because of the nature of a distributed system. Remember that asynchronous messages \nallow the sender to continue operation (and not block) waiting for the message response. \nIn this case, the client PC will send a systemOn message to the distributed system and \ncontinue serving operators without waiting for a response to come back. Communication \nbetween server and client laptop is done in a similar fashion; however, communication \nbetween the client laptop and embedded sensor nodes occurs in synchronous fashion. That \nis, once a systemOn message is received, the client laptop will synchronously power up sen-\nsor node one; control returns back once the power up operation is complete, at which point \nit can initiate the power on message to sensor node two. When both sensor nodes are up, \nstatus is returned asynchronously from the site manager to the system manager.\nConcurrent designs that work on the same data are tougher to manage, since they can \nlead to errors that are hard to find during construction. When this happens, access to \nshared sections of data needs to be designed properly and carefully to ensure the integrity \nof the data. To this end, UML provides synchronization properties that can be used to \nconstrain the model so that it supports concurrency by controlling the way multiple flows \nof execution access critical sections of code. These are presented in Table\u00a02.8.\nThe Sequential synchronization property specifies that no concurrency management \nmechanism is associated with an operation. With sequential access, concurrency con-\nflicts may occur, so clients that rely on the operation need to coordinate so that only one \n\u00ad\ninvocation occurs at any given point. The Guarded property specifies that the operation \ncan be invoked from multiple independent flows simultaneously, but only one flow of \nexecution is allowed to commence; other independent flows are blocked until the execu-\ntion of currently executing operation, under the currently executing thread, is complete. \nWhen using the Guarded synchronization property, it is the responsibility of the designer \nto ensure that concurrency issues, such as starvation and deadlocks, do not occur. Finally, \nTABLE\u00a02.8\nUML Synchronization Properties\nSynchronization\nDescription\nSequential\nNo concurrency management mechanism are associated with the operation.\nGuarded\nConcurrency management mechanisms are in place so that operations can be invoked \nfrom multiple independent flows simultaneously; each call waits for the previous one to \nfinish execution.\nConcurrent\nMultiple invocations may occur simultaneously, and all of them may proceed \nconcurrently.\n", "page": 86, "type": "text", "section": "Page 86"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 63\nthe\u00a0Concurrent synchronization property specifies that multiple invocations may occur \nsimultaneously and that all of them may proceed concurrently. Concurrent synchroni-\nzation is achieved in languages with built-in support for concurrency, such as Java with \nthe use of the \u00ad\nsynchronized property. All three of these properties can be modeled as \n\u00ad\nconstraints to fully specify the behavior of concurrent systems.\nCHAPTER SUMMARY\nUML is a visual language with an extensive set of features appropriate for designing soft-\nware systems across a broad set of application domains. The current version of UML (2.3) \nprovides 14 diagrams for structural and behavioral modeling of software systems. These \ndiagrams support software design during architectural, detailed design, and construction \ndesign activities. Since UML has been designed with flexibility in mind, it is important \nto understand how the its fundamental building blocks (i.e., classifiers, relationships, and \nenhancing features) can be used to model systems of disparate capabilities and domains. \nWhile some UML diagrams provide modeling concepts that are too abstract for direct \ntranslation to code, others are not. Therefore, it is essential that designers understand \nhow these models translate to code and how they are used to model quality attributes. \nBy providing a unified communication language for software design, UML is appropri-\nate and efficient for capturing and conveying information that can be evaluated by many \n\u00ad\nstakeholders including customers and software engineers alike, resulting in a more effi-\ncient design process.\nREVIEW QUESTIONS\n\t\n1.\tWhat is UML, and why is it important in software design?\n\t\n2.\tWhat are the two main classifications for UML diagrams, and how do these differ \nfrom one another?\n\t\n3.\tList and explain two important reasons for software designers to study UML.\n\t\n4.\tIn UML context, what are classifiers? Provide examples of classifiers.\n\t\n5.\tWhat are the main relationships used in UML diagrams? Provide examples of each.\n\t\n6.\tList and explain the main mechanisms for extending UML.\n\t\n7.\tWhat is structural modeling?\n\t\n8.\tCompare and contrasts the following:\n\t\na.\t Component diagram\n\t\nb.\t Class diagram\n\t\nc.\t Deployment diagram\n", "page": 87, "type": "text", "section": "Page 87"}
{"text": "64\u2002 \u2022\u2002 Software Engineering Design\ufeff\n\t\n9.\tExplain the following relationships, and show how they are modeled in component \ndiagrams:\n\t\na.\t Provided and required interfaces\n\t\nb.\t Assembly connector\n\t\nc.\t Delegates\n\t 10.\tWhat is a UML artifact? How are artifacts different from components?\n\t 11.\tList and explain the main compartments of UML class.\n\t 12.\tWhat are the possible types of visibility that can be used in items of class diagrams? \nExplain.\n\t 13.\tIn a class diagram, what is the difference between the following relationships:\n\t\na.\t Generalization vs. realization\n\t\nb.\t Aggregation vs. object composition\n\t\nc.\t Dependency vs. association\n\t 14.\tHow can the manifestation of software components in a deployed environment be \nmodeled in UML? Explain.\n\t 15.\tIn a UML deployment diagram, what is a node?\n\t 16.\tCompare and contrasts the following:\n\t\na.\t Use case diagram\n\t\nb.\t Sequence diagram\n\t\nc.\t Communication diagram\n\t 17.\tWhat is the difference between synchronous and asynchronous messages?\n\t 18.\tExplain how concurrency issues can be addressed using UML.\n\t 19.\tCompare and contrasts the following:\n\t\na.\t Sequential synchronization\n\t\nb.\t Guarded synchronization\n\t\nc.\t Concurrent synchronization\nCHAPTER EXERCISES\n\t\n1.\tConsider the software design of a car in a racing game. Use a software modeling tool \nto identify the major components of the car, define the component\u2019s interfaces, and \nconnect all components the way you think provides the best design for developing the \ncar. Create a list of design factors that influenced the final car\u2019s design and the benefits \nprovided by your approach. When done, ask a peer to do the same and compare your \napproach and final results.\n\t\n2.\tUse the component design created in Exercise 1 to design the classes required to sup-\nport the component\u2019s interfaces and provided services. Create a list of design factors \nthat influenced the final car\u2019s design and the benefits provided by your approach. \nWhen done, ask a peer to do the same and compare your approach and final results.\n", "page": 88, "type": "text", "section": "Page 88"}
{"text": "Software Design with Unified\u00a0Modeling Language\u2002 \u2022\u2002 65\n\t\n3.\tCreate a UML class diagram containing the following information.\nClass Name\nOperations\nAttributes\nRelationships\nName\nType\nReturn \nName\nVisibility\nReturn\nName\nVisibility\nInherits from \nClassZ and \nuses \naggregation \nwith ClassT\nClassA\nClass\nvoid\noperation1\npublic\nchar*\nx\nprivate\nint\noperation2\nprivate\nbool\ny\nprotected\nClassB\nInterface\nvoid\noperation3\npublic\nNone\nDepends on \nClassA and is \nassociated with \nClassO using a \ndirectional \nassociation\nvoid\noperation4\npublic\nClassC\nClass\nnone\nNone\nRealizes ClassB \nand is \ncomposed of \nClassA\n\t\n4.\tMatt and Alice are starting a bed-and-breakfast in a small Virginia town. They will \nhave three bedrooms for guests. They want a system to manage the reservations and \nto monitor expenses and profits. When a potential customer calls for a reservation, \nthey will check the calendar, and if there is a vacancy they will enter the customer \nname, address, phone number, dates, agreed upon price, credit card number, and \nroom number. To facilitate reservations, the system needs to print weekly schedules, \nincluding available rooms, their locations, price, and special rates. Reservations must \nbe guaranteed by one day\u2019s payment. Reservations will be held without guarantee for \nan agreed upon time. If not guaranteed by that date, the reservation will be dropped. \nCreate a UML use case diagram using a system boundary for this system.\nREFERENCES\nBooch, Grady, Robert A. Maksimchuk, Michael W. Engle, Bobbi J. Young, Jim Conallen, and Kelli A. Houston. \nObject-Oriented Analysis and Design with Applications. Upper Saddle River, NJ: Addison-Wesley \nProfessional, 2007.\nBooch, Grady, James Rumbaugh, and Ivar Jacobson. The Unified Modeling Language User Guide. Santa Clara, \nCA: Addison-Wesley, 2005.\nQian, Kai, Xiang Fu, Lixin Tao, Chong-Wei Xu, and Jorge L. Diaz-Herrera. Software Architecture and Design \nIlluminated. Sudbury, MA: Jones & Barlett, 2009.\n\u201cUML 2.3 Superstructure.\u201d Vers. 2.3. Object Management Group. May 2010. Available from: http://www.omg.org.\n", "page": 89, "type": "text", "section": "Page 89"}
{"text": "67\n3\nPrinciples of Software Architecture\nCHAPTER OBJECTIVES\n\u2022\t Understand the role of software architecture within the software \ndesign phase\n\u2022\t Become familiar with architectural tasks and problem solving \u00ad\nduring \narchitecture\n\u2022\t Understand the importance and role of architectural views in \u00ad\nsoftware \narchitecture\n\u2022\t Become familiar with the software architecture process\n\u2022\t Become familiar with the concept of architecture evaluation\nCONCEPTUAL OVERVIEW\nThe software architecture activity corresponds to a macrodesign approach \nfor transforming software requirements into design elements that support \nquality and functions of software systems. During software architecture, \nperspectives appropriate for modeling particular concerns are identified \nand design elements created to address those concerns. These design ele-\nments present systems from different perspectives, thus providing stake-\nholders, with different background and expertise, the means to evaluate the \nappropriateness of architectural decisions for supporting the construction \nof the desired system. The software architecture activity places emphasis \non systems\u2019 quality and therefore provides the earliest means for ensur-\ning that identified quality goals are evaluated and incorporated into the \ndesign before moving on to more detailed design and construction work. \nThe software architecture lays the foundation for all subsequent work in the \ndevelopment process and serves as an important communication, reason-\ning, and analysis tool for developing and maintaining software systems.\n", "page": 91, "type": "text", "section": "Page 91"}
{"text": "68\u2002 \u2022\u2002 Software Engineering Design\ufeff\nWHAT IS SOFTWARE ARCHITECTURE?\nIn a broad context, software architecture refers to both the process and design products \nrequired to systematically build software systems that meet their intended functions and \nquality. Of\u00a0course, such broad definition of software architecture leaves out many of the \ndetails that make architecture essential in designing today\u2019s complex software systems. \nTo understand the meaning and importance of software architecture, it helps to examine \nhow other engineering disciplines employ architectural designs to build complex systems \nwith demanding functional and quality requirements. Consider the role of architecture in \ncivil engineering, where designing and building structures such as houses, bridges, and \nhigh-rises is a nontrivial task. In these cases, architectural designs are used to specify the \noverall appearance of physical structures. When examined closer, it becomes evident that \nthis broad definition is insufficient to describe to actual role of architecture in the process of \nbuilding these \u00ad\nsystems, which involve far more than structural appearance. Architectural \ndesigns must also specify a variety of quality properties that make structures functional, \nsafe, and economical. This requires architects to incorporate design alternatives that con-\nsider a wide variety of factors (e.g., social, aesthetic, and cost) supporting the needs of \nstakeholders, including the people who use these physical structures.\nIn software engineering, architects work to create the overall design elements appro-\npriate for supporting efficient refinement and construction of software systems. However, \nas in the previous discussion, architectural designs in software engineering involve far \nmore than structural composition. They must also address numerous quality properties\u00ad\n \n(e.g.,\u00a0 performance, usability, and maintainability) that combine together to produce \nsoftware systems that meet the quality expected by their stakeholders. To address these \nnumerous concerns, software architects create different models of the software system, \neach addressing the system design from different perspectives. From the structural, logical \nperspective, the software architecture should address the needs of downstream designers \nand developers by decomposing the software (in an efficient manner) and defining the \nmajor components of the system, identifying their interfaces and interrelationships, and \nproviding support for both functional and quality attributes of the system. From the con-\nfiguration management perspective, the architecture should provide information about \nthe hierarchy of files in the file system, their interrelationships, and the process for building \none or more versions of the software system. From a systems engineering perspective, the \narchitecture provides information about the physical deployment of the system, including \nthe location of distributed subsystems, their interfaces and interrelationship, and specifi-\ncation of communication protocols between them. Other architectural perspectives exist \nfor addressing various concerns that stakeholders may have and should be considered and \ndesigned for during the software architecture activity. Since the nature of stakeholders\u00ad\n \n\u00ad\nvaries greatly in software systems, the perspective used to model the structure and behav-\nior of software systems varies as well. Therefore, it is almost never the case that a single \ndesign element, from a single perspective, can represent the software architecture, espe-\ncially for large-scale software intensive systems. In these cases, the collection of design \n", "page": 92, "type": "text", "section": "Page 92"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 69\nelements and their detailed descriptions help form the software architecture. Formally, \nsoftware architecture is defined as\nThe foundational software design activity that evaluates and translates software require-\nments (both functional and non-functional) into a collection of design elements that specify \nstructural and behavioral aspects of the major components of the system, together with their \nprovided quality, and interrelationships required to support the detailed design and con-\nstruction of software systems; and the product resulting from such activity.\nFrom this definition, a few things are of interest and need further explanation. First, as \nfoundational design, software architecture provides the groundwork essential for meeting \nfunctional and nonfunctional requirements. The architectural design foundation provides \nthe necessary structure for achieving quality throughout subsequent phases of the software \nengineering life cycle. This suggests that architecture is not an optional design activity or \nan activity performed as a means of documenting software systems long after they are \nimplemented. Although deriving and documenting a system\u2019s software architecture from \nits implementation in legacy systems provides an excellent avenue for capturing and trans-\nferring knowledge about the system\u2019s design, new development efforts should approach \nsoftware architecture as a forward engineering activity that leads to the implementation of \nsystems and not as a reverse engineering mechanism for documentation. Second, software \narchitecture provides abstractions for software requirements in the design domain, so that \ndesign elements, components, and alternatives all derive from requirements. This suggests \nthat as part of the architectural effort architects must be proficient in activities related to \nrequirements engineering. Third, by specifying that architecture is a collection of design \nelements, it is implied that software architectures are composed of multiple structures and \nthat no one structure can fully describe the software architecture (Bass, Clements, and \nKazman 2003). Fourth, as a design activity that deals with the major system components, \nit\u00a0is suggested that software architecture works at a distinct level of abstraction that differs \nfrom other forms of design, such as detailed design. This means that architectural work \nfocuses on the major components\u2014which become the units of system composition\u2014and \nthe properties and services that these components exhibit and provide to other compo-\nnents. This clearly delineates architectural efforts from other detailed design efforts. Fifth, \na sometimes overlooked or underappreciated piece of the software architecture definition \nis its support for detailed design and construction. Even though architects do not need to \nbe proficient with particular programming languages, they benefit greatly from having \nproficiency with general programming design concepts, so that their architectural designs \nprovide sufficient avenues for efficient construction of the system. Finally, software archi-\ntecture supports\u2014as opposed to ensures\u2014the achievement of quality goals; that is, soft-\nware architecture cannot single-handedly provide the work necessary for achieving the \ndesired quality properties of the system. Since work performed during subsequent activi-\nties and phases significantly shapes the system\u2019s quality, software architecture can play \nonly the initial (indispensable) role of establishing the design quality framework for the \nrest of the development process.\n", "page": 93, "type": "text", "section": "Page 93"}
{"text": "70\u2002 \u2022\u2002 Software Engineering Design\ufeff\nWHY STUDY SOFTWARE ARCHITECTURE?\nArchitectural designs identify the necessary elements\u2014and attributes of those \u00ad\nelements\u2014\nthat support detailed design and construction efforts. These design elements are presented \nin context for examining how well the system as a whole collaborates to meet its intended \nfunctions. In many cases, this includes the modeling of other nonsoftware \u00ad\nelements \n(e.g.,\u00a0physical nodes) that play a key role in assessing the system\u2019s capabilities for achieving \na desired quality goal. An understanding of architectural modeling capabilities is essential \nin problem solving, since they provide the means to overcome functional fixedness early on \nin the development process by allowing designers to model and evaluate the same problem \nfrom different perspectives. Benefits from studying software architecture are also evident in \nnumerous aspects of both product development and management. From the product devel-\nopment perspective, studying software architecture is important for creating an efficient \nbridge between the software requirements phase and the detailed design phase. Having \nextended knowledge of software architecture provides architects with a wider pool of design \nalternatives, some of which have been proven successful in previously developed and similar \nsystems. In these cases, architects can reuse structural design elements and interconnec-\ntions and their responsibilities and can gain insight into their quality properties, all based \non previously used architectures. This provides quick insight into the system\u2019s or individ-\nual component\u2019s ability to meet quality expectations. Besides aiding in product develop-\nment activities, studying software architecture also enhances project managers\u2019 activities \nbecause it helps dictate units of planning, scheduling, and budget; it helps establish inter-\nteam communication channels, configuration control, and file system organization; and it \nhelps manage the integration, test, and maintenance efforts (Bass et al. 2003).\nKEY TASKS IN ARCHITECTURAL DESIGN\nDefining the structure of software systems requires consideration of many project-specific \naspects and how those aspects relate to the organization\u2019s goals. Therefore, examining the \nbusiness impact of architectural decisions in the organization is a major task of software \narchitects (Bass et al. 2003). This requires a holistic approach that considers all factors \nthat help shape the system in an efficient manner. Some of the key tasks that need to be \n\u00ad\nperformed during the software architectural design effort include\n\u2022\t Identifying stakeholders concerns\n\u2022\t Identifying appropriate architectural views\n\u2022\t Identifying architectural styles and patterns\n\u2022\t Identifying influences of architectural decisions in organization\n\u2022\t Identifying the system\u2019s major components and interfaces\n\u2022\t Evaluating and validating the architecture\n\u2022\t Establish policies for ensuring architectural design synchronicity\n", "page": 94, "type": "text", "section": "Page 94"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 71\nIdentifying Stakeholders\u2019 Concerns\nStakeholders are persons, groups, or organizations that have a direct or indirect stake in the \nsystem. They include systems engineers, software engineers, hardware engineers, project \nmanagement, customers and their representatives, testing teams, quality assurance teams, \nand members of the configuration management team. The list of stakeholders and the abil-\nity to manage them from an architectural design\u2019s perspective varies in magnitude and \ncomplexity per project. An important job of the software architect is to ensure that the \nsoftware to be developed addresses stakeholders\u2019 concerns. Stakeholders\u2019 concerns provide \nhigh-level information about desired characteristics of the software system. Therefore, a\u00a0key \nfactor in the architectural design activity is identifying and understanding the different \nways stakeholders influence the system and how they interact with each other. These con-\ncerns need to be elicited and captured before any design effort can begin. Stakeholders\u2019 \nconcerns (e.g., requirements) are the driving force behind architectural decisions and can \ninfluence both product and processes, may be functional or quality in nature, and may have \ndifferent levels of abstraction. During project inception, stakeholders\u2019 concerns are cap-\ntured and specified in a clear and consistent manner to define the expected functions and \nquality of the software system. An essential characteristic of the specification of concerns \nis their ability to provide verifiable specifications, which are used as evaluation criteria for \nall architectural design activities. Therefore, when identifying stakeholders\u2019 concerns, addi-\ntional effort is required so that they are understandable, achievable, and consistent with all \nother identified concerns from all other stakeholders.\nIdentifying Appropriate Architectural Views\nSoftware architects work hard to create designs that achieve all functional and quality features \nexpected from stakeholders. In complex software systems, there can be a multitude of stake-\nholders with myriad backgrounds, all shaping the way the system development is approached \nbased on their perception of what the final product should be. Different perceptions signifi-\ncantly influence the way these stakeholders evaluate the system\u2019s design and determine the \nappropriateness of the design to meet their goals. For this reason, architectural designs must \nsupport different architectural views used to evaluate the design from a particular stakeholder\u2019s \nperspective. By providing different architectural views of the system, communication among \nstakeholders is enhanced during new or ongoing development or during a system\u2019s mainte-\nnance phase. These architectural views provide designers the ability to address concerns using \na perspective and design elements well suited for analyzing and evaluating the particular prob-\nlem. By using appropriate views, architectural design can be placed in context to yield better \nmodeling and evaluation capabilities. Therefore, the result of any architectural effort must \ncontain design solutions that address one or more viewpoints specific to the problem at hand.\nIdentifying Architectural Styles and Patterns\nThe concepts of architectural styles and patterns are fundamental to the efficient creation \nof software architectures. Architectural styles and patterns provide an overall strategy \n", "page": 95, "type": "text", "section": "Page 95"}
{"text": "72\u2002 \u2022\u2002 Software Engineering Design\ufeff\nfor designing a family of software systems. They provide generic, reusable architectural \nsolutions, documented in a way that is easily understood and applied to new problems \nrequiring similar architectural features. For this reason, identifying architectural styles \nand patterns is one of the first decisions that software architects make. This decision has \nlong-lasting effects on all subsequent design and construction efforts. Decisions based on \narchitectural styles and patterns benefit from years of documented experience that high-\nlight the solution approach to given problems, from the advantages of these approaches, \nand from gaining understanding of the consequences of designing the system with a par-\nticular style. Today, numerous architectural styles and patterns have been documented, \nso software architects need to identify and determine the appropriateness, benefits, and \nconsequences of choosing a particular style or pattern for their system\u2019s design.\nIdentifying System Interfaces\nInterface identification and definition compose another essential task of the software \narchitecture activity. Interfaces are defined for components residing within single physical \nnodes within a single process space, for components residing within a single node in dif-\nferent process spaces, or for components residing in separate processes distributed across a \nnetwork. Interface definition may include the definition of stable interfaces such as abstract \nclasses in object-oriented environments. When using a structured design approach, identi-\nfying internal interfaces can result in determining the set of services required by each archi-\ntectural component to collaborate with all other architectural components. These identify \nthe major access points for architectural components together with the communication \nrules that must be followed during the detailed design activity. Having well-defined inter-\nfaces allows the software system to evolve gracefully with time when existing capabilities \nare modified or new capabilities are added to the system. Defining the interfaces between \ncomponents that reside in different nodes may include specifying messaging structures, \nprotocols, and other communication mechanisms for allowing communication across \ndistributed components. These can include identification of physical medium, data-link \nprotocols, network and transport protocols, messaging specification, and application-level \nprotocols. Identification of external interfaces can significantly impact a system\u2019s ability to \nsupport its identifying quality properties.\nIdentifying Impact of Architectural Decisions in Organization\nDuring the architectural design activity, software architects are required to make decisions \nthat support the efficient development of the software system within bounds placed by \nthe organization mission and goals. These restrictions are company-specific and in many \ncases appear outside the scope of architects\u2019 work; nonetheless, these restrictions need to \nbe considered and are typically manifested in software architectures. For example, con-\nsider the case of software system decomposition. From a pure logical standpoint, decom-\nposition is made to define units of manageable complexity that can be evaluated, built, and \nmaintained. These criteria are typically used as basis for system decomposition; however, \n", "page": 96, "type": "text", "section": "Page 96"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 73\nin\u00a0practical applications, other key organizational issues need to be addressed to determine \nthe right granularity of components when decomposing a system. When approached this \nway, architectural decisions are driven not only by common design principles discussed in \nChapter 1 but also by other organizational and project-specific factors, such as \u00ad\nstakeholders\u2019 \nconcerns, resource availability, resource location, schedule, and budget. These factors drive \narchitectural decisions to create design solutions that are appropriate for meeting both \nproduct and organizational requirements, therefore bridging the gap between the business \norganization and its technical products.\nImpact on Customer Base\nDecisions made during the architectural activity affect not only subsequent activities in the \nsoftware life cycle but also stakeholders, especially customers. When faced with competing \nalternatives, each benefiting one customer more than others, architects have to find ways to \nmake decisions that accommodate each customer and minimize overall customer dissatis-\nfaction. In these cases, software architects must be skilled at predicting, verifying, and vali-\ndating the effects of their design decisions. This issue is further complicated by the presence \nof quality requirements. The problem with quality attributes is that they typically contradict \neach other. This property of quality attributes is described in detail by Gorton (2011, p. 37):\nQuality attributes are not orthogonal. They interact in subtle ways, meaning a design that \n\u00ad\nsatisfies one quality attribute requirement may have a detrimental effect on another. For exam-\nple, a highly secure system may be difficult or impossible to integrate in an open environment.\nSoftware architects are constantly faced with the challenging task of determining the \neffects of individual design alternatives, identifying conflicting design solutions, negotiat-\ning systems\u2019 features among stakeholders, and verifying and documenting the final archi-\ntectural solution, all of which impact the customer base.\nImpact on Budget and Schedule\nArchitectural designs provide project management with more concrete representations of \nthe effort required to build the software system. Specifically, they provide the best source \nof information for creating or reevaluating schedules and cost so that they reflect realistic \nand achievable milestones. Once schedule and budget are established, other attributes of \nthe project can be fine-tuned to meet the established goals. For example, architectural \ndesigns can highlight inadequacy in resources required for completing the system on time \nand within budget. In these cases, architectural designs are used as concrete justifica-\ntion for requesting more resources early on in the project life cycle. In cases where adding \nresources is infeasible, architectural designs can help justify reevaluation of the strategy, \nwhich requires decision making in all aspects of the project, such as schedule, budget, \nor\u00a0make versus buy decisions. These adjustments based on architectural designs impact \n", "page": 97, "type": "text", "section": "Page 97"}
{"text": "74\u2002 \u2022\u2002 Software Engineering Design\ufeff\nthe development organization\u2019s budget and schedule and are necessary to manage risks, \nto\u00a0maintain customer satisfaction, and to ensure the project\u2019s success.\nImpact from Resource Availability\nThe previous section introduced human resource availability as an impacting factor in the \ndevelopment project. However, architectural decisions are also affected by other differ-\nent forms of resource availability. Resource availability, such as employees, software, and \nhardware, can all prompt adjustments to the architecture. Architectural designs that take \ninto account human resources can maximize employee efficiency throughout the detailed \ndesign and construction phase. By taking into account employee availability, location, and \nteam composition, work can be compartmentalized and developed in parallel. Employees \nthat are distributed across different sites can prompt the creation of components with \nwell-defined interfaces that can be developed independently and integrated into the sys-\ntem with minimal effort. Hardware availability can also prompt adjustment in the software \narchitecture. In cases where hardware availability is essential to the development and test \nof software, the architecture may be adjusted to provide simulation components that can be \nused to move the development effort forward in case hardware is unavailable. In these cases, \nconstruction and test can continue until the hardware becomes available. At any point, the \nsimulation component can be swapped easily for the real hardware component without \nchanges to the overall architecture or software. The same approach can be employed for \nother software resources that are essential to the development of the system.\nIdentifying the System\u2019s Major Components and Interfaces\nA major task performed during the software architecture activity involves decomposing \nsystems into manageable component units. In doing so, it is important to identify the inter-\nfaces that these components use to collaborate with each other. Components and interfaces \nare identified during system decomposition; however, the nature of these significant ele-\nments varies according to the perspective used for system decomposition. In the broad \ncontext of system decomposition, identifying the major components and interfaces may \ninvolve, for example, logical components, physical nodes, files, or directories, and physi-\ncal or logical interfaces required for these components to interoperate with each other. \nExamples of identifying logical and physical components and their interfaces are presented \nin Chapter 4.\nEvaluating and Validating the Architecture\nConsider designing a large-scale, secure, high-performing, distributed system composed \nof multiple nodes, each with usable interfaces, all while emphasizing the system\u2019s \u00ad\ntestability \nand maintainability. In addition, the system needs to be built using a joint approach among \nthree organizations in separate geographical locations. For such development efforts, an \nunsuitable architecture is a recipe for disaster. Therefore, software architecture evaluation \n", "page": 98, "type": "text", "section": "Page 98"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 75\nand validation are essential tasks of the software architecture activity. In most cases, failure \nto evaluate and validate the architecture significantly impacts the effort and cost incurred \nto develop the system. Typically, defects found during earlier stages of the development life \ncycle (e.g., architecture) take much less effort to correct than if found at later stages, such as \nduring the testing phase (Clements, Kazman, and Klein 2001). For this reason, it\u00a0is essen-\ntial to evaluate and validate the suitability of the architecture to meet its intended purpose \nbefore attempting to construct the system. Evaluation and validation can focus on compo-\nnents, subsystems, or the entire system, depending on how the architecture is structured \nand the requirements placed on the system. In all of these cases, evaluation and validation \nensure that architectural components and the architecture itself are sufficiently complete \nto support the expected services and quality of those services.\nIntroducing Policies for Design Synchronicity\nA most often overlooked issue in software design efforts is the concept of design syn-\nchronicity. Design synchronicity is a measurement of the degree of how well the software \nsystem\u2019s implementation reflects its software architecture and detailed design. In many \ncases, design synchronicity reflects the quality of the software process in place; in others, \nit reflects the organization\u2019s capability for monitoring and controlling processes through-\nout. The software architecture establishes the foundation required for subsequent design \nand construction work to meet the system requirements (including quality requirements). \nTherefore, unmanaged deviations from the software architecture during detailed design \nand construction can reshape the properties of the system and affect its overall capability \nto meet requirements. For any software architecture effort to result in successful imple-\nmentation of a system, all subsequent phases and activities (i.e., detailed design and con-\nstruction) must be synchronized with the software architecture. Therefore, designers and \nprogrammers need to work closely and communicate to ensure that the detailed design and \nsoftware implementation are consistent with architectural decisions. In addition, \u00ad\nproject \nmanagers need to set processes in place to support design synchronicity throughout the \nsoftware development life cycle, which is difficult for large-scale multiyear efforts or for \nprojects entering the maintenance phase.\nSkill Development 3.1: Key Tasks in Architectural Design\nA building architect is hired to design an indoor sports complex with capacity of \n3,000\u00a0 people. The building will be used to host sports, concerts, and other major \nactivities. The initial design consists of a futuristic building with single door for both \nentrance and exit. The building\u2019s design is technically sound and can even withstand \nmajor natural disasters common to the area. Create an exhaustive list of stakehold-\ners, and identify the concerns they may have and how they can be addressed in the \nproposed building\u2019s architectural design. Do any of the identified key tasks of software \n\u00ad\narchitecture apply to this problem? Explain.\n", "page": 99, "type": "text", "section": "Page 99"}
{"text": "76\u2002 \u2022\u2002 Software Engineering Design\ufeff\nPROBLEM SOLVING IN SOFTWARE ARCHITECTURE\nIn Chapter 1, a generic model for problem solving was introduced based on inputs, constraints, \nand outputs, where each input problem is interpreted and carefully formulated, is evaluated \nagainst its external constraints, and is ultimately processed, evaluated, and documented. \nDifferent instances of this problem-solving model can be created for particular activities in the \ndesign process, such as the software architecture activity. During software architecture, the \nproblem-solving landscape can be characterized by a particular set of inputs, constraints, and \noutputs common to architectural problems encountered during the design effort. These prop-\nerties can be consistently defined for most architectural design efforts; therefore, it becomes \nessential for software architects to understand the types of inputs, constraints, and outputs \nexpected during architectural problem solving. Using the holistic problem-solving approach \npresented in Chapter 1, the generic problem-solving model is modified to account for common \nproperties present during the software architecture activity and is presented in Figure\u00a03.1.\nAs seen in the figure, typical inputs present during the software architecture activity \ninclude requirements, system goals, and scenarios. These are interpreted and carefully \nformulated as part of the requirements engineering (RE) phase; however, it is not uncom-\nmon for software architects to perform RE activities, since requirements may not be well \nunderstood or defined or new requirements may be created as knowledge of the system is \nacquired throughout the design phase. These inputs are interpreted and evaluated against \nthe architectural and project constraints, are transformed through collaborative work into \narchitectural design products, and are evaluated and documented\u2014typically as part of the \nsoftware design document\u2014as architectural design elements for future activities or phases \nin the development life cycle.\nEvaluate\nConstraints\nArchitectural\nDesign \nInterpret\nProblem \nEvaluate\nCollaborative\nBrainstorming\nDocument\nResources\nActivities\nControls\nSchedule Constraints,\nCost Constraints, Quality Constraints \nRequirements,\nSystem Goals,\nScenarios\nArchitectural\nDesigns,\nDocumentation\nFIGURE 3.1\nHolistic architectural problem-solving model.\n", "page": 100, "type": "text", "section": "Page 100"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 77\nInputs\nThe most typical inputs encountered in problem solving during the software architecture \nactivity are requirements and system goals, which both can be represented using scenarios. \nThese inputs are elicited from stakeholders and provide the driving forces behind all prob-\nlems and solutions devised during the architectural design activity. Requirement inputs \nmust have certain characteristics so that they can be well understood by designers. Bad or \nmisunderstood requirements lead to problems that are hard to solve or solved incorrectly. \nIn some cases, requirement input can be incomplete, misleading, or inconsistent; in others, \nthey may specify unverifiable or unachievable capabilities, which makes problem solving \ndifficult or impossible at times. In these cases, requirement input results in ill-defined or \nwicked problems, which are hard to solve. On the other hand, system goals, which estab-\nlish a high-level desired capability, need to be transformed (when possible) into require-\nment form so that they are appropriate for problem solving. Before any problem solving \ncan occur during architecture, issues with requirements, system goals, and scenarios need \nto be resolved so that the proper problem interpretation and formulation can be made. \nTherefore, careful attention needs to be placed when interpreting inputs so that their cor-\nrect solution can be integrated into the design and evaluated and validated appropriately. \nThese tasks belong mostly to the requirements phase; however, in many cases it is common \nfor software architects to iterate back and forth from requirements to design.\nConstraints\nWhereas inputs define the problems that need solutions during the architectural design \nactivity, constrains specify bounds identified for their proposed solutions. At the architec-\ntural design level, typical constraints include schedule, budget, and process constraints. \nBesides constraints derived from nonfunctional requirements, other constraints include \nspecific platform constraints (e.g., embedded, mobile, web), constraints from existing and \nreused architectures, constraints on new technology (e.g., cloud-based solutions), incorpo-\nrating commercial of-the-shelf (COTS) products, and numerous other constraints placed \non both product and processes. During architectural problem solving, architects must be \nquick to learn technology aspects of product constraints and also must have a keen sense \nof project management aspects to account for both schedule and budget constraints when \ndecomposing the major software components of the architectural design. Other character-\nistics of the software project may give rise to constraints placed on the architectural design \nprocess. For example, process constraints may dictate the type of architectural designs \nrequired, the views supported by the architecture, and other supporting activities required \nto meet constraints placed on the architectural design process.\nOutputs\nProblem solving during architectural design should lead to further understanding of the \nmajor structure and behavior of software systems. Therefore, outputs consist of design \n", "page": 101, "type": "text", "section": "Page 101"}
{"text": "78\u2002 \u2022\u2002 Software Engineering Design\ufeff\nelements and descriptions that differ from other forms of design, such as detailed design. \nOutputs during the architecture activity are in the form of black-box solutions, which \nrequire refinement in subsequent design work. In many cases it is difficult to delineate \nbetween where an architectural design solution ends and its respective detailed design \nsolution begins. From the logical perspective, architectural solutions need to account for \nthe necessary components and interfaces required to achieve functional requirements and \nto support its quality requirements. Once architectural solutions can account for these \n\u00ad\ncriteria, details of implementation can be deferred to detailed designs.\nThe output of problem solving during the architectural design activity is essential to \nproducing a high-quality software system. Problem solutions during software architec-\nture need to be evaluated and documented accordingly so that they can be used in future \ndesign and construction work. The documentation format varies from project to project \nand from organization to organization. Typically, solutions found during the architectural \ndesign activity are documented in the form of diagrams, documents, or a combination \nof the two. They can contain analysis and documentation for major design decisions, the \nconcerns and stakeholders related to the problem, design trade-offs, identified conflicting \ngoals, prioritization schemes, design synchronization plans, and a mapping of require-\nments to the architectural solution. This information can be incorporated into an official \narchitectural design document that is maintained independently or incorporated into the \nofficial software design document, which is completed, reviewed, and approved after com-\npletion of the design phase. Regardless of the documentation format, solutions to problems \n\u00ad\nduring the architectural design activity must be understandable, complete, and sufficient \nto \u00ad\nsupport the detailed design phase.\nSOFTWARE ARCHITECTURE PROCESS\nThe architectural design activity involves many problems that need to be solved before the \nsoftware architecture is created and the development effort can move forward. Each problem \nsolved during architecture helps address a particular concern and has an associated set of \ninputs (e.g., requirements), constraints, and desired output. Outputs of the architectural prob-\nlem-solving process produce design elements of the software architecture, and the \u00ad\ncollective \nset of elements is combined to form the software architecture. Therefore, problem solving \nduring architecture forms part of a broader process for creating software \u00ad\narchitectures. \nOn a larger scale, the process for creating software architecture can be executed using the \nfollowing\u00a0tasks:\n\u2022\t Understand and evaluate requirements\n\u2022\t Design the architecture\n\u2022\t Evaluate the architecture\n\u2022\t Document the architecture\n\u2022\t Monitor and control implementation\n", "page": 102, "type": "text", "section": "Page 102"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 79\nUNDERSTAND AND EVALUATE REQUIREMENTS\nSoftware architects spend a great deal of time working with software requirements. Even \nafter requirements are specified, software architects find themselves going back and forth \nbetween requirements and design to clarify them, correct them, or completely revise them. \nIn some cases, software architects are completely immersed in the requirements process, \nplaying a key role in specifying the requirements of the system. For this reason, software \narchitects need to understand RE, the discipline within software engineering that is con-\ncerned with the systematic approach to requirements specification, mainly through the \nfollowing activities (Abran, Moore, Bourque, and Dupuis 2005):\n\u2022\t Elicitation\n\u2022\t Analysis\n\u2022\t Specification\n\u2022\t Validation\nTogether, these activities are performed to express the needs and constraints placed on the \nsoftware system, which provides the foundation for all architectural and subsequent design \nand construction work. Understanding RE and how the fundamental activities relate to \ndesigning software architectures provides architects with a different dimension for design-\ning successful systems by filling gaps or making appropriate corrections to the software \n\u00ad\nspecification before committing to a particular design solution.\nElicitation\nElicitation is the requirement activity that deals with identifying stakeholders, with \nuncovering what the customer needs and wants, and with determining the (often over-\nlooked) nonfunctional requirements (Laplante 2009). Elicitation begins by identifying all \nsources of information that can be used to generate requirements. Sources of informa-\ntion vary from project to project and can provide bias information to shape the system \nin a way that addresses their particular needs. Sources of information also come from a \nvariety of backgrounds; therefore, the use of techniques that are effective in extracting \nimportant information from a variety of sources with different expertise and background \nis essential.\nRequirement Sources\nSoftware requirements originate from many different sources. In some cases, require-\nments may originate from one source with an overall strategy and consistent vision for \nthe system, which makes analyzing, specifying, and validating requirements more man-\nageable. In most large-scale software efforts, requirements originate from many different \nsources with similar but inconsistent visions for the system. In these cases, identifying \n", "page": 103, "type": "text", "section": "Page 103"}
{"text": "80\u2002 \u2022\u2002 Software Engineering Design\ufeff\nand managing these sources becomes a nontrivial task that requires additional time and \neffort. Some of the most common sources of requirements include (Abran et al. 2005):\n\u2022\t Stakeholders\n\u2022\t Goals\n\u2022\t Domain knowledge\n\u2022\t Operational and organizational environment\nMultiple stakeholders view the system differently and provide different input and con-\nstraints for the system. Having an increased number of stakeholders causes almost every \naspect of requirements elicitation to be more complex. Particularly, having a greater num-\nber of stakeholders increases the goals for the system. System goals can specify desirable \naspects of the business, process, or product and are typically referred to as quality attri-\nbutes. When goals are identified, they must be evaluated and (if possible) transformed into \nnonfunctional (quality) requirements. Nonfunctional requirements can be used to place \nconstraints on the devised solutions so that they support acceptable levels of quality, as \ndefined by stakeholders (Abran et al. 2005). As mentioned before, an essential character-\nistic of requirements (both functional and nonfunctional) is their ability to provide verifi-\nable specifications. By transforming goals to nonfunctional requirements, they can be used \nnot only for decision making during architectural, detailed, and construction design but \nalso as evaluation criteria during system test, after the system is designed, constructed, and \nunit tested. A list of common quality attributes with descriptions is presented in Table\u00a03.1.\nDomain knowledge provides an essential source for requirements since it provides \ndetails of how the system should behave and help determine obscure functions that the \nTABLE\u00a03.1\nCommon Quality Attributes for Software Systems\nQuality\nDescription\nUsability\nA goal that seeks to minimize the degree of complexity involved when learning or using the \nsystem\nModifiability\nA goal that seeks to minimize the degree of complexity involved when changing the system \nto fit current or future needs\nSecurity\nA goal that seeks to maximize the system\u2019s ability to protect and defend its information or \ninformation system\nPerformance\nA goal that seeks to maximize the system\u2019s capacity to accomplish useful work under time \nand resource constraints\nReliability\nA goal that seeks to minimize the system\u2019s failure rate\nPortability\nA goal that seeks to minimize the degree of complexity involved when adapting the system \nto other software or hardware environments\nTestability\nA goal that seeks to minimize the degree of complexity involved when verifying and \nvalidating the system\u2019s required functions\nAvailability\nA goal that seeks to maximize the system\u2019s uptime\nInteroperability\nA goal that seeks to maximize the system\u2019s ability to collaborate with other software or \nhardware systems\n", "page": 104, "type": "text", "section": "Page 104"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 81\nsystem needs to provide in special cases. This knowledge is obtained through the design \nand development of similar systems or through involvement in the development effort \nunder different disciplines, such as hardware, test, and management. Finally, the opera-\ntional and organizational environment can be used as a source for requirements common \nto software product lines within the organization to maintain consistency among all prod-\nucts developed in the organization.\nElicitation Techniques\nDifferent stakeholders view systems differently, based on their specific background and \nspecialization. When eliciting information from different stakeholders, it is sometimes \ndifficult to compile a consistent set of requirements, since needs from stakeholders may \ncontradict each other. Therefore, effective elicitation techniques are required to gather and \nconsolidate a consistent set of requirements for the system. Some of the most common \ntechniques for requirements elicitation include (Abran et al. 2005):\n\u2022\t Interviews\n\u2022\t Facilitated meetings\n\u2022\t Observation\n\u2022\t Scenarios\nInterviews and facilitated meetings are both common techniques for requirement elicita-\ntion. During interviews, meetings are scheduled individually with different stakeholders \nto bring forth their particular needs and gain understanding of their particular expecta-\ntions for the system. On the other hand, facilitated meetings are performed with a group \nof stakeholders to bring forth a collective vision and to gain more insight into the overall \nexpectations of the system. Typically, facilitated meetings include a moderator, the design \nteam, and peer reviewers (including stakeholders). By eliciting requirements in a collec-\ntive fashion, details that affect different stakeholders can be identified, negotiations can be \nmade, and collective resolutions can be achieved. Information from both interviews and \nfacilitated meetings needs to be carefully documented, further elaborated, and iteratively \nrefined until a solid grasp of the system needs is acquired.\nIn many cases, stakeholders are unaware or cannot articulate desirable system features. \nWhen this occurs, observations of similar systems can help capture desired functions of \nthe system behavior under particular (nonobvious) conditions. This information can be \nlearned to gain insight into a particular system behavior, quality, or interaction and used \nto generate appropriate requirements for the system. When systems are hard to specify, \nobservation allows both engineers and stakeholders to effectively conceptualize and trans-\nfer knowledge required to yield important system information; however, in some cases it \ncan be intrusive, expensive, or impossible.\nFinally, a popular approach to eliciting requirements is through scenarios. Scenarios \nare popular because they allow software architects to create and present to stakeholders \n\u00ad\nstorylines about different behaviors that the system is expected to provide. These storylines \n", "page": 105, "type": "text", "section": "Page 105"}
{"text": "82\u2002 \u2022\u2002 Software Engineering Design\ufeff\nare born out of perceived expected behavior by the software architect and refined and vali-\ndated through stakeholders\u2019 reviews. Scenarios provide a valuable means for establishing \na framework for eliciting requirements, identifying major system functions and details of \nthe software, and providing initial insight in the required testing of the software. In\u00a0Unified \nModeling Language (UML), scenarios can be grouped by use cases, as presented in Chapter \n2. For each use case, one or more scenarios\u2014one for the main flow of events and others for \nalternate scenarios\u2014are created to document the expected system behavior and deviations \nfrom its main flow of events. Scenarios represent instances of use cases; therefore, there \nexists a one-to-many relationship between use cases and scenarios. Since there are no uni-\nversal methods accepted as standard for formatting and capturing scenarios, scenarios can \nbe created as paragraphs, numbered list, tabular or graphical form, or any other convenient \nform that is appropriate for systems analysis and knowledge transfer. Table\u00a03.2 contains a \nsample scenario for the Search Product use case presented in Chapter\u00a02.\nScenarios provide an effective method for eliciting the system\u2019s functions and serve as \nexcellent communication avenue between stakeholders and engineers. They also provide \nan effective method for identifying quality information that can lead to the creation of \nnonfunctional requirements. By presenting a particular quality attribute within context, \nstakeholders can get a better appreciation of how it relates and affects the system. For \nexample, as seen in step 3 of the search product\u2019s main scenario, a statement of perfor-\nmance is initially brought forth for evaluation and (if necessary) modification to specify \nthe actual expected performance of the system. In this example, the scenario helped iden-\ntify an important quality of the system, and, if required, prototypes can be developed to \nfurther evaluate the adequacy of the desired performance.\nSkill Development 3.2: Eliciting Requirements Using Scenarios\nUse any of the other remaining use cases presented in Figure\u00a02.4, and create a detailed \nscenario description including steps, operator actions, and system actions. After \n\u00ad\ncompleting the task, can you think of any quality requirements that can be derived from \nthe \u00ad\nscenario? Explain. Lists the steps that would you consider taking after completion \nof the scenario to ensure that requirements derived from the scenario are \u00ad\nincorporated \ninto the system.\nAnalysis\nIn the analysis activity, requirements are analyzed in their raw form to address issues such \nas requirements that are contradicting, incomplete, vague, or just wrong (Laplante 2009). \nDuring analysis, software architects spend a great deal of time evaluating each require-\nment to determine its impact on the system design as well as its impact on all other identi-\nfied requirements. Analysis allows architects to clear the air in regards to what needs to be \n", "page": 106, "type": "text", "section": "Page 106"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 83\ndone before devising more detailed designs. Software architects may be required to carry \nout important tasks, such as\n\u2022\t Requirement classification\n\u2022\t Requirement prioritization\n\u2022\t Requirement negotiation\n\u2022\t Conceptual modeling\nRequirement classification refers to the activity and process required for identifying \nthe nature of each requirement. Classification is important in determining the relative \nTABLE\u00a03.2\nMain Scenario for Search Product Use Case\nUC-00-Search Product Main Scenario\nDescription: This scenario describes the main flow of operations for requesting a product search with the \nserver system.\nActors: Operator, Server System\nPreconditions: The client and server system have been initialized.\nRequirements: MCR-001, MCR-002\nAlternate scenario: UC-10-Invalid Search, UC-11-Connection Failure, UC-12-Response Timeout\nRevision History\nDate\nVersion\nDescription\nRevised By\n9/17/2010\n1.0\nInitial scenario creation\nJohn Doe\nDescription\nStep\nOperator Action\nSystem Action\n1\nOperator enters valid product ID \nand clicks on the search button.\nValidates the data. Retrieves server\u2019s communication \ninformation from config file.\n2\nEstablishes a connection with the server system and \nsends product request data to the server.\n3\nWaits a maximum of 3 seconds for a server response.\n4\n.\n.\n5\nResponse received and product information is displayed.\n6\nSave response data in file system and ask user to search \nfor another product.\n7\nOperator clicks the cancel button \nto finish searching for products.\nNotes\nFor details of data validation and saving response data to file system see use cases UC-05 and UC-06 \nrespectively.\nApproval Signatures\nSoftware engineer:\nStakeholder(s):\nQuality auditor:\n", "page": 107, "type": "text", "section": "Page 107"}
{"text": "84\u2002 \u2022\u2002 Software Engineering Design\ufeff\nimportance of each requirement and can serve as a driver for prioritization of work units \nand negotiation and trade-off throughout. Common criteria for classifying requirements \nare presented in Table\u00a03.3.\nPrioritization of requirements is done to help identify the most important functions of the \nsoftware system. When done properly, prioritization can help refine the projected schedule \nby determining which requirements (or component carrying out these requirements) need \nto be developed first or can help identify different builds of the software \u00ad\nsystem, which \ncan be designed, developed, and deployed at different times. Prioritization also helps dur-\ning requirement negotiation when conflicts between requirements are identified during \nanalysis. When this occurs, negotiation takes place among stakeholders, and resolutions \nto conflicts are made while taking into account requirement priorities. Finally, an integral \ntask of the analysis activity is conceptual modeling. Conceptual models are created to fur-\nther identify the requirements by understanding their context, discovering the bounds of \nthe software system, and conceptualizing how the system interacts with its environment. \nIn many projects, conceptual modeling is where architectural design begins, since system \ndecomposition is essential to developing effective conceptual models.\nSpecification and Validation\nSpecification is the activity of the requirements phase where the results of elicitation and \nanalysis are formally captured and documented in an appropriate format for the use and \nreview of all stakeholders. The format of the specification varies depending on the develop-\ning organization or project; however, it is typically produced as a document or its electronic \nequivalent (Abran et al. 2005) and is referred to as the software requirements specifica-\ntion (SRS). When specifying requirements, it is important that each requirement exhibit \n\u00ad\ncertain characteristics desired for designing successful systems, including the following:\n\u2022\t Specific\n\u2022\t Correct\n\u2022\t Complete\n\u2022\t Consistent\n\u2022\t Attainable\n\u2022\t Verifiable\nTABLE\u00a03.3\nCommon Criteria for Requirement Classification\nCriteria\nDescription\nFunctional vs. \nnonfunctional\nClassification that differentiates between requirements that specify the functional \naspects of the system versus the ones that place constraints on how the functional \naspects are achieved\nProduct vs. process\nRequirement placed on the system product versus requirements placed on the process \nemployed to build the product\nImposed vs. derived\nRequirements imposed by stakeholders versus requirements that are derived by the \ndevelopment team\n", "page": 108, "type": "text", "section": "Page 108"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 85\nOnce requirements are specified and the SRS is created, validation can occur. \n\u00ad\nRequirements validation is the process of ensuring (through well-known techniques) that \nthe SRS provides a complete and correct representation of what the stakeholders need \n(Laplante\u00a02009).\nSpecific\nRequirements need to be specified in a clear, concise, and exclusive manner. Clear require-\nments are not open to interpretation; unclear or ambiguous requirements lead to incorrect \ndesigns, incorrect implementations, and deceptive validation during test. Concise require-\nments are brief and to the point and are therefore easier to understand. Finally, exclusive \nrequirements specify one, and only one, thing, making them easier to verify. Consider the \nfollowing statements:\n\u2022\t The software needs to provide an easy-to-use interface; that is, it must be usable.\n\u2022\t Speed is a concern; therefore, the software should operate with high performance.\n\u2022\t Software evolution is a concern; therefore, the software shall be testable and \nmaintainable.\nThese statements provide important information to begin thinking about what the cus-\ntomer wants and expects from the software system. However, in their current form, the \nstatements are too generic to use as a basis for design, construction, and verification of \nsoftware systems. For example, a console-based user interface may be highly visible for \nthe system\u2019s developers but not its customers or intended users. Alternatively, the \u00ad\nsystem\u2019s \ntechnical developers may interpret speed as the system responding to received mes-\nsage within 5 milliseconds; anything above would be considered an infeasible solution. \nDesigning the system based on this interpretation may entail sacrificing other functions \nthat may be important to customers and users, when all the while customers and intended \nusers perceived speed as receiving responses within 2 seconds. When left unresolved, state-\nments like these become a major reason for the failure of the project. Examples of specific \nrequirements are presented in Table\u00a03.4.\nTABLE\u00a03.4\nExample of Specific and Nonspecific Requirements\nSpecific\nRequirement\nNo\nThe software shall search the database.\nYes\nThe software shall search for a product using the product ID.\nNo\nThe software shall be secure.\nYes\nThe software shall authenticate users with user ID and password.\nNo\nThe software shall be secure and fast.\nYes\nThe software shall authenticate users with user ID and password.\nServer acknowledgment message shall be sent within 1/2 second from the time a request is received.\n", "page": 109, "type": "text", "section": "Page 109"}
{"text": "86\u2002 \u2022\u2002 Software Engineering Design\ufeff\nCorrect\nRequirements need to be correct in the sense that they must accurately describe a desired \nsystem function. Similar to ambiguous or unclear requirements, specifying incorrect system \nfunctions leads to a chain of incorrect solutions in subsequent development phases. In some \ncases, correctness of requirements is easily identified; in others, it is not. To illustrate this \nproblem, Laplante (2009) presents an example based on requirements for a computer secu-\nrity system for which it requires users to log on using a unique combination of user ID and \npassword. In this case, when users attempt to log on using an already existing user name or \npassword, the system is required to reject the attempt, therefore giving insight into someone \nelse\u2019s logon information. Incorrect requirements, when left unchecked, can lead to incor-\nrect or undesired behavior, such as the vulnerability found in the computer security system \ndescribed above. Examples of correct and incorrect requirements are presented in Table\u00a03.5.\nComplete\nRequirements should be complete both individually and as collective set. This means that \neach requirement should be specified thoroughly so that it absolutely describes the func-\ntions required to meet some need. Collectively, requirements need to provide complete \nspecification of the software\u2019s required functionality in the SRS. Incomplete requirements \nlead to incomplete designs, which in turn leads to incomplete construction of the software \nsystem. Requirements that are complete help clarify questions during construction and \ntesting by providing the information necessary to disambiguate or prevent misinterpre-\ntations of required functionality. Consider requirements for a software system that sup-\nports generation of product reports. An example of an incomplete requirement created for \nthis system is presented in Table\u00a03.6. As seen, determining incomplete requirements is not \nalways an easy task.\nAs seen, the first requirement presented in Table\u00a03.6 specifies the system\u2019s function to \ngenerate product reports; this is a good requirement in the sense that it specifies a function \nTABLE\u00a03.5\nExample of Correct and Incorrect Requirements\nCorrect\nRequirement\nNo\nThe software shall require users to log on using a unique combination of user ID and password.\nYes\nThe software shall require users to log on using a user ID and password.\nThe software shall require users to log on using a valid e-mail address.\nTABLE\u00a03.6\nExample of Complete and Incomplete Requirements\nComplete\nRequirement\nNo\nThe software shall generate product reports.\nYes\nThe software shall generate product reports consisting of product description, picture, and price.\nProduct reports shall be in PDF format.\n", "page": 110, "type": "text", "section": "Page 110"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 87\nthat the system must perform. However, when additional information is available, this \nrequirement becomes incomplete when this information is not specified and is necessary \nfor providing the correct function that meets a particular stakeholder\u2019s need. Consider the \ncase where products have vast amounts of information, such as color, dimensions, store \nlocation, \u00ad\nhistory, and other product information. Generating reports containing all prod-\nuct information may be undesirable if the intended reporting function requires only the \nproduct\u2019s description, picture, and price. In this case, making requirements as complete \nas possible improves the efficiency of the construction and verification phases. Consider \nanother case where there is a need for a client system to interoperate with two existing leg-\nacy servers by sending and receiving messages back and forth using two different (already \nexisting) \u00ad\nmessaging specifications. A requirement that fails to specify a mandate to inter-\noperate with both existing servers supporting both messaging specification may easily lead \nto \u00ad\nclient \u00ad\nsystems that are unable to interoperate with one of the servers, therefore render-\ning the \u00ad\nclient unusable for the system in mind. Completeness is hard because it is not \nalways obvious or it is sometimes too difficult to determine when information is missing \n(Laplante\u00a02009).\nConsistent\nRequirements are consistent when they do not preclude the design or construction of \nother requirements. When they do, individual requirements or the SRS as a whole are \nreferred to as inconsistent. Inconsistent requirements are hard to resolve, since they almost \nalways originate from different stakeholders\u2019 needs. When this occurs, negotiation and \ntrade-offs need to occur to consolidate the requirements and provide a consistent specifica-\ntion. Requirements can also be inconsistent due to incorrect requirements. In these cases, \nrequirements are made consistent easily by removing them from the SRS.\nAttainable\nRequirements that are unattainable serve no purpose. Attainability is a property that spans \nmany different characteristics of the software system, including product characteristics \nsuch as functionality as well as project characteristics such as cost and schedule. When \nspecifying requirements, it is important to evaluate their attainability under both cost and \nschedule constraints. Examples of attainable and unattainable requirements are presented \nin Table\u00a03.7. As seen, although it is nice to develop software without platform limitations \nnow or in the future, verifying this requirement is impossible since it is unattainable.\nTABLE\u00a03.7\nExample of Attainable and Unattainable Requirements\nAttainable\nRequirement\nNo\nThe software shall execute on all future operating systems.\nYes\nThe software shall execute on the Microsoft Windows 7 platform.\n", "page": 111, "type": "text", "section": "Page 111"}
{"text": "88\u2002 \u2022\u2002 Software Engineering Design\ufeff\nVerifiable\nPerhaps the most obvious desirable characteristic of requirements in practical applications is \ntheir verifiability. Requirements that cannot be verified cannot be claimed as met. Inability \nto verify requirements points to a serious flaw early on in the development project\u00ad\n, since \nrequirements are the driving force of all software development activities. In some cases, veri-\nfying requirements can include a complex and costly task. Typically, requirements that are \nunclear or ambiguous lead to unverifiable requirements. Before engaging in any design or \nconstruction work, all requirements in the SRS must be evaluated and analyzed for their \nverifiability. Examples of verifiable and unverifiable requirements are presented in Table\u00a03.8.\nSkill Development 3.3: Requirements Engineering\nConsider the use case models created as part of Skill Development 2.2 that show the \nfive most important functions that your home personal computer system needs to pro-\nvide. Create a list of requirements (three per characteristic) for the computer system \nthat meet the following characteristics: specific, correct, complete, consistent, attain-\nable, and verifiable. Share the list of 18 requirements with a peer, and have him or her \nexplain to you what the requirements specify. Is your understanding of the require-\nments consistent with that of your peer?\nDESIGNING THE ARCHITECTURE\nIn a typical waterfall model for software development, once the software specification \n(i.e.,\u00a0SRS) is validated, the architectural design effort can begin. In practical applications, \nfollowing a strict waterfall model is rarely productive, since new knowledge acquired dur-\ning the development process forces iterative approaches between requirements and archi-\ntectural design. As discussed in previous sections, architectural designs can begin as early \nas the analysis activity of the requirements phase, where conceptual models of the system \nare devised. In either case, be it during requirements or design, designing architectures \nrequire the selection of particular perspectives for design that are appropriate for describ-\ning the system to be developed. To this end, several models have been created that suggest \npopular views that are useful in the design of most systems. These models propose address-\ning the system\u2019s architectural design from perspectives that are common to most software \nTABLE\u00a03.8\nExample of Verifiable and Unverifiable Requirements\nVerifiable\nRequirement\nNo\nThe system shall maximize communication speed.\nYes\nThe system\u2019s data rate shall be no less than 1 Mbps.\n", "page": 112, "type": "text", "section": "Page 112"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 89\nsystems and provide designers with a structured approach for modeling the architecture \nof software-intensive systems. Two popular models are Kruchten\u2019s (1995) 4 + 1 view model \nand Siemens\u2019 4 views model (Hofmeister, Nord, and Soni 2000).\nThe 4 + 1 View Model\nIn 1995, Philippe Kruchten published an influential paper that proposed modeling software \narchitectures using different perspectives; each perspective provides avenues for address-\ning problems from different angles, and, when combined, the set of models created from \neach perspective helps form the software architecture. Kruchten\u2019s model concentrated \non four main views: logical, process, development, and physical. Modeling systems from \neach view requires addressing design problems of different natures, such as problems that \ndeal with the logical system structure or problems that deal with dynamic, concurrency \n\u00ad\nsystem issues. To ensure consistency among all four views, the user\u2019s perpective is captured \nthrough several key use cases. Today, Kructhen\u2019s 4+1 view model, presented in Figure\u00a03.2, \nis used as a basis for the rational unified process (Bass et al. 2003).\nThe 4+1 model provides an adequate framework for modeling the architecture of most \nsoftware systems. However, adoption of the model varies from organization to organiza-\ntion, and from project to project. For example, when concurrency is not an issue, modeling \nthe system from a process view makes little to no sense. Similarly, for systems that reside \nin one node and in which the physical properties of their deployment are not of concern, \nmodeling them using the physical view provides little to no benefit. Typically, all software \nsystems benefit from the logical view; therefore, designs elements from this view should be \nincorporated into the software architecture.\nUser View\nThe user view of a software system represents the behavior that the system exhibits to its \nusers. Specifically, the user view depicts how users interact with the system and how the \nspecific sequences of inputs and outputs occur during software operation. Users represent \nanyone who interacts with the software system, such as operators, software testers, \u00ad\nanalysts, \nand quality. As part of this view, UML use case models can be used to drive scenarios that \nprovide storylines and to promote consistency among all other models. The scenarios cre-\nated can help capture important system functions and discover new knowledge that drives \nLogical View\nDevelopment View\nProcess View\nPhysical View\nUser View \nFIGURE 3.2\n4+1 view model for software architecture.\n", "page": 113, "type": "text", "section": "Page 113"}
{"text": "90\u2002 \u2022\u2002 Software Engineering Design\ufeff\narchitectural design decisions. The user view also provides an effective source of informa-\ntion for verifying and validating system functions, after the system is built. In\u00a0addition to \nUML use cases, UML activity diagrams can be used to flush out important user interactions \nthat are important during architectural design (Pressman 2010).\nProcess View\nThe process view of a software system represents the dynamic or behavioral aspects of the \nsoftware system where the main units of analysis are processes and threads. Using this \nview, software systems are decomposed into processes and threads to address design issues \nthat deal with the dynamic flow of control between architectural elements, such as concur-\nrency, distribution, system\u2019s integrity, fault tolerance, and other nonfunctional require-\nments (Kruchten 1995). Since analysis using the process view is behavioral in nature, \nbehavioral UML diagrams can be used efficiently to address issues pertinent to the process \nviews. Particularly, UML sequence and communication diagrams, together with the active \nobject notation (presented in Chapter 2), can be used to evaluate, analyze, and characterize \nthe system\u2019s capabilities from the process perspective. This view is necessary for projects \nthat need to meet performance and availability requirements by modeling aspects of con-\ncurrency, distribution, and fault tolerance.\nPhysical View\nThe physical view of a software system represents the deployment aspects of software systems \nwhere the main elements of analysis are nodes, connections between nodes, and maps of \nsoftware artifacts to nodes. The physical view focuses on modeling of elements that directly \naffect quality requirements, such as availability, performance, and scalability (Kruchten \n1995). For example, consider a case where system quality is measured in part by the avail-\nability of the system. That is, systems are perceived as low quality when they fail to provide a \nspecified behavior. In this case, availability can be addressed via redundancy of processors or \ncomplete nodes, which both can be depicted using UML deployment \u00ad\ndiagrams. The identifi-\ncation of redundant nodes using the physical view requires downstream design and develop-\nment to think about techniques for identifying faults and swapping between primary and \nredundant nodes when necessary to support the system\u2019s availability. Similarly, aspects that \naffect system performance must be addressed using the physical view. When performance \nis measured with throughput, the physical view of \u00ad\nsystems must identify the elements that \ndirectly impact this metric, such as required bandwidth between a client and server.\nIn some applications, modeling system deployment may require one or more UML \ndeployment diagrams. Different deployment diagrams may be necessary to model dif-\nferent deployment configurations of the same software system, for example, deployments \nof software systems in testing environments or in different locations where deployment \nconfigurations may differ. In each case, the physical view provides insight into necessary \nelements that directly affect the perceived quality of the software system. An example of \nthe physical view of software systems is presented as a deployment diagram in Chapter 2.\n", "page": 114, "type": "text", "section": "Page 114"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 91\nDevelopment View\nThe development view of software systems represents the software development configu-\nration aspects of the software system, where the main units of decomposition are actual \nphysical files and directories. The development view is used to analyze the system from the \nperspective of how logical components map to physical files and directories. These analyses \ncan be employed to address concerns that deal with ease of development, \u00ad\nreusability, con-\nstraints imposed by tool sets, allocation of work to teams, cost evaluation and planning, \nmonitoring the project\u2019s progress, portability, and security (Kruchten 1995). In\u00a0 UML, \narchitectural elements resulting from analyzing systems from the development\u2019s perspec-\ntive can be documented using package diagrams in combination with components and \nclass diagrams as well as notes, tagged values, and constraints to enhance the meaning \nof the diagrams. This way, components can be mapped to the hierarchy of files in the file \nsystem, and their interrelationships and process for building one or more versions of the \nsoftware system can be carefully specified.\nLogical View\nThe logical view of a software system is used to decompose systems into logical compo-\nnents that represent the structural integrity that supports functional and nonfunctional \nrequirements. Examples of architectural design elements using the logical view are pre-\nsented in Figure\u00a02.1. Using this view, the static structure of the system can be modeled \nusing high-level diagrams to decompose, abstract, and encapsulate the services that the \nsystem needs to provide to its users. By using these diagrams, the major components, their \ninterfaces, and their associations with all other components are identified. Architectural \nlogical designs exist at a higher level of abstraction than detailed designs and can be mod-\neled using box and line diagrams, UML component diagrams, package diagrams, or class \ndiagrams. Architectural logical designs provide the building blocks for detailed design; \ntherefore, they are indispensable in the architectural design of software systems.\nSkill Development 3.4: Designing with Architectural Views\nAs seen, views are used to present the system from particular perspectives so that \ndesign elements particular to that perspective can serve as tool for evaluating a desired \nproperty of the system. Using the logical view, the system\u2019s reusability can be evalu-\nated; through the physical view, the system\u2019s availability can be examined; and the pro-\ncess view can be used to evaluate the system\u2019s performance. Consider the architectural \ndesign of two systems: a banking information system and a safety-critical medical sys-\ntem. For each system, come up with appropriate views\u2014feel free to come up with ones \nother than those presented in this chapter\u2014and how they could help address particular \nconcerns in each. Discuss and justify your results with peers.\n", "page": 115, "type": "text", "section": "Page 115"}
{"text": "92\u2002 \u2022\u2002 Software Engineering Design\ufeff\nComponents and Connectors\nIn Chapter 2, components were presented to depict units of the logical architecture. \nConceptually, a component is an entity that encapsulates some functionality and provides \nservices through well-known interfaces. By definition, then, components can be replace-\nable by other components that provide equal interfaces. Components are building blocks \nthat exemplify the general design principles of abstraction, encapsulation, and modular-\nization presented in Chapter 1. Prior to UML 2.0, the concept of components was different \nin that it denoted specifically a physically deployable unit, which limited the use of the \ncomponent entity in architectural diagrams. However, this is not the case in the current \nversion of the UML, so the component concept can be used to model logical, modular \nparts of a system.\nComponents do not exist in isolation; they are part of a logical architecture that depicts \ninteractions with other components. In some applications, interactions between compo-\nnents are far more complicated than what UML\u2019s typical relationships (e.g., association, \ndependency) can reflect. In these systems, the proper identification and description of \nsuch interactions can have a profound impact on quality requirements. For this reason, the \nconcept of a connector is devised. A connector is an architectural entity that abstracts the \ncomplexities of the interactions between components. Therefore, connectors can represent \ninteraction between components as simple procedure calls, shared data access, or more \nadvanced mechanisms such as remote procedure calls (Taylor, Medvidovic, and Dashofy \n2009). Together, components and connectors can be used as fundamental building blocks \nfor large-scale software architectures.\nDesigning Logical Architectural Elements Using Data Flows\nThere are many approaches for designing logical architectures. These approaches are typi-\ncally associated with the overall design strategy selected for a given product. For example, \nwhen using the structured design strategy, a disciplined approach is employed to decom-\npose systems into independent, single-purpose modules, using an iterative top-down \napproach. The main focus of structured design is on the functions that systems need to \nprovide, the decomposition of these functions, and the creation of modules that incorpo-\nrate these functions. Structured design approaches are typically employed after structured \nanalysis, where the main purpose is to derive a structure chart (i.e., logical software archi-\ntecture) from data flow diagrams (DFDs). A popular approach for creating structure charts \nincludes employing transform analysis (Pressman 2010). When using transform analysis, \nthe flow of data through the system is analyzed using DFDs to derive data transformations \n(i.e., functions) required to generate the system\u2019s outputs. Initially, a level 0 DFD is used to \nrepresent the initial context of the system. As the DFD is refined, further levels of the DFD \nare produced to expose further transformations of different scope. This refinement process \nis iteratively done until all transformations are identified and grouped into components to \nform the logical architecture of the system.\n", "page": 116, "type": "text", "section": "Page 116"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 93\nDesigning Logical Architectural Elements Using Styles and Patterns\nIn the 1990s, the software engineering community began paying attention to recurring \narchitectural solutions in terms of specific elements and their relationships. These solu-\ntions were known as architectural styles and patterns; these terms are used interchangeably \nthroughout (see Chapter 4). Architectural patterns provide the means for software architects \nto reuse architectural design solutions in different projects. Buschmann, Meunier, Rohnert, \nSommerlad, and Stal (1996) introduced a catalog of architectural patterns that conveyed \nfundamental structural organization for software systems, including predefined compo-\nnents, their responsibility, and rules for specifying the relationship between them. Together, \nthese architectural patterns serve as a blueprint for designing elements of the logical archi-\ntecture of particular groups of systems. The application of architectural patterns to the \ndevelopment of software systems occurs at the highest level of abstraction in the design pro-\ncess. Since they are used to create architectural elements, they do not describe the detailed \ndesign of the system and therefore cannot be directly translated into code. Identifying pat-\nterns at the architectural level (and designing around them) improves the quality of the final \nsystem by reducing the design of logical architectural elements to a \u00ad\ncollection of interacting \ncomponents whose expected behavior is well understood. Examples of architectural design \nelements using architectural patterns are presented in Chapter 4.\nDesigning the Process Architecture\nWhereas logical elements of the software architecture model static, structural aspects of the \nsoftware system, process elements model how elements interact to evaluate certain aspects \nof the software\u2019s quality, such as concurrency. In software systems, concurrency is achieved \nmainly though multithreading or multiprocessing the system. Multithreading or multi\u00ad\nprocessing applications introduce concurrency issues that require careful analysis to ensure \nthat architectural designs account for effective synchronization techniques. Concurrent \ndesigns that work on the same data are tougher to design and manage since they can lead to \nsoftware errors that are hard to find (e.g., race conditions) and increase the complexity of the \nsoftware development effort. To fully understand and model issues such as performance, one \nmust have some understanding of the universal mechanisms in place when software applica-\ntions execute. Although code has no place during the software architecture activity, every soft-\nware architect must understand how the modeling of process elements affects the downstream \nwork performed during construction. For this reason, an unconventional learning approach \ninvolving code in the study of software architecture to introduce important architectural \nconcepts and present the process view of software architecture is employed. This under-\nstanding is essential when modeling parts of the software that will affect its process quality.\nProcesses\nProcesses and threads are fundamental units of execution in today\u2019s modern software \n\u00ad\nsystems. They are created, managed, and terminated by the operating system. A process is \n", "page": 117, "type": "text", "section": "Page 117"}
{"text": "94\u2002 \u2022\u2002 Software Engineering Design\ufeff\na unit of software execution, that is, a program in execution. When you execute software, \nfor example, an executable (.exe) file in Windows, a process is created by the Windows \noperating system. This process has some unique characteristics that distinguish from other \nprocesses. Whenever a process is created, the operating system creates a process control \nblock (PCB) with information required by the operating systems to schedule and manage \nthe process. This information can include the program counter, process state, registers, and \nstack. In single-processor systems, the operating system uses this information to switch \nbetween different processes while maintaining the integrity of all processes. This switch-\ning, known as a context switch, requires saving the information from a PCB of the active \nprocess and loading a PCB of the new process into memory to continue execution. A con-\ntext switch is pure overhead, since the processor\u2019s time is spent doing management tasks \nrather than useful work for the software system; however, it enables concurrency. These \noperations happen so quickly that programs executing are perceived as executing concur-\nrently. In single-processor systems, this pseudo-concurrency allows designers to model the \nsystem with concurrency in mind. In multiprocessor systems, processes are scheduled for \nexecution in more than one processor, so actual concurrency is achieved. In either case, \nconcurrency is used to increase the performance of the software system. Software systems, \nespecially distributed systems, can be designed as systems of multiple processes executing \non the same or different networked computing platforms. Multiple processes are used to \nleverage off the operating system to achieve concurrency of operations and increase the \n\u00ad\nsystem\u2019s performance. That is, modern operating systems provide scheduling mechanisms \nthat allow multiple processes to execute concurrently to maximize CPU usage.\nThreads\nThreads, sometimes called lightweight processes, are similar to processes in that they allow \ncode to be compartmentalized in a way that they are schedulable as independent flows \nof control by the operating systems. In most modern operating systems, threads execute \nwithin a single process in a one-to-many fashion\u2014that is, one process can contain one or \nmore threads. Threads, therefore, can be thought of as small, schedulable, and sequential \nprogram units executing (typically) within a process. Processes that execute with only one \nthread can be described as sequential, or serial, which means that the commands in the \nprograms are executed in turn so that a specific command is executed only after the previ-\nous command is finished. In single-threaded applications, if one statement halts waiting \nfor some computer resource (e.g., input\u2013output resource), the execution of the program \nblocks until the resource becomes available and execution can continue. For example, \n\u00ad\nconsider the code in Listing 3.1.\nIn the Windows operating system, when the code in Listing 3.1 is compiled and built, \na file with an .exe extension is created. When this file is executed, a process is created \nwith one thread, whose body of execution is defined by the main function. In this case, \nthe operations in the main thread will execute sequentially until the return operation is \nencountered, at which point the operating system destroys both thread and process and the \nprogram is \u00ad\nfinished. Since there is only one independent flow of execution (i.e., one thread), \n", "page": 118, "type": "text", "section": "Page 118"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 95\nthe program will halt at the cin>>number line until a number followed by the return \nkey is entered as input. This is true because the cin>> line results in a \u00ad\nblocking\u00a0call to the \noperating system; that is, the main thread will block execution until input is provided. \nWhile blocking, the program wastes execution time in the sense that it is not utilizing the \nprocessor for achieving other necessary application-dependent tasks. When the thread is \nblocked, the process can accomplish nothing else, since there is only one flow of execution.\nWhen multiple threads execute, multiple independent flows of control exit, so that if one is \nin a blocking state others can continue executing. To achieve this, the operating system needs \nto execute context switches to manage the program execution among the different threads \nin pseudo-concurrent fashion at the expense of causing similar but reduced overhead as the \nones described with processes. By allowing the executing software to perform other activi-\nties while waiting for some resource, its performance may be enhanced. Consider Listing 3.2 \nfor a number-guessing game where the executing software counts until user input is received \nand then determines if the input (i.e., guessed number) matches the counted number.\nWhen this program executes, a single process is created, and its main thread is \u00ad\nexecuted. \nAs the main thread executes sequentially, a counter object of ThreadCounter type \nis \u00ad\ncreated. The ThreadCounter type abstracts the creation of another thread that is \nstarted by calling the object\u2019s count\n() method, which results in an independent flow of \nListing 3.1: C++ Code for Single-Threaded Application\n#include <iostream>\nusing namespace std;\nint main( int argc, char* argv[] ) {\n\t // A number to be guessed.\n\t const int THE_NUMBER = 10;\n\t // User input.\n\t int number;\n\t // Display message to user.\n\t cout<<\u201dGuess a number from 0-100:\\n\u201d;\n\t // Block waiting for user input.\n\t cin>>number;\n\t // Display results to user.\n\t cout<<\u201cYour guess is \u201d<<number<<\u201c, actual number is \u201d \n<<THE_NUMBER<<endl;\n\t // End of program.\n\t return 0;\n}\n", "page": 119, "type": "text", "section": "Page 119"}
{"text": "96\u2002 \u2022\u2002 Software Engineering Design\ufeff\nexecution created tasked with counting. This allows the main thread to continue execut-\ning sequentially while the counter thread counts. The main thread will block waiting for \nuser input (via cin) while the counter thread continues to count, therefore introducing \nconcurrency into the software. Once user input is received, the main thread terminates \nthe counter thread and displays the results. This process is presented in Figure\u00a03.3 using a \nsequence diagram with active objects relying on synchronous and asynchronous messages. \nNotice that once the counter threads calls its start\n() method, it counts and does nothing \nelse until it is finished counting, which is triggered by the stop() method. This is modeled \nusing the synchronous message to self.\nThe code presented in Listing 3.2 serves as a good example for introducing the concept \nof concurrency in a simplified manner. Concurrency issues are always amplified when \ndata need to be shared among concurrent flows of executions. In these cases, correct \nListing 3.2: C++ Code for Concurrent Number-Guessing Game\n#include <iostream>\n#include \u201cThreadCounter.h\u201d\nusing namespace std;\nint main( int argc, char* argv[] ) {\n\t // User input.\n\t int number;\n\t // Create the thread counter object.\n\t ThreadCounter counter;\n\t // Start the counter.\n\t counter.count();\n\t // Display message to user.\n\t cout<<\u201dGuess a number from 0-100:\\n\u201d;\n\t // Block waiting for user input.\n\t cin>>number;\n\t // Stop the counter.\n\t counter.stop();\n\t // Display results to user.\n\t cout<<\u201cYour guess is \u201d<<number<<\u201c, actual number is \u201d\n\t\n<<counter.current()<<endl;\n\t // End of program.\n\t return 0;\n}\n", "page": 120, "type": "text", "section": "Page 120"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 97\nsynchronization mechanisms need to be in place to ensure the proper execution of the soft-\nware system. Consider the case of a communication system receiving messages concurrently \nthrough two different interfaces. Upon receiving messages, the system updates its message \ncount statistic and continues on to process each message. Listing 3.3 presents the code for \nthe MessageStatistics type used to abstract services for managing message statistics.\nAs seen, the MessageStatistics type has an interface method to increment the \nnumber of received messages throughout the system. Since the system requires concur-\nrency, each independent flow of message processing is carried out using two different \nthreads; therefore, it is assumed that a base Thread class exists that abstracts the creation \nand management of threads, providing a simplified interface that contains start\n() and \nstop() methods to execute and terminate the thread. In addition, the Thread base class \nprovides an abstract method run() used by derived classes to provide the implementation \nof the thread\u2019s main (entry) function and an isActive() method to determine if the \nthread should continue executing or not. With such framework in place, the code for the \nSerialReceiverThread class, used to receive messages through the serial communi-\ncation interface, is presented in Listing 3.4.\nAs seen, the class is configured with a reference to an object of type Message\u00ad\nStatistics, which is used to update the message count once a serial message is received. \nSimilarly, the EthernetReceiverThread class is designed to be a thread that waits \nfor incoming messages via the Ethernet interface, as presented in Listing 3.5.\nAs seen, this class is also initialized using a reference to a MessageStatistics object, \nso that both serial and Ethernet threads rely on the same data structure to update message \nstatistics. Consider what happens when objects of type SerialReceiverThread and \nmain : MainTread\n1 : count( )\n2 : start( )\ncounter = 1, wait 1 sec.\ncounter = 2, wait 1 sec.\ncounter = 3, wait 1 sec.\ncounter = 4, wait 1 sec.\ncounter = 5, wait 1 sec.\ncounter = 6, wait 1 sec.\ncounter = 7, wait 1 sec.\n4 : stop( )\n3 : user input\nsd Concurrent Number Guessing Design\ncounter : TreadCounter\nFIGURE 3.3\nUML design for concurrent guessing game.\n", "page": 121, "type": "text", "section": "Page 121"}
{"text": "98\u2002 \u2022\u2002 Software Engineering Design\ufeff\nEthernetReceiverThread are both initialized using the same object instance of the \nMessageStatistics class, as illustrated in Listing 3.6. Once instantiated, both threads \nstart to receive messages via their respective interfaces. The main thread simply waits until \nall expected messages are received.\nThe main problem with Listing 3.6 can be traced to the critical section of code inside the \nincrement\n() method of the MessageStatistics class. A critical section is a code segment \nthat makes changes to common variables, such as the _messageCount. This makes software \nmore challenging to design and evaluate since the integrity of the data inside the critical section \nneeds to be preserved. Since there are no safeguards to ensure the proper synchronization of \nmultiple threads when updating the _messageCount variable, both threads may attempt \nto update the message count at the same time, therefore resulting in unpredictable results that \nmay hinder the system\u2019s integrity. To illustrate this point, consider the assembly (lower-level) \ncode generated to increment the _messageCount variable, as seen in Listing 3.7.\nUsing a disassembly tool, it can be seen that the _messageCount++ written in C++ \nrequires three assembly lines of code: one to move the current value of _messageCount \nListing 3.3: C++ Code for Specification of the MessageStatistics Type\nclass MessageStatistics {\npublic:\n\t // Use constructor to set messageCount = 0;\n\t // Method to increment number of received messages.\n\t void increment() {\n\t \t // A message has been received, increment the current count.\n\t \t _messageCount++;\n\t }\n\t // Method to return the current number of messages received.\n\t int count() {\n\t \t // Return the number of messages received.\n\t \t return _messageCount;\n\t }\n\t // ...\nprivate:\n\t // Variable used to keep track of the number of messages received.\n\t int _messageCount;\n\t // ...\n};\n", "page": 122, "type": "text", "section": "Page 122"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 99\nto the accumulator eax register; one to increment the value; and the last one to move the \nresults back from the eax register to the address referenced by the _messageCount vari-\nable in C++. When executed concurrently, both threads of execution will execute the opera-\ntions. However the order in which they are executed cannot be guaranteed; that is, the order \ncan be interleaved in some arbitrary fashion. Consider the interleaved order of execution \namong the two threads\u2014each receiving messages at the same time\u2014presented in Table\u00a03.9.\nAfter execution, the value of _messageCount is incorrectly set to 1, when it should \nbe\u00a02, since two messages were received. This phenomenon is known as a race condition \nand occurs when two processes or threads operate concurrently on the same data and the \noutcome of the execution depends on the particular order in which the access takes place. \nThis example shows the importance of designing and evaluating architectural elements \nusing the process view, which provides the appropriate perspective for detecting such \nListing 3.4: C++ Code for the Serial Message Processor Thread Class\nclass SerialReceiverThread : public Thread {\npublic:\n\t // Constructor.\n\t SerialReceiverThread(MessageStatistics& stats) {\n\t \t // Save the statistics object for later use.\n\t \t _stats = &stats;\n\t }\nprotected:\n\t // Thread\u2019s main function.\n\t virtual void run() {\n\t \t while( isActive() ) {\n\t \t \t // Wait for a message via the serial interface.\n\t \t // Once a message is received, increment count in the stats\n\t \t // object.\n\t \t \t _stats->increment();\n\t \t \t // Process received serial message.\n\t \t } // end while loop.\n\t } // end run() method.\nprivate:\n\t // The pointer to the stats object.\n\t MessageStatistics* _stats;\n};\n", "page": 123, "type": "text", "section": "Page 123"}
{"text": "100\u2002 \u2022\u2002 Software Engineering Design\ufeff\ncases. When these cases are detected, guards in the design can be introduced to protect the \nintegrity of such critical sections of code. In UML, such design evaluations and decisions \ncan be captured using the synchronization properties such as Sequential, Guarded, and \nConcurrent presented in Chapter 2. These properties place constraints in process models \nto support concurrency by controlling the way multiple flows of execution access critical \nsections of code. The Sequential synchronization property specifies that no concurrency \nmanagement mechanism is associated with an operation, such as in the case of the existing \nincrement method in Listing 3.3. With sequential access, concurrency conflicts may occur, \nso clients that rely on the operation need to coordinate so that only one invocation occurs \nat any given point. The Guarded property specifies that the operation can be invoked from \nListing 3.5: C++ Code for the Serial Message Processor Thread Class\nclass EthernetReceiverThread : public Thread {\npublic:\n\t // Constructor.\n\t EthernetReceiverThread(MessageStatistics& stats) {\n\t \t // Save the statistics object for later use.\n\t \t _stats = &stats;\n\t }\nprotected:\n\t // Thread\u2019s main function.\n\t virtual void run() {\n\t \t while( isActive() ) {\n\t \t \t // Block waiting for a message via the serial interface.\n\t \t \t // Once a message is received, increment count in the stats\n\t \t \t // object.\n\t \t \t _stats->increment();\n\t \t \t // Process received Ethernet message.\n\t \t } // end while loop.\n\t } // end run() method.\nprivate:\n\t // The pointer to the stats object.\n\t MessageStatistics* _stats;\n};\n", "page": 124, "type": "text", "section": "Page 124"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 101\nListing 3.6: C++ Code for Concurrent Application\n// Code to demonstrate the critical section concept in concurrent \nprograms.\n#include <iostream>\n#include \u201cSerialReceiverThread.h\u201d\n#include \u201cEthernetReceiverThread.h\u201d\n#include \u201cMessageStatistics.h\u201d\nusing namespace std;\nint main( int argc, char* argv[] ) {\n\t // Number of messages received.\n\t int messagesReceived = 0;\n\t // Number of messages expected.\n\t const int MESSAGES_EXPECTED = 10;\n\t // Create the object to keep track of message statistics.\n\t MessageStatistics msgStats;\n\t // Create the thread to receive messages via serial interface.\n\t SerialReceiverThread serial(msgStats);\n\t // Create the thread to receive messages via Ethernet interface.\n\t EthernetReceiverThread ethernet(msgStats);\n\t // Start receiving messages through both interfaces.\n\t serial.start();\n\t ethernet.start();\n\t while( msgStats.count() < MESSAGES_EXPECTED ) {\n\t \t cout<<\u201cMessages received: \u201d<<msgStats.count()<<endl;\n\t \t // if flag set, exit loop.\n\t \t // Blocking call. Wait one second before checking again.\n\t \t sleep(1000);\n\t }\n\t // Stop receiving through serial interface.\n\t serial.stop();\n\t // Stop receiving through Ethernet interface.\n\t ethernet.stop();\n\t // End of program.\n\t return 0;\n}\n", "page": 125, "type": "text", "section": "Page 125"}
{"text": "102\u2002 \u2022\u2002 Software Engineering Design\ufeff\nmultiple independent flows simultaneously, but only one flow of execution is allowed to \ncommence; other independent flows are blocked until the execution of a currently execut-\ning operation, under the currently executing thread, is complete. When using the Guarded \nsynchronization property, it is the responsibility of the designer to ensure that concurrency \nissues, such as starvation and deadlocks, do not occur. Finally, the Concurrent synchroniza-\ntion property specifies that multiple invocations may occur simultaneously and all of them \nmay proceed concurrently. Concurrency is achieved in languages with built-in support for \nconcurrency, such as Java, with the use of the synchronized property. To resolve the \nissue of concurrency caused by the increment\n() method, the Guarded synchronization \nconcept can be modeled and manifested in code by ensuring that the critical section of code \nthat increments the _messageCount is mutually exclusive to both threads of execution. \nThis can be achieved by employing a mutually exclusive (Mutex) object, typically provided \nby the operating system. The code from Listing 3.3 is modified using pseudo-code to sup-\nport concurrency, as seen in Listing 3.8.\nThe concepts presented in Listings 3.3, 3.4, 3.5, 3.6, and 3.8 can all be summarized using \ntwo simple UML designs, as seen in Figure\u00a03.4.\nThe concepts presented so far are essential for understanding how the process view of \nsoftware architecture is used to evaluate and design for performance in software systems. \nThese concepts play a key role in designing systems that meet performance and availability \nrequirements by modeling aspects of concurrency, distribution, and fault tolerance.\nListing 3.7: Sample Assembly Program to Increment _ messageCount\n; Move contents of _messageCount to eax register.\nmov eax, dword ptr [_messageCount (417140h)]\n; Add one to the number in eax.\nadd eax, 1\n; Copy the result from eax to _messageCount.\nmov dword ptr [_messageCount (417140h)], eax\nTABLE\u00a03.9\nInterleaved Execution in Concurrent Designs\nTime\nSource\nOperation\n_messageCount\nT0\nThread 1\nmov eax, dword ptr [_messageCount (417140h)]\n0\nT1\nThread 1\nadd eax, 1\n0\nT2\nThread 2\nmov eax, dword ptr [_messageCount (417140h)]\n0\nT3\nThread 2\nadd eax, 1\n0\nT4\nThread 1\nmov dword ptr [_messageCount (417140h)], eax\n1\nT5\nThread 2\nmov dword ptr [_messageCount (417140h)], eax\n1\n", "page": 126, "type": "text", "section": "Page 126"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 103\nEVALUATING THE ARCHITECTURE\nArchitecture evaluation is the process of determining how well suited architecture is for \ndeveloping a system that meets both its intended functional and quality requirements. \nFrom a functional perspective, architectures need to introduce the appropriate abstrac-\ntions for the services that the system is required to provide. The functional properties of the \narchitecture can be evaluated using the identified logical components, assigning require-\nments to them and modeling the interactions required among components to support all \nfunctional requirements. On the other hand, evaluating the architecture\u2019s ability to sup-\nport expected system quality requires more effort to ensure that the proposed architecture \nprovides a good approach for a system\u2019s development. Evaluating architectures for their \nprovided quality requires the investigation and breakdown of quality goals to attributes \nthat are adequate for evaluation. The architectural evaluation determines the appropriate-\nness for supporting these quality features and can be used for determining their relative \nimportance and how they impact other quality attributes supported by the architecture. \nThis information, in turn, is used to evaluate different proposed architectures and to pri-\noritize quality goals so that design trade-off among stakeholders can occur. Ultimately, the \nevaluation process is performed until a solution that is sufficiently complete and accept-\nable for all stakeholders is found. Although there is no universally accepted methodol-\nogy for analyzing and evaluating software architectures, the architecture trade-off analysis \nmethod (ATAM) approach (Bass et al. 2003) provides a rigorous and proven methodology \nfor such endeavors.\nListing 3.8: C++ Code for Guarded Implementation of the increment() method\n// Method to increment number of received messages.\nvoid increment() {\n\t // Access Mutex. If unavailable, block until it becomes available.\n\t // If you are here, it means that you have access to the Mutex. Once\n\t // in possession, no other thread of execution can gain access to the\n\t // Mutex, therefore this critical section of code is protected.\n\t // Increment the message count.\n\t _messageCount++;\n\t // Release the Mutex. The next thread waiting for the Mutex will gain\n\t // access to it, therefore gaining protected access to the critical\n\t // section of code.\n}\n", "page": 127, "type": "text", "section": "Page 127"}
{"text": "104\u2002 \u2022\u2002 Software Engineering Design\ufeff\nCHAPTER SUMMARY\nThe software architecture activity corresponds to a macrodesign approach for transform-\ning software requirements into design elements that support quality and functions of \nsoftware systems. Formally, software architecture is defined as the foundational software \ndesign activity that evaluates and translates software requirements (both functional and \nnonfunctional) into a collection of design elements that specify structural and behavioral \naspects of the major components of the system, together with their provided quality and \n_stats\n\u2013messageCount: int\n+increment(): void {Guarded}\n+count(): int\n_stats\n<<thread>>\nserial : SerialReceiverTread\nincrement()\n{Guarded}\nincrement()\n{Guarded}\nmsqStats : MessageStatistics\n#run(): void\n<<thread>>\nethernet : EthernetReceiverTread\nEthernetReceiverTread\nMessageStatistics\n#run(): void\nStructural View\nBehavioral View\n+start(): void\n+stop(): void\n+run(): void\n#isActive() : bool\nSerialReceiverTread\nTread\nFIGURE 3.4\nUML concurrent design for communication elements.\n", "page": 128, "type": "text", "section": "Page 128"}
{"text": "Principles of Software Architecture\u2002 \u2022\u2002 105\ninterrelationships required to support the detailed design and construction of software \nsystems and the product resulting from such activity. To accomplish all of this, software \narchitects must be familiar with activities from the requirements engineering discipline so \nthat inputs to the software architecture activity can be well understood and formulated in \nsuch a way that supports the design and development of the software system. To address \nthe concerns from multiple stakeholders, architects model architectural elements using \ndifferent views, which may be prescribed by popular view models, such as the 4+1 view \nmodel. All systems use the logical view to identify and structure the major components, \nassign responsibility to them, and model their interactions. In some cases, architectural \nstyles and patterns can be used to provide architectural (logical) solutions to common \narchitectural problems. All architectural elements designed from all particular views form \nthe software architecture, which can be used to establish the initial framework for the \nquality of the system. Since architecture alone cannot guarantee the quality of the system, \nprocesses need to be in place to ensure that architectural decisions made to address quality \nconcerns are maintained throughout the development life cycle. The software architecture \nlays the foundation for all subsequent work in the development process and serves as an \nimportant communication, reasoning, and analysis tool for the development and mainte-\nnance of software systems. Once complete, the detailed design activity can begin.\nREVIEW QUESTIONS\n\t\n1.\tWhat is software architecture, and how does it differ from other forms of design?\n\t\n2.\tHow can software architecture affect both product development and product man-\nagement activities?\n\t\n3.\tList and explain the common tasks performed during software architecture.\n\t\n4.\tWhat are the common input, constraints, and outputs found during architectural \nproblem solving?\n\t\n5.\tWhy is it important for software architects to be familiar with the discipline of \nrequirements engineering?\n\t\n6.\tWhat are the four main activities performed during requirements engineering? Explain.\n\t\n7.\tList and explain four common quality attributes for software systems.\n\t\n8.\tWhat are the essential characteristics that requirements must exhibit when specify-\ning requirements? Provide an example of each.\n\t\n9.\tWhat are architectural views, and why are they important in software architecture?\n\t 10.\tExplain Kruchten\u2019s (1995) 4+1 view model.\n\t 11.\tWhat are architectural styles and patterns, and why are they important in software \narchitecture?\n\t 12.\tWhat are the following concepts, and how do they relate to the process architecture \nof software systems?\n\t\na.\t Process versus threads\n\t\nb.\t Blocking calls\n", "page": 129, "type": "text", "section": "Page 129"}
{"text": "106\u2002 \u2022\u2002 Software Engineering Design\ufeff\n\t\nc.\t Race condition\n\t\nd.\t Critical section\n\t 13.\tIn UML, what synchronization properties are available to constraints process models \nthat support concurrency? Explain each.\nCHAPTER EXERCISES\n\t\n1.\tSelect a problem of interest and write a statement of work that describes the over-\nview of the problem. Use this statement of work to generate a list of requirements for \nthe system and to explain how each requirement meets the desired characteristics of \nrequirements. Once the list of requirements is defined, complete the \u00ad\nfollowing steps:\n\t\na.\t Determine at least two views appropriate for this problem.\n\t\nb.\t Using a UML modeling tool, create design elements appropriate for each view.\n\t\nc.\t For each design element, write a paragraph describing how the design element \nhelp address particular concerns for the system.\n\t\nd.\t Assume that portability and performance have been identified as new quality attri-\nbutes for the system. Integrate these into the design. Note that you will have to make \nassumptions to complete this step. Make sure that you document all assumptions.\n\t\ne.\t Evaluate how all assumptions, identified requirements, and quality attributes \nare supported by the resulting architectural elements. Create a report that docu-\nments the result of the evaluation process.\nREFERENCES\nAbran, Alain, James W. Moore, Pierre Bourque, and Robert Dupuis. Guide to the Software Engineering Body of \nKnowledge\u20142004 Version\u2014SWEBOK. Los Alamitos, CA: IEEE Computer Society Press, 2005.\nBass, Len, Paul Clements, and Rick Kazman. Software Architecture in Practice, 2d ed. Boston: Addison-Wesley, \n2003.\nBuschmann, Frank, Regine Meunier, Hans Rohnert, Peter Sommerlad, and Michael Stal. Pattern-Oriented \nSoftware Architecture: A System of Patterns. West Sussex, UK: Wiley, 1996.\nClements, Paul, Rick Kazman, and Mark Klein. Evaluating Software Architectures. Santa Clara, CA: Addison \nWesley, 2001.\nGorton, Ian. Essential Software Architecture. Heidelberg, Germany: Springer, 2011.\nHofmeister, C., R. Nord, and D. Soni. Applied Software Architecture. Boston: Addison-Wesley, 2000.\nKruchten, Philippe. \u201c\nArchitectural Blueprints\u2014The \u201c4+1\u201d View Model of Software Architecture.\n\u201d IEEE Software 12, \nno. 6 (1995): 42\u201350.\nLaplante, Phillip A. Requirements Engineering for Software and Systems. Boca Raton, FL: Auerbach Publications, \n2009.\nPressman, Roger S. Software Engineering: A Practitioner\u2019s Approach, 7th ed. Chicago: McGraw-Hill, 2010.\nTaylor, Richard N., Nenad Medvidovic, and Eric M. Dashofy. Software Architecture: Foundations, Theory, and \nPractice. Hoboken, NJ: Wiley, 2009.\n", "page": 130, "type": "text", "section": "Page 130"}
{"text": "107\n4\nPatterns and Styles in \nSoftware Architecture\nCHAPTER OBJECTIVES\n\u2022\t Understand the concept of architectural styles and patterns\n\u2022\t Understand the importance and role of architectural patterns in archi-\ntectural designs\n\u2022\t Identify, understand, and apply the major types of architectural patterns\n\u2022\t Understand the quality benefits associated with using different archi-\ntectural patterns\nCONCEPTUAL OVERVIEW\nDuring software architecture, designers spend a great deal of time devising \narchitectural solutions that provide the necessary components and interfaces \nto achieve system requirements. At the architectural level, common pat-\nterns have emerged that describe elements of the system together with their \ninterrelationships and quality characteristics. These patterns allow designers \nto quickly and systematically identify structural characteristics of systems \n(or\u00a0subsystems\u00ad\n) and provide the means for examining interactions and the \nproposed quality of the system. During the past decade, many styles and pat-\nterns for software architecture have been researched and published. Many of \nthese patterns have been identified in pattern catalogue books; some of these \nare common design patterns in enterprise-level systems, while \u00ad\nothers address \nspecific needs such as distributed systems. This chapter explores several \nwell-established architectural patterns and examines the problems they are \ndesigned to address, together with their exhibited quality attributes. Identify\u00ad\ning and designing using architectural patterns can improve the \u00ad\nefficiency of \nthe development process and the quality of the final system.\n", "page": 131, "type": "text", "section": "Page 131"}
{"text": "108\u2002 \u2022\u2002 Software Engineering Design\ufeff\nARCHITECTURAL STYLES AND PATTERNS\nAs seen in Chapter 3, software systems need to be carefully architected and evaluated from \nvarious perspectives to properly address multiple concerns that affect the quality of the \nend product. Modeling systems from each view requires addressing design problems of \ndifferent natures, such as problems that deal with the logical system structure or problems \nthat deal with dynamic, concurrency system issues. In all cases, it is essential to identify \nthe necessary components and interfaces (at the right granularity) and the responsibility \nof each component and to model behavioral interactions among them before moving on to \ndetailed design. Of particular interest is the logical architecture of software systems, since \nit includes system decomposition into logical components that are refined throughout the \ndesign phase and ultimately implemented during construction. From this perspective, it\u00a0is \nimportant to use past experience with logical decompositions together with their inter-\nfaces when designing today\u2019s software systems. To this end, the concepts of \u00ad\narchitectural \nstyles and architectural patterns have emerged as mainstream approach for achieving \n(mostly logical design) reuse at the architectural level. These concepts are fundamental to \nthe efficient creation of software architectures by providing an overall strategy for design-\ning families of software systems. They provide generic, reusable architectural solutions, \ndocumented in a way that can be easily understood and applied to new problems requiring \nsimilar architectural features. Decisions based on architectural styles and patterns benefit \nfrom years of documented experience that highlights the solution approach to given prob-\nlems, the benefits of these approaches, and the consequences of designing the system with \na particular style.\nToday, the terms architectural styles and architectural patterns are used loosely to refer \nto similar concept. The fuzzy line that may exist among them can be a source of confu-\nsion, which shifts the focus away from the true importance and role of both concepts in \ndesigning today\u2019s complex software. Since numerous architectural styles and patterns are \ndocumented today, a brief history of the concepts is required to consolidate the terms and \nprovide a consistent approach for applying them throughout the rest of the chapter.\nHistory of Architectural Styles and Patterns\nIn 1977, Christopher Alexander presented a language intended to help individuals, or \nteams of individuals, design quality structures of different sizes, shapes, and complexities \n(Ishikawa, Silverstein, Jacobson, Fiksdahl-King, and Angel 1977, p. x). This language\u2014born \nout of experience\u2014had at its core entities called patterns. According to Alexander et al.:\nEach pattern describes a problem which occurs over and over again in our environment, and \nthen describes the core of the solution to that problem, in such a way that you can use this \nsolution a million times over, without ever doing it the same way twice.\nAlexander\u2019s work resulted in a catalogue of 253 patterns, each describing in detail the \nessential information required for documenting the patterns. Each pattern\u2019s description \n", "page": 132, "type": "text", "section": "Page 132"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 109\nincluded a picture of the pattern, the context of the pattern, the problem that it attempts \nto solve, evidence for its validity, solution for the problem, and related patterns among \n\u00ad\nothers (Alexander et al. 1977). Together, these patterns formed a language for use dur-\ning the design and construction process. Although Alexander\u2019s work on patterns appears \n\u00ad\nrelevant and appropriate for the software engineering profession, it actually referred to \npatterns found in the design of buildings and towns.\nAlexander\u2019s work significantly impacted the field of software engineering. Even though \nhis patterns dealt with design quality in buildings and towns, it inspired computer scien-\ntists to answer the same types of questions about quality in object-oriented designs. In the \nearly 1990s, the software engineering community began researching and finding recur-\nring high-level problem solutions in terms of specific elements and their relationships; \nthese were originally referred to as architectural styles (Clements, Kazman, and Klein \n2001). Architectural styles provided the means for software architects to reuse architectural \ndesign solutions in different projects. In 1995, Gamma, Helm, Johnson, and Vlissides\u2014bet-\nter known as the Gang of Four (or GoF)\u2014embarked on a similar quest to find and docu-\nment detailed object-oriented solutions successfully applied more than once in different \nsystems. Their influential work focused on a finer-grained set of detailed design patterns \nand resulted in the creation of a catalogue of 23 patterns, commonly known as design pat-\nterns. In 1996, the work of Buschmann, Meunier, Rohnert, Sommerland, and Stal (1996) \nmeshed the work of styles and patterns by providing a set of well-known architectural styles \ndocumented using a pattern-like approach (Clements et al. 2001). In their original work, \nBushman and \u00ad\ncolleagues indicate that patterns and styles are essentially the same thing by \nstating (Buschman et al. 1996, p. 395):\nEvery architectural style can be described as an architectural pattern.\nToday, the terms architectural styles and architectural patterns are used to convey funda-\nmental structural and architectural organization for software systems. Other authors, such \nas Bass, Clements, and Kazman (2003) and Qian, Tao, Xu, and Diaz-Herrera (2009), con-\nsider both concepts to be the same thing. Throughout this chapter (and the rest of the book), \nthe terms architectural patterns and architectural styles are used interchangeably to denote \narchitectural solutions for software systems that occur at the highest level of abstraction in the \ndesign process. The concern of the work presented in this chapter is to understand not how \nto document specific architectural solutions but how and when to apply a particular pattern \nand the quality attributes these patterns provide. Architectural patterns do not describe the \ndetailed design of the system and therefore cannot be directly translated into code. However, \nthey are appropriately used as basis for system decomposition and for analyzing the structure \nof systems in principled manner, which is essential to constructing high-quality systems.\nArchitectural Pattern Classification\nThe choice of applying architectural patterns for designing some architectural element \ndepends on the particular system type, requirements, and desired quality attributes. These \n", "page": 133, "type": "text", "section": "Page 133"}
{"text": "110\u2002 \u2022\u2002 Software Engineering Design\ufeff\ncharacteristics help guide the choice of selecting one particular pattern over another. \nIn\u00a0some cases, several recognized patterns can all meet the identified characteristics of the \nsystem, therefore leaving the design team with the decision of choosing the most appro-\npriate pattern for the design. In other cases, various architectural patterns can be used in \ncombination to collectively provide the appropriate architectural solution that best fits the \nidentified system type, requirements, and quality attributes. Since architectural patterns are \nfound at the highest level of system decomposition, they are too abstract to yield a concrete \nsystem design; therefore, they are not tied to a particular system implementation but can \nbe associated with types (or families) of systems so that their solution can be reused across \nsystems of the same type. For example, a data-centered type of system can employ architec-\ntural patterns that provide the logical design that reflects various components interacting \nwith a main component where data are hosted. The architectural pattern for such a system \nwould include the structural entity that manages the data, components that perform work \non the data, their data-centered interrelationships, and the quality of those components \nfor providing the application-specific structure for the data-centered software system. As \nanother example, consider the design of a distributed software system with components \nthat communicate and collaborate across the network. In such cases, architectural patterns \nthat support these components and their interrelationships in a distributed manner can be \nemployed to define the overall strategy of the distributed systems. A list of common types of \nsystems appropriate for classifying architectural patterns is presented in Table\u00a04.1.\nFor large-scale systems, a single architectural pattern is inadequate for describing all the \ninteractions of the complete system. In these cases, several patterns may be required to aid \nin the composition of architectural designs of the system and subsystems. That is, at the \nhighest level, the logical design of a distributed system can incorporate an architectural \npattern fitting of such system; however, at finer levels of abstraction, the system can include \nin its logical architecture other patterns that address other nondistributed system issues. \nConsider, for example, both distributed and data-centered systems already discussed. The \noverall architectural logical composition may include an architectural pattern that includes \nclient and server components collaborating in distributed fashion. When further refined, \nthe architectural design of the server\u2019s logical composition may employ an architectural \npattern appropriate for data-centered systems, while the design of the client\u2019s architectural \nTABLE\u00a04.1\nType of Software Systems for Classifying Architectural Patterns\nType\nDescription\nData-centered\nSystems that serve as a centralized repository for data, while allowing clients to access and \nperform work on the data\nData flow\nSystems oriented around the transport and transformation of a stream of data\nDistributed\nSystems that primarily involve interaction between several independent processing units \nconnected via a network\nInteractive\nSystems that serve users or user-centric systems\nHierarchical\nSystems where components can be structured as a hierarchy (vertically and horizontally) to \nreflect different levels of abstraction and responsibility\n", "page": 134, "type": "text", "section": "Page 134"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 111\ncomposition may employ an architectural pattern appropriate for data-flow systems. All \nof these issues are architectural, and different design elements addressing these concerns \nthroughout the system are required to form the software architecture. This way, architec-\ntural patterns are combined to describe the complete layout of a system. In the rest of the \nchapter, common architectural patterns for each of these major system types are presented \nand examined. The central features of the pattern and the problems addressed are shown \nalong with a summary of the benefits and limitations of each pattern.\nDATA-CENTERED SYSTEMS\nData-centered systems are systems primarily decomposed around a main central reposi-\ntory of data. Therefore, typical responsibilities found in components of data-centered \nsystem include a centralized data manager and various worker components. The data \nmanager component controls, provides, and manages access to system data, while worker \ncomponents execute operations and perform work based on the data. The communica-\ntion in data-centered systems is characterized by a one-to-one bidirectional communica-\ntion between workers and data manager components. That is, worker components do not \ninteract with each other directly; all communication goes through the data manager. Some \nconsiderations for these systems are data manipulation, communications protocols, trans-\nactions and recovery (also known as roll-back), and security. Examples of data-centered \nsystems include expert systems, which interact with a database management system for \nstoring and retrieving knowledge information. An example of an architectural pattern for \ndata-centered systems includes the blackboard architectural pattern.\nBlackboard Pattern\nThe blackboard architectural pattern decomposes software systems into components that \nwork around a central data component to provide solutions to complex problems. These \ncomponents work independently of each other to provide partial solutions to problems \nusing an opportunistic problem-solving approach. That is, there are no predetermined, \nor\u00a0correct, sequences of operations for reaching the problem\u2019s solution. Each component \nprovides solutions that build upon the problem\u2019s current state, which is defined by the \n\u00ad\ncollective set of solutions provided by the blackboard\u2019s components. The access to the \ncentral data component can be made through direct memory reference, procedure calls, \nor database query (Taylor, Medvidovic, and Dashofy 2009). Other forms of access to the \ndata central store may require complex and distributed remote method invocations, which \nmay prompt designing blackboard systems as part of a broader architectural pattern. \nNevertheless, this data-driven and opportunistic problem-solving approach is typical in \nthe development of expert systems (Buschmann et al. 1996).\nUsing the blackboard architectural pattern, systems can be broken down to include \na common repository where data and solutions to particular problems reside (i.e., the \n", "page": 135, "type": "text", "section": "Page 135"}
{"text": "112\u2002 \u2022\u2002 Software Engineering Design\ufeff\nblackboard), a controller, and various agents that work to refine and further solutions \nto arrive at an acceptable solution. The blackboard architectural pattern resembles the \napproach a group of scientists would employ to solve a complex problem. Consider a group \nof scientists at one location using a blackboard (chalkboard, whiteboard, or electronic \nblackboard) to solve a complex problem. Assume that to manage the problem-solving pro-\ncess among scientists, a mediator controls access to the blackboard. Once the controller \nassigns control to the blackboard, a scientist evaluates the current problem\u2019s state as pre-\nsented in the blackboard and, if possible, advances its solution before releasing control of \nthe blackboard. With new knowledge obtained from the previous solution attempt, control \nis assigned to the next scientist who can further improve the problem\u2019s state. This pro-\ncess continues until no more progress can be made, at which point the blackboard system \nreaches a solution. Similar to this example, the blackboard architectural pattern identifies \nspecialized agents that independently contribute to a problem\u2019s solution. Together, one or \nmore agent components, the controller component, the blackboard component, and their \ninterrelationships form the essence of the blackboard architectural pattern, as presented in \nthe box-and-line diagram in Figure\u00a04.1.\nConsider the application of the blackboard architectural pattern for the design of a \nuniversity software system that manages student registrations. Registrations are man-\naged based on course availability, students\u2019 course history, and students\u2019 work schedule. \nController\nAgent 2\nAgent n\nBox-and-Line Diagram\nUML Component Diagram\n<<component>>\nScheduleManager\n<<component>>\nScheduleBlackboard\n<<component>>\nScheduleHistory\nISchedule\nIStudentHistory\nIWorkSchedule\nISchedule\nISchedule\nISchedule\nICourseO\ufb00erings\n<<component>>\nWorkSchedule\n<<component>>\nCourseO\ufb00erings\nAgent 1\nBlackboard\nFIGURE 4.1\nThe blackboard architectural pattern.\n", "page": 136, "type": "text", "section": "Page 136"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 113\nAcquiring each independent piece of information may require the system to interface with \nother systems with, for example, particular messaging protocols and interfaces. The cur-\nrent state of students\u2019 schedule is managed in a central component, housed with a data-\nbase system containing the schedule details. To update schedules, the student scheduling \nsystem needs to interface with these external systems to retrieve information pertinent to \ncreate an optimized student schedule. In addition, future implementations of the schedul-\ning system may include other information pertinent to the problem; therefore, the logical \narchitecture needs to provide flexibility for incorporating new specialized agents capable \nof \u00ad\nfurther improving the scheduling generation capabilities. Using the blackboard archi-\ntectural \u00ad\npattern, the following components are identified in Table\u00a04.2 and presented in \nFigure\u00a04.1 using the Unified Modeling Language (UML) component diagram.\nThe ScheduleManager corresponds to the controller component of the blackboard \narchitectural pattern seen in the box-and-line diagram of Figure\u00a04.1. The StudentHistory, \nWorkSchedule, and CourseOfferings components correspond to the worker agents pre-\nscribed in the blackboard architectural pattern, which work independently to contribute \nto the problem solution by addressing a particular part of the problem and injecting their \nresults back into the main data repository component. Finally, the ScheduleBlackboard \ncorresponds to the prescribed blackboard component from the blackboard architectural \npattern, which manages and controls access to the current state of students\u2019 schedules.\nAssuming the design configuration presented in Figure\u00a04.1, the solution approach to gen-\nerate a schedule that maximizes both the number of courses taken and work hours (\u00ad\nsubject \nto some constraints) can be devised as follows. First, the ScheduleManager \u00ad\ncomponent \ninitializes all other components, including agents and ScheduleBlackboard components. \nOnce components in the blackboard system are initialized, the StudentHistory component \nis activated to search for a particular student\u2019s course history and retrieves information \nregarding courses left to complete a particular degree, the student\u2019s preference between \nday and night courses, and their preference between face-to-face and online courses. This \ninformation is stored in the ScheduleBlackboard component and is used to generate the first \nversion of the student\u2019s schedule. Next, the ScheduleManager activates the CourseOffering \ncomponent to search for the particular semester\u2019s course offering, including courses offered \nonline, within the university system, from local and remote branch campuses. This may \nrequire the CourseOfferings component to have the capability of interfacing with different \ndistributed information systems. The course offering information is used to modify the \noriginal schedule to include a schedule that reflects the student\u2019s preference fused with the \nTABLE\u00a04.2\nArchitectural Components for Students Scheduling System\nComponent\nDescription\nScheduleManager\nManages access to the ScheduleBlackboard and controls the problem-solving process\nStudentHistory\nKnowledge source for students\u2019 history, including course and other preferences\nWorkSchedule\nKnowledge source for students\u2019 work schedule\nCourseOfferings\nKnowledge source for university\u2019s course offerings\nScheduleBlackboard\nCentral data store where elements of the solution space are stored\n", "page": 137, "type": "text", "section": "Page 137"}
{"text": "114\u2002 \u2022\u2002 Software Engineering Design\ufeff\ncourse offerings. That is, if the student prefers face-to-face night courses, the CourseOffering \ncomponent will combine this information to propose the schedule most appropriate for \nmeeting these preferences. After the CourseOfferings component releases control of the \nScheduleBlackboard component, the ScheduleManager activates the WorkScheduler com-\nponent to determine the student\u2019s federal work-study schedule, which is accessible through \nthe university system. Assuming the student\u2019s work schedule includes alternatives for var-\nious shifts, the WorkScheduler component evaluates the current state of the scheduling \nproblem stored in the ScheduleBlackboard and determines the best shift based on the cur-\nrent schedule. When doing this, the WorkSchedule component may modify the schedule \nby removing classes that conflict with the most desirable and proposed work schedule. \nAfter releasing control of the ScheduleBlackboard, future iterations of the problem-solving \nprocess may include the CourseOffering component filling the gaps in the master schedule \nby selecting different classes that may or may not be of the student\u2019s preference but result in \nthe schedule that maximizes both the number of courses taken and work hours. This pro-\ncess, as presented in Figure\u00a04.2, can be repeated many times until the process is complete \nClient\nScheduleManager\n1 : sch := generateSchedule()\n2 : nextScheduler()\n3 : workOnSchedule()\n6 : <<return>>\n11 <<return>>\n18 <<return>>\n16 : <<return>>\n12 : nextScheduler()\n13 : workOnSchedule()\n7 : nextScheduler()\n17 : sch := getSchedule()\n14 : sch := getSchedule()\n9 : sch := getSchedule()\n15 : setSchedule(sch)\n10 : setSchedule(sch)\n8 : workOnSchedule()\n4 : sch := getSchedule()\n5 : setSchedule(sch)\nStudentHistory\nCourseO\ufb00erings\nWorkSchedule\nScheduleBlackboard\n19 <<return>>\nModify\nSchedule\nFIGURE 4.2\nInteractions among components in the blackboard architectural pattern.\n", "page": 138, "type": "text", "section": "Page 138"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 115\nand the schedule provides the best possible solution. Because the number of agents can \nvary, the solutions provided by blackboard systems are (typically) nondeterministic and \nvary depending on the number of agents and the available information.\nAs seen, each component in the system abstracts the process and capabilities for acquir-\ning information necessary for carrying out work to improve the solution from their \nparticular standpoint. By abstracting each agent\u2019s work, the details employed inside the \ncomponent, such as interprocess communication with external or distributed sources of \ndata, protocols, messaging interfaces, and others, can be separated from the overall sys-\ntem design. Also, as seen, interactions between workers and the blackboard are limited to \nretrieving and injecting new knowledge to the blackboard. This way, changes to one agent \ncomponent do not affect other agents or the blackboard components.\nThe major benefits of using the blackboard architectural pattern include its modifiability, \nreusability, and maintainability. These quality properties come as a result of compartmen-\ntalizing knowledge sources and establishing a standard method for using the blackboard. \nSince each agent needs to know only how to communicate with the blackboard, new agents \ncan be introduced without much effort to improve the system\u2019s capabilities. Also, by com-\npartmentalizing knowledge sources, changes to the system are also compartmentalized; \ntherefore, changes to one agent do not affect other agents in the system. Finally, compart-\nmentalization of agents supports easy reuse in future systems. The list of quality properties \nassociated with the blackboard architectural pattern is presented in Table\u00a04.3.\nAn important element to consider when applying any architectural pattern, including \nthe blackboard, is their deployment aspect. Going back to the example with the scientists, \nit was explicitly stated that they were located in the same room, in front of the blackboard. \nHowever, scientists can be distributed all over the world, collaborating via electronic \n\u00ad\navenues. Similarly, blackboard systems and other systems based on architectural patterns \ndiscussed in this chapter may be distributed through the network, in which case describ-\ning the nature of their connectors becomes important. This would be presented using an \narchitectural design element from a deployment perspective.\nSkill Development 4.1: The Blackboard Architectural Pattern\nConsider the existence of the new HolidaySchedule software component that can \nretrieve information regarding the university system\u2019s holiday schedule. This includes \ninformation regarding operation hours during, for example, holidays and spring break. \nTABLE\u00a04.3\nQuality Properties of the Blackboard Architectural Pattern\nQuality\nDescription\nModifiability\nAgents are compartmentalized and independent from each other; therefore, it is easy to \nadd or remove agents to fit new systems.\nReusability\nSpecialized components can be reused easily in other applications.\nMaintainability\nAllows for separation of concerns and independence of the knowledge-based agents; \ntherefore, maintaining existing components becomes easier.\n", "page": 139, "type": "text", "section": "Page 139"}
{"text": "116\u2002 \u2022\u2002 Software Engineering Design\ufeff\nUsing pencil and paper, redraw Figure\u00a04.1 to include this component. How can such a \ncomponent be used in the student\u2019s schedule blackboard system to further increase the \nnumber of hours worked? Using Figure\u00a04.2 as context, how much effort and how many \narchitectural changes would be required to add this new component to the system? \nDiscuss this problem with a peer.\nDATA FLOW SYSTEMS\nData-flow systems are primarily decomposed around the central theme of transporting \ndata (or data streams) and transforming the data along the way to meet application-specific \nrequirements. Therefore, typical responsibilities found in components of data-flow systems \ninclude worker components\u2014those who perform work on data\u2014and transport compo-\nnents, which transmit data among worker components. The worker components abstract \ndata transformations that need to take place before passing data streams forward in the \nsystem, such as encryption, decryption, compression, decompression, and changing data \nformat form binary to Extensible Markup Language (XML). The transport components \nabstract the management and control of the data transport mechanisms, which could \ninclude interprocess communication, socket-based communication, and serial interfaces. \nTogether, these components combine to form architectural elements of data-flow systems. \nThe data transformation and transport in data-flow systems can entail transporting and \ntransforming data among different components within a single node or between nodes \nin distributed fashion. Data-flow systems provide the means for data transformation to \ntake place in series or in parallel fashion, which helps the system improve performance by \nadding concurrency to the system. Other considerations for these system include modi-\nfiability, security, and reusability of worker components capable of performing complex \noperations. An example of an architectural pattern for data-flow systems is the pipe and \nfilter architectural pattern.\nPipe and Filter Pattern\nThe pipe and filter architectural pattern decomposes software systems into components \nthat carry out two major functions: processing and transforming data and transferring \ndata between components. Components responsible for processing and transforming data \nare referred as filters, while components that transfer data between components are referred \nas pipes. Together, these components are combined in various ways to create families of \nrelated systems that process streams of data (Buschmann et al. 1996). The pipes and filters \narchitectural pattern is commonly seen in data-flow systems, where data inputs need to be \ntransformed into data output through a series of computational or manipulative compo-\nnents (Pressman 2010). The structure of the pipe and filter architectural pattern is often \npresented using a box-and-line diagram, such as the one in Figure\u00a04.3. As seen, systems \n", "page": 140, "type": "text", "section": "Page 140"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 117\nbased on the pipe and filter architectural pattern require a data source, one or more filter \ncomponents, and a data sink, all connected via filters.\nUsing the box-and-line diagram presented in Figure\u00a04.3, the flow of operations of pipe \nand filter systems can be described as follows. Initially, the DataSource component produces \ndata and sends it to the Filter 1 component through a Pipe, denoted by an arrow flowing out \nof the DataSource component and into Filter 1. The Filter 1 component processes the data, \ntransforms it, and outputs the transformed data to three other filters for further processing. \nAt this point, three independent and concurrent data transformations occur and their results \nsent to Filter 5. This process continues until the final formatted output is sent to the DataSink.\nFilter 2\nFilter 3\nFilter 5\nBox-and-Line Diagram\nUML Component Diagram\nUML Deployment Diagram\nISecurityFilter\n<<component>>\nLocalPipe\n<<component>>\nDataSource\n<<TCP/IP>>\n<<component>>\nSecurityFilter\n<<manifests>>\n<<manifests>>\n<<manifests>>\n<<manifests>>\n<<component>>\nDistributedPipe\n<<component>>\nDataSource\n<<component>>\nDataSink\n<<component>>\nDistributedPipe\n<<component>>\nDistributedPipe\n<<artifact>>\ndata_collector.exe\n<<artifact>>\ndata_processor.exe\nNode A\nNode B\n<<component>>\nDataSink\nIDistributedPipe\nIDistributedPipe\nPipes\nData Sink\nFilter 1\nILocalPipe\nData\nSource\nFilter 4\nFIGURE 4.3\nThe pipe and filter architectural pattern.\n", "page": 141, "type": "text", "section": "Page 141"}
{"text": "118\u2002 \u2022\u2002 Software Engineering Design\ufeff\nWhen using the pipe and filter architectural pattern, the software system consumes and \nprocesses input data incrementally, in separate filters, instead of consuming and process-\ning all of its input data at once. This allows the system to become more efficient, mainly \nby achieving low latency, which can be achieved through parallel processing (Buschmann \net\u00a0al. 1996). Also, by segregating the processing components and abstracting the data trans-\nferring process, processing and computations can be performed across process boundaries \nor across node boundaries. In these cases, the pipe and filter architectural pattern can exist \nwithin another architectural pattern for distributed systems. That is, several computers, \nexecuting different processes, can work together to process input data, transform the data, \nand generate the desired output data.\nConsider the design of a signal processing system that operates on real-time video or \naudio streams and is designed to collect data, encrypt it, and forward it for further process-\ning. This process can be repeated for various steps of data processing; however, for simplic-\nity, the number of pipes and filters is limited to present the concept in a concise manner. \nUsing the pipe and filter architectural pattern, the components in Table\u00a04.4 are identified.\nTogether, these components work to collect video and audio data streams, to encrypt \nthem, and to transmit them to a remote location, where data can be further processed and \ndistributed. The pipe and filter logical architecture for the real-time collection system is \npresented using the component notation in Figure\u00a04.3. As seen, the component notation is \nused to model and abstract the major functions identified for the system; however, it may \nstill be difficult to envision the actual system simply by viewing the logical distribution \nof components. Consider the following flow of operations. Once data become available \nat the DataSource component, they are transferred locally to the SecurityFilter compo-\nnent using the LocalPipe component. At the SecurityFilter component, the data stream is \ntransformed using encryption and is transferred to the DataSink component using mecha-\nnisms provided by the DistributedPipe component. In this case, the DistributedPipe com-\nponent abstracts the details of transferring data across the network, since the DataSource \nand DataSink are hosted on different nodes; therefore, a deployment view is necessary to \nproperly characterize the system. As seen in the deployment diagram in Figure\u00a04.3, the \nDataSource and DistributedPipe components are manifested in Node A, while the DataSink \nand (another) DistributedPipe components are manifested in Node B. The manifestation of \nTABLE\u00a04.4\nArchitectural Components for Distributed Signal Processing System\nComponent\nDescription\nData source\nProduces real-time video or audio streams\nLocal pipe\nMechanism for transferring video or audio data streams locally from data source to \nsecurity filter\nSecurity filter\nTransforms data streams by encrypting flow of data\nDistributed pipe\nMechanism for transferring encrypted data streams wirelessly (e.g., Satellite \nCommunications [SATCOM]) from local site to remote site; provides the logical \nconnection between data source and data sink\nData sink\nDestination component where data streams are stored for later review\n", "page": 142, "type": "text", "section": "Page 142"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 119\nthe LocalPipe and SecurityFilter components is omitted for simplicity; however, they would \nbe presented in Node A. This example shows how using different architectural views can \nenhance the understanding of the true architecture of a system.\nThe presentation of the pipe and filter system using component diagrams is appropriate \nsince the piping mechanisms entail more advanced mechanisms than a simple method \ncall to another component. However, the same knowledge can be conveyed using a \nbox-and-line diagram or other non-UML diagram approach. The problem with using a \nsimple box-and-line diagram is that it becomes difficult to capture or abstract the work \nrequired to realize the work required by the pipe (or connector). When components are \nidentified during the software architecture activity, they are slated for refinement during \ndetailed design work, therefore providing an explicit and manageable unit of design work. \nBy modeling complex pipes as components, the details of their work are abstracted, and \nfuture planned work for providing the details of such abstraction can be integrated into the \ndesigns and construction schedule, similar to any other component in the system.\nThe pipe and filter architectural pattern can be applied to a problem of smaller scope \nwhere both pipe and filter components reside within a single node and communicate using \nsimple method calls or using simple mechanisms provided by the operating systems, such \nas \u00ad\nmessage queues. In other cases, creating a customized pipe, such as the DistributedPipe \npresented earlier, may require additional work. Filters can be designed as multiple com-\nponents manifested by as single process or by multiple independent processes executing \nwithin a node and communicating through common inter-process pipe mechanisms. \nTypically, once the pipe and filter framework is in place, numerous filters can be added \n(serially or in parallel) to provide additional capabilities. The major quality properties \nassociated with pipes and filter systems are presented in Table\u00a04.5.\nSkill Development 4.2: Designing with the Pipes and Filter Architectural Pattern\nUsing pencil and paper, complete the design for Node B required to distribute the \naudio and video feed. Once the data reach the data sink, all data need to be decrypted, \nTABLE\u00a04.5\nQualities of the Pipes and Filter Architectural Pattern\nQuality\nDescription\nExtensibility\nProcessing filters can be added easily for more capabilities.\nEfficiency\nBy connecting filters in parallel, concurrency can be achieved to reduce latency in the \nsystem.\nReusability\nBy compartmentalizing pipes and filters, they can both be reused as is in other systems.\nModifiability\nFilters are compartmentalized and independent from each other; therefore, it is easy to add \nor remove filters to enhance the system\nSecurity\nAt any point during data flow, security components can be injected to the work flow to \nprovide different types of security mechanisms to the data.\nMaintainability\nAllows for separation of concerns and independence of the filters and pipes; therefore, \nmaintaining existing components becomes easier.\n", "page": 143, "type": "text", "section": "Page 143"}
{"text": "120\u2002 \u2022\u2002 Software Engineering Design\ufeff\ncompressed, and stored in the file system\u2014operations that can take a long time due to \nthe expected massive amounts of data. In addition, data need to be prepared for view-\ning in real-time using a web server and client PCs and provided to a client (non-web \npage) application hosted on a mobile phone. In all of these, efficiency is the most impor-\ntant characteristic of the system so that the quality of audio and video is appropriate. \nAssuming that there are no resource constraints, also draw a deployment diagram to \nhelps support the required efficiency of the system. How does the pipe and filter pattern \nhelp in meeting efficiency expectations?\nDISTRIBUTED SYSTEMS\nDistributed systems are commonly known as systems decomposed into multiple processes \nthat collaborate through the network. These systems are ubiquitous in today\u2019s modern \n\u00ad\nsystems thanks to wireless, mobile, and Internet technology. In some distributed systems, \none or more distributed processes perform work on behalf of client users and provide a \nbridge to some server computer, typically located remotely and performing work delegated \nto it by the client part of the system. Once complete, results are typically returned back to \nclients for viewing and further processing. Other distributed systems may be composed of \npeer nodes, each with similar capabilities and collaborating together to provide enhanced \n\u00ad\nservices, such as music-sharing distributed applications. These forms of distributed systems \nare well-known in the sense that their deployment architecture typically entails multiple \nnodes. However, with the advent of multiple CPU architectures, distributed architectures \nare also relevant to software that executes on a single node with multiprocessor capability. \nThe main concerns for distributed systems may include performance, reliability\u00ad\n, availability\u00ad\n, \nsecurity, and interoperability. Some examples are Internet systems with web services and \nhigh-performance scientific computing projects such as the Search for Extraterrestrial \nIntelligence (SETI) program or the Large Hadron Collider (LHC) at CERN. In such \u00ad\nsystems, \nmultiple processors that may reside on different physical machines or in different concurrent \nprocesses on a single machine cooperate to solve the tasks required of the system. Common \narchitectural patterns for these systems include\n\u2022\t Client\u2013server\n\u2022\t Broker\nClient\u2013Server Pattern\nThe client\u2013server architecture is a popular architectural pattern present in today\u2019s modern \nsystems. It decomposes software systems into two main components: the client and the \nserver. These components are manifested as individual processes that can be distributed \nover the network or within a single node. Client\u2013server systems are not determined merely \nby separating processes or by distributing processes across the network but by having one \n", "page": 144, "type": "text", "section": "Page 144"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 121\nprocess, the client, depend on the services provided by another process, the server. The \nmost pervasive example of a client\u2013server system today includes the web browser client \nand the web server. When searching for a particular site using the web browser client, \na\u00a0connection is made to the server, a request is sent and received by the server, and the \nserver processes the requests and sends a response back to the client. Note that this is also \ntrue regardless of the location\u2014which can be on the same node as the server\u2014 of the web \nclient, as long as it can connect to the server. In addition, web browser clients are not very \nuseful without the services provided by the server; therefore, they are dependent on the \nserver. Figure\u00a04.4 presents the client\u2013server architectural pattern.\nClient\u2013server systems are particularly useful for distributed systems with a large \u00ad\nclient \nbase, since they provide localization of data in one central place. Therefore, making updates \nor adding new information in once central place is all that it is needed for a multitude \nof clients to receive this information. The quality attributes associated with client\u2013server \n\u00ad\nsystems are identified in Table\u00a04.6.\nTABLE\u00a04.6\nQualities of the Client\u2013Server Architectural Pattern\nQuality\nDescription\nInteroperability\nAllows clients on different platforms to interoperate with servers of different platforms\nModifiability\nAllows for centralized changes in the server and quick distribution among many clients\nAvailability\nBy separating server data, multiple server nodes can be connected as backup to increase \nthe server data or services\u2019 availability\nReusability\nBy separating server from clients, services or data provided by the server can be reused in \ndifferent applications\nClient\n<<artifact>>\npc_browser.exe\n<<Request>>\n<<Response>>\n<<HTTP>>\n<<HTTP>>\nBox-and-LineDiagram\nUML Deployment Diagram\nPC Node\nServer Node\nServer\n<<artifact>>\nmp_browser.exe\nMobile Phone Node\n<<artifact>>\npc_browser.exe\n<<artifact>>\nweb_server.exe\nFIGURE 4.4\nThe client\u2013server architectural pattern.\n", "page": 145, "type": "text", "section": "Page 145"}
{"text": "122\u2002 \u2022\u2002 Software Engineering Design\ufeff\nServers can abstract the services\u2014and the details of providing those services\u2014provided \nby the host platform, therefore creating a window for clients to interoperate with the host \nplatform. When done properly, this allows interoperation between systems of different \nplatforms. Client\u2013server systems can also lead to highly modifiable systems. Consider a \ncorporate web-based intranet system, where modifying or adding completely new system \ncapabilities may require creating the necessary server code, including a new hyperlink to \nthe existing corporate portal, and deploying the modified code to the production server. \nOnce deployed, everyone in the corporate network would have instant access to the modi-\nfied system. Also, by separating the client application from the server data, client\u2013server \nsystems allow designers to render multiple views of the same data; clients can be improved \nor replaced independently of the resources needed to perform computations on the data; \nmultiple clients can share the resources of a server allowing for increased efficiency; or \nthe user interface can be replaced completely, allowing specialized clients to consume and \nperform additional processing on the data for further processing.\nBroker Pattern\nThe broker architectural pattern provides mechanisms for achieving better flexibil-\nity between clients and servers in a distributed environment. Consider the client\u2013server \nexample presented in Figure\u00a04.4. In the typical client\u2013server architectural pattern, clients \ndirectly access services of servers, which may require them to establish direct connection \n(e.g.,\u00a0Transmission Control Protocol/Internet Protocol [TCP/IP]) or employ other inter-\nprocess communication mechanisms for communicating with the server. This result in a \nhigher degree of coupling between clients and servers, which leads to complexity for \u00ad\nsystems \nexpected to evolve by providing services from different servers hosted at different locations. \nIn some cases, client terminals need to be able to access services from multiple servers with-\nout knowing their actual locations or particular details of communication for accessing \nthose services. This leads to systems with increased interoperability and flexibility.\nThe broker architectural pattern decreases coupling between clients and servers by \nmediating between them so that one client can transparently access the services of multiple \nservers. Instead of accessing servers directly, clients access their functionality via a bro-\nker component, which locates appropriate servers, forwards requests, and relays responses \n(including exceptions) back to clients (Buschmann et al. 1996). With this mechanism in \nplace, clients can request services as if they were provided locally on the same node as the \nserver, when they are in fact being provided in distributed fashion over the network by \ndifferent nodes. The main participants in the broker architectural pattern are presented \nin Table\u00a04.7, and examples of modeling broker systems are presented in Figure\u00a04.5 using \nbox-and-line, UML components, and UML deployment diagrams.\nIn the box-and-line diagram presented in Figure\u00a04.5, it can be seen that broker compo-\nnents can interoperate with other brokers, so that if a service requested by a client is acces-\nsible through a separate broker this communication can be established to provide clients \nadditional services. For example, Client 1 may forward a request to Broker 1 for a particular \nservice. Broker 1, after determining that Server 2 provides the service requested, forwards \n", "page": 146, "type": "text", "section": "Page 146"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 123\nTABLE\u00a04.7\nComponents of the Broker Architectural Pattern\nComponent\nDescription\nClient\nApplications that use the services provided by one or more servers\nClientProxy\nComponent that provides transparency (at client) between remote and local components so \nthat remote components appear as local ones\nBroker\nComponent that mediates between client and server components\nServerProxy\nComponent that provides transparency (at server) between remote and local components so \nthat remote components appear as local ones\nServer\nProvide services to clients; may also act as client to the broker\nBridge\nOptional component for encapsulating interoperation among brokers\nBroker 1\nClient\nBroker 2\nServer 1\nBox-and-Line Diagram\nUML Component Diagram\nServer 2\n<<component>>\nUserInterface\n<<component>>\nDvrClient\nIDvrStatus\nIDvrRemoteControl\nIBroker\nIDvrControl\n<<component>>\nDvrClientProxy\n<<delegate>>\n<<artifact>>\niexplore.exe\nO\ufb03cePC\n<<delegate>>\n<<component>>\nDvrBroker\n<<component>>\nDvrClient\n<<manifests>>\n<<HTTP>>\n<<HTTP>>\n<<component>>\nUserInterface\n<<component>>\nDvrServer\nIDvrStatus\nIDvrStatus\nIDvrRemoteControl\nIDvrRemoteControl\nIDvrControl\nIDvrControl\nUML Deployment Diagram\n<<component>>\nDvrSystem\n<<component>>\nDvrServerProxy\n<<artifact>>\ndvr_server.exe\nFamilyRoomDvr\n<<component>>\nDvrServer\n<<manifests>>\n<<artifact>>\ndvr_server.exe\nBedroomDvr\n<<component>>\nDvrServer\n<<manifests>>\nFIGURE 4.5\nThe broker architectural pattern.\n", "page": 147, "type": "text", "section": "Page 147"}
{"text": "124\u2002 \u2022\u2002 Software Engineering Design\ufeff\nthe requests to Broker 2, which in turn forwards the requests to Server 2. Once the opera-\ntions required for the particular service are executed, Server 2 establishes a connection \nwith Broker 2 and supplies it with a response, which is forwarded to Broker 1 and subse-\nquently to the Client. This sequence highlights a major difference between client\u2013server \nand broker architectural patterns: in the broker architectural pattern servers may also act \nas clients to the broker, whereas in client\u2013server architectures roles are exclusive so that \nservers are never clients (Buschmann et al. 1996).\nConsider the architectural design of the distributed digital video recording (DVR) sys-\ntem presented in the UML component diagram in Figure\u00a04.5. In this example, two proxies \nare created to provide transparency at both client and server side. The DvrClientProxy \ncomponent realizes the IDvrStatus and IDvrControl in a remote environment, while the \nDvrServerProxy realizes these interfaces in a local environment providing direct connec-\ntion to the DVR computer. Therefore, both user interfaces at the client and server locations \ncan be interchangeable, since they both interface with the DvrSystem component through \nwell-defined methods provided by these interfaces. With these mechanisms in place, the \nbroker system begins by initializing the DVR system to find appropriate servers and iden-\ntify their provided services, as seen in Figure\u00a04.6. Notice that in this example the optional \nbridge component identified in Table\u00a04.7 is not used.\nUserInterface\nDvrClientProxy\nDvrServerProxy\nDvrBroker\n2 : aMsg := intBrokerMsg()\n1 : int()\n4 : \ufb01ndServer()\n5 : callService(aMsg)\n6 : recv()\n3 : forwardRequest(aMg)\naResponse contains a\nlist of services supported\nby the server.\nAt this point, the\nborker has knowledge\nof all services\nsupported by the\nserver.\n7 : callService(aResponse)\n8 : registerServices(aResponse)\nFIGURE 4.6\nThe broker architectural pattern\u2014initialization.\n", "page": 148, "type": "text", "section": "Page 148"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 125\nAs seen, once the system begins initialization an initialization message containing a \nrequest for services and client information is created and forwarded to the DvrBroker \ncomponent, which finds appropriate servers and transmits the message for processing. \nAt\u00a0this point, the DvrBroker waits for a response, which contains the services provided \nby the particular server; these services are registered and become available to the client \nduring\u00ad\n system operation. Once the system is initialized, services from remote severs can \nbe accessed through the broker, as seen in Figure\u00a04.7. In this example, the client requests \ninformation about the DVR\u2019s available disk space. Notice that the client\u2019s UserInterface \ncomponent, the getDiskSpace() interface method, can be called as if the DVR system were \nlocal to the client.\nAn important architectural design element for this system involves the deployment \naspect of the DVR system. The logical view for architectural design does not convey enough \ninformation to fully provide the context for the operations that take place in the DVR \nsystem\u00ad\n. Figure\u00a04.5 provides a UML deployment diagram to add this context to the archi-\ntectural effort. As seen, the system employs two DVR nodes, which manifest the DvrServer \ncomponent identified in the UML component diagram. This means that the \u00ad\ngetDiskSpace() \noperation can be mapped to either FamilyroomDvr or BedroomDvr systems, all performed \ntransparently from clients. That is, the call made to the DvrServerProxy to get service \n(i.e.,\u00a0callService(aMsg)) can be made to either node (i.e., FamilyroomDvr or BedroomDvr) \nUserInterface\nDvrClientProxy\nDvrServerProxy\nDvrBroker\n2 : aMsg := pack()\n1 : getDiskSpace()\n4 : \ufb01ndServer()\n5 : callService(aMsg)\n6 : recv()\n3 : forwardRequest(aMsg)\n8 <<return>>\n10 <<return>>\n7 : callService(aResponse)\n9 : unpack(aResponse)\naMsg contains information\nabout the server\u2019s s\ndestination (e.g., IP address)\nand service requested.\nAt this point, the\nBroker waits for a response.\nOnce received, aResponse\nwill contain the information\nrequested. In this case,\nthe amount of disk\nspace available.\nFIGURE 4.7\nThe broker architectural pattern\u2014client operation.\n", "page": 149, "type": "text", "section": "Page 149"}
{"text": "126\u2002 \u2022\u2002 Software Engineering Design\ufeff\ntransparently from clients, and the response is processed identically by the client. In similar\u00ad\n \nfashion, many other nodes can be added to the system without affecting the client applica-\ntion. This provides additional flexibility when modifying the system to add more nodes. \nOn the server side, messages received are processed as presented in Figure\u00a04.8.\nAs seen, the DvrServerProxy interfaces directly with the DvrSystem to relay requests from \nclients and prepare responses for transmission back to one or more clients. In this case, \nonce the DvrServerProxy receives a message, interprets it, and makes the getDiskSpace() \noperation call to the DvrSystem component, the getDiskSpace() operation encapsulates the \ndetails of the protocols required for the direct communication between the server compo-\nnent and the actual DVR computer. Once a response is received from the DVR computer, \nthe getDiskSpace() returns with results from the disk space availability; these are packaged \ninto a message and sent back to the broker as response for the client\u2019s requests. This process \nis repeated for all other services requested by clients.\nIn practice, there are numerous variations of architectural designs based on the broker \narchitectural pattern. Some broker systems may have the broker component deployed \non separate nodes from the client; others allow clients to communicate directly with \n\u00ad\nservers in special cases; some rely on remote procedure calls (vs. the messaging approach \npresented here); and others rely on reactive models, where callback methods from reg-\nistered components are invoked by the broker whenever an event is triggered. However, \nall broker systems typically benefit mainly from the flexibility provided by decoupling \nclients and servers. The quality attributes associated with broker systems are identified \nin Table\u00a04.8.\nDvrSystem\nDvrServerProxy\nDvrBroker\n1 : waitForRequests()\n3 : unpack(aMsg)\n4 : getDiskSpace()\n2 : callService(aMsg)\n7 : callService(aResponse)\n6 : aResponse := pack()\n5 <<return>>\nAt this point, a Broker has\nbeen intialized on the client\nside and a request to retrieve\nthe available disk space has\nbeen sent.\nFIGURE 4.8\nThe broker architectural pattern\u2014server operation.\n", "page": 150, "type": "text", "section": "Page 150"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 127\nINTERACTIVE SYSTEMS\nInteractive systems are systems that support user interactions, typically through user \ninterfaces. When designing interactive systems, design alternatives concentrate on two \nmain quality attributes: usability and modifiability. As stated before, usability refers to \nthe quality goal that seeks to minimize the degree of complexity involved when learning \nor using the system. Usable systems are designed in such way that operators can quickly \nbecome proficient with the system; they also respond to user requests rapidly to support \nhigh interactivity\u00ad\n requirements. A large portion of usability design takes place during the \nuser interface design activity. Whereas usability is achieved mostly through user interface \ndesign, modifiability and interactive performance are mainly functions of the architec-\ntural logical design. To maximize modifiability and performance in interactive systems, \nthe graphic user interface that represents the system data needs to be efficiently decoupled \nfrom the functional system core. By doing this, the functional core\u2014which is typically \nstable since it is largely based on functional requirements\u2014is separated from user displays, \nwhich are largely based on quality requirements. Since user interfaces are more likely to \nchange and adapted to future versions of software systems, segregating them from the sys-\ntem core increases the modifiability of interactive systems. Examples of interactive systems \ninclude gaming \u00ad\nsystems, simulations, and Internet applications, where such systems need \nto respond to user requests rapidly and update the display so the user can interact appro-\npriately. The mainstream architectural pattern employed in most interactive systems is the \nmodel\u2013view\u2013controller (MVC).\nModel\u2013View\u2013Controller Pattern\nThe MVC architectural pattern is used in interactive applications that require flexible \nincorporation of human\u2013computer interfaces. With the MVC, systems are decomposed \ninto three main components that handle independently the system\u2019s input, processing, and \noutput. By separating the system\u2019s output from its core processing functions, different rep-\nresentations of the system core can be easily supported. The main components present in \nthe MVC architectural pattern are presented in Table\u00a04.9.\nTABLE\u00a04.8\nQualities of the Broker Architectural Pattern\nQuality\nDescription\nInteroperability\nAllows clients on different platforms to interoperate with servers of different platforms; \nalso allows clients to interoperate (transparently) with multiple servers\nModifiability\nAllows for centralized changes in the server and quick distribution among many clients\nPortability\nBy porting the broker to different platforms, services provided by the system can be easily \nacquired by new clients in different platforms\nReusability\nBrokers abstract many system calls required for providing communication between nodes; \nwhen using brokers, many complex services can be reused in other applications that \nrequire similar distributed operations\n", "page": 151, "type": "text", "section": "Page 151"}
{"text": "128\u2002 \u2022\u2002 Software Engineering Design\ufeff\nView and controller components work together as part of the user interface to accept \nuser input and transform this input into format compatible with the model component. \nIn some variants of the MVC, the responsibility of controllers and views are fused into \none component. The relationship among the model, view, and controller components can \nvary depending on the application; however, at minimum, MVC designs provide relation-\nships that allow changes in the model to be propagated to its view and, when necessary, to \ncontrollers. This way, MVC systems provide a systematic, flexible, and controlled approach \nfor accepting system inputs and providing system outputs.\nAs an architectural pattern, MVC defines the interfaces required for the change propa-\ngation mechanisms among the model, view, and controller components. However, it does \nnot (and should not) specify the details of how the change propagation mechanism is actu-\nally implemented. Details of such mechanisms are left to the detailed design activity, which \ncan provide design patterns, such as the observer, to realize the intent of the MCV. As an \narchitectural pattern, MVC designs should specify the components, their interfaces, and \nthe nature of those interfaces to support system development. This fundamental difference \nprovides a clear delineation between MVC and other detailed design patterns. Figure\u00a04.9 \npresents a generic box-and-line design of the MVC architectural pattern. This diagram \npresents\u00ad\n the MVC in its most connected form, in which bidirectional relationships exist \namong all components. However, many variants exist that customize relationships among \ncomponents depending on the application.\nFigure\u00a04.9 also presents a UML component diagram for a hypothetical real estate hous-\ning market system\u00ad\n that allows users to find properties for sale. The real estate system is \nbased on the MVC architectural pattern and is composed of two views, each with their \nown controller and a model that contains all real estate information. The two views are \ndesigned uniquely for usability on a standard PC and large SMART board environment. \nSince the form factor\u00ad\n of PC monitors and SMART Boards differ significantly, two differ-\nent views are created for the system. Since the PC monitor is significantly smaller than the \nSMART board, the user interface created by the PCView component will cover the whole \nmonitor screen and rely on speech recognition technology for its input mechanism. Since \nthe SMART board provides larger space for viewing the software, the SmartboardView \ncomponent provides more informative buttons and menu options to use the software. The \nSMART board \u00ad\nversion of the software relies on direct human touch interface or hand ges-\nture recognition. For this reason, two different controller components\u2014one that performs \nspeech processing and the other for hand touch or hand gesture recognition\u2014are designed. \nTABLE\u00a04.9\nComponents of the MVC Architectural Pattern\nComponent\nDescription\nModel\nComponent that represents the system\u2019s core, including its major processing capabilities \nand\u00a0data\nView\nComponent that represents the output representation of the system (e.g., graphical output or \nconsole based)\nController\nComponent (associated with a view) that handles user inputs\n", "page": 152, "type": "text", "section": "Page 152"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 129\nWhen using the system on a PC, users can command the system using speech, such as \n\u201cFind single family homes in Lakeland, Florida.\u201d Once this input is received through the \nPC\u2019s microphone, the speech controller transforms it into a command that is passed on \nthe model using the provided IModel interface. Once the request is processed by the model \ncomponent, it uses the IObserver interface to employ the change propagation mechanisms \nto let the PCView \u00ad\ncomponent\u2014or any other view associated with the model\u2014know that \nthe request has been processed. At this point, the PCView component retrieves the data \nusing the model\u2019s IModel interface and displays them to users. A\u00a0similar approach is con-\nducted in the SMART board version of the system. These sequences of operations for the \nMVC system are presented in Figure\u00a04.10.\nFrom this trivial example, the major advantage in the flexibility that MVC systems \nprovide can be clearly examined. For example, consider the case where a more advanced \nspeech processor is created. In this case, neither view nor model components need to \nbe modified for this addition. This means that support for enhanced speech processing \nor new languages can be added to the real estate system without much effort. Similarly, \nother views for the same data can be incorporated easily to the system, for example, a view \nproviding graphical descriptive or inferential statistics for housing markets based on the \nmodel\u2019s data. Finally, advanced computational features can be added to the real estate sys-\ntems by adding faster search algorithms to the model component independently from both \nview and controller. This flexibility can be extended to distributed environments, such as \nView 1\nView 2\nView n\nBox-and-Line Diagram\nUML Component Diagram\nController 1\nController 2\nModel\nController n\n<<component>>\nSmartBoardView\n<<component>>\nRealEstateModel\nIModel\nIObserver\nIObserver\nIPenController\n<<component>>\nPCView\n<<component>>\nSbController\nIModel\nIObserver\nIObservable\nIObserver\nISpeechController\n<<component>>\nSpeechController\nFIGURE 4.9\nThe model\u2013view\u2013controller architectural pattern.\n", "page": 153, "type": "text", "section": "Page 153"}
{"text": "130\u2002 \u2022\u2002 Software Engineering Design\ufeff\nInternet systems, where MVC architectures are very popular. Systems based on the MVC \nbenefit from flexibility that allows them to evolve gracefully over time. The main quality \nattributes associated with MVC systems are presented in Table\u00a04.10.\nThere are some variations of the MVC architectural pattern. One popular variation of \ndesigning MVC systems includes the fusion of views and controller components into one \ncomponent. This variant was very popular in the 1990s as part of Microsoft\u2019s Document-\nView architecture integrated in the Microsoft Foundation Classes (MFC) Visual C++ envi-\nronment. The Document-View architecture sacrificed exchangeability of the controller for \nsimplicity. Other, more extensive variations include the process\u2013abstraction\u2013controller \n(PAC) architectural pattern (Qian et al. 2009). The PAC is an extension of the MVC, where \nsystems are decomposed into agents, each containing a process, abstraction, and controller \ncomponents arranged in hierarchical fashion.\nTABLE\u00a04.10\nQualities of the MVC Architectural Pattern\nQuality\nDescription\nModifiability\nEasy to exchange, enhance, or add additional user interfaces\nUsability\nBy allowing easy exchangeability of user interfaces, systems can be configured with different \nuser interfaces to meet different usability needs of particular groups of customers\nReusability\nBy separating the concerns of the model, view, and controller components, they can all be \nreused in other systems\nPCView\nApplication\nRealEstateModel\nSpeechController\n5 : show()\n6 : show()\n9 : sendCommand(FIND_CMD,SFH,33803)\n10 : processCommand()\n12 : getResults()\n11 : update()\n4 : attach(aView)\n2 : aView := new SpeechCustomizedView()\n3 : aController := new VoiceController()\n7 : onVoiceInput(\u201c\ufb01nd single family homes in Lakeland, FL\u201d)\n8 : processSpeech()\n1 : aModel := new Model()\nOnce the view is\ndisplayed, it enables\nthe voice input mode\nto receive voice input.\n: User\nFIGURE 4.10\nThe sequence for searching for single-family homes in Lakeland, Florida.\n", "page": 154, "type": "text", "section": "Page 154"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 131\nSkill Development 4.3: Distributed MVC Real Estate System\nConsider a distributed, Internet version of the MVC real estate system. Using pencil \nand paper, use UML ports and delegate relationships to modify the component dia-\ngram of Figure\u00a04.9 to support the development of this system under the new environ-\nment constraints. Draw also a deployment diagram that shows how the system can be \ndeployed on tablets and mobile phones. Feel free to modify the original MVC relation-\nships and diagram to account for this new problem.\nHIERARCHICAL SYSTEMS\nHierarchical systems are systems in which components can be structured in hierarchical \nfashion so that components exist at different levels of abstraction and each level addresses \na particular concern of the software system. For each level identified in the hierarchical \nsystem, one or more components can be identified, each possibly branching downward \nto other components necessary to carry out a particular operation. Conceptually, compo-\nnents residing at higher levels of the hierarchy structure dispatch requests and rely on the \nservices of those in lower levels of the hierarchy. In some cases, access to the services pro-\nvided at the different levels can be unified and strictly controlled, therefore compartmen-\ntalizing them and increasing the reusability of their services. In other cases, the hierarchy \nstructure is mapped conceptually to the processing of data, resulting in a set of functional \ncohesive components at appropriate levels of abstraction for creating modular systems. \nIn\u00a0any case, designing systems in hierarchical fashion typically leads to well-structured \nand modular systems. Two common architectural patterns for hierarchical systems are\n\u2022\t Main program and subroutine\n\u2022\t Layered\nMain Program and Subroutine\nThe main program and subroutine architectural pattern is popular in systems that are \ndesigned using the structured (or functional) design strategy. In these systems, a main \ncomponent (or\u00a0program\u00ad\n) \u00ad\ncontains the main data for the program, which is shared among \ncomponents residing\u00ad\n at lower levels of the hierarchy. Each level of the hierarchy represents \nrefinements of the system, so that level n provides the main level; level n + 1 provides further \nrefinements of services; n + 2 provides even further refinements, and so on. This process \ncontinues until the system is decomposed into an appropriate set of finer-grained compo-\nnents (or \u00ad\nsubroutines). To illustrate this concept, consider creating the logical architecture \nfor a printer system, based on its data-flow diagram (DFD). When using a DFD, inputs and \noutputs are represented by boxes, data flowing through systems are represented by arrows, \nand data transformations are represented by circles, as presented in Figure\u00a04.11. As seen, a \n", "page": 155, "type": "text", "section": "Page 155"}
{"text": "132\u2002 \u2022\u2002 Software Engineering Design\ufeff\nLevel 0 DFD represents the initial context of the system. The input source 1 (IS1) represents a \nkeypad for configuration of the printer, and the input source 2 (IS2) represents input from the \ncomputer that sends jobs to the printer. Two system outputs are presented: one to the printer\u2019s \nonboard display (OD1); and another for the paper printout (OD2). The initial context of the \nsystem (i.e., Level 0) design indicates that the system transforms two inputs to generate two \ndifferent outputs. As the DFD is refined, a Level 1 DFD is produced to indicate that two \nKeypad Input\nComputer Input\nKeypad Display\nLevel 0 DFD\nSystem\nTray Output\nKeypad Input\nComputer Input\nKeypad Display\nLevel 1 DFD\nDT1\nDT2\nTray Output\nKeypad Input\nComputer Input\nStructure Chart - Logical Architecture\nKeypad Display\nLevel 2 DFD\nTray Output\n<<component>>\nPrinter\nIComputer\nITray\nIKeypad\n<<component>>\nTray Output\n<<component>>\nComputer IF\n<<component>>\nKeypad IO\nFIGURE 4.11\nThe main program and subroutine architectural pattern.\n", "page": 156, "type": "text", "section": "Page 156"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 133\ndistinct transformations are required: one for transforming data from the keypad input to \nthe keypad display; and the other for transforming computer input into a printout. In the \nLevel 2 DFD, two distinct flows of data are identified: one to generate printouts in black and \nwhite; and the other to generate printouts in color. In each flow, different transformations \nare required. This refinement is iteratively done, and once all transformations are identified \nthey can be grouped into components to form the logical architecture of the system. In this \nexample, the print manager (PM), which is the main program, consists of three independent \ncomponents, which provide the subroutines identified based on the data transformations. \nA\u00a0more detailed coverage of this approach is represented by Pressman (2010, p. 265).\nThe main components identified for the main program and subroutine architectural \n\u00ad\npattern include one main component, which stores all the data, and various, finer-grained, \nsubcomponents that carry out detailed system operations. Systems based on this archi-\ntectural pattern benefit mainly from its structured decomposing, such that independent, \nsingle-purpose components become easier to understand, manage, code, debug, and reuse. \nThe main quality properties associated with the main program and subroutine architec-\ntural pattern are presented in Table\u00a04.11.\nLayered Pattern\nThe main program and subroutine architectural pattern leads to hierarchical structures that \nexpand vertically and horizontally, with each level of the hierarchy containing one or more \ncomponents that can interact with one or more components at lower-levels of the hierarchy. \nA more constrained form of hierarchical structure involves each layer having one main \ncomponent\u2014which can be composed internally of multiple components\u2014that provides a \nunified interface for communicating with components residing immediately below in the \nhierarchy structure. This form of constrained collaboration of hierarchical architectures \nis captured with the layered architectural pattern. With the layered architectural pattern, \nthe work performed to accomplish a system function is somewhat independent and more \ncompartmentalized than in the main program and subroutine. It is used when systems can \nbe decomposed into cohesive layers with a structured way of interfacing between layers. \nThe layered architecture is widely used in systems software, such as an operating system\u2019s \ncommunication stack, where each layer is an abstraction of a major function of communi-\ncation systems. Each layer also relies on services from other layers directly below to create \ncommunication packets and to provide quality of service, routing services, node-to-node \ncommunication, and transmission using varied physical layers. This way, rules can be \nTABLE\u00a04.11\nQuality Properties of the Main Program and Subroutine Pattern\nQuality\nDescription\nModifiability\nBy decomposing the system into independent, single-purpose components, each component \nbecomes easier to understand and manage.\nReusability\nIndependent, finer-grained components can be reused in other systems.\n", "page": 157, "type": "text", "section": "Page 157"}
{"text": "134\u2002 \u2022\u2002 Software Engineering Design\ufeff\nimposed on the system\u2019s logical architecture to restrict access among components, therefore \ndecreasing the system\u2019s coupling and increasing its modifiability and portability. That is, by \ncompartmentalizing major system functions and controlling access to their services (via \nwell-defined and stable interfaces), system modifiability and portability can be increased.\nConsider the logical architecture of an environmental embedded monitor and control \nsystem capable of being remotely deployed to monitor and control other nodes in a sys-\ntem that provides environmental information. The system works by receiving a collection \nschedule that is used to activate and deactivate other nodes in the system, to control their \noperations, and to retrieve their collected data. Since the system is deployed in environmen-\ntal areas where communication infrastructure may not be present, it uses satellite commu-\nnications to receive collection schedules and to provide environmental information back \nto a central station, where it can be safely analyzed. Collection schedules are encrypted to \nprovide additional level of security, which means that upon receipt the remotely deployed \nsystem needs to decrypt the messages and perform application-dependent logic to inter-\npret and execute them. Once a collection schedule for a particular node in the system is \nexecuted, the system interfaces with the hardware to send appropriate commands to other \ncollection nodes. The logical architecture for this system is designed using the layered \narchitectural pattern, as seen in Figure\u00a04.12.\nThe box-and-line design of Figure\u00a0 4.12 presents a generic approach to designing \n\u00ad\nlayered software. It shows each independent layer collaborating only with the services \nof the \u00ad\nlayers immediately below. This way, replacing services at one layer does not affect \nthe whole system. When applied to the environmental monitor and control system, \nthe UML component diagram results in the one presented in Figure\u00a04.12. As seen, the \nSatcomLayer component abstracts the services required to receive a monitor plan, which \nwhen received is passed down to the SecurityLayer component for decryption and further \npassed down the layered hierarchy for processing in the ApplicationLayer. Once environ\u00ad\nmental monitoring is activated, the ApplicationLayer component interfaces with the \nHardwareComponent to initiate activation of the external nodes. As seen, UML ports are \nused to show the boundaries of the remote monitor system, and the delegate label is used \nto indicate that the responsibility for fulfilling the required services is delegated to one or \nmore components in the system. The main quality attributes associated with the layered \narchitectural pattern are presented in Table\u00a04.12.\nSkill Development 4.4: Layered Architectural Pattern\nConduct an online search for the Open Systems Interconnection (OSI) reference model \nor TCP/IP model. Select one and explain how the layered architectural pattern applies \nto the selected model. Clearly identify each layer, their services, and how they interact \nwith other layers in the system. Can you think of other system software that can be \ndesigned using the layered architectural pattern? Come up with such examples and \nthen identify the layers that you would create and the services (and interaction with \nother layers) within the system.\n", "page": 158, "type": "text", "section": "Page 158"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 135\nLayer 1\nLayer 2\nBox-and-Line Diagram\nLayer 3\nLayer n\nUML Component Diagram\n<<component>>\nSatcomLayer\n<<subsystem>>\nRemoteMonitorSystem\nISatcom\nISecure\n<<component>>\nSecurityLayer\n<<delegate>>\n<<component>>\nApplicationLayer\n<<component>>\nHardwareLayer\nISecure\nIApplication\nIHardware\nIApplication\nINodeMonitor\nINodeMonitor\n<<delegate>>\nIMonitorPlan\nIMonitorPlan\nFIGURE 4.12\nThe layered architectural pattern.\nTABLE\u00a04.12\nQuality Attributes Associated with the Layered Architectural Pattern\nQuality\nDescription\nModifiability\nDependencies are kept local within layer components. Since components can access other \ncomponents only through a well-defined and unified interface, the system can be modified \neasily by swapping layer components with other enhanced or new layer components.\nPortability\nServices that deal directly with a platform\u2019s application programming interface (API) can be \nencapsulated using a system layer component. Higher-level layers rely on this component for \nproviding system services to the application; therefore, by porting the system\u2019s API layer to \nother platforms the systems become more portable.\nSecurity\nThe controlled hierarchical structure of layered systems allows for easy incorporation of \nsecurity components to encrypt or decrypt incoming or outgoing data.\nReusability\nBy compartmentalizing each layer\u2019s services, they become easier to reuse.\n", "page": 159, "type": "text", "section": "Page 159"}
{"text": "136\u2002 \u2022\u2002 Software Engineering Design\ufeff\nCHAPTER SUMMARY\nDuring software architecture, designers spend a great deal of time devising architectural solu-\ntions that provide the necessary components and interfaces to achieve systems\u2019 requirements. \nAt the architectural level, common patterns have emerged that describe the elements of the \nsystem and the quality characteristics of those elements. These patterns, also known as archi-\ntectural styles, have emerged as the mainstream approach for achieving reuse of successful \ndesign solutions at the architectural level and are fundamental to the efficient creation of soft-\nware architectures. Architectural patterns provide generic, reusable architectural solutions, \ndocumented in a way that can be easily understood and applied to new problems requiring \nsimilar architectural features. Decisions based on architectural patterns benefit from years of \ndocumented experience that highlights the solution approach to given problems, the benefits \nof these approaches, and the consequences of designing the system with a particular style.\nArchitectural patterns can be classified by the type of systems they support, such as \ndata-centered, data-flow, distributed, interactive, and hierarchical systems. Examples \nof architectural patterns include blackboard, pipe and filter, client\u2013server, broker, \nmodel\u2013view\u2013controller, main program and subroutine, and layered patterns. These patterns \nallow designers to efficiently conduct principled analyses of the layout of sub\u00ad\nsystems and \ncomponents that need to communicate in the operational system. During the past decade, \nmany styles and patterns for software architecture have been researched and published. \nMany of these patterns have been identified in pattern catalogue books; some of these are \ncommon design patterns in enterprise-level systems, while others address specific needs \nsuch as distributed systems. Identifying and designing using architectural patterns can \nimprove the efficiency of the development process and the quality of the final system.\nREVIEW QUESTIONS\n\t\n1.\tWhat is an architectural pattern, and how does it differ from detailed design patterns?\n\t\n2.\tList and explain the different types of systems discussed for which architectural \n\u00ad\npatterns can be employed.\n\t\n3.\tAre software architectures restricted to only one architectural pattern for its \u00ad\nlogical \ndesign, or can they include more than one architectural pattern? Explain with examples.\n\t\n4.\tCan architectural patterns lead to direct translation to code? Explain.\n\t\n5.\tExplain the following architectural patterns, and provide an example of a system \n(different from the one discussed in this chapter) appropriate for them. Explain how \nthese patterns support particular quality attributes.\n\t\na.\t Blackboard\n\t\nb.\t Pipe and filter\n\t\nc.\t MVC\n\t\nd.\t Layered\n", "page": 160, "type": "text", "section": "Page 160"}
{"text": "Patterns and Styles in Software Architecture\u2002 \u2022\u2002 137\n\t\n6.\tCompare and contrasts the following architectural patterns:\n\t\na.\t Client\u2013server vs. broker\n\t\nb.\t Layered vs. main program and subroutine\n\t\n7.\tHow can the pipe and filter architectural pattern enhance the performance of software \nsystems?\n\t\n8.\tHow can the MVC enhance a system\u2019s modifiability, usability, and reusability?\n\t\n9.\tHow can the broker pattern enhance a system\u2019s interoperability?\n\t 10.\tHow can the layered pattern support a system\u2019s security and portability?\n\t 11.\tExplain how using design elements from different architectural views can support \nthe use of architectural patterns for providing a complete picture of an architectural \ndesign element.\nCHAPTER EXERCISES\n\t\n1.\tFind a computer using the Microsoft Windows operation systems and Microsoft Office \nWord. Perform a Google search on how to split the window horizontally of the par-\nticular version of Word that you are executing so that you can split a document hori-\nzontally into two windows that mirror each other. Position each window on the same \ndocument location, and begin typing in the topmost window. As you type, you should \nsee the bottom window getting updated in real time to incorporate the newly entered \ntext. Explain how architectural patterns can help achieve this capability. Provide spe-\ncific examples of architectural patterns that can be used for this capability.\n\t\n2.\tUsing the UML tool of choice, create the logical design using patterns for a portable, \ninteractive, and distributed software system. State your assumptions, and accompany \nyour design with a rationale of why the particular patterns were selected and how they \nsupport the required quality attributes. Feel free to design around the patterns to pro-\nvide other views and to present a whole picture of the system design.\nREFERENCES\nAlexander, Christopher, Sara Ishikawa, Murray Silverstein, Max Jacobson, Ingrid Fiksdahl-King, and Shlomo \nAngel. A Pattern Language: Towns, Buildings, Construction. New York: Oxford University Press, 1977.\nBass, Len, Paul Clements, and Rick Kazman. Software Architecture in Practice, 2d ed. Boston: Addison-Wesley, 2003.\nBuschmann, Frank, Regine Meunier, Hans Rohnert, Peter Sommerlad, and Michael Stal. Pattern-Oriented \nSoftware Architecture: A System of Patterns. West Sussex, UK: Wiley, 1996.\nClements, Paul, Rick Kazman, and Mark Klein. Evaluating Software Architectures. Santa Clara, CA: Addison \nWesley, 2001.\nPressman, Roger S. Software Engineering: A Practitioner\u2019s Approach, 7th ed. Belmont, CA: McGraw-Hill, 2010.\nQian, Kai, Xiang Fu, Lixin Tao, Chong-Wei Xu, and Jorge L. Diaz-Herrera. Software Architecture and Design \nIlluminated. Sudbury, MA: Jones & Barlett, 2009.\nTaylor, Richard N., Nenad Medvidovic, and Eric M. Dashofy. Software Architecture: Foundations, Theory, and \nPractice. Hoboken, NJ: Wiley, 2009.\n", "page": 161, "type": "text", "section": "Page 161"}
{"text": "139\n5\nPrinciples of Detailed Design\nCHAPTER OBJECTIVES\n\u2022\t Understand the role of detailed design within the software design phase\n\u2022\t Become familiar with detailed design tasks during software design\n\u2022\t Become familiar with the detailed design process\n\u2022\t Understand fundamental concepts of object-oriented concepts and \nprinciples for component designs\n\u2022\t Understand the role of documentation in software design and how to \ncreate a software design document\nCONCEPTUAL OVERVIEW\nThe previous chapters presented the software architecture activity as a \nmacrodesign approach for transforming software requirements into design \nelements that specify the main components and interfaces of software sys-\ntems. This holistic black-box approach is essential for establishing the initial \ndesign and a framework of quality that guides and supports the detailed \ndesign and construction of software systems. During detailed design, the \ndesign process continues where software architecture leaves off for pro-\nviding a white-box approach to design, where details left undefined and \ndeferred to downstream designers are created to define the necessary details \nfor fully specifying the internal structure and behavior of components iden-\ntified during architecture. These detailed designs fill the gaps in the design \nand provide a complete picture of how the system achieves its functional \nrequirements within the quality framework established by the software \narchitecture. Detailed design decisions can significantly shape the system\u2019s \nquality properties (e.g., portability, performance, usability); therefore, they \n", "page": 163, "type": "text", "section": "Page 163"}
{"text": "140\u2002 \u2022\u2002 Software Engineering Design\ufeff\nmust exist within the bounds of the software architecture. In some cases, where modeling \ntools are used to generate code, detailed designs can also significantly impact the quality \nproperties of the construction phase. Upon completion of the detailed design activity, the \n\u00ad\nsystem\u2019s design is sufficiently complete so that it can be formally documented, reviewed, \nand approved by the system\u2019s stakeholders, which marks the end of the design phase.\nWHAT IS DETAILED DESIGN?\nThe detailed design activity begins once the software architecture is specified, reviewed, and \napproved by all stakeholders in the project. During detailed design, logical components are \nrefined and their interactions are modeled to verify the validity of their structural compo-\nsition. The execution of the detailed design activity requires a shift from the macro\u00ad\ndesign \napproach to the microdesign approach to further decompose and refine system components \ninto one or more fine-grained elements, functions, and data variables required for support-\ning the internal structure and behavior of components that meet assigned roles during the \nsoftware architecture activity. IEEE (1990, p. 26) defines detailed design as\n\t\n1.\tThe process of refining and expanding the preliminary design phase of a system or \ncomponent to the extent that the design is sufficiently complete to be implemented.\n\t\n2.\tThe result of the process in 1.\nExtending the IEEE definition, detailed design is both the process of refining the soft-\nware architecture to reach a point where construction can begin and the result of such \nprocess. The detailed design activity is the last major design effort before the software con-\nstruction phase. A fundamental difference between architectural and detailed design is \nthat whereas the former is concerned mostly with defining the major components of the \nsystem and their interfaces, the latter is concerned with how these components realize their \nassigned responsibility. This suggests that architectural designs employ a holistic approach \nto software system design, which emphasizes system quality, while detailed design focuses \non particular components within the system, which emphasizes the functional aspects of \na system. This fundamental difference is essential in determining what and how work is \nperformed during these activities. For example, whereas the component notation provides \nan appropriate mechanism for designing logical architectures, their level of abstraction \nis inappropriate for modeling detailed design elements. Therefore, in object-oriented sys-\ntems, classes and interfaces become the major unit of design work. This, in turn, influences \nthe type of analyses performed during both activities. The modeling and analyses that \noccur during architecture help answer the questions of what needs to be developed, and by \nthemselves these models and analyses cannot be used to build directly a working software \nsystem. Detailed design goes deep into each component to define its internal structure and \nbehavioral capabilities, and the resulting design leads to natural and efficient construction \nof software. Clements, Bachmann, Bass, Garlan, Ivers, Little, Nord, and Stafford (2002, p.\u00a05) \ndifferentiate between architectural and detailed design as follows:\n", "page": 164, "type": "text", "section": "Page 164"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 141\nArchitecture is design, but not all design is architecture. That is, many design decisions are \nleft unbound by the architecture and are happily left to the discretion and good judgement of \ndownstream designers and implementers. The architecture establishes constraints on down-\nstream activities, and those activities must produce artifacts\u2014finer-grained design and code\u2014\nthat are compliant with the archtiecture, but architecture does not define an implementation.\nDetailed design is closely related to architecture and construction; therefore, successful \ndesigners (during detailed design) are required to have a full understanding of the system\u2019s \nrequirements and architecture, design strategy, programming language, and methods and \nprocesses for software quality control. Detailed designers must also work closely with stake-\nholders (e.g., hardware team, test team, quality team, management) to provide designs that \naccommodate multiple concerns appropriate to the detailed design activity. This requires \na holistic vision\u2014different from that of the software architecture designer\u2014to envision \ndetailed designs and how they relate to requirements, architecture, and construction, as \npresented in Figure\u00a05.1.\nThe conceptual model presented in Figure\u00a0 5.1 shows interrelationships that detailed \ndesign elements have with other architectural or construction elements. In this context, \nC\nRequirements,\nArchitecture \nDetailed Design\nRequirements,\nArchitecture \nDesigner\u2019s Mental Model\nCode \nCode \nDetailed\nDesign\nFIGURE 5.1\nContext of detailed design activity.\n", "page": 165, "type": "text", "section": "Page 165"}
{"text": "142\u2002 \u2022\u2002 Software Engineering Design\ufeff\ndetailed designs provide the essential structure that acts as bridge connecting the work \nperformed during architecture and construction. Detailed designs need to incorporate \ndesign alternatives that support the requirements and quality attributes (e.g., testability, \nmaintainability, modifiability) identified in previous phases and activities of the software \nengineering life cycle. When presented with requirements or concerns from other stake-\nholders, detailed designers are able to visualize designs that provide the required struc-\ntural and behavioral capabilities for achieving those needs. As they work to shape new \nor existing designs, they are also capable of visualizing the executing code to help them \nformalize the design. When given code, such as the case during the maintenance phase, \ndetailed designers are required to envision detailed designs or even reverse engineer the \ncode into designs and to understand how both code and designs relate to the original soft-\nware requirements. This mental model allows designers to understand the complex inter-\ndependencies that exist among these different life cycle phases and how requirements and \nquality attributes are achieved throughout the software project. Achieving such visions \nfrom designers helps in all aspects of designing high-quality, large-scale software systems.\nKEY TASKS IN DETAILED DESIGN\nIt can be argued that the detailed design phase is where most of the problem-solving activi-\nties occur in software projects. Consider the case where formal design processes are fol-\nlowed so that the requirements phase is followed by the architectural design activity, which \nis \u00ad\nfollowed by detailed design. In many practical applications, the architectural design \nactivity defers complex problem solving to the detailed design activity mainly through \nabstraction. In some cases, even defining the requirements is deferred to the detailed design \nphase, leaving the detailed design activity as the gatekeeper for ensuring that the system\u2019s \nspecification and design are sufficiently complete before construction begins. Deferring \nsuch problems to the construction phase is a recipe for failure, since this typically results \nin higher cost (Clements, Kazman, and Klein 2001). When done properly, detailed designs \nshould provide a ready-made solution that eases the construction process\u00ad\n. To achieve this \nduring detailed design, designers must fully understand requirements assigned to com-\nponents and architectural decisions deriving detailed design; they must design complex \ninterfaces, identify design patterns, evaluate and validate detailed designs, generate code \nfrom the models, and establish policies for ensuring design synchronicity throughout the \nconstruction phase.\nDETAILED DESIGN PROCESS\nThe detailed design process is carried out to identify how architectural components are \ndesigned with enough detail so that their implementation using programming languages \n", "page": 166, "type": "text", "section": "Page 166"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 143\ncan follow without much effort. Many process flows can be identified and used to carry \nout and manage detailed design activity, including iterative, sequential, and spiral \n(Pressman\u00a02010). Regardless of the particular process flow selected for a given project, \ncarrying out the detailed design activity requires the following fundamental tasks:\n\u2022\t Understanding the architecture and requirements\n\u2022\t Creating detailed design\n\u2022\t Evaluating detailed design\n\u2022\t Documenting detailed design\n\u2022\t Monitoring and controlling implementation\nUNDERSTANDING THE ARCHITECTURE AND REQUIREMENTS\nUnlike the software architecture activity, where the complete set of system requirements \nare evaluated and well understood, designers during the detailed design activity focus \non requirements allocated to their specific components. In some cases, requirements can \ncross-cut several components; therefore, communication with other designers is essential \nto coordinating the design solution without duplicating work. Besides addressing require-\nments passed on from the architectural activity, it is also common during detailed design \nto derive new software requirements as knowledge of the system is enhanced throughout \nthe detailed design activity. Derived requirements are requirements based on higher-level \nspecifications created to address a finer-grained function or process during detailed design \nand construction. These requirements can help standardize operations for higher-level \nrequirements identified in previous phases and activities of the project. Consider an \nembedded real-time software system broken down into five different major subsystem \ncomponents, each executed on different target hardware and broken down further into \nnumerous other components. During requirements, the functional capability to log events \nin the system is specified. To carry out this function of the system, a detailed design activ-\nity is done to create a common event logger so that all components in the systems rely on \na standardized way for logging events in the system. Because of the resource-constrained \nenvironment of the particular embedded system, simply having one functional require-\nment to log events provides insufficient specification for the desired behavior. Consider the \ncase where the event logger is designed to log all events in the system to a file without limits \nor policies to manage how events are stored, purged, and so forth. In such a resource-\nconstrained environment, enforcing and verifying policies for such behavior is essential, \nsince a large number of events, depending on the target resources, can slow or bring the \nsystem down. In such cases, deriving requirements that specify these policies (e.g., maxi-\nmum number of events logged, event purge policy such as first-in, first-out (FIFO), last-in, \nlast-out (LIFO)) provides essential items of verification for the system. These requirements \nare imposed not by customers but by the design team to enforce a desired capability of the \nsoftware or process to develop the software. When conducting the detailed design activity, \n", "page": 167, "type": "text", "section": "Page 167"}
{"text": "144\u2002 \u2022\u2002 Software Engineering Design\ufeff\nassigned requirements for the components have to be well understood, and, when appro-\npriate, derived requirements need to be specified before construction begins.\nBesides understanding requirements during detailed design, understanding and adhering \nto the software architecture are essential for building high-quality systems. The concept of \ndesign synchronicity was presented in Chapter 3 as the degree to which the software imple-\nmentation conforms to its design. To maintain synchronicity throughout the development \neffort, all decisions made during detailed design must conform to the system\u2019s identified \narchitecture. To achieve this, software processes must be in place for monitoring and con-\ntrolling detailed designs throughout. Unmanaged deviations from the software architec-\nture during detailed design and construction can reshape the properties of the system and \naffect its overall capability to meet requirements. Therefore, detailed designers need to work \nclosely with each other and with software architects to ensure that their design choices are \nconsistent with the overall system plan. This is especially true during maintenance phases, \nwhere deviations may occur long after the initial system design is devised.\nCREATING DETAILED DESIGNS\nAfter requirements and the software architecture are well understood, the detailed design \nof software components can begin. The detailed design consists of structural and behav-\nioral designs required to specify components sufficiently so that they can be consistently \nconstructed by one or more programmers. This entails various design tasks, including \nrefining or \u00ad\ncreating components\u2019 interface design internal structure, and behavioral \ndesign; identifying design patterns; applying design principles; adopting naming conven-\ntions; and evaluating and documenting detailed designs. These are discussed in more \ndetail throughout the following sections.\nInterface Design\nInterface design refers to the design activity that deals with specification of interfaces \nbetween components in the design (Sommerville 2010). Interface design can be focused on \nspecifying the interfaces used internally within software components or externally across \nsoftware components. In both cases, interfaces provide a standardized way for specifying \nhow services are accessed and provided by software components. Interface design allows \nsubsystems to be designed independently and in parallel; therefore, it is typically done first \nwithin the detailed design step.\nExternal Interface Design\nDuring the software architecture activity, externally visible interfaces are specified. The \nrealization of these interfaces may involve much detailed design work before they can \nbe used in construction. These may include a customized binary message definition, \n", "page": 168, "type": "text", "section": "Page 168"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 145\nExtensible Markup Language (XML) schemas and messages, or other interfaces required \nfor specifying how components interact with other external components. Depending on \nthe interface design effort, a formal interface document can be created and managed inde-\npendently, similar to the requirements specification or design document. This document, \nknown as the interface control document (ICD), is an important piece of documentation \nthat serves as a written contract between components of the software system to specify how \nthey will communicate. The ICD defines the important data and protocols used for com-\nmunication between components, therefore providing developers during construction the \nrequired information needed to write the software.\nInternal Interface Design\nThe Internal interface definition establishes policies for subsequent development in the \nsoftware design. It provides a way for abstracting common operations so that problems \nduring detailed design can be reasoned in terms of these interfaces, which provides a \nhigher level of abstraction for specifying rules that apply to a larger set of entities that \nrely on them. In object-oriented systems, Unified Modeling Language (UML) can be used \nto create interface designs using class diagrams that include the <<interface>> \u00ad\nstereotype \nin the name section of the class, as presented in Chapter 2. These help identify the major \nclasses and functions that allow intercomponent communication and provide the rules \nof communication that must be followed by other classes that implement these interfaces \nduring the detailed design activity.\nGraphical User Interface Design\nVisual designs have a major role in the success or failure of software systems. Systems that \nmeet functional requirements but are not usable cannot succeed. During detailed-design, \nthe initial Human Computer Interface (HCI) design identified during the software archi-\ntecture activity is refined and the appropriate design for interfacing the Graphical User \nInterface (GUI) to the whole system is done. During detailed design, all aspects of the \nGUI\u2014such as modes, navigation, visual designs (e.g., color, icons, fonts), response time and \nfeedback, design modalities (e.g., forms, menu-driven), localization, internationalization, \nand general human\u2013computer design principles\u2014are fine-tuned.\nDesigning Internal Structure of Components\nComponent design is not restricted to object-oriented systems; however, the discussion \nand approach presented in this section and throughout the book focus on object-oriented \nsystems\u00ad\n. Other forms of component design can be employed based on the design \u00ad\nstrategy, \nsuch as the structured design strategy. In object-oriented systems, the internal structure \nof components is typically modeled using UML through one or more class diagrams. \nComponent design refers to the detailed design task of defining the internal logical structure \nof components. That is, the internal data structures, algorithms, interface characteristics, \n", "page": 169, "type": "text", "section": "Page 169"}
{"text": "146\u2002 \u2022\u2002 Software Engineering Design\ufeff\nand communication mechanisms of all components are all defined during component \ndesign. For this reason, component design provides the most significant mechanism for \ndetermining the functional correctness of the software system and allows for evaluating \nalternative solutions before coding begins.\nA multitude of principles, guidelines, and patterns exist for creating quality component-\nlevel design. These principles guide engineers to make appropriate decisions when \u00ad\nrefining \ncomponents into other components and classes and defining the relationships between \nthem. The work produced during component design serves as strong indication of the \nfunctional success of the software system. Before these concepts can be understood, it is \n\u00ad\nnecessary to understand the basic concepts in component design of object-oriented \u00ad\nsystems. \nThese include (Gamma et al. 1995):\n\u2022\t Classes and objects\n\u2022\t Interfaces, types, and subtypes\n\u2022\t Dynamic binding\n\u2022\t Polymorphism\nClasses\nThe main unit of composition in object-oriented component design is the class. Chapter 2 \nintroduced classes as modeling entities in UML class diagrams. However, before becoming \nefficient during component design, a clear distinction between classes and objects needs to \nbe made. A class is a specification that defines the data and services used and provided by \nparticular objects. There are two types of classes in object-oriented component designs, as \npresented in Table\u00a05.1.\nConcrete classes specify the data, services, and implementation of those services required \nfor instantiating objects. Concrete classes provide complete information that supports \ninstantiation of objects at run time that have state and behavior. On the other hand, abstract \nclasses are special types of classes that contain one or more abstract methods, which have \nno implementation. Because abstract methods contain no implementation, abstract classes \ncannot be instantiated at run time. A special type of abstract class is one where all methods \nare abstract. These are equivalent to Java interfaces and the pure virtual classes in C++. \nAs abstract classes, interfaces and pure virtual classes cannot be instantiated at run time. \nAt\u00a0first glance, it seems logical to think that classes that cannot be instantiated serve little to \nno purpose in software designs. However, these classes provide powerful mechanisms for \ncreating elegant and reusable designs that can lead to increased maintainability, reusability, \nTABLE\u00a05.1\nTypes of Classes in Component Designs\nType\nDescription\nConcrete\nOrdinary class for specifying object\u2019s data and behavior\nAbstract\nSpecial class that contains at least one abstract method\n", "page": 170, "type": "text", "section": "Page 170"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 147\nand efficient software evolution. Abstract classes provide the means for designers to create \ncontracts that dictate the use of interfaces throughout software designs. These contracts are \nenforced by compilers and are founded on the principles and concepts of interfaces, types, \nsubtypes, dynamic binding, and polymorphism.\nInterfaces, Types, Subtypes, Dynamic Binding, and Polymorphism\nIn a broad sense, an interface is the set of functions that specify the services provided by \nobjects of a particular type. An interface method is simply one method that belongs to an \nobject\u2019s interface. The concepts of types and interfaces are interrelated; that is, since an \ninterface specifies the services provided by a particular type, it follows that a particular \ntype refers to a particular interface. In popular object-oriented systems, the concept of \ntypes is used interchangeably with classes. A subtype refers to an interface that includes \nthe interface of another type, referred to as its supertype (Gamma et al. 1995). This con-\ncept is reflected in object-oriented languages as inheritance. At design time, the concepts \nof interfaces, types, and subtypes are used to create software that is extensible at run time, \nmainly through the techniques of dynamic binding and polymorphism. Consider the \nspecification of an interface using an abstract class, which, as discussed before, cannot \nbe instantiated. In such cases, abstract classes are useful for defining the common set of \nservices provided by a specific type. Through inheritance, one or more subtypes can be \nspecified at design time to provide implementations for the defined interfaces, therefore \ncreating concrete classes that share the same interface, as defined by the abstract class. \nBy\u00a0designing classes this way, different objects can be instantiated at run time to share the \nsame interface but to provide completely different implementations (Gamma et al. 1995). \nConsider the type Shape with a single interface method named draw(). Now consider \ntwo other subtypes (inheriting from Shape), named Circle and Rectangle. By defi-\nnition, since Circle and Rectangle are subtypes of Shape, then they share its inter-\nface, which in this example includes the draw() interface method. This scenario is easily \ndesigned in modern programming languages by specifying Shape as pure virtual class \nin C++ or interface in Java. Both Circle and Rectangle would be designed using a \n(UML) realization relationship with the Shape type. Since Circle and Rectangle are \nmeant to be concrete classes, they both must provide an implementation for the draw() \ninterface method; otherwise, they would both be abstract classes that cannot be instanti-\nated. With this framework in place, portions of the software at design time can be specified \nusing the Shape interface, which both Circle and Rectangle support. At run\u00a0time, \nservices specified by the Shape interface are carried out by the particular run-time object \nattached to the request, which could be objects of either Circle or Rectangle sub-\ntypes. This way, when calling upon the object\u2019s draw interface method, the software can \nbehave differently at run time by drawing to the screen either a circle or a rectangle.\nThe mechanism for providing the run-time association between an object and an inter-\nface method is known as dynamic binding (Gamma et al. 1995). This allows objects of the \nsame type hierarchy to behave differently at run time simply by associating the interface \nmethod call to the appropriate run-time instance. This capability is known as polymorphism. \n", "page": 171, "type": "text", "section": "Page 171"}
{"text": "148\u2002 \u2022\u2002 Software Engineering Design\ufeff\nInterfaces, types, subtypes, dynamic binding, and polymorphisms are essential to achieving \nefficient designs of components in object-oriented systems and are the fundamental mecha-\nnisms for achieving most object-oriented design principles and patterns.\nObjects\nWhereas classes are design-time entities, objects are run-time entities; that is, objects are \nthe manifestation of classes and therefore occupy space and time during software exe-\ncution. For classes to be of use in executing programs, objects have to be instantiated. \nInstantiation is the process of manifesting a class in the computer\u2019s memory; this manifes-\ntation is referred to as an object of that class. Therefore, one class can be manifested in the \ncomputer\u2019s memory as multiple objects, since we can instantiate a class numerous times. \nThis concept is presented in the conceptual model presented in Figure\u00a05.2.\nAs seen, the code in the main function of the ProgramDriver class instructs the \ncompiler to instantiate three different objects of type ListNode type. In this example, \nthe specification for objects of type ListNode is provided by the ListNode class and \ninstantiation of objects of that class is done by employing the new keyword. When the \ncompiled and built version of the code is executed, three different objects of the same \nclass\u2014together with the object of type ProgramDriver\u2014will occupy some space in the \ncomputer\u2019s memory. These three objects of type ListNode occupy specific locations in \nmemory and are addressable by their own memory address. This is possible because each \nobject has its own identity. Notice also in the figure that the ProgramDriver object has \nlinks to the three different node objects, since it has variables holding the addresses to \n\u0012\u0012\u00037KH\u0003RQH\u0003DQG\u0003RQO\\\u0003VSHFLILFDWLRQ\u0003\n\u0012\u0012\u0003RI\u0003WKH\u0003/LVW1RGH\u0003W\\SH\u0011\u0003\nFODVV\u0003/LVW1RGH\u0003^\u0003\n\u00ab\n`\u0003\nSXEOLF\u0003FODVV\u00033URJUDP'ULYHU\u0003^\u0003\nSXEOLF\u0003VWDWLF\u0003YRLG\u0003PDLQ\u000b6WULQJ>@\u0003DUJV\f\u0003^\u0003\n\u0012\u0012\u0003,QVWDQWLDWH\u0003WKUHH\u0003REMHFWV\u0003RI\u0003WKH\u0003\u0003\u0003\u0003\n\u0012\u0012\u0003/LVW1RGH\u0003W\\SH\u0011\u0003\n/LVW1RGH\u0003QRGH2QH\u0003 \u0003QHZ\u0003/LVW1RGH\u000b\f\u001e\u0003\n/LVW1RGH\u0003QRGH7ZR\u0003 \u0003QHZ\u0003/LVW1RGH\u000b\f\u001e\u0003\n/LVW1RGH\u0003QRGH7KUHH\u0003 \u0003QHZ\u0003/LVW1RGH\u000b\f\u001e\u0003\n\u0003\u0003`\u0003\n`\u0003\nCompile and Build into Executable \n\u0013\u0003\u0014\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0014\u0003\u0014\u0003\u0013\u0003\u0014\u0003\u0013\u0003\u0014\u0003\u0013\u0003\u0014\u0003\u0013\u0003\u0014\u0003\u0013\u0003\u0014\u0003\u0014\u0003\u0013\u0003\u0003\nExecute in Computer \nMemory for Executable \nComputer Memory \nWKLV\u0003 \u0003\u0013[\u0013\u0013IIDDEE\u0003\nQRGH2QH\nWKLV\u0003 \u0003\u0013[GHDEFGEE\u0003\nQRGH7KUHH\nWKLV\u0003 \u0003\u0013[\u0013IDGFGEE\u0003\nQRGH7ZR\nSURJUDP'ULYHU\nWKLV\u0003 \u0003\u0013[\u0013\u0013IIDDEE\u0003\nFIGURE 5.2\nConceptual model for classes and objects.\n", "page": 172, "type": "text", "section": "Page 172"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 149\nthese objects; therefore, programDriver can always access these objects through these \n\u00ad\nvariables (i.e.,\u00a0nodeOne, nodeTwo, nodeThree). Unlike classes, objects exist at run time and \nhave specific characteristics such as the ones presented in Table\u00a05.2 (Douglas 1999).\nWhen designing at the component level, careful class specification is essential to allow \nobjects at run time to behave in such a way that flexibility and reusability are added to \nthe software. This in turn allows component designs to provide the means to allow the \nsoftware to evolve gracefully over time and to become more reusable. Designing efficient \ncomponent structures allows today\u2019s software to adapt to future technology or new system \nfunctionality. Therefore, when designing component-level software, careful attention has \nto be paid in the application of fundamental detailed design principles.\nDesign Principles for Internal Component Design\nSeveral principles have been identified throughout the literature that help in making \ncomponent-level design decisions, including\n\u2022\t The open\u2013closed principle (OCP)\n\u2022\t The Liskov substitution principle (LSP)\n\u2022\t The interface segregation principle (ISP)\nOpen\u2013Closed Principle\nThe OCP is an essential principle for creating reusable detailed designs. It promotes designs \nthat allow changes to be made by extension of designs rather than by modification of exist-\ning code. The main idea behind the OCP is that code that works should remain untouched \nand that new additions incorporated to address new concerns should be extensions of the \noriginal work. The OCP was originally coined by Bertrand Meyer (1997) and states that \nsoftware designs should be open to extension but closed for modification. At first glance, \nthe OCP sounds contradictory since it promotes designs that are closed to modification. \nHowever, in the OCP context, being closed to modification does not mean that designs \ncannot be modified; it means that modifications should be made as extensions to the \ndesign, by adding new design and code instead of modifying existing working designs and \ncode (Marin 2003). This is possible in object-oriented systems through the use of abstract \nclasses and interfaces. Consider a gaming system that includes several types of terrestrial \ncharacters, which can roam freely over land, as shown in Listing 5.1.\nTABLE\u00a05.2\nCharacteristics of Objects\nCharacteristic\nDescription\nAttributes\nThe object\u2019s data\nBehavior\nThe object\u2019s designed behavior, as specified by its public functions\nState\nThe current state of the object, as defined by the values of its data\nIdentity\nTheir own individual memory address\nResponsibilities\nTwo objects of the same class can be instantiated for specific purposes\n", "page": 173, "type": "text", "section": "Page 173"}
{"text": "150\u2002 \u2022\u2002 Software Engineering Design\ufeff\nAs seen, the GameEngine class is designed with an interface method that accepts \nreferences (i.e., pointer) to objects that share the TerrestrialCharacter \ninterface. When an object of type TerrestrialCharacter is passed into the \naddCharacter(.\n.\n.) method, the method draws it to the screen and calls the char-\nacter\u2019s run() method, which activates the character to move over land in a random \npattern. This design works fine for all kinds of terrestrial characters; however, it does \nlittle to support efficient addition of other types of characters to the game. This is true \nbecause the design of the GameEngine class relies on the interface of the concrete \nTerrestrialCharacter class. Consider the case where characters that move dif-\nferently\u2014for example, aerial characters or aquatic characters\u2014are added to the gam-\ning system design. In such cases, the \u00ad\naddCharacter method needs to be modified to \naccount for these new types of characters. Therefore, the design of the GameEngine \nclass is not closed for modification. That is, the code inside the GameEngine class \nwould have to change, which violates the OCP. To prevent this, the OCP promotes and \nrelies on an indispensable design principle in object-oriented systems, which states \nthat software designs should rely on interfaces and not on implementations (Gamma \nListing 5.1: C++ Code for the Gaming System\n// The terrestrial character.\nclass TerrestrialCharacter {\npublic:\n\t // Draw the character on the screen.\n\t virtual void draw() { /*Code to draw the terrestrial character.*/ \n}\n\t // Make the character run!\n\t virtual void run() { /* Code to make the character run.*/\n};\n// The game engine responsible for managing the game.\nclass GameEngine {\npublic:\n\t // Add the character to the screen.\n\t void add(TerrestrialCharacter* pCharacter) {\n\t \t // Display the character.\n\t \t pCharacter->draw();\n\t \t // Make the character move!\n\t \t pCharacter->run();\n\t }\n};\n", "page": 174, "type": "text", "section": "Page 174"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 151\net\u00a0al. 1995). Consider the addition of the Character* interface to the gaming system\u2019s \ndesign, as presented in Listing 5.2.\nAs seen, the Character class is abstract, as specified by the two pure virtual methods \ngetType() and draw(). The character interface can be used to define interface \u00ad\nmethods \nthat are common to all characters in the gaming system. With this interface in place, the \naerial character is added to the design by implementing the Character interface, as \n\u00ad\npresented in Listing 5.3.\n*\t For those of you interested in compiling the code, e.g., the Character code, you will need to include in your code appro-\npriate libraries and namespace. In this case, to use the string type, you will need to include <string> and namespace \nstd to compile the Character class. This approach is generally followed throughout the rest of the book.\nListing 5.2: C++ Code for the Character Interface\nclass Character {\npublic:\n\t // Get the type of character.\n\t virtual string getType() = 0;\n\t // Draw the character on the screen.\n\t virtual void draw() = 0;\n};\nListing 5.3: C++ Code for the AerialCharacter Class\nclass AerialCharacter : public Character {\npublic:\n\t // Get the type of character.\n\t virtual string getType() {\n\t \t // Return the type of character.\n\t \t return \u201caerial\u201d;\n\t }\n\t // Draw the character on the screen.\n\t virtual void draw() {\n\t \t // Code to draw the aerial character.\n\t \t cout<<\u201ddrawing aerial character!\\n\u201d;\n\t }\n\t // Make the character fly!\n\t virtual void fly() {\n\t \t // Code to make the character fly.\n\t \t cout<<\u201dcharacter flying!\\n\u201d;\n\t }\n};\n", "page": 175, "type": "text", "section": "Page 175"}
{"text": "152\u2002 \u2022\u2002 Software Engineering Design\ufeff\nAs seen, the AerialCharacter class implements both getType() and draw() in \nterms of aerial characters. The AerialCharacter class also specifies the interface method \nfly() to make the character fly in random patterns during the character\u2019s activation in the \ngame. With the Character interface added to the design, the TerrestrialCharacter \nis now modified to implement the newly added interface so that anywhere in the design \nwhere objects sharing the Character interface are expected, both terrestrial- and \naerial-type objects can be used. The redesigned TerrestrialCharacter class, which \nnow implements the Character interface, is presented in Listing 5.4.\nWith this new framework in place, consider the redesign of the GameEngine from \nListing 5.1, presented in Listing 5.5. Two major modifications have been made to the \nGameEngine design. First, the add(   ) method is modified to rely on the Character \ninterface instead of on concrete classes; second, the code inside the add(   ) method now \naccounts for different types of characters. To\u00a0support this new behavior, the getType(   ) \nmethod has been added to retrieve the type of the character at run time so that the code \ninside the add() method can determine whether to make characters run or fly, depending \non their type. This fixes the problem of not being able to handle various types of characters \nwith different movements. This is an improvement from the first design version; however, \nthe design still violates the OCP. Anytime that a new character is added to the game, the \nListing 5.4: C++ Code for Redesigned TerrestrialCharacter Class\nclass TerrestrialCharacter : public Character {\npublic:\n\t // Get the type of character.\n\t virtual string getType() {\n\t \t // Return the type of character.\n\t \t return \u201cterrestrial\u201d;\n\t }\n\t // Draw the character on the screen.\n\t virtual void draw() {\n\t \t // Code to draw the terrestrial character.\n\t \t cout<<\u201ddrawing terrestrial character!\\n\u201d;\n\t }\n\t // Make the character run!\n\t virtual void run() {\n\t \t // Code to make the character run.\n\t \t cout<<\u201dcharacter running!\\n\u201d;\n\t }\n};\n", "page": 176, "type": "text", "section": "Page 176"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 153\nadd(   ) method needs to be modified to add another conditional statement to test for \nthe new character and call the appropriate method to make the new character move. This \nis a direct effect of designs that violate the OCP. The gaming system\u2019s design is redesigned \none last time to make it conform to the OCP, as presented in Listing 5.6. As seen, to make \nthe design OCP-compliant, better abstractions are introduced to the Character interface, \nwhich now includes the move(   ) interface method.\nA major design decision made in the redesign of the gaming system includes the addi-\ntion of the move() interface method to the Character interface. This provides a higher \nlevel of abstraction that allows the design to appropriately abstract moving behavior for all \ncharacters in the system. By introducing a higher level of abstraction that is appropriate \nfor characterizing the behavior required by characters (e.g., walk, run, swim, or fly), the \ndesign now allows the GameEngine class to rely on this abstraction to support multiple \nexisting and future characters in the game, as seen in Listing 5.7.\nListing 5.5: C++ Code for the GameEngine Class\nclass GameEngine {\npublic:\n\t // Add a character to the game.\n\t void add( Character* pCharacter ) {\n\t \t // Draw the character on the screen.\n\t \t pCharacter->draw();\n\t \t // If aerial, make it fly, otherwise, make it run.\n\t \t if( pCharacter->getType() == \u201caerial\u201d ) {\n\t \t \t // Downcast the pointer to an aerial character.\n\t \t \t AerialCharacter* pAerial = dynamic_cast<AerialCharacter*>\n\t \t \t\n(pCharacter);\n\t \t \t // Assume a valid pointer and make the character fly!\n\t \t \t pAerial->fly();\n\t \t }\n\t \t else {\n\t \t \t // Downcast the pointer to a terrestrial character.\n\t \t \t TerrestrialCharacter* pTerrestrial =\n\t \t \t\ndynamic_cast<TerrestrialCharacter*>(pCharacter);\n\t \t \t // Make the character run!\n\t \t \t pTerrestrial->run();\n\t \t } // end if statement.\n\t } // end add function.\n};\n", "page": 177, "type": "text", "section": "Page 177"}
{"text": "154\u2002 \u2022\u2002 Software Engineering Design\ufeff\nWith the redesign in place, the GameEngine can be used throughout to draw and \n\u00ad\nactivate all types of characters that share the Character interface, as seen in Listing 5.8.\nConsider the addition of an aquatic character under this new gaming system\u2019s design. \nIn the OCP-compliant case, the new character is added with new code, by implementing \nthe Character interface. At run time, objects that share the Character interface can \nbe passed into the GameEngine, which draws and activates the new character using the \ninterface methods specified by the Character interface. The OCP-compliant design of \nthe gaming system with all three supported characters is presented in Figure\u00a05.3.\nAn important caveat to the OCP is that no design is 100% closed for modification. At \nsome point, some code has to be readily available for modifications. The main idea of the \nOCP is to locate the areas of the software that are likely to vary and encapsulate them, so \nListing 5.6: C++ Code for the OCP-Compliant Gaming System\u2019s Design\nclass Character {\npublic:\n\t // Draw the character on the screen.\n\t virtual void draw() = 0;\n\t // Make the character move.\n\t virtual void move() = 0;\n};\n// The aerial character.\nclass AerialCharacter : public Character {\npublic:\n\t // Draw the character on the screen.\n\t virtual void draw() { /* Code to draw the aerial character. */ }\n\t // Make the character fly.\n\t virtual void move() { /* Code to make the character fly! */ }\n};\n// The terrestrial character.\nclass TerrestialCharacter : public Character {\npublic:\n\t // Draw the character on the screen.\n\t virtual void draw() { /* Code to draw the terrestrial character. */ }\n\t // Make the character run.\n\t virtual void move() { /* Code to make the character run! */ }\n};\n", "page": 178, "type": "text", "section": "Page 178"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 155\nthat variations required to account for particular behaviors can be compartmentalized and \nmade interchangeable through polymorphism.\nSkill Development 5.1: Open\u2013Closed Design Principle\nUsing the IDE of choice, implement the OCP-compliant design presented in Figure\u00a05.4. \nCreate a test driver function that uses the GameEngine to add all three characters to \nthe game. Once the code compiles and executes, design a fourth character and add it \nto the game. How do you think the OCP made the addition of the new character easy \nor hard? Explain.\nListing 5.7: C++ OCP-Compliant Design for the GameEngine Class\n// The game engine responsible for managing the game.\nclass GameEngine {\npublic:\n\t // Add the character to the screen.\n\t void add(Character* pCharacter) {\n\t \t // Display the character.\n\t \t pCharacter->draw();\n\t \t // Activate the character... make it move!\n\t \t pCharacter->move();\n\t } // end add function.\n};\nListing 5.8: C++ Client Code that Uses the GameEngine Class\n// Create the main game engine.\nGameEngine game;\n// Create the aerial character object.\nAerialCharacter aerialCharacter;\n// Crete the terrestrial character object.\nTerrestrialCharacter terrestrialCharacter;\n// Add all characters to the game.\ngame.add(&aerialCharacter);\ngame.add(&terrestrialCharacter);\n", "page": 179, "type": "text", "section": "Page 179"}
{"text": "156\u2002 \u2022\u2002 Software Engineering Design\ufeff\nLiskov Substitution Principle\nThe OCP from the previous section provides guidance to design extensible systems by \nmaking designs open to extension but closed to modification. In some cases, it can be seen \nthat adhering to the OCP alone does not guarantee correct designs or designs that lead to \nreusability throughout the system. To maintain the integrity of designs that adhere to the \nOCP, designs must honor any implied contract between base classes and the components \nthat use them (Pressman 2010). This concept is captured by the LSP, which was originally \nproposed by Barbara Liskov. The LSP serves as basis for creating designs that allow clients \nthat use derived classes to behave just as they would if they used the corresponding base \nclasses (Liskov and Guttag 2000). The LSP requires not only that signatures between base \nand derived classes are maintained but also that the subtype specification supports reason-\ning based on the supertype specification (Liskov and Guttag 2000).\nConsider the following implementation for a new EntryLevelTerrestrial\u00ad\nCharacter \nin the gaming system. The new entry-level character inherits from the terrestrial character \nclass, which provides the interface method move() and information about the semantics \nof the operation through pre- and postcondition specification, as presented in Listing 5.9.\nAs seen, EntryLevelTerrestrialCharacter implements the move method to \nmake terrestrial characters fly, therefore providing a design that can adhere to the OCP but \nthat violates the LSP, since the semantics of the TerrestrialCharacter are not main-\ntained. Anywhere in the design where objects of type TerrestrialCharacter are \ncalled upon to move, the postconditions defined for this type specify that terrestrial char-\nacters will walk or run. Upon extending this design with its entry-level subtype, characters \nTerrestrialCharacter\nAdheres to OCP\nViolates OCP\nGameEngine\n<<interface>>\nCharacter\n+draw(): void\n+run(): void\n+draw(): void\n+move(): void\n+add(pCharacter : TerrestrialCharacter*): void\nGameEngine\nAerialCharacter\n+add(pCharacter : Character*): void\n+draw(): void\n+move(): void\nTerrestrialCharacter\n+draw(): void\n+move(): void\nAquaticCharacter\n+draw(): void\n+move(): void\nFIGURE 5.3\nUML class diagrams for the OCP examples of the gaming system\u2019s design.\n", "page": 180, "type": "text", "section": "Page 180"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 157\nno longer walk but fly. When designing systems that adhere to the LSP, subtypes must \nconform both syntactically and semantically to their base types, so they can be replaceable \nat run time throughout the software execution.\nInterface Segregation Principle\nWell-designed classes should have one (and only one) reason to change. When this concept \nis violated, there is a strong indication that the interfaces provided by these classes are pro-\nviding more information than they should, which makes designs harder to maintain and \nreuse. The SIP states that \u201cclients should not be forced to depend on methods that they do \nnot use\u201d (Marin 2003). As example, consider incorporating into the gaming system a set of \ndifferent types of enemy characters, each with specific capabilities for moving over land, \nunder water, or over the air. In addition, a fourth type of enemy character is added to the \nsystem, which incorporates moving capabilities from all other enemy characters into the \n\u00ad\nsystem (e.g.,\u00a0run, swim, and fly). To allow characters to be interchangeable at run time, these \ncharacters are designed initially with a common EnemyCharacter base class, as seen in \nsm : ScheduleManager\ns : Schedule\nHeatSensor : Sensor\nVibrationSensor : Sensor\n2 : getMsg()\n1 : timer expires\n4 : msgId = interpretMsg()\n[msgId == HEAT_MSG_ID]\nalt\n[msgId == VIBRATE_MSG_ID]\n<<return>>\n5 : activate()\n6 : activate()\nsd Activate Sensors\nFIGURE 5.4\nSequence diagram during detailed design.\n", "page": 181, "type": "text", "section": "Page 181"}
{"text": "158\u2002 \u2022\u2002 Software Engineering Design\ufeff\nthe top part of Figure\u00a05.5. Notice that since the SuperCharacter class requires behavior \nfrom all other enemy characters, the EnemyCharacter base class is designed to con-\ntain the implementations for all enemy characters in the system. This way, through inheri-\ntance, the SuperCharacter can reuse all behaviors. What is wrong with this design? \nFor starters\u00ad\n, the design violates the LSP, since only the SuperCharacter conforms both \nsyntactically and semantically to the base type. However, of more interest is the fact that \nthe interface for all other characters in the system has now been polluted with unnecessary \nmethods. As enemy characters and capabilities continue to increase, so will the complexity \nof the EnemyCharacter interface, which in turn passes this complexity on to its derived \ntypes. Designs such as this, where clients or subtypes are forced to depend and maintain \nmethods that they do not use, leads to designs that are hard to reuse and maintain.\nThe SIP implies that many client-specific interfaces are better than one general purpose \ninterface. For example, consider the redesign presented in the lower part of Figure\u00a05.5. As \n+\ufb02y(): void\n+run(): void\n+swin(): void\nAerialCharacterClient\nTerrestrialCharacterClient\nAquaticCharacterClient\nAerialCharacter\nTerrestrialCharacter\nEnemyCharacter\n+\ufb02y(): void\n+run(): void\n+swim(): void\n<<interface>>\nSuperCharacter\nSuperCharacterClient\n+\ufb02y(): void\n+run(): void\n+swim(): void\nAquaticCharacter\nSuperCharacter\nViolates ISP\nAdheres to ISP\n<<interface>>\nAerialCharacter\n<<interface>>\nTerrestrialCharacter\n<<interface>>\nAquaticCharacter\nFIGURE 5.5\nThe interface segregation principle for the enemy character design.\n", "page": 182, "type": "text", "section": "Page 182"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 159\nseen, the bloated EnemyCharacter interface has been dissolved and many client-specific \ninterfaces have been created. These interfaces are easier to maintain and reuse and lead to \neasier adherence to both OCP and LSP.\nProgramming Styles in Detailed Design\nDuring detailed design, styles are used to provide a consistent approach for structuring code \nby specifying a standard for code elements, such as code formatting, naming conventions, \ndocumentation, and many other programming language-specific conventions. The appli-\ncation of styles is typically an activity that is emphasized during construction; \u00ad\nhowever, \ndue to the capabilities of today\u2019s modeling tools the application of styles is prevalent during \nthe detailed design phase. For example, when modeling tools are used in software proj-\nects, the detailed design activity is where, for example, classes, variables, functions, func-\ntion parameters, and return types are specified. When modeling tools are used to generate \ncode, other construction styles such as formatting styles (e.g., spaces, bracket positioning) \ncan also be specified. In all of these cases, styles are used to specify the way these elements \nappear in code in such way that it is consistent, readable, and therefore more maintainable. \nProgramming styles provide the means for ensuring consistency in code when designs are \ntransformed to code by different engineers.\nListing 5.9: C++ Implementation for EntryLevelTerrestrialCharacter\nclass TerrestrialCharacter : public Character {\n\t // Pre-Condition: Character is drawn on screen.\n\t // Post-Condition: Character roams around randomly over land, either\n\t // walking or running.\n\t virtual void move() {\n\t \t //code to make the character walk or run.\n\t }\n\t // code here to implement all other interfaces.\n};\nclass EntryLevelTerrestrialCharacter : public TerrestrialCharacter {\npublic:\n\t // Override move to make the character fly!\n\t virtual void move() {\n\t \t // code to make the character fly.\n\t }\n\t // Code here to implement all other interfaces.\n};\n", "page": 183, "type": "text", "section": "Page 183"}
{"text": "160\u2002 \u2022\u2002 Software Engineering Design\ufeff\nSince programming styles are mostly programming language-specific, styles for one \nparticular programming language may not apply to another programming language. \nHowever, some styles can be applied in a general fashion to a wide variety of modern pro-\ngramming languages, in particular those that share similar language characteristics, such \nas C++, Java, and C#. When creating detailed designs, the focus of programming styles can \nbe placed on the following:\n\u2022\t Type names\n\u2022\t Function names\n\u2022\t Variable names\nType names are names selected for defining types in a programming language. Examples \ninclude classes, interfaces, structs, and enumeration. Type names are commonly specified \nusing nouns and the PascalCase style. Type names that refer to collections can be pluralized \nto explicitly convey this information. Styles for interface names vary from most other type \nnames. Popular styles for interface names include the use of nouns, adjectives, the \u00ad\nletter \u201cI\u201d \nbefore the interface name, and a combination of all of these. Both the Java \u00ad\nlanguage and C# \nuse nouns and adjectives when specifying interface names. In addition, the C# language \nemploys the style of applying \u201cI\u201d before interface names. For custom-defined interfaces, \nVermeulen, Ambler, Bumgardner, Metz, Misfeldt, Shur et al. (2000) recommend using \nnouns for interfaces that act as service declarations (e.g., Java\u2019s ActionListener) and adjec-\ntives for interfaces that act as description of capabilities (e.g., Java\u2019s Runnable). Examples of \ntype name conventions are presented in\u00a0Listing 5.10.\nFunction Names\nWhereas type names typically use the PascalCase style in the naming convention, func-\ntion names vary significantly between PascalCase and lowerCamelCase styles. Naming \nconventions for function names also vary among the software engineering community, \nwith camps strongly supporting each side. This is largely due to the way in which differ-\nent programming languages use styles for function names. For example, it is not uncom-\nmon for C++ programmers to support lowerCamelCase style, since every function name \nin the standard template library uses this style. The same is true about Java programmers. \nHowever, the C# programming language employs the PascalCase style for function names; \ntherefore, programmers coming from Java or C++ background may tend to disagree with \nthe C# convention. Consider, for example, the function calls for displaying text to the con-\nsole in both Java and C#, as seen in Listing 5.11.\nNotice how pintnln and WriteLine use different styles built into the Java and .NET \nframeworks, respectively. Ultimately, projects should adopt a style for the function naming \nconvention that fits the project team and target programming language to maintain con-\nsistency. If in doubt, follow the convention provided by the target programming language.\nAnother characteristic of quality function names is how well they conform to all other \nparts of a function\u2019s signature. Function names should be chosen so that they relate \n", "page": 184, "type": "text", "section": "Page 184"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 161\naccurately to the main intention of the function and its return type. Function names \nthat accurately describe the function\u2019s intent can be referred as action-conforming func-\ntions. Alternatively, function names that do not are referred as action-contradictive; \nthese are function names that do not accurately relate to the function\u2019s main intent. \nExamples of action-contradictive and action-conforming function names are presented \nin Listing\u00a05.12.\nListing 5.10: Example of Type Name Conventions\n// Class name for a single node.\nclass MobileNode {\n};\n// Class name for a collection of nodes, therefore name is \npluralized.\nclass MobileNodes {\n\t public:\n\t \t void addNode( int nodeId );\n\t \t void removeNode( int nodeId );\n\t \t MobileNode* getNode( int nodeId );\n};\n// Another example of a collection name in C++.\nlist<MobileNode*> mobileNodes;\n// Custom-defined interface name in Java.\ninterface SampleInterface {\n}\n// Custom-defined interface name in C#.\ninterface ISampleInterface {\n}\n// Built-in interface name in Java\njava.util.Observable\n// Built-in interface name in C#\nSystem.ICloneable;\nListing 5.11: Example of Both PascalCase and \nlowerCamelCase for Function Names\n// Displaying text to the console in Java.\nSystem.out.println(\u201cconsole message...\u201d);\n// Displaying text to the console in C#.\nSystem.Console.WriteLine(\u201cconsole message...\u201d);\n", "page": 185, "type": "text", "section": "Page 185"}
{"text": "162\u2002 \u2022\u2002 Software Engineering Design\ufeff\nAs seen in Listing 5.13, the identified purpose for Function 1 is to display validity \u00ad\nstatus \nto the console; however, this is not evident by the choice of function name isValid. \nFurthermore, the use of \u201cis\u201d in front of function names typically implies the return of a \nBoolean value; therefore, clients may be more inclined to expect the function isValid() \nto provide information regarding the validity of an object by returning a Boolean \nvalue instead of displaying a message to the console. The function name of isValid is \naction-contradictive, since it does not accurately reflect the function\u2019s main intent, which \nis to \u00ad\ndisplay validity to the console. The function name is made action-conforming in \nListing 5.12: Action-Conforming and Action-Contradictive Function Names\n// Function 1 Purpose: Display validity to the console.\nvoid isValid() {\n\t if( /*some condition*/ ) {\n\t \t cout<<\u201dX is valid\u201d;\n\t }\n\t else {\n\t \t cout<<\u201dX is invalid\u201d;\n\t }\n}\n// Function 2 Purpose: Display validity to the console.\nvoid displayValidity() {\n\t if( /*some condition*/ ) {\n\t \t cout<<\u201dX is valid\u201d;\n\t }\n\t else {\n\t \t cout<<\u201dX is invalid\u201d;\n\t }\n}\n// Function 3 Purpose: Display element count number to the console.\nvoid hasElements() {\n\t cout<<\u201dElement count: 0\u201d;\n}\n// Function 4 Purpose: Display element count number to the console.\nvoid displayElementCount() {\n\t cout<<\u201dElement count: 0\u201d;\n}\n// Function 5 Purpose: Determine if a function has elements.\nbool hasElements() {\n\t return true;\n}\n", "page": 186, "type": "text", "section": "Page 186"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 163\nFunction\u00a02 by changing the name to more accurately reflect its purpose. Similarly, the \naction-contradictive name of Function 3 can be changed to action-conforming by chang-\ning it as presented in Function 4. In Function 5, the same name as in Function 3 is used \nwith a different purpose. In this case, the name results in an action-conforming type, since \nthe name accurately relates to the main intent of the function.\nType-conforming function names are those in which the function name relates and \nconform to the function return type. Function names that are inconsistent with the \nreturn type used are referred as type-contradictive. Examples of type-contradictive and \ntype-conforming function names are presented in Listing 5.13.\nIn the case of Function 5, the name toString implies the return of a string value; \nhowever, the return type of the function is set to bool to determine if the conversion was \nsuccessful. Users of this function may come to expect the function to return a string value; \ntherefore, this function is type-contradictive. The type-conforming version of the function \nis presented in Function 6.\nThe last commonly accepted style for function names includes the use of verbs to prop-\nerly describe actions in the code. In code, function names are abstractions of some action; \ntherefore, the use of verbs as function names can result in code that maps accurately to \nmental models used to reason about the code, as seen in Listing 5.14.\nVariable Names\nThe styles for variable names also include the use of CamelCase; however, unlike styles for \ntype names, which are typically PascalCase, and unlike styles for function names, which \nListing 5.13: Type-Contradictive and Type-Conforming Function Names\nclass Message {\npublic:\n\t // Function 5: Type-contradictive function!\n\t bool toString() {\n\t \t // Convert this object to a string.\n\t \t // return true if success, false otherwise.\n\t }\n\t // Function 6: Type-conforming function.\n\t string toString() {\n\t \t // Convert this object to a string.\n\t \t // return the string to the calling function.\n\t }\n};\n", "page": 187, "type": "text", "section": "Page 187"}
{"text": "164\u2002 \u2022\u2002 Software Engineering Design\ufeff\ntypically vary according to programming language, variable names (including parame-\nter names) typically use the lowerCamelCase style. Two main reasons exist for preferring \n\u00ad\nlowerCamelCase for variable names. First, the difference in styles can be used to differen-\ntiate between variables and types. Second, the lowerCamelCase style in variables can be \nused to differentiate between variables and constants, which typically use PascalCase or all \nuppercase, as seen in Listing 5.15.\nAs seen, two different styles are used for the constant max value. When the \u00ad\nuppercase \nstyle is selected, compound words are separated using the underscore \u201c_\u201d character. \nListing 5.15: Example of Styles for Variable Names\nclass Receiver {\npublic:\n\t // The style use for case differentiates types from variables.\n\t void receive(Message* message) {\n\t \t // Prefix used to identify member variables.\n\t \t _message = message;\n\t }\nprivate:\n\t Message* _message;\n};\n// Style 1 for a constant.\nconst int MaxValue = 10;\n// Style 2 for a constant.\nconst int MAX_VALUE = 10;\nListing 5.14: Example of Function Names Using Verbs\nclass Door {\npublic:\n\t void open(/*...*/) {\n\t \t // Open door.\n\t }\n\t void close(/*...*/) {\n\t \t // Close door.\n\t }\n};\n", "page": 188, "type": "text", "section": "Page 188"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 165\nIn\u00a0addition, Listing 5.15 presents a common style for identifying member variables, such \nas the\u00a0_message variable. Identifying member variables can improve readability of code \nwhere function parameters use the same name as member variables. In such cases, a pre-\nfix or suffix can be used to clearly identify the member variable, especially in large mem-\nber functions.\nModeling Internal Behavior of Components\nModeling interactions among entities designed during component design provides an \nefficient approach for visualizing complex interactions required for achieving a particu-\nlar system function. This helps verify the component designs before construction begins. \nSequence or communication diagrams can be employed to model objects representing \ninstances of classes, or roles representing prototypical instances of other entities, such as \nclasses (Booch, Rumbaugh, and Jacobson 2005). Both objects and roles can be connected \nto model the exchange of messages using links or connectors, respectively, to carry out a \nparticular function of the design, typically as part of the system\u2019s functional requirements. \nDuring detailed designs, the majority of behavioral models include objects, since analyses \nare made with detailed information that is already been designed. In many cases, class dia-\ngrams are accompanied by one or more behavioral diagrams to provide a complete picture \nof the detailed design; both of these are reviewed and documented as part of the software \ndesign document. An example of a detailed sequence diagram is presented in Figure\u00a05.5.\nThe sequence diagram from Figure\u00a0 5.5 presents the behavioral modeling of objects \nbelonging to three classes, namely, the ScheduleManager, Schedule, and Sensor classes. The \nsequence diagram\u2014identified by the sd keyword and name Activate Sensors\u2014uses the \nFrame notation, which provides the means to model combined fragments of interactions \nthroughout sequence diagrams. Each interaction frame inside the sequence diagram can \nbe classified using the operators presented in Table\u00a05.3 (UML 2.3 Superstructure 2010).\nThe alt operator is used to denote a conditional statement, where more than one case \nis examined. The opt operator is employed when a single optional fragment exists in a \nsequence. When this occurs, the operations inside the fragment are either executed or \nnot. This differs from the alt operator, which includes additional conditional statements. \nThe loop operator specifies a repetition structure. The format of the loop operator is as \nTABLE\u00a05.3\nCommon Interaction Operators Used in Sequence Diagrams\nOperator\nDescription\nseq\nDefault operator that specifies a weak sequencing between the behaviors of the operands\nalt\nSpecifies a choice of behavior where at most one of the operands will be chosen\nopt\nSpecifies a choice of behavior where either the (sole) operand happens or nothing happens\nloop\nSpecifies a repetition structure within the combined fragment\npar\nSpecifies parallel operations inside the combined fragment\ncritical\nSpecifies a critical section within the combined fragment\n", "page": 189, "type": "text", "section": "Page 189"}
{"text": "166\u2002 \u2022\u2002 Software Engineering Design\ufeff\n\u00ad\nfollows: loop (min, max), where min specifies the minimum bound of the loop and \nmax represents the maximum bound of the loop. When these are omitted, then it implies \nthat min = 0 and max = infinity. In these cases, the loop typically includes a separate inter-\naction constraint, called a Guard, which evaluates to true or false. The loop will continue \nonly if the guard evaluates to true during execution regardless of the minimum number \nof iterations specified in the loop. The Guard interaction constraint is in the format of \n[<<constraint>>]. Guards can also be used in other interactions throughout sequence dia-\ngrams. For example, in Figure\u00a05.5, a Guard is used to explicitly specify the condition used \nto determine alternate paths in the alt combined fragment.\nDesign Components Using Design Patterns\nIn Chapters 3 and 4, the concept of patterns was introduced with an emphasis on software \narchitecture. During detailed design, a wide variety of design patterns exists for providing \nsolutions to recurring problems in the form of structural designs for components. Design \npatterns are recurring solutions to object-oriented design problems in a particular context. \nWhen used effectively, they can help improve efficiency in the detailed design effort by pro-\nviding high-quality reusable solutions that can be applied in many practical applications. \nTo properly and consistently capture design patterns, detailed descriptions are required to \nidentify the patterns, the problem that they solve, and their solution approach.\nDesigning high-quality object-oriented software is hard. Typically, designers of systems \nthat evolve gracefully have time to develop their skills through years of experience. This \nexperience gives designers the ability to identify classes with the right granularity, appro-\npriate relationships among the classes, and inheritance hierarchies that are reusable\u00ad\n and \nmaintainable. Experience also allows designers to evaluate the effects of their design deci-\nsion in the overall development of a working software system. The more we experience \nthe design of systems, the more knowledge and skill we acquire to design better systems. \nUnfortunately, for novice designers, this experience can take years to acquire. Because \ndetailed design entails a great deal of problem-solving skills, novice designers can spend \nmuch time trying to determine how to efficiently structure their designs in a way that the \nsystem can exhibit a certain level of quality. Fortunately, many of the common design prob-\nlems\u2014those recurring over and over in different systems\u2014have been solved already and \ncaptured as design patterns. Design patterns are experience captured in a well-structured \nand consistent format; they provide blueprints that guide designers to solve specific prob-\nlems by specifying important design characteristics, such as the classes that need to be \ncreated, their level of granularity, their relationships, and how all these classes and rela-\ntionships work together to solve a problem. They provide this information in a generic \nsense, so that they can be reused many times over, in different software \u00ad\nsystems, without \never doing it the same way twice.\nThere are many benefits from studying and applying design patterns. First, they can \nhelp designers and programmers become more efficient. It is now common to find built-in \nsupport for design patterns in today\u2019s popular language frameworks, such as Java and the \n.NET framework. Therefore, knowing about design patterns can help programmers come \n", "page": 190, "type": "text", "section": "Page 190"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 167\nup to speed quicker in these environments and enable them to quickly apply them to par-\nticular problems. In the work reported by Walter Tichy (2010), strong empirical evidence \nsuggested that merely documenting design patterns can already lead to an increase in pro-\ngrammer productivity and reduce errors during maintenance tasks. Design patterns also \nhelp enhance communication during the problem-solving process by providing \u00ad\nabstractions \nof problem-solving techniques. Tichy\u2019s work also shows evidence of improvements in \n\u00ad\ncommunication when team members shared design patterns knowledge. In his work, it was \nnoticed that weaker designers catch up with more experienced ones when using patterns. \nDesign patterns also serve as starting point for the design (or redesign) effort of software \ncomponents; therefore, they help reduce the time to design new systems. Finally, design \n\u00ad\npatterns provide examples of the application of many object-oriented design principles; \ntherefore, they can serve as practical methods for learning object-oriented design techniques.\nArchitectural versus Design Pattern\nBefore diving deeply into the topic of design patterns in the next chapters, it is impor-\ntant to make a clear distinction between (detailed) design patterns\u2014the topic of the next \ntwo chapters\u2014and architectural (design) patterns, which were covered in Chapter\u00a0 4. \nAs\u00a0mentioned\u00ad\n in Chapters 3 and 4, architectural patterns serve mostly at higher levels \nof abstraction to identify the major components and interfaces of the software system. \nTherefore, their application is too abstract to be translated directly to code. In contrast, \ndesign patterns are detailed solutions to particular problems that can be directly trans-\nlated to code. Architectural patterns have a direct effect on the architecture of a software \nsystem and are associated to particular application domains (e.g., interactive systems), \nwhereas design patterns are independent of a particular application domain (Buschmann \net al.\u00a01996). These differences should become evident in Chapters 6 and 7.\nClassification of Design Patterns\nWhen first studying design patterns, it is important to understand what each pattern \ndoes and how it does it. In the influential work presented by Gamma, Helm, Johnson, \nand Vlissides (1995), design patterns are classified based on purpose and scope. The pur-\npose of a design pattern identifies the functional essence of the pattern; therefore, it serves \nas fundamental differentiation criteria between design patterns. Three different purposes \nare identified by the Gang of Four (GoF), including creational, structural, and behavioral. \nCreational design patterns are the ones that attempt to efficiently manage the creation \nor creational process of objects in a software system. A common characteristic of cre-\national pattern is the presence of creational classes and product classes. In some cases, \nthe creational and product classes are combined into one class. Creational patterns are \noverall known for abstracting the instantiation process of one or more objects. Structural \ndesign patterns are the ones that attempt to create larger structures from the composition \nof existing classes, objects, or other structures. Finally, behavioral design patterns are con-\ncerned with how classes and object interact, the variation of behavior, and the assignment \n", "page": 191, "type": "text", "section": "Page 191"}
{"text": "168\u2002 \u2022\u2002 Software Engineering Design\ufeff\nof responsibility between objects. The purpose criteria apply to a large number of patterns; \ntherefore, it serves well for classifying a large variety of design solutions.\nWhile the purpose criteria of design patterns captures the overview of what the pattern \ndoes, the scope of a design pattern captures whether the design pattern primarily applies \nto classes or objects. Class patterns apply primarily to classes by defining the relationship \nbetween classes and subclasses, at compile time, via inheritance. Object patterns apply \nprimarily to objects by defining the pattern\u2019s relationship between objects, at run time, \nvia object composition. Since the relationships in object patterns are defined via object \ncomposition, they result in more dynamic designs and flexible designs. Since the large \nmajority of design patterns rely on inheritance, it can be difficult to draw the line to dif-\nferentiate between class patterns and object patterns. Furthermore, some design patterns \ncan be applied in different ways, so that the same pattern can be classified as class \u00ad\npattern \nor object pattern, depending on the design implementation. Typically, the distinction \nbetween class patterns and object patterns becomes clearer after having experience with \npatterns for some time. When it comes to scope classification, the most efficient differen-\ntiation criteria lies in the focus that the design pattern puts on inheritance versus object \ncomposition. Design patterns that place focus on inheritance as key relationship for the \npattern are \u00ad\nclassified as class patterns, whereas design patterns that place focus on object \ncomposition are classified as object patterns.\nPurpose and scope can be used in combination to fully classify design patterns. For \nexample, design patterns can be classified as class creational or object creational, class \nstructural or object structural, or class behavioral or object behavioral. In addition to \npurpose, scope, and their combination, many other types of classification and domains \nhave been identified throughout the years. Example of these include design patterns \nin real-time programming (Douglass 2002), patterns in web applications (Vora 2009), \nand patterns for parallel software (Ortega-Arjona 2010).\nDocumenting Design Patterns\nDocumenting design patterns in a consistent format is important to the dissemination of \npattern knowledge. Although design patterns can be documented in many ways, the GoF \nidentified 13 categories that can be used as standard for fully documenting design pat-\nterns. Together, these categories provide detailed information of existing design patterns \nand provide direction for documenting future patterns. In practical applications, well-\ndocumented patterns are important because they allow designers to quickly study a design \npattern to determine its applicability in a particular scenario. Well-documented patterns \nalso provide the means to compare patterns and evaluate important characteristics, such \nas consequences, that can help designers in selecting the best pattern for the problem at \nhand. The 13 categories for documenting patterns proposed by the GoF and their descrip-\ntions are presented in Table\u00a05.4.\nChapters 6 and 7 provide throughout coverage of common design patterns used during \nthe detailed design activity. For extensive coverage of design patterns, readers are encour-\naged to study the original design patterns book by the GoF (Gamma et al. 1995).\n", "page": 192, "type": "text", "section": "Page 192"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 169\nDOCUMENT THE SOFTWARE DESIGN\nDocumentation of a project\u2019s software design is captured in the software design docu-\nment (SDD), a document that contains the designs or plans of the software to be imple-\nmented. From the time the SDD is written in the design phase, it may be used by various \nstakeholders and until the end of the software life cycle. During the code and unit test \nphase, it may be referred to in order to construct the software, to develop unit test plans, \nor to write script files and driver code to automate the running of tests. System integrators \nmay use the SDD in the system integration test phase to better plan integration activities, \nand maintainers will use and possibly have to update the SDD in the maintenance phase. \nTo provide relevant information to the stakeholders, the SDD must contain certain items \nthat document everything that goes into the design of the software. The proposed con-\ntents of an SDD are as shown in Table\u00a05.5 (IEEE 2009).\nProviding this SDD information is important not only to communicate the design to \nstakeholders but also to properly maintain the SDD to ensure the version stakeholders \nreceive is current and consistent. The body section of the SDD contains architectural and \ndetailed design elements, presented in a format specified by design viewpoints. Design \nviewpoints dictate the way design views are presented within an SDD, and each design \nview has exactly one design viewpoint to go along with it. The IEEE (2009) recommends \neach design viewpoint specification to contain (among others) the following information:\nTABLE\u00a05.4\nCategories and Descriptions for Documenting Design Patterns\nCategory\nDescription\nName and classification\nThe unique pattern name that reflects the essence of the patterns and its classification\nIntent\nDescribes the purpose of the pattern in such way that it is clear what types of design \nproblems the pattern solves, what the pattern does, its rationale and intent\nAlso Known As\nA list of alternate well-known names for the pattern\nMotivation\nAn example scenario that serves as motivation for the application of the pattern\nApplicability\nDescribes the situations, or design problems, that lend themselves for the \napplication of the design pattern; provides examples of poor designs that can \nbenefit from the pattern and ways for identifying these situations\nStructure\nProvides a structural (e.g., UML class diagram) view of the design pattern\nParticipants\nList the classes and objects required in the design pattern and their responsibilities\nCollaborations\nProvides information about how the participants work together to carry out \ntheir\u00a0responsibilities\nConsequences\nDescribes the effects of the design pattern, good or bad, on the software solution\nImplementation\nProvides information and techniques for successfully implementing the design pattern\nSample Code\nProvides sample code that demonstrates how to implement the design pattern in \ndifferent programming languages\nKnown Uses\nProvides examples of real systems that employ the design pattern\nRelated Patterns\nProvides information about other design patterns that are related or that can be \nused in combination with the design pattern\n", "page": 193, "type": "text", "section": "Page 193"}
{"text": "170\u2002 \u2022\u2002 Software Engineering Design\ufeff\n\u2022\t Viewpoint name\n\u2022\t Relevant design concerns\n\u2022\t Design elements (e.g., elements of design language)\n\u2022\t Analytical methods or other operations for supporting the view\n\u2022\t Viewpoint authorship or citation\n\u2022\t Patterns, heuristics, or other guidelines used in the creation of the viewpoint\nThe specification of design viewpoints can be done fully in the SDD or incorporated \nby reference (IEEE 2009). Once specified, viewpoints can be used throughout the SDD \nto document software designs. The SDD should also present the rationale for selecting \nthe specific design viewpoint. Long after the design phase is complete, the SDD will be \nreferred to several times during the software life cycle. Therefore, it is useful if the rationale \nfor making certain design decisions is included in the SDD so developers can gain addi-\ntional insight into why decisions were made for certain parts of the software design. Design \nrationale includes justification for choosing a particular design approach and can be found \nin commentary throughout the SDD. Examples of design rationale include design issues \nraised in response to design concerns of stakeholders, trade-offs evaluated, criteria used \nto make decisions, and design options considered (IEEE 2009). With this information, \na\u00a0sample table of contents for the SDD is provided in Table\u00a05.6.\nTABLE\u00a05.5\nSections of the Software Design Document\nSection\nDescription\nDate of issue and status\nDate of issue is the day on which the SDD has been formally released. Every time \nthe SDD is updated and formally released, there should be a new date of issue.\nScope\nScope provides a high-level overview of the intended purpose of the software. \nIt\u00a0sets a limit as to what the SDD will describe and defines the objectives of \nthe\u00a0software.\nIssuing organization\nIssuing organization is the company that produced the SDD.\nAuthorship\nAuthorship pertains to who wrote the SDD and certain copyright information.\nReferences\nReferences provide a list of all applicable documents that are referred to within the \nSDD. If there is a certain technology that is used within the design, it is important \nto refer to the corresponding documentation on that technology, so it may be \nreferenced. When reading the referenced documents, stakeholders may uncover \ninconsistencies in how the technology should be used and how it is used in the \nsoftware design.\nContext\nDescription of the context of the SDD.\nBody\nBody is the main section of the SDD where the design is documented. \nThis\u00a0is\u00a0where stakeholders look to understand the software and how it is to \nbe\u00a0constructed.\nSummary\nGlossary\nA glossary provides definitions for all software-related terms and acronyms used in \nthe\u00a0SDD.\nChange history\nChange history is a brief description of the items added to, deleted from, or \nchanged within the SDD.\n", "page": 194, "type": "text", "section": "Page 194"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 171\nInterface Control Document\nThe interface control document (ICD) is an important piece of documentation that serves as \na written contract between components of the system software as to how they communicate. \nThis document is usually intended to cover only the software components that are internal \nto the software development effort. Many times in software engineering, there exists a sys-\ntem in which two pieces of software need to communicate to share information or possibly \nto invoke function calls. For developers to write software, they need to know what to expect \nwhen asking for certain data or how to perform a particular action on another piece of soft-\nware. A classic example of this is a client\u2013server based system\u00ad\n. The\u00a0server may contain and \nmanage certain data, or it may provide a set of actions that a client may invoke. An ICD is \nmuch like documentation on how to speak a particular language. If\u00a0two pieces of software \ncannot speak the same language, they will not be able to communicate and a software sys-\ntem will not be able to work. ICDs can also be an important part of communication within \na single component of a software system. For instance, the example in Figure\u00a05.6 has two \nTABLE\u00a05.6\nSample Table of Contents for the Software Design Document\n1.\t Introduction\n\t\n1.1\t Date of Issue\n\t\n1.2\t Context\n\t\n1.3\t Scope\n\t\n1.4\t Authorship\n\t\n1.5\t Change history\n\t\n1.6\t Summary\n2.\t Software Architecture\n\t\n2.1\t Overview\n\t\n2.2\t Stakeholders\n\t\n2.3\t System Design Concerns\n\t\n2.4\t Architectural Viewpoint 1\n\t\n\t\n2.4.1\t Design View 1\n\t\n2.5\t Architectural Viewpoint 2\n\t\n\t\n2.5.1\t Design View 2\n\t\n2.6\t Architectural Viewpoint n\n\t\n\t\n2.6.1\t Design View n\n3.\t Detailed Design\n\t\n3.1\t Overview\n\t\n3.2\t Component Design Viewpoint 1\n\t\n\t\n3.2.1\t Design View 1\n\t\n3.3\t Component Design Viewpoint 2\n\t\n\t\n3.3.1\t Design View 2\n\t\n3.4\t Component Design Viewpoint n\n\t\n\t\n3.4.1\t Design View n\n4.\t Glossary\n5.\t References\n", "page": 195, "type": "text", "section": "Page 195"}
{"text": "172\u2002 \u2022\u2002 Software Engineering Design\ufeff\ndifferent kinds of interfaces. There is one interface between the client and server, and then \nthere are several interfaces that are just internal to the server.\nThe server may be running three different processes, but it could be thought of as one \ncohesive component in the entire software system. These two different kinds of interfaces \ndo not have to use the same kind of technology either. The interfaces described in an ICD \ncan be either proprietary, such as a company-developed protocol using Extensible Markup \nLanguage (XML), or something standard such as Simple Network Management Protocol \n(SNMP) or Common Object Request Broker Architecture (CORBA). However, the descrip-\ntions of the data contents or what actions to take will surely be proprietary. To make an \nICD effective, it must describe all the interfaces in as much detail as possible. ICDs can \ndetail, for example, which data item on a server corresponds with what screen element on a \nGUI. Messages can also be formed in an ICD to detail all items coming back from a server \nto a client. It is much of this content that makes the bulk of an ICD. However, other docu-\nments may be referenced so that developers can get a better understanding of the commu-\nnication process. For example, if a system uses SNMP, the ICD may reference the\u00a0Request \nfor Comments (RFCs) related to SNMP. This could further help a reader to understand \ncertain parts of the software as related to communications.\nSoftware Version Document\nThe software version description (SVD) is a document containing information about \nwhat is included in a software release, including different files, scripts, and executables. \nIt also contains information about how to build the code, how to set up a computer that \nwill host the software, and the software requirements for the host computer. The SVD is \nalso an important document that tracks what changes have been made between different \nreleases of software. It also details what problems might be encountered with a specific \nrelease of software and what problems have been fixed. Not every release of software is \ngoing to be perfect. Software can sometimes contain unfixed problems that go unidenti-\nfied even after testing. These problems are then often noticed by the end users who report \nthem to the software developers. To keep the customers satisfied, the software developers \nmust fix the problems noted in the most recent release and issue a new release with the \nfixes. In other cases, changes are made to the design and code to create different versions \nof the software for different customers. When these modifications result in changes to \n6HUYHU\n&OLHQW\u0003\n$\n%\n&\nFIGURE 5.6\nConceptual model for system interfaces.\n", "page": 196, "type": "text", "section": "Page 196"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 173\nthe design, the SVD must document the appropriate steps to build software versions, \nwhich requires inclusion of the appropriate software design.\nThe SVD will often contain a section called the version description. It is in this section that \nthe bulk of the material concerning the new release of software is documented. Even though \nthis document may not be released to a customer, it could still prove to be very useful for \ninternal tracking of different releases of software. The first section of the version description \nis the inventory of software contents. This part lists all the files, scripts, and executables that \nhave gone into making the software build or are an output of the build process.\nThe section after the inventories of the materials released and software contents is the list \nof changes installed. As previously stated, these could either be fixes to problems identi-\nfied in previous releases or entirely new capabilities. Installation instructions detail any \nnecessary steps it takes to install the software to properly run on the host computers. The \nSVD also lists any potential problems that may be encountered when using the software or \nknown and verified errors for which developers have yet to find a solution.\nMONITOR AND CONTROL IMPLEMENTATION\nDetailed design synchronicity is concerned with the degree of how well detailed designs \nadhere to the software architecture and how well software code adheres to the detailed \ndesign. Detailed designs provide a design structure carefully crafted to ensure desired \ncharacteristics of the software, such as reusability or maintainability. Typically, soft-\nware engineers are good at respecting detailed design decisions early on in a project life \ncycle; however, as the development process continues, detailed designs are more prompt \nto deviations during construction. For any software architecture and detailed design \nto result in a successful system implementation, the construction phase must be syn-\nchronized with the software products resulting from both efforts. Therefore, the engi-\nneering team must ensure that detailed design decisions are enforced throughout the \nconstruction phase. Particular attention needs to be paid to design synchronicity when \nprojects enter the maintenance phase or when new engineers are brought into the project. \nSimilarly to achieving architectural design synchronicity, processes must be in place and \nenforced to ensure that overall design synchronicity is high.\nCHAPTER SUMMARY\nThe detailed design activity begins after the software architecture is specified, reviewed, \nand approved by all stakeholders in the project. The detailed design activity corresponds \nto a microdesign view of the structure and behavior of the software system and is the \nlast major effort before software construction begins. IEEE (1990) defines detailed design \nas \u201cthe process of refining and expanding the preliminary design phase of a system or \n", "page": 197, "type": "text", "section": "Page 197"}
{"text": "174\u2002 \u2022\u2002 Software Engineering Design\ufeff\ncomponent to the extent that the design is sufficiently complete to be implemented.\u201d That \nis, the process of refining the software architecture to reach a point where construction can \nbegin. It is important to note that most of the detailed design activities deal directly with \naddressing functional requirements of the system. The detailed design process requires \ndesigners to understand the architecture and requirements before creation of detailed \ndesigns. Detailed design decisions can significantly shape the system\u2019s quality properties; \ntherefore, they must exist within the bounds of the software architecture. In some cases, \nwhere modeling tools are used to generate code, detailed designs can also have significant \nimpact on the quality properties of the construction phase. Once created, detailed designs \ncan be documented together with architectural design to form the software design docu-\nment, which is reviewed and approved before construction begins. The design document \nestablishes the general framework of reference for all construction work; therefore, policies \nmust be in place to maintain synchronicity between the design document and construc-\ntion work. Upon completion of the detailed design activity, the system\u2019s design is suffi-\nciently complete so that it can be formally documented, reviewed, and approved by the \nsystem\u2019s stakeholders, which marks the end of the design phase.\nREVIEW QUESTIONS\n\t\n1.\tWhat is detailed design, and how does it differ from architectural design?\n\t\n2.\tExplain the relationship among requirements, architecture, detailed design, and \nconstruction.\n\t\n3.\tWhat key tasks are performed during detailed design? Explain.\n\t\n4.\tWhat steps are involved in the detailed design process?\n\t\n5.\tWhat are derived requirements, and how do they play a role during detailed design?\n\t\n6.\tWhat is the role of software architecture during detailed design? Can detailed \ndesign succeed without architecture? Explain.\n\t\n7.\tExplain the concept of interface design during detailed design.\n\t\n8.\tIn object-oriented systems, what is the difference between a class and an object?\n\t\n9.\tWhat is the difference between concrete and abstract classes?\n\t 10.\tExplain the following concepts:\n\t\na.\t Interfaces\n\t\nb.\t Types and subtypes\n\t\nc.\t Dynamic binding\n\t\nd.\t Polymorphism\n\t 11.\tCompare and contrast the OCP, LSP, and ISP.\n\t 12.\tWhy are programming styles important during detailed design? Give examples of \nsome styles used during detailed design.\n\t 13.\tExplain the concepts of combined fragments, operators, and guards in interaction \n\u00ad\ndiagrams. Give an example of each.\n\t 14.\tWhat is the difference between architectural patterns and detailed design patterns?\n", "page": 198, "type": "text", "section": "Page 198"}
{"text": "Principles of Detailed Design\u2002 \u2022\u2002 175\n\t 15.\tWhat are the sections of the software design document? Explain each.\n\t 16.\tWhat is the interface control document, and why is it necessary in practical develop-\nment efforts?\n\t 17.\tWhat is the version control document, and how does it relate to the software design?\nCHAPTER EXERCISES\n\t\n1.\tCreate a class diagram and sequence diagram to design and validate the following \nsystem. The system will consist of a traffic light object that communicates with three \nlight bulb objects. Each light bulb object cannot exist without the traffic light object. \nAll light bulb objects have capabilities to turn green, yellow, and red. In fact, all light \nbulb objects are identical, except that they communicate with different light bulb \nhardware controllers to turn specific light bulbs on and off. All light bulb objects \nmust support a turnOn(), turnOff(), and setColor(int color) method which will turn \nthe light bulb on, off, and set the color, respectively. The system will use a custom \ntimer object for managing the transition of the light bulbs and a sensor object to \ndetect when cars arrived at the traffic light system. Both timer and sensor are part of \nthe traffic light system but are also used in other sections of the system, so their life-\ntime is not controlled by the traffic light object. When the sensor object fires off, the \ntraffic light object will activate the green light and the timer. When the timer expires, \nthe traffic light object will deactivate the green light and activate the yellow light. It \nwill also activate the timer again. When the timer expires, the traffic light system will \ndeactivate the yellow light and activate the red light.\nREFERENCES\nBooch, Grady, James Rumbaugh, and Ivar Jacobson. The Unified Modeling Langauge User Guide, 2d ed. Addison-\nWesley Professional, 2005.\nBuschmann, Frank, Regine Meunier, Hans Rohnert, Peter Sommerlad, and Michael Stal. Pattern-Oriented \nSoftware Architecture: A System of Patterns. West Sussex, UK: Wiley, 1996.\nClements, Paul, Felix Bachmann, Len Bass, David Garlan, James Ivers, Reed Little, Robert Nord, and Judith Stafford. \nDocumenting Software Architectures. Boston, MA: Addison Wesley, 2002.\nClements, Paul, Rick Kazman, and Mark Klein. Evaluating Software Architectures. Addison Wesley, 2001.\nDouglas, Bruce P\n. Doing Hard Time: Developing Real-Time Systems with UML, Objects, Frameworks, and Patterns. \nAddison-Wesley Professional, 1999.\nDouglass, Bruce P. Real-Time Design Patterns: Robust Scalable Architecture for Real-Time Systems. Addison-Wesley \nProfessional, 2002.\nGamma, Erich, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns: Elements of Reusable \nObject-Oriented Software. Boston: Addison-Wesley, 1995.\nIEEE. \u201cIEEE Standard for Information Technology-Systems Design-Software Design Descriptions.\u201d 2009. \nhttp://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=5167255.\nIEEE. \u201cIEEE Standard Glossary of Software Engineering Terminology.\u201d IEEE, 1990, p. 34.\n", "page": 199, "type": "text", "section": "Page 199"}
{"text": "176\u2002 \u2022\u2002 Software Engineering Design\ufeff\nLiskov, Barbara, and John Guttag. Program Development in Java: Abstraction, Specification, and Object-Oriented \nDesign. Boston: Addison-Wesley, 2000.\nMarin, Robert C. Agile Software Development: Principles, Patterns, and Practices. Upper Saddle River, NJ: \nPrentice Hall, 2003.\nMeyer, Bertrand. Object-Oriented Software Construction, 2d ed. Upper Saddle River, NJ: Prentice Hall, 1997.\nOrtega-Arjona, Jorge L. Patterns for Parallel Software Design. West Sussex, UK: Wiley, 2010.\nPressman, Roger S. Software Engineering: A Practitioner\u2019s Approach, 7th ed. Chicago: McGraw-Hill, 2010.\nSommerville, Ian. Software Engineering, 9th ed. Boston: Addison Wesley, 2010.\nTichy, Walter. Making Software: What Really Works, and Why We Believe It. Sebastopol, CA: O\u2019Reilly Media, \n2010.\n\u201cUML 2.3 Superstructure.\u201d Vers. 2.3. Object Management Group. May 2010. Available at: http://www.omg.org\nVermeulen, Allan, Felix Bachmann, Len Bass, David Garlan, James Ivers, Reed Little, Robert Nord, and \nJudith\u00a0Stafford. The Elements of Java Styles. Cambridge, UK: Cambridge University Press, 2000.\nVora, Pawan. Web Application Design Patterns. Burlington, MA: Morgan Kaufmann, 2009.\n", "page": 200, "type": "text", "section": "Page 200"}
{"text": "177\n6\nCreational Design Patterns \nin Detailed Design\nCHAPTER OBJECTIVES\n\u2022\t Understand the importance and role of creational design patterns in \ndetailed design\n\u2022\t Identify, understand, and model common creational design patterns\n\u2022\t Become proficient in implementing models of creational design patterns\n\u2022\t Understand the benefits of creational patterns when implementing \nsoftware systems\nCONCEPTUAL OVERVIEW\nDuring detailed design, software engineers spend a great deal of time devis-\ning component design solutions that fill in the gaps in architectural designs \nand provide the necessary internal design of components and their inter-\nfaces to achieve system functionality. At the detailed design level, common \npatterns in object-oriented designs have emerged that provide detailed \ndesign solutions to problems that recur many times over in different systems\u00ad\n. \nA\u00a0 particular problem in these systems involves the efficient creation\u00ad\n of \nobjects so that concepts highlighted in previous chapters (i.e.,\u00a0interfaces, \ntypes, dynamic binding, and polymorphism) can be used effectively to \ngenerate reusable and maintainable software. Creational design patterns \nhelp identify problems that deal with creating quality detailed designs \nthat are efficient in the creation of object in the system. They prescribe the \nclasses required for their design solution and interrelationships required \nto support object creation. These patterns allow designers to quickly and \n", "page": 201, "type": "text", "section": "Page 201"}
{"text": "178\u2002 \u2022\u2002 Software Engineering Design\ufeff\nsystematically identify structural layouts of systems (or subsystems) and provide avenues \nfor examining system interactions and quality evaluation within the operational system. \nThis chapter explores several well-established creational design patterns and examines the \nproblems they are designed to address, together with their exhibited quality attributes. \nIdentifying and designing using creational design patterns can improve the efficiency of \nthe development process and the quality of the final system.\nCREATIONAL DESIGN PATTERNS\nCreational design patterns are patterns for abstracting and controlling the way objects are \ncreated in software applications. They play a key role in the design of systems by making \nthem independent of how objects in the system are created, composed, and represented \n(Gamma, Helm, Johnson, and Vlissides 1995). Therefore, parts of the system responsible \nfor creating (or instantiating) objects do so through a common creational interface without \nknowledge of how the actual object or group of objects are created. In addition, by control-\nling the creational process with a common interface, enforcing creational policies becomes \neasier, therefore giving the system the ability to create product objects that share a com-\nmon interface but vary widely in structure and behavior. Examples of creational patterns \ninclude the abstract factory, factory method, builder, prototype, and singleton.\nABSTRACT FACTORY\nThe abstract factory is an object creational design pattern intended to manage and encap-\nsulate the creation of a set of objects that conceptually belong together and that represent a \nspecific family of products. According to the Gang of Four (Gamma et al. 1995, p. 87), the \nintent of the abstract factory is to\nProvide an interface for creating families of related or dependent objects without specifying \ntheir concrete classes.\nIn the abstract factory pattern, the terms family of products or family of objects are used \nto denote a group of objects that belong together and therefore must be created together. \nWhen designing software that uses a group of objects that need to be created and used \ntogether, problems can arise when there is no consistent way for managing the creation \nof these objects. For example, consider two distinct families of computers: one represent-\ning standard computers made up of standard computer parts; and another representing \nadvanced computers made up of advanced computer parts. Assume that the family of \nstandard computers can be composed only of standard computer parts, such as a stan-\ndard monitor, standard keyboard, and standard CPU, and that the family of advanced \n", "page": 202, "type": "text", "section": "Page 202"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 179\ncomputers can consist only of advanced computer parts, such as an advanced monitor, \nadvanced keyboard, and advanced CPU. When left unmanaged, designing software that \ninstantiates both standard and advanced computers can be prone to various problems. \nFirst, there is the possibility that advanced computer objects can be created using standard \nproducts or vice versa, that is, standard computer objects created using advanced com-\nputer parts products. Moreover, without a standardized common interface identified for \nthe different computer parts, the code inside the computer classes would be required to \nknow about the correct computer parts type to use; therefore, the addition of new prod-\nucts or new product types would require changing the code inside the computer classes, a \nclear violation of the open\u2013closed principle discussed in Chapter 5. These problems result \nin code that is hard to maintain and reuse. The abstract factory design pattern addresses \nthese problems by encapsulating the creation of these families of products in such a way \nthat they can be interchangeable at run time and by ensuring that products that belong to \na specific group, or family, are instantiated together.\nProblem\nA computer store needs stand-alone software that keeps track of computer inventory, which \nincludes computers and different computer parts made by different hardware manufactur-\ners. The software for the computer store needs capabilities for displaying information about \ncomputer parts, including information from the manufacturer\u2019s site and various other sites \nthat contain customer satisfaction reviews and other relevant information. Therefore, each \ncomputer part object needs to be capable of extracting information in real time from a list \nof predefined remote locations, of aggregating the information, and of providing this infor-\nmation upon request. Upon requesting the information for a particular computer, all com-\nputer part objects communicate over the network and find out the latest comments and \nstatistics about a component from all predefined sources and make this information avail-\nable to the requesting object. Initially, the store supports only two types of computers: stan-\ndard computers and advanced computers, composed of standard and advanced computer \nparts (i.e., CPU, monitor, and mouse), respectively. Due to store policy, standard computers \ncannot be composed of advanced computer parts and advanced computers cannot be com-\nposed of standard computer parts. The software solution needs to provide a maintainable \nand modifiable design for creating these families of objects, to support easy addition of new \nfamilies of computers, and to promote consistency with computer products.\nStructure\nThe general and applied structure for the abstract factory design pattern is presented in \nFigure\u00a06.1. As seen, the abstract factory is presented in general and applied form, and for \nsimplicity the details of both abstract and concrete computer part classes are omitted \nin the applied form. The general structure of the abstract factory design pattern serves \nas a \u00ad\nblueprint that depicts the participants and relationships required to design abstract \n\u00ad\nfactories; it presents the essence of the pattern, which needs to be fitted for the particular \n", "page": 203, "type": "text", "section": "Page 203"}
{"text": "180\u2002 \u2022\u2002 Software Engineering Design\ufeff\nproblem at hand. The applied view of Figure\u00a06.1 presents an instantiation of the general \nstructure for depicting the solution for the particular computer store problem, which \nconsists of abstract products (e.g., monitor), concrete products (e.g., standard monitor), \nabstract creators (e.g.,\u00a0computer parts factory), and concrete creators (e.g., standard com-\nputer parts factory). These participants are interrelated via realization and association rela-\ntionships. From this example, it should be evident how a new family of computer parts can \nbe added to the design by adding the required pattern classes that make up the new family \nof computers.\nImplementing the abstract factory design pattern can be confusing because of the num-\nber of classes required. However, when looking closely at the Unified Modeling Language \n(UML) diagram for the application view, it is evident that regardless of the number of \ncomputer factories or computer products, the structural relationship among these classes \n<<interface>>\nAbstractFactory\n<<interface>>\nComputerPartsFactory\n+createProductA()\n+createProductB()\n+createProductA()\n+createProductB()\n<<interface>>\nAbstractProductA\n<<interface>>\nCPU\nConcreteProductA1\nConcreteFactory1\n+createMonitor(): Monitor*\n+createCPU(): CPU*\n+createKeyboard(): Keyboard*\n+createMonitor(): Monitor*\n+createCPU(): CPU*\n+createKeyboard(): Keyboard*\n+createProductA()\n+createProductB()\nConcreteFactory2\nConcreteProductB1\nConcreteProductA2\n<<interface>>\nMonitor\nComputer\n<<interface>>\nKeyboard\nConcreteProductB2\nAdvancedKeyboard\nAdvancedMonitor\nAdvancedCPU\nStandardKeyboard\nStandardMonitor\nStandardCPU\nAdvancedComputerPartsFactory\n+createMonitor(): Monitor*\n+createCPU(): CPU*\n+createKeyboard(): Keyboard*\nStandardComputerPartsFactory\nClient\n<<interface>>\nAbstractProductB\nGeneral View\nApplied View\nFIGURE 6.1\nAbstract factory design pattern.\n", "page": 204, "type": "text", "section": "Page 204"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 181\nis always the same. This is true for all other patterns studied throughout this and other \nchapters. Therefore, a step-by-step approach can be taken to design abstract factories:\n\t\n1.\tDesign the product interfaces (e.g., CPU, monitor, keyboard).\n\t\n2.\tIdentify the different families or groups required for the problem (e.g., standard and \nadvanced computers).\n\t\n3.\tFor each group identified, design concrete products that realize the respective prod-\nuct interface (e.g., standard monitor vs. advanced monitor) identified in Step 1.\n\t\n4.\tCreate the factory interface (e.g., ComputerPartsFactory). The factory interface \ncontains n interface methods, where n is the number interfaces created in Step 1.\n\t\n5.\tFor each group identified in Step 2, create concrete factories that realize the factory \ninterface created in Step 4.\n\t\n6.\tCreate the factory client (e.g., Computer) which is associated with both products \nand factory interfaces created in Steps 1 and 4, respectively.\nAbstract factory designs contain two fundamental sets of class designs: products and \n\u00ad\nfactories. Once both products and factories portions of the design are complete, dynamic \nbinding can be used at run time to allow the computer client to create different computer \nobjects (e.g., standard vs. advanced computers) and use them throughout programs without \nactually knowing the specific type of the object. This way, adding other computer types to \nthe system can be done by extending the design and not by modifying already working code.\nImplementation\nWhen studying the abstract factory (and all other design patterns), it is important that \nUML models are translated to code, compiled, and executed. When necessary, it is also \nhelpful to step through the code with a debugger to keep track of dynamic binding \nthroughout the software\u2019s execution. This provides additional insight and helps further \nthe understanding of both concepts and benefits of using a particular design pattern. Once \nthe structural design of the abstract factory is created, its translation to code is straight-\nforward. Listing\u00a06.1 presents the C++ implementation for the ComputerPartsFactory class.\nAs seen, the ComputerPartsFactory abstract class simply defines interface methods \nrequired for creating each computer part designed for the system. Therefore, there is a \none-to-one relationship between interface methods and product interfaces. Since the \ncode for the abstract factory interface is presented in C++, each interface method is \ndefined as pure virtual, which includes the virtual keyword and is set to 0. In the \nJava programming language, the ComputerPartsFactory would be defined as a \nJava interface, using the interface keyword. Once the interface for the computer \nparts factory is established, all other concrete factories can be implemented to create \nproducts of specific computer types upon request. Consider the implementation for \ncreating advanced computer parts, where the advanced computer part factory instan-\ntiates advanced computer products. The header file for the advanced computer parts \ncomputer factory is presented in Listing 6.2.\n", "page": 205, "type": "text", "section": "Page 205"}
{"text": "182\u2002 \u2022\u2002 Software Engineering Design\ufeff\nAs seen, the AdvancedComputerPartsFactory realizes the ComputerParts-\nFactory interface by inheriting from it and defining concrete methods for each of its \ndefined interface methods. Each interface method is implemented in terms of advanced \ncomputer parts, such that the createMonitor() method returns an instance of \ntype AdvancedMonitor, the createKeyboard() returns an instance of type \nAdvancedKeyboard, and so on. This behavior is presented in the source file for the \nAdvancedComputerParts factory, as presented in Listing 6.3.\nListing 6.2: C++ Header File for the Advanced\u00a0Computer Parts Concrete Factory\n// Forward references\nclass Monitor;\nclass Keyboard;\nclass Cpu;\n// Concrete advanced computer parts factory.\nclass AdvancedComputerPartsFactory : public ComputerPartsFactory {\npublic:\n\t // Create and return an advanced monitor.\n\t Monitor* createMonitor();\n\t // Create and return an advanced keyboard.\n\t Keyboard* createKeyboard();\n\t // Create and return an advanced cpu.\n\t Cpu* createCpu();\n};\nListing 6.1: C++ Code for the Computer Parts Factory Interface\n// Computer parts factory interface.\nclass ComputerPartsFactory {\npublic:\n\t // Define the interface to create a monitor object.\n\t virtual Monitor* createMonitor(void) = 0;\n\t // Define the interface to create a keyboard object.\n\t virtual Keyboard* createKeyboard = 0;\n\t // Define the interface to create a CPU object.\n\t virtual Cpu* createCpu = 0;\n};\n", "page": 206, "type": "text", "section": "Page 206"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 183\nIn Listing 6.3, it is assumed that the concrete products for the advanced computer parts \nfactory have been defined. In fact, before any concrete computer parts factory code can \nbe compiled, its parts need to be defined. Using this pattern, the implementation for the \nstandard computer parts factory is similar to the advanced one, but instead of creating \nadvanced concrete products it implements the creational methods in terms of standard \ncomputer parts products. Listings 6.4 and 6.5 present the generated code for the UML \nmodel of the standard computer parts factory together with its implementation. In a simi-\nlar fashion, the creation of all other required computer parts factories in the system can be \ndesigned and implemented the same way.\nThe final piece of the abstract factory design pattern includes the factory client object. \nIn this example, the client is a computer object that is composed of different computer \npart products. The concept employed in this example is that computers are composed of \ndifferent computer parts; therefore, by configuring computer objects with computer parts \nfactories they can delegate the creation of computer parts to run-time objects mapped \nusing dynamic binding. This allows the creational code for computer objects to be open to \nextension but closed for modification. The header and source code for the Computer class \nare presented in Listings 6.6 and 6.7.\nListing 6.3: C++ Source File for the Advanced\u00a0Computer\u00a0Parts Concrete Factory\n#include \u201cAdvancedComputerPartsFactory.h\u201d\n#include \u201cAdvancedMonitor.h\u201d\n#include \u201cAdvancedKeyboard.h\u201d\n#include \u201cAdvancedCpu.h\u201d\n// Create and return an advanced monitor.\nMonitor* AdvancedComputerPartsFactory::createMonitor() {\n\t // Caller is responsible for cleaning up the memory.\n\t return new AdvancedMonitor;\n}\n// Create and return an advanced keyboard.\nKeyboard* AdvancedComputerPartsFactory::createKeyboard() {\n\t // Caller is responsible for cleaning up the memory.\n\t return new AdvancedKeyboard;\n}\n// Create and return an advanced cpu.\nCpu* AdvancedComputerPartsFactory::createCpu() {\n\t // Caller is responsible for cleaning up the memory.\n\t return new AdvancedCpu;\n}\n", "page": 207, "type": "text", "section": "Page 207"}
{"text": "184\u2002 \u2022\u2002 Software Engineering Design\ufeff\nListing 6.4: C++ Header File for the Standard\u00a0Computer\u00a0Parts Concrete Factory\n// Forward references\nclass Monitor;\nclass Keyboard;\nclass Cpu;\n// Concrete standard computer parts factory.\nclass StandardComputerPartsFactory : public ComputerPartsFactory {\npublic:\n\t // Create and return a standard monitor.\n\t Monitor* createMonitor();\n\t // Create and return a standard keyboard.\n\t Keyboard* createKeyboard();\n\t // Create and return a standard CPU.\n\t Cpu* createCpu();\n};\nListing 6.5: C++ Source File for the Standard Computer Parts Concrete Factory\n#include \u201cStandardComputerPartsFactory.h\u201d\n#include \u201cStandardMonitor.h\u201d\n#include \u201cStandardKeyboard.h\u201d\n#include \u201cStandardCpu.h\u201d\n// Create and return a standard monitor.\nMonitor* StandardComputerPartsFactory::createMonitor() {\n\t // Caller is responsible for cleaning up the memory.\n\t return new StandardMonitor;\n}\n// Create and return a standard keyboard.\nKeyboard* StandardComputerPartsFactory::createKeyboard() {\n\t // Caller is responsible for cleaning up the memory.\n\t return new StandardKeyboard;\n}\n// Create and return a standard CPU.\nCpu* StandardComputerPartsFactory::createCpu() {\n\t // Caller is responsible for cleaning up the memory.\n\t return new StandardCpu;\n}\n", "page": 208, "type": "text", "section": "Page 208"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 185\nThe key concept presented in Listing 6.6 is the reliance of the Computer class on four \ninterfaces, namely, the ComputerPartsFactory, Monitor, Cpu, and Keyboard \ninterfaces. This highlights a desirable attribute of component designs, which is to rely \non interfaces instead of on concrete implementations. Together, these interface refer-\nences (i.e., pointers) will hold the addresses of run-time objects that adhere to the par-\nticular interface. Therefore, upon creation, objects of the computer type will use these \ninterface references to save the addresses of concrete products created by a particular \ncomputer parts factory object. The implementation code for this behavior is presented \nin Listing 6.7.\nOnce a concrete factory is passed into the constructor of the Computer class, the respon-\nsibility for creating each product is delegated to the factory object. This way, a Computer \nobject can be created the same way for all computer types, simply by changing the factory \nListing 6.6: C++ Header File for the Computer Client\n// Forward references.\nclass ComputerPartsFactory;\nclass Monitor;\nclass Cpu;\nclass Keyboard;\nclass Computer {\npublic:\n\t // Constructor parameterized with a computer parts factory.\n\t Computer(ComputerPartsFactory* computerPartsFactory);\n\t // Display detailed information about the monitor.\n\t void displayMonitorInfo();\n\t // Display detailed information about the CPU.\n\t void displayCpuInfo();\n\t // Display detailed information about the keyboard.\n\t void displayKeyboardInfo();\n\t // Display computer cost.\n\t void displayCost();\n\t // All other computer methods.\n\t // Destructor needs to clean up memory.\nprivate:\n\t Monitor* _monitor; // Pointer to the monitor interface.\n\t Cpu* _cpu; // Pointer to the Cpu interface.\n\t Keyboard* _keyboard; // Pointer to the Keyboard interface.\n};\n", "page": 209, "type": "text", "section": "Page 209"}
{"text": "186\u2002 \u2022\u2002 Software Engineering Design\ufeff\nListing 6.7: C++ Source File for the Computer Client\n#include \u201cComputer.h\u201d\n#include \u201cComputerPartsFactory.h\u201d\n#include \u201cMonitor.h\u201d\n#include \u201cCpu.h\u201d\n#include \u201cKeyboard.h\u201d\n// Constructor\nComputer::Computer(ComputerPartsFactory* computerPartsFactory) {\n\t // Delegate the creation of the monitor object to the Factory.\n\t _monitor = computerPartsFactory->createMonitor();\n\t // Delegate the creation of the keyboard object to the Factory.\n\t _keyboard = computerPartsFactory->createKeyboard();\n\t // Delegate the creation of the Cpu object to the Factory.\n\t _cpu = computerPartsFactory->createCpu();\n}\n// Display detailed information about the monitor.\nvoid Computer::displayMonitorInfo() {\n\t // Display monitor\u2019s info.\n\t _monitor->displayInformation();\n}\n// Display detailed information about the CPU.\nvoid Computer::displayCpuInfo() {\n\t // Display Cpu\u2019s info.\n\t _cpu->displayInformation();\n}\n// Display detailed information about the keyboard.\nvoid Computer::displayKeyboardInfo() {\n\t // Display keyboard\u2019s info.\n\t _keyboard->displayInformation();\n}\n// Display computer cost.\nvoid Computer::displayCost() {\n\t // Use all computer products to compute total cost and display it.\n}\n", "page": 210, "type": "text", "section": "Page 210"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 187\nthat creates the products. Consider the code the computer store software that provides \nand manages inventory information using the ComputerStore class. Using the abstract \nfactory design pattern, the implementation code for displaying computer information is \npresented in Listing\u00a06.8. As seen, the display computer method is passed in a string to \ndetermine the type of computer to be displayed. Once the type is identified, the appropri-\nate computer parts factory object is instantiated and passed into the constructor of the \ncomputer object. From this point forward, all operations called on the computer object are \nimplemented in terms of the factory used to create its parts. Similarly, many different com-\nputer types can be supported by creating additional factories to parameterize computer \nobjects with newly supported computer types.\nListing 6.8: C++ Implementation of the Computer Store\n// Assume that the ComputerStore class has been defined and contains\n// the method displayComputer and the member attributes used below.\n// Method to display a computer\u2019s information.\nvoid ComputerStore::displayComputer(string type) {\n\t // Determine which computer needs to be created.\n\t if( type.compare(\u201cstandard\u201d) == 0 ) {\n\t \t // Create the standard computer factory object.\n\t \t computerPartsFactory = new StandardComputerPartsFactory;\n\t }\n\t else {\n\t \t // Create the advanced computer factory object.\n\t \t computerPartsFactory = new AdvancedComputerPartsFactory;\n\t }\n\t // Create the computer object using the appropriate factory.\n\t _computer = new Computer(computerPartsFactory);\n\t // Display the computer information, including its cost. This\n\t // information varies according to the factory object used to create\n\t // the computer.\n\t _computer->displayMonitorInfo();\n\t _computer->displayCpuInfo();\n\t _computer->displayKeyboardInfo();\n\t _computer->displayCost();\n\t // Do more stuff with the computer object here.\n\t // Clean up the all memory allocated when done.\n}\n", "page": 211, "type": "text", "section": "Page 211"}
{"text": "188\u2002 \u2022\u2002 Software Engineering Design\ufeff\nWhen applying the abstract factory design pattern, depending on the problem, a large \nnumber of classes may be required, causing confusion to those who are new to the pattern. \nHowever, it is important to keep in mind that the core classes and relationships identified in \nthe general structure of the pattern remain the same, regardless of the problem. That is, an \nabstract factory has one or more factory objects defined by an abstract factory interface and \none or more products defined by one or more product interfaces.\nBenefits\n\u2022\t Isolates concrete product classes so that reusing them becomes easier\n\u2022\t Promotes consistency within specific product families\n\u2022\t Adding new families of products, which requires no modification of existing code\nSkill Development 6.1: Abstract Factory Design Pattern\nUsing the UML tool of choice, replicate the UML model presented in Figure\u00a06.1 and \ngenerate code from the model. Using the Integrated Development Environment (IDE) \nof choice, fill in the gaps in the code generated using Listings 6.1 through 6.8 and com-\npile and execute the software. Once the software executes, go back to the UML model \nand add a third factory\u00ad\n, named SpecialComputerFactory, together with special \ncomputer products (e.g.,\u00a0SpecialMonitor, SpecialKeyboard, SpecialCpu). \nRepeat the code generation process, fill in the gaps of the new generated code, compile, \nand execute. When complete, explain the steps required to make this new modification \nand how the abstract factory design pattern made this change easy or hard.\nFACTORY METHOD\nThe factory method design pattern is a class creational pattern used to encapsulate and \ndefer object instantiation to derived classes. Structurally, the factory method can be mod-\neled as a simplified version of the abstract factory design pattern, since both patterns \nrequire \u00ad\ncreator and product interfaces. However, unlike the abstract factory design pat-\ntern, in which the creator objects (i.e., factories) are responsible for instantiating a plural-\nity of products that belong to a specific family type, creator objects in the factory method \ndesign pattern are responsible for the creation of a single product of specific type. Therefore, \nthe creator interface for the factory method design pattern provides only one creational \nmethod, whereas the creator interface for the abstract factory design pattern provides two \nor more creational methods. In addition, unlike the abstract factory design pattern, the \nfactory method design pattern defers object creation to subtypes that realize the creational \ninterface; a relationship specified by inheritance, therefore, the factory method design pat-\ntern is classified as a class creational design pattern as opposed to an object creational \n", "page": 212, "type": "text", "section": "Page 212"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 189\ndesign pattern. These fundamental differences are essential for understanding the differ-\nence between both \u00ad\npatterns. According to the Gang of Four (Gamma et al. 1995, p. 107), \nthe intent of the factory method is to\nDefine an interface for creating an object, but let subclasses decide which class to instantiate. \nFactory Method lets a class defer instantiation to subclasses.\nThe factory method design pattern provides the ability for designers to model and imple-\nment code in terms of the factory method and product interfaces. The factory method \ndesign pattern is mainly characterized by one creational method, which is used to instan-\ntiate and return objects of a specified product interface. This creational method is made \nabstract at the factory base class so that objects of the factory base class cannot be directly \ninstantiated. This is done to create a framework that allows the factory base class to define \na series of operations that rely on the product interface; however, before executing opera-\ntions, object creation is delegated to derived classes that are required to implement the \nfactory (creational) method. This way, new derived factories can override the method to \ninstantiate and return the appropriate product for the particular situation that is then used \nto carry out the operations specified in the factory base class. This way, through inheri-\ntance, new factories can be added to the design of the system to extend the factory base \nclass without modifying its code. With the factory method in place, reasoning about appli-\ncation logic can be made in terms of the product interface and not on concrete products, \ntherefore resulting in code that can be extended easily.\nProblem\nThe computer store from the previous example has expanded its operations to have three \ndifferent stores at different locations. Because of demographics at each location, particu-\nlar types of computers are offered at specific locations. The computer store in Location 1 \n\u00ad\nsupports standard computers only, the computer store at Location 2 supports advanced \ncomputers, and the computer store at Location 3 supports a new type of special computer. \nThe software system is now required to display information about computers carried at \nspecific stores. Therefore, the software design requires modification so that the display of \ncomputer information is site-specific. A desired feature for the redesigned software is the \nability to keep the logic code separate from specific types of computer stores so that future \nstores, carrying different computers, can be added to the system with minimal effort.\nStructure\nThe generic and applied structure of the factory method design pattern is presented in \nFigure\u00a06.2. As seen, the pattern requires both creational and product classes, similar to \nthe abstract factory design pattern. However, unlike the abstract factory design pattern, \ncreator classes in the factory method design pattern require only one creational interface \n", "page": 213, "type": "text", "section": "Page 213"}
{"text": "190\u2002 \u2022\u2002 Software Engineering Design\ufeff\nmethod for creating products that share the same interface. Therefore, for each product in \nthe system, the design incorporates concrete product and concrete creator classes.\nA step-by-step approach to designing the factory method design patterns includes \nthe\u00a0following:\n\t\n1.\tIdentify and design the product interface (e.g., computer).\n\t\n2.\tIdentify and design the concrete products that realize the interface from Step 1 \n(e.g.,\u00a0StandardComputer, AdvancedComputer).\n+createProduct()\n+someOperator()\nCreator\n+createComputer(type: string): Computer*\n+displayComputer(type: string): void\nComputerStore\nStandardComputerStore\n+createComputer(type: string): Computer*\nAdvancedComputerStore\n+createComputer(type: string): Computer*\n+displayMonitorInfo(): void\n+displayCpuInfo(): void\n+displayKeyboardInfo(): void\n+displayCost(): void\n+createProduct()\nConcreteCreator\n+productOperation1()\n+createOperation2()\n<interface>>\nProduct\nGeneral View\nApplied View\n<<interface>>\nComputer\n+displayMonitorInfo(): void\n+displayCpuInfo(): void\n+displayKeyboardInfo(): void\n+displayCost(): void\nStandardComputer\n+displayMonitorInfo(): void\n+displayCpuInfo(): void\n+displayKeyboardInfo(): void\n+displayCost(): void\nAdvancedComputer\n+displayMonitorInfo(): void\n+displayCpuInfo(): void\n+displayKeyboardInfo(): void\n+displayCost(): void\nNullComputer\n+productOperation1()\n+productOperation2()\nConcreteProduct\nFIGURE 6.2\nUML class diagram for the factory method design pattern.\n", "page": 214, "type": "text", "section": "Page 214"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 191\n\t\n3.\tDesign the factory base class (e.g., ComputerStore), which contains one abstract \nfactory\u00ad\n interface method for delegating product creation to derived classes. Product \ncreation must conform to the interface defined in Step 1.\n\t\n4.\tDesign one or more concrete factories for each product identified in Step 2.\nAs seen in the applied version, a standard computer store capable of displaying computer \ninformation is added to the design. Displaying computer information is performed with \nthe displayComputer() method that performs operations and requests services using the \ncomputer interface. Two creator classes have been added to the design: one for the standard \ncomputer store and another for the advanced computer store. As seen, each computer store \nis associated with the specific product that it supports. In addition, a NullComputer class is \nadded to ensure that computer stores do not return null pointers to clients in the case that \na requested computer is not supported by a particular computer store.\nImplementation\nOnce the structural design is complete, translating it to code is straightforward. Listings\u00a06.9 \nand 6.10 present the C++ implementation for the ComputerStore class.\nAs seen in Listing 6.10, the computer store displays a computer\u2019s information by relying \non the computer product interface; therefore, once derived computer stores override the \nfactory method to instantiate and return objects of the computer types supported in par-\nticular stores, the displayComputer() method will display the computer information \naccording to the object bound to it at run time. Listing 6.11 presents the factory method \ncode for a standard computer store.\nListing 6.9: Header File for the ComputerStore Class\n#include <string>\n// Forward reference.\nclass Computer;\n// The computer store creator class. This is an abstract class,\n// therefore to instantiate computer stores, specific derived\n// computer store classes are required.\nclass ComputerStore {\npublic:\n\t // The standard factory method for creating computer products.\n\t virtual Computer* createComputer(std::string type) = 0;\n\t // Method to display a computer\u2019s information.\n\t void displayComputer(std::string type);\n};\n", "page": 215, "type": "text", "section": "Page 215"}
{"text": "192\u2002 \u2022\u2002 Software Engineering Design\ufeff\nAs seen, the implementation for the factory method for standard computer stores \nsupports only standard computers. Internally, objects of type StandardComputer \ncan use the abstract factory design pattern from Listings 6.4 and 6.5 to create the stan-\ndard computer, which is common in many practical applications. To remain concise, \nthis part of the problem is not presented in this example; however, to accomplish this, \nthe design of the StandardComputer class would require an association with the \nStandardComputerPartsFactory from the previous section. With this association, \nthe standard computer parts factory is used inside the StandardComputer object to \ncreate standard products, such as standard monitor, keyboard, and CPU. In many prac-\ntical applications, both factory method and abstract factory design patterns are used in \nconjunction for providing extensible and reusable code. To support new products at the \nstandard computer store, the factory method can be modified with different conditional \nstatements for creating the new product; therefore, changes to support new products at a \nspecific \u00ad\ncomputer store are compartmentalized and do not affect all other computer stores.\nBenefits\n\u2022\t Separates code from product-specific classes; therefore, the same code can work with \nvarious existing or newly created product classes.\n\u2022\t By separating the code, development becomes efficient, since different developers can \nwork on the different parts of the project at the same time.\n\u2022\t By separating the code, it becomes easier to reuse and maintain specific parts of the code.\nListing 6.10: Source File for the ComputerStore Class\n#include \u201cComputer.h\u201d\n// Method to display a computer\u2019s information.\nvoid ComputerStore::displayComputer(string type) {\n\t // Delegate the responsibility of creating a computer object to\n\t // derived classes using the factory method.\n\t Computer* computer = createComputer(type);\n\t // Display the computer information, including its cost. This\n\t // information varies according to the factory object used to create\n\t // the computer.\n\t computer->displayMonitorInfo();\n\t computer->displayCpuInfo();\n\t computer->displayKeyboardInfo();\n\t computer->displayCost();\n\t // Do more stuff with the computer object here.\n\t // Clean up the pComputer and pFactory objects when done.\n}\n", "page": 216, "type": "text", "section": "Page 216"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 193\nSkill Development 6.2: Factory Method Design Pattern\nUsing the UML tool of choice, replicate the UML model presented in Figure\u00a0 6.2 \nand generate code from the model. Using the IDE of choice, fill in the gaps in the \ncode generated using Listings 6.9 and 6.11 and compile and execute the software. \nOnce the software \u00ad\nexecutes, go back to the UML model and add a third factory, \nSpecialComputerStore, that carries SpecialComputers. Repeat the code \ngeneration process, fill in the gaps of the new generated code, compile, and execute. \nWhen complete, explain the steps required to make this new modification and how the \nfactory method design pattern made this change easy or hard.\nBUILDER\nThe builder design pattern is an object creational pattern that encapsulates both the \n\u00ad\ncreational process and the representation of product objects. Unlike the abstract factory \nListing 6.11: Implementation of the Factory Method \nfor the Standard Computer Store\n// Implement the factory method.\nComputer* StandardComputerStore::createComputer(string type) {\n\t // Pointer to a computer object.\n\t Computer* computer;\n\t // Determine which computer needs to be created.\n\t if( type.compare(\u201cstandard\u201d) == 0 {\n\t \t // Create the StandardComputer. Clients are responsible for\n\t \t // cleaning up the memory for the computer object. Internally,\n\t \t // StandardComputer uses StandardComputerPartsFactory to create\n\t \t // a standard computer.\n\t \t computer = new StandardComputer;\n\t }\n\t else {\n\t \t // Create and return a null computer.\n\t \t computer = new NullComputer;\n\t }\n\t // Return the newly created computer object. Clients are responsible\n\t // for cleaning up the computer object.\n\t return computer;\n}\n", "page": 217, "type": "text", "section": "Page 217"}
{"text": "194\u2002 \u2022\u2002 Software Engineering Design\ufeff\ndesign pattern, in which various product objects are created all at once, the builder design \npattern allows clients to control the (multistep) creational process of a single product object, \nallowing them to dictate the creation of individual parts of the object at discrete points \nthroughout software operations. To accomplish this, the builder design pattern introduces \na creator class (i.e., the builder) that species the (abstract) interface methods required to \nbuild a particular product. These methods are used to build parts of a product, and once \nall parts of the product are created (using the builder interface) clients can request the \nbuilder to return the created object as a whole. Since the creation of the product object is \ndelegated to the concrete builder objects, the product\u2019s representation can vary accord-\ning to the specific concrete builder creating the object. This provides added flexibility for \nmanaging the creational process and representation of products that is not present in other \ncreational patterns. According to the Gang of Four (Gamma et al. 1995, p. 97), the intent \nof the builder is to\nSeparate the construction of a complex object from its representation so that the same con-\nstruction process can create different representations.\nThe idea of separating the process of constructing objects from their representations \nis essential when considering using the builder design pattern. Consider a client\u2013server \nsystem consisting of three clients that work in a distributed fashion and report to a central-\nized server. The server can request status from all three clients, compile the status received \ninto an object of the Message type, and forward it for further processing within the server \nsystem. In this scenario, the creational process of the Message object depends on receiving \ninformation from three different clients. Once information from the first client is received, \nthe part of the Message object that contains information about this client can be created. \nSimilarly, once information from the second and third clients is received, the parts of the \nMessage object that require this information can be built. Once all parts of the Message \nobject are built, the Message object can be forwarded to the rest of the system. In this \nexample, two important characteristics should be noted. First, the Message object cannot \nbe instantiated all at once; therefore, a finer-grained method of Message construction is \nrequired so that events occurring at discrete points in time can be used to build individual \nparts of the Message object. The second important, and perhaps more important, charac-\nteristic is the fact that the multistep process that allows for the construction of the Message \nobject is the same, regardless of the representation of the Message object. In this exam-\nple, the Message object can be forwarded within the server system using a binary format\u00ad\n, \nExtensible Markup Language (XML), or any other custom-defined format. A major prac-\ntical benefit can be gained by separating the construction process of objects from their \nrepresentation. Since objects using the builder design pattern can be constructed one step \nat a time, complex algorithms necessary to create these objects can be separated from the \nactual construction of objects so that the same algorithms can be used to build different \nrepresentations of an object. This results in code that can evolve to provide new representa-\ntion of objects by adding new builder classes without modifying the code for the algorithm \nused for creating objects.\n", "page": 218, "type": "text", "section": "Page 218"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 195\nProblem\nA company develops software to monitor and control custom-built hardware developed \nby a separate vendor. The equipment supports 100 different messages, defined using a \ncustom-defined interface control document (ICD). Every time the messaging specifica-\ntion changes, the code that represents all 100 messages has to be changed manually. The \ncompany has decided to develop a message generator that reads the message specifica-\ntion document, finds the appropriate information for each message, and generates code \nto represent them. This way, once the ICD changes all the company has to do is regen-\nerate the messages. Currently, the software for monitoring and control is developed \nin C++ so the message generator generates C++ code. However, the need for creating \n\u00ad\nmessage libraries for both Java, C#, and other languages is being evaluated. This means \nthat changes to the ICD will require message regeneration for all supported languages. \nThe software company wants a design for the message generator that separates the algo-\nrithm for parsing the messaging specification from the code that generates classes for \nthe messages in specific programming languages (e.g., C++, Java). This way, changes \nto the messaging specification will not affect the code that generates the messages in \nspecific programming languages and vice versa; changes or addition to support new \nprogramming language generation will not affect the code that parses the messaging \nspecification. To keep track of changes in the ICD and messaging libraries, the company \nalso wants to keep history and statistics of code generation, such as build number, build \ndate, number of methods generated, and number of classes generated.\nStructure\nThe general and applied structural view of the builder design pattern for the message \nbuilder problem is presented in Figure\u00a06.3. In the general view of the pattern\u2019s structure, \nnotice that the association with the Product class and the method for returning the \nproduct are specified in the ConcreteBuilder class. In many practical situations, the \nproducts being built can have dissimilar interfaces, therefore making it difficult to add \nthe interface method that returns the product in the AbstractBuilder base class and \nreducing flexibility in code. In the message builder example, since the products gener-\nated can be represented using the same interface, the method that returns the product \n(i.e.,\u00a0getGeneratedProduct\n()\n) is moved to the base class so that client code can rea-\nson about builders in terms of the AbstractBuilder interface and not based on con-\ncrete builders. The creational process is represented using the builder base class, which \ndelineates the creational process using abstract interface methods. For each identified rep-\nresentation of the product, a class is created that inherits from the builder base class. These \nclasses provide the specific creational details for their particular representation. Finally, \nbuilders are associated with the product class to generate the information required to build \nthe product as a whole.\nThere are two main driving forces behind the application of the builder design pattern \nto the message builder problem. First, since messages are generated from a document, the \n", "page": 219, "type": "text", "section": "Page 219"}
{"text": "196\u2002 \u2022\u2002 Software Engineering Design\ufeff\nsections in the document that specify the parts of a particular message may be scattered \nthroughout the document; therefore, the message object may not be able to be created all at \nonce. Second, the processing of the ICD file is the same, regardless of the target program-\nming language used for generating messaging code. This means that the same parsing \nalgorithm can be used to identify the key document elements used for code generation, \nregardless of the target language. Once these characteristics are identified, a step-by-step \napproach can be used to design the builder design pattern. The steps for applying the \nbuilder design pattern are as follows:\n\t\n1.\tIdentify and design the product class (e.g., GeneratedProduct).\n\t\n2.\tIdentify the product\u2019s creational process and algorithm, and design a class for its exe-\ncution (e.g., CodeGenerator). Each creational step (when necessary) must be made in \nterms of a standard product builder interface (instead of concrete product interface).\n\t\n3.\tUsing the knowledge acquired from Steps 1 and 2, design the builder interface, which \nspecifies the parts that need to be created for the whole object to exist. These are captured \nas abstract interface methods that need to be implemented by derived concrete builders.\n<<interface>>\nAbstractBuilder\n+buildProductPartA()\n+buildProductPartB()\n+buildProductPartC()\nConcreteBuilder\n+buildProductPartA()\n+buildProductPartB()\n+buildProductPartC()\n+getProduct()\nDirector\n+construct()\nCodeGenerator\n+generateCode(): void\nMessageBuilder\n+buildNewClass(name: stiring): void\n+buildClassAttributes(attributes: string): void\n+buildClassOperations(operations: string): void\n+closeClass(): void\n+getFileExtension(): string\n+getGeneratedProduct(): GeneratedProduct*\n+buildNewClass(name: string): void\n+buildClassAttributes(attributes: string): void\n+buildClassOperations(operations: string): void\n+closeClass(): void\n+getFileExtension(): string\n+buildNewClass(name: string): void\n+buildClassAttributes(attributes: string): void\n+buildClassOperations(operations: string): void\n+closeClass(): void\n+getFileExtension(): string\nJavaMessageBuilder\nCppMessageBuilder\nGeneratedProduct\n+addCode(code : string)\n+getCode(): string\n+getStats(): string\n+getdate() string\n+getBuild(): string\n+getAttributes(): string\n+getClasses() : string\n\u2013stats: string\nProduct\nGeneral View\nApplication View\nFIGURE 6.3\nUML class diagram for the builder design pattern.\n", "page": 220, "type": "text", "section": "Page 220"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 197\n\t\n4.\tIdentify and design classes for the different representations of the product \n(e.g.,\u00a0CppMessageBuilder and JavaMessageBuilder). These classes realize the inter-\nface from Step 3 in terms of the particular representations.\nWhen using the builder design pattern, the representation of each object is encapsulated \nin one or more concrete builder classes; therefore, adding new representation can be done \neasily by extending the design and not modifying existing working code.\nImplementation\nUsing the structural design from Figure\u00a06.3, the implementation for the MesageBuilder \nclass is presented in Listing 6.12. As seen, the purpose of this class is to specify the creational\u00ad\n \nsteps required for the generation of each message. Since messages in the ICD are generated \nas classes, the MessageBuilder has methods for creating new classes, adding attributes, \nadding methods, and generating code for closing classes (e.g., \u201c};\u201d in C++ and \u201c}\u201d in Java) \nand retrieving the extension used for the generated file. These interface methods serve as \nindication of the parts required to create a whole GeneratedProduct object. By sepa-\nrating these parts into multiple interface methods, the creational process can call upon \nthem individually to create the product object at discrete points during software execution, \nwhen information becomes available.\nOnce the creational parts are identified and incorporated into the MessageBuilder \nbase class, different derived classes can be implemented to provide the required object \nrepresentation. Since this behavior is incorporated into the design using inheritance, \nthe number of representations can be extended easily in future versions of the software. \nListing\u00a06.13 presents the code for the concrete message builder that generates C++ code for \nthe messages.\nFor each creational method in the CppMessageBuilder class, the parameters passed \nin are processed and transformed to C++ code before adding it to the product being gener-\nated. The same process is used for any other language that needs to be supported, such as \nJava or C#. Finally, the algorithm for product creation is created and encapsulated using \nthe CodeGenerator class. As seen, by varying the builder object passed to the code \ngenerator\u2019s\u00ad\n constructor, message generation can occur in different languages, as presented \nin Listing 6.14.\nBenefits\n\u2022\t The builder separates an object\u2019s construction process with its representation; \ntherefore\u00ad\n, future representations can be added easily to the software.\n\u2022\t Changes to the existing representation can be made without modifying the code for \nthe creational process.\n\u2022\t The builder provides finer control over the construction process so that objects can be \ncreated at discrete points in time.\n", "page": 221, "type": "text", "section": "Page 221"}
{"text": "198\u2002 \u2022\u2002 Software Engineering Design\ufeff\nSkill Development 6.3: Builder Design Pattern\nUsing pencil and paper, modify the UML class diagram for the message builder prob-\nlem to include message generation using the C# programming language. Explain the \nsteps taken and how the addition of the new program feature impacts the existing \ndesign. List the pros and cons of using the builder design pattern for this problem.\nListing 6.12: C++ Implementation of the MessageBuilder Class\n#include <string>\n// Forward reference.\nclass GeneratedProduct;\nclass MessageBuilder {\npublic:\n\t // The interface method for building a new class.\n\t virtual void buildNewClass(string name) = 0;\n\t // The interface method for building class attributes.\n\t virtual void buildClassAttributes(string attributeList) = 0;\n\t // The interface method for building class operations.\n\t virtual void buildClassOperations(string operationList) = 0;\n\t // The interface method for closing a new class.\n\t virtual void closeClass() = 0;\n\t // The file extension for the target programming language.\n\t virtual string getFileExtension() = 0;\n\t // Return the generated product.\n\t GeneratedProduct* getGeneratedProduct() {\n\t \t return _codeProduct;\n\t }\nprivate:\n\t // The product containing generated code and stats about code\n\t // generated.\n\t GeneratedProduct* _codeProduct;\n};\n", "page": 222, "type": "text", "section": "Page 222"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 199\nListing 6.13: C++ Implementation for the Message Builder that Generates C++\nclass CppMessageBuilder : public MessageBuilder {\npublic:\n\t // The interface method for building a new class.\n\t virtual void buildNewClass(string name) {\n\t \t // Generate code for creating a class using CPP style and the\n\t \t // name argument.\n\t \t // Once code is generated, add it to the product.\n\t \t getGeneratedProduct()->addCode(/*new C++ class code*/);\n\t }\n\t // The interface method for building class attributes.\n\t virtual void buildClassAttributes(string attributeList) {\n\t \t // For all items in attributeList, generate attributes using CPP\n\t \t // style and add them to the generated code.\n\t \t // Once code is generated, add it to the product.\n\t \t getGeneratedProduct()->addCode(/*C++ attributes*/);\n\t }\n\t // The interface method for building class operations.\n\t virtual void buildClassOperations(string operationList) {\n\t \t // For all items in operationList, generate operations using CPP\n\t \t // style and add them to the generated code.\n\t \t // Once code is generated, add it to the product.\n\t \t getGeneratedProduct()->addCode(/*C++ operations*/);\n\t }\n\t // The interface method for closing a new class.\n\t virtual void closeClass() {\n\t \t // Generate code to close a class in Cpp, and add it to the\n\t \t // generated code.\n\t \t // Once code is generated, add it to the product.\n\t \t getGeneratedProduct()->addCode(\u201c\\n};\\n\\n\u201d);\n};\n", "page": 223, "type": "text", "section": "Page 223"}
{"text": "200\u2002 \u2022\u2002 Software Engineering Design\ufeff\nListing 6.14: C++ Implementation for the CodeGenerator\nclass CodeGenerator {\npublic:\n\t // Constructor.\n\t CodeGenerator(MessageBuilder* pBuilder) : m_pBuilder(pBuilder) {\n\t \t // Assume a valid builder pointer. Notice that m_pBuilder is\n\t \t // initialized in the constructor\u2019s initialization list above.\n\t }\n\t // The interface method for building a new class.\n\t virtual void generateCode(string fileName) {\n\t \t // Open file for reading: fileName.\n\t \t while ( /* not end of file */) {\n\t \t \t // read next token in file.\n\t \t \t if( /*class name found*/) {\n\t \t \t \t // Assume that variable className holds the name.\n\t \t \t \t m_pBuilder->buildNewClass(className);\n\t \t \t }\telse if( /*attribute list found*/) {\n\t \t \t \t // Assume that attributeList contains the attributes\n\t \t \t \t m_pBuilder->buildClassAttributes(attributeList);\n\t \t \t }\telse if( /*operation list found*/) {\n\t \t \t \t // Assume that operationList contains the operations.\n\t \t \t \t m_pBuilder->buildClassOperations(operationList);\n\t \t \t \t // Close the class.\n\t \t \t \t m_pBuilder->closeClass();\n\t \t \t }\n\t \t } // end while( /* not end of file */)\n\t \t // Close file: fileName.\n\t \t // Create file using file extension from generated product object.\n\t \t // write(m_pBuilder->getGeneratedProduct()->getCode());\n\t \t // Close file.\n\t \t // logCodeGeneration(m_pBuilder->getGeneratedProduct());\n\t }\t// end generateCode(...)\nprivate:\n\t MessageBuilder* m_pBuilder;\n};\n", "page": 224, "type": "text", "section": "Page 224"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 201\nPROTOTYPE\nThe prototype design pattern is a class creational design pattern that allows clients to \u00ad\ncreate \nduplicates of prototype objects at run time without knowing the objects\u2019 specific type. \nPrevious creational design patterns, such as abstract factory and builder, required two \ndistinct set of classes: one or more creational classes and one or more product classes to \nsupport the creational process. Unlike these, in which creator and product classes were \nseparate, prototype objects are both creators and products. This characteristic allows them \nto support a generic interface for object creation while having the capability to access inter-\nnal product data to create (deep) copies of prototypical objects. These copies are returned \nto clients and used independently from the original prototype object. According to the \nGang of Four (Gamma et al. 1995, p. 117), the intent of the prototype design pattern is to\nSpecify the kinds of objects to create using a prototypical instance, and create new objects by \ncopying this prototype.\nThe prototype design pattern is typically used when clients need to duplicate products \nat run time without regarding how products are created or their specific concrete types. \nThis allows copies from a variety of objects within the same class hierarchy to be created \nuniformly, which simplifies client code and adds flexibility to designs.\nProblem\nConsider the enemy component created for a gaming system. The detailed design of the \nenemy component includes a wide variety of enemy specifications defined for the game, \neach including different profiles and weapons. The game designers have identified the \nneed to have each character provide a method for creating copies of themselves so that \nat any given point during the game a character clone can be made including identical \nenergy level, weapons, and profiles. This functionality is required to develop an enemy \nregistry of different Character subtypes to create and add enemies at any point dur-\ning the game. Consider the initial proposed solution to the problem, as presented in \nListing 6.15.\nAs seen, both TerrestrialEnemyCharacter and AerialEnemyCharacter have been \ndesigned to support an interface method for duplication of objects at run time. The prob-\nlem with the code in Listing 6.15 is that clients are required to know about the specific \nconcrete class to create a copy of each different character. Therefore, it is inefficient to \ndesign an enemy character registry that can be used throughout the game to create char-\nacters uniformly, since the creational process requires knowledge about the particular \ninterface method for duplicating a run-time object. This decreases the design\u2019s flexibility, \nsince it does not support object extension without code modification. That is, for every \nnew type of enemy character, the enemy registry code for creating and adding\u00ad\n \u00ad\ncharacters \n", "page": 225, "type": "text", "section": "Page 225"}
{"text": "202\u2002 \u2022\u2002 Software Engineering Design\ufeff\nto the game needs to be modified for including the new character. This problem is pre-\nsented in Listing 6.16.\nAs seen, the code required to create copies of enemy characters using the enemy regis-\ntry with only two characters is quite large. Consider the case where 100 different enemy \ncharacters are designed for the gaming system. In such a case, the size of the function \nwould increase significantly, since a conditional statement is required for each character. \nThis problem can be solved easily by using a prototypical interface for creating copies \nthat does not require clients\u2014in this case, the function to create the enemy character\u2014to \nknow which object they are creating.\nListing 6.15: C++ Implementation for the Terrestrial and Aerial Enemy Characters\n// The character interface.\nclass Character {\npublic:\n\t virtual void attack() = 0;\n\t // Other methods such as defend, move, etc.\n};\nclass TerrestrialEnemyCharacter : public Character {\npublic:\n\t // Method definitions for terrestrial attack, defend, etc.\n\t // Duplicate this object.\n\t TerrestrialEnemyCharacter* duplicateTerrestrial() {\n\t \t // Use the copy constructor to create a copy of this object and\n\t \t // return it.\n\t return new TerrestrialEnemyCharacter (*this);\n\t }\n};\nclass AerialEnemyCharacter : public Character {\npublic:\n\t // Method definitions for aerial attack, defend, etc.\n\t // Duplicate this object.\n\t AerialEnemyCharacter* duplicateAerial() {\n\t \t // Use the copy constructor to create a copy of this object and\n\t \t // return it.\n\t \t return new AerialEnemyCharacter(*this);\n\t }\n};\n", "page": 226, "type": "text", "section": "Page 226"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 203\nListing 6.16: C++ Implementation of the Client \nthat Creates New Enemy Character\n// Pre-Condition: A registry of 2 Enemy Characters has been created.\nCharacter* createNextEnemyCharacter() {\n\t // Randomly pick the location of the next enemy character to be\n\t // created.\n\t int nextEnemyLocation = rand() % MaxNumberOfEnemies;\n\t // Make sure that nextEnemyLocation is within proper bounds.\n\t // Retrieve the character at the nextEnemyLocation.\n\t Character* pCharacter = enemyRegistry[nextEnemyLocation];\n\t // The enemy character to be returned.\n\t Character* pNewCharacter = 0;\n\t // Determine if the character located at nextEnemyLocation is\n\t // Terrestrial.\n\t if( dynamic_cast<TerrestrialEnemyCharacter*>(pCharacter) != 0 ) {\n\t \t // Terrestrial Character, downcast it so that the\n\t \t // duplicateTerrestrial method can be used to duplicate the\n\t \t // terrestrial character.\n\t \t TerrestrialEnemyCharacter* pTerrestrial =\n\t \t\ndynamic_cast<TerrestrialEnemyCharacter*>(pCharacter);\n\t \t // Create the copy. Clients are responsible for cleaning up memory\n\t \t // allocated for the copy.\n\t \t pNewCharacter = pTerrestrial->duplicateTerrestrial();\n\t }\n\t // Determine if the character located at nextEnemyLocation is Aerial.\n\t else if( dynamic_cast<AerialEnemyCharacter*>(pCharacter) != 0 ) {\n\t \t // Aerial Character, downcast it so that the duplicateAerial\n\t \t // method can be used to duplicate the aerial character.\n\t \t AerialEnemyCharacter* pAerial =\n\t \t\ndynamic_cast<AerialEnemyCharacter*>(pCharacter);\n\t \t // Create the copy. Clients are responsible for cleaning up memory\n\t \t // allocated for the copy.\n\t \t pNewCharacter = pAerial->duplicateAerial();\n\t }\n\t else {\n\t \t // Invalid Character.\n\t \t pNewCharacter = new InvalidEnemyCharacter;\n\t }\n\t // Return the newly created enemy character.\n\t return pNewCharacter;\n}\n", "page": 227, "type": "text", "section": "Page 227"}
{"text": "204\u2002 \u2022\u2002 Software Engineering Design\ufeff\nStructure\nThe general and applied structural view of the prototype design pattern for the gaming \nsystem problem is presented in Figure\u00a06.4. As seen, from the structural point of view the \nonly thing required to implement the prototype design pattern is the addition of the clone \ninterface method to the Character type. By adding the clone() method in the char-\nacter interface, the behavior for creating character duplicates throughout the game is stan-\ndardized and delegated to derived classes. Therefore, by deriving from this base class and \nimplementing the clone interface, derived classes can abstract the process of creating a \ncopy of themselves.\nThe driving forces behind this design are the ability of client objects to create duplicates \nof character objects without knowing the object\u2019s internal true composition and providing \nclients the ability to reason about character objects using the character interface. Once these \ncharacteristics are identified, applying the prototype design pattern is straightforward.\n\t\n1.\tIdentify and design the common interface that needs duplication. As part of the \ninterface, the clone interface method needs to be specified.\n\t\n2.\tIdentify and design concrete products, which realize the interface created in Step 1.\n\t\n3.\tFor each concrete product created in Step 2, implement the clone method in terms of \nthat particular concrete product.\n<<interface>>\nPrototype\n+clone(): Prototype*\nConcretePrototypeA\n+clone(): Prototype*\nGemeEngine\n+createNextEnemyCharacter(): Character*\n+clone(): Character*\n+attack(): void\nTerrestrialEnemyCharacter\n+clone(): Character*\n+attack(): void\nAerialEnemyCharacter\n+clone(): Character*\n+attack(): void\n<<interface>>\nCharacter\nConcretePrototypeB\n+clone(): Prototype*\nClient\n+operation()\nGeneral View\nApplied View\nFIGURE 6.4\nUML class diagram for the prototype design pattern.\n", "page": 228, "type": "text", "section": "Page 228"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 205\nImplementation\nFrom the structural point of view, application of the prototype design pattern is straight\u00ad\nforward. In Listing 6.17, the Character interface is specified, which includes the clone() \ninterface method. By specifying the clone method as a pure virtual method, derived classes \nare forced to provide an implementation before they can be instantiated. For simplicity \nListing 6.17: C++ Implementation of the Terrestrial\u00a0Character \nand New Character Interface\n// The character interface.\nclass Character {\npublic:\n\t // Interface method for initiating an attack.\n\t virtual void attack() = 0;\n\t // Interface method for duplicating objects at run-time.\n\t virtual Character* clone() = 0;\n\t // Other methods such as defend, move, etc.\n};\nclass TerrestrialEnemyCharacter : public Character {\npublic:\n\t // Method definitions for terrestrial attack, defend, etc.\n\t void attack() {\n\t \t // Display to the console the type of attack.\n\t \t cout<<\u201dTerrestrialEnemyCharacter::attack()!\\n\u201d;\n\t }\n\t // Duplicate this object.\n\t TerrestrialEnemyCharacter* duplicateTerrestrial() {\n\t \t // Use the copy constructor to create a copy of this object and\n\t \t // return it.\n\t \t return new TerrestrialEnemyCharacter (*this);\n\t }\n\t // Implementation of the clone interface method to duplicate a\n\t // terrestrial enemy character.\n\t Character* clone(void) {\n\t \t // Delegate duplication to existing method.\n\t \t return duplicateTerrestrial();\n\t }\n};\n", "page": 229, "type": "text", "section": "Page 229"}
{"text": "206\u2002 \u2022\u2002 Software Engineering Design\ufeff\n(and to make the point clearer), the clone() method is implemented in terms of the pre-\nviously existing duplicateTerrestrial\n() method from Listing 6.15. In a practical \ndevelopment effort, such a method is removed so that the clone method can directly create \nthe object\u2019s copy.\nAs seen, the prototype\u2019s clone method results in a call to the copy constructor. In this \nexample, the C++ default copy constructor is called upon to create a copy of the specific \ncharacter object. However, careful attention must be in place when copying more complex \nobjects. In these cases, where the default copy constructor is insufficient to provide a deep \ncopy of the object, a specialized copy constructor must be provided. The same approach for \ncreating duplicates is repeated for the AerialEnemyCharacter, as seen in Listing 6.18.\nOnce both TerrestrialEnemyCharacter and AerialEnemyCharacter imple-\nment the clone interface, the client code presented in Listing 6.16 is modified to randomly \ncreate enemy characters using prototypical instances that support the clone() method, \nas seen in Listing 6.19. By using the prototype design pattern, the original client function is \nreduced significantly. More importantly, the addition of new enemy characters or removal \nListing 6.18: C++ Implementation for the AerialEnemyCharacter\nclass AerialEnemyCharacter : public Character {\npublic:\n\t // Implement the attack interface method for aerial characters.\n\t void attack(void) {\n\t \t // Display to the console the type of attack.\n\t \t cout<<\u201dAerialEnemyCharacter::attack()!\\n\u201d;\n\t }\n\t // Duplicate this object.\n\t AerialEnemyCharacter* duplicateAerial(void) {\n\t \t // Use the copy constructor to create a copy of this object and\n\t \t // return it.\n\t \t return new AerialEnemyCharacter(*this);\n\t }\n\t // Implementation of the clone interface method to duplicate a\n\t // aerial enemy character.\n\t Character* clone(void) {\n\t \t // Delegate duplication to existing method.\n\t \t return duplicateAerial();\n\t }\n};\n", "page": 230, "type": "text", "section": "Page 230"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 207\nof existing characters will not affect the client\u2019s implementation. This provides added flex-\nibility to support change in future versions of the gaming system.\nBenefits\n\u2022\t Clients are shielded from knowing the internal structure of objects; therefore, adding \nproducts at run time is easier. This reduces the client\u2019s complexity.\n\u2022\t Reduced number of classes; instead of having two classes for object creation (i.e., creator \nand product classes), the prototype is both, therefore eliminating the need for one class \nfor each product.\nSINGLETON\nThe singleton design pattern is an object creational design pattern used to prevent objects \nfrom being instantiated more than once in a running program. It is meant to provide a \ndesign solution that enforces the conceptual representation of entities that must be sin-\ngular within the problem domain. For example, consider the simulation of an operat-\ning system. In the operating systems domain, the simulation software may contain types \n(i.e., classes) for processes, threads, and so forth that can be instantiated multiple times to \nproperly represent running programs within the simulation. In these cases, the multiple \ninstantiation of these types is conceptually consistent with the problem domain. However, \nconsider an entity type for singular items, such as the file system. In this case, for a typical \noperating system, it would be conceptually incorrect to have multiple file system object \ninstances running within the simulation. Furthermore, if the simulation were to create \ntwo file systems by mistake, the results would not be reliable. In cases such as this one, the \nsingleton design pattern can be used to enforce the policy that only one instance of the file \nListing 6.19: C++ Code for the Client that Creates \nNew\u00a0Characters Using the Prototype Interface\nCharacter* createNextEnemyCharacter() {\n\t // Randomly pick the location of the next enemy character to be\n\t // created.\n\t int nextEnemyLocation = rand() % MaxNumberOfEnemies;\n\t // Make sure that nextEnemyLocation is within proper bounds.\n\t // Retrieve the character at the nextEnemyLocation.\n\t return enemyRegistry[nextEnemyLocation]->clone();\n}\n", "page": 231, "type": "text", "section": "Page 231"}
{"text": "208\u2002 \u2022\u2002 Software Engineering Design\ufeff\nsystem object is running at all times. According to the Gang of Four (Gamma et al. 1995, \np. 127), the intent of the singleton is to\nEnsure a class only has one instance, and provide a global point of access to it.\nSince the singleton limits object creation to one instance, it is important that the one \ninstance can be accessible through a standard method. Therefore, the singleton design pat-\ntern also provides a global point of access to it.\nProblem\nConsider an application that requires event-logging capabilities. The application consists of \nmany different objects that generate events to keep track of their actions, status of opera-\ntions, errors, or any other information of interest. A decision is made to create an event \nmanager that can be accessed by all objects and used to manage all events in the system. \nUpon instantiation, the event manager creates an event list that gets updated as events are \nlogged. At specific points during the software system\u2019s operation, these events are written \nto a file. To prevent conflicts, it is desirable that at any given time there is only one instance \nof the event manager executing.\nStructure\nThe general and applied structural view of the singleton design pattern for the event man-\nager is presented in Figure\u00a06.5. As seen, from the structural point of view the singleton is \nthe simplest design pattern, since it requires only one class. The driving force behind this \nGeneral View\nApplication View\n\u2013instance_: Singleton*\n+operation()\n\u2013Singleton()\n+getInstance(): Singleton*\nSingleton\n\u2013instance : EventManager*\n\u2013EventManager()\n+getInstance(): EventManager*\n+logEvent(eventDescription: string): void\nEventManager\nFIGURE 6.5\nUML class diagram for the singleton design pattern.\n", "page": 232, "type": "text", "section": "Page 232"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 209\ndesign is the ability for clients to have global access to the event manager and the assurance \nthat there is only one instance of the event manager at all times. Assuming a single-threaded \napplication, these characteristics are typically a good indication for applying the singleton \ndesign pattern. To apply the singleton design pattern, a three-step approach is employed:\n\t\n1.\tSet the visibility of the constructor to private.\n\t\n2.\tDefine a private static member attribute that can store a reference (or pointer) to the \none instance of the singleton.\n\t\n3.\tCreate a public static getInstance method that can access the private constructor \nto instantiate objects of the singleton type and return it to clients.\nWhen designing singletons, the class constructor needs to be specified as private to pre-\nvent clients from instantiating objects of the singleton type via the direct access to the \nconstructor. Since access to the constructor is prohibited, the second step involves creating \na method that can access the private constructor to instantiate objects of the singleton\u2019s \ntype. This method needs to be a class method (i.e., static) so that it can be called at the class \nlevel without instantiating an object of the class. This is done by specifying the method as \nstatic with public visibility. Finally, a private static member attribute that can store a refer-\nence or pointer to the running instance of the singleton needs to be created to keep track \nof the one, and only one, instance of the singleton. This attribute is initially set to zero or \nnull, and once a call to the getInstance() method is made the attribute is checked to \ndetermine if the instance of the singleton has been created. If it hasn\u2019t, the method instanti-\nates it and returns it to the caller. After the first initialization process, further calls to the \ngetInstance() method will fail the condition that determines that the attribute is null, \ntherefore directly returning the existing singleton object.\nImplementation\nAs specified before, the implementation of the singleton consists of three main steps. First, \nthe visibility of the constructor needs to be private to prevent direct instantiation from \n\u00ad\nclients. Next, a public class (static) member function must be created to provide clients \nwith a globally accessible function for the singleton. Finally, the globally accessible func-\ntion must instantiate the singleton object while enforcing that only one instance is \u00ad\ncreated \nthroughout program. The C++ implementation of the EventManager singleton class is \n\u00ad\npresented in Listings 6.19 and 6.20.\nOnce the singleton design pattern is applied to the EventManager, client objects can \nuse it easily via the standardized and globally accessible getInstance() method, as \npresented in Listing 6.21.\nThe singleton design pattern has been known to fail in multithreaded applications, result-\ning in the creation of more than one instance of the singleton. Therefore, its usage in these \ntypes of environments should be carefully evaluated before implementation.\n", "page": 233, "type": "text", "section": "Page 233"}
{"text": "210\u2002 \u2022\u2002 Software Engineering Design\ufeff\nListing 6.19: C++ Header File for the EventManager Singleton\n#include <string>\nclass EventManager {\npublic:\n\t // The global point of access to the EventManager.\n\t static EventManager* getInstance();\n\t // The method that logs events.\n\t void logEvent(std::string eventDescription);\nprivate:\n\t // Private Constructor.\n\t EventManager();\n\t // The one and only instance of the EventManager.\n\t static EventManager* _instance;\n};\nListing 6.20: C++ Source File for the EventManager Singleton\n#include \u201cEventManager.h\u201d\n// Initialize the instance_ static member attribute.\nEventManager* EventManager::_instance = 0;\n// The global point of access to the EventManager.\nEventManager* EventManager::getInstance() {\n\t // Determine if an instance of the EventManager has been created.\n\t if( _instance == 0 ) {\n\t \t // Create the one and only instance.\n\t \t _instance = new EventManager;\n\t }\n\t return _instance;\n}\n// The method that logs events.\nvoid EventManager::logEvent(std::string eventDescription) {\n\t // Code to log event.\n}\n// Private Constructor.\nEventManager::EventManager() {\n\t // Intentionally left blank.\n}\n", "page": 234, "type": "text", "section": "Page 234"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 211\nBenefits\n\u2022\t The singleton provides controlled access to a single instance of a given type.\n\u2022\t It has reduced name space since it provides an alternative to global variables.\n\u2022\t It can be customized to permit variable number of instances.\nCHAPTER SUMMARY\nCreational design patterns are patterns for abstracting and controlling the way objects are \ncreated in software applications. They play a key role in the design of systems by making them \nindependent of how objects in the system are created, composed, and represented. Therefore, \nparts of the system responsible for creating (or instantiating) objects do so through a common \ncreational interface without knowledge of how the actual object or group of objects are created. \nIn addition, by controlling the creational process with a common interface, enforcing cre-\national policies becomes easier, therefore giving the system the ability to create product objects \nthat share a common interface but that vary widely in structure and behavior. Examples \nof creational patterns include the abstract factory, factory method, builder, prototype, and \nsingleton. This chapter explored several well-established creational design patterns and pre-\nsented the problems they are designed to address, together with the benefits that each of the \ndiscussed patterns provides. Identifying and designing using creational design patterns can \nimprove the efficiency of the development process and the quality of the final system.\nREVIEW QUESTIONS\n\t\n1.\tWhat are creational design patterns? What are they used for?\n\t\n2.\tCompare and contrasts the following patterns:\n\t\na.\t Abstract factory\n\t\nb.\t Factory method\nListing 6.21: C++ Implementation for Client Objects \nUsing the EventManager Singleton\nint main() {\n\t // Log events using the singleton event manager.\n\t EventManager::getInstance()->logEvent(\u201clog some event here\u201d);\n\t // Or store the pointer to log events later.\n\t EventManager* pEventManager = EventManager::getInstance();\n\t pEventManager->logEvent(\u201clog some event here\u201d);\n}\n", "page": 235, "type": "text", "section": "Page 235"}
{"text": "212\u2002 \u2022\u2002 Software Engineering Design\ufeff\n\t\nc.\t Builder\n\t\nd.\t Prototype\n\t\n3.\tList and explain the benefits of applying the abstract factory design pattern.\n\t\n4.\tWhat is the builder design pattern? List and explain the main features of the builder \ndesign pattern.\n\t\n5.\tWhat particular problems are addressed by the builder design pattern?\n\t\n6.\tWhat is the essential structural element required in the prototype design pattern?\n\t\n7.\tExplain the steps required to implement the singleton design pattern? Are there any \nlimitations to this pattern? Explain.\nCHAPTER EXERCISES\n\t\n1.\tA company is designing software for monitoring and controlling a custom-built \nsystem consisting of multiple hardware components (i.e., Equipment1, Equipment2, \nand Equipment3). Each equipment component provides unique status, unique \ncommands, and specific interface for communicating, such as a Universal Serial \nBus (USB), Serial, and Transmission Control Protocol/Internet Protocol (TCP/IP). \nRegardless of the communication type, each class representing an equipment must \nprovide functionality to get specific status (e.g., getEquipmentOneStatus1, getE-\nquipmentTwoStatus1) and send specific commands to the device (e.g., sendEquip-\nmentOneCmd1, sendEquipmentTwoCmd1). The software provides a graphical user \ninterface (GUI) that polls each hardware component for its status data and also pro-\nvides means for sending commands to the components. Since hardware development \nis expected to take longer than the expected GUI development, management has \ndecided to simulate the components so that GUI development and testing can move \nforward. That is, there are two streams of equipments: real equipment, composed of \nEquipment1, Equipment2, and Equipment3; and simulated equipments, composed \nof SimEquipment1, SimEquipment2, and SimEquipment3. Design this system using \nthe abstract factory design pattern so that the GUI software can work the same way \nusing real or simulated components, regardless of the type of component.\n\t\n2.\tYour company develops software to monitor and control custom-built hardware devel-\noped by a separate vendor. The equipment supports 100 different messages, defined \nwith the format specified in the following box. Every time the messaging specifica-\ntion changes, the code for all 100 messages has to change manually. To make things \nworse, your company supports two versions of the software, one in Java and one in \nC++, so these changes must be made to both versions. In addition, there are future \nplans for providing a messaging library in C# as well, based on the messaging specifica-\ntion. Clearly, there has to be a more efficient way to manage this process. Management \nhas asked you, the design team, to come up with a design that separates the algorithm \nfor parsing the messaging specification from the code that generates classes for the \n", "page": 236, "type": "text", "section": "Page 236"}
{"text": "Creational Design Patterns in Detailed Design\u2002 \u2022\u2002 213\nmessages in a specific programming language (e.g., Java or C++). This way, changes \nto the messaging specification will not affect the code that generates the messages in \nspecific programming languages and vice versa; that is, changes or additions to support \nnew programming language generation will not affect the code that parses the messag-\ning specification. A sample of the messaging specification containing three messages is \ngiven to you so that you can propose a design that can improve the code generation pro-\ncess. Management would be thrilled if your design would support different generators \n(at run time) capable of producing the messages in different programming languages. \nThat way, by swapping generators different programming languages can be supported. \nThe generated code should provide get() and set() methods for all attributes.\n\t\n3.\tApply the builder design pattern to design this system.\n\t\n4.\tUse the tool of your choice (e.g., rational rose, starUML, MS PowerPoint, Visio) to \ncreate the UML class diagram for the problem\n\t\n5.\tWrite code in C++ to demonstrate the implementation of your design. Your pro-\ngram must create files containing Java or C++ code for the generated messages, \ndepending on the builder used.\nMessaging Specification Sample\nName:PowerOnCmd;\nAttributes:4;\nbyte:headerSize;\nbyte:msgId;\nbyte:sourceId;\nbyte:destinationId;\nOperations:0;\nName:SelfTestCmd\nAttributes:5;\nbyte:headerSize;\nbyte:msgId;\nbyte:sourceId;\nbyte:destinationId;\nbyte:testId;\nOperations:0;\nName:SetDataCmd;\nAttributes:6;\nbyte:headerSize;\nbyte:msgId;\nbyte:sourceId;\nbyte:destinationId;\nbyte:dataType;\nbyte:dataSize;\nOperations:2;\nbyte*,getData,void;\nvoid,setData,byte*;\n", "page": 237, "type": "text", "section": "Page 237"}
{"text": "214\u2002 \u2022\u2002 Software Engineering Design\ufeff\n\t\n6.\tPrepare a 10- to 15-minute PowerPoint presentation consisting of the following:\n\t\na.\t Introduction to the problem\n\t\nb.\t Solution approach (UML class diagram)\n\t\nc.\t Presentation of the builder code\n\t\nd.\t Demo of the program\n\t\ne.\t Be ready to state your assumptions and to justify and defend all of your design \ndecisions.\nREFERENCE\nGamma, Erich, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns: Elements of Reusable \nObject-Oriented Software. Boston: Addison-Wesley, 1995.\n", "page": 238, "type": "text", "section": "Page 238"}
{"text": "215\n7\nStructural and Behavioral\u00a0Patterns \nin Detailed Design\nCHAPTER OBJECTIVES\n\u2022\t Understand the importance and role of structural and behavioral \ndesign patterns in detailed design\n\u2022\t Identify, understand, and model common structural and behavioral \ndesign patterns\n\u2022\t Become proficient in implementing models of both structural and \nbehavioral design patterns\n\u2022\t Understand the benefits of important structural and behavioral design \npatterns\nCONCEPTUAL OVERVIEW\nAs seen in the previous chapter, common patterns in object-oriented \ndesigns exist to provide detailed design solutions to problems that recur \nmany times over in different systems. Beside the creational design patterns \nstudied so far, other common and popular design patterns have been iden-\ntified to address structural and behavioral problems commonly encoun-\ntered in software applications. Structural and behavioral designs patterns \nhelp identify problems that deal with the structure and behavior of software \ndesigns; they prescribe the classes required for their design solution and \ninterrelationships required to support object creation their behavior. These \npatterns allow designers to quickly and systematically identify structural \nlayouts of systems (or subsystems) and provide avenues for examining the \nsystem\u2019s interactions and quality evaluation within the operational system. \n", "page": 239, "type": "text", "section": "Page 239"}
{"text": "216\u2002 \u2022\u2002 Software Engineering Design\ufeff\nThis chapter explores several well-established structural and behavioral design patterns \nand examines the problems they are designed to address, together with the benefits they \nprovide. Identifying and designing using these design patterns can improve the efficiency \nof the development process and the quality of the final system.\nSTRUCTURAL DESIGN PATTERNS\nStructural design patterns are patterns that deal with designing larger structures from \nexisting classes or objects at run time. They play a key role in the design and evolution of \nsystems by allowing integration of new designs with existing ones, via object \u00ad\ncomposition \n(i.e., object structural) or inheritance (i.e., class structural). Class structural design \u00ad\npatterns \nidentify the inheritance relationship necessary to create new interfaces or implementa-\ntions that may be compatible with the older design structure. Object structural patterns \nprovide the relationships required to create larger structures through object composition \nat run time, therefore providing more flexibility to extend the system at run time, which \nis impossible for class structural solutions. In both cases, by allowing designs to build on \nother existing structures, systems can be made interoperable by designing compatible \ninterfaces for otherwise incompatible systems. Structural design patterns have also signifi-\ncant impact on the reusability and modifiability of systems. Examples of structural design \npatterns include the adapter, composite, and facade.\nADAPTER\nThe adapter design pattern is a class/object structural design pattern used to adapt an exist-\ning interface to another interface that is expected in a software system. It can be designed \nas both class structural, in which the major composition relationships are defined at com-\npile time, and object structural, where structural object composition occurs at run time. \nIn\u00a0 either case, the adapter design pattern allows systems with incompatible interfaces \nto work together, therefore increasing the reusability and evolution of software systems. \nAccording to the Gang of Four (Gamma, Elm, Johnson, and Vlissides 1995, p. 139), the \nintent of the adapter is to\nConvert the interface of a class into another interface clients expect. Adapter lets classes work \ntogether that couldn\u2019t otherwise because of incompatible interfaces.\nConceptually, adapters are used everywhere. For example, electrical adapters can \nbe used to connect devices with incompatible interfaces, such as European plugs and \nAmerican sockets. In gardening, adapters are used to connect water hoses with \n", "page": 240, "type": "text", "section": "Page 240"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 217\nincompatible interfaces to extend their reach. In computer hardware, adapters are used \nto covert between many different interfaces, such as serial to Universal Serial Bus (USB). \nIn software, the adapter concept is applied similar to adapters in the previous examples. \nConsider the graphical user interface (GUI) for an application to monitor and control \na satellite communication system composed of several independent hardware devices. \nFor each hardware device, complex GUI screens are designed to monitor and con-\ntrol each device. All screens rely on a class, named HardwareDevice, that provides \nmethods\u00ad\n (e.g., string getStatusA(), string getStatusB()) designed and developed assuming \nthat commands and status for each device use the string type (in C++). When receiv-\ning the hardware devices from their manufacturers and the binary compiled library \nthat provides monitor and control capabilities for each device, it is noticed that the class \nManufacturerHardwareDevice (provided by the manufacturer) provides all func-\ntions for command and control using the char* type or other nonstring type, which \ncreates an incompatible interface between the existing GUI code and the library code. \nSince the code inside the library cannot be changed and changing the code for all screens \n(\u00ad\ndepending on the number of screens) may be impractical, the provided class in the binary \nlibrary can be adapted using the adapter design pattern to fit the expected interfaces in \nthe GUI software or vice versa.\nProblem\nConsider the completed gaming system discussed in Chapter 5, which includes the \ndesign and development for all 10 levels of a gaming system, including the design and \nimplementation of all gaming characters. At each level, the core of the gaming system \n(i.e.,\u00a0 GameEngine) uses the Character interface to add enemy characters to the game, \nmaking them move, defend, and attack using the move(), defend(), and attack() \ninterface methods, respectively. Each character in the game implements the Character \ninterface to provide specific behavior appropriate for the character and the level of the \ngame. That is, depending on the character and the game level, the behavior for moving, \ndefending, and attacking varies among characters. An online character developer has \ncreated a special character that is compatible with the game development\u2019s application \nprogramming interface (API) but not with the particular Character interface; that is, \nthe special character designed by the online developer includes the following interface \nmethods: specialMove(), \u00ad\nspecialAttack(), and specialDefend(). The special \ncharacter is made available freely to the gaming community; however, the special charac-\nter code can be downloaded and incorporated into other gaming systems only as a binary \ncompiled library, which can be incorporated into the existing game. Since all levels of the \ngame are complete, it is impractical to change the code in all places to detect the new spe-\ncial character and make different calls for moving, attacking, and defending; therefore\u00ad\n, \nthe adapter design pattern is required to adapt the special character\u2019s interface to the \ncurrent\u00ad\n character interface.\n", "page": 241, "type": "text", "section": "Page 241"}
{"text": "218\u2002 \u2022\u2002 Software Engineering Design\ufeff\nClient\n+request()\nTarget\nClient\n+request()\nTarget\nGameEngine\n+attack(): void\n+defend() : void\n+move(): void\n<<interface>>\nCharacter\n+request()\nAdapter\n+speci\ufb01cRequest()\nAdaptee\n+request()\nAdapter\n+speci\ufb01cRequest()\nGeneral Class\nStructural View\nGeneral Object\nStructural View\nApplied Object\nStructural View\nAdaptee\n+attack(): void\n+defend(): void\n+move(): void\nCharacterAdapter\n+borrowedAttack(): void\n+borrowedDefend(): void\n+borrowedMove(): void\n<<interface>>\nBorrowedCharacter\n+borrowedAttack(): void\n+borrowedDefend(): void\n+borrowedMove(): void\nConcreteBorrowedCharacter\nFIGURE 7.1\nUML class diagram for the class/object structural adapter design pattern.\n", "page": 242, "type": "text", "section": "Page 242"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 219\nStructure\nThe general and applied structure of the adapter design pattern is presented in Figure\u00a07.1. \nAs seen, the adapter can be designed using multiple inheritance or object composition.\nIn the multiple inheritance version, the pattern\u2019s relationships between classes and sub-\nclasses are defined at compile time, via inheritance; therefore, this version is classified as \nclass structural. When the adapter design pattern is designed using object composition, \nobject relationships are defined at run time; therefore, the adapter design pattern in this \ncase is classified as object structural. The object structural version of the adapter design \npattern results in a more dynamic and flexible design; therefore, it is the recommended \nand followed approach for the gaming system. The step-by-step approach for designing the \nobject structural adapter design pattern is presented as follows:\n\t\n1.\tIdentify the source and destination interfaces that need adapting in the new system \n(e.g., target and adaptee or character and SpecialCharacter).\n\t\n2.\tAdd a new class (e.g., adapter or AdaptedCharacter) in the design that realizes the \ntarget interface and implements it in terms of the adaptee\u2019s implementation. This \nrequires a realization relationship between the adapter and target, and an association \nbetween the adapter and the adaptee.\n\t\n3.\tIn the new system, whenever objects that share the target interface are expected, \nit\u00a0can now be possible to use the adapter objects created in Step 2.\nThe driving forces for applying the adapter design pattern are reusability and integration \nof code between two mature software structures. Under these conditions, changing the \ncode to match either of the two software entities is impractical. Furthermore, access to the \ncode for either software entity may not be possible; therefore, to reuse and integrate code \nfrom one entity to the other, the adapter is required. When this is the case, the adapter \ndesign pattern is easily applied by creating an adapter class that inherits from the target \nclass. By incorporating new adapter objects that share the Target interface, clients can use \nthem the same way they used original Target objects; however, these new adapter objects \nimplement the Target functions in terms of the Adaptee, which is the object providing the \nnew functionality under a different, incompatible interface.\nImplementation\nThe implementation of the object structural adapter design pattern simply requires the \ncreation of one class with two relationships\u2014realization and association. In practical \napplications, the Target and Adaptee classes are typically part of larger mature and sable \nsoftware structures. In this example, the Target and Adaptee classes are represented by the \nCharacter and BorrowedCharacter classes, as seen in Listings 7.1 and 7.2.\n", "page": 243, "type": "text", "section": "Page 243"}
{"text": "220\u2002 \u2022\u2002 Software Engineering Design\ufeff\nAs seen, the interfaces for the Character and BorrowedCharacters are different\u00ad\n; \ntherefore, client code that expects objects with the Character interface cannot accept \nobjects with the BorrowedCharacter interface even though conceptually, both objects do \nthe same operations. To allow the existing code to process objects of the borrowed charac-\nter type as if they were objects of the character type, a CharacterAdapter is required, \nas seen in Listing 7.3.\nListing 7.1: C++ Code for the Character Interface\n// The Target class.\nclass Character {\npublic:\n\t // Interface method for attack functionality.\n\t virtual void attack() = 0;\n\t // Interface method for defend functionality.\n\t virtual void defend() = 0;\n\t // Interface method for moving functionality.\n\t virtual void move() = 0;\n};\nListing 7.2: C++ Code for the BorrowedCharacter \nInterface and ConcreteBorrowedCharacter\n// Interface for the borrowed character.\nclass BorrowedCharacter {\npublic:\n\t // Interface methods for the borrowed character.\n\t virtual void borrowedAttack() = 0;\n\t virtual void borrowedDefend() = 0;\n\t virtual void borrowedMove() = 0;\n};\n// Concrete borrowed character.\nclass ConcreteBorrowedCharacter : public BorrowedCharacter {\npublic:\n\t // Implementations for the BorrowedCharacter interface methods.\n\t void borrowedAttack() { /* attack code here... */}\n\t void borrowedDefend() { /* defense code here... */}\n\t void borrowedMove() { /* code to move here... */}\n};\n", "page": 244, "type": "text", "section": "Page 244"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 221\nAs seen, the CharacterAdapter inherits from the Character to implement the \nrealization relationship in C++. It is also associated with the BorrowedCharacter class \nvia member attribute. To finalize the object adaptation, the newly created character adapter \ntype is required to implement all interface methods defined by the character interface in \nterms of the associated borrowed character, as seen in Listing 7.4.\nOnce the adapter design pattern is applied, it is easy to use borrowed characters in the \ngaming system. Consider the method presented in Listing 7.5 for triggering character \nbehavior in the GameEngine class.\nAs seen, this and other methods defined in the GameEngine class can now employ the \nadapter design pattern to accept character objects that comply with the character interface \nbut provide behavior from the borrowed character. An example of client code used to acti-\nvate a borrowed character in the gaming system is presented in Listing 7.6. As seen, the \nborrowed character is created and passed into the character adapter during its initialization \nthrough the constructor. From this point forward, the adapted character is used instead of \nthe borrowed character to provide the new features to the game.\nBenefits\n\u2022\t Allows classes with incompatible interfaces to work together, therefore increasing \nreusability and ease of code integration\n\u2022\t Provides a standard way for integrating a plurality of different types to existing software\nListing 7.3: C++ Header File for the CharacterAdapter Class\n// Forward reference.\nclass BorrowedCharacter;\nclass CharacterAdapter : public Character {\npublic:\n\t // Constructor.\n\t CharacterAdapter(BorrowedCharacter* pCharacter);\n\t // Adapt the attack method.\n\t void attack(void);\n\t // Adapt the defend method.\n\t void defend(void);\n\t // Adapt the move method.\n\t void move(void);\nprivate:\n\t // BorrowedCharacter that needs adapting to the Character interface.\n\t BorrowedCharacter* _borrowedCharacter;\n};\n", "page": 245, "type": "text", "section": "Page 245"}
{"text": "222\u2002 \u2022\u2002 Software Engineering Design\ufeff\nSkill Development 7.1: Adapter Design Pattern\nUsing the Unified Modeling Language (UML) tool of choice, replicate the UML \nmodel presented in Figure\u00a07.1 and generate code from the model. Using the Integrated \nDevelopment Environment (IDE) of choice, fill in the gaps in the code generated using \nListings 7.1 through 7.6, and compile and execute the software. Create two additional \nclasses: one that derives from the character class in which its methods are implemented \nto simply display some output to the console; and another adapter class that adapts \nanother character with different interface methods for attacking, defending, and mov-\ning (e.g., slowAttack, slowDefend, and slowMove). Use the triggeredAction \nmethod to pass in (one at a time) objects of all the types created. Observe how the trig-\ngeredAction method accepts both objects of the original character interface and the new \nadapted objects (since they now all share the character interface). How does the adapter \ndesign pattern increase reusability, maintainability, and modifiability in such system?\nListing 7.4: C++ Source File for the CharacterAdapter Class\n#include \u201cCharacterAdapter.h\u201d\n#include \u201cBorrowedCharacter.h\u201d\n// Constructor.\nCharacterAdapter::CharacterAdapter(BorrowedCharacter* pCharacter) {\n\t // For simplicity, assume a valid pointer.\n\t _borrowedCharacter = pCharacter;\n}\n// Adapt the attack method.\nvoid CharacterAdapter::attack() {\n\t // Implement the attack functionality in terms of the\n\t // BorrowedCharacter.\n\t _borrowedCharacter->borrowedAttack();\n}\n// Adapt the defend method.\nvoid CharacterAdapter::CharacterAdapter::defend() {\n\t // Implement the defend functionality in terms of the\n\t // BorrowedCharacter.\n\t _borrowedCharacter->borrowedDefend();\n}\n// Adapt the move method.\nvoid CharacterAdapter::move() {\n\t // Implement the move functionality in terms of the\n\t // BorrowedCharacter.\n\t _borrowedCharacter->borrowedMove();\n}\n", "page": 246, "type": "text", "section": "Page 246"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 223\nCOMPOSITE\nThe composite design pattern is an object structural pattern that allows designers to \ncompose (large) tree-like design structures by strategically structuring objects that share \na whole\u2013part relationship. Whole\u2013part relationships are those in which a larger entity \n(i.e.,\u00a0the whole) is created by the composition of smaller entities (i.e., the parts). The key \nListing 7.5: C++ Code for the GameEngine\u00a0Method \nto Trigger a Character\u2019s Actions\nclass GameEngine {\npublic:\n\t // ...\n\t // Method to activate a character.\n\t void GameEngine::triggeredAction(Character* pCharacter) {\n\t // Activate the character and make it move randomly for a short\n\t // time.\n\t pCharacter->move();\n\t // Once the character stops moving, if being attacked, defend!\n\t pCharacter->defend();\n\t // Once the characters stops defending, if others characters are\n\t // detected, attack!\n\t pCharacter->attack();\n\t }\n\t // ...\n};\nListing 7.6: C++ Code for Client Code in the Gaming\u00a0System \nto Activate a Borrowed Character\n// Instantiate the game engine.\nGameEngine engine;\n// Create the borrowed character that needs adapting.\nConcreteBorrowedCharacter borrowedCharacter;\n// Create the character adapter and pass in the borrowed character.\n// From this point on, the adapterCharacter object can be used\n// throughout the game engine as if it were a Character!\nCharacterAdapter adaptedCharacter(&borrowedCharacter);\n// Move, attack, and defend with the borrowed character\u2019s features!\nengine.triggeredAction(&adaptedCharacter);\n", "page": 247, "type": "text", "section": "Page 247"}
{"text": "224\u2002 \u2022\u2002 Software Engineering Design\ufeff\nadvantage of using the composite design pattern is that it provides a design structure that \nallows both whole and part objects to be treated uniformly; therefore, operations that are \ncommon to both type of objects can be applied the same way to both types of objects. \nAccording to the Gang of Four (Gamma et al. 1995, p. 163), the intent of the composite is\u00a0to\nCompose objects into tree structures to represent part-whole hierarchies. Composite lets \n\u00ad\nclients treat individual objects and composites of objects uniformly.\nMany situations exist that require objects to be composed of many parts. However, in \nsome specific instances, some problems require both objects and their parts to be treated \nuniformly. In the software domain, perhaps the most common example is seen in modern \nuser interfaces, which contain both Menu and MenuItem objects. A Menu, in the graphical \nuser interface context, is a mechanism of the software that allows users to select and activate \nfeatures of the system. A Menu can also provide access to other Menus or MenuItems that \ncan be selected to trigger software execution. Both Menu and MenuItem may contain func-\ntions to change their visible text, size, and background color or to handle events. Therefore, \nboth must be treated uniformly. In this case, the composite design pattern can be used to \ncreate a flexible design structure that groups both Menu and MenuItems, that provides easy \naddition and removal of both Menu and MenuItems to the design structure, and that pro-\nvides a uniform interface so that operations common to both can be easily performed using \nthe composite interface. Although the composite design pattern is prevalent in examples \nsuch as this, its application can be found in numerous practical applications.\nProblem\nA wireless sensor system is remotely deployed to collect environmental information. The \nsensor system communicates via satellite to a central location, where a schedule of tasks \n(i.e., a mission plan) is created and sent over satellite communications. A mission plan is a \ncomposite message that contains one or more messages that command the sensor \u00ad\nsystem \nto perform particular tasks. These messages contain information on how and when to per-\nform particular tasks. Mission plan messages can be created with many different com-\nbinations of messages. Upon creating the mission plan message, it is sent to the wireless \nsensor system, which retrieves each message and message information from the mission \nplan and executes them to collect environmental data, store it, and send it back to the \ncentral location, as directed by the mission plan message. The sensor system is extensible \nand contains many capabilities provided by numerous sensors (e.g., temperature, vibra-\ntion), still-shot camera, and video recording. To operate the sensor system, the operators at \nthe central location are requesting a message generator capable of allowing them to easily \ncreate a mission plan message. The mission plan message may contain both primitive and \ncomposite messages. Numerous mission plan messages can be created to support different \n\u201cmissions,\u201d and it is expected that more sensing capabilities will be added in the future. \nTherefore, the design of the message generator must provide easy addition and removal of \n", "page": 248, "type": "text", "section": "Page 248"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 225\nboth \u00ad\nmessages and composite messages to a mission plan. A graphical representation of the \nmessage generator is presented in Figure\u00a07.2.\nAs seen, the topmost composite message represents the mission plan message (or schedule). \nThe message generator provides a series of menu items that allows operators to select a par-\nticular message, to configure its parameters, and to add it to the mission plan message. In this \nexample, Message 3 is a composite message that can be configured to contain Messages\u00a05, 6, \nand 7. Message 3 can also be configured individually and added to the mission plan. Both \nprimitive and composite messages need to be treated uniformly, so that methods such as \ngetId(), setId(), and toXml\n() can be supported by both types of messages.\nStructure\nThe general and applied structure of the composite design pattern is presented in Figure\u00a07.3. \nAs seen, the general structure of the composite design pattern requires three main classes, \nthe Composite, Leaf, and Component classes. The Component class defines the operations \nthat are common to both Composite and Leaf objects, for example, print\n(), toXml\n(), \ngetId(), setId(), etc., as shown in the Applied View portion of Figure\u00a07.3. The com-\nponent class also defines the methods specific to support the composite design pattern, \nnamely, the add() and remove() methods. The add and remove methods are intended \nfor use by composite objects and not by leaf objects; therefore, they must be specified as \noverridable methods with default implementation that indicates an unsupported operation. \nComposite\nMessage\nMessage\nComposite\nMessage\nMessage\nMessage\nMessage\nMessage\nMessage\nParam1:\nInclude Message\nMessage 3\nMessage 5\nMessagesMenu\nMessage 1\nMessage 2\nMessage 3\nMessage 4\nMessage 5\nMessage 6\nMessage 7\nParam2:\nParam3:\nFIGURE 7.2\nMessage generator graphical user interface concept.\n", "page": 249, "type": "text", "section": "Page 249"}
{"text": "226\u2002 \u2022\u2002 Software Engineering Design\ufeff\nThis means that if at any point during run time a leaf object is called upon to add or remove \nobjects to the hierarchy, the default implementation for these methods is executed to reflect \nthe unsupported requests. In many cases, a good alternative for the default implementation \ninvolves writing code that throws exceptions within the add and remove methods. On\u00a0the \nother hand, composite objects that derive from the component base class are required to \noverride the default implementation so that objects can be added and removed from the \nhierarchy. This way, when composite objects are bound dynamically at run time to a ref-\nerence of the component type, the appropriate code for adding and removing objects is \ncalled, preventing the default implementation from being executed. The steps required to \napply the composite design pattern include\n\t\n1.\tIdentify, understand, and plan the tree-like structure required for the system.\n\t\n2.\tWith the knowledge from Step 1, identify and design the component base class, \nwhich includes overridable methods common to both leaf and composite objects as \nwell as methods specific to composite objects, which provide capability for adding \nand removing objects to the hierarchy.\n+operation()\n+add(param1 : Component)\n+remove(param1: Component)\n+getChild(int)\nClient\nLeaf\nComponent\n+operation()\n+add(param1 : Component)\n+remove(param1: Component)\n+getChild(int)\n+operation()\nVideoControlMessage\nMessageGenerator\nGeneral View\nApplied View\nComposite\n+getId(: void): int\n+getName(: void): string\n+setId(id: int): void\n+setName(name: string): void\n+add(message : Message*): void\n+print(: void): void\n+toXml(): string\n+clone(): Message*\n+setFrameRate(framesPerSecond: int): void\n+toXml(): string\n+clone(): Message*\nSelfTestMessage\n+toXml(): string\n+clone(): Message*\nCompositeMessage\n+CompositeMessage(other : const CompositeMessage&)\n+CompositeMessage(name : string)\n+add(message : Message*): void\n+print(): void\n+toXml(): string\n+clone(): Message*\n\u2013messages_: list<Message*>\n\u2013id_: int\n\u2013name_: string\nMessage\nFIGURE 7.3\nUML class diagram for the composite design pattern.\n", "page": 250, "type": "text", "section": "Page 250"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 227\n\t\n3.\tFor the methods specified in Step 2 for adding and removing objects to the hierarchy, \nimplement default behavior that if not overridden will result in an exception or error \nmessage indicating an unsupported operation.\n\t\n4.\tIdentify and design the composite class, which overrides methods for adding and \nremoving objects to the hierarchy. The composite class requires an internal data \nstructure to store leaf nodes added to the hierarchy. In addition, the composite class is \nrequired to override all other operational methods identified in Step 2 to implement \nfunctionality in terms of the composite object and all of its contained leaf objects.\n\t\n5.\tIdentify and design the leaf class, which overrides operational methods specified in \nStep 2 to implement behavior in terms of the leaf object. Leaf objects do not override \nthe add and remove methods identified in Step 2.\n\t\n6.\tIdentify and design the client that uses both composite and leaf objects.\nIn the message generator example, add() and remove() are used to add and remove \nboth CompositeMessage and all other derived messages to the design structure \n(e.g.,\u00a0VideoControlMessage, SelfTestMessage). Therefore, to support the addi-\ntion of new messages that provide control of future sensing capabilities, a new class that \nderives from the Message base class needs to be added to the message generator design. \nIn addition, to support easy duplication of both types of messages, the prototype design \npattern is incorporated into the message generator design so that message copies can be \neasily created throughout the application. This is reflected in the design with the addition \nof the clone() method to the Message class.\nThe driving forces behind the design include the ability to treat both individual messages \nand mission plan messages uniformly, so that the complexity of client code is minimized. \nThe composite design pattern is also chosen to achieve design flexibility so that new mes-\nsages can be created easily to support future systems\u2019 demands. The most influential step \nwhen applying the composite design pattern is the addition of the add() method in the \nComponent base class. Once this method is created, composite objects override it to store \nthe primitive objects contained by it.\nImplementation\nMost of the implementation work for the composite design pattern takes place in both \nthe component and composite classes, which are represented in the message generator by \nthe Message and CompositeMessage classes. Once these are created, other message \nclasses that share the same Message interface can be added easily by deriving from the \nMessage class. The implementation for the Message class is presented in Listing 7.7.\nAs seen, the toXml\n() and clone() methods are incorporated in the Message type \ninterface. These methods are application specific and are not related to the composite \ndesign pattern. The toXml\n() method is added to enforce the policy that all messages in \nthe system are required to provide implementation appropriate to convert the particular \nmessage data into Extensible Markup Language (XML) format. Other application-specific \nmethods include the getId(), setId(), getName(), and setName().\n", "page": 251, "type": "text", "section": "Page 251"}
{"text": "228\u2002 \u2022\u2002 Software Engineering Design\ufeff\nThe add(Message*) method is specific to the composite design pattern. Specifically, it \ngives composite classes the ability to add messages to their structure so that the whole\u2013part \nrelationship can be realized. Because this method is intended specifically for composite \nclasses, it violates the Liskov substitution principle presented in Chapter 5. However, it pro-\nvides the functionality necessary to support efficient solution to the problem; therefore, its \nusage can be easily justified during design reviews. To minimize the effects of this viola-\ntion, careful attention needs to be paid when implementing the default behavior of the \nadd(Message*) method in the Message base class. The easiest solution is to provide a base \nimplementation that notifies the operator stating that the operation is not supported. That \nway, derived classes that do not support the add method would simply inherit the default \nListing 7.7: C++ Header File for the Message Class\nclass Message {\npublic:\n\t // Method to retrieve the message\u2019s id.\n\t int getId() const;\n\t // Method to retrieve the message\u2019s name.\n\t string getName() const;\n\t // Method to set the message\u2019s id.\n\t void setId(int id);\n\t // Method to set the message\u2019s name.\n\t void setName(string name);\n\t // Method to add messages to a composite message.\n\t virtual void add(Message* message);\n\t // Method to display messages to the console.\n\t virtual void print();\n\t // Method to transform the contents of this message to XML format.\n\t virtual string toXml() = 0;\n\t // Duplicate Messages using the prototype design pattern.\n\t virtual Message* clone() = 0;\nprivate:\n\t // The message\u2019s id.\n\t int _id;\n\t // The message\u2019s name.\n\t string _name;\n};\n", "page": 252, "type": "text", "section": "Page 252"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 229\nimplementation. A more sophisticated approach includes writing code that throws an excep-\ntion indicating that the operation is not supported. This way, calls to the add(Message*) \nmethod from leaf classes will result in exceptions that can explicitly notify developers of \nthis unsupported operation. The default implementation for both the add() and print\n() \nmethods is presented in Listing 7.8. Notice that the print method can be defined in the \nMessage base class to display the message\u2019s information. This implementation is appropri-\nate for leaf objects but not for composite objects; therefore, leaf objects can inherit this \nimplementation without further changes.\nThe main difference between the CompositeMessage class and all other messages in \nthe design is that the operations of the CompositeMessage need to support its \u00ad\ncontained \nmessages. For example, the print\n() method needs to display the information of the com-\nposite message and all of its contained messages. Similarly, the CompositeMessage \nclass needs to override the add(), toXml\n(), and clone() methods to appropriately sup-\nport all of its contained objects. The CompositeMessage class is specified in Listing 7.9.\nTo support the addition of primitive messages in the composite structure, a C++ \n\u00ad\ntemplate list is used, so the implementation of the add(Message*) method simply pushes \n\u00ad\nmessages to the back of the list. By using a list, implementing the print\n() method is made \neasy since all it has to do is iterate through the list and call each of the message object\u2019s \nprint\n() methods, as displayed in Listing 7.10.\nPrimitive objects of the message type are created by deriving from the Message base class \nand implementing all other application-specific required methods. For example, the video \nListing 7.8: C++ Implementation for the Add() and \nPrint() Methods of the Message Class\n#include \u201cMessage.h\u201d\n#include <string>\n#include <iostream>\n// Method to add messages to a composite message.\nvoid Message::add(Message* message) {\n\t // The default implementation lets clients know that the operation\n\t // is unsupported. This behavior is inherited by Leaf classes, but\n\t // overridden by Composite classes.\n\t std::cout<<\u201dMessages cannot be added to Leaf objects!\\n\u201d;\n}\n// Method to display messages to the console.\nvoid Message::print(void) {\n\t // The default behavior for displaying a message\u2019s information.\n\t // This behavior is inherited by Leaf classes, but overridden by\n\t // Composite classes.\n\t std::cout<<\u201dMessage \u201c<<_name.c_str()<<\u201d, Id: \u201c<<_id<<endl;\n}\n", "page": 253, "type": "text", "section": "Page 253"}
{"text": "230\u2002 \u2022\u2002 Software Engineering Design\ufeff\ncontrol message for the system is required to provide implementation for required toXml() and \nclone() methods and all other methods required to execute video control messages, such as the \nsetFrameRate() method. An example of the VideoControlMessage implementation \nis presented in Listing 7.11. In similar fashion, all other messages in the system are created.\nOnce the CompositeMessage and primitive messages are designed and implemented, \nthe client message generator can be implemented, as seen in Listing 7.12.\nAs seen, by using the composite design patterns message hierarchies containing both \nprimitive and composite objects can be created easily simply by adding objects to the com-\nposite objects via the add() interface method. For example, the \u00ad\npowerOnMessage, \n\u00ad\nselfTestMessage, and transmitStatusMessage, all sharing the Message \ninterface, are added to the composite message initializeTaskingMessage, \nListing 7.9: C++ Header File for the CompositeMessage Class\n#include <list>\n#include \u201cMessage.h\u201d\nclass CompositeMessage : public Message {\npublic:\n\t // Copy constructor.\n\t CompositeMessage(const CompositeMessage& other);\n\t // Overloaded constructor to set the message\u2019s name.\n\t CompositeMessage(string name);\n\t // Destructor to clean up memory for messages in _message.\n\t virtual ~CompositeMessage();\n\t // Method to add messages to this Composite Message.\n\t void add(Message* message);\n\t // Override the print method to display all messages in _message.\n\t virtual void print();\n\t // Method to transform the contents of this message to XML format.\n\t string Message::toXml();\n\t // Create a duplicate of the Composite Message using the prototype\n\t // design pattern.\n\t Message* clone();\nprivate:\n\t // The Messages that make up the Composite Message.\n\t list<Message*> _messages;\n};\n", "page": 254, "type": "text", "section": "Page 254"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 231\nwhich in turn is added to the composite message missionPlanMessage. Similarly, \n\u00ad\ncollectionMessage, which is a composite message, and shutdownMessage, which \nis a primitive message, are both added to the missionPlanMessage to create a full \n\u00ad\ncollection mission plan message. Once the whole message is created from its parts, the \n\u00ad\nmission plan message can be used to display its content and convert all messages contained \nin the missionPlanMessage to XML before being sent out via the communication link. \nThe\u00a0sample output for the code in Listing 7.12 is presented in Listing 7.13.\nBenefits\n\u2022\t Provides a design structure that supports both composite and primitive objects\n\u2022\t Minimizes complexity on clients by shielding them from knowing the operational \ndifferences between primitive and composite objects; clients that expect a primitive \nobject will also work with a composite object, since operations are called uniformly \non both primitive and composite objects\n\u2022\t Easy to create and add new component objects to applications\nListing 7.10: C++ Implementation of the Composite\u2019s \nAdd() and Print() Methods\n// Add a message to the collection of messages in the Composite\n// Message.\nvoid CompositeMessage::add(Message* message) {\n\t // Add this message.\n\t _messages.push_back(message);\n}\nvoid CompositeMessage::print() {\n\t // Display the Composite Message\u2019s name and id.\n\t cout<<\u201d\\nComposite Message: \u201c<<getName().c_str()\n\t \t\n<<\u201d, Id: \u201c<<getId()<<endl;\n\t // Retrieve an iterator for the _messages collection.\n\t list<Message*>::iterator pIter = _messages.begin();\n\t // Iterate through the messages that make up this composite\n\t // message and display their info.\n\t for( unsigned int i = 0; i < _messages.size(); i++ ) {\n\t \t // Display the message\u2019s information and move the iterator to\n\t \t // the next position.\n\t \t (*pIter++)->print();\n\t }\n}\n", "page": 255, "type": "text", "section": "Page 255"}
{"text": "232\u2002 \u2022\u2002 Software Engineering Design\ufeff\nFACADE\nThe facade design pattern is an object structural pattern that provides a simplified inter-\nface to complex subsystems. By providing a simplified interface, the facade design pattern \nprovides a higher level of abstraction that liberates clients from the responsibility of know-\ning the internal structure of various elements of the subsystem, which in turn reduces \ncoupling and simplifies client code. Facade also shields clients from changes that occur \nin the subsystem; by having a standardized facade interface, the internal structure of the \nsubsystem can vary without affecting clients. According to the Gang of Four (Gamma \net\u00a0al. 1995, p. 185), the intent of the facade design pattern is to\nProvide a unified to a set of interfaces in a subsystem. Facade defines a higher-level interface \nthat makes the subsystem easier to use.\nIn most practical applications, components or subsystems are created to abstract a \ncomplex behavior that the system must provide. In these cases, executing a complex \nListing 7.11: C++ Header File for the VideoControlMessage Leaf Class\n#include \u201cMessage.h\u201d\nclass VideoControlMessage : public Message\n{\npublic:\n\t // Constructor.\n\t VideoControlMessage(void);\n\t // Destructor.\n\t ~VideoControlMessage(void);\n\t // TODO: Specific video control methods.\n\t void setFrameRate(int framesPerSecond);\n\t // .\n\t // .\n\t // .\n\t // Method to transform the contents of this message to XML format.\n\t string toXml(void);\n\t // Duplicate the VideoControlMessage using the prototype design\n\t // pattern.\n\t Message* clone(void);\n};\n", "page": 256, "type": "text", "section": "Page 256"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 233\nListing 7.12: C++ Implementation for the Message Generator and Sample Usage\n// Create the initialization primitive messages.\nPowerOnMessage powerOnMessage;\nSelfTestMessage selfTestMessage;\nTransmitStatusMessage transmitStatusMessage;\n// The message to task the system to initialize properly.\nCompositeMessage initializeTaskingMessage(\u201cInitialize System\u201d);\n// Add copies of the power on, self test, and transmit status messages\n// to the initialize tasking composite message.\ninitializeTaskingMessage.add( powerOnMessage.clone() );\ninitializeTaskingMessage.add( selfTestMessage.clone() );\ninitializeTaskingMessage.add( transmitStatusMessage.clone() );\n// Collection Control Messages.\nTemperatureSensorControlMessage temperatureSensorControlMessage;\nVideoControlMessage videoControlMessage;\n// The message to task the system to collect information.\nCompositeMessage collectionMessage(\u201cInformation Collection\u201d);\n// Add the temp. sensor and video control messages to the collection\n// tasking composite message.\ncollectionMessage.add( temperatureSensorControlMessage.clone() );\ncollectionMessage.add( videoControlMessage.clone() );\n// Shutdown Messages.\nShutdownMessage shutdownMessage;\n// The message to task the system to complete Mission 1.\nCompositeMessage missionPlanMessage(\u201cMission 1 - Temperature\n\t\nand Video Collection\u201d);\n// Add the messages to the initialize, collection, and shutdown\n// messages to the mission plan composite message.\nmissionPlanMessage.add( initializeTaskingMessage.clone() );\nmissionPlanMessage.add( collectionMessage.clone() );\nmissionPlanMessage.add( shutdownMessage.clone() );\n// Before sending message, verify its content.\nmissionPlanMessage.print();\n// If content is valid, send the message through the system. Before\n// being sent out through the communication link, a call to\n// missionPlanMessage.toXml() is made to convert all of the\n// message\u2019s content to XML format.\n", "page": 257, "type": "text", "section": "Page 257"}
{"text": "234\u2002 \u2022\u2002 Software Engineering Design\ufeff\nsubsystem behavior may require the combination of multiple function calls from multi\u00ad\nple component and subsystem elements. For example, consider a software component \nthat provides various elements and functionality for assessing the integrity of a particu-\nlar computer. This component may contain elements responsible for particular items of \n\u00ad\ninterests, such as a file system element, memory element, and communication element. \nIn\u00a0this case, the facade design pattern can be used to abstract all elements in the sub\u00ad\nsystem by creating a method testSystem() that in turns calls upon the various elements of \nthe subsystem in the appropriate order to evaluate the integrity of the system. This allows \nclients to be associated only with the facade and relieves them from knowing the internals \nof the integrity assessment component.\nProblem\nConsider the sensor system described as part of the message generator in the previous \n\u00ad\nsection. Upon field deployment, it is desirable to test the system\u2019s capabilities to ensure \nthat the system works properly before engaging in autonomous operation. For this reason, \na graphical user interface is required to monitor and control the system in the field during \ninstallation. A conceptual diagram of both subsystems and their interactions is presented \nin Figure\u00a07.4.\nThe sensor subsystem consists of the following elements: SystemManager, SerialComm, \nFileSystem, DataAnalyzer, and WirelessComm. A typical set of operations to assess the \nintegrity of the system would require clients to know about all subsystem elements\u2014for \nexample, opening the serial port, sending a collection message to the system manager, and \nopening the wireless communication link. This adds complexity to the developers of the UI \nsubsystem, since they are required to know the details of the sensor sub\u00ad\nsystem. In \u00ad\naddition, \nin many practical applications, the internals of subsystem are prone to change; therefore, \nListing 7.13: Sample Output for the Message Generator Problem\nComposite Message: Mission 1 - Temperature and Video Collection, Id: 20\nComposite Message: Initialize System, Id: 20\nMessage Power On Message, Id: 0\nMessage Self Test Message, Id: 1\nMessage Transmit Status Message, Id: 2\nComposite Message: Information Collection, Id: 20\nMessage Temperature Sensor Control Message, Id: 3\nMessage Video Control Message, Id: 4\nMessage Shutdown Message, Id: 5\nPress any key to continue . . .\n", "page": 258, "type": "text", "section": "Page 258"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 235\nclients relying on the internal of subsystems must keep up with changes throughout devel-\nopment and maintenance phases. The designers of the sensor system wants an easy solu-\ntion to shield UI subsystem developers from changes in the sensor subsystem\u2014one that \nallows developers of the sensor subsystem to identify and set interfaces for the visible \naspects of the sensor subsystem so that clients can rely on this interface, giving develop-\ners of the sensor subsystem the ability to change the internals of the subsystem without \naffecting clients.\nStructure\nThe general and applied structure of the facade design pattern is presented in Figure\u00a07.5. \nAs seen, the facade provides functionality in terms of existing classes through a sim-\nplified interface. In most cases, a facade\u2019s functions will be implemented in terms of \nseveral\u00ad\n functions from different subsystem classes. This prevents clients from depending \non these internal subsystems; therefore, both complexity and dependencies on the client \nside are\u00a0reduced.\nConsider the set of operations required to retrieve sensor data, which may require open-\ning communication links, testing the connections, and scheduling a collection message. \nThese operations require interfacing with several components within the sensor sub\u00ad\nsystem. \nIn such cases, the UI subsystem is required to know the details required to carry out all of \nthese operations, which increases coupling and complexity of the UI. However, with the \nfacade design pattern, an interface method, named transmitSensorData(), can\u00a0be \nused to abstract all of the required operations to transmit sensor data, such as opening \nSerial\nComm.\nMsg In\nCon\ufb01gure\nMassages Out\nSystem Manager\nSensor Subsystem\nUser Interface Subsystem\nDecode\nExecute\nSend\nRecv\nSend\nRecv\nWireless\nComm.\nCon\ufb01gure\nRead\nData Out\nWrite\nData In\nFile System\nData Analyzer\nFIGURE 7.4\nConceptual diagram of wireless sensor system.\n", "page": 259, "type": "text", "section": "Page 259"}
{"text": "236\u2002 \u2022\u2002 Software Engineering Design\ufeff\nthe serial connection, opening the wireless connection, testing both connections, and \n\u00ad\nscheduling a collection message. A step-by-step procedure for applying the facade design \npattern includes\n\t\n1.\tIdentify all components involved in carrying out a subsystem operation.\n\t\n2.\tCreate an ordered list of the operations required to execute the subsystem operation.\n\t\n3.\tDesign a facade class that includes an interface method to carry out the subsystem \noperation. The facade class has dependencies to all other subsystem components \nrequired to carry out the subsystem operation.\n\t\n4.\tImplement the facade interface method by calling operations on one or more sub\u00ad\nsystem components, in the order identified in Step 2.\n\t\n5.\tAllow one or more clients to access the objects of the facade type so that they can gain \naccess to the subsystem operation. This creates a many-to-one relationship between \nexternal subsystems and the facade interface instead of many-to-many relationships.\nThe driving forces behind the facade are simplicity of client code and lower coupling. \nThe facade design pattern can be simply applied by creating an additional facade class \nthat provides simple functions summarizing the major external functions expected and \nrequired by clients.\nClient\nSubsystemClassA\nSubsystemClassB\nSubsystemClassC\nFacade\nSensorSystem\n+simpli\ufb01edInterface()\nSerialComm\nSystemManager\nFileSystem\nDataAnalyzer\nWirelessComm\nclient\n+enableSensor(sensorNum: int): void\n+enableAllSensors(): void\n+disableSensor(sensorNum: int): void\n+disableAllSensor(): void\n+transmitSensorData(sensorNum: int): void\n+transmitAllSensorData(): void\n+scheduleCollection(): void\nApplied View\nGeneral View\nFIGURE 7.5\nUML class diagram for the facade design pattern.\n", "page": 260, "type": "text", "section": "Page 260"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 237\nImplementation\nImplementing the facade design pattern is straightforward, since it simply provides behav-\nior in terms of other subsystems. An example facade method for transmitting sensor data \nis presented in Listing 7.14. As seen, many of the complexities associated with using the \nsubsystem elements are hidden by the facade. By depending only on the facade, clients are \nshielded from unnecessary details required to perform the operation.\nListing 7.14: C++ Implementation of One Method of the SensorSystem Facade\nvoid SensorSystem::transmitSensorData(int sensorNumber) {\n\t // Create an object for serial communications parameters.\n\t SerialParams params;\n\t params.setCommPort( SerialParams::COM_1 );\n\t params.setBaudRate( SerialParams::BR_9600 );\n\t params.setParity( SerialParams::PARITY_NO_PARITY );\n\t params.setByteSize( SerialParams::BYTE_SIZE_8 );\n\t params.setStopBits( SerialParams::STOP_BIT_ONE );\n\t // Retrieve pointer to the serial communication object.\n\t SerialComm* pSerialComm = SerialComm::getInstance();\n\t // Open the serial communication with the specified parameters.\n\t if( serialComm->open(params) ) {\n\t \t // Ready to communicate with collection nodes, now get ready for\n\t \t // transmitting the data via the wireless link.\n\t \t TcpConnection* pConnection = TcpConnection::getInstance();\n\t \t if( pConnection->open(TcpConnection::PORT_NUMBER,\n\t \t\nTcpConnection::IP_ADDRESS) ) {\n\t \t \t // Schedule a collection message.\n\t \t \t SystemManager::getInstance()->scheduleMessage(/*...*/);\n\t \t }\n\t \t else {\n\t \t \t // Log TCP error here.\n\t \t \t // Close serial connection.\n\t \t } // end if( pConnection->open(...)\n\t }\n\t else {\n\t \t // Log serial connection error here.\n\t } // end if( serialComm->open(...)\n} // end transmitSensorData function.\n", "page": 261, "type": "text", "section": "Page 261"}
{"text": "238\u2002 \u2022\u2002 Software Engineering Design\ufeff\nBenefits\n\u2022\t Shields clients from knowing the internals of complex subsystem, therefore minimiz-\ning complexity in clients\n\u2022\t Since the internals of the subsystem are prone to change, provides a stable interface \nthat hides changes to internal subsystems, therefore making client code more stable\n\u2022\t Promotes weak coupling on clients; clients depend on only one interface instead of \nmultiple interfaces\nBEHAVIORAL DESIGN PATTERNS\nBehavioral design patterns deal with encapsulating behavior with objects, assigning \nresponsibility, and managing object cooperation when achieving common tasks (Gamma \net al. 1995). Behavioral design patterns include many of the mainstream design patterns \nused in modern object-oriented frameworks and play a key role in the design of systems \nby making them independent of specific behavior, which is made replaceable with objects \nthroughout these design patterns. Therefore, parts of the system responsible for perform-\ning some algorithm or behavior do so by relying on a common interface without knowl-\nedge of how the actual behavior or algorithm is carried out. In addition, by controlling the \nbehavioral process with common interfaces, enforcing behavioral policies becomes easier, \ntherefore giving systems the ability to create algorithms that share a common interface \nbut that vary widely in behavior. Examples of behavioral patterns include the iterator and \nthe\u00a0observer.\nITERATOR\nThe iterator design pattern is an object behavioral pattern that provides a standardized way \nfor accessing and traversing objects in a collection data structure. A collection data struc-\nture may consist of arrays, vectors, lists, or other custom-designed structures. The iterator \ndesign pattern works by abstracting the way each specific collection structure operates on \nthe data so that clients are not required to have knowledge of the details of their internal \nstructure. According to the Gang of Four (Gamma et al. 1995, p. 257), the intent of the \niterator design pattern is to\nProvide a way to access the elements of an aggregate object sequentially without exposing its \nunderlying representation.\nBy providing a standard interface and encapsulated methodology for accessing elements \nof a collection structure, client code becomes more consistent and easier to maintain, since \n", "page": 262, "type": "text", "section": "Page 262"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 239\nchanging the internal structure of the data collection structure does not affect the way \nclient code interacts with the structure. Iterators are prevalent in software engineering; \ntheir presence can be found built-in in today\u2019s most common programming languages and \nframeworks, such as C++, Java, and the .NET framework.\nProblem\nA company\u2019s software system manages inventory, financials, and all other information \navailable from its two store branches. Each store carries specific computer products appro-\npriate for its location\u2019s demographics. During design, the software system is decomposed \ninto several components, including two components for deferring and abstracting design \ninformation relevant to requirements for each computer store branch. The detailed design \nof each component is carried out separately by two different software engineers; this \nresults in two different versions of data structures for managing and providing store prod-\nuct information. Now, anytime the software system is called upon to display information \nabout store products, it is required to identify between the two store branches so that the \ncorrect implementation for accessing store information can be executed. This problem is \nencountered every time a new computer store branch is added to the system; therefore, \na\u00a0uniform and standardized method for accessing computer store products from different \ncollection data structures is highly desirable. Consider the existing ComputerProduct \ncode for the store\u2019s software system, as presented in Listing 7.15. The ComputerProduct \nis the product class for all products carried at all store branches, which includes simple or \nadvanced computer products.\nConsider the case where the designer of one computer store branch uses a list data \nstructure to save computer products for the computer store branch carrying simple com-\nputer products. To retrieve the products from the simple computer store, a method is \nListing 7.15: C++ Specification of the ComputerProduct Type\nclass ComputerProduct {\npublic:\n\t // Return the product\u2019s id.\n\t int getProductId();\n\t // Return the product\u2019s price.\n\t int getPrice() const;\n\t // Return the product\u2019s description.\n\t string getDescription() const;\n\t // Other methods here...\n};\n", "page": 263, "type": "text", "section": "Page 263"}
{"text": "240\u2002 \u2022\u2002 Software Engineering Design\ufeff\nprovided, getProducts(), which returns a reference or pointer to the object of type \nSimpleProductList, as seen in Listing 7.16.\nThe second computer store, which carries advanced computer products, is designed to \nkeep track of computer products using a custom-made list data structure for the advanced \ncomputer products class. This list provides a method getProducts() that returns a \nreference or pointer to a collection object of type AdvancedProductList, as seen in \nListing 7.17.\nAs trivial as this problem may seem, it highlights problems in code that occur typically \nin software teams during practical applications. Different developers want to work with \ntheir own code, they may want to showcase their skills by developing a better collection \ndata structure, or the lack of oversight in the design process results in work redundancy. \nThis example presents the problem using two different (but almost similar) lists; however, \nin practical situations, the difference in design and implementation may involve signifi-\ncantly different approaches like arrays versus custom-defined lists versus library-specific \nlists, such as the C++ standard template library list. Lack of standardization in the way \nthat computer stores access and traverse through their products creates complexity for \nclients. Consider the software system code for displaying computer product information \nfrom both stores, as presented in Listing 7.18.\nListing 7.16: C++ Code for the SimpleComputerStore Class\n#include \u201cSimpleProductList.h\u201d\n// Simple Computer Store\nclass SimpleComputerStore {\npublic:\n\t // Constructor.\n\t SimpleComputerStore() { /*Connect to DB and initialize all\n\t \t \t\nproducts.*/ }\n\t // Computer store methods...\n\t // Return the computer products carried by the simple computer store.\n\t SimpleProductList* getProducts() {\n\t \t // Return the simple product list.\n\t \t return &_products;\n\t }\nprivate:\n\t // The list of simple computer products.\n\t SimpleProductList _products;\n};\n", "page": 264, "type": "text", "section": "Page 264"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 241\nNotice that by having different methods to retrieve each product (i.e., getSimple\u00ad\nProduct and getAdvancedProduct), the client code now requires a conditional state-\nment to differentiate between the two store branches, which results in two versions of code \nfor displaying product information. For each store added to the system, a new conditional \nstatement is required to support the display of the new computer store branch.\nStructure\nThe general and applied structure of the iterator design pattern is presented in Figure\u00a07.6. \nThe key to designing the iterator design pattern lies in the Iterator interface. As seen in \nthe General View portion of Figure\u00a07.6, the Iterator interface consists of the first\n(), \nnext\n(), isDone(), and currentItem() interface methods. These methods specify the \nfundamental operations that need to be provided by iterator objects that implement the \ninterface. Regardless of the collection data structure employed to store products, these inter-\nface methods can be used uniformly to traverse the items contained by the data structure. \nThe first\n() method is used to return the first item in the collection; the next\n() method \nis used to move the current item to the next element of the list; the \u00ad\ncurrentItem() \nmethod is used to return the product stored at the current location of the iterator; and \nthe isDone() method is used to determine if there are more products to traverse in the \n\u00ad\ncollection item.\nListing 7.17: C++ Code for the AdvancedComputerStore Class\n#include \u201cAdvancedProductList.h\u201d\n// Advanced Computer Store\nclass AdvancedComputerStore {\npublic:\n\t // Constructor.\n\t AdvancedComputerStore() { /*Initialize all products.*/ }\n\t // Computer store methods...\n\t // Return a pointer to the advanced product list.\n\t AdvancedProductList* getProducts() {\n\t \t // Return the advanced product list.\n\t \t return &_products;\n\t }\nprivate:\n\t // The computer products... in ProductList form.\n\t AdvancedProductList _products;\n};\n", "page": 265, "type": "text", "section": "Page 265"}
{"text": "242\u2002 \u2022\u2002 Software Engineering Design\ufeff\nAlso, in the General View of the iterator design pattern, the Aggregate interface speci-\nfies the method for instantiating and returning an iterator object. Clients use this object to \ntraverse the collection using the iterator interface instead of the concrete aggregate object. \nThis version of the iterator design pattern is the preferred version for new design efforts. \nHowever, in practice, the iterator can be designed differently from project to project, espe-\ncially when existing code is in place. For example, in the Applied View of Figure\u00a07.6, some \nListing 7.18: C++ Code for the Centralized Server \nSoftware to Display Computer Products\n// Simple store.\nSimpleComputerStore simpleStore;\nComputerProduct* pProduct = 0;\nSimpleProductList* simpleStoreProducts = simpleStore.getProducts();\n// Display simple store products.\nfor( int i = 0; i < simpleStoreProducts->size(); i++ ) {\n\t // Retrieve the product at index i.\n\t pProduct = simpleStoreProducts->getSimpleProduct(i);\n\t // Make sure pProduct is valid before using it!\n\t // Display product\u2019s information.\n\t cout<<\u201dProduct id: \u201c<<pProduct->getProductId()<<endl\n\t \t <<\u201dProduct price: \u201c<<pProduct->getPrice()<<endl\n\t \t <<\u201dProduct Description: \u201c<<pProduct->getDescription().c_str()<<endl;\n}\n//Advanced store.\nAdvancedComputerStore advancedStore;\nAdvancedProductList* advancedProducts = advancedStore.getProducts();\n// Display advanced store products.\nfor( int i = 0; i < advancedProducts->length(); i++ ) {\n\t // Retrieve the product at location i.\n\t pProduct = advancedProducts->getAdvancedProduct(i);\n\t // Make sure pProduct is valid before using it!\n\t // Display product\u2019s information.\n\t cout<<\u201dProduct id: \u201c<<pProduct->getProductId()<<endl\n\t \t <<\u201dProduct price: \u201c<<pProduct->getPrice()<<endl\n\t \t <<\u201dProduct Description: \u201c<<pProduct->getDescription().c_str()<<endl;\n}\n// Repeat here for all other types of lists!\n", "page": 266, "type": "text", "section": "Page 266"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 243\nof the iterator interface methods are omitted and the names are modified from the original \npattern. In addition, each concrete aggregate class is designed as of two independent and \nexisting classes in the system. This is necessary when code for the existing collection data \nstructures (e.g., SimpleProductList) cannot be modified. When examined closely, \nthe Applied View of Figure\u00a07.6 consists of the same relationships and similar interface \nmethods but are structured differently to account for the existing code. Similar variations \nof the iterator design pattern can be found in practice; therefore, modifying the iterator \nrelationships to fit a particular problem is common. Notice, however, that if code for both \nSingleProductList and AdvancedProductList is available for modification, the \nAggregate\nIterator\n+createIterator()\nConcreteAggregate\n+createIterator()\nSimpleProductList\n+createIterator(): StoreProductIterator*\n<<interface>>\nComputerStore\n+createIterator(): StoreProductIterator*\nAdvancedComputerStore\n+createIterator(): StoreProductIterator*\nAdvancedComputerStore\nAdvancedProductList\n+hasNext(): bool\n+getNext(): ComputerProduct*\n+reset(): void\n<<interface>>\nStoreProductIterator\n+hasNext(): bool\n+getNext(): ComputerProduct*\n+reset(): void\nSimpleStoreProductIterator\n+hasNext(): bool\n+getNext(): ComputerProduct*\n+reset(): void\nAdvancedStoreProductIterator\n+\ufb01rst()\n+next()\n+isDone()\n+currentItem()\nGeneral View\nConcreteIterator\n+\ufb01rst()\n+next()\n+isDone()\n+currentItem()\nApplied View\nFIGURE 7.6\nUML class diagram for the iterator design pattern.\n", "page": 267, "type": "text", "section": "Page 267"}
{"text": "244\u2002 \u2022\u2002 Software Engineering Design\ufeff\ndesign of these classes would take the place of the simple and advanced computer store \nfrom the Applied View of Figure\u00a07.6 to match the general view of the design pattern.\nIn the applied version, the hasNext\n() method is specified to return true if the col-\nlection data structure has more elements for traversal; the getNext\n() interface method \nis used to move the iterator\u2019s pointer to the next element in the collection and return the \nproduct stored at that location; finally, the reset\n() interface method is designed to reset \nthe collection index to the first item in the collection. Similar to the applied design for the \ncomputer store software, the iterator design pattern is applied in software systems with dif-\nferent interface methods to solve the original problem that the pattern describes.\nOnce the iterator is designed, the next key element of the design pattern involves design-\ning the concrete iterators that provide a uniform level of abstraction for each collection \nstructure (e.g., array, linked list) in the system. As seen in Figure\u00a07.6, for each concrete \niterator designed an association is made to the appropriate collection structure. This means \nthat each iterator knows the specific interface methods provided by its associated collection \nstructure so that it can use them to traverse and access its products. This way, when clients \nof the iterator call a method from the iterator interface (e.g., getNext\n()\n), the concrete \niterator can carry out the request internally in terms of the collection structure\u2019s inter-\nface method, hiding these details from its clients. Therefore, regardless of the collection \nstructure, clients of the iterator can always rely on the Iterator interface to traverse any \ncollection structure supported by concrete iterators. This property of the iterator design \npatterns is desirable in many practical applications.\nFinally, the iterator design pattern requires the design of the Aggregate interface which \nis manifested in the computer store problem as the ComputerStore interface. The impor-\ntance of this interface is that it allows clients of the computer store to create iterators for \ntraversing through the different store product items. As discussed earlier, the aggregate \n\u00ad\ninterface can be directly implemented by the class representing the collection structure \nor, if this code is unavailable, by another class that provides one more levels of abstrac-\ntion, such as the ComputerStore in Figure\u00a07.6. With this in place, clients rely on the \nComputerStore interface to create and return an iterator without needing to know the \nparticular type of store; once the iterator is returned, clients use the iterator interface to \ntraverse through the products, therefore providing a design that relies fully on interfaces \nrather than concrete implementations. This results in flexible designs that can be modified \nand adapted easily to future demands. The step-by-step approach for applying the iterator \ndesign pattern is as follows:\n\t\n1.\tIdentify and design the Iterator interface.\n\t\n2.\tFor each class representing a collection data structure in the software system, design \na concrete iterator and associate it with it. Implement the concrete iterator\u2019s methods \nin terms of the collection data structure.\n\t\n3.\tCreate the aggregate interface, which includes the interface method to create iterators.\n\t\n4.\tFor each class representing a collection data structure, implement the aggregate \ninterface to instantiate and return a concrete iterator.\n", "page": 268, "type": "text", "section": "Page 268"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 245\nThe driving forces behind the design are decreased complexity for clients and \u00ad\nflexibility. \nBy applying the iterator design pattern, clients are shielded from the internals of the \n\u00ad\ncollection data structure. This in turn provides flexibility by allowing new stores to be \nadded easily or different existing iterators to be swapped without changes to the client code.\nImplementation\nThe implementation of the iterator design pattern for the computer store system \nassumes that both collection data structures (i.e., simple and advanced lists) cannot be \nmodified. Therefore, the aggregate portion of the pattern is split, as seen in Figure\u00a07.6. \nThe implementation of the iterator design pattern begins with the specification of the \nStoreProductIterator interface, as seen in Listing 7.19. This interface is designed \nListing 7.19: C++ Specification of the StoreProductIterator Interface\n// Forward reference.\nclass ComputerProduct;\n// The base for all store product iterators.\nclass StoreProductIterator {\npublic:\n\t // Constructor.\n\t StoreProductIterator() : _position(0) { /*Intentionally left\n\t \t \t\nblank.*/}\n\t // Interface method for determining if more products are available.\n\t virtual bool hasNext() = 0;\n\t // Interface method for retrieving the next available product.\n\t virtual ComputerProduct* getNext() = 0;\nprotected:\n\t // Give access to derived classes for setting the iterator\u2019s\n\t // position.\n\t void setPosition(int position) { _position = position; }\n\t // Allow derived classes to retrieve the iterator\u2019s position.\n\t int getPosition(void) { return _position; }\n\t // Reset the iterator\u2019s position.\n\t void reset(void) { _position = 0; }\nprivate:\n\t // The iterator\u2019s current position.\n\t int _position;\n};\n", "page": 269, "type": "text", "section": "Page 269"}
{"text": "246\u2002 \u2022\u2002 Software Engineering Design\ufeff\nwith simplicity in mind; therefore it contains two main methods for iteration, hasNext\n() \nand getNext\n(). There are many different ways iterators can be designed; in this case, \nif\u00a0the method hasNext\n() returns true, a subsequent call to getNext\n() can be made to \nmove the iterator to the next element and to retrieve the product stored at that location.\nOnce the StoreProductIterator interface is specified, each concrete iterator can be \ncreated. Listing 7.20 presents the specification of the SimpleStoreProductIterator, \nwhich is the iterator used for traversing through in the simple computer store, which stores \ncomputer products in a simple product list. Since this iterator is designed to work with the \nsimple computer store, a SimpleProductList memory reference or pointer is passed \nto it in the constructor.\nAs expected, the interface methods for the SimpleStoreProductIterator type \nare implemented in terms of the SimpleProductList type, as seen in Listing 7.21. \nOf\u00a0particular interest is the getNext\n() method, which encapsulates the specific call to \ngetSimpleProduct\n() to retrieve a computer product.\nThe specification of the AdvancedStoreProductIterator is similar to the one \npresented in Listing 7.21 but is specific to the AdvancedProductList collection data \nstructure. Therefore, implementation of the AdvancedStoreProductIterator is \nmade in terms of this data structure, as seen in Listing 7.22.\nTo enforce the policy that all computer stores must support the iterator design pattern, a \nstandard ComputerStore interface is specified, as seen in Listing 7.23.\nComputer stores deriving from this interface must provide an implementation for the \n\u00ad\ncreateIterator() method before they can be instantiated. This provides clients with \na standard method for retrieving iterators from all computer stores. Listings 7.24 and 7.25 \npresent\u00ad\n the C++ implementation for both simple and advanced computer stores, respectively.\nListing 7.20: C++ Specification of the SimpleStoreProductIterator\nclass SimpleStoreProductIterator : public StoreProductIterator {\npublic:\n\t // Constructor.\n\t SimpleStoreProductIterator(SimpleProductList* products);\n\t // Determine if more products are available.\n\t bool hasNext();\n\t // If more products are available, get the next one.\n\t ComputerProduct* getNext();\nprivate:\n\t // Pointer to the simple computer product list.\n\t SimpleProductList* _products;\n};\n", "page": 270, "type": "text", "section": "Page 270"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 247\nListing 7.21: C++ Implementation for the SimpleStoreProductIterator\n#include \u201cSimpleStoreProductIterator.h\u201d\n#include \u201cSimpleProductList.h\u201d\n// Constructor.\nSimpleStoreProductIterator::\n\t \t SimpleStoreProductIterator(SimpleProductList* products) {\n\t // For simplicity, assume a valid pointer.\n\t _products = products;\n}\n// Determine if more products are available.\nbool SimpleStoreProductIterator::hasNext() {\n\t // The return value.\n\t bool isNextProductAvailable = false;\n\t if( getPosition() < _products->size() ) {\n\t \t isNextProductAvailable = true;\n\t }\n\t return isNextProductAvailable;\n}\n// If more products are available, get the next one.\nComputerProduct* SimpleStoreProductIterator::getNext() {\n\t // Temporary pointer to computer product.\n\t ComputerProduct* pProduct = 0;\n\t // Get the iterator\u2019s current position.\n\t int nextItem = getPosition();\n\t // Determine if there are more products.\n\t if( hasNext() ) {\n\t \t // Get the address of the next product and move the iterator\u2019s\n\t \t // position.\n\t \t pProduct = _products->getSimpleProduct(nextItem++);\n\t \t // Set the new position of the Iterator.\n\t \t setPosition(nextItem);\n\t }\n\t // Return the requested product.\n\t return pProduct;\n}\n", "page": 271, "type": "text", "section": "Page 271"}
{"text": "248\u2002 \u2022\u2002 Software Engineering Design\ufeff\nListing 7.22: C++ Implementation for the AdvancedStoreProductIterator\n#include \u201cAdvancedStoreProductIterator.h\u201d\n#include \u201cAdvancedProductList.h\u201d\n// Constructor.\nAdvancedStoreProductIterator::\n\t \t AdvancedStoreProductIterator(AdvancedProductList* products) {\n\t // For simplicity, assume valid pointer.\n\t _products = products;\n}\n// Determine if more products are available.\nbool AdvancedStoreProductIterator::hasNext() {\n\t // The return value.\n\t bool nextProductAvailable = false;\n\t if( getPosition() < _products->length() ) {\n\t \t nextProductAvailable = true;\n\t }\n\t return nextProductAvailable;\n}\n// If more products are available, get the next one.\nComputerProduct* AdvancedStoreProductIterator::getNext() {\n\t // Temporary pointer to computer product.\n\t ComputerProduct* pProduct = 0;\n\t // Get the iterator\u2019s current position.\n\t int nextItem = getPosition();\n\t // Determine if there are more products.\n\t if( hasNext() ) {\n\t \t // Get the address of the next product and move the iterator\u2019s\n\t \t // position.\n\t \t pProduct = _products->getAdvancedProduct(nextItem++);\n\t \t // Set the new position of the iterator.\n\t \t setPosition(nextItem);\n\t }\n\t // Return the requested product.\n\t return pProduct;\n}\n", "page": 272, "type": "text", "section": "Page 272"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 249\nWith the iterator design pattern in place, the function to display computer products in \nthe software system can be modified to work in terms of the iterator interface, as seen in \nListing 7.26.\nThe software system can now display each store\u2019s product using a unified interface, as \nseen in Listing 7.27. This design supports adding new computer stores without much effort.\nListing 7.23: C++ Specification of the ComputerStore Interface\nclass StoreProductIterator; // Forward reference.\n// The interface for all computer stores.\nclass ComputerStore {\npublic:\n\t // The interface method to create an iterator.\n\t virtual StoreProductIterator* createIterator() = 0;\n};\nListing 7.24: C++ Implementation for the Simple Computer Store\n#include \u201cSimpleStoreProductIterator.h\u201d\n#include \u201cSimpleProductList.h\u201d\n// Simple Computer Store\nclass SimpleComputerStore : public ComputerStore {\npublic:\n\t // Override the createIterator interface method to create the\n\t // appropriate iterator for simple computer stores.\n\t StoreProductIterator* createIterator() {\n\t \t // Create and return a simple store product iterator.\n\t \t return new SimpleStoreProductIterator(&_products);\n\t }\n\t // All other methods for simple computer stores.\nprivate:\n\t // The simple product list.\n\t SimpleProductList _products;\n};\n", "page": 273, "type": "text", "section": "Page 273"}
{"text": "250\u2002 \u2022\u2002 Software Engineering Design\ufeff\nListing 7.25: C++ Implementation for the Advanced Computer Store\n// Advanced Computer Store\nclass AdvancedComputerStore : public ComputerStore {\npublic:\n\t // Override the createIterator interface method to create the\n\t // appropriate iterator for advanced computer stores.\n\t StoreProductIterator* createIterator() {\n\t \t // Create and return an advanced store product iterator.\n\t \t return new AdvancedStoreProductIterator(&_products);\n\t }\n\t // All other methods for advanced computer stores.\nprivate:\n\t // The advanced product list.\n\t AdvancedProductList _products;\n};\nListing 7.26: C++ Implementation of the Display \nFunction in the Centralized Software\n// Display the products using the iterator.\nvoid displayProducts(StoreProductIterator* pIterator) {\n\t // Temporary pointer to hold a computer product.\n\t ComputerProduct* pProduct = 0;\n\t // Determine if there are more products to browse.\n\t while( pIterator->hasNext() ) {\n\t \t // Retrieve the next product.\n\t \t pProduct = pIterator->getNext();\n\t \t // Display the product\u2019s information.\n\t \t cout<<\u201d\\nProduct id: \u201c<<pProduct->getProductId()<<endl\n\t \t \t\n<<\u201dProduct price: \u201c<<pProduct->getPrice()<<endl\n\t \t \t\n<<\u201dProduct Description: \u201c<<pProduct->getDescription().c_str();\n\t }\n}\n", "page": 274, "type": "text", "section": "Page 274"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 251\nBenefits\n\u2022\t Provides a consistent way for clients to iterate through the objects in a collection\n\u2022\t Abstracts the internals of the collection objects so that if they change, clients do not \nhave to change\n\u2022\t Allows client code to be extended easily; numerous iterators can be created to support \ndifferent traversals from the same or different collection structure\nSkill Development 7.2: Iterator Design Pattern\nUsing the UML tool of choice, create the design presented in the Applied View Section \nof Figure\u00a07.6. Rename the aggregate interface method from ComputerStore to \n\u00ad\ncreate Product Iterator. Make the appropriate modifications to both simple and \nadvanced computer stores so that they work with the new interface method. Generate \ncode from the model, and \u00ad\ncreate a test driver code to verify the design. Once the code \ncompiles and executes, describe how your design benefited from using the iterator \ndesign pattern.\nListing 7.27: C++ Code for the Centralized Software \nto Create Iterators and Display Products\n// Simple store.\nSimpleComputerStore simpleStore;\n// Iterator for the simple store.\nStoreProductIterator* pIterator = simpleStore.createIterator();\n// Display the products using the iterator.\ndisplayProducts(pIterator);\n// Cleanup the simple computer store iterator.\ndelete pIterator;\n// Advanced store.\nAdvancedComputerStore advancedStore;\n// The advanced store iterator.\npIterator = advancedStore.createIterator();\n// Display the products using the iterator.\ndisplayProducts(pIterator);\n// Cleanup the advanced computer store iterator.\ndelete pIterator;\n", "page": 275, "type": "text", "section": "Page 275"}
{"text": "252\u2002 \u2022\u2002 Software Engineering Design\ufeff\nOBSERVER\nThe observer design pattern is an object behavioral pattern that standardizes the opera-\ntions between objects that interoperate using a one-to-many relationship. According to the \nGang of Four (Gamma et al. 1995, p. 293), the intent of the observer is to\nDefine a one-to-many dependency between objects so that when one object changes state, all \nits dependents are notified and updated automatically.\nIn many practical applications, a common design structure is required to support inter-\naction between objects that monitor a common data source so that when changes occur in \nthe data source the objects react appropriately. Consider a detailed design that supports the \nmodel\u2013view\u2013controller (MVC) architectural pattern from Chapter 4. In the MVC archi-\ntectural pattern, once the data in the model component changes, all views must change as \nwell. In cases such as the MVC, the observer design pattern provides the necessary struc-\ntural interfaces to allow one or more views to register with the model component. Once \nregistered, the observer design pattern provides the structural interfaces for executing a \nuniform change propagation mechanism for the model to notify all registered views of the \nrecent changes. The observer design pattern is very popular and prevalent in today\u2019s modern \nlanguages and frameworks, such as Java (i.e., Observable and Observer interfaces) and .NET.\nProblem\nA local university is designing a system for weather-alert notification that allows students, \nfaculty, and staff to receive notifications of class cancellations (due to weather) via e-mail, \nvoice call, or SMS text messages. Other methods of notification may be added in the \nfuture. The system is based on the weather data decision engine that interfaces with several \nweather-related data sources, fuses the information, and automatically decides whether \nclass cancellations are in effect. The university is interested in integrating the existing com-\nmunication services (i.e., e-mail, SMS, and voice) with the decision engine so that these \nservices can be triggered to initiate notification via their respective communication types. \nThe design must be flexible so that other types of communication mechanisms can be \nadded to the system in the future.\nStructure\nThe general and applied structure of the observer design pattern is presented in Figure\u00a07.7. \nThe typical application of the observer design pattern includes one concrete subject and \none or more concrete observers, as seen in the Applied View of Figure\u00a07.7.\nEach concrete observer is required to implement the update() interface method spec-\nified by the Observer interface. Similar to other design patterns, implementation of the \nobserver design pattern varies depending on particular details of projects. Specifically, \n", "page": 276, "type": "text", "section": "Page 276"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 253\nthe implementation of the update method is typically seen in two common versions. One \nversion includes passing as parameter the details of the change notification. Using this \napproach, concrete observers examine notification information using the update param-\neter and act accordingly. This is possible when the type of notification can be abstracted \nso that it provides a common interface for all other concrete observers. Another popular \napproach involves designing the update() method without parameters. Upon receiving \nchange notification, concrete objects call a method of the concrete subject to retrieve the \ndetails of the notified change. Since the behavior for attaching, detaching, and notifying \nobservers is the same, the Subject base class can specify and implement these methods, \nwhich are inherited by all other concrete subjects. The step-by-step approach for applying \nthe observer design pattern includes\n\t\n1.\tDesign the subject interface and implement code for attaching, detaching, and noti-\nfying observer objects. The code for keeping track of observers can be done using \nlinked-lists data structures.\n\t\n2.\tFor classes that manage information of interest to observers, inherit from the subject \nclass created in Step 1.\n\t\n3.\tDesign the observer interface, which includes the abstract update interface method.\n\t\n4.\tFor all observers in the system, implement the observer interface, which requires \nimplementing the update method.\n\t\n5.\tAt run time, create each observer and attach it to the subject. When changes occur, \nthe subject iterates through its list of registered objects and calls its update method.\n+attach(pObserver: Observer*): void\n+dettach(pObserver: Observer*): void\n#notify(): void\nSubject\nEmailService\n+update(): void\n<<interface>>\nObserver\n+update(): void\nConcreteObserver\nConcreteSubject\nDecisionEngine\nServiceNoti\ufb01er\nApplied View\nGeneral View\n+update(msg: string): void\n+attach(pService: Service*): void\n+detach(pService: Service*): void\n#notify(): void\n<<interface>>\nService\n+update(msg: string): void\nPhoneService\n+update(msg: string): void\nSmsService\n+update(msg: string): void\nFIGURE 7.7\nUML class diagram for the observer design pattern.\n", "page": 277, "type": "text", "section": "Page 277"}
{"text": "254\u2002 \u2022\u2002 Software Engineering Design\ufeff\nThe driving force behind the application of the observer design pattern is flexibility. \nBy\u00a0applying the observer design pattern, future additions of services can be done automati-\ncally, therefore leading to software that is easy to maintain.\nImplementation\nImplenting the observer design pattern begins with the ServiceNotifier class, which \nserves as base class for the subjects. As seen, the methods to provide registration and noti-\nfication services are implemented in terms of a C++ STL list, as presented in Listing 7.28.\nWith the registration mechanism in place, all services realize the Service \u00ad\ninterface to \nacquire notification capabilities. Listing 7.29 presents an example for the EmailService \nobserver.\nAn example of the registration and notification mechanism is presented in Listing 7.30. \nAs seen, many different observers can register with the DecisionEngine object to get \nnotifications of weather alerts.\nBenefits\n\u2022\t Flexibility for adding new services to the system\n\u2022\t Maintaining and modifying existing system services become easier because specific \nservices are compartmentalized\nListing 7.28: C++ Code to Provide Registration and Notification to Observers\n// Provide the registration mechanism for all observers.\nvoid ServiceNotifier::attach(Service* pService) {\n\t // Add this observer to the list of registered observers. Assume a\n\t // valid pointer.\n\t _services.push_back(pService);\n};\n// The trigger mechanism to notify all observers of class cancellation.\nvoid ServiceNotifier::notify(string message) {\n\t // Get an Iterator that points to the beginning of the\n\t // observers_ list.\n\t list<Service*>::iterator pIter = _services.begin();\n\t // Iterate through the list of observers and notify them.\n\t for( int i = 0; i < _services.size(); i++ ) {\n\t \t // Pass the message along to all registered observers.\n\t \t (*pIter++)->update(message);\n\t }\n}\n", "page": 278, "type": "text", "section": "Page 278"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 255\nSkill Development 7.3: Observer Design Pattern\nUsing the UML tool of choice, create the detailed component design of the MVC archi-\ntectural design presented in Figure\u00a04.9 using the observer design pattern. Generate \ncode from the model, and create a test driver method to validate the design. Explain \nthe differences between the MVC architectural pattern and the observer design pattern \nin this example.\nListing 7.29: C++ Code for the Update() Method \nof the EmailService Observer\nclass EmailService : public Service {\n\t public:\n\t // Once the Observable object changes, it will call this method.\n\t void update(string message) {\n\t \t // Open file containing all users registered for email\n\t \t // notification. Open connection to the Email server.\n\t \t // For all registered clients, notify them via email.\n\t }\n\t // ...\n};\nListing 7.30: C++ Registration and Notification\u00a0Mechanism \nof the WeatherDataObject\n// Sends message as email.\nEmailHandler emailHandler;\n// Sends message as text message.\nSmsHandler smsHandler;\n// Translates message to speech and sends it via the voice interface.\nVoiceHandler voiceHandler;\n// Assume that the decision engine object is a singleton.\nDecisionEngine::getInstance()->register(&emailHandler);\nDecisionEngine::getInstance()->register(&smsHandler);\nDecisionEngine::getInstance()->register(&voiceHandler);\n", "page": 279, "type": "text", "section": "Page 279"}
{"text": "256\u2002 \u2022\u2002 Software Engineering Design\ufeff\nCHAPTER SUMMARY\nStructural and behavioral designs patterns help identify problems that deal with the structure \nand behavior of software designs; they prescribe the classes required for their design solu-\ntion and interrelationships required to support object creation. These patterns allow design-\ners to quickly and systematically identify structural layouts of systems (or\u00a0subsystems) and \nprovide avenues for examining the system\u2019s interactions and quality evaluation within the \noperational system. Structural design patterns are patterns that deal with designing larger \nstructures from existing classes or objects at run time. They play a key role in the design and \nevolution of systems by allowing integration of new designs with existing ones, via object \ncomposition (i.e., object structural) or inheritance (i.e., class structural). By\u00a0allowing designs \nto build on other existing structures, systems can be made interoperable by designing com-\npatible interfaces for otherwise incompatible systems. Examples of structural design patterns \ninclude adapter, composite, and facade design patterns. Behavioral design patterns deal with \nencapsulating behavior with objects, assigning responsibility, and managing object coopera-\ntion when achieving common tasks. Behavioral design patterns include many of the main-\nstream design patterns used in \u00ad\nmodern object-oriented frameworks and play a key role in the \ndesign of systems by making them independent of specific behavior, which is made replace-\nable with objects throughout these design patterns. Therefore, parts of the system respon-\nsible for performing some algorithm or behavior do so by relying on a common interface \nwithout knowledge of how the actual behavior or algorithm is carried out. In\u00a0addition, by \ncontrolling the behavioral process with common interfaces, enforcing behavioral policies \nbecomes easier, therefore giving systems the ability to create algorithms that share a com-\nmon interface but vary widely in behavior. Examples of behavioral patterns include the \niterator and the observer. This \u00ad\nchapter explored each structural and behavioral design \npattern to present the problems they are designed to address together with the benefits \nthey provide. Identifying and designing using these design patterns can improve the effi-\nciency of the development \u00ad\nprocess and the quality of the final system.\nREVIEW QUESTIONS\n\t\n1.\tWhat are structural design patterns? What are they used for?\n\t\n2.\tCompare and contrasts the following patterns:\n\t\na.\t Adapter\n\t\nb.\t Composite\n\t\n3.\tWhat is the adapter design pattern? Explain its main benefits and features.\n\t\n4.\tWhat is the composite design pattern? List and explain the main features of the \nbuilder design pattern.\n\t\n5.\tGive an example each of both adapter and composite design patterns. Do not use the \nones presented in the chapter.\n", "page": 280, "type": "text", "section": "Page 280"}
{"text": "Structural and Behavioral\u00a0Patterns in Detailed Design\u2002 \u2022\u2002 257\n\t\n6.\tExplain the steps required to implement the composite design pattern.\n\t\n7.\tWhat is the facade design pattern? What does it do?\n\t\n8.\tWhat are the essential structural elements required in the composite design pattern?\n\t\n9.\tWhat are the main benefits of using the iterator design pattern?\n\t 10.\tWhat is the observer design pattern? Give one example of a particular software \n\u00ad\nfeature that you think is appropriate for applying the observer.\n\t 11.\tWhat are the essential elements required in the observer design pattern?\nCHAPTER EXERCISES\n\t\n1.\tYou have been hired to work on a car testing utility class. The car testing utility \nclass has one method with the following signature: void testCar(Car* pCar). \nAs seen, the testCar function is designed to test objects of the type Car. The \ncar interface supports the following methods: void enableCruise(), void \n\u00ad\nopenWindow(), void closeWindow(), and void accelerate(int mph). The \ntest utility function is currently being used to test objects of type TypicalCar, \nwhich support all interface methods. However, the test utility is now needed to test \nobjects of the new type RaceCar, however, the RaceCar type only supports the \naccelerateReallyFast(int mph) method. Use an appropriate design pattern \nto allow the RaceCar type to be used in the testCar utility function. Feel free to \nmake any assumptions necessary to complete the design. The usage and output are \npresented below.\nvoid testCar(Car* pCar)\n{\n\t pCar->enableCruise();\n\t pCar->openWindow();\n\t pCar->closeWindow();\n\t pCar->accelerate(50);\n}\n// Sample output - if typical car passed in to the test utility\n// function.\nTypicalCar::enabling smart cruise control...\nTypicalCar::opening 2 windows...\nTypicalCar::closing 2 windows...\nTypicalCar::accelerating fast to 50 mph...\n// Sample output - if race car passed in to the test utility\n// function.\nConcreteRaceCar::no cruise control available...\nConcreteRaceCar::no window available...\nConcreteRaceCar::no window available...\nConcreteRaceCar::accelerating really fast to 50 mph...\n", "page": 281, "type": "text", "section": "Page 281"}
{"text": "258\u2002 \u2022\u2002 Software Engineering Design\ufeff\nREFERENCE\nGamma, Erich, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns: Elements of Reusable \nObject-Oriented Software. Boston: Addison-Wesley, 1995.\n", "page": 282, "type": "text", "section": "Page 282"}
{"text": "259\n8\nPrinciples of Construction Design\nCHAPTER OBJECTIVES\n\u2022\t Understand the importance and role of construction design\n\u2022\t Identify, understand, and apply table-based and state-based func-\ntion design\n\u2022\t Identify, understand, and apply the general construction styles\n\u2022\t Understand how quality can be evaluated during construction design\nCONCEPTUAL OVERVIEW\nThe transition from software design to construction should occur with \nminimal effort. In some cases, component designs provide enough detail \nto allow their transformation from design artifact into code easily; how-\never, in other cases, a more fine-grained level of design detail is required. \nConstruction design provides a form of design that closely resembles code so \nthat complex operations can be planned and evaluated prior to implemen-\ntation in code. Once the correctness of operations is verified, the construc-\ntion design activity provides additional heuristics to enforce consistency \nin the code. Construction design provides the last form of design to create \nhigh-quality software operations that are correct, consistent, and efficient.\nWHAT IS CONSTRUCTION DESIGN?\nThe idea of the detailed design phase is to manage complexity so that \ndesign artifacts can be translated to code with minimal effort. Even though \n", "page": 283, "type": "text", "section": "Page 283"}
{"text": "260\u2002 \u2022\u2002 Software Engineering Design\ufeff\nsignificant attempts can be made during the detailed (component) design activity to \u00ad\ncreate \nextensive designs, in most practical applications transitioning from the component design \ndomain to code can still be daunting. Regardless of the amount of effort spent during \nthe design phase, additional design efforts may still be required during construction to \n\u00ad\nidentify, plan, and manage the construction of complex operations. This form of con-\nstruction design extends the work performed during detailed design to provide essential \ninformation that is used to generate correct, efficient, and consistent code. Construction \ndesign is the lowest level of detailed design that addresses the modeling and specification \nof function implementations. By designing complex operations, problem solutions can be \nevaluated, analyzed, and verified for correctness and efficiency before construction using \nprogramming languages. Construction design provides the means for evaluating problem \nsolutions using a form of design that closely relates to code\u2014that is, a form of design that \nmodels what the code does and how the code is specified.\nConstruction design can address problem solving from a dynamic (behavioral) perspec-\ntive, which provides the description of operations (such as methods and functions) and the \ninternal details and logic of each design entity (IEEE 2009). This approach involves graph-\nical, tabular, or other methods to model and specify the internal structure of functions \n(e.g.,\u00a0operations, routines) so that the algorithms or flows required to carry out a function\u2019s \nintent are evaluated and clearly specified. The algorithm approach minimizes complexity \nduring construction by providing a graphical method for specifying the details required \nby programmers to implement the function\u2019s code. A separate but closely related task per-\nformed when evaluating the quality of software construction deals with enforcing styles for \nestablishing a consistent approach to structuring function \u00ad\nimplementations. These styles \nplay a significant role in shaping the system\u2019s \u00ad\nmaintainability, complexity, and testability. \nTherefore, they are included as part of the construction design activity.\nConstruction design is not a new concept. In fact, there are many books covering con-\nstruction design under different names. McConnell (2004) specifies five levels of software \ndesign, the lowest two of which deal with division of data and routines within classes and \ninternal routine design. Similarly, Fox (2006) identifies a form of low-level design that fills \nthe gap between detailed design and programming and deals with issues such as opera-\ntion specification, including operation name, parameter types, and return types. Similarly, \nMeyer (1997) and Misfeldt, Bumgardner, Gray, and Xiaoping (2004) provide coverage of \nconstruction design.\nWHY STUDY CONSTRUCTION DESIGN?\nConstruction design is about developing abstract models of the structure and behavior of \nthe internal implementation of operations. From a behavioral perspective, construction \ndesign is important because it provides the means for evaluating different implementations \nfor a particular function before committing to it. Behavioral designs at this level provide \n", "page": 284, "type": "text", "section": "Page 284"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 261\nthe means to evaluate a function\u2019s completeness, complexity, testability, and maintainabil-\nity. They also provide the means for analysts to evaluate algorithms in regard to time\u2013space \nperformance and processing logic prior to implementation (IEEE 2009). Finally, since they \nprovide a representation of the code through graphical and tabular ways, they increase \ncollaborative evaluation efforts, since other members without knowledge of the particu-\nlar programming language in use can evaluate the design and contribute to the solution. \nThese collaboration efforts can lead to improvement in future phases, for example, the \ntesting phase, where construction designs can be used to generate unit test cases, or the \nmaintenance phase, where construction designs can be used to increase knowledge and \nunderstanding of the software behavior.\nFrom the structural perspective (i.e., construction styles), construction design is impor-\ntant because it provides heuristics for establishing a common criterion for evaluating the \nquality of the structure of code, which directly affects code readability and thus mainte-\nnance. Code with low readability leads to higher maintenance costs, since it requires more \neffort to understand (Collar 2005). Construction styles are important during the design \nand construction phases so that code generation from design models can be done \u00ad\ncorrectly. \nFrom a construction phase perspective, construction styles serve as a blueprint that ensures \nconsistency among teams of developers. Finally, as mentioned before, \u00ad\nduring the testing \nand maintenance phase construction styles increase code readability and understanding, \nwhich can result in minimized cost during these phases.\nBEHAVIORAL CONSTRUCTION DESIGN\nBehavioral designs at the construction level are used to model complex logic that is \nunknown or difficult to understand. This way, details required to describe an operation \ncan be discovered or evaluated without requiring code. The purpose of behavioral design \nis to model the dynamic aspects of code that makes up a particular function. Behavioral \ndesigns have been the topic of much research work in software engineering and are an \nintegral part of all major software design strategies (e.g., structured and object-oriented \ndesigns). Behavioral designs provide the means for assessing the completeness, correct-\nness, and quality of functions before actual implementation occurs and therefore are an \nessential activity for complex operations. Four major approaches to behavioral design at \nthe construction level are flow-based designs, state-based designs, table-based designs, and \nprogramming design languages.\nFlow-Based Designs\nFlow-based designs provide a systematic methodology for specifying the logic of opera-\ntions using a graphical approach. Two popular approaches for creating flow-based designs \ninclude flowcharts and Unified Modeling Language (UML) activity diagrams. Both work \n", "page": 285, "type": "text", "section": "Page 285"}
{"text": "262\u2002 \u2022\u2002 Software Engineering Design\ufeff\nwell for modeling the internal flow of routines because they can be defined using sequential \nprocess flows, loops, conditional statements, and other useful mechanisms needed to model \ncomplex business logic or complicated algorithms. UML activity diagrams provide power-\nful constructs for modeling complex logic at different stages of the software engineering \nlife cycle; however, when applied toward modeling logic, activity diagrams provide similar \nfeatures to flowcharts. Four important modeling constructs for flow-based designs are\n\u2022\t If statements\n\u2022\t Case statements\n\u2022\t Do while loop\n\u2022\t While loops\nThe common elements used to model flow-based designs using UML activity diagrams \nare presented in Figure\u00a08.1, together with examples of modeling conditional and repeti-\ntion statements.\nState-Based Designs\nFlow-based designs can be used to model operational logic by identifying the transitions \nfrom activity to activity required to perform an operation. However, in some cases the \noperational logic of a function or system is dictated by the different states that the system \nexhibits during its lifetime. That is, certain activities can be performed only when a system \nis in a particular state. When this occurs, the operational logic of a system can be modeled \nas a state machine using a (UML) state diagram. State diagrams are typically used to model \nthe behavior of complete system. However, in many practical applications, state diagrams \ncan be used to guide the logical design of one or more operations in the system. Consider \nthe state design presented in Figure\u00a08.2.\nFigure\u00a0 8.2 depicts the design of a software system that receives messages and per-\nforms operations based on the messages received and the system\u2019s state. That is, during \nthe power-on initialization state, the system only reacts to the GetStatus, SelfTest, and the \nSoftwareUpdate message. Once the SelfTest message is received, the system transitions \nto the self-test state, where system capabilities are evaluated to determine the integrity \nof the system. Once the self-test state is complete, two transitions can occur; if the tests \nwere successful then the system transitions to the operational state, and if any failures are \nencountered then the system enters a fault state, in which no commands can be executed. \nOnce the fault state is complete, the system transitions to a power-down state, which allows \nthe system to save all pertinent information to the file system before transitioning to the \n\u00ad\ninitialization (Power On) state.\nUpon successfully execution of the self-test state, the system transitions to the operational \nstate, where all messages in the system can be processed, including the SelfTest message and \nShutDown message. As seen, the state diagram presents the state of the system, together \nwith the transitions and the events that trigger each transition. Unlike the flow-based design \n", "page": 286, "type": "text", "section": "Page 286"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 263\napproach in the previous section, the system\u2019s state-based designs show the flow of opera-\ntions from state to state; it acts like a well-structured algorithm that is efficient, simple, \nadaptable, and understandable (Booch, Rumbaugh, and Jacobson 2005). It also presents \nthe full operation of a complete system during its lifetime, which can be derived from the \ndesign. Consider the implementation of Listing 8.1, which implements the state machine.\nInitially, the system is set to the Power-OnState; therefore, upon executing the code the \nexecutePowerOnState() method is called to process the received message and deter-\nmines if a state change is required (or not), as seen in Listing 8.2. Listing 8.2 uses a message \nqueue for retrieving messages received in the system.\nBranch\nTransition\nIf Statement\nCase Statement\ntrue\ntrue\ntrue\ntrue\nAction\nFinal State\nActivity 1\nActivity Diagram Examples\nInitial State\nElements in Activity Diagram\nActivity2\nActivity3\nActivity5\nActivity6\nActivity1\nfalse\nfalse\nfalse\nfalse\nDo While Loop\nActivity4\nActivity7\nActivity8\ntrue\nfalse\nWhile Loop\nFIGURE 8.1\nFlow-based logic design using UML activity diagrams.\n", "page": 287, "type": "text", "section": "Page 287"}
{"text": "264\u2002 \u2022\u2002 Software Engineering Design\ufeff\nThe source of the code presented in Listing 8.2 can be traced back to the state design \npresented in Figure\u00a08.2. As seen, once the EmbeddedComponent is in the power-on state, \nit can execute the messages only for updating the software, retrieving the component\u2019s \nstatus\u00ad\n, and executing a self-test. Messages containing different IDs cannot be executed in \nthis state; therefore, upon receiving any other message the system logs an event and waits \nfor the next message to be received. In a similar fashion, the code for all other states is \nimplemented according to the state design, as presented in Listings 8.3 and 8.4.\nAs seen, once the EmbeddedComponent enters the self-test state, it executes the appro-\npriate tests, and based on the tests results it sets the new system state to the operational \nor fault state, as defined in the state design. Assuming all tests are performed successfully, \nthe EmbeddedComponent transitions to the operational state, where all messages can be \nreceived and processed by the EmbeddedComponent. The implementation for the opera-\ntional sate is presented in Listing 8.4.\nTable-Based Designs\nMany times, the internal logic of routines is made up of complex conditional statements, \neach statement evaluating a condition (i.e., a cause) and providing some action (i.e.,\u00a0an \neffect) as a result. This can lead to an increasingly complex nesting structure that is \nerror-prone, hard to read, and hard to maintain. In these cases, the logic design can be \nmanaged using a decision table (Hurley 1982). A decision table is a well-structured table \nthat provides the means to formulate, evaluate, and improve the design of complex prob-\nlems that deal with cause and effect. The format of decision tables is presented in Table\u00a08.1.\nTable\u00a08.1 has four different sections. The first section is the Condition section, which \ncontains a list of all of the conditions present in the decision problem. The second \u00ad\nsection \nis the Action section, which contains a list of all possible outcomes that can result from one \nor more conditions occurring. The third and fourth sections are found in matrix form, \nadjacent to the Condition and Action sections. The matrix adjacent to the Condition \u00ad\nsection \nindicates all possible combinations of conditions for the decision problem, while the \nmatrix adjacent to the Action section indicates the corresponding actions. Combined, the \nSelfTest\nFault\nOperational\nPower On\nSelfTest\nMsg Received\nSelfTest Msg Received\nFault Processing\nComplete\nAll Other\nMessages Received\nPower Down Process Complete\nGetStatus Msg\nUpdateSoftware Msg\nShutDown\nMsg Received\nTest Passed\nTests did not pass\nPower\nDown\nFIGURE 8.2\nExample of a state design using UML state diagrams.\n", "page": 288, "type": "text", "section": "Page 288"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 265\nrespective columns in both matrices provide a policy for decision making in the \u00ad\ndecision \n\u00ad\nproblem. Four types of decision tables are as follows (Hurley 1982):\n\u2022\t Limited-entry decision table (LEDT)\n\u2022\t Extended-entry decision table (EEDT)\n\u2022\t Mixed-entry decision table (MEDT)\n\u2022\t Hybrid-entry decision table (HEDT)\nListing 8.1: C++ Implementation of the State Design\n// The state machine\u2019s execute method.\nvoid EmbeddedComponent::execute() {\n\t // Execute the state machine. _compnentState is a member variable\n\t // of the EmbeddedComponent class.\n\t switch( _componentState ) {\n\t \t case PowerOnState:\n\t \t \t // Execute in the power on state. When finished, allow the\n\t \t \t // executing function to determine if a state change is required\n\t \t \t // (or not) and set the state appropriately. This capability is\n\t \t \t // provided by executing functions in all other states.\n\t \t \t executePowerOnState();\n\t \t \t break;\n\t \t case SelfTestState:\n\t \t \t // Execute in the self test state.\n\t \t \t executeSelfTestState();\n\t \t \t break;\n\t \t case OperationalState:\n\t \t \t // Execute in the operational state.\n\t \t \t executeOperationalState();\n\t \t \t break;\n\t \t case FaultState:\n\t \t \t // Execute in the fault state.\n\t \t \t executeFaultState();\n\t \t \t break;\n\t \t case PowerDownState:\n\t \t \t // Execute in the power down state.\n\t \t \t executePowerDownState();\n\t \t \t break;\n\t \t default:\n\t \t \t // invalid state, log error.\n\t \t \t break;\n\t }\n}\n", "page": 289, "type": "text", "section": "Page 289"}
{"text": "266\u2002 \u2022\u2002 Software Engineering Design\ufeff\nLimited-Entry Decision Table\nThe LEDT is the simplest type of decision table in which the condition section of the \nLEDT presents Boolean conditional statements. That is, the condition section of the LEDT \n\u00ad\npresents features of the design problem that are either present or not, and their combined \npresence (or absence) triggers specific actions. Therefore, the condition entry section of \nthe LEDT consists of Boolean values, such as true or false or yes or no, that can be used to \ndefine different policies in the decision problem. For example, consider the LEDT design \nfor a function that computes discounts for the purchase of mobile phones. Two types of \ndiscounts are available, a store discount of $15 and a manufacturer discount of $30, as \npresented in Table\u00a08.2.\nUsing the information specified in the LEDT from Table\u00a08.2, the code for the function \nused to compute phone discounts can be easily implemented, simply by translating the \ninformation captured in the LEDT to code, as presented in Listing 8.5. The table name is \nListing 8.2: C++ Implementation of the PowerOn State\nvoid EmbeddedComponent::executePowerOnState() {\n\t // Assume messages are received and placed in a blocking message\n\t // queue. Therefore, the messageQueue.read call is a blocking call.\n\t Message* message = messageQueue.read(WAIT_FOREVER);\n\t // Retrieve the message\u2019s id.\n\t MessageIdType messageId = message->getId();\n\t // This state only processes three messages according to the state\n\t // diagram.\n\t if( messageId == UpdateSoftwareMsgId ) {\n\t \t // Cast message to an UpdateSoftwareMsg.\n\t \t // Retrieve the software image from the message and update\n\t \t // software.\n\t }\n\t else if( messageId == GetStatusMsgId ) {\n\t \t // Retrieve status from File System and return to client.\n\t }\n\t else if( messageId == SelfTestMsgId ) {\n\t \t // Cast message to a SelfTestMsg.\n\t \t // Retrieve the type of self test and change state.\n\t \t selfTestType_ = message->getTestType();\n\t \t _componentState = SelfTestState;\n\t }\n\t else {\n\t \t // Any other message received in this state results in an error.\n\t \t // Log the specific error here and do not change state.\n\t }\n}\n", "page": 290, "type": "text", "section": "Page 290"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 267\nListing 8.3: C++ Implementation of the SelfTest State\nvoid EmbeddedComponent::executeSelfTestState() {\n\t // No messages are processed during self test.\n\t // Perform either a simple, normal, or advanced test. Advanced tests\n\t // perform a complete test of the system, therefore they take\n\t // longer to complete.\n\t if( performTest(_selfTestType) ) {\n\t \t // Software and hardware are working properly. Log results and\n\t \t // change state to the operational state.\n\t \t _componentState = OperationalState;\n\t }\n\t else {\n\t \t // Faulty system software or hardware! Log results and change\n\t \t // state to the Fault state.\n\t \t _componentState = FaultState;\n\t }\n}\nListing 8.4: C++ Implementation of the Operational State\nvoid EmbeddedComponent::executeOperationalState() {\n\t // Assume messages are received and placed in a blocking message\n\t // queue. Therefore, the messageQueue.read call is a blocking call.\n\t Message* message = messageQueue.read(WAIT_FOREVER);\n\t // Retrieve the message\u2019s id.\n\t MessageIdType messageId = message->getId();\n\t // Process messages according to the state diagram.\n\t if( /* messageId == x */ ) {\n\t \t // Process message x.\n\t }\n\t else if( /* messageId == y */ ) {\n\t \t // Process message y.\n\t }\n\t else if (/* ... */ {\n\t \t // ...\n\t }\n\t else {\n\t \t // Invalid message. Log error.\n\t }\n}\n", "page": 291, "type": "text", "section": "Page 291"}
{"text": "268\u2002 \u2022\u2002 Software Engineering Design\ufeff\nused to name the function, and the two items in the conditional section of the table are \ntranslated as conditional statements in the code. The action portion of the table is used \nto determine the code executed when each of the conditional statements evaluate to true. \nFor\u00a0example, Policy 1 (P1) states that the $15 and $30 discounts are applied when both store \nand manufacturer discounts are active (as seen by the x\u2019s in the table). This behavior is seen \nin Listing 8.5.\nAlthough such a simple problem hardly requires effort to design, it is valuable in point-\ning out several important characteristics of LEDTs. As seen, the condition section contains \nfeatures that are either present or not for each policy defined in the problem. These condi-\ntions represent questions for determining the types of discounts (i.e., store or manufacturer \ndiscounts) that are in effect and the types of polices required for each possible combination \nof discounts. The condition entry section follows by providing answers to all possible com-\nbinations for the given problem. As seen, for an LEDT, the number of distinct elementary \npolicies is 2n, where n is the number of conditions in the condition section. In\u00a0this example, \nwhere n = 2, there are four distinct policies. It is also evident that the fourth policy (P4) is \nnever applied to the implementation presented in Listing 8.5. Therefore, this policy could \nhave been left out of the decision table, since it represents not an action but the absence of \none. Such policies that are left out of the decision table are referred to as missing policies. \nFinally, it can be seen that all policies result in a unique set of actions. When two or more \npolicies result in identical actions, the actions are considered redundant actions and can be \ncombined to simplify the decision table.\nExtended-Entry Decision Table\nWhereas the condition and action sections of LEDTs contain complete questions and \nactions, the condition and action sections of the EEDT are extended into the entry \u00ad\nsections \n(i.e., upper-condition entry section and lower-action entry section) of the decision table. \nThat is, in LEDTs, the condition section contained information that can be used to ask a \nTABLE\u00a08.1\nFundamental Structure of Decision Tables\nCondition\nCondition Entry\nAction\nAction Entry\nTABLE\u00a08.2\nLimited-Entry Decision Table for the Phone Discount Logic\nGet Phone Discount\nP1\nP2\nP3\nP4\nStore Discount\nT\nT\nF\nF\nManufacturer Discount\nT\nF\nT\nF\n$15 Discount\nx\nx\n$30 Manufacturer Discount\nx\nx\nNo Discount ($0)\nx\n", "page": 292, "type": "text", "section": "Page 292"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 269\ncomplete questions, such as, \u201cIs there a store discount in effect?\u201d In EEDTs, the \u00ad\ncondition \nand condition entry sections of the table are required to formulate a complete question, \nsuch as, \u201cIs the customer a regular, preferred, or VIP customer?\u201d Similarly, the action \n\u00ad\nsection must be combined with the action entry section of the decision table to formulate \na complete action, such as \u201cadd a free car kit to the purchase.\u201d In addition, the number of \npossible values for each condition and action in EEDTs is not bounded to two. An example \nof the EEDT for the customer discount logic is presented in Table\u00a08.3.\nListing 8.5: Implementation of the LEDT for the Phone Discount Function\nint getPhoneDiscount() {\n\t const int StoreDiscount = 15;\n\t const int ManufacturerDiscount = 30;\n\t // The total added phone discount.\n\t int phoneDiscount = 0;\n\t // Determine if the store discount applies.\n\t if( isStoreDiscountActive ) {\n\t \t // Apply the store\u2019s discount.\n\t \t phoneDiscount += StoreDiscount;\n\t }\n\t // Determine if the manufacturer discount applies.\n\t if( isManufacturerDiscountActive ) {\n\t \t // Apply the manufacturer\u2019s discount.\n\t \t phoneDiscount += ManufacturerDiscount;\n\t }\n\t // Return the total added phone discount.\n\t return phoneDiscount;\n}\nTABLE\u00a08.3\nExtended-Entry Decision Table for the Customer Discount Logic\nGet Phone Discount\nP1\nP2\nP3\nP4\nP5\nP6\nCustomer type is\nREG\nREG\nPRE\nPRE\nVIP\nVIP\nCredit score is\nBAD\nGOOD\nBAD\nGOOD\nBAD\nGOOD\nDiscount\n$0\n$15\n$10\n$25\n$50\n$100\nAdd a free\nHOLSTER\nCHARGER\nBLUE \nTOOTH\nCAR \nKIT\nDATA \nPLAN\nCAR KIT & \nDATA PLAN\n", "page": 293, "type": "text", "section": "Page 293"}
{"text": "270\u2002 \u2022\u2002 Software Engineering Design\ufeff\nAs seen, customers can be of type regular (REG), preferred (PRE), or very important \n(VIP); therefore, the number of possible values for the type of customer condition is three. \nAlso, actions can take on any form; the \u201cX\u201d used for denoting the presence or absence of \nactions in LEDTs cannot be applied in EEDTs. In this example, the number of possible \n\u00ad\nvalues for the credit score condition is two, denoting good and bad credit scores. Finally, \nthe number of distinct elementary policies in EEDTs is the product of all maximum num-\nbers of possible values for each condition. In this example, this result in 3 \u00d7 2 = 6 policies \n(i.e.,\u00a03\u00a0for Condition 1 and 2 for Condition 2).\nMixed-Entry Decision Table\nThe MEDT combines features from both LEDTs and EEDTs. For example, consider a com-\npany that sells mobile phones of different kinds and with different promotional discounts \nbased on the type of mobile phone. The software used to manage inventory and discounts \nuses a method to return the total discount that can be applied toward the purchase of a \nphone. The company carries three types of phones: a simple second-generation (2G) phone; \nan advanced third-generation phone (3G); and a special fourth-generation (4G) phone. \nDepending on the type of phone, different store discounts are applied toward the total \npurchase of the phone. For simple phones, when the manufacturer\u2019s discount is in effect \na $30 discount can be applied, whereas when the store discount is in effect a $15 discount \ncan be applied. When both discounts are in effect, a $45 discount can be applied toward \nthe purchase of the phone. For advanced phones, a default store discount of $60 is always \napplied. In addition, when the manufacturer\u2019s discount is in effect an additional $50 is \napplied; when the store discount is in effect an additional $60 can be applied, since a free \nBluetooth ear piece is included; and when all discounts are in effect all discounts can be \napplied toward the price of the phone. Finally, for special phones, a default discount of \n$120 is always applied. Additionally, discounts of $70, $180, or $370 (i.e., the sum of all dis-\ncounts) can be applied toward the purchase of a special phone. The problem is formulated \nusing the decision table presented in Table\u00a08.4.\nUsing the information presented in Table\u00a08.4, the construction of the function applying dis-\ncounts to phone products can take place. Listing 8.6 presents the code for the phone type used \nin this problem. As seen, the phone type includes interface methods for returning a phone\u2019s \ntype (i.e., simple, advanced, or special phone) and the particular discount that applies the \nphone type.\nUsing the phone type created, the code for the (getPhoneDiscount) function is presented \nin Listing 8.7. As seen, the code matches the table-based design presented in Table\u00a08.4.\nTable-Based Construction\nTable-based construction is a technique for transforming table-based designs to code \nthat is easy to maintain, read, and so forth. As seen, the resulting code for implementing \nthe table-based design from Table\u00a08.4 contains various conditional statements. Similarly, \ntable-based designs can result in complex code that is hard to read and maintain. When \n", "page": 294, "type": "text", "section": "Page 294"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 271\nthis occurs, table-based construction can be used to shift the complexity of logic to the \nproblem\u2019s data structure. Consider the data structures in Listing 8.8 designed for the \ntable-based design of Table\u00a08.4.\nAs seen, the logic defined in Table\u00a08.4 is now captured using data structures, through the \ndiscounts array. The discounts array consists of 12 different elements of the Discount \ntype. Each index in the array represents one of the 12 policies defined during the table-based \ndesign from Table\u00a08.4. For example, the element at index 0 of the discounts array contains \nthe discounts defined by P1 of Table\u00a08.4; the element at Index 1 contains the discounts \ndefined by P2, and so on. With this framework in place, the code from Listing 8.7 can be \nreduced to the one presented in Listing 8.9, which drastically reduces the amount of code \nrequired to achieve the same operation.\nProgramming Design Language\nProgramming design language (PDL) is a form of pseudo-code used widely for designing \ninternal function behavior. Its popularity stems from the use of natural languages\u2014as \nopposed to computer languages or graphical techniques\u2014to define the required behav-\nior of functions. This results in detailed function designs that are easier to create, review, \nand translate to code. In addition, the usage of a natural language in PDL provides a \n\u201c\u00ad\ncomments-first approach\u201d to constructing code for any programming language. Therefore, \nPDL should be written without concern given to the target programming language and \ndetailed enough that code can be generated with minimal effort.\nPDL can be effectively employed using a top-down approach that first describes the gen-\neral work performed by the function and then more specific operations within the function \n(McConnell 2004). The description of the general work performed by the function should \nTABLE\u00a08.4\nMixed-Entry Decision Table for the Phone Discount Logic\nGet Phone Discount\nSimple Phone \nPolicies\nAdvanced Phone \nPolicies\nSpecial Phone \nPolicies\nP1\nP2\nP3\nP4\nP5\nP6\nP7\nP8\nP9\nP10\nP11\nP12\nPhone type is\nS\nS\nS\nS\nA\nA\nA\nA\nSP\nSP\nSP\nSP\nManufacturer discount\nF\nT\nF\nT\nF\nT\nF\nT\nF\nT\nF\nT\nStore discount\nF\nF\nT\nT\nF\nF\nT\nT\nF\nF\nT\nT\n$15 discount\nx\nx\n$60 discount\nx\nx\nx\nx\n$120 discount\nx\nx\nx\nx\n$30 manufacturer discount\nx\nx\n$50 manufacturer discount\nx\nx\n$70 manufacturer discount\nx\nx\nBluetooth discount ($60)\nx\nx\n6-month data discount ($180)\nx\nx\nNo discount ($0)\nx\n", "page": 295, "type": "text", "section": "Page 295"}
{"text": "272\u2002 \u2022\u2002 Software Engineering Design\ufeff\ninclude the function\u2019s intent, inputs, and outputs. Once the general purpose of the function \nis in PDL form, individual parts are elaborated in PDL form to provide complete design \ndetails for the function. When finished, the function\u2019s detailed PDL should result in the \nidentification of operations that support the general description of the function. Therefore, \nPDL can be used as both design technique and effective documentation approach for func-\ntions and code within functions. An example of a detailed function design using PDL is \npresented in Listing 8.10.\nThere are many benefits of using PDL. First, PDL provides a programming language-\nindependent technique for creating detailed function designs; therefore, collaborative \nefforts with all disciplines involved in the project can be achieved to provide complete \nreviews for the design of a function. That is, members from the systems, hardware, quality, \nand test groups can all chime in to help the function design meet the required capabilities \nListing 8.6: Implementation of the Phone Class to Support the Table-Based Design\n// The different types of phones.\ntypedef enum{ SIMPLE_PHONE = 0, ADVANCED_PHONE = 1, SPECIAL_PHONE = 2} \nPhoneType;\n// The different types of discounts options.\ntypedef enum{ NO_DISCOUNT = 0,\n\t MANUFACTURER_DISCOUNT = 3,\n\t STORE_DISCOUNT = 6,\n\t COMBINED_DISCOUNT = 9} DiscountType;\n// The Phone class.\nclass Phone {\n\t public:\n\t \t // Constructor.\n\t \t Phone(PhoneType type, DiscountType discountType) {\n\t \t \t _type = type;\n\t \t \t _discountType = discountType;\n\t \t }\n\t \t // Return the type of phone.\n\t \t PhoneType getType(){ return _type; }\n\t \t // Return the discount type for this phone.\n\t \t DiscountType getDiscountType() { return _discountType; }\n\t private:\n\t \t PhoneType _type;\n\t \t DiscountType _discountType;\n};\n", "page": 296, "type": "text", "section": "Page 296"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 273\nListing 8.7: Implementation for the Phone Discount Function\nint getPhoneDiscount(const Phone& phone) {\n\t int totalDiscount = 0; // The total computer discount.\n\t if( phone.getType() == SIMPLE_PHONE ) {\n\t \t if( phone.getDiscountType() == MANUFACTURER_DISCOUNT) {\n\t \t \t // Add $30 manufacturer\u2019s discount to totalDiscount.\n\t \t }\n\t \t else if( phone.getDiscountType() == STORE_DISCOUNT ) {\n\t \t \t // Add $15 store discount to totalDiscount.\n\t \t } else if( phone.getDiscountType() == COMBINED_DISCOUNT ) {\n\t \t \t // Add $30 and $15 to totalDiscount.\n\t \t }\n\t \t else { // No discount.\n\t \t }\n\t }\n\t else if( phone.getType() == ADVANCED_PHONE ) {\n\t \t // Add $60 default advanced phone discount to totalDiscount.\n\t \t if( phone.getDiscountType() == MANUFACTURER_DISCOUNT) {\n\t \t \t // Add additional $50 manufacturer\u2019s discount to totalDiscount.\n\t \t }\n\t \t else if( phone.getDiscountType() == STORE_DISCOUNT ) {\n\t \t \t // Add additional Bluetooth ear piece discount ($60) to\n\t \t \t // totalDiscount.\n\t \t }\n\t \t else if( phone.getDiscountType() == COMBINED_DISCOUNT ) {\n\t \t \t // Add additional $50 and $60 to totalDiscount.\n\t \t }\n\t \t else { // No additional discount.\n\t \t }\n\t }\n\t else if( phone.getType() == SPECIAL_PHONE ) {\n\t \t // Add $120 default special phone discount to totalDiscount.\n\t \t if( phone.getDiscountType() == MANUFACTURER_DISCOUNT) {\n\t \t \t // Add additional $70 manufacturer\u2019s discount to totalDiscount.\n\t \t }\n\t \t else if( phone.getDiscountType() == STORE_DISCOUNT ) {\n\t \t \t // Add additional 6 month data plan discount ($180).\n\t \t }\n\t \t else if( phone.getDiscountType() == COMBINED_DISCOUNT ) {\n\t \t \t // A additional $70 and $180 to totalDiscount.\n\t \t }\n\t \t else { // No additional discount.\n\t \t }\n\t }\n\t return totalDiscount; // Return the computed phone discount.\n}\n", "page": 297, "type": "text", "section": "Page 297"}
{"text": "274\u2002 \u2022\u2002 Software Engineering Design\ufeff\nfrom different viewpoints. Another important benefit from using PDL is the reduction of \ncommenting efforts. Since PDL is written at the construction design level, it provides full \ndocumentation of what the function does and the meaning of actions within \u00ad\noperations; \ntherefore, once code is generated PDL is turned into complete and meaningful program-\nming-language comments for the function (McConnell 2004). Finally, using the PDL \napproach greatly benefits the documentation effort, especially when using documentation \ntechniques that allow for the creation of software documentation from the comments in \ncode (e.g., Javadoc). In these cases, PDL provides the process for creating, reviewing, and \nevaluating the function documentation, therefore increasing its quality.\nSOFTWARE CONSTRUCTION USING STYLES\nConstruction styles are not about programming but about defining the rules or guidelines \nfor everyone in the project for writing the source code for a computer program. Combined \nwith the logic design, styles provide the final piece to generate high-quality and consistent \nListing 8.8: Table-Based Implementation for Computing Phone Discounts\nstruct Discounts {\n\t\nint smallStoreDiscount;\t\n// For this example, it should be $15.\n\t\nint mediumStoreDiscount;\t\n// For this example, it should be $60.\n\t\nint highStoreDiscount;\t\n// For this example, it should be $120.\n\t\nint smallManufacturerDiscount;\t // For this example, it should be $30.\n\t\nint mediumManufacturerDiscount;\t\n// For this example, it should be $50.\n\t\nint highManufacturerDiscount;\t\n// For this example, it should be $70.\n\t\nint bluetoothDiscount;\t\n// For this example, it should be $60.\n\t\nint dataPlanDiscount;\t\n// For this example, it should be $180.\n};\n// The discounts available for simple phones (SIM), advanced phones (ADV), \n// and special phones (SPE), all accessible via discount keys (DK#).\nDiscounts discounts[] = {\n\t\n{ 0, 0, 0, 0, 0, 0, 0, 0\t\n}, // DK0, SIM/ No discounts.\n\t\n{ 0, 60, 0, 0, 0, 0, 0, 0\t\n}, // DK1, ADV/ Store\u2019s default discount.\n\t\n{ 0, 0, 120, 0, 0, 0, 0, 0\t\n}, // DK2, SPE/ Store\u2019s default discount.\n\t\n{ 0, 0, 0, 30, 0, 0, 0, 0\t\n}, // DK3, SIM/ Manufacturer\u2019s discount.\n\t\n{ 0, 60, 0, 0, 50, 0, 0, 0\t\n}, // DK4, ADV/ Manufacturer\u2019s discount.\n\t\n{ 0, 0, 120, 0, 0, 70, 0, 0\t\n}, // DK5, SPE/ Manufacturer\u2019s discount.\n\t\n{ 15, 0, 0, 0, 0, 0, 0, 0\t\n}, // DK6, SIM/ Special store discount.\n\t\n{ 0, 60, 0, 0, 0, 0, 60, 0\t\n}, // DK7, ADV/ Default & spec. store disc.\n\t\n{ 0, 0, 120, 0, 0, 0, 0, 180\t\n}, // DK8, SPE/ Default & spec. store disc.\n\t\n{ 15, 0, 0, 30, 0, 0, 0, 0\t\n}, // DK9, SIM/ All applicable discounts.\n\t\n{ 0, 60, 0, 0, 50, 0, 60, 0\t\n}, // DK10, ADV/ All applicable discounts.\n\t\n{ 0, 0, 120, 0, 0, 70, 0, 180\t\n} // DK11, SPE/ All applicable disc.\n};\n", "page": 298, "type": "text", "section": "Page 298"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 275\nimplementations for programming problems. As a general principle, programming styles \nmust provide rules that ensure consistency, simplicity, and clarity of code. Numerous \nstyles have been proposed. Baldwin, Gray, and Misfeldt (2006) provide an extensive list of \nguidelines for formatting code using the C# programming language. Similarly, Misfeldt, \nBumgardner, and Gray (2004) and Vermeulen, Ambler, Bumgardner, Metz, Misfeldt, and \nShur (2000) presented equivalent work for the C++ and Java language. Besides the styles \ncovered\u00ad\n in Chapter\u00a05, typical styles used during\u00ad\n construction design include\n\u2022\t Formatting conventions\n\u2022\t Naming conventions\n\u2022\t Documentation conventions\nFormatting Conventions\nCommon styles for formatting code include the use of white spaces, indentation, and \nbracket placement. White spaces can be used to separate keywords, parentheses, curly \nbraces, binary operators, and commas (Baldwin et al. 2006) in such a way that the resulting \ncode is consistent, easier to read, and easier to maintain. For example, consider the use of \nwhite spaces to separate keywords, parentheses, and curly braces in control flow statements.\nListing 8.9: Table-Based Construction of\u00a0the Phone Discount Function\n// The table-based version for retrieving discounts.\nint getPhoneDiscount( const Phone& phone ) {\n\t // Compute the key for accessing the corresponding table row.\n\t int discountKey = phone.getType() + phone.getDiscountType();\n\t // Add all discounts associated with the discount key.\n\t int totalDiscount =\t\ndiscounts[discountKey].smallStoreDiscount +\n\t \t\ndiscounts[discountKey].mediumStoreDiscount +\n\t \t\ndiscounts[discountKey].highStoreDiscount +\n\t \t\ndiscounts[discountKey].smallManufacturerDiscount +\n\t \t\ndiscounts[discountKey].mediumManufacturerDiscount +\n\t \t\ndiscounts[discountKey].highManufacturerDiscount +\n\t \t\ndiscounts[discountKey].bluetoothDiscount +\n\t \t\ndiscounts[discountKey].dataPlanDiscount;\n\t // Return the total discount.\n\t return totalDiscount;\n}\n// Create a simple phone with manufacturer\u2019s discount.\nPhone phone(SIMPLE_PHONE, MANUFACTURER_DISCOUNT);\n// Display the phone\u2019s discount.\ncout<<\u201dTotal Phone Discount: \u201c<<getPhoneDiscount( phone )<<endl;\n", "page": 299, "type": "text", "section": "Page 299"}
{"text": "276\u2002 \u2022\u2002 Software Engineering Design\ufeff\nListing 8.11 presents three different ways white space can be used. Adopt a consistent style \nfor spacing elements, and follow it consistently in your organization. In the case of binary \noperators, which require two operands, it is suggested that a single space be used on both sides \nof the operator, when applicable, as seen in Listing 8.12. Another important place to apply \nwhite spaces in common languages, such as C++, Java, and C#, is after commas and semi\u00ad\ncolons, which are delimiters, also demonstrated in Listing 8.12.\nIndentation\nIndentation is a simple way to improve program readability. Programs that do not apply \nindentation consistently can be hard to read. Similarly, programs that do not apply appropri-\nate forms of indentation may result in inappropriately formatted text when viewing on dif-\nferent platforms. Indentation is typically employed by applying two white spaces\u2014this varies \nper project\u2014in front of one or more related program statements that need to be differentiated \nfrom other statements. However, the choice of number of white spaces must be defined by the \nproject policy. For example, one or more statements related in code can be grouped by the \nListing 8.10: Example PDL for a System\u2019s Event-Handling Capabilities\nThis function writes events occurring in the system to the event \nconsole. Events are displayed together with their classification and \ndescription, which are both provided by the client\u2019s calling func-\ntion. In addition, the number of events received for each type of \nevent is computed and displayed in the event console. Events are \nrequired to have id and description. The function returns a value \nindicating success/failure of the operation.\nSet the value of the function status to \u201cfailure\u201d\nDetermine if the event id is valid\nIf the event id is valid\n\t Use the event id to determine the type of event\n\t Increment by one the counter that keeps track of the number of\n\t events logged of this type to reflect this newly received event.\n\t Write the event id, description, and event counter to the event\n\t console and set the return value to \u201csuccess\u201d\nIf the event id is not valid\n\t Set the event id to \u201cunknown\u201d\n\t Set the event description to \u201cinvalid event ...\u201d\n\t Write the event id and description to the event console\nReturn the value of the function status\n", "page": 300, "type": "text", "section": "Page 300"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 277\nnumber of white spaces used in indentation. Consider the example presented in Listing\u00a08.13, \nwhere conditional statements are indented consistently throughout the program.\nAn important thing to consider when applying indentation is the prevention of tab \ncharacters, since they are interpreted differently in different development environments \n(Misfeldt et al. 2004). This means that code that appears properly indented can look \ndrastically different when viewed by other developers reviewing the code in a different \nenvironment. In today\u2019s popular code editors (e.g., MS Visual Studio and Eclipse), this \nproblem can be easily solved by configuring the editor to replace tab characters with \nwhite spaces automatically on new or existing code. Another important characteristic \nhighlighted by Listing 8.13 is the difficulty of matching opening and closing brackets in \nnested statements. This can lead to complex code that is hard to maintain. When encoun-\ntered with a highly nested code statement in programming languages that use brackets, \nit\u00a0is desirable to match closing brackets with opening ones, as seen in Listing\u00a08.14.\nListing 8.11: Styles for Whitespaces to Separate\u00a0Keywords, \nParentheses, and Curly Braces\n// Style #1: White space after keyword.\nif\u2219(x)\u2219{\n}\n// Style #2: White space after parenthesis and parameter.\nif(\u2219x\u2219)\u2219{\n}\n// Style #3: White space after keyword, parenthesis and parameter.\nif\u2219(\u2219x\u2219)\u2219{\n}\nListing 8.12: Styles for White Spaces in Binary\u00a0Operators \nand after Commas and Semicolons\n// White before and after binary operators.\nint x\u2219=\u2219y\u2219+\u2219z;\n// Using Style #2 of white spaces.\n// White space after comma.\nint x,\u2219y,\u2219z;\n// White space after semicolon.\nfor( int i = 0;\u2219i < maxSize;\u2219i++ ) {\n}\n", "page": 301, "type": "text", "section": "Page 301"}
{"text": "278\u2002 \u2022\u2002 Software Engineering Design\ufeff\nBrace Placement\nBrace placement is another commonly used technique for formatting code. Styles for \nbrace placement are applied in many languages for class definitions, function defini-\ntions, conditional and repetitive statements, and exception handlers. Two major styles \ninclude the application of the opening brace in-line or the application of the opening \nbrace on a new line, aligned with the first character of the statement that controls the \nstatements inside the braces. Regardless of the style applied for the opening brace, the \nclosing brace is applied on a new line. Listings 8.15 and 8.16 present examples of both \nin-line and new-line styles, respectively.\nListing 8.13: Styles for White Spaces in Nested Statements\n// Indentation of nested statements.\nif( x == y ) {\n\u2219\u2219// Code here is appropriately indented with 2 white spaces.\n\u2219\u2219if( z == r ) {\n\u2219\u2219\u2219\u2219// Code here is appropriately indented with 4 white spaces.\n\u2219\u2219\u2219\u2219if( c == a ) {\n\u2219\u2219\u2219\u2219\u2219\u2219// Code here is appropriately indented with 6 white spaces.\n\u2219\u2219\u2219\u2219}\n\u2219\u2219}\n}\nListing 8.14: Matching Closing and Opening Brackets in Nested Statements\nvoid computeValue() {\n\t while( /*some condition*/ ) {\n\t \t for( /*some condition, iterate*/ ) {\n\t \t \t if( /*some condition*/ ) {\n\t \t \t \t switch( /*some condition*/ ) {\n\t \t \t \t \t // ...\n\t \t \t \t } // end switch\n\t \t \t } // end if\t\n\t \t } // end for\n\t } // end while\n}\n", "page": 302, "type": "text", "section": "Page 302"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 279\nNaming Conventions\nNaming conventions can help programmers develop models for differentiating different \naspects of software programs and maintain consistency through software items. This can \nin turn result in code that is self-documented by the use of conventions applied consis-\ntently in the code. Naming conventions can be used to differentiate all elements that com-\npose a software program; therefore, consistent use of naming style can help software teams \nto better understand the work done by each other. When applied consistently, styles can \neasily help software developers, testers, and maintainers understand the code and make \nassumptions about it based on the programming style.\nA general naming convention that applies to all elements in a software program is the \nuse of meaningful names. Meaningful names are ones that are complete and contextually \ncorrect. Naming conventions should lead to names that unambiguously and completely \ndefine the intent of the entity that they represent. Names should be chosen so that they \nclearly define entities so that they quickly become familiar to those who read and maintain \nthe code. Failure to select meaningful names can result in code that is hard to understand, \nfollow, and maintain. Examples of bad and good examples of meaningful names are pre-\nsented in Listing 8.17.\nListing 8.17 presents several cases of good and bad names. Example 1 presents the \nchoice of using rdo1 and rdo2 for names to describe two Radio objects. These names \nare incomplete and as a consequence can make the code hard to understand, debug, and \nListing 8.15: In-line Bracket Placement Style\n// Inline brace placement style in C++ class definition.\nclass List {\n\t // ...\n};\n// Inline brace placement style in function definition.\nvoid append() {\n\t // ...\n}\n// Inline brace placement style in conditional statements.\nif( condition == true ) {\n\t // ...\n}\nelse {\n\t // ...\n}\n// Inline brace placement style in loops.\nwhile( condition == true ) {\n\t // ...\n}\n", "page": 303, "type": "text", "section": "Page 303"}
{"text": "280\u2002 \u2022\u2002 Software Engineering Design\ufeff\nmaintain. Example 2 shows the usage of the name xmit to abstract the transmission func-\ntion of a radio object. Developers who are not familiar with this abbreviation of the word \ntransmit may find it difficult to find the appropriate function call in the documentation \nto transmit a message. In addition, consider the case where the integrated development \nenvironment (IDE) supports the intellisense feature. In this case, developers would intui-\ntively and without success type the letter t in hopes that the IDE would reveal a function \nname that somewhat relates to the transmission behavior required by the radio object. \nExample 3 presents the case where the name chosen is both incomplete and inappropri-\nate for the program\u2019s context. That is, it is hard to determine the correct meaning of the \ncode when using s and MaxAmount. This is mainly because s does not describe the entity \nbeing evaluated and MaxAmount can refer to multiple limits that relate to different prop-\nerties (e.g., max salary, max number of items). These names are improved by making them \ncomplete and appropriate for the context. Finally, Example\u00a04 presents an example of a \ncontextually inappropriate name for an object of type DirectoryManager. In this case, \nobjects of type DirectoryManager monitor a directory for cleanup. Once the directory \nreaches a specified threshold, objects of the DirectoryManger type would begin delet-\ning files. The choice of name reaper and destroy are not appropriate for this context. \nReaper and destroy seem more appropriate for a gaming context; therefore, the names are \nimproved by replacing them to describe better the actions of these objects.\nListing 8.16: New-Line Bracket Placement Style\n// Newline brace placement style in C++ class definition.\nclass List\n{\n\t // ...\n};\n// Newline brace placement style in function definition.\nvoid append()\n{\n\t // ...\n}\n// Newline brace placement style in conditional statements.\nif( condition == true )\n{\n\t // ...\n}\n// Newline brace placement style in loops.\nwhile( condition == true )\n{\n\t // ...\n}\n", "page": 304, "type": "text", "section": "Page 304"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 281\nListing 8.17: Styles for Naming Conventions\n// Example 1:\n// Incomplete variable names.\nRadio rdo1;\nRadio rdo2;\n// Complete variable name.\nRadio activeRadio;\nRadio backupRadio;\n// Example 2:\nclass Radio {\n\t public:\n\t \t // Incomplete function name.\n\t \t void xmit(Message* message);\n};\nclass Radio {\n\t public:\n\t \t // Complete function name.\n\t \t void transmit(Message* message);\n};\n// Example 3:\n// Incomplete and contextually inappropriate variable names.\nif( s > MaxAmount ) {\n\t // s is ambiguous!\n\t // MaxAmount of what?\n\t // MaxAmount does not reflect the appropriate context!\n}\n// Complete and contextually appropriate variable names.\nif( salary > MaxSalaryAmount ) {\n\t // ...\n}\n// Example 4:\n// Contextually inappropriate names.\nDirectoryManager reaper;\nreaper.destroy();\n// Contextually appropriate names.\nDirectoryManager directoryManager;\ndirectoryManager.deleteFiles(); \n", "page": 305, "type": "text", "section": "Page 305"}
{"text": "282\u2002 \u2022\u2002 Software Engineering Design\ufeff\nDocumentation Conventions\nSimilar to formatting and naming conventions, documentation conventions can also \nbe (almost universally) applied to projects in different domains and with different pro-\ngramming languages. Documentation conventions deal with styles and specifications for \nwhat to document and how to document during construction. Generally, if the naming \nconventions are followed, comments should provide information that describes why an \noperation is written as opposed to what the operation is doing. In many cases, the actions \nperformed by operations (or blocks of codes) can be inferred from the naming conven-\ntions or programming syntax; however, the reasons behind the choice of code cannot be \ninferred as easily. Therefore, comments should provide the reasons why code was written \nand, when necessary, what the code is doing.\nDocumenting Files\nIn software construction, files are units of cohesive work. In some architectural efforts, \nusing the development view discussed in Chapter 3, systems are decomposed using files \n(and directories) as a main unit of system decomposition. Therefore, files should be well \ndocumented in a clear and concise manner so that clients of the file can understand the \nactions carried out by its contents. Depending on the language, files can contain one or \nmore classes, one or more functions, or one or more variable, constant, or type definitions. \nIn all cases, file documentation is necessary for managing the file throughout its lifetime. \nFile documentation can vary from company to company or even from project to proj-\nect within a same company. However, at a minimum, file documentation should contain \nheader information that identifies the contents of the file, description, and original author. \nIn addition, file documentation can include other important information, such as revision \ninformation (e.g., bug fixes or enhancements), classification (mostly for companies that \nwrite software for national security purposes) of the file\u2019s content, and any restrictions\u00ad\n asso-\nciated with the file\u2019s content. An example of file documentation is presented\u00ad\n in Listing\u00a08.18.\nDocumenting Functions\nSimilar to files, functions are units of work; however, they operate on a smaller scale. \nTherefore, their intent should be well documented in a clear and concise manner so that \ntheir clients can understand the actions carried out by the function\u2019s contents. Functions \noperate on a finer-grained context than files; therefore, their documentation should be \nspecific to the work performed by the functions. Information such as classification and \nhistory can be deferred to the file\u2019s documentation. At a minimum, function docu-\nmentation should contain information about its intent, parameters, and return values. \nIn\u00a0addition, it can include any pre- and postconditions applicable. An example of func-\ntion documentation header is presented in Listing 8.19. As seen, an important relation-\nship exists between PDL and function documentation. When using PDL, a comment\u2019s first \napproach is employed to designing code at the construction level. PDL generated as part of \n", "page": 306, "type": "text", "section": "Page 306"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 283\na particular function\u2019s behavior can be directly used to create the function\u2019s documenta-\ntion. In Listing\u00a08.19, PDL generated and presented in Listing 8.10 is used word for word in \nthe function\u2019s documentation.\nMINIMIZING COMPLEXITY IN CONSTRUCTION DESIGN\nConstruction design is an activity directly related to the construction phase. In some cases, \nconstruction design begins during the design phase and continues throughout the con-\nstruction phase. This activity is heavily collaborative, since construction design represents \nparts of a whole system. Complexity encountered during construction design can be mini-\nmized through making use of standards (Abran, Moore, Bourque, and Dupuis 2005). The \nuse of standards is an important part of the software development process. In\u00a0the con-\nstruction design activity, standards can be used to define common processes and practices \nfor improving the efficiency of engineers. Standards can help designers become more effi-\ncient by allowing them to quickly understand, for example, complex data structures, com-\nplex messaging interfaces, and configuration management processes. They can also help \nminimize complexity by defining the basis for implementing construction designs that are \nListing 8.18: Style for File Documentation\n//*******************************************************************\n// FILE:\t\nMyFile.h\n//\n// DESCRIPTION:\t\nThis file contains the definition of class x. \n//\t\nClass x is used in the system for ... Clients of\n//\t\nthis class are required to ...\n//\n// REVISION:\t\nRevision 1.0\n//\n// CLASSIFICATION:\tUnclassified\n//\n// RESTRICTIONS:\t\nNone\n//\n// AUTHOR:\t\nJoe Developer\n//\n// HISTORY:\n//\t\nPROBLEM #\t INITIALS\t\nDATE\t\nDESCRIPTION\n// \n--------------------------------------------------------------------\n//\t\nN/A\t\nJD\t\n1/1/2011\t Initial Design and Code.\n//\t\n10\t\nTAE\t\n5/1/2011\t Removed dead code.\n//\t\n...\t\n...\t\n...\t\n...\n// \n--------------------------------------------------------------------\n//\n//*******************************************************************\n", "page": 307, "type": "text", "section": "Page 307"}
{"text": "284\u2002 \u2022\u2002 Software Engineering Design\ufeff\nsimple and readable rather than clever (Abran et al. 2005). Some important standards that \ncan be created for software projects include the software development plan, the software \nversion document, the interface control document, and the programming style standard, \nas presented in Chapter 5.\nQUALITY EVALUATION OF CONSTRUCTION DESIGN\nThe construction design activity is the last major design step performed before construc-\ntion. Therefore, it provides the last opportunity to evaluate the quality of the system\u00ad\n \nto be built. There are numerous project-specific quality characteristics (e.g., security\u00ad\n, \nusability) that can be identified and evaluated for construction designs. However, at \na minimum, the design\u2019s completeness, correctness, testability, and maintainability \nshould be evaluated, since these generally apply to all software projects.\nCompleteness and correctness deal with the degree to which construction designs cor-\nrectly meet the allocated requirements. Construction designs that are correct, but incom-\nplete, complete but incorrect, or incomplete and incorrect\u2014those that do not meet all \nrequirements, are incorrect, or both\u2014need to be addressed and resolved to maintain the \nenvisioned software quality of the product. Completeness and correctness can both be \nevaluated through peer reviews, unit testing, and audits. In all of these activities, the use of \nchecklists\u2014one of the seven common tools of quality\u2014is essential. In other cases, incom-\nplete designs are the product of incomplete specifications. In these cases, construction \nListing 8.19: Style for File Documentation\n//*******************************************************************\n// METHOD:\t\nEventLogger::log(EventId id, string description)\n//\n// DESCRIPTION:\t This function writes events occurring in the system \n//\t\nto the event console. Events are displayed together\n//\t\nwith their classification and description, which are\n//\t\nboth provided by the client\u2019s calling function.\n//\t\nIn addition, the number of events received for each\n//\t\ntype of event is computed and displayed in the event\n//\t\nconsole. Events are required to have id and\n//\t\ndescription.\n//\n// RETURNS:\t\nThe function returns a boolean value indicating\n//\t\nsuccess/failure of the operation.\n//\n// PRE-CONDITIONS:\t ...\n// POST-CONDITIONS:\t...\n//\n//*******************************************************************\n", "page": 308, "type": "text", "section": "Page 308"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 285\ndesigns can be further analyzed using prototypes for eliciting the required capabilities to \ncomplete the specifications and therefore the construction design.\nTestability quality (in construction design) deals with the amount of effort required to \ntest artifacts that are the result of construction design. On the other hand, a design\u2019s main-\ntainability deals with the amount of effort required to maintain a tested artifact that is the \nresult of construction design. Both testability and maintainability goals can be achieved \nin many ways, as determined by nonfunctional requirements of the project. A common \napproach for evaluating the testability and maintainability of construction designs includes \nthe measurement of the design\u2019s cyclomatic complexity (McCabe 1976); therefore, testabil-\nity and maintainability goals can be transformed into requirements that are based on the \ncyclomatic complexity. In addition, maintainability quality can also be evaluated by the \ncompliance of the resulting implementation of construction design to the programming \nstyle defined for the project. Pressman (2010, p. 437) states that \u201csource code and related \nwork products must conform to local coding standards and exhibit characteristics that will \nfacilitate maintainability.\u201d Therefore, evaluation techniques that enforce 100% compliance \nwith local styles of programming must be in place.\nPeer Reviews\nPeer reviews are tasks that concentrate on verifying and validating designs and code \n(i.e.,\u00a0design reviews and code reviews, respectively). Peer reviews must be planned, orga-\nnized, and conducted in such a way that a collective approval among all members of the \nproject (with different disciplines) is reached. The main tasks are performed by techno-\nlogically savvy engineers and domain experts that can verify and validate the items of \nreview. In addition, the presence of an auditor (or software quality personnel) is required \nto inspect both processes and products. Finally, members of the software testing and main-\ntenance team can contribute highly to the review of items.\nA great deal of time during code review is spent evaluating code. In many practical situ-\nations, where requirements have been established to meet a specific programming style, it \ncan be time-consuming to read code line by line to validate that the code meets the style\u2019s \nrequirements. In these cases, the use of automated style checkers can provide significant \nbenefits. Automated style checkers are tools that can be configured to enforce a \u00ad\nspecific \nstyle of programming. Some of the capabilities provided by automated style checkers \ninclude checks for numerous conventions. For example, the open-source CheckStyle 5.3 \n(2010) is a Java code auditor that can be incorporated into the Eclipse integrated develop-\nment environment to enforce coding styles and identify areas of potential errors in code. \nSome of the capabilities included by CheckStyle include the following:\n\u2022\t Naming conventions of attributes and methods\n\u2022\t Formatting conventions\n\u2022\t Limit of the number of function parameters, line lengths\n\u2022\t Comments (Javadoc) for classes, attributes, and methods\n\u2022\t Presence of mandatory headers\n", "page": 309, "type": "text", "section": "Page 309"}
{"text": "286\u2002 \u2022\u2002 Software Engineering Design\ufeff\n\u2022\t Good practices for class design\n\u2022\t Checks for duplicated code sections\n\u2022\t Checks cyclomatic complexity against a specified threshold\n\u2022\t Other multiple complexity measurements\nUnit Testing\nUltimately, the quality of construction designs in terms of completeness and correctness \nis\u00a0evaluated through unit testing. Therefore, as construction designs are created, so are unit \ntests. One or more unit test cases are essential for verifying and validating construction \ndesigns. A sample unit test case is presented in Table\u00a08.5.\nCyclomatic Complexity\nCyclomatic complexity is a technique developed by McCabe (1976) that can be used for \nevaluating the quality of flow-based designs. It is a mathematical technique based on graph \ntheory that provides a quantitative justification for making design decisions that lead to \nhigher quality in terms of a design\u2019s maintainability and testability. The cyclomatic com-\nplexity computation allows designers to measure the complexity of flow-based operational \ndesigns by determining the complexity of the decision structure of operations instead of \nlines of code. In his original work, McCabe illustrated the correlation between intuitive \ncomplexity and the graph-theoretic complexity of several programming operations and \nshowed that the complexity of an operation had less to do with physical size and more to \ndo with the decision structure of the operation. By using this approach, the cyclomatic \ncomplexity provides not only a measurement of the complexity of flow-based designs but \nalso a measurement of the maximum number of independent paths required to fully test \nthe operation (Galin 2003). Therefore, cyclomatic complexity can be used to determine the \nmaintainability (i.e., understandability) and testability of flow-based designs.\nThe cyclomatic complexity technique works by computing the cyclomatic number v(G) \nof a graph G with n vertices, e edges, and p connected components, as seen in Equation 8.1.\n\t\nv G\ne\nn\np\n( )= \u2212+ 2 \t\n(8.1)\nFor a strongly connected graph G\u2014in which there is a path connecting any pair of arbi-\ntrary distinct nodes\u2014the cyclomatic number is equal to the maximum number of linearly \nindependent circuits (McCabe 1976). Therefore, flow-based designs can be associated with \ndirected, strongly connected graphs that have unique entry and exit points, where each node \ncan be reached from the entry node, and each node can reach the exit node. When this is \nthe case, the graph is referred as the program control graph, and Equation (8.1) can be used \nto compute the cyclomatic complexity of the function, based on its flow-based design. For \nexample, consider a UML flow-based design (i.e., activity diagram) constructed as a directed, \nstrongly connected graph consisting of five activities (i.e., nodes) and six transitional arrows \n(i.e., edges), each activity accessible from the starting node and capable of reaching the exit \n", "page": 310, "type": "text", "section": "Page 310"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 287\nactivity. In this case, the cyclomatic complexity of the design is v(G) = 6 \u2013 5 + 2(1) = 3. \nIn\u00a0most cases, the value of p = 1 is expected, since p is the number of connected components \nin the graph. Given the characteristics specified for the program control graph (i.e., unique \nentry and exit points, all nodes reachable from the entry, and all nodes capable of reaching \nthe exit node), all program control graphs will end up having only one connected compo-\nnent (McCabe 1976). However, in some cases, complexity may be evaluated as the com-\nbined complexity of several operations. Consider a parent operation that calls on several \nchild operations; in this case, the complexity of the operation is the combined complexity of \nthe parent\u2019s operation complexity and the complexity of all other child operations that are \ncalled within the parent. In these cases, p will equal the number of connected components \nTABLE\u00a08.5\nSample Unit Test Case Template\nUnit Test Case\nUnit test name:\nDescription:\nRequirements:\nPreconditions:\nS\nOperator Action\nSystem Action\nP/F\nN\n1\nOperator enters invalid product data \nand clicks on the send button.\nDetects invalid data and displays error message to \nthe operator\n2\nOperator enters valid product data \nand clicks on the send button.\nValidates the data; retrieves server\u2019s Internet \nProtocol (IP) address and port number\n3\nOpens a socket connection and send product \nrequest data to the server\n4\nWaits a maximum of 3 seconds for a server response\n5\n.\n.\n6\nResponse received and product information is \ndisplayed \n7\nSave response data in file system and ask user to \nsearch for another product\n8\nOperator clicks the cancel button to \nfinish searching for products.\nTest Result Notes\nApproval Signatures\nSoftware engineer:\nTest engineer:\nQuality auditor:\n", "page": 311, "type": "text", "section": "Page 311"}
{"text": "288\u2002 \u2022\u2002 Software Engineering Design\ufeff\nin the parent and child operations, which can be equal to the number of operations (parent \nand child operations) being evaluated. It is important to note that when p \u2260 1, the complex-\nity measure will be equal to the summation of the individual complexities of each connected \ncomponent, since complexity measures are\u00a0additive.\nComputing the cyclomatic complexity for large operations can be tedious; therefore, \ntwo simplification methods are available for easily computing the cyclomatic complexity \nof \u00ad\nsingle-component graphs (i.e., p = 1). The first method allows for the computation of \ncomplexity in terms of a program\u2019s decision constructs, such as if statements, while loop, for \nloop, and case statements. Mills (1972) proved that the cyclomatic complexity (C) of a struc-\ntured program meeting the control graphs requirements previously mentioned is equal to \nthe number of conditions in the code (\u03c0) plus 1, as seen in Equation (8.2).\n\t\nC =\n+\n\u03c0 1\t\n(8.2)\nThe number of conditions (\u03c0) can be easily measured as follows. Conditional statements, \nsuch as if statements, while loop, and for loop, all count as one unit of complexity. Compound \nconditional statements, such as if x and y then z, count as two complexity units, since with-\nout the connective and the condition would have to be specified as if x then, if\u00a0y\u00a0then z \n(McCabe 1976). Case statements, such as the switch statement in C++, Java, and C#, or other \nconditional statements containing multiple n branching statements are counted as \u03c0 = n \u2013 1 \nunit of complexity.\nThe second simplification approach allows for the visual determination of complexity via \nthe program\u2019s control graph (i.e., flow-based design). This approach is based on the work of \nmathematician Leonhard Euler, who proved that for connected planar graphs\u2014those with-\nout intersecting edges\u2014the regions (r) of a graph can be computed using Equation\u00a0(8.3), \nknown as Euler\u2019s formula.\n\t\n2 =\n\u2212+\nn\ne\nr \t\n(8.3)\nA region is an area enclosed by arcs; therefore, given the characteristics of the program \ncontrol chart, the number of regions enclosed by arcs, plus one that resides outside the \ngraph, is equal to the cyclomatic complexity of the graph. All three methods for computing \nthe cyclomatic complexity of a program control graph are presented in Figure\u00a08.3.\nThe top-left corner of Figure\u00a08.3 represents the program control graph designed using a \n(flow-based) activity diagram. As seen, the program control graph represents a case state-\nment with five branches; therefore, the number of conditions (\u03c0) is equal to 5 \u2013 1 = 4 and \nthe cyclomatic complexity, using Equation (8.2), is C = 4 + 1 = 5. This can be easily verified \nwith Equations (8.1) and (8.3). For example, using Equation (8.1), the cyclomatic complex-\nity is v(G) = 10 \u2013 7 + 2(1) = 5.\nThe top-right corner presents the evaluation of complexity of a program control graph \nusing the regions visual inspection. As seen, the number of regions of the planar graph is \nfive; therefore, the cyclomatic complexity of the design is five. This can easily be verified \nby rearranging Equation (8.3) to solve for r, which results in r = 9 \u2013 6 + 2 = 5. Finally, the \nbottom of Figure\u00a08.3 presents a more complex program design, which includes 23 nodes \n", "page": 312, "type": "text", "section": "Page 312"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 289\nand 31 edges. By using the regions visual inspection, the complexity of the design can be \nevaluated quickly, which results in a complexity of 10. Since designs like this one involve a \nrelatively large number of nodes and edges, it is a good idea to verify the complexity mea-\nsurement using any of the other techniques presented. For example, using Equation (8.1), \nthe complexity results in v(G) = 31 \u2013 23 + 2(1) = 10.\nAn important consideration when evaluating quality in terms of cyclomatic complexity \nis the establishment of a threshold value for determining when the complexity of designs is \nacceptable. This threshold value can be used to create quality requirements for the software \ndevelopment process; for example, the cyclomatic complexity of functions shall not exceed\u00a010. \nTypically, a value of 10 is acceptable, based on McCabe\u2019s (1976) work. Other studies have shown \nresults similar to McCabe; for example, Casper Jones (2008, p. 415) reports the following:\nEmpirical studies reveal that program with cyclomatic complexities of less than 5 are gener-\nally considered simple and easy to understand. Cyclomatic complexities of 10 or less are con-\nsidered not too difficult. When the cyclomatic complexity is greater than 20, the complexity is \nperceived as high. When the McCabe number exceeds 50, the software for practical purposes \nbecomes untestable.\n1\n2\n3\n4\n7\n5\n6\n1\n1\n2\nR1\nR2\n2\n3\n10\n17\n2\n3\n4\n5\n6\nR5\nR3\nR4\nR2\nR4\nR5\nR3\nR7\nR6\nR9\nR10\nR8\nR1\n18\n19\n11\n6\n12\n13\n15\n16\n22\n20\n21\n23\n8\n9\n14\n5\n7\nFIGURE 8.3\nCyclomatic complexity for three flow-based designs.\n", "page": 313, "type": "text", "section": "Page 313"}
{"text": "290\u2002 \u2022\u2002 Software Engineering Design\ufeff\nUltimately, a threshold value that makes sense for the project team (e.g., 10) should be \nselected and enforced throughout the design and construction phase, metrics should be \ncollected and analyzed, and the threshold value should be reevaluated (for new projects) \naccording to the results.\nCHAPTER SUMMARY\nThe transition from software design to construction should occur with minimal effort. \nIn\u00a0some cases, component designs provide enough detail to allow their transformation from \ndesign artifact into code easily; however, in other cases, a more fine-grained level of design \ndetail is required. Construction design provides a form of design that closely resembles code \nso that complex operations can be planned and evaluated prior to implementation in code. \nOnce the correctness of operations is verified, the construction design activity provides \nadditional heuristics to enforce consistency in the code. Construction designs are typically \ncreated using the following techniques: flow-based, state-based, table-based, and program-\nming design language. Each method provides its own benefits; therefore, careful attention \nshould be paid when selecting the appropriateness of construction designs in practical \napplications. The benefits acquired from designing complex functions and enforcing styles \nfor consistency are essential to maintaining each system\u2019s envisioned quality.\nREVIEW QUESTIONS\n\t\n1.\tWhat is construction design, and why is it important?\n\t\n2.\tList and explain common quality attributes that can be addressed during construc-\ntion design.\n\t\n3.\tWhy are styles important during construction?\n\t\n4.\tWhat are flow-based designs, and how do they relate to UML activity diagrams?\n\t\n5.\tDescribe the following elements of an activity diagram:\n\t\na.\t Initial state\n\t\nb.\t Final state\n\t\nc.\t Action\n\t\nd.\t Branch\n\t\ne.\t Transition\n\t\n6.\tWhat are state-based designs, and why are they important for construction design?\n\t\n7.\tHow are state-based designs typically translated to code?\n\t\n8.\tWhat are table-based designs, and why are they important for construction design?\n\t\n9.\tCompare and contrasts the following:\n\t\na.\t Limited-entry decision table\n\t\nb.\t Extended-entry decision table\n\t\nc.\t Mixed-entry decision table\n", "page": 314, "type": "text", "section": "Page 314"}
{"text": "Principles of Construction Design\u2002 \u2022\u2002 291\n\t 10.\tHow are table-based designs used to decrease code\u2019s complexity and increase both \nreadability and maintainability?\n\t 11.\tIn decision tables, what are missing policies and redundant actions? How does iden-\ntifying these help make more efficient tables?\n\t 12.\tWhat is programming design language, and what is the main benefit that it provides \nover other construction design methods?\n\t 13.\tHow are construction styles used to decrease code\u2019s complexity and increase both \nreadability and maintainability?\n\t 14.\tWhat are the main methods used for evaluating quality of construction designs?\n\t 15.\tList and explain an efficient method for enforcing styles during construction.\n\t 16.\tWhat is cyclomatic complexity? Name three different ways to compute the cyclo-\nmatic complexity of a function during construction design.\n\t 17.\tWhat is the relationship between cyclomatic complexity and software quality? \nExplain.\nCHAPTER EXERCISES\n\t\n1.\tSelect a project of choice, and identify three different functions that can be designed \nusing flow-based, table-based, and state-based design. Create the designs for these \nfunctions, and prepare a 5- to 10-minute presentation including designs, code, \nand\u00a0justification.\n\t\n2.\tCompute the cyclomatic complexity of the following code using all three methods:\nswitch( state ) {\n\t case ONE:\n\t \t // Perform activity.\n\t \t if( /*some condition*/ ) {\n\t \t \t // Perform activity.\n\t \t }\n\t \t else if( /*some condition*/ ) {\n\t \t \t // Perform activity.\n\t \t }\n\t \t else {\n\t \t \t // Perform activity.\n\t \t }\n\t \t break;\n\t case TWO:\n\t \t // Perform activity FIVE.\n\t \t break;\n", "page": 315, "type": "text", "section": "Page 315"}
{"text": "292\u2002 \u2022\u2002 Software Engineering Design\ufeff\n\t case THREE:\n\t \t // Perform activity FOUR.\n\t \t break;\n\t default:\n\t \t // Intentionally left blank.\n\t \t break;\n}\nREFERENCES\nAbran, Alain, James W. Moore, Pierre Bourque, and Robert Dupuis. Guide to the Software Engineering Body of \nKnowledge\u20142004 Version\u2014SWEBOK. Los Angeles, CA: IEEE Computer Society Press, 2005.\nBaldwin, Kenneth, Andrew Gray, and Trevor Misfeldt. The Elements of C# Style. Cambridge, UK: Cambridge \nUniversity Press, 2006.\nBooch, Grady, James Rumbaugh, and Ivar Jacobson. The Unified Modeling Language User Guide, 2d ed. \nBoston:\u00a0Addison-Wesley, 2005.\nCheckstyle 5.3. October 19, 2010. Available from: http://checkstyle.sourceforge.net/index.html (accessed March \n11, 2011).\nCollar, Emilio Jr. \u201cAn Investigation of Programming Code Textbase Readability Based on a Cognitive Readability \nModel.\u201d PhD thesis, University of Colorado at Boulder, 2005.\nFox, Christopher. Introduction to Software Engineering Design: Processes, Principles, and Patterns with UML2. \nBoston: Addison Wesley, 2006.\nGalin, Daniel. Software Quality Assurance: From Theory to Implementation. Harlow, UK: Pearson Addison Wesley, \n2003.\nHurley, Richard B. Decision Tables in Software Engineering. New York: Van Nostrand Reinhold, 1982.\nIEEE. \u201cIEEE Standard for Information Technology-Systems Design-Software Design Descriptions.\u201d 2009, \np.\u00a0175.\nJones, Capers. Applied Software Measurement: Global Analysis of Productivity and Quality, 3d ed. New York: \nMcGraw-Hill Osborne Media, 2008.\nMcCabe, Thomas J. \u201c\nA Complexity Measure.\u201d IEEE Transactions on Software Engineering SE-2, no. 4 (1976): \n308\u2013320.\nMcConnell, Steve. Code Complete, 2d ed. Redmond, WA: Microsoft Press, 2004.\nMeyer, Bertrand. Object-Oriented Software Construction, 2d ed. Upper Saddle River, NJ: Prentice Hall, 1997.\nMills, Harlan D. Mathematical Foundations for Structured Programming. Gaithersburg, MD: IBM Federal \nSystems Division, IBM Corporation, 1972.\nMisfeldt, Trevor, Gregory Bumgardner, and Andrew Gray. The Elements of C++ Style. Cambridge, UK: \nCambridge University Press, 2004.\nPressman, Roger S. Software Engineering: A Practitioner\u2019s Approach, 7th ed. Chicago: McGraw-Hill, 2010.\nVermeulen, Allan, Scott W. Ambler, Greg Bumgardner, Eldon Metz, Trevor Misfeldt, Jim Shur, and \nPatrick\u00a0Thompson. The Elements of Java Style. Cambridge, UK: Cambridge University Press, 2000.\n", "page": 316, "type": "text", "section": "Page 316"}
{"text": "293\n9\nHuman\u2013Computer Interface Design\nJacob Somervell\nUniversity of Virginia, College at Wise\nCHAPTER OBJECTIVES\n\u2022\t Understand the role that the computer interface plays in high-quality \nand successful software systems\n\u2022\t Describe how to address interface design and evaluation within the \nsoftware development life cycle\n\u2022\t Provide usable guidance for evaluating designs\nCONCEPTUAL OVERVIEW\nTo end users, the interface is the system. Most end users do not know, nor \ndo they even need to know, about the underlying structure and implemen-\ntation of the software system. They are concerned only with the interface \npresented to them and the capabilities provided by that interface. Consider \nthe analogy of driving a car: the driver does not need to know anything \nabout how an internal combustion engine works and how it is connected \nto the transmission to send power to the wheels, nor do they need to know \nabout hydraulics and fluid dynamics of the braking system to actually \ndrive a car. Indeed, mainly the driver needs to know that \u201cD\u201d means drive \n(assuming an automatic transmission), press gas pedal to go, press brake \npedal to stop. The same concept applies to software systems. End users are \nconcerned only with what they can do with the system and how they do it, \nnot with how it works \u201cunder the hood.\u201d Hence, it is of vital importance to \nget the interface design sufficiently correct so that it serves users in an efficient \nand usable \u00ad\nmanner. This chapter shifts the focus away from the detailed \nunder-the-hood approach to design to cover the essential human\u2013computer \ndesign activity. The chapter focuses on providing valuable information on \nhow to create effective and usable interfaces for software systems.\n", "page": 317, "type": "text", "section": "Page 317"}
{"text": "294\u2002 \u2022\u2002 Software Engineering Design\nWHAT IS HUMAN\u2013COMPUTER INTERFACE DESIGN?\nSo what does it mean to \u201cget it right?\u201d As part of the software design process, human\u2013computer \ninteraction (HCI) design must account for the user of the software. While designing the \narchitecture and detailed design of software systems is essential for meeting most quality \nattributes, designing an efficient user interface that is understandable by the end user is \nparamount to the usability quality of all successful software systems. The most elegant, \nefficient, and high-quality architectural and detailed designs can be felled by a poor inter-\nface. In the context of HCI, interface design refers to the creation of the user interface. \nIEEE (1990, p. 80) defines the user interface as follows:\nAn interface that enables information to be passed between a human user and hardware or \nsoftware components of a computer systems.\nFor most software, this entails designing the graphical user interface (GUI). This involves \nselecting appropriate information presentation and interaction techniques for the various \nend-user classes (Rosson and Carroll 2002). More specifically this entails selecting appro-\npriate information layouts, correct language, appropriate interface controls (e.g., radio but-\ntons versus check boxes), and tying the detailed design to the various input mechanisms \nprovided in the interface.\nAn essential task of the HCI design activity involves making sure that the interface provides \nappropriate means for using the system in an efficient manner. The best way to ensure an inter-\nface is sufficiently good is to iteratively improve the design through user testing. The implication \nis that there will be multiple iterations of a process that includes the following HCI design tasks:\n\u2022\t Creating a prototype of the system\n\u2022\t Having end users use that prototype in realistic ways\n\u2022\t Gathering data from these tests\n\u2022\t Redesigning the interface to address discovered problems\nAll of this work (choosing appropriate information representation and interaction methods) \nhinges on a thorough understanding of the users of the system. It is paramount to learn \nhow the users typically perform similar actions and what their expectations of the new \nsystem may be. This information is gleaned through detailed requirements gathering and \nanalysis and through significant user testing.\nWHY STUDY HUMAN\u2013COMPUTER INTERFACE DESIGN?\nThe HCI design activity is where general principles are applied to optimize the interface \nbetween humans and computers. Visual designs have a major role in the success or failure \n", "page": 318, "type": "text", "section": "Page 318"}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 295\nof software systems. Systems that meet functional requirements but are not usable cannot\u00ad\n \nsucceed. The major concerns of the HCI designs may include the evaluation and use of \nmodes, navigation, visual designs, response time and feedback, and design modalities, \nsuch as forms and menu-driven. HCI designs directly influence the quality of any system \nand are essential to understanding and addressing the factors that affect the overall usabil-\nity of the system. Many design principles and evaluation techniques exist to successfully \ndesign user interfaces. Therefore, understanding the techniques and tools for designing \ninterfaces allows designers to become proficient in creating efficient interfaces. Providing \nan interface that allow users to accomplish their goals with the software, without unneces-\nsary effort, is the ultimate goal of the user interface designer.\nThe \u201cwithout unnecessary effort\u201d clause is important. Consider a system that requires a \ndate from the user, as presented on Iteration 1 of Figure\u00a09.1.\nThe user interface could ask the user to type in the date in a text box. Without any extra \ninformation a user could type any of the following:\n\u2022\t Jan 1, 2011\n\u2022\t 1 / 1/ 11\n\u2022\t 1 - 1 - 11\n\u2022\t 1 January 2011\nWhich format was expected by the software? If the information typed by the user doesn\u2019t \nmatch the format, what happens? An error message? Program crash? The most flexible \noption involves allowing all of these and others as valid input and then correctly parsing the \ninput to find the appropriate fields for month, day, and year from that input string. This is a \nnontrivial solution and does not help the user form a basis or understanding of the desired \ninput. A simpler solution involves adding a label to the input box specifying the appropriate \nformat (i.e., MM/DD/YYYY), as presented on Iteration 2 of Figure\u00a09.1. This option works \nDate:\nDate: (MM/DD/YYYY)\nDate: (MM/DD/YYYY)\nInvalid Date\nIteration 3\nIteration 2\nIteration 1\nFIGURE 9.1\nSimple data entry user interface.\n", "page": 319, "type": "text", "section": "Page 319"}
{"text": "296\u2002 \u2022\u2002 Software Engineering Design\nfine and helps the user understand the expected formats for date objects, knowledge that \ncan be leveraged in other software systems with similar requirements. Finally, to address \ninput errors, error indicators in the interface are introduced to help guide the user to the \ncorrect input format, as presented on Iteration 3 of Figure\u00a09.1. Typically, a red error indica-\ntor (e.g., as a background color on input boxes) is a passive way of accomplishing this.\nMany other options for date input could be used instead, including drop-down lists, graph-\nical mini-calendars for selecting the date, and spinners. Each of these options has been used \nwith varying levels of success in various applications. Learning which method works for \na specific software system requires end-user testing: create prototype systems or mock-ups \nwith each design choice, have users complete realistic tasks using these systems, record infor-\nmation about the users\u2019 performance (e.g., speed, accuracy), and empirically determine the \nbest design. This effort is significant and requires time and resources to accomplish correctly.\nThe point of this discussion is that the interface (the presented information to the user) \nplays a significant role in the utility of the software and the experience of the user. Carefully \nconsidering the user and the user\u2019s abilities when designing the interface can only increase \nthe usability of the software system. Thorough testing of the design, with end users, is \nparamount to designing successful software systems.\nSo how do we go about involving the user in the process? One must spend time early in \nthe software development life cycle identifying the user classes for the software. A user class \nis a set of users who share common tasks with the software. Consider a student information \nsystem that may be used by a university. Clearly, one class of user would be the students. \nAnother obvious class would be the faculty. Other classes that might not be immediately \nobvious could include department chairs, registrar, advisors, enrollment management staff, \nand financial aid staff. There could be others. Furthermore, a single person could take on the \ncharacteristics of multiple classes. For example, a faculty member could also be an advisor \nand a department chair. Each of the user classes to which a user belongs contributes to the \ntype of work that that user should be able to perform with the software.\nAfter identifying the user classes, it is then necessary to hold requirements meetings with \nrepresentatives of each user class. These meetings should elicit the tasks that the target user \nclass should be able to do with the software as well as tasks that would be \u201cnice\u201d to have. \nRecall that these meetings would normally occur as part of the requirements gathering \nprocess in the overall software development life cycle, not as a separate activity, although it \ncould be separate if needed. Similar to software architects, it is common for user interface \ndesigners to go back and forth between requirements and design, until the interface is \n\u00ad\nsufficiently appropriate to accommodate the needs of users of each class.\nSkill Development 9.1: Eliciting Needs from Different User Classes\nCreate a list of 10 questions you would ask a group of students about their expectations \nfor a new student information system. Create a list of 10 questions you would ask a \ngroup of faculty about their expectations for the same system.\n", "page": 320, "type": "text", "section": "Page 320"}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 297\nAfter learning about the typical interactions your user classes will have with the system, \none can begin designing the user interface to meet those needs. One of the most challenging \nthings for software engineers is to disconnect from the system they are designing and try to \nsee the world through the eyes of the end user. It is tempting to simply design an interface \nthat meets the needs of the engineer or developer (e.g., for testing, verification) instead of \ndesigning an interface that meets the needs of the end user. It is up to software developers to \nmaintain a clear focus on the end user while developing the user interface for a system. The \nfollowing sections provide specific information to aid the designer in \u00ad\nfocusing on the user.\nGENERAL HCI DESIGN PRINCIPLES\nSeveral design principles and heuristics exist for guiding user interface designers. Accord-\ning to Nielsen and Mack (1994), there are 10 major heuristics to follow when creating a user \ninterface:\n\t\n1.\tVisibility of system status: The interface should have some mechanism for showing \nwhere users are in their task.\n\t\n2.\tMatch between system and the real world: The interface should provide interaction \ntechniques that mimic or model what is expected in the real world.\n\t\n3.\tUser control and freedom: The interface should support user exploration without fear \nof breaking anything. Undo and redo should be supported.\n\t\n4.\tConsistency and standards: The interface should use, for example, language or wording \nthat is consistent with users\u2019 expectations. Follow style guides and platform standards.\n\t\n5.\tError prevention: The interface should help users avoid mistakes. Always ask them \nwhen they initiate a destructive command.\n\t\n6.\tRecognition rather than recall: The interface should support rapid and easy learning \nof the system and support recognizing features and their associated actions rather \nthan relying on memorization of unique interface widgets.\n\t\n7.\tFlexibility and efficiency of use: The interface should provide users with shortcuts or \nother accelerators. This helps the interface get out of the way of expert users while \nallowing novice users the opportunity to become more efficient.\n\t\n8.\tAesthetic and minimalist design: The interface should present only the necessary infor-\nmation and no more. Extra visual elements can distract from the important information.\n\t\n9.\tHelp users recognize, diagnose, and recover from errors: Error messages should be \nexpressed in plain language (no codes), precisely indicate the problem, and con-\nstructively suggest a solution.\n\t 10.\tHelp and documentation: Make sure the help and documentation is clearly available \nin the interface.\nThese 10 guidelines or heuristics are generic and open. This is intentional so that they can \nbe applied across a large cross section of software systems. This generality can sometimes \n", "page": 321, "type": "text", "section": "Page 321"}
{"text": "298\u2002 \u2022\u2002 Software Engineering Design\nlead to ambiguity and confusion on the part of the developer. More specific, heuristics \ncan be useful when developing software for specific platforms or systems (Somervell and \nMcCrickard 2005). However, the point is that there are some simple, straightforward things \nto consider when designing any user interface. More importantly, these 10 guidelines are \nfocused on users and strive to keep them in control of the system: the system serves the \nuser. Applying these rules in a specific application can help create an interface that users \nwill find both useful and usable. Consider a popular online calendar application as pre-\nsented in Figure 9.2.\nIn this particular calendar application, creating an appointment relies mostly on direct \nmanipulation\u2014directly clicking on the desired day, typing in a description, including \ntime, and hitting the return key. This action is analogous to writing that information on \na desk calendar or other paper calendar. It is exactly what users expect to be able to do \nwith a calendar. In addition, there is a button (\u201cCreate event\u201d) that allows users to add \nappointments by filling in a form: some users may prefer this method of entry, especially \nfor events that occur in the future, which would require navigation within the calendar to \nenter through the direct manipulation route. A new appointment is shown immediately in \nthe day for which it is assigned.\nNow consider the 10 guidelines in relation to this interface. In terms of system status this \ninterface shows an entire month (or week or day) of appointments in the expected monthly \nformat. A newly created appointment appears immediately within the day for which it \nFIGURE 9.2\nExample calendar user interface.\n", "page": 322, "type": "text", "section": "Page 322"}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 299\noccurs. Error conditions are displayed prominently in the top center of the display in red \ntext. In terms of matching the real world, it clearly mimics the desktop calendar and heavily\u00ad\n \nutilizes that metaphor. The form and layout closely resembles other calendar applications \nso consistency and standards are followed. Users can really commit no errors in the soft-\nware, and any mistakes are easily corrected through undo or deletion capabilities. As a \nGUI application, there are no commands to learn and remember from usage to usage, and \nhelp is available through pop-up labels on hover. The design is minimal in that only the \nnecessary information is shown with extra functionality available in submenus. Overall, \nthis particular\u00ad\n interface performs well with respect to Nielsen and Mack\u2019s (1994) heuristics.\nThis high-level analysis of the calendar application serves to illustrate a good interface \nand how a good interface will typically meet most of the general heuristics. Improvements \nto an interface will often revolve around one of the 10 areas described by these guidelines. \nHowever, these guidelines are just that: guidance. How does one go about starting the inter-\nface design process? How do we get a prototype of the system?\nHUMAN\u2013COMPUTER INTERFACE DESIGN METHODS\nHCI sits at the intersection of design, science, and engineering (McCrickard, Chewar, and \nSomervell 2004). To create an effective interface, the designer must rely on information from \npsychology, sociology, graphic design, human factors and ergonomics, computer \u00ad\nscience, \nand mathematics (among a plethora of other specialty areas). This implies that designers \nwork on or with a multidisciplinary team. Each of the aforementioned areas contributes to \nthe design of the interface in some specific way\u2014whether it be in leveraging the intricacies \nof the human information systems (e.g., visual, audible, haptic) through color choice, font \nchoice, line width, and so forth or in leveraging the societal norms or customs of the target \nuser class through, for example, wording, ordering of information, or icon design.\nGetting Started\nAlmost all design activities, regardless of discipline, start with some form of brainstorm-\ning activity. There is no specific structure required or followed; the designer simply starts \nthinking about ways to solve a problem and then drawing or writing out descriptions of \nthat solution. Often at this stage in design, the only technologies needed are kindergarten \ntools: pencils, paper, crayons, markers, scissors, tape. Some people prefer to work on a \nchalkboard or whiteboard and take pictures of the drawings for record keeping. In any \ncase, the point is to capture ideas and thoughts on \u201cpaper\u201d for later access.\nIt is interesting (but not surprising) to note that the majority of interfaces (electronic) \nare rectangular. We use rectangular paper, rectangular calendars, rectangular screens, and \nrectangular books. Humans like rectangles. Most of the interfaces you will design will be \ncontained in rectangles. This fact can be leveraged when creating an interface. Furthermore, \nat least in North America, people read from left to right and from top to bottom. This is \n", "page": 323, "type": "text", "section": "Page 323"}
{"text": "300\u2002 \u2022\u2002 Software Engineering Design\ntaught from early childhood when parents read to their children and trace their finger \nalong with the words. Certainly by kindergarten, even before they know how to read, most \nchildren are trained to look at \u201creadable\u201d objects and materials at the top left and proceed to \nthe right and down. This knowledge is used in interface design by placing prominent infor-\nmation in the upper left corner of the interface. Take a moment to examine your favorite \nprogram. Check out the interface and identify the type of information placed in the upper \nleft quadrant. Most programs will have some important functionality located in that area \nof the interface. One notable exception is the Start menu in Windows operating systems \n(but it is still on the left). This type of understanding of the human element can help the \ninterface designer create effective and usable interfaces.\nFidelity in Prototypes\nEarly design efforts generate low-fidelity prototypes of the system interface. Fidelity in this \nsense means the level of sophistication or realism in the interface (Virzi, Sokolov, and Karis \n1996). Certainly a drawing of an interface on paper, done in pencil, would require lots of \nimagination on the part of end users or clients if they were to get a feel for the intent of \nthe interface. More realism is needed when communicating design ideas to customers; \nperhaps screen shots or a simple presentation. Mostly working, high-fidelity prototypes \nare required for summative evaluations (Hix and Hartson 1993). The idea is that there is \na spectrum of fidelity when it comes to designing prototypes. Low-fidelity prototypes are \nuseful in early design for communicating and eliciting requirements from the client and \nend users. Medium-fidelity prototypes are useful for illustrating interaction sequences and \nspecific design choices. High-fidelity prototypes are required for effective end-user testing. \nEach level of fidelity is useful to the designer and will likely be utilized during the interface \ncreation process.\nSkill Development 9.2: Low-Fidelity User Interface Design\nUsing only paper and pencil, draw an interface for a ticket purchasing kiosk. The hard-\nware supports touch-screen interaction.\nLow-fidelity prototypes are useful to the designer in the early stages for several reasons. \nThey cost very little. Pencil and paper and other similar materials are cheap. The time and \nenergy required to create a simple sketch of an interface are also negligible. Often, if the \nideas come during the initial requirements gathering meetings, designers can create mock-\nups on the spot to clarify ideas and get a better grasp of the customer\u2019s wants and needs. \nLow-fidelity prototypes can also be \u201cthrown away\u201d easily. Often designers simply crum-\nple up a piece of paper and \u201cstart over\u201d with the design. This is much more difficult and \ntime-consuming when using higher-fidelity tools (e.g., commercial tools, integrated devel-\nopment environments, presentation software). Figure\u00a09.3 presents an example of a low-\n", "page": 324, "type": "text", "section": "Page 324"}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 301\nfidelity prototype of a fictional document editor, in which the major interface components \nare illustrated without any real details.\nAfter identifying requirements and getting initial feedback from customers on early pro-\ntotypes, designers must then work toward creating a more realistic prototype that can be \nused for specific testing. Interface design tools with drag-and-drop support for widgets \nlike text boxes, labels, buttons, and other controls are highly useful for this phase. Most \npopular programming languages have graphical development environments with support \nfor interface design. One popular example is Visual Studio, which has excellent support \nfor C# and Visual Basic. Using these types of tools, and others, the designer then creates a \nmore realistic prototype of the system, with either stubbed functionality or some \u201cWizard \nof Oz\u201d* approach (Carroll and Aaronson 1998). In the high-fidelity prototype of the system \nall controls are functional and do what is expected of them so that it can be used for more \nextensive testing purposes. It is during this phase of creation that guidelines like the afore-\nmentioned heuristics can aid the designer in creating an interface that will be useful and \nusable. Style guides, system compatibility issues, and other external constraints must be \nfollowed and can impact the flexibility of the designer. Considerations such as these serve \nas input to the design process, and the resulting interface should meet as many of these \nconstraints as possible.\nMetaphors\nHelping the end user learn and use a new interface requires thought and effort on the part \nof the interface designer. One highly used technique is the incorporation of metaphors in \n*\tThe Wonderful Wizard of Oz is a children\u2019s story by L. Frank Baum. In this story an all-powerful wizard turns out to be a \nnormal man operating some sophisticated machinery behind a curtain. The relevance here is that the designers or testers \n\u201cfake\u201d the functionality for testing purposes.\nFIGURE 9.3\nLow-fidelity prototype of a fictional document editor.\n", "page": 325, "type": "text", "section": "Page 325"}
{"text": "302\u2002 \u2022\u2002 Software Engineering Design\nthe design. A metaphor is the application of a known, often real-world, object and its char-\nacteristics to an electronic interface. A classic example is the desktop metaphor used in all \nmajor operating system graphical shells (GUIs). Before computers became ubiquitous in \nthe workplace, people sat at desks where all of the tools needed in their work were available \nwithin arm\u2019s reach. This work environment and management style was \u201ccopied\u201d in the cre-\nation of the virtual desktop. People now rely on their graphical user interface to access all \nof the tools they need to get their work done. Learning this environment is straightforward \nand relatively simple for those familiar with a physical desk.\nOther similar metaphors abound in electronic interfaces. Consider e-mail, which consists \nof a blend of two physical objects that are heavily used in interoffice communications: \u00ad\nletters \nand memos. Most e-mail composition programs provide an interface that includes text entry \nareas for the recipient, copies, and subject\u2014all requirements for most interoffice memos. \nE-mail also supports both formal and informal letter writing and copies the idea of sending \na \u00ad\nletter to someone. The e-mail\u2013memo metaphor is readily understood by newcomers and \n\u00ad\neasily \u00ad\nmastered by those who have never dealt with the real-world counterparts: an all-around \nexcellent use of a metaphor to aid the end user in learning and using a software system.\nOne must be mindful of overusing metaphors. While the benefits include ease of learn-\ning and ease of use, overapplication or too literal an application of a metaphor can limit \nthe designer and prevent improvements. Take the classic calculator. A handheld calculator \nwith basic functionality is simple and easy to use. Creating a calculator for use within an \noperating system is a normal thing, and many users employ the software calculator for \nvarious tasks. Figure\u00a09.4 presents a simple software calculator interface.\nFIGURE 9.4\nSimple software calculator.\n", "page": 326, "type": "text", "section": "Page 326"}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 303\nNotice that the software version looks much like a handheld calculator. This is good for \nlearning how the interface works and what is possible. A novice user can easily use the inter-\nface to perform simple calculations. However, the interface is a literal copy of the real-world \ninterface and as such does not provide any extra features that might be expected in soft-\nware, including selectable history, multiple storage areas (variables), and visualizations \n(like\u00a0graphing or showing the equation that yielded the answer). In this case, the designers \ntook the metaphor too far and restricted the utility of the program. Unfortunately, there are \nno hard-and-fast rules to tell when a designer has taken a metaphor \u201ctoo far.\u201d The only way \nto discern this information is through beta testing or actual use. People will use a product \nand indicate functionality they would like to see in the product. Good designers try their \nbest to anticipate that functionality, but that ability comes with experience.\nSkill Development 9.3: Metaphors in User Interface Design\nDescribe three metaphors used on the popular social website Facebook (http://www.\nfacebook.com).\nGestalt Principles\nAnother set of useful design guidance comes from perceptual psychology. Knowing how \nthe human brain processes information should be high on the list of things with which an \ninterface designer should be familiar. German psychologists described several principles \nof perception in the 1920s. They used the term gestalt, which means \u201cwhole,\u201d to illustrate \nhow the human brain recognizes and organizes information. Take a moment to examine \nFigure\u00a09.5. What do you see in the image on the left? Most people would describe it as a plus \nsign. Very few, if any, would describe it as two symmetric right angles sharing a common \npoint. The image on the right shows the two right angles slightly separated for emphasis.\nThere are six major gestalt principles: proximity, similarity, closure, area, symmetry, and \ncontinuity (Rosson and Carroll 2002). Proximity relies on the fact that objects arranged \nclose together are considered grouped together. Similarity simply means that objects that \nFIGURE 9.5\nIllustration of continuity.\n", "page": 327, "type": "text", "section": "Page 327"}
{"text": "304\u2002 \u2022\u2002 Software Engineering Design\nshare visual characteristics (e.g., color, shape) will be considered as a group or as similar \nin functionality. Closure is the idea that humans try to organize things into closed figures. \nArea is similar to closure but with the extra emphasis on the fact that humans try to create \nthe figure with the smallest area. Symmetry refers to the fact that humans often treat sym-\nmetric elements as part of the same figure or group. Finally, \u00ad\ncontinuity refers to the human \npredisposition to see continuous contours or patterns.\nSkill Development 9.4: Gestalt Principles in User Interface Design\nIdentify instances of the six gestalt principles in the interface presented in Figure\u00a09.6.\nKnowledge of the gestalt principles is useful in and of itself, but knowing how to utilize \nand capitalize on them for effective interface design requires extensive practice. In addition \nto the gestalt principles, there are some other useful design guidelines to consider. Consider \nwhite space in interface designs. White space is the area in a graphical display with no \nvisual elements. White space becomes very important for helping the end user understand \nthe graphical elements in a display. For example, tabs are often used for alignment pur-\nposes, and it is the extra white space between the columns in a tabbed display that allows \nusers to perceive the data as columns, thus allowing them to more readily understand the \npresented information. Be generous with white space as it directly reinforces several of \nthe gestalt principles. Simultaneously, be very careful about superfluous design elements. \nAnything extra in an interface that does not provide useful information has the potential \nto detract from the utility of the interface (Carroll 1990). Consider the interface in the pre-\nvious skill development. All of the vertical and horizontal lines can be removed from the \ninterface without detracting the utility or communication provided. Be careful about any \nFIGURE 9.6\nCommon user interface for printer systems.\n", "page": 328, "type": "text", "section": "Page 328"}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 305\ngraphical element. Whenever a graphical element is added to an interface, always ask the \nquestion, \u201cIs this necessary?\u201d\nReusing Earlier Designs\nSometimes interface designers do not need to start from scratch. Instead, they have access \nto similar products or have rough designs given to them. In these types of situations, inter-\nface designers are likely to work with designs that do need heavy modification to meet the \nunique needs of the new system. In such situations, designers need to rely on field studies \nand other empirical testing to identify areas for improvement. In other words, reusing \nan existing interface can sometimes reduce the design effort but will usually increase the \n\u00ad\ntesting effort.\nEVALUATION OF HCI QUALITY\nBefore systems are deployed, significant efforts must be made to ensure that user interfaces \nare sufficiently complete, understandable, and efficient for providing users with systems \nthat exhibit high quality in terms of usability. IEEE (1990, p. 80) defines usability as\nThe ease with which a user can learn to operate, prepare inputs for, and interpret outputs of \na system or component. \nTherefore, evaluation of the HCI quality is essential during the design process. Several \napproaches can be taken when evaluating and minimizing the degree of complexity \ninvolved when learning or using the system, including usability testing, analytic testing, \nand empirical testing.\nUsability Testing\nAt this point during the interface design process there should be some usable prototype of \nthe interface that can be used for testing purposes. It is beneficial to understand testing and \nhow to go about doing it. First, it should be noted that there are two classes of evaluation \n(Scriven 1967):\n\u2022\t Formative\n\u2022\t Summative\nFormative evaluation occurs within the design process and focuses on alternatives \nand clarification. Summative evaluation occurs \u201cafter\u201d the design process and focuses on \nassessing the result. Formative evaluation should be heavily utilized throughout the inter-\nface design process, iteratively improving the design. Summative evaluation should be \n", "page": 329, "type": "text", "section": "Page 329"}
{"text": "306\u2002 \u2022\u2002 Software Engineering Design\nutilized when a solid version of the interface is completed. (Note: this does not mean after \nthe design is complete but rather when a version of the interface is considered ready for \ntesting.) An easy way to distinguish between formative and summative evaluation is that \nformative evaluation is like the cook tasting the soup and summative evaluation is like the \ncustomer tasting the soup.\nThere are two main methods of user interface testing: analytic and empiric (Scriven \n1967). Each can be used for both formative and summative evaluations. Analytic testing \ninvolves domain or usability experts analyzing an interface for design issues. Empirical \ntesting (also known as user testing) involves representative end users performing realistic \ntasks with the interface. Each type of test reveals different information to the interface \ndesigner, and ideally both should be utilized in a mediated evaluation (Scriven 1967).\nAnalytic Testing\nAnalytic testing is often used earlier in the development process than empirical testing. \nThe reason for this is that early in the interface design process there is usually no working \n\u00ad\nsystem with which to test end users. Instead there are low- or high-fidelity prototypes. These \nprototypes can be examined by knowledgeable experts for compliance with, for example, \ndesign guidelines, style guides, and compatibility guides. The key result of an analytic eval-\nuation is a subjective opinion about the interface. Multiple specific tests fall under the ana-\nlytic umbrella: usability inspections, heuristic evaluations, and cognitive walkthroughs. \nUsability inspections are simply experts using the prototype in intended ways while ensur-\ning usability guidelines are followed. Often these types of inspections have checklists or \nother guidelines (e.g., style guides) that are noted by evaluators. The end result is often a \nlist of usability issues identified and sometimes rated by severity (how much an impact the \nissue might have on end users\u2019 ability to complete their task). Cognitive walkthroughs are \nan example of a usability inspection. In this specific type of inspection, experts are given \na script to work through in an interface while looking for violations of usability guidelines \nand standards while assessing the interface for visual cues (Lewis, Polson, Wharton, and \nRieman 1990). The goal is to identify aspects of the interface that detract from users\u2019 ability \nto complete their tasks with the system and to identify missing information that could be \nuseful. The result of a cognitive walkthrough is a detailed listing of good and bad aspects \nof interfaces with respect to specific tasks.\nHeuristic evaluation is similar to usability inspection whereas it involves multiple experts \nreviewing an interface with respect to a list of heuristics (see Nielsen\u2019s heuristics described \nearlier; Nielsen and Mack 1994). The difference is that the evaluator may be a representa-\ntive stakeholder (e.g., developer, end user). Again, the result is a list of problems identified \nin the interface. These can be rated by severity. The interesting thing to note about this \napproach is the utility it brings. A few (3\u20135) experts can find about 80% of the usability \nissues in an interface with this method (Nielsen and Molich 1990). However, heuristic \nevaluation and all analytic methods suffer a major weakness: the results are mainly the \nopinion (albeit\u00a0educated) of evaluators. Whether an identified issue will negatively impact \n", "page": 330, "type": "text", "section": "Page 330"}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 307\nreal users of the system is unknown without further testing. This type of data is subjective \nand often holds less weight than objective data.\nEmpirical Testing\nThe opposite of subjective data is objective data, or empirical data. This type of data is \nhighly respected because it is hard to argue about\u2014it is factual data about the system \nof interest. Empirical testing provides this type of data to the designers. Unfortunately, \nempirical testing is difficult and expensive. Why? It costs time and money to set up and \nexecute a good empirical study. Costs revolve around securing space, development time \n(of the tests), \u00ad\nhiring participants, data collection, analysis, and reporting. Nonetheless, \nempirical testing is highly respected and should be utilized in the interface design process.\nMany types of empirical testing can be used for interface evaluation: field studies, lab \nbased experiments, and user surveys. The recorded data can vary from observations of use \nto survey responses to measured data from lab-based experiments. This data is objective, \nand the data itself is unquestionable. The issue with empirical data is the interpretation of \nthe data and the validity of the setting from which the data came.\nField studies involve designers or design teams going into the field and observing the end \nusers in their current work environment. Observations of work practices, data flow, and \ncommunication channels can provide insight for what to include in user interfaces. The \nraw data from a field study is typically not as useful as the analysis of the data through cate-\ngorization or content classification (higher-level issues that caused the observed behavior). \nA major drawback of field studies is the cost involved. Significant time (and thus money) \nwould need to be invested to fully understand the existing work environment. On projects \nwith tight schedules, this type of evaluation may not be feasible. It is useful to note that \nfield studies are highly useful for formative evaluations.\nLab-based studies are highly useful in usability evaluation (whether formative or sum-\nmative). Often the prohibitive cost of doing field work implies testing should be done in \na computer lab. In this situation the designers work with testers to create a testing envi-\nronment with which to isolate and study specific aspects of an interface. Participants are \nbrought into the lab environment and asked to perform the required tasks. In these settings, \nexcellent data on usage can be collected. The major issue with lab-based studies comes from \nvalidity. Validity refers to how realistic the experiment happens to be\u2014how well does the \ntesting situation model the real-world situation? Are the participants representative of the \nreal end users? Did the participants used in the test have more knowledge of this type of \nsystem than the average user? Would the participants be more distracted in their normal \nwork environment? All of these questions and others take away from the utility of the data \nthat comes from a lab-based study. Controlling for validity is difficult and time-consuming. \nResults should always be considered in light of any validity issues.\nA specific type of lab-based study is the controlled experiment. If a specific design choice \nneeds to be validated through experimental means, one can design an experiment to objec-\ntively determine the performance of competing options. Suppose a design team wants to \ndetermine which color scheme to use for a system display. The choices have been narrowed \n", "page": 331, "type": "text", "section": "Page 331"}
{"text": "308\u2002 \u2022\u2002 Software Engineering Design\nto black text on a white background or white text on a black background. Before determin-\ning the best approach, a criteria for evaluation needs to be in place. In\u00a0other words, what \ndoes \u201cbest approach\u201d mean? Does it mean faster reading times, higher reading comprehen-\nsion, or less eye strain? We could actually study all three with a single experiment. In\u00a0this \nsituation, the read time, reading comprehension, and eye strain would be the dependent \nvariables. The values obtained from the test participants are dependent upon the color \nscheme. This means that the color scheme is the independent variable, in this case with two \nlevels: black on white and white on black.\nThere are many ways to design the actual experimental setting for this test. We could use \na between-subjects design and have two separate sets of participants work with each level \nof the independent variable. Or we could use a within-subjects design and have the same \ngroups of people read text with both color schemes. The latter choice would imply the need \nfor two different sets of text, so that a person who reads a passage in white on black would \nnot read the same passage in black on white but a different passage. We would need to \naccount for the passage used in a within-subjects test because reading one passage before \nthe other might influence the speed of reading or comprehension. We would also need to \nvary the order of the presentation of the white-on-black, black-on-white conditions: half \nof the participants would start with white on black first; the other half would start with \nblack on white first. In all cases, we need to be concerned with the number of participants \nfor our test. A good rule-of-thumb is 10 participants per condition (Scriven 1967). For \nour experimental setup (two levels of the independent variable and two passages to read) \nwe would need 2 \u00d7 2 \u00d7 10 = 40 participants. It should be clear that a within-subjects test \nrequires more participants (if there are more conditions). Within-subjects tests are often \nmore highly regarded with respect to the findings. The reason is that individual \u00ad\nvariability \nin the participants can be controlled for in a within-subjects test.\nSkill Development 9.5: Designing Experiments for Empirical Testing\nDesign a between-subjects and a within-subjects experimental setup for determining \nwhether direct entry or a drop-down list would provide faster input times for dates \nin a database form. In the direct-entry condition, invalid date formats are errors and \ncost an extra 3 seconds to correct. Identify the dependent and independent variables. \nDetermine the number of participants required for each type of test (assume a minimal \nof 10 participants per condition).\nAnother way to gather empirical data is through user surveys. These can be stand-alone \nsurveys or part of a lab-based experiment. The goal is to have end users comment on the \nsystem and their experiences. This type of data can be useful in identifying high-level \nusability issues as well as provide insight into how users will perform with the system. \nDepending on the type of data, it can be analyzed using statistical methods for concrete \n", "page": 332, "type": "text", "section": "Page 332"}
{"text": "Human\u2013Computer Interface Design\u2002 \u2022\u2002 309\nevidence for specific design choices. Often, survey results are used for categorization of the \nparticipants and aid in interpreting results.\nCHAPTER SUMMARY\nThis chapter has provided high-level guidance for completing the human\u2013computer \ninterface design phase within system design. The main focus is users. It is the duty of the \ndesigner to keep users and their interests as the focus of the interface. The application \nof design guidelines, perceptual psychology, and sound scientific method are all used to \nprovide and justify concrete interface designs that meet the needs of the users. It is on \nthe shoulders of the designer to make sure the system is going to be easy to use, easy to \nlearn, and enjoyable for the end user. Balancing these fundamental requirements with \nthe various system requirements and functional constraints is the core of the interface \ndesigner\u2019s challenge.\nREVIEW QUESTIONS\n\t\n1.\tWhat is human\u2013computer interface design?\n\t\n2.\tWhat are the steps in the HCI design phase?\n\t\n3.\tWhy is the focus on the user so important to successful interface design?\n\t\n4.\tWhat is a metaphor with regards to interface design?\n\t\n5.\tWhat are the gestalt principles?\n\t\n6.\tWhy is white space so important?\n\t\n7.\tWhat are the two major types of evaluations?\n\t\n8.\tWhat are the two major evaluation methods?\n\t\n9.\tWhy are analytic methods typically cheaper and faster and empirical methods?\n\t 10.\tWhat is the difference between a between-subjects design and a within-subjects design?\nCHAPTER EXERCISES\n\t\n1.\tUsing presentation software (e.g., PowerPoint, Impress), create a high-fidelity pro-\ntotype of the ticket purchasing kiosk described in Skill Development 7.2. Fake the \nfunctionality by linking to different slides in your prototype.\n\t\n2.\tRepeat Exercise 1 using a high-level graphical language (e.g., Visual Basic, Visual C#).\n\t\n3.\tAnalyze your favorite e-mail client with regards to Nielsen\u2019s 10 heuristics. Create a \nlist of usability issues and rank them by severity.\n", "page": 333, "type": "text", "section": "Page 333"}
{"text": "310\u2002 \u2022\u2002 Software Engineering Design\n\t\n4.\tWalk through the process of creating and sending an e-mail in your favorite e-mail \nclient. Identify gestalt principles that are in use in the system. Identify improvements \nthat could be made through the application of gestalt principles.\n\t\n5.\tA common metaphor used for online shopping is the idea of a shopping cart. Thor-\noughly discuss the usage of this metaphor for your favorite online shopping system. \nFocus on how the similarities to the real world enhance the experience and how the \ndifferences detract from the experience.\n\t\n6.\tLook up discount usability evaluation. Describe the process and identify whether it is \nmore useful for formative or summative evaluation.\nREFERENCES\nCarroll, J. M. The Nurnberg Funnell: Designing Minimalist Instruction for Practical Computer Skill. Cambridge, \nMA: MIT Press, 1990.\nCarroll, J. M., and P. Aaronson. \u201cLearning by Doing with Simulated Intelligent Help.\u201d Communications of the \nAssociation for Computing Machinery, 1998: 1064\u20131079.\nHix, D., and H. R. Hartson. Developing User Interfaces: Ensuring Usability Through Product & Process. \nNew\u00a0York: John Wiley & Sons, 1993.\nIEEE. \u201cIEEE Standard Glossary of Software Engineering Terminology.\u201d 1990. http://ieeexplore.ieee.org/xpl/\nfreeabs_all.jsp?arnumber=159342.\nLewis, C., P. Polson, C. Wharton, and J. Rieman. \u201cTesting a Walkthrough Methodology for Theory-Based Design \nof Walk-Up-and-Use Interfaces.\u201d Chi \u201990 Proceedings, 1990, 235\u2013242.\nMcCrickard, D. S., C. M. Chewar, and J. Somervell. \u201cDesign, Science, and Engineering Topics? Teaching HCI \nwith a Unified Method.\u201d Technical Symposium on Computer Science Education (SigCSE\u201904). Norfolk, VA, \n2004, 31\u201335.\nNielsen, J., and R. L. Mack. Usability Inspection Methods. New York: John Wiley & Sons, 1994.\nNielsen, J., and R. Molich. \u201cHeuristic Evaluation of User Interfaces.\u201d Proc. ACM CHI\u201990 Conference, Seattle, \n1990, 249\u2013256.\nRosson, M. B., and J. M. Carroll. Usability Engineering: Scenario-Based Development of Human\u2013Computer \nInteraction. San Franciso: Morgan Kaufmann, 2002.\nScriven, M. The Methodology of Evaluation in Perspectives of Curriculum Evaluation. Chicago, IL: Rand McNally, \n1967.\nSomervell, J., and D. S. McCrickard. \u201cBetter Discount Evaluation: Illustrating How Critical Parameters Support \nHeuristic Creation.\u201d Interacting with Computers: Special Issue on Social Impact of Emerging Technologies \n17, no. 5 (September 2005): 592\u2013612.\nVirzi, R. A., J. L. Sokolov, and D. Karis. \u201cUsability Problem Identification Using both Low- and High-Fidelity \nPrototypes.\u201d Proceedings of ACM CHI \u201996, British Columbia, Canada, 1996, 236\u2013243.\n", "page": 334, "type": "text", "section": "Page 334"}
{"text": "311\n10\nSoftware Design Management, \nLeadership, and Ethics\nLuis Daniel Otero\nFlorida Institute of Technology\nCHAPTER OBJECTIVES\n\u2022\t Understand the definition and importance of software design man-\nagement\n\u2022\t Describe various techniques to manage the software design phase\n\u2022\t Describe leadership in the context of design management\n\u2022\t Describe relevant ethics items from the software engineering code of \nethics\nCONCEPTUAL OVERVIEW\nSoftware design is an essential phase of the software engineering life cycle. \nConceptually, design is the process of transforming functional and non-\nfunctional requirements into models that describe a technical solution. This \ntransformation process can be viewed as a complex decision problem that \nmust be managed to ensure an effective use of resources to deliver quality \nproducts that meet requirements. It is regarded as a decision problem since \nthere are many ways to design a software system, and software engineers \nmust make design decisions to achieve the required goals of the software \nsystem in the most effective manner. Obviously, quality must be considered \nat every step of the design phase. The idea is that proper design efforts are \nexpected to minimize the complexity of subsequent phases in the life cycle as \nwell as the impact of requirements changes on the overall cost and schedule.\nThe objective of this chapter is to describe three major elements that are \ncritical for the success of any major design project: management, leadership, \nand ethics. It is not intended to be a complete tutorial on any of these three \n", "page": 335, "type": "text", "section": "Page 335"}
{"text": "312\u2002 \u2022\u2002 Software Engineering Design\nelements. Instead, the chapter develops a design management framework that describes \nimportant concepts related to each element with the hope of facilitating the successful man-\nagement of this complex phase. For this purpose, the chapter begins by describing the soft-\nware design phase as a complex task that must be managed to achieve acceptable quality\u00ad\n \nlevels. Various project management techniques to monitor and control the resources that are \nresponsible for the completion of design tasks are presented. The chapter\u00ad\n then describes the \nrelationship between management and leadership and highlights several\u00ad\n leadership traits \nthat are important for successful results. Finally, the chapter presents various ethic items \nfrom the Software Engineering Code of Ethics that are relevant to software\u00ad\n design\u00a0projects.\nWHAT IS SOFTWARE DESIGN MANAGEMENT?\nGriffin (2010, p. 5) defines management as \u201ca set of activities\u2014including planning and deci-\nsion making, organizing, leading, and controlling\u2014directed at an organization\u2019s resources \n(i.e.\u00a0human, financial, physical, and information), with the aim of achieving organizational \ngoals in an efficient and effective manner.\u201d Management plays a big role in software engi-\nneering projects. In the design phase, management refers to a set of activities required to \nefficiently create quality design artifacts, within schedule and budget constraints. This def-\ninition encompasses a broad set of activities that are particular to specific organizations. \nHowever, at the core of every organization\u2019s management activities, quality is a focal point.\nWHY STUDY DESIGN MANAGEMENT?\nIn large-scale software projects, software design management is essential to plan, organize, \nstaff, track, and lead the activities required to carry out successfully the software architecture \nand detailed design steps. Key to the success of software design management is an effective \nuse of resources to achieve the various goals set forth for each main component in the design \nphase (i.e., software architecture, detailed design, and documentation). Therefore, software \ndesign management is needed to control/monitor the processes and resources \u00ad\nnecessary for \ncompleting quality design artifacts according to organizational goals.\nTHE CONCEPT OF QUALITY\nQuality is a term that can be loosely defined as a performance measure for a service pro-\nvided or a product produced, and it is relative to a particular stakeholder. For example, \na personal website can be classified as high quality by the programmer that developed it \nand as low quality by user clients. That is, two stakeholders of the software system have \n", "page": 336, "type": "text", "section": "Page 336"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 313\ndifferent opinions regarding the quality of the product produced. Why? Because both of \nthese stakeholders have different parameters by which they measure quality. For example, \nthe programmer may perceive quality in terms of being able to use appropriate colors and \norganize the website to run on a particular web browser. On the other hand, a client using \na different web browser may not see the website\u2019s organization and colors as intended, thus \nperceiving the website\u2019s quality as poor. Similarly, the quality of a software design can \nbe assessed in various ways. However, from a management perspective, quality of soft-\nware design tends to be evaluated in terms of cost and scheduling. Therefore, this chapter \nfocuses on various project management techniques that can be used to keep the design \nartifacts within cost and schedule thresholds.\nDESIGN MANAGEMENT FRAMEWORK\nTo efficiently and effectively manage the software design activities of a project, it is beneficial \nto view the design phase as a project itself. The managerial benefit of this approach is that \nproject management techniques can be directly applied to the design phase. For example, the \nlife cycle of the design phase can be represented with three stages similar to Figure\u00a010.1. This \nlife cycle represents a typical project pattern where contributions to a project\u2019s completion \nare relatively small during the initial and termination phases and significantly high during \nthe implementation phase. Defining a life cycle structure for a project helps to decompose \nthe project into its appropriate stages, where each stage can be managed individually.\nThere are two main objectives associated with the initial stage. The first objective is to \nachieve a clear understanding of the tasks to be accomplished and the resources that are nec-\nessary to successfully complete the tasks. The second main objective is to develop a plan to \ncomplete the project\u2019s tasks within schedule and budget constraints. Thus, the initial phase is \n100\nInitial\nImplementation\nTermination\nTime\nProject Completion (%)\n0\nFIGURE 10.1\nProject life cycle.\n", "page": 337, "type": "text", "section": "Page 337"}
{"text": "314\u2002 \u2022\u2002 Software Engineering Design\ncharacterized by planning activities. Although some of the artifacts resulting from this phase \n(e.g., schedule) may be deliverables to clients, this phase is not viewed as contributing signifi-\ncantly to the percentage project completion. The implementation stage, on the other hand, \nis where most of the effort is employed and where most of the design project deliverables \nare achieved, including completed design documents. Therefore, the percent project comple-\ntion is the highest during this stage. In the termination stage, key activities involve verifica-\ntion that everything is in place for a smooth transition into the code construction phase. \nActivities include, for example, making sure that the latest versions of the design documents \nare securely stored according to configuration management procedures, updating schedule \nand cost current values, reevaluating schedule and budget plans based on the resulting per-\nformance measures of the design phase, and communicating results to upper management. \nThe design documents generated in this stage are critical for the robustness and maintain-\nability of the software designed. However, the relative impact of this stage to project comple-\ntion is not viewed as significant as that of the implementation phase. The key is that each of \nthese phases must be individually managed to ensure that all phases meet acceptable levels of \nquality and performance measures. For example, an important outcome of the planning stage \nis a clear understanding of the tasks to be accomplished and the resources that are neces-\nsary to successfully complete the tasks. Various project management techniques exist to help \nachieve this outcome. Therefore, it is important to know how to apply these project manage-\nment techniques to your particular design project, and go through a peer-review process* to \nensure that the objectives of the planning stage are achieved. Performance measures in the \nplanning stage are thoroughness (everything is considered), completeness (complete defini-\ntion of plans), and accuracy of estimates. In the execution/implementation stage, quality is a \nfunction of a series of technical attributes of software designs. Managing during this stage is \nmainly a monitoring approach to make sure that the plan is being followed and to take cor-\nrective actions if necessary. Important factors that affect the effectiveness of managing these \nphases are leadership and good ethical conduct. Therefore, a design management framework \ncomposed of the following four main areas is proposed:\n\u2022\t Planning\n\u2022\t Execution/implementation\n\u2022\t Termination\n\u2022\t Leadership and ethics\nPLANNING DESIGN EFFORTS\nThe planning stage is critical to the success of any major project. In a holistic view, plan-\nning exists to lay out a strong foundation for a successful project by clearly specifying the \n*\t Peer reviews must be conducted throughout these stages to minimize the propagation of errors to subsequent stages and \napply corrective actions.\n", "page": 338, "type": "text", "section": "Page 338"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 315\ntasks that must be completed, resources in terms of personnel skills required to complete \neach task and any hardware and software required, the durations of tasks, and the specific \npoints within the project\u2019s life cycle phases where resources will be needed. Basically, plan-\nning establishes the directions to follow to complete the project and improve its probability \nof success. It is intended to facilitate future project accomplishments. The key functions in \nthe project planning stage are scoping and organizing.\nScoping\nProject scoping is the first key function of the planning stage. It involves two main activities: \nidentify the tasks and develop the budget. The idea is to follow the divide and conquer para-\ndigm to utilize a mechanism for identifying lower-level assignable activities that need to be \ncompleted. Then, expected costs for each activity are estimated to develop the \u00ad\nbudget. Two \ncommonly used techniques for project scoping are the work breakdown \u00ad\nfunction\u00a0(WBS) \nand budgeting.\nWork Breakdown Structure\nIn the project management point of view, a project begins as a statement of work (SOW), \nwhich mainly consists as the set of main objectives to be achieved. The SOW is decomposed \ninto tasks where these tasks are decomposed into subtasks and subtasks into work \u00ad\npackages. \nA management technique to represent, either graphically or in list format, a \u00ad\nproject modu-\nlarized into task activities is called WBS. Also known as hierarchical planning, the WBS is \na simple but powerful technique that helps to plan, clearly define, and organize the activi-\nties related to reach specific milestones and complete a project. Milestones are defined \nas specific events to be reached at specific points in time. For example, obtaining budget \nand schedule approvals for a project are typically considered important project milestones. \nGiven that the major artifacts in the design phase are the main components of the design \nprocess, these are considered the main milestones. That is, the completion of the architec-\nture design, detailed design, and documentation constitute the main project milestones of \na design project. Therefore, the objective of a WBS in the design phase is to establish the \nwork elements for each of these major milestones.\nTable\u00a010.1 shows an example of a WBS for the design of a software application. This \nfigure shows the managerial levels for each component. The top level is the design project\u00ad\n \nitself. This level represents the overall objective to be achieved, which is to successfully \ncomplete the design phase. Then, this top level is decomposed into the three main mile-\nstones of the design phase, which are the development of architectural and detailed \ndesigns, and the completion of the design document. These tasks are direct sublevels of the \ndesign project; therefore they are labeled 1.1, 1.2, and 1.3. Each task is then decomposed \ninto appropriate subtasks. For the architectural design task, two subtasks were identified: \nevaluation of alternative designs and selection of the final architectural design. Since these \nare sublevels of the architectural design task, they are labeled 1.1.1 and 1.1.2. Each of these \nsubtasks is decomposed into appropriate work packages. For example, the evaluation of \n", "page": 339, "type": "text", "section": "Page 339"}
{"text": "316\u2002 \u2022\u2002 Software Engineering Design\nalternative architecture designs was decomposed into prioritizing objectives and conduct-\ning \u00ad\nformal evaluation peer reviews. Consequently, these two work packages were labeled as \nthe four-level activities 1.1.1.1 and 1.1.1.2.\nEvaluating the usefulness of a WBS is often more a matter of subjective assessments \nthan not. We can define three criteria for this evaluation. The first criterion is called \nscope\u00a0accuracy\u00ad\n. That is, we need to agree that the WBS serves its overall objective of being \na breakdown of the project into tasks, and nothing else. A WBS does not contain informa-\ntion regarding tasks\u2019 relationships such as task precedence or task durations, and it does \nnot include personnel skills required for the completion of tasks. Instead, each element of \na WBS represents an activity that consumes resources\u2019 time and effort. This brings us to \nthe second criteria, completeness. The purpose of this evaluation criterion is to ensure that \nthe WBS includes the complete set of tasks necessary to complete the project. The third \ncriterion\u00ad\n is level of detail. This criterion evaluates if the WBS breaks down the project\u2019s \ntasks into appropriate levels such that it facilitates the estimation of effort for each task.\nBudgeting\nBudgeting is the process of estimating the cost of a project. It is basically a forecasting \nproblem, since cost is a function of various parameters that are uncertain, such as the \nnumber of resources required throughout the project, their cost, hardware and software \nequipment, inflation changes, and requirement changes. The accuracy of a budget is a \nfunction of the uncertainty of these individual cost parameters. For example, a budget for \nTABLE\u00a010.1\nExample of a WBS for a Design Project\nOutline Number\nTask Name\n1\nDesign project\n1.1\nArchitectural design\n1.1.1\nEvaluate alternative designs\n1.1.1.1\nPrioritize objectives\n1.1.1.2\nFormal review of evaluations\n1.1.2\nSelect architectural design\n1.1.2.1\nMake initial selection\n1.1.2.2\nFormal review to select final design\n1.2\nDetailed design\n1.2.1\nEvaluate alternatives\n1.2.2\nSelect among alternatives\n1.3\nDocumentation\n1.3.1\nWrite architectural design documentation\n1.3.2\nFormal review (architecture design)\n1.3.3\nFinal architectural design document\n1.3.4\nWrite detailed design documentation\n1.3.5\nFormal review (detailed design)\n1.3.6\nFinal architectural design document\n", "page": 340, "type": "text", "section": "Page 340"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 317\nthe construction of a house is expected to be more accurate than the budget for develop-\ning a complex software application. For the project of constructing a house, planners often \nhave a very good idea of the resources that are needed, cost of permits, and so forth. For \nthe software project, it becomes a more challenging task due to the level of uncertainty in \nkey elements such as the number of software lines of code that it would take to develop the \napplication, the number of software engineers required, and unknown learning curves for \nnewer technology, to name a few. Compared with the house construction project, the typi-\ncal error size for the estimation of cost parameters in software projects is much higher. Due \nto these uncertainties, monitoring and controlling activities must be enforced throughout \nthe course of the project to determine any deviations from the plan (i.e., budget), and study \nthe causes of these deviations (monitoring and control mechanisms will be discussed later \nin the chapter). As such, the budget serves as a baseline to compare differences between \nactual and estimated costs at any point in the life of a project.\nConceptually, a common strategy to develop a budget is to simply cost each element in \nthe WBS. To accomplish this, elements are associated with direct and indirect costs. Direct \ncosts are those that can be directly tied to the development of the design. The most often \nused direct costs are labor and equipment (i.e., hardware and software equipment). Indirect \ncosts, on the other hand, include costs such as fringe benefits and administrative expenses.\nOne of the most significant and hard-to-estimate direct costs for each task is the cost of \nthe staff that will be directly working on the completion of the task. The level of difficulty \nin developing accurate cost estimates related to task durations is a function of the complex-\nity of the design project itself. Given that software projects are typically custom-made solu-\ntions to particular problems, tasks are considered nonrepetitive and often involve learning \nrates. This is particularly true for tasks that involve new technologies or the use of skills \nthat the staff is unfamiliar with. Therefore, it is important to account for learning rates in \nthe budgeting process.\nIt is important to understand that developing accurate budgets for design projects is often \nvery difficult due to the complexity of the projects. Data from previous similar projects, as \nwell as input from experienced personnel, are used as resources to prepare budgets. After the \n\u00ad\nbudget for a project is created and approved, it becomes more of a control mechanism for man-\nagers because it establishes the cost threshold for the entire project.\nOrganizing\nOrganizing is the second key function of the planning stage. It involves two main activi-\nties: responsibility assignments and scheduling. That is, after identifying and organizing \nthe tasks in the scoping function with the WBS, the organizing function conducts task \nassignments, establishes task durations, and identifies any predecessors* for each task. Task \ndurations are critical because they are an integral part of the monitoring and controlling \nmechanisms in the implementation stage. The next subsections describe various project \nmanagement tools that are applicable for the organizing function.\n*\t A predecessor is a task that must be completed before another task can begin.\n", "page": 341, "type": "text", "section": "Page 341"}
{"text": "318\u2002 \u2022\u2002 Software Engineering Design\nLinear Responsibility Chart\nAn important outcome of the planning stage is to have a clear understanding of the roles \nthat each staff member plays in the process of completing each element of the WBS. This can \nbe viewed as a plan for task assignments. The goal here is to clearly identify the staff mem-\nbers that will be mainly responsible for each task and those that will serve as reviewers or \nsupport the task in any way. A project management tool that allows such outcome is called \na linear responsibility chart (LRC), which is a tabular representation of task assignments.\nTable\u00a010.2 shows an example of an LRC for a particular design project. This table clearly \nshows the staff members that are mainly responsible for each of the tasks and those that \nwill be supporting the tasks in any way or acting as reviewers. Other than clearly establish-\ning the responsibilities of each team member, having a clear understanding of task assign-\nments is important for scheduling purposes. For example, finding skilled personnel to act \nas reviewers for a particular artifact (e.g., detailed design) later in the project\u2019s life cycle \ncan become a challenging task because employees get regularly reassigned to new tasks. \nTherefore, it is beneficial to establish their roles with the design project early in the plan-\nning stage to minimize the probability of not having adequate reviewers and the chance of \noverrunning the schedule or compromising quality standards.\nScheduling with Gantt Charts and Network Diagrams\nAfter task assignments, a key activity in the planning stage is scheduling. A basic function of \nthe scheduling process is to determine task relationships in order to convert the WBS into an \noperating timetable. Scheduling helps to identify the critical project activities that cannot be \ndelayed without delaying the overall project duration as well as those that will not affect the \noverall project duration if delayed. Furthermore, scheduling allows tasks to be ordered so \nthat, for each task, preceding and subsequent tasks are easily identified.\nVarious project management techniques are used in scheduling. Two of the most common \nones are Gantt charts and network diagrams. They are basically graphical representations of \nthe logical flow between tasks (i.e., activities) and their durations. The Gantt chart technique is \nvery simple to follow. Because of its simplicity, this approach is often used to show schedule and \nprogress as well as to serve as a control and monitoring mechanism. The three basic param-\neters needed for a Gantt chart are tasks, their durations, and their predecessors and successors. \nThese parameters are used to develop a graph that depicts the durations of tasks and their rela-\ntionship. For example, consider a snapshot of a Gantt\u00a0chart presented in Figure\u00a010.2 from the \nMicrosoft Project software package. The left-hand side of this figure shows the list of tasks from \na WBS with expected duration, start date, and finish date. It also shows any predecessor for \neach task. For example, the predecessor to evaluate detailed design alternatives (WBS\u00a0#1.2.1) \nis to have selected a final architectural design (WBS #1.1.2.2). On the right-hand side, we can \nsee the actual Gantt chart showing predecessors of tasks and their durations. We can see, for \nexample, that the documentation for the architectural design can be started as soon as the \narchitectural design passes a formal review and the detailed design is ready to begin.\n", "page": 342, "type": "text", "section": "Page 342"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 319\nSimilar to Gantt charts, network diagrams are also graphical representations of logi-\ncal flow among tasks, describe task durations, and need the same three basic parameters: \ntasks, their durations, and their predecessors and successors. Moreover, network diagrams \nare used to show additional important information such as critical paths, earliest and latest \ncompletion times, and slack times. We will use information from the WBS from Table\u00a010.1 to \nexplain the activity-on-node (AON) network diagram technique. First, we need estimates \nfor task durations. Estimating accurate task durations is often a very complex endeavor. \nOne common approach is to estimate minimum, maximum, and most likely duration \nTABLE\u00a010.2\nExample of a Linear Responsibility Chart\nOutline #\nTask Name\nStaff_1\nStaff_2\nStaff_3\nStaff_4\nStaff_5\n1\nDesign project\n1.1\nArchitectural design\n1\n2\n3\n1.1.1\nEvaluate alternative designs\n1\n2\n1.1.1.1\nPrioritize objectives\n1\n2\n1.1.1.2\nFormal review of evaluations\n1\n3\n3\n1.1.2\nSelect architectural design\n1\n1.1.2.1\nMake initial selection\n1\n1.1.2.2\nFormal review to select final design\n1\n2\n3\n3\n1.2\nDetailed design\n1\n3\n1.2.1\nEvaluate alternatives\n2\n1\n11.2.2\nSelect among alternatives\n2\n1\n3\n1.3\nDocumentation\n1.3.1\nWrite architectural design documentation\n1\n2\n1.3.2\nFormal review (architecture design)\n1\n3\n3\n1.3.3\nFinal architectural design document\n1\n3\n1.3.4\nWrite detailed design documentation\n2\n1\n3\n1.3.5\nFormal review (detailed design)\n2\n1\n3\n1.3.6\nFinal detailed design document\n3\n1\n3\nLegend:\n1 = Primary responsibility\n2 = Support development role\n3 = Review role\nFIGURE 10.2\nSnapshot of Gantt chart from Microsoft project.\n", "page": 343, "type": "text", "section": "Page 343"}
{"text": "320\u2002 \u2022\u2002 Software Engineering Design\ntimes. Table\u00a010.3 gives an example of task durations for the three-level tasks described in \nthe WBS. For each task, this table shows an estimated minimum duration, a, a most likely \nduration, m, and a maximum duration, b. These three parameters are used to calculate \nthe expected time, ET, of each task. ET durations are calculated using the beta distribu-\ntion* with Equation (10.1) because of its simplicity and flexibility. A key benefit for having \nthree estimates for task durations is that we can use them to develop variance calculations, \nwhich can then be used to estimate the probability of completing the project within a spe-\ncific time. The variance of the duration of a task is calculated using Equation (10.2).\n\t\nExpected Time =\n+\n+\na\nm b\n4\n6\n\t\n(10.1)\n\t\nVariance =\n\u2212\nb\na\n6\n2\n\t\n(10.2)\nFigure\u00a010.3a shows the resulting network diagram from the information described in \nTable\u00a010.3. Notice the inclusion of start and end nodes. These two extra nodes are included \nto make the network easier to follow. The network diagram clearly shows the predecessors \nfor each.\nAfter estimating task durations and variances, the next step is to calculate the critical \npath. A path is any combination of nodes from the start node to the last node. For example, \nour network diagram shows the following two paths:\n\u2022\t Path 1: (1.1.1) \u2013 (1.1.2) \u2013 (1.2.1) \u2013 (1.2.2) \u2013 (1.3.4) \u2013 (1.3.5) \u2013 (1.3.6)\n\u2022\t Path 2: (1.1.1) \u2013 (1.1.2) \u2013 (1.3.1) \u2013 (1.3.2) \u2013 (1.3.3) \u2013 (1.3.4) \u2013 (1.3.5) \u2013 (1.3.6)\nUsing the expected times from Table\u00a0 10.3, the expected duration of the first path is \n55\u00a0days. The expected duration of the second path is 46 days. The critical path is the one with \n*\tFor a refresher on elementary statistics, please refer to books such as Pelosi and Sandifer (2003).\nTABLE\u00a010.3\nTask Durations for the Three-Level Tasks Described in the WBS\nOutline #\nTime (Days)\nMinimum \n(a)\nMost Likely \n(m)\nMaximum \n(b)\nImmediate \nPredecessors\nExpected \nTime (ET)\nVariance \n(\u03c32)\n1.1.1\n3\n5\n13\n\u2014\n6\n2.78\n1.1.2\n1\n2\n9\n1.1.1\n3\n1.78\n1.2.1\n8\n15\n22\n1.1.2\n15\n5.44\n1.2.2\n5\n10\n21\n1.2.1\n11\n7.11\n1.3.1\n5\n10\n21\n1.1.2\n11\n7.11\n1.3.2\n1\n2\n9\n1.3.1\n3\n1.78\n1.3.3\n3\n5\n13\n1.3.2\n6\n2.78\n1.3.4\n5\n10\n21\n1.2.2; 1.3.3\n11\n7.11\n1.3.5\n1\n2\n9\n1.3.4\n3\n1.78\n1.3.6\n3\n5\n13\n1.3.5\n6\n2.78\n", "page": 344, "type": "text", "section": "Page 344"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 321\nthe longest duration; hence, the critical path for this problem is Path 1. The critical path is \nshown in Figure\u00a010.3b with heavy lines. Identifying the critical path of a project is important \nbecause it pinpoints the activities that cannot be delayed without delaying the entire project. \nThat is, if any of the activities along the critical path get delayed, the entire project will be \ndelayed. Identifying the critical path also marks the activities that can be delayed without \naffecting the project duration. These activities are the ones outside of the critical path.\nAfter calculating the critical path, the next step is to calculate earliest and latest times \nfor activities to start and finish. That is, we need to calculate the earliest time that we can \nbegin each activity and the earliest time that the activity can be completed. We denote \nthese terms as earliest start (ES) and earliest finish (EF) times. Similarly, we calculate the \nlatest time that we can begin each activity and the latest time that the activity can be com-\npleted. We denote these terms as latest start (LS) and latest finish (LF) times. The difference \nbetween the LS and ES of an activity is called the slack time for the activity. Because activi-\nties along the critical path cannot be delayed without delaying the entire project\u2019s duration, \nonly noncritical path activities can have slack times.\nTo calculate earliest times, we move from the start node to the other nodes. Logically, \nthe first activity (i.e., node 1.1.1) begins at time 0. Therefore, the ES for activity 1.1.1 is 0, \nand its EF time is its expected time duration (6 days). Any immediate subsequent activity \ncan start as early as activity 1.1.1 ends. Therefore, the ES of activity 1.1.2 is 6 days, and its \nEF is 9 days, which is the sum of its ES and expected time duration. Similarly, the ES of \nactivity 1.3.1 is 9 days, and its EF is 20 days. In cases where an activity has more than one \npredecessor\u00ad\n, the largest EF time of the predecessors becomes the ES time of the activity. \nFor example, activity 1.3.4 has two predecessors: 1.2.2 (with an EF time of 35 days) and \n1.3.3 (with an EF time of 29 days). Since activity 1.3.4 can be started only when both of its \n\u00ad\npredecessors are complete, its earliest possible start time is 35 days.\nStart\n1.1.1\n1.1.2\n1.2.1\n1.3.1\n1.2.2\n1.3.2\n1.3.3\n1.3.4\n1.3.5\n1.3.6\nEnd\nStart\n1.1.1\n1.1.2\n1.2.1\n1.3.1\n1.2.2\n1.3.2\n1.3.3\n1.3.4\n1.3.5\n1.3.6\nEnd\nES\nEF\nLS\nLF\n0\n6\n0\n6\n6\n9\n6\n9\n0\n0\n0\n0\n9\n24\n9\n24\n24\n35\n24\n35\n9\n20\n15\n26\n20\n23\n23\n29\n23\n29\n29\n35\n35\n46\n35\n46\n46\n49\n46\n49\n49\n55\n49\n55\n55\n55\n55\n55\n(a)\n(b)\nFIGURE 10.3\nAON network diagram.\n", "page": 345, "type": "text", "section": "Page 345"}
{"text": "322\u2002 \u2022\u2002 Software Engineering Design\nTo calculate latest times, we move from the last node to the start node. The LF time for \nactivities in the critical path is the same as their EF times. Similarly, the LS time for critical \nactivities is the same as their ES. For noncritical activities such as 1.3.3, this is not the case. \nIf this activity finishes at its EF time of 29 days, activity 1.3.4 (i.e., its successor) will still \nbe unable to start because it needs to wait for activity 1.2.2 to finish at day 35. Therefore, \nactivity 1.3.3 can actually finish as late as day 35 and not affect the critical path duration \nof the project. Consequently, the LF time for activity 1.3.3 is 35 days, and its LS time is \n29\u00a0days, which is its LF minus its expected time duration of 6 days. Activity 1.3.2 can \u00ad\nfinish \nas late as the LF time of its successor 1.3.3. Therefore, its LF time is 29 days, and its LS time \nis 26 days. When the earliest and latest times for each activity are completed, it can be \neasily seen that only the noncritical activities (i.e., 1.3.1, 1.3.2, and 1.3.3) have slack times. \nThe total allowable slack time for these activities is 6 days. This means that, for example, \nif\u00a0a slack time of 5 days is used in activity 1.3.1, then only one of the remaining noncritical \nactivities can be delayed by 1 day. If, for example, a slack time of 6 days is used in activity \n1.3.1, then the network will have two critical paths. This means that in this case noncritical \nactivities 1.3.2 and 1.3.3 will become critical activities (i.e., no slack times).\nProbability of Time to Completion\nIn our network diagram example from the previous section, expected task durations were \ncalculated based on estimates of minimum, average, and maximum durations using the \nbeta distribution. The other obvious option is to overlook these three parameters and esti-\nmate a single average task duration instead. This option tends to be troublesome for decision \n\u00ad\nmakers since it does not explicitly consider a range of possibilities (e.g., max/min values), and \naccurate estimates of task durations with a single parameter seem unlikely. Consequently, \nsetting values for these three parameters\u2014instead of one estimate\u2014alleviates the estima-\ntion process for decision makers. Another benefit from using these three parameters is that \nwe can use them to develop variance calculations and then use the variances to estimate the \nprobability of completing the project within a specific time.\nTo estimate the probability of completing a project by a particular time period, we use \nthe cumulative standard normal distribution to obtain Z-values.* The standard normal dis-\ntribution is a normal distribution with a mean equal to zero and a standard deviation equal \nto one. A Z-value represents the number of standard deviations from the mean (either to \nthe right or to the left of the mean) of the standard normal distribution.\nThe critical path contains the activities that establish the duration of a project. We basi-\ncally use the expected completion times of the critical activities and their variances to \ndetermine the probability of completing the critical path activities by a deadline. Before \nwe continue, it is worth mentioning that there is an assumption that must be made when \nusing the standard normal distribution to make our probability estimates. The assump-\ntion is that the durations of each activity in the critical path are statistically independent \nof each other. In other words, they must be independent random variables. This allows us \n*\tAgain, for a refresher on elementary statistics, please refer to books such as Pelosi and Sandifer (2003).\n", "page": 346, "type": "text", "section": "Page 346"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 323\nto invoke the central limit theorem (CLT) to find the mean and standard deviation of the \nproject duration, which is basically the sum of each activity in the critical path. The CLT \nsays that the sum of independent and identically distributed (iid) random variables forms a \nnormal distribution as the number of random variables increases. In our case, we treat the \nproject duration as the sum of the critical path activities (i.e., iid random variables); there-\nfore, by virtue of the CLT, we can assume that the project duration is normally distributed. \nArmed with the CLT, we can use the standard normal distribution to make estimates about \nthe probability of completing the project by a certain time.\nFirst, we need to transform (sometimes called \u201cnormalize\u201d) the estimated project dura-\ntion time into a Z-value using Equation 10.3\n\t\nZ\nD\nEPT\nEPT\n=\n\u2212\n\u03c32\n\t\n(10.3)\nwhere\nZ\t\n=\tthe number of standard deviations of a standard normal distribution\nD\t\n=\tthe desired completion time (usually in days) of a project\nEPT\t =\texpected project completion time (this is the critical path duration)\n\u03c3EPT\n2\n\t=\tthe variance of the critical path\nRegarding the variance parameter (and refreshing some statistics concepts), if the \n\u00ad\nrandom variables in a set are independent of each other, then the sum of the variances \nof the individual random variables equals the variance of the entire set. Since we assume \nthat the critical path activities are independent of each other, the sum of their variances \n\u00ad\ncorresponds to the variance of the expected project duration.\nAfter calculating the Z-value, we find the probability of completing the project by a certain \ntime using a cumulative normal distribution table similar to the one found in Table\u00a010.4. \nIn this table we can find the probability associated with a Z-value. For example, assume \nthat a design project has an expected critical path duration of 75 days, with a critical path \nvariance of 36 days. We would like to know the probability of completing the project in \n85\u00a0days. Using Equation (10.3), we calculate a Z-value of 1.67. Then, we go to Table\u00a010.4 and \nfind the probability to be 0.9525 (go down the left column until 1.6, then across to the right \nuntil column 0.07). This means that there is a 95.25 percent probability of finishing the \ndesign project in 85 days, given the variance in the expected project duration time.\nSkill Development 10.1: Negative Z-Value\nAssume that a design project has an expected critical path duration of 75 days, with a \ncritical path variance of 36 days. We would like to know the probability of completing \nthe project in 65 days. As you will see, the resulting Z-value will be a negative number. \nHow do you get its associated probability from Table\u00a010.4, which gives you only positive \nZ-values? Hint: Remember that the standard normal distribution has a symmetrical \nshape around the mean and that its area under the entire bell-shape curve equals 1. \n", "page": 347, "type": "text", "section": "Page 347"}
{"text": "324\u2002 \u2022\u2002 Software Engineering Design\nEstablish Change Control Policy\nManaging the design of software systems is often a very complex endeavor, especially when \nchanges to the design occur after the design has successfully gone through peer reviews. \nEven a small design change can result in system failures if not managed appropriately. To \navoid major problems later in the project, it is critical that a formal change control process \ngets adopted early in the planning phase. A change control process also serves to ensure the \nTABLE\u00a010.4\nProbabilities of the Cumulative Standard Normal Distribution\nZ\n0.00\n0.01\n0.02\n0.03\n0.04\n0.05\n0.06\n0.07\n0.08\n0.09\n0.0\n0.5000\n0.5040\n0.5080\n0.5120\n0.5160\n0.5199\n0.5239\n0.5279\n0.5319\n0.5359\n0.1\n0.5398\n0.5438\n0.5478\n0.5517\n0.5557\n0.5596\n0.5636\n0.5675\n0.5714\n0.5754\n0.2\n0.5793\n0.5832\n0.5871\n0.5910\n0.5948\n0.5987\n0.6026\n0.6064\n0.6103\n0.6141\n0.3\n0.6179\n0.6217\n0.6255\n0.6293\n0.6331\n0.6368\n0.6406\n0.6443\n0.6480\n0.6517\n0.4\n0.6554\n0.6591\n0.6628\n0.6664\n0.6700\n0.6736\n0.6772\n0.6808\n0.6844\n0.6879\n0.5\n0.6915\n0.6950\n0.6985\n0.7019\n0.7054\n0.7088\n0.7123\n0.7157\n0.7190\n0.7224\n0.6\n0.7258\n0.7291\n0.7324\n0.7357\n0.7389\n0.7422\n0.7454\n0.7486\n0.7518\n0.7549\n0.7\n0.7580\n0.7612\n0.7642\n0.7673\n0.7704\n0.7734\n0.7764\n0.7794\n0.7823\n0.7852\n0.8\n0.7881\n0.7910\n0.7939\n0.7967\n0.7996\n0.8023\n0.8051\n0.8079\n0.8106\n0.8133\n0.9\n0.8159\n0.8186\n0.8212\n0.8238\n0.8264\n0.8289\n0.8315\n0.8340\n0.8365\n0.8389\n1.0\n0.8413\n0.8438\n0.8461\n0.8485\n0.8508\n0.8531\n0.8554\n0.8577\n0.8599\n0.8621\n1.1\n0.8643\n0.8665\n0.8686\n0.8708\n0.8729\n0.8749\n0.8770\n0.8790\n0.8810\n0.8830\n1.2\n0.8849\n0.8869\n0.8888\n0.8907\n0.8925\n0.8944\n0.8962\n0.8980\n0.8997\n0.9015\n1.3\n0.9032\n0.9049\n0.9066\n0.9082\n0.9099\n0.9115\n0.9131\n0.9147\n0.9162\n0.9177\n1.4\n0.9192\n0.9207\n0.9222\n0.9236\n0.9251\n0.9265\n0.9279\n0.9292\n0.9306\n0.9319\n1.5\n0.9332\n0.9345\n0.9357\n0.9370\n0.9382\n0.9394\n0.9406\n0.9418\n0.9430\n0.9441\n1.6\n0.9452\n0.9463\n0.9474\n0.9485\n0.9495\n0.9505\n0.9515\n0.9525\n0.9535\n0.9545\n1.7\n0.9554\n0.9564\n0.9573\n0.9582\n0.9591\n0.9599\n0.9608\n0.9616\n0.9625\n0.9633\n1.8\n0.9641\n0.9649\n0.9656\n0.9664\n0.9671\n0.9678\n0.9686\n0.9693\n0.9700\n0.9706\n1.9\n0.9713\n0.9719\n0.9726\n0.9732\n0.9738\n0.9744\n0.9750\n0.9756\n0.9762\n0.9767\n2.0\n0.9773\n0.9778\n0.9783\n0.9788\n0.9793\n0.9798\n0.9803\n0.9808\n0.9812\n0.9817\n2.1\n0.9821\n0.9826\n0.9830\n0.9834\n0.9838\n0.9842\n0.9846\n0.9850\n0.9854\n0.9857\n2.2\n0.9861\n0.9865\n0.9868\n0.9871\n0.9875\n0.9878\n0.9881\n0.9884\n0.9887\n0.9890\n2.3\n0.9893\n0.9896\n0.9898\n0.9901\n0.9904\n0.9906\n0.9909\n0.9911\n0.9913\n0.9916\n2.4\n0.9918\n0.9920\n0.9922\n0.9925\n0.9927\n0.9929\n0.9931\n0.9932\n0.9934\n0.9936\n2.5\n0.9938\n0.9940\n0.9941\n0.9943\n0.9945\n0.9946\n0.9948\n0.9949\n0.9951\n0.9952\n2.6\n0.9953\n0.9955\n0.9956\n0.9957\n0.9959\n0.9960\n0.9961\n0.9962\n0.9963\n0.9964\n2.7\n0.9965\n0.9966\n0.9967\n0.9968\n0.9969\n0.9970\n0.9971\n0.9972\n0.9973\n0.9974\n2.8\n0.9974\n0.9975\n0.9976\n0.9977\n0.9977\n0.9978\n0.9979\n0.9980\n0.9980\n0.9981\n2.9\n0.9981\n0.9982\n0.9983\n0.9983\n0.9984\n0.9984\n0.9985\n0.9985\n0.9986\n0.9986\n3.0\n0.9987\n0.9987\n0.9987\n0.9988\n0.9988\n0.9989\n0.9989\n0.9989\n0.9990\n0.9990\n3.1\n0.9990\n0.9991\n0.9991\n0.9991\n0.9992\n0.9992\n0.9992\n0.9992\n0.9993\n0.9993\n3.2\n0.9993\n0.9993\n0.9994\n0.9994\n0.9994\n0.9994\n0.9994\n0.9995\n0.9995\n0.9995\n3.3\n0.9995\n0.9995\n0.9996\n0.9996\n0.9996\n0.9996\n0.9996\n0.9996\n0.9996\n0.9997\n3.4\n0.9997\n0.9997\n0.9997\n0.9997\n0.9997\n0.9997\n0.9997\n0.9997\n0.9998\n0.9998\n3.5\n0.9998\n0.9998\n0.9998\n0.9998\n0.9998\n0.9998\n0.9998\n0.9998\n0.9998\n0.9998\n", "page": 348, "type": "text", "section": "Page 348"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 325\ntechnical integrity of the design in the presence of changes. Figure\u00a010.4 shows an example\u00ad\n \nof a change control process. Here, a change request is submitted to the change control \nauthority, which in many cases corresponds to the project manager, the design lead, or \nthe group that makes the final decision on the status and priority of a change. The request \nis then evaluated based on technical merit, complexity of integration, and potential side \neffects. From these assessments, the request is assigned a change priority. Developers then \ntake their initial design documents through another round of formal reviews to obtain \nupdated estimates for the budget, schedule, and staffing. Finally, updated design docu-\nments and schedule estimates must then be approved by the customer since they represent \nchanges to the original estimates.\nIMPLEMENTATION PHASE\nDuring the implementation stage, the main managerial activities are monitoring and con-\ntrolling that the design project activities are being accomplished according to the plan \n(i.e.,\u00a0schedule and budget). Monitoring and controlling mechanisms exist to identify any \ndeviations from the plan and to ensure that these deviations get corrected in a timely \nmanner in order to avoid major future problems. Appropriate project management tools \nfor this phase are Gantt charts and earned value management (EVM). Recall that in our \nearlier\u00ad\n discussion on Gantt charts, we mentioned that they are a useful mechanism to \nmanage progress within the design phase. Since we have already covered Gantt charts in \nthe previous\u00ad\n section, we will limit our discussion only to earned value management.\nInternal Analysis\nand Evaluation\nCustomer\nRequirements\nHigher Level\nManagement\nChange Request\nPriority\nEvaluations\nAssess Complexity\nof Integration\nUpdate Documents\n(e.g., design)\nUpdate Budget &\nSchedule, and Sta\ufb00\nRequirements\nGet Customer\nApproval of Updates\nFIGURE 10.4\nExample of a change control process.\n", "page": 349, "type": "text", "section": "Page 349"}
{"text": "326\u2002 \u2022\u2002 Software Engineering Design\nEarned Value Management\nEarned value management (EVM) is an important project management technique to \ndetermine the progress of tasks based on the value of the work currently completed versus \nthe work that was expected to be completed at that particular time. The term used to define \nthe dollar amount of the work currently completed is called earned value (EV), which is \ncalculated by multiplying the percentage work completed times the planned total cost of \nthe work when completed. Therefore, a key factor is to accurately estimate the percentage \nof work completed, which can be hard to do because of the complexity of tasks and the \nhigh degree of subjectivity that is typically involved. Furthermore, workers tend to inflate \nthe percentage of work completed to give the perception that work is progressing smoothly \nfor the completion of the task. Portraying a false sense of work completion is very danger-\nous for a project and can result in significant schedule and budget overruns. Knowing \nthat the percent completion of a task at a particular point in time is lower than expected \nprovides managers the opportunity to implement corrective actions to mitigate the risks of \nnot completing the task within established cost and schedule constraints. There are various \nways to estimate percentage completion. Meredith and Mantel (2009) provide a rough set \nof guidelines that can be used to help in the estimation process, which are briefly described \nin Table\u00a010.5.\nArmed with EV calculations for each task (i.e., each element in the WBS), we can exam-\nine deviations to cost and schedule and then establish a dollar amount to these devia-\ntions. The terms used to define current deviations to schedule and cost are called schedule \nvariance (SV) and cost variance (CV). SV is calculated as the difference between the EV \nand the planned value (PV), which is the cost/value of the work that was expected to be \ncompleted at that point in time of the schedule. CV is the difference between the EV and \nthe actual cost (AC), which is the amount of money that was spent on the work currently \ncompleted. Two other important measures are the cost performance index (CPI) and the \nschedule performance index (SPI). The CPI value is calculated as the ratio of EV to AC. This \nmeasure can be used to estimate the projected cost to complete some work. The SPI value is \ncalculated as the ratio of EV to PV. This measure can be used to estimate the projected time \nto complete some work. Table\u00a010.6 provides a brief description of the EVM parameters \ndefined so far as well as budget at completion (BAC), estimate cost to complete (ETC), and \nestimate at completion (EAC). Table\u00a010.7 shows the equations for the parameters. Notice \nTABLE\u00a010.5\nSome Guidelines for Estimating Percentage Completion of a Task\nApproach Name\nBrief Description\n50\u201350 \nAssumes 50% task completion as soon as the task begins, and 100% completion when \nthe task is completed\n0\u2013100 percent\nAssumes 0% until the task gets fully completed\nCritical input use\nPercent completion is a function of how much of a critical input is used versus its overall \nexpected total to be used\nProportionality\nAssumes work completion as the proportion of actual time (or cost) spent over the total \ntime (or cost) planned for the task to be completed\n", "page": 350, "type": "text", "section": "Page 350"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 327\nthat the EV parameter is present in all of these calculations. This highlights the importance \nof establishing accurate estimations of percent work completion, which is the key factor \nused to define EV.\nLet\u2019s show the implementation of the EVM equations discussed so far through an \nexample\u00ad\n. Assume the following scenario:\nSara is managing a software design project composed of 10 tasks. Each task was estimated to \ncost $1,000; therefore, BAC = $10,000. Each task was estimated to be completed in a month; \ntherefore, the total planned duration for the project was estimated to be 10 months. Since \neach task is expected to have the same cost and duration, the completion of an individual task \nrepresents 10% completion of the design project. In the current fifth month, only three tasks \nhave been fully completed at a cost of $4,000. Sara needs to provide upper management with \ncurrent progress status. \nTABLE\u00a010.6\nEVM Definition of Parameters\nParameter\nDescription\nEV\nAlso called budgeted cost of work performed (BCWP), it is the dollar amount of the work \ncurrently completed\nAC\nAlso called actual cost of work performed (ACWP), it represents the amount of money that was \nspent on the work currently completed\nPV\nAlso called budgeted cost of work scheduled (BCWS), it represents the value of the work that was \nexpected to be completed at that point in time of the schedule\nCV\nDescribes the difference between the value of work completed and the actual cost spent to \ncomplete it\nSV\nDescribes the difference between the value of work currently completed and the cost of the \nwork that was expected to be completed\nCPI\nDescribes the current cost efficiency of the work (CPI < 1 means over budget; CPI > 1 means \nunder budget; CPI = 1 means right on budget)\nSPI\nDescribes the current schedule efficiency of the work (SPI < 1 means behind schedule; SPI > 1 \nmeans ahead of schedule; SPI = 1 means right on schedule)\nBAC\nTotal budget for the project\nETC\nRepresents the estimated cost remaining to complete the project\nEAC\nRepresents the total cost of the entire project\nTABLE\u00a010.7\nEquations for EVM parameters\nParameter\nEquation\nEV\nEV = (% work completed) \u2217 planned cost for the work\nCV\nCV = EV \u2013 AC\nSV\nSV = EV \u2013 PV\nCPI\nCPI = EV/AC\nSPI\nSPI = EV/PV\nETC\nETC = (BAC \u2013 EV)/CPI\nEAC\nEAC = ETC + AC\n", "page": 351, "type": "text", "section": "Page 351"}
{"text": "328\u2002 \u2022\u2002 Software Engineering Design\nIn this scenario, Sara can use the set of equations from Table\u00a010.7 to present upper man-\nagement with a complete progress status of the project. EV is calculated to be $3,000 given \nthat the three tasks completed represent 30% of the project, and the budget for the entire \nproject is $10,000. To calculate SV, we use a PV of $5,000 because each task was budgeted at \n$1,000 and five tasks should have been completed in the fifth month. Table\u00a010.8 shows the \ncalculations for the rest of the EVM parameters. These results clearly show that the project is \nover both budget and schedule estimates. The CPI index, for example, shows that only $0.75 \nof earned value was received for every dollar actually spent. The EAC shows an estimated \n$6,333 over budget amount. These alarming values give Sara and upper management the \nopportunity to implement risk mitigation policies to either get the project to its budgeted \npath or at least attempt to minimize losses.\nSkill Development 10.2: Estimating Project Completion via Simple Simulation\nEstimating the percent completion of tasks is not an exact science. In fact, we can say \nthat estimated values of percentage completion are uncertain and therefore can be \ntreated as random variables from assumed probabilistic distributions. An example of \na probabilistic distribution is the uniform distribution, which is a continuous distri-\nbution where possible events (within a lower and upper bound) have the same prob-\nability of occurrence. This distribution is expressed as U(a, b), where a and b denote \nlower and upper limits, respectively. In the example related to Table\u00a010.8, assume that \nthe costs for the tasks are considered random variables. More specifically, assume \nthat the estimated costs for Tasks 1, 3, 5, 7, and 9 can be modeled with the following \ndistribution: U($700, $1,300). Similarly, assume that the estimated costs for Tasks 2, \n4, 6, 8, and 10 can be modeled with the following distribution: U($800, $1,200). In a \nspreadsheet (e.g.,\u00a0Microsoft Excel), simulate 10 values for the cost of each task. What \nis the average cost of the project using simulation? Are there any benefits from using \nsimulation \u00ad\nmodeling for project cost estimation? Note: In Excel, to model a U(a, b) \nrandom \u00ad\nvariable, type the following function in an empty cell: = a + (b \u2013 a)*RAND(). \nRemember that it is critical to begin with the \u201c=\u201d sign.\nTABLE\u00a010.8\nExample EVM Parameters\nParameter\nCalculation\nEV\n0.3 \u2217 $10,000 = $3,000\nCV\n$3,000 \u2013 $4,000 = -$1,000\nSV\n$3,000 \u2013 $5,000 = -$2,000\nCPI\n$3,000/$4,000 = 0.75\nSPI\n$3,000/$5,000 = 0.6000\nETC\n($10,000 \u2013 $3,000)/0.75 = $9,333\nEAC\n$9,333 + $7,000 = $16,333\n", "page": 352, "type": "text", "section": "Page 352"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 329\nTERMINATION STAGE\nDuring the termination stage, key activities involve verification that everything is in place \nfor a smooth transition into the code construction phase. Activities include, for example, \nmaking sure that the latest versions of the design documents are securely stored based \non configuration management procedures, updating schedule and cost current values, \nreevaluating schedule and budget plans based on the resulting performance measures of \nthe design phase, and communicating results to upper management.\nLEADING THE DESIGN EFFORT\nWithout a doubt, leadership plays a key role in the success or failure of complex projects. \nAs such, it is necessary to cover important concepts related to leadership in the design \neffort. It\u00a0is important to mention that the field of leadership is one that has been researched \nby academicians and practitioners for many years. Therefore, there is an extensive body \nof knowledge and literature related to this field. The purpose of this section is to high-\nlight some key leadership concepts that are relevant to our study of software designs. \nA\u00a0significant part of the material covered in this section was gathered from Lussier and \nAchua (2010); therefore, readers are referred to this work for more detailed explanations of \n\u00ad\nleadership concepts.\nPersonality Traits and Leadership\nTraits are personal characteristics that help to describe a person. For example, someone \nwho has the ability to communicate well with others and start friendly conversations with \nunknown people can be said to have a highly sociable trait. Someone who works hard and \ntends to go the extra mile to complete assigned tasks can be said to possess an achieve-\nment trait. The combination of traits that a person has defines that person\u2019s personality, \nand personality significantly affects our decisions. For example, a highly sociable person \nwith an achievement trait is expected to make decisions such as volunteering to make \npresentations to clients. Given that a good decision-making ability is a major part of being \nan effective leader, it is important to understand the relationship among traits, personality, \ndecision making, and leadership.\nPersonality Dimensions\nResearchers have identified five personality dimensions to categorize groups of traits. The \nidea behind this is to be able to classify someone\u2019s personality into one of these dimen-\nsions. The five dimensions are agreeableness, surgency, adjustment, conscientiousness, and \n", "page": 353, "type": "text", "section": "Page 353"}
{"text": "330\u2002 \u2022\u2002 Software Engineering Design\n\u00ad\nopenness to experience. Although called by different names by various researchers, we will \nrefer to Lussier and Achua (2010) and call them the Big Five Model of Personality.\nThe agreeableness dimension contains traits that are related to getting along with people. \nIndividuals who are strong in agreeableness are friendly, sociable, and compassionate. The \nsurgency dimension, on the other hand, corresponds to personalities that are dominant \n(i.e., want to be in control), enjoy competition, and are willing to confront others, among \nother things. Individuals who are weak in surgency are typically followers. The adjust-\nment dimension is related to emotional stability. Individuals who are strong in this dimen-\nsion are considered stable people who are in control of themselves, are positive minded, \nand react well under pressure. Those who are weak in adjustment are considered unstable \nand typically are characterized by being negative and performing poorly under pressure. \nThe\u00a0conscientiousness dimension contains traits related to achievement. Basically, indi-\nviduals who are strong in this dimension are those who are willing to work extra hours and \nmake sacrifices to reach the assigned objectives. Last but not least, the openness to experi-\nence dimension is related to individuals who are flexible to change, are open-minded, and \nattempt enjoy trying new things. Understanding these dimensions is important because \nresearchers have found varying degrees of correlations between leadership and each of the \nfive personality dimensions. For example, Judge, Ilies, Bono, and Gerhardt (2007) analyzed \nover 70 prior studies to determine correlations among the five personality dimensions and \nleadership. The results of this study showed that the surgency dimension was the highest \nwith a 0.31 correlation. This means that traits corresponding to surgency can be used, to \nsome extent, to describe leadership. The second highest was conscientiousness with a 0.28 \ncorrelation, followed by openness to experience with 0.24 and agreeableness with 0.08.\nTraits of Effective Leaders\nAs already stated, personality dimensions are defined by groups of traits and can provide \nan understanding of leadership in individuals. A different approach to studying personal-\nity dimensions is to investigate common individual traits that effective leaders possess, \nwithout grouping traits into personality dimensions. Some of the most important traits \nare presented in Table\u00a010.9.\nEthical Leadership\nEthics can be defined as a set of moral principles that facilitates the process to distinguish \nbetween right and wrong behavior. Research has shown that ethical behavior positively \ncorrelates with leadership effectiveness (Veiga 2004). Furthermore, it is well-known that \none of the best ways to lead is by example. Therefore, an ethical leader sets the tone for \nemployees to conduct themselves in an ethical manner. However, being an ethical leader \ncan be very challenging because of the risk of rejection or loss associated with ethical deci-\nsions. A few things can be done to overcome this challenge, one of which is to focus on a \nhigher purpose while going through the decision process that involves moral behavior. For \nexample, assume that the design lead of a major top secret software project is approached \n", "page": 354, "type": "text", "section": "Page 354"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 331\nby a foreign citizen with a proposition to sell the software design and other important \ndocuments to an enemy country. If focused on the safety of the people (i.e., the higher \npurpose), then ethical values will provide the answer of not accepting the offer and report-\ning the foreign person to the authorities. Another approach that can be taken to over-\ncome the challenges associated with ethical decisions is to find support from other ethical \npeople (e.g., friends, family, coworkers). To help employees distinguish between ethical and \nunethical activities, most companies have their own internal documents that describe the \nexpected ethical behavior from employees. It is very important for leaders to conform to \nthese guidelines and discuss them with employees.\nPower\nLeading is about influencing others. The potential influence that leaders have over others \nis called power. The word potential means that it is actually the perception of power, and \nnot the power itself, that influences followers. The two main sources of power are position \npower and personal power. Position power is related to hierarchical position levels. More \nspecifically, higher hierarchical levels mean higher potential power. Therefore, the presi-\ndent of a software company has more potential power than any other employee in the com-\npany because of position power. Position power is important because it allows \u00ad\nmanagers \nto influence employees to reach planned objectives. There are various types of position \npower. An example of one is called the reward power. This type of power gives managers \nthe \u00ad\nability to influence employees with something of value to them, namely, performance \nevaluations. Employees will be influenced to complete their corresponding assignments \nbecause of their manager\u2019s reward power to provide good performance evaluations\u00ad\n. \nAnother type of position power\u2014related to reward power\u2014is called coercive power. The \ncoercive power basically says that managers have the ability to influence \u00ad\nothers by the idea \nof punishment and withholding of rewards. Following the same example, employees can \nTABLE\u00a010.9\nTraits of Effective Leaders\nPrinciple\nDescription (Trait\u2019s Characteristics in a Person)\nDominance\nThis trait describes a person who wants to be a manager and takes control. Successful \nleaders with this trait are not overly bossy and avoid the bullying style.\nHigh energy\nThis trait describes a positive-minded person who works hard to achieve objectives and \nis good at taking initiative.\nIntegrity\nThis trait describes a person who is highly ethical and trustworthy.\nFlexibility\nThis trait describes a person who can adapt well to new and different situations.\nSelf-confidence\nThis trait describes a person who trusts his or her judgment, initiatives, intelligence, \nand ideas. This is not to be confused with arrogance.\nStability\nThis trait describes a person who is able to control emotions and act well under pressure.\nIntelligence\nThis trait describes a person who possesses a high cognitive ability to solve problems \nand make decisions.\nSensitivity to others\nThis trait describes a person who focuses on the feelings of others and strongly \nconsiders them.\n", "page": 355, "type": "text", "section": "Page 355"}
{"text": "332\u2002 \u2022\u2002 Software Engineering Design\nbe influenced to complete their corresponding assignments because of their manager\u2019s \ncoercive power to provide bad performance evaluations and withhold salary increases.\nPersonal power relates to the potential influence that a person\u2019s behavior has to influ-\nence others. Being positive, assertive, and hard-working are some of the characteristics that \nincrease personal power. As with position power, there are also various types of personal \npower. One example is the expert power. This type of power is based on the ability to influ-\nence others based on a leader\u2019s skill and knowledge. For example, being an expert in devel-\noping architectural designs will influence others to follow the expert. The expert power of \nan individual gets stronger as people with similar expertise levels become fewer. Another \ntype of personal power is called connection power. Connection power refers to the ability \nof a person\u00ad\n to influence others because of the person\u2019s relationships with influential people.\nKEY LEADERSHIP SKILLS\nVarious skills are important to leadership. Some of these skills include communication, \nnetworking, motivation, and negotiation. These are described in the following subsections.\nCommunication Skills\nGood communication skills are essential for effective leadership. Various researchers \n(see,\u00a0e.g., Li and Liu 2010; Simkin 1996) have mentioned that a high percent of a managers\u2019 \ntime is spent in communications. As already mentioned, leadership is about influencing \nothers. Leaders can influence and establish productive relationships with others through \ncommunication. Truly effective communication occurs when the information passed is \nequally and fully understood by all parties. One way to achieve effective communication is \nto plan in advance the message that needs to be conveyed. To achieve this, the goal of the \nmessage needs to be clearly understood. Also, it is important to think about the best timing \nto convey the message, how the message will be delivered (e.g., oral, written), and where \n(e.g., company\u2019s auditorium, employee\u2019s office).\nOne type of communication is oral communication. To become an effective oral commu-\nnicator can be challenging and often takes much practice. One way to become effective is to \nhave a process in place so that focus can be placed in the individual elements of the process. \nLussier and Achua (2010) describe a five-step process for effectively sending oral messages. \nThe first step is to develop a rapport. This means to try establishing a good relationship with \nthe receiving party and begin small conversations related to the message. The second step is \nto clearly state the objective of the message. This is crucial as it helps the receiver to under-\nstand what the message is expected to accomplish before the details of the message are trans-\nmitted. This will engage the receiver\u2019s mind to focus on the message\u00ad\n to be received. The third \nstep is to actually transmit the message. The fourth step is to perceive the receiver\u2019s under-\nstanding of the message. It is important that the message was well understood; otherwise, its \nobjectives were not achieved. This can be accomplished by asking direct questions or reading \n", "page": 356, "type": "text", "section": "Page 356"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 333\nthe receiver\u2019s expressions. When convinced that the message was understood, the final step \nof the process is to get a commitment from the receiver. This is unnecessary if the goal of the \nmessage is to merely inform. However, if the goal is to influence the receiver to accomplish \na task (e.g., design document), then a commitment from the receiver to complete the task is \nnecessary. For this, the leader must be convinced that the receiver is capable of completing \nthe task by its deadline. When a commitment from the receiver is received, the leader must \nfollow up to make sure that the task is being accomplished. If not, the leader can make use of \nthe power concept to persuade the receiver to complete the task.\nAnother type of communication is written communication. This type of communication \nis now more important than ever, and it is mainly attributed to e-mail technology. Today, \npeople around the world communicate with each other via e-mails, and e-mailing between \nmanagers and employees is almost always the preferred type of written communication.\nThe key elements for effective written communication are content and structure. That is, \nthe message must be structured in such a way that the information it intends to transmit \n(i.e., content) is clearly described and the flow of information is smooth and easy to follow\u00ad\n. \nAs with oral communication, it is critical for the communicator to clearly understand \nthe intended objective of the message before writing it. One way to do this is to make an \n\u00ad\noutline with the main points that need to be transmitted. Making an outline also helps to \nestablish an appropriate flow for the message, which is necessary for a clear understanding \nof it. Another way to improve message flow is to avoid including unnecessary information. \nMessages must be kept short, simple, and to the point.\nA final point on written communication is that we must understand that writing is \na skill. As such, it takes effort (e.g., reading books on proper grammar) and practice to \nbecome good at it. One way to improve this skill is to have others review your work so \nthat you can learn from their feedback. It is important to keep in mind that editing and \nrewriting are often necessary actions to ensure the quality of messages. With continued \nadvances in technology, the value of becoming an effective writer is becoming more and \nmore important to leadership. Consider, for example, the relatively recent technology of \nsocial networking and electronic chatting rooms, which allow real-time written commu-\nnication between parties around the world.\nNetworking Skills\nNetworking can be defined as a skill that focuses on building relationships with others \nthrough effective communications. Thus, communications and networking skills are closely \nrelated to each other. Networking is particularly important for leadership because it facilitates \nthe process of meeting objectives. As with any skill, networking can be improved with practice.\nMotivation Skills\nIt can be safe to say that there exists a positive correlation between employees\u2019 motivation \nlevels and their productivity. Therefore, the ability to motivate others to work hard to achieve \nparticular project goals is a major part of being a leader. For various decades now, motivation \n", "page": 357, "type": "text", "section": "Page 357"}
{"text": "334\u2002 \u2022\u2002 Software Engineering Design\nhas been an area of investigation to many researchers. Various theories have been developed \nto describe a set of motivational factors that significantly affect individuals\u2019 behavior. The \ngeneral benefit sought from these research studies was that identifying and understand-\ning these factors would provide leaders with necessary resources to positively influence and \ninspire employees to successfully complete their tasks.\nOne of the motivational theories developed is called the hierarchy of needs theory (Lussier \nand Achua 2010). This theory describes five types of needs through which employees are \nmotivated. Table\u00a010.10 shows the five types and provides some of the activities that can \nhelp meet the particular needs associated with each type.\nNegotiation Skills\nNegotiation skills are an important part of any management job. Good negotiators are \ncapable of leading by looking out for the best interests of the people that they are leading. \nThere are many research studies related to negotiations, some of which have resulted in \nguidelines that can help to improve a person\u2019s negotiation skills. One such set of guidelines, \ncalled principled negotiation, was developed by Fisher and Ury (1991). Principled negotia-\ntion is composed of four guidelines. The first one is to separate the people from the problem. \nThis principle helps to keep the focus on the problem at hand rather than on interpersonal \nissues. The second guideline is to focus on interests rather than \u00ad\npositions. This principle helps \nto keep the focus of the negotiation on the interests of people rather than their positions. \nThe third guideline is to generate options before trying to reach an\u00a0agreement. This\u00a0principle \npromotes creativity and reminds the negotiating parties to brainstorm to find potential \nTABLE\u00a010.10\nTypes of Needs and Activities to Meet Them\nType of Need\nActivities to Meet the Needs\nPhysiological\nAdequate salaries\nAllowance of breaks\nAdequate working conditions\nSafety\nSafe working conditions\nSalary increases (considering inflation)\nFringe benefits\nSocial\nSocial activities that conform to individual behavior\nTeam-building retreats\nTeam sports\nLunch gatherings\nEsteem\nRaises based on performance\nAwards\nPublic recognition\nParticipation in decision making\nSelf-actualization\nSkill development activities\nPromotions\nIncrease control of an employee\u2019s task\n", "page": 358, "type": "text", "section": "Page 358"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 335\nsolutions that can be brought to the negotiation. The fourth guideline is to insist on using \nobjective criteria. This principle promotes decision making based on reasonable standards \nrather than on subjective ones.\nETHICS IN SOFTWARE DESIGN\nSoftware engineers must abide to the highest possible standards when developing soft-\nware systems to make the software engineering profession beneficial and highly respected. \nEngineers have the responsibility to public welfare, including health and safety. The \nIEEE-CS/ACM organizations developed a Software Engineering Code of Ethics (SECE) \n(IEEE 2010) as the standard set of ethical guidelines that engineers must adhere to. \nThis\u00a0code contains the principles shown in Table\u00a010.11.\nAs seen, these principles collectively ensure that professionals in the software engineer-\ning field adhere to high levels of ethical conduct. In one way or another, all of these prin-\nciples can be directly related with the design of software systems. The SECE provides a very \nclear set of guidelines for each principle. Following is a brief description of some of these \nprinciples, as well as their specific guidelines from the SECE.\nPublic and Product Principles\nThe public principle is the first principle included in the SECE (Table\u00a010.12). Basically, this \nprinciple states that professionals in the software engineering field must take responsibil-\nity for their own work and must ensure that their work positively affects the public good. \nThe product principle (Table\u00a010.13) states, among other things, that professionals must \nstrive for high quality within acceptable cost and schedule thresholds.\nTABLE\u00a010.11\nPrinciples of Ethics in Software Engineering\nPrinciple\nDescription\nPublic\nSoftware engineers shall act consistently with the public interest.\nClient and Employer\nSoftware engineers shall act in a manner that is in the best interests of their client and \nemployer consistent with the public interest.\nProduct\nSoftware engineers shall ensure that their products and related modifications meet \nthe highest professional standards possible.\nJudgment\nSoftware engineers shall maintain integrity and independence in their \nprofessional\u00a0judgment.\nManagement\nSoftware engineering managers and leaders shall subscribe to and promote an ethical \napproach to the management of software development and maintenance.\nProfession\nSoftware engineers shall advance the integrity and reputation of the profession \nconsistent with the public interest.\nColleagues\nSoftware engineers shall be fair to and supportive of their colleagues.\nSelf\nSoftware engineers shall participate in lifelong learning regarding the practice of their \nprofession and shall promote an ethical approach to the practice of the profession.\nSource:\t\nIEEE Computer Society, Software Engineering Code of Ethics and Professional Practice. 2010.\n", "page": 359, "type": "text", "section": "Page 359"}
{"text": "336\u2002 \u2022\u2002 Software Engineering Design\nJudgment Principle\nAlthough maintaining integrity in professional judgment should be implicitly under-\nstood for every principle in the SECE, a high level of individual integrity is so impor-\ntant that the code explicitly included it into a single principle, the judgment principle \n(Table\u00a010.14). Making decisions that conform to the highest ethical levels can be very \nchallenging at times; therefore, the integrity and moral values of a person play a major \nrole when making judgment calls.\nManagement Principle\nThe management principle is of particular relevance to this chapter. Therefore, Table\u00a010.15 \noutlines the guidelines included for software engineering managers in the code of ethics.\nCHAPTER SUMMARY\nThis chapter presented an introduction to software design management. In particular, this \nchapter focused on describing three major elements that are critical for the success of any \nmajor design project: management, leadership, and ethics. In doing so, the chapter developed \na design management framework that describes important concepts related to each element \nwith the hope of facilitating the successful management of this complex phase.\nTABLE\u00a010.12\nGuidelines Concerning the Public Principle\nNo.\nGuideline Description\n1.01\nEngineers must accept full responsibility for their own work.\n1.02\nModerate the interests of the software engineer, the employer, the client and the users with the \npublic\u00a0good.\n1.03\nApprove software only if they have a well-founded belief that it is safe, meets specifications, passes tests, \nand does not diminish quality of life, diminish privacy or harm the environment. The ultimate effect of \nthe work should be to the public good.\n1.04\nDisclose to appropriate persons or authorities any actual or potential danger to the user, the public, or \nthe environment, that they reasonably believe to be associated with software or related documents.\n1.05\nCooperate in efforts to address matters of grave public concern caused by software, its installation, \nmaintenance, support or documentation.\n1.06\nBe fair and avoid deception in all statements, particularly public ones, concerning software or related \ndocuments, methods and tools.\n1.07\nConsider issues of physical disabilities, allocation of resources, economic disadvantage and other \nfactors that can diminish access to the benefits of software.\n1.08\nBe encouraged to volunteer professional skills to good causes and contribute to public education \nconcerning the discipline.\nSource:\t\nIEEE Computer Society, Software Engineering Code of Ethics and Professional Practice. 2010.\n", "page": 360, "type": "text", "section": "Page 360"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 337\nTABLE\u00a010.13\nGuidelines Concerning the Product Principle\nNo.\nGuideline Description\n3.01\nStrive for high quality, acceptable cost and a reasonable schedule, ensuring significant tradeoffs are \nclear to and accepted by the employer and the client, and are available for consideration by the user \nand the public.\n3.02\nEnsure proper and achievable goals and objectives for any project on which they work or propose.\n3.03\nIdentify, define and address ethical, economic, cultural, legal and environmental issues related to \nwork\u00a0projects.\n3.04\nEnsure that they are qualified for any project on which they work or propose to work by an \nappropriate combination of education and training, and experience.\n3.05\nEnsure an appropriate method is used for any project on which they work or propose to work.\n3.06\nWork to follow professional standards, when available, that are most appropriate for the task at hand, \ndeparting from these only when ethically or technically justified.\n3.07\nStrive to fully understand the specifications for software on which they work.\n3.08\nEnsure that specifications for software on which they work have been well documented, satisfy the users \nrequirements and have the appropriate approvals.\n3.09\nEnsure realistic quantitative estimates of cost, scheduling, personnel, quality and outcomes on \nany\u00a0project on which they work or propose to work and provide an uncertainty assessment of \nthese\u00a0estimates.\n3.10\nEnsure adequate testing, debugging, and review of software and related documents on which they work.\n3.11\nEnsure adequate documentation, including significant problems discovered and solutions adopted, \nfor\u00a0any project on which they work.\n3.12\nWork to develop software and related documents that respect the privacy of those who will be affected \nby that software.\n3.13\nBe careful to use only accurate data derived by ethical and lawful means, and use it only in ways \nproperly authorized.\n3.14\nMaintain the integrity of data, being sensitive to outdated or flawed occurrences.\n3.15\nTreat all forms of software maintenance with the same professionalism as new development.\nSource:\t\nIEEE Computer Society, Software Engineering Code of Ethics and Professional Practice. 2010.\nTABLE\u00a010.14\nGuidelines Concerning the Judgment Principle\nNo.\nGuideline Description\n4.01\nTemper all technical judgments by the need to support and maintain human values.\n4.02\nOnly endorse documents either prepared under their supervision or within their areas of competence \nand with which they are in agreement.\n4.03\nMaintain professional objectivity with respect to any software or related documents they are asked \nto\u00a0evaluate.\n4.04\nNot engage in deceptive financial practices such as bribery, double billing, or other improper \nfinancial\u00a0practices.\n4.05\nDisclose to all concerned parties those conflicts of interest that cannot reasonably be avoided or escaped.\n4.06\nRefuse to participate, as members or advisors, in a private, governmental or professional body \nconcerned with software related issues, in which they, their employers or their clients have \nundisclosed potential conflicts of interest.\nSource:\t\nIEEE Computer Society, Software Engineering Code of Ethics and Professional Practice. 2010.\n", "page": 361, "type": "text", "section": "Page 361"}
{"text": "338\u2002 \u2022\u2002 Software Engineering Design\nThe chapter described the software design phase as a complex task that must be man-\naged in order to achieve acceptable quality levels. Various project management techniques \nwere presented. These included techniques for planning such as work breakdown struc-\ntures, linear responsibility charts, and network diagrams for scheduling. It also included \na description of earned value management as a tool for determining the progress of tasks \nbased on the value of the work currently completed versus the work that was expected to \nbe completed at that particular time. The chapter also described the relationship between \nmanagement and leadership, highlighted several leadership traits that are important for \nsuccessful results, and presented various ethic items from the Software Engineering Code \nof Ethics that are relevant to software design projects.\nREVIEW QUESTIONS\n\t\n1.\tWhat is software design management, and why is it important?\n\t\n2.\tWhy is it important to view the software design phase as a project?\n\t\n3.\tWhat are the phases of the software design phase?\n\t\n4.\tWhat are the managerial objectives of the planning stage?\n\t\n5.\tWhat project management tools can be used to manage the planning phase of a soft-\nware design project? Briefly explain them.\n\t\n6.\tWhat project management tools can be used to manage the implementation phase of \na software design project? Briefly explain them.\nTABLE\u00a010.15\nGuidelines Concerning the Management Principle\nNo.\nGuideline Description\n5.01\nEnsure good management for any project on which they work, including effective procedures for \npromotion of quality and reduction of risk.\n5.02\nEnsure that software engineers are informed of standards before being held to them.\n5.03\nEnsure that software engineers know the employer\u2019s policies and procedures for protecting passwords, \nfiles and information that is confidential to the employer or confidential to others.\n5.04\nAssign work only after taking into account appropriate contributions of education and experience \ntempered with a desire to further that education and experience.\n5.05\nEnsure realistic quantitative estimates of cost, scheduling, personnel, quality and outcomes on any\u00a0project \non which they work or propose to work, and provide an uncertainty assessment of these\u00a0estimates.\n5.06\nAttract potential software engineers only by full and accurate description of the conditions \nof\u00a0employment.\n5.07\nOffer fair and just remuneration.\n5.08\nNot unjustly prevent someone from taking a position for which that person is suitably qualified.\n5.09\nEnsure that there is a fair agreement concerning ownership of any software, processes, research, \nwriting, or other intellectual property to which a software engineer has contributed.\n5.10\nProvide for due process in hearing charges of violation of an employer\u2019s policy or of this Code.\n5.11\nNot ask a software engineer to do anything inconsistent with this Code.\n5.12\nNot punish anyone for expressing ethical concerns about a project.\nSource:\t\nIEEE Computer Society, Software Engineering Code of Ethics and Professional Practice. 2010.\n", "page": 362, "type": "text", "section": "Page 362"}
{"text": "Software Design Management, Leadership, and Ethics\u2002 \u2022\u2002 339\n\t\n7.\tWhat is the importance of a change control process?\n\t\n8.\tWhy is estimating the percent completion of a task so important in earned value \nmanagement?\n\t\n9.\tWhat are the four guidelines described in the chapter to estimate percent work \ncompletion?\n\t 10.\tWhat are some of the traits of effective leaders?\n\t 11.\tHow do management and leadership relate to each other?\n\t 12.\tExplain the concept of power and how it can influence others.\n\t 13.\tWhat are the key leadership skills described in the chapter?\n\t 14.\tHow do ethics and leadership relate to each other?\nCHAPTER EXERCISES\n\t\n1.\tThe following table contains task durations for a project.\nTask ID\nTime (Days)\nMinimum (a)\nMost Likely (m)\nMaximum (b)\nImmediate Predecessors\nA\n10\n22\n38\n\u2014\nB\n3\n7\n12\nA\nC\n11\n25\n44\nB\nD\n11\n24\n42\nB\nE\n4\n9\n17\nB, C\nF\n2\n5\n9\nD, E\nG\n4\n8\n14\nF\nH\n11\n24\n43\nG\n\t\na.\t Construct an AON network diagram and identify the critical path. What is the \nduration of the critical path?\n\t\nb.\t What is the probability that the project gets completed by 85% of the critical path \nduration?\n\t\n2.\tThe following table contains expected duration times and expected cost for the set of \ntasks corresponding to a major design project that Dr. Christian Daniel is managing.\nTask ID\nExpected Duration \n(Months)\nExpected Cost ($)\nTask Predecessor\n1\n1\n1,500\n\u2014\n2\n2\n3,000\n1\n3\n1\n1,500\n2\n4\n2\n3,000\n3\n5\n1\n1,500\n4\n6\n2\n3,000\n5\n7\n1\n1,500\n6\n8\n2\n3,000\n7\n", "page": 363, "type": "text", "section": "Page 363"}
{"text": "340\u2002 \u2022\u2002 Software Engineering Design\n\t\na.\t Assume a scenario where at the end of the seventh month five tasks have been \ncompleted at a cost of $11,500. Use the EVM equations to understand and show the \ncurrent status of the project. Also, based on this scenario, what is the EAC value?\n\t\nb.\t Assume a scenario where at the end of the sixth month two tasks have been com-\npleted at a cost of $8,500. Use the EVM equations to understand and show the \ncurrent status of the project. Also, based on this scenario, what is the EAC value?\n\t\nc.\t Assume a scenario where at the end of the tenth month seven tasks have been \ncompleted at a cost of $14,500. Use the EVM equations to understand and show the \ncurrent status of the project. Also, based on this scenario, what is the EAC value?\nREFERENCES\nFisher, R., and W. Ury. Getting to Yes, 2d ed. New York: Penguin Books, 1991.\nGriffin, Ricky W. Management, 10th ed. Mason, OH: South-Western Publications, 2010.\nIEEE Computer Society. \u201cSoftware Engineering Code of Ethics and Professional Practice.\u201d 2010. Available at \nhttp://www.computer.org/portal/web/certification/resources/code_of_ethics.\nJudge, T. A., R. Ilies, J. E. Bono, and M. W. Gerhardt. \u201cPersonality and Leadership: A Qualitative and Quantitative \nReview.\u201d Journal of Applied Psychology 87, no. 4 (2002): 765\u2013768.\nLi, Mei Yan, and Ying Zong Liu. \u201cStudy on Line Managers\u2019 Competence-Based Abilities of Performance \nManagement.\u201d Applied Mechanics and Materials 40\u201341 (2010): 820\u2013824.\nLussier, Robert, and Christopher Achua. Leadership: Theory, Application, & Skill Development, 4th ed. Florence, \nKY: Cengage Learning, 2010.\nMeredith, Jack, and Samuel Mantel. Project Management: A Managerial Approach, 7th ed. Hoboken, NJ: \nJohn\u00a0Wiley & Sons, 2009.\nNebus, J. \u201cBuilding Collegial Information Networks: A Theory of Advice Network Generation.\u201d Academy of \nManagement Review 31, no. 3 (2006): 615\u2013637.\nPelosi, Marilyn K., and Theresa M. Sandifer. Elementary Statistics: From Discovery to Decision. Hoboken, NJ: \nJohn Wiley & Sons, 2003.\nSimkin, Mark. \u201cThe Importance of Good Communication Skills on \u2018IS\u2019 Career Paths.\u201d Journal of Technical \nWriting and Communication 26, no. 1 (1996): 69\u201378.\nVeiga, J. F. \u201cSpecial Topic Ethical Behavior in Management, Bringing Ethics into the Mainstream: An Introduction \nto the Special Topic.\u201d Academy of Management Executive 18, no. 2 (2004): 37\u201338.\n", "page": 364, "type": "text", "section": "Page 364"}
{"text": "Software Engineering & Systems Development \nTaking a learn-by-doing approach, Software Engineering Design: Theory and \nPractice uses examples, review questions, chapter exercises, and case study assign-\nments to provide students and practitioners with the understanding required to de-\nsign complex software systems. Explaining the concepts that are immediately rele-\nvant to software designers, it begins with a review of software design fundamentals. \nThe text presents a formal top-down design process that consists of several design \nactivities with varied levels of detail, including the macro-, micro-, and construction-\ndesign levels. As part of the top-down approach, it provides in-depth coverage of \napplied architectural, creational, structural, and behavioral design patterns. For \neach design issue covered, it includes a step-by-step breakdown of the execution of \nthe design solution, along with an evaluation, discussion, and justification for using \nthat particular solution. \nThe book outlines industry-proven software design practices for leading large-scale \nsoftware design efforts, developing reusable and high-quality software systems, \nand producing technical and customer-driven design documentation. It also:\n\u2022 Offers one-stop guidance for mastering the Software Design \n& Construction sections of the official Software Engineering \nBody of Knowledge (SWEBOK\u00ae)\n\u2022 Details a collection of standards and guidelines for structuring  \nhigh-quality code\n\u2022 Describes techniques for analyzing and evaluating the quality \nof  software designs \nCollectively, the text supplies comprehensive coverage of the software design \nconcepts students will need to succeed as professional design leaders. The section \non engineering leadership for software designers covers the necessary ethical and \nleadership skills required of software developers in the public domain. The section on \ncreating software design documents (SDD) familiarizes students with the software \ndesign notations, structural descriptions, and behavioral models required for SDDs.\nCourse notes, exercises with answers, online resources, and an instructor\u2019s \nmanual are available upon qualified course adoption.\nISBN: 978-1-4398-5168-5\n9 781439 851685\n90000\nK12371\nwww.auerbach-publications.com\nwww.crcpress.com\n", "page": 365, "type": "text", "section": "Page 365"}
