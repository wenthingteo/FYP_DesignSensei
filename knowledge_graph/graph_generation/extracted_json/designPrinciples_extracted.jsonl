{"text": "PRINCIPLES OF \nSOFTWARE DESIGN\nF. Tip and \nM. Weintraub\nThanks go to Andreas Zeller for allowing incorporation of his materials\n", "page": 1, "type": "text", "section": "Page 1"}
{"text": "THE CHALLENGE\n1. Software may live much longer than expected\n2. Software must be continuously adapted to a changing \nenvironment\n3. Maintenance takes 50\u201380% of the cost\nGoal: Make software maintainable and reusable \u2013 at little \nor no cost\n", "page": 2, "type": "text", "section": "Page 2"}
{"text": "USE THE PRINCIPLES OF OBJECT-ORIENTED \nDESIGN TO ACHIEVE THE GOAL\n1. Abstraction\n2. Encapsulation\n3. Modularity\n4. Hierarchy\nGoal: Maintainability and Reusability\n", "page": 3, "type": "text", "section": "Page 3"}
{"text": "PRINCIPLES OF OBJECT-ORIENTED DESIGN\n1. Abstraction\n2. Encapsulation\n3. Modularity\n4. Hierarchy\n", "page": 4, "type": "text", "section": "Page 4"}
{"text": "ABSTRACTION\nConcrete Object\nGeneral Principle\n", "page": 5, "type": "text", "section": "Page 5"}
{"text": "ABSTRACTION\u2026\n1. Highlights common properties of objects\n2. Distinguishes important and unimportant properties\n3. Must be understood even without a concrete object\n", "page": 6, "type": "text", "section": "Page 6"}
{"text": "ABSTRACTION\n\u201cAn abstraction denotes the essential characteristics \nof an object that distinguish it from all other kinds \nof objects and thus provide crisply defined \nconceptual boundaries, relative to the perspective of \nthe viewer\u201d\nFrom \u201cObject Oriented Design with Applications\u201d by Grady Booch\n", "page": 7, "type": "text", "section": "Page 7"}
{"text": "PERSPECTIVES\n", "page": 8, "type": "text", "section": "Page 8"}
{"text": "EXAMPLE: SENSORS\n", "page": 9, "type": "text", "section": "Page 9"}
{"text": "AN ENGINEER\u2019S SOLUTION\nvoid check_temperature() {\n// see specs AEG sensor type 700, pp. 53\nshort *sensor = 0x80004000;\nshort *low    = sensor[0x20];\nshort *high   = sensor[0x21];\nint temp_celsius = low + high * 256;\nif (temp_celsius > 50) {\nturn_heating_off()\n}\n}\nC code where values read by a sensor are directly mapped to memory locations\n", "page": 10, "type": "text", "section": "Page 10"}
{"text": "interface Temperature { \u2026 }\ninterface Location { \u2026 }\nclass TemperatureSensor {\npublic TemperatureSensor(Location){ \u2026 }\npublic void calibrate(Temperature actual){ \u2026 }\npublic Temperature currentTemperature(){ \u2026 }\npublic Location location(){ \u2026 }\n// private methods below\n}\nABSTRACT SOLUTION\nAll implementation \ndetails are hidden\n", "page": 11, "type": "text", "section": "Page 11"}
{"text": "MORE ABSTRACTION\n", "page": 12, "type": "text", "section": "Page 12"}
{"text": "IT\u2019S A PROJECTION OF A SLIDE OF A \nPHOTO OF A PAINTING OF A PIPE\n", "page": 13, "type": "text", "section": "Page 13"}
{"text": "PRINCIPLES OF OBJECT-ORIENTED DESIGN\n1. Abstraction \u2013 hide details\n2. Encapsulation\n3. Modularity\n4. Hierarchy\n", "page": 14, "type": "text", "section": "Page 14"}
{"text": "PRINCIPLES OF OBJECT-ORIENTED DESIGN\n1. Abstraction \u2013 Hide details\n2. Encapsulation\n3. Modularity\n4. Hierarchy\n", "page": 15, "type": "text", "section": "Page 15"}
{"text": "ENCAPSULATION\n\u2022 No part of a complex system should depend on internal details \nof another\nGoal: keep software changes local\nInformation hiding: Internal details (state, structure, behavior) \nbecome the object\u2019s secret\n", "page": 16, "type": "text", "section": "Page 16"}
{"text": "GRADY BOOCH ON ENCAPSULATION\n\u201cEncapsulation is the process of \ncompartmentalizing the elements of an \nabstraction that constitute its structure and its \nbehavior; encapsulation serves to separate the \ncontractual interface of an abstraction and its \nimplementation.\u201d\nGrady Booch, Object-Oriented Analysis and Design with Applications, \nAddison-Wesley, 2007, p. 51-52\n", "page": 17, "type": "text", "section": "Page 17"}
{"text": "class ActiveSensor {\npublic ActiveSensor(Location)\npublic void calibrate(Temperature actual){ \u2026 }\npublic Temperature currentTemperature(){ \u2026 }\npublic Location location(){ \u2026 }\npublic void register(ActiveSensorObserver o){ \u2026 }\n// private methods below\u2026\n}\nAN ACTIVE SENSOR\nnotified when \ntemperature \nchanges\nCallback management is the sensor\u2019s secret and this illustrates how the \u201cObserver\u201d \ndesign pattern is used to avoid giving external parties access to internal state of the \nActiveSensor\n", "page": 18, "type": "text", "section": "Page 18"}
{"text": "ANTICIPATING CHANGE\nFeatures you expect will change should be isolated in specific \ncomponents\n\u2022 Number literals\n\u2022 String literals\n\u2022 Presentation and interaction\n", "page": 19, "type": "text", "section": "Page 19"}
{"text": "NUMBER LITERALS\nint a[100]; for (int i = 0; i <= 99; i++) a[i] = 0;\n", "page": 20, "type": "text", "section": "Page 20"}
{"text": "int ONE_HUNDRED = 100;\nint a[ONE_HUNDRED]; \u2026\nNUMBER LITERALS\nint a[100]; for (int i = 0; i <= 99; i++) a[i] = 0;\nint SIZE = 100;\nint a[SIZE]; for (int i = 0; i < SIZE; i++) a[i] = 0;\n", "page": 21, "type": "text", "section": "Page 21"}
{"text": "NUMBER LITERALS\ndouble sales_price = net_price * 1.06;\n", "page": 22, "type": "text", "section": "Page 22"}
{"text": "NUMBER LITERALS\ndouble sales_price = net_price * 1.06;\nfinal double SALES_TAX = 1.06;\ndouble sales_price = net_price * SALES_TAX;\n", "page": 23, "type": "text", "section": "Page 23"}
{"text": "STRING LITERALS\nif (sensor.temperature() > 100)\nSystem.out.println(\u201cWater is boiling!\u201d);\n", "page": 24, "type": "text", "section": "Page 24"}
{"text": "STRING LITERALS\nif (sensor.temperature() > 100)\nSystem.out.println(\u201cWater is boiling!\u201d);\nif (sensor.temperature() > BOILING_POINT)\nSystem.out.println(message(BOILING_WARNING,\n\u201cWater is boiling!\u201d);\nif (sensor.temperature() > BOILING_POINT)\nalarm.handle_boiling();\n", "page": 25, "type": "text", "section": "Page 25"}
{"text": "PRINCIPLES OF OBJECT-ORIENTED DESIGN\n1. Abstraction \u2013 Hide details\n2. Encapsulation \u2013 Keep changes local\n3. Modularity\n4. Hierarchy\n", "page": 26, "type": "text", "section": "Page 26"}
{"text": "PRINCIPLES OF OBJECT-ORIENTED DESIGN\n1. Abstraction \u2013 Hide details\n2. Encapsulation \u2013 Keep changes local\n3. Modularity\n4. Hierarchy\n", "page": 27, "type": "text", "section": "Page 27"}
{"text": "MODULARITY\nBasic idea: Partition a system such that parts can be designed \nand revised independently (\u201cdivide and conquer\u201d)\nSystem is partitioned into modules, with each one fulfilling a \nspecific task\nModules should be changeable and reuseable independent \nof other modules\n", "page": 28, "type": "text", "section": "Page 28"}
{"text": "GRADY BOOCH ON MODULARITY\n\u201cModularity is the property of a system that has \nbeen decomposed into a set of cohesive and \nloosely coupled modules.\u201d\n", "page": 29, "type": "text", "section": "Page 29"}
{"text": "MODULE BALANCE\nGoal 1: Modules should hide information \u2013 and expose as little \nas possible\nGoal 2: Modules should cooperate \u2013 and therefore must \nexchange information\nThese goals conflict with each other\n", "page": 30, "type": "text", "section": "Page 30"}
{"text": "PRINCIPLES OF MODULARITY\nHigh cohesion \nModules should contain functions that \nlogically belong together\nWeak coupling\nChanges to modules should not affect \nother modules\nLaw of Demeter \nTalk only to friends \n", "page": 31, "type": "text", "section": "Page 31"}
{"text": "HIGH COHESION\n1. Modules should contain \nfunctions that logically \nbelong together\n2. Achieved by grouping \nfunctions that work on the \nsame data\n3. \u201cNatural\u201d grouping in object \noriented design\n", "page": 32, "type": "text", "section": "Page 32"}
{"text": "WEAK COUPLING\nChanges in modules should not \nimpact other modules\nAchieved via\n1. Information hiding\n2. Depending on as few modules \nas possible\n", "page": 33, "type": "text", "section": "Page 33"}
{"text": "LAW OF DEMETER\n(OR: PRINCIPLE OF LEAST KNOWLEDGE)\nBasic idea: Assume as little as possible \nabout other modules\nApproach: Restrict method calls to \nfriends\nProposed by Holland, Lieberherr, and Riel at Northeastern University in 1988\nDemeter (aka Ceres) is the Greek mythical goddess of the harvest, and she presided also over the sacred\nlaw and the cycle of life and death.\n", "page": 34, "type": "text", "section": "Page 34"}
{"text": "LoD: CALL YOUR FRIENDS\nA method M of an object O should only call methods of\n1.O itself\n2.M\u2019s parameters\n3.any objects created in M\n4.O\u2019s direct component objects\n\u201csingle dot rule\u201d\n", "page": 35, "type": "text", "section": "Page 35"}
{"text": "DEMETER: EXAMPLE\nclass Uni {\nProf boring = new Prof();\npublic Prof getProf() { return boring; }\npublic Prof getNewProf() { return new Prof(); }\n}\nclass Test {\nUni uds = new Uni();\npublic void one() { uds.getProf().fired(); }\npublic void two() { uds.getNewProf().hired(); }\n}\n", "page": 36, "type": "text", "section": "Page 36"}
{"text": "DEMETER: EXAMPLE\nclass Uni {\nProf boring = new Prof();\npublic Prof getProf() { return boring; }\npublic Prof getNewProf() { return new Prof(); }\npublic void fireProf(...) { ... }\n}\nclass BetterTest {\nUni uds = new Uni();\npublic void betterOne() { uds.fireProf(...); }\n}\n", "page": 37, "type": "text", "section": "Page 37"}
{"text": "DEMETER EFFECTS\n1. Reduces coupling between modules\n2. Disallow direct access to parts\n3. Limit the number of accessible classes\n4. Reduce dependencies\n5. Results in several new wrapper methods \n\u25aa\u201cDemeter transmogrifiers\u201d\n", "page": 38, "type": "text", "section": "Page 38"}
{"text": "PRINCIPLES OF OBJECT-ORIENTED DESIGN\n1. Abstraction \u2013 Hide details\n2. Encapsulation \u2013 Keep changes local\n3. Modularity \u2013 Control information flow\n\u25aahigh cohesion \n\u25aaweak coupling \n\u25aatalk only to friends\n4. Hierarchy\n", "page": 39, "type": "text", "section": "Page 39"}
{"text": "PRINCIPLES OF OBJECT-ORIENTED DESIGN\n1. Abstraction \u2013 Hide details\n2. Encapsulation \u2013 Keep changes local\n3. Modularity \u2013 Control information flow\n\u25aaHigh cohesion\n\u25aaweak coupling\n\u25aatalk only to friends\n4. Hierarchy\n", "page": 40, "type": "text", "section": "Page 40"}
{"text": "HIERARCHY\n\u201cHierarchy is a \nranking or ordering of \nabstractions.\u201d\n", "page": 41, "type": "text", "section": "Page 41"}
{"text": "CENTRAL HIERARCHIES\n1. \u201chas-a\u201d hierarchy \u2013 Aggregation of abstractions\n\u25aaA car has three to four wheels\n1. \u201cis-a\u201d hierarchy \u2013 Generalization across abstractions\n\u25aaAn ActiveSensor is a TemperatureSensor\n", "page": 42, "type": "text", "section": "Page 42"}
{"text": "HIERARCHY PRINCIPLES\nOpen/Close Principle \nClasses should be open for extensions\nLiskov Substitution Principle \nSubclasses should not require more, and not deliver less\nDependency Principle \nClasses should only depend on abstractions\n", "page": 43, "type": "text", "section": "Page 43"}
{"text": "OPEN/CLOSE PRINCIPLE\n\u25aaA class should be open for extension, but closed for changes\n\u25aaAchieved via inheritance and dynamic binding\n", "page": 44, "type": "text", "section": "Page 44"}
{"text": "AN INTERNET CONNECTION\nvoid connect() {\nif (connection_type == MODEM_56K)\n{\nModem modem = new Modem();\nmodem.connect();\n}\nelse if (connection_type == ETHERNET) \u2026\nelse if (connection_type == WLAN) \u2026\nelse if (connection_type == UMTS) \u2026\n}\n", "page": 45, "type": "text", "section": "Page 45"}
{"text": "SOLUTION WITH HIERARCHIES\n", "page": 46, "type": "text", "section": "Page 46"}
{"text": "AN INTERNET CONNECTION\nabstract class Connection {\nabstract int connect();\nabstract int hangup();\n}\nclass EthernetConnection extends Connection {\nint connect() {// does Ethernet connection; }\n}\nclass ModemConnection extends Connection {\nint connect() {// does dial-up connection; }\n}\n\u2026\n", "page": 47, "type": "text", "section": "Page 47"}
{"text": "CONSIDER BILLING PLANS\nenum { FUN50, FUN120, FUN240, ... } plan;\nenum { STUDENT, ADAC, ADAC_AND_STUDENT ... } special;\nenum { PRIVATE, BUSINESS, ... } customer_type;\nenum { T60_1, T60_60, T30_1, ... } billing_increment;\nint compute_bill(int seconds)\n{\nif (customer_type == BUSINESS)\nbilling_increment = T1_1;\nelse if (plan == FUN50 || plan == FUN120)\nbilling_increment = T60_1;\nelse if (plan == FUN240 && contract_year < 2011)\nbilling_increment = T30_1;\nelse\nbilling_increment = T60_60;\nif (contract_year >= 2011 && special != ADAC)\nbilling_increment = T60_60;\n// etc.etc. \n", "page": 48, "type": "text", "section": "Page 48"}
{"text": "HIERARCHY SOLUTION\nYou can add a new plan at any time!\n", "page": 49, "type": "text", "section": "Page 49"}
{"text": "HIERARCHY PRINCIPLES\n\u25aaOpen/Close principle \u2013 Classes should be open for extensions\n\u25aaLiskov substitution principle \u2013 Subclasses should not require more, and \nnot deliver less\n\u25aaDependency principle \u2013 Classes should only depend on abstractions\n", "page": 50, "type": "text", "section": "Page 50"}
{"text": "LISKOV SUBSTITUTION PRINCIPLE\nAn object of a superclass should always be substitutable by an \nobject of a subclass:\n\u25aaSame or weaker preconditions\n\u25aaSame or stronger postconditions\nDerived methods should not assume more or deliver less\n", "page": 51, "type": "text", "section": "Page 51"}
{"text": "CIRCLE VS ELLIPSE\n\u25aaEvery circle is an ellipse\n\u25aaDoes this hierarchy make sense?\nNo, as a circle requires more and \ndelivers less\ndraw()\nstretchX()\ndraw()\nEllipse\nCircle\n", "page": 52, "type": "text", "section": "Page 52"}
{"text": "HIERARCHY PRINCIPLES\n\u25aaOpen/Close principle \u2013 Classes should be open for extensions\n\u25aaLiskov substitution principle \u2013 Subclasses should not require more, and \nnot deliver less\n\u25aaDependency principle \u2013 Classes should only depend on abstractions\n", "page": 53, "type": "text", "section": "Page 53"}
{"text": "DEPENDENCY PRINCIPLE\nA class should only depend on abstractions \u2013 never on concrete \nsubclasses (dependency inversion principle)\nThis principle can be used to break dependencies\n", "page": 54, "type": "text", "section": "Page 54"}
{"text": "// Print current Web page to FILENAME after user clicks \u201cprint.\"\nvoid print_to_file(string filename)\n{\nif (path_exists(filename))\n{\n// FILENAME exists;\n// ask user to confirm overwrite in UserPresentation\nbool confirmed = confirm_loss(filename);\nif (!confirmed)\nreturn;\n}\n// Proceed printing to FILENAME\n...\n}\nDEPENDENCY\n", "page": 55, "type": "text", "section": "Page 55"}
{"text": "CYCLIC DEPENDENCY\nconstructing, testing, reusing individual \nmodules becomes impossible!\n", "page": 56, "type": "text", "section": "Page 56"}
{"text": "// Print current Web page to FILENAME after user clicks \u201cprint.\"\nvoid print_to_file(string filename, Presentation p)\n{\nif (path_exists(filename))\n{\n// FILENAME exists;\n// ask user to confirm overwrite\nbool confirmed = p.confirm_loss(filename);\nif (!confirmed)\nreturn;\n}\n// Proceed printing to FILENAME\n...\n}\nDEPENDENCY\n", "page": 57, "type": "text", "section": "Page 57"}
{"text": "DEPENDING ON ABSTRACTION\n", "page": 58, "type": "text", "section": "Page 58"}
{"text": "1. Which is the \u201cdominant\u201d \nabstraction?\n2. How does this choice impact \nthe remaining system?\nCHOOSING ABSTRACTION\n", "page": 59, "type": "text", "section": "Page 59"}
{"text": "PRINCIPLES OF OBJECT-ORIENTED DESIGN\n\u25aaAbstraction \u2013 Hide details\n\u25aaEncapsulation \u2013 Keep changes local\n\u25aaModularity \u2013 Control information flow\n\u25aahigh cohesion\n\u25aaweak coupling\n\u25aatalk only to friends\n\u25aaHierarchy \u2013 Order abstractions \n\u25aaclasses open for extensions, closed for changes\n\u25aasubclasses that do not require more or deliver less\n\u25aadepend only on abstractions\n", "page": 60, "type": "text", "section": "Page 60"}
{"text": "PRINCIPLES OF OBJECT-ORIENTED DESIGN\n\u25aaAbstraction \u2013 Hide details\n\u25aaEncapsulation \u2013 Keep changes local\n\u25aaModularity \u2013 Control information flow\n\u25aahigh cohesion\n\u25aaweak coupling\n\u25aatalk only to friends\n\u25aaHierarchy \u2013 Order abstractions\n\u25aaclasses open for extensions, closed for changes\n\u25aasubclasses that do not require more or deliver less\n\u25aadepend only on abstractions\nGoal: Maintainability and Reusability\n", "page": 61, "type": "text", "section": "Page 61"}
