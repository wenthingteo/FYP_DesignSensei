{
  "12-design-principles.pdf": [
    {
      "entities": [
        {
          "name": "Design Principles\"",
          "type": "Concept\"",
          "description": "Guidelines for writing maintainable, scalable, and consistent code"
        },
        {
          "name": "Previous Code Convention Discussions\"",
          "type": "Practice\"",
          "description": "Discussions about code style, formatting, and readability"
        },
        {
          "name": "Naming\"",
          "type": "Practice\"",
          "description": "Describing identifiers in code to be understandable and reflective of purpose"
        },
        {
          "name": "Program comprehension\"",
          "type": "Concept\"",
          "description": "Understanding code through naming and structure"
        },
        {
          "name": "SOLID Principles\"",
          "type": "Principle\"",
          "description": "Five basic object-oriented design principles"
        },
        {
          "name": "Single Responsibility Principle\"",
          "type": "Principle\"",
          "description": "A class should have only one reason to change"
        },
        {
          "name": "Open-Closed Principle\"",
          "type": "Principle\"",
          "description": "Software entities should be open for extension but closed for modification"
        },
        {
          "name": "Liskov Substitution Principle\"",
          "type": "Principle\"",
          "description": "Objects of a superclass should be replaceable with objects of subclasses without affecting correctness"
        },
        {
          "name": "Interface Segregation Principle\"",
          "type": "Principle\"",
          "description": "Clients should not be forced to depend on interfaces they do not use"
        },
        {
          "name": "Dependency Inversion Principle\"",
          "type": "Principle\"",
          "description": "Depend on abstractions, not on concrete implementations"
        },
        {
          "name": "Cohesion\"",
          "type": "Concept\"",
          "description": "Degree to which elements of a module belong together"
        },
        {
          "name": "Maintainability\"",
          "type": "Concept\"",
          "description": "Ease of modifying and extending software"
        },
        {
          "name": "Extensibility\"",
          "type": "Concept\"",
          "description": "Ability to extend software functionalities"
        },
        {
          "name": "Class\"",
          "type": "Component\"",
          "description": "Blueprint for creating objects in object-oriented programming"
        },
        {
          "name": "Method\"",
          "type": "Component\"",
          "description": "Function defined within a class"
        },
        {
          "name": "Code Style\"",
          "type": "Practice\"",
          "description": "Standards for formatting and organizing code"
        }
      ],
      "relationships": [
        {
          "source": "SOLID Principles\"",
          "target": "Single Responsibility Principle\"",
          "relationship": "CONTAINS\"",
          "description": "SRP is part of SOLID"
        },
        {
          "source": "SOLID Principles\"",
          "target": "Open-Closed Principle\"",
          "relationship": "CONTAINS\"",
          "description": "OCP is part of SOLID"
        },
        {
          "source": "SOLID Principles\"",
          "target": "Liskov Substitution Principle\"",
          "relationship": "CONTAINS\"",
          "description": "LSP is part of SOLID"
        },
        {
          "source": "SOLID Principles\"",
          "target": "Interface Segregation Principle\"",
          "relationship": "CONTAINS\"",
          "description": "ISP is part of SOLID"
        },
        {
          "source": "SOLID Principles\"",
          "target": "Dependency Inversion Principle\"",
          "relationship": "CONTAINS\"",
          "description": "DIP is part of SOLID"
        },
        {
          "source": "Class\"",
          "target": "Method\"",
          "relationship": "IS_PART_OF\"",
          "description": "Methods are part of classes"
        },
        {
          "source": "Code Style\"",
          "target": "Naming\"",
          "relationship": "SUPPORTS\"",
          "description": "Naming conventions support code readability"
        },
        {
          "source": "Program comprehension\"",
          "target": "Naming\"",
          "relationship": "DEPENDS_ON\"",
          "description": "Understanding code depends on meaningful naming"
        },
        {
          "source": "Design Principles\"",
          "target": "Cohesion\"",
          "relationship": "SUPPORTS\"",
          "description": "Good design principles support high cohesion"
        },
        {
          "source": "Design Principles\"",
          "target": "Maintainability\"",
          "relationship": "SUPPORTS\"",
          "description": "Design principles support maintainable code"
        }
      ],
      "cypher_queries": [
        "CREATE (:Principle {name: \"SOLID Principles\", description: \"Five basic object-oriented design principles\"})\",\n    \"CREATE (:Principle {name: \"Single Responsibility Principle\", description: \"A class should have only one reason to change\"})\",\n    \"CREATE (:Principle {name: \"Open-Closed Principle\", description: \"Software entities should be open for extension but closed for modification\"})\",\n    \"CREATE (:Principle {name: \"Liskov Substitution Principle\", description: \"Objects of a superclass should be replaceable with objects of subclasses\"})\",\n    \"CREATE (:Principle {name: \"Interface Segregation Principle\", description: \"Clients should not be forced to depend on interfaces they do not use\"})\",\n    \"CREATE (:Principle {name: \"Dependency Inversion Principle\", description: \"Depend on abstractions, not on concrete implementations\"})\",\n    \"CREATE (:Component {name: \"Class\", description: \"Blueprint for creating objects\"})\",\n    \"CREATE (:Component {name: \"Method\", description: \"Function within a class\"})\",\n    \"CREATE (:Practice {name: \"Code Style\", description: \"Standards for formatting and organizing code\"})\",\n    \"CREATE (s:Principle {name: \"SOLID Principles\"})-[:CONTAINS]->(sr:Principle {name: \"Single Responsibility Principle\"})\",\n    \"CREATE (s)-[:CONTAINS]->(ocp:Principle {name: \"Open-Closed Principle\"})\",\n    \"CREATE (s)-[:CONTAINS]->(lsp:Principle {name: \"Liskov Substitution Principle\"})\",\n    \"CREATE (s)-[:CONTAINS]->(isp:Principle {name: \"Interface Segregation Principle\"})\",\n    \"CREATE (s)-[:CONTAINS]->(dip:Principle {name: \"Dependency Inversion Principle\"})\",\n    \"CREATE (c:Component {name: \"Class\"})-[:IS_PART_OF]->(m:Component {name: \"Method\"})"
      ],
      "chunk_metadata": {
        "chunk_id": 0,
        "tokens": 367,
        "type": "sentence-based",
        "text": "Design Principles 1 Previous Code Convention Discussions Style What does the code look like? Is it consistent, scalable, and maintainable? Appearance, format, readability Naming How are we describing the identifiers in our code? Are they understandable? Do the names reflect purposeresponsibility? Program comprehension 2 SOLID Principles for Object-Oriented Design Five basic principles (guidelines) for Object-Oriented Design (OOD) Results in systems that are: Easy to maintain Easy to extend SOLID is a guide for: Creating designs from scratch Improving existing designs 3 SOILD Principles Single Responsibility Principle (SRP) Openclosed Principle (OCP) Liskov Substitution Principle (LSP) Interface Segregation Principle (ISP) Dependency Inversion Principle (DIP) 4 Single Responsibility Principle Every class should have A SINGLE RESPONSIBILITY The responsibility of a class drives its need to change Responsibility should be entirely encapsulated by the class All functionality of the class should focus on that single responsibility Why? More cohesive Easier to understand Easier to maintain 5 SRP Analysis A basic method for determining if a method belongs with a given class. A rough approximation Need to apply context about the domain and the abstraction The _class name _method name_ itself. 6 7 8 9 SRP Example 10 SRP Example - Violation 11 SRP Example - Compliant 12 OpenClosed Principle Software entities (classes, function, etc.)",
        "source": "12-design-principles.pdf"
      },
      "extraction_success": true
    },
    {
      "entities": [
        {
          "name": "Single Responsibility Principle\"",
          "type": "Principle\"",
          "description": "A class should have only one reason to change, focusing on a single responsibility"
        },
        {
          "name": "Open-Closed Principle\"",
          "type": "Principle\"",
          "description": "Software entities should be open for extension but closed for modification"
        },
        {
          "name": "Liskov Substitution Principle\"",
          "type": "Principle\"",
          "description": "Objects of a superclass should be replaceable with objects of subclasses without affecting correctness"
        },
        {
          "name": "Inheritance\"",
          "type": "Concept\"",
          "description": "A mechanism where a new class derives from an existing class to reuse code and extend functionality"
        },
        {
          "name": "Polymorphism\"",
          "type": "Concept\"",
          "description": "The ability of different classes to be treated as instances of a common superclass, typically via method overriding"
        },
        {
          "name": "Abstract Base Class\"",
          "type": "Concept\"",
          "description": "A class that defines an interface for subclasses to implement"
        },
        {
          "name": "Design Pattern\"",
          "type": "Pattern\"",
          "description": "Reusable solutions to common software design problems"
        },
        {
          "name": "Inheritance\"",
          "type": "Pattern\"",
          "description": "A pattern enabling new classes to derive from existing classes"
        },
        {
          "name": "Delegation\"",
          "type": "Pattern\"",
          "description": "A pattern where an object handles a request by passing it to a second object"
        },
        {
          "name": "Component\"",
          "type": "Concept\"",
          "description": "Architectural elements such as classes, modules, or layers"
        },
        {
          "name": "Layer\"",
          "type": "Component\"",
          "description": "An architectural level in software design that separates concerns"
        }
      ],
      "relationships": [
        {
          "source": "Single Responsibility Principle\"",
          "target": "Principle\"",
          "relationship": "IS_A\"",
          "description": "SRP is a type of design principle"
        },
        {
          "source": "Open-Closed Principle\"",
          "target": "Principle\"",
          "relationship": "IS_A\"",
          "description": "OCP is a type of design principle"
        },
        {
          "source": "Liskov Substitution Principle\"",
          "target": "Principle\"",
          "relationship": "IS_A\"",
          "description": "LSP is a type of design principle"
        },
        {
          "source": "Inheritance\"",
          "target": "Pattern\"",
          "relationship": "REALIZED_BY\"",
          "description": "Inheritance pattern implements the concept of class derivation"
        },
        {
          "source": "Delegation\"",
          "target": "Pattern\"",
          "relationship": "REALIZED_BY\"",
          "description": "Delegation pattern implements passing requests to other objects"
        },
        {
          "source": "Abstract Base Class\"",
          "target": "Concept\"",
          "relationship": "IS_A\"",
          "description": "Abstract base class is a type of software concept for defining interfaces"
        },
        {
          "source": "Polymorphism\"",
          "target": "Concept\"",
          "relationship": "IS_A\"",
          "description": "Polymorphism is a core object-oriented concept"
        },
        {
          "source": "Layer\"",
          "target": "Component\"",
          "relationship": "IS_PART_OF\"",
          "description": "Layer is a type of architectural component"
        }
      ],
      "cypher_queries": [
        "CREATE (:Principle {name: \"Single Responsibility Principle\", description: \"A class should have only one reason to change\"})\",\n    \"CREATE (:Principle {name: \"Open-Closed Principle\", description: \"Software entities should be open for extension but closed for modification\"})\",\n    \"CREATE (:Principle {name: \"Liskov Substitution Principle\", description: \"Objects of a superclass should be replaceable with objects of subclasses\"})\",\n    \"CREATE (:Concept {name: \"Inheritance\", description: \"A mechanism where a new class derives from an existing class\"})\",\n    \"CREATE (:Concept {name: \"Polymorphism\", description: \"The ability of different classes to be treated as instances of a common superclass\"})\",\n    \"CREATE (:Concept {name: \"Abstract Base Class\", description: \"A class that defines an interface for subclasses\"})\",\n    \"CREATE (:Pattern {name: \"Inheritance\", description: \"A pattern enabling new classes to derive from existing classes\"})\",\n    \"CREATE (:Pattern {name: \"Delegation\", description: \"A pattern where an object handles a request by passing it to a second object\"})\",\n    \"CREATE (:Component {name: \"Layer\", description: \"An architectural level in software design that separates concerns\"})"
      ],
      "chunk_metadata": {
        "chunk_id": 1,
        "tokens": 343,
        "type": "sentence-based",
        "text": "6 7 8 9 SRP Example 10 SRP Example - Violation 11 SRP Example - Compliant 12 OpenClosed Principle Software entities (classes, function, etc.) should be open for extension but closed for modification Closed - as can be compiled, stored in a library, and used by client classes Open - as any new class can inherit and add new features Why? Client code dependent on base (closed) class unaffected Less testing Less code to review 13 Meyers OpenClosed Principle Implementation is extended through inheritance Open means available for extension (generalizationinheritance) Closed to avoid changes to the original class New functionality by adding a new class, not changing current ones Results in tight coupling between base and derived classes 14 Polymorphic OpenClosed Principle Abstract base class and multiple implementations that we can substitute for each other Base design on abstract base classes Focus on sharing the interface, not the implementation Code to an interface, not an implementation Reuse implementation via delegation abstract Parser parse() ParserImplementation parse() ParserRubyImplementation parse() 15 Liskov Substitution Principle An Object in a program should be replaceable with an instance of subtypes without affecting program correctness Objects of subtypes should behave like those of supertypes if used via supertype methods.",
        "source": "12-design-principles.pdf"
      },
      "extraction_success": true
    },
    {
      "entities": [
        {
          "name": "OpenClosed Principle\"",
          "type": "Principle\"",
          "description": "Design principle that promotes software entities being open for extension but closed for modification"
        },
        {
          "name": "Liskov Substitution Principle\"",
          "type": "Principle\"",
          "description": "Design principle that states objects of subtypes should be replaceable with objects of supertypes without affecting correctness"
        },
        {
          "name": "Inheritance\"",
          "type": "Concept\"",
          "description": "Object-oriented concept allowing new classes to extend existing classes"
        },
        {
          "name": "Polymorphism\"",
          "type": "Concept\"",
          "description": "Ability of different classes to be treated as instances of a common superclass, typically via interfaces"
        },
        {
          "name": "Abstract Base Class\"",
          "type": "Component\"",
          "description": "A class that defines a common interface for its subclasses"
        },
        {
          "name": "Interface\"",
          "type": "Concept\"",
          "description": "A shared boundary across which two separate components exchange information"
        },
        {
          "name": "Delegation\"",
          "type": "Practice\"",
          "description": "Design pattern where an object handles a request by passing it to a second object"
        },
        {
          "name": "Parser\"",
          "type": "Component\"",
          "description": "A class responsible for parsing input data"
        },
        {
          "name": "ParserImplementation\"",
          "type": "Component\"",
          "description": "Concrete implementation of the Parser interface"
        },
        {
          "name": "ParserRubyImplementation\"",
          "type": "Component\"",
          "description": "A specific parser implementation for Ruby language"
        }
      ],
      "relationships": [
        {
          "source": "OpenClosed Principle\"",
          "target": "Inheritance\"",
          "relationship": "SUPPORTS\"",
          "description": "Open for extension through inheritance"
        },
        {
          "source": "OpenClosed Principle\"",
          "target": "Principle\"",
          "relationship": "IS_PART_OF\"",
          "description": "OpenClosed Principle is a type of design principle"
        },
        {
          "source": "Liskov Substitution Principle\"",
          "target": "Inheritance\"",
          "relationship": "DEPENDS_ON\"",
          "description": "Relies on inheritance to ensure substitutability"
        },
        {
          "source": "Liskov Substitution Principle\"",
          "target": "Principle\"",
          "relationship": "IS_PART_OF\"",
          "description": "Liskov Substitution Principle is a type of design principle"
        },
        {
          "source": "Abstract Base Class\"",
          "target": "Interface\"",
          "relationship": "IS_PART_OF\"",
          "description": "Abstract base classes often define interfaces"
        },
        {
          "source": "Parser\"",
          "target": "ParserImplementation\"",
          "relationship": "IS_A\"",
          "description": "ParserImplementation is a concrete implementation of Parser"
        },
        {
          "source": "ParserImplementation\"",
          "target": "ParserRubyImplementation\"",
          "relationship": "IS_A\"",
          "description": "ParserRubyImplementation is a specific implementation of ParserImplementation"
        },
        {
          "source": "Parser\"",
          "target": "Delegation\"",
          "relationship": "ENABLES\"",
          "description": "Parser uses delegation to handle parsing via different implementations"
        }
      ],
      "cypher_queries": [
        "CREATE (:Principle {name: \"OpenClosed Principle\", description: \"Design principle that promotes software entities being open for extension but closed for modification\"})\",\n    \"CREATE (:Principle {name: \"Liskov Substitution Principle\", description: \"Design principle that states objects of subtypes should be replaceable with objects of supertypes without affecting correctness\"})\",\n    \"CREATE (:Concept {name: \"Inheritance\", description: \"Object-oriented concept allowing new classes to extend existing classes\"})\",\n    \"CREATE (:Concept {name: \"Polymorphism\", description: \"Ability of different classes to be treated as instances of a common superclass, typically via interfaces\"})\",\n    \"CREATE (:Component {name: \"Abstract Base Class\", description: \"A class that defines a common interface for its subclasses\"})\",\n    \"CREATE (:Component {name: \"Parser\", description: \"A class responsible for parsing input data\"})\",\n    \"CREATE (:Component {name: \"ParserImplementation\", description: \"Concrete implementation of the Parser interface\"})\",\n    \"CREATE (:Component {name: \"ParserRubyImplementation\", description: \"A specific parser implementation for Ruby language\"})\",\n    \"MATCH (p:Principle {name: \"OpenClosed Principle\"}), (i:Concept {name: \"Inheritance\"}) CREATE (p)-[:SUPPORTS]->(i)\",\n    \"MATCH (p:Principle {name: \"Liskov Substitution Principle\"}), (i:Concept {name: \"Inheritance\"}) CREATE (p)-[:DEPENDS_ON]->(i)\",\n    \"MATCH (abc:Component {name: \"Abstract Base Class\"}), (iface:Concept {name: \"Interface\"}) CREATE (abc)-[:IS_PART_OF]->(iface)\",\n    \"MATCH (p:Parser), (pi:Component {name: \"ParserImplementation\"}) CREATE (p)-[:IS_A]->(pi)\",\n    \"MATCH (pi:Component {name: \"ParserImplementation\"}), (pr:Component {name: \"ParserRubyImplementation\"}) CREATE (pi)-[:IS_A]->(pr)"
      ],
      "chunk_metadata": {
        "chunk_id": 2,
        "tokens": 354,
        "type": "sentence-based",
        "text": "Client code dependent on base (closed) class unaffected Less testing Less code to review 13 Meyers OpenClosed Principle Implementation is extended through inheritance Open means available for extension (generalizationinheritance) Closed to avoid changes to the original class New functionality by adding a new class, not changing current ones Results in tight coupling between base and derived classes 14 Polymorphic OpenClosed Principle Abstract base class and multiple implementations that we can substitute for each other Base design on abstract base classes Focus on sharing the interface, not the implementation Code to an interface, not an implementation Reuse implementation via delegation abstract Parser parse() ParserImplementation parse() ParserRubyImplementation parse() 15 Liskov Substitution Principle An Object in a program should be replaceable with an instance of subtypes without affecting program correctness Objects of subtypes should behave like those of supertypes if used via supertype methods. Preconditions cannot be strengthened in a subtype Postconditions cannot be weakened in a subtype Invariants of supertype must be preserved in subtype History constraint - new methods in subtype cannot introduce state changes in a way that is not permissible in the supertype Why? Knowledgeassumptions about base class apply to the subclass Easier to understand Easier to maintain.",
        "source": "12-design-principles.pdf"
      },
      "extraction_success": true
    },
    {
      "entities": [
        {
          "name": "Liskov Substitution Principle\"",
          "type": "Principle\"",
          "description": "A principle stating that objects of a superclass should be replaceable with objects of subclasses without affecting correctness"
        },
        {
          "name": "Interface Segregation Principle\"",
          "type": "Principle\"",
          "description": "A principle stating that clients should not be forced to depend on interfaces they do not use"
        },
        {
          "name": "Dependency Inversion Principle\"",
          "type": "Principle\"",
          "description": "A principle stating that high-level modules should not depend on low-level modules, but both should depend on abstractions"
        },
        {
          "name": "Interface Segregation\"",
          "type": "Concept\"",
          "description": "Design approach favoring multiple specific interfaces over a single general-purpose interface"
        },
        {
          "name": "Abstraction\"",
          "type": "Concept\"",
          "description": "A fundamental concept where details are hidden behind simplified interfaces"
        },
        {
          "name": "Cohesion\"",
          "type": "Concept\"",
          "description": "Degree to which elements of a module belong together"
        },
        {
          "name": "Coupling\"",
          "type": "Concept\"",
          "description": "Degree of interdependence between software modules"
        },
        {
          "name": "High-level modules\"",
          "type": "Component\"",
          "description": "Modules that contain the core logic and depend on abstractions"
        },
        {
          "name": "Low-level modules\"",
          "type": "Component\"",
          "description": "Modules that implement details and depend on abstractions"
        }
      ],
      "relationships": [
        {
          "source": "Liskov Substitution Principle\"",
          "target": "Principle\"",
          "relationship": "IS_A\"",
          "description": "LSP is a type of SOLID principle"
        },
        {
          "source": "Interface Segregation Principle\"",
          "target": "Principle\"",
          "relationship": "IS_A\"",
          "description": "ISP is a type of SOLID principle"
        },
        {
          "source": "Dependency Inversion Principle\"",
          "target": "Principle\"",
          "relationship": "IS_A\"",
          "description": "DIP is a type of SOLID principle"
        },
        {
          "source": "Interface Segregation\"",
          "target": "Concept\"",
          "relationship": "SUPPORTS\"",
          "description": "Supports ISP by promoting multiple specific interfaces"
        },
        {
          "source": "Abstraction\"",
          "target": "Concept\"",
          "relationship": "IS_A\"",
          "description": "Abstraction is a fundamental software concept"
        },
        {
          "source": "High-level modules\"",
          "target": "Component\"",
          "relationship": "IS_PART_OF\"",
          "description": "High-level modules are architectural components"
        },
        {
          "source": "Low-level modules\"",
          "target": "Component\"",
          "relationship": "IS_PART_OF\"",
          "description": "Low-level modules are architectural components"
        },
        {
          "source": "High-level modules\"",
          "target": "Abstraction\"",
          "relationship": "DEPENDS_ON\"",
          "description": "High-level modules depend on abstractions"
        },
        {
          "source": "Low-level modules\"",
          "target": "Abstraction\"",
          "relationship": "DEPENDS_ON\"",
          "description": "Low-level modules depend on abstractions"
        },
        {
          "source": "Cohesion\"",
          "target": "Concept\"",
          "relationship": "IS_A\"",
          "description": "Cohesion is a software design concept"
        },
        {
          "source": "Coupling\"",
          "target": "Concept\"",
          "relationship": "IS_A\"",
          "description": "Coupling is a software design concept"
        }
      ],
      "cypher_queries": [
        "CREATE (:Principle {name: \"Liskov Substitution Principle\", description: \"A principle stating that objects of a superclass should be replaceable with objects of subclasses without affecting correctness\"})\",\n    \"CREATE (:Principle {name: \"Interface Segregation Principle\", description: \"A principle stating that clients should not be forced to depend on interfaces they do not use\"})\",\n    \"CREATE (:Principle {name: \"Dependency Inversion Principle\", description: \"A principle stating that high-level modules should not depend on low-level modules, but both should depend on abstractions\"})\",\n    \"CREATE (:Concept {name: \"Interface Segregation\", description: \"Design approach favoring multiple specific interfaces over a single general-purpose interface\"})\",\n    \"CREATE (:Concept {name: \"Abstraction\", description: \"A fundamental concept where details are hidden behind simplified interfaces\"})\",\n    \"CREATE (:Concept {name: \"Cohesion\", description: \"Degree to which elements of a module belong together\"})\",\n    \"CREATE (:Concept {name: \"Coupling\", description: \"Degree of interdependence between software modules\"})\",\n    \"CREATE (:Component {name: \"High-level modules\", description: \"Modules that contain the core logic and depend on abstractions\"})\",\n    \"CREATE (:Component {name: \"Low-level modules\", description: \"Modules that implement details and depend on abstractions\"})"
      ],
      "chunk_metadata": {
        "chunk_id": 3,
        "tokens": 260,
        "type": "sentence-based",
        "text": "Knowledgeassumptions about base class apply to the subclass Easier to understand Easier to maintain. 16 LSP Example 17 LSP Example - Violation 18 LSP Example 19 LSP Example 20 21 Interface Segregation Principle A client should NOT be forced to depend on methods it does not use Having many client-specific interfaces is better than one general- purpose interface Why? More cohesive Lower coupling Easier to understand Easier to maintain 22 ISP Example How can we make this better? 23 ISP Example How can we make this better? Bird name: string FlyingBird fly() Ostrich Duck CREATED WITH YUML 24 Dependency Inversion Principle Depend upon abstractions, not concretions (specific implementations of an abstraction) Abstractions should not depend on details, but details on abstractions High-level modules are independent and should not depend on low- level modules Why? Lower coupling Reuse Easier to test Easer to understand Easier to maintain 25 DIP Example 26 DIP Example Can We Do Better? 27 DIP Example Can We Do Better?",
        "source": "12-design-principles.pdf"
      },
      "extraction_success": true
    },
    {
      "entities": [
        {
          "name": "Dependency Inversion Principle\"",
          "type": "Principle\"",
          "description": "A design principle that emphasizes decoupling high-level modules from low-level modules through abstractions"
        },
        {
          "name": "OutletInterface\"",
          "type": "Component\"",
          "description": "An abstraction representing different power outlets"
        },
        {
          "name": "Lamp\"",
          "type": "Component\"",
          "description": "A device that can be turned on or off, depends on OutletInterface"
        },
        {
          "name": "DRY\"",
          "type": "Principle\"",
          "description": "Dont Repeat Yourself, a principle to reduce redundancy through abstractions or functional decomposition"
        },
        {
          "name": "YAGNI\"",
          "type": "Principle\"",
          "description": "You Arent Gonna Need It, a principle to avoid building unnecessary features"
        },
        {
          "name": "KISS\"",
          "type": "Principle\"",
          "description": "Keep It Simple, a principle to avoid unnecessary complexity"
        },
        {
          "name": "Occam's Razor\"",
          "type": "Principle\"",
          "description": "A principle favoring simplicity in design"
        },
        {
          "name": "GRASP\"",
          "type": "Principle\"",
          "description": "General Responsibility Assignment Software Patterns, guiding principles for assigning responsibilities"
        },
        {
          "name": "Design Patterns\"",
          "type": "Pattern\"",
          "description": "Reusable solutions to common software design problems"
        },
        {
          "name": "SOLID\"",
          "type": "Principle\"",
          "description": "A set of object-oriented design principles"
        }
      ],
      "relationships": [
        {
          "source": "Dependency Inversion Principle\"",
          "target": "OutletInterface\"",
          "relationship": "DEPENDS_ON\"",
          "description": "Lamp depends on OutletInterface for power control"
        },
        {
          "source": "Lamp\"",
          "target": "OutletInterface\"",
          "relationship": "USES\"",
          "description": "Lamp uses OutletInterface to turn on or off"
        },
        {
          "source": "DRY\"",
          "target": "Abstractions\"",
          "relationship": "SUPPORTS\"",
          "description": "DRY supports using abstractions to reduce redundancy"
        },
        {
          "source": "YAGNI\"",
          "target": "Features\"",
          "relationship": "CONFLICTS_WITH\"",
          "description": "YAGNI discourages building features that might not be needed"
        },
        {
          "source": "KISS\"",
          "target": "Design\"",
          "relationship": "SUPPORTS\"",
          "description": "KISS supports keeping design simple"
        },
        {
          "source": "Occam's Razor\"",
          "target": "Design\"",
          "relationship": "SUPPORTS\"",
          "description": "Occam's Razor supports simplicity in design"
        },
        {
          "source": "GRASP\"",
          "target": "Design Patterns\"",
          "relationship": "ENABLED\"",
          "description": "GRASP principles enable effective use of design patterns"
        },
        {
          "source": "SOLID\"",
          "target": "Design Principles\"",
          "relationship": "IS_PART_OF\"",
          "description": "SOLID is a set of design principles"
        }
      ],
      "cypher_queries": [
        "CREATE (:Principle {name: \"Dependency Inversion Principle\", description: \"A design principle that emphasizes decoupling high-level modules from low-level modules through abstractions\"})\",\n    \"CREATE (:Component {name: \"OutletInterface\", description: \"An abstraction representing different power outlets\"})\",\n    \"CREATE (:Component {name: \"Lamp\", description: \"A device that can be turned on or off, depends on OutletInterface\"})\",\n    \"CREATE (:Principle {name: \"DRY\", description: \"Dont Repeat Yourself, a principle to reduce redundancy through abstractions or functional decomposition\"})\",\n    \"CREATE (:Principle {name: \"YAGNI\", description: \"You Arent Gonna Need It, a principle to avoid building unnecessary features\"})\",\n    \"CREATE (:Principle {name: \"KISS\", description: \"Keep It Simple, a principle to avoid unnecessary complexity\"})\",\n    \"CREATE (:Principle {name: \"Occam's Razor\", description: \"A principle favoring simplicity in design\"})\",\n    \"CREATE (:Principle {name: \"GRASP\", description: \"General Responsibility Assignment Software Patterns, guiding principles for assigning responsibilities\"})\",\n    \"CREATE (:Pattern {name: \"Design Patterns\", description: \"Reusable solutions to common software design problems\"})\",\n    \"CREATE (:Principle {name: \"SOLID\", description: \"A set of object-oriented design principles\"})"
      ],
      "chunk_metadata": {
        "chunk_id": 4,
        "tokens": 310,
        "type": "sentence-based",
        "text": "27 DIP Example Can We Do Better? https:medium.comkedren.villenasimplifying-dependency-inversion-principle-dip-59228122649a Lamp isOn: boolean powerSource: OutletInterface turnOn() turnOff() changeOutlet(OutletInterface) OutletInterface DormOutlet GarageOutlet ClassroomOutlet CREATED WITH YUML 28 29 Other Helpful Principles DRY- Dont Repeat Yourself Use functional decomposition or abstractions to reduce redundancies YAGNI You Arent Gonna Need It Dont try to build out features now that you think your software MIGHT need later Software development is too volatile for that, focus on what is needed now and the maintainability of your design Occams RazorKISS Keep it simple Dont introduce unnecessary complexity or overblown designs GRASP General Responsibility Assignment Software Patterns Design patterns that can help with your software designimplementation More on design patterns later 30 Conclusion Meant to be applied together Make it more likely that the system is easy to maintain and extend over time SOLID principles are guidelines Do not guarantee success Can be misused Use in conjunction with other principles Dont chase perfection Design based on your needs Good enough design gets software delivered 31",
        "source": "12-design-principles.pdf"
      },
      "extraction_success": true
    }
  ]
}