{"text": "Titles in the: Auerbach Series on Applied Software Engineering\nPhillip A. Laplante, Pennsylvania State University, Series Editor\nSoftware Engineering Design: Theory and Practice\nCarlos E. Otero  \n978-1-4398-5168-5\nEthics in IT Outsourcing\nTandy Gold \n978-1-4398-5062-6\nThe ScrumMaster Study Guide \nJames Schiel\n978-1-4398-5991-9\nAntipatterns: Managing Software Organizations and People,  \nSecond Edition\nColin J. Neill, Philip A. Laplante, and Joanna F\n. DeFranco\n978-1-4398-6186-8\nEnterprise-Scale Agile Software Development\nJames Schiel\n978-1-4398-0321-9\nRequirements Engineering for Software and Systems\nPhillip A. Laplante\n978-1-4200-6467-4 \nBuilding Software: A Practioner\u2019s Guide\nNikhilesh Krishnamurthy and Amitabh Saran\n978-0-8493-7303-9\nGlobal Software Development Handbook\nRaghvinder Sangwan, Matthew Bass, Neel Mullick, Daniel J. Paulish, \nand Juergen Kazmeier\n978-0-8493-9384-6\nSoftware Engineering Quality Practices\nRonald Kirk Kandt\n978-0-8493-4633-0", "domains": ["Design Patterns"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 2", "position": 2, "chunk_type": "semantic", "token_estimate": 114}
{"text": "vii: Contents\nPreface .......................................................................................................................... xvii\nAcknowledgments .........................................................................................................xix\nAbout the Author \n...........................................................................................................xxi\nChapter 1\t Introduction to Software Engineering Design \n...........................................1\nChapter Objectives .................................................................................................. 1\nConceptual Overview ............................................................................................. 1\nEngineering Design \n................................................................................................. 2\nEngineering Problem Solving \n................................................................................ 3\nInitial State \n........................................................................................................... 4\nOperational State ................................................................................................ 4\nTinking about the Problem ........................................................................ 5\nProblem Solution............................................................................................ 6\nGoal State ............................................................................................................. 6\nSofware Engineering Design ................................................................................ 9\nWhy Study Sofware Engineering Design? ........................................................ 10\nReasons for Studying Sofware Design in Product Development ............. 10\nReasons for Studying Sofware Design in Project Management ............... 11\nSofware Design Challenges \n................................................................................. 11\nDesign Challenge 1: Requirements Volatility ............................................... 12\nDesign Challenge 2: Process ........................................................................... 12\nDesign Challenge 3: Technology .................................................................... 12\nDesign Challenge 4: Ethical and Professional Practices ............................. 13\nDesign Challenge 5: Managing Design Infuences ...................................... 13\nStakeholders \n.................................................................................................. 14\nDevelopment Organization\u2019s Structure .................................................... 14\nContext of Sofware Design ................................................................................. 15\nSofware Design Process \n....................................................................................... 17\nSofware Architecture ...................................................................................... 18\nDetailed Design \n................................................................................................. 19\nInterface Design ........................................................................................... 19\nComponent Design \n......................................................................................20\nConstruction Design ........................................................................................20\nHuman\u2013Computer Interface Design \n............................................................. 21\nSofware Design Documentation ................................................................... 21\nSofware Design Management ........................................................................ 21", "domains": ["Design Patterns", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 7", "position": 7, "chunk_type": "semantic", "token_estimate": 182}
{"text": "viii\u2002 \u2022\u2002 Contents: Roles of the Sofware Designer ............................................................................ 22\nSystems Engineer .............................................................................................. 23\nSofware Architect ............................................................................................ 23\nComponent Designer ....................................................................................... 23\nSofware Design Fundamentals \n........................................................................... 24\nGeneral Sofware Design Principles .............................................................. 24\nModularization ............................................................................................ 25\nAbstraction ................................................................................................... 25\nEncapsulation ............................................................................................... 26\nCoupling \n........................................................................................................ 27\nCohesion \n........................................................................................................ 28\nSeparation of Interface and Implementation ........................................... 29\nCompleteness and Sufciency \n.................................................................... 30\nPractical Sofware Design Considerations \n.................................................... 30\nDesign for Minimizing Complexity \n.......................................................... 31\nDesign for Change ....................................................................................... 31\nSofware Design Strategies .............................................................................. 31\nStructured Design \n........................................................................................ 31\nObject-Oriented Design .............................................................................. 32\nChapter Summary ................................................................................................. 32\nReview Questions .................................................................................................. 33\nReferences ...............................................................................................................34\nChapter 2\t Software Design with Unified\u00a0Modeling Language ................................35\nChapter Objectives ................................................................................................ 35\nConceptual Overview ........................................................................................... 35\nWhat Is UML? ........................................................................................................ 36\nWhy Study UML? .................................................................................................. 37\nTe UML\u2019s Fundamentals .................................................................................... 37\nStructural Modeling \n..............................................................................................40\nComponent Diagrams ..........................................................................................40\nLogical versus Physical Components \n.............................................................42\nClass Diagrams ...................................................................................................... 43\nClasses ................................................................................................................ 43\nName Compartment ...................................................................................44\nAttribute Compartment \n..............................................................................44\nOperation Compartment \n............................................................................ 45\nRelationships .....................................................................................................46\nDependency .................................................................................................. 47\nAssociation \n.................................................................................................... 47\nAggregation ..................................................................................................48\nComposition .................................................................................................48", "domains": ["Design Patterns", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 8", "position": 8, "chunk_type": "semantic", "token_estimate": 172}
{"text": "Contents\u2002 \u2022\u2002 ix: Generalization .............................................................................................. 49\nRealization .................................................................................................... 50\nDeployment Diagrams \n.......................................................................................... 53\nBehavioral Modeling \n............................................................................................. 55\nUse Case Diagrams ............................................................................................... 55\nInteraction Diagrams \n............................................................................................ 57\nCommunication Diagrams ............................................................................. 58\nSequence Diagrams .......................................................................................... 59\nConcurrency in Interaction Diagrams .......................................................... 59\nChapter Summary ................................................................................................. 63\nReview Questions .................................................................................................. 63\nChapter Exercises ..................................................................................................64\nReferences ............................................................................................................... 65\nChapter 3\t Principles of Software Architecture \n..........................................................67\nChapter Objectives ................................................................................................ 67\nConceptual Overview ........................................................................................... 67\nWhat Is Sofware Architecture? ..........................................................................68\nWhy Study Sofware Architecture?..................................................................... 70\nKey Tasks in Architectural Design ..................................................................... 70\nIdentifying Stakeholders\u2019 Concerns \n............................................................... 71\nIdentifying Appropriate Architectural Views .............................................. 71\nIdentifying Architectural Styles and Patterns .............................................. 71\nIdentifying System Interfaces ......................................................................... 72\nIdentifying Impact of Architectural Decisions in Organization ............... 72\nImpact on Customer Base \n........................................................................... 73\nImpact on Budget and Schedule ................................................................ 73\nImpact from Resource Availability ............................................................74\nIdentifying the System\u2019s Major Components and Interfaces.......................74\nEvaluating and Validating the Architecture \n..................................................74\nIntroducing Policies for Design Synchronicity ............................................ 75\nProblem Solving in Sofware Architecture ........................................................ 76\nInputs \n.................................................................................................................. 77\nConstraints ........................................................................................................ 77\nOutputs............................................................................................................... 77\nSofware Architecture Process............................................................................. 78\nUnderstand and Evaluate Requirements \n............................................................ 79\nElicitation \n........................................................................................................... 79\nRequirement Sources \n................................................................................... 79\nElicitation Techniques ................................................................................. 81\nAnalysis .............................................................................................................. 82", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 9", "position": 9, "chunk_type": "semantic", "token_estimate": 195}
{"text": "Contents\u2002 \u2022\u2002 xi: Hierarchical Systems \n........................................................................................... 131\nMain Program and Subroutine \n..................................................................... 131\nLayered Pattern ............................................................................................... 133\nChapter Summary ............................................................................................... 136\nReview Questions ................................................................................................ 136\nChapter Exercises ................................................................................................ 137\nReferences ............................................................................................................. 137\nChapter 5\t Principles of Detailed Design \n.................................................................. 139\nChapter Objectives .............................................................................................. 139\nConceptual Overview ......................................................................................... 139\nWhat Is Detailed Design? ................................................................................... 140\nKey Tasks in Detailed Design ............................................................................ 142\nDetailed Design Process ..................................................................................... 142\nUnderstanding the Architecture and Requirements \n...................................... 143\nCreating Detailed Designs ................................................................................. 144\nInterface Design .............................................................................................. 144\nExternal Interface Design ......................................................................... 144\nInternal Interface Design \n.......................................................................... 145\nGraphical User Interface Design ............................................................. 145\nDesigning Internal Structure of Components \n............................................ 145\nClasses ......................................................................................................... 146\nInterfaces, Types, Subtypes, Dynamic Binding, and Polymorphism ... 147\nObjects ......................................................................................................... 148\nDesign Principles for Internal Component Design ................................... 149\nOpen\u2013Closed Principle ............................................................................. 149\nLiskov Substitution Principle ................................................................... 156\nInterface Segregation Principle ................................................................ 157\nProgramming Styles in Detailed Design \n..................................................... 159\nFunction Names \n......................................................................................... 160\nVariable Names .......................................................................................... 162\nModeling Internal Behavior of Components \n.............................................. 164\nDesign Components Using Design Patterns .............................................. 166\nArchitectural versus Design Patterns ..................................................... 167\nClassifcation of Design Patterns ............................................................. 167\nDocumenting Design Patterns \n................................................................. 168\nDocument the Sofware Design ........................................................................ 169\nInterface Control Document \n......................................................................... 171\nSofware Version Document ......................................................................... 172\nMonitor and Control Implementation ............................................................. 173\nChapter Summary ............................................................................................... 173\nReview Questions .................................................................................................174", "domains": ["Architectural Patterns and Styles", "Design Principles", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 11", "position": 11, "chunk_type": "semantic", "token_estimate": 217}
{"text": "xii\u2002 \u2022\u2002 Contents: Chapter Exercises ................................................................................................ 175\nReferences ............................................................................................................. 175\nChapter 6\t Creational Design Patterns in Detailed Design ..................................... 177\nChapter Objectives .............................................................................................. 177\nConceptual Overview ......................................................................................... 177\nCreational Design Patterns ................................................................................ 178\nAbstract Factory .................................................................................................. 178\nProblem ............................................................................................................ 179\nStructure .......................................................................................................... 179\nImplementation \n................................................................................................181\nBenefts ............................................................................................................. 188\nFactory Method ................................................................................................... 188\nProblem ............................................................................................................ 189\nStructure .......................................................................................................... 189\nImplementation \n............................................................................................... 191\nBenefts ............................................................................................................. 192\nBuilder \n................................................................................................................... 193\nProblem ............................................................................................................ 195\nStructure .......................................................................................................... 195\nImplementation \n............................................................................................... 197\nBenefts ............................................................................................................. 197\nPrototype .............................................................................................................. 201\nProblem ............................................................................................................ 201\nStructure ..........................................................................................................204\nImplementation \n...............................................................................................205\nBenefts .............................................................................................................207\nSingleton ...............................................................................................................207\nProblem ............................................................................................................208\nStructure ..........................................................................................................208\nImplementation \n...............................................................................................209\nBenefts ..............................................................................................................211\nChapter Summary ................................................................................................211\nReview Questions .................................................................................................211\nChapter Exercises ................................................................................................ 212\nReference \n................................................................................................................214\nChapter 7\t Structural and Behavioral\u00a0Patterns in Detailed Design \n........................ 215\nChapter Objectives .............................................................................................. 215\nConceptual Overview ......................................................................................... 215\nStructural Design Patterns \n..................................................................................216", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 12", "position": 12, "chunk_type": "semantic", "token_estimate": 136}
{"text": "Contents\u2002 \u2022\u2002 xiii: Adapter...................................................................................................................216\nProblem ............................................................................................................ 217\nStructure .......................................................................................................... 219\nImplementation \n............................................................................................... 219\nBenefts ............................................................................................................. 221\nComposite \n.............................................................................................................223\nProblem ............................................................................................................224\nStructure ..........................................................................................................225\nImplementation \n...............................................................................................227\nBenefts ............................................................................................................. 231\nFacade \n.................................................................................................................... 232\nProblem ............................................................................................................234\nStructure .......................................................................................................... 235\nImplementation \n............................................................................................... 237\nBenefts .............................................................................................................238\nBehavioral Design Patterns \n................................................................................238\nIterator \n...................................................................................................................238\nProblem ............................................................................................................ 239\nStructure .......................................................................................................... 241\nImplementation \n...............................................................................................245\nBenefts ............................................................................................................. 251\nObserver \n................................................................................................................ 252\nProblem ............................................................................................................ 252\nStructure .......................................................................................................... 252\nImplementation \n...............................................................................................254\nBenefts .............................................................................................................254\nChapter Summary ...............................................................................................256\nReview Questions ................................................................................................256\nChapter Exercises ................................................................................................ 257\nReference \n...............................................................................................................258\nChapter 8\t Principles of Construction Design \n.......................................................... 259\nChapter Objectives .............................................................................................. 259\nConceptual Overview ......................................................................................... 259\nWhat Is Construction Design? .......................................................................... 259\nWhy Study Construction Design? ....................................................................260\nBehavioral Construction Design \n....................................................................... 261\nFlow-Based Designs \n........................................................................................ 261\nState-Based Designs \n........................................................................................262\nTable-Based Designs \n.......................................................................................264\nLimited-Entry Decision Table ..................................................................266\nExtended-Entry Decision Table ...............................................................268", "domains": ["Design Patterns"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 13", "position": 13, "chunk_type": "semantic", "token_estimate": 132}
{"text": "xiv\u2002 \u2022\u2002 Contents: Mixed-Entry Decision Table .................................................................... 270\nTable-Based Construction ........................................................................ 270\nProgramming Design Language .................................................................. 271\nSofware Construction Using Styles ................................................................. 274\nFormatting Conventions ............................................................................... 275\nIndentation ................................................................................................. 276\nBrace Placement ......................................................................................... 278\nNaming Conventions ..................................................................................... 279\nDocumentation Conventions \n........................................................................282\nDocumenting Files.....................................................................................282\nDocumenting Functions ...........................................................................282\nMinimizing Complexity in Construction Design ..........................................283\nQuality Evaluation of Construction Design \n....................................................284\nPeer Reviews ....................................................................................................285\nUnit Testing .....................................................................................................286\nCyclomatic Complexity .................................................................................286\nChapter Summary ...............................................................................................290\nReview Questions ................................................................................................290\nChapter Exercises ................................................................................................ 291\nReferences .............................................................................................................292\nChapter 9\t Human\u2013Computer Interface Design ...................................................... 293\nJacob Somervell\nChapter Objectives .............................................................................................. 293\nConceptual Overview ......................................................................................... 293\nWhat Is Human\u2013Computer Interface Design? ...............................................294\nWhy Study Human\u2013Computer Interface Design? .........................................294\nGeneral HCI Design Principles .........................................................................297\nHuman\u2013Computer Interface Design Methods ...............................................299\nGetting Started \n................................................................................................299\nFidelity in Prototypes \n.....................................................................................300\nMetaphors ........................................................................................................ 301\nGestalt Principles ............................................................................................303\nReusing Earlier Designs \n.................................................................................305\nEvaluation of HCI Quality .................................................................................305\nUsability Testing .............................................................................................305\nAnalytic Testing \n..............................................................................................306\nEmpirical Testing \n............................................................................................307\nChapter Summary ...............................................................................................309\nReview Questions ................................................................................................309\nChapter Exercises ................................................................................................309\nReferences ..............................................................................................................310", "domains": ["Design Patterns", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 14", "position": 14, "chunk_type": "semantic", "token_estimate": 160}
{"text": "xvii: Tis book is the result of an efort that I began in 2010 at the University of Virginia\u2019s \nCollege at Wise to create a course in sofware engineering design consistent with the 2004 \nIEEE/ACM curriculum guidelines for undergraduate programs in sofware engineering \n(SE). In a broad context, the recommended topics for undergraduate SE programs include \ndesign concepts, design strategies, architectural design, detailed design, human\u2013computer \ninterface design, and design evaluation. As a former industry practitioner, I learned frst-\nhand the diference between hearing or \u201clearning\u201d about these topics and developing the \nnecessary skills to apply them in a way that adds value to some development team, pro-\ngram, project, or business. With that in mind, I set out to compile material that I could \nuse (from previous industry experience) to help students become profcient in design-\ning sofware-intensive systems. Troughout the process, many of the original examples \nconsidered dry or hard to follow by students were replaced with new problem domains \n(e.g.,\u00a0 gaming\u00ad\n systems) that helped students assimilate the concepts better. Because of \nthe \u201chands-on\u201d approach required to master these concepts, the teaching style evolved \nto emphasize both theory and practice. Te theory portion was used to present accept-\nable general design principles or a body of design principles to explain successful sofware \n\u00ad\nsystems\u2019 designs. Te practice portion provided the avenue for transforming design theory \ninto skills that can be employed directly to real-life industrial settings. Te knowledge \nand experience gained from these eforts have been captured in this textbook, which can \nbe useful for both industry practitioners and students in sofware engineering, computer \n\u00ad\nscience, and information technology programs.", "domains": ["Design Principles", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 17", "position": 17, "chunk_type": "semantic", "token_estimate": 271}
{"text": "xviii\u2002 \u2022\u2002 Preface: As part of the introductory material, the sofware engineering process is covered briefy \nto provide the context in which sofware design takes place and a formal top-down design \nprocess is presented. Te top-down approach consists of several design phases and activi-\nties that occur at varied levels of detail/abstraction, including the sofware architecture, \ndetailed design, and construction design. As part of the top-down approach, detailed \ncoverage of applied architectural, creational, structural, and behavioral design patterns is \nprovided and a collection of standards and guidelines for structuring high-quality code \nis presented. Te book also provides techniques for evaluating sofware design quality at \ndiferent stages and much needed coverage of management and engineering leadership \nfor sofware designers. Tis provides sofware engineers with the necessary management, \n\u00ad\nethical, and leadership knowledge required to build products for the public domain. Te \nbook also provides coverage of the sofware design document and other forms of documen-\ntation important during the design of sofware systems. Collectively, the book comprehen-\nsively introduces students and practitioners to sofware engineering design and provides \nthe knowledge required to emerge and succeed as tomorrow\u2019s professional design leaders.", "domains": ["Design Patterns"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 18", "position": 18, "chunk_type": "semantic", "token_estimate": 189}
{"text": "xxi: Carlos E. Otero, PhD, is assistant professor in the College of Technology and Innovation \nat the University of South Florida Polytechnic (USFP). Prior to joining USFP, Dr. Otero \nworked as assistant professor of sofware engineering in the Department of Mathematics \nand Computer Science at the University of Virginia\u2019s College at Wise, where he created \nthe sofware engineering design course for Virginia\u2019s frst and (at the time of writing) only \nABET-accredited BS in sofware engineering. Prior to his academic career, Dr. Otero spent 11 years in the private industry, where \nhe worked as design and development engineer in a wide variety of military computer \n\u00ad\nsystems, including satellite communications systems, command and control systems, \nwireless security systems, and unmanned aerial vehicle systems. Currently, he continues \nto consult with industry in the areas of requirements engineering, sofware systems design \nand development, quality assurance, and mobile systems engineering. Dr. Otero received his BS in computer science, MS in sofware engineering, MS in \u00ad\nsystems \nengineering, and PhD in computer engineering from Florida Institute of Technology in \nMelbourne. He has published over 25 technical publications in \u00ad\nscientifc peer-reviewed \njournals and conferences proceedings. He is a senior member of the IEEE, a\u00a0science \u00ad\nadvisor \nfor the National Aeronautics and Space Administration (NASA) DEVELOP program, an \nactive professional member of the Association for Computing Machinery (ACM), and a \nmember of several journal editorial boards in technology and engineering. About the Author", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 21", "position": 21, "chunk_type": "semantic", "token_estimate": 238}
{"text": "Design is an integral part of every engineering discipline. Airplanes, bridges, buildings,: electronic devices, cars, and many other products of similar complexity are all designed. In civil engineering, designs are used to specify detailed plans for developing physical and \nnaturally built environments, such as bridges, roads, canals, dams, and buildings. In elec-\ntrical engineering, designs are used to capture, evaluate, and specify the detailed qualita-\ntive and quantitative description of solutions for telecommunication systems, electrical \nsystems, and electronic devices. In mechanical engineering, designs are used for analyzing, \nevaluating, and specifying technical features required to construct machines and tools, \nsuch as industrial equipment, heating and cooling systems, aircrafs, robots, and medical \ndevices. In all other engineering disciplines, design provides a systematic approach for \ncreating products that meet their intended functions and users\u2019 expectations. Formally, \nDym\u00a0and Little (2008, p. 6) defne engineering design as\nA systematic, intelligent process in which designers generate, evaluate and specify designs for \ndevices, systems or processes whose form(s) and function(s) achieve clients\u2019 objectives and \nusers\u2019 needs while satisfying a specifed set of constraints. Design is a lengthy and complex process requiring signifcant investments in time and \nefort. So why conduct design in engineering disciplines? Tere are many possible answers \nto this question, stemming from simple common sense to more complicated ones involv-\ning professional, ethical, social, and legal implications. From the commonsense perspec-\ntive, products of such complexity are hard to create, are costly to change, and, when built \ncarelessly or incorrectly, can signifcantly impact human life. When working toward the \ncreation of complex products, teams must organize in a disciplined manner, and a sys-\ntematic approach needs to be employed to carefully ensure that products are built to meet \ntheir specifcations. Consider the construction of a bridge that spans over a body of water \nand is required to support a particular weight, to maintain access to watercrafs navigating \nunderneath, to withstand expected wind speeds, and to provide other features such as side-\nwalks\u2014all while being bound by a schedule and budget. Te successful construction of such \na bridge is a nontrivial task and requires years of experience, formal education, and large \nteams collaborating together to achieve the construction goals. If constructed incorrectly\u00ad\n, \nreconstructing the bridge can skyrocket from its original construction cost; worse yet, \nif defects are undetected, the bridge could collapse, resulting in the catastrophic loss of \nhuman life. Similar to the construction of the bridge, teams engineering other products,", "domains": ["Design Patterns"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 24", "position": 24, "chunk_type": "semantic", "token_estimate": 407}
{"text": "Troughout the design process, designers are constantly engaging in problem-solving activ-: ities that are fundamental to all modern engineering projects. In a broad sense, engineers \ncan be characterized as specialized problem solvers. Teir work requires them to identify, \nevaluate, and propose solutions to complex problems (in particular domains) under tight \nproject constraints. In some situations, engineers tackle problems that have never been \nsolved before, creating challenges to meet not only functional aspects of products but also \ntheir established schedule and budget. Before engaging in more concrete design topics, a \nformal discussion on problem solving is necessary to identify fundamental concepts that \nare well understood by successful designers; these serve as basis for establishing a holistic \nproblem solving framework that can be employed any time during design. To become a good designer, engineers must be good problem solvers. Tis may require \nyears of experience solving problems in a particular domain. In many cases, experience \nallows engineers to reuse already proven solutions across separate but similar problems. In other cases, where unsolved problems are encountered, designers are required to \n\u201cthink\u00a0out of the box\u201d and carefully craf a systematic approach for solving the problem in \nan acceptable manner, which may require problem classifcation, identifcation of the solu-\ntion approach and type of adequate solution, and identifying the overall strategy for reach-\ning its solution. In a general sense, problem solving during design occurs in three diferent \nstates (Plotnik and Kouyoumdjian 2010):\n\u2022\t Initial state\n\u2022\t Operation state\n\u2022\t Goal state\nTrough these states, designers employ several techniques and strategies to create a \nlandscape suitable for problem solving. Te initial state is where problems are formulated \nand interpreted. In some cases, achieving full understanding of the problem is a problem \nitself. Once problems are well understood, designers move to the operational state, where \nthinking about the problem occurs and viable solutions come to light. Once an appropri-\nate solution is identifed, evaluated, and validated, designers move to the goal state, where \na fnal solution to the problem is found, marking the end of the problem-solving process.", "domains": ["Design Patterns"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 25", "position": 25, "chunk_type": "semantic", "token_estimate": 343}
{"text": "4\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: Initial State\nDesign problems are not all the same; they vary in size, complexity, and, based on these \ncharacteristics, the amount of time and efort required for their solution. In some cases, it \nquickly becomes evident that certain problems are harder to solve than others. When this \ndetermination is made, the strategy for the solution approach is adjusted to account for \nthe additional complexity. Being able to diferentiate between types of problem is crucial \nin helping designers account for the amount of efort, time, and risk associated with the \nsolution approach. Terefore, an important problem-solving skill involves identifying and \nclassifying the type of problem encountered, which includes well-defned, ill-defned, and \nwicked problems, as presented in Table\u00a01.1 (Giachetti 2010). Well-defned problems have clear defned goals and their constraints are well under-\nstood. Tis makes scoping the problem, proposing a solution approach, and arriving at \nthe solution easier than with other types of problems, such as ill-defned and wicked \nproblems. Ill-defned problems are problems where the mere interpretation of the prob-\nlem is a problem itself; they are ambiguous with undefned goals and require more time \nand efort to clarify and interpret the problem to arrive at a solution. In some cases, with \nadditional efort, ill-defned problems can be transformed into well-defned problems. Finally, wicked problems are problems where no single problem formulation exists. Tere \nmay be many acceptable formulations of the problem and no defnite solutions, and solu-\ntions are not deemed correct or incorrect but good or bad (Giachetti 2010). In\u00a0many cases, \nwicked problems can lead to contradictive goals that need additional resolution before the \nproblem solving can occur. When contradictive goals are present, providing a solution \nto one part of the problem results in the inability of solving other parts of the problem. In these types of problem, optimal solutions are hard to fnd, requiring additional strug-\ngle and collaborative brainstorming. Also, evaluation of alternative designs may require \nadvanced techniques to determine the best course of action, which tends to require more \ntime. In many cases, the solution to wicked problems is not known until afer the problem \nis solved. Operational State\nTe operational state of problem solving is where thinking about the problem solution \ntakes place. It requires employing multiple techniques for problem solving such as using \nmetaphors, decomposing problems into smaller, less complex problems (i.e., divide and \nconquer), reusing solutions (e.g., patterns), and so forth.", "domains": ["Design Patterns"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 26", "position": 26, "chunk_type": "semantic", "token_estimate": 405}
{"text": "4\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: Operational State\nTe operational state of problem solving is where thinking about the problem solution \ntakes place. It requires employing multiple techniques for problem solving such as using \nmetaphors, decomposing problems into smaller, less complex problems (i.e., divide and \nconquer), reusing solutions (e.g., patterns), and so forth. In all of the techniques, designers \nTABLE\u00a01.1\nProblem Classifcation\nProblem\nDescription\nWell-defned\nProblem with clear goals and known constraints\nIll-defned\nProblem with undefned or ambiguous goals and unknown constraints\nWicked\nProblem with no defnite solution; not understood until afer the formulation of its solution", "domains": ["Design Patterns"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 26", "position": 26, "chunk_type": "semantic", "token_estimate": 97}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 5: are expected to exhibit a \u201cthink outside the box\u201d mentality to be able to solve complex \nproblems. Tis requires shifing the mental model from a conventional approach to uncon-\nventional methodology where solutions to complex problems may arise from thinking in \nways that deviate from conventional wisdom. For example, consider the popular nine-dot \npuzzle illustrated in Figure\u00a01.1 (Kershaw and Ohlsson 2004). Te requirements for solving the nine-dot puzzle problem are as follows:\n\t\n1. Draw four straight lines to connect all dots. 2. Te pencil cannot be lifed from the paper once the line-drawing process begins. 3. No lines can be retraced. Before moving on, think about this problem and attempt to provide a solution. At frst, \nthis may seem difcult because of the tendency of fxing the mental process to operate on \nthe assumption that lines should begin and end on a dot. Tis functional fxedness limits \nthe ability to fnd solutions based on objects having a diferent function from their usual \nones (Plotnik and Kouyoumdjian 2010). In the case of the nine-dot puzzle, for some, func-\ntional fxedness makes it awkward or even impossible to propose solutions that involve lines \ngoing past the dots, which is what is required to solve this problem. To increase the chance \nof overcoming functional fxedness, problems need to be attempted several times and con-\nsidered from many diferent viewpoints and unusual angles (Plotnik and Kouyoumdjian). Overcoming functional fxedness is critical for designers attempting to provide solutions \nat the operational state of problem solving. Thinking about the Problem\nDiferent types of thinking take place when fnding solutions to problems. For example, \nwhen learning about a problem for the frst time, problem solvers may begin by asking \nquestions, which allows them to think about many diferent alternative solutions; as the \nproblem-solving process moves forward, problem solvers can begin narrowing down the \npossibilities and think about the single best solution to the problem. Tese types of think-\ning are known as convergent thinking and divergent thinking (Table 1.2). Both convergent and divergent thinking have signifcant roles in solving engineering \nproblems. In many cases, problem solvers begin using divergent thinking with diferent \nlevels of abstraction, and each level provides fner-grained solutions to the problem until \nconvergent thinking can be employed to solve it. FIGURE 1.1\nTe nine-dot puzzle.", "domains": ["Design Patterns"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 27", "position": 27, "chunk_type": "semantic", "token_estimate": 389}
{"text": "6\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: Problem Solution\nIn many cases, determining the type of solution required for a given problem can reduce \nwasted time and efort spent in attempting to fnd a single, optimal solution. In such cases, \ndesigners can elect to seek approximate solutions\u2014as opposed to optimal solutions\u2014that \nare appropriate and acceptable for meeting project constraints. Determining the type of \nsolution for a given problem can reduce time and budget required for building the system. Two types of solutions are algorithms and heuristics, as presented in Table\u00a01.3. Algorithms are step-by-step procedures for fnding the correct solution to given prob-\nlems. Algorithms do not normally involve subjective decisions or rely on intuition or \n\u00ad\ncreativity to fnd solutions (Brassard and Bratley 1995). For some types of problems, using \nalgorithms to fnd solutions can be unrealistic, especially in time-driven, practical engi-\nneering problems. In these cases, heuristics provide a realistic approach for fnding good \napproximations of the solution. In some cases, heuristics can lead to optimal solutions; in \nothers, they can lead to solutions that are far from optimal or no solution at all (Brassard \nand Bratley 1995). Algorithms and heuristics are both used heavily in the design of engi-\nneering systems and determining their appropriateness for solving particular problems is \nessential to meeting other project demands. Goal State\nTe goal state represents the fnal state of problem solving. It is where adequate solutions \nto given problems are determined. For many engineering problems, reaching the goal state \nis a nontrivial task that requires careful attention to all important aspects of the problem. Te concepts of initial, operational, and goal state can be fused together to create a holistic \nproblem-solving framework adequate to solving engineering problems at all stages of the \ndevelopment efort. Te approach consists of the following tasks:\n\u2022\t Interpret problem\n\u2022\t Evaluate constraints\n\u2022\t Collaborative brainstorming\nTABLE\u00a01.2\nTypes of Tinking\nType\nDescription\nConvergent thinking\nType of thinking that seeks to fnd one single solution to a problem\nDivergent thinking\nType of thinking that seeks to fnd multiple solutions to a problem\nTABLE\u00a01.3\nTypes of Problem Solution\nProblem\nDescription\nAlgorithm\nFixed set of rules that lead to the solution of a problem\nHeuristic\nRules of thumb (or procedure) that may or may not lead to the solution of a problem", "domains": ["Design Patterns"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 28", "position": 28, "chunk_type": "semantic", "token_estimate": 383}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 7: \u2022\t Synthesize possibilities\n\u2022\t Evaluate solution\n\u2022\t Implement solution\nTe frst task of the problem-solving approach involves interpreting the problem. Tis \nis where problem information is received and processed; problem classifcation is identi-\nfed (e.g., well-defned, ill-defned) and activities are performed to formulate the problem. Interpreting the problem is a task performed during the initial state of problem solving. During the initial state, identifcation of stakeholders\u2014persons, groups, or organizations \nthat have direct or indirect stake in the problem and its solution\u2014is essential. Once the \nproblem is formulated, the evaluate constraints task is used to identify external problem con-\nstraints, which are negotiated, integrated, and used to set the bounds on the solution land-\nscape. Once the problem and constraints are well understood, collaborative \u00ad\nbrainstorming \ncan begin among problem solvers and stakeholders. During collaborative brainstorming, \nproblem solvers use mostly divergent thinking to come up with alternative solutions that \nmay bring to light new knowledge, which can trigger a transition back to the problem inter-\npretation task. Once a set of acceptable solutions is identifed, problem solvers synthesize \npossibilities to form the acceptable proposed solution to the problem. During this task, prob-\nlem solvers shif from divergent thinking to convergent thinking to propose the best-known \nsolution to the problem. Te solution is shared and evaluated by everyone involved in the \nproblem-solving process. Flaws in the solution may trigger a transition back to the collab-\norative brainstorming task; otherwise, implementation begins. Collaborative brainstorming, \nsynthesize possibilities, and evaluate solutions are all tasks performed as part of the opera-\ntional state of problem solving. During implementation, the proposed solution is executed \nuntil the problem is solved, which is a task performed during the goal state of problem solv-\ning. Together, these tasks are combined with other problem variables to provide a holistic \napproach to problem solving (Harrell, Ghosh, and Bowden 2004), as presented in Figure\u00a01.2. As seen in the fgure, inputs are items that require processing during problem solving. Inputs come from many diferent sources and are interpreted and formulated for particu-\nlar problems. Tey drive all activities by specifying the overarching need that promotes \nthe execution of the problem-solving tasks. Constraints are external properties that come \ninherent with any problem and limit the solution approach. Outputs are the expected \noutcome in problem solving.", "domains": ["Design Patterns"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 29", "position": 29, "chunk_type": "semantic", "token_estimate": 388}
{"text": "8\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: time required to solve the problem. Controls, on the other hand, are internal constraints set by \nthe development organization that limit the possible solutions so that they align well with the \norganizational goals and current practices. Tese controls can dictate when and where prob-\nlem solving takes place, selection of strategies, permitted tools, personnel allowed to engage in \nproblem solving, and measures for quality control. Finally, resources are the means by which \nactivities are performed, which include people, sofware, and hardware, and their availability, \nwhich all impact problem solving. Together, all of these variables mix together to defne the \nproblem-solving landscape, which must be considered when tackling engineering problems. Skill Development 1.1: Using the Holistic Approach in Problem Solving\nUse and document all the steps of the holistic problem-solving approach presented in \nFigure\u00a01.2 to solve the following problem. If possible, do this exercise as a team. Te \nproblem specifcation is as follows: there are six equal matches; connect each match to \nform four equilateral triangles. When done, explain how functional fxedness played a \nrole in preventing you from arriving at the solution to this problem. TABLE\u00a01.4\nProblem-Solving Process Variables\nPhase\nDescription\nActivities\nOne or more tasks identifed and required to solve the problem\nResources\nMeans by which activities are performed\nControls\nInternal properties of the organization that place bounds on the solution, or the solution process, \nfor the problem\nEvaluate\nConstraints \nSynthesize\nPossibilities\nInterpret\nProblem\nEvaluate \nInputs \nConstraints \nOutputs \nCollaborative\nBrainstorming\nImplement \nGeneric Design Problem \nResources \nActivities \nControls \nFIGURE 1.2\nHolistic approach to problem solving.", "domains": ["Software Quality Attributes"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 30", "position": 30, "chunk_type": "semantic", "token_estimate": 262}
{"text": "In the previous sections, design was introduced as a systematic and intelligent process for: generating, evaluating, and specifying designs for devices, systems, or processes. To support \nthis process, the problem-solving skill was identifed as an essential ingredient for design-\ning complex products. Tese discussions provided a general perspective on the impor-\ntance of these concepts in the engineering profession. As in other engineering disciplines, \ndesign and problem-solving are crucial to the development of professional, large-scale, \nsofware systems. Sofware systems are highly complex, difcult to create, costly to change, \nand\u2014depending on the sofware product\u2014critical to human safety. Similarly to other \nengineering disciplines, designs in sofware engineering are used to identify, evaluate, and \nspecify the structural and behavioral characteristics of sofware systems that adhere to \nsome specifcation. Sofware designs provide blueprints that capture how sofware systems \nmeet their required functions and how they are shaped to meet their intended quality. Formally, sofware engineering design is defned as\n(1) Te process of identifying, evaluating, validating, and specifying the architectural, detailed, \nand construction models required to build sofware that meets its intended functional and non-\nfunctional requirements; and (2) the result of such process. Te term sofware design is used interchangeably in practice as a means to describe both \nthe process and product of sofware design. From a process perspective, sofware design is \nused to identify the phase, activities, tasks, and interrelationship between them required \nto model sofware\u2019s structure and behavior before construction begins. From a product \ndevelopment perspective, sofware design is used to identify the design artifacts that result \nfrom the identifed phase, activities, and tasks; therefore, these products by themselves, or \ncollectively, are referred to as sofware design. Design products vary according to several \nfactors, including design perspective, language, purpose, and their capabilities for evalu-\nation and analysis. For example, designs can be in architectural form, using architectural \nnotations targeted for specifc stakeholders. Tese types of design can be presented using \nblock diagrams, Unifed Modeling Language (UML) diagrams, or other descriptive form \nof black-box design documentation. In other cases, design can be in detailed form, where \na more white-box representation of the system is used to model structural and behavioral \naspects. Tese can include sofware models that contain class diagrams, object diagrams, \nsequence diagrams, or activity diagrams. Other design products include models that rep-\nresent interfaces, data, or user interface designs.", "domains": ["Design Patterns", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 31", "position": 31, "chunk_type": "semantic", "token_estimate": 389}
{"text": "In the previous sections, design was introduced as a systematic and intelligent process for: Tese can include sofware models that contain class diagrams, object diagrams, \nsequence diagrams, or activity diagrams. Other design products include models that rep-\nresent interfaces, data, or user interface designs. Due to the many ways sofware design is \nused in practice, a common pitfall in sofware engineering projects is to associate design \nwith a particular type of design artifact, therefore neglecting other forms of design or the \nactivities required to create complete and correct sofware designs. Collectively, both pro-\ncess and products, including all variety of design products, are considered sofware design \nand are essential in most professional sofware projects.", "domains": ["Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 31", "position": 31, "chunk_type": "semantic", "token_estimate": 114}
{"text": "10\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: WHY STUDY SOFTWARE ENGINEERING DESIGN? On February 25, 1991, a sofware error on the Patriot missile defense system operating \nduring operation Desert Storm caused it to fail to track and intercept an incoming Scud, \nwhich resulted in the death of 28 Americans (GAO, 1992). In 1996, a sofware error caused \nthe Ariane 501 satellite launch to fail catastrophically, resulting in a direct cost of approx-\nimately $370 million (Dowson 1997). Te sofware error that caused Ariane 501 to fail \ncould be attributed to its sofware design. Similarly, the literature is swamped with many \nexamples of disastrous results of sofware-based products. Te reason for many of these \ndisasters is that developing high-quality sofware on time and within budget is a daunting \ntask. From the outset, the landscape for sofware development projects is plagued with a \nvariety of challenges that increase complexity in sofware projects. Sofware design plays \nan integral part in managing the complexity and the challenges encountered in any sof-\nware development efort. During the sofware design phase, the system is decomposed to allow optimum develop-\nment of the sofware; requirements are mapped to conceptual models of the operational \nsofware; roles are assigned to sofware teams on the same or remote sites; well-known \ninterfaces for sofware components are created; quality attributes are addressed and \nincorporated into the design of the system; the user interface is created; the sofware\u2019s \ncapability is analyzed; function and variable names are identifed; design documentation \ngoals are established; and the foundation for the rest of the sofware engineering life cycle \nis established. Given its impact on the creation and management of sofware products, \n\u00ad\nmastering sofware design becomes essential to successfully engineer sofware products. Te reasons for studying sofware engineering design can be described using a product \ndevelopment perspective and a project management perspective. Reasons for Studying Software Design in Product Development\nFrom the product development view, studying sofware design is important because \ndesigns form the foundation for all other sofware construction activities. Sofware designs \nallow sofware engineers to create models that represent the structure and behavior of \nthe sofware system. Trough these models, the main components and their interconnec-\ntion for the solution are identifed. Characteristics of quality code, such as modularization, \ncohesiveness, and coupling, are all born in the design phase. For complex tasks, abstrac-\ntions and encapsulation are used in sofware design as means to provide a systematic \napproach for problem solving.", "domains": ["Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 32", "position": 32, "chunk_type": "semantic", "token_estimate": 404}
{"text": "10\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: Characteristics of quality code, such as modularization, \ncohesiveness, and coupling, are all born in the design phase. For complex tasks, abstrac-\ntions and encapsulation are used in sofware design as means to provide a systematic \napproach for problem solving. In addition, sofware designs are reusable; therefore, they \ncan be applied to diferent projects to provide ready-made solutions to common problems. Sofware design also provides the means to evaluate and incorporate the quality attributes \nnecessary for sofware systems. Terefore, issues such as performance, usability, portabil-\nity, and security can all be addressed early on in the development project. Tese benefts \nare carried over to all other subsequent phases of the sofware development life cycle and \nhave direct impact on the implementation, testing, and maintenance phase.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 32", "position": 32, "chunk_type": "semantic", "token_estimate": 129}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 11: Reasons for Studying Software Design in Project Management\nManaging sofware projects characterized by changing requirements, tight schedules, cost \nconstraints, and high expectations for sofware quality is tough. Among these, require-\nment changes are common drivers for all other project characteristics. Tis means that, \nas requirements change, projects should expect some impact in their cost, schedule, and \nquality. In some cases, requirement changes can easily translate to extended schedules \nand increased cost; in others, where schedules are not extended, requirement changes \ntranslate to decreased sofware quality. Good sofware design can minimize (or counter) \nthe efects of requirements volatility in managing sofware projects. From the manage-\nment\u2019s point of view, sofware design is important because it helps accommodate changes \nto the requirements or system updates, therefore minimizing impact on schedule, cost, \nand quality. In\u00a0addition, good sofware design increases efciency in human resource \nallocation tasks. By decomposing the sofware into independent units, resources can be \nassigned to sofware components so that they can be built in parallel in the same or dif-\nferent construction sites, therefore having signifcant impact on sofware schedules and \ncost. By compartmentalizing the design, the efects of unwanted employment attrition \n(i.e.,\u00a0employees leaving the company) can also be minimized, since new employees need \nonly to take on the individual design component assigned to that employee. Good sof-\nware designs provide an efcient mapping of customer requirements to sofware solu-\ntions, therefore facilitating requirements tracing throughout the design. Having a strong \ngrasp on sofware design helps management abstract project tasks and acquire better \nappreciation of the work to be done. Overall, having a strong grasp in sofware design \nhelps management improve the project planning, organization, stafng, and tracking and \nprovide overall guidance for the project.", "domains": ["Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 33", "position": 33, "chunk_type": "semantic", "token_estimate": 293}
{"text": "Today, the sofware design phase has evolved from an ad hoc and sometimes overlooked: phase to an essential phase of the development life cycle. Furthermore, the increasing com-\nplexity of today\u2019s systems has created a set of particular challenges that makes it hard for sof-\nware engineers to meet the continuous customer demand for higher sofware quality. Tese \nchallenges have prompted sofware engineers to pay closer attention to the design process \nto better understand, apply, and promulgate well known design principles, processes, and \nprofessional practices to overcome these challenges. Some of the major challenges include \nrequirements volatility, design process, quality issues (e.g., performance, usability, secu-\nrity), distributed sofware development, efcient allocation of human resources to devel-\nopment tasks, limited budgets, unreasonable expectations and schedules, fast-changing \ntechnology, and accurate transformation from sofware requirement to a sofware product. A brief discussion of these challenges is presented next.", "domains": ["Software Quality Attributes"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 33", "position": 33, "chunk_type": "semantic", "token_estimate": 145}
{"text": "12\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: Design Challenge 1: Requirements Volatility\nA major reason for the complexity of sofware projects is the constant change of require-\nments. When designed properly, sofware can be modifed or extended easily; however, when \ndesigned poorly, modifying sofware can become overwhelming and lead to all sorts of com-\nplex problems. Unlike the development of computer hardware, bridges, houses, or mechanical \nparts, sofware\u2019s very own nature allows itself to change to provide diferent or new function-\nality to systems. Tis same trait that makes sofware so desirable is what makes it also so com-\nplex. Although much efort is put into the requirements phase to ensure that requirements are \ncomplete and consistent, that is rarely the case; leaving the sofware design phase as the most \ninfuential one when it comes to minimizing the efects of new or changing requirements. Requirements volatility is challenging because they impact future or current development \neforts. Tis forces designers to create designs that provide solutions to problems at a given \nstate while also anticipating changes and accommodating them with minimal efort. Tis \nrequires designers to have a strong understanding of the principles of sofware design and \ndevelop skills to manage complexity and change in sofware development. Design Challenge 2: Process\nSofware engineering is a process-oriented feld. Sofware processes allow engineers to \norganize the steps required to develop sofware solutions with schedule and cost constraints. Terefore, at the core of every sofware development company, there should be a sound, \nwell-understood, and consistent process for sofware development. Processes can also be devel-\noped and customized for particular phases of the sofware engineering life cycle. In the design \nphase, sofware processes involve a broad set of activities and tasks that bridge the gap between \nrequirements and construction while adhering to a set of project-specifc (or company-specifc) \nconstraints. Tese activities include common ones, such as architectural and detailed design, \nas well as other supporting activities. Tese supporting activities include establishing a design \nreview process, defning design quality evaluation criteria, evaluating design reuse, estab-\nlishing design change management and version control procedures, adopting design tools, \nand allocating resources. In many cases, a company\u2019s design process is not well established, \nis poorly understood, or is approached with minimalistic expectations that ignore aspects \nthat are essential to executing a successful design phase.", "domains": ["Design Patterns"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 34", "position": 34, "chunk_type": "semantic", "token_estimate": 383}
{"text": "12\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: Tese supporting activities include establishing a design \nreview process, defning design quality evaluation criteria, evaluating design reuse, estab-\nlishing design change management and version control procedures, adopting design tools, \nand allocating resources. In many cases, a company\u2019s design process is not well established, \nis poorly understood, or is approached with minimalistic expectations that ignore aspects \nthat are essential to executing a successful design phase. Focusing design eforts on creating \n\u00ad\nindependent sofware products, such as a simple class diagram or user interface, while ignoring \nother design activities may create complexities later on during system\u2019s test and maintenance. Te design process is challenging because essential design process activities are ofen over-\nlooked, done in an ad hoc manner, or simply not done at all. In many cases, a well-established \nand well carried out design process serves an indication of future project\u2019s success. Design Challenge 3: Technology\nSofware is meant to be everywhere. From health-care systems and education to defense \nand everyday ubiquitous devices, sofware is required to operate on a massive and always", "domains": ["Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 34", "position": 34, "chunk_type": "semantic", "token_estimate": 177}
{"text": "14\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: and its external infuences, such that external factors afect the development of the system \nand the system afects its external factors (Bass, Clements, and Kazman 2003). Managing \nthese infuences is essential for maximizing the quality of systems and their related infu-\nence on future business opportunities. Of specifc importance are design infuences that \ncome from the system stakeholders and its developing organization. Stakeholders\nDesigning sofware is a nondeterministic activity. If given the same task to diferent \ndesigners, diferent solutions will be proposed, each of them being perfectly acceptable \n(McConnell 2004). Now add to the mix the multitude of infuences that come from dif-\nferent stakeholders, and you can easily get a variety of design alternatives for meeting a \nvariety of stakeholders\u2019 concerns, all conficting with each other. Tis creates a challenge \nwhen trading of design alternatives that meet all stakeholders concerns. Making such \ndesign trade-ofs is difcult, especially on large-scale design eforts. Consider a project \nwith multiple customers, each with conficting goals afecting design decisions. In such \nprojects, creating a design that sacrifces some desired customer capability but provides \nother desired properties, such as quick time-to-market, reliability, or lower cost, can lead \nto the development of a high-quality system that maintains acceptable levels of satisfaction \namong stakeholders. Tis is an example of how stakeholders afect design decision, and the \ndesign, in turn, infuences the stakeholder goals (Bass et al. 2003). Managing \u00ad\nstakeholders\u2019 \ninfuences is challenging because it requires designers to exert a high-level of communica-\ntion, negotiation, and technical skills to ensure that design decisions are made to accom-\nmodate all concerns without negatively afecting the project. Development Organization\u2019s Structure\nTe development organization\u2019s structure infuences the development of sofware prod-\nucts, in particular, the design of those products. As example, consider the case of distrib-\nuted sofware engineering. In today\u2019s global market, more and more cases of distributed \nsofware development are taking place. A wide variety of reasons exist for developing sof-\nware at diferent sites. Consider companies that have sites in multiple states, where various \nlevels of domain expertise are found at diferent sites. Or consider the case of sofware \nengineers resigning, creating a gap in the development team that is hard to fll with local \nresources. Finally, consider companies that simply want to reduce cost by hiring sofware \nengineers from diferent countries. Tese and many other reasons exist for having devel-\nopment across site boundaries.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 36", "position": 36, "chunk_type": "semantic", "token_estimate": 403}
{"text": "14\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: Finally, consider companies that simply want to reduce cost by hiring sofware \nengineers from diferent countries. Tese and many other reasons exist for having devel-\nopment across site boundaries. In each of these cases, the structure of the development\u2019s \norganization makes it complicated to, for example, coordinate design eforts, evaluate and \ndiscuss design alternatives, conduct peer reviews, and manage version control. In these \ncases, designers need to consider not only technical aspects of the design but also the dis-\ntribution of employees, organizational goals, resource availability, and so forth. Designs \nthat support integration of distributed expertise across sites can introduce capabilities for \nbuilding new sofware products that could not be engineered otherwise. Tis in turn can", "domains": ["Software Quality Attributes"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 36", "position": 36, "chunk_type": "semantic", "token_estimate": 121}
{"text": "In today\u2019s modern sofware systems, sofware design plays a key role in the development of: sofware products; however, it is only one phase of the complete sofware engineering life \ncycle. To understand how design fts within the whole sofware engineering process, it is \nnecessary to provide the appropriate context so that clear distinctions can be made between \nthe diferent life cycle phases and an appreciation of the importance of sofware design \nactivities and tasks can be acquired. For this reason, an overview of sofware engineering \nand its life cycle is required. Sofware engineering is defned by the IEEE (1990, p. 67) as\n(1) Te application of a systematic, disciplined, quantifable approach to the development, \noperation, and maintenance of sofware; that is, the application of engineering to sofware. (2) Te study of approaches as in (1). Te fundamental sofware engineering life cycle phases include requirements, design, \nconstruction, test, and maintenance, as presented in Table\u00a01.5. Te requirements phase is where stakeholders are identifed and customer needs, wants, \nand the (ofen overlooked) nonfunctional requirements are determined (Laplante 2009). During this phase, requirements are analyzed in their raw form to address issues such as \nrequirements that don\u2019t make sense, contradict each other, or are incomplete, vague, or \njust wrong (Laplante 2009); requirements are classifed and prioritized; and the specifca-\ntion of the sofware system, which typically results in the production of a document, or \nits electronic equivalent is reviewed and validated (Abran, Moore, Bourque, and Dupuis \nTABLE\u00a01.5\nFundamental Sofware Engineering Phases\nPhase\nDescription\nRequirements\nInitial stage in the sofware development life cycle where requirements are elicited, analyzed, \nspecifed, and validated\nDesign\nTe requirement\u2019s specifcation is used to create the sofware design, which includes its \narchitecture and detailed design\nConstruction\nRelies on the requirements\u2019 specifcation, the sofware architecture, and detailed design to \nimplement the solution using a programming language; a great deal of design can also \noccur at this phase\nTest\nEnsures that the sofware behaves correctly and that it meets the specifed requirements\nMaintenance\nModifes sofware afer delivery to correct faults, improve performance, or adapt it for a \ndiferent environment", "domains": ["Software Quality Attributes"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 37", "position": 37, "chunk_type": "semantic", "token_estimate": 348}
{"text": "16\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: 2005). Once the requirements for the system are specifed, designing the system takes \nplace, which is the main topic of this book. Te construction phase begins once the design phase has been executed and all require-\nments can be traced to a section of the sofware design models. Te construction phase is \nwhere designs are implemented using the programming language of choice. In this phase, \ncode is generated according to a style guide. In addition, the code is unit tested, debugged, \nand peer-reviewed; programming errors are detected, tracked, and resolved; code is man-\naged by using change management and version control sofware; and, fnally, code is pre-\npared for delivery using a predefned set of conventions for formatting. Te construction \nphase is tightly related to the design phase and in some cases (typically on smaller projects) \nthe line dividing both phases can be hard to identify. Tere are several reasons for this, \nthe main one being that detailed designs can be directly translated to code; therefore, sof-\nware engineers tend to design and code at the same time. In other cases, where design and \nconstruction are clearly delineated by the process, it is common for some construction \ntasks, such as identifying appropriate class, function, and variable names, to be performed \nduring detailed design. Finally, because many discoveries made well into the construction \nphase give rise to functionality that requires design work, engineers must iterate back and \nforth between construction and design activities. Once all the design artifacts are imple-\nmented with programming and all assigned requirements can be validated through execu-\ntion of code during unit testing, the construction phase is complete. Te testing phase is typically the fnal step before the sofware goes out the door. Te\u00a0main \npurpose of the testing phase is to verify and validate the sofware to ensure that it meets \nthe predefned functions and level of quality defned in the sofware requirement\u2019s phase. Formally, the IEEE (1990, p. 76) defnes testing as\n(1) Te process of operating a system or component under specifed conditions, observing or \nrecording the results, and making an evaluation of some aspect of the system or component. (2) Te process of analyzing a sofware item to detect the diferences between existing and \nrequired conditions (that is, bugs) and to evaluate the features of the sofware item. Te sofware testing phase serves as a gateway between product development and product \nrelease.", "domains": ["Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 38", "position": 38, "chunk_type": "semantic", "token_estimate": 405}
{"text": "In the previous section, the design phase was briefy mentioned as a means for determin-: ing its place within the sofware engineering process. However, as it will be seen, the design \nphase incorporates many activities and tasks conducted by diferent teams and typically \nmanaged by personnel other than designers. Tis requires a formal process to ensure that the \ndesign phase is conducted properly and that it addresses all the concerns identifed for the \nsofware system being built. Many processes exist to carry out phases, activities, and tasks \nthroughout the sofware engineering life cycle, including the unifed process (UP), Scrum, \nand the dynamic systems development method (DSDM) (Pressman 2010). What follows is \na discussion on the sofware design process in terms of the fundamental activities and tasks \nrequired to build sofware products. Tese activities and tasks are essential and typically built \ninto other formal processes such as the ones already mentioned. Te hope is that by plac-\ning more emphasis on the fundamental activities and tasks and less on particular process \napproaches readers can obtain a more concise and understandable coverage of the topic. In today\u2019s professional sofware engineering landscape, sofware engineers are being \nasked to build larger and more complex sofware systems in the same or diferent sites. Terefore, both design processes and artifacts are increasing in complexity. Tis means that \nit is not enough to know how to model structural and behavioral aspects of the system in \nthe design phase, but it is also essential that sofware designers know about the particular \nprocess (e.g.,\u00a0UP, Scrum) required to manage, create, and control sofware design activities. Sommerville (2010) defnes a sofware process as a set of activities that lead to the production \nof a sofware product. Similarly, a sofware design process is a set of activities and controls \nthat specify how resources work together for the production of sofware design artifacts. Te sofware engineering body of knowledge identifes two major activities for sofware \ndesign: sofware architecture and detailed design (Abran et al. 2005). Tese are the essential \nactivities for managing the complexity involved in developing large-scale sofware systems. However, numerous other important activities are required for supporting the creation of \narchitectural and detailed designs. Terefore, when planning and identifying an appropri-\nate sofware design process, the efort required for these activities needs to be considered.", "domains": ["Design Patterns"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 39", "position": 39, "chunk_type": "semantic", "token_estimate": 385}
{"text": "18\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: phase and span through the design phase; in others, it begins afer the requirements are \nspecifed and validated. In a similar fashion, the detailed design activity can start at the \nproject\u2019s design phase and span through the sofware construction phase. Tese scenarios \nare highly project dependent; therefore, following to a strict waterfall-like process for sof-\nware development is impractical for all but the simplest sofware applications. Software Architecture\nTe sofware architecture activity corresponds to a macrodesign approach for creating \n\u00ad\nmodels that depict the quality and function of the sofware system. It provides black-box \nmodels used to evaluate the system\u2019s projected capabilities as well as its expected quality, \nall from multiple perspectives. Terefore, architectural designs allow diferent \u00ad\nstakeholders, \nwith diferent backgrounds and expertise, to evaluate the design and ensure that the sofware \nSoftware Design \nManagement \nDocumentation \nDetailed Design:\nInterface Design\nComponent Design\nConstruction Design:\nFlow-Based Design\nTable-Based Design\nSoftware\nRequirements\nSoftware\nConstruction\nSoftware Architecture:\nArchitectural Views\nArchitectural Patterns\n\u2026\n\u2026", "domains": ["Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 40", "position": 40, "chunk_type": "semantic", "token_estimate": 166}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 19: architecture is addressing their concerns. For example, from the systems engineering per-\nspective, architectural designs can provide information about the physical deployment of \nthe system, including subsystems located at diferent locations, the artifacts executing in \nthe subsystems, and how the system as a whole communicates. From the confguration \nmanagement perspective, architectural designs can provide information about the hier-\narchy of fles in the fle system and how these fles are interconnected to build and deploy \nthe sofware system. From the sofware engineering perspective, diferent architectural \ndesigns can help decompose the sofware and defne the major structural components of \nthe system, identify interfaces between the components, map the requirements to them, \nevaluate concurrency issues, and provide overall insight into the design solution. A major \nbeneft of architectural designs is their capacity to evaluate high-level concerns from stake-\nholders that deal mostly with nonfunctional requirements (e.g., performance, usability, \nsecurity). For these purposes, architectural designs serve as important communication, \nreasoning, and analysis tools that support the development and growth of the systems \n(Bass et al. 2003). Sofware architecture lays the foundation for all subsequent work in the \nsofware engineering life cycle. Detailed Design\nTe detailed design step begins afer the sofware architecture is specifed, reviewed, and \ndeemed sufciently complete for detailed design to begin. Te detailed design activity \nbuilds on the sofware architecture to provide white-box design elements of the \u00ad\nstructure \nand behavior of the sofware system and in many cases is the last major efort before \n\u00ad\nsofware construction begins. Detailed design is the activity that deals with refning the \nsofware architecture to reach a point where the sofware design, including architecture \nand detailed design, is deemed sufciently complete for construction to begin. Whereas the \nsofware architecture places a major emphasis on quality (nonfunctional requirements), \nthe detailed design activity places a major focus on addressing functional requirements of \nthe system. In object-oriented systems, the detailed design activity is where components \nare refned into one or more classes, interfaces are realized, relationships between classes \nare specifed, class functions and variable names are created, design patterns are identifed \nand applied, and, if applicable, design tools are confgured for code generation. Two major \ntasks of the detailed design activity are interface design and component design. Interface Design\nInterface design refers to the design activity that deals with specifcation of interfaces \nbetween components in the design (Sommerville 2010).", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 41", "position": 41, "chunk_type": "semantic", "token_estimate": 400}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 19: Two major \ntasks of the detailed design activity are interface design and component design. Interface Design\nInterface design refers to the design activity that deals with specifcation of interfaces \nbetween components in the design (Sommerville 2010). Interface design can be focused \non specifying the interfaces used internally within sofware components or externally \nacross sofware components. In both cases, interfaces provide a standardized way for spec-\nifying how services are accessed and provided by sofware components. Interface design \nallows subsystems to be designed independently and in parallel; therefore, it is typically \none of the frst tasks performed as part of the detailed design. Other forms of interface", "domains": ["Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 41", "position": 41, "chunk_type": "semantic", "token_estimate": 113}
{"text": "20\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: design specify communication between systems, for example, custom binary or Extensible \nMarkup Language (XML) messaging specifcations used for communication between two \nor more subsystems through the network. Component Design\nDuring architecture, the sofware system is decomposed into logical components that \nabstract required system functions. During detailed design, these logical components are \nrefned and their interactions are modeled to verify the validity of their structural compo-\nsition. Te execution of the detailed design activity requires a shif from the macrodesign \napproach to the microdesign approach to further decompose and refne system components \ninto one or more fne-grained elements, functions, and data variables required for support-\ning the internal structure and behavior of components that meet assigned roles during the \nsofware architecture activity. Component design refers to modeling the internal\u00a0structure\u00ad\n \nand behavior of components\u2014which includes the internal structure of both logical and \nphysical components\u2014identifed during the sofware architecture phase. During this \nactivity\u00ad\n, fne-grained components are derived from the architecture, and their internal \nstructure and behavior are designed. Components are not limited to object-oriented \n\u00ad\nsystems; therefore, component designs can be realized in many ways. In\u00a0object-oriented \nsystems, the internal structure of components is typically modeled using UML through \none or more diagrams, including class and sequence diagrams. When modeling the inter-\nnal structure of components, several design principles, heuristics, and patterns are used to \ncreate and evaluate component designs. Construction Design\nTe idea of the detailed design activity is to get as close to the solution as possible without \nbeginning the construction phase. In many cases, in object-oriented systems, this amounts \nto identifying classes, their attributes and functions, and interrelationships with other \nclasses. Tese tasks are done while abstracting and deferring details of implementation to \nthe construction phase. In some cases, however, implementing complex sofware functions \nidentifed during the detailed design activity requires additional design work to ensure they \nwork properly and maintain the quality standards sought during the sofware architecture \nactivities. In these cases, construction design is necessary. Construction design is not a new \nconcept. Many other authors have proposed it as an important design activity. For example, \nMcConnell (2004) specifes fve levels of sofware design; one of them, being at the lowest \nlevel, deals with internal routine design.", "domains": ["Design Patterns", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 42", "position": 42, "chunk_type": "semantic", "token_estimate": 375}
{"text": "20\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: Many other authors have proposed it as an important design activity. For example, \nMcConnell (2004) specifes fve levels of sofware design; one of them, being at the lowest \nlevel, deals with internal routine design. Similarly, Fox (2006) identifes a form of low-level \ndesign that flls the gap between detailed design and programming and deals with issues \nsuch as operation specifcation, including operation name, parameter types, and return \ntypes among others. Other authors, such as Meyers (2005), have highlighted the impor-\ntance of designing code at low levels, during construction. Construction design is the last \ndesign activity\u2014typically conducted during the construction phase\u2014required to support \nthe \u00ad\nsystem\u2019s quality attributes, such as performance, maintainability, and testability.", "domains": ["Software Quality Attributes"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 42", "position": 42, "chunk_type": "semantic", "token_estimate": 119}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 21: Human\u2013Computer Interface Design\nTe human\u2013computer Interface (HCI) design activity is where general principles are applied \nto optimize the interface between humans and computers. Visual designs have a major role \non the success or failure of sofware systems. Systems that meet functional requirements \nbut that are not usable cannot succeed. Te HCI design activity can be executed in paral-\nlel to the sofware architecture or detailed design activities. In some cases, HCI design is \nconsidered an architectural task, while in others it is considered a detailed design task. Regardless of where HCI design fts within design processes adopted by specifc organiza-\ntions, it is a major design activitiy that requires careful attention. Te major concerns of \nthe HCI designs may include the evaluation and use of modes, navigation, visual designs, \nresponse time and feedback, and design modalities, such as forms and menu-driven. HCI \ndesigns directly infuence the quality of any system and are essential to understanding and \naddressing the factors that afect the overall usability of the system. Many design principles \nand evaluation techniques exist to succesfully design user interfaces. Software Design Documentation\nSimilar to the specifcation activity of the requirements phase, sofware design documen-\ntation, also known as sofware design description (SDD), plays a big role in professional, \nlarge-scale, or sofware-intensive systems. Its importance is specifed by the IEEE (1998, \np.\u00a0iii) as follows:\nSDDs play a pivotal role in the development and maintenance of sofware systems. During \nits lifetime, a given design description is used by project managers, quality assurance staf, \n\u00ad\nconfguration managers, sofware designers, programmers, testers, and maintainers. Each \nof these users has unique needs, both in terms of required design information and optimal \norganization of that information. Hence, a design description must contain all the design \n\u00ad\ninformation needed by those users. SDD should include the necessary information that properly captures the design of \nthe system. As part of this activity, other issues such as tools for generating design docu-\nments, validation, and confguration management must be addressed. Te sofware design \n\u00ad\ndocumentation activity typically begins at the design phase and continues throughout the \n\u00ad\nlifetime of the sofware system. Software Design Management\nManagement plays a big role in sofware engineering projects.", "domains": ["Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 43", "position": 43, "chunk_type": "semantic", "token_estimate": 373}
{"text": "From the discussions provided so far, it should be evident that designers are not all equal.: In many design eforts, designers have diferent roles, with diferent titles and responsibili-\nties that focus on specifc design problems of the sofware system. Tere are many factors \nin place that determine the designer\u2019s role, including an engineer\u2019s work preference, expe-\nrience, and capabilities. When studying sofware design, it is important to understand \nhow these roles difer, the type of work performed, and capabilities required to perform \nthe activities required of each role. In some cases, sofware designers are heavily involved \nin the requirements and construction phases; therefore, they must have expertise not \nonly in design but also in requirements engineering and sofware construction. In other \ncases, a clear organizational delineation exists, allowing designers to focus on their area \nof \u00ad\nexpertise. A\u00a0list of typical designer roles is presented in Table\u00a01.6 (Giachetti 2010). TABLE\u00a01.6\nTypical Roles in Sofware Design\nDesigner\nDescription\nEnterprise architect\nDesigns the enterprise\u2019s strategy, processes, information, and organizational \nstructure\nSofware architect\nDesigns sofware systems using a black-box modeling approach; concern is placed \non the external properties of sofware components that determine the system\u2019s \nquality and support the further design of functional requirements\nComponent designer\nFocuses on designing the internal structure of sofware components identifed \nduring the sofware architecture phase; has strong programming skills\nUser Interface designer\nDesigns the sofware\u2019s user interface; skilled in determining ways that increase \nusability of the system\nSystem engineer\nDesigns systems using a holistic approach, which include designing how sofware \nand hardware collaborate to achieve the system\u2019s goals", "domains": ["Design Patterns", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 44", "position": 44, "chunk_type": "semantic", "token_estimate": 264}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 23: Systems Engineer\nTe systems engineer designs the overall development process of systems as a whole, \nincluding processes for development of both the sofware and hardware that are part of the \nsystem. As a specialization of system engineering, sofware systems engineers design sof-\nware at the system level; in many cases, the work performed by sofware systems engineers \nis similar to that of a sofware architect. Systems engineers work closely with customers to \nprovide a holistic view of systems, their interfaces, and the distribution of requirements \nto subsystems. Sofware systems engineers are typically experts in the problem domain, \nand, depending on the type of system (e.g., embedded, web), they also develop expertise \non other nonsofware-related parts, such as hardware, communications, and avionics. Tis \nis essential at all phases of the sofware development process, since they must be able to \ncommunicate with other engineering disciplines, such as electrical, mechanical, and civil. In this role, designers have typically accumulated experience in other design roles, such as \nsofware architecture, component design, and in some cases construction. In addition to \ntechnical skills, systems engineers are required to have strong leadership skills to ensure \nthe successful system development. Software Architect\nTe sofware architect is in charge of designing the sofware architecture. Sofware architects \ncan be found under a wide variety of titles, such as sofware lead, senior sofware engineer, \nor principal sofware engineer. Regardless of the title, sofware architects have extensive \nexperience architecting systems that meet their intended requirements. Experience is typi-\ncally acquired while moving up through the ranks, from sofware programmer all the way \nup to sofware architect. Sofware architects have strong leadership skills and are required \nto be skilled in initiation, communication, and negotiation. Tey also need to have a keen \nunderstanding of the developing organization to determine ways sofware systems can \ninfuence the organizational business goals and increase new business ventures leveraged \nfrom existing architectures. Other skills benefcial to sofware architects include project \nmanagement skills. Component Designer\nComponent designers are highly noticeable during detailed and construction designs, \nsince they are typically the ones constructing the sofware. Terefore, they have strong \nprogramming skills and a strong foundation in design principles. For object-oriented com-\nponent designers, strong object-oriented skills including knowledge of design patterns are \nessential.", "domains": ["Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 45", "position": 45, "chunk_type": "semantic", "token_estimate": 379}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 23: Terefore, they have strong \nprogramming skills and a strong foundation in design principles. For object-oriented com-\nponent designers, strong object-oriented skills including knowledge of design patterns are \nessential. Component designers create both static and dynamic models of the sofware \nsystem at levels appropriate to drive \u00ad\nconstruction; these include (when applicable) UML \nclass diagrams and sequence diagrams. Tey have deep knowledge and understanding of \nthe sofware requirements assigned to them; they are knowledgeable about other tools that \nsupport the design and development efort, such as modeling tools, integrated development", "domains": ["Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 45", "position": 45, "chunk_type": "semantic", "token_estimate": 96}
{"text": "24\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: environments, forward and reverse \u00ad\nengineering, and confguration management. When \ndesigning at the component level, component designers have a full understanding of style \nguides for the project, since they dictate \u00ad\nnaming, spacing, and commenting conventions \nand other aspects that shape the structure of code. Component designers devise construc-\ntion designs as needed and are profcient at creating efective unit tests that verify the \nquality of their product developed. Finally, component designers need to be comfort-\nable scheduling and conducting peer reviews and accepting feedback and evaluating it \n\u00ad\nobjectively to improve their designs.", "domains": ["Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 46", "position": 46, "chunk_type": "semantic", "token_estimate": 99}
{"text": "Within the design process, many principles, considerations, and strategies help designers: execute the sofware design process in an efective and consistent manner. For the most \npart, these help designers manage and simplify problems, consider the impacts of their \nproposed solutions, and establish a foundation for decision making during design. In this \ncontext, design principles refer to knowledge matter that has been found efective through-\nout the years in multiple projects on diferent domains. Design principles are applicable on \nmost design projects; therefore, their use is expected to help achieve high-quality designs. On the other hand, design considerations are recommendations that help designers in the \ndesign process; they may or may not be followed. Finally, design strategies consist of tacti-\ncal approaches in which design principles and considerations can be employed to drive the \ndesign process. Tese concepts are further discussed in the next sections. General Software Design Principles\nTroughout the history of sofware engineering, many design principles have emerged \nto become fundamental drivers for decision making during the sofware design process. Tese design principles are used as a basis for reasoning and serve as justifcation for almost \nall design decisions. Tey also provide designers with a foundation from which other more \nsophisticated design methods can be applied (Pressman 2010). Tese principles are not \nspecifc to any particular design strategy (e.g., object oriented) or process, so they are fun-\ndamental to all sofware design eforts and can be applied during architectural, detailed, \nand construction designs. Te principles include (Abran et al. 2005):\n\u2022\t Modularization\n\u2022\t Abstraction\n\u2022\t Encapsulation\n\u2022\t Coupling and cohesion\n\u2022\t Separation of interface and implementation\n\u2022\t Sufciency and completeness", "domains": ["Design Patterns", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 46", "position": 46, "chunk_type": "semantic", "token_estimate": 271}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 25: Modularization\nModularization is one of the most important (and perhaps oversimplifed) design prin-\nciples in sofware design. Modularity allows sofware systems to be manageable at all levels \nof the development life cycle. Tat is, the work products of the requirements, design, con-\nstruction, and testing eforts can all be modularized to efciently carry out the operations. In\u00a0the design phase, modularization is the principle that drives the continuous decompo-\nsition of the sofware system until fne-grained components are created. Modularization \nplays a key role during all design activities, including sofware architecture and detailed \nand construction design; when applied efectively, it provides a roadmap for sofware \ndevelopment starting from coarse-grained components that are further modularized into \nfne-grained components directly related to code. If applied properly, modularization can \nlead to designs that are easier to understand, resulting in systems that are easier to develop \nand \u00ad\nmaintain. Efcient modularization can be achieved by following and applying the \nprinciples of abstraction and encapsulation. With proper modularization, sofware systems \ncan be decomposed into modules that allow the system\u2019s complexity to be manageable and \nallow the system to be efciently built, maintained, and reused. Abstraction\nWhile the principle of modularization specifes what needs to be done, the principle of \nabstraction provides the guidance as to how it should be done. Modularizing systems in \nan ad hoc manner leads to designs that are incoherent, hard to understand, and hard to \nmaintain. To modularize intelligently, a thorough understanding of abstraction is required \n(Liskov and Guttag 2010). Abstraction is the principle that deals with creating conceptual \nentities required to facilitate problem solving by focusing on essential characteristics of \nentities\u2014in their active context\u2014while deferring unnecessary details. When abstraction \nis applied, the level of detail required to think about a problem is adjusted to productively \nmodularize a system; this allows for the creation of coherent entities that can be used to \nrepresent their possible variations in the problem\u2019s context and domain. Te principle of \nabstraction can be applied iteratively at multiple levels during the design phase. At the sof-\nware architecture level, abstraction helps during the identifcation of sofware components \nand their interfaces. At the detailed design phase, abstraction helps identify the entities, \nfunctions, and interfaces required to realize the component\u2019s provided services. At the \nconstruction level, abstraction helps in the further design of functions identifed during \ndetailed design.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 47", "position": 47, "chunk_type": "semantic", "token_estimate": 396}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 25: At the detailed design phase, abstraction helps identify the entities, \nfunctions, and interfaces required to realize the component\u2019s provided services. At the \nconstruction level, abstraction helps in the further design of functions identifed during \ndetailed design. In all of these, abstraction is used to facilitate problem-solving by defer-\nring details to later stages. Te principle of abstraction can be classifed as (Pressman 2010):\n\u2022\t Procedural abstraction\n\u2022\t Data abstraction\nProcedural abstraction is a specifc type of abstraction that simplifes behavioral \n\u00ad\noperations containing a sequence of steps or other procedural abstractions. For example,", "domains": ["Design Patterns", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 47", "position": 47, "chunk_type": "semantic", "token_estimate": 100}
{"text": "26\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: consider a client\u2013server application in which the client sends data to the server through \nthe Internet. In this case, the Send procedural abstraction can be used to denote a series \nof operations, for example, retrieving the server\u2019s information (e.g., Internet Protocol [IP] \naddress, port number), opening a connection, sending the message, and closing the con-\nnection. On the other hand, data abstraction is used to simplify the structural composition \nof data objects. Using the previous example, the Message data abstraction can be used to \nrepresent various messages with diferent attributes, such as the message\u2019s ID, content, and \nformat. Te defnition of all of these properties can be deferred to later stages. Abstraction \nis fundamental for managing complexity in all activities of the sofware design phase. Skill Development 1.2: The Abstraction Principle\nTe world is full of abstractions; without abstractions, communicating with our peers \nwould be much more difcult. As an exercise, look for the nearest rectangular object \nthat contains a knob and (maybe) a keyhole; if the object is blocking an entrance, \nchange the state of the object so that it no longer blocks the entrance. Summarize this \nscenario by coming up with two abstractions: one data and the other procedural to \nincrease communication with peers. When done, create a list of four other abstractions \nthat surround you, and provide an abstraction as well as the detailed object description \nthat would be required if the abstraction is not used. Ensure that there are two data \nabstractions and two procedural abstractions. Encapsulation\nIn previous sections, modularization is presented as principle for decomposing mono-\nlithic systems into manageable units. While abstraction provides the principle for guid-\ning the decomposition of the systems based on behavior and data, encapsulation provides \nthe principle for enhancing the efciency of the collaboration among modularized units. Encapsulation is the principle that deals with providing access to the services of concep-\ntual entities (e.g., modules, components) by exposing only the information that is essential \nto carry out such services while hiding details of how the services are carried out. While \nabstraction is employed to fnd conceptual entities, encapsulation enforces that abstracted \nentities communicate between each other using a \u201cneed to know only\u201d basis. When evalu-\nated this way, the abstraction design principle helps create the modules and the encapsula-\ntion design principle enforces efcient communication between them. Tese principles are \nall essential in achieving efcient modularization.", "domains": ["Design Patterns", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 48", "position": 48, "chunk_type": "semantic", "token_estimate": 403}
{"text": "26\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: When evalu-\nated this way, the abstraction design principle helps create the modules and the encapsula-\ntion design principle enforces efcient communication between them. Tese principles are \nall essential in achieving efcient modularization. Te relationship among modulariza-\ntion, abstraction, and encapsulation is presented in Figure\u00a01.4. As seen, afer the principle \nof abstraction is applied, the encapsulation principle is used to hide irrelevant details from \nthe abstraction. In Figure\u00a01.4, the shaded region corresponds to information that is irrel-\nevant to other modules, while the white region corresponds to access points that modules \ncan use to interoperate.", "domains": ["Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 48", "position": 48, "chunk_type": "semantic", "token_estimate": 102}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 27: Coupling\nSimilar to abstraction and encapsulation, coupling and cohesion are design principles that lead \nto efcient module creation by emphasizing on the degree of dependency and belonging of \nmodules, respectively. Formally, the IEEE (1990, p. 22) defnes coupling as\nTe manner and degree of interdependence between sofware modules. Like all other design principles discussed so far, coupling can be applied during sofware \narchitecture, detailed design, and construction design to measure the degree of depen-\ndency of design units, such as an architectural subsystem, a class in a detailed design\u2019s \nclass diagram, or a function in code. In other words, the coupling principle can be used \nto determine how much an architectural subsystem depends on other architectural sub\u00ad\nsystems, how much a class depends on other classes, and how much a function depends on \nother functions. When measuring coupling, the number of dependencies between design \nunits does not tell the whole story, since the nature of the dependencies plays an impor-\ntant role in decision making. For example, design units can depend on well-defned and \nstable interfaces, common data structures, and internal structure of other design units. It\u00a0is not hard to support the idea that dependencies on well-defned and stable interfaces \nare less troublesome than dependencies on the internal structure of other design units. Tree common types of coupling are\n\u2022\t Content coupling\n\u2022\t Common coupling\n\u2022\t Data coupling\nContent coupling represents the most severe type of coupling, since it refers to modules that \nmodify and rely on the internal details of other modules. Common coupling refers to depen-\ndencies based on a common access area, such as a global variable (IEEE 1990). When this \noccurs, changes to the global data area causes changes in all dependent modules. Tis type \nof coupling results in lesser severity than content coupling; however, it shares many of the \nundesired efects as content coupling. Finally, data coupling refers to the type of dependency \nAbstraction\nModularization \nEncapsulation\nMonolithic\nSystem\nModularized\nSystem \nFIGURE 1.4\nTe modularization, abstraction, and encapsulation principles.", "domains": ["Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 49", "position": 49, "chunk_type": "semantic", "token_estimate": 341}
{"text": "28\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: in which design units communicate with each other only through a set of data parameters. Unlike content coupling, data coupling does not depend on the internals of other design \nunits, and unlike common coupling it provides more control over the form of dependency. When dependency between modules relies on data parameters that are globally inaccessible, \ndesign units are shielded from undesired changes to the data by other design units. In all \ncases, a high degree of coupling gives rise to negative side efects. For example, as coupling \nincreases, reusability and manageability of the design units decrease since errors or changes \nto the independent unit propagate to all dependent units. In\u00a0other cases, when coupling \nincreases, so does the complexity of managing and maintaining design units. Other types \nof coupling include control coupling, hybrid coupling\u00ad\n, and pathological\u00ad\n coupling (IEEE 1990). Cohesion\nWhile coupling gives insight to a design unit\u2019s degree of dependency, cohesion provides \ninsight into its strengths. Te IEEE (1990, p. 17) defnes cohesion as\nTe manner and degree to which the tasks performed by a single sofware module are related \nto one another. Cohesion measures how well design units are put together for achieving a particular \npurpose and can be classifed based on the measurement approach as\n\u2022\t Functional cohesion\n\u2022\t Procedural (or sequential) cohesion\n\u2022\t Temporal cohesion\n\u2022\t Communication cohesion\nFunctional cohesion measures a design unit\u2019s strength by the degree to which its tasks, \noperations, or subunits all contribute to perform a single function. When the function \nto be performed has a single logical meaning, functional cohesion can be seen as a form \nof logical cohesion. A highly functionally cohesive module is one whose internal details \nwork toward achieving the same function. Functional cohesion is the most typical type \nof cohesion. Procedural cohesion measures the strength of a design unit by the degree to \nwhich its tasks work procedurally (in steps) to achieve the unit\u2019s purpose. Terefore, func-\ntional and procedural cohesion are not mutually exclusive; that is, modules can exhibit \nboth high functional and procedural cohesion. Temporal cohesion measures strength by \nthe degree to which all tasks in a design unit are performed at specifc times. Consider \na design unit responsible for carrying out the initialization of a system. Tis unit may \nbe responsible for performing a power-on self-test that may include memory tests, fle \nsystem\u00ad\n checks, and communication checks.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 50", "position": 50, "chunk_type": "semantic", "token_estimate": 399}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 29: Cohesion provides an important principle that measures how much design units that are \ngrouped together actually belong together based on diferent criteria. Cohesion can also \nbe seen at diferent levels of the design process. During the sofware architecture activity, \nlogical and communication cohesive modules are typical, whereas, during the detailed \nand construction design activities, functional, procedural, and temporal cohesiveness are \nmore expected. In all cases, highly cohesive modules increase reusability. An example of \nthe cohesion and coupling principles is presented in Figure\u00a01.5. As seen in the top part \nof the fgure, Module 1 performs three unrelated diferent tasks (i.e., Task 1, Task\u00a02, and \nTask 3), each requiring three independent subtasks. For example, Task 1 requires three \ndiferent subtasks, denoted by the labels Task 1.1, Task 1.2, and Task 1.3. As seen, Module\u00a01 \nhas dependencies to nine diferent unrelated tasks, which can translate to a high degree \nof coupling and low degree of cohesion. Te bottom part of Figure\u00a01.5 shows how the \nsystem is decomposed into three more cohesive units, each with lower coupling than \nthe original approach. In this case, the system is transformed to a modular system with \nhigher \u00ad\ncohesiveness and lower coupling. With this transformation, Module 1 now has fve \ndependencies and stronger functional cohesion. Modules 2 and 3 have lower coupling than \nModule 1 (both in its original and improve form) and are highly cohesive. Separation of Interface and Implementation\nTe principle of separation of interface and implementation deals with creating modules \nin such way that a stable interface is identifed and separated from its implementation. Tis design principle should not be confused with encapsulation. During encapsulation, \nModule 1 \nTask 1.1 \nTask 1.2 \nTask 1.3 \nTask 2.1 \nTask 2.2 \nTask 2.3 \nTask 3.1 \nTask 3.2 \nTask 3.3 \nModule 2 \nModule 3  \nModule 1 \nTask 1.1 \nTask 1.2\nTask 1.3 \nTask 2.1 \nTask 2.2 \nTask 2.3\nTask 3.1 \nTask 3.2 \nTask 3.3 \nFIGURE 1.5\nExample of principles of coupling and cohesion.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 51", "position": 51, "chunk_type": "semantic", "token_estimate": 335}
{"text": "30\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: interfaces are created to provide public access to services provided by the design unit while \nhiding unnecessary details, which include implementation. While encapsulation dictates \nhiding the details of implementation, the principle of separation dictates their separation, so \nthat diferent implementation of the same interface can be swapped to provide modifed or \nnew behavior. Figure\u00a01.6 presents these concepts. As seen, the bottom design units have separated interfaces; therefore, varied implemen-\ntations can be employed without changes to a unit\u2019s interface and, subsequently, to depen-\ndent units. Tere are many benefts from this principle, including increased extensibility, \nreusability, and maintainability. Since implementation is compartmentalized, new capa-\nbilities can be added simply by including a new variation of the implementation without \nchanges to old implementations. Also, in this way specifc implementations can be reused. Completeness and Sufficiency\nTe principles of completeness and sufciency deal with efcient module creation. Completeness is a characteristic that measures how well design units provide the required \nservices to achieve their intent. For example, during the detailed design activity, a commu-\nnication class can be considered complete for a particular application if it provides services \nfor establishing and terminating connections, sending and receiving messages. Missing \nany of these services would render the class incomplete. On the other hand, sufciency \nmeasures how well design units are at providing only the services that are sufcient for \nachieving their intent. Consider the same communication class, which can include services \nfor logging statistics, visualization of network activity, or any other capability applicable \nto the communication task. Although these capabilities enhance the class\u2019 service list, the \nclass is considered sufcient by providing the required services of opening/terminating \nconnections, sending, and receiving messages. Tat is, these sets of services are sufcient \nto achieve the unit\u2019s required functions, nothing more and nothing less. Practical Software Design Considerations\nDesign principles are well-known throughout the sofware engineering community and \nare applied in one way or another in most projects. However, other considerations need to \nSegregation of Interface\nand Implementation\nEncapsulation\nFIGURE 1.6\nPrinciple of segregation of interface and implementation.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 52", "position": 52, "chunk_type": "semantic", "token_estimate": 347}
{"text": "Introduction to Sofware Engineering Design\u2002 \u2022\u2002 31: be made to provide the appropriate context in which these principles can be successfully \napplied for developing high-quality sofware systems. Tese considerations are discussed \nin the next sections. Design for Minimizing Complexity\nDesign is about minimizing complexity. Every decision that is made during the design phase \nmust take into account reducing complexity (McConnell 2004). In fact, the majority of design \nprinciples (e.g., modularization, abstraction, encapsulation) are meant to reduce complexity \nin one way or another. By doing this, details of the problem solution can be pushed further \ndown the process, where they can be appropriately handled. As another example, consider \nHCI design: it is all about reducing complexity for the user. Finally, code design is about \nreducing complexity for other developers maintaining the sofware. As rule of thumb, when \nfaced with competing design options, always choose the one that minimizes complexity. Design for Change\nAs stated before, sofware will change; therefore, design with extension in mind. Tere are \nnumerous reasons for this; for example, customers who like the sofware may want to extend \nits functionalities. On the other hand, customers who are discontent with the \u00ad\nsofware may \nwant to replace or remove functionality. In other cases, hardware changes may trigger a \nsofware change; advances in communications may cause sofware to change; or, simply, \nnewer, better sofware technology becomes available triggering a change of \u00ad\nsofware that \nintroduces no new functionality but a more maintainable development technology that \nis supported by current practices. In any case, sofware will change; therefore, its very \nown nature requires sofware designers to plan for the future. A variety of \u00ad\ntechniques is \n\u00ad\navailable during the detailed design phase to achieve this. Software Design Strategies\nTroughout the years, a wide variety of strategies for designing sofware has been \u00ad\nproposed. Some of these include structured design, object-oriented design, aspect-oriented design, \ndata component-based design, and data structure-based design. Two popular strategies are \ndiscussed in the following sections. Structured Design\nIn a broad context, structured design refers to any disciplined functional design approach \nwhere sofware systems are decomposed into independent, single-purpose modules, using \nan iterative top-down approach. Te main focus of structured design is on the functions \nthat systems need to provide, the decomposition of these functions, and the creation of \nmodules that incorporate these functions. Structured design approaches are typically \nemployed afer structured analysis, where the main purpose is to derive a structure chart", "domains": ["Design Patterns", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 53", "position": 53, "chunk_type": "semantic", "token_estimate": 406}
{"text": "32\u2002 \u2022\u2002 Sofware Engineering Design\ufeff: (i.e., sofware architecture) from data fow diagrams. Structured design introduced many \nbenefts; for instance, by decomposing the system into independent, single-purpose \nmodules\u00ad\n, programs were simpler to understand, manage, code, debug, and reuse (Stevens \n1981). However, structured design does not address the issues of data abstraction and infor-\nmation hiding and \u201cis largely inappropriate for use with object-based and object-oriented \nprogramming languages\u201d (Booch 1994, p. 22). Object-Oriented Design\nUnlike structured design, which focuses on functional decomposition of systems, \nobject-oriented design focuses on object decomposition. Formally, the IEEE (1990, p. 51) \ndefnes object-oriented design as\nA design strategy in which a system or component is expressed in terms of objects and \n\u00ad\nconnections between those objects. Objects provide numerous capabilities that make them desirable for efciently designing \nsofware systems. For example, objects are capable of maintaining state information and \nprovide services that can be used independently or relative to the object\u2019s state. Terefore, \nthey are naturally good building blocks for creating good abstractions. Object-oriented \ndesigns also provide capabilities for inheritance and polymorphism, which provide vari-\nous advantages when designing complex and large-scale sofware systems. Inheritance \nallows designers to create families of objects capable of reusing each other\u2019s interfaces or \ninterfaces with implementations. While inheritance allows objects to inherit interfaces \nand implementations, polymorphism allows objects to change the behavior of inherited \ninterfaces\u00ad\n. Numerous design methods based on objects have been proposed. Today, the UP \nprovides a popular framework for object-oriented sofware engineering using UML.", "domains": ["Design Patterns", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 54", "position": 54, "chunk_type": "semantic", "token_estimate": 248}
{"text": "Designs in sofware engineering are used to identify, evaluate, and specify the structural: and behavioral characteristics of sofware systems that adhere to some specifcation. Sofware designs provide blueprints that capture how sofware systems meet their required \nfunctions and how they are shaped to meet their intended quality. Formally, sofware engi-\nneering design is defned as the process of identifying, evaluating, validating, and specify-\ning the architectural, detailed, and construction models required to build sofware that \nmeets its intended functional and nonfunctional requirements and the result of such a pro-\ncess. Te\u00a0term sofware design is used interchangeably in practice as means to describe \nboth the process and product of sofware design. Troughout the design process, designers \nare constantly engaging in problem-solving activities that are fundamental to all modern \nengineering projects; therefore, they can be characterized as specialized problem solvers.", "domains": ["Design Patterns"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 54", "position": 54, "chunk_type": "semantic", "token_estimate": 139}
{"text": "1.\tWhat is sofware engineering design, and why is it important?: 2. What are the three states of problem solving? Describe each and explain how they \napply to design problems? 3. What are two types of thinking employed during problem solving? Provide an \n\u00ad\nexample of how they are applied to design problems. 4. What is the diference between well-defned, ill-defned, and wicked problems and \nhow these problems can afect sofware design? 5. What is the diference between an algorithm and a heuristic? Give examples of how \nboth approaches can be applied during the design phase? 6. What is the holistic approach to problem solving? Explain. 7. How does design fts within the sofware engineering life cycle? Explain. 8. What are the major activities of the sofware design phase, and how do they difer \nfrom one another? 9. List and explain the challenges faced in sofware design. 10. Why is important to emphasize on documentation and management activities \n\u00ad\nduring design? 11. Compare and contrast the following: interface design, user interface design, and \n\u00ad\nconstruction design. 12. What are the diferent roles of sofware designers? How do they difer? 13. Explain the diference between procedural and data abstraction. 14. What is content coupling, and how does it difer from other forms of coupling? 15. Explain in detail the concept of cohesion. 16. What do completeness and sufciency mean? 17. What is the diference among the principles of modularization, abstraction, encapsu-\nlation, and separation of interface and implementation? Provide an example of each. 18. Compare and contrast the structured design strategy with the object-oriented design \nstrategy.", "domains": ["Design Patterns", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 55", "position": 55, "chunk_type": "semantic", "token_estimate": 265}
{"text": "9 Chapter 9 - Human\u2013Computer Interface: Design\nCarroll, J. M. \ufffde Nurnberg Funnell: Designing Minimalist\nInstruction for Practical Computer Skill. Cambridge, MA:\nMIT Press, 1990. Carroll, J. M., and P. Aaronson. \u201cLearning by Doing with\nSimulated Intelligent Help.\u201d Communications of the\nAssociation for Computing Machinery, 1998: 1064\u20131079. Hix, D., and H. R. Hartson. Developing User Interfaces:\nEnsuring Usability Through Product & Process. New York:\nJohn Wiley & Sons, 1993. IEEE. \u201cIEEE Standard Glossary of So\ufffdware Engineering\nTerminology.\u201d 1990. http://ieeexplore.ieee.org/xpl/\nfreeabs_all.jsp?arnumber=159342. Lewis, C., P. Polson, C. Wharton, and J. Rieman. \u201cTesting a\nWalkthrough Methodology for eory-Based Design of\nWalk-Up-and-Use Interfaces.\u201d Chi \u201990 Proceedings, 1990,\n235\u2013242. McCrickard, D. S., C. M. Chewar, and J. Somervell. \u201cDesign,\nScience, and Engineering Topics? Teaching HCI with a\nUni\u00a5ed Method.\u201d Technical Symposium on Computer Science\nEducation (SigCSE\u201904). Norfolk, VA, 2004, 31\u201335. Nielsen, J., and R. L. Mack. Usability Inspection Methods. New York: John Wiley & Sons, 1994. Nielsen, J., and R. Molich. \u201cHeuristic Evaluation of User\nInterfaces.\u201d Proc. ACM CHI\u201990 Conference, Seattle, 1990,\n249\u2013256. Rosson, M. B., and J. M. Carroll. Usability Engineering:\nScenario-Based Development of Human\u2013Computer Interaction. San Franciso: Morgan Kaufmann, 2002. Scriven, M. \ufffde Methodology of Evaluation in Perspectives of\nCurriculum Evaluation. Chicago, IL: Rand McNally, 1967. Somervell, J., and D. S. McCrickard. \u201cBetter Discount\nEvaluation: Illustrating How Critical Parameters Support\nHeuristic Creation.\u201d Interacting with Computers: Special\nIssue on Social Impact of Emerging Technologies 17, no. 5\n(September 2005): 592\u2013612. Virzi, R. A., J. L. Sokolov, and D. Karis. \u201cUsability", "domains": ["Design Patterns", "Code Organization"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 66", "position": 66, "chunk_type": "semantic", "token_estimate": 246}
{"text": "10 Chapter 10 - Software Design: Management, Leadership, and Ethics\nFisher, R., and W. Ury. Getting to Yes, 2d ed. New York:\nPenguin Books, 1991. Gri\ufffdn, Ricky W. Management, 10th ed. Mason, OH:\nSouth-Western Publications, 2010. IEEE Computer Society. \u201cSo\ufffdware Engineering Code of Ethics\nand Professional Practice.\u201d 2010. Available at\nJudge, T. A., R. Ilies, J. E. Bono, and M. W. Gerhardt. \u201cPersonality and Leadership: A Qualitative and Quantitative\nReview.\u201d Journal of Applied Psychology 87, no. 4 (2002):\n765\u2013768. Li, Mei Yan, and Ying Zong Liu. \u201cStudy on Line Managers\u2019\nCompetence-Based Abilities of Performance Management.\u201d\nApplied Mechanics and Materials 40\u201341 (2010): 820\u2013824. Lussier, Robert, and Christopher Achua. Leadership: \ufffdeory,\nApplication, & Skill Development, 4th ed. Florence, KY:\nCengage Learning, 2010. Meredith, Jack, and Samuel Mantel. Project Management: A\nManagerial Approach, 7th ed. Hoboken, NJ: John Wiley &\nSons, 2009. Nebus, J. \u201cBuilding Collegial Information Networks: A eory\nof Advice Network Generation.\u201d Academy of Management\nReview 31, no. 3 (2006): 615\u2013637. Pelosi, Marilyn K., and eresa M. Sandifer. Elementary\nStatistics: From Discovery to Decision. Hoboken, NJ: John\nWiley & Sons, 2003. Simkin, Mark. \u201c e Importance of Good Communication Skills\non \u2018IS\u2019 Career Paths.\u201d Journal of Technical Writing and\nCommunication 26, no. 1 (1996): 69\u201378. Veiga, J. F. \u201cSpecial Topic Ethical Behavior in Management,\nBringing Ethics into the Mainstream: An Introduction to\nthe Special Topic.\u201d Academy of Management Executive 18, no. 2 (2004): 37\u201338.", "domains": ["Software Quality Attributes"], "source": "SE_Design_Practice_Theory.pdf", "section": "Page 68", "position": 68, "chunk_type": "semantic", "token_estimate": 233}
