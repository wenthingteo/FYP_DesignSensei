{"text": "Chapman & Hall/CRC Innovations in Software Engineering and Software Development: Series\nRichard LeBlanc\nSeattle University, Washington, USA\nThis series covers all aspects of software engineering and software development. Books \nin the series include innovative reference books, research monographs, and textbooks \nat the undergraduate and graduate level. The series covers traditional subject matter, \ncutting-edge research, and current industry practice, such as agile software development \nmethods and service-oriented architectures. We also welcome proposals for books that \ncapture the latest results on the domains and conditions in which practices are most \neffective. Introduction to Combinatorial Testing \nD. Richard Kuhn, Raghu N. Kacker, Yu Lei\nSoftware Test Attacks to Break Mobile and Embedded Devices \nJon Duncan Hagar\nSoftware Essentials Design and Construction \nAdair Dingle\nSoftware Metrics A Rigorous and Practical Approach, Third Edition \nNorman Fenton, James Bieman\nComputer Games and Software Engineering \nKendra M. L. Cooper, Walt Scacchi\nEvidence-Based Software Engineering and Systematic Reviews \nBarbara Ann Kitchenham, David Budgen, Pearl Brereton\nEngineering Modeling Languages Turning Domain Knowledge into Tools \nBenoit Combemale, Robert France, Jean-Marc J\u00e9z\u00e9quel, Bernhard Rumpe, James Steel, \nDidier Vojtisek\nSpeed, Data, and Ecosystems Excelling in a Software-Driven World \nJan Bosch\nIntroduction to Software Engineering, Second Edition \nRonald J. Leach\nSoftware Design, Third Edition \nDavid Budgen\nFor more information about this series, please visit: https://www.routledge.com/\nChapman--HallCRC-Innovations-in-Software-Engineering-and-Software-Development/\nbook-series/CHCRCINNSOFEN", "domains": ["Architectural Patterns and Styles"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 3", "position": 3, "chunk_type": "semantic", "token_estimate": 214}
{"text": "Contents: . . 40\n4\nDesign Knowledge\n43\n4.1\nWhat do expert software designers do? . . . . . . . . . . . . 43\n4.2\nSome software design principles\n. . . . . . . . . . . . . . . . 49\n4.2.1\nFitness for purpose . . . . . . . . . . . . . . . . . . . . 49\n4.2.2\nSeparation of concerns . . . . . . . . . . . . . . . . . . 50\nvii", "domains": ["Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 8", "position": 8, "chunk_type": "semantic", "token_estimate": 99}
{"text": "viii: Contents\n4.2.3\nMinimum coupling . . . . . . . . . . . . . . . . . . . . 51\n4.2.4\nMaximum cohesion . . . . . . . . . . . . . . . . . . . . 52\n4.2.5\nInformation hiding . . . . . . . . . . . . . . . . . . . . 52\n4.3\nThe evolution of design ideas\n. . . . . . . . . . . . . . . . . . 53\n4.4\nThe nature of expert design knowledge\n. . . . . . . . . . . . 55\nKey take-home points about design knowledge\n. . . . . . . . . . . 57\n5\nEmpirical Knowledge about Software Design\n59\n5.1\nMeasuring software development processes\n. . . . . . . . . . 59\n5.1.1\nMeasuring physical phenomena . . . . . . . . . . . . . 60\n5.1.2\nMeasuring human reactions . . . . . . . . . . . . . . . 61\n5.2\nEmpirical studies in software engineering\n. . . . . . . . . . . 63\n5.2.1\nThe empirical spectrum . . . . . . . . . . . . . . . . . 64\n5.2.2\nThe research protocol\n. . . . . . . . . . . . . . . . . . 65\n5.2.3\nQualitative studies . . . . . . . . . . . . . . . . . . . . 65\n5.2.4\nQuantitative studies . . . . . . . . . . . . . . . . . . . 66\n5.2.5\nCase studies . . . . . . . . . . . . . . . . . . . . . . . . 67\n5.3\nSystematic reviews . . . . . . . . . . . . . . . . . . . . . . . . 69\n5.4\nUsing empirical knowledge\n. . . . . . . . . . . . . . . . . . . 71\nKey take-home points about empirical knowledge\n. . . . . . .", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 9", "position": 9, "chunk_type": "semantic", "token_estimate": 401}
{"text": "Design as a Noun: How Software Is Structured: 75\n6\nSoftware Architecture\n77\n6.1\nWhat architecture provides for us\n. . . . . . . . . . . . . . . 77\n6.2\nArchitectural style . . . . . . . . . . . . . . . . . . . . . . . . 79\n6.2.1\nPipe-and-\ufb01lter architectural style . . . . . . . . . . . . 82\n6.2.2\nCall-and-return architectural style\n. . . . . . . . . . . 83\n6.2.3\nData-centred repository architectural style . . . . . . . 84\n6.3\nArchitectural patterns . . . . . . . . . . . . . . . . . . . . . . 87\n6.3.1\nModel-view-controller (MVC) . . . . . . . . . . . . . . 88\n6.3.2\nLayers . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\n6.4\nEmpirical knowledge about architecture . . . . . . . . . . . . 91\nKey take-home points about software architecture\n. . . . . . . . . 92\n7\nModelling Software Properties\n93\n7.1\nWhat is a design model? . . . . . . . . . . . . . . . . . . . . 93\n7.2\nRepresentations, perspectives and viewpoints . . . . . . . . . 96\n7.2.1\nThe constructional viewpoint . . . . . . . . . . . . . . 100\n7.2.2\nThe behavioural viewpoint\n. . . . . . . . . . . . . . . 101\n7.2.3\nThe functional viewpoint\n. . . . . . . . . . . . . . . . 101\n7.2.4\nThe data-modelling viewpoint . . . . . . . . . . . . . . 102\n7.3\nDesign notations . . . . . . . . . . . . . . . . . . . . . . . . . 102", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 9", "position": 9, "chunk_type": "semantic", "token_estimate": 372}
{"text": "Contents: ix\n7.3.1\nTextual description forms . . . . . . . . . . . . . . . . 103\n7.3.2\nBox and line description forms\n. . . . . . . . . . . . . 103\n7.3.3\nMathematical notations . . . . . . . . . . . . . . . . . 105\n7.4\nEmpirical knowledge related to viewpoint notations\n. . . . . 106\nKey take-home points about design modelling\n. . . . . . . . . . . 107\n8\nSketching Design Models\n109\n8.1\nWhy do designers sketch? . . . . . . . . . . . . . . . . . . . . 109\n8.2\nSketching: developing informal models . . . . . . . . . . . . . 110\n8.3\nCharacterising the design elements . . . . . . . . . . . . . . . 112\n8.3.1\nSoftware design as an ISP . . . . . . . . . . . . . . . . 112\n8.3.2\nSketching initial models . . . . . . . . . . . . . . . . . 113\n8.4\nEmpirical knowledge about the use of sketching\n. . . . . . . 116\nKey take-home points about sketching . . . . . . . . . . . . . . . . 116\n9\nModelling Software Processes\n119\n9.1\nCharacteristics of software processes . . . . . . . . . . . . . . 119\n9.2\nModelling function: the data-\ufb02ow diagram (DFD)\n. . . . . . 121\n9.3\nModelling behaviour: the state transition diagram (STD) and\nthe state transition table (STT)\n. . . . . . . . . . . . . . . . 126\n9.4\nModelling data: the entity-relationship diagram (ERD)\n. . . 130\n9.5\nModelling construction: the structure chart\n. . . . . . . . . . 134\n9.6\nEmpirical knowledge about modelling processes\n. . . . . . . 136\nKey take-home points about modelling processes . . . . . . . . . . 136\n10 Modelling Objects and Classes\n139\n10.1 Characteristics of objects and classes\n. . . . . . . . . . .", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 10", "position": 10, "chunk_type": "semantic", "token_estimate": 401}
{"text": "x: Contents\n10.9.1 The object model . . . . . . . . . . . . . . . . . . . . . 173\n10.9.2 Object modelling notations . . . . . . . . . . . . . . . 173\n10.9.3 Object-oriented metrics\n. . . . . . . . . . . . . . . . . 174\nKey take-home points about modelling objects and classes\n. . . . 174\n11 Modelling Software Components and Services\n177\n11.1 Reuse\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n11.2 Modelling software components\n. . . . . . . . . . . . . . . . 180\n11.2.1 Component characteristics . . . . . . . . . . . . . . . . 181\n11.2.2 Component frameworks . . . . . . . . . . . . . . . . . 183\n11.2.3 Designing components . . . . . . . . . . . . . . . . . . 185\n11.2.4 COTS . . . . . . . . . . . . . . . . . . . . . . . . . . . 186\n11.3 Modelling software services\n. . . . . . . . . . . . . . . . . . . 187\n11.4 Empirical knowledge about modelling components and services 190\n11.4.1 Empirical knowledge about components . . . . . . . . 190\n11.4.2 Empirical knowledge about services\n. . . . . . . . . . 191\nKey take-home points about modelling components and services\n. 191\nIII Design as a Verb: Designing Software\n193\n12 Structuring the Ill-Structured\n195\n12.1 Challenges in creating a design . . . . . . . . . . . . . . . . . 195\n12.2 Evolution of knowledge transfer mechanisms\n. . . . . . . . . 197\n12.3 Designing with others\n. . . . . . . . . . . . . . . . . . . . . . 199\n12.4 Empirical knowledge about design creation\n. . . . .", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 11", "position": 11, "chunk_type": "semantic", "token_estimate": 401}
{"text": "Contents: . . 265\n15.2.1 Model-view-controller (MVC) . . . . . . . . . . . . . . 266\n15.2.2 Layers . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\n15.2.3 Broker . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n15.3 Design patterns\n. . . . . . . . . . . . . . . . . . . . . . . . . 271\n15.3.1 Proxy (207) . . . . . . . . . . . . . . . . . . . . . . . . 275\n15.3.2 Observer (293) . . . . . . . . . . . . . . . . . . . . . . 278\n15.3.3 Abstract Factory(87) . . . . . . . . . . . . . . . . . . . 281\n15.4 Other uses of patterns . . . . . . . . . . . . . . . . . . . . . . 283\n15.4.1 Software service patterns\n. . . . . . . . . . . . . . . . 283\n15.4.2 Design anti-patterns and code smells . . . . . . . . . . 284\n15.5 Designing with patterns . . . . . . . . . . . . . . . . . . . . . 286\n15.6 Empirical knowledge about designing with patterns\n. . . . . 288\nKey take-home points about designing with patterns\n. . . . . . . 290\n16 Designing with Components and Services\n293\n16.1 Modular design\n. . . . . . . . . . . . . . . . . . . . . . . . . 293\n16.2 Designing with components . . . . . . . . . . . . . . . . . . . 294\n16.3 Designing with software services\n. . . . . . . . . . . . . . . . 298\n16.4 Empirical knowledge about modular design\n. . . . .", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 12", "position": 12, "chunk_type": "semantic", "token_estimate": 401}
{"text": "Preface to the Third Edition: \u201cScience is built up of facts as a house is built of stones, but an\naccumulation of facts is no more a science than a heap of stones\nis a house.\u201d Jules Henri Poincar\u00e9 (1854-1912)\nWhen using this quotation to open the second edition of this book I ob-\nserved that it is sometimes hard not to feel that our knowledge about how\nto design software might sometimes feel akin to having a heap of stones. We\npossess a collection of observations, techniques and experiences, but \ufb01nding\nways of putting them together to provide an organised corpus of knowledge\nabout how to design software is something of a challenge. The \ufb01rst and second\neditions of this book have sought to gather, classify, categorise and interpret\nthe available knowledge with the aim of providing some sort of structure that\nwill help the reader to understand and use it\u2014and this one aims to do the\nsame. The ten years that elapsed between the \ufb01rst and second editions of this\nbook saw the emergence of many new and sometimes radically di\ufb00erent ideas\nabout how we might go about designing software. The software designer\u2019s\ntoolbox acquired concepts such as architecture and new forms of software\ntechnology such as software services; there was a move away from \u2018waterfall\u2019\nthinking with agile methods as well as with new forms of reuse through design\npatterns; and there was a greater \u2018standardisation\u2019 of modelling forms with\nthe Uni\ufb01ed Modeling Language (UML). In the (rather longer) period between the second edition and this one,\nalthough new ideas have continued to emerge, mostly they have been less rad-\nical in their scope. Perhaps this has been partly because software developers\nhave also had to cope with signi\ufb01cant changes in the context within which\nsoftware design takes place. It is now increasingly the case that applications\nmay well be developed by globally dispersed teams; make use of open source\ncomponents; be in the form of product lines; need to operate within a global\nnetwork of systems rather than in a purely local environment; and of course,\nincreasingly need to cope with the possibility of malicious attacks. In addition,\nthe growing availability of knowledge that is based upon empirical evidence is\nslowly giving us a better understanding of what works, when and why.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 14", "position": 14, "chunk_type": "semantic", "token_estimate": 386}
{"text": "Preface to the Third Edition: It is now increasingly the case that applications\nmay well be developed by globally dispersed teams; make use of open source\ncomponents; be in the form of product lines; need to operate within a global\nnetwork of systems rather than in a purely local environment; and of course,\nincreasingly need to cope with the possibility of malicious attacks. In addition,\nthe growing availability of knowledge that is based upon empirical evidence is\nslowly giving us a better understanding of what works, when and why. So, in order to keep the focus upon ideas about design, rather than being\nswamped with detail about software, this edition has been organised very dif-\nferently to the previous two. In particular, the presentation of material about\ndesign has placed a much greater emphasis upon the role of design as related\nxiii", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 14", "position": 14, "chunk_type": "semantic", "token_estimate": 142}
{"text": "Preface to the Third Edition: xv\nwith it my apologies for the accompanying handwriting. This move to greater\ninformality has also been extended to the illustrations intended to provide\n\u2018memory aid\u2019 via visualisations of various concepts\u2014within the capacity of\nmy draughtsmanship at least! What has not changed is what has usually been considered as the unique\nstrength of this book, in that it seeks to describe the available knowledge\nabout software design in a balanced and advocacy-free manner. In a \ufb01eld\nsuch as computing, where enthusiastic advocacy may drown out evidence and\nevaluation, this role continues to be an important one. This is not to imply that\nthe aim is to create a \u201cdry and dusty tome\u201d. The act of designing something\nis a creative and exciting one, whatever the domain, and is one that readily\nprovokes enthusiasm among practitioners and students\u2014and can often lead to\nsome frustration too, we might admit. This is every bit as true for designing\nsoftware as it is for designing cars, aircraft, bridges, toasters and televisions\u2014\nthe aim as always is (or should be) to create something new and better for its\nusers. One other aspect of the book that has not changed is the issue of using\nmaterial taken from the web. The ephemeral nature of these sources, combined\nwith the di\ufb03culty of \ufb01nding out how up-to-date they are, as well as the issues\nof provenance for the material they contain, means that I have been rather\nreluctant to cite other than a small number of those that I have consulted. Where possible, I have tried to cite only those sites that I consider to be\nrelatively stable, and that can also be regarded as being authoritative in a\ntechnical sense. Acknowledgements\nMy interest in software design now dates back over some forty years (oh\ndear! ), so giving due acknowledgement to all of the people who have in\ufb02uenced\nmy understanding and my thinking would be a very long list indeed. However,\nI should particularly acknowledge here the contribution made by the late\nNorm Gibbs when he was Director of the Education Program at the Software\nEngineering Institute of Carnegie Mellon University. Norm encouraged me\nto persist with my early attempts to categorise and classify knowledge about\nsoftware design, starting with my work on developing a prototype for the SEI\u2019s\ncurriculum modules, which eventually led to the \ufb01rst edition of this book.", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 16", "position": 16, "chunk_type": "semantic", "token_estimate": 399}
{"text": "Preface to the Third Edition: However,\nI should particularly acknowledge here the contribution made by the late\nNorm Gibbs when he was Director of the Education Program at the Software\nEngineering Institute of Carnegie Mellon University. Norm encouraged me\nto persist with my early attempts to categorise and classify knowledge about\nsoftware design, starting with my work on developing a prototype for the SEI\u2019s\ncurriculum modules, which eventually led to the \ufb01rst edition of this book. I\nwould also like to thank Marian Petre and Andr\u00e9 van der Hoek for making\nme so much more aware of the importance of sketching and informality, for\nboth the purpose of design and also for presenting ideas. I would also like to repeat my thanks to all those who helped clarify my\nthinking for the \ufb01rst two editions: \ufb01rstly the students who have had to put\nup with my use of my teaching role to explore new ways of explaining this", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 16", "position": 16, "chunk_type": "semantic", "token_estimate": 158}
{"text": "The City Car Club: A member will also be\ncharged an additional fee if a car is left outside of the designated central zone. The position and status of the cars is tracked using a GPS system built into\neach car. At any time each car will have a status, describing its availability,\nwhich can have one of the following values:\n1", "domains": ["Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 18", "position": 18, "chunk_type": "semantic", "token_estimate": 62}
{"text": "2: The City Car Club\n\u2022 Unavailable \u2013 the car is currently in use by a member of the club, or has\nbeen identi\ufb01ed by the support team as needing attention in some way. \u2022 Available \u2013 the car is available for use and can be booked by a club\nmember. \u2022 Reserved \u2013 a member has requested use of the car, but has not yet taken\ncharge of it. CCC\u2019s central monitoring system will continuously record and track the po-\nsition and status of each car. To use a car (a \u2018session\u2019), a member uses their club id to access the cen-\ntral booking system, identi\ufb01es a car that is available as well as conveniently\npositioned for their use, and makes a reservation, with a unique con\ufb01rmation\ncode being sent to them as an SMS text or in an e-mail. The reservation can\nbe made using a laptop application or a phone app (these are provided when\na member registers with CCC). A reservation automatically expires if a car\nhas not been collected within 20 minutes of making the reservation, but it can\nbe extended for one additional period of 20 minutes (the system prompts the\nmember at the end of the \ufb01rst 20-minute period and gives them the opportu-\nnity to extend it). On reaching the car they have reserved, the member uses\nthe unique code to open the car and to operate the ignition system, as well\nas to unlock the security post if one is in use. This can all be done by using\neither a small keypad that is provided to members by CCC, or by means of a\nBluetooth link to the app on their phone or tablet. Entering the code starts\nthe session, and from that point on the member is responsible for the car until\nthey \ufb01nish the session by locking the car and notifying the central booking\nsystem. Billing for a session is based upon a formula that takes account of distance\ncovered and the length of time the car is being used. Members can also add\nfuel to a car at a number of authorised agencies (including the supermarkets\nproviding car parking) using a payment card that charges the fuel to CCC,\nfor which they get credit.", "domains": ["Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 19", "position": 19, "chunk_type": "semantic", "token_estimate": 377}
{"text": "2: Billing for a session is based upon a formula that takes account of distance\ncovered and the length of time the car is being used. Members can also add\nfuel to a car at a number of authorised agencies (including the supermarkets\nproviding car parking) using a payment card that charges the fuel to CCC,\nfor which they get credit. There is a \u2018\ufb01ne\u2019 for leaving a car with an inade-\nquate reserve of fuel in the tank (the fuel level is transmitted to the central\nmonitoring system at the start and end of a session). As well as identifying\nwhere nearby available cars are located, the phone app provided by CCC can\nbe used to locate nearby \ufb01lling stations. The support team of CCC can perform various \u2019mobile\u2019 tasks of mainte-\nnance, including \ufb01xing any problems with cars and retrieving any that have\nbeen left outside of the central area. While out \u2018on the road\u2019, they will use\na similar set of apps to those provided for ordinary members, but with addi-\ntional privileges (for example, allowing them to declare a car to be unavailable\nwhen they begin work on it, and available once they have \ufb01nished). In the longer term, once the system has been tested out in this \ufb01rst loca-\ntion, CCC plan to make their cars available in other cities. So the design of\ntheir software needs to ensure that this is adaptable for use in other places,\nin addition to the usual requirements for security, robustness and e\ufb03ciency.", "domains": ["Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 19", "position": 19, "chunk_type": "semantic", "token_estimate": 254}
{"text": "8: Software Design: Creating Solutions for Ill-Structured Problems\nto determine that their values are x = 2 and x = 3. Putting either\nvalue back into the original expression provides a simple and complete\ntest of correctness for that solution. Applications such as \ufb01nancial mod-\nelling and database transactions provide examples of using computers\nto address WSPs. \u2022 Ill-Structured Problems or ISPs. For such problems there will usually\nbe no explicit formulation, and many possible solutions, with these be-\ning characterised by being good or bad rather than right or wrong. For\nISPs there will be no de\ufb01nitive test to determine the correctness of a\nresult, and so no way of knowing that the \u2018best\u2019 available solution has\nbeen achieved (usually termed \u2018no stopping rule\u2019). Computer applica-\ntions such as face or voice recognition, that have to cope with incomplete\ninformation, can be considered as addressing ISPs. When we look at problem-solving more broadly, not just through the use\nof computers, these distinctions are every bit as useful. Many problems en-\ncountered in science, particularly in physics and maths, are well-structured\nproblems that can be solved through mathematical analysis. However, the\nproblems addressed by engineers, including software engineers, are nearly al-\nways ill-structured problems. The need for a bridge can be met in many ways,\nand there are many ways of writing even a simple computer program. So ad-\ndressing an ISP involves employing some form of design process which enables\nus to formulate a possible solution and then evaluate how well it might meet\na particular need. The CCC system as an ISP\nLet\u2019s consider a design scenario that might occur when the software\ndesign team start to plan how they will develop the software for CCC. 1. The head designer suggests representing each car as an object,\nwith its current status being stored internally, and a set of meth-\nods that allow customers and other users (such as the mainte-\nnance team and the accounting software) to access that status. 2. The next question is how to organise all of these objects. So\na member of the team suggests using an array of objects. One\nconsequence is that every car now has to have an index number\nso that the relevant object can be accessed. 3. And then there\u2019s the question of how to model the status of a\ncar internally (is it available, unavailable or reserved?).", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 25", "position": 25, "chunk_type": "semantic", "token_estimate": 399}
{"text": "What Is Designing About?: 9\nwhich we need to approach the task of \u2018solving\u2019 ISPs and WSPs. A really\nimportant distinction is the way that postulating a possible solution to one\naspect of an ISP may in\ufb02uence our understanding of that aspect as well as\ninteracting with the ideas we may have for solving its other aspects (indicated\nby the dashed-line backward pointing arrows). problem\nspecification\nsolution\nprocedure\nsolution\nset of algorithmic\nrules to apply when\nsolving such problems\nset of algorithmic\nrules to apply when\nsolving such problems\na) Process for 'solving' a WSP\nproblem\nspace\npart\nproblem 1\npart\nproblem 2\npart\nproblem 3\npart\nsolution 1\npart\nsolution 2\npart\nsolution 3\nsolution\nspace\nexternal design\nknowledge and problem\nexpertise used to\nexplore the 'solutions'\nexternal design\nknowledge and problem\nexpertise used to\nexplore the 'solutions'\nb) Process for 'solving' an ISP\nFIGURE 1.1: The solution processes for WSPs and ISPs\nSo this is really a book about how we tackle ISPs within the domain of\nsoftware development. We look a bit more closely at the nature of ISPs in the\nnext chapter, and in the rest of this chapter we brie\ufb02y consider some of the\nother factors that are likely to be involved in designing software.", "domains": ["Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 26", "position": 26, "chunk_type": "semantic", "token_estimate": 210}
{"text": "10: Software Design: Creating Solutions for Ill-Structured Problems\n1.2\nA bit about software\nBefore engaging with design concepts and \u2018design thinking\u2019, we need to\ngive a (brief) mention to the other word that appears in the title of this book,\nas it forms an important in\ufb02uence upon the sections and chapters that follow. In the \u2018pre-internet\u2019 era (and yes, there was such a time), software came\nin two main \ufb02avours. System software, supplied with the computer, provided\nan operating environment and applications written by users were executed\nin the context that this provided. So, for most purposes, anyone setting out\nto design an application could do so within a fairly well-bounded context\nthat was largely determined by their choice of programming language and\nthe resources provided through the particular operating system. This didn\u2019t\nnecessarily mean that the task of design was easier than it is today though,\nsince the designer might well have to design around a lack of resources rather\nthan having to choose between di\ufb00erent ones. From the early 1990s, the internet era began to extend this context. And at\nthe same time, the emergence of new ideas about how to organise and structure\nsoftware, such as classes, objects and software services required that developers\n\ufb01nd new ways of creating and organising applications. In particular, when\ndesigning an application, it might be necessary to envisage not just how it\nwould interact with other applications on its \u2018host\u2019, but also with applications\nrunning on remote computers, where these might or might not need to be\ndeveloped as part of the design task. And of course, technology has continued to evolve. Rather than being\ncon\ufb01ned to a local computer, the di\ufb00erent parts of an application might now\nbe found hosted in the cloud, tablets, phones or even domestic appliances (the\n\u2018Internet of Things\u2019). Systems might well need to be dynamically con\ufb01gured\nduring execution, and the designer may well only be responsible for part of a\nmuch more extensive system or application. And even in the pre-internet era it was recognised that the e\ufb00ort invested\nin creating software applications meant that an application might have quite\na long lifetime in use. It was also realised that an application might need\nto evolve during that lifetime in various ways, so as to meet new needs or\nchanges in its environment (Bennett & Rajlich 2000).", "domains": ["Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 27", "position": 27, "chunk_type": "semantic", "token_estimate": 392}
{"text": "12: Software Design: Creating Solutions for Ill-Structured Problems\nimplicitly re\ufb02ects this process of ongoing change. Plan-driven design strate-\ngies, as favoured in the pre-internet era, essentially assume a stable operat-\ning environment for an application, while agile ones allow designers to adapt\ntheir ideas to a changing context, which itself may well be changing (and\nbeing clari\ufb01ed) as development proceeds. However, despite this, since design\nideas usually stem from experience, technology developments are usually well\nahead. This book therefore aims to provide the reader both with conceptual tools\nfor thinking about how a design might be organised, and also with knowledge\nabout some of the strategies that might be used to produce a design. When\nthinking about software at this level, the Internet of Things (IoT), the cloud,\nthe mobile phone app, the web application, and the more \u2018conventional\u2019 ap-\nplication have much in common, although the detailed realisations might be\nquite di\ufb00erent. Hence this is not a book about software design for distributed\nsystems, web applications, or phone apps, it is a book that explains di\ufb00erent\nways of approaching the task of software design. And with that, let\u2019s get on\nwith thinking about design. . . 1.3\nWhat exactly do we mean by \u2018design\u2019? One of the complications of the English language is that a word can have\nmultiple uses, and we may often have to work out which meaning is intended\nby considering the context in which the word appears. The word design is just\nsuch a word, and in this book we are going to be concerned with exploring\na range of key concepts and ideas related to each of its meanings. So it is\nappropriate to begin by examining just what these meanings are. Firstly, we can speak of \u2018a design\u2019, using it as a noun that describes some-\nthing that forms a plan of how we intend some artifact to be constructed. Indeed, we often speak of a \u2018design plan\u2019 in this context, where the purpose\nof this is to provide a \u2018model\u2019 of how some form of \u2018product\u2019 should be con-\nstructed. This particular meaning is therefore widely associated with the idea\nof manufacturing something, whether crafted by an individual, or assembled\nin a factory (mass production)1.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 29", "position": 29, "chunk_type": "semantic", "token_estimate": 373}
{"text": "12: Indeed, we often speak of a \u2018design plan\u2019 in this context, where the purpose\nof this is to provide a \u2018model\u2019 of how some form of \u2018product\u2019 should be con-\nstructed. This particular meaning is therefore widely associated with the idea\nof manufacturing something, whether crafted by an individual, or assembled\nin a factory (mass production)1. So, we may have a design plan that provides\nguidance on how to construct a model boat (or a real one, depending on how\nambitious we are), or an item of clothing, or a car. The information provided\nin the plan about how to realise that design might be quite detailed and need\nto be followed exactly, which is probably a good idea when building a boat\nor a kit car, or it might be something of a more strategic nature that we\n1London\u2019s \u2018Great Exhibition\u2019 of 1851, which occurred at a relatively early stage of indus-\ntrial development, was essentially about design, and contained over 100,000 exhibits that\nwere essentially design artifacts\u2014admittedly of widely varying taste and usefulness.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 29", "position": 29, "chunk_type": "semantic", "token_estimate": 176}
{"text": "20: Software Design: Creating Solutions for Ill-Structured Problems\nmainly one of recording design decisions rather than helping to create new\nmodels, they do not really \ufb01t into the scope of this book. Creativity requires more than the availability of conceptual tools of course. What creativity involves is the ability to \u201cthink outside the box\u201d and to \ufb01nd\nnew and e\ufb00ective ways to meet a particular need. While this may occasionally\ninvolve coming up with a radically di\ufb00erent way of doing something, quite\noften the creative element will be realising that doing things a bit di\ufb00erently\nmight produce something that is more e\ufb00ective, robust, elegant, or some com-\nbination of such attributes. Our perception of how design is involved in producing new ideas will vary,\nand probably not always be correct. No-one is likely to deny the importance\nof using rigorous and well-proven engineering design practices when creating\nmotorway bridges, aircraft and buildings, not least because of the safety issues\nassociated with their role and use. Yet good design is important for everyday\nthings too (Norman 2002), even if the e\ufb00ects of poor design lead to noth-\ning more than the odd stubbed toe, or the irritation of having to restart a\ntransaction on our phone or tablet because some information has been \u2018lost\u2019. A second, and associated, human characteristic is that of communication\u2014\nalthough in a design context its importance may arise more from the variety\nof ways in which it is employed. Communication with the team\nCommunication usually plays a vital supporting role to creativity, since\ndeveloping any new form of artifact almost always requires us to formulate\nin some way the concept of what this artifact is to be and then to tell others\nabout our ideas. Communication has always been necessary to gain approval\nand assistance from others, whether it be for the purpose of persuading them\nto join in with building a megalithic barrow; obtaining a commission to paint a", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 37", "position": 37, "chunk_type": "semantic", "token_estimate": 324}
{"text": "Doing Design: 23\nInternal design\nmodel of how the\nfunctionality will\nbe provided\nRequirements specification of\nexternal functionality, describing\nwhat the system is to do. Model of\nexternal\nbehaviour\nSystem specification\nDesign\nModel of\ninternal\norganisation\n(structure)\nFIGURE 2.1: The interaction between requirements and design models\nwill be familiar with the wide variation of style and structure commonly\nencountered\u2014even for the programs that work!) \u2022 There is no immediate and no ultimate test of a solution to an ISP. What\nthis e\ufb00ectively observes is that we can\u2019t really be sure that what we have\nproduced meets all the identi\ufb01ed needs by means of any simple form of\ntest. As we will see, evaluation of a software design is very challenging,\nand even apparently simple comparisons between design solutions need\nto be made by using multiple criteria. \u2022 Every ISP is essentially unique. In later chapters we discuss ideas about\nhow we can reuse design experience for part-designs through forms such\nas design patterns and software product lines. But even with these, the\ndesigner needs to adapt and interpret the idea in order to apply them to\na speci\ufb01c requirement\u2014which of course is why design activities do not\nlend themselves to being automated. Taken together, these ideas are certainly at variance with the reductionist\napproaches to problem-solving widely employed in mathematics and science. Such an approach seeks to break a problem down into smaller, more manage-\nable (and solvable) elements, with an implicit assumption that there will be\na single solution that this process will converge on. In contrast, ill-structured design problems require the designer to juggle\nmany di\ufb00erent aspects of their \u2018solution\u2019 simultaneously. This then requires the\ndevelopment and use of complex models, and making a \u2018wrong\u2019 design choice", "domains": ["Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 40", "position": 40, "chunk_type": "semantic", "token_estimate": 289}
{"text": "24: Software Design: Creating Solutions for Ill-Structured Problems\nearlier in the design process may make it harder to resolve later choices. The\nconcept of orthogonality, whereby the parameters of a model are independent\nfrom each other, doesn\u2019t apply to an ISP, where factors may interact in di\ufb00er-\nent ways and the best that we can hope to do is to make trade-o\ufb00s between\nthem. Our choices between options are apt to be driven by the need to \ufb01nd a\nbalance, rather than expecting to \ufb01nd the \u2018right\u2019 outcome. So, these are the types of problems that we will be addressing in the\nfollowing chapters. Successful designing does not result simply from following\nprescribed processes or reusing structures that have worked for others. As we\nwill see, these things might well be useful elements in the design process, or in\nlearning about it, but even then, their use will probably involve some degree\nof adaptation. 2.3\nWhat does a designer do? So, what exactly is involved in designing something? A good starting point\nis to consider the words of a pioneering \u2018design methodologist\u2019, J. Christopher\nJones, taken from his classic work, Design Methods: Seeds of Human Futures\n(1970). \u201cThe fundamental problem is that designers are obliged to use\ncurrent information to predict a future state that will not come\nabout unless their predictions are correct. The \ufb01nal outcome of\ndesigning has to be assumed before the means of achieving it can\nbe explored; the designers have to work backwards in time from an\nassumed e\ufb00ect upon the world to the beginning of a chain of events\nthat will bring the e\ufb00ect about.\u201d\nScience\nseeks\nto\nreduce\ncomplexity\nThis statement describes an approach to\ntackling an ISP that is radically di\ufb00erent from\nthe reductionist practices of \u2018scienti\ufb01c method\u2019\ncommonly used with WSPs, and involving sub-\ndividing a complex problem into simpler ones. So in its way the statement from Jones is both\nchallenging and unsettling\u2014we are asked to pos-\ntulate the form of the desired end result in or-\nder to try to achieve it, rather than to proceed\nthrough a process of deduction and analysis to\ndetermine what its form should be. One reason for this di\ufb00erence of philosophy is\nbecause science is largely concerned with study-\ning things as they are, using observation and ex-\nperiment as the means of testing ideas. A rather", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 41", "position": 41, "chunk_type": "semantic", "token_estimate": 394}
{"text": "Doing Design: 29\nKey take-home points about designing\nThis second chapter has largely focused on how design thinking is applied\nto designing new things. Designing is creative. The aim of designing is to create something that\ndoes not already exist. This requires the designer to predict a (desired)\noutcome and explore ways of bringing this about. Design is used to address ill-structured problems (ISPs). This means\nthat there will be a large number of possible \u2018solutions\u2019 (designs) for a\ngiven problem, and that the process of designing has no \u2018stopping rule\u2019\nthat tells the designer that the current state of their design solution is\ngood enough. As an added complication, there are no simple measures\nthat can be used to assess the feasibility of a design plan. Designers solve problems di\ufb00erently to scientists. Scientists commonly\naddress problems by following a process of reductionism, seeking to re-\nsolve a complex problem into separate simpler ones that can be more\nreadily solved analytically. Designing involves exploring all, or most, of\nthe characteristics of the \u2018design model\u2019 at once, rather than being able\nto consider them separately.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 46", "position": 46, "chunk_type": "semantic", "token_estimate": 184}
{"text": "34: Software Design: Creating Solutions for Ill-Structured Problems\n3.3\nModelling and making design choices\nWhen describing what designing is about, we might say that our aim is to\nproduce a \u2018design solution\u2019 that will meet a speci\ufb01c need. In computing, that\nneed will typically be documented in some form of requirements speci\ufb01cation. This may be little more than a few jotted notes or sketches, through to a\nvery detailed formal document (the speci\ufb01cation for the CCC system comes\nsomewhere between those). It is then the task of the designer or design team\nto formulate a way of meeting that need by creating some form of design\nmodel for the proposed solution. The act of designing something usually involves identifying suitable op-\ntions for the key features of our \u2018design solution\u2019 and then evaluating the\nconsequences of adopting each of them. For example, one of our \ufb01rst deci-\nsions may well be to choose an appropriate architectural style for our ap-\nplication. (We will discuss the idea of system architecture and architectural\nstyle more fully in later chapters; for the moment we can just consider the\narchitecture of an application as being the types of software module we will\nemploy.) So, for a particular application, we might consider organising it using\nan object-oriented form, based upon a set of classes and objects, or organising\nit around a central database. Both approaches will have their merits: using\nobjects may mean that any future evolution of our application that is an-\nticipated will be easier to achieve; while using a database may mean that\nthe application can be delivered to the end-users more quickly, although fu-\nture changes may require more work. And here we can see one aspect of the\nproblem of choice, in that our reasons for preferring one design solution over\nanother may well be based upon how we rank quite di\ufb00erent criteria, with\nthe options also incurring quite di\ufb00erent degrees and forms of technical debt. Making a choice between the di\ufb00erent design options\nmay also be based upon criteria that are relatively ill-\nde\ufb01ned.", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 51", "position": 51, "chunk_type": "semantic", "token_estimate": 345}
{"text": "Managing the Design Process: 35\nThroughout this process though, the designer needs to keep in mind that\nthe ultimate criterion has to be \ufb01tness for purpose. It is not that the other\nfactors don\u2019t matter, they certainly do, but they need to be subordinate to\nthe need to produce a system that does the required job. This goes for most\nartifacts of course\u2014however much we might like the added \u201cbells and whistles\u201d\nof a particular model of car or of a speci\ufb01c hi-\ufb01ampli\ufb01er\u2014pragmatism usually\nmeans that our ultimate choice will need to be made on the basis that it can\nbe relied upon to do the job that we need it to do, and that it will do so at a\nreasonable cost. Using these criteria to help evaluate possible options can be made easier\nif the designer produces some form of design model that can be used to help\nmanage the cognitive processes involved. The nature of an ISP means that\nwe need to postulate a design solution and then re\ufb02ect on whether or not\nit will do the job we want, and how well it will do it. Having some form of\nabstract design model, possibly realised in the form of diagrams and text, can\nhelp with managing this process of re\ufb02ection, perhaps by using it to evaluate\ndi\ufb00erent scenarios of use or change via some form of \u2018design walk-through\u2019. And \ufb01nally, the idea of \ufb01tness for purpose isn\u2019t some abstract concept, it\nneeds to be given concrete values that can be used to assess the terms above. We need to have a clear picture of what we expect of something that \u2018should\nwork\u2019 and of what we mean by \u2018as well as possible\u2019. If we are building something\nthat is safety-critical (that is, lives will be at risk if it fails), then we should\nhave some quite de\ufb01nite ideas about these terms. This is less so where the\nconcept of \u2018works\u2019 might be less precise (such as an application that depends\nupon some form of image recognition), where we might be willing to accept a\nless than complete level of reliability, at least in early versions. This is maybe where some reverse thinking may help.", "domains": ["Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 52", "position": 52, "chunk_type": "semantic", "token_estimate": 368}
{"text": "Managing the Design Process: This is less so where the\nconcept of \u2018works\u2019 might be less precise (such as an application that depends\nupon some form of image recognition), where we might be willing to accept a\nless than complete level of reliability, at least in early versions. This is maybe where some reverse thinking may help. Rather than trying\nto de\ufb01ne \u2018should work\u2019, we might try to consider what sort of shortfalls in\nfunctionality or performance might still mean that we consider that the system\n\u2018works\u2019, even if it is not doing so as well as we wish. For the example of image\nrecognition, we might be willing to accept that our application may sometimes\nbe unable to recognise an image, or fail to get the right match, particularly\nif such a failure can be easily identi\ufb01ed by the user. On the other hand, an\napplication where the outputs are occasionally badly in error in a way that\ncannot easily be recognised by the user is likely to be considered unacceptable,\neven if this occurs very infrequently. 3.4\nRecording design decisions\nSomething that is often overlooked when a software application is devel-\noped is the value that can be derived from noting why particular design choices\nwere made. While the rationale for these may have been obvious to the design-", "domains": ["Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 52", "position": 52, "chunk_type": "semantic", "token_estimate": 221}
{"text": "38: Software Design: Creating Solutions for Ill-Structured Problems\nRequirements\nelicitation\nRequirements\nelicitation\nRequirements\nspecification\nRequirements\nspecification\nTesting\nTesting\nCoding\nCoding\nDesign\nDesign\nInstallation\nInstallation\nFIGURE 3.1: A waterfall model of software development\nas understanding of its role emerges, leading to the evolution of more \u2018agile\u2019\napproaches as we will see later. So, while a design model may help the designer cope with the cognitive\nchallenges of designing complex things, it also plays an important role in\nsharing ideas about the design with others. The model may be little more\nthan a list (as in the example of moving house), or it may be much more\ndetailed, as in the \u2018blueprint\u2019 traditionally produced for mechanical design. The level of detail will depend upon how much freedom can be given to those\nresponsible for fabricating the design ideas. For mechanical engineering where\nend-products are not easily modi\ufb01ed or adjusted, the degree of tolerance that\ncan be permitted is important, so those responsible for fabrication activities\nwill need to follow the design plan very closely. For house-movers and software\nengineers, whose processes can be modi\ufb01ed rather more easily, the plan can be\nmuch less detailed, to the point that it can evolve while the implementation\ntask is progressing. This is a point that we will return to, as it is one of the\nways in which too close an adherence to traditional design thinking is often\nnot appropriate for the software domain. So we can conclude that communication with those who are responsible for\nfabricating the solution is likely to be an important part of a designer\u2019s role. In addition though, there is also a need for communication with those who are\ncommissioning the design. Their requirements might be very tightly speci\ufb01ed\nand the description of these may focus upon such factors as their market and\nother constraints (\u201ca table for use in village halls, cheap to fabricate, durable,\neasily cleaned, being capable of being safely stacked, and being light enough", "domains": ["Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 55", "position": 55, "chunk_type": "semantic", "token_estimate": 328}
{"text": "Managing the Design Process: 39\nfor one person to move it easily\u201d). Or they may be rather broad and sweeping\n(the medieval baron who wants \u201ca castle bigger and grander than the one\nowned by their rival across the valley\u201d). So here we see another demand upon the designer and their skill-set. The\ndesigner needs to have a good understanding of the problem domain (we can\nassume that in the examples of the previous paragraph the designer would\nknow about tables or castles) and also of the materials that they need to\nwork with. The great Victorian engineers like Isambard Kingdom Brunel were\nprepared to design railways, ships, bridges, railway stations, and many other\nnecessary items as part of their portfolio. However, since that time design ac-\ntivities have tended to become more specialised, partly because of this need for\ndeeper knowledge about the context of a design. So an aeronautical engineer\nis unlikely to be employed to design roads. One thing Brunel didn\u2019t\ndesign was software! In some ways though, software designers \ufb01nd\nthemselves more in the situation of needing to\ncreate a wide range of applications, more as the\nVictorian engineers did (but fortunately with-\nout the need to wear tall stove-pipe hats). The\nuse of software is so ubiquitous and its form so\nadaptable that over-specialisation is rarely an\noption. Admittedly a specialist in (say) database\nsystems might (or almost certainly should) hes-\nitate to take on the task of designing a real-time\ncommand and control system, but in principle\nat least, one person could possess the necessary\nrange of skills for both. So the acquisition of domain knowledge plays\na particularly important role for software design. Some of this may be obtained from the cus-\ntomer\u2019s speci\ufb01cation, but as we will see later,\nthis may well fail to identify key elements of the\n\u2018tacit\u2019 knowledge that are familiar to everyone\nworking in the domain\u2014but that may not necessarily be familiar to the soft-\nware designers. If we think about designing software rather than castles, and particularly\nabout designing software applications that will be implemented by a large\nteam of people, what sort of thing are they likely to want to know from the\ndesigner(s)?", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 56", "position": 56, "chunk_type": "semantic", "token_estimate": 368}
{"text": "40: Software Design: Creating Solutions for Ill-Structured Problems\n\u2022 how the elements of the application will be packaged and organised;\n\u2022 how the elements of the application will interact, including any depen-\ndencies (coupling) and causal (event-driven) links;\n\u2022 how the application will interface to, and interact with, its environment\n(users, other software components such as browsers, etc.). Mostly these are concerned with the form or structure of the application, but\nsome are also concerned with its behaviour, both overall and in detail. So the\noutcomes of the design process (the design model) is likely to be concerned\nwith the way that the elements are structured, the functions that the system\nwill perform, and the way that di\ufb00erent elements will behave, individually and\ncollectively. Whew! Key take-home points about the design process\nIn this chapter we have considered the outcomes of the process of designing\nsoftware, and addressed some ideas about what we might consider to be a\n\u2018good\u2019 design. Abstraction is an important design tool. A designer needs to focus on\nthe core issues that are relevant to a solution, and to successfully manage\ntheir ideas about this, needs to be able to \u2018discard\u2019 consideration of other\nissues that are not relevant to this. Fitness for purpose should be the ultimate criterion. While a good\ndesign solution may exhibit many qualities, the ultimate need is that\nit should work and do what is required as well as possible. Design models are a key product of designing. Design as a process\n(verb) leads to design as a product (noun). In its most simple form,\nwhere a designer also implements their design, the design model may\nsimply reside in the designer\u2019s head, but beyond that it needs to be\nmore formally recorded in whatever manner is most appropriate. The rationale for design decisions should be recorded. While this may\nnot be of immediate value to the original application development team,\nit will help others to ensure that future modi\ufb01cations and extensions will\npreserve the integrity of the original design structures, and so reduce the\ntechnical debt during later evolution of the system. Design solutions need to be shared with others. While communication\nis particularly important where manufacturing forms a part of develop-\nment, software applications are often created by teams of developers,", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 57", "position": 57, "chunk_type": "semantic", "token_estimate": 381}
{"text": "Chapter 4: Design Knowledge\n4.1\nWhat do expert software designers do? ..........................\n43\n4.2\nSome software design principles ..................................\n49\n4.2.1\nFitness for purpose ......................................\n49\n4.2.2\nSeparation of concerns ...................................\n50\n4.2.3\nMinimum coupling .......................................\n51\n4.2.4\nMaximum cohesion ......................................\n52\n4.2.5\nInformation hiding .......................................\n52\n4.3\nThe evolution of design ideas ....................................\n53\n4.4\nThe nature of expert design knowledge ..........................\n55\nKey take-home points about design knowledge ..................\n57\nThe previous chapters have spelt out some of the challenges associated with\ndesign in general, as well as with designing software, and from this point we\nfocus upon the latter task. Clearly, there are people who can very ably and\nsuccessfully juggle the many factors involved in designing software, and in this\nchapter we look at what it is that characterises expert designers, the designs\nthat they produce, and the nature of their expert knowledge about designing. 4.1\nWhat do expert software designers do? When learning any skill, it is useful to analyse what the experts do (and why\nthey do things as they do). Studying the experts might (will) not instantly\nturn anyone into a tournament-winning tennis player, or an award-winning\nartist, but it will almost certainly be a good way to improve one\u2019s skills. In their witty little book Software Design Decoded: 66 Ways Experts Think,\nMarian Petre and Andr\u00e9 van der Hoek (2016) provide just such a study of\nsoftware designers. Their book brie\ufb02y illustrates and explains some of the\npractices that expert software designers are observed to employ. Of course\nthis is only half of the story. It isn\u2019t just what an expert does that matters, it\nis what they don\u2019t do that may be just as important. (And particularly, the\nsort of things that novices will probably do, and that experts will avoid!) 43", "domains": ["Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 60", "position": 60, "chunk_type": "semantic", "token_estimate": 301}
{"text": "Design Knowledge: 45\nSimulating the \u2018execution\u2019 of a design model in one\u2019s head is a concept\nfamiliar to programmers, who often mentally trace through the execution of\ncode as a check on the formulation of such constructs as conditional expres-\nsions. Arguably this is something that is particular to designing software\u2014\nwhereas such activities as note-making and reuse are design activities widely\nobserved in other domains too. As we will see later, the idea of \u2018labelling\u2019\npreviously used plans is one that also resonates with the idea of the design\npattern, described in Chapter 15. An observational study by Bill Curtis and his co-workers examined the\ncharacteristics of a set of designers who had been identi\ufb01ed by their organi-\nsations as being particularly successful (Curtis, Krasner & Iscoe 1988). They\nobserved that the number of exceptional designers identi\ufb01ed in this way was\nsmall\u2014and hence they were usually treated as an important resource within\nan organisation. Interestingly though, the outstanding designers were often\nnot considered to possess particularly good programming skills, suggesting\nthat programming and design may call upon di\ufb00erent abilities in an individ-\nual. Table 4.2 summarises three key \ufb01ndings from this study. TABLE 4.2: Key \ufb01ndings from the study by Curtis et al. Observed Behaviour\nPurpose\nFamiliarity with the application do-\nmain. Making it possible to map between prob-\nlem characteristics and solution structures\nwith ease. Skill in communicating technical vi-\nsion to other project members. Much of the design work was often accom-\nplished while interacting with others. Identi\ufb01cation with project perfor-\nmance. Achievement of technical progress\u2014the de-\nsigner might even take on signi\ufb01cant man-\nagement responsibilities to ensure this. In studying the ways that designers make decisions, Visser & Hoc (1990)\nused the term opportunistic to describe the way that an expert designer would\nrevise their strategy for \u2018solving\u2019 a design problem. When working opportunis-\ntically, although a designer may have chosen a strategy for how they are going\nto develop their design ideas such as \u2018top-down\u2019 (systematically decomposing\nthe solution elements into smaller actions), they may still deviate from the\nstrategy to either:\n\u2022 postpone a decision, perhaps because the information needed to make\nthis has not yet been resolved; or\n\u2022 process information that is readily at hand, and can be used to de\ufb01ne\ndesign elements in anticipation of the way that the design will evolve.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 62", "position": 62, "chunk_type": "semantic", "token_estimate": 391}
{"text": "Design Knowledge: In studying the ways that designers make decisions, Visser & Hoc (1990)\nused the term opportunistic to describe the way that an expert designer would\nrevise their strategy for \u2018solving\u2019 a design problem. When working opportunis-\ntically, although a designer may have chosen a strategy for how they are going\nto develop their design ideas such as \u2018top-down\u2019 (systematically decomposing\nthe solution elements into smaller actions), they may still deviate from the\nstrategy to either:\n\u2022 postpone a decision, perhaps because the information needed to make\nthis has not yet been resolved; or\n\u2022 process information that is readily at hand, and can be used to de\ufb01ne\ndesign elements in anticipation of the way that the design will evolve. The term \u2018opportunistic\u2019 was originally introduced by Hayes-Roth & Hayes-\nRoth (1979) in the context of planning (an activity which can be considered\nas a form of design, as we noted earlier). It stems from the ill-structured", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 62", "position": 62, "chunk_type": "semantic", "token_estimate": 158}
{"text": "46: Software Design: Creating Solutions for Ill-Structured Problems\nSkill in communicating technical vision\naspects of design , in that, as a solution to a problem (i.e. a design model)\nemerges, and creates a correspondingly better understanding of the problem,\nthis improved knowledge may well lead the designer to modify their strategy\nfor solving the problem. So this can also be considered as a form of feed-back\nmechanism that occurs during the design process. What else drives such opportunistic behaviour? Well, Akin (1990) has sug-\ngested that there are three \u2018classic\u2019 actions that occur during creative activities\nsuch as design. These are:\n1. The recognition step, sometimes termed as the \u2018Aha!\u2019 response. This\narises when the designer recognises a solution that has been there all\nalong. As a creative act, it typically occurs when a designer realises that\nthere is a simpler way of doing something than the model that they have\nbeen employing. 2. The problem restructuring step, in which a change in the way that a\nproblem or design solution is being described or modelled leads to a\nmajor advance towards \ufb01nding a design solution. In many ways this is\nsimilar to the idea of refactoring that we will discuss later in the con-\ntext of agile design. As a simple example, a designer might be planning\nto store some of the key information for an application in a relational\ndatabase, but then realises that managing the information within a set\nof objects will greatly simplify all of the associated operations. 3. The development of procedural knowledge about how a particular type of\nproblem is best addressed, allowing the designer to perform many cre-\native acts within a domain. One way that this is manifested in software\nengineering is through the use of patterns to provide reusable solution\nmodels.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 63", "position": 63, "chunk_type": "semantic", "token_estimate": 300}
{"text": "48: Software Design: Creating Solutions for Ill-Structured Problems\nfuture\u2019, even though (or perhaps because) their vision of what that future may\nbe is less clear than that of the expert. Experts externalise their thoughts. PvdH #24\nWhat this really means is that experts sketch\u2014on paper, whiteboards or\nany other readily available surface (paper napkins, backs of envelopes etc.). While the sketches may well be simple \u2018box and line\u2019 diagrams, sketching can\nalso involve making lists, drawing tables, or a mix of the three. Externalising\ntheir ideas in this way helps the expert think them through (including use of\n\u2018mental execution\u2019 at a relatively abstract level), and adapt them. Inexperi-\nenced designers appear to be more reluctant to explore di\ufb00erent ideas once\nthey have a design model that they think looks feasible. Experts externalise their thoughts\nExperts invent notations. PvdH #28\nThis partly relates to the previous item. Essentially, what this says is that\nexperts are not constrained to using particular notations. Part of this book\nis about the variety of notations used to describe software models, and about\ntheir syntax and semantics. However, while these may be (and are) useful\nfor documenting and sharing design models, they are not always so useful\nfor developing them, and over-attention to syntax may constrain thinking. Design sketches can take all sorts of forms (and do so) and the less experienced\ndesigner should not feel bound to keep too closely to the syntax of established\nnotations, even when following a plan-based design strategy. In the rest of this chapter we brie\ufb02y look at the sort of experiences and\nmechanisms that help build up design expertise. One thing that this book\nde\ufb01nitely can\u2019t do is teach anyone how to be a great designer. That only", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 65", "position": 65, "chunk_type": "semantic", "token_estimate": 290}
{"text": "50: Software Design: Creating Solutions for Ill-Structured Problems\nNeedless to say, this is an easier goal to specify than to achieve. The nature\nof ISPs makes it di\ufb03cult to obtain a de\ufb01nitive speci\ufb01cation of purpose or a\ntest that demonstrates that it is achieved. However, what this principle really\nmeans is that the designer should not get diverted into providing unnecessary\n\u2018bells and whistles\u2019 and should focus upon the essence of what a piece of\nsoftware should do. (Remember too that \u201cexperts prefer simple solutions\u201d.) The wonderful pliability of software makes it easy to add features that are not\nreally necessary, and the temptation to do so needs to be avoided. So, what\nthis principle gives us is a \u2018litmus test\u2019 for assessing a design model, in that we\ncan look at each of its features and structures and ask if it is really essential\nand what it contributes to this principle. If we ask why this should be so, the answer is very simple. Anything\nadditional to what is needed for the core purpose of the software adds potential\ntechnical debt by incurring unnecessary complexity. 4.2.2\nSeparation of concerns\nMost of us are familiar with the concept of the Swiss Army Knife as a\ntool that can be used to do many things (almost unlimited things if we have\na really grand model). However, although a single knife can be used to do\nmany things, each component of the knife has been designed to do one thing,\nwhether it be cutting, \ufb01ling, sawing etc. And this principle of having each\nelement \u201cdo one thing and do it well\u201d also applies to the design of software. What this means for software is that a design model should clearly sepa-\nrate di\ufb00erent elements. Input, output, data storage, handling user interaction\netc. are all quite distinct tasks. And this is where the \ufb02exibility and pliability\nof software (Brooks 1987) can tempt the designer to cut corners and com-\nbine di\ufb00erent things in the elements of the model. When writing software in\nthis way, we refer to the end result as \u201cspaghetti code\u201d, implying complexity\n(rather than edibility) and hence longer-term problems of technical debt, to\nsay nothing of shorter-term problems with testing. The same issues are true\nfor design\u2014clear separation of concerns can greatly assist with later changes\nand updates to an application, as well as making for more modular testing.", "domains": ["Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 67", "position": 67, "chunk_type": "semantic", "token_estimate": 399}
{"text": "50: When writing software in\nthis way, we refer to the end result as \u201cspaghetti code\u201d, implying complexity\n(rather than edibility) and hence longer-term problems of technical debt, to\nsay nothing of shorter-term problems with testing. The same issues are true\nfor design\u2014clear separation of concerns can greatly assist with later changes\nand updates to an application, as well as making for more modular testing. Separation of concerns", "domains": ["Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 67", "position": 67, "chunk_type": "semantic", "token_estimate": 68}
{"text": "Design Knowledge: 51\nSeparation of concerns in the CCC\nIn the context of the CCC we can identify some obvious \u2018concerns\u2019\nthat should be treated as distinct elements. These include the following\n(note that the list is not meant to be exhaustive). \u2022 knowledge about the cars\n\u2022 knowledge about bookings\n\u2022 customer interaction\n\u2022 billing for car usage\n\u2022 \ufb01nding available cars that are within a given area\nThese all interact to provide the overall functionality, but represent\nquite di\ufb00erent facets of the design model. 4.2.3\nMinimum coupling\nWhen constructing anything but the smallest software applications, we\nneed to adopt some form of modularity for its organisation, whether the mod-\nules concerned are methods (sub-programs), classes, processes or some other\nform. Indeed, the choice of these may well relate to the previous principle\nregarding the separation of concerns. And since these modules are part of\nthe whole, they need to interact and share information in some manner. This\ninter-module dependency is usually termed coupling, a concept that was \ufb01rst\nrecognised in the early 1970s when the modules concerned were most likely to\nbe sub-programs (Stevens, Myers & Constantine 1974). And as new forms of\nmodular structure for software have emerged, it is one that has continued to\nbe relevant. Coupling can take a range of forms. For example, module A may make use\nof operations, data or data types that are provided by module B. And it can\noccur in di\ufb00erent ways too. Module A may invoke methods in Module B, or\nobtain values of variables it contains, or even inherit properties from it. The\npresence of any of these forms will create a dependency of A upon B, and\nwhat it particularly means is that if any changes are made to module B, they\nmay potentially a\ufb00ect module A. Some coupling is of course necessary for the\nconstruction of any software system\u2014the point is that this should be as much\nas is needed and no more\u2014since unnecessary coupling can add to technical\ndebt, complicating future evolution of an application. Excessive or unnecessary coupling may well indicate a poor choice of mod-\nular structure. If the concerns are well separated, the dependency of a module\nupon other modules should be minimal, and in particular, should not involve\nrequiring knowledge about how the other modules perform their tasks.", "domains": ["Design Principles", "Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 68", "position": 68, "chunk_type": "semantic", "token_estimate": 388}
{"text": "52: Software Design: Creating Solutions for Ill-Structured Problems\n4.2.4\nMaximum cohesion\nThe concept of cohesion is concerned with intra-module relationships. The\nissue here is that the elements grouped within a module should all share the\ncharacteristic of being related to the purpose of the module. For example, if\nwe have a class that consists of a data structure representing some part of an\napplication, all of the other elements of the class should be concerned with\nupdating and reporting on that data structure. Cohesion is conceptually fairly\nstraightforward, but can be quite di\ufb03cult to assess. 4.2.5\nInformation hiding\nThis principle is also related to the way that modularity is achieved within\nan application, but incorporates additional notions about how information\nshould be organised and stored within an application. It is particularly rele-\nvant to thinking about objects and in this context it is often referred to as\nencapsulation. The basic concept is concerned with knowledge about the detailed form\nin which data is represented and stored. The aim is to keep this knowledge\nlocal to a module, so that it is not visible outside of a particular module\n(Parnas 1972, Parnas 1979). Like cohesion it is concerned with intra-module\nproperties, and its use requires that a module should provide a number of\nmethods that can be used to access the data, where these are used to \u2018hide\u2019\nthe way that the data is organised internally. Again, the motivation for this\nis to enable and simplify subsequent changes to an application. Information hiding in the CCC\nThere are several items of information employed in the CCC software\nthat should clearly be encapsulated (hidden) so that they cannot be\ndirectly modi\ufb01ed or accessed by other objects. These include:\n\u2022 details that describe the full status of a speci\ufb01c car\u2014not just\navailability but also such things as distance covered, its current\nposition etc. ;\n\u2022 the way in which information about the set of cars is organised,\nso that objects using this just refer to a particular car without\nknowing how that information is organised internally;\n\u2022 information relating to customer accounts.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 69", "position": 69, "chunk_type": "semantic", "token_estimate": 349}
{"text": "Design Knowledge: 53\n4.3\nThe evolution of design ideas\nGiven that we have some ideas about the characteristics of an e\ufb00ective\nand even great designer, together with some ideas about what they are trying\nto achieve, this then raises the question of what knowledge does a software\ndesigner need to acquire? Long before software was thought of, people probably began learning their\ndesign skills primarily through some form of \u2018apprenticeship\u2019, and many would\nthen continue to learn from sharing their experiences with their peers. There\nis still quite a strong element of this in many creative disciplines, and indeed,\nthe concept of the \u2018design studio\u2019 has been successfully adapted for teaching\nabout software development (Tomayko 1996). We can reasonably assume that the craftsmen who designed the pyra-\nmids of Egypt and those who created Europe\u2019s medieval cathedrals, will have\nexchanged ideas with, and learned from, their peers. However, each resulting\nbuilding was a single unique creation, and while new ideas did emerge, such as\nthe use of ribbed vaulting or \ufb02ying buttresses, these were more likely to relate\nto the design product rather than to the process of learning about designing. It was only with the emergence of what we would now consider as engineering\npractices that new contributions to the way that people learn about designing\nreally began to occur. Two of these are worth noting here as being particularly\nrelevant to software design. 1. Knowledge gained from scienti\ufb01c research. As the properties of materials\nbecame better understood, and the means of predicting their behaviour\nbecame more re\ufb01ned and dependable, so designers could utilise such\nknowledge to help create new structures. It is interesting to note that\nin a period when the distinctions between the professions were less rigid\n(and probably not even recognised) Sir Christopher Wren, the designer\nof some of London\u2019s most iconic churches, including St Paul\u2019s Cathedral,\nbegan his career as an astronomer and was regarded as an outstanding\nmathematician and geometer. 2. The concept of reuse. While ideas were certainly reused before the indus-\ntrial revolution, the idea of fabricating structures by using \u2018standardised\u2019\ncomponents was not. The availability of reusable components both ex-\ntends and constrains a designer\u2019s repertoire. Their use may reduce the\ndesign task as well as o\ufb00ering speedier development and time to market\nand reducing costs\u2014while at the same time introducing new trade-o\ufb00s\ninto the design process.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 70", "position": 70, "chunk_type": "semantic", "token_estimate": 396}
{"text": "Design Knowledge: The availability of reusable components both ex-\ntends and constrains a designer\u2019s repertoire. Their use may reduce the\ndesign task as well as o\ufb00ering speedier development and time to market\nand reducing costs\u2014while at the same time introducing new trade-o\ufb00s\ninto the design process. In particular, the opportunity to reuse things\nraises the question as to when it would be better to \u2018buy-in\u2019 existing\nelements and adapt one\u2019s design around these, which introduces a de-\npendency upon a supplier, or to adopt a policy of \u2018build-your-own\u2019? There is also the related question of how to document and catalogue", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 70", "position": 70, "chunk_type": "semantic", "token_estimate": 100}
{"text": "54: They also require an element of formal\nmathematical understanding for their application. On the other hand, reuse\nlends itself to a more compositional way of thinking, in which we build up a\nsolution from parts, and hence is intrinsically more suited for use with ISPs. It certainly \ufb01ts better with the idea of an opportunistic design strategy, as\nused by agile approaches to software development, and as such, is probably\nmuch more widely applicable to software development. Finally, a useful concept \ufb01rst posited by Herb Simon is that of satis\ufb01cing. This can be summarised as \u201cseeking a satisfactory solution to a problem rather\nthan the optimal one\u201d (van Vliet & Tang 2016). Satis\ufb01cing is often observed\nas occurring during design activities and forms an important decision-making\nstrategy. It may be employed for a variety of reasons: a designer may have only\nlimited time to work on an issue; there is a lack of information needed to make\nan optimal decision; or the designer is trying to simplify a cognitively complex\nissue. In essence, the use of satis\ufb01cing often involves taking the \ufb01rst solution", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 71", "position": 71, "chunk_type": "semantic", "token_estimate": 184}
{"text": "Design Knowledge: 57\nabout designing software largely falls into the categories of observations and\nrules of thumb. So, given that design knowledge is di\ufb03cult to codify, and its quality is\nmixed, this emphasises why expert knowledge about how to design software\nsystems can be di\ufb03cult to share with others. From the 1970s onwards, various\nmechanisms have been developed to assist with this, starting with plan-driven\ndesign methods, and going on through such ideas as software architecture, ag-\nile methods and design patterns. In essence, these provide ways of translating\nexpert design schemas into some \u2018rules\u2019 that can be used when designing\nsoftware intended to meet speci\ufb01c purposes. While they may be relatively\ncrude, relative to the subtlety of the cognitive knowledge involved, they have\nnonetheless shown themselves to be useful, and we will be looking more closely\nat them in Parts II and III of this book. Key take-home points about design knowledge\nThis chapter has examined some of the characteristics of expert software\ndesigners and of the ways that they design software systems. Experienced designers use abstract mental models. An important role\nfor these models is to allow the designer to mentally \u2018simulate\u2019 the way\nthat a system will behave in particular conditions. This characteris-\ntic is one that is largely peculiar to software design, since the \u2018prod-\nuct+process\u2019 nature of software forms one of its distinctive features. Designers often work opportunistically. Rather than following some\n\ufb01xed set of procedures to develop their design model (as advocated\nby plan-driven design approaches), experienced designers will employ\na general strategy but adapt it as their understanding of the problem\n(and solution) evolves. Designers sketch their ideas. Design ideas are \ufb02uid and experts like to\nconcentrate on abstractions which can easily be revised to allow ready\nexploration of their models for a solution. Using informal notations to\naid the development of a design model helps with this by avoiding the\nconstraints of a \ufb01xed syntax and semantics. Design principles embody accumulated design experience and provide a set\nof criteria for assessing the quality of a design model. Designers reuse. This may occur at the abstract level, where designers reuse\npart-solutions that they previously found to be successful, and also at\nthe level of reusing actual software components that are known to work", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 74", "position": 74, "chunk_type": "semantic", "token_estimate": 380}
{"text": "60: Software Design: Creating Solutions for Ill-Structured Problems\nknowledge that they can provide, it is important to understand the forms of\nmeasure commonly used in empirical studies. Many of our ideas about what constitutes \u2018measurement\u2019 stem from dis-\nciplines such as physics that involve measuring the properties of real-world\nphenomena. An important feature of subjects such as physics (as well as most\nother sciences and technologies) is that they are founded upon a positivist phi-\nlosophy, embodying the assumption that there are general rules that apply to\nthe phenomena being studied. In the physical world that philosophy is com-\nmonly manifested in such assumptions as \u201call electrons have the same mass\nand charge\u201d1. A further assumption is that the \u2018observer\u2019 who is performing\nthe measurements has no in\ufb02uence upon the values obtained. Both of these assumptions present a challenge when we seek to study\nhuman-centric activities such as designing software. For practical purposes we\nhave to adopt a positivist philosophy, while accepting that this is probably\nsomething of an approximation given that people have di\ufb00erent abilities. And\nwhen designing our studies, we have to plan them so as to minimise the extent\nto which bias can arise from the involvement of the observer, particularly\nwhere any observations may involve an element of interpretation. 5.1.1\nMeasuring physical phenomena\nIn the physics laboratory, a desirable form of experiment is one where the\nobserver has as little to do with the measurement process as possible. If the\nmeasurement can be performed by instruments that (say) count the number\nof electrons hitting a \u2018target\u2019, then although measurement errors cannot be\nwholly eliminated, they can usually be kept to a very low level. Often however, it isn\u2019t possible to avoid having the involvement of an\nobserver when making measurements. For example, analysing traces that show\nhow much a beam of electrons is de\ufb02ected by a magnetic \ufb01eld. For this, some\nerrors are likely to occur because the observer didn\u2019t have their head in quite\nthe right position to read the relevant point on the scale, or simply made a\nsmall error in identifying or recording what the value should be. Scientists are accustomed to this form of error and its properties.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 77", "position": 77, "chunk_type": "semantic", "token_estimate": 366}
{"text": "60: For this, some\nerrors are likely to occur because the observer didn\u2019t have their head in quite\nthe right position to read the relevant point on the scale, or simply made a\nsmall error in identifying or recording what the value should be. Scientists are accustomed to this form of error and its properties. For one\nthing it is expected that over a large number of measurements there will\nbe roughly as many \u2018over-measures\u2019 as \u2018under-measures\u2019, and that errors of\nthis type will have a normal distribution, based on the well-known bell-shaped\ncurve. Experimenters will be expected to make an assessment of the magnitude\nof such errors and to report them. While this will represent a (usually small)\ndegree of uncertainty about the measured value, the important thing is that\nthis uncertainty essentially stems from the limitations of the measurement\ninstruments. Taken together with the original assumption that there is a single\n1The opposite philosophy is termed an interpretivist one. Interpretivists view each mea-\nsurement as being unique, so that it can only be understood in terms of its speci\ufb01c context. While this perspective is one that is adopted by many social scientists, research into software\nengineering practices usually adopts a positivist approach.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 77", "position": 77, "chunk_type": "semantic", "token_estimate": 204}
{"text": "62: Software Design: Creating Solutions for Ill-Structured Problems\nthe two groups. This is because humans are complex and di\ufb00erent and\nwhile everyone in the trial will have been selected because they have\nsome condition that could potentially be a\ufb00ected by the treatment, this\nmay occur in di\ufb00erent degrees, and they may also have other conditions,\npossibly unknown, that could a\ufb00ect the outcomes. Some people in the experimental group may therefore respond well to\nthe treatment, but others less so, or even negatively. As a result the mea-\nsured outcomes will vary between participants, and to a much greater\ndegree than would arise from measurement errors alone. So it can\u2019t be assumed that any measurements across each group will be\nspread in a normal distribution. This makes it necessary to use reason-\nably large groups of participants for such studies, together with statis-\ntical tests to determine whether or not the spread of results arises from\nthe treatment, or could have been produced at random (that is, with\nthe treatment not being the cause of any observed e\ufb00ects). \u2022 The second category contains those studies where the treatment involves\nthe participants in performing some form of activity. This is of course\nwhat arises in software development, where the activities may involve\nusing a particular test strategy to debug a block of code, or revising a\ndesign that was produced using a speci\ufb01c technique. The use of RCTs is\nclearly impractical for this type of study, since participants can hardly\nbe unaware of which group they are in. Although experiments and quasi-\nexperiments2 can sometimes be used to make comparisons, it may well\nbe di\ufb03cult to identify a suitable form of activity for the control group. So in order to study such activities we often end up using observational\nforms of study. (The study of designer behaviour by Adelson & Soloway\n(1985) described in Chapter 4 is an example of an observational study.) Since everyone taking part in such a study comes along\nwith their own experience and opinions, together with their\nnatural ability, it can be expected that there will again be\nsigni\ufb01cant variation in the values for any outcome measure-\nments of the way that the participants react to the interven-\ntion (or its absence), such as the time to complete a task, or\nthe sort of \u2018solutions\u2019 produced.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 79", "position": 79, "chunk_type": "semantic", "token_estimate": 389}
{"text": "Empirical Knowledge about Software Design: 65\n5.2.2\nThe research protocol\nEmpirical studies in software engineering are commonly human-centric,\nstudying how software developers undertake the various activities involved in\ncreating and updating software systems. An important role in this type of\nstudy is that of the observer, who is often called upon to make interpretations\nof what they observe, not least because participants do not always behave\nquite as anticipated. One of the hazards of such interpretations is that, since the observer will\nbe aware of what the study is investigating, they may be unconsciously biased\nor in\ufb02uenced by this when making their interpretations. To help avoid, or at\nleast reduce, the degree of any resulting bias, it is common practice to develop\na comprehensive plan for conducting and analysing an empirical study, which\nis known as the research protocol. The research protocol may well be quite a substantial and detailed docu-\nment, but inevitably it may still not anticipate every situation. For example,\nwhen faced with a particular choice as part of a study, the protocol might\nexpect that participants will usually make one of three fairly obvious choices,\nand so the task of the analyst will be to determine how to categorise each\nparticipant\u2019s actions against these. However, when the study is performed, it\nmay well be that a small number of participants make another, and signi\ufb01-\ncantly di\ufb00erent, choice. In that case, the research team may agree to create\na fourth category for purposes of analysis, and this decision is then recorded\nand reported as a deviation from the protocol. Deviations may occur for all\nsorts of reasons, including errors that the experimenters make in conduct-\ning the study, but may also occur as a result of encountering unanticipated\nparticipant actions. So the purpose of the research protocol is to help ensure that the study is\nconducted rigorously, and that in analysing the results, the experimenters do\nnot \u2018\ufb01sh\u2019 for interesting results. 5.2.3\nQualitative studies\nQualitative studies are apt to be observational in their nature and concen-\ntrate upon gaining insight into the reasoning that lies behind the activities of\nan individual designer. Here we provide two examples of the ways that such\nstudies might be conducted (they are by no means the only ones). \u2022 Interviews. One way of \ufb01nding out what designers think about what they\ndo (and why they do it that way) is to talk with them.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 82", "position": 82, "chunk_type": "semantic", "token_estimate": 403}
{"text": "66: Software Design: Creating Solutions for Ill-Structured Problems\n\u2022 Think-aloud. This is really one element in the technique known as Proto-\ncol Analysis developed for knowledge elicitation in psychological studies\n(Ericsson & Simon 1993). It involves asking the participant to under-\ntake some task and to describe their thinking verbally as they perform it\n(think-aloud). A transcript of their verbal \u2018utterances\u2019 is then analysed,\nthose utterances that are not directly relevant to the task are discarded,\nand a model is developed around the others. In practice, think-aloud is\nby no means easy to perform (among other problems, participants tend\nto \u2018dry up\u2019 when they are concentrating), but it can provide valuable\ninsight into the basis for their actions, including identifying where this\ninvolves the use of tacit knowledge (Owen, Budgen & Brereton 2006). A challenge when conducting qualitative studies is to be able to analyse the\noutcomes in as rigorous and unbiased a manner as possible, particularly since\nan element of human interpretation is usually required. To help reduce the risk\nof bias, good practice involves using more than one person to analyse the data,\nwith the analysts working independently and then checking for consistency of\ninterpretation between them. And of course, the analysis should be planned\nin advance as part of the research protocol. We will examine a number of outcomes derived from such studies as we\nprogress through the following chapters, and some of the studies described in\nthe previous chapter such as (Curtis et al. 1988) employed qualitative forms. Qualitative studies tend to use ordinal or \u2018ranking\u2019 forms of measurement\nscale. So, when making measurements, the observer (or participants) will typ-\nically rank (say) issues or preferences in terms of their perceived importance,\nwith no sense that the elements are equally spaced. 5.2.4\nQuantitative studies\nBecause quantitative studies are more likely to be laboratory-based and\nuse statistical techniques for analysis, they usually need larger numbers of\nparticipants than qualitative studies, in order to provide an appropriate level\nof con\ufb01dence in the results. Two of the more widely-used tools of quantitative\nstudies are experiments (and quasi-experiments), and surveys. \u2022 Experiments and quasi-experiments take a range of forms, but are usually\ncomparative in form. The purpose is to test a hypothesis and to establish\nwhere this is true or not. More precisely, the aim is to establish whether\nthe hypothesis or the alternate hypothesis is true.", "domains": ["Design Patterns", "Design Principles"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 83", "position": 83, "chunk_type": "semantic", "token_estimate": 397}
{"text": "66: The purpose is to test a hypothesis and to establish\nwhere this is true or not. More precisely, the aim is to establish whether\nthe hypothesis or the alternate hypothesis is true. For example, a hy-\npothesis to be tested might be that design models created by using the\nobserver design pattern (described in Chapter 15) will produce larger\nclasses than those that do not use patterns. The alternate (or null) hy-\npothesis will then be that there will be no di\ufb00erences in terms of the\nsizes of class involved. Experiments are similar to RCTs, but less rigorous, because the partic-\nipants cannot be blinded about their role. Most experiments performed", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 83", "position": 83, "chunk_type": "semantic", "token_estimate": 112}
{"text": "68: Software Design: Creating Solutions for Ill-Structured Problems\nA case study can be viewed as a structured form of observational study. When conducting an experiment the researcher aims to get many repeated\nmeasures of the same property. For example, the amount of time participants\nneed to complete a design task when using a particular strategy. Since we can\nexpect that this will vary considerably for di\ufb00erent people, we need to mea-\nsure the time for many participants. In contrast, a case study seeks to measure\nmany di\ufb00erent variables related to a particular \u2018case\u2019, which might be a soft-\nware development project, and then to triangulate the knowledge provided\nby the di\ufb00erent measures to see how well they provide mutual reinforcement\nabout some particular characteristic. Triangulation aggregates di\ufb00erent measures\nWhile many social scientists consider case studies to be an interpretivist\nform of study, with any \ufb01ndings only applying to that particular case, others\ndo consider that the \ufb01ndings of di\ufb00erent case studies may be combined, so\nproviding a positivist interpretation. Robert K Yin has been a major proponent\nof the positivist approach to case study research, and the use of case studies\nin software engineering has largely been based upon his work (Yin 2014). Yin suggests that case studies can be particularly useful when addressing\nthree types of research question, as described below. \u2022 An explanatory case study is concerned with examining how something\nworks or is performed, and identifying any conditions that determine\nwhy it is successful or otherwise. \u2022 A descriptive case study is more concerned with performing a detailed\nobservation of the case and therefore \u201cproviding a rich and detailed\nanalysis of a phenomenon and its context\u201d. Essentially it is concerned\nwith identifying what occurs. \u2022 An exploratory case study forms a preliminary investigation of some\ne\ufb00ect, laying the groundwork for a later (fuller) study of some form. Case studies can use a mix of qualitative and quantitative data, and both\nexplanatory and descriptive case studies may usefully make use of one or more\npropositions that direct attention to some aspect that should be investigated.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 85", "position": 85, "chunk_type": "semantic", "token_estimate": 347}
{"text": "Empirical Knowledge about Software Design: 73\nThe use of systematic reviews can help overcome the e\ufb00ects of bias that\ncan arise in the \ufb01ndings of individual \u2018primary\u2019 studies and hence can\nprovide the most reliable sources of evidence for making design decisions\nor selecting a design strategy. The empirical knowledge provided by such\nevidence can be presented for use in a number of ways, including: sum-\nmary of experience; lists of factors to consider; and comparative ranking\nof techniques.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 90", "position": 90, "chunk_type": "semantic", "token_estimate": 79}
{"text": "Chapter 6: Software Architecture\n6.1\nWhat architecture provides for us ...............................\n77\n6.2\nArchitectural style ...............................................\n79\n6.2.1\nPipe-and-\ufb01lter architectural style .......................\n82\n6.2.2\nCall-and-return architectural style ......................\n83\n6.2.3\nData-centred repository architectural style .............\n84\n6.3\nArchitectural patterns ...........................................\n87\n6.3.1\nModel-view-controller (MVC) ...........................\n88\n6.3.2\nLayers ....................................................\n90\n6.4\nEmpirical knowledge about architecture .........................\n91\nKey take-home points about software architecture ..............\n92\nThe idea that a software application might have an architecture has become an\nimportant concept in thinking about how applications are composed, and how\ntheir operations are organised. As in other domains, its value largely stems\nfrom providing a highly abstract and readily visualised perspective on how\nsomething is organised and structured, whether it be a building, a ship, or a\nsoftware application. And the idea of architecture also captures more than the\nway something is constructed. It also embodies ideas about how it functions\n(think of how \u2018tanker\u2019, \u2018car ferry\u2019 relate to a combination of di\ufb00erent forms\nand functions when considering naval architecture). So, architecture turns out to be a versatile concept: we can describe an\napplication as having \u2018an architecture\u2019; use ideas about \u2018architectural style\u2019 to\ncategorise architectures; and employ \u2018architectural patterns\u2019 when designing\nan application. These facets are all explored in the rest of this chapter, but\n\ufb01rst we look a bit more closely at what we mean by the concept itself. 6.1\nWhat architecture provides for us\nWhen software applications consisted of programs executed on isolated\ncomputers (the \u2018pre-internet era\u2019), there was little need for the concept\nof architecture. Software was largely developed using imperative program-\nming languages (Algol, COBOL, FORTRAN etc.) which used broadly similar\nstructures. Certainly, there were di\ufb00erent ways that an application could be\n77", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 94", "position": 94, "chunk_type": "semantic", "token_estimate": 287}
{"text": "80: Software Design: Creating Solutions for Ill-Structured Problems\nFor software, the concept of architectural style can similarly be viewed as\nproviding a very abstract description of a set of general characteristics related\nto the form of an application. When provided with such a description, we will\nthen know something about the general form this has, although there may\nstill be great variation of detail. More speci\ufb01cally, and a point that we will\nreturn to, is that this will also tell us something about what might be involved\nin modifying the resulting application in the future. For software the sort of label we use may relate to the way that the ap-\nplication is intended to operate. So we might refer to styles using terms such\nas \u2018client-server\u2019 or \u2018pipeline\u2019. However, such labels are not a very systematic\nway of classifying architectural styles, although very useful for easy reference. And as it became realised that the idea of an application\u2019s architecture was\nuseful, so ideas emerged about how best to describe and classify this. In Perry & Wolf (1992), the authors proposed a classi\ufb01cation scheme based\non the following characteristics:\nsoftware architecture \u2194{elements, form, rationale}\nThey categorised elements as being concerned with processing, data or con-\nnections, and form as a \u2018set of weighted properties and relationships\u2019, while\nrationale recorded the motivation for particular choices. The in\ufb02uential book by Shaw & Garlan (1996), that helped to consolidate\nthe idea of architecture and its importance, adopted a rather simpler approach\nto classi\ufb01cation, employing a basic framework based solely upon components\nand connectors. A rather more detailed scheme was used in (Shaw & Clements 1997). This\ncategorised architectural style in terms of the following major features. \u2022 the kinds of components and connectors used in the style (for example,\nobjects and method calls);\n\u2022 the ways in which control (of execution) is shared, allocated and trans-\nferred among the components;\n\u2022 how data is communicated through the system;\n\u2022 how data and control interact;\n\u2022 the type of (design) reasoning that is compatible with the style.", "domains": ["Architectural Patterns and Styles", "Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 97", "position": 97, "chunk_type": "semantic", "token_estimate": 343}
{"text": "Software Architecture: 81\n2017). Indeed, architectural concepts tend to be rather abstract as well as\nvery diverse, and hence are probably not really easily described using formal\nnotations. As indicated earlier, applications created in the 1970s and 1980s were\nusually organised in a self-contained \u2018monolithic\u2019 form, with all of the elements\nresiding on the same computer, and having a form such as call-and-return or\ndata-centred-repository. With the advent of the internet in the 1990s new\nforms evolved (such as client-server), exploiting the ability to distribute the\nelements of an application. The later evolution of the cloud, and related ideas\nabout services has added further to the choices available to the designer. Because architectural concepts are relatively abstract, the vocabulary as-\nsociated with them lacks precision\u2014one of the factors motivating the cate-\ngorisation process provided in early works such as (Shaw & Garlan 1996). Table 6.1 summarises the major categories of architectural style identi\ufb01ed\nin (Shaw & Clements 1997). Perhaps not surprisingly, these largely relate to\n\u2018monolithic\u2019 forms of application construction\u2014distributed forms can be hard\nto classify\u2014and many categories do encompass a variety of styles. TABLE 6.1: Some major categories of software architectural style\nCategory\nCharacteristics\nExamples of Styles\nData-\ufb02ow\nMotion of data, with no \u2018up-\nstream content control\u2019 by\nthe recipient\nbatch\nsequential;\npipe-and-\ufb01lter\nCall-and-return\nOrder of computation with a\nsingle thread of control\nmain\nprogram/sub-\nprograms;\n\u2018classical\u2019\nobjects\nInteracting-processes\nCommunication among in-\ndependent, concurrent pro-\ncesses\ncommunicating\npro-\ncesses;\ndistributed\nobjects\nData-centred repository\nComplex central data store\ntransactional\ndatabases;\nclient-\nserver; blackboard\nData-sharing\nDirect\nsharing\nof\ndata\namong components\nhypertext;\nlightweight threads\nOne caveat emphasised by Shaw & Clements (1997) and one that we should\nnote, is that applications are not necessarily \u2018pure\u2019 in terms of their style and\nso may possess the characteristics of more than one style. And of course, if a\nsystem is classi\ufb01ed as being a \u2018hybrid\u2019, that doesn\u2019t reduce the value of the\nclassi\ufb01cation process, indeed it may even render it more important. Bass, Clements & Kazman (2013) describe how thinking about architecture\nhas subsequently evolved. Many of the original ideas are still there, but they\nare apt to be expressed di\ufb00erently. Rather than categorising styles in terms of\ntheir elements and the connections between them, they argue that architecture\nshould be viewed in terms of three di\ufb00erent structures, which in turn relate\nto di\ufb00erent sets of decisions that occur during the process of design.", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 98", "position": 98, "chunk_type": "semantic", "token_estimate": 401}
{"text": "82: Software Design: Creating Solutions for Ill-Structured Problems\n1. Module structures consist of the blocks of code or data that will form\nthe application, and relate to design decisions about how responsibility\nis allocated, the ways that the modules depend upon each other (the\nforms of coupling), and the use of external modules. 2. Component-and-connector structures are more concerned with how the\napplication will behave when it executes and how the di\ufb00erent elements\nwill interact during execution. Whereas module structures are essentially\nstatic, these are concerned with system execution. 3. Allocation structures are concerned with where di\ufb00erent modules will\nreside, and from where external resources will be sourced. While this can be simpli\ufb01ed to a model of \u2018component-connector-context\u2019\nit goes much further and relates much more closely to the decision-making\nprocesses involved in architectural design. To help illustrate the concepts involved, we now look brie\ufb02y at the forms\nof three widely used architectural styles. Other styles such as object-oriented\nand service-oriented architecture will be discussed in later chapters, and these\nexamples have been chosen simply to illustrate the variety that can occur. 6.2.1\nPipe-and-\ufb01lter architectural style\nAn application based upon this style is one in which a sequence of trans-\nformations are performed upon data, typically by a series of processes. Each\nprocess performs its allocated task and then passes the data on to the next\none. As a style it emphasises separation of concerns, where the concerns are\nprovided by the transformations embodied in the individual processes. It is\norganised around \ufb02ow of data. Table 6.2 summarises the main characteristics\nof the style using the classi\ufb01cation scheme from (Shaw & Clements 1997). TABLE 6.2: The pipe-and-\ufb01lter architectural style\nFeature\nInstantiation in pipe-and-\ufb01lter\nComponents\nData transformation processes. Connectors\nData transfer mechanisms (e.g. Unix pipes, \ufb01les etc.). Control of execution\nTypically asynchronous. Control is transferred by the\narrival of data at the input to a process. Data communication\nData is generally passed with control. Control/data interaction\nControl and data generally share the same topology\nand control is achieved through the activity of trans-\nferring data. Design reasoning\nTends to employ a bottom-up approach based upon\nfunction due to the emphasis placed upon the \ufb01l-\nters (components). Fits well with incremental devel-\nopment forms.", "domains": ["Architectural Patterns and Styles", "Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 99", "position": 99, "chunk_type": "semantic", "token_estimate": 372}
{"text": "84: Software Design: Creating Solutions for Ill-Structured Problems\nthe use of static global variables that are visible to all sub-programs. Object-\noriented languages such as Java often use this as an underpinning mechanism,\nand so can also be used to write software in this style. main\noutput\ninput\nprocessing\nProcess 2\nProcess 1\nFIGURE 6.2: Call and return using a main program and sub-programs\nFigure 6.2 shows a simple illustration of an application structured in\nthis style, with a main program unit (which sequences the calls to the sub-\nprograms), and a hierarchical set of sub-programs that perform the tasks. Here the arrows indicate transfer of control by a conventional sub-program\ninvocation mechanism, and further annotation can be used to show transfer\nof data via sub-program parameters. Table 6.3 summarises the main characteristics of this architectural style. While this is a simple and convenient form to employ for constructing mono-\nlithic applications, and likely to produce e\ufb03cient code because of the way that\nit \u2018mirrors\u2019 the underlying computer mechanisms, it provides limited scope for\nreuse beyond employing a \u2018library\u2019 of sub-programs. However, it is quite ver-\nsatile and widely employed\u2014for example, it could be used to structure the\ninternal forms of the processes used in Figure 6.1. 6.2.3\nData-centred repository architectural style\nThis style encompasses those applications for which the key element is\nsome central mechanism that is used for the persistent storage of information\n(not necessarily a database management system), so that the information\ncan then be manipulated by a set of external processing units. So for this\narchitectural style, the \u2018concerns\u2019 are related to data and its use. However, it\nalso o\ufb00ers scope to provide an element of information hiding regarding the\nway that the information is actually stored. Obvious examples of applications in this category are database systems\nand blackboard-style expert systems (here the blackboard itself provides the\ncentral mechanism). Shaw & Clements (1997) argue that client-server systems\nalso come into this general category, on the basis that the server acts as a", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 101", "position": 101, "chunk_type": "semantic", "token_estimate": 336}
{"text": "Software Architecture: 85\nTABLE 6.3: The call-and-return architectural style\nFeature\nInstantiation in call-and-return\nComponents\nSub-program units. Connectors\nInvocation of sub-programs. Control of execution\nSequencing of calls is organised by the algorithms in\nthe components that form the invocation hierarchy. Data communication\nData can be passed through parameters and may also\nbe shared using a global storage mechanism (variables\ndeclared in the main component). Control/data interaction\nThis is largely limited to the passing of parameters\nand the return of data through function calls. Design reasoning\nBecause the \u2018concerns\u2019 (functions) are sub-divided, it\nis usually associated with top-down thinking. Many\ntraditional plan-driven design approaches produce de-\nsign models that have this form. Use of global data\nstructures can constrain the e\ufb00ective separation of\nconcerns. central repository, and may well include a database. Figure 6.3 provides an\nillustration of the general form of a client-server system (whether the server\nis \u2018local\u2019 or in the cloud is not important, since it is the role that matters). 'Thin' client\n(e.g. laptop,\nphone, tablet)\nApplication\ndatabase\nServer\nFIGURE 6.3: Data-centred repository: a simple client-server model\nWhen the repository is an actual database, the central mechanism is likely\nto be concerned with providing one or more forms of indexed access to a poten-\ntially large volume of data. Blackboard systems and object-oriented databases\ncan provide a less highly structured form of repository, which may well be used\nto acquire, aggregate, and record a variety of forms of \u2018knowledge\u2019. Table 6.4\nsummarises the characteristics of this architectural style.", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 102", "position": 102, "chunk_type": "semantic", "token_estimate": 250}
{"text": "86: Software Design: Creating Solutions for Ill-Structured Problems\nTABLE 6.4: The data-centred repository architectural style\nFeature\nInstantiation in data-centred repository\nComponents\nStorage mechanisms and processing units. Connectors\nTransactions, queries, direct access (blackboard). Control of execution\nOperations are usually asynchronous and may also\noccur in parallel. Data communication\nData is usually passed through some form of param-\neter mechanism. Control/data interaction\nThis varies quite widely. For a database or a client-\nserver system, these may be highly synchronised,\nwhereas in the case of blackboard there may be little\nor no interaction. Design reasoning\nThe strong focus on data usually means that mod-\nelling the data is an important element. The variety\nof forms such systems take tends to mean that design\nlogic may also vary extensively. An architectural style for the CCC\nThe", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 103", "position": 103, "chunk_type": "semantic", "token_estimate": 132}
{"text": "system: is\nessentially\none\nthat\nis\nused\nto\nmanage\ninformation\u2014about the cars, the members and the way that mem-\nbers are charged for the use of the cars. So the choice of a data-centred\nrepository style seems to be appropriate, providing a central \u2018knowl-\nedge base\u2019 that can be accessed to manage bookings, accounts etc. And\nsince the customers will be using remote forms of access such as mobile\nphones, it also seems appropriate to adopt a client-server form for this. One question that this then raises is \u201cwhat form will the server take?\u201d. We could adopt the use of a relational database to hold details of cars,\nbookings etc., but equally we could use an object model in which we\nhave objects that represent cars. The latter is likely to prove more\n\ufb02exible. We can see this could cope with di\ufb00erent models of car using\ninheritance if CCC later decide to o\ufb00er di\ufb00erent options, and an object\nmodel does encapsulate all of the relevant data about a car within an\nobject. However, given the various things that the CCC system does\n(and may do in the future) it may well be that some form of compromise\nwould be a good way to handle this. The more changeable activities\nrelated to cars could be modelled as objects, but things like recording\nbookings and charging for use might employ a database. At this stage we will focus on the choice of style and \ufb01ll out the details\nlater, deferring decisions about these until we have a clearer picture of\nhow the CCC system will work and the directions in which it will later\nexpand.", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 103", "position": 103, "chunk_type": "semantic", "token_estimate": 273}
{"text": "Software Architecture: 87\n6.3\nArchitectural patterns\nThe concept of using some form of abstract \u2018pattern\u2019 to transfer knowl-\nedge about useful design models that could be used to \u2018solve\u2019 issues that are\nrepeatedly encountered across a range of applications emerged in the 1990s,\nand has been realised in a number of ways. It has been widely adopted for use\nin object-oriented software development, as a means of describing solutions\nto recurring challenges that might face the designer (Gamma, Helm, Johnson\n& Vlissides 1995), usually involving particular parts of a system or applica-\ntion. It has also been suggested that patterns could be adapted to perform a\nsimilar role in the design of service-oriented applications (Erl 2009). We will\ndiscuss the pattern concept in much more detail in Chapter 15, but in this\nsection we discuss how the concept can be used to describe the overall form of\na system, by making use of architectural design patterns, a concept proposed\nby Buschmann, Meunier, Rohnert, Sommerlad & Stal (1996). The idea of using patterns to help with transferring knowledge about de-\nsign \u2018solutions\u2019 is rooted in the work of the architect Christopher Alexander\n(Alexander, Ishikawa, Silverstein, Jacobson, Fiksdahl-King & Angel 1977),\nand has been described by him in the following words. \u201cEach pattern describes a problem which occurs over and over\nagain in our environment, and then describes the core of the solu-\ntion to that problem, in such a way that you can use this solution\na million times over, without ever doing it the same way twice.\u201d\nEssentially, a pattern provides a generic description of, and \u2018solution\u2019 to,\na problem, and being generic, it will always need to be instantiated in a way\nthat addresses the speci\ufb01c situation that the designer is actually facing. (This\n\ufb01ts in with the concept of \u2018design as adaptation\u2019 introduced in Chapter 1 and\nFigure 1.2.) Couched in terms of knowledge transfer, a pattern identi\ufb01es a particular\ndesign problem that might be encountered, together with a strategy for ad-\ndressing that problem. We also expect that the description of a pattern will\nidentify some possible consequences of adopting the pattern, since the choice\nof whether or not to use a pattern may well involve making trade-o\ufb00s between\ndi\ufb00erent aspects of the design model. In some ways using patterns has similarities to the sort of learning involved\nin the traditional master/apprentice relationship.", "domains": ["Architectural Patterns and Styles", "Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 104", "position": 104, "chunk_type": "semantic", "token_estimate": 396}
{"text": "88: Software Design: Creating Solutions for Ill-Structured Problems\n(1985), whereby a designer would note the presence of a sub-problem for which\nthey already had a solution strategy, (again, re\ufb02ecting the idea of designing\nby adaptation). At the architectural level of software design the pattern concept is used\nslightly di\ufb00erently. Here, patterns o\ufb00er models for the general structure that\nthe application should take, rather than for a part of the design solution. The\nideas involved in architectural patterns do overlap with architectural styles to\nsome degree\u2014some patterns can be realised using a variety of styles, whereas\nothers are implicitly linked to the idea of using a particular type of design\nelement (the most obvious example of such an overlap is that of \u2018pipes-and-\n\ufb01lters\u2019 which is essentially a pattern that can be employed with processes). Architectural patterns provide di\ufb00erent ways of \u2018separating the concerns\u2019\nfor an application, aiming to organise its structure so that future changes\ncan be made with a minimum impact from any side-e\ufb00ects. However, to do so\nsuccessfully does implicitly assume that the designer (system architect) is able\nto envisage the ways in which the application may later evolve\u2014and a possible\nrisk is that the architectural pattern adopted may not be well suited to what\nactually does happen. So, while patterns do o\ufb00er bene\ufb01ts, the adoption of any\narchitectural pattern, like the adoption of an architectural style, does create\nthe potential for generating technical debt. Table 6.5 summarises the roles provided by a selection of the patterns\nintroduced in (Buschmann et al. 1996). In the rest of this section we examine\ntwo examples from this set in order to illustrate the idea more fully. TABLE 6.5: Some examples of architectural patterns\nPattern\nDescription of Role\nModel-view-controller\nProvides a structure for decoupling the various ele-\nments of an interactive system. Layers\nUsed where an application can be organised as a hi-\nerarchy of sub-tasks performed at di\ufb00erent levels of\nabstraction. Pipes-and-\ufb01lters\nFor systems that process a stream of data (this is\nrather similar to the architectural style). Broker\nUsed to structure the interaction of distributed sys-\ntems with highly decoupled components, where the\nchoice of components may be made \u2018on the \ufb02y\u2019 when\nthe application executes. Re\ufb02ection\nIntended to support dynamic adaptation of the struc-\nture for a system.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 105", "position": 105, "chunk_type": "semantic", "token_estimate": 380}
{"text": "88: Broker\nUsed to structure the interaction of distributed sys-\ntems with highly decoupled components, where the\nchoice of components may be made \u2018on the \ufb02y\u2019 when\nthe application executes. Re\ufb02ection\nIntended to support dynamic adaptation of the struc-\nture for a system. 6.3.1\nModel-view-controller (MVC)\nThis is a widely encountered pattern used to structure the sort of appli-\ncations in which end-users will interact with some form of \u2018data repository\u2019,", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 105", "position": 105, "chunk_type": "semantic", "token_estimate": 71}
{"text": "Software Architecture: 89\nperforming updates to the data and viewing di\ufb00erent projections from it. As\nan example of where it could be used, it is well suited for use with applications\nwhich involve extensive user interaction with a dataset, such as a spreadsheet\nor word processor. This pattern is motivated by the principle of separation of concerns, and\nis concerned with keeping the details of the model (the data repository) in-\ndependent from the elements that need to interact with it, namely the views\nand controllers. Essentially the model is encapsulated in such a way that its\ndetails (and format) are not directly visible to the views and controllers (the\nlink to designing with objects may be fairly obvious here, since both place\nemphasis upon information hiding through the encapsulation of data). controller\nmodel\nview\nInvokes methods\nin the model's API\nto change its state\nQueries\nmodel state\nNotifies of any\nchanges in the\nmodel state\nSelect view\nUser actions\nFIGURE 6.4: The MVC pattern\nFigure 6.4 shows the idea of MVC in a rather abstract way. It is worth\nnoting that a wide variety of such diagrams exist, often providing slightly dif-\nferent interpretations of the elements making up MVC and how they interact. The roles for the elements are as follows. Model. This provides the core functionality of the application (that is, the\noperations performed upon the data) and the associated data. View. Each view provides a di\ufb00erent way of presenting knowledge about the\nmodel, obtained from the model, to the user. Controller A controller handles user input, and each view is likely to have\na distinct controller associated with it. The views and controllers make up the user interface and are largely inde-\npendent of the model, beyond sharing knowledge of the data types making\nup the model. The model may well also need to provide updates to the views\nand controllers when changes are made to it (or at least, provide them with", "domains": ["Design Patterns", "Design Principles", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 106", "position": 106, "chunk_type": "semantic", "token_estimate": 327}
{"text": "90: Software Design: Creating Solutions for Ill-Structured Problems\ninformation that an update is available). An important characteristic of this\ndesign structure is that it makes it possible to provide quite di\ufb00erent \u2018look\nand feel\u2019 forms of interaction without a need to modify the model itself. Using MVC for the CCC system\nWe can easily see that the software for the CCC \ufb01ts well with the MVC\npattern. We can interpret the elements as follows:\n\u2022 The model is the information held centrally about the cars, book-\nings, customer accounts etc. This is continually being modi\ufb01ed\nand updated as cars are claimed, customers make bookings, cars\nare taken out of use for servicing etc. \u2022 There are a number of di\ufb00erent views. Some are ones presented to\na customer, perhaps reporting which cars are nearby and avail-\nable, or present data pertaining to a recently completed hire ses-\nsion. Other views are available to the managers, accounts depart-\nment, maintenance team etc. They all relate to the same core set\nof information, but present di\ufb00erent elements of it in ways that\nare meaningful to the needs of a particular user. \u2022 The controllers relate to interaction with di\ufb00erent users who are\nmaking requests, choices etc. Some may be phone apps, others\nmay be devices in the \u2018back o\ufb03ce\u2019 of CCC. An important feature of MVC is that the characteristics of the model\nas seen by di\ufb00erent users through di\ufb00erent views should be consistent. This alone is an excellent reason for thinking of the model as a cohesive\nwhole. 6.3.2\nLayers\nOpportunities to employ the Layers pattern occur less commonly than\nthose for using MVC. However, as an example, it illustrates a di\ufb00erent way of\nthinking about how to organise the separation of concerns within the structure\nof an application, placing greater emphasis upon function. This pattern structures an application by separating its functionality into\ndi\ufb00erent groups of operations, with each group performing its tasks at a di\ufb00er-\nent level of abstraction within a hierarchy. A classic illustration of this is the\nway that networking software is usually organised. Figure 6.5 shows a simple\nillustration of this for the OSI model, highlighting how each layer provides\nmore abstract operations by performing its tasks by using operations from\nthe layer beneath it.", "domains": ["Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 107", "position": 107, "chunk_type": "semantic", "token_estimate": 379}
{"text": "Software Architecture: 91\ndrawing upon the services of Layer 3 (Network), to organise the route(s) by\nwhich the packets are delivered. Application\nTransport\nSession\nPresentation\nPhysical\nData Link\nNetwork\nFIGURE 6.5: Layers pattern\nThe use of Layers makes it easy to iso-\nlate the e\ufb00ects that can arise from making\nchanges at the lower levels. A simple ex-\nample concerns a change in the underlying\nnetwork form. To move from using (say) an\nethernet implementation to using a slotted\nring as the network medium only involves\nchanges to the very lowest layers. The higher\nlayers have no knowledge of the nature of the\nactual transport mechanism being used. Many operating systems use a similar\nmodel (for example, Unix applications sit\nabove the \u2018shell\u2019, which in turn makes use\nof the system layers below it). Again, a dif-\nferent interface can be provided by simply\nchanging the shell, and hence a single com-\nputer can readily have a situation where dif-\nferent users are working with di\ufb00erent in-\nterfaces, but are still able to share \ufb01les and\nother resources when necessary. While clearly Layers is a particularly use-\nful pattern to use for \u2018system\u2019 software, in\nprinciple it is by no means restricted to such\napplications. However, it is likely that most\ndesigners will encounter this as a pattern\nthat is already established for a software system, and their concern will be\nto develop applications that conform to it. 6.4\nEmpirical knowledge about architecture\nThe nature of software architecture makes it di\ufb03cult to perform empirical\nstudies, since for each application, the choice of a suitable architecture is rather\nentwined with the unique nature of the application itself. Hence systematic\nreviews in this area are relatively uncommon, and those that are available,\nmainly look at the \u2018robustness\u2019 of architectures when changes need to be\nmade. An example of this is the systematic review by Williams & Carver (2010)\nthat focused upon assessing the impact of proposed changes to a system\u2019s\narchitecture. A further example is provided by Breivold, Crnkovic & Larsson", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 108", "position": 108, "chunk_type": "semantic", "token_estimate": 339}
{"text": "92: Software Design: Creating Solutions for Ill-Structured Problems\n(2012), that looks at the e\ufb00ect of architecture upon software evolution, and\nat the di\ufb00erent approaches that have been proposed to help address this. A somewhat di\ufb00erent and interesting perspective is provided in the sys-\ntematic review by Shahin, Liang & Babar (2014). This examines some of the\nforms used for visualising software architecture, as well as di\ufb00erent elements\n(such as patterns), and the ways that these are used. They particularly ob-\nserved that these were often used to help with di\ufb00erent aspects of recovery\nof architectural knowledge about existing applications as well as to help with\nevolution. Key take-home points about software architecture\nThe concept of software architecture o\ufb00ers a high-level perspective upon\nthe way that a software application is structured and organised. Some key\nissues related to this include the following. Separation of concerns. The major elements of a system will address dif-\nferent \u2018concerns\u2019 and choice of a suitable architecture will reduce the\nlikelihood of side-e\ufb00ects arising from interactions between the elements\nas well as providing a way to reduce future technical debt. Composition. The architecture of a system is concerned with how this is to\nbe composed from a (possibly diverse) set of elements. Vocabulary. Architectural concepts provide a useful vocabulary that can be\nused to aid understanding and discussion related to the high-level struc-\nture of an application. This may also help identify how it might evolve\nin the future as well as what scope there is to reuse elements. Categorisation. A useful way to think of an architectural style is in terms of\nits components, the connectors that map the dependencies between the\ncomponents, and the context that describes how the elements execute\nand relate to each other. Architectural patterns. These describe some commonly used ways to or-\nganise the top-level form of an application. Empirical knowledge. Such knowledge is mainly concerned with the in-\nterplay between the choice of an architecture and the ease of making\nchanges to a system.", "domains": ["Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 109", "position": 109, "chunk_type": "semantic", "token_estimate": 335}
{"text": "Modelling Software Properties: 99\nto describe a viewpoint describes a particular set of design attributes, there\nmay be some overlap between these, as shown symbolically in Figure 7.3,\nproviding some potential for checking consistency between viewpoints with\nrespect to the model itself. attribute8\nattribute4\nattribute3\nattribute2\nattribute1\nattribute7\nattribute6\nattribute5\nRepresentation 1\nRepresentation 2\nRepresentation 3\nFIGURE 7.3: Some attributes may appear in more than one representation\nWhat is more, these viewpoints can themselves be further classi\ufb01ed as\nbeing \u2018direct\u2019 viewpoints, in that they are created directly by the designer(s). We can also identify viewpoints that may be described as being \u2018derived\u2019\nviewpoints, created by applying some form of transformation to the design\nmodel. The most obvious such form occurs when some form of interpreter\nis used to \u2018execute\u2019 the design model (usually a behavioural description of\nthe model), rather akin to the process of mental execution noted earlier and\ndescribed in (Adelson & Soloway 1985). While this scheme of classi\ufb01cation is quite practical for our purposes, it is\nby no means the only way that we can classify design descriptions. A widely-\ncited form that is used for describing object-oriented models is Kruchten\u2019s 4+1\nView that uses the labels: logical, process, development, physical + scenarios\n(Kruchten 1994). While less general-purpose than the scheme used here, there\nare some similarities, including the common recognition that some character-\nistics are not necessarily uniquely represented in one single viewpoint. In the rest of this chapter we examine the characteristics of each viewpoint\nand identify the attributes of design elements that are modelled in these. In\nthe chapters that follow, we will then look at some examples of how these\nviewpoints are modelled for some of the major architectural styles.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 116", "position": 116, "chunk_type": "semantic", "token_estimate": 287}
{"text": "Modelling Software Properties: 101\nNotations used to model this viewpoint may well combine di\ufb00erent forms\nof coupling (such as uses and inheritance. (These two forms can also be con-\nsidered as being rather more abstract than the other three.) More generally, this viewpoint is largely concerned with modelling static\nstructures rather than with any form of run-time behaviour. Even when the\nform modelled is something like invocation, the concern here is what is being\ninvoked, not when it is invoked. And as a result, when we look at some exam-\nples in the following chapters, we will \ufb01nd that these are heavily in\ufb02uenced\nby architectural style. 7.2.2\nThe behavioural viewpoint\nThis viewpoint is concerned with\ncausal relationships, connecting \u2018events\u2019\nto \u2018responses\u2019 via any necessary condi-\ntions. The associated notations tend to\nbe far more abstract than those used\nfor construction as the events and tran-\nsitions may involve operations that are\nspread across a number of di\ufb00erent con-\nstructional elements. Many behavioural notations can be considered as examples of \ufb01nite-state\nmachines, being concerned with the transitions that occur between di\ufb00erent\nstates of an application (such as waiting, processing, generating output etc. ),\nand the changes in context (events) that are required to make these transitions\noccur. And being concerned with dynamic relationships, these forms are useful\nwhen describing the attributes of a design model that are concerned with time\nin any way. However, not all aspects of timing can be handled with equal ease:\n\u2022 aspects concerned with sequencing of events can be described fairly well;\n\u2022 descriptions related to \ufb01xed-interval events are also fairly tractable;\n\u2022 the e\ufb00ects of timing constraints are di\ufb03cult to represent. Behavioural descriptions do not necessarily require that the design model\nhas been elaborated beyond being able to provide a \u2018black box\u2019 description of\na system, particularly when thinking about events in the abstract. However,\nthey can also be used for quite detailed modelling of how system elements will\nbe a\ufb00ected by events, both internal and external, and as such, this class of\nrepresentations is an important one. 7.2.3\nThe functional viewpoint\nOne of the harder tasks for a designer is that of describing just what an\napplication does. It is de\ufb01nitely more challenging than describing how it is", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 118", "position": 118, "chunk_type": "semantic", "token_estimate": 374}
{"text": "Modelling Software Properties: 103\n\u2022 text\n\u2022 \u2018box and line\u2019 diagrams\n\u2022 mathematical expressions\nOf course, these are not mutually exclusive, and indeed, neither of the latter\nforms is likely to be of much use without a supporting textual component. 7.3.1\nTextual description forms\nText is widely used as a means of summarising information, both when\nsketching and also when producing more formal descriptions. Ordered lists,\ntables, and highlight boxes, as used throughout this book, provide a ready\nmeans of presenting information. Two problems with using text on its own to\ndescribe aspects of a design are as follows. \u2022 Any structure that is implicit in the information can easily be obscured,\nunless it can be highlighted using lists, tables or boxes. Sub-headings\nand indentation can help to show structure, but may be less e\ufb00ective\nover long blocks of text. \u2022 Natural-language descriptions can easily be ambiguous, and structuring\ntext so as to avoid ambiguity can lead to the use of long and complex\nstructures. Text is really most e\ufb00ective when used in small blocks and tables. We will\nuse some examples of these in the next chapters, but it is also worth noting\nthat the SSADM (structured systems analysis and design method) approach\nto plan-driven design is one that makes e\ufb00ective use of text through the use\nof standard pro-formas to record information about certain design decisions\n(Longworth 1992). (SSADM was developed to meet the needs of local and na-\ntional government agencies. Its designers recognised that these were organisa-\ntions where sta\ufb00were regularly transferred between projects and departments,\nand hence that design rationale could easily be lost when this occurred. So\nin specifying its procedures they took care to include the means of recording\nthese. We discuss SSADM further in Chapter 13.) 7.3.2\nBox and line description forms\nWe have already seen various examples of box and line forms, and there\nwill be many more in the chapters that follow this one. As with text, diagrams\ndo bene\ufb01t from simplicity of form, and diagrams that contain a large number\nof symbols may be di\ufb03cult to comprehend. Box and line diagrams are easily\nsketched on a whiteboard or on paper, but of course, because of the invisibil-\nity of software they lack any ready visual link between their form and their\nmeaning. Curiously, despite a long history of using such forms for describing", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 120", "position": 120, "chunk_type": "semantic", "token_estimate": 394}
{"text": "104: Software Design: Creating Solutions for Ill-Structured Problems\nsoftware, there would appear to be little or no research into their form and\nuse. Many widely used forms have a relatively small number of symbols, possi-\nbly re\ufb02ecting the issues underlying the \u2018magical number seven plus or minus\ntwo\u2019 discussed in Chapter 3. More abstract notations tend to have fewer sym-\nbols too. For most users, diagrams are probably the most e\ufb00ective way of provid-\ning a clear summary of ideas about the abstract concepts and relationships\ninvolved in developing a design model. However, we should remember that\nthis is not guaranteed, and a poor diagram is no more helpful than a block of\nunstructured and ungrammatical text. Like text, diagrams have both a syntax\n(\u2018how we express an idea\u2019) and a semantics (\u2018what it means\u2019) and these need\nto be used correctly if ideas are to be conveyed to others. However, this should\nnot be over-emphasised, especially at the sketching phase of model develop-\nment. Diagrams being used to develop ideas often have very informal syntax\nand semantics, possibly being created as they are drawn, and these aspects\nonly become more important when we need to record ideas for others. Indeed, and sometimes frustratingly for a tool-creating culture such as\nsoftware engineering, this does limit the usefulness of software tools that can\nbe used to create diagrams. Because these tools often tend to enforce syntactic\nrules (or at least, don\u2019t necessarily permit free use of the notation), their most\nuseful role is probably one of record-keeping rather than diagram development. FIGURE 7.5: Hierarchy in diagrams\nA useful property of some of the more formal diagrammatical notations\nis that of a hierarchical organisation, shown schematically in Figure 7.5. This\noccurs where one or more forms of \u2018diagram element\u2019 can themselves be de-\nscribed in an expanded diagram of the same form. A hierarchical organisation\no\ufb00ers the advantage that diagrams can be \u2018layered\u2019 into levels of abstraction,", "domains": ["Architectural Patterns and Styles"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 121", "position": 121, "chunk_type": "semantic", "token_estimate": 325}
{"text": "Modelling Software Properties: 105\navoiding large and complicated diagrams and so aiding comprehension. Again\nthough, this is probably of limited value when sketching, and mainly useful\nwhen creating diagrams using tools. Table 7.2 summarises the details of some well-known diagrammatical no-\ntations. Most of them are ones that we will encounter in the following chapters\nas we look at how to model some widely-used implementation forms. TABLE 7.2: A selection of box and line notations\nRepresentation\nViewpoints\nCharacteristics modelled\nData-Flow\nDia-\ngram (DFD)\nFunctional\nInformation \ufb02ow, dependency of operations\non other operations, relations with data\nstores. Entity-\nRelationship\nDiagram (ERD)\nData\nmod-\nelling\nStatic relationships between data entities. State\nTransition\nDiagram (STD)\nBehavioural\nState-machine model of an entity or system. . Statechart\nBehavioural\nSystem-wide state model, including paral-\nlelism (orthogonality), hierarchy and ab-\nstraction. Jackson\nStruc-\nture Diagram\nFunctional,\nBehavioural,\nData\nMod-\nelling\nForms of sequencing employed for opera-\ntions, actions and data entities. Structure Chart\nConstructional\nInvocation hierarchy between subprograms. Class Diagram\nConstructional\nCoupling between classes and objects. Use\nCase\nDia-\ngram\nBehavioural,\nFunctional\nInteractions between an application and\nother \u2018actors\u2019. Activity Diagram\nBehavioural,\nFunctional\nSynchronisation and coordination between\nthe actions of an application. Sequence\nDia-\ngram\nBehavioural\nMessage-passing between elements and in-\nteraction protocols. 7.3.3\nMathematical notations\nMathematics (or at least, mathematical notation) o\ufb00ers scope to combine\nabstraction with a lack of ambiguity. Various notations for use in specifying\nthe properties of software have been proposed (a good account of the evolution\nof these forms, and the claims for some of them, is provided in the review by\nShapiro (1997)). These formal description techniques or FDTs have had some\nsuccess, particularly where there is a need to ensure the robustness of safety-\ncritical systems, preferably via rigorous proof mechanisms. Probably the best-\nknown formalism is the Z speci\ufb01cation language (Spivey 1998). There is a brief\ndiscussion of this in Chapter 18.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 122", "position": 122, "chunk_type": "semantic", "token_estimate": 313}
{"text": "Modelling Software Properties: 107\nTABLE 7.3: The cognitive dimensions\nDimension\nInterpretation\nAbstraction\nTypes and availability of abstraction mechanisms\nHidden dependencies\nImportant links between entities are not visible\nPremature commitment\nConstraints on the order of doing things\nSecondary notation\nExtra information provided via means other than for-\nmal syntax\nViscosity\nResistance to change\nVisibility\nAbility to view components easily\nCloseness of mapping\nCloseness of representation to domain\nConsistency\nSimilar semantics are expressed in similar syntactic\nforms\nDi\ufb00useness\nVerbosity of language\nError-proneness\nNotation invites mistakes\nHard mental operations\nHigh demand on cognitive resources\nProgressive evaluation\nWork-to-date can be checked at any time\nProvisionality\nDegree of commitment to actions or marks\nRole-expressiveness\nThe purpose of a component is readily inferred\nThe CCC and premature commitment\nThe concept of premature commitment resonates well with the idea\nof technical debt. In Chapter 1 we observed that we might model the\ninformation about the cars using a database or using a set of objects. This is just the sort of architectural choice referred to above\u2014and the\nconsequences for other parts of the design model need to be considered\ncarefully before making a \ufb01nal choice. Arguably some design notations are prone to di\ufb00useness (we will see this in\nthe next chapter) in the sense that the notations are overloaded with symbols\nor notational variations. This puts a greater cognitive demand upon the reader,\nwho needs to remember what a diamond in the middle of a line means, or what\nthe di\ufb00erence is between a continuous line and a dashed one. This is very much an evaluation framework that can be applied (and has\nbeen) to design notations as well as to HCI design. Key take-home points about design modelling\nModelling involves creating an abstract description that re\ufb02ects the in-\ntended properties of a software application in a form that is visible, and that\ndescribes its di\ufb00erent attributes.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 124", "position": 124, "chunk_type": "semantic", "token_estimate": 310}
{"text": "Sketching Design Models: 115\nFIGURE 8.3: Listing ideas about the model\nAnd while this may not appear as architecture-neutral as all that (implic-\nitly, it already looks like a client-server model), it is important to remember\nthat there might be other ways of creating such a system. While it might seem\nunlikely, the CCC could instal small booths in the streets that users could use\nto make bookings instead of using mobile phones. The sketch in Figure 8.4 below summarises some of the things that char-\nacterise the use of sketches when used for modelling design solutions. It may\nbe useful to keep these points in mind when reading through the following\nchapters. As already observed, these forms are very likely to be the even-\ntual outcome from sketches, not something that we start with. And of course,\nthese are \u2018advice\u2019 rather than \u2018rules\u2019 for sketching, since the whole point about\nsketching is that there are no rules! The following chapters examine a variety of di\ufb00erent modelling forms. We\nbegin by looking at those forms commonly developed for describing processes,\ngo on to look at the rather more complex world of object-oriented modelling\nand then take a rather briefer look at how we can model components and\nsoftware services. However, the divisions between these are certainly not set\nin stone. Rather as design sketches can often be architecture-neutral, so we\ncan often use notations in a context that is quite di\ufb00erent to the one for which\nit was developed, as we will see when we look at software services.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 132", "position": 132, "chunk_type": "semantic", "token_estimate": 259}
{"text": "Chapter 9: Modelling Software Processes\n9.1\nCharacteristics of software processes ............................\n119\n9.2\nModelling function: the data-\ufb02ow diagram (DFD) ..............\n121\n9.3\nModelling behaviour: the state transition diagram (STD) and\nthe state transition table (STT) .................................\n126\n9.4\nModelling data: the entity-relationship diagram (ERD) .........\n130\n9.5\nModelling construction: the structure chart .....................\n134\n9.6\nEmpirical knowledge about modelling processes ................\n136\nKey take-home points about modelling processes ...............\n137\nThere are many needs that can well be met by applications that are organised\nas processes. So, having considered how we can describe di\ufb00erent properties\nand attributes of software, both formally and informally, we now bring to-\ngether ideas about architectural style and modelling to consider how we can\nmodel the characteristics of an application that is to be implemented as a\nprocess. This chapter provides a fairly generic summary of how to model the di\ufb00er-\nent aspects of this relatively simple form of software element, since processes\ncan be organised and implemented in di\ufb00erent ways, and can be realised in a\nrange of architectural styles. Indeed, an important thing to remember is that\na distinctive characteristic of software is that a \u2018one size \ufb01ts all\u2019 approach is\nde\ufb01nitely inappropriate, and that the choice of modelling forms to use needs\nto be adapted to the particular form of ISP being addressed. 9.1\nCharacteristics of software processes\nIn order to model software processes, it helps to have a fairly clear idea\nof just what is meant by a \u2018process\u2019. From the perspective of an operating\nsystem, a process can be considered as being an executable block of code and\nassociated data, that is created from some user-owned software application\nand is executed as a single thread of control. This interpretation can be seen\nas being closely related to the way that the underlying computer operates,\n119", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 136", "position": 136, "chunk_type": "semantic", "token_estimate": 305}
{"text": "Modelling Software Processes: 121\nSo, how can we model the way that this is organised in the abstract? The functional viewpoint can be used to describe the task that the process is\nperforming, and the constructional viewpoint can be used to indicate how the\ntasks and sub-tasks involved are organised, as well as any issues related to data\naccess. Additionally, the behavioural viewpoint may also aid with modelling\nhow the process interacts with the external world, and the data modelling\nviewpoint can be used where there are important relationships in the data\nthat may have an in\ufb02uence upon the structure of the process. The issue of data organisation may be rather implementation-speci\ufb01c. For\nmany programming languages permanent data storage can only be provided\nwhere variables are declared in the \u2018main\u2019 body of the program, with variables\ndeclared in the sub-programs only being created when that sub-program is\nexecuting. This means that knowledge about the structure, format and values\nof any data involved will be global in nature and shared among the elements\nof a process. A disadvantage of this sharing of knowledge about data is that it forms a\ntechnical debt that can impede later evolution of an application. This issue was\ndemonstrated by David Parnas (1972), with his ideas later being extended in\n(Parnas 1979). His crucial insight that systems constructed around informa-\ntion hiding, whereby the detailed form of data elements was only known to a\nfew key parts of a system, made it easier to change software was a very im-\nportant one, and one that underpinned the emergence of the object-oriented\nparadigm. (Of course, there is a trade-o\ufb00, in that using this approach can be\nexpected to result in a more complex set of structures for the organisation of\nthe process, in order to maintain this concealment of detail.) While information-hiding is associated with the object-oriented paradigm\nand the concept of encapsulation, it is worth noting that in (Parnas 1972)\nthe example solution was presented as a top-down design for a process. So\nconstructing single-threaded processes around information hiding is certainly\npossible, but few procedural programming languages really provide explicit\nsupport for its use. 9.2\nModelling function: the data-\ufb02ow diagram (DFD)\nThe design of processes commonly begins with the functional viewpoint,\nsince this \ufb01ts well with the idea of a single thread of control that involves\nspecifying what the process is to do.", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 138", "position": 138, "chunk_type": "semantic", "token_estimate": 397}
{"text": "Modelling Software Processes: So\nconstructing single-threaded processes around information hiding is certainly\npossible, but few procedural programming languages really provide explicit\nsupport for its use. 9.2\nModelling function: the data-\ufb02ow diagram (DFD)\nThe design of processes commonly begins with the functional viewpoint,\nsince this \ufb01ts well with the idea of a single thread of control that involves\nspecifying what the process is to do. Modelling the functional aspects of a\nprocess has a domain-oriented element and hence has clear links to require-\nments speci\ufb01cation activities. One way of describing function is to do so in\nterms of the way that di\ufb00erent actions performed by the process interact with\nthe various forms of information (data) that form a necessary part of the task\nof an application. Hence, what is usually termed the data-\ufb02ow perspective,", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 138", "position": 138, "chunk_type": "semantic", "token_estimate": 133}
{"text": "122: Software Design: Creating Solutions for Ill-Structured Problems\nmixing actions and data, is one that has provided a highly e\ufb00ective way to\ndescribe the functional viewpoint for many di\ufb00erent domains. The data-\ufb02ow approach to modelling function probably long pre-dates\nthe use of digital technology, and it is thought such forms may well have\nbeen used in the 1920s to model the way that teams of workers in businesses\nwere organised when performing their tasks (Page-Jones 1988). This may or\nmay not have been the case (the evidence seems to be largely folklore), but\nthe point remains that data-\ufb02ow forms can be used to model many data-\ndriven activities performed by people (such as processing insurance claims,\nor assembling \ufb02at-pack furniture) just as e\ufb00ectively as they can be used for\nmodelling the activities performed by software and their interactions with\ndata. The name might be thought to imply that a DFD is primarily concerned\nwith the data-modelling viewpoint, but the real issue here is describing the\noperation of a system from the perspective of the transfer of information,\nrather than being concerned about its form. DFDs are not really concerned\nwith modelling the form of the data, but the fact that they are concerned\nabout how it is used does suggest that they do incorporate some element of\nthe data-modelling viewpoint. When we look at plan-driven approaches to creating design models in\nChapter 13, we will see that DFDs formed a popular starting point for many\nearly approaches, ultimately mapping on to call-and-return implementations\n(Wieringa 1998). However, that doesn\u2019t mean that they can\u2019t be used with\nother architectural forms or development strategies (for example, they \ufb01t quite\nwell with service-oriented architectures). In particular, where an application\nis strongly data-centric, they have the bene\ufb01ts of being:\n\u2022 easy to sketch and comprehend (so, handy for describing \u2018user stories\u2019);\n\u2022 useful for clarifying what an application should do, and identifying any\ndependencies upon other processes or information that this may involve. DFDs can also be drawn with a range of degrees of formality. The \u2018bubble\u2019\nform we use here, as popularised by Tom De Marco (1978) is relatively informal\nand easy to sketch. This is partly because it also makes good use of di\ufb00erent\nshapes to di\ufb00erentiate between the elements making up a diagram (Moody\n2009).", "domains": ["Architectural Patterns and Styles"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 139", "position": 139, "chunk_type": "semantic", "token_estimate": 383}
{"text": "Modelling Software Processes: The\nDFD can also be used with scenarios of use (Ratcli\ufb00e & Budgen 2001, Rat-\ncli\ufb00e & Budgen 2005) that de\ufb01ne the conditions for speci\ufb01c execution paths,\nand which can also be combined with user stories both for developing and\nvalidating the DFD. DFDs are easy to sketch, and as in the examples above, they do not nec-\nessarily need to be large and complex. They also provide a tried and tested\nway of thinking about the functions of a process. However, they implicitly\nassume the widespread availability of knowledge about the data, and so are\nless suited to modelling the encapsulation of data needed with object-oriented\narchitectures.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 142", "position": 142, "chunk_type": "semantic", "token_estimate": 111}
{"text": "126: Software Design: Creating Solutions for Ill-Structured Problems\n9.3\nModelling behaviour: the state transition diagram\n(STD) and the state transition table (STT)\nThe idea of state is quite a familiar one. As an everyday example, we\nthink of ourselves as being in a sleeping state when we are asleep, and\nin an awake state when we are not sleeping. And there are events causing\ntransitions between these that are familiar to us, such as that caused by an\nalarm clock, or listening to a dull speaker in a warm room! We might also\nidentify some other related states such as day-dreaming or dozing, which\ncan be considered as being sub-states of a major state (in this case awake). This is shown as a simple model in Figure 9.4. FIGURE 9.4: An everyday state model\nWithin computing, some classes of problem (and solution) can usefully be\ndescribed and modelled by treating them as a \u2018\ufb01nite-state machine\u2019. Such a\nmodel can be considered as one that describes a running application as being\nin one of a \ufb01nite set of possible states, with external (and internal) events\nproviding the triggers that can lead to transitions occurring between those\nstates. A process (as well as a data element or object) in a computer \ufb01ts this\nquite well. In a formal sense, the \u2018state\u2019 of a process at any point can be\nfully described in terms of the contents of any variables that it uses, and the\n\u2018program counter\u2019 that determines which instruction is to be executed next,\nalthough we usually prefer to use rather more abstract descriptions of state. And using a \ufb01nite-state form of description to think about the properties of a\nprocess enables us to model the \u2018rules\u2019 which govern its behaviour. Indeed, an\nimportant aspect of such models is that they not only describe the transitions\nthat are allowed to occur, but also those that should not be able to happen.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 143", "position": 143, "chunk_type": "semantic", "token_estimate": 320}
{"text": "Modelling Software Processes: 127\nAnd of course, as a general constraint, an entity can only be in one state at\nany time. We have already seen an example of state modelling when describing the\ndi\ufb00erent states that one of the cars owned by CCC can be in. A car can\nbe available, reserved, or unavailable. This is quite a simple model, and\ndoesn\u2019t really allow us to describe some of the situations that might arise, such\nas when a car is unavailable because it is damaged, or needs servicing. While\nthat can be considered as being unavailable as far as modelling customer\nactivities is concerned, it isn\u2019t really su\ufb03cient to meet all of the needs of the\nCCC. (And, as we saw when considering the DFD for booking a car, what\nshould happen when two customers are o\ufb00ered the same car, when it is near\nto both of them?) FIGURE 9.5: An extended state model for a car as an STD\nFigure 9.5 shows an example of a state transition diagram that provides\na slightly more comprehensive model that describes the di\ufb00erent states of a\ncar. It uses the notation developed by Ward & Mellor (1985) in which there\nare four principal components.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 144", "position": 144, "chunk_type": "semantic", "token_estimate": 203}
{"text": "128: Software Design: Creating Solutions for Ill-Structured Problems\n\u2022 A state represents an externally observable mode of behaviour for some\nentity, and is represented by a box which is labelled to indicate that\nbehaviour. \u2022 A transition is described by an arrow, identifying a \u2018legal\u2019 change of state\nthat can occur within the entity. \u2022 The transition condition that identi\ufb01es the condition(s) that can lead to\na transition are written next to the arrow, above the line. \u2022 The transition action is written by the arrow, but below the line, and\ndescribes any actions that may occur as a result of the transition. There\nmay be several of these, and they might occur in a sequence or simulta-\nneously. This model has two states that are additional to the original set, re\ufb02ecting\nthe possibilities that at the end of a session a car may require maintenance\n(perhaps because a routine service is due, or simply because the fuel level is\ntoo low); and that it might have been left outside of the area covered by the\nCCC, and require retrieval. Both of the new states can be considered as being\nforms of unavailable, a point we will return to later. We have modelled the car as an STD in this instance, but could equally\nwell model something \u2018active\u2019 such as an application or process. The value of\nusing state modelling is that it creates a behavioural model that can be used\nto complement the functional model provided by using a form such as a DFD. For example, a state model can help with clarifying the \u2018rules\u2019 that determine\nwhich choices can be made when the process executes. There are no hard and\nfast rules about how and when to use an STD when modelling processes. It\nmay be useful to begin by creating a very abstract \u2018system-wide\u2019 STD to help\nthinking about the functional tasks that the process needs to perform. Or\nit may be helpful at a later stage to use an STD to focus ideas about how\nsome aspect of the application needs to behave (such as the example above of\nmodelling the car). Modelling the behaviour of a process (or more likely, speci\ufb01c elements of\nit) in this way provides both a means of augmenting the design model as well\nproviding a means of performing consistency checking that all options have\nbeen considered.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 145", "position": 145, "chunk_type": "semantic", "token_estimate": 396}
{"text": "line up on runway;: release brake;\nopen throttles\nFIGURE 9.6: An example of an STD modelling aircraft behaviour\npart of an air tra\ufb03c control system. The short arrow at the top indicates the\ninitial state (when the aircraft \ufb01rst enters the airspace and is detected by the\nprimary radar). There are two sources of complexity here: one is the number\nof actions that an aircraft might take (including \ufb02ying through the airspace\nand onwards, being stacked etc.) and the other is the number of operations\n(actions) performed in each transition (this is simpli\ufb01ed here of course). While STDs provide a useful visual description of how entities in a model\nchange their state, and the operations that are involved in those changes, as\nwell as being easily sketched, the lack of a hierarchical decomposition means\nthat they can rapidly become inconveniently complex in form. An alternative,\nbut less visual, way of presenting this information is to use a table, known\nas a state transition table or STT. A common convention for these is to plot\nthe set of states down the left-hand column, and then the set of events as the\ncolumn headers for the remaining columns. Entries in the table can describe\nboth the actions to be performed and also the \ufb01nal state that results when a\nparticular event occurs for a given initial state. As an example, the model in Figure 9.5 is shown in tabular form in Table\n9.1. While a state transition table provides essentially the same model as an\nSTD (or can be used to do so), it can more easily be used where it is necessary", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 146", "position": 146, "chunk_type": "semantic", "token_estimate": 271}
{"text": "130: Software Design: Creating Solutions for Ill-Structured Problems\nTABLE 9.1: An STT for the model of a car\nMake\nEnd of\nEntry key\n20 minute\nbooking\nsession\nused\ntime-out\nAvailable\nRecord\nthe\nbooking;\nstart 20 min\ntimer; change\nto\nreserved\nstatus\nReserved\nRefuse\nbook-\ning\nCancel book-\ning\nand\nre-\nturn to avail-\nable status\nRecord\nstart\ntime\nof\nses-\nsion\nand\nlo-\ncation; change\nto unavailable\nstatus\nNotify\nuser\nof\ncancelled\nbooking;\nchange\nto\navailable\nUnavailable\nRefuse\nbook-\ning\nRecord\nend\ntime and loca-\ntion;\nchange\nto\navailable\nmode\nto handle issues of scale, or of many possible transitions between a relatively\nsmall number of states. Additionally, the issues of veri\ufb01cation and validation can be more system-\natically addressed through analysis of an STT (\u2018are we building the system\nright\u2019 and \u2018are we building the right system\u2019) (Boehm 1981). An STT makes\nexplicit those situations where we do not expect there to be a response to a\nspeci\ufb01c event, since these correspond to an empty cell, and even as simple\nan act as checking and justifying all empty entries can be a useful form of\nanalysis. In particular, when there is a need to discuss these with the \u2018cus-\ntomer\u2019, tabulation may be easier to use than diagrams\u2014software engineers\ndraw diagrams all the time, but others might be less comfortable with their\nuse. 9.4\nModelling\ndata:\nthe\nentity-relationship\ndiagram\n(ERD)\nThe data-modelling viewpoint also plays a rather subsidiary role when\nmodelling processes, except of course, when a process is an element in an\napplication that has an overall data-centric style. A form that is widely\nfor modelling the relationships that exist between static data elements in", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 147", "position": 147, "chunk_type": "semantic", "token_estimate": 277}
{"text": "Modelling Software Processes: 131\na speci\ufb01cation model or a design model is the entity-relationship diagram\n(ERD). While the entity-relationship concept has provided an essential foun-\ndation for the development of the models that underpin many database sys-\ntems, it can help with modelling detailed data models for less data-centric\napplications too (Page-Jones 1988, Stevens 1991). As we will see in the next\nchapter, the form of the ERD has also provided useful ideas for modelling\nobject relationships. As with all of the notations covered in this chapter (and elsewhere) there\nare various, largely syntactic, variations in the way that ERDs are presented\nvisually. However, many forms seem to have been derived from the pioneering\nnotation devised by Peter Chen (1976). Here we concentrate on the essential\nelements, avoiding the more detailed nuances of the form. Entity\nAttribute\nRelationship\nFIGURE 9.7: The basic entity-relationship notation\nFigure 9.7 shows the three principal symbols that are used in ERDs, to-\ngether with their meanings (the symbols for entities and relationships are\nfairly universal). These entities are de\ufb01ned as follows:\n\u2022 entities are real-world \u2018objects\u2019 that have common properties;\n\u2022 a relationship is a class of elementary facts that relates two or more\nentities;\n\u2022 attributes are classes of values that represent atomic properties of either\nentities or relationships (the attributes of entities are apt to be more\nreadily recognised than those of relationships, as can be seen from the\nexamples). We might usefully note that the ERD, like the DFD, makes good use of visual\ndi\ufb00erences to clearly distinguish between the symbols. The nature of an entity will, of course, vary with the level of abstraction in-\nvolved within a design model. Entities may also be connected by more than one\ntype of relationship. (For example, the entities student and teacher might\nbe connected by both of the relationships attends-class-of and examines.) Also, attributes may be composite, with higher-level attributes being decom-\nposed into lower-level attributes. (As an example of this, the abstract attribute\ncourse-module might be decomposed into module-number, module-title\nand learning-level.)", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 148", "position": 148, "chunk_type": "semantic", "token_estimate": 340}
{"text": "132: Software Design: Creating Solutions for Ill-Structured Problems\nFIGURE 9.8: Some entity-relationship links in the CCC\nRelationships are also classi\ufb01ed by their \u2018n-ary\u2019 properties. Binary rela-\ntionships link two entities. An example of a binary relation is the relationship\n\u2018reserves\u2019 that will exist between the entities CCC member and car (it isn\u2019t\nphysically possible to drive more than one car at any moment!). Figure 9.8\nshows some simple relationships that exist in the CCC. Relationships may\nalso be \u2018one to many\u2019 (1 to n) and \u2018many to many\u2019 (m to n). Examples of\nthese relationships are:\n\u2022 car (of order 1) selected from the set of cars (entity of order n) pro-\nvided in a city\n\u2022 authors (n) having written books (m)\n(In the latter case, an author may have written many books, and a book may\nhave multiple authors.) The e\ufb00ect of the n-ary property is to set bounds upon\nthe cardinality of the set of values that are permitted by the relationship. The development of an ERD typically involves performing an analysis\nof speci\ufb01cation or design documents, and classifying the terms in these as\nentities, relationships or attributes. The resulting list then provides the basis\nfor developing an ERD. Figure 9.9 provides an ERD model for the entities that might be involved\nin an air tra\ufb03c control system (following on from the example in the previ-\nous section). This example can be considered as being quite design-related,\nand provides supplementary information about the factors that need to be\nconsidered in the eventual design model. The relationship between aircraft\nand runway also provides a simple illustration of a point that was made ear-\nlier, concerning the possible existence of multiple relationships between two\nentities.", "domains": ["Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 149", "position": 149, "chunk_type": "semantic", "token_estimate": 286}
{"text": "Modelling Software Processes: 135\nmain body\nmatch\nnode\nadd element\nto tree\ntraverse\ntree\nget next\nelement\nprint\nstring\ncreate\nnode\ninsert\nnode\nread next\ntoken\nsubprogram      in            out \ninsert_node       n:node  \nprint_string        s:string\nmatch_node      n:node    m: match status\nFIGURE 9.10: Simple illustration of a structure chart\n\u2022 Sub-programs are grouped on levels, and each one is drawn below the\nlevel of the lowest calling unit. In the example, print string() is\ndrawn at the lowest level, because it is called from both main() and\nalso traverse tree(), which is on a level below main(). \u2022 Double bars at the sides of a box (using print string() as the exam-\nple again) indicates where the designer is intending to use a standard\n\u2018library\u2019 component. \u2022 The use of recursion can be indicated by a closed invocation arc, as in\nthe example of match node. While there may be no explicit convention about left to right ordering of sub-\nprograms, there may well be an implicit one. Structure charts are often drawn\nwith input activities on the left, and output activities on the right, which\nprobably does help with understanding of a diagram. Because the structure chart describes an invocation hierarchy, it is implic-\nitly hierarchical in form, and so in principle at least, any box in the diagram\ncould be expanded using the same form. However, for moderate-sized appli-\ncations at least, this is normally only likely to occur for the lowest level, as\nshown here for read next token(). That said, given that some sub-programs are present purely for \u2018house-\nkeeping\u2019 roles such as initialisation, rather than playing a role in the main\nfunction of the process, it may be useful to simply abstract the description of", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 152", "position": 152, "chunk_type": "semantic", "token_estimate": 287}
{"text": "Modelling Objects and Classes: 141\nA good overview of the concept of an object was provided in Booch (1994),\nwhich includes a survey of historical issues associated with objects. The analy-\nsis by Taivalsaari (1993) used a rather di\ufb00erent framework and examined the\nnotion of an \u2018object\u2019 from \ufb01ve di\ufb00erent \u2018viewpoints\u2019: conceptual modelling;\nphilosophical; software engineering or data abstraction; implementation; and\nformal. For the purposes of this chapter however, a rather shorter description\nof the characteristics of objects (and classes) will be su\ufb03cient. 10.1.1\nThe notion of an object\nWhen seeking to pin down the notion of what distinguishes an object, a\nuseful starting point may be to contrast the idea of an object with that of\nthe process that was the topic for the previous chapter. Processes are usually\nsingle-threaded, especially when implemented in a call-and-return style. While\nthey may exhibit state, this is rarely readily accessible outside of the process,\nand, for sub-programs any variables may be transient and only exist when\nthe sub-program is executing. There are variations on all of these of course\n(that\u2019s why we have so many programming languages and platforms), but\nfrom a modelling aspect, the process is a relatively simple element, and one\nthat is essentially \u2018action-oriented\u2019, with structures that place relatively little\nemphasis upon data or information. global\ndata\nlocal\ndata\ninvoke\ninvoke\nuses\nmethod\ncall\nsub-program B\nsub-program A\nobject X\nobject Y\ninternal\nmethod\nexternal methods\na) Structure of a process\nb) Structure of an object\nFIGURE 10.1: Processes versus objects\nFigure 10.1 provides a simple illustration of the distinction between the\nway a process is organised and the way that an object is organised. On the\nleft of the \ufb01gure, we have a process consisting of sub-programs that make use", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 158", "position": 158, "chunk_type": "semantic", "token_estimate": 292}
{"text": "142: Software Design: Creating Solutions for Ill-Structured Problems\nof other sub-programs through invocation, and that can access global data\nstructures that are held in the main body of the program. On the right of the\n\ufb01gure, we have an object that provides multiple entry points to the resources\nit provides through di\ufb00erent external methods, that contains permanent en-\ncapsulated data structures, employs both external and internal methods, and\nthat can make use of other objects in a number of di\ufb00erent ways. As we noted in the last chapter, the emphasis placed upon \u2018action\u2019 in pro-\ncesses was challenged by David Parnas (1972) with his ideas about informa-\ntion hiding. Objects incorporate this concept via an encapsulation mechanism\nthat makes it possible to create applications in which the detailed forms used\nto store and organise data elements are only known to a few key parts of a\nsystem. As various ideas began to merge around the concept of objects in the 1980s,\nvarious e\ufb00orts were made to maintain consistency of concepts and terminol-\nogy. A useful contribution to this was made by a working group at Hewlett-\nPackard, for which the \ufb01ndings (in the form of a discussion of exactly what\nobjects are) were reported in (Snyder 1993). A little later, the emergence of the\nUni\ufb01ed Modeling Language (UML) provided a set of ideas about the nature\nof objects that were in\ufb02uenced by abstract modelling. Although originally the\nwork of the \u2018three amigos\u2019\n(Grady Booch, Ivar Jacobson and James Rum-\nbaugh), the UML and its evolution subsequently came under the umbrella\nof the Object Management Group1 (OMG), and at time of writing the latest\nspeci\ufb01cation of the UML is that provided in version 2.5.1 (2017). It is worth\nnoting that the OMG and those involved in the development of the UML\nare essentially \u2018computer industry\u2019 bodies, rather than the sort of grassroots\norganisations that have provided the motivation for Open Source Software\n(OSS) and design patterns. We will return to this issue in a later chapter. So, we can regard an object as some form of software entity that performs\ncomputations and that has a local \u2018state\u2019 of some form that may be modi\ufb01ed\nby the computations.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 159", "position": 159, "chunk_type": "semantic", "token_estimate": 366}
{"text": "142: We will return to this issue in a later chapter. So, we can regard an object as some form of software entity that performs\ncomputations and that has a local \u2018state\u2019 of some form that may be modi\ufb01ed\nby the computations. In particular, an object model:\n\u2022 is organised to provide services to other elements, rather than simply\nto perform actions, usually through a set of methods which are invoked\nfrom other objects, rather as sub-programs are invoked within processes;\n\u2022 enforces strict control of scope (encapsulation) to ensure that data and\noperations within an object are not directly available for use by other\nelements, and can only be accessed through the external mechanisms\nprovided by the object interface;\n\u2022 makes little or no use of \u2018global\u2019 data, such that any data used in an\napplication is stored within objects and normally can only be directly\naccessed by that object. . 1www.omg.org", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 159", "position": 159, "chunk_type": "semantic", "token_estimate": 153}
{"text": "Modelling Objects and Classes: 143\ndata\n(state)\nmethods\n(behaviour)\nexternal\ninvocation\n(method calls)\ninstantiation\n(identity)\nencapsulation\ninternal\nexternal\nFIGURE 10.2: A simple illustration of object characteristics\nAn object also has a distinct identity that allows it to be distinguished\nfrom other objects having the same form. Hence when modelling objects, we\nneed to be able to represent ideas about state, behaviour and identity in some\nway. Figure 10.2 provides a simple illustration of the context and form of an\nobject. We might also note that when modelling objects we will rarely need to\nmodel the use of global data and that the topological form of an application\nwill usually be that of a network of objects rather than a hierarchical \u2018tree\u2019. (Objects may have a hierarchy, in fact, they can have more than one, but\nnot quite in the same sense that we encountered with processes, where the\nhierarchy was usually one of invocation of functional elements.) Moving on from what an object is, to thinking about how we can model it\nwithin the design process, we can identify some key object characteristics as\nfollows. Abstraction This plays an important role in the design process as a whole. It is concerned with describing the external perspective of an object\nin terms of its \u2018essential features\u2019. Abstraction provides a concise de-\nscription of an object, which can then be used to help reason about its\nbehaviour and about its relationships with other objects, without a need\nto possess any knowledge about its internal details. Hence, when modelling objects, an essential property for any form of\n\u2018design object\u2019 is that it should be possible to identify its characteristics", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 160", "position": 160, "chunk_type": "semantic", "token_estimate": 276}
{"text": "144: Software Design: Creating Solutions for Ill-Structured Problems\nin an abstract manner. Identifying the key abstractions needed for an\napplication and modelling their relationships is an important part of the\ndesign process. Encapsulation The concept of information hiding\nis realised through the\nability to conceal the details of an object\u2019s internal organisation and the\nways in which information is represented through some form of encap-\nsulation mechanism. Concealing the implementation details of an object\nmakes it much easier to make changes to them without this having side-\ne\ufb00ects within the rest of the application. Encapsulation is an important\nissue for detailed design and implementation, and when thinking about\nthis at a more abstract level the key question is to identify what should\nbe concealed? Encapsulation and abstraction are largely complementary\nconcepts. Modularity This relates to the division of the overall architecture of an\napplication into major sub-units (which we can consider as being moti-\nvated by \u2018separation of concerns\u2019). In doing so, one important criterion\nto consider is the complexity of the interfaces between the modules,\nwhile another is the likely e\ufb00ects of evolution of the application over\ntime. For processes, the unit of modularity is the sub-program, which is\nlargely organised around function, with relatively little emphasis being\nplaced upon any relationships with data. In an object-oriented context\nwhere there are many forms of uses relationships, the choice of suitable\nmodules becomes rather more complex and multi-faceted. For example,\nobjects do not have a single thread of control, and it may be that the\ndesign of an application needs to allow di\ufb00erent methods to be invoked\nconcurrently, requiring that any consequent changes to variables be suit-\nably protected. The choice of modules is also determined by how the application will\nevolve. Where possible, we should be seeking to isolate major design\ndecisions within separate modules, so that when changes do occur, they\nare largely isolated to a single module. We look at this later when we\ndiscuss the role of architectural patterns in Chapter 15. Hierarchy As noted above, the object model is characterised by the presence\nof several di\ufb00erent forms of hierarchical structure. Within an object\nthat performs complex computations there is the possibility of having\na hierarchy of function, rather similar to that of processes, whereby\na complex task is sub-divided into small elements.", "domains": ["Design Principles", "Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 161", "position": 161, "chunk_type": "semantic", "token_estimate": 387}
{"text": "Modelling Objects and Classes: 145\nBefore we examine the idea of a class hierarchy, there are two other char-\nacteristics of objects that should be mentioned, since they can a\ufb00ect the mod-\nelling process. The \ufb01rst is that new objects can be created at any time\u2014and\nobviously, objects can be deleted too. This creates a dynamically changing\napplication structure, and is a particularly useful feature when a particular\nobject is mainly concerned with representing one item of a set of resources and\nwe want to add new items to the set. However, it also represents a new issue\nin terms of the ideas about design models that we have so far encountered,\nsince the equivalent feature for processes is limited to creating new list ele-\nments when using linked data structures. And a second, related characteristic,\nis that when a client issues a request to one object in a set of objects, it needs\nto be able to identify the object that should be the recipient (taking us back\nto the issue of objects having an identity). 10.1.2\nObjects and classes\nClass\nclass data\nclass methods\nobject 'template'\nobject\ndata\nObject\nexternal methods\nFIGURE 10.3: Instantiating an object from its class\nViewed in terms of their implementation roles, a class speci\ufb01cation can\nbe regarded as a form of \u2018template\u2019 that can be used to create objects. The\nclass de\ufb01nes the state and behaviour attributes of an object, and when an", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 162", "position": 162, "chunk_type": "semantic", "token_estimate": 240}
{"text": "Modelling Objects and Classes: Such a coupling is assumed\nto exist if one class uses methods or instance variables from another class,\nand an excessively high value of CBO is considered to be an indicator of poor\nmodular design as well as an impediment to reuse. Coupling can take a range\nof forms: invocation of a method, inheritance, copying the value of a variable. The metric treats coupling as a two-way link, and so calculation of CBO needs\nto count both the classes that use a class and also those that it uses, as shown\nin the example of Figure 10.6. In the example, the solid lines indicate that one object calls methods in\nanother (such as the line between class A and class B) while the dashed line\nbetween class A and class C indicates a di\ufb00erent form of coupling, such as\ninheritance (class C inheriting from class A). As often, the empirical \ufb01ndings about the usefulness of CBO are rather\nmixed, but overall, it was found to have \u201cmoderate predictive ability\u201d with", "domains": ["Design Principles"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 168", "position": 168, "chunk_type": "semantic", "token_estimate": 174}
{"text": "152: Software Design: Creating Solutions for Ill-Structured Problems\nclass B\nclass A\nclass D\nclass C\nCBO(A)=2\nCBO(B)=2\nCBO(C)=3\nCBO(D)=1\nFIGURE 10.6: Simple illustration of CBO measures\nregard to fault-proneness. Two useful observations from a design perspective\nare that:\n\u2022 the presence of one class having a high value of CBO, while others have\na CBO of 1, may indicate that a call-and-return design model has been\nmapped on to an object structure;\n\u2022 the presence of many classes with high CBO may indicate that the\nmodularity in the design model is too granular, and that the classes\nare too small, requiring that they have to make use of other classes in\norder to perform their tasks. Response for a Class (RFC) is a measure that seeks to re\ufb02ect the in\ufb02uence\nof the \u201cimmediate surroundings of a class\u201d, in other words, the methods that it\nuses directly. The response set of a class is the set of methods that are accessed\nby the set of methods belonging to an object of that class (which may include\naccess to other methods within the class). This is a static measure, and so\nidenti\ufb01es the set of methods that might potentially be executed if a message\nis sent to one of the methods in an object of that class. It is de\ufb01ned as:\nX\n(localmethods) +\nX\n(methodscalledbylocalmethods)\nand Figure 10.7 shows a simple illustration of this. As a measure, the larger the number of methods that can be invoked from\nan object, the greater will be its complexity in terms of the e\ufb00ort needed to\ncomprehend its operation, and of the level of understanding needed to test it.", "domains": ["Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 169", "position": 169, "chunk_type": "semantic", "token_estimate": 276}
{"text": "154: Software Design: Creating Solutions for Ill-Structured Problems\nAn object...\n...embodies an abstraction that is meaningful\nto its clients\n...possesses a state, which can be inspected\nand changed through its methods\n...exhibits behaviour through its responses to\nexternal events\n...possesses an identity, since more than one\nobject may be created from a class\n...provides services (through methods) that\ncharacterise the abstraction, and that may\naccess or modify data within an object, and\nmay affect (use) other objects\n...is encapsulated so that clients cannot\ndirectly access data associated with an \nobject\n...provides services through the interfaces that\nit provides to clients\n...can have a common implementation so that\nobjects may share code (but usually not data)\nFIGURE 10.8: Key characteristics of an object\ncall-and-return style, the abstract model is one that is described in terms\nof statically linked sub-programs, with these having well-de\ufb01ned functional\nroles. The control and data topologies are also more or less the same, so that\nthe task of mapping a design model on to a given procedural programming\nlanguage is a relatively straightforward process. Likewise, the pipe-and-\ufb01lter\nstyle employs fairly simple architectural elements, and again, both control and\ndata topologies are closely linked, assisting with the eventual implementation. When employing the object-oriented style, the basic concepts used for for-\nmulating the abstract design model, as well as for mapping it on to some form\nof implementation, are somewhat more challenging. To take a simple exam-\nple, we noted earlier that observational studies of designers showed that they\noften \u2018mentally executed\u2019 their design models, to ensure that these exhibited\nthe intended behaviour. This is a relatively straightforward exercise with a de-\nsign model formulated using a style such as call-and-return, but a potentially\nmuch more complex task when realising a design using objects. The di\ufb00ering\ncontrol and data topologies, together with dynamic binding of methods and\nmultiple threads of execution within an object, all combine to make this more\nchallenging. Experts know how things work. PvdH #33", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 171", "position": 171, "chunk_type": "semantic", "token_estimate": 329}
{"text": "Modelling Objects and Classes: 155\nOne of the arguments sometimes made for adopting the object-oriented\nstyle is that it is more \u2018natural\u2019 than (say) call-and-return. Objects and their\ninteractions can be recognised in the everyday world, whereas call-and-return\nuses a model which more closely re\ufb02ects the workings of the computer itself. Hence (so the argument goes), the process of analysis should involve identi-\nfying the objects in the problem domain, and then use the resulting model\nto help with deciding upon a set of corresponding \u2018solution objects\u2019. However,\nin practice this has not proved to be a particularly e\ufb00ective strategy, and as\nD\u00e9tienne (2002) observes:\n\u201cearly books on OO emphasised how easy it was to identify objects\nwhile later ones, often by the same authors, emphasise the di\ufb03culty\nof identifying them\u201d\nwhich rather undermines the case for \u2018naturalness\u2019 and for any modelling\nbased upon it. That said, D\u00e9tienne also notes that comparative studies have\ndemonstrated that:\n\u2022 object-oriented design tends to be faster and easier than the procedural\n(structured) design approaches discussed in Part III;\n\u2022 di\ufb00erent designers will produce solutions that are more similar when\nusing an object-oriented approach than when using other approaches;\nsuggesting that once the necessary levels of knowledge have been acquired by\nthe designer, the object-oriented style may have more to o\ufb00er. An important issue here would appear to be the relatively steep learning\ncurve involved in learning about object-oriented design. Studies by Fichman\n& Kemerer (1997), Vessey & Conger (1994) and Sheetz & Tegarden (1996)\nall observed that inexperienced designers struggled to acquire and deploy the\nconcepts. In the study by Sheetz & Tegarden (1996), they speci\ufb01cally identi\ufb01ed\nthe following object-centred design issues as contributing to the problems by\nacting as sources of confusion for the inexperienced designer. \u2022 Organising the distribution of application functionality from the \u2018prob-\nlem space\u2019 across a set of objects. (In other words, identifying the ob-\njects.) \u2022 Using the existing class hierarchy. \u2022 Designing classes (including making use of inheritance). \u2022 Using polymorphism, where the semantics of methods with the same\nname may di\ufb00er. \u2022 Evaluating solutions (see earlier comment about mental execution). \u2022 Communication among objects. \u2022 Designing methods.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 172", "position": 172, "chunk_type": "semantic", "token_estimate": 362}
{"text": "Modelling Objects and Classes: class name\nclass name\nclass name\nclass name\nlist of\nattributes\nlist of\nattributes\nlist of\noperations\nlist of\noperations\nFIGURE 10.9: The UML class notation\nThe UML has adopted the use of a box in its class diagram, and classes\ncan be represented using boxes with three compartments, two of which are\noptional. A class can simply be represented by a box containing the class name,\nwhich is probably su\ufb03cient when the class is \ufb01rst included in the model. The\ntwo optional compartments are the attributes, with the state of an object\nof the class at any time being determined by their values; and a list of the\noperations that the class provides through its methods. The resulting forms,", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 174", "position": 174, "chunk_type": "semantic", "token_estimate": 124}
{"text": "Modelling Objects and Classes: 159\nCar\nlocation\navailability\nfuel level\noffered\nreserve()\nrelease()\nbeginHire()\nendHire()\nselected:Car\nFIGURE 10.10: The UML class-object notations\nso are not addressed here. More details about these features can be obtained\nfrom specialist texts on OO modelling such as (Arlow & Neustadt 2005) or\n(Lunn 2003). 10.5.2\nClass relationships\nIn order to make use of the class and object notations we need to be able\nto model the di\ufb00erent relationships that can occur between them. These are\ngenerally drawn as one or more object diagrams that represent the structure\nof an application at some point in time. At its most basic an object diagram\nforms a network model that describes the interactions between a set of objects,\nwhere these interactions chie\ufb02y consist of method calls. (The UML refers to\nthe links between classes as associations.) In the same way that we employ the concept of arity with entity-\nrelationship diagrams, when modelling relationships between classes it may\nbe useful to indicate whether a relationship between two classes is on a one-\nto-one, one-to-many or many-to-many basis. The emphasis here is upon may. If the application consists of a small number of objects, with only one object\nfrom each class, there is little point in cluttering up the model with informa-\ntion about the multiplicity of the relationship. Available Car\nCCC site\n1\n0..*\nAvailable Car\nCustomer search\n1..3\n0..*\nFIGURE 10.11: Use of class multiplicity annotation\nFigure 10.11 illustrates the use of multiplicity for two simple examples\nfrom the CCC. The upper one indicates that a CCC site (assuming that CCC", "domains": ["Software Quality Attributes", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 176", "position": 176, "chunk_type": "semantic", "token_estimate": 265}
{"text": "160: Software Design: Creating Solutions for Ill-Structured Problems\nexpand their business to other cities) can have between zero and many cars\navailable. The lower one indicates that a car that is available can respond to\nany number of requests, but that the \u2018search object\u2019 for a customer may only\nselect up to three cars. Horri\ufb01ed purist\nThe UML has some less than inspiring no-\ntations for indicating di\ufb00erent forms of relation-\nship between classes. However, it also provides\nthe quite useful concept of a stereotype, which\ne\ufb00ectively allows a new modelling element to be\nintroduced that is based upon an existing one. Stereotypes are created by placing the name of\nthe stereotype between guillemots (\u00ab...\u00bb) and us-\ning it to label the line indicating the relationship. Although it might horrify a UML purist, using\nstereotypes as a means of clarifying intended re-\nlationships, especially when sketching, may be\nmuch clearer than using the graphical symbols\nde\ufb01ned in the UML. When describing class\u2013instance relationships\nwe might therefore use the stereotype \u00abinstanti-\nate\u00bb. Another useful one is \u00abuse\u00bb (this one is so obvious that it can simply\nbe treated as a default). The role of \u00abcreate\u00bb is likewise obvious. Although\nnot advocated by the UML, it may also be useful to use stereotypes for other\nrelationships such as \u00abinherit\u00bb and \u00abaggregate\u00bb. Reducing the number and\ncomplexity of symbols is a useful step when dealing with objects and doing\nso in this way reduces the cognitive load. It also demonstrates that you don\u2019t\nhave to use the formal semantics of a notation, especially when sketching ideas. Van\nVehicle\nCar\nVan\nVehicle\nCar\n<<inherits>>\nFIGURE 10.12: UML class inheritance annotation versus using stereotypes\nFigure 10.12 shows the conventional UML notation for inheritance on the\nleft, and the use of a stereotype on the right. There is de\ufb01nitely an argument in\nfavour of using the stereotype for showing such a diagram to anyone unfamiliar\nwith the UML, as well as when sketching on a whiteboard. However, one thing\nthat can be harder to capture this way is the direction in which the \u2018\ufb02ow\u2019 of\ninheritance should be read (although many might \ufb01nd the UML notation\nconfusing anyway, in terms of the apparent \u2018\ufb02ow\u2019 implied by the triangle). So", "domains": ["Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 177", "position": 177, "chunk_type": "semantic", "token_estimate": 373}
{"text": "Modelling Objects and Classes: 161\ncareful positioning of the indexstereotype stereotype or using an additional\narrowhead as shown here might sometimes be helpful. Other forms of association, including aggregation and composition can be\nused when modelling classes and objects. And of course, we can add polymor-\nphism and abstract classes to our use of inheritance. All of this explains why\nbooks on modelling with the UML tend to be large\u2014as classes and objects\nare much more complex design elements than processes. So, in fairness, while\nthe UML itself may often be cumbersome as a modelling tool, it is required\nto provide ways of modelling some potentially very complex structures. 10.6\nModelling behaviour: the statechart and the mes-\nsage sequence diagram\nThe idea of state plays a much bigger role for objects than it does for\nprocesses, not least because the use of encapsulation means that an object is\nvery likely to contain persistent information related to its role and identity. And because an object can have many external methods, there can also be\nmany ways of accessing and modifying that state. Object modelling commonly makes use of two forms for modelling be-\nhaviour. The statechart (or \u2018state diagram\u2019) is used to model the way that the\nstate of some entity (which may be an object, or a subsystem, or a complete\napplication) is modi\ufb01ed by interaction with the events occurring in the ex-\nternal world. And the message sequence diagram, or message sequence graph\n(MSG) can be used to model the way that events are triggered and handled\nover time. Actually, sequence diagrams are not entirely about behaviour, they\ncan also be viewed as describing some aspects of function, highlighting the\nproblem with any simple classi\ufb01cation system! However, regardless of how we\nclassify them, sequence diagrams (or sequence graphs; both terms are used)\nrepresent a useful modelling tool for thinking about the interactions that occur\nbetween objects. 10.6.1\nThe statechart\nLike the state transition diagram that was described in Section 9.3, the\nstatechart is concerned with describing the behaviour of a \u2018system\u2019 as a form\nof \ufb01nite-state automaton, or \ufb01nite-state machine. Used at the system level\nit can be a good way of modelling the behaviour of reactive applications,\nresponding to external events. Used at the object level, it can describe how\nan object responds to the requests created by its \u2018response set\u2019.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 178", "position": 178, "chunk_type": "semantic", "token_estimate": 393}
{"text": "162: Software Design: Creating Solutions for Ill-Structured Problems\n(Harel 1987, Harel 1988). It provides a rather more \ufb02exible modelling form\nthan the STD, and in particular, it incorporates the facility for creating a hier-\narchy of abstractions. It also o\ufb00ers the facility to describe transitions that are\northogonal, in the sense that they can occur completely independently of each\nother, so making it possible to model transitions that can occur in parallel. And like the STD, it can be used to model the behaviour of a \u2018problem\u2019 (black\nbox) as well as of a \u2018solution\u2019 (white box). The UML has largely adopted the\nform of statechart devised by Harel (but of course, not quite). The original paper (1987) provides an excellent tutorial on statecharts and\ntheir powers of description. In this, the author uses the functions of a digital\nwatch with two alarms to provide examples. Our examples here are somewhat\nless dramatic and extensive, but should provide essential ideas about how to\nuse this form. A state is denoted by a box with rounded corners, labelled with the name\n(identi\ufb01er) for the state in the top of the box. Hierarchy is represented by\nencapsulating states within states, and directed arcs are used to represent a\ntransition between states. The arcs are also labelled with a description of the\nevent that triggers that transition, and optionally, with a parenthesised con-\ndition. (Conditions are quite common in the real world. For example, it might\nnot be possible to engage a cruise control mechanism in a car\u2014representing\na change in its state\u2014while the car is accelerating.) engine off\nstart\nignition off\nengine running\nidling\nmove \nforward\nreverse\nselect\ngear\nbrake\nbrake\nengage\nFIGURE 10.13: A simple statechart describing driving a car\nFigure 10.13 uses a statechart to provide a very simple state model that\ndescribes the use of a car. At the top level it simply has two states that\nrepresent the car when the engine is o\ufb00and when it is running. The default\ninitial state is indicated by the short arrow with a black dot on the end. Transitions between these states are caused by pressing the starter (or waving\na card) and by turning the ignition o\ufb00. There are three sub-states when the\nengine is running. The initial state has the engine idling and no gear selected.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 179", "position": 179, "chunk_type": "semantic", "token_estimate": 387}
{"text": "162: There are three sub-states when the\nengine is running. The initial state has the engine idling and no gear selected. To change to going forward we select a gear, and to stop we brake (OK, there\nare other ways, but this is a simpli\ufb01ed diagram). Engaging reverse we have\nlabelled the transition as \u2018engage\u2019 to emphasise that there is usually only one", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 179", "position": 179, "chunk_type": "semantic", "token_estimate": 63}
{"text": "Modelling Objects and Classes: 163\nsuch gear, and again, stopping involves braking. And of course, there are no\ntransitions between going forwards and reverse (again, this might be possible,\nbut it is usually extremely unwise). This is a very simple model that wouldn\u2019t even be recommended for one\u2019s\n\ufb01rst driving lesson (it doesn\u2019t allow for slowing down and accelerating when\nmoving forward as one example), but it is su\ufb03cient to show the essential ideas,\nand particularly the use of hierarchy. cruising\nin flight\nlanding\napproach\nstacked\non ground\nparked\ntaxiing\ntouch down\ntake-off\nFIGURE 10.14: A simple statechart describing an aircraft in an ATC system\nModelling watches and cars has the advantage that the events that cause\ntransitions between states are directly identi\ufb01able in terms of button presses\nor using a gear lever. Figure 10.14 reworks the example provided in Figure\n9.6, describing an air tra\ufb03c system, to use a statechart formalism. (Some of\nthe labels for the internal transitions have been omitted for clarity.) When comparing this with the STD used in Figure 9.6, we can see that\nwhile the descriptions of state, event and transition are common to both, the\nSTD provides a more detailed description in terms of the associated actions,\nwhile the statechart has more re\ufb01ned mechanisms for describing abstraction,\ndefaults and scale. The lack of hierarchy limits the STD to being used to de-\nscribe the behaviour of individual design elements, whereas the statechart can\nbe used to describe complete systems through a hierarchy of diagrams and\nstates. To some degree the strengths of the two forms are probably comple-\nmentary, with the STD perhaps being more suited to modelling descriptions\nof \u2018problems\u2019 and the statechart being better suited to describing detailed\n\u2018solutions\u2019. The remaining major feature of the statechart that should be described\nhere is orthogonality. Our example here, shown in Figure 10.15, is rather more\nabstract in order to highlight the mechanisms involved.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 180", "position": 180, "chunk_type": "semantic", "token_estimate": 320}
{"text": "b: a\nb(P)\nFIGURE 10.15: Describing orthogonality in the statechart formalism\nIn our example, state \u2018A\u2019 can be described as being a superstate of two or-\nthogonal states \u2018B\u2019 and \u2018C\u2019. These can in turn be described in terms of further\nstates \u2018D\u2019 to \u2018G\u2019 but the two states involve what are essentially independent\ngroupings. However, events may be common as can be seen from the descrip-\ntion of the transitions that occur in response to event \u2018a\u2019. Also, in describing\nA, note that we need to identify the default entry to both states \u2018B\u2019 and \u2018C\u2019\n(the inner states \u2018D\u2019 and \u2018F\u2019). There is also a conditional transition between\nstates \u2018F\u2019 and \u2018G\u2019, where an event \u2018b\u2019 will cause a transition only if condition\n\u2018P\u2019 is satis\ufb01ed. The statechart is a powerful modelling tool for thinking about objects,\nand can also be used for modelling of executable use cases/scenarios (Harel &\nGery 1997). Again, it is easily sketched on a whiteboard or on paper. 10.6.2\nThe message sequence diagram\nSequence diagrams have proved to be particularly useful with object-\noriented modelling. This is probably at least in part because they provide\na means of modelling the interactions between di\ufb00erent elements of a system,\nwhether these be objects, actors, remote processes, or client and server. Since\nessentially they model collaboration, in this case object collaboration, they\ncan be used with any architectural style that has loosely coupled elements. Sequence diagrams can also be useful for modelling the interactions in-\nvolved in a use case (or more correctly, in a speci\ufb01c scenario). Use cases have\nproved to be a useful tool for modelling object-oriented systems, so this tends\nto reinforce the value that they have for this type of modelling. The UML\n(inevitably) incorporates sequence diagrams, describing their form as follows. \u201cA diagram that shows object interactions arranged in time se-\nquence. It shows the objects participating in an interaction and the\nsequence of messages exchanges\u201d (Rumbaugh et al. 1999).", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 181", "position": 181, "chunk_type": "semantic", "token_estimate": 329}
{"text": "interface: Bank\ncustomer\nBank\naccount\nBank\nvalidation\nInsert\ncard\ncheck\nvalid\ncard\nrequest PIN\nenter PIN", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 182", "position": 182, "chunk_type": "semantic", "token_estimate": 16}
{"text": "Modelling Objects and Classes: 167\nthis form of consistency is a challenge, particularly during more detailed design\nactivities. 10.7\nModelling function: the activity diagram\nOne viewpoint where the UML does make a useful contribution to the\nset of notations is the functional viewpoint. UML activity diagrams can be\nused to model the way that a business operates and, like DFDs, can help\nwith analysing the needs of a problem. (There are no really good notations\nfor describing function when using objects. This is perhaps not surprising as\nunlike many processes, an object often doesn\u2019t have a single functional task.) In particular, an activity diagram can be useful for modelling the type\nof \u2018coordinating\u2019 situation where a given computation cannot proceed until\ncertain conditions are met (for example, new data is available and a prior\ncomputation has completed). The diagram does model states, but these now\nrepresent the performance of actions, and the focus of interest is upon what\ntriggers transitions between the states. This emphasis upon action is why it\nhas been categorised as functional here. However, rather as with sequence\ndiagrams, an activity diagram can be viewed as providing a mix of functional\nand behavioural aspects in its description. Some key notational elements are as follows. \u2022 The activity, which is a task performed by the application and is shown\nas a named box with rounded sides. \u2022 A state, which can be viewed as being an activity where nothing happens. \u2022 A transition, where work \ufb02ows between activities, shown as an unlabelled\narrow. The lack of a label is because, unlike the case of a statechart,\nthe transitions arise from the actions of the activities themselves, not\nbecause of external events. \u2022 A decision, represented by a diamond, where a work\ufb02ow divides between\npossible branches. When used, it is then necessary to label the transitions\nto indicate which condition is employed for a particular route. \u2022 The synchronisation bar is a thick horizontal line that represents the\ncoordination of the activities. When all of the transitions into a bar\nare complete (the coordinating bit) then the outward transitions will be\n\u2018\ufb01red\u2019. Entry and exit from a diagram are shown respectively by a short arrow with\na \ufb01lled dot on its tail, and a \ufb01lled dot with a circle around it. There can only", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 184", "position": 184, "chunk_type": "semantic", "token_estimate": 385}
{"text": "Chapter 11: Modelling Software Components and\nServices\n11.1\nReuse .............................................................\n178\n11.2\nModelling software components ..................................\n180\n11.2.1\nComponent characteristics ..............................\n181\n11.2.2\nComponent frameworks .................................\n183\n11.2.3\nDesigning components ...................................\n185\n11.2.4\nCOTS ....................................................\n186\n11.3\nModelling software services ......................................\n187\n11.4\nEmpirical knowledge about modelling components and services\n190\n11.4.1\nEmpirical knowledge about components ................\n190\n11.4.2\nEmpirical knowledge about services .....................\n191\nKey take-home points about modelling components and services\n191\nThis chapter looks at two quite di\ufb00erent approaches to the idea of reusing\nsoftware that has been developed by others. The concept of the software com-\nponent has been around for many years\u2014indeed, the concept of reusable blocks\nof software was put forward at the inaugural Software Engineering conference\nin 1968 by Doug McIlroy. Building on this concept, Component-Based Soft-\nware Engineering (CBSE) has had the goal of enabling a software developer\nto be able to make use of pre-existing reusable \u2018chunks\u2019 of software in order\nto create (or \u2018compose\u2019) an application. In many ways the service paradigm\nrepresents an evolution of this idea. While it largely aims to do the same\nthing, the means of realising it is very di\ufb00erent. Here the software itself is\nprovided by third parties, and is hosted and executed elsewhere (typically in\nthe cloud) rather than being embedded within the application, enabling easy\nsubstitution of di\ufb00erent providers. Each of these technologies poses challenges regarding both about how to\ndesign the reusable elements themselves as well as how to design an application\nto make use of existing resources. For the moment though, we concentrate\non the forms those resources can take and how to model them, leaving the\nquestion of how to design applications around them until a later chapter. However, since reuse is so important for both, we begin by discussing its role\nand in\ufb02uence. 177", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 194", "position": 194, "chunk_type": "semantic", "token_estimate": 306}
{"text": "178: Software Design: Creating Solutions for Ill-Structured Problems\n11.1\nReuse\nFor other domains in which design performs an important role, the idea\nof reuse is fairly well established and takes a range of forms. It is sometimes\nassociated with the abstract reuse of design ideas and experiences, rather than\nof physical elements, and we will look at this aspect in Chapter 15 when we\nexamine how the concept of a pattern can be employed. Where the manufacturing cycle is important, then it is also associated\nwith the interchangeability of physical components, not least because creating\n\u2018product lines\u2019 can help reduce the cost of the individual product1. Mechanical\nengineering in its many forms makes extensive use of components, as do the\nelectrical engineering and construction industries. In all of these, the use of\nstandardised units helps with manufacture and maintenance. Their use also\nchanges the nature of the design process by introducing the notion of compo-\nsition. Organisational and other processes themselves can be reused too. We can\nsee this in the way that production lines in factories can be re-organised and\nre-purposed to create new products. Successful reuse of pre-existing elements is commonly based upon two im-\nportant characteristics. \u2022 The \ufb01rst is that the role of a reusable component is associated with\nsome well-de\ufb01ned functionality. Most physical components have very\nwell-de\ufb01ned roles (switch, pump, door handle, starter motor, etc.) mak-\ning it possible for the designer to select suitable items from a catalogue. \u2022 Secondly, the components themselves usually have well-de\ufb01ned inter-\nfaces, enabling ready composition with other components that meet the\nsame standard, as well as easy substitution of one manufacturer\u2019s com-\nponent with one from another maker. This can also help with identi\ufb01-\ncation of suitable ones in a catalogue. In manufacturing this can mean\nthat there may be several manufacturers who are able to provide a par-\nticular component (\u2018second sourcing\u2019), providing users with con\ufb01dence\nthat they will be able to obtain adequate supplies. These are not accidental properties, but rather, they are ones that arise from\neconomic factors. These factors include the need to minimise the cost of fabri-\ncating an item; pressure to maintain a marketplace position; and the end-user\u2019s\nneed to protect their supply chain (here the end-user will be the manufacturer\nwho is making use of a given component in their own product).", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 195", "position": 195, "chunk_type": "semantic", "token_estimate": 391}
{"text": "178: These are not accidental properties, but rather, they are ones that arise from\neconomic factors. These factors include the need to minimise the cost of fabri-\ncating an item; pressure to maintain a marketplace position; and the end-user\u2019s\nneed to protect their supply chain (here the end-user will be the manufacturer\nwho is making use of a given component in their own product). The adoption\n1One of the earliest examples of a product line is probably when Sir Marc Brunel (fa-\nther of Isambard Brunel) established his block-making machinery in Portsmouth dockyard\naround 1806. This introduced an important element of standardisation in the \ufb01tting out of\nsailing ships, which used large numbers of blocks as part of their rigging.", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 195", "position": 195, "chunk_type": "semantic", "token_estimate": 120}
{"text": "Modelling Software Components and Services: 179\nof interface standards may be motivated in a number of ways: one manufac-\nturer may be so dominant that their interface becomes widely accepted; an\nindustry (or professional body) may take on the role of de\ufb01ning the necessary\nstandards (as has happened widely with electrical connectors); or a group of\nmanufacturers may come together to agree on a common standard. Reuse can be facilitated by the availability of catalogues of components. However, the way that such catalogues are used during the design process\nappears to be less well understood. Pugh (1991) provides an example of this\nin the domain of electronic engineering, in quoting from Cooke (1984). \u201cThe designer of electronic-based products has available an enor-\nmous range of basic building blocks of high or still increasing com-\nplexity. What he often does not have is either training or well-\nestablished conceptual tools for working out levels of sophistica-\ntion.\u201d\nSimilarly, in Pahl & Beitz (1996), a textbook that is widely cited as a repos-\nitory of engineering design knowledge, the discussion of \u2018design catalogues\u2019\nis almost entirely con\ufb01ned to consideration of how such a catalogue will be\nconstructed rather than how it might be used. If we turn our attention to the reuse of software, we \ufb01nd that, despite the\nlack of a manufacturing phase, reuse of software components has had a long\nhistory of success in some areas. An often-cited example is the set of mathe-\nmatical and statistical functions provided in the NAG (Numerical Algorithms\nGroup) library that was \ufb01rst released in 1971. The set of functions and the\nprogramming languages supported has gradually expanded over the years, and\nthe routines it provides do of course meet our two criteria above, having well-\nde\ufb01ned functionality and well-de\ufb01ned interfaces. Other examples include user\ninterface packages such as tk and tools such as MATLAB R\n\u20ddthat provide an\nenvironment of \u2018components\u2019. Component models such as CORBA (Common\nObject Request Broker Architecture) have assisted further by de\ufb01ning inter-\nface standards to enable local and distributed components, possibly written\nusing di\ufb00erent programming languages, to work together. However, because software is so easily adapted and modi\ufb01ed, it would\nalso be true to say that examples of wide reuse, in the sense of embodying one", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 196", "position": 196, "chunk_type": "semantic", "token_estimate": 378}
{"text": "180: Software Design: Creating Solutions for Ill-Structured Problems\nsoftware product within another, are relatively rare. Where they do occur then\nthere may be special factors that constrain this freedom. (Network protocols\nprovide a good example of this\u2014there is little point in producing unique\nnetwork protocols if you want your software to work with other applications.) Indeed, although the bene\ufb01ts of reuse are often extolled by software en-\ngineers (and vendors of software), for example, when considering the bene\ufb01ts\nof an architectural form such as the object model, attempts to incorporate\nit more fully into software development practices have not been widely suc-\ncessful. In the rest of this chapter we describe two approaches to software\ndevelopment that focus on reuse, and examine the issues associated with their\ncreation and use. 11.2\nModelling software components\nThe idea of component-based software engineering (CBSE) began to attract\ngreater attention in the 1990s, and in some ways the concept of a component\nformed an evolution of the idea of the object. And, as with objects, ideas about\nprecisely what constitutes a component could be di\ufb03cult to pin down. Indeed,\nwhen writing an introduction to a special journal section on CBSE, Brown &\nWallnau (1998) observed (slightly tongues-in-cheeks), that:\n\u201cCBSE is a coherent engineering practice, but we haven\u2019t fully\nidenti\ufb01ed just what it is\u201d. Note though, the use of the word \u2018practice\u2019, as it could certainly be argued\nthat one of the motivations of research into CBSE was to seek something that\ncould be more tractably \u2018engineered\u2019 and composed together than objects. One of the challenges of codifying CBSE was to determine just what a\ncomponent is. An early de\ufb01nition from Brown & Short (1997) very concisely\ndescribed a component as:\n\u201can independently deliverable set of reusable services\u201d. Note too that this de\ufb01nition made no explicit assumptions about architectural\nstyle\u2014so that a component could be realised as anything from an object to\nan operating system. The emphasis here is upon reuse (needing a clearly\nspeci\ufb01ed interface) and upon the idea of independent delivery. This second\naspect is important since it implies that a component should not be aware of its\ncontext, especially in terms of any embedded dependencies or the expectation\nof the presence of some shared resource. There is also the implication that a\ncomponent needs to be integrated with other components in order to provide\nthe overall system functionality.", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 197", "position": 197, "chunk_type": "semantic", "token_estimate": 396}
{"text": "180: This second\naspect is important since it implies that a component should not be aware of its\ncontext, especially in terms of any embedded dependencies or the expectation\nof the presence of some shared resource. There is also the implication that a\ncomponent needs to be integrated with other components in order to provide\nthe overall system functionality. In other words, it is a part, rather than a\nwhole.", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 197", "position": 197, "chunk_type": "semantic", "token_estimate": 70}
{"text": "Modelling Software Components and Services: 181\nThe pioneering text on software components by Szyperski (1998) provided\na rather more extensive de\ufb01nition of what a component was considered to be. \u201ca unit of composition with contractually speci\ufb01ed interfaces and\nexplicit context dependencies only. A software component can be\ndeployed independently and is subject to third-party composition.\u201d\nWhile addressing the same properties as the more abstract de\ufb01nition provided\nby Brown and Short, this added the concept of black box reuse, required if it\nwas to be used by third parties. A slightly more evolved de\ufb01nition was that provided in Heineman & Coun-\ncill (2001), where a software component was de\ufb01ned as:\n\u201ca software element that conforms to a component model and can\nbe independently deployed and composed without modi\ufb01cation ac-\ncording to a composition standard\u201d\nThis de\ufb01nition is interesting because it separates out two further supporting\nconcepts, which are those of:\n\u2022 the component model that incorporates \u2018speci\ufb01c interaction and compo-\nsition standards\u2019; and\n\u2022 the composition standard, that \u2018de\ufb01nes how components can be com-\nposed\u2019 to create a larger structure. Both of these are important concepts in terms of considering how we can design\nwith components, and also how components themselves should be designed in\norder to be usable. Indirectly, they also raise the question of architectural style,\nand the extent to which the process of composition may need to be con\ufb01ned\nto applications using an architectural style that conforms to the \u2018standard\u2019\nbeing used. None of these de\ufb01nitions are really contradictory. Where they di\ufb00er is in\nthe level of abstraction required to express the ideas, and which of the many\naspects of a component they emphasise. It is worth noting that there may also\nbe business factors that in\ufb02uence the component model and its acceptance\n(Brereton & Budgen 2000) (a more business-focused view of CBSE is also\npresented in Brown (2000)). And as we will see when addressing the second topic of this chapter, the\nevolution of these de\ufb01nitions has distinct parallels with the emergence of the\nidea of a software service. 11.2.1\nComponent characteristics\nOf course, not only have ideas about the nature of a component evolved\nsince the concept was \ufb01rst envisaged in 1968, the forms of components have\ntoo. As Crnkovic, Sta\ufb00ord & Szyperski (2011) observe:", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 198", "position": 198, "chunk_type": "semantic", "token_estimate": 379}
{"text": "182: Software Design: Creating Solutions for Ill-Structured Problems\n\u201cStarting as elements of source code, such as routines, procedures,\nmethods or objects, they transformed to architectural units and\nready-to-execute blocks that are dynamically plugged into the run-\nning systems.\u201d\nIn discussing the idea of reuse, the two characteristics that were identi\ufb01ed\nas being essential for a component of any form were:\n\u2022 well-de\ufb01ned functionality\n\u2022 well-de\ufb01ned interfaces\nA further characteristic, which is probably implicit for non-software forms of\ncomponent, but which needs to be explicitly stated for software components\n(because of the nature of software) is that of independence. This avoidance of\nany context-speci\ufb01c dependencies follows on from the ideas above. In practice\nof course, some dependencies are di\ufb03cult to avoid, particularly where these\nrelated to issues such as architectural style, but where these do exist, they need\nto be made fully explicit. Figure 11.1 illustrates this set of characteristics. Component\n(black box)\nInterface\nFunction\nDependencies\nFIGURE 11.1: Characteristics of a software component\nIf we look at other domains, we might note that there are often implicit\ncontext-speci\ufb01c dependencies. For example, the starter motor for a car will\ndepend upon the availability of an electrical supply with a speci\ufb01c voltage\nand power rating. However, software dependencies can be more subtle, and\nso to ensure that a software component can be treated as a black box as far\nas is reasonably possible, such dependencies need to be made explicit in the\nspeci\ufb01cation. (As an example of the need for this, and of the di\ufb03culty of\nensuring it is comprehensively achieved, see the analysis of the $500 million\nfailure of the Ariane 5 rocket in 1996 that is provided in J\u00e9z\u00e9quel & Meyer\n(1997).)", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 199", "position": 199, "chunk_type": "semantic", "token_estimate": 281}
{"text": "Modelling Software Components and Services: 183\nWe might note here that the UML component diagram is a very speci\ufb01c\ninterpretation of the concept and of little use in a CBSE context. Indeed,\nperhaps because the concept of a component lacks any association with a\nspeci\ufb01c architectural style, there are no diagrammatical forms that have been\nwidely used for modelling CBSE implementations. However, that said, many aspects of component use can be modelled using\nexisting notations. In particular, issues related to functional and behavioural\nmodelling can often be modelled using the forms commonly used with objects,\nsuch as activity diagrams, statecharts and sequence diagrams. What is not so\nreadily modelled is the constructional viewpoint, although for many purposes,\ncomponents can be modelled by adapting existing forms of class diagram. 11.2.2\nComponent frameworks\nCommonality of architectural style does not guarantee that components\nof di\ufb00erent origins can be easily integrated to create an application. This is-\nsue, termed architectural mismatch was \ufb01rst identi\ufb01ed in the context of seek-\ning to compose an application by making use of existing objects (Garlan,\nAllen & Ockerbloom 1995). Attempts to create new applications from ob-\njects that had been created by di\ufb00erent sources revealed that these made dif-\nferent, and incompatible, assumptions about the way that the object model\nwas organised. When the original analysis was revisited in (Garlan, Allan &\nOckerbloom 2009), the authors concluded that the reuse of components still\nformed a challenge, and indeed, that while the expanded computing landscape\nhad reduced some of the earlier problems, it also introduced new ones. What sort of assumptions created the problems? In the original (1995)\nstudy there were four general categories of assumptions that could result in\nmismatch. These were:\n\u2022 the nature of the (other) components, including the control model;\n\u2022 the nature of the connectors and the protocols used;\n\u2022 the global architectural structure; and\n\u2022 the construction process. There were also three aspects regarding the ways that components interact\nwhere assumptions could produce mismatch: the infrastructure; the appli-\ncation itself; and interactions between peer components. None of these were\nissues that are strictly matters of design, although they might constrain design\nchoices. The later study identi\ufb01ed some changes that had altered the situation;\ngreater use of reusable infrastructure; use of standard interfaces such as web\nbrowsers; extensive use of open source software; and more sophisticated devel-\nopment environments.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 200", "position": 200, "chunk_type": "semantic", "token_estimate": 395}
{"text": "184: Software Design: Creating Solutions for Ill-Structured Problems\nsuch issues as trust between components; dynamic recon\ufb01guration of systems;\nsystem evolution; and technical debt in the form of being locked into a speci\ufb01c\narchitecture. The idea of the framework as a means of imposing a common component\nmodel has formed an important element in the evolution of CBSE and of com-\nponents themselves. It has also helped to address many of the issues identi\ufb01ed\nabove. While early ideas, such as those illustrated in Figure 11.1 assumed that\ncomponents would be integrated to form monolithic software applications, the\nuse of frameworks has allowed for more loosely coupled and distributed use\nof components, while also providing the necessary protocols for interaction\nbetween components. Figure 11.2 illustrates this evolution. Component  3\nComponent  2\nComponent  4\nComponent  1\na) Monolithic integration\nFramework Infrastructure\nComponent 1\nComponent 3\nComponent 2\nb) Integration via a Framework\nFIGURE 11.2: From monolithic construction to frameworks\nSo, what is a component framework? It can be summarised as being a set\nof formal de\ufb01nitions for the interfaces between components, where the def-\ninitions establish a set of protocols through which components will interact\nand cooperate within the given framework. In turn, these protocols may in-\nclude \u2018naming conventions\u2019 used for the methods in an object that provide\nparticular functions, the requirement to provide particular functions, and the\noperational procedures required for a component to declare itself available for\nuse, and for others to request its services. There are many frameworks (of course). We have already mentioned\nCORBA, which is maintained by the OMG (Object Management Group) that\nwe encountered in the last chapter in the context of UML. CORBA has map-\nping to many implementation languages and the \u2018client\u2019 of an object can access", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 201", "position": 201, "chunk_type": "semantic", "token_estimate": 293}
{"text": "Modelling Software Components and Services: 185\nthat object only through the protocols of its published interface. There are a\nnumber of frameworks provided by commercial vendors, such as Microsoft\u2019s\n.NET and of course the open source frameworks, such as Apache Spark. There\nare also many frameworks aimed particularly at Web applications, with J2EE\nproviding an important Java-based example. For the purposes of this chapter, the details of particular frameworks are\nof less importance, what matters is that they exist\u2014and that the choice of a\nframework has therefore become one of the design activities. And like other\ndesign activities, this is one that can involve complex trade-o\ufb00s between many\ndi\ufb00erent factors\u2014and inevitably, the choice creates a long-term technical debt. 11.2.3\nDesigning components\nThe design of the actual components can be considered as having two\ngoals. The \ufb01rst of these is to achieve the three general component character-\nistics identi\ufb01ed earlier, in order to ensure that a component can be \u201cdeployed\nindependently\u201d. These require that a component:\n\u2022 possesses well-de\ufb01ned functionality;\n\u2022 provides a set of well-de\ufb01ned interfaces;\n\u2022 clearly speci\ufb01es any explicit dependencies. And over and above that is the second goal, of conforming to the standards\nof a particular component framework. This aspect is likely to be supported\nby a range of tools (depending on the choice of framework), even down to the\nnaming convention for any identi\ufb01ers that are to be used for externally-visible\nmethods. Returning to the question of functionality (a major motivation for creat-\ning components), designing components to be reusable does imply that the\ndesigner should strive to make the component as general as is reasonably pos-\nsible. This is not an argument to use an excess of \u2018bells & whistles\u2019 or a \u2018swiss\narmy knife\u2019 approach, indeed quite the opposite. Making a component do one\njob and do it well was an important philosophical underpinning for the Unix\noperating system when it was developed in the 1970s. Using simple tools that\nconnected together readily via standard mechanisms helped users create their\nown applications with only limited e\ufb00ort (or even programming knowledge). And as Unix continues to underpin much of our computing infrastructure, we\ncan reasonably assume this was a good principle to adopt elsewhere. Experts prefer solutions that they know work. PvdH #13\nThe paper by Crnkovic & Larsson (2002) provides an interesting case study\non component use. The authors examine the evolution of two components", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 202", "position": 202, "chunk_type": "semantic", "token_estimate": 401}
{"text": "186: Software Design: Creating Solutions for Ill-Structured Problems\nwithin the application being studied (a control system package used for in-\ndustrial applications). While not speci\ufb01cally concerned with component devel-\nopment, this still examines how key component characteristics a\ufb00ect the two\nparticular aspects being studied: evolution of components across platforms and\nreplacement of proprietary components with industry-standard ones. And, al-\nthough the two components have relatively low-level roles (one can be consid-\nered as middleware, while the other is a class library), the general experiences\nmay well have wider generality. Some of the particular issues that the case study identi\ufb01es from the view-\npoint of designing individual components are as follows. \u2022 The bene\ufb01t of using larger components that are easy to reuse, in pref-\nerence to smaller ones that could be developed in-house. \u2022 The high cost of maintaining backward compatibility with early instal-\nlations (this arose largely because the application being studied was a\n\u2018product line\u2019 so creating additional technical debt). \u2022 The need to separate out those features of a component that depend\nupon platform interactions in order to assist with ease of change. It is worth noting here that components can be relatively costly to create. In\nSzyperski (1998) it is suggested that developing a reusable component could\nrequire 3\u20134 times the resources needed for a \u2018non-component\u2019 implementation. However, since some of these additional costs arise from external factors such\nas evolutionary changes to the component framework, it is di\ufb03cult to predict\nthe additional overhead involved in using a component. However, it is worth\nnoting that unless there really is good scope to make reuse of components, or\nan application can be largely created using existing components with only a\nfew additional specialised ones being built, developing components may not\nmake economic sense. (A good example of where extensive use is made of\nexisting components is the common practice with web applications of making\nuse of component frameworks to build a user interface.) 11.2.4", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 203", "position": 203, "chunk_type": "semantic", "token_estimate": 327}
{"text": "188: Software Design: Creating Solutions for Ill-Structured Problems\nstep in that evolution of reusable software components. Indeed, one way of\nthinking about services is as remote components that are very loosely coupled,\nso that the application making use of them does not need to know anything\nabout how they are realised. This progression is illustrated in Figure 11.3. Here the service sources are shown as miniature \u2018clouds\u2019, and indeed, the idea\nof software services has been an important underpinning for the concept of a\ncloud. Service technologies, in one form and an-\nother, emerged around the millennium, and\nthe di\ufb00erent practices of using services to\ncreate applications have resulted in a va-\nriety of descriptive terms such as Software\nas a Service, Service-Oriented Architecture\n(SOA), web services, as well as a large range\nof acronyms that describe the protocols used\nto support the various activities involved\n(Turner, Budgen & Brereton 2003). Services\nare usually accessed and delivered across the\nweb, often by third-party providers. Service models focus upon separating the\npossession and ownership of software from its use. By delivering software\u2019s\nfunctionality as a set of distributed services that can if necessary be con\ufb01gured\nand bound at the time of delivery (ultra-late binding), provides a highly \ufb02exible\nstrategy. Of course, the end user still needs to have some form of application\nthat incorporates a set of business rules, but this can be fairly minimalist\nand only needs to specify what services are needed, not how they are to be\nprovided. Figure 11.4 shows two forms of service model. Model a) is one where\nthis is organised on a supply-led basis, using a pre-determined range of services\nfrom a remote provider (a step on from distributed components, but still using\na \ufb01xed pro\ufb01le). Model b) shows how this can be organised on a demand-led\nbasis, involving an additional integration layer. Basic service description, discovery, delivery and composition are largely\norganised using XML-based protocols. SOAP (Simple Object Access Protocol) provides a message format for com-\nmunicating with, and invoking, web-based services. (REST is also used,\nbut historically, SOAP was the main protocol employed with web ser-\nvices.) WSDL (Web Services Description Language) is used to describe a service in\nterms of its acceptable data types, methods, message format, transport\nprotocol and end-point uniform resource identi\ufb01er (URI).", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 205", "position": 205, "chunk_type": "semantic", "token_estimate": 384}
{"text": "Modelling Software Components and Services: 189\nService transport layer\n(using forms such as \n.NET or J2EE)\nBusiness Rules\nService transport layer\n(using forms such as \n.NET or J2EE)\nBusiness Rules\nSupplier's software\napplication service\nService integration\nlayer\nService layer\n(applications created\non demand from\nsmaller services)\nPre-determined set\nof services\nDynamically selected\nset of services\na) Supply-led model\nb) Demand-led model\nFIGURE 11.4: Supply-led and demand-led service models\nFigure 11.5 shows the basic mechanics of service use. The service consumer\nmakes a request for a service. This may be a request for a speci\ufb01c service from a\nparticular provider, but if not, the request goes to some element that provides\nfor dynamic composition or orchestration of services (as in the diagram). This\nthen negotiates with one or more possible providers, depending on the business\nrules that are speci\ufb01ed, and then selects a particular service provider, which\nis then bound to the service user for this transaction. The actual service\nis then provided through the protocols embodied in that particular service\ndescription. This is of course a fairly simple single transaction, and providing for a\nuser\u2019s need may well require that several services are composed together in\norder to perform a speci\ufb01c task. Note also that the same symbol has been\nused for both the service consumer and the service provider to emphasise that\na consumer can itself also be a provider. Modelling both the realisation of a service, and also its use is clearly a\nfairly challenging issue. There are no speci\ufb01c service modelling notations, and\nlike components in general, most modelling appears to be performed by using\nexisting notations. Those provided by the UML can be useful (with the bene\ufb01t\nof having drawing tools available if required), as are DFDs (Anjum & Budgen\n2017). A particularly distinctive element in the process of service composition is\nthe presence of the business rules. Although these are normally a factor to be\nconsidered when designing applications, they are usually implicitly embodied\nin the design process (essentially forming an element of the design speci\ufb01ca-\ntion). However, when using software services, the business rules need to be", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 206", "position": 206, "chunk_type": "semantic", "token_estimate": 353}
{"text": "Modelling Software Components and Services: 191\nsuch as service-oriented development, software product lines, and model-based\nengineering\u201d. They noted that the main objectives for adopting CBSE tended to be\nnon-functional ones such as increasing productivity, saving on cost, improving\nquality etc. They noted that there were \u201cfew studies that measure the e\ufb00ort\ninvolved in building for reuse\u201d and suggest that industry experience is that\n\u201cbuilding reusable components on average requires three to \ufb01ve times more\ne\ufb00ort than building the same function but not building for reuse\u201d (similar to\nSzyperski\u2019s estimates). While the literature identi\ufb01ed more than 50 component models, with the\nfour most frequently addressed including CORBA. They also identi\ufb01ed a wide\nrange of domains in which CBSE has been applied and observed that the pro-\nvision of support for these \u201cexplains the large number of component models\u201d,\nwith these di\ufb00ering chie\ufb02y in term of being realised to meet the needs of a\ndomain, rather than in terms of basic principles. 11.4.2\nEmpirical knowledge about services\nFew systematic reviews on the use of software services are available, and\nthose that are, tend to be looking at rather speci\ufb01c research issues rather than\nat questions about the e\ufb00ectiveness of services. Key take-home points about modelling components and\nservices\nModelling the attributes of software components and services uses a range\nof di\ufb00erent forms, but to date modelling has tended to use existing notations\nrather than develop any that are speci\ufb01c to these technologies..\nReuse. This forms a major motivation for the adoption of components,\nwhether close or loosely coupled. Component characteristics. Components are characterised by having\nwell-de\ufb01ned functionality, accessed through well-de\ufb01ned interfaces, and\nwith any dependencies being made explicit. Ideally, a component has\nvery few (if any) dependencies, so aiding its composition within appli-\ncations. Component frameworks. The use of frameworks helps address the need\nto publish the interfaces of components, as well as aid loose coupling\nbetween components, and the choice of a framework is an important\narchitectural decision.", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 208", "position": 208, "chunk_type": "semantic", "token_estimate": 327}
{"text": "Chapter 12: Structuring the Ill-Structured\n12.1\nChallenges in creating a design ..................................\n195\n12.2\nEvolution of knowledge transfer mechanisms ....................\n197\n12.3\nDesigning with others ............................................\n199\n12.4\nEmpirical knowledge about design creation .....................\n200\nKey take-home points about structuring \u2018solutions\u2019 to ISPs ....\n201\nHaving examined the nature of software and some of the characteristics of the\ndesign process in the \ufb01rst part of this book, and some of the ways that we\ncan describe these in the second part, in this third part we address the role of\n\u2018design as a verb\u2019 and the question of how software might be designed. We might expect that, in the ideal, the design of software should be an\nopportunistic process, with design decisions being driven by the needs and\ncharacteristics of the required application. However, to do so well requires\nextensive experience and considerable ability from the designer(s). Given that\nsoftware is often more likely to be designed by less experienced and more\nimperfect beings, various design strategies and guidelines have been devised\nto assist them and to help organise the design process. This chapter introduces these, and then the following chapters (among\nother things) look at some of them in rather more detail. A core theme\nthat runs throughout is that of how to exchange and share design knowl-\nedge, whether it be in terms of strategies for developing a design, or ways of\norganising the design elements. Indeed, given that providing knowledge trans-\nfer is one of the main goals of this book, this chapter can be considered as\nintroducing some key elements of what this can involve. 12.1\nChallenges in creating a design\nThe di\ufb03culties involved in creating software applications and systems have\nlong been recognised by software developers, if not always by others. While\nother technologies related to computing such as hardware design have raced\nalong, rapidly gaining orders of magnitude in performance, while reducing\nsize and cost, the techniques employed for designing software appear to have\n195", "domains": ["Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 212", "position": 212, "chunk_type": "semantic", "token_estimate": 331}
{"text": "198: Software Design: Creating Solutions for Ill-Structured Problems\n3. re\ufb01ning the details of the elements and their interactions (such as the\nuse of parameters) to create the \ufb01nal design model. We will look at such strategies, their strengths and limitations in Chapter\n13. In terms of the properties of software identi\ufb01ed above, they do provide\nsupport for addressing both complexity and invisibility, but are less readily\nable to incorporate ideas about conformity or changeability. Early plan-driven approaches commonly employed a top-down strategy\nwith a clear sequence of actions, starting with a description of the system as a\nwhole and then developing a design model that describes the detailed design\nelements in a step by step manner. As noted above, this may well produce\ndesigns that lack \ufb02exibility and that can be di\ufb03cult to adapt and modify. Over the years various forms employing a more \u2018bottom-up\u2019 strategy emerged,\nculminating in the concept of agile development approaches. These aim to\nprovide better support for changeability (and to some extent for conformity)\nand are discussed in Chapter 14. Any form of knowledge transfer tends to depend upon some element of\ncommonality. Plan-driven thinking is largely centred upon commonality of ar-\nchitectural form (essentially implementation). If instead we seek to share ideas\nbased upon commonality of function, then this leads to the next development\nin design knowledge transfer. During the 1990s, as the use of objects and object-oriented thinking be-\ncame widely used, there was much greater interest in the idea of reuse of design\nknowledge at di\ufb00erent levels. Adelson & Soloway (1985) observed that design-\ners reused past experiences (what they termed \u2018labels for plans\u2019) and as the\ncorpus of software applications grew, the patterns concept emerged as a way\nof codifying useful forms. Whereas a designer was previously expected to be-\ngin with a \u2018clean sheet\u2019, basing key elements of a design upon well-established\nstructures or \u2018patterns\u2019 made it possible to draw upon the experiences of oth-\ners. Again, we look more fully at the ideas involved in Chapter 15, but one\nthing we can observe here is that one of the strengths of this approach is that\nit gives greater attention to changeability. The adage that \u201cthere is no such thing as a free lunch\u201d does certainly hold\ntrue for when designing software.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 215", "position": 215, "chunk_type": "semantic", "token_estimate": 382}
{"text": "200: Software Design: Creating Solutions for Ill-Structured Problems\n\u2022 the size of a team\u2014with some indication that a size of 10-12 members\nis probably an upper limit for productive working;\n\u2022 the large impact that may be exerted by a small subset of the team who\npossess superior application domain knowledge;\n\u2022 the in\ufb02uence of the way that an organisation operates\u2014with particular\nemphasis upon the need to maintain a bridge between the developers\nand the customer (Bano & Zowghi 2015). So, operating as a design team requires the use of knowledge schema drawn\nfrom the domain of group psychology as well as technical knowledge about\nsoftware design. This is perhaps best summarised by the following quotation\nfrom Curtis & Walz (1990). \u201cProgramming in the large is, in part, a learning, negotiation, and\ncommunication process.\u201d\nWe will particularly return to this when we examine agile development ideas\nin Chapter 14. Experts prefer working with others. PvdH #7\n12.4\nEmpirical knowledge about design creation\nSince much of the material of this chapter refers to empirical knowledge\nabout how people and teams create designs, many of the relevant empirical\nstudies have already been discussed. One topic not really elaborated though is that of opportunistic design ac-\ntivities. There are of course good reasons for this. If a process is opportunistic,\nthen its form is determined by the problem, and the way that designers begin\nto understand both the problem and ways in which it might be addressed. That doesn\u2019t o\ufb00er much in the way of guidelines about how to employ an\nopportunistic strategy of course, as it doesn\u2019t lend itself to being generalised. (Unfortunately, this doesn\u2019t therefore \ufb01t well with van Aken\u2019s idea of design\nsciences that we encountered in Chapter 5, where the goal was to \u201cdevelop\nvalid and reliable knowledge to be used in designing solutions to problems\u201d\n(van Aken 2004).) To highlight this, we brie\ufb02y examine some outcomes from the study of\nsoftware design that formed the basis of the book edited by van der Hoek &\nPetre (2014). This study was based upon recorded observations of a number of\npairs of software designers who were addressing a particular problem (creating", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 217", "position": 217, "chunk_type": "semantic", "token_estimate": 361}
{"text": "Structuring the Ill-Structured: 201\na simulation package for city tra\ufb03c management planning). The plot shown\nin 12.1 is based upon the qualitative analysis reported in Budgen (2014), and\nwas obtained by analysing the recorded utterances of one of the teams of\ndesigners and interpreting these to determine which viewpoint was the focus\nof attention at that point. In all, the utterances of three teams were analysed,\nand all were very di\ufb00erent. 20\n40\n60\n80\n100\nTime (in minutes)\nReq Spec\nFunction\nBehaviour\nData Model\nConstruction\nViewpoints\nFIGURE 12.1: Example of viewpoint changes during design\nThe main point is that over a period of nearly two hours, as the two design-\ners in the team produced their design model, their modelling process ranged\nwidely between all four viewpoints, as well as spending some time revisiting\nthe original requirements speci\ufb01cation. This was very much an opportunistic\ndesign session, with the designers exploring di\ufb00erent aspects as their under-\nstanding unfolded, and helps to illustrate why such a process cannot readily\nbe generalised. Key take-home points about structuring \u2018solutions\u2019 to\nISPs\nSoftware design practices employ a range of strategies for addressing the\nill-structured nature of software applications and need to cope with some\nimportant factors. Challenging properties of software. In 1987 Fred Brooks Jr. identi\ufb01ed\nfour key challenges for the designer as arising from the complexity of\nsoftware, the need for conformity with other elements of a system, the", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 218", "position": 218, "chunk_type": "semantic", "token_estimate": 236}
{"text": "Chapter 13: Plan-Driven Software Design\n13.1\nWhat does plan-driven mean? ...................................\n204\n13.2\nDecompositional and compositional strategies ..................\n205\n13.2.1\nTop-down decomposition ................................\n206\n13.2.2\nCompositional design strategies .........................\n207\n13.3\nWhat do plan-driven methods provide? .........................\n208\n13.4\nSSA/SD: example of an early plan-driven form .................\n211\n13.4.1\nSSA/SD representation part\n............................\n212\n13.4.2\nSSA/SD process part ....................................\n212\n13.4.3\nSSA/SD heuristics .......................................\n214\n13.5\nSSADM: a designed design method ..............................\n214\n13.5.1\nSSADM representation part .............................\n215\n13.5.2\nSSADM process part ....................................\n217\n13.5.3\nSSADM heuristics .......................................\n218\n13.6\nPlan-driven design for object-oriented models ...................\n219\n13.6.1\nThe Fusion method ......................................\n219\nThe Fusion process ...............................................\n220\nThe Fusion notations .............................................\n223\nFusion\u2014some observations .......................................\n225\n13.6.2\nThe Uni\ufb01ed Process (UP) ...............................\n226\nThe UP phases ...................................................\n227\nThe UP work\ufb02ows ................................................\n229\nThe UP\u2014some observations .....................................\n232\n13.7\nEmpirical knowledge related to plan-driven design ..............\n233\nKey take-home points about plan-driven design practices ......\n235\nPlan-driven strategies were one of the earliest mechanisms devised for trans-\nferring knowledge about software design. Essentially, the relevant knowledge\nschema are organised in the form of a structured sequence of well-de\ufb01ned ac-\ntivities, with the activities themselves being performed in a form appropriate\nto the needs of a particular application. In this chapter we examine the nature of plan-driven design strategies, and\nlook at some examples of the practices that they employ. As we will see, a\nsigni\ufb01cant limitation is that this form of strategy is less readily suited to being\nused with design solutions that are based upon more complex architectural\nstyles. However, this does not make plan-driven strategies irrelevant. In par-\nticular, one of their strengths lies in the way that they \u2018systematise\u2019 the design\n203", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 220", "position": 220, "chunk_type": "semantic", "token_estimate": 287}
{"text": "Plan-Driven Software Design: Understandably perhaps, plan-driven software development is now often\nviewed as being mainly of historical interest. On the debit side, it does have two\nsigni\ufb01cant limitations: one is that it is implicitly tied to an overall \u2018waterfall\ndevelopment\u2019 context; the other is that it is more likely to be e\ufb00ective with less\ncomplex software architectures. On the positive side, many applications have\nbeen successfully developed using a plan-driven strategy; and some important\nconcepts (such as coupling) have emerged from its use. And of course, as\nmentioned earlier, an understanding of how such strategies are organised can\nhelp with preserving the integrity of the resulting design during maintenance. 13.2\nDecompositional and compositional strategies\nWhile an opportunistic strategy may commonly be used by experienced\nsoftware designers (Visser & Hoc 1990), such an approach cannot readily be", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 222", "position": 222, "chunk_type": "semantic", "token_estimate": 136}
{"text": "206: Software Design: Creating Solutions for Ill-Structured Problems\nincorporated into a plan-driven structure. Plan-driven methods therefore or-\nganise their guidance around one of two major problem-solving strategies. 13.2.1\nTop-down decomposition\nDecomposition\nWhen early software applications were\nbeing developed, a common choice of ar-\nchitectural style was one of call-and-return,\nsince most implementation languages had\nfeatures that mapped closely to the struc-\nture of the underlying machine, aiding gen-\neration of e\ufb03cient code. Applications there-\nfore employed some form of \u2018main\u2019 program\nunit (often incorporating any permanent and\nglobal variables) and a set of sub-programs,\nwith these performing their tasks using local\nvariables that were only in scope while the\nsub-program was executing. So early think-\ning about design was focused upon how to\nmap application functionality on to such a structure. In a pioneering paper, Niklaus Wirth (1971) proposed the use of a process\nin which the task to be performed by the overall problem was gradually de-\ncomposed into a set of smaller ones (termed stepwise re\ufb01nement). As envisaged\nby Wirth, both functionality and also data were to be re\ufb01ned in this way, and\nduly mapped on to the main program and sub-programs. Among the lessons\nthat he derived from this model were two that we might usefully note here. \u2022 The modular structure resulting from this process determines the ease\nwith which a program can later be adapted to meet changes in the\nrequirements or its context. Although this idea is demonstrated in his\npaper, the changes illustrated in his example were ones that largely\nextended the functionality involved in the original problem posed, and\nwe should note that the ideas about information hiding later expounded\nin Parnas (1972) provide a much more coherent strategy for determining\nthe choice of modular structure. \u2022 Each re\ufb01nement in the process of decomposition embodies a set of de-\nsign decisions that are based upon speci\ufb01c criteria. This re\ufb02ects the\nrecognition that, as we have already observed many times in this book,\ndesigning software is not an analytical process, with a need to assess\n(and re-assess) the in\ufb02uences of a range of factors at each design step. Wirth\u2019s paper was undoubtedly a seminal one, but although his ideas were\ncentred upon the concept of modularity, his paper provided no criteria that a\ndesigner could employ to compare between possible choices of module struc-\nture (Shapiro 1997).", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 223", "position": 223, "chunk_type": "semantic", "token_estimate": 394}
{"text": "206: This re\ufb02ects the\nrecognition that, as we have already observed many times in this book,\ndesigning software is not an analytical process, with a need to assess\n(and re-assess) the in\ufb02uences of a range of factors at each design step. Wirth\u2019s paper was undoubtedly a seminal one, but although his ideas were\ncentred upon the concept of modularity, his paper provided no criteria that a\ndesigner could employ to compare between possible choices of module struc-\nture (Shapiro 1997). However, the concept of module coupling introduced in", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 223", "position": 223, "chunk_type": "semantic", "token_estimate": 88}
{"text": "Plan-Driven Software Design: 207\n(Myers 1973), that later formed one of the underpinnings of the \u2018structured\ndesign\u2019 school of thinking (Stevens et al. 1974) that are examined later in\nthis chapter, did provide criteria that could be used to assist the process of\nstepwise re\ufb01nement, and so coupling became an underpinning concept used\nas part of this approach. Myers argued that the \u201cprimary goal in designing a modular program\nshould be to decompose the program in such a way that the modules are highly\nindependent from one another\u201d. He advocated the use of \u2018strong modules\u2019,\nwhich performed a single, well-de\ufb01ned function and he identi\ufb01ed some of the\nways in which coupling between modules could arise. 13.2.2\nCompositional design strategies\nA rather di\ufb00erent, and often more challenging, way of creating a design\nis to use a compositional strategy. Whereas the decompositional approach\ntends to focus upon creating the structure of the resulting application around\nconsideration of its function, usually realised through by the operations that\nan application needs to perform, a compositional approach seeks to create\na design model that is formed from the descriptions of a set of distinctive\nentities or components that can be recognised in the problem, together with\ndescriptions of the relationships that link these entities. The nature of the\nentities and the relationships will vary with the method and the architectural\nstyle that is adopted. Indeed, whereas decompositional forms are e\ufb00ectively\nconstrained to producing design models using an architectural style such as\ncall-and-return, compositional strategies can be used to create design models\nfor a variety of architectural styles, including those using processes and objects. Composition\nEmploying a compositional approach is usu-\nally considered as being less intuitive than\nthe use of top-down decomposition (Vessey &\nConger 1994). In part this may be because of its\ngreater complexity, requiring a more mixed set\nof viewpoints for creating the design model, and\nalso because it provides more scope for oppor-\ntunistic decision making. However, it can be ar-\ngued that the use of this strategy is likely to lead\nto more consistent design solutions, regardless of\nwho is doing the design, since the design strategy aims to relate the structure\nof the \u2018solution\u2019 (design model) to that of the \u2018problem\u2019 rather than the struc-\nture of the underlying machine (D\u00e9tienne 2002).", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 224", "position": 224, "chunk_type": "semantic", "token_estimate": 383}
{"text": "Plan-Driven Software Design: In part this may be because of its\ngreater complexity, requiring a more mixed set\nof viewpoints for creating the design model, and\nalso because it provides more scope for oppor-\ntunistic decision making. However, it can be ar-\ngued that the use of this strategy is likely to lead\nto more consistent design solutions, regardless of\nwho is doing the design, since the design strategy aims to relate the structure\nof the \u2018solution\u2019 (design model) to that of the \u2018problem\u2019 rather than the struc-\nture of the underlying machine (D\u00e9tienne 2002). The process of compositional\ndesign also places an emphasis upon \u2018grouping\u2019 elements when elaborating the\ndesign model, where groupings can be based on criteria such as the di\ufb00erent\nforms of coupling, which again may be related closely to both the problem as\nspeci\ufb01ed in the requirements and the chosen architectural style.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 224", "position": 224, "chunk_type": "semantic", "token_estimate": 146}
{"text": "208: Software Design: Creating Solutions for Ill-Structured Problems\n13.3\nWhat do plan-driven methods provide? One question we should ask at this point is why should anyone want to\nuse a plan-driven method? Probably far more software has been developed\nwithout using anything in the nature of a \u2018method\u2019 than through the use of\nsuch methods, so what bene\ufb01ts does their use confer? To answer this, we \ufb01rst\nneed to look at the mechanisms they employ in a little more detail. Vessey & Conger (1994) suggested that the knowledge involved in following\na plan-driven strategy can be categorised into two forms:\n1. declarative knowledge, which describes the tasks that should be per-\nformed at each step in the process; and\n2. procedural knowledge, consisting of knowledge about how to employ a\ngiven \u2018method\u2019 in a particular situation. In terms of our example of making tea, the declarative knowledge involved\nwould consist of an understanding of the tasks to be performed and of the\norder in which they should be performed, while procedural knowledge would\naddress such issues as how much tea to put in the pot and how much water\nto add in order to make tea for four people. Declarative knowledge schemas can be codi\ufb01ed by providing a \u2018do this, then\ndo that, then follow this by doing...\u2019 form of description, whereas procedural\nknowledge schemas are more likely to be acquired from experience and best\ncodi\ufb01ed in the form of advice. Since we often express the declarative knowledge\nin what we might term a procedural form, by specifying the sequence of actions\nthat should be performed, this terminology can also be a little confusing. (And\nit is worth noting that in (D\u00e9tienne 2002) the terms declarative and procedural\nare used in yet another, slightly di\ufb00erent, way.) As used for software design, plan-driven methods generally embody the\nrelevant design knowledge through the use of three main elements. \u2022 The representation part consists of a set of notations that can be used\nto describe (or model) both the characteristics of the original problem\nand also that of the intended \u2018solution\u2019 (the design model), using one or\nmore viewpoints and di\ufb00erent levels of abstraction. \u2022 The process part provides the declarative knowledge by describing the\nprocedures to be followed in developing the design model, and suggesting\nstrategies that can be used and adopted when making any design choices\ninvolved.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 225", "position": 225, "chunk_type": "semantic", "token_estimate": 396}
{"text": "Plan-Driven Software Design: 209\nparticular classes of problem. These may well be based upon experience\nof past use. In terms of the classi\ufb01cation employed by Vessey & Conger (1994), the process\npart can be considered as embodying declarative knowledge, while heuristics\nprovide a means of supplying procedural knowledge. (The representation part\nis a vehicle for capturing knowledge about the design model rather than a\nmechanism for creating it.) We will use these three elements as a framework\nfor discussing how the examples of plan-driven forms discussed in the rest of\nthis chapter are structured. However, to return to the question posed at the start of this section, namely\nwhat bene\ufb01ts do users hope to obtain from using a \u2018systematic design method\u2019,\nit can be argued that some of the bene\ufb01ts are as follows. \u2022 The representation part of a design method provides an arti\ufb01cial frame-\nwork to help with thinking about an invisible set of elements. Portray-\ning ideas about something that is invisible is inevitably a challenging\nissue when designing software, and the representation part of a method\ndoes provide a syntax and semantics to aid this through the notations\nadopted. \u2022 Design methods can assist with managing some of the e\ufb00ects of scale\nand of the cognitive load this imposes, particularly where teams are\ninvolved. They do so by ensuring that consistent forms of description are\nused for sharing knowledge among a team. Recording design plans in a\nconsistent manner may well be important for future evolution (and while\nthey may not necessarily reduce the technical debt involved, they can at\nleast help with making it explicit). However, while design records may\nhelp a maintenance team to understand the intentions of the original\ndevelopers (Littman et al. 1987), as Parnas & Clements (1986) have\nobserved, such documentation may well be more helpful if it describes\nan \u2018idealised\u2019 process rather than the more opportunistic strategy that\nmay well have actually been followed, even for a plan-driven method. \u2022 As already noted, plan-driven methods act as a knowledge transfer mech-\nanism. Observational studies suggest that although experienced design-\ners may often work in an opportunistic manner, this practice may be less\nwell-formed and reliable when the designer is less familiar with a problem\nor its domain (Adelson & Soloway 1985, Guindon & Curtis 1988, Visser\n& Hoc 1990).", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 226", "position": 226, "chunk_type": "semantic", "token_estimate": 388}
{"text": "210: Software Design: Creating Solutions for Ill-Structured Problems\nstrategy addresses the problem of \u2018solving\u2019 an ISP (and is much simpler than\nthe form described in Figure 1.1). We can also see that in some ways, the\nproblem-solving process in Figure 13.1(b) is much closer to the form in Figure\n13.1(a), which describes how we solve WSPs. Of course, this is rather idealised,\nsince iteration may well occur between the steps of a method, but nonetheless,\nthe design process involved is a much more constrained one. problem\nspecification\nsolution\nprocedure\nsolution\nset of algorithmic\nrules to apply when\nsolving such problems\nset of algorithmic\nrules to apply when\nsolving such problems\na) Process for 'solving' a WSP\nproblem\nspace\nstep 1\nStep 2... Step n\npart\nsolution 1\npart\nsolution 2\npart\nsolution n\nsolution\nspace\nProcedural knowledge \nand problem expertise\nProcedural knowledge \nand problem expertise\nb) Plan-driven process for 'solving' an ISP\nDeclarative \nknowledge \nDeclarative \nknowledge \nFIGURE 13.1: Addressing an ISP using a plan-driven form\nHowever, while a systematic design method may help to structure the\nstrategy used to address an ISP, it cannot magically turn it into a WSP,\nand in particular, the designer\u2019s choices and decision-making will still need\nto be made on the basis of the problem being addressed. What a design\nmethod assists with, is guiding the designer about determining when it might\nbe appropriate to make those decisions. It may be helpful here to return brie\ufb02y to the analogy of the recipe for\ncooking. A recipe describes the process that should be followed in order to\ncreate a particular dish, in much the same way as a software application may\nembody the algorithm needed to rank the positions of the nearest cars for", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 227", "position": 227, "chunk_type": "semantic", "token_estimate": 288}
{"text": "Plan-Driven Software Design: 211\nthe CCC. Designing software applications is therefore rather like designing\nrecipes, it requires the designer to possess insight into the problem domain;\nto be aware of the potential that is present in the various available materials;\nand to appreciate the bounds upon the software application (or cook) that will\nperform the task. So plan-driven (and other) design methods are essentially\nstrategic in their scope rather than prescriptive. Experts use design methods (selectively). PvdH #17\nThe rest of this chapter looks at some examples of plan-driven forms. Of\nnecessity the descriptions have to be brief (a full description for any of them\nmerits a book in itself). However, they should be su\ufb03cient to show how plan-\ndriven strategies have evolved and something of the way that they can help\nwith addressing the problem of designing software. 13.4\nSSA/SD: example of an early plan-driven form\nThe structured systems analysis/structured design (SSA/SD) method in\nits various \ufb02avours provides a good example of an early plan-driven approach\nto design. It is one that evolved over a period when software applications were\ngetting larger and ideas about how to design software were in a rapid state\nof evolution. SSA/SD was by no means the only approach to software design\nbeing explored and documented in this period, but became quite a widely-\nused form, perhaps because it stemmed largely from work performed by IBM,\nwhich was then a leading organisation involved both in developing software\nand also researching into the associated issues. Various authors published\nbooks describing forms of SSA/SD (Gane & Sarsen 1979, Page-Jones 1988,\nConnor 1985), as well as variants such as real-time applications, covered in\nthe books by Hatley & Pirbhai (1988) and Ward & Mellor (1985). For this\nsection we will largely follow the form described by Page-Jones (1988). As a design method, this one is really a composite of two separate but\nrelated techniques. Structured systems analysis is concerned with modelling\nthe problem-related characteristics of the application, making use of a set of\nrepresentation forms that can also be used for architectural design. Struc-\ntured design is then concerned with the \u2018solution\u2019-related aspects involved in\nproducing a design model. In its early forms, the basic design strategy was a re\ufb01nement of top-down\ndesign, with the choices involved in the functional decomposition process be-\ning moderated and constrained by considerations of information \ufb02ow, and to\na lesser degree, of data structure.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 228", "position": 228, "chunk_type": "semantic", "token_estimate": 403}
{"text": "Plan-Driven Software Design: Struc-\ntured design is then concerned with the \u2018solution\u2019-related aspects involved in\nproducing a design model. In its early forms, the basic design strategy was a re\ufb01nement of top-down\ndesign, with the choices involved in the functional decomposition process be-\ning moderated and constrained by considerations of information \ufb02ow, and to\na lesser degree, of data structure. Subsequent variants adopted a more compo-\nsitional approach for the analysis stages, based upon such techniques as event", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 228", "position": 228, "chunk_type": "semantic", "token_estimate": 78}
{"text": "212: Software Design: Creating Solutions for Ill-Structured Problems\npartitioning (Avison & Fitzgerald 1995). There were some later developments\nthat tried to adapt the approach to an object-oriented style, but these do not\nseem to have been adopted very widely, and apart from these, the evolution of\nSSA/SD forms e\ufb00ectively appears to have come to an end in the later 1980s\nat a time when ideas about software architecture were evolving rapidly. In the rest of this section we brie\ufb02y examine the representation part, pro-\ncess part and some of the heuristics used in this method. 13.4.1\nSSA/SD representation part\nThe two techniques make use of quite di\ufb00erent notations. The structured\nsystems analysis element primarily builds a problem model using data-\ufb02ow\ndiagrams or DFDs (see Section 9.2), while the structured design component\ncreates a design model around the use of structure charts (see Section 9.5). The functional model created by using the DFDs can be augmented\nthrough the use of more detailed descriptions of the bubbles in the form of\n\u2018process speci\ufb01cations\u2019 or P-Specs, where these can be regarded as providing\na subsidiary functional viewpoint. A P-Spec is a textual description of the\nprimitive process represented by a bubble, summarising the process in terms\nof its title, input/output data \ufb02ows and the procedural tasks that it performs. An additional element of the \u2018problem model\u2019 is a Data Dictionary. This\ncan be used to record the information content of data \ufb02ows, drawing together\ndescriptions of all of the data forms that are included in the DFDs, P-Specs\nand any other elements that might be used. In its initial form this should be\nhighly abstract and avoid focusing upon physical format (Page-Jones 1988). Whereas problem modelling can use a variety of supplementary forms (such\nas ERDs and state transition diagrams), the solution modelling part is con-\n\ufb01ned to using structure charts. As observed earlier, the structure chart is\na program-oriented form of description that maps on to the call-and-return\nstyle. 13.4.2\nSSA/SD process part\nThe process embodied in this method can be regarded as an elaboration\nof the basic top-down approach based on functional decomposition, being\nextended by adding such elements as consideration of information \ufb02ow. A\nsimple description of the process is as follows. 1.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 229", "position": 229, "chunk_type": "semantic", "token_estimate": 373}
{"text": "214: Software Design: Creating Solutions for Ill-Structured Problems\nFigure 13.2 provides a schematic model of this process. In part a), we see\nthe complete system DFD produced from steps 1 and 2. Part b) shows the\nprocess of transaction analysis, with the DFD being partitioned into three\nsmaller DFDs that address speci\ufb01c tasks (the dashed lines show the divisions). In part c), transform analysis has been used to create structure charts for the\nthree transactions, and then \ufb01nally in part d), these have been combined to\ncreate the complete design model for the application program. (This is very\nidealised, and we have assumed here that the functionality in each bubble can\nbe readily mapped on to a single sub-program.) Each of these steps involves what we might consider to be design activities\n(use of the term \u2018analysis\u2019 in this method can be a bit misleading). Steps 2-4\nform the core of the method, and as we might expect, while there is guidance\navailable about how to perform these tasks, actually mapping them on to a\nreal problem is a task \u2018left for the reader\u2019. Transform analysis in particular is\nwhere the design model becomes modi\ufb01ed, and while the emphasis upon data\nand function is retained, the logical model embodied in the DFDs is changed\ninto a \u2018physical\u2019 model that maps on to sub-programs. 13.4.3\nSSA/SD heuristics\nHeuristics are often created when a particular design method is used on a\nset of broadly similar problems. This does not seem to have been the case with\nSSA/SD although a number of heuristics have become established to provide\nguidance on such tasks as creating a DFD, or performing a transform analysis. A technique that we should mention here is that of factoring, used to\nseparate out the functions of a module, where the operations of one module\nare contained within the structure of another. Factoring can be considered\nas a re\ufb02ective activity aimed at reducing the size of modules, clarifying their\nfeatures, avoiding duplication of operations and helping with reuse of design\nelements. Some of the tasks of Step 5 above are related to factoring and\ntogether they highlight the way that the use of such design methods may\nstill depend upon an additional design element in order to produce \u2018e\ufb03cient\u2019\ndesign models.", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 231", "position": 231, "chunk_type": "semantic", "token_estimate": 380}
{"text": "Plan-Driven Software Design: 215\ntems since the use of these, and hence their systematic production, was seen\nas playing an important role for both central and local government agencies. Part of the rationale for commissioning such a development was the way\nthat public bodies in the UK are traditionally organised. In particular, central\nand local government agencies often move sta\ufb00to new posts on a regular\nbasis (the UK civil service has tended to favour the idea of the \u2018generalist\u2019\nover the \u2018specialist\u2019, and hence sta\ufb00development tends to require the gaining\nof wide experience). Where such roles involved the responsibility for software\ndevelopment, it was considered that regular change of sta\ufb00could (and did)\nlead to discontinuity in the way that the software applications were developed,\nand hence that using a mandated approach for their development would help\novercome this. SSADM Version 3 was the \ufb01rst stable version of the method, and was\nsupported by a small number of textbooks. This evolved into Version 4 in\nthe early 1990s, at which point the method was considered to be \u2018mature\u2019,\nand which appears to have marked the end of development for both SSADM\nand for the textbooks supporting it (Longworth 1992, Weaver, Lambrou &\nWalkley 2002). This period also coincided with the growing uptake of object-\noriented platforms, which would have been likely to compete as an alternative\nstrategy for use in government projects. Car\nBilling\nrecord\nMaintenance\nsession\nUser\nreservation\nUser query\n(availability)\nFIGURE 13.3: Example of an LDS\n13.5.1\nSSADM representation part\nThe forms adopted for SSADM largely reused established ideas and no-\ntations, albeit with some (sometimes rather confusing) renaming and rela-\nbelling. SSADM analysis and modelling practices address the following main\nviewpoints.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 232", "position": 232, "chunk_type": "semantic", "token_estimate": 283}
{"text": "216: Software Design: Creating Solutions for Ill-Structured Problems\n\u2022 Data relationships. These are modelled using the fairly conventional\nentity-relationship diagram, relabelled as a logical data structure (LDS),\nwith the modelling process being termed \u2018logical data modelling\u2019, or\nLDM. \u2022 Data \ufb02ow. This is modelled using a form of DFD, which is either de-\nveloped by transformation of an existing application or through decom-\nposition. However, these are more solution-oriented than the \u2018bubble\u2019\nforms used by De Marco and others for analysis. \u2022 Function and behaviour. Modelling of these viewpoints uses entity-life-\nhistory (ELH) diagrams that have the same form and syntax as a Jackson\nstructure diagram (Jackson 1975). a", "domains": ["Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 233", "position": 233, "chunk_type": "semantic", "token_estimate": 109}
{"text": "Plan-Driven Software Design: 217\ncar\noperation\nremoved\nfrom use\nregistered\nas available\noperational\nuse\nrelease\nfrom service\nassign to\nbooking\nwithdraw\nfor service\nrelease\nfrom booking\n*\nFIGURE 13.5: Example of an entity-life-history diagram", "domains": ["Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 234", "position": 234, "chunk_type": "semantic", "token_estimate": 34}
{"text": "process: Phase 2\nSystems\nAnalysis\nPhase 3\nSystems\nDesign\nPhase 1\nFeasibility\nStudy\n(No study)\nConduct\nstudy\nStage 3\nSelection\nof technical\nrequirements\nStage 2\nSpecification\nof \nrequirements\nStage 1\nAnalysis of\noperations\n& problems\nStage 6\nPhysical\ndesign\nStage 5\nProcess\ndesign\nStage 4\nData\ndesign\nFIGURE 13.6: The SSADM process part\na branch of the model, only one form (sequence, iteration, selection) can be\nused\u2014they cannot be mixed. 13.5.2\nSSADM process part\nDeclarative knowledge is embedded into SSADM through a strongly hier-\narchical process, with three top level phases. The \ufb01rst (a feasibility study) is\noptional, and the other two phases each consist of three stages. The stages are\nfurther sub-divided into steps which in turn each encompass a set of one or", "domains": ["Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 234", "position": 234, "chunk_type": "semantic", "token_estimate": 125}
{"text": "218: Software Design: Creating Solutions for Ill-Structured Problems\nmore tasks. Figure 13.6 uses the Jackson structure diagram format to describe\nthe top levels of the process part. SSADM practice is very much focused upon the idea of producing a logical\ndesign for an application, and this is only mapped on to a physical design\nin the \ufb01nal stage. So, in principle at least, there is no strong coupling to a\nparticular architectural style. SSADM is also a very bureaucratic method,\nas might be expected from its origins and purpose. Figure 13.7 provides an\nexample of Step 320 (the \ufb01rst digit indicates which phase of the method\nthis concerns). Note in particular that there is also a strong emphasis upon\ndocumentation, which again has an important role in this method. However,\nwhen we examine empirical knowledge about plan-driven forms in Section 13.7\nwe will see that the procedures of SSADM can be, and have been, used in part\nwithout necessarily employing the complete method. Inputs:\nOption Specifications from (step 310)\nRequired system specification (from stage 2)\nTasks:\n1. Prepare presentation plan\n2. Prepare presentations for each option\n3. Deliver presentations\n4. Provide assistance and advice for option\nselection\n5. Note decisions of users\nTechniques:\nUser option selection\nOutputs:\nNote of option decisions (to 330)\nOption specifications (to 330)\nFIGURE 13.7: Step 320: user selects from technical options\n13.5.3\nSSADM heuristics\nSSADM can be regarded as using rather formalised heuristics in a number\nof the steps, referring to these as techniques. There are 13 of these, and their\nmain role is to provide procedural knowledge that can be used to help develop\nthe diagrams, with SSADM placing heavy emphasis on the use of matrices for\nthis purpose. A matrix in this context is a grid or table that helps with iden-\ntifying links between elements, rather as the state transition table described\nin Section 9.3 can be used to develop state transition diagrams. However, these could also be regarded as providing declarative knowledge\nas well as procedural knowledge, although it can be argued that their use\naugments the SSADM process rather than forming a part of it. Figure 13.8", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 235", "position": 235, "chunk_type": "semantic", "token_estimate": 357}
{"text": "Plan-Driven Software Design: 219\nshows an entity-life-history matrix (ELH matrix) that can be used to help\nproduce the ELH diagram shown in Figure 13.5. Entities\nEvents\nseek nearby reserve\nstart\nrelease\nservice\nservice\ncars\ncar\nsession\ncar\nwithdrawal release\ncar\n*\n*\n*\n*\n*\ncustomer\n*\n*\n*\n*\nbooking system\n*\n*\n*\n*\nbilling system\n*\n*\nmaintainers\n*\n*\nFIGURE 13.8: Example ELH matrix\n13.6\nPlan-driven design for object-oriented models\nEarly thinking about how to design object-oriented systems not unnatu-\nrally sought to use experience from the approaches used to design applications\nthat used call-and-return and other forms of software architecture. Since plan-\ndriven forms were then the main established vehicle for knowledge transfer,\nit was not surprising that design \u2018methodologists\u2019 sought to extend the use of\nwhat was generally considered a generally e\ufb00ective approach. Indeed, many\n\u2018\ufb01rst-generation\u2019 OO design methods made varying degrees of use of existing\nideas and notations. However, while in principle, plan-driven approaches are a viable means\nof providing knowledge transfer about OO design, the greater complexity of\nthe OO model, when compared to architectural styles such as call-and-return,\nhas tended to result in a correspondingly greater complexity of structure for\nassociated plan-driven approaches. This section examines two OO plan-driven methods (Fusion and the Uni-\n\ufb01ed Process). Both represent attempts to create a second-generation plan-\ndriven method by merging ideas from \ufb01rst-generation OO methods that were\nseen as e\ufb00ective. In many ways, the UP can also be considered as the point\nat which the use of a plan-driven form both achieved maximum complexity,\nand also started to morph into more agile forms. 13.6.1\nThe Fusion method\nAs indicated above, Fusion can be viewed as being a \u2018second-generation\u2019\nOO method. Indeed the methodologists at the Hewlett-Packard Laborato-\nries in Bristol UK who developed Fusion described their goal as being to", "domains": ["Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 236", "position": 236, "chunk_type": "semantic", "token_estimate": 307}
{"text": "220: Software Design: Creating Solutions for Ill-Structured Problems\n\u201cintegrate the best aspects of several methods\u201d (Coleman, Arnold, Bodo\ufb00,\nDollin, Gilchrist, Hayes & Jeremes 1994). Among the problems intrinsic to\nan object-oriented approach that they identi\ufb01ed as drivers for their work, the\nmethod developers included the following. Di\ufb03culty with \ufb01nding the objects. They observed that \u201c\ufb01nding the\nright objects and classes in an object-oriented system is not easy\u201d. Function-oriented methods being inappropriate. Their observation here\nwas that for OO applications, the traditional methods of analysis and\ndesign (that is, those based on data-\ufb02ow and function) \u201cno longer\nwork\u201d. Implicitly, the use of these was seen as a weakness of many\n\ufb01rst-generation approaches. In particular, they noted that \u201cfunctional\ndecompositions clash with the object structure of the implementation\u201d. While Fusion seems to have had some early success in terms of its adoption,\nit never seemed to acquire a solid base of users. The text by Coleman et al. (1994) remains the only readily available description of the methods, and\nseems to be mainly cited when authors are discussing OO methods. Wieringa\n(1998) did note that there had been some subsequent development of the\nmethod, but that these were not readily accessible, and so the description\nprovided here is that described in the 1994 version. Since the more distinctive\nelement of Fusion lies in the process part, we describe this \ufb01rst (there are no\nevident heuristics). The Fusion process\nRe\ufb02ecting the need for more complex processes to address the more com-\nplex architectural style created by the use of objects, the Fusion process has no\nfewer than eight distinct steps. Four of these are classi\ufb01ed as analysis (black\nbox modelling) while the other four are white box design steps. Continuity\nthrough the overall process is provided through the use of a data dictionary,\nwhich is intended to act as \u201ca central repository of de\ufb01nitions of terms and\nconcepts\u201d. Arguably, this is the one element that is most evidently (and sensi-\nbly) carried over from earlier structured design practices. The eight steps are\nshown in Figure 13.9, and can then be summarised as follows. 1. Develop the object model. While the task of this step is identi\ufb01ed as\nidentifying a set of candidate classes, relationships and attributes, the\nmethod does not specify how this should be done.", "domains": ["Design Principles", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 237", "position": 237, "chunk_type": "semantic", "token_estimate": 383}
{"text": "Plan-Driven Software Design: 221\nRequirements\nDocument\n(Analysis)\nStep 1\nDevelop object\nmodel\nAdded system\noperations\nBehaviour\nadded to model\nInitial\nobject model\nStep 4\nCheck analysis\nmodels\nStep 2\nDetermine system\ninterface\nStep 3\nDevelop interface\nmodel\nModel revised\nas needed\nAdded temporal\naspects\nProvide system\nfunctionality\nStep 5\nDevelop object\ninteraction graphs\nStep 7\nDevelop class\ndescriptions\nStep 6\nDevelop visibility\ngraphs\nDetailed class\nmodel\nAdded abstract\nclasses\n(final model)\nStep 8\nDevelop inheritance\ngraphs\n(Design)\nFIGURE 13.9: The Fusion design process\nIn addition to identifying candidate classes, relationships and attributes,\nthis process should also identify any invariants and record their details\nin the data dictionary. For our purposes an invariant is some form of\nconstraint upon the overall state of the system. 2. Determine the system interface. The model from step 1 is essentially\na static one, and this step extends it to describe the dynamic behaviour\nof the system as a whole. In doing so, it also clari\ufb01es the system bounds\nby determining what is, and what is not, included in the system itself. The core concept here is that of the event, with the designer being en-\ncouraged to think of how the system is to respond to external events as\nwell as to consider what events will be generated in response to these.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 238", "position": 238, "chunk_type": "semantic", "token_estimate": 218}
{"text": "222: Software Design: Creating Solutions for Ill-Structured Problems\nThe approach suggested is to consider a set of scenarios of use, mod-\nelled as timeline diagrams (essentially message sequence diagrams, as de-\nscribed in Section 10.6), extending the data dictionary to include these\nscenarios. 3. Development of the interface model. The \ufb01rst element of this in-\nvolves creating a set of use cases that generalise the scenarios from the\nprevious step (termed life-cycle expressions). These are then used as the\nbasis for the \u2018operational model\u2019 that de\ufb01nes the semantics (meaning)\nfor each system operation, expressed in terms of informal pre-condition\nand post-condition speci\ufb01cations. Overall, this provides a functional de-\nscription of the system. 4. Check the analysis models. This step is intended to ensure complete-\nness and consistency in the (still black-box) model, rather than extend-\ning it in any way. Completeness is largely a matter of cross-referencing\nwith the requirements speci\ufb01cation (a limitation of plan-driven mod-\nels is that they implicitly require a requirements speci\ufb01cation as their\nstarting point). Consistency is concerned with ensuring that the di\ufb00er-\nent viewpoint models from the previous steps (which we can categorise\nas being constructional, behavioural and functional) as well as the in-\nvariants represent the same overall design model. This can be partly\nachieved by using scenarios to trace event paths through objects. 5. Develop object interaction graphs. The \ufb01rst step categorised as be-\ning \u2018design\u2019 is used to describe the designer\u2019s intentions about how the\nobjects will interact at run-time to provide the required functionality. This involves creating an object interaction graph for each system oper-\nation, and in doing so, making decisions about message passing between\nobjects and any resulting state changes. One of the elements also clari\ufb01ed in this step is the point at which objects\nshould be created from the classes. (Although the descriptions tend to\nbe couched in terms of objects, since these are the executable elements\nof the eventual system model, the model itself is really described in\nterms of classes\u2014while recognising that many classes will only lead to\nthe creation of a single object.) A question here is whether the set of objects used in this step is essen-\ntially that created in Step 1? The answer to this is \u2018yes\u2019, as the objects\ninvolved are de\ufb01ned as design objects that are derived from the analysis\nobjects.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 239", "position": 239, "chunk_type": "semantic", "token_estimate": 391}
{"text": "224: Software Design: Creating Solutions for Ill-Structured Problems\nClass name\nattribute\nAggregate class\nClass 3\nClass 2\nClass 1 C\nname\nClass\n(a) Object Model\nRole 1\nRole 2\nThis example shows aggregation and\nRelationship. C represents the cardinality\nof the aggregation. Can also use to model\nclass generalisation (subtyping inheritance). (b) Object interaction graph\nObject name: class\nObject\nObject 1: class 1\nsystem operation()\n(Controller object)\nObject 3: class 3\nObject 2: class 2\n(Collaborator objects)\nMessage 1 (parameter list)\nMessage 2 (parameter list)\nClass name\nattribute\nClass\n(d) Inheritance graph\nSuperclass\nSubclass 1\nSubclass 2\nSubclass 3\n(c) Object visibility graph\nClass (client)\nServer object\nClass name\nName: class\nClass A\nObject 1: class B\nExample of 'server lifetime unbound'\n(Lifetime of the server object is not bound to\nThe lifetime of the class that is accessing it)\nFIGURE 13.10: Some Fusion notation forms\nLike other OO methods and the UML, the construction viewpoint employs\na class diagram (termed the object model that has strong similarities to the\nERD notation described in Section 9.4. A simple example of this is shown in\nFigure 13.10(a). Class behaviour makes use of textual descriptions. Informally, in (Coleman\net al. 1994) there are examples that describe scenarios by using a form similar\nto the UML message sequence diagram that we described in Section 10.6. In the later, more detailed stages of model development, functionality is\ndescribed by using object interaction graphs to describe the way that objects\ncollaborate. A graph is created for each system operation. Figure 13.10(b)\nshows an example of this form, which does di\ufb00er rather from other notations\nencountered so far.", "domains": ["Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 241", "position": 241, "chunk_type": "semantic", "token_estimate": 272}
{"text": "Plan-Driven Software Design: 225\nThe second form of notation that can perhaps be considered as being spe-\nci\ufb01c to Fusion is the object visibility graph, shown in Figure 13.10(c). This is\nused to describe the \u2018reference structure of classes in the system\u2019, identify-\ning the objects that class instances need to access and the forms that these\nreferences should take (including their permanency or otherwise). In e\ufb00ect,\nthis notation is intended to describe encapsulation, and hence can be regarded\nas providing a data-modelling viewpoint. Finally, Fusion makes use of a relatively conventional inheritance graph,\nwhich again, provides support for modelling of the constructional viewpoint. An example of this is provided in Figure 13.10(d). Fusion\u2014some observations\nThe description above, brief as it is, should be su\ufb03cient to allow us to\nmake a number of observations about the use of plan-driven approaches to\ncreate an object-oriented model. 1. Fusion employs a quite complex four-viewpoint model at a relatively\nearly stage in the design process, particularly when compared to the\nsimpler models employed by SSA/SD in the early stages. 2. The process throughout is largely one of re\ufb01nement and elaboration,\npossibly because of the more complex design model, rather than involv-\ning any element of transformation between viewpoints (a key element of\nSSA/SD). 3. The basic set of candidate objects (a major design decision) is largely\ndetermined at the very start of the process. A bene\ufb01t of this is that\nthe design options are thereby constrained from an early point, while a\ndisadvantage is that it is then necessary to get the \u2018right\u2019 object model\nestablished very early in the process. For less experienced designers, this\ncan be a signi\ufb01cant challenge. 4. The characteristics described by the constructional viewpoint play a\nmuch more \u2018up front\u2019 role than in more traditional plan-driven ap-\nproaches. 5. While the concept of inheritance is integrated into Fusion, it is restricted\nto appearing very early (seeking to recognise domain-based opportuni-\nties) or much later, looking for constructionally-based opportunities. In terms of the characteristics of the object model, it can be argued that\nFusion does provide support for all of the major ones: abstraction, modular-\nity, encapsulation, and hierarchy. Fusion also handles the often quite di\ufb03cult\ndistinction between the class and the object quite e\ufb00ectively. When consid-\nering static and abstract issues, and specifying general characteristics, then\nthe emphasis is rightly upon the class.", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 242", "position": 242, "chunk_type": "semantic", "token_estimate": 395}
{"text": "226: Software Design: Creating Solutions for Ill-Structured Problems\nthe better abstraction to employ. As a method, it does keep these distinct,\nand encourages the designer to use whichever is the more appropriate in the\nspeci\ufb01c steps. Fusion therefore demonstrates that the use of a fairly \u2018traditional\u2019 form\nof plan-driven approach appears to be feasible when designing object-oriented\nsystems. However, key decisions about the choice of objects need to be made at\na very early stage. Indeed, this need to identify key elements early is probably\na disadvantage of all plan-driven approaches, regardless of the architectural\nstyle employed. 13.6.2\nThe Uni\ufb01ed Process (UP)\nThe Uni\ufb01ed Process (UP) stems from the work of the \u2018three amigos\u2019: Grady\nBooch, James Rumbaugh and Ivar Jacobson. It draws strongly upon early\nwork by Jacobson at Ericsson, and his later development of the Objectory\n(Object Factory) method. The UP also exists in more commercial forms, with\nthe best known of these being the Rational Uni\ufb01ed Process (RUP). The authoritative text on the UP is Jacobson, Booch & Rumbaugh (1999). Two other widely-cited sources are by Kruchten (2004) and Arlow & Neustadt\n(2005). Perhaps because the UP is closely associated with the UML, there are\nalso various texts on combinations with other forms, such as design patterns,\ndescribed in Larman (2004). While, like Fusion, the UP represents a merging of ideas from many\nsources, it di\ufb00ers from Fusion in two signi\ufb01cant ways. 1. The sources for the UP have included some of the most popular of the\navailable object-oriented methods and notations, as observed by Johnson\n& Hardgrave (1999). 2. The resulting process structure is much less sequential than that em-\nployed in Fusion. Its form comes much closer to RAD (Rapid Applica-\ntion Development) methods such as DSDM (described in Chapter 14)\nthat represent something of an interim form between plan-driven and\nagile approaches. A consequence of the \ufb01rst di\ufb00erence is that the association with the UML has\nmeant that it uses forms that are, at least in part, more familiar to users. The\nconsequence of the second is that it can probably be regarded as something of a\n\u2018bridge\u2019 between plan-driven and agile ideas. While still more structured than\nagile forms, it is nonetheless more iterative in terms of the processes involved\nthan those employed by plan-driven forms.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 243", "position": 243, "chunk_type": "semantic", "token_estimate": 383}
{"text": "226: The\nconsequence of the second is that it can probably be regarded as something of a\n\u2018bridge\u2019 between plan-driven and agile ideas. While still more structured than\nagile forms, it is nonetheless more iterative in terms of the processes involved\nthan those employed by plan-driven forms. Taken together, these may at least\npartly explain why the UP has continued to be of interest into the 2000s,\nwhile Fusion has largely receded into the shadows. (This is not a comment\nor assessment about relative technical excellence, more an observation that\nthe form of the UP has probably \ufb01tted better with the way that ideas about\nsoftware development have evolved.)", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 243", "position": 243, "chunk_type": "semantic", "token_estimate": 109}
{"text": "228: Software Design: Creating Solutions for Ill-Structured Problems\n1. Inception. This phase is primarily concerned with project planning ac-\ntivities. However, we might note that establishing the feasibility of a\nproject may lead to the creation of one or more exploratory prototypes. The milestone for this phase, life cycle objectives is largely concerned\nwith the eventual deliverables for the phase (documents, models, proto-\ntypes), but does include a candidate architecture, representing the initial\narchitectural design for the eventual application. The milestone documents should also include:\n\u2022 an initial domain-based class model;\n\u2022 a set of domain-based use cases;\n\u2022 initial analysis and design models. Although iteration is implicit, the normal expectation is that this phase\nshould require only a single cycle. We might also note the use of use\ncases, a very distinctive feature of the UP and one that has been elabo-\nrated in later developments. 2. Elaboration. From a design perspective, this is a much more signi\ufb01cant\nphase. Its purpose is to create the architectural baseline (top-level de-\nsign) that will underpin further development. In doing so, there is the\nexpectation of producing further use cases, as well as addressing ques-\ntions about quality factors, including those related to performance. The milestone for this phase, the life cycle architecture is a partial work-\ning system. The UP documentation does emphasise that this is not an\nexploratory prototype, although it can be argued that it is fairly close\nto being an evolutionary prototype. The resulting set of models will\ninclude:\n\u2022 static domain-based class models;\n\u2022 a fuller set of use cases;\n\u2022 analysis models (both static and dynamic);\n\u2022 static and dynamic architectural design models. The emphasis upon model-building and the need to ensure consistency\nbetween them, means that some degree of iteration is likely to be needed. 3. Construction. Despite the name, this phase still involves some design\nactivity. The initial operational capacity milestone corresponds to the\ndelivery of a beta version of the application. Hence its goals include:\n\u2022 completion of any requirements elicitation or analysis tasks;\n\u2022 completion of models. Clearly, the detailed physical design tasks form an essential element of\nthis.", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 245", "position": 245, "chunk_type": "semantic", "token_estimate": 357}
{"text": "Plan-Driven Software Design: 231\nUse Case: Reserve Car\nID: CCC_14\nActors: Customer\nPreconditions: Customer has \nReceived details of nearby cars. Flow of Events:\n 1. Customer selects car from list. 2. Reservation Manager object sends\n 'reserve' message to selected car. 3. Reservation Manager generates\n 'unlock' code and sends to customer. Postconditions: Status of car is\nchanged to 'reserved'. Unique identifier\nUse case name\nSystem state before\nuse case can begin\nActors involved\nSystem state at\nend of use case\nSteps of the\nuse case\n:ReservationManager\nselectCar(carID)\ncode\nCustomerID: code\nCarID: status (new)\nCustomer\n<<create>>\n<<update>>\nFIGURE 13.13: A UML use case and associated collaboration diagram\nThe UML package notation can be used to group analysis classes and use\ncase realisations as analysis packages. Since packages can also contain\nother packages, the analysis model can itself be considered as being a\npackage. A key role of this notation is to help keep track of the analysis\nelements, with the overall analysis architecture being de\ufb01ned by the\nhigh-level analysis packages. 3. Design work\ufb02ow This forms a major element of both the elaboration and\nconstruction phases and is intended to provide the white box description\nof how the black box model from the analysis work\ufb02ow is to be achieved. Many of the activities are similar to those described for Fusion: identi-\nfying design objects; when to create objects from the static classes; and\nthe persistence, or lifetime, of objects. Another consideration for this", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 248", "position": 248, "chunk_type": "semantic", "token_estimate": 239}
{"text": "232: Software Design: Creating Solutions for Ill-Structured Problems\nwork\ufb02ow is the more structural question of how to employ the inheri-\ntance mechanism. And once again, the package mechanism can be used\nto manage the outcomes, although the term subsystem is now used in\nplace of package to indicate that more detail is provided. Use cases are expected to provide a linking thread between analysis and\ndesign and may themselves need to be elaborated further. The UP design work\ufb02ow therefore addresses many detailed issues con-\ncerned with developing the design classes and their interfaces. Perhaps\nthe main change in the modelling involved, apart from elaboration of de-\ntail, is the development of behavioural viewpoint models, largely through\nUML statecharts, which also helps address the issues of object creation\nand persistence. As with Fusion, the white box design tasks of the UP are largely con-\ncerned with elaborating detail and ensuring consistency between the\ndi\ufb00erent parts of the design model. Most of the key architectural deci-\nsions have already been made as part of the analysis work\ufb02ow, although\nobviously this can be revised by the activities of the design work\ufb02ow\nif necessary. In that sense, like Fusion, the key structural decisions are\nmade early in the process re\ufb02ecting the more compositional approaches\nemployed by these object-oriented methods. 4. Implementation work\ufb02ow. This is primarily concerned with producing\nexecutable code, with the main design elements being con\ufb01ned to the\ndecisions involved in translating the design model to actual implemen-\ntation. Overall, this phase is not expected to form an active part of the\ndesign task. 5. Test work\ufb02ow. As might be expected, this involves no explicit design\nactivities beyond any required in response to the testing outputs. The UP\u2014some observations\nThe UP design process has a much more complex structure than the other\nmethods examined in this chapter, including Fusion. The interweaving of de-\nvelopment phases and work\ufb02ows produces a much more complex process than\nthe more linear forms of the other design methods we have examined, and as\nsuch forms a much more challenging management task. A key element of the UP, and one that particularly distinguishes it,\nis the use case.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 249", "position": 249, "chunk_type": "semantic", "token_estimate": 359}
{"text": "Plan-Driven Software Design: 233\n13.7\nEmpirical knowledge related to plan-driven design\nThe use of plan-driven design methods is perhaps more associated with\nthe ideas of advocacy than those of rigorous empirical assessment. In the early\ndays at least, design methodologists tended to be codifying their experiences (a\nquite reasonable approach to knowledge transfer in the circumstances) rather\nthan exploring their limitations. There are a number of possible explanations\nfor the lack of useful empirical knowledge about design methods, including\nthe following. \u2022 By their nature, design methods both evolve and are intended to be\nadapted to meet di\ufb00erent needs. This means that any attempt at eval-\nuation of the processes involved usually lacks a widely-established and\nwell-de\ufb01ned \u2018baseline design method\u2019 to study. \u2022 Software development (at least before the emergence of open source soft-\nware) was largely conducted by commercial organisations\u2014and knowl-\nedge about how it was done may well have been considered as being of\ntoo much value to allow for open publication. \u2022 As we have observed, the development of ideas about design methods\nrather \u2018tailed o\ufb00\u2019 in the 1990s. However, this was also the period in which\ninterest in empirical research about software engineering was beginning\nto become more established, and so researchers were perhaps less likely\nto view design methods as a topic of interest. The most appropriate form of empirical study to use in studying plan-\ndriven design development is probably the case study, since the subject matter\nneeds \ufb01eld studies with relatively long-term data collection, and there are also\nlikely to be many variables of interest. Unfortunately, these are challenging\nto perform for such a topic, and examples do appear to be lacking in the\nliterature. Nor do there seem to be any useful observation studies. An alternative form for collecting information about experience with de-\nsign processes is the survey, and while these may collect data that can be\nconsidered as more \u2018shallow\u2019 for these purposes, a survey does o\ufb00er scope to\ncollect and aggregate user experiences. Such a survey was conducted by Ed-\nwards, Thompson & Smith (1989) to look at the use of SSADM, and other\nsurveys have been conducted to address questions about object-oriented meth-\nods. In the rest of this section we examine their \ufb01ndings and observations\nabout the use of plan-driven approaches (there were other \ufb01ndings, but here\nwe concentrate on the methodological aspects). Knowledge about SSADM.", "domains": ["Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 250", "position": 250, "chunk_type": "semantic", "token_estimate": 399}
{"text": "234: Software Design: Creating Solutions for Ill-Structured Problems\ngovernment organisations, from which they obtained 117 responses, with\n72 (23%) of these being usable. (Given that anything above 10% is re-\ngarded as being a good response rate for a survey, the researchers did\nwell.) At the time when they conducted their survey, projects tended to\nbe using programming languages such as COBOL and many were also\nconcerned with database management systems. For the responses, team\nsizes involved ranged from teams with fewer than 10 up to ones with\nover 200 developers. The survey revealed that SSADM was rarely used in full, with developers\nbeing selective about when to make use of it. In particular, it was noted\nthat, while responses tended to be positive:\n\u2022 the techniques were generally found to be e\ufb00ective, but were time-\nconsuming to employ;\n\u2022 the entity-life-history diagram presented most problems for devel-\nopers when modelling and was the form of notation most frequently\nomitted;\n\u2022 the physical design step was the most challenging, perhaps in part\nbecause the method provided little in the way of detailed guidance\nabout how to perform this for a particular platform. Knowledge about OO design. The survey conducted by Johnson & Hard-\ngrave (1999) used two groups of participants: experienced developers and\ntrainees. Also, its focus was upon their attitudes and preferences with re-\nspect to object-oriented methods and tools, rather than upon the forms\nof the speci\ufb01c methods. Separate survey forms were used for the two groups, and the sample\nincluded 102 experienced designers and 58 trainees. Since the survey\nwas conducted on-line, there are some methodological issues regarding\nsampling and representativeness, as the authors do acknowledge. The authors also observe that the degree of comparison (between meth-\nods) that could be achieved was limited. This was chie\ufb02y because \u201ca\ntheory explaining attitudes and behaviour toward, and use of OOAD\nmethods does not currently exist\u201d. Hence they argue that the survey\no\ufb00ered an inductive approach that would \u201cuse facts to develop general\nconclusions\u201d and lay some of the groundwork for the development of\nsuch a theory. In terms of comparisons, the survey was chie\ufb02y concerned with the de-\ngree of training provided for developers, their familiarity with, and pref-\nerence between, di\ufb00erent object-oriented methods, and their attitudes\ntowards them.", "domains": ["Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 251", "position": 251, "chunk_type": "semantic", "token_estimate": 381}
{"text": "236: Software Design: Creating Solutions for Ill-Structured Problems\nprovide a solution modelling process for an ISP that is more akin to\nthat for a WSP. Design input. Although plan-driven forms provide a structure that can help\norganise the design process, it is important to appreciate that the design\ndecisions made within this are still ones that are based upon the needs of\nthe application. Using a plan-driven approach requires that the designer\npossesses method knowledge, an understanding of the problem, and an\nappreciation of relevant design criteria. Plan-driven design strategies. These usually consist of a mix of a repre-\nsentation part; a process part; and a set of heuristics used to help adapt\na strategy or method to a particular type of problem. The process part\nincorporates declarative knowledge about how the design task should be\norganised as a set of steps. The heuristics provide procedural knowledge\nabout how to employ the method for a particular type of problem. Context. Plan-driven methods implicitly assume a \u2018waterfall-like\u2019 develop-\nment context. This is chie\ufb02y because they build their initial analysis\nmodels around the elements of the requirements speci\ufb01cation. While\nthis doesn\u2019t preclude making later changes to the model, the assump-\ntion is that the requirements speci\ufb01cation is a comprehensive description\nof the design goals. Architectural form. Earlier plan-driven methods were concerned with rel-\natively simple architectural styles such as call-and-return, where the de-\npendencies (coupling) between design elements used only a limited set of\nforms. Use of plan-driven approaches has proved more challenging with\nsuch styles as the object-oriented model, where there are many forms of\ninteraction that can occur between the elements of a design. E\ufb00ectiveness. There are few empirical studies available to provide any in-\nsight into this. One bene\ufb01t of using a systematic plan-driven approach\nis that it helps constrain the structure of the resulting design model,\nwhich in turn may assist with later evolution of the model. Perhaps one\nof the main disadvantages of the plan-driven approach is that it can be\nbureaucratic, with a signi\ufb01cant overhead of documentation\u2014although\nas in the case of SSADM, that may be considered as a bene\ufb01t.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 253", "position": 253, "chunk_type": "semantic", "token_estimate": 354}
{"text": "238: Software Design: Creating Solutions for Ill-Structured Problems\nrole of design, it becomes much harder to compartmentalise its contribution\nto the process as a whole. 14.1\nUsing software prototypes\nAs observed above, a major limitation of a linear development process such\nas a plan-driven one, is the need to identify exactly what is needed from an\napplication at the very beginning of the process. There are many reasons why\nthis is largely impractical: those commissioning the application (who may be\nthe developers of course) do not have a comprehensive picture of what it will\ndo; the picture that they do have may need to change between starting and\n\ufb01nishing development because of a growing understanding; and there may be\nmany uncertainties and possible omissions in the understanding of what is\nrequired. In other engineering domains, such a situation is often resolved by the\nconstruction of some form of prototype which can be used to investigate both\nwhat is needed, and how it might be delivered. The same idea can be used\nwith software, although the ease with which software can be changed can make\nits role and use rather di\ufb00erent. For more traditional branches of engineering,\na prototype is usually regarded as a \u2018\ufb01rst of kind\u2019, or takes the form of a\nmodel that can be realised on a (reduced) scale. In automotive engineering,\na prototype of a car is de\ufb01nitely a \ufb01rst of kind (and sometimes the last too),\nwhile scale modelling may well be used with complex civil engineering projects. (As an example, the engineers constructing the Thames Barrier down-river\nfrom London built a scale model of their intended structures in the nearby\nmarshes.) Analogous roles for prototypes are not easily found in software develop-\nment, where there is no manufacturing cycle and no real equivalent to scale\nmodelling. Indeed, for software it is quite possible that the prototype will ac-\ntually become the product in due course, which would make no sense for our\nexamples from other branches of engineering. However, while the form of a\nprototype might be di\ufb00erent for software, the reasons for creating prototypes\nare very similar to those found in other disciplines. Prototypes are constructed\nin order to explore ideas about the requirements and design of an application\nmore completely than would be possible by other means (such as modelling).", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 255", "position": 255, "chunk_type": "semantic", "token_estimate": 387}
{"text": "238: However, while the form of a\nprototype might be di\ufb00erent for software, the reasons for creating prototypes\nare very similar to those found in other disciplines. Prototypes are constructed\nin order to explore ideas about the requirements and design of an application\nmore completely than would be possible by other means (such as modelling). A useful categorisation of major prototyping forms as used with software\nwas produced by Floyd (1984), and this recognised three principal roles for a\nprototype. 1. Evolutionary. This is the form that is closest to the idea of incremen-\ntal development of an application. The software is changed gradually\nby changing the requirements speci\ufb01cation as experience is gained with", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 255", "position": 255, "chunk_type": "semantic", "token_estimate": 114}
{"text": "Incremental Design in Agile Software Development: 239\nusing the application, and changing the application to \ufb01t those changes. In this form, prototyping is used to develop a product and the prototype\ngradually evolves into the \u2018end\u2019 product. One bene\ufb01t of this strategy is that it allows a product to be made avail-\nable quickly where the market or other factors mean that this is needed\nurgently. It can then be re\ufb01ned through subsequent releases (Cusumano\n& Selby 1989). 2. Experimental. In this role, the purpose of the prototype is to assist with\nevaluating a possible design model for all or part of an application, by\ndeveloping a \u2018quick build\u2019 in advance of a more complete design and\nimplementation. The prototype can be used to assess such aspects as a\nuser interface or an algorithm, and may well be built using tools that\nproduce an implementation that is quite di\ufb00erent to the form intended. Such a prototype is de\ufb01nitely intended as a throw-away item. 3. Exploratory. Such a prototype is usually used to help clarify user re-\nquirements and perhaps to investigate how using the application might\nchange the way that users work within an organisation. In this role, it\ncan act as a form of partial feasibility study, focusing on the issues of\ninterest alone, and again, such a prototype is really a throw-away item. Whatever the purpose, a prototype can provide a useful intermediate step\ntowards addressing an ISP. The experimental and exploratory forms can be\nviewed as simplifying the elements of the problem (whereas a plan-driven ap-\nproach seeks to simplify the process), while the evolutionary approach struc-\ntures the way that the interactions in Figure 1.1 are managed. This is illus-\ntrated in Figure 14.1. The idea of prototyping, and of evolutionary prototyping in particular,\n\ufb01ts in well with the concept of an emergent organisation. An emergent organ-\nisation is one that is \u201cin a state of continual process change, never arriving,\nalways in transition\u201d (Truex, Baskerville & Klein 1999). Where the software\nit uses needs to re\ufb02ect this characteristic, then prototyping can help explore\nwhat the needs of an application are as well as how it can be created. That all said, the adoption of a prototyping approach does not o\ufb00er any\nparticular guidance about how the development of a design should occur.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 256", "position": 256, "chunk_type": "semantic", "token_estimate": 387}
{"text": "240: Software Design: Creating Solutions for Ill-Structured Problems\nproblem\nspace\npart\nproblem 1\npart\nproblem 2\npart\nproblem n\npart\nsolution 1\npart\nsolution 2\npart\nsolution n\nrevised\nproblem\nspace\npart\nproblem 1\npart\nproblem 2\npart\nproblem n\npart\nsolution 1\npart\nsolution 2\npart\nsolution n\nsolution\nspace\nprototype\nenhanced understanding\nfrom the prototype\nFIGURE 14.1: Use of an evolutionary prototype\nas well as for design, and provide a pictorial overview of a process. Story-\nboards can provide useful support for design reviews. These, conducted both\nwith other team members as well as with end-users and customers, can form a\nvaluable element of incremental design, as they can convey system behaviour\nwithout needing to go into technical detail. (And with the bene\ufb01t that a story-\nboard does not easily become an evolutionary prototype!). The story-board\ncan also be used in conjunction with the idea of the use case discussed in the\ncontext of the Uni\ufb01ed Process, both for developing and also for recording the\ndetails of a use case. Figure 14.2 shows a simple example of the use of a story-\nboard when developing the CCC software. In practice this would probably\nbe sketched if it is being used within a design team, although it may well be\nturned into a more elegant presentation for a customer. Experts prototype concepts. PvdH #55", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 257", "position": 257, "chunk_type": "semantic", "token_estimate": 225}
{"text": "242: Software Design: Creating Solutions for Ill-Structured Problems\ning in this way, the development team can periodically re-assess the ISP being\ntackled based on understanding gained in the preceding stages. From a design perspective, this represents something of the inevitable\ntrade-o\ufb00. Plan-driven forms tend to become overly complex when used with\nother than relatively simple architectural styles. Equally, many key decisions\nare made early in the development process, when the nature of the intended\napplication is still incompletely understood. However, plan-driven strategies\ndo provide a (relatively clear) path to the end goals. Incremental design pro-\nvides greater \ufb02exibility, but some decisions still need to be made early on (such\nas architectural form) and it may be harder to keep a sense of direction towards\na solution. This may be more challenging for larger projects (Boehm 2002, El-\nbanna & Sarker 2016), and there are questions of the skills needed for design-\ning in such a context and the e\ufb00ectiveness of agile development for knowledge\ntransfer about design skills (Jacobson, Spence & Seidewitz 2016). One of the earliest attempts at breaking away from the perceived rigidity\nof plan-driven forms was the spiral model devised by Barry Boehm (1988). In many ways, Boehm\u2019s spiral model was quite \u2018visionary\u2019, and it explicitly\nassumed the use of prototyping in an incremental process by which the design\nmodel was developed through a set of incremental stages. At each stage in\ndevelopment the next set of developments for the design model were planned\nin terms of:\n\u2022 the objectives for that particular stage;\n\u2022 the options and constraints that were to be explored;\n\u2022 evaluation of the risks involved in choosing between the options;\n\u2022 formulating a plan for the stage, which might involve developing a new\nprototype or involve other activities, according to the conclusions of the\nrisk analysis. Within the context of a prototyping strategy, perhaps the most important\nelement to highlight from this list of actions is that of risk assessment, since\nthis links back to the very reason why such an approach might be needed. In particular, given that one of the risks implicit in the use of prototyping\nis that the sense of \u2018direction\u2019 might become lost, the spiral model o\ufb00ered a\nmechanism for monitoring and controlling the development process. Incremental design is an approach that is less commonly encountered in\nother forms of engineering design.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 259", "position": 259, "chunk_type": "semantic", "token_estimate": 395}
{"text": "242: In particular, given that one of the risks implicit in the use of prototyping\nis that the sense of \u2018direction\u2019 might become lost, the spiral model o\ufb00ered a\nmechanism for monitoring and controlling the development process. Incremental design is an approach that is less commonly encountered in\nother forms of engineering design. As a technique it is unlikely to \ufb01nd much\nfavour with civil engineers (\u201cafter we have built the central span of the bridge,\nwe\u2019ll work out how to construct the approaches\u201d), any more than with other\nengineering disciplines such as chemical or electrical engineering. This is not\nto argue that it is not a valid engineering approach, given su\ufb03cient planning\nand control, but rather that it is an approach that only makes sense when used\nwith a medium such as software where there is no manufacturing stage, and\nwithin the type of dynamically changing context often met in software-based", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 259", "position": 259, "chunk_type": "semantic", "token_estimate": 152}
{"text": "Incremental Design in Agile Software Development: 243\nbusiness use and in the emergent organisations that are made possible through\nthe use of software applications. It is also widely employed for development\nof open source software (OSS) as discussed in Chapter 18. Experts design throughout the creation of software. PvdH #22\nAgree basic\nrequirements\nImplement \nand test\nfinal system\nDevelop\narchitectural\ndesign\nPrototype,\ntest and\nevaluate\nPartial detailed\ndesign\nFIGURE 14.3: Pro\ufb01le of an incremental development process\nOne issue that can easily become blurred where incremental development\nis employed is the distinction between design and implementation. An incre-\nmental approach is likely to involve some interleaving of design stages with\nimplementation and evaluation. However, the design stages are likely to be\nmore concerned with \u2018detailed design\u2019 issues, occurring within a context es-\ntablished by a set of architectural design decisions made early on. Figure 14.3\nillustrates this point schematically, and in the next section we will see that\nour example of DSDM broadly conforms to this form of structure. Valuable and in\ufb02uential though the spiral model was, in itself it didn\u2019t\no\ufb00er any very strong procedural or declarative guidance about how develop-\nment, and design in particular, should be organised as a set of \u2018chunks\u2019. This\nwas addressed in the later development of thinking about rapid application\ndevelopment or RAD. 14.3\nRAD: the DSDM method\nRAD, or rapid application development can be considered as describing\na process of development that is essentially a structured form of incremental\ndevelopment. RAD has attractions for developing commercial applications and", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 260", "position": 260, "chunk_type": "semantic", "token_estimate": 255}
{"text": "Incremental Design in Agile Software Development: 245\n1. Active user involvement is imperative. DSDM identi\ufb01es a number of\nsuch roles such as the ambassador, who \u201cguides the developers in their\nactivities to ensure that the solution being developed will accurately\nmeet the needs of the business\u201d; and the advisor, who is tasked with\nrepresenting a particular user view. 2. DSDM teams must be empowered to make decisions. This is a corollary\nto the \ufb01rst principle, since active user involvement is incompatible with\nthe need to obtain decisions from higher-level project management. 3. Focus is on frequent delivery of products. DSDM favours managing in-\ncrements on the basis of the \u2018product\u2019 (including documentation) over\nincrements of the \u2018activities\u2019 themselves, with an emphasis upon allo-\ncating \ufb01xed periods of time for performing various activities. 4. Fitness for business purpose is the essential criterion for acceptance of\ndeliverables. DSDM takes the view that delivery within the required time\nperiod is of paramount importance, and that once the functionality has\nbeen established, the structure of the software can be re-engineered as\nnecessary. (This can be seen as down-playing the role of design.) 5. Iterative and incremental development is necessary to converge on an\naccurate business solution. The key issue here is that iteration needs\nto be part of the organisation\u2019s procurement strategy, with the aim of\nachieving continuous improvement in the software through its use. 6. All changes during development are reversible. DSDM accepts that the\npossible need to backtrack to an earlier state (of the design model) is in-\nherent in incremental design. Hence con\ufb01guration control is an essential\nand all-pervasive element of the development context. 7. Requirements are baselined at a high level. Unlike plan-driven forms,\nDSDM is mainly concerned with freezing requirements at a high level\n(which in turn relates to the need to choose an architecture), and allow-\ning more detailed aspects to evolve as necessary. 8. Testing is integrated throughout the life-cycle. This is a major departure\nfrom plan-driven thinking, which tends to consider testing as a post-\nimplementation element, but again looks forward to ideas about agile\ndevelopment. 9. A collaborative and co-operative approach between all stakeholders is\nessential. Involving the stakeholders in the development process implies\nthe need for \u2018lightweight\u2019 change control procedures, allowing for short-\nterm redirection of a project through consensus. A distinctive feature of the philosophy, and one that strongly in\ufb02uences\nthe process, is that of time.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 262", "position": 262, "chunk_type": "semantic", "token_estimate": 403}
{"text": "246: Software Design: Creating Solutions for Ill-Structured Problems\nTime\nFunctionality\nResources\na) DSDM: fix time &\nresources, vary the\nfunctionality delivered\nb) Plan-driven: fix the\nfunctionality, & vary the\ntime and resources. FIGURE 14.4: Varying the design constraints (time, functionality and re-\nsources)\napplication is expected to provide, embodied in the requirements speci\ufb01cation,\nis \ufb01xed, with the time and resources needed to achieve this being varied as\nnecessary. But in the DSDM context this is inverted, time and resources are\nconsidered as \ufb01xed during a cycle, and the deliverable functionality is allowed\nto change, as illustrated schematically in Figure 14.4. Obviously this philosophy is one that rather constrains the scope for using\nDSDM. No-one would advocate its use for developing avionics software (\u201cwe\ndidn\u2019t have time to complete the module that allows the landing gear to be\nlowered, but go ahead with the test \ufb02ight anyway\u201d). On the other hand, where\nbeing \ufb01rst to market is important, some limitations in an application might\nbe more acceptable if agreed by developer and end-user. An important concept in DSDM is that of timeboxing. This is a process\n\u201cby which de\ufb01ned objectives are reached at a pre-determined and immovable\ndate through continuous prioritisation and \ufb02exing of requirements using the\nMoSCoW rules\u201d (Stapleton 1999). (Note that timeboxing is a process, rather\nthan some form of object, although the DSDM literature does then refer to\nindividual \u2018timeboxes\u2019\u2014and it is di\ufb03cult not to do so!) A timebox is normally\nexpected to last between two and four weeks. The MoSCoW rules used to\nprioritise requirements are summarised in Table 14.1. In essence the role of\ntimeboxing is to ensure that a project team has a clear focus and deadline at\nany point in time and to manage the \ufb01xed-time aspect by providing guidance\non the acceptable degree of functionality that an increment should have. In", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 263", "position": 263, "chunk_type": "semantic", "token_estimate": 308}
{"text": "Incremental Design in Agile Software Development: 247\nplanning a timebox the recommendation is that about 60% of e\ufb00ort should be\ndirected towards implemented \u2018must have\u2019 requirements, with the remaining\n40% split between \u2018should\u2019 and \u2018could\u2019 haves. This means that if it proves\nimpossible to achieve all of the goals within a timebox, there should still\nbe enough resource and time to ensure that the \u2018must have\u2019 elements are\ndelivered. TABLE 14.1: The MoSCoW Rules for prioritisation\nRule\nInterpretation\nMust have\nThose requirements that are fundamental to the\nsystem, such that it will be inoperable if they are\nnot met. Should have\nImportant requirements that would be manda-\ntory if more time were available, but for which\nsome sort of work-around can be achieved in the\nshort term. Could have\nRequirements that can safely be left out of the\ncurrent deliverable, being desirable but not es-\nsential. Want\nto\nhave\nbut\nwon\u2019t have this time\nRequirements that are on the waiting list for the\nfuture. Of course, assigning requirements to categories can be quite a di\ufb03cult\nprocess, and this is where the emphasis that DSDM places upon a collaborative\napproach to development is important. Team members who insist that all of\ntheir requirements are clearly in the \u2018must have\u2019 category are unlikely to make\nuseful contributions to this process! 14.3.2\nThe DSDM process\nThe DSDM process is generally described as being a framework made up\nfrom \ufb01ve phases, and provides little that can be considered as prescriptive. Figure 14.5 provides a simple model of this. In many ways this is an elaboration\nof the model shown in Figure 14.3 for incremental development, although the\nfeedback involved in iteration is rather more complex. The description here\nfocuses chie\ufb02y on the impact that this model has upon the design process. Feasibility study. This phase is meant to be kept short, and should deliver\na feasibility report, together with an outline plan for development that\nprovides more detail. One option is to develop a feasibility prototype that\ncan be viewed as largely exploratory (and of course, need not actually\ninvolve writing software if a form such as story-boarding is used). From\na design perspective this is likely to explore possible architectural forms,\nrather than provide anything more detailed.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 264", "position": 264, "chunk_type": "semantic", "token_estimate": 374}
{"text": "248: Software Design: Creating Solutions for Ill-Structured Problems\nFeasibility\nstudy\nImplementation\nBusiness\nstudy\nFunctional\nmodel\niteration\nDesign and\nbuild iteration\nAgree\nplan\nIdentify\nfunctional\nprototype\nCreate\nfunctional\nprototype\nReview\nprototype\nAgree\nplan\nIdentify\ndesign\nprototype\nCreate\ndesign\nprototype\nReview\ndesign\nprototype\nReview\nbusiness\nImplement\nTrain\nusers\nUser approval\n& guidelines\nFIGURE 14.5: The DSDM development process\nBusiness study. This again is intended to be of short duration and to be\nhighly collaborative. It leads to what we can consider as being the \ufb01rst\nreal design decisions, embodied in the system architecture de\ufb01nition. This identi\ufb01es both the architectural style to be employed and also the\nmain elements of the system architecture. Functional model iteration. This is really the element that concentrates\non black box modelling of what the application is to do within the given\nbusiness context. So this phase does emphasise modelling of business\nneeds, without going into detail about such non-functional aspects as\nsecurity and performance. The main outputs are models such as class\nmodels and data models and functional prototypes that are expected to\nbe more or less complete in terms of their user interface, along with\nsome basic degree of functionality. Design and build iteration. This is the phase where the detailed decisions\nabout implementation are made. The main output produced is still clas-\nsi\ufb01ed as being a prototype although it may well incorporate the key\nfunctionality of the application. This phase produces a mix of white box\nmodels and actual code and incorporates a strong element of testing. Implementation. The emphasis here is less upon developing the software as\ngetting it into productive use, including collaboratively addressing any\nneeds for training material and documentation.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 265", "position": 265, "chunk_type": "semantic", "token_estimate": 278}
{"text": "252: Software Design: Creating Solutions for Ill-Structured Problems\n9. Collective ownership. The code of the application is owned by all, and\nany member of the team may make changes to it when they feel it\nnecessary. 10. On-site customer. The customer works with the team to answer ques-\ntions, perform acceptance tests, and monitor progress. 11. 40-hour week. Iterations should be organised so that overtime is not\nneeded, on the basis that tired developers make mistakes. 12. Open workspace. Developers share workspace and use shared coding\nstandards, following clearly-de\ufb01ned conventions for such aspects as iden-\nti\ufb01ers, layout etc. Interesting as these are (and there are few that would be likely to appear\nin a plan-driven method), as observed above, our main concern here is how\nthese in\ufb02uence the process of design. Indeed, one thing we might note is that\nthere are no particular assumptions in the practices about architectural style\nor the detailed form that the implementation will take. So, based upon the values and practices described above, we can identify a\nnumber of characteristics that can be considered to form the design strategy of\nXP. As might be expected these are much more concerned with principles that\ndesign activities should follow, rather than the exact form that the activity\nshould take. Indeed, as one measure of the nature of \u2018agility\u2019, it is impractical\nto try to draw a process model for XP. \u2022 The KISS principle. The idea of \u2018keep it simple stupid\u2019 is to remind de-\nsigners to avoid over-complicating the design model. Implicitly of course,\ncomplicated structures create technical debt and make future changes\nmore di\ufb03cult. In an agile context, where those future changes are hap-\npening as part of the development process, this is particularly important. So a simple design minimises the set of classes and methods, avoids du-\nplication of logic, and avoids unnecessary items\u2013while of course, meeting\nthe criterion of \u2018\ufb01tness for purpose\u2019. \u2022 Use CRC cards. We encountered the use of class-responsibility-\ncollaborator cards in the previous chapter when looking at the Uni\ufb01ed\nProcess. They are a valuable way of documenting a design, providing a\nplace to note design issues, and also helping to identify where an element\nis becoming overly complicated. \u2022 Use \u2018spike\u2019 solutions to reduce risk.", "domains": ["Design Patterns", "Design Principles"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 269", "position": 269, "chunk_type": "semantic", "token_estimate": 376}
{"text": "252: They are a valuable way of documenting a design, providing a\nplace to note design issues, and also helping to identify where an element\nis becoming overly complicated. \u2022 Use \u2018spike\u2019 solutions to reduce risk. A spike solution can be regarded as a\nform of exploratory prototype, and is used where the team need to decide\nhow to proceed with a particular element of the system that is proving to\nbe complex. By building a \u201cquick and narrow implementation\u201d (P\ufb02eeger\n& Atlee 2010) the team can obtain valuable feedback about the design\noptions.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 269", "position": 269, "chunk_type": "semantic", "token_estimate": 94}
{"text": "Incremental Design in Agile Software Development: 253\n\u2022 Have a metaphor. This is really a description of the application that\nthe project aims to produce. In some ways it is similar to the idea of\nthe architectural pattern that we discuss in the next chapter, providing\na simple message that describes the overarching form of the application\nand maps its key features on to software structures. \u2022 Refactor. After adding a factor to the code, the team should look to\nsee if this can be simpli\ufb01ed. This complements the goal of keeping the\ndesign as simple as possible (the KISS principle). An important point here is that while the XP literature tends to refer to\n\u2018code\u2019, there is absolutely no reason why the design should not be modelled\nwith diagrams when the team thinks this will help. The emphasis in XP upon\ndeveloping through a series of small increments does not present an obstacle\nto doing this either, provided we remember that sketches are probably the\nappropriate form to use. Viewed as an incremental development process, XP \u2018chunks\u2019 the incre-\nments based on application functionality rather than on performing speci\ufb01c\ndevelopment activities (in principle, each iteration may involve combinations\nof all of the \u2018classical\u2019 activities). 14.6\nAgile development: Scrum\nOur second example provides a rather di\ufb00erent example of agile thinking,\nwith much greater focus upon the processes rather than the technical issues\nof producing a design. The basic ideas underpinning Scrum date from the mid-1990s. (The name\nisn\u2019t an acronym, and refers to the way that team members in a game of\nrugby huddle together when they are trying to advance.) Two key references\nare (Schwaber & Beedle 2002) and (Schwaber 2004)1. The original motivation\nappears to be the question that Ken Schwaber asked about software devel-\nopment: \u201cwhy do the de\ufb01ned processes of the CMM (Capability Maturity\nModel) not measurably deliver?\u201d. Without digressing too much from our fo-\ncus on design, we should note that the CMM is primarily concerned with\nassessing how dependable an organisation\u2019s development processes are\u2014with\na strong emphasis upon the idea of learning from previous projects. Schwaber\nrecognised that development processes were dealing with ISPs (whereas the\nCMM implicitly treats them as WSPs by assuming that such experiences are\ntransferable) and that developers needed to accept change rather than expect\npredictability. 1A short de\ufb01nitive (downloadable) guide from the developers of Scrum is available at\nhttps://www.scrum.org/resources/scrum-guide", "domains": ["Design Principles"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 270", "position": 270, "chunk_type": "semantic", "token_estimate": 400}
{"text": "Incremental Design in Agile Software Development: 257\nRefactoring may be performed for other reasons of course, with performance\nbeing one example of a possible motivation. Identifying candidate classes for\nreorganisation may also be based upon the use of code metrics, and upon\nconsideration of such issues as code smells, a topic that we address in the next\nchapter. Of course, refactoring also requires time and e\ufb00ort, which may be di\ufb03cult\nto spare in a project, particularly as refactoring is something that we perform\nwith code that is working correctly. Here again, we encounter the trade-o\ufb00\nbetween time spent on performing restructuring in order to make future de-\nvelopment activities easier, and the need for a team to deliver code. In a survey\nby (Tempero, Gorschek & Angelis 2017) examining what might impede devel-\nopers from refactoring, the authors observe that \u201cthe decision to refactor is\nultimately a business decision\u201d, reinforcing the view that refactoring is really\nnot a design issue alone. So, from the perspective of the software designer, refactoring can be viewed\nas \u2018design adjustment\u2019 rather than \u2018design modi\ufb01cation\u2019. It involves reorganis-\ning the design elements, while retaining the functionality and behaviour of the\ndesign. So it can be regarded as purely a\ufb00ecting the design from the construc-\ntional viewpoint with the goal of improving largely non-functional aspects of\nthe design model. 14.8\nEmpirical knowledge about design in agile develop-\nment\nThis chapter (and the previous one) cover some quite di\ufb00erent forms of\ndevelopment life-cycle and there is an interesting review and summary of many\nof these in Ruparelia (2010) (an article that is described as a \u2018history column\u2019). While there is relatively little empirical knowledge for plan-driven forms,\nthe agile concept emerged at more or less the same time that empirical studies\nwere becoming \ufb01rmly established in software engineering. As a result, there is\nwhat might sometimes seem to be an endless stream of evaluation frameworks\nfor comparing methods and of empirical studies related to various aspects of\ntheir use, adoption, adaptation, etc. This section is not a systematic review\nof knowledge about agile development (Kitchenham et al. 2015); rather it\nis a selection of a few studies that can be thought of as examples, or that\nparticularly address issues highlighted in the previous sections. So, here we concentrate on evaluations that involve some element of as-\nsessment of how far a method provides guidance about design.", "domains": ["Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 274", "position": 274, "chunk_type": "semantic", "token_estimate": 399}
{"text": "Chapter 15: Designing with Patterns\n15.1\nPatterns as a mechanism for knowledge transfer ................\n262\n15.2\nArchitectural patterns ...........................................\n265\n15.2.1\nModel-view-controller (MVC) ...........................\n266\n15.2.2\nLayers ....................................................\n268\n15.2.3\nBroker\n...................................................\n270\n15.3\nDesign patterns ..................................................\n271\n15.3.1\nProxy (207) ..............................................\n275\n15.3.2\nObserver (293) ...........................................\n278\n15.3.3\nAbstract Factory(87) ....................................\n281\n15.4\nOther uses of patterns ...........................................\n283\n15.4.1\nSoftware service patterns ................................\n283\n15.4.2\nDesign anti-patterns and code smells ...................\n284\n15.5\nDesigning with patterns ..........................................\n286\n15.6\nEmpirical knowledge about designing with patterns ............\n288\nKey take-home points about designing with patterns ...........\n290\nSo far, in this third part of the book, we have been largely concerned with\ndesign approaches that involve following procedures (methods) to create ap-\nplications. In this chapter we consider a quite di\ufb00erent way of producing a\ndesign (or part of a design), by reusing abstract ideas about design structures\nthat have been found to work well by others. In a way, it makes use of forms\nthat could be considered as being more related to \u2018design as a noun\u2019 in order\nto support the activities of \u2018design as a verb\u2019! Reuse of experience comes in various forms, and the idea of designing an\napplication by reusing some form of pattern has attracted a lot of attention\nsince the 1990s. Patterns o\ufb00er another way of codifying experience about\ndesign, and of transferring it to others\u2014although there are those who consider\nthat they provide a knowledge transfer mechanism that is more appropriate\nto experienced designers than beginners. The pattern concept can be employed at di\ufb00erent levels of abstraction, and\nwith di\ufb00erent architectural styles, and although it is usually associated with\nobject-oriented development, it is by no means restricted to being used with\nsuch architectures. However, as with all mechanisms for transferring design\nknowledge, patterns provide no automatic guarantee of success, and do require\ncare in use. 261", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 278", "position": 278, "chunk_type": "semantic", "token_estimate": 315}
{"text": "262: Software Design: Creating Solutions for Ill-Structured Problems\n15.1\nPatterns as a mechanism for knowledge transfer\nThe concept of the design pattern is one that originated in another dis-\ncipline, and is rooted in the work of the architect Christopher Alexander\n(Alexander et al. 1977). He has described it in the following words. \u201cEach pattern describes a problem which occurs over and over\nagain in our environment, and then describes the core of the solu-\ntion to that problem, in such a way that you can use this solution\na million times over, without ever doing it the same way twice.\u201d\nAs a simple example, we could have a pattern for building a school. The\nproblem that it addresses is a generic one (to support the process of educating\nchildren and young adults), and the format of teachers and classes is more or\nless universal. However support for this might be realised in many di\ufb00erent,\nbut related, ways, with the di\ufb00erences between them re\ufb02ecting such issues as\neducational structures, age group, climate etc. While the \u2018school pattern\u2019 describes how something might be structured,\nthere are other familiar patterns that describe how things behave. Bus services\nprovide an example of a behavioural pattern with easily-recognised compo-\nnents (bus stations, stops, routes, timetables etc.). Catching a bus in an unfa-\nmiliar place might involve local variations, such as where to board, and when\nand how to pay, but the idea is a familiar one that usually requires little\nexplanation. Build-a-pyramid pattern\nUsed in the context of design, a pattern\ncan provide a generic solution to some prob-\nlem which recurs in various forms, and which\nitself may be sub-part of a larger problem. A pattern can help a designer gain under-\nstanding of the characteristics of a particu-\nlar problem as well as providing a strategy\nfor addressing it. If it is well documented,\nit should also provide some ideas about the\ncontext where it might arise, as well as of any\npossible consequences (usually in the form of\ntechnical debt) that might be incurred when using that pattern. In some ways, the idea of the pattern comes much closer to embodying the\ntraditional master/apprentice model for transfer of knowledge and expertise\nthan forms such as plan-driven design methods can hope to achieve.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 279", "position": 279, "chunk_type": "semantic", "token_estimate": 381}
{"text": "266: Software Design: Creating Solutions for Ill-Structured Problems\nAs with other patterns, the basic description of an architectural pattern\nneeds to address the following three factors. \u2022 The context within which some recurring situation occurs. Examples of\nthis might be the need to decouple elements of an application, or to\nincorporate the ability to dynamically update information sources while\na system is operating. \u2022 The problem, which is related to the issues that the context may present\nfor software development. \u2022 A solution that addresses the needs of the problem in a suitably general\nway. This may be described in terms of the type of element making up\nthe application, the forms of interaction between elements, the topology\nof the elements, and the likely constraints and trade-o\ufb00s involved. Architectural patterns have some synergy with ideas about architectural\nstyle although they are not necessarily restricted to being realised using a par-\nticular style. In principle at least, any architectural style can be employed with\na pattern providing that the form of the elements can provide the necessary\nstructures and that their interactions can be organised to \ufb01t the pattern. Perhaps because of the large-scale perspective involved, the set of archi-\ntectural patterns is much smaller than that of design patterns discussed in\nthe next section. However, as with all patterns (and styles) they do provide\na useful vocabulary for the designer who is wishing to exchange ideas or ex-\nplore options. In the rest of this section we brie\ufb02y examine three examples of\narchitectural patterns. (A much more detailed and analytical explanation of\na useful catalogue of architectural patterns is provided in (Bass et al. 2013).) 15.2.1\nModel-view-controller (MVC)\nThe model-view-controller pattern describes a widely-used form of organ-\nisation that is employed for many applications that involve some degree of\ninteraction with end-users. Here, the context is one of needing to decouple\nsome form of information store (the \u2018model\u2019) from the way that it is shown to\ndi\ufb00erent users and viewed on di\ufb00erent devices (the \u2018views\u2019). The problem is\nhow to achieve this decoupling while also keeping the application responsive\nto user actions. To achieve this, MVC divides such an application into three\ntypes of element. \u2022 The model incorporates the core functionality and associated data for\nthe application. \u2022 A view provides information about the model to the user, presented in a\nparticular way.", "domains": ["Architectural Patterns and Styles"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 283", "position": 283, "chunk_type": "semantic", "token_estimate": 394}
{"text": "Designing with Patterns: 267\n\u2022 Controllers handle user input. Each view has an associated controller\nthat responds to any choices made through the use of relevant forms of\ninput (keyboard, mouse, touchscreen,. . . ). Controller\n(interacts with user,\nperforms commands)\nModel\n(stores the data\nIncluding rules)\nView\n(displays the model\nfor the user)\nActions\nPresentation\nDomain\nInput presentation\nchoices\nUser actions\nQuery model\nstate\nNotify of change\nof model state\nManipulates the\nmodel, invoking \nmethods in its API\nto change state\nFIGURE 15.3: The model-view-controller pattern\nFigure 15.3 shows this schematically (note that there are many forms of\nvisual description for MVC). Note that both views and controllers send re-\nquests to the model, but that the model does not send out any requests, and\nit only provides responses through the view. Requests sent by a controller do\nnot create a direct response, instead they cause the model to be modi\ufb01ed,\nand the corresponding view to be noti\ufb01ed that the state of the model has\nbeen modi\ufb01ed. The application may also directly change the model (with no\nuser interaction) of course, and again, when this occurs the views are noti\ufb01ed. The view can then request details of the revised model (or part-model) and\ndisplay it to the user in response to their input (the mechanism for doing this\nis provided by the Observer design pattern described in the next section. The important characteristic of MVC is the decoupling of the internal\nmodel from the associated interactions with the user (separation of concerns). We can recognise this pattern as describing many familiar but di\ufb00erent, in-\nteractive applications. Word processors, spreadsheets, web browsers etc. all\n\ufb01t this model. Decoupling the \u2018knowledge store\u2019 from the way that it is pre-\nsented, as well as from the di\ufb00erent forms of interaction, makes it possible\nto implement the application so that it can be used on di\ufb00erent operating\nsystems or with a range of devices. Figure 15.4 shows a sketch of how MVC might be used with the CCC\napplication. This is really a rather \u2018behavioural\u2019 sketch, where the designer is\nthinking out how the MVC model will handle the situation where a customer\nmakes a booking. The booking results in a modi\ufb01cation to the record set for", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 284", "position": 284, "chunk_type": "semantic", "token_estimate": 374}
{"text": "268: Software Design: Creating Solutions for Ill-Structured Problems\nFIGURE 15.4: An MVC interpretation of the CCC application\nthe cars (the chosen car is no longer available to other customers), and it has\nsome consequent e\ufb00ects upon the di\ufb00erent views (such as the symbol for that\ncar on the city map changing colour). 15.2.2\nLayers\nThe Layers pattern addresses a context where di\ufb00erent elements of the soft-\nware need to be developed and to evolve separately, requiring that interaction\nbetween them should be kept to a minimum. This means that the resulting\nsoftware is likely to be portable and can readily be modi\ufb01ed to meet new\nneeds. Essentially, Layers represents a very strati\ufb01ed approach to addressing\nthe issue of \u2018separation of concerns\u2019. When using Layers, the solution adopted\nis to group those elements that provide a particular service into a \u2018layer\u2019, with\nthe layers being organised in a hierarchy, so that the layers providing higher\nlevels of abstraction depend on lower ones, but not vice-versa. While Layers may not be used as universally as MVC, it does provide the\nstructuring for some very important software applications, with networking\nand operating systems being key examples of where this pattern is particularly\nuseful. Figure 15.5 illustrates the use of Layers to implement the OSI model\nused in computer networking.", "domains": ["Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 285", "position": 285, "chunk_type": "semantic", "token_estimate": 216}
{"text": "270: Software Design: Creating Solutions for Ill-Structured Problems\n15.2.3\nBroker\nIn everyday life, the role of a broker is to act as a \u2018trusted intermediary\u2019\nwho can provide some form of expertise to help with choosing a service that we\nneed. The idea of \u2018insurance broker\u2019 and \u2018mortgage broker\u2019 remain relevant,\neven in an era of internet shopping (and many web sites claim to o\ufb00er the\nservices of a broker). We turn to a broker so that we can draw upon their\nexpert domain knowledge to determine which provider is likely to be best\nsuited to our needs. The same can occur in a software context, particularly in the context of\nservice-oriented architectures. In this context we have clients (which them-\nselves may be providing services to others) and servers and these need to be\nmatched so that clients obtain the most appropriate service for any request\n(Bennett, Layzell, Budgen, Brereton, Macaulay & Munro 2000). Broker\nServers\nClients\nFIGURE 15.6: A simple broker architecture\nWhen using a broker architecture for software, the client sends requests to\nthe broker, the broker seeks out and uses the most appropriate service, and\nthen returns the outcomes to the client. This involves a dynamic binding for\neach request (or set of requests), which is managed by the broker so that the\nclient may well not be aware of which server provided the necessary response. Figure 15.6 shows this schematically. The broker architecture is commonly\nassociated with platforms for distributed service provision such as .NET and\nEnterprise Java Beans (EJB). This is because the broker pattern is particularly", "domains": ["Architectural Patterns and Styles"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 287", "position": 287, "chunk_type": "semantic", "token_estimate": 263}
{"text": "Designing with Patterns: 271\nuseful in a dynamic environment, where the set of service providers (which\nmay include \u2018information services\u2019) and their availability may be subject to\nregular change, as may well occur with distributed systems. Use of a broker does add a run-time overhead in exchange for this de-\ncoupling, and incorporating security needs can add further to this (Turner,\nBrereton & Budgen 2006). The broker itself needs to be secure (and hence\ntrustworthy) and also any requests and responses must be transmitted se-\ncurely. Equally, a broker does provide a robust run-time environment since\nthe broker is able to make substitutions for a server that has failed, or that\nmay have become available. 15.3\nDesign patterns\nDesign patterns address smaller and more detailed pieces of an overall de-\nsign than architectural patterns and have been adopted particularly widely in\nthe object-oriented context. As we noted when looking at plan-driven ap-\nproaches to design, this form of \u2018design method\u2019 tends to become overly-\ncomplex when used with objects, and design patterns, rightly or wrongly,\nhave been seen as one way of overcoming the problem by reusing \u2018proven\u2019\nsolutions to speci\ufb01c aspects of an ISP. Objects o\ufb00er a useful form of design element that can form one of the\ncomponents of a pattern. As we noted in Chapter 10, an object:\n\u2022 possesses a state, which is encapsulated within the object and can be\ninspected and changed through its methods;\n\u2022 exhibits behaviour through its responses to external events;\n\u2022 possesses an identity, since more than one object may be created from\na class. Objects are also capable of using static and dynamic binding (valuable for\npatterns) and can be coupled to other objects using a number of di\ufb00erent\nmechanisms. One thing that we might note though, as already mentioned,\nis that design patterns tend to make use of aggregations of objects rather\nthan employing inheritance. Employing inheritance remains a design chal-\nlenge, much as it did for plan-driven design methods, and opportunities to\nemploy inheritance may still need to be identi\ufb01ed through techniques such as\nrefactoring. For our purposes, the important features of an object are that it provides\nan abstraction of some aspect of the design model, that it incorporates en-\ncapsulation of state information, and that it provides externally accessible\nmethods.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 288", "position": 288, "chunk_type": "semantic", "token_estimate": 384}
{"text": "272: Where an application evolves through time, one of the risks\nis that the changes to the objects mean that a pattern may decay, or that\nits presence might even impede unforeseen forms of change. There isn\u2019t much\nthat can be done about the latter (or they wouldn\u2019t be unforeseen), but the\nissue of decay is one that designers need to consider when making changes. Two useful concepts related to pattern decay are those of grime and rot,\nthat are used to describe the corruption of a pattern that can occur when\nchanges are made to the objects involved in the pattern (Izurieta & Bieman\n2007, Feitosa, Avgeriou, Ampatzoglou & Nakagawa 2017). Pattern grime is the\n\u201cdegradation of design pattern instance due to buildup of unrelated artifacts\nin pattern instances\u201d and in essence involves material being added to the\nclasses and objects of a pattern that are not directly related to the purpose\nof the pattern. Pattern rot, which is less common, is the \u201cdeterioration of the\nstructural or functional integrity\u201d of the elements making up a pattern. The\npresence of grime and rot may mean that a pattern cannot support changes\nto the application in the way that was originally envisaged when the decision\nwas made to adopt that pattern. Patterns can take a variety of forms, and the GoF classi\ufb01ed patterns along\ntwo \u2018axes\u2019, as illustrated in Figure 15.7, which were as follows. 1. The purpose of the pattern. Its purpose describes what a pattern is used\nfor, and is usually described as being one of the following three types.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 289", "position": 289, "chunk_type": "semantic", "token_estimate": 262}
{"text": "Designing with Patterns: 273\nCreational\nStructural\nBehavioural\nClass\nObject\nScope\nPurpose\nFIGURE 15.7: Pattern classi\ufb01cation scheme used by the \u2018Gang of Four\u2019\n\u2022 creational patterns are concerned with occasions where objects need\nto be created in order to achieve the purpose of the pattern;\n\u2022 structural patterns address the way in which the constituent classes\nor objects are composed;\n\u2022 behavioural patterns describe the ways that classes or objects inter-\nact, and how responsibilities for di\ufb00erent aspects of the pattern\u2019s\npurpose are allocated between them. 2. The scope of the pattern. This describes whether the pattern is primarily\none that addresses the use of classes or the use of objects (where we can\nregard a class as being a form of \u2018template\u2019 from which one or more\ninstantiating objects are realised). Most patterns deal with objects, and\nso we concentrate on looking at examples of these. In terms of the viewpoints model, creational and structural patterns are es-\nsentially ones for which the organisation of the pattern is associated with\nthe constructional viewpoint. And obviously, the organisation of behavioural\npatterns is associated with the behavioural viewpoint. While we use the framework shown in Figure 15.7 here, it is worth noting\nthat others have employed other ways of categorising patterns. Although in\nBuschmann et al. (1996) the main focus is on architectural patterns, there is\nalso some discussion of a number of design patterns. They categorise these\nusing a set of role-based headings (structural decomposition, organisation of\nwork, access control, management and communication). The remaining question to address, before looking at some examples of\npatterns, is how to describe a pattern. The books by Gamma et al. (1995)\nand Buschmann et al. (1996) use slightly di\ufb00erent templates for this. The\nfollowing template is something of a merging of these (and others) to try and", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 290", "position": 290, "chunk_type": "semantic", "token_estimate": 303}
{"text": "Designing with Patterns: 275\n15.3.1\nProxy (207)\nThe role of a proxy can be undertaken\nin various ways as part of everyday life,\nwhen someone acts \u2018on behalf of\u2019 another\nperson for some purpose. A common ex-\nample is in voting, where someone un-\nable to go and take part in a ballot will\nappoint another person to act as their\nproxy and cast their vote for them. This\npattern employs the same concept, and\ninvolves one object acting on behalf of another object. The GoF classify this pattern as being Object Structural whereas\nBuschmann et al. describe it as being Access Control. Using the template\noutlined above this is described as follows. Name. Proxy\nAlso known as. Surrogate\nProblem. Proxy addresses the problem where direct provision of access to\nan actual object requires to be moderated in some way. This may be\nbecause access represents a signi\ufb01cant overhead of some form (time,\nspace) or because di\ufb00erent types of client may require or be entitled to\ndi\ufb00erent levels of access. Solution. This is to provide a representative of the object and let the client\nobject communicate with this proxy rather than with the actual object. The proxy provides the same interface as the actual object and ensures\ncorrect access to it, while possibly performing additional tasks such as\nenforcing access protection rules. Example. The GoF provides the example of an object representing a com-\nplex image when used in a word processor. Rather than incurring the\noverhead of loading a (potentially) large graphical object it may be pos-\nsible to employ a much simpler proxy that ensures that key properties\n(such as position and boundaries) are correctly represented in the screen\nimage. With more widespread access to electronic data sources, a more\ncommon example today is probably the protection proxy form, in which\nthe proxy is used to control the level of access that users may be per-\nmitted to have to an object or to information. For example, in the case\nof access to Electronic Health Records (EHR), a doctor is likely to have\nfuller access than (say) a nurse, and an administrator might have quite\nlimited access that is restricted solely to demographic information. Applicability. Proxy can also be employed to control access to relatively\ncomplex objects, which may be in a di\ufb00erent space (remote proxy);\nwith minimising overheads, as in the case of the word processor and", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 292", "position": 292, "chunk_type": "semantic", "token_estimate": 400}
{"text": "276: Software Design: Creating Solutions for Ill-Structured Problems\nimage (virtual proxy); and controlling di\ufb00erent access rights (protection\nproxy). Structure. Figure 15.8 illustrates the idea of proxy using a class diagram. Normally, requests from the client will be serviced by the methods of\nthe proxy, relaying these on to the original object only when necessary. Figure 15.9 uses a sequence diagram to illustrate the operation of virtual\nproxy (or alternatively this could be viewed as an example of protection\nproxy, with the \ufb01rst request being refused for lack of access permission). Client\nProxy object\nservice_1()\nservice_2()\nReal object\nservice_1()\nservice_2()\nFIGURE 15.8: Class diagram for the proxy design pattern\nImplementation. Since this is not relevant to the theme of the book, we\nomit this element. Known uses. Both the GoF and Buschmann et al. provide examples, with\nthe latter being more extensive and varied and also relating more\nstrongly to internet-based forms of implementation, where this pattern\nis quite widely employed. Related patterns. The Adapter (139) and Decorator (175) patterns are also\nconcerned with issues related to interfaces. Consequences. Obviously, the use of proxy creates an overhead by adding a\nlevel of indirection when accessing potentially quite important objects. As an initial example of a design pattern, proxy illustrates a number of\nthe points made above about patterns in general. It is compositional in form,\naddressing what is very much a sub-problem for any design, relatively simple\nin its structure, and provides quite loose coupling that may help with future\nchanges. It is also a pattern where ideas from \u2018conventional\u2019 coding and the in-\nternet in its various forms coincide, showing how the concept behind a pattern\ncan apply across quite a wide range of roles and forms.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 293", "position": 293, "chunk_type": "semantic", "token_estimate": 287}
{"text": "Designing with Patterns: 277\nClient\nReal\nobject\nProxy\nobject\nClient requests service_1\nProxy responds directly\nto the request\nClient requests service_2\nservice_1()\nservice_2()\nservice_2()\nProxy relays request to\nreal object to service\nthis request\nFIGURE 15.9: Sequence diagram for the proxy design pattern\nThe proxy pattern in the CCC\nAn obvious role for the proxy pattern within the CCC is to provide a\nprotection proxy role for access to car objects. There are a number of\nroles in the overall CCC organisation that need access to car objects,\nbut for di\ufb00erent purposes. Customers need access for bookings, the\nmaintenance team need access to monitor the state of a car and to be\nable to withdraw it from use if necessary, the billing system may need\nfurther access to details of journeys and so on. While it would be possible to build this into the car object itself, it\nwould then mean that the car object would require knowledge about\nsuch roles, which in themselves, have no direct relevance to its function. So, following the principle of separation of concerns, it is better to use\na proxy as the means of embodying the knowledge about who may\naccess what. It also aids future evolution of the application, which\nmight create new roles, or roles that are specialisations of existing\nroles. Such developments would then only a\ufb00ect the proxy object.", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 294", "position": 294, "chunk_type": "semantic", "token_estimate": 228}
{"text": "278: Software Design: Creating Solutions for Ill-Structured Problems\n15.3.2\nObserver (293)\nObserver is a well-known and widely-used pat-\ntern and is categorised as being object behavioural\nby the GoF. It embodies the concept of a publish-\nsubscribe relationship between the design elements. The pattern as described by the GoF is fairly ba-\nsic, omitting various \u2018housekeeping\u2019 issues, and the\ndescription provided here likewise concentrates on\nthe core model, while indicating where additional\naspects need to be considered for implementation. Name. Observer\nAlso known as. Dependents, Publish-Subscribe\nProblem. A common side-e\ufb00ect of organising a software system as a set of\nco-operating objects is the need to maintain consistency between re-\nlated objects, while avoiding overly-tight coupling that may constrain\nperformance as well as reduce the scope for reuse. Solution. This involves creating a \u2018publish-subscribe\u2019 relationship between\nthe subject and the observers. Whenever the subject undergoes a change\nof state it noti\ufb01es the observers that this has occurred, and they can\nthen query the subject in order to synchronise with it and obtain any\nupdated values. Example. A simple example is that of a spreadsheet. When the data in a\ncell or group of cells is changed, any graphs, pie-charts or the like that\nare using that data will also need to be redrawn. Here the spreadsheet\ncell is the subject, and the objects that are responsible for drawing the\ncharts and graphs are the observers. Applicability. This form of relationship occurs widely wherever objects are\nworking together to perform some task, and where an object needs to\nbe able to notify other objects about changes without any knowledge\nabout those objects. Structure. Figure 15.10 illustrates the idea of observer using a class diagram. An interface is used to implement the subject-observer relationship and\nthis is then implemented by the concrete subject and observers. Ob-\nservers register with the subject to receive calls to update() from the\nsubject. On receiving an update() message it is then the task of the ob-\nserver to use some form of getState() to check if the change a\ufb00ects it\n(since observers may be interested in di\ufb00erent aspects of the state, they\nmay use di\ufb00erent versions of getState()). Figure 15.11 uses a sequence\ndiagram to illustrate the operation of observer. Implementation. Again, this element is omitted here.", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 295", "position": 295, "chunk_type": "semantic", "token_estimate": 380}
{"text": "Designing with Patterns: 279\n<<interface>>\nSubject\n<<interface>>\nObserver\nregisterObserver()\nremoveObserver()\nnotifyObservers()\nupdate()\nConcreteSubject\nConcreteObserver\nregisterObserver(){...}\nremoveObserver(){...}\nnotifyObservers(){...}\nsetState()\ngetState_1()\n\u2026\ngetState_n()\nUpdate(){...}\n/* other observer\nmethods unrelated\nto this pattern */\nchange\nnotification\nchange\nnotification\nresponse\nto change\nresponse\nto change\nFIGURE 15.10: Class diagram for the observer design pattern\nKnown uses. Observer is a very widely used pattern. The example above of\nthe spreadsheet is just one of many. Another well-known one is within\nthe MVC architectural pattern, where the model acts as a subject, and\nthe views act as observers, being noti\ufb01ed when changes are made to the\nmodel. Related patterns. Publish-Subscribe, Mediator. Consequences. While Observer provides loose coupling that makes it possi-\nble to vary subjects and observers independently, and to add observers\nwithout needing to modify the subject or other observers, there are some\n\u2018housekeeping\u2019 issues that need to be considered. These include:\n\u2022 a subject does need to keep track of the observers;\n\u2022 if an observer is observing more than one subject then it is necessary\nto extend the update() method so that the observer is able to know\nwhich subject has provided the noti\ufb01cation;\n\u2022 if a subject is deleted then it is necessary to notify all of its observers\nto avoid dangling references. The model shown in Figure 15.10 describes the very basic operation (largely\nignoring the housekeeping issues above). Even so, this is a relatively simple\nas well as e\ufb00ective pattern (it was the pattern that was most highly valued in\nthe survey by Zhang & Budgen (2013)).", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 296", "position": 296, "chunk_type": "semantic", "token_estimate": 257}
{"text": "280: Software Design: Creating Solutions for Ill-Structured Problems\nConcreteSubject\nConcreteObserver_2\nConcreteObserver_1\nsetState()\nupdate()\nnotifyObservers()\ngetState_1()\ngetState_2()\nupdate()\nFIGURE 15.11: Sequence diagram for the observer design pattern\nThe Observer pattern in the CCC\nOne of the most obvious roles for the Observer pattern is to help mon-\nitor the status and use of car objects. When a car object changes its\nstatus (such as becoming available), then it can \u2018publish\u2019 that change of\nstate, and any subscribers can take note. Di\ufb00erent subscribers likely to\nbe interested in car states will include club members seeking a nearby\ncar, the maintenance team, and the billing system. When seeking a car, a club member may become an observer for sev-\neral cars. But once the member has selected one, then the appropriate\nbooking object needs to remove itself from the list of subscribers to\nany other cars in order to avoid \u2018dangling references\u2019.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 297", "position": 297, "chunk_type": "semantic", "token_estimate": 149}
{"text": "Designing with Patterns: 281\n15.3.3\nAbstract Factory(87)\nThe Abstract Factory provides an exam-\nple of an object creational pattern that ad-\ndresses a problem that probably is a bit more\nlimited in scope than those of the previous\ntwo examples, although the problem itself\nis an important one. The aim of this pat-\ntern is to make a \u2018client\u2019 class independent\nof the speci\ufb01c set of objects that may need to\nbe created for it to perform its task (decou-\npling it from them), where there is a choice\nof classes that can be instantiated. The decision about which class to instan-\ntiate is deferred to runtime, when a speci\ufb01c concrete factory class is used to\ncreate the objects. Name. Abstract Factory\nAlso known as. Kit\nProblem. This pattern addresses the need to achieve portability of an appli-\ncation across environments. A common role is to enable an application\n(the \u2018client\u2019) to be used on a range of platforms that provide di\ufb00erent\nforms of \u2018look and feel\u2019 user interaction. Solution. The abstract factory de\ufb01nes an interface for creating each basic\nform of widget used in interaction (such as scroll bars, radio buttons\netc.). Clients perform operations to obtain a new instance of a widget,\nbut are not aware which concrete class is being used. Example. The widgets will usually form a user interaction toolkit that sup-\nports multiple standards for such widgets as scroll bars, buttons etc. Applicability. The roles for this pattern address situations where either:\n\u2022 a system needs to be independent of the way in which its products\nare created, composed and represented; or\n\u2022 a system may be con\ufb01gured locally, using just one form from a\nfamily of products. Structure. Figure 15.12 illustrates the idea of abstract factory using a class\ndiagram. The client uses the abstract factory when it is compiled and\nthen at run-time it is linked to an actual (concrete) factory. So if Con-\ncreteFactory1 is selected, that class will provide ProductA and ProductB\nfor use by the client. (Of course, the interfaces that these must conform\nto are speci\ufb01ed by the abstract factory.) Implementation. Again, we omit this element.", "domains": ["Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 298", "position": 298, "chunk_type": "semantic", "token_estimate": 357}
{"text": "282: Software Design: Creating Solutions for Ill-Structured Problems\nAbstractFactory\nCreateProductA()\nCreateProductB()\nClient\nConcreteFactory1\nAbstractProductA\nCreateProductA()\nCreateProductB()\nRequest creation of ProductA\nRequest creation of ProductA\nCreates a concrete product\nwith specific characteristics\nCreates a concrete product\nwith specific characteristics\nConcreteFactory2\nCreateProductA()\nCreateProductB()\nProductA2\nProductA1\nInteraction with ProductA\nInteraction with ProductA\nFIGURE 15.12: Class diagram for the abstract factory design pattern\nKnown uses. Abstract factory isolates clients from the responsibility and\nprocess of creating product objects, the client manipulates the instances\nthrough their abstract interfaces and hence remains unaware of the par-\nticular implementation. Related patterns. Prototype\nConsequences. While the abstract factory can be easily extended to in-\nclude new members of a product family (for example, a new form of\nuser interface), adding new products to the set provided by the factory\nis not easy, because the pattern de\ufb01nes a \ufb01xed set of products. So adding\n(say) a variant form of radio buttons would require modifying the ab-\nstract factory and recreating all of the concrete factories. In that sense,\nusing abstract factory does create a form of technical debt through the\nconstraints this creates. Abstract factory meets a quite speci\ufb01c need and is generally considered to do\nit well. However, apart from the example of di\ufb00erent user interfaces it is not\nas likely to be so widely used as the previous two examples.", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 299", "position": 299, "chunk_type": "semantic", "token_estimate": 223}
{"text": "Designing with Patterns: 283\n15.4\nOther uses of patterns\nThis section addresses two rather di\ufb00erent pattern-related issues. The \ufb01rst\nis to brie\ufb02y examine an example of how design patterns can be used with\nanother architectural style (SOA), while the second involves looking at how\npatterns can be employed to describe experiences of what doesn\u2019t work. 15.4.1\nSoftware service patterns\nSoftware service concepts were described in Chapter 11. While compo-\nnents (which can be considered as the precursors of services) do not seem to\nhave attracted much interest from the patterns community, software services\nhave presented a topic of greater interest, and indeed, patterns may well be a\nparticularly e\ufb00ective way of adapting the service concept to user needs. At the architectural pattern level, Bass et al. (2013) consider that the\nservice-oriented architectural pattern describes the use by service consumers\nof distributed services o\ufb00ered by service providers. Essentially this pattern\ndescribes the use of services in the form described in Chapter 11. It identi\ufb01es\nthe need for a service to publish details of what is provided, and also to ad-\ndress quality issues through the use of service-level agreements (SLAs), which\nre\ufb02ects the strong business element often associated with the use of the service\nmodel. Application\nService 1\nprovider\nService 2\nprovider\nService 3\nprovider\nService 4\nprovider\nService\ninterface\nSOAP call\nFIGURE 15.13: A very simple SOA pattern", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 300", "position": 300, "chunk_type": "semantic", "token_estimate": 228}
{"text": "Designing with Patterns: 285\nbeing a structural weakness that indicates a deeper \ufb02aw, and that needs to\nbe removed from the source code through the use of refactoring in order to\nimprove the maintainability of the software. (While the term does provide an\nunquestionably evocative description of the sort of issue involved, it is prob-\nably better not used when explaining refactoring plans to project managers,\ncustomers etc.) As the term indicates, code smells are likely to be recognised during im-\nplementation, although some may well be detectable in advance of that. Here\nwe brie\ufb02y look at some examples. God Class. A God Class \u201crefers to those classes that tend to centralise the\nintelligence of the system. An instance of a god class performs most of\nthe work, delegating only minor details to a set of trivial classes and\nusing the data from other classes\u201d (Lanza & Marinescu 2006). A God\nClass may well make frequent access to the data of foreign classes and its\nrole violates the object-oriented design principle that each class should\nonly have one responsibility. God Classes also tend to be very large,\na\ufb00ecting ease of comprehension. Because of its role, it is anticipated\nthat such a class will be changed frequently during maintenance, and\nhence more likely to include errors. However, the study by Olbrich, Cruzes & Sj\u00f8berg (2010), looking at the\nevolution of three OSS applications does demonstrate that it may well\nbe that the use of a God Class is a quite reasonable way to organise\nsome forms of application, provided that its size is not extreme. This\nemphasises the point made above that the identi\ufb01cation of relevant code\nsmells may well be subjective and contextual. Data Class. Such a class has data \ufb01elds, together with methods for changing\nand inspecting these, but plays no role in the operational purposes of the\napplication. Its lack of a behavioural role weakens the object-oriented\nstructures and at the worst it may simply be a mechanism for including\nglobal data. As observed in (Fowler 1999) this may be an acceptable\nform for a class to have during initial development, but at some point\nit should take on the role of a \u2018grownup\u2019. Code Duplication. Duplication of code can arise in more or less any ar-\nchitectural style (for example, it can easily arise in the lower levels\nof a call-and-return structure).", "domains": ["Design Patterns", "Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 302", "position": 302, "chunk_type": "semantic", "token_estimate": 395}
{"text": "286: Software Design: Creating Solutions for Ill-Structured Problems\nWhere code smells do have a useful role is when identifying the need for\npossible refactoring. As discussed in Section 14.7, refactoring involves reor-\nganisation of the code from a constructional perspective, while retaining its\nfunction and behaviour, in order to help with the future evolution of an ap-\nplication. Code smells can help with prioritising the need for such change in\nthe design. They may also provide a motivation for refactoring that is related\nto the design model itself, although they still have a strong link to the actual\ncode structures. 15.5\nDesigning with patterns\nHaving reviewed various examples of the pattern concept, the next obvious\nquestion to ask is \u201chow do we use design patterns to solve design problems?\u201d. In this section we discuss some issues related to pattern use. Many of the books that describe design patterns, such as those by Gamma\net al. (1995) and Buschmann et al. (1996) are very much structured as cata-\nlogues of patterns. And later texts such as Bates et al. (2009) focus largely on\nthe issues of how to implement patterns. Important as both of these are, par-\nticularly for documenting patterns, they still leave our initial question unan-\nswered. Unfortunately, rather as a gardening catalogue, full of glorious colour\npictures of healthy, thriving plants, provides little real aid with the task of\nplanning a new garden\u2014although it may tell us which plants like shade and\nhow tall they will grow\u2014so it is apt to be with design patterns. Possession of\na catalogue provides a source of ideas; it provides information that can help\nwith planning and anticipating possible consequences, but the task of working\nout how to use its contents is still a creative activity. (Actually, the analogy with planning a garden is quite a good one, at\nleast, if you like gardens, since gardens do evolve and exhibit behaviour, even\nif over much longer periods of time than we expect with software. Trees grow\nand shade di\ufb00erent parts of the garden, some plants take time to become\nestablished but then take over adjacent sections unless controlled. So, like the\nsoftware designer, the gardener\u2019s planning requires an ability to envisage some\nfuture state, while having inadequate control over both the conditions and the\nquality of materials that they need to use to achieve that state.)", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 303", "position": 303, "chunk_type": "semantic", "token_estimate": 394}
{"text": "286: Trees grow\nand shade di\ufb00erent parts of the garden, some plants take time to become\nestablished but then take over adjacent sections unless controlled. So, like the\nsoftware designer, the gardener\u2019s planning requires an ability to envisage some\nfuture state, while having inadequate control over both the conditions and the\nquality of materials that they need to use to achieve that state.) How then do we use catalogues of design patterns, whether in books or\non-line? Well, the GoF advice is very much along the lines that patterns need\nto be learned, and that by studying patterns the designer will acquire both\ninsight into how and why the pattern works as well as enough familiarity\nwith it to be able to recognise those situations where it can be used to e\ufb00ect. Designers are also advised to follow the following two principles. \u2022 Program to an interface, not an implementation. What this means is\nthat a client object should not be aware of the identity of the actual", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 303", "position": 303, "chunk_type": "semantic", "token_estimate": 168}
{"text": "Designing with Patterns: 287\nobject that is used to service a particular request, so long as its form\nand behaviour conform to the interface speci\ufb01cation. \u2022 Favour object composition over class inheritance. This is not to deny the\nvalue of inheritance as a mechanism for reuse, but rather that it should\nnot be over-used. This implies that the minimum conditions for the successful use of patterns\nrequire that a designer should:\n\u2022 acquire a \u2018vocabulary\u2019 of design patterns;\n\u2022 be able to recognise where a particular pattern could provide a useful\nsolution;\n\u2022 have an understanding of how to realise the pattern within that context. Given that there are now hundreds of documented patterns (the book by\nGamma et al. (1995) documented only 23 of them), these are quite challenging\nrequirements, especially given that the question of which patterns are the ones\nthat are most valuable to learn (\ufb01rst) is not easily answered. The strategy advocated by Buschmann et al. (1996) is rather di\ufb00erent,\nalthough the basic conditions for when it is appropriate to employ a pattern\nare the same. They advise classifying a given problem in the same way that\nthe patterns themselves are classi\ufb01ed, as a step towards being able to identify\npotentially useful patterns. Their basic process is as follows. 1. Specify the problem, and if possible, any sub-problems involved. 2. Determine the category of pattern that is appropriate to the design\nactivity being performed (that is, architectural or design patterns). 3. Determine the problem category appropriate to the problem. 4. Compare the problem description with the available set of patterns in\nthe catalogue that \ufb01t that problem description. 5. Consider the bene\ufb01ts and liabilities (assess the design trade-o\ufb00s and\npossible technical debt that will be incurred by using the pattern). Of\ncourse, this may also need to include the possibility that there is no\nexisting tried and tested pattern for the given problem. 6. Select the pattern variant that best \ufb01ts the problem and o\ufb00ers most\nbene\ufb01ts. Since their strategy includes architectural styles as well as design patterns and\nidioms, the above process can be considered as fairly comprehensive, and in\nprinciple at least, avoids the need to learn a growing catalogue of patterns. We\nmight also note that it has a distinctively top-down decompositional aspect,", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 304", "position": 304, "chunk_type": "semantic", "token_estimate": 380}
{"text": "Designing with Patterns: 289\n(mainly small-scale experiments) and a number of \u2018experience papers\u2019, with\nthat by Wendor\ufb00(2001) being particularly insightful. All of the patterns stud-\nied were either directly taken from the GoF or were close derivatives. They\nconcluded that: \u201cwe could not identify \ufb01rm support for any of the claims made\nfor patterns in general, although there was some support for the usefulness\nof patterns in providing a framework for maintenance, and some qualitative\nindication that they do not help novices learn about design\u201d. However, the\nstrength of evidence for the overall \ufb01ndings from the study was limited by\nthe small number of primary studies and the way that these used a spread\nof di\ufb00erent patterns, with\nComposite, Observer and Visitor being the only\npatterns that had been addressed by more than two or three primary studies. This study was followed up with two surveys. The \ufb01rst was a quantitative\nsurvey of the usefulness of the 23 GoF patterns, using the authors of pattern\npapers as the sampling frame (Zhang & Budgen 2013), and then was aug-\nmented by a more qualitative survey (using the same sampling frame), seeking\nexplanations for some of the results (Zhang, Budgen & Drummond 2012). As\nwith almost any survey undertaken in software engineering, it is extremely\ndi\ufb03cult to determine to what degree the sampling frame used could be con-\nsidered as being representative of pattern users as a whole. From the \ufb01rst survey, the most highly rated patterns were Observer, Com-\nposite and Abstract Factory, and there was also a substantial group that were\nnot considered to be useful (most notably, Memento). There was also con-\nsiderable ambivalence about Singleton, which was investigated further in the\nsecond survey. The Singleton pattern is a creational pattern that \u201censures a\nclass only has one instance\u201d, with a single global access point. (A good exam-\nple of a situation where the use of this might be appropriate is for a spooler\nclass responsible for managing output to a printer.) The qualitative survey\nrevealed that a signi\ufb01cant number of users were concerned that Singleton was\neasily mis-used to provide global variables, and that its use also increased\ncoupling. So, while it could be useful for limited roles, the potential disadvan-\ntages in terms of introducing undesirable features into a design model were\nsuch that they felt it better to avoid its use1.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 306", "position": 306, "chunk_type": "semantic", "token_estimate": 395}
{"text": "Designing with Patterns: The qualitative survey\nrevealed that a signi\ufb01cant number of users were concerned that Singleton was\neasily mis-used to provide global variables, and that its use also increased\ncoupling. So, while it could be useful for limited roles, the potential disadvan-\ntages in terms of introducing undesirable features into a design model were\nsuch that they felt it better to avoid its use1. While there have been quite comprehensive studies of research trends re-\nlated to the use of design patterns, such as Mayvan, Rasoolzadegan & Yazdi\n(2017), (which found that pattern development, pattern mining, and pattern\nusage were the most active research topics in the \ufb01eld of design patterns),\nthere appear to have been relatively few studies related to any form of eval-\nuation of the patterns themselves. Given how much patterns are valued by\nquite a wide community (and lack of research does not imply lack of value),\nthis lack of critical analysis is disappointing. This situation is even more marked for the use of software service patterns. Although there is no lack of tutorial material, there seem to have been few\nstudies that assessed the usefulness of this class of patterns. 1For these reasons, this has not been used as one of our examples of patterns.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 306", "position": 306, "chunk_type": "semantic", "token_estimate": 211}
{"text": "290: Software Design: Creating Solutions for Ill-Structured Problems\nIf we turn brie\ufb02y to the anti-pattern context, then we \ufb01nd that, despite\nthe issues of context and di\ufb03culty of de\ufb01nition, there have been many studies\non the use of code smells. An example of such a study is that by Palomba,\nBavota, Penta, Fasano, Oliveto & Lucia (2018), and it is worth noting that\nthis, like many others in this area, largely draws upon data from open source\nprojects. However, these studies do not appear to o\ufb00er any very conclusive\nviews on the usefulness of code smells, and rarely provide any systematic\nform of evaluation. Some of the cause of this may be the in\ufb02uence of context\nas a confounding factor, as noted by Olbrich et al. (2010). Key take-home points about designing with patterns\nDesign patterns provide a useful and valued means of codifying and ex-\nchanging information about design structures (large and small) that have been\nfound to be e\ufb00ective by software designers. A pattern describes both a \u2018design problem\u2019 and a generic solution to that\nproblem that can be reused over and over again in many di\ufb00erent ways. Labelling of patterns aids with knowledge transfer and reuse. Patterns are more concerned with coupling through composition than with\ninheritance. They generally aim to provide loose coupling between design\nelements so as to aid the \u2018evolution\u2019 of a design model. Architectural patterns describe ways of structuring applications to \ufb01t par-\nticular characteristics of their role. Design patterns provide \u2018part-solutions\u2019 for elements of a design model,\nsimplifying the process of \u2018solving\u2019 an ISP by providing a way of organ-\nising speci\ufb01c aspects of the design model. Patterns are used for di\ufb00erent aspects of the design model. Creational and\nstructural patterns are organised around the constructional viewpoint,\nwhile behavioural patterns structure the design within the behavioural\nviewpoint. Patterns can be used with any architectural style (in principle) but have\nlargely evolved for the object-oriented architectural style where there is\na large community of pattern enthusiasts. The design process when making use of design patterns is an informal one\nwith only quite limited guidance about the recognition and use of pat-\nterns being available to help the designer.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 307", "position": 307, "chunk_type": "semantic", "token_estimate": 365}
{"text": "Designing with Patterns: 291\nEmpirical knowledge about the usefulness of design patterns and architec-\ntural patterns is limited. However, it is clear that some patterns (most\nnotably Observer, Composite and Abstract Factory) are valued by ex-\nperienced designers. There is some evidence that the use of patterns is\nunlikely to provide help for less experienced designers.", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 308", "position": 308, "chunk_type": "semantic", "token_estimate": 56}
{"text": "Chapter 16: Designing with Components and\nServices\n16.1\nModular design ...................................................\n293\n16.2\nDesigning with components ......................................\n294\n16.3\nDesigning with software services .................................\n298\n16.4\nEmpirical knowledge about modular design .....................\n302\nKey take-home points about designing with components and\nservices ...........................................................\n302\nIn Chapter 11 we looked at component technology and the concept of the\nsoftware service. Our concern there was to describe their forms and to consider\nthe properties of components and services that were of importance from the\nperspective of how they might be modelled. This chapter looks at how components and services can be composed to\ncreate applications, and some factors that we might need to consider when\ndesigning with such elements. 16.1\nModular design\nChapter 11 addressed the question of how to design components, both in\nthe form of \u2018local\u2019 software components, and also software services (which of\ncourse, can be viewed as being a form of \u2018remote\u2019 component). In this chapter\nwe brie\ufb02y discuss the question of producing designs for building applications\nthat make use of both components and services. The two forms have much in common as well as some di\ufb00erences when it\ncomes to producing a design. They particularly share a \u2018plug-and-play\u2019 phi-\nlosophy, arising from the widespread use of dynamic binding when composing\nan application from existing elements, hence the reference above to the idea\nof \u2018modular\u2019 design. And despite the importance of reuse in software devel-\nopment as a whole, in neither case are there any well-established practices to\nassist with formulating an overall design model around the concept of reuse. Indeed, up to this point, the ideas about creating software applications pre-\nsented in Part III have essentially assumed a \u2018bespoke\u2019 development process,\n293", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 310", "position": 310, "chunk_type": "semantic", "token_estimate": 286}
{"text": "294: Software Design: Creating Solutions for Ill-Structured Problems\nwith the elements making up each application (or product line) largely being\ndi\ufb00erent and unique. So, while the development of ideas about component-\nbased software engineering (CBSE) could build upon experiences with using\nobjects, those experiences provided little opportunity for accumulating and\nformalising declarative and procedural knowledge about modular design. However, when creating applications from existing components and ser-\nvices, some aspects of incremental design may well be adapted for this pur-\npose, because both forms provide scope for the use of prototyping, particularly\nexploratory and evolutionary prototyping. Exploratory prototyping allows the\ndesigner to investigate the use of di\ufb00erent component combinations while de-\nveloping an application, while evolutionary prototyping may provide an over-\narching development context in which the application emerges from a series\nof intermediate forms. The use of prototyping rather than the development of more structured\ndesign models may however create limited opportunity for providing knowl-\nedge transfer that has been derived from experience of composing components. This is because, although components and services are implicitly well-suited\nto the use of a compositional strategy, the major in\ufb02uence upon design deci-\nsions is likely to be the identi\ufb01cation of what modules are available from the\ncomponent catalogue rather than design strategy. 16.2\nDesigning with components\nAs noted above, there is very little guidance available about how to de-\nvelop a design by using components. This is true even for a well-established\narchitectural form such as JavaBeans, the component architecture used with\nthe Java platform. The component composition process itself is further com-\nplicated by the way that components can be used to perform what we might\nterm horizontal roles within a system (whereby the overall functionality of the\napplication is distributed between them), and also vertical roles in which they\nprovide \u2018layers\u2019 of services through component frameworks such as CORBA\nand .NET. The latter role essentially corresponds to the use of a Layers ar-\nchitectural pattern. This is illustrated in Figure 16.1. Our concern here is primarily about how the design choices related to \u2018hori-\nzontal\u2019 structuring are to be made, on the basis that these provide the detailed\ndesign, whereas the \u2018vertical\u2019 structuring provides an architectural design. But\nof course, as always, the two cannot be regarded as entirely separate.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 311", "position": 311, "chunk_type": "semantic", "token_estimate": 380}
{"text": "Designing with Components and Services: 295\nHorizontal integration to\nprovide system functionality\nfrom a set of components\n(at each level). Vertical integration to provide a\nlayered set of services (lower\nlevels may be monolithic,\nrather than component-based). FIGURE 16.1: Horizontal and vertical integration of components\n\u2022 Identify the general needs of the application problem, and search for a\nset of components that collectively match that functionality, and seek\nto construct the design (and implicitly, the application) by aggregating\nthese in some way. (This can be termed as an element \ufb01rst strategy.) \u2022 Decompose the application problem into well-de\ufb01ned sub-problems that\naddress speci\ufb01c tasks and then seek a set of components that will \ufb01t\nthe needs of the individual sub-problems. (This can be termed as a\nframework \ufb01rst strategy.) Some small empirical studies that investigated the extent to which either strat-\negy was adopted, and with what level of success, are described in (Pohthong\n& Budgen 2000) and (Pohthong & Budgen 2001). These used a rather con-\nstrained component context (Unix processes), and as might have been ex-\npected, for much of the time the participants worked opportunistically, ad-\njusting the choice of strategy as the solution evolved. However, for less expe-\nrienced designers, the use of an element \ufb01rst strategy did appear to be more\nlikely to result in a working solution. It was thought that this might be partly\nbecause identifying the available components might provide better assistance\nwith creating a conceptual model of how the overall application might work. Reusing existing components with an opportunistic strategy makes it pos-\nsible to make good use of exploratory prototyping. When the option to develop\ncomponents rather than simply reuse existing ones is added to this (what we\nmight term a \u2018buy or build\u2019 strategy) then the design decisions become even", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 312", "position": 312, "chunk_type": "semantic", "token_estimate": 300}
{"text": "296: Software Design: Creating Solutions for Ill-Structured Problems\nIntegrated system\nIntegrated system\nIntegrated system\nIntegrated system\na) Overlapping functionality\nSystem functionality\nb) Missing functionality\nc) Redundant functionality\nd) Architectural mismatch\nFIGURE 16.2: Illustrations of some of the problems that might arise in com-\nponent integration\nmore complex. As indicated in Chapter 11, it is necessary to factor in the\nknowledge that the cost of developing components for reuse is around four\ntimes greater than direct development. Given these issues, we can conclude\nthat simple strategies are unlikely to work for many applications, and that\nthe complexity of component-based design can only really be addressed by an\nopportunistic strategy. In composing a system from a set of components, particularly when work-\ning opportunistically, a designer needs to be able to model and predict their\naggregate behaviour and functionality. In doing this, the designer also needs\nto identify the potential for the occurrence of any of the issues shown schemat-\nically in Figure 16.2. These problems can be classi\ufb01ed as follows. a) Overlapping functionality. This occurs where two or more components\nare able to perform a particular application function. The designer\u2019s task\nis to determine which one should perform the task, and how to ensure\nthat only that component performs it. From a design point of view it is\nde\ufb01nitely undesirable to have the same function performed by di\ufb00erent\nelements (possibly with di\ufb00erent limits or ranges), and this also creates\na problem for system maintenance and evolution. b) Missing functionality. The problem arises when the total set of func-\ntions provided by the components chosen to make up the application is", "domains": ["Design Patterns", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 313", "position": 313, "chunk_type": "semantic", "token_estimate": 269}
{"text": "Designing with Components and Services: 297\nless than what is needed. The solution is fairly simple, either \ufb01nd an-\nother component or (possibly) create one. So this should be a short-term\nissue with no longer-term technical debt associated with it. c) Redundant functionality. Components may well provide services over\nand above those that form the basis for choosing those particular compo-\nnents. This is particularly so for large components. The designer needs to\nchoose between incorporating the added functionality in some way (with\npossible undesirable consequences) or, preferably, \ufb01nding some way to\nexclude the unwanted functions. d) Architectural mismatch. This issue was discussed in Chapter 11, and\narises when there are mismatches between the expectations that each\ncomponent makes about its context. The study by Yakimovich, Bieman\n& Basili (1999) provides examples of how architectural mismatch can\narise from inconsistencies in:\n\u2022 component packaging\u2014where components may be constructed as\nlinkable elements that need to be integrated into an executable\nimage, or as independent elements, that may be scheduled inde-\npendently;\n\u2022 type of control\u2014concerning the way that control is organised and\ntransferred between components, and whether this is managed cen-\ntrally within an application or concurrently (such as through an\nevent-driven mechanism);\n\u2022 type of information \ufb02ow\u2014whether organised as control \ufb02ow\nthrough method calls, data \ufb02ow through shared memory, or in a\nmixed format;\n\u2022 synchronisation between components\u2014referring to whether a com-\nponent can \u2018block\u2019 the execution of other components (syn-\nchronous), or can continue to run regardless (asynchronous);\n\u2022 binding time\u2014referring to when the components are attached to\nconnectors, which may occur at compilation, link-editing, run-time\netc. What should be clear from this is that while component-based development\no\ufb00ers potential to bring together components from a variety of sources and\nin a range of forms, it is probably wisest to employ only components that\nconform to a single architectural style. This doesn\u2019t prevent the \ufb01rst three\nproblems arising, but these are likely to be much more tractable than coping\nwith architectural mismatch. The systematic mapping study by Vale et al. (2016) identi\ufb01ed some im-\nportant gaps in CBSE knowledge, while recognising that some of these were\ncompounded by the diversity of CBSE forms and application areas. Gaps of\nparticular relevance to design included a lack of experience reports about use", "domains": ["Architectural Patterns and Styles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 314", "position": 314, "chunk_type": "semantic", "token_estimate": 381}
{"text": "298: Software Design: Creating Solutions for Ill-Structured Problems\nof CBSE in practice, a lack of clear concepts about CBSE in practice, and\na lack of CBSE tool support. CBSE tools do exist but appear to be largely\nconcerned with implementation rather with activities such as modelling. To complete our discussion of designing with components we look at how\ncomponents might be used to compose the software needed to support the\nbusiness of the CCC. Modular implementation for the CCC\nMost of the operations of the CCC are those that will be common to\nmany businesses that provide resources on a temporary basis, whether\nit be car rental, hire of sca\ufb00olding, use of hotel meeting rooms etc. A CBSE implementation might therefore expect to \ufb01nd modules that\ncan handle its needs as regards accounting for use, keeping records of\ncars and customers. (Of course, as we have already observed, it will be\nbetter if these all conform to the same component architecture.) Building the user interface app, to be used on mobile phones, can again\nuse fairly low-level components such as buttons, boxes etc., and one\nbene\ufb01t of using a suitable component platform is that these should be\nportable across di\ufb00erent platforms. What is less likely to be \u2018o\ufb00the shelf\u2019 is the rather important element\nof reservation. Locating nearby cars and calculating their distance from\nthe customer and then ranking these in some way may be rather less\nreadily available, although some of the elements needed for GPS loca-\ntion may well be so. Whether to adopt this strategy also depends upon issues such as trust\n(of components built by others), con\ufb01dence in their continued avail-\nability (and evolution). As with all issues associated with ISPs there\nis no one answer of course. 16.3\nDesigning with software services\nWith any new implementation technology paradigm, there is an inevitable\nlag between it becoming available and the accumulation of relevant knowl-\nedge schema about how to design applications using it. And for more complex\nforms, such as objects, components and services, there is also a need to es-\ntablish a consistent context for their use, usually in the form of some sort of\nframework. The basic service model, often described as Software as a Service separates\npossession and ownership of software from its use by employing remote service\nproviders to deliver services \u2018on demand\u2019 (Turner et al. 2003, Budgen, Brereton\n& Turner 2004).", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 315", "position": 315, "chunk_type": "semantic", "token_estimate": 400}
{"text": "300: Software Design: Creating Solutions for Ill-Structured Problems\ndynamically (one of the more challenging aspects of the service model)\nunless such contracts are negotiated in advance of use. \u2022 Delivery. Essentially this is the operational aspect by which a service\nprovides the agreed service functionality. \u2022 Distributed Sources. Services can be delivered locally as well as from\nremote sources, but this aspect is particularly concerned with delivery\nacross a network (implicitly, the web). \u2022 Identity. This is essentially the description of a particular service and\nthe ways that it can be accessed. \u2022 Interoperability. This relates to the service framework and the way that\nservices can be deployed within this, including the possibility that the\nend-user has no knowledge about the location or provider of a particular\nservice, and indeed, that such a service may be provided by di\ufb00erent\nsources each time it is requested. \u2022 Packaging. A constructional issue concerning the creation of services so\nas to ensure that a service both provides the required functionality, and\nalso the appropriate interface. While all of these are factors that in\ufb02uence design of an application in some\nway, not all of them will necessarily be a direct in\ufb02uence. Characteristics such\nas packaging and identity are primarily ones that are determined or speci\ufb01ed\nby the service provider, and hence likely to be an indirect in\ufb02uence. Others\nsuch as orchestration, binding time and capability are likely to be of much\nmore immediate importance when con\ufb01guring an application to use services. Figure 16.3 shows how these characteristics map on to the main elements of\nthe service paradigm, by annotating the model provided in Figure 11.5. Development of SOA applications is apt to employ a complex mix of busi-\nness and technological modelling. As noted in the last chapter, the use of de-\nsign patterns has been advocated for more detailed modelling needs (Erl 2009). There has also been some interest in using what are more or less plan-driven\nforms of approach such as the SOA method (SOAM) proposed in (O\ufb00ermann\n& Bub 2009). (There is some discussion of di\ufb00erent methods in (Anjum &\nBudgen 2017).) Modelling would appear to be largely dependent upon the use\nof UML class and component diagrams. In many ways, designing SOA applications can be considered as being\nan indirect form of design.", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 317", "position": 317, "chunk_type": "semantic", "token_estimate": 383}
{"text": "300: Modelling would appear to be largely dependent upon the use\nof UML class and component diagrams. In many ways, designing SOA applications can be considered as being\nan indirect form of design. Rather than explicitly determining things like\ncon\ufb01guration of elements, the SOA designer is more concerned with writing\na set of rules for the dynamic orchestration of the services. And these roles\nare not only concerned with basic service properties, but also with things like\nService-Level Agreements that are con\ufb01rmed or re-negotiated at run time, as\nwell as security.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 317", "position": 317, "chunk_type": "semantic", "token_estimate": 91}
{"text": "Designing with Components and Services: 301\nService\nConsumer\nService\nDescription\nService\nProvider\nService\nComposition\nselection\n& binding\nuse\nprovision\nrequest\nnegotiation\nBusiness\nRules\ncapability\ncapability\ndelivery\ndelivery\ncontracts\ncontracts\nidentity\ndistributed sources\npackaging\narchitecture\nbinding time\ncomposition\narchitecture\nidentity\ninteroperability\nFIGURE 16.3: SOA characteristics mapped on to the service model\nOne question that arises when designing around the use of SOA is the\nextent to which relevant commercial service provision exists? (A similar issue\narises with component-based design, but once a component has been found, its\nuse is less dependent upon the external provider.) As with the use of physical\nservices, adoption of this model does involve an element of risk in that a service\nprovider may cease to trade. Hence employing a service model does implicitly\nrequire the availability of multiple providers for a given service. Many of the\npapers describing and discussing use of services do tend to be focused on quite\nspeci\ufb01c application areas, which may help the emergence of a provider market,\npossibly related to the use of cloud services. To complete our discussion of the use of software services in this section,\nwe again turn to the needs of the CCC and consider how this might make use\nof a service model, including services provided by external providers. For the\npurposes of this discussion, we assume that some of the more \u2018general purpose\u2019\nservices needed are readily available from external sources.", "domains": ["Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 318", "position": 318, "chunk_type": "semantic", "token_estimate": 236}
{"text": "302: Software Design: Creating Solutions for Ill-Structured Problems\nSoftware service implementation for the CCC? We can model the customer\u2019s use of the CCC as being provided by\na set of distinct user-facing services: seeking available cars; making a\nreservation; accessing the chosen car. However, all, or most, of these\nwill need to be provided by a \u2018bespoke\u2019 service provider since they are\nspeci\ufb01c to the needs of the CCC. Of course it is also possible that\nthis specialist service provision may be based within the CCC system. There is no reason why \u2018local\u2019 and \u2018general\u2019 services should not be used\ntogether as long as they conform to the same service model. (Making\na reservation is more likely to be available as a general service.) The backend functionality may well be able to use a number of ser-\nvices that are su\ufb03ciently widely used that it is likely that they can be\nprovided by multiple service providers. This may include such tasks\nas identifying where the cars are in the streets (GPS locations), as\nwell as for accounting and billing functions, with security clearly being\nimportant for the latter. 16.4\nEmpirical knowledge about modular design\nThe diversity and emerging nature of the technologies covered in this chap-\nter pose something of a challenge for empirical studies. We have already identi-\n\ufb01ed the systematic mapping study by Vale et al. (2016) as looking at research\nactivities in CBSE. At time of writing, there is no obvious equivalent study\naddressing the use of software service technologies. Key take-home points about designing with components\nand services\nIf we view components and software services as being evolutionary stages\nin modular design of software, we can identify the following lessons about their\nuse. Design models. Modular design can make use of many of the modelling\nforms already developed for object-oriented development, possibly aug-\nmented by forms such as DFDs where the \u2018\ufb02ow\u2019 nature of service models\nrequire such a form.", "domains": ["Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 319", "position": 319, "chunk_type": "semantic", "token_estimate": 324}
{"text": "306: In Chapter 4 we identi\ufb01ed some design\nprinciples that are generally considered to characterise a good design. \u2022 Fitness for purpose. This comes as close as we can hope to providing\nthe ultimate test for an ISP, but of course, is not something that we can\neasily quantify or indeed, assess systematically. \u2022 Separation of concerns. This can be considered as providing an assess-\nment of the \u2018modular\u2019 organisation of a design.", "domains": ["Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 323", "position": 323, "chunk_type": "semantic", "token_estimate": 73}
{"text": "How Good Is My Design?: 307\n\u2022 Minimum coupling. For any application, the di\ufb00erent elements need to\ninteract in order to perform the necessary tasks, and coupling determines\nhow they interact (statically and dynamically). \u2022 Maximum cohesion. Like coupling, the idea of cohesion re\ufb02ects our ex-\npectation that the compartmentalisation of the system elements provides\nelements that are relatively self-contained. \u2022 Information hiding. Relates to knowledge used by the application and\nhow this is shared between the elements, such that each element can\nonly access the knowledge that is relevant to its role. Information hiding\nWhile these are important software design prin-\nciples, they very much embody ideas about how a de-\nsign model should be organised, strongly in\ufb02uenced\nby the idea that a design is likely to evolve and to\nbe adapted. A rather di\ufb00erent perspective, and one that is\nequally important, is to think about the role and\nfunctioning of an application. The group of quality\nfactors that we associate with this are often referred\nto as the ilities (because most of them end with \u2018il-\nity\u2019), and we brie\ufb02y consider some of these below. 17.1.1\nThe \u2018ilities\u2019\nThere are many ilities, with the emphasis placed upon particular factors\nbeing dependent upon the purpose of the application being developed. Here,\nthe discussion is con\ufb01ned to a group that can be considered to be fairly widely\napplicable: reliability; e\ufb03ciency; maintainability; and usability. Other, rather\nmore specialised ones include: testability; portability; and reusability. Reliability. This factor is essentially concerned with the dynamic charac-\nteristics of the eventual application, and so involves making predictions\nabout behavioural issues. From a design perspective, assessing this in-\nvolves determining whether the eventual application will be:\n\u2022 complete, in the sense of being able to react correctly to all combi-\nnations of events and system states;\n\u2022 consistent, in that its behaviour will be as expected and repeatable,\nregardless of how busy the application might be;\n\u2022 robust when faced with component failure or similar con\ufb02icts (this is\nusually referred to as being graceful degradation)\u2014for the example\nof the CCC, this might require that it copes with a situation where\nthe customer is unable to unlock the selected car, despite having\nthe correct code.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 324", "position": 324, "chunk_type": "semantic", "token_estimate": 369}
{"text": "308: Software Design: Creating Solutions for Ill-Structured Problems\nThis factor is a key one for safety-critical systems, which may use repli-\ncated hardware and software to minimise the risk of component failure,\nbut it is also important for those applications that have an element of\nuser interaction. E\ufb03ciency. This can be measured through an application\u2019s use of resources,\nparticularly where these need to be shared. Depending upon context,\nthe relevant resources may include processor time, storage, network use\netc., and this multi-variate aspect does make it di\ufb03cult to assess. There are also trade-o\ufb00s involved between these. As an example,\neconomising on memory use might result in an increase on processor\nload. Where resources are constrained it can be important to try and\nmake some assessment of the likely e\ufb00ects of particular design choices,\nalthough \ufb01ne-tuning may be better left to the implementation phase. Maintainability. The lifetime of a software artifact, whether it be a compo-\nnent or an application or a platform will probably be quite long. Plan-\nning for possible change is therefore something that should in\ufb02uence\ndesign decisions. This factor strongly re\ufb02ects the characteristic of separation of concerns. The problem is to determine what the likely evolutionary pathways may\nbe. It may be important to be clear about the assumptions that an\napplication makes about its context and use, and to query these in the\nlight of di\ufb00erent possible scenarios of evolution. Usability. There are many things that can in\ufb02uence the usability of an arti-\nfact (Norman 2002). However, for software, the user-interaction, or HCI\n(Human Computer Interaction) elements tend to predominate and may\nwell in\ufb02uence other design decisions too. The set of measures provided\nby the cognitive dimensions framework is widely considered as being a\nuseful way of thinking about usability (Green & Petre 1996), and the\nconcept of interaction design has helped focus attention on the nature\nof software use (Sharp et al. 2019). The cognitive dimensions framework can be considered as providing a set of\nqualitative measures that can be used to assess a design (not just from the\nHCI aspect either). We now look at ways in which we might use quantitative\nmeasures, and the forms that they might take. 17.1.2\nDesign metrics\nUnfortunately, neither the general design characteristics nor the \u2018ilities\u2019\ncan be measured directly, which is where the use of quantitative software\nmetrics may assist by providing some surrogate measures.", "domains": ["Design Principles", "Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 325", "position": 325, "chunk_type": "semantic", "token_estimate": 398}
{"text": "How Good Is My Design?: 309\nWe encountered some examples of metrics in Chapter 10 and this may be\na useful place to examine their role and form a bit more fully. Measurement\nscience di\ufb00erentiates between an attribute, which we associate with some el-\nement (in this case, of design), and a metric, which will have a value in the\nform of a speci\ufb01c number and an associated unit of measurement. And for a\ngiven metric, as we say in Chapter 10, we need to have some form of counting\nrules that are applied in order to derive its value. Indeed, Fenton & Bieman\n(2014) have observed that \u201cmeasurement is concerned with capturing infor-\nmation about attributes of entities\u201d. So, our next need is to determine how\nideas about quality can use metrics and measurements. Figure 17.1 shows a simple view of the mapping that links quality concepts\nthrough to actual counts. Counts taken from\nrepresentations\nQuality factors\n(properties)\nMeasurable\ncharacteristic\nQuality criteria\nRole\nExamples\nQuality concepts\nAssociated\nsystem attributes\nMetric definition\n(counting rules)\nSeparation of\nconcerns;\nMaintainability;\nUsability\nModularity;\nCompleteness\nCoupling Between\nObjects (CBO);\nInformation Flow\nOperationalisation\nof metric\nCounting links;\nCounting objects;\netc. FIGURE 17.1: Linking quality concept to measurements\nUnfortunately, none of the mappings between the elements of this are par-\nticularly easy to de\ufb01ne. The desirable design characteristics are quite abstract,\nas are the attributes. Finding measures for an invisible and complex media\nsuch as software can be quite challenging, and so each of the things that we\ncan actually measure usually comes down to counting tokens. For code met-\nrics, the tokens are usually syntactic elements, for design metrics, they tend\nto be diagrammatical elements. So what we can count is not always what we\nwould like to be able to count! And of course, we are limited to counts of static", "domains": ["Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 326", "position": 326, "chunk_type": "semantic", "token_estimate": 307}
{"text": "310: Software Design: Creating Solutions for Ill-Structured Problems\nrelationships, although we know that software has quite important dynamic\nproperties. So, counting the number of objects, components, sub-programs and the\ncoupling links between these is probably the best we can do when looking at\na design model. (We saw this in Chapter 10 when reviewing the Chidamber\nand Kemerer metrics.) Having relatively \u2018formal\u2019 models that are documented\nusing (say) UML notations may help, but quite a lot can be done just by\nlooking at sketches too. And there are other things that are related to the\ndesign model that can also be measured, such as the number of times the\ndesign of a particular sub-system of an application has been modi\ufb01ed. Before discussing what we might do with such knowledge, it is worth noting\nthat there are two types of metric that are both commonly used in software\nengineering (Hughes 2000). \u2022 Actionable metrics are those that relate to things we can control. We can\nreact to the values obtained from using such a metric by making changes\nto our design. If we are counting the arguments of methods as part of\na metric, we can make changes if we \ufb01nd a particular method seem to\nhave too many arguments for its purpose. At a more abstract level, we\ncan make changes if we \ufb01nd that a particular class has particularly high\ncounts for coupling measures (when compared with the other classes in\nthe design model). \u2022 Informational metrics tell us about things that can be measured and that\nare important to us, but that we cannot in\ufb02uence directly. One example\nof this is \u2018module churn\u2019, which occurs where the number of revisions\nto the design (or code) of each module is counted over a period of time,\nand we observe that a particular element may have been modi\ufb01ed many\ntimes. This churn is a consequence of design activities, but usually we\nwouldn\u2019t want to use it to control them! Many design metrics fall into the category of actionable metrics, since after\nall, they are usually relating to an application that has yet to be built. And as a last point about metrics, we should note that complexity is not\nan attribute in its own right. It is incorrect to refer to the \u2018complexity of\nobject D\u2019, because there are many measures that might be applied to that\nobject.", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 327", "position": 327, "chunk_type": "semantic", "token_estimate": 398}
{"text": "312: Software Design: Creating Solutions for Ill-Structured Problems\nParnas & Weiss (1987) have suggested that there are eight requirements\nthat a \u2018good\u2019 design should meet. 1. Well structured: being consistent with principles such as information-\nhiding and separation of concerns. 2. Simple: to the extent of being \u2018as simple as possible, but no simpler\u2019. 3. E\ufb03cient: providing functions that can be computed using the available\nresources. 4. Adequate: su\ufb03cient to meet the stated requirements. 5. Flexible: being able to accommodate likely changes in the requirements,\nhowever these are likely to arise. 6. Practical: with module interfaces providing the required functionality,\nneither more nor less. 7. Implementable: with current (and chosen) software and hardware tech-\nnologies. 8. Standardised: using well-de\ufb01ned and familiar notation for any documen-\ntation. The last point is particularly relevant given that as we have observed, designers\noften employ informal notations. However, the key issue is that any notations\nused should at least be readily explained and interpreted. A set of hand-drawn\nsequence diagrams may be su\ufb03cient to explore scenarios without the need to\nfollow exact UML syntax. A systematic review looking at the use of metrics by industry during agile\nsoftware development by Kupiainen, M\u00e4ntyl\u00e4 & Itkonen (2015) made some\nobservations of how such reviews could use metrics. In particular the review\nreinforced the view that the targets of measurement should be the product\nand the process, but not the people. They also observed the following. \u2022 Documentation produced by a project should not be the object of mea-\nsurement, and the focus of attention should be the product and its fea-\ntures. \u2022 Using metrics can be a positive motivator for a team, and can change\nthe way that people behave by determining the set of issues that they\npay attention to. \u2022 For agile development, teams used metrics in a similar way to how they\nwere employed with plan-driven projects, using them to support sprint\nand project planning, sprint and progress tracking, understanding and\nimproving quality, and \ufb01xing problems with software processes.", "domains": ["Design Patterns", "Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 329", "position": 329, "chunk_type": "semantic", "token_estimate": 337}
{"text": "How Good Is My Design?: 313\nAn important ground-rule for a design review is that it should concentrate\non reviewing the design and not attempt to \ufb01x any issues that are identi\ufb01ed. In the next section we therefore look at what we might do next, following a\nreview. 17.3\nRefactoring of designs\nThe idea of refactoring was introduced in Section 14.7, and as explained\nin Section 15.4, the need to perform refactoring is often motivated by the\npresence of code smells (Fowler 1999). The discussion in both of these sections\nwas focused largely upon code, rather than design, as this is often where\nthe relevant structural weaknesses are identi\ufb01ed. However, many of the code\nsmells originate in design weaknesses and there is scope to identify their likely\npresence during a design review. Of course, this isn\u2019t always the case, and the\nidea of code duplication is an obvious example of a problem that is less likely\nto be identi\ufb01ed during design. Refactoring can occur before that though, based upon the design model,\nand is one way of addressing the issues identi\ufb01ed in a design review. Clearly,\nsome issues such as those associated with duplication are unlikely to be \ufb02ushed\nout by a review. However, the need for redistribution of functionality across\ndesign elements (objects, components) and reorganisation of communication\nmodels are possible outcomes, along with the possible creation of new design\nelements. What this points to is the need to document and record the outcomes\nof a review with care. One possible option here is to use video-recording,\nwith the agreement of all participants, so that issues do not get lost and any\nwhiteboard-based discussions are captured. And of course, after a post-review\nrefactoring of the design (if such changes are necessary), it may be useful to\nrepeat the review, or part of it, using the same review team. 17.4\nEmpirical knowledge about quality assessment\nEmpirical studies that are relevant to this chapter are chie\ufb02y those look-\ning at the use of metrics in assessing quality as well as those examining the\ne\ufb00ectiveness of code reviews and ways of improving their e\ufb03ciency. (Design\nreviews do not appear to have been very extensively studied, perhaps because\nof the di\ufb03culty of \ufb01nding enough experienced participants.) Earlier we men-\ntioned the systematic review by Kupiainen et al. (2015) and its \ufb01ndings. Here", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 330", "position": 330, "chunk_type": "semantic", "token_estimate": 389}
{"text": "314: Software Design: Creating Solutions for Ill-Structured Problems\nwe identify a small number of further studies that use di\ufb00erent approaches for\nthe purpose of evaluation. Software metrics can be used inappropriately as well as being a useful tool,\nand before adopting any metrics it may well be worth reading the book by\nFenton & Bieman (2014) and the invited review paper by Kitchenham (2010). Another interesting study is that by Jabangwe, Borstler, Smite & Wohlin\n(2015) which looks at the link between object-oriented metrics and quality\nattributes. Reinforcing our observations about OO metrics in Chapter 10,\nthis review did note that measures for complexity, cohesion, coupling and size\ncorresponded better with reliability and maintainability than the inheritance\nmeasures. The study reported in Bosu, Greiler & Bird (2015) is based on interviews\nwith sta\ufb00at Microsoft and provides some useful recommendations for improv-\ning the practice of reviews. The e\ufb00ect of using light-weight tool-based review\npractices is reviewed in McIntosh, Kamei, Adams & Hassan (2016) using three\nlarge open-source repositories in a case study design. Again, the \ufb01ndings of\nthis study reinforce the value of well-conducted reviews. Key take-home points about assessing design quality\nAssessing design quality poses some challenges, not least because our inter-\npretation of quality may be in\ufb02uenced by such factors as domain, technologies\netc. However, there are some useful general points worth making here. Quality measures. A design will have many di\ufb00erent quality attributes,\nusually related to the ilities, and with the emphasis placed on each\nattribute being largely dependent upon the nature of the application. Metrics that directly measure features that are directly related to these\nattributes are generally impractical and it may be necessary for a team\nto decide on their own counting rules when making measurements re-\nlated to a design model. Design reviews. The use of formal or informal design reviews provides an\nopportunity to make project-speci\ufb01c interpretation of any metric values\nobtained, as well as to assess the general structure of a design model. It\nis important that the outcomes from a review are carefully recorded. Design refactoring. This can be performed as part of the outcome from\na review, but there is little guidance available about how to perform\nrefactoring at the design level.", "domains": ["Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 331", "position": 331, "chunk_type": "semantic", "token_estimate": 372}
{"text": "Chapter 18: And What About...\n18.1\nOpen source software (OSS) .....................................\n315\n18.2\nFormal description techniques (FDTs) ...........................\n317\n18.3\nModel driven engineering (MDE) ................................\n321\n18.4\nAnd the rest. . . ..................................................\n322\nThis last chapter provides a brief summary of some of the topics that this\nbook does not cover. These are some quite important in\ufb02uences upon software\ndesign that either don\u2019t really \ufb01t into the narrative of this book, or that don\u2019t\ncontribute quite enough to the theme of emerging software design knowledge\nto be included. And inevitably, there will also be some topics that don\u2019t appear\nhere that others may feel should do. The structure of this chapter is a little di\ufb00erent too, in that the discussion\nof empirical knowledge is embedded in the sections, rather than appearing\nin a separate section. There is also no \ufb01nal \u2018take home\u2019 section, since the\ndescriptions are really too short to merit this. 18.1\nOpen source software (OSS)\nThis has had occasional mention in the preceding chapters. One descrip-\ntion for the way that open source software (OSS) is developed is that this is a\nreactive development process, whereby a particular application evolves largely\nin response to what its developers perceive as being needed. It can also be\nviewed as being a form of incremental development. Either way, it has be-\ncome a major source of software that is used worldwide for an ever-increasing\nnumber of applications. For most users, the most important characteristic is\nusually that it is free to download and use, but for some the availability of the\nsource code and the freedom to change it opens up important opportunities. The rami\ufb01cations of OSS can be somewhat theological in nature, but most\nwould consider that its roots lie back in the pioneering work of Richard Stall-\nman\u2019s Free Software Foundation and the GNU project (a recursive de\ufb01ni-\ntion of GNU is \u2018GNU\u2019s Not Unix\u2019!). Two factors accelerated its emergence\nin the 1990s: one was when the Linux operating system kernel came together\nwith GNU to provide a widely distributed free operating system for personal\n315", "domains": ["Software Quality Attributes"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 332", "position": 332, "chunk_type": "semantic", "token_estimate": 349}
{"text": "And What About...: 319\nExamples are:\n[CCCCARS]the set of all cars available for use by CCC members\n[RUNWAY ] ::== main | north | west\nThe \ufb01rst example is self-evident, while the second tells us that an airport\nhas three runways. As in this example, the variables are in lower case. Set operations. These are largely as would be expected. Two that may be\nless familiar are the use of # that returns the number of elements in the\nset, and P for the powerset of a set (the set of all subsets of that set). Logic. Operations and relations in a speci\ufb01cation are usually expressed by\nusing the standard operators of predicate logic. The logical operators\ncan then be combined with the set elements and used to describe char-\nacteristic rules a\ufb00ecting a set, usually in the general form of:\ndeclaration | predicate \u2022 expression\nwhere the declaration introduces the variables of concern to the rule;\nthe predicate constrains their values; and the expression describes the\nresulting set of values. A key component of Z is the schema. The role of this is to describe a system\noperation, and it is usually drawn as an open box that has three elements:\n\u2022 the schema name;\n\u2022 the signature, that introduces any variables and assigns them to set\ntheoretic types;\n\u2022 the predicates that form the state invariants, describing how the elements\nof the signature are related and constrain the operation, and that are\ndescribed in terms of preconditions and postconditions. A very simple example of a schema that is related to the activities of the CCC\nis provided below. ReserveCar\ndrivers, drivers\u2032 : P CCCMEMBER\nd? : CCCMEMBER\n#drivers < #CCCCARS\nd? /\n\u2208drivers\ndrivers\u2032 = drivers \u222a{d?} #drivers\u2032 \u2264#CCCCARS\nHere, the elements used are:", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 336", "position": 336, "chunk_type": "semantic", "token_estimate": 296}
{"text": "320: Software Design: Creating Solutions for Ill-Structured Problems\n\u2022 the name of the schema, which is ReserveCar;\n\u2022 the signature that describes the \u2018before\u2019 and \u2018after\u2019 states of the set of\ndrivers (CCC members who are currently using a CCC car), with the\nconvention being that the primed identi\ufb01er denotes the state of the set\nafter the operation; while the variable d? is a variable used for an input\nthat is required as part of the schema;\n\u2022 the predicate describes the operations required to reserve a car, which\nare as follows:\n\u2013 \ufb01rstly, the number of drivers should be fewer than the number of\ncars available (precondition 1);\n\u2013 the new driver should not already be driving a car (and hence is\nnot in the set of existing drivers) (precondition 2);\n\u2013 the new set of drivers will be comprised of the original set together\nwith the new driver (postcondition 1);\n\u2013 the number of drivers after the operation must now be either less\nthan the number of available cars, or equal to it (postcondition 2)\nOne advantage of this type of formal speci\ufb01cation is that we can readily reason\nabout it, and clearly there are some shortcomings we can identify fairly quickly. In particular, the set of cars implicitly includes all of the cars available at the\nsite. But of course, some may be unavailable for other reasons, such as being\nserviced, and so we should probably use a subset of \u2018active\u2019 cars, together with\nanother schema that keeps that subset up to date. From a design perspective, Z probably does not particularly assist with\nthe problems of producing a design solution for an ISP, beyond helping to\nmanage completeness and consistency. In many ways it can make more of a\ncontribution to the issue of clarifying the needs that an application needs to\nmeet (that is, the speci\ufb01cation). One of the characteristics of an ISP is the\nlack of a de\ufb01nitive speci\ufb01cation, and while Z might not be able to address all\nthe aspects of that lack, it can help with clari\ufb01cation. Few empirical studies appear to have been performed on the use of FDTs,\nparticularly with regard to their use in industry. This in turn makes it di\ufb03cult\nto assess what features of their use are particularly valued by those who adopt\nthem.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 337", "position": 337, "chunk_type": "semantic", "token_estimate": 387}
{"text": "326: Bibliography\nBass, L., Clements, P. & Kazman, R. (2013), Software Architecture in Practice,\n3rd edn, Pearson. Bates, B., Sierra, K., Freeman, E. & Robson, E. (2009), Head First Design\nPatterns, O\u2019Reilly. Beck, K. (2000), Extreme Programming Explained: Embrace Change, Addison-\nWesley. Beck, K. & Cunningham, W. (1989), \u2018A laboratory for teaching object-oriented\nthinking\u2019, ACM SIGPLAN Notices 24(10), 1\u20136. Bennett, K. H. & Rajlich, V. T. (2000), Software maintenance and evolution:\nA roadmap, in \u2018Proceedings of the Conference on the Future of Software\nEngineering\u2019, ICSE \u201900, ACM, New York, NY, USA, pp. 73\u201387. URL: http://doi.acm.org/10.1145/336512.336534\nBennett, K., Layzell, P., Budgen, D., Brereton, P., Macaulay, L. & Munro,\nM. (2000), Service-based software: The future for \ufb02exible software, in\n\u2018Proceedings of Seventh Asia-Paci\ufb01c Software Engineering Conference\u2019,\nIEEE Computer Society Press, pp. 214\u2013221. Blackwell, A. & Green, T. (2003), Notational systems\u2014the cognitive dimen-\nsions of notations framework, in J. M. Carroll, ed., \u2018HCI Models, Theo-\nries, and Frameworks: Toward a Multidisciplinary Science\u2019, Morgan Kauf-\nman, chapter 5. Boehm, B. W. (1981), Software Engineering Economics, Prentice-Hall. Boehm, B. W. (1988), \u2018A spiral model of software development and enhance-\nment\u2019, IEEE Computer 21(5), 61\u201372. Boehm, B. W. (2002), \u2018Get ready for agile methods, with care\u2019, IEEE Com-\nputer 35(1). Booch, G. (1994), Object-Oriented Analysis and Design with Applications, 2nd\nedn, Benjamin Cummings. Bosu, A., Greiler, M. & Bird, C. (2015), Characteristics of useful code reviews:\nAn empirical study at Microsoft, in \u201812th IEEE/ACM Working Confer-\nence on Mining Software Repositories\u2019, IEEE Computer Society Press,\npp. 1\u201311. Breivold, H. P., Crnkovic, I. & Larsson, M. (2012), \u2018A systematic review of\nsoftware architecture evolution research\u2019, Information & Software Tech-\nnology 54, 16\u201340. Brereton, P. & Budgen, D. (2000), \u2018Component based systems: A classi\ufb01cation\nof issues\u2019, IEEE Computer 33(11), 54\u201362.", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 343", "position": 343, "chunk_type": "semantic", "token_estimate": 292}
{"text": "Bibliography: 327\nBrooks, F. P. (1987), \u2018No silver bullet: Essences and accidents of software\nengineering\u2019, IEEE Computer 20(4), 10\u201319. Brooks, F. P. (1988), Grasping reality through illusion \u2013 interactive graphics\nserving science, in \u2018Proceedings of the ACM SIGCHI Conference\u2019, pp. 1\u2013\n11. Brown, A. W. (2000), Large-Scale Component-Based Development, Prentice-\nHall. Brown, A. W. & Short, K. (1997), On components and objects: the foundations\nof component-based development, in \u2018Proceedings of 5th International\nSymposium on Assessment of Software Tools and Technologies\u2019, IEEE\nComputer Society Press, pp. 112\u2013121. Brown, A. W. & Wallnau, K. C. (1998), \u2018The current state of cbse\u2019, IEEE\nSoftware 15(5), 37\u201346. Brown, W. J., Malveau, R. C., McCormick, H. W. & Mowbray, T. J. (1998),\nAntipatterns: Refactoring Software, Architectures, and Projects in Crisis,\nWiley. Budgen, D. (2014), Software Designers in Action: A Human-Centric Look at\nDesign Work, Chapman & Hall, chapter 12. Budgen, D., Brereton, P., Drummond, S. & Williams, N. (2018), \u2018Reporting\nsystematic reviews: Some lessons from a tertiary study\u2019, Information and\nSoftware Technology 95, 62 \u2013 74. Budgen, D., Brereton, P. & Turner, M. (2004), Codifying a Service Archi-\ntectural Style, in \u2018Proceedings 28th International Computer Software &\nApplications Conference - COMPSAC\u2019, IEEE Computer Society Press,\npp. 16\u201322. Budgen, D., Brereton, P., Williams, N. & Drummond, S. (2018), \u2018The contri-\nbution that empirical studies performed in industry make to the \ufb01ndings\nof systematic reviews: A tertiary study\u2019, Information and Software Tech-\nnology 94, 234 \u2013 244. Budgen, D., Brereton, P., Williams, N. & Drummond, S. (2020), \u2018What sup-\nport do systematic reviews provide for evidence-informed teaching about\nsoftware engineering practice?\u2019, e-Informatica 14(1), 7\u201360. Budgen, D., Burn, A., Brereton, P., Kitchenham, B. & Pretorius, R. (2011),\n\u2018Empirical evidence about the UML: A systematic literature review\u2019, Soft-\nware \u2014 Practice and Experience 41(4), 363\u2013392. Buschmann, F., Meunier, R., Rohnert, H., Sommerlad, P. & Stal, M. (1996),\nPattern-Oriented Software Architecture, Wiley.", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 344", "position": 344, "chunk_type": "semantic", "token_estimate": 312}
{"text": "328: Bibliography\nCarney, D. & Long, F. (2000), \u2018What do you mean by COTS? Finally, a useful\nanswer\u2019, IEEE Software 17(2), 83\u201386. Chen, J., Xiao, J., Wang, Q., Osterweil, L. J. & Li, M. (2016), \u2018Perspectives on\nrefactoring planning and practice: An empirical study\u2019, Empirical Soft-\nware Engineering 21, 1397\u20131436. Chen, P. P. (1976), \u2018The entity-relationship model: Toward a uni\ufb01ed view of\ndata\u2019, ACM Transactions on Database Systems 1(1), 9\u201337. Chidamber, S. R. & Kemerer, C. F. (1994), \u2018A metrics suite for object oriented\ndesign\u2019, IEEE Transactions on Software Engineering 20(6), 476\u2013493. Coleman, D., Arnold, P., Bodo\ufb00, S., Dollin, C., Gilchrist, H., Hayes, F. &\nJeremes, P. (1994), Object-Oriented Development: The Fusion Method,\nPrentice-Hall. Connor, D. (1985), Information System Speci\ufb01cation and Design Road Map,\nPrentice-Hall. Cooke, P. (1984), \u2018Electronic design warning\u2019, Engineering Design 9(6), 8. Coplien, J. O. (1997), \u2018Idioms and patterns as architectural literature\u2019, IEEE\nSoftware 14(1), 36\u201342. Crnkovic, I. & Larsson, M. (2002), \u2018Challenges of component-based develop-\nment\u2019, Journal of Systems & Software 61(3), 201\u2013212. Crnkovic, I., Sta\ufb00ord, J. & Szyperski, C. (2011), \u2018Software components beyond\nprogramming: From routines to services\u2019, IEEE Software 28(3), 22\u201326. Cunningham, W. (1992), The WyCash portfolio management system, in \u2018Ad-\ndendum to the Proceedings on Object-oriented Programming Systems,\nLanguages, and Applications (Addendum)\u2019, OOPSLA \u201992, ACM, New\nYork, NY, USA, pp. 29\u201330. Curtis, B., Krasner, H. & Iscoe, N. (1988), \u2018A \ufb01eld study of the software design\nprocess for large systems\u2019, Communications of the ACM 31(11), 1268\u2013\n1287. Curtis, B. & Walz, D. (1990), The psychology of programming in the large:\nTeam and organizational behaviour, in \u2018Psychology of Programming\u2019,\nAcademic Press, pp. 253\u2013270. Cusumano, M. A. & Selby, R. W. (1989), \u2018How Microsoft builds software\u2019,\nCommunications of the ACM 40(6), 53\u201361. De Marco, T. (1978), Structured Analysis and System Speci\ufb01cation, Yourdon\nPress.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 345", "position": 345, "chunk_type": "semantic", "token_estimate": 298}
{"text": "Bibliography: 331\nHayes-Roth, B. & Hayes-Roth, F. (1979), \u2018A cognitive model of planning\u2019,\nCognitive Science 3(4), 275\u2013310. Heineman, G. T. & Councill, W. T. (2001), Component-Based Software En-\ngineering: Putting the Pieces Together, Addison-Wesley. Hughes, B. (2000), Practical Software Measurement, McGraw Hill. Izurieta, C. & Bieman, J. M. (2007), How software designs decay: A pilot study\nof pattern evolution, in \u2018Proceedings of Empirical Software Engineering\n& Measurement, 2007\u2019. Jabangwe, R., Borstler, J., Smite, D. & Wohlin, C. (2015), \u2018Empirical evi-\ndence on the link between object-oriented measures and external quality\nattributes: A systematic literature review\u2019, Empirical Software Engineer-\ning 20, 640\u2013693. Jackson, M. A. (1975), Principles of Program Design, Academic Press. Jacobson, I., Booch, G. & Rumbaugh, J. (1999), The Uni\ufb01ed Software Devel-\nopment Process, Addison-Wesley. Jacobson, I., Christerson, M., Jonsson, P. & Overgaard, G. (1992), Object-\nOriented Software Engineering: A Use Case Driven Approach, Addison-\nWesley. Jacobson, I., Spence, I. & Kerr, B. (2016), \u2018Use-Case 2.0\u2019, Communications of\nthe ACM 59(5), 61\u201369. Jacobson, I., Spence, I. & Seidewitz, E. (2016), \u2018Industrial-scale agile\u2014from\ncraft to engineering\u2019, Communications of the ACM 59(12), 63\u201371. J\u00e9z\u00e9quel, J.-M. & Meyer, B. (1997), \u2018Design by contract: The lessons of Ari-\nane\u2019, IEEE Computer 30(1), 129\u2013130. Johnson, R. A. & Hardgrave, W. C. (1999), \u2018Object-oriented methods: Current\npractices and attributes\u2019, Journal of Systems & Software 48(1), 5\u201312. Jones, J. C. (1970), Design Methods: Seeds of Human Futures, Wiley-\nInterscience. Kitchenham, B. (2010), \u2018What\u2019s up with software metrics? \u2013 a preliminary\nmapping study\u2019, Journal of Systems & Software 83, 37\u201351. Kitchenham, B. A., Budgen, D. & Brereton, P. (2015), Evidence-Based Soft-\nware Engineering and Systematic Reviews, Innovations in Software En-\ngineering and Software Development, CRC Press. Kruchten, P. (2004), The Rational Uni\ufb01ed Process: An Introduction, 3rd edn,\nAddison-Wesley.", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 348", "position": 348, "chunk_type": "semantic", "token_estimate": 291}
{"text": "332: Bibliography\nKruchten, P. B. (1994), \u2018The 4+1 view model of architecture\u2019, IEEE Software\n12(6), 42\u201350. Kupiainen, E., M\u00e4ntyl\u00e4, M. V. & Itkonen, J. (2015), \u2018Using metrics in agile and\nlean software development \u2013 a systematic literature review of industrial\nstudies\u2019, Information & Software Technology 62, 143\u2013163. Lanza, M. & Marinescu, R. (2006), Object-Oriented Metrics in Practice,\nSpringer. Larman, C. (2004), Applying UML and Patterns: An Introduction to Object-\nOriented Analysis and Design and Iterative Development, 3rd edn, Pren-\ntice Hall. le Goues, C., Jaspan, C., Ozkaya, I., Shaw, M. & Stolee, K. T. (2018), \u2018Bridg-\ning the gap: From research to practical advice\u2019, IEEE Software 35(5), 50\u2013\n57. Littman, D. C., Pinto, J., Letovsky, S. & Soloway, E. (1987), \u2018Mental models\nand software maintenance\u2019, Journal of Systems & Software 7, 351\u2013355. Litz, M. & Montazeri, B. (1996), \u2018Chidamber and kemerer\u2019s metrics suite: A\nmeasurement theory perspective\u2019, IEEE Transactions on Software Engi-\nneering 22(4), 267\u2013271. Long, J. (2001), \u2018Software reuse antipatterns\u2019, ACM Software Engineering\nNotes 26(4), 68\u201376. Longworth, G. (1992), Introducing SSADM Version 4, Blackwell Publishing. Lunn, K. (2003), Software Development with UML, Palgrave Macmillan. Mangano, N., Toza, T. D. L., Petre, M. & van der Hoek, A. (2015), \u2018How soft-\nware designers interact with sketches at the whiteboard\u2019, IEEE Transac-\ntions on Software Engineering 41(2), 135\u2013156. Mayvan, B. B., Rasoolzadegan, A. & Yazdi, Z. G. (2017), \u2018The state of the\nart on design patterns: A systematic mapping of the literature\u2019, Journal\nof Systems & Software 125, 93\u2013118. McIntosh, S., Kamei, Y., Adams, B. & Hassan, A. E. (2016), \u2018An empirical\nstudy of the impact of modern code review practices on software quallity\u2019,\nEmpirical Software Engineering 21, 2145\u20132189. Miller, G. A. (1956), \u2018The magical number seven, plus or minus two: Some lim-\nits on our capacity for processing information\u2019, The Psychological Review\n63(2), 81\u201397. Mills, H. (1971), Chief programmer teams, principles, and procedures, Tech-\nnical report, IBM Federal Systems Division.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 349", "position": 349, "chunk_type": "semantic", "token_estimate": 320}
{"text": "Bibliography: 333\nMohagheghi, P. & Conradi, R. (2007), \u2018Quality, productivity and economic\nbene\ufb01ts of software reuse: A review of industrial studies\u2019, Empirical Soft-\nware Engineering 12, 471\u2013516. Mohagheghi, P. & Dehlen, V. (2008), Where is the proof? \u2013 a review of ex-\nperiences from applying MDE in industry, in \u2018ECMDA-FA, LNCS 5095\u2019,\nSpringer, pp. 432\u2013443. Moody, D. L. (2009), \u2018The \u201cphysics\u201d of notations: Toward a scienti\ufb01c basis for\nconstructing visual notations in software engineering\u2019, IEEE Transactions\non Software Engineering 35(6), 756\u2013779. Myers, G. J. (1973), \u2018Characteristics of composite design\u2019, Datamation\n19(9), 100\u2013102. Norman, D. A. (2002), The Design of Everyday Things, Basic Books. O\ufb00ermann, P. & Bub, U. (2009), Empirical comparison of methods for in-\nformation systems development according to SOA, in \u2018Proceedings 17th\nEuropean Conference on Information Systems (ECIS 2009)\u2019, pp. 1\u201313. Olbrich, S. M., Cruzes, D. S. & Sj\u00f8berg, D. I. K. (2010), Are all code smells\nharmful? A study of god classes and brain classes in the evolution of three\nopen source systems, in \u2018Proceedings of 26th International Conference on\nSoftware Maintenance\u2019, IEEE Computer Society Press. Owen, S., Budgen, D. & Brereton, P. (2006), \u2018Protocol analysis: A neglected\npractice\u2019, Communications of the ACM 49, 117\u2013122. Ozkaya, M. (2017), \u2018Do the informal and formal software modeling notations\nsatisfy practitioners for software architecture modeling\u2019, Information &\nSoftware Technology 95, 15\u201333. Page-Jones, M. (1988), The Practical Guide to Structured Systems Design,\n2nd edn, Prentice-Hall. Pahl, G. & Beitz, W. (1996), Engineering Design: A Systematic Approach,\n2nd edn, Springer-Verlag. Palomba, F., Bavota, G., Penta, M. D., Fasano, F., Oliveto, R. & Lucia,\nA. D. (2018), \u2018On the di\ufb00useness and the impact on maintainability of\ncode smells: A large scale empirical investigation\u2019, Empirical Software\nEngineering 23, 1188\u20131221. Parnas, D. L. (1972), \u2018On the criteria to be used in decomposing systems into\nmodules\u2019, Communications of the ACM 15(12), 1053\u20131058. Parnas, D. L. (1979), \u2018Designing software for ease of extension and contrac-\ntion\u2019, IEEE Transactions on Software Engineering 5(2), 128\u2013137.", "domains": ["Design Patterns", "Software Quality Attributes", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 350", "position": 350, "chunk_type": "semantic", "token_estimate": 326}
{"text": "334: Bibliography\nParnas, D. L. & Clements, P. C. (1986), \u2018A rational design process: How and\nwhy to fake it\u2019, IEEE Transactions on Software Engineering 12(2), 251\u2013\n257. Parnas, D. L. & Weiss, D. M. (1987), \u2018Active design reviews: Principles and\npractices\u2019, Journal of Systems & Software 7, 259\u2013265. Perry, D. E. & Wolf, A. L. (1992), \u2018Foundations for the study of software\narchitecture\u2019, ACM Software Engineering Notes 17(4), 40\u201352. Peters, L. & Tripp, L. (1976), \u2018Is software design \u2018wicked\u2019 too?\u2019, Datamation\n22(5), 127. Petre, M. (2013), UML in practice, in \u2018Proceedings of the 2013 International\nConference on Software Engineering (ICSE)\u2019, IEEE Computer Society\nPress, pp. 722\u2013731. Petre, M. & van der Hoek, A. (2016), Software Design Decoded: 66 Ways\nExperts Think, The MIT Press. P\ufb02eeger, S. L. & Atlee, J. M. (2010), Software Engineering: Theory and Prac-\ntice, 4th edn, Pearson. Pohthong, A. & Budgen, D. (2000), Accessing software component documen-\ntation during design: An observational study, in \u2018Proceedings of Seventh\nAsia-Paci\ufb01c Software Engineering Conference\u2019, IEEE Computer Society\nPress, pp. 196\u2013203. Pohthong, A. & Budgen, D. (2001), \u2018Reuse strategies in software development:\nAn empirical study\u2019, Information & Software Technology 43(9), 561\u2013575. Pugh, S. (1991), Total Design: Integrated Methods for Successful Product En-\ngineering, Addison-Wesley. Purchase, H. C., Welland, R., McGill, M. & Colpoys, L. (2004), \u2018Compre-\nhension of diagram syntax: An empirical study of entity relationship no-\ntations\u2019, International Journal of Human-Computer Studies 61(2), 187\u2013\n203. Qumer, A. & Henderson-Sellers, B. (2008), \u2018An evaluation of the degree of\nagility in six agile methods and its applicability for method engineering\u2019,\nInformation & Software Technology 50, 280\u2013295. Radjenovi\u0107, D., Heri\u010dko, M., Torkar, R. & \u017divkovi\u010d, A. (2013), \u2018Software fault\nprediction metrics: A systematic literature review\u2019, Information & Soft-\nware Technology 55, 1397\u20131418. Ratcli\ufb00e, M. & Budgen, D. (2001), \u2018The application of use case de\ufb01ni-\ntions in system design speci\ufb01cation\u2019, Information & Software Technology\n43(6), 365\u2013386.", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 351", "position": 351, "chunk_type": "semantic", "token_estimate": 314}
{"text": "336: Bibliography\nSheetz, S. D. & Tegarden, D. P. (1996), \u2018Perceptual complexity of object\noriented systems: A student view\u2019, Object Oriented Systems 3(4), 165\u2013\n195. Simon, H. A. (1973), \u2018The structure of ill-structured problems\u2019, Arti\ufb01cial In-\ntelligence 4, 181\u2013201. Sj\u00f8berg, D., Hannay, J., Hansen, O., Kampenes, V., Karahasanovic, A.,\nLiborg, N. & Rekdal, A. (2005), \u2018A survey of controlled experiments\nin software engineering\u2019, IEEE Transactions on Software Engineering\n31(9), 733\u2013753. Smith, G. (2000), The Object-Z Speci\ufb01cation Language, Springer. Snyder, A. (1993), \u2018The essence of objects: Concepts and terms\u2019, IEEE Soft-\nware 10(1), 31\u201342. Spivey, J. M. (1998), The Z notation: A reference manual, Technical report,\nProgramming Research Group, University of Oxford. Stapleton, J., ed. (1999), Dynamic Systems Development Method (Version 3),\nTesseract Publishing. Stapleton, J., ed. (2002), DSDM: Business Focused Development, Addison-\nWesley. Steinmacher, I., Silva, M. A. G., Gerosa, M. A. & Redmiles, D. F. (2015), \u2018A\nsystematic literature review on the barriers faced by newcomers to open\nsource software projects\u2019, Information & Software Technology 59(67-85). Stevens, W. P. (1991), Software Design: Concepts and Methods, Prentice-Hall. Stevens, W. P., Myers, G. J. & Constantine, L. L. (1974), \u2018Structured design\u2019,\nIBM Systems Journal 13(115-139). Szyperski, C. (1998), Component Software: Beyond Object-Oriented Program-\nming, Addison-Wesley. Taivalsaari, A. (1993), \u2018On the notion of object\u2019, Journal of Systems & Soft-\nware 21(1), 3\u201316. Tempero, E., Gorschek, T. & Angelis, L. (2017), \u2018Barriers to refactoring\u2019,\nCommunications of the ACM 60(10), 54\u201361. Tiwari, S. & Gupta, A. (2015), \u2018A systematic literature review of use case\nspeci\ufb01cations research\u2019, Information & Software Technology 67, 128\u2013158. Tomayko, J. (1996), Carnegie Mellon\u2019s Software Development Studio: A \ufb01ve\nyear retrospective, in \u2018Proceedings of 9th Conference on Software Engi-\nneering Education\u2019, IEEE Computer Society Press, pp. 119\u2013129.", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 353", "position": 353, "chunk_type": "semantic", "token_estimate": 286}
{"text": "Bibliography: 337\nTruex, D., Baskerville, R. & Klein, H. (1999), \u2018Growing systems in emergent\norganisations\u2019, Communications of the ACM 42(8), 117\u2013123. Turner, M., Brereton, P. & Budgen, D. (2006), \u2018Service-enabled access control\nfor distributed data\u2019, IEE Proceedings \u2013 Software 153, 24\u201330. Special\nSection on RBAC. Turner, M., Budgen, D. & Brereton, P. (2003), \u2018Turning software into a ser-\nvice\u2019, IEEE Computer 36(10), 38\u201344. Vale, T., Crnkovic, I., de Almeida, E. S., da Mota Silviera Neto, P. A., Cav-\nalcanti, Y. a. C. & de Lemos Meira, S. R. (2016), \u2018Twenty-eight years of\ncomponent-based software engineering\u2019, Journal of Systems & Software\n111, 128\u2013148. van Aken, J. E. (2004), \u2018Management research based on the paradigm of the\ndesign sciences: The quest for \ufb01eld-tested and grounded technological\nrules\u2019, Journal of Management Studies 41(2), 219\u2013246. van der Hoek, A. & Petre, M. (2014), Software Designers in Action: A Human-\nCentric Look at Design Work, CRC Press. van Vliet, H. & Tang, A. (2016), \u2018Decision making in software architecture\u2019,\nJournal of Systems & Software 17(638-644). Vessey, I. & Conger, S. (1994), \u2018Requirements speci\ufb01cation: Learning object,\nprocess and data methodologies\u2019, Communications of the ACM 37, 102\u2013\n113. Visser, W. & Hoc, J.-M. (1990), Expert software design strategies, in J.-M.\nHoc, T. Green, R. Samur\u00e7ay & D. Gilmore, eds, \u2018Psychology of Program-\nming\u2019, Academic Press, pp. 235\u2013249. Ward, P. T. & Mellor, S. J. (1985), Structured Development for Real-Time\nSystems, Yourdon Press. Weaver, P. L., Lambrou, N. & Walkley, M. (2002), Practical Business Sys-\ntems Development Using SSADM: A Complete Tutorial Guide, 3rd edn,\nPearson Education. Weinberg, G. M. (1971), The Psychology of Computer Programming, Van Nos-\ntrand Reinhold. Weinberg, G. M. & Freedman, D. P. (1987), \u2018Reviews, walkthroughs and in-\nspections\u2019, IEEE Transactions on Software Engineering 10(1), 68\u201372. Wendor\ufb00, P. (2001), Assessment of design patterns during software reengineer-\ning: Lessons learned from a large commercial project, in \u2018Proceedings of\n5th European Conference on Software Maintenance and Reengineering\n(CSMR\u201901)\u2019, IEEE Computer Society Press, pp. 77\u201384.", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 354", "position": 354, "chunk_type": "semantic", "token_estimate": 328}
{"text": "338: Bibliography\nWhittle, J., Hutchinson, J. & Rounce\ufb01eld, M. (2014), \u2018The state of practice\nin model-driven engineering\u2019, IEEE Software 31(3), 7985. Wieringa, R. (1998), \u2018A survey of structured and object-oriented software spec-\ni\ufb01cation methods and techniques\u2019, ACM Computing Surveys 30(4), 459\u2013\n527. Williams, B. J. & Carver, J. C. (2010), \u2018Characterizing software architec-\nture changes: A systematic review\u2019, Information & Software Technology\n52(1), 31\u201351. Wirth, N. (1971), \u2018Program development by stepwise re\ufb01nement\u2019, Communi-\ncations of the ACM 14(4), 221\u2013227. Wood, M., Daly, J., Miller, J. & Roper, M. (1999), \u2018Multi-method research: An\nempirical investigation of object-oriented technology\u2019, Journal of Systems\n& Software 48, 13\u201326. Woodcock, J., Larsen, P. G., Bicarregui, J. & Fitzgerald, J. (2009), \u2018Formal\nmethods: Practice and experience\u2019, ACM Computing Surveys 41(4), 1\u2013\n36. Wu, M.-W. & Lin, Y.-D. (2001), \u2018Open source software development: An\noverview\u2019, IEEE Computer 34(6), 33\u201338. Yakimovich, D., Bieman, J. M. & Basili, V. R. (1999), Software architecture\nclassi\ufb01cation for estimating the cost of COTS integration, in \u2018Proceed-\nings of 21st International Conference on Software Engineering (ICSE\u201999)\u2019,\nIEEE Computer Society Press, pp. 296\u2013302. Yin, R. K. (2014), Case Study Research: Design & Methods, 5th edn, Sage\nPublications Ltd.\nYourdon, E. & Constantine, L. L. (1979), Structured Design, Prentice-Hall. Zhang, C. & Budgen, D. (2012), \u2018What do we know about the e\ufb00ectiveness of\nsoftware design patterns?\u2019, IEEE Transactions on Software Engineering\n38(5), 1213\u20131231. Zhang, C. & Budgen, D. (2013), \u2018A survey of experienced user perceptions\nabout design patterns\u2019, Information & Software Technology 55(5), 822\u2013\n835. Zhang, C., Budgen, D. & Drummond, S. (2012), Using a follow-on survey\nto investigate why use of the Visitor, Singleton and Facade design pat-\nterns is controversial?, in \u2018Proceedings 6th International Symposium on\nEmpirical Software Engineering and Measurement (ESEM)\u2019, ACM Press,\npp. 79\u201388.", "domains": ["Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 355", "position": 355, "chunk_type": "semantic", "token_estimate": 293}
{"text": "Index: .NET, 185, 270, 294\n4+1, 99\nAbrial, J-R, 318\nabstraction, 32, 33, 40, 94\u201396, 143,\n225\nactivity, 167\nactivity diagram, 105, 167, 183\nAdelson, B., 33, 44, 62, 88, 99, 198,\n209, 263\nADL, see architecture description\nlanguage\nagile development, 11, 71, 198, 199,\n226, 237, 244, 249, 253, 255,\n256, 258, 259, 312, 318\nagile manifesto, 237, 249\nAkin, O., 46\nAlexander, C., 87, 262\nAli, M.S., 71\nAllman, E., 10\nAnjum, M., 189, 299, 300\nApache Spark, 185\narchitectural\ndecision, 232\ndesign, 211, 294\nevolution, 92\nmismatch, 183, 297\npattern, 144, 265\npattern\nlayers, 294\nservice broker, 284\nvisualisation, 92\narchitectural pattern, 77, 87, 88, 92,\n253, 263, 266, 287, 288, 290\narchitectural pattern\nbroker, 88, 270, 271\nlayers, 88, 90, 91, 268, 269\nmodel-view-controller, 88, 89,\n266, 267\npipes-and-\ufb01lters, 88\nre\ufb02ection, 88\narchitectural style, 34, 77, 79\u201385, 88,\n92, 100, 106, 112, 119, 153,\n164, 180\u2013182, 197, 202, 203,\n206, 218, 220, 242, 248, 252,\n260, 261, 266, 287, 290\narchitectural style\ncall-and-return, 81, 83, 84, 120,\n122, 134, 206, 207, 219, 236\nclient-server, 84, 85\ncommunicating-processes, 120\ndata-centred repository, 81, 84,\n85\ndata-\ufb02ow, 81\ndata-sharing, 81\ninteracting processes, 81\npipe-and-\ufb01lter, 82, 83, 120\narchitecture, 77\u201385, 87\u201392, 144, 212,\n228\narchitecture\nas vocabulary, 78, 92\narchitecture description language, 80\nArlow, J., 159, 226, 229\nAvison, D.E., 212\nBailey, J., 173, 235\nBano, M., 200\nBarrow, P.D.M., 258\nBass, L., 81, 265, 266, 283\nBates, B., 272, 286\nBeck, K., 230, 250, 284\nBennett, K.H., 10, 270\nbinding\ndynamic, 149, 154, 270, 271, 293\n339", "domains": ["Architectural Patterns and Styles", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 356", "position": 356, "chunk_type": "semantic", "token_estimate": 258}
{"text": "340: Index\nstatic, 148, 149, 271\ntime, 148, 297\nblack box, 97, 101, 162, 181, 182,\n222, 229, 249, 317\nBlackwell, A., 106\nBoehm, B.W., 130, 242, 249\nBooch, G., 141, 142, 226\nBosu, A., 314\nbox and line, 95, 103\nbox plot, 62\nBreivold, H.P., 92\nBrereton, P., 181\nBrooks, F.P. Jr., 50, 56, 140, 196,\n199, 201\nBrown, A.W., 180, 181\nBrown, W.J., 284\nBrunel, I.K., 39, 54\nBrunel, M., 178\nBudgen, D., 67, 69, 70, 72, 173, 201\nBuschmann, F., 87, 88, 263, 265,\n273, 275, 276, 286, 288\nbusiness modelling, 299, 300, 303\ncamelCase, 158\ncapability maturity model, 253\nCarney, D., 186\ncase study, 67, 69, 233\ncase study\ndescriptive, 68\nexplanatory, 68\nexploratory, 68\nproposition, 68, 69\ncausal relationships, 101\nCBSE, see component-based\nsoftware engineering\nChen, J., 259\nChen, P., 131\nChidamber, S.R., 150, 174, 310\nchief programmer, 199\nclass, see also object, 139, 140, 145,\n146, 157, 158, 172, 222, 225,\n273\nclass\ndescription, 223\nhierarchy, 145\ninheritance, 147, 148, 287\nmethod, 146\nmodel, 228\nsubclass, 146, 147\nsuperclass, 147, 148\nuses, 151\nvariable, 146\nclass diagram, 105, 166, 230\nclass-responsibility-collaborator, 230,\n252\ncloud, 177, 188, 298, 301\nCMM, see capability maturity model\ncode smell, 257, 286\ncognitive\ncapacity, 31, 32\nload, 32, 96, 111, 125, 148, 156,\n209\nmapping, 153\ncognitive dimensions, 106, 108, 134,\n308\ncohesion, 52, 307\nColeman, D., 220\ncollaboration diagram, 230\ncommon object request broker\narchitecture, 179, 184, 191,\n294\ncommunication, 20, 21, 37, 38, 40, 45\ncomponent, 177, 178, 180, 183, 185,\n191, 293, 294, 297, 302\ncomponent\narchitecture, 294, 298\ncatalogue, 178, 179, 294\ncharacteristics, 181, 182\ncomposition, 177, 178, 180, 181,\n183, 187, 293, 294, 296, 298\ncomposition\nelement \ufb01rst, 295\nframework \ufb01rst, 295\ncomposition standard, 181\ncontrol \ufb02ow, 297\nCOTS, 186\ndependency, 185, 191\nevolution, 186\nframework, 183\u2013186, 191", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 357", "position": 357, "chunk_type": "semantic", "token_estimate": 304}
{"text": "Index: 341\nfunctionality, 178, 179, 182, 185,\n191\nindependence, 180, 182\ninformation \ufb02ow, 297\nintegration, 180, 184\ninteraction, 183, 184, 186\ninteraction protocols, 184\ninterface, 178, 179, 182, 185, 191\nmodel, 179, 181\npackaging, 297\nrecon\ufb01guration, 184\nsynchronisation, 297\ntrust, 184\ncomponent-based software\nengineering, 177, 180, 183,\n184, 187, 190, 294, 297, 298,\n302\ncompositional strategy, 207, 294\nconfounding factor, 63\nConnor, D., 211\ncontext diagram, 122\u2013124, 212\ncontrol group, 61\nCooke, P., 179\nCoplien, J.O., 263\nCORBA, see common object request\nbroker architecture\ncost model, 94\ncoupling, 51, 78, 82, 100, 134, 151,\n205, 207, 236, 263, 307\ncoupling\ndata \ufb02ow, 100\ndata sharing, 100\ninheritance, 100\u2013102, 256\ninvocation, 100, 101\nloose, 272, 276, 279, 290\nuses, 100, 101, 144, 223\nCRC, see class-responsibility-\ncollaborator\ncreativity, 20\nCrnkovic, I., 181, 185\nCunningham, W., 10\nCurtis, B., 45, 66, 199, 200\nCusumano, M.A., 239\nD\u00e9tienne, F., 56, 155, 207, 208, 263\nda Vinci, L., 54\ndata dictionary, 212, 220, 223\ndata-\ufb02ow diagram, 105, 121\u2013125,\n127, 128, 136, 137, 189, 212,\n216, 302\nDe Marco, T., 122, 136\ndependent variable, 61, 62\ndesign\nagile, 100\nanti-pattern, 284, 290\napprentice, 262\nas a noun, 261\nas a verb, 261\nas adaptation, 15\u201317, 47, 87\nas noun, 12, 17\nas planning, 14\u201317, 27, 45\nas social process, 251, 306, 311,\n316, 321\nas styling, 14\u201317\nas verb, 13, 17, 195\nattribute, 99, 101, 102, 131\naudit, 36\nbottom-up, 198\nby composition, 302\nchoice, 294\ncode smell, 284, 285, 290, 313\nconstraint, 259\ndecision, 206, 242, 294, 295\ndocumentation, 36, 218, 313\nevolution, 256, 260, 307\nheuristic, 55, 208, 214, 218\nincremental, 237, 239, 240, 242,\n243, 250, 259\ninvariant, 221\nknowledge, 155, 195, 315\nlogical, 214, 218\nmethod, 205, 209, 233\nmetrics, 309\nmodel, 26, 28, 29, 32\u201336, 38, 40,\n48\u201350, 93\u201397, 101, 102, 106,\n107, 109\u2013111, 113, 114, 125,\n137, 145, 153, 157, 170, 197,\n198, 201, 204, 207, 213, 263,\n264, 284, 285, 294, 299, 302,\n305, 306, 311, 313, 317", "domains": ["Design Patterns", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 358", "position": 358, "chunk_type": "semantic", "token_estimate": 330}
{"text": "342: Index\nnote-making, 117\npattern, 178, 198, 261\u2013263, 271,\n274, 283, 286\u2013288, 290, 300\npattern\nabstract factory, 281, 282,\n289, 291\nbehavioural, 262, 273\ncomposite, 289, 291\ncreational, 273, 290\ngrime, 272\nmemento, 289\nobserver, 278, 279, 289, 291\nprotection proxy, 275\u2013277\nproxy, 275, 276\nremote proxy, 275\nrot, 272\nservice-oriented, 283\nsingleton, 289\nsoftware service, 283, 284\nstructural, 273, 290\nvirtual proxy, 276\nvisitor, 289\nvocabulary, 263, 266\nphysical, 214, 218, 228, 234\nplan, 12, 13\nplan-based, 209\nplan-driven, 12, 100, 122, 197,\n198, 203\u2013209, 211\u2013214, 219,\n222, 224\u2013237, 239, 241, 244,\n271\nprinciple, 306, 307\nprocess, 134, 208, 258\nquality, 305, 306, 314\nrationale, 35, 36, 40\nrecords, 117\nrefactoring, 313, 314\nrepresentation, 102, 196, 208,\n209, 212\nreview, 240, 311, 314\nschema, 56, 58\nsciences, 200\nsimulation, 44, 57\nsketches, 48, 57, 103, 105,\n109\u2013116, 122, 125, 133, 156,\n164, 253\nteam, 199, 200, 202\nthinking, 13, 15\u201317, 27\ntop-down, 198, 206, 211, 212\ntrade-o\ufb00, 242\nvalidation, 130\nveri\ufb01cation, 229\nviewpoints, 108\nwalk-through, 35, 229\nincremental, 294\nveri\ufb01cation, 130\nDFD, see data-\ufb02ow diagram\ndiagram\nhierarchy, 104, 125, 128, 129,\n135, 137, 162, 163, 165\nsemantics, 104\nsyntax, 104\ndiagrammatical notations, 95\nDiebold, P., 258\ndi\ufb00useness, 107\ndomain knowledge, 39, 41, 204\nDSDM, 226, 241, 243\u2013247, 249, 254,\n257, 258, 260", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 359", "position": 359, "chunk_type": "semantic", "token_estimate": 213}
{"text": "phase, 247: principles, 244, 245\nstakeholders, 245\nDyb\u00e5, T., 258\ndynamic systems development\nmethod, see DSDM\nEBSE, see evidence-based software\nengineering\nEdwards, H.M., 233\nElbanna, A., 242, 259\nemergent organisation, 239, 243\nempirical knowledge, 59, 63, 70\u201373,\n136, 172, 190, 200, 233\u2013235,\n257, 258, 288, 291, 302, 313,\n315\nempirical study, 59, 63\u201365, 72, 236,\n316, 320, 322\nencapsulation, see information hiding\nenterprise java beans, 270\nentity-life-history diagram, 216, 234\nentity-life-history matrix, 219", "domains": ["Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 359", "position": 359, "chunk_type": "semantic", "token_estimate": 73}
{"text": "Index: 343\nentity-relationship diagram, 105,\n130\u2013133, 159, 216\nERD, see entity-relationship diagram\nEricsson, K.A., 66\nErl, T., 87, 284, 300\nevent, 126, 161, 163, 221\nevent partitioning, 211\nevidence-based software engineering,\n69\nevolution, 78, 79, 88, 204, 209, 268,\n272, 277, 285, 296, 298\nexperience paper, 173\nexperience report, 64\nexperiment, 60, 62, 66\u201368\nexperimental group, 61\nexperimental treatment, 61\nexpert designers, 43\u201345, 47, 55\nextreme programming, see XP\nfactoring, 214\nFagan, M., 311\nFayad, M.E., 263\nFDT, see formal description\ntechnique\nfeasibility study, 217, 239, 247\nfeature interaction, 21\nFeitosa, H., 272\nFenton, N.E., 309, 314\nFichman, R.G., 155\n\ufb01eld study, 64, 69, 173\n\ufb01nite-state machine, 101, 126, 161\nFinkelstein, A., 97\n\ufb01tness for purpose, 35, 40, 49, 252,\n306\nFloyd, C., 238\nformal description technique, 105,\n317, 318, 320\nformal description technique\nmodel-based, 318\nZ, 318\u2013320\nZ\npostcondition, 319, 320\nprecondition, 319, 320\npredicate, 319, 320\nschema, 319\nsignature, 319\nFowler, M., 256, 284, 285, 313\nFusion, 219\u2013226, 231, 232, 235\nGamma, E., 87, 272, 273, 286, 287\nGane, C., 211\nGarlan, D., 78, 183\nGNU, 315\ngod class, 285\nGoF, 272, 274\u2013276, 286, 288, 289\ngraceful degradation, 307\nGreen, T.R.G., 106, 308\nGuindon, R., 209\nHadhrawi, M., 106\nHall, A., 318\nHannay, J., 71\nHarel, D., 161, 162, 164\nHatley, D.J, 211\nHayes-Roth, B., 45\nHCI, 14, 106, 239, 308\nHeineman, G.T., 181\nHelm, R., 272\nhidden dependencies, 106, 134\nHOOD, 157\nHughes, R., 310\nhuman-computer interaction, see", "domains": ["Design Patterns", "Domain-Driven Design"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 360", "position": 360, "chunk_type": "semantic", "token_estimate": 241}
{"text": "hypothesis, 66: hypothesis\nalternate, 66\nIBM, 211\nidiom, 263\nilities, 49, 307, 308, 314\nIll-Structured Problem, 8, 9, 17,\n21\u201325, 29, 35, 46, 49, 54, 62,\n93, 109, 112, 119, 124, 140,\n195\u2013197, 201, 210, 236, 239,\n241, 253, 259, 264, 271, 288,\n290, 298, 305, 317, 320, 322\nincremental development, 238, 241,\n243, 247, 249, 253, 315, 316\ninformation hiding, 52, 84, 89, 121,\n142, 144, 206, 307, 312\ninheritance, see coupling", "domains": ["Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 360", "position": 360, "chunk_type": "semantic", "token_estimate": 73}
{"text": "Index: 345\nmodel driven engineering, 321, 322\nmodularity, 144, 206, 207, 225\nMohagheghi, P., 71, 321\nMoody, D.L., 32, 122, 136, 156, 173,\n322\nMoSCoW rules, 246, 247\nMSG, see sequence diagram\nMVC, see architectural pattern\n(model-view-controller)\nMyers, G.J., 207\nn-ary property, 132\nnon-functional properties, 34\nnon-functional requirements, 49\nnormal distribution, 60, 62\nNorman, D., 20, 308\nnoun-verb analysis, 220, 230\nobject, 139\u2013141, 143\u2013145, 153, 157,\n169, 172, 180, 225, 273\nobject\nanonymous, 158\nattribute, 157, 223\nbehaviour, 143, 161, 224, 271\ncharacteristics, 140, 174, 225\nclass relationship, 158, 174\nconstruction, 157\ncoupling, 139, 140\ncreation, 145, 146, 158, 222\ndesign, 235\ndesign method, 219\nencapsulation, 142, 144, 161, 225\nhierarchy, 143, 144, 155, 225\nidentity, 143, 145, 148, 271\ninheritance, 146, 155, 225, 256,\n271\ninteraction, 159, 165\nmethod, 142, 149, 151, 152, 157,\n159\nmodel, 139, 142\u2013144, 153\u2013157,\n172, 174, 183, 219, 220, 225,\n234\nnotation, 156, 175\nparadigm, 139, 140\npolymorphism, 148, 149, 155,\n161, 256\nrelationship, 139, 150, 174\nstate, 157, 161, 271\nuses, 157\nobject inheritance graph, 223, 225\nobject interaction graph, 222\u2013224\nobject interaction graph\ncontroller object, 222\nobject management group, 142, 184\nobject visibility graph, 223, 225\nObjectory, 226\nobservational study, 62, 68, 116\nO\ufb00ermann, P., 300\nOlbrich, S.M., 285, 290\nOMG, see object management group\nopen source software, 37, 142, 185,\n243, 285, 315, 316\nopportunistic strategy, 45, 54, 57,\n195, 200, 201, 205, 209, 241,\n264, 295, 296\nordinal measurement scale, 66\northogonality, 163\nOSI model, 268\nOSS, see open source software\nOwen, S., 66\nOzkaya, M., 81\np-spec, 212\nPage-Jones, M., 122, 131, 211, 212\nPahl, G., 179\nPalomba, F., 290\nParnas, D.L., 36, 52, 121, 206, 209,\n311, 312\npattern book, 54\nPerry, D.E., 80\nperspective, 96, 97\nPeters, L.J., 22\nPetre, M., 43, 47, 109, 110, 116, 173\nP\ufb02eeger, S.L., 252\nplug-and-play, 293\nPohthong, A., 295\npositivist philosophy, 60, 67, 68\nPreece, J., 239\npremature commitment, 106\nprimary study, 69, 70\nproduct line, 178, 186", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Software Quality Attributes", "Domain-Driven Design", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 362", "position": 362, "chunk_type": "semantic", "token_estimate": 327}
{"text": "346: Index\nprotocol analysis, 66\nprototype, 238, 239, 242, 248, 249,\n294\nprototype\nevolutionary, 238, 240, 294\nexperimental, 239\nexploratory, 228, 239, 247, 252,\n294, 295\nfunctional, 248\npublish-subscribe, 278\nPugh, S., 179\nPurchase, H.C., 136\nqualitative study, 64\u201366, 70, 72, 201\nquantitative study, 64, 66, 70, 72\nquasi-experiment, 62, 66, 67\nQumer, A., 258\nRAD, see rapid application\ndevelopment\nRadjenovi\u0107, D., 150, 174\nRandomised Controlled Trial, 61, 62,\n66, 70\nrapid application development, 226,\n243, 249\nRatcli\ufb00e, M., 125, 166, 229\nratio measurement scale, 67\nRational Uni\ufb01ed Process, 226\nRCT, see Randomised Controlled\nTrial\nreactive development, 315\nrefactoring, 251, 253, 255\u2013257, 259,\n260, 271, 285, 286\nRentsch, T., 140\nrepresentation, 96, 97\nrequirements\nelicitation, 228, 239\nevolution, 256\nmodel, 94, 197\nspeci\ufb01cation, 34, 38, 102, 121,\n197, 222, 237, 238, 317\nresearch\ndescription-driven, 71, 72\ndesign sciences, 71, 72\nresearch protocol, 65, 69, 72\nreuse, 21, 44, 45, 53, 54, 57, 78, 83,\n84, 177\u2013183, 191, 235, 261,\n284, 293, 295\nrisk, 94, 301\nrisk assessment, 242\nRittel, H.J., 22\nRobinson, P.J., 157\nRumbaugh, J., 142, 156, 164, 170,\n226\nRuneson, P., 67\nRUP, see Rational Uni\ufb01ed Process\nRuparelia, N., 257\nsafety-critical, 308, 317, 318\nsatis\ufb01cing, 54, 58, 305, 306\nscale, 94, 238\nscenario, 164, 169, 170, 222, 224, 311\nSchwaber, K., 253\nscrum, 253, 255, 257, 258, 260, 311\nscrum\nproduct backlog, 254\nrelease, 254\nsprint, 254\nsecondary study, 69\nSellar, W.C, 22\nseparation of concerns, 50, 51, 78, 82,\n83, 88, 89, 92, 144, 267,\n268, 277, 306, 308, 312\nsequence diagram, 105, 161, 164\u2013166,\n171, 183, 222, 224, 230\nservice\nparadigm, 177\nservice composition, 293\nservice-level agreement, 283, 299, 300\nservice-oriented architecture, 188,\n270, 299\nShadish, W.R., 62\nShahin, M., 92\nShapiro, S., 44, 54, 105, 206\nSharp, H., 308\nShaw, M., 78, 80\u201382\nSheetz, S.D, 155\nshells of knowledge, 56\nsilver bullet, 140\nSimon, H., 7, 54", "domains": ["Architectural Patterns and Styles", "Design Patterns", "Design Principles", "Code Organization"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 363", "position": 363, "chunk_type": "semantic", "token_estimate": 312}
{"text": "Index: 347\nsimple object access protocol, 188\nsingle inheritance, 139, 148\nSj\u00f8berg, D.A.G., 67\nsketching, see design sketches\nSmith, G., 318\nSOA, see service-oriented\narchitecture\nSOAP, see simple object access\nprotocol, 299\nsoftware\nattribute, 95\ncomplexity, 196\nevolution, 10, 196\ninvisibility, 94, 196\nmaintenance, 10\nprocess, 119\u2013121, 126, 130, 137,\n141\nproperty, 95, 201\nsoftware as a service, 188, 298, 299\nsoftware service, 181, 187, 188, 191,\n192, 293, 298, 301, 302\nsoftware service\narchitecture, 299\nbinding time, 299, 300\nconsumer, 189, 299\ndelivery, 300\ndescription, 189\ndeveloper, 299\norchestration, 299, 300\nprovider, 189, 299, 301, 302\nstateless, 299\nsoftware service models, 188\nsoftware service pattern, 289\nsourceforge, 316\nspiral model, 241\u2013243\nSpivey, J.M., 105, 318\nSSADM, 103, 122, 214\u2013218, 233, 234,\n236, 258\nStallman, R.M., 315\nStapleton, J., 244, 246\nstate, 126\u2013128, 141, 143, 162, 167\nstate\nmodel, 128, 162\ntransition, 126, 128, 129, 162,\n163, 167, 168\nstate transition diagram, 105,\n127\u2013129, 161, 163, 218\nstate transition table, 129, 218\nstatechart, 105, 161, 162, 164, 183,\n232\nSTD, see state transition diagram\nSteinmacher, I., 37, 316\nstepwise re\ufb01nement, 206, 207\nstereotype, 160, 171\nStevens, W.P., 51, 131, 134, 207\nstopping rule, 22, 305, 322\nstory-board, 239, 247\nstructure chart, 105, 134\u2013136, 212,\n213\nstructured design, 211, 212\nstructured systems analysis, 211, 212\nSTT, see state transition table\nsuperclass, 223\nsurvey, 66, 67, 233, 234, 259, 289\nsynchronisation bar, 167, 168\nSynder, A., 142\nsystematic review, 69\u201373, 91\nSzyperski, C., 181, 186, 191\nTaivalsaari, A., 141\ntechnical debt, 10, 11, 17, 36, 40, 79,\n88, 107, 121, 148, 184\u2013186,\n196, 209, 252, 255, 259, 262,\n272, 297, 311\nTempero, E., 257, 259\nthink-aloud, 66\ntimebox, 246, 247, 249, 254, 255,\n258\u2013260\ntimeline, 165\nTiwari, S., 173\nTomayko, J.E., 53\ntop-down strategy, 287\ntransaction analysis, 213, 214\ntransform analysis, 213, 214\ntransition\naction, 128, 129\ncondition, 128\ntriangulation, 68\nTruex, D., 239\ntrust, 298", "domains": ["Architectural Patterns and Styles", "Design Patterns"], "source": "Software Design \u2013 Creating Solutions for Ill-Structured Problems.pdf", "section": "Page 364", "position": 364, "chunk_type": "semantic", "token_estimate": 314}
